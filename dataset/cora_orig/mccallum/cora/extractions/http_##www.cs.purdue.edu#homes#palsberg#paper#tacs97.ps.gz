URL: http://www.cs.purdue.edu/homes/palsberg/paper/tacs97.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Phone: 2  3  
Title: Optimal Representations of Polymorphic Types with Subtyping (Extended Abstract)  
Author: Alexander Aiken ? and Edward L. Wimmers and Jens Palsberg 
Address: Berkeley, Berkeley, CA 94720-1776.  650 Harry Rd., San Jose, CA 95120-6099.  West Lafayette, IN 47907.  
Affiliation: 1 EECS Department, University of California at  IBM Almaden Research Center,  Department of Computer Science, Purdue University,  
Abstract: Many type inference and program analysis systems include notions of subtyping and parametric polymorphism. When used together, these two features induce equivalences that allow types to be simplified by eliminating quantified variables. Eliminating variables both improves the readability of types and the performance of algorithms whose complexity depends on the number of type variables. We present an algorithm for simplifying quantified types in the presence of subtyping and prove it is sound and complete for non-recursive and recursive types.
Abstract-found: 1
Intro-found: 1
Reference: [AC93] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> Also in Proc. POPL'91. </note>
Reference-contexts: Notice that i+1 i . Then x y holds iff x i y holds for all i 0 <ref> [AC93] </ref>. First we check that has standard function types. x 0 ! x 00 y 0 ! y 00 , 8i (x 00 i y 00 and y 0 i x 0 ) , x 00 y 00 and y 0 x 0 Thus has standard function types.
Reference: [AW93] <author> A. Aiken and E. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Parametric polymorphism allows a parameterized type inferred for a program fragment to take on a different instance in every usage context. A number of type systems combine subtyping and polymorphism, among other features. The intended purposes of these systems varies. A few examples are: studies of type systems themselves <ref> [CW85, Cur90, AW93] </ref>, type systems for object-oriented languages [EST95], and program analyses aimed at program optimization [AWL94, HM94]. In short, the combination of subtyping and poly-morphism is useful, with many applications. <p> These algorithms have been implemented and in use since 1993, but with the exception of code documentation little has been written previously on the subject. The algorithm has been implemented and used in Illyria 4 , the systems reported in <ref> [AW93] </ref>, a large scale program analysis system for the functional language FL [AWL94], and a general-purpose constraint-based program analysis system [FA96]. Other recent systems based on constrained types have also pointed out the importance of variable elimination. <p> Example 4. Consider the minimal semantic domain (Example 1). It is clear that 8ff:(ff ! ff) (&gt; ! &gt;) in the minimal semantic domain. Therefore, 8ff:(ff ! ff) is reduced but not irredundant. Example 5. In the semantic domain used in <ref> [AW93] </ref>, x ! &gt; = y ! &gt; regardless of the values of x and y, because if the answer can be anything (i.e., &gt;), it does not matter what the domain is. In this case, 8ff:((ff ! ff) ! &gt;) &gt; ! &gt;.
Reference: [AWL94] <author> A. Aiken, E. Wimmers, </author> <title> and T.K. Lakshman. Soft typing with conditional types. </title> <booktitle> In Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: A number of type systems combine subtyping and polymorphism, among other features. The intended purposes of these systems varies. A few examples are: studies of type systems themselves [CW85, Cur90, AW93], type systems for object-oriented languages [EST95], and program analyses aimed at program optimization <ref> [AWL94, HM94] </ref>. In short, the combination of subtyping and poly-morphism is useful, with many applications. When taken together, subtyping and polymorphism induce equivalences on types that can be exploited to simplify the representation of types. <p> Second, eliminating variables makes types more readable. Third, simplification makes properties of types manifest that are otherwise implicit; in at least one case that we know of, these "hidden" properties are exactly the information needed to justify compiler optimizations based on type information <ref> [AWL94] </ref>. The basic idea behind variable elimination is best illustrated by example. A few definitions are needed first. Consider the following simple type language: t ::= ff j &gt; j ? j t 1 ! t 2 In this grammar, ff is a type variable. <p> Note that this example is the simplest one possible; the problem of understanding types only increases with the size of the type and expressiveness of the type language. Simplifying types can improve not only the speed but the quality of program analyses. For example, the soft typing system of <ref> [AWL94] </ref> reduces the problem of identifying where runtime type checks are unneeded in a program to testing whether certain type variables can be replaced by ? in a quantified type. This is exactly the task performed by elimination of variables in quantified types. <p> The algorithm has been implemented and used in Illyria 4 , the systems reported in [AW93], a large scale program analysis system for the functional language FL <ref> [AWL94] </ref>, and a general-purpose constraint-based program analysis system [FA96]. Other recent systems based on constrained types have also pointed out the importance of variable elimination. In [EST95], Eifrig, Smith, and Trifonov and separately Pottier [Pot96] describe methods for eliminating unnecessary variables from constraint sets.
Reference: [AWP96] <author> A. Aiken, E. Wimmers, and J. Palsberg. </author> <title> Optimal representations of polymorphic types with subtyping. </title> <type> Technical Report UCB//CSD-96-909, </type> <institution> University of California, Berkeley, </institution> <year> 1996. </year>
Reference-contexts: For lack of space, this extended abstract omits additional extensions to sound but incomplete algorithms to systems with union and intersection types and constrained types. The interested reader is referred to the full version of the paper <ref> [AWP96] </ref>. 2 Semantic Domains Rather than work with a particular semantic domain, we axiomatize the properties needed to prove the corresponding theorems about eliminating quantified variables. Definition 1. A semantic domain D = (D 0 ; D 1 ; ; u) satisfies the following properties: 1.
Reference: [Cou79] <author> Bruno Courcelle. </author> <title> Infinite trees in normal form and recursive equations having a unique solution. </title> <journal> Mathematical Systems Theory, </journal> <volume> 13 </volume> <pages> 131-180, </pages> <year> 1979. </year>
Reference-contexts: Furthermore, x 0 and x 00 are unique. It is well-known that such a domain has contractive solutions <ref> [Cou79] </ref>. Let x 0 y hold for all x; y 2 D 0 .
Reference: [Cur90] <author> Pavel Curtis. </author> <title> Constrained quantification in polymorphic type analysis. </title> <type> Technical Report CSL-90-1, </type> <note> Xerox Parc, </note> <month> February </month> <year> 1990. </year>
Reference-contexts: Parametric polymorphism allows a parameterized type inferred for a program fragment to take on a different instance in every usage context. A number of type systems combine subtyping and polymorphism, among other features. The intended purposes of these systems varies. A few examples are: studies of type systems themselves <ref> [CW85, Cur90, AW93] </ref>, type systems for object-oriented languages [EST95], and program analyses aimed at program optimization [AWL94, HM94]. In short, the combination of subtyping and poly-morphism is useful, with many applications.
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction and polymorphism. </title> <journal> Computing Surverys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Parametric polymorphism allows a parameterized type inferred for a program fragment to take on a different instance in every usage context. A number of type systems combine subtyping and polymorphism, among other features. The intended purposes of these systems varies. A few examples are: studies of type systems themselves <ref> [CW85, Cur90, AW93] </ref>, type systems for object-oriented languages [EST95], and program analyses aimed at program optimization [AWL94, HM94]. In short, the combination of subtyping and poly-morphism is useful, with many applications.
Reference: [EST95] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In OOPSLA '96, </booktitle> <year> 1995. </year>
Reference-contexts: A number of type systems combine subtyping and polymorphism, among other features. The intended purposes of these systems varies. A few examples are: studies of type systems themselves [CW85, Cur90, AW93], type systems for object-oriented languages <ref> [EST95] </ref>, and program analyses aimed at program optimization [AWL94, HM94]. In short, the combination of subtyping and poly-morphism is useful, with many applications. When taken together, subtyping and polymorphism induce equivalences on types that can be exploited to simplify the representation of types. <p> Other recent systems based on constrained types have also pointed out the importance of variable elimination. In <ref> [EST95] </ref>, Eifrig, Smith, and Trifonov and separately Pottier [Pot96] describe methods for eliminating unnecessary variables from constraint sets. Both of these methods are heuristic; i.e., they are sound but not complete. Constraint simplification is also a component of the systems described in [Kae92, Smi94].
Reference: [FA96] <author> M. Fahndrich and A. Aiken. </author> <title> Making set-constraint program analyses scale. </title> <booktitle> In CP96 Workshop on Set Constraints, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: The algorithm has been implemented and used in Illyria 4 , the systems reported in [AW93], a large scale program analysis system for the functional language FL [AWL94], and a general-purpose constraint-based program analysis system <ref> [FA96] </ref>. Other recent systems based on constrained types have also pointed out the importance of variable elimination. In [EST95], Eifrig, Smith, and Trifonov and separately Pottier [Pot96] describe methods for eliminating unnecessary variables from constraint sets. Both of these methods are heuristic; i.e., they are sound but not complete.
Reference: [HM94] <author> Fritz Henglein and Christian Mossin. </author> <title> Polymorphic binding-time analysis. </title> <editor> In Donald Sannella, editor, </editor> <booktitle> Proceedings of European Symposium on Programming, volume 788 of Lecture Notes in Computer Science, </booktitle> <pages> pages 287-301. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: A number of type systems combine subtyping and polymorphism, among other features. The intended purposes of these systems varies. A few examples are: studies of type systems themselves [CW85, Cur90, AW93], type systems for object-oriented languages [EST95], and program analyses aimed at program optimization <ref> [AWL94, HM94] </ref>. In short, the combination of subtyping and poly-morphism is useful, with many applications. When taken together, subtyping and polymorphism induce equivalences on types that can be exploited to simplify the representation of types.
Reference: [Kae92] <author> Stefan Kaes. </author> <title> Type inference in the presence of overloading, subtyping and recursive types. </title> <booktitle> In 1992 ACM Conference on Lisp and Functional Programming. </booktitle> <address> San Francisco, California. </address> <booktitle> LISP Pointers V, </booktitle> <volume> 1, </volume> <pages> pages 193-204, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: In [EST95], Eifrig, Smith, and Trifonov and separately Pottier [Pot96] describe methods for eliminating unnecessary variables from constraint sets. Both of these methods are heuristic; i.e., they are sound but not complete. Constraint simplification is also a component of the systems described in <ref> [Kae92, Smi94] </ref>. Our focus in this paper is quite different. The question of variable elimination arises in any type system with polymorphism and subtyping, not just in systems with constrained types. Our purpose is to explore the basic structure of this problem in the simplest settings.
Reference: [Koe94] <author> A. Koenig. </author> <title> An anecdote about ML type inference. </title> <booktitle> In Proceedings of the USENIX 1994 Symposium on Very High Level Languages, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: The reasoning required to discover that 8ff:8fi:ff ! fi represents an everywhere-divergent function is non-trivial. There is a published account illustrating how types inferred from ML programs (which have polymorphism but no subtyping) can be used to detect non-terminating functions exactly as above <ref> [Koe94] </ref>. Note that this example is the simplest one possible; the problem of understanding types only increases with the size of the type and expressiveness of the type language. Simplifying types can improve not only the speed but the quality of program analyses.
Reference: [MPS84] <author> D. MacQueen, G. Plotkin, and R. Sethi. </author> <title> An ideal model for recursive poly-mophic types. </title> <booktitle> In Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 165-174, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: Thus, one might suspect that this type is equivalent to &gt; !?. The only function with this type is the one that diverges for all possible inputs. It turns out that, in fact, 8ff:8fi:ff ! fi &gt; ! ? in the standard ideal model of types <ref> [MPS84] </ref>. As argued above, the type with fewer variables is better for human readability and the speed of type inference (since it reduces the number of variables in instances of the polymorphic type, in this case to zero). <p> Notice that, unlike the notion of strong glb types, which is purely semantic, standard glb types also has a syntactic component. Example 3. Consider the domain equation V N + (V ! V ) where N is the integers. This is essentially the equation of the ideal model in <ref> [MPS84] </ref>. The ideal model does not have strong glb types. For example, consider the set S 0 = f3; 4g. The glb of this set is f?g, but there is neither 3 nor 4 is less than ?. <p> A system of equations ffi 1 = t 1 ^ : : : ^ ffi n = t n is contractive iff each ffi i is contractive in every equation of the system. Contractiveness is a standard technical condition in systems with recursive types <ref> [MPS84] </ref>. Contractiveness is necessary for equations to have unique solutions (e.g., an equation such as ffi = ffi may have many solutions). The results of this section only apply to systems of contractive equations. Definition 29.
Reference: [Pot96] <author> F. Pottier. </author> <title> Simplifying subtyping constraints. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 122-133, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Other recent systems based on constrained types have also pointed out the importance of variable elimination. In [EST95], Eifrig, Smith, and Trifonov and separately Pottier <ref> [Pot96] </ref> describe methods for eliminating unnecessary variables from constraint sets. Both of these methods are heuristic; i.e., they are sound but not complete. Constraint simplification is also a component of the systems described in [Kae92, Smi94]. Our focus in this paper is quite different.
Reference: [Smi94] <author> Geoffrey S. Smith. </author> <title> Principal type schemes for functional programs with overloading and subtyping. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 23 </volume> <pages> 197-226, </pages> <year> 1994. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: In [EST95], Eifrig, Smith, and Trifonov and separately Pottier [Pot96] describe methods for eliminating unnecessary variables from constraint sets. Both of these methods are heuristic; i.e., they are sound but not complete. Constraint simplification is also a component of the systems described in <ref> [Kae92, Smi94] </ref>. Our focus in this paper is quite different. The question of variable elimination arises in any type system with polymorphism and subtyping, not just in systems with constrained types. Our purpose is to explore the basic structure of this problem in the simplest settings.
References-found: 15

