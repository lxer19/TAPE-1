URL: ftp://ftp.cc.gatech.edu/pub/gvu/tr/1992/92-10.ps.Z
Refering-URL: http://www.cs.gatech.edu/gvu/reports/1992/
Root-URL: 
Title: A Methodology for Building Application-Specific Visualizations of Parallel Programs  
Author: John T. Stasko Eileen Kraemer 
Note: Office:  
Address: Atlanta, GA 30332-0280  
Affiliation: Graphics, Visualization, and Usability Center College of Computing Georgia Institute of Technology  
Pubnum: Technical Report GIT-GVU-92-10  
Email: Email: stasko@cc.gatech.edu  
Phone: (404) 853-9386  
Abstract: Visualization of computer programs, particularly parallel programs, promises to help programmers better understand, develop, and debug their code, especially if the visualizations are relatively easy to create. We have developed a visualization methodology being used as a component in a comprehensive parallel program visualization system. The focus of the system is on application-specific user-tailored program views. An application-specific visualization of a parallel program presents the inherent application domain, semantics, and data being manipulated by the program in a manner natural to one's understanding of the program. In this paper we discuss why application-specific views are necessary for program debugging, and we list several requirements and challenges that a system for application-specific viewing should meet. The visualization methodology that we introduce includes primitives for designing smooth animation scenarios, and most importantly, for allowing designers to visualize or showcase the concurrency exhibited by parallel programs. 
Abstract-found: 1
Intro-found: 1
Reference: [AS91] <author> William Appelbe and John T. Stasko. </author> <title> Utilizing program visualization and animation techniques to aid parallel program development and debugging (extended abstract). </title> <booktitle> In Proceedings of the 1991 ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 207-209, </pages> <address> Santa Cruz, CA, </address> <month> May </month> <year> 1991. </year> <month> 19 </month>
Reference-contexts: The system should be able to visualize programs from a variety of system models and architectures. 3 Animation Methodology We are building a comprehensive program visualization system called PARADE (PARallel program Animation Development Environment) for developing animations of parallel programs <ref> [AS91, SAK91] </ref>. The system contains components for 1) extracting and formatting program event information; 2) mapping and restructuring the event information as input to the animation component; 3) creating the animated graphical program views. The 3 third component, our animation methodology, is the focus of this paper.
Reference: [Bar86] <author> Paul S. Barth. </author> <title> An object-oriented approach to graphical interfaces. </title> <journal> ACM Trans--actions on Graphics, </journal> <volume> 5(2) </volume> <pages> 142-172, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Views are designed using a spreadsheet programming model. This paradigm works well for views that can be described from an algebraic specification of program execution data. Object-oriented Graphics The use of object-oriented techniques for computer graphics has seen increased attention recently. The GROW system <ref> [Bar86] </ref> uses taxonomic inheritance and constraints to help users build program interfaces, most often graphical editors. The InterViews Graphical Toolkit [VL88] contains an extensive hierarchy of graphical objects (written in C++) and a powerful set of methods for manipulating these objects.
Reference: [Bro88] <author> Marc H. Brown. </author> <title> Perspectives on algorithm animation. </title> <booktitle> In Proceedings of the ACM SIGCHI '88 Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 33-38, </pages> <address> Washington D.C., </address> <month> May </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Software visualization is the use of graphics to illustrate the methods, constituents, and purpose of computer algorithms and programs [Mye90, PSB92, SP92]. When the visualization is dynamic and it illustrates the semantics or abstract operations of a program, the visualization is often called algorithm animation <ref> [Bro88] </ref>. In this paper, we describe a new animation methodology particularly useful for developing dynamic visualizations of parallel programs, a relatively unexplored area of computer science. Visualization techniques can be applied to a number of activities involved in parallel program development including program design, performance evaluation, and debugging.
Reference: [Bro91] <author> Marc H. Brown. ZEUS: </author> <title> A system for algorithm animation and multi-view editing. </title> <booktitle> In Proceedings of the 1991 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 4-9, </pages> <address> Kobe Japan, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Many different applications such as user interface builders and graphical editors have been implemented using Interviews. 18 POLKA differs from these systems in its focus on object classes for animation rather than static graphics. The algorithm animation system Zeus <ref> [Bro91] </ref> makes extensive use of objects, particularly at higher, more abstract levels, such as classes for algorithms, windows, and views.
Reference: [CR91] <author> Kenneth C. Cox and Gruia-Catalin Roman. </author> <title> Visualizing concurrent computations. </title> <booktitle> In Proceedings of the IEEE 1991 Workshop on Visual Languages, </booktitle> <pages> pages 18-24, </pages> <address> Kobe Japan, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: To create an external view, a programmer must extract information from an execution history graph, 17 over a given time interval. design a view in a Common Lisp environment, and then input the information to other visualization tools. The Pavane system <ref> [CR91] </ref>, which operates on a shared-memory tuple space architecture, supports formal mappings from a program space to an abstract animation space that can later be rendered. This model supports highly application-specific program views.
Reference: [FLK + 91] <author> Mark Friedell, Mark LaPolla, Sandeep Kochhar, Steve Sistare, and Janusz Juda. </author> <title> Visualizing the behavior of massively parallel programs. </title> <booktitle> In Proceedings of Supercomputing '91, </booktitle> <pages> pages 472-480, </pages> <address> Albuquerque, NM, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: This model supports highly application-specific program views. To describe a visualization, programmers must construct the mappings, which are similar to those in formal proof systems. The IVE system <ref> [FLK + 91] </ref> supports visualizations of programs on massively parallel SIMD machines. These process visualizations are developed using visualization templates, parametrical graphical object descriptions that can be created by refining existing templates or by using a CAD-style tool. This model appears to support static visualizations much more so than animations.
Reference: [HE91] <author> Michael T. Heath and Jennifer A. Etheridge. </author> <title> Visualizing the performance of parallel programs. </title> <journal> IEEE Software, 8(5):29 -39, </journal> <month> September </month> <year> 1991. </year>
Reference-contexts: Essentially, it is a general visualization environment for all features and types of 16 programs. Figure 7 shows a view of a Kiviat diagram [KK73] created using POLKA. A Kiviat diagram (this View is modeled after one from the Paragraph system <ref> [HE91] </ref>) illustrates a set of processors as spokes on a wheel with each processor's recent average utilization reflected as distance along its spoke. When a processor is idle, its spoke is at the center of the wheel. When it is completely busy, the spoke is extended to the outer edge. <p> POLKA's animation methodology also serves equally well as a platform for developing these performance views or even algorithm animations of serial programs. 5 Related Work Visualizing Parallel Programs A few existing systems have addressed the need for application-specific program views. The ParaGraph system <ref> [HE91] </ref>, best known for its predefined library of performance views, contains facilities for application-specific views to be added and run under the infrastructure of ParaGraph's existing support environment. This task requires basic X Window System programming, however.
Reference: [KK73] <author> K. Kolence and P. Kiviat. </author> <title> Software unit profiles and Kiviat figures. </title> <booktitle> Performance Evaluation Review, </booktitle> <pages> pages 2-12, </pages> <month> September </month> <year> 1973. </year>
Reference-contexts: POLKA also can be used for animating more than only the semantic behavior of parallel algorithms. Essentially, it is a general visualization environment for all features and types of 16 programs. Figure 7 shows a view of a Kiviat diagram <ref> [KK73] </ref> created using POLKA. A Kiviat diagram (this View is modeled after one from the Paragraph system [HE91]) illustrates a set of processors as spokes on a wheel with each processor's recent average utilization reflected as distance along its spoke.
Reference: [Lam78] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Another moment the viewer may want to view program execution as related to a global system clock time. In other instances the viewer may wish to observe program behavior according to logical precedences, so-called Lamport time <ref> [Lam78] </ref>, or even under some alternative feasible execution ordering. The animation choreographer, much more so than in serial program animations, is an absolutely crucial element in the system.
Reference: [LMCF90] <author> Thomas J. LeBlanc, John M. Mellor-Crummey, and Robert J. Fowler. </author> <title> Analyzing parallel program execution using multiple views. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9(2) </volume> <pages> 203-217, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Voyeur uses a class hierarchy of views, so that derivations of views are easy. It does not appear that many types of views were implemented, however. Creating a new view, as is common in application-specific visualization, required X Window programming. The system presented in <ref> [LMCF90] </ref> provides many different styles of program views. Their external view corresponds to the application-specific visualizations we seek.
Reference: [Mey92] <author> Scott Meyers. </author> <title> Effective C++: 50 Ways To Improve Your Programs and Designs. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1992. </year>
Reference: [Mye90] <author> Brad A. Myers. </author> <title> Taxonomies of visual programming and program visualization. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 1(1) </volume> <pages> 97-123, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Software visualization is the use of graphics to illustrate the methods, constituents, and purpose of computer algorithms and programs <ref> [Mye90, PSB92, SP92] </ref>. When the visualization is dynamic and it illustrates the semantics or abstract operations of a program, the visualization is often called algorithm animation [Bro88].
Reference: [PSB92] <author> Blaine A. Price, Ian S. Small, and Ronald M. Baecker. </author> <title> A taxonomy of software visualization. </title> <booktitle> In Proceedings of the 25th Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 597-606, </pages> <address> Kauai, HI, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Software visualization is the use of graphics to illustrate the methods, constituents, and purpose of computer algorithms and programs <ref> [Mye90, PSB92, SP92] </ref>. When the visualization is dynamic and it illustrates the semantics or abstract operations of a program, the visualization is often called algorithm animation [Bro88].
Reference: [SAK91] <author> John T. Stasko, William F. Appelbe, and Eileen Kraemer. </author> <title> Utilizing program visualization techniques to aid parallel and distributed program development. </title> <type> Technical Report GIT-GVU-91/08, </type> <institution> Graphics, Visualization, and Usability Center, Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: The system should be able to visualize programs from a variety of system models and architectures. 3 Animation Methodology We are building a comprehensive program visualization system called PARADE (PARallel program Animation Development Environment) for developing animations of parallel programs <ref> [AS91, SAK91] </ref>. The system contains components for 1) extracting and formatting program event information; 2) mapping and restructuring the event information as input to the animation component; 3) creating the animated graphical program views. The 3 third component, our animation methodology, is the focus of this paper.
Reference: [SBN89] <author> David Socha, Mary L. Bailey, and David Notkin. Voyeur: </author> <title> Graphical views of parallel programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 206-215, </pages> <month> January </month> <year> 1989. </year> <booktitle> (Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, WI, </address> <month> May </month> <year> 1988). </year>
Reference-contexts: This task requires basic X Window System programming, however. Many of our goals mirror those of the system Voyeur <ref> [SBN89] </ref> which focuses on supporting easy-to-create views matching a programmer's mental model of her code. Voyeur uses a class hierarchy of views, so that derivations of views are easy. It does not appear that many types of views were implemented, however.
Reference: [SG92] <author> Sekhar R. Sarukkai and Dennis Gannon. </author> <title> Performance visualization of parallel programs using SIEVE.1. </title> <booktitle> In Proceedings of the 1992 International Conference on Supercomputing, </booktitle> <pages> pages 157-166, </pages> <address> Washington, D.C., </address> <month> July </month> <year> 1992. </year>
Reference-contexts: Sarukkai and Gannon echo the importance of application-specific views in <ref> [SG92] </ref>: While it is convenient to have predefined visualizations of programs, the problem with such tools is that is is not easy to rapidly test new visualizations of the program execution. <p> These process visualizations are developed using visualization templates, parametrical graphical object descriptions that can be created by refining existing templates or by using a CAD-style tool. This model appears to support static visualizations much more so than animations. SIEVE.1 <ref> [SG92] </ref>, although specifically designed for performance visualization, supports program views that can be considered application-specific. Views are designed using a spreadsheet programming model. This paradigm works well for views that can be described from an algebraic specification of program execution data.
Reference: [Sno88] <author> Richard Snodgrass. </author> <title> A relational approach to monitoring complex systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(2) </volume> <pages> 157-196, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: In the first component, extracted program information can be either automatically generated system events such as control, message, and synchronization events, or it can be programmer annotated application-specific program events. We currently write the events to trace file (s). We also are exploring the use of temporal databases <ref> [Sno88] </ref> to store and manipulate event information, and the use of on-line (pseudo real-time) processing and display. In all of these methods, we do assume that the parallel program being animated and its animation are in separate process spaces so that they cannot share data structures.
Reference: [SP92] <author> John T. Stasko and Charles Patterson. </author> <title> Understanding and characterizing software visualization systems. </title> <booktitle> In Proceedings of the 1992 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 3-10, </pages> <address> Seattle, WA, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Software visualization is the use of graphics to illustrate the methods, constituents, and purpose of computer algorithms and programs <ref> [Mye90, PSB92, SP92] </ref>. When the visualization is dynamic and it illustrates the semantics or abstract operations of a program, the visualization is often called algorithm animation [Bro88].
Reference: [Sta90a] <author> John T. Stasko. </author> <title> The Path-Transition Paradigm: A practical methodology for adding animation to program interfaces. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 1(3) </volume> <pages> 213-236, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: For our simplified world, restricting the control points to two real numbers, which correspond with the View coordinate system, is practical, efficient, and advantageous. POLKA's animation methodology is derived from a combination of principles of the path-transition paradigm <ref> [Sta90a] </ref> of the TANGO algorithm animation system [Sta90b] in which designers create images and modify them along paths or two-dimensional trajectories and also from the techniques of more traditional production 3D animation systems. POLKA's animation methods differ critically from TANGO's path-transition paradigm in how animation actions are defined and executed.
Reference: [Sta90b] <author> John T. Stasko. </author> <title> TANGO: A framework and system for algorithm animation. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: For our simplified world, restricting the control points to two real numbers, which correspond with the View coordinate system, is practical, efficient, and advantageous. POLKA's animation methodology is derived from a combination of principles of the path-transition paradigm [Sta90a] of the TANGO algorithm animation system <ref> [Sta90b] </ref> in which designers create images and modify them along paths or two-dimensional trajectories and also from the techniques of more traditional production 3D animation systems. POLKA's animation methods differ critically from TANGO's path-transition paradigm in how animation actions are defined and executed.
Reference: [Sta91] <author> John T. Stasko. </author> <title> Using direct manipulation to build algorithm animations by demonstration. </title> <booktitle> In Proceedings of the ACM SIGCHI '91 Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 307-314, </pages> <address> New Orleans, LA, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: The methodology we have developed sacrifices some ease-of-use for visualization specification power. Improving this trade-off is our primary goal for future work. As one possible improvement, we hope to develop a direct manipulation visualization design tool similar to the DANCE tool <ref> [Sta91] </ref> for sequential programs animated using the path-transition paradigm. With such a tool, POLKA's Views and animation scenes could be generated by demonstration rather than with graphics programming. We also continue to develop the other components, program monitors and the animation choreographer, of our parallel program visualization system PARADE.
Reference: [VL88] <author> John M. Vlissides and Mark A. Linton. </author> <title> Applying object-oriented design to structured graphics. </title> <booktitle> In Proceedings of the 1988 USENIX C++ Conference, </booktitle> <pages> pages 81-94, </pages> <address> Denver, CO, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: Object-oriented Graphics The use of object-oriented techniques for computer graphics has seen increased attention recently. The GROW system [Bar86] uses taxonomic inheritance and constraints to help users build program interfaces, most often graphical editors. The InterViews Graphical Toolkit <ref> [VL88] </ref> contains an extensive hierarchy of graphical objects (written in C++) and a powerful set of methods for manipulating these objects.
Reference: [Z + 91] <author> Robert C. Zeleznik et al. </author> <title> An object-oriented framework for the integration of interactive animation techniques. </title> <journal> Computer Graphics: </journal> <volume> SIGGRAPH '91, 25(4) </volume> <pages> 105-111, </pages> <month> July </month> <year> 1991. </year> <month> 21 </month>
Reference-contexts: An Action has both a type, which is simply a string identifier such as "MOVE," "COLOR," or "RESIZE" and a list of hx; yi offset pairs, defining a two-dimensional sequence in the View coordinate system. In more complex 3-D systems such as <ref> [Z + 91] </ref>, the offset lists or paths can consist of control points of varying types such as vectors, expressions, and strings. For our simplified world, restricting the control points to two real numbers, which correspond with the View coordinate system, is practical, efficient, and advantageous.
References-found: 23

