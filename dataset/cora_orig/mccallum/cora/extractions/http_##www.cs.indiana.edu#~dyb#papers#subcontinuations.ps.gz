URL: http://www.cs.indiana.edu/~dyb/papers/subcontinuations.ps.gz
Refering-URL: http://www.cs.indiana.edu/~dyb/pubs.html
Root-URL: http://www.cs.indiana.edu
Email: (dyb@cs.indiana.edu)  (anderson@cs.rose-hulman.edu)  
Title: Subcontinuations  Keywords: Continuations, Control Structure, Control Delimiters, Concurrency, En gines, Scheme  
Author: ROBERT HIEB R. KENT DYBVIG CLAUDE W. ANDERSON, III 
Address: Bloomington, IN 47405  47803  
Affiliation: Indiana University Computer Science Department  Rose-Hulman Institute of Technology Computer Science Department Terre Haute, Indiana  
Date: 6, 453-484, 1993  (Received: November, 1992) (Revised: June, 1993)  
Note: LISP AND SYMBOLIC COMPUTATION: An International Journal,  c 1993 Kluwer Academic Publishers Manufactured in The Netherlands  
Abstract: Continuations have proven to be useful for implementing a variety of control structures, including exception handling facilities and breadth-first searching algorithms. However, traditional continuations are not useful in the presence of concurrency, because the notion of the rest of the computation represented by a continuation does not in general make sense. Traditional continuations can also be difficult to use in nonconcurrent settings, since their global nature is sometimes problematic. This article presents a new type of continuation, called a subcontinuation. Just as a traditional continuation represents the rest of a computation from a given point in the computation, a subcontinuation represents the rest of a subcomputation from a given point in the subcomputation. Sub-continuations may be used to control tree-structured concurrency by allowing nonlocal exits to arbitrary points in a process tree and allowing the capture of a subtree of a computation as a composable continuation for later use. In the absence of concurrency the localized control achievable with subcontinuations makes them more useful than traditional continuations. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Halstead, Jr., Robert H. </author> <title> Multilisp: A language for concurrent symbolic computation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7, </volume> <month> 4 (October </month> <year> 1985) </year> <month> 501-538. </month>
Reference-contexts: In the absence of concurrency, subcontinuations offer the ability to localize the effects of control operations. Not all concurrency is tree-based. A good example of the distinction be SUBCONTINUATIONS 455 tween tree-based and other forms of concurrency can be found in Halstead's Multilisp <ref> [1] </ref>, which supports both parallel calls (with pcall) and futures (with future). pcall introduces tree-based concurrency, since it evaluates its arguments in parallel and then applies the value of the first argument to the values of the remaining arguments as in a normal procedure call.
Reference: 2. <author> Steele Jr., Guy L. </author> <title> Common Lisp, the Language. </title> <note> Digital Press, second edition (1990). </note>
Reference-contexts: Thus, entry and exit provide a "barrier" between the computation performed by body and computations performed outside body. This barrier may be used to set up state variables or objects external to the Scheme system that are needed only within body. Common Lisp <ref> [2] </ref> provides a similar form, unwind-protect, which allows an exit handler to be established within its body. There is no need for an entry handler since Common Lisp continuations are not first-class and can be used only for nonlocal exits.
Reference: 3. <author> Bartley, David H. and Jensen, John C. </author> <title> The implementation of PC Scheme. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Lisp and Functional Programming (August 1986) 86-93. </booktitle>
Reference-contexts: In the presence of continuations, this stack is often implemented as a linked list to facilitate the capture and invocation of continuations as objects. It is also possible to employ a true stack by copying continuations that have been captured before they are modified <ref> [7, 5, 3] </ref>. With either implementation, it is possible to place a constant bound on the amount of work that must be performed by the continuation operations regardless of the size of the current continuation [17]. Subcontinuations can be implemented in a similar manner with little additional overhead.
Reference: 4. <editor> Clinger, William, Rees, Jonathan A., et al. </editor> <title> The revised 4 report on the SUBCONTINUATIONS 477 algorithmic language Scheme. LISP Pointers, </title> <type> 4, </type> <month> 3 </month> <year> (1991). </year>
Reference-contexts: 1. Introduction A continuation is an abstract entity that represents the rest of the computa tion from a given point in the computation. A language such as Scheme <ref> [4] </ref> that provides access to continuations as first-class values need not directly fl This material is based on work supported by the National Science Foundation under grant number CCR-88-03432 and by Sandia National Laboratories under contract number 06-06211. <p> Many programming languages provide control operations such as jumps and exits that modify a program's continuation. Scheme makes continuations available as procedures via the procedure call-with-current-continuation, commonly abbreviated call/cc <ref> [4, 24] </ref>. The argument to call/cc is a procedure of one argument. The application (call/cc p ) causes p to be applied to a procedure representing the current continuation.
Reference: 5. <author> Clinger, William D. and Ost, Eric M. </author> <title> Implementation strategies for continuations. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming (July 1988) 124-131. </booktitle>
Reference-contexts: In the presence of continuations, this stack is often implemented as a linked list to facilitate the capture and invocation of continuations as objects. It is also possible to employ a true stack by copying continuations that have been captured before they are modified <ref> [7, 5, 3] </ref>. With either implementation, it is possible to place a constant bound on the amount of work that must be performed by the continuation operations regardless of the size of the current continuation [17]. Subcontinuations can be implemented in a similar manner with little additional overhead.
Reference: 6. <author> Dybvig, R. Kent. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice Hall (1987). </publisher>
Reference-contexts: Continuation operations must affect either the entire process tree or single branches of the process tree; there is no way to designate subtrees. Problems also arise when continuations are used for modeling process abstractions, such as coroutines [13] and engines <ref> [8, 6] </ref>. In such cases, continuations must be saved so that processes can be resumed. Again, it is difficult to specify how much of the process tree is to be affected, but another problem also arises. <p> The seemingly redundant additional zero-arity lambda expressions and the corresponding invocation on line four are present to ensure that k is invoked to restore the root of the controller before any attempt is made to invoke the controller. 5. Control Filters The Scheme procedure dynamic-wind <ref> [15, 6] </ref> may be used to perform setup and clean-up actions on entry to or exit from a given computation, even if exit or entry occurs as the result of a continuation invocation. This procedure accepts three arguments, each of which is a zero-arity procedure: entry, body, and exit.
Reference: 7. <author> Dybvig, R. Kent. </author> <title> Three Implementation Models for Scheme. </title> <type> PhD thesis, </type> <institution> University of North Carolina, </institution> <address> Chapel Hill (April 1987). </address>
Reference-contexts: In the presence of continuations, this stack is often implemented as a linked list to facilitate the capture and invocation of continuations as objects. It is also possible to employ a true stack by copying continuations that have been captured before they are modified <ref> [7, 5, 3] </ref>. With either implementation, it is possible to place a constant bound on the amount of work that must be performed by the continuation operations regardless of the size of the current continuation [17]. Subcontinuations can be implemented in a similar manner with little additional overhead.
Reference: 8. <author> Dybvig, R. Kent and Hieb, Robert. </author> <title> Engines from continuations. </title> <journal> Computer Languages, </journal> <volume> 14, </volume> <month> 2 </month> <year> (1989) </year> <month> 109-123. </month>
Reference-contexts: Continuation operations must affect either the entire process tree or single branches of the process tree; there is no way to designate subtrees. Problems also arise when continuations are used for modeling process abstractions, such as coroutines [13] and engines <ref> [8, 6] </ref>. In such cases, continuations must be saved so that processes can be resumed. Again, it is difficult to specify how much of the process tree is to be affected, but another problem also arises. <p> of the first to complete: (define amb (lambda (t0 t1 ) (let loop ((e0 (make-engine t0 )) (e1 (make-engine t1 ))) (e0 1 (lambda (value ticks ) value ) (lambda (new-e0 ) (loop e1 new-e0 )))))) In an earlier article, we showed that engines may be implemented using traditional continuations <ref> [8] </ref>. The article cites several problems inherent in the interaction between engines and traditional continuations. These problems are exactly those present in the interaction between tree-structured concurrency and traditional continuations. Subcontinuations solve these problems and simplify the engine implementation, especially the implementation of nestable engines. <p> Independent timers may be implemented in terms of a single timer provided by the host operating environment. It is also straightforward to generalize the single-timer mechanism described in <ref> [8] </ref>, which relies upon a syntactic extension for lambda that causes one tick to be consumed for each procedure call.
Reference: 9. <author> Felleisen, Matthias. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages (January 1988) 180-190. </booktitle>
Reference-contexts: However, since F always aborts the complete computation, it still suffers from some of the same problems as traditional continuations. In a later paper Felleisen introduced the notion of a "prompt" operator (written "#") to provide finer control over F <ref> [9] </ref>. The prompt establishes the base of a computation for subsequent calls to F. The continuation captured by F extends only to the last prompt, and the current continuation is aborted only to the last prompt. <p> Subcontinuations were first introduced by the authors in an earlier paper, which referred to subcontinuations as process continuations [16]. A similar mechanism, developed independently, was described in a later paper by Queinnec and Serpette [22]. Our work is based on work by Felleisen, et al. <ref> [11, 9, 12] </ref>. Johnson and Duggan [18] have developed a notion of partial continuations that also extends traditional continuation control in a similar manner. In a related work, Sitaram and Felleisen [23] introduce techniques to constrain the effects of prompts and functional continuations.
Reference: 10. <author> Felleisen, Matthias and Hieb, Robert. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <booktitle> Theoretical Computer Science, </booktitle> <month> 103 </month> <year> (1992) </year> <month> 235-271. </month>
Reference-contexts: Evaluation proceeds by rewriting an expression-store pair until a value is obtained. The rewrite rules are expressed in terms of evaluation contexts <ref> [10] </ref>. A context is an expression containing a "hole," written . C [e] denotes the expression formed by filling the context C with the expression e.
Reference: 11. <author> Felleisen, Matthias, Friedman, Daniel P., Duba, Bruce, and Merrill, John. </author> <title> Beyond Continuations. </title> <type> Technical Report 216, </type> <institution> Indiana University Computer Science Department (1987). </institution>
Reference-contexts: Some of the problems inherent in abortive continuations can be solved by using "functional" continuations. Felleisen, et al. <ref> [11] </ref>, introduced a new control operator, F, that is similar to call/cc in that it captures the current continuation and passes it to its argument. However, F differs from call/cc in two ways. One difference is that the captured continuation is compositional rather than abortive. <p> Subcontinuations were first introduced by the authors in an earlier paper, which referred to subcontinuations as process continuations [16]. A similar mechanism, developed independently, was described in a later paper by Queinnec and Serpette [22]. Our work is based on work by Felleisen, et al. <ref> [11, 9, 12] </ref>. Johnson and Duggan [18] have developed a notion of partial continuations that also extends traditional continuation control in a similar manner. In a related work, Sitaram and Felleisen [23] introduce techniques to constrain the effects of prompts and functional continuations.
Reference: 12. <author> Felleisen, Matthias, Wand, Mitchell, Friedman, Daniel P., and Duba, Bruce F. </author> <title> Abstract continuations: A mathematical semantics for handling full functional jumps. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming (July 1988) 52-62. </booktitle>
Reference-contexts: Subcontinuations were first introduced by the authors in an earlier paper, which referred to subcontinuations as process continuations [16]. A similar mechanism, developed independently, was described in a later paper by Queinnec and Serpette [22]. Our work is based on work by Felleisen, et al. <ref> [11, 9, 12] </ref>. Johnson and Duggan [18] have developed a notion of partial continuations that also extends traditional continuation control in a similar manner. In a related work, Sitaram and Felleisen [23] introduce techniques to constrain the effects of prompts and functional continuations.
Reference: 13. <author> Friedman, Daniel P., Haynes, Christopher T., and Wand, Mitchell. </author> <title> Obtaining coroutines with continuations. </title> <journal> Computer Languages, </journal> <volume> 11, </volume> <month> 3/4 </month> <year> (1986) </year> <month> 143-153. </month>
Reference-contexts: There is, however, no way to make such distinctions with call/cc. Continuation operations must affect either the entire process tree or single branches of the process tree; there is no way to designate subtrees. Problems also arise when continuations are used for modeling process abstractions, such as coroutines <ref> [13] </ref> and engines [8, 6]. In such cases, continuations must be saved so that processes can be resumed. Again, it is difficult to specify how much of the process tree is to be affected, but another problem also arises.
Reference: 14. <author> Haynes, Christopher T. and Friedman, Daniel P. </author> <title> Abstracting timed preemption with engines. </title> <journal> Computer Languages, </journal> <volume> 12, </volume> <month> 2 </month> <year> (1987) </year> <month> 109-121. </month>
Reference-contexts: Engines provide the means for a computation SUBCONTINUATIONS 469 to be run for a limited period of time, interrupted if it does not complete in that time, and later restarted from the point of interruption <ref> [14] </ref>. The procedure make-engine creates an engine from a thunk, a procedure of no arguments specifying the computation to be performed by the engine. <p> The need to nest engines in the same family arises rarely, if ever, in practice, so the added complexity required to relax this restriction does not seem warranted. The style of nesting implemented by the code above is termed fair nesting <ref> [14] </ref>. With fair nesting, each tick charged to an engine is charged as well to each of its ancestors. Fair nesting results from leaving the timer of a parent engine running while the timer of a child engine is running.
Reference: 15. <author> Haynes, Christopher T. and Friedman, Daniel P. </author> <title> Embedding continuations in procedural objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9, </volume> <month> 4 </month> <year> (1987) </year> <month> 582-598. </month>
Reference-contexts: The seemingly redundant additional zero-arity lambda expressions and the corresponding invocation on line four are present to ensure that k is invoked to restore the root of the controller before any attempt is made to invoke the controller. 5. Control Filters The Scheme procedure dynamic-wind <ref> [15, 6] </ref> may be used to perform setup and clean-up actions on entry to or exit from a given computation, even if exit or entry occurs as the result of a continuation invocation. This procedure accepts three arguments, each of which is a zero-arity procedure: entry, body, and exit. <p> Control filters are implemented straightforwardly using a mechanism similar to that described by Haynes and Friedman for dynamic-wind <ref> [15] </ref>. A list of currently active filters is maintained by the system, and each time a controller is created or reestablished, a pointer to the topmost element of the list of filters is saved with the controller.
Reference: 16. <author> Hieb, Robert and Dybvig, R. Kent. </author> <title> Continuations and concurrency. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (March 1990) 128-136. 478 HIEB, DYBVIG, AND ANDERSON </booktitle>
Reference-contexts: One possibility is to treat such combinations of dependent and independent processes as a forest of trees, in which control operations affect only the tree in which they occur. Subcontinuations were first introduced by the authors in an earlier paper, which referred to subcontinuations as process continuations <ref> [16] </ref>. A similar mechanism, developed independently, was described in a later paper by Queinnec and Serpette [22]. Our work is based on work by Felleisen, et al. [11, 9, 12].
Reference: 17. <author> Hieb, Robert, Dybvig, R. Kent, and Bruggeman, Carl. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation (June 1990) 66-77. </booktitle>
Reference-contexts: With either implementation, it is possible to place a constant bound on the amount of work that must be performed by the continuation operations regardless of the size of the current continuation <ref> [17] </ref>. Subcontinuations can be implemented in a similar manner with little additional overhead. Instead of a single stack of activation records, the system maintains a stack of labeled stacks 1 .
Reference: 18. <author> Johnson, Gregory F. and Duggan, Dominic. </author> <title> Stores and partial continuations as first-class objects in a language and its environment. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages (January 1988) 158-168. </booktitle>
Reference-contexts: A similar mechanism, developed independently, was described in a later paper by Queinnec and Serpette [22]. Our work is based on work by Felleisen, et al. [11, 9, 12]. Johnson and Duggan <ref> [18] </ref> have developed a notion of partial continuations that also extends traditional continuation control in a similar manner. In a related work, Sitaram and Felleisen [23] introduce techniques to constrain the effects of prompts and functional continuations.
Reference: 19. <author> Katz, Morry and Weise, Daniel. </author> <title> Continuing into the future: on the interaction of futures and first-class continuations. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming (June 1990) 176-184. </booktitle>
Reference-contexts: Miller [21] does address the issue of using continuations in a parallel Scheme implementation. In his implementation, concurrency is based on placeholders, which are similar to Halstead's futures, and thus he does not treat the problems inherent in using continuations to control tree-based concurrency. Katz and Weise <ref> [19] </ref> also address the relationship between continuations and futures, but do not address control of tree-based concurrency. Acknowledgements: The authors would like to thank the anonymous reviewers for their comments on an earlier version of this article.
Reference: 20. <author> McCarthy, John. </author> <title> A basis for a mathematical theory of computation. </title> <editor> In Braffort, P. and Hirschberg, D., editors, </editor> <booktitle> Computer Programming and Formal Systems, </booktitle> <address> North Holland (1963) 33-70. </address>
Reference-contexts: It is the notion of returning, with or without values, to the point of creation that distinguishes tree-based concurrency from other forms of concurrency. Other examples of tree-based concurrency are McCarthy's amb operator <ref> [20] </ref> and related constructs such as parallel and and or operators. Although our mechanism does not apply to nontree-structured concurrency, we do discuss how our mechanism can be used in languages that allow both forms of concurrency. The remainder of the article is organized as follows. <p> The expire continuation must be a procedure of one arguments; it is invoked with a new engine capable of continuing the computation if the ticks expire before the computation completes. Engines may be used to implement multitasking. The following defines a version of McCarthy's amb operator <ref> [20] </ref> that multitasks two computations and returns the value of the first to complete: (define amb (lambda (t0 t1 ) (let loop ((e0 (make-engine t0 )) (e1 (make-engine t1 ))) (e0 1 (lambda (value ticks ) value ) (lambda (new-e0 ) (loop e1 new-e0 )))))) In an earlier article, we showed
Reference: 21. <author> Miller, James S. MultiScheme: </author> <title> A Parallel Processing System Based on MIT Scheme. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology (September 1987). </institution>
Reference-contexts: In a related work, Sitaram and Felleisen [23] introduce techniques to constrain the effects of prompts and functional continuations. They do so, however, by developing complicated protocols on top of primitive control structures, and they do not address concurrency issues. Miller <ref> [21] </ref> does address the issue of using continuations in a parallel Scheme implementation. In his implementation, concurrency is based on placeholders, which are similar to Halstead's futures, and thus he does not treat the problems inherent in using continuations to control tree-based concurrency.
Reference: 22. <author> Queinnec, Christian and Serpette, Bernard. </author> <title> A dynamic extent control operator for partial continuations. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages (January 1991) 174-184. </booktitle>
Reference-contexts: Subcontinuations were first introduced by the authors in an earlier paper, which referred to subcontinuations as process continuations [16]. A similar mechanism, developed independently, was described in a later paper by Queinnec and Serpette <ref> [22] </ref>. Our work is based on work by Felleisen, et al. [11, 9, 12]. Johnson and Duggan [18] have developed a notion of partial continuations that also extends traditional continuation control in a similar manner.
Reference: 23. <author> Sitaram, Dorai and Felleisen, Matthias. </author> <title> Control delimiters and their hierarchies. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3, </volume> <month> 1 (January </month> <year> 1990) </year> <month> 67-99. </month>
Reference-contexts: Our work is based on work by Felleisen, et al. [11, 9, 12]. Johnson and Duggan [18] have developed a notion of partial continuations that also extends traditional continuation control in a similar manner. In a related work, Sitaram and Felleisen <ref> [23] </ref> introduce techniques to constrain the effects of prompts and functional continuations. They do so, however, by developing complicated protocols on top of primitive control structures, and they do not address concurrency issues. Miller [21] does address the issue of using continuations in a parallel Scheme implementation.
Reference: 24. <author> Springer, George and Friedman, Daniel P. </author> <title> Scheme and the Art of Computer Programming. </title> <publisher> MIT Press and McGraw-Hill (1989). </publisher>
Reference-contexts: Many programming languages provide control operations such as jumps and exits that modify a program's continuation. Scheme makes continuations available as procedures via the procedure call-with-current-continuation, commonly abbreviated call/cc <ref> [4, 24] </ref>. The argument to call/cc is a procedure of one argument. The application (call/cc p ) causes p to be applied to a procedure representing the current continuation.
Reference: 25. <author> Stoy, Joseph E. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press (1977). </publisher>
Reference-contexts: In Section 8, we describe how subcontinuations are implemented. Finally, in Section 9, we make some concluding remarks. 2. Background Continuations are commonly used in denotational semantics as a basis for deriving the meaning of control operations in imperative languages <ref> [25] </ref>. Many programming languages provide control operations such as jumps and exits that modify a program's continuation. Scheme makes continuations available as procedures via the procedure call-with-current-continuation, commonly abbreviated call/cc [4, 24]. The argument to call/cc is a procedure of one argument.
References-found: 25

