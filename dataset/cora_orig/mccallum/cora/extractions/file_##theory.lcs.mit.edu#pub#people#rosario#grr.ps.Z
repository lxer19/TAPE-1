URL: file://theory.lcs.mit.edu/pub/people/rosario/grr.ps.Z
Refering-URL: http://theory.lcs.mit.edu/~rosario/research.html
Root-URL: 
Email: Email: rosario@watson.ibm.com.  rabin@cs.huji.ac.il  Email: talr@watson.ibm.com. Con  
Title: Simplified VSS and Fast-track Multiparty Computations with Applications to Threshold Cryptography  
Author: Rosario Gennaro Michael O. Rabin Tal Rabin 
Note: tact author.  
Address: PO Box 704, Yorktown Heights, New York 10598, USA  Email:  PO Box 704, Yorktown Heights, New York 10598, USA  
Affiliation: IBM T.J. Watson Research Center,  Harvard University and Hebrew University.  IBM T.J. Watson Research Center,  
Abstract: The goal of this paper is to introduce a simple verifiable secret sharing scheme, to improve the efficiency of known secure multiparty protocols and, by employing these techniques, to improve the efficiency of applications which use these protocols. First we present a very simple Verifiable Secret Sharing protocol which is based on fast cryptographic primitives and avoids altogether the need for expensive zero-knowledge proofs. This is followed by a highly simplified protocol to compute multiplications over shared secrets. This is a major component in secure multiparty computation protocols and accounts for much of the complexity of proposed solutions. Using our protocol as a plug-in unit in known protocols reduces their complexity. We show how to achieve efficient multiparty computations in the computational model, through the application of homomorphic commitments. Finally, we present fast-track multiparty computation protocols. In a model in which malicious faults are rare we show that it is possible to carry out a simpler and more efficient protocol which does not perform all the expensive checks needed to combat a malicious adversary from foiling the computation. Yet, the protocol still enables detection of faults and recovers the computation when faults occur without giving any information advantage to the adversary. This results in protocols which are much more efficient under normal operation of the system i.e. when there are no faults. As an example of the practical impact of our work we show how our techniques can be used to greatly improve the speed and the fault-tolerance of existing threshold cryptography protocols. 
Abstract-found: 1
Intro-found: 1
Reference: [BB89] <author> J. Bar-Ilan and D. Beaver. </author> <title> Non-cryptographic fault-tolerant computing in a constant number of rounds. </title> <booktitle> In Proc. 8th ACM Symp. on Principles of Distributed Computati on, </booktitle> <pages> pages 201-209. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference: [Bea89] <author> D. Beaver. </author> <title> Multiparty Protocols Tolerating Half Faulty Processors. </title> <editor> In G. Brassard, editor, </editor> <booktitle> Advances in Cryptology | Crypto '89, </booktitle> <pages> pages 560-572, </pages> <address> Berlin, </address> <year> 1989. </year> <note> Springer-Verlag. Lecture Notes in Computer Science No. 435. </note>
Reference: [Bea91] <author> D. Beaver. </author> <title> Foundations of secure interactive computing. </title> <editor> In J. Feigenbaum, editor, </editor> <booktitle> Advances in Cryptology | Crypto '91, </booktitle> <pages> pages 377-391, </pages> <address> Berlin, </address> <year> 1991. </year> <note> Springer-Verlag. Lecture Notes in Computer Science No. 576. </note>
Reference-contexts: The adversary we consider is static i.e. it decides which players to corrupt at the beginning of the computation. Also our adversary is computationally unbounded. We follow formal definitions of VSS and secure multiparty computations that have appeared in several papers <ref> [FM, MR91, Bea91, CFGN96, Can95] </ref>. Remark. Because of space limitations, formal definitions and proofs have been omitted from this abstract.
Reference: [BGW88] <author> M. Ben-Or, S. Goldwasser, and A. Wigderson. </author> <title> Completeness Theorems for Noncryptographic Fault-Tolerant Distributed Computations. </title> <booktitle> In Proc. 20th Annual Symp. on the Theory of Computing, </booktitle> <pages> pages 1-10. </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference-contexts: From the introduction of public-key cryptography [DH76, RSA78], to the invention of zero-knowledge proofs [GMR89], to the definition of the problem of secure multiparty computation and the somewhat surprising proof that any multiparty computation can be performed securely <ref> [Yao82, GMW87, BGW88, CCD88] </ref>. The combination of these results is extremely powerful, as they show that virtually any cryptographic problem can be solved under some reasonable appropriate assumptions. Although theoretically impressive, these results lack in the area of practical feasibility. <p> Although theoretically impressive, these results lack in the area of practical feasibility. In today's applications even a simple public-key operation is sometimes considered too slow in comparison to the speed required by the application. Thus, the complicated exchanges of messages and zero-knowledge proofs in protocols like <ref> [Yao82, GMW87, BGW88, CCD88] </ref>, might render them impractical. Thus, it is a high priority to optimize such techniques. Yet, they do provide for a sound basis for our solutions, in particular we will draw heavily on the solution introduced in [BGW88]. <p> Thus, it is a high priority to optimize such techniques. Yet, they do provide for a sound basis for our solutions, in particular we will draw heavily on the solution introduced in <ref> [BGW88] </ref>. We shall concentrate in this paper on the problems of verifiable secret sharing and multiparty computations. The inefficiency of the general secure multiparty protocols is partially caused by the "generality" of the algorithms. Thus, optimization can be achieved in (at least) two ways. <p> Our contribution. The major contributions of this paper can be summarized as follows: * A new simple and efficient design for Verifiable Secret Sharing. * Computational simplifications of the <ref> [BGW88] </ref> proto col * Efficient multiparty computations in the computational model * Expediting computations through the notion of "fast track" * Applying all the above to a specific cryptographic prob lem VSS. The first algorithm we introduce is a very simple and efficient Verifiable Secret Sharing protocol (Section 2). <p> This protocol can be used in any existing multiparty computation protocol. For example when used inside <ref> [BGW88] </ref> it improves the speed of the computation of a multiplication gate by a factor of at least 2. When used inside our general multiparty protocol, gains are even greater. Efficient Protocols Computational Model. We achieve efficient multiparty computations using constructions based on homomorphic commitments. <p> For example in the general multiparty computation of an arithmetic circuit, critical points are placed on multiplications gates. At these gates we need to verify only one VSS compared to, for example, <ref> [BGW88] </ref> where O (n) such VSS's must be checked (at least one for each player). Applications. As an example of the practical impact of our approach, we present its application in the area of threshold cryptography. <p> Tompa and Woll [TW88] and McEliece and Sarwate [MS81] gave the first (partial) solutions for a model with faults. Finally the paper of Chor et al. [CGMA85] defined the complete notion of Verifiable Secret Sharing (VSS), and gave a solution. Under various assumptions, solutions to the problem were given <ref> [CGMA85, GMW91, Fel87, BGW88, CCD88, RB89, Ped91a] </ref>. In order to achieve the goal of verifiability, these protocols deviate from the original solutions' simplicity. They require either heavy computations and/or extensive zero-knowledge proofs of proper conduct. Furthermore, in order to reconstruct the secret there is again a need for extensive computations. <p> This approach is made more efficient in [Fel87, Ped91a] where the dealer publicly commits to the polynomial using some form of "homomorphic" commitment scheme. These commitments in return provide for a simpler proof of the VSPS property. In <ref> [BGW88, CCD88, Rab94] </ref> the model assumes a com-putationally unbounded adversary, disabling the use of encryption. In this case the ZK proof is done via a cut-and-choose approach ([BGW88] also has an alternative construction). <p> In [BGW88, CCD88, Rab94] the model assumes a com-putationally unbounded adversary, disabling the use of encryption. In this case the ZK proof is done via a cut-and-choose approach ([BGW88] also has an alternative construction). Correction of bad shares during recover is done via error-correcting codes <ref> [BGW88, CCD88] </ref> or via a mechanism of mutual authentication [Rab94]. Is there a trend developing in all these solutions which explains why our solution is so simple? The answer is yes. The above mentioned results achieve more than just having the dealer commit to a single value. <p> And indeed there are several applications, such as storing important information for back-up in a distributed fashion on insecure devices, where there is a need only for VSS without the VSPS property. 3 Simplification to Secure Multiparty Computations We consider the problem of secure multiparty computation <ref> [Yao82, GMW87, BGW88, CCD88] </ref>. There are n players Verifiable Secret Sharing Sharing Phase 1. <p> In this section we will describe two simplifications to the <ref> [BGW88] </ref> protocol, and in particular to the multiplication protocol. <p> Given two secrets ff and fi shared by polynomials f ff (x) and f fi (x) respectively of degree t, the players would like to compute the product fffi. In their seminal paper Ben-Or et al. <ref> [BGW88] </ref> note that it is not sufficient for each player to locally multiply his shares of both secrets, as this generates a polynomial whose constant term is the desired one, i.e. fffi; but it is of degree 2t and is not a random polynomial. <p> To overcome this they introduced a degree reduction and randomization protocols. We will show how to achieve both the degree reduction and the randomization in a single step. This building block can be substituted for the multiplication step in the protocol of <ref> [BGW88] </ref>, as it works in the same model of computation. The computation in this section is described under the assumption that all players act properly (as has been said, methods for how to remove this assumption appear in the next section). <p> Denote by f ff (i) and f fi (i) the shares of player P i on f ff (x) and f fi (x) respectively. The product of f ff (x) and 1 This simplification of the multiplication step of <ref> [BGW88] </ref> was discovered by the second author in 1994, and presented by him in class. f fi (x) is f ff (x)f fi (x) = fl 2t x 2t + ::: + fl 1 x + fffi def = f fffi (x). <p> In order to tolerate an active adversary there is a need to verify the actions of the players. <ref> [BGW88] </ref> uses a computa-tionally expensive protocol to do this (which could be combined with Simple-Mult). However, we were able to simplify this protocol as well, and greatly improve its efficiency. The description of our simplification appears in Appendix B. <p> The basic idea is to use a homomorphic commitment (see Section 4.1) to commit to the sharing of the inputs during the VSS. The computation will then follow the <ref> [BGW88] </ref> paradigm. Additions are computed locally by just summing up the shares of the secret values being added. For multiplication we run a robust version of the simplified multiplication protocol Simple-Mult presented above. <p> We further said that this property is needed for the multiparty computations of <ref> [BGW88] </ref>. Thus, if we want to use our VSS for multiparty computations we will first need to reintroduce the VSPS property into our VSS. <p> The full protocol appears in Figure 3 and is denoted Mult. Theorem 4 Under the the discrete log assumption protocol Mult is a secure multiplication protocol in the presence of a computationally bounded active adversary. Plugging the above multiplication protocol into the <ref> [BGW88] </ref> construction one gets a secure multiparty computation protocol for any function F in the computational model.
Reference: [Bla79] <author> G. R. Blakley. </author> <title> Safeguarding cryptographic keys. </title> <booktitle> In Proc. AFIPS 1979 National Computer Conference, </booktitle> <pages> pages 313-317. </pages> <publisher> AFIPS, </publisher> <year> 1979. </year>
Reference-contexts: Remark. Because of space limitations, formal definitions and proofs have been omitted from this abstract. We refer the reader to the final version of the paper [GRR98]. 2 Verifiable Secret Sharing Made Very Simple Since the appearance of Shamir's [Sha79] and Blakley's <ref> [Bla79] </ref> seminal papers on secret sharing which introduced the notion of sharing a secret and gave very simple solutions to the problem, the research on this topic has been extensive. These two solutions worked in the model where there are no faults in the system.
Reference: [Boy89] <editor> C. Boyd. Digital Multisignatures. In H. Baker and F. Piper, editors, </editor> <booktitle> Cryptography and Coding, </booktitle> <pages> pages 241-246. </pages> <publisher> Claredon Press, </publisher> <year> 1989. </year>
Reference-contexts: The complete protocol appears in Appendix D. 6 Threshold Cryptography Applications In recent years it has become evident that one of the most important applications of secure multiparty computation is threshold cryptography <ref> [Boy89, CH89, Des87, Des94] </ref>. Consider for example the cryptographic function of signing which receives as input a secret key and a message, and generates the signature on the message. The signer holding the secret key can easily generate the signature.
Reference: [Can95] <author> Ran Canetti. </author> <title> Studies in Secure Multiparty Computation. </title> <type> PhD thesis, </type> <institution> weizmann Institute of Science, </institution> <year> 1995. </year>
Reference-contexts: The adversary we consider is static i.e. it decides which players to corrupt at the beginning of the computation. Also our adversary is computationally unbounded. We follow formal definitions of VSS and secure multiparty computations that have appeared in several papers <ref> [FM, MR91, Bea91, CFGN96, Can95] </ref>. Remark. Because of space limitations, formal definitions and proofs have been omitted from this abstract.
Reference: [CCD88] <author> D. Chaum, C. Crepeau, and I. Damgard. </author> <title> Multi-party Unconditionally Secure Protocols. </title> <booktitle> In Proc. 20th Annual Symp. on the Theory of Computing, </booktitle> <pages> pages 11-19. </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference-contexts: From the introduction of public-key cryptography [DH76, RSA78], to the invention of zero-knowledge proofs [GMR89], to the definition of the problem of secure multiparty computation and the somewhat surprising proof that any multiparty computation can be performed securely <ref> [Yao82, GMW87, BGW88, CCD88] </ref>. The combination of these results is extremely powerful, as they show that virtually any cryptographic problem can be solved under some reasonable appropriate assumptions. Although theoretically impressive, these results lack in the area of practical feasibility. <p> Although theoretically impressive, these results lack in the area of practical feasibility. In today's applications even a simple public-key operation is sometimes considered too slow in comparison to the speed required by the application. Thus, the complicated exchanges of messages and zero-knowledge proofs in protocols like <ref> [Yao82, GMW87, BGW88, CCD88] </ref>, might render them impractical. Thus, it is a high priority to optimize such techniques. Yet, they do provide for a sound basis for our solutions, in particular we will draw heavily on the solution introduced in [BGW88]. <p> Tompa and Woll [TW88] and McEliece and Sarwate [MS81] gave the first (partial) solutions for a model with faults. Finally the paper of Chor et al. [CGMA85] defined the complete notion of Verifiable Secret Sharing (VSS), and gave a solution. Under various assumptions, solutions to the problem were given <ref> [CGMA85, GMW91, Fel87, BGW88, CCD88, RB89, Ped91a] </ref>. In order to achieve the goal of verifiability, these protocols deviate from the original solutions' simplicity. They require either heavy computations and/or extensive zero-knowledge proofs of proper conduct. Furthermore, in order to reconstruct the secret there is again a need for extensive computations. <p> This approach is made more efficient in [Fel87, Ped91a] where the dealer publicly commits to the polynomial using some form of "homomorphic" commitment scheme. These commitments in return provide for a simpler proof of the VSPS property. In <ref> [BGW88, CCD88, Rab94] </ref> the model assumes a com-putationally unbounded adversary, disabling the use of encryption. In this case the ZK proof is done via a cut-and-choose approach ([BGW88] also has an alternative construction). <p> In [BGW88, CCD88, Rab94] the model assumes a com-putationally unbounded adversary, disabling the use of encryption. In this case the ZK proof is done via a cut-and-choose approach ([BGW88] also has an alternative construction). Correction of bad shares during recover is done via error-correcting codes <ref> [BGW88, CCD88] </ref> or via a mechanism of mutual authentication [Rab94]. Is there a trend developing in all these solutions which explains why our solution is so simple? The answer is yes. The above mentioned results achieve more than just having the dealer commit to a single value. <p> And indeed there are several applications, such as storing important information for back-up in a distributed fashion on insecure devices, where there is a need only for VSS without the VSPS property. 3 Simplification to Secure Multiparty Computations We consider the problem of secure multiparty computation <ref> [Yao82, GMW87, BGW88, CCD88] </ref>. There are n players Verifiable Secret Sharing Sharing Phase 1. <p> For multiplication we run a robust version of the simplified multiplication protocol Simple-Mult presented above. But we will use the public commitments over the inputs to enforce correct behavior on the part of the players. This idea originated in <ref> [CCD88] </ref> in the information-theoretic model, where such "commitments" were achieved by a second layer of input sharings. In the cryptographic model we use homomorphic commitments to generate the same effect. Some of these techniques have been independently devised by [CDM97], yet they use them in the context of span programs.
Reference: [CD97] <author> R. Cramer and I. Damgard. </author> <title> Zero-knowledge for finite field arithmetic or: Can zero-knowledge be for free? Manuscript, </title> <year> 1997. </year>
Reference-contexts: Homomorphic commitments based on general computational assumptions have been recently introduced and studied by Cramer and Damgard <ref> [CD97] </ref>. The ZK proof in Appendix C is also due to them. For simplicity of exposition we will use a specific commitment scheme due to Pedersen described below. However the reader should keep in mind that any of the commitments in [CD97] will do. <p> been recently introduced and studied by Cramer and Damgard <ref> [CD97] </ref>. The ZK proof in Appendix C is also due to them. For simplicity of exposition we will use a specific commitment scheme due to Pedersen described below. However the reader should keep in mind that any of the commitments in [CD97] will do. Let p and q be primes such that p = q + 1, let g be an element of order q in Z fl p and h = g z mod p. The value z is chosen at random and is unknown to the dealer and players.
Reference: [CDM97] <author> R. Cramer, I. Damgard, and U. Maurer. </author> <title> Span programs and general multiparty computations. </title> <type> Manuscript, </type> <year> 1997. </year>
Reference-contexts: Efficient Protocols Computational Model. We achieve efficient multiparty computations using constructions based on homomorphic commitments. These commitments have been used for the problem of verifiable secret sharing, by Feldman and Pedersen [Fel87, Ped91a], who exhibit efficient VSS protocols. Some of these techniques have been independently devised by <ref> [CDM97] </ref>, yet they use them in the context of span programs. Fast-track. Secure multiparty protocols pay a heavy cost in terms of communication/computation in order to guarantee robustness against malicious adversaries who may cause players to behave arbitrarily during the protocol. <p> This idea originated in [CCD88] in the information-theoretic model, where such "commitments" were achieved by a second layer of input sharings. In the cryptographic model we use homomorphic commitments to generate the same effect. Some of these techniques have been independently devised by <ref> [CDM97] </ref>, yet they use them in the context of span programs. In the following sections we will concentrate on the multiplication protocol.
Reference: [CFGN96] <author> Ran Canetti, Uri Feige, Oded Goldreich, and Moni Naor. </author> <title> Adaptively secure multi-party computation. </title> <booktitle> In Proc. 28th Annual Symp. on the Theory of Computing, </booktitle> <pages> pages 639-648. </pages> <publisher> ACM, </publisher> <year> 1996. </year>
Reference-contexts: The adversary we consider is static i.e. it decides which players to corrupt at the beginning of the computation. Also our adversary is computationally unbounded. We follow formal definitions of VSS and secure multiparty computations that have appeared in several papers <ref> [FM, MR91, Bea91, CFGN96, Can95] </ref>. Remark. Because of space limitations, formal definitions and proofs have been omitted from this abstract.
Reference: [CGMA85] <author> B. Chor, S. Goldwasser, S. Micali, and B. Awer-buch. </author> <title> Verifiable Secret Sharing and Achieving Simultaneity in the Presence of Faults. </title> <booktitle> In Proceeding 26th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 383-395. </pages> <publisher> IEEE, </publisher> <year> 1985. </year>
Reference-contexts: These two solutions worked in the model where there are no faults in the system. Tompa and Woll [TW88] and McEliece and Sarwate [MS81] gave the first (partial) solutions for a model with faults. Finally the paper of Chor et al. <ref> [CGMA85] </ref> defined the complete notion of Verifiable Secret Sharing (VSS), and gave a solution. Under various assumptions, solutions to the problem were given [CGMA85, GMW91, Fel87, BGW88, CCD88, RB89, Ped91a]. In order to achieve the goal of verifiability, these protocols deviate from the original solutions' simplicity. <p> Tompa and Woll [TW88] and McEliece and Sarwate [MS81] gave the first (partial) solutions for a model with faults. Finally the paper of Chor et al. [CGMA85] defined the complete notion of Verifiable Secret Sharing (VSS), and gave a solution. Under various assumptions, solutions to the problem were given <ref> [CGMA85, GMW91, Fel87, BGW88, CCD88, RB89, Ped91a] </ref>. In order to achieve the goal of verifiability, these protocols deviate from the original solutions' simplicity. They require either heavy computations and/or extensive zero-knowledge proofs of proper conduct. Furthermore, in order to reconstruct the secret there is again a need for extensive computations. <p> During the recover phase each player has to compute the hash n times. No costly modular exponentiations or complex ZK proofs are required. 2.2 Previous approaches Almost all the VSS protocols in the literature (with the curious exception of the first one <ref> [CGMA85] </ref>) are based on Shamir's protocol. On top of that they add some proof from the dealer that the values shared lie on a polynomial of degree t, thus ensuring that the shares identify a unique secret.
Reference: [CH89] <author> R. A. Croft and S. P. Harris. </author> <title> Public-key cryptography and re-usable shared secrets. </title> <editor> In H. Baker and F. Piper, editors, </editor> <booktitle> Cryptography and Coding, </booktitle> <pages> pages 189-201. </pages> <publisher> Claredon Press, </publisher> <year> 1989. </year>
Reference-contexts: The complete protocol appears in Appendix D. 6 Threshold Cryptography Applications In recent years it has become evident that one of the most important applications of secure multiparty computation is threshold cryptography <ref> [Boy89, CH89, Des87, Des94] </ref>. Consider for example the cryptographic function of signing which receives as input a secret key and a message, and generates the signature on the message. The signer holding the secret key can easily generate the signature.
Reference: [CMI93] <author> M. Cerecedo, T. Matsumoto, and H. Imai. </author> <title> Efficient and secure multiparty generation of digital signatures based on discrete logarithms. </title> <journal> IEICE Trans. Fundamentals, </journal> <volume> E76-A(4):532-545, </volume> <year> 1993. </year>
Reference-contexts: Threshold cryptography is indeed the study of efficient multiparty computation protocols for cryptographic functions (e.g. signing or decrypting) in which each party has as input a share of the secret key that allows the computation of such function. Examples of threshold cryptography protocols can be found in <ref> [DF91, DF89, CMI93, Har94, DDFY94, PK96, GJKR96b, FGY96, GJKR96a, JY] </ref>. The above cited protocols use, in various ways, expensive VSS protocols and zero-knowledge proofs. Though some are more efficient than others there is still room and need for improvement.
Reference: [CW79] <author> J.L. Carter and M.N. Wegman. </author> <title> Universal Classes of Hash Functions. </title> <journal> JCSS, vol.18, </journal> <volume> pp.143-154, </volume> <year> 1979. </year>
Reference: [DDFY94] <author> Alfredo De Santis, Yvo Desmedt, Yair Frankel, and Moti Yung. </author> <title> How to share a function securely. </title> <booktitle> In Proc. 26th Annual Symp. on the Theory of Computing, </booktitle> <pages> pages 522-533. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference-contexts: Threshold cryptography is indeed the study of efficient multiparty computation protocols for cryptographic functions (e.g. signing or decrypting) in which each party has as input a share of the secret key that allows the computation of such function. Examples of threshold cryptography protocols can be found in <ref> [DF91, DF89, CMI93, Har94, DDFY94, PK96, GJKR96b, FGY96, GJKR96a, JY] </ref>. The above cited protocols use, in various ways, expensive VSS protocols and zero-knowledge proofs. Though some are more efficient than others there is still room and need for improvement.
Reference: [Des87] <author> Yvo Desmedt. </author> <title> Society and group oriented cryptography: A new concept. </title> <editor> In C. Pomerance, editor, </editor> <booktitle> Advances in Cryptology | Crypto '87, </booktitle> <pages> pages 120-127, </pages> <address> Berlin, </address> <year> 1987. </year> <note> Springer-Verlag. Lecture Notes in Computer Science No. 293. </note>
Reference-contexts: The complete protocol appears in Appendix D. 6 Threshold Cryptography Applications In recent years it has become evident that one of the most important applications of secure multiparty computation is threshold cryptography <ref> [Boy89, CH89, Des87, Des94] </ref>. Consider for example the cryptographic function of signing which receives as input a secret key and a message, and generates the signature on the message. The signer holding the secret key can easily generate the signature.
Reference: [Des94] <author> Yvo G. Desmedt. </author> <title> Threshold cryptography. </title> <journal> European Transactions on Telecommunications, </journal> <volume> 5(4) </volume> <pages> 449-457, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: The complete protocol appears in Appendix D. 6 Threshold Cryptography Applications In recent years it has become evident that one of the most important applications of secure multiparty computation is threshold cryptography <ref> [Boy89, CH89, Des87, Des94] </ref>. Consider for example the cryptographic function of signing which receives as input a secret key and a message, and generates the signature on the message. The signer holding the secret key can easily generate the signature.
Reference: [DF89] <editor> Yvo Desmedt and Yair Frankel. Threshold cryp--tosystems. In G. Brassard, editor, </editor> <booktitle> Advances in Cryptology | Crypto '89, </booktitle> <pages> pages 307-315, </pages> <address> Berlin, </address> <year> 1989. </year> <note> Springer-Verlag. Lecture Notes in Computer Science No. 435. </note>
Reference-contexts: Threshold cryptography is indeed the study of efficient multiparty computation protocols for cryptographic functions (e.g. signing or decrypting) in which each party has as input a share of the secret key that allows the computation of such function. Examples of threshold cryptography protocols can be found in <ref> [DF91, DF89, CMI93, Har94, DDFY94, PK96, GJKR96b, FGY96, GJKR96a, JY] </ref>. The above cited protocols use, in various ways, expensive VSS protocols and zero-knowledge proofs. Though some are more efficient than others there is still room and need for improvement.
Reference: [DF91] <author> Y. Desmedt and Y. Frankel. </author> <title> Shared generation of authenticators and signatures. </title> <editor> In J. Feigenbaum, editor, </editor> <booktitle> Advances in Cryptology | Crypto '91, </booktitle> <pages> pages 457-469, </pages> <address> Berlin, </address> <year> 1991. </year> <note> Springer-Verlag. Lecture Notes in Computer Science No. 576. </note>
Reference-contexts: Threshold cryptography is indeed the study of efficient multiparty computation protocols for cryptographic functions (e.g. signing or decrypting) in which each party has as input a share of the secret key that allows the computation of such function. Examples of threshold cryptography protocols can be found in <ref> [DF91, DF89, CMI93, Har94, DDFY94, PK96, GJKR96b, FGY96, GJKR96a, JY] </ref>. The above cited protocols use, in various ways, expensive VSS protocols and zero-knowledge proofs. Though some are more efficient than others there is still room and need for improvement.
Reference: [DH76] <author> W. Diffie and M. E. Hellman. </author> <title> New Directions in Cryptography. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 22(6) </volume> <pages> 644-654, </pages> <year> 1976. </year>
Reference-contexts: 1 Introduction The past twenty years have witnessed an exciting development of research in the area of cryptography and network security. From the introduction of public-key cryptography <ref> [DH76, RSA78] </ref>, to the invention of zero-knowledge proofs [GMR89], to the definition of the problem of secure multiparty computation and the somewhat surprising proof that any multiparty computation can be performed securely [Yao82, GMW87, BGW88, CCD88].
Reference: [DPP96] <author> I. Damgard, T.P. Pedersen and B. Pfitzmann. </author> <title> On the existence of Statistically Hiding Bit Commitment Schemes and Fail-Stop Signatures J. </title> <journal> of Cryptology, </journal> <note> vol.10, no.4, pp.163-194. See also Statistical Secrecy and Multi-Bit Commitments. BRICS report series, RS-96-45, available from http://www.brics.dk </note>
Reference-contexts: Theorem 1 If C is a homomorphic commitment (see Section 4.1) then protocol New-VSS in Figure 1 is a VSS protocol. All the homomorphic commitment schemes we know are based on modular arithmetic over large numbers. We devised a new commitment scheme, based on <ref> [DPP96] </ref>, which uses only collision-resistant hash functions and when used inside New-VSS yields a provably secure VSS protocol. The scheme is described in Appendix A. Theorem 2 The protocol MD-VSS in Appendix A is a VSS protocol. Efficiency. We would like to stress the efficiency of MD-VSS. <p> We stress that our new protocol can be proven secure under the sole assumption of the unforgeability of DSS signatures. Acknowledgments We would like to thank Hugo Krawczyk for countless suggestions on earlier versions of this paper and Ivan Damgard for suggesting the use of the <ref> [DPP96] </ref> provably secure commitments in our protocol New-VSS. We also thank: Ran Canetti, Ronald Cramer, Juan Garay, Shai Halevi, Amir Herzberg, Ueli Maurer, Moni Naor and Victor Shoup for useful discussions.
Reference: [ElG85] <author> T. ElGamal. </author> <title> A public key cryptosystem and a signature scheme based on discrete logarithms. </title> <journal> IEEE Trans. Info. Theory, </journal> <volume> IT 31, </volume> <year> 1985. </year>
Reference: [Fel87] <author> P. Feldman. </author> <title> A Practical Scheme for Non-Interactive Verifiable Secret Sharing. </title> <booktitle> In Proc. 28th Annual Symp. on Foundations of Computer Science, </booktitle> <pages> pages 427-437. </pages> <publisher> IEEE, </publisher> <year> 1987. </year>
Reference-contexts: When used inside our general multiparty protocol, gains are even greater. Efficient Protocols Computational Model. We achieve efficient multiparty computations using constructions based on homomorphic commitments. These commitments have been used for the problem of verifiable secret sharing, by Feldman and Pedersen <ref> [Fel87, Ped91a] </ref>, who exhibit efficient VSS protocols. Some of these techniques have been independently devised by [CDM97], yet they use them in the context of span programs. Fast-track. <p> Tompa and Woll [TW88] and McEliece and Sarwate [MS81] gave the first (partial) solutions for a model with faults. Finally the paper of Chor et al. [CGMA85] defined the complete notion of Verifiable Secret Sharing (VSS), and gave a solution. Under various assumptions, solutions to the problem were given <ref> [CGMA85, GMW91, Fel87, BGW88, CCD88, RB89, Ped91a] </ref>. In order to achieve the goal of verifiability, these protocols deviate from the original solutions' simplicity. They require either heavy computations and/or extensive zero-knowledge proofs of proper conduct. Furthermore, in order to reconstruct the secret there is again a need for extensive computations. <p> In [GMW91] the shares are encrypted and then the VSPS property is proven via a "generic" zero-knowledge (ZK) proof of an NP-complete problem. The public knowledge of the encrypted shares also prevents bad players from contributing bad shares during reconstruction. This approach is made more efficient in <ref> [Fel87, Ped91a] </ref> where the dealer publicly commits to the polynomial using some form of "homomorphic" commitment scheme. These commitments in return provide for a simpler proof of the VSPS property. In [BGW88, CCD88, Rab94] the model assumes a com-putationally unbounded adversary, disabling the use of encryption. <p> It is well known that in this model there exist VSS protocols due to Feldman <ref> [Fel87] </ref> and Pedersen [Ped91a] which are quite efficient and require limited interaction. We will show that is possible to use this kind of VSS protocols, including our New-VSS, to perform multiparty computations efficiently.
Reference: [FGY96] <author> Y. Frankel, P. Gemmell, and M. Yung. </author> <title> Witness-based Cryptographic Program Checking and Robust Function Sharing. </title> <booktitle> In Proc. 28th Annual Symp. on the Theory of Computing, </booktitle> <pages> pages 499-508. </pages> <publisher> ACM, </publisher> <year> 1996. </year>
Reference-contexts: Threshold cryptography is indeed the study of efficient multiparty computation protocols for cryptographic functions (e.g. signing or decrypting) in which each party has as input a share of the secret key that allows the computation of such function. Examples of threshold cryptography protocols can be found in <ref> [DF91, DF89, CMI93, Har94, DDFY94, PK96, GJKR96b, FGY96, GJKR96a, JY] </ref>. The above cited protocols use, in various ways, expensive VSS protocols and zero-knowledge proofs. Though some are more efficient than others there is still room and need for improvement.
Reference: [FM] <author> P. Feldman and S. Micali. </author> <title> A Definition of Verifiable Secret Sharing. An adaptation from [FM88]. </title>
Reference-contexts: The adversary we consider is static i.e. it decides which players to corrupt at the beginning of the computation. Also our adversary is computationally unbounded. We follow formal definitions of VSS and secure multiparty computations that have appeared in several papers <ref> [FM, MR91, Bea91, CFGN96, Can95] </ref>. Remark. Because of space limitations, formal definitions and proofs have been omitted from this abstract.
Reference: [FM88] <author> P. Feldman and S. Micali. </author> <title> An Optimal Algorithm for Synchronous Byzantine Agreement. </title> <booktitle> In Proc. 20th Annual Symp. on the Theory of Computing, </booktitle> <pages> pages 148-161. </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference: [FY92] <author> M. Franklin and M. Yung. </author> <title> Communication complexity of secure computation. </title> <booktitle> In Proc. 24th Annual Symp. on the Theory of Computing, </booktitle> <pages> pages 699-710. </pages> <publisher> ACM, </publisher> <year> 1992. </year>
Reference-contexts: In this case one cannot rule out malicious faults (and thus cannot blindly use the simpler private protocols), but on the other hand would like to take advantage in some way of the fact that faults are rare. This model was also considered in <ref> [FY92] </ref>. We would like to build on the efficiency of private protocols, which operate under the assumption that no faults occur, while avoiding the trap of assuming that you can execute the private computation until a fault occurs and then re-compute. <p> Indeed such a computation might turn out to be insecure, and expose secret information. This model also appears in <ref> [FY92] </ref>. We call it fast-track computation. Thus at this point we introduce a fast-track version of our multiparty computation protocol. Our idea is to avoid carrying out all the verification steps, but rather to identify "critical" verification points. Only at these critical points some verification will be carried out.
Reference: [GJKR96a] <author> R. Gennaro, S. Jarecki, H. Krawczyk, and T. Ra-bin. </author> <title> Robust and efficient sharing of RSA functions. </title> <editor> In N. Koblitz, editor, </editor> <booktitle> Advances in Cryptology | Crypto '96, </booktitle> <pages> pages 157-172, </pages> <address> Berlin, </address> <year> 1996. </year> <note> Springer-Verlag. Lecture Notes in Computer Science No. 1109. </note>
Reference-contexts: Threshold cryptography is indeed the study of efficient multiparty computation protocols for cryptographic functions (e.g. signing or decrypting) in which each party has as input a share of the secret key that allows the computation of such function. Examples of threshold cryptography protocols can be found in <ref> [DF91, DF89, CMI93, Har94, DDFY94, PK96, GJKR96b, FGY96, GJKR96a, JY] </ref>. The above cited protocols use, in various ways, expensive VSS protocols and zero-knowledge proofs. Though some are more efficient than others there is still room and need for improvement.
Reference: [GJKR96b] <author> R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin. </author> <title> Robust threshold DSS signatures. </title> <editor> In Ueli Maurer, editor, </editor> <booktitle> Advances in Cryptology | Eurocrypt '96, </booktitle> <pages> pages 354-371, </pages> <address> Berlin, </address> <year> 1996. </year> <note> Springer-Verlag. Lecture Notes in Computer Science No. 1070. </note>
Reference-contexts: Applications. As an example of the practical impact of our approach, we present its application in the area of threshold cryptography. We show that existing threshold signature protocols can be greatly enhanced in speed using our techniques. We exemplify this over the threshold DSS protocol of <ref> [GJKR96b] </ref>. The improvements are quite substantial. We improve the fault-tolerance from n=4 to n=2 without increasing the communication or the computational complexity, thanks to our simplified VSS and multiplication protocols. <p> We also present a fast-track version of the protocol where the exponentiation requirement from each server is a factor of n less than a fully fault-tolerant protocol (e.g. in <ref> [GJKR96b] </ref>) (see Section 6). Model and Definitions. We consider a synchronous model with private channels and broadcast (e.g.[RB89, Bea89]). The parties engage in a distributed computation, following a protocol , in order to evaluate F (x 1 ; :::; x n ). <p> Threshold cryptography is indeed the study of efficient multiparty computation protocols for cryptographic functions (e.g. signing or decrypting) in which each party has as input a share of the secret key that allows the computation of such function. Examples of threshold cryptography protocols can be found in <ref> [DF91, DF89, CMI93, Har94, DDFY94, PK96, GJKR96b, FGY96, GJKR96a, JY] </ref>. The above cited protocols use, in various ways, expensive VSS protocols and zero-knowledge proofs. Though some are more efficient than others there is still room and need for improvement. <p> Our techniques can be readily applied to this scenario to obtain much more efficient protocols. In the final paper we present a specific application of our techniques to the robust threshold DSS protocol of Gennaro e tal <ref> [GJKR96b] </ref>. <p> Security. Formal definitions of security for threshold signature protocols can be found in <ref> [GJKR96b] </ref>. We stress that our new protocol can be proven secure under the sole assumption of the unforgeability of DSS signatures.
Reference: [GMR89] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The knowledge complexity of interactive proof-systems. </title> <journal> SIAM. J. Computing, </journal> <volume> 18(1) </volume> <pages> 186-208, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: 1 Introduction The past twenty years have witnessed an exciting development of research in the area of cryptography and network security. From the introduction of public-key cryptography [DH76, RSA78], to the invention of zero-knowledge proofs <ref> [GMR89] </ref>, to the definition of the problem of secure multiparty computation and the somewhat surprising proof that any multiparty computation can be performed securely [Yao82, GMW87, BGW88, CCD88].
Reference: [GMW87] <author> O. Goldreich, S. Micali, and A. Wigderson. </author> <title> How to Play Any Mental Game. </title> <booktitle> In Proc. 19th Annual Symp. on the Theory of Computing, </booktitle> <pages> pages 218-229. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: From the introduction of public-key cryptography [DH76, RSA78], to the invention of zero-knowledge proofs [GMR89], to the definition of the problem of secure multiparty computation and the somewhat surprising proof that any multiparty computation can be performed securely <ref> [Yao82, GMW87, BGW88, CCD88] </ref>. The combination of these results is extremely powerful, as they show that virtually any cryptographic problem can be solved under some reasonable appropriate assumptions. Although theoretically impressive, these results lack in the area of practical feasibility. <p> Although theoretically impressive, these results lack in the area of practical feasibility. In today's applications even a simple public-key operation is sometimes considered too slow in comparison to the speed required by the application. Thus, the complicated exchanges of messages and zero-knowledge proofs in protocols like <ref> [Yao82, GMW87, BGW88, CCD88] </ref>, might render them impractical. Thus, it is a high priority to optimize such techniques. Yet, they do provide for a sound basis for our solutions, in particular we will draw heavily on the solution introduced in [BGW88]. <p> And indeed there are several applications, such as storing important information for back-up in a distributed fashion on insecure devices, where there is a need only for VSS without the VSPS property. 3 Simplification to Secure Multiparty Computations We consider the problem of secure multiparty computation <ref> [Yao82, GMW87, BGW88, CCD88] </ref>. There are n players Verifiable Secret Sharing Sharing Phase 1.
Reference: [GMW91] <author> O. Goldreich, S. Micali, and A. Wigderson. </author> <title> Proofs that Yield Nothing But Their Validity or All Languages in NP Have Zero-Knowledge Proof Systems . Journal of the ACM, </title> <booktitle> 38(1) </booktitle> <pages> 691-729, </pages> <year> 1991. </year>
Reference-contexts: Tompa and Woll [TW88] and McEliece and Sarwate [MS81] gave the first (partial) solutions for a model with faults. Finally the paper of Chor et al. [CGMA85] defined the complete notion of Verifiable Secret Sharing (VSS), and gave a solution. Under various assumptions, solutions to the problem were given <ref> [CGMA85, GMW91, Fel87, BGW88, CCD88, RB89, Ped91a] </ref>. In order to achieve the goal of verifiability, these protocols deviate from the original solutions' simplicity. They require either heavy computations and/or extensive zero-knowledge proofs of proper conduct. Furthermore, in order to reconstruct the secret there is again a need for extensive computations. <p> On top of that they add some proof from the dealer that the values shared lie on a polynomial of degree t, thus ensuring that the shares identify a unique secret. We refer to this property as the VSPS property, which will be defined more rigorously later. In <ref> [GMW91] </ref> the shares are encrypted and then the VSPS property is proven via a "generic" zero-knowledge (ZK) proof of an NP-complete problem. The public knowledge of the encrypted shares also prevents bad players from contributing bad shares during reconstruction.
Reference: [GRR98] <author> R. Gennaro, M.O. Rabin and T. Rabin. </author> <title> Simplified VSS and Fast-track Multiparty Computations with Applications to Threshold Cryptography. </title> <note> Final version. Available on-line at www.research.ibm.com/security/grr.ps </note>
Reference-contexts: We follow formal definitions of VSS and secure multiparty computations that have appeared in several papers [FM, MR91, Bea91, CFGN96, Can95]. Remark. Because of space limitations, formal definitions and proofs have been omitted from this abstract. We refer the reader to the final version of the paper <ref> [GRR98] </ref>. 2 Verifiable Secret Sharing Made Very Simple Since the appearance of Shamir's [Sha79] and Blakley's [Bla79] seminal papers on secret sharing which introduced the notion of sharing a secret and gave very simple solutions to the problem, the research on this topic has been extensive.
Reference: [Har94] <author> L. Harn. </author> <title> Group oriented (t,n) digital signature scheme. </title> <journal> IEEE Proc.-Comput.Digit.Tech, </journal> <volume> 141(5) </volume> <pages> 307-313, </pages> <month> Sept </month> <year> 1994. </year>
Reference-contexts: Threshold cryptography is indeed the study of efficient multiparty computation protocols for cryptographic functions (e.g. signing or decrypting) in which each party has as input a share of the secret key that allows the computation of such function. Examples of threshold cryptography protocols can be found in <ref> [DF91, DF89, CMI93, Har94, DDFY94, PK96, GJKR96b, FGY96, GJKR96a, JY] </ref>. The above cited protocols use, in various ways, expensive VSS protocols and zero-knowledge proofs. Though some are more efficient than others there is still room and need for improvement.
Reference: [JY] <author> Markus Jakobsson and Moti Yung. </author> <title> Distributed "magic ink" signatures. </title> <note> To appear in EuroCrypt97. </note>
Reference-contexts: Threshold cryptography is indeed the study of efficient multiparty computation protocols for cryptographic functions (e.g. signing or decrypting) in which each party has as input a share of the secret key that allows the computation of such function. Examples of threshold cryptography protocols can be found in <ref> [DF91, DF89, CMI93, Har94, DDFY94, PK96, GJKR96b, FGY96, GJKR96a, JY] </ref>. The above cited protocols use, in various ways, expensive VSS protocols and zero-knowledge proofs. Though some are more efficient than others there is still room and need for improvement.
Reference: [Lan95] <author> S. Langford. </author> <title> Threshold dss signatures without a trusted party. </title> <editor> In D. Coppersmith, editor, </editor> <booktitle> Advances in Cryptology | Crypto '95, </booktitle> <pages> pages 397-409, </pages> <address> Berlin, </address> <year> 1995. </year> <note> Springer-Verlag. Lecture Notes in Computer Science No. 963. </note>
Reference: [MR91] <author> S. Micali and P. Rogaway. </author> <title> Secure computation. </title> <editor> In J. Feigenbaum, editor, </editor> <booktitle> Advances in Cryptology | Crypto '91, </booktitle> <pages> pages 392-404, </pages> <address> Berlin, </address> <year> 1991. </year> <note> Springer-Verlag. Lecture Notes in Computer Science No. 576. </note>
Reference-contexts: The adversary we consider is static i.e. it decides which players to corrupt at the beginning of the computation. Also our adversary is computationally unbounded. We follow formal definitions of VSS and secure multiparty computations that have appeared in several papers <ref> [FM, MR91, Bea91, CFGN96, Can95] </ref>. Remark. Because of space limitations, formal definitions and proofs have been omitted from this abstract.
Reference: [MS81] <author> R. J. McEliece and D. V. Sarwate. </author> <title> On Sharing Secrets and Reed-Solomon Codes. </title> <journal> Communications of the ACM, </journal> <volume> 24 </volume> <pages> 583-584, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: These two solutions worked in the model where there are no faults in the system. Tompa and Woll [TW88] and McEliece and Sarwate <ref> [MS81] </ref> gave the first (partial) solutions for a model with faults. Finally the paper of Chor et al. [CGMA85] defined the complete notion of Verifiable Secret Sharing (VSS), and gave a solution. Under various assumptions, solutions to the problem were given [CGMA85, GMW91, Fel87, BGW88, CCD88, RB89, Ped91a].
Reference: [NIST91] <institution> National Institute for Standards and Technology. Digital Signature Standard (DSS). </institution> <type> Technical Report 169, </type> <month> August 30 </month> <year> 1991. </year>
Reference: [PK96] <author> C. Park, and K. Kurosawa. </author> <title> New ElGamal Type Threshold Digital Signature Scheme. </title> <journal> IEICE Trans. Fundamentals, </journal> <volume> E79-A(1):86-93, </volume> <month> January </month> <year> 1996. </year>
Reference-contexts: Threshold cryptography is indeed the study of efficient multiparty computation protocols for cryptographic functions (e.g. signing or decrypting) in which each party has as input a share of the secret key that allows the computation of such function. Examples of threshold cryptography protocols can be found in <ref> [DF91, DF89, CMI93, Har94, DDFY94, PK96, GJKR96b, FGY96, GJKR96a, JY] </ref>. The above cited protocols use, in various ways, expensive VSS protocols and zero-knowledge proofs. Though some are more efficient than others there is still room and need for improvement.
Reference: [Ped91a] <author> T. Pedersen. </author> <title> Non-interactive and information-theoretic secure verifiable secret sharing. </title> <editor> In J. Feigenbaum, editor, </editor> <booktitle> Advances in Cryptology | Crypto '91, </booktitle> <pages> pages 129-140, </pages> <address> Berlin, </address> <year> 1991. </year> <note> Springer-Verlag. Lecture Notes in Computer Science No. 576. </note>
Reference-contexts: When used inside our general multiparty protocol, gains are even greater. Efficient Protocols Computational Model. We achieve efficient multiparty computations using constructions based on homomorphic commitments. These commitments have been used for the problem of verifiable secret sharing, by Feldman and Pedersen <ref> [Fel87, Ped91a] </ref>, who exhibit efficient VSS protocols. Some of these techniques have been independently devised by [CDM97], yet they use them in the context of span programs. Fast-track. <p> Tompa and Woll [TW88] and McEliece and Sarwate [MS81] gave the first (partial) solutions for a model with faults. Finally the paper of Chor et al. [CGMA85] defined the complete notion of Verifiable Secret Sharing (VSS), and gave a solution. Under various assumptions, solutions to the problem were given <ref> [CGMA85, GMW91, Fel87, BGW88, CCD88, RB89, Ped91a] </ref>. In order to achieve the goal of verifiability, these protocols deviate from the original solutions' simplicity. They require either heavy computations and/or extensive zero-knowledge proofs of proper conduct. Furthermore, in order to reconstruct the secret there is again a need for extensive computations. <p> In [GMW91] the shares are encrypted and then the VSPS property is proven via a "generic" zero-knowledge (ZK) proof of an NP-complete problem. The public knowledge of the encrypted shares also prevents bad players from contributing bad shares during reconstruction. This approach is made more efficient in <ref> [Fel87, Ped91a] </ref> where the dealer publicly commits to the polynomial using some form of "homomorphic" commitment scheme. These commitments in return provide for a simpler proof of the VSPS property. In [BGW88, CCD88, Rab94] the model assumes a com-putationally unbounded adversary, disabling the use of encryption. <p> It is well known that in this model there exist VSS protocols due to Feldman [Fel87] and Pedersen <ref> [Ped91a] </ref> which are quite efficient and require limited interaction. We will show that is possible to use this kind of VSS protocols, including our New-VSS, to perform multiparty computations efficiently. <p> A commitment to a string ff 2 Z q using a random 2 R Z q is the value A = g ff h mod p. It is proven in <ref> [Ped91a] </ref> that this commitment is information-theoretic secure in terms of privacy and can be opened in two different ways only by somebody who can compute z. Polynomial evaluations. Consider a polynomial f (x) = a t x t + ::: + a 1 x + a 0 .
Reference: [Ped91b] <author> T. Pedersen. </author> <title> A threshold cryptosystem without a trusted party. </title> <editor> In D. Davies, editor, </editor> <booktitle> Advances in Cryptology | Eurocrypt '91, </booktitle> <pages> pages 522-526, </pages> <address> Berlin, </address> <year> 1991. </year> <note> Springer-Verlag. Lecture Notes in Computer Science No. 547. </note>
Reference: [Rab94] <author> T. Rabin. </author> <title> Robust Sharing of Secrets When the Dealer is Honest or Faulty. </title> <journal> Journal of the ACM, </journal> <volume> 41(6) </volume> <pages> 1089-1109, </pages> <year> 1994. </year>
Reference-contexts: This approach is made more efficient in [Fel87, Ped91a] where the dealer publicly commits to the polynomial using some form of "homomorphic" commitment scheme. These commitments in return provide for a simpler proof of the VSPS property. In <ref> [BGW88, CCD88, Rab94] </ref> the model assumes a com-putationally unbounded adversary, disabling the use of encryption. In this case the ZK proof is done via a cut-and-choose approach ([BGW88] also has an alternative construction). <p> In this case the ZK proof is done via a cut-and-choose approach ([BGW88] also has an alternative construction). Correction of bad shares during recover is done via error-correcting codes [BGW88, CCD88] or via a mechanism of mutual authentication <ref> [Rab94] </ref>. Is there a trend developing in all these solutions which explains why our solution is so simple? The answer is yes. The above mentioned results achieve more than just having the dealer commit to a single value.
Reference: [RB89] <author> T. Rabin and M. Ben-Or. </author> <title> Verifiable Secret Sharing and Multiparty Protocols with Honest Majority. </title> <booktitle> In Proc. 21st Annual Symp. on the Theory of Computing, </booktitle> <pages> pages 73-85. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Tompa and Woll [TW88] and McEliece and Sarwate [MS81] gave the first (partial) solutions for a model with faults. Finally the paper of Chor et al. [CGMA85] defined the complete notion of Verifiable Secret Sharing (VSS), and gave a solution. Under various assumptions, solutions to the problem were given <ref> [CGMA85, GMW91, Fel87, BGW88, CCD88, RB89, Ped91a] </ref>. In order to achieve the goal of verifiability, these protocols deviate from the original solutions' simplicity. They require either heavy computations and/or extensive zero-knowledge proofs of proper conduct. Furthermore, in order to reconstruct the secret there is again a need for extensive computations.
Reference: [RSA78] <author> Ronald L. Rivest, Adi Shamir, and Leonard M. Adleman. </author> <title> A method for obtaining digital signatures and public-key cryptosystems. </title> <journal> Communication of the ACM, </journal> <volume> 21(2) </volume> <pages> 120-126, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction The past twenty years have witnessed an exciting development of research in the area of cryptography and network security. From the introduction of public-key cryptography <ref> [DH76, RSA78] </ref>, to the invention of zero-knowledge proofs [GMR89], to the definition of the problem of secure multiparty computation and the somewhat surprising proof that any multiparty computation can be performed securely [Yao82, GMW87, BGW88, CCD88].
Reference: [Sch91] <author> C. P. Schnorr. </author> <title> Efficient signature generation by smart cards. </title> <journal> Journal of Cryptology, </journal> <volume> 4 </volume> <pages> 161-174, </pages> <year> 1991. </year>
Reference: [Sha79] <author> A. Shamir. </author> <title> How to Share a Secret. </title> <journal> Communications of the ACM, </journal> <volume> 22 </volume> <pages> 612-613, </pages> <year> 1979. </year>
Reference-contexts: Remark. Because of space limitations, formal definitions and proofs have been omitted from this abstract. We refer the reader to the final version of the paper [GRR98]. 2 Verifiable Secret Sharing Made Very Simple Since the appearance of Shamir's <ref> [Sha79] </ref> and Blakley's [Bla79] seminal papers on secret sharing which introduced the notion of sharing a secret and gave very simple solutions to the problem, the research on this topic has been extensive. These two solutions worked in the model where there are no faults in the system.
Reference: [TW88] <author> M. Tompa and H. Woll. </author> <title> How to share a secret with cheaters. </title> <journal> Journal of Cryptology, </journal> <volume> 1(2) </volume> <pages> 133-138, </pages> <year> 1988. </year>
Reference-contexts: These two solutions worked in the model where there are no faults in the system. Tompa and Woll <ref> [TW88] </ref> and McEliece and Sarwate [MS81] gave the first (partial) solutions for a model with faults. Finally the paper of Chor et al. [CGMA85] defined the complete notion of Verifiable Secret Sharing (VSS), and gave a solution.
Reference: [Yao82] <author> A.C. Yao. </author> <title> Protocols for secure computations. </title> <booktitle> In Proceedings of FOCS'82, </booktitle> <pages> pages 160-164, </pages> <address> Chicago, 1982. </address> <publisher> IEEE. </publisher>
Reference-contexts: From the introduction of public-key cryptography [DH76, RSA78], to the invention of zero-knowledge proofs [GMR89], to the definition of the problem of secure multiparty computation and the somewhat surprising proof that any multiparty computation can be performed securely <ref> [Yao82, GMW87, BGW88, CCD88] </ref>. The combination of these results is extremely powerful, as they show that virtually any cryptographic problem can be solved under some reasonable appropriate assumptions. Although theoretically impressive, these results lack in the area of practical feasibility. <p> Although theoretically impressive, these results lack in the area of practical feasibility. In today's applications even a simple public-key operation is sometimes considered too slow in comparison to the speed required by the application. Thus, the complicated exchanges of messages and zero-knowledge proofs in protocols like <ref> [Yao82, GMW87, BGW88, CCD88] </ref>, might render them impractical. Thus, it is a high priority to optimize such techniques. Yet, they do provide for a sound basis for our solutions, in particular we will draw heavily on the solution introduced in [BGW88]. <p> And indeed there are several applications, such as storing important information for back-up in a distributed fashion on insecure devices, where there is a need only for VSS without the VSPS property. 3 Simplification to Secure Multiparty Computations We consider the problem of secure multiparty computation <ref> [Yao82, GMW87, BGW88, CCD88] </ref>. There are n players Verifiable Secret Sharing Sharing Phase 1.
References-found: 50

