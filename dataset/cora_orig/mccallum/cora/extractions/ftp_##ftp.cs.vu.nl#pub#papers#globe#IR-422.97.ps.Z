URL: ftp://ftp.cs.vu.nl/pub/papers/globe/IR-422.97.ps.Z
Refering-URL: http://www.cs.washington.edu/homes/zives/cse551/proposal.htm
Root-URL: 
Title: The Architectural Design of Globe: A Wide-Area Distributed System  
Author: Maarten van Steen (contact) Philip Homburg Andrew S. Tanenbaum 
Keyword: wide-area systems, distributed systems, distributed objects, Internet, middleware  
Affiliation: Faculty of Mathematics and Computer Science  
Date: March 1997  
Pubnum: Internal report IR-422  
Abstract: Developing large-scale wide-area applications requires an infrastructure that is presently lacking entirely. Currently, applications have to be built on top of raw communication services, such as TCP connections. All additional services, including those for naming, replication, migration, persistence, fault tolerance, and security, have to be implemented for each application anew. Not only is this a waste of effort, it also makes interoperability between different applications difficult or even impossible. We present a novel, object-based framework for developing wide-area distributed applications. The framework is based on the concept of a distributed shared object, which has the characteristic feature that its state can be physically distributed across multiple machines at the same time. All implementation aspects, including communication protocols, replication strategies, and distribution and migration of state, are part of an object and are hidden behind its interface. The current performance problems of the World-Wide Web are taken as an example to illustrate the benefit of encapsulating state, operations, and implementation strategies on a per-object basis. We describe how distributed objects can be used to implement worldwide scalable Web objects. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. Rosenberry, D. Kenney, and G. Fisher. </author> <title> Understanding DCE. </title> <publisher> O'Reilly & Associates, </publisher> <address> Sebastopol, CA., </address> <year> 1992. </year>
Reference-contexts: DCE <ref> [1] </ref>, for example, is designed to support traditional client-server computing using RPCs as the foundation for all communication.
Reference: [2] <author> OMG. </author> <title> The Common Object Request Broker: Architecture and Specification, revision 2.0. OMG Document 96.03.04, </title> <booktitle> Object Management Group, </booktitle> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: DCE [1], for example, is designed to support traditional client-server computing using RPCs as the foundation for all communication. Likewise, CORBA <ref> [2] </ref> 1 Table 1: Different kinds of distribution transparency relevant for distributed systems [4] Transparency Description Access transparency Hides differences in data representation and invocation mechanisms Failure transparency Hides failure and possible recovery of objects Location transparency Hides where an object resides Migration transparency Hides from an object the ability of
Reference: [3] <author> M. Satyanarayanan. </author> <title> Scalable, Secure, and Highly Available Distributed File Access. </title> <journal> Computer, </journal> <volume> 23(5) </volume> <pages> 9-21, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: As another example, AFS <ref> [3] </ref> offers its users a relatively simple way for distributing information by means of a wide-area file system that is based on a location-transparent file name space. Finally, consider the Web.
Reference: [4] <author> ISO. </author> <title> Open Distributed Processing Reference Model Part 3: Architecture. International Standard ISO/IEC IS 10746-3, </title> <year> 1995. </year>
Reference-contexts: DCE [1], for example, is designed to support traditional client-server computing using RPCs as the foundation for all communication. Likewise, CORBA [2] 1 Table 1: Different kinds of distribution transparency relevant for distributed systems <ref> [4] </ref> Transparency Description Access transparency Hides differences in data representation and invocation mechanisms Failure transparency Hides failure and possible recovery of objects Location transparency Hides where an object resides Migration transparency Hides from an object the ability of a system to change that object's location Relocation transparency Hides from a client
Reference: [5] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns, Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA., </address> <year> 1994. </year>
Reference-contexts: These examples show that we need a flexible implementation framework: a set of cooperating mechanisms that make up a reusable design for wide-area distributed applications <ref> [5] </ref>. It is here that an object-based approach will help. By strictly separating an object's interface from its implementation, we can construct reusable designs by considering only interfaces.
Reference: [6] <author> N. Islam. </author> <title> Customizing System Software Using OO Frameworks. </title> <journal> Computer, </journal> <volume> 30(2) </volume> <pages> 69-78, </pages> <month> Feb. </month> <year> 1997. </year>
Reference-contexts: By strictly separating an object's interface from its implementation, we can construct reusable designs by considering only interfaces. A design can be tailored towards a specific application by choosing the appropriate object implementations, and, where necessary, extend the design with other objects <ref> [6] </ref>. This is the approach followed in Globe. 2.3 Worldwide Scalability The most important design issue is scalability. It is conceivable that we may eventually have to support one billion users, each having thousands of objects.
Reference: [7] <author> Microsoft Corporation. </author> <title> The Component Object Model Specification, </title> <note> Version 0.9, </note> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: An interface of a composition refers to methods available at its constituents. More specifically, we implement an interface as an array of (state,method)-pairs of pointers, similar to the approach followed in COM <ref> [7] </ref>. Using such binary (i.e. runtime) interfaces has the advantage that Globe objects are language independent, making runtime adaptations more easy. We normally store code separately in a class object. This is a local object that contains the method implementations for objects belonging to the same class.
Reference: [8] <author> M. van Steen, F. Hauck, and A. Tanenbaum. </author> <title> A Model for Worldwide Tracking of Distributed Objects. </title> <booktitle> In Proc. </booktitle> <volume> TINA '96, </volume> <pages> pp. 203-212, </pages> <address> Heidelberg, Germany, </address> <month> Sept. </month> <year> 1996. </year> <month> Eurescom. </month>
Reference-contexts: We can now remove all location information from names, thus making it easier to realize distribution transparency. However, we do require a scalable location service that can handle frequent updates of contact addresses in an efficient manner. We have designed such a service <ref> [8] </ref> and are currently implementing a prototype version that is being tested on the Internet.
Reference: [9] <author> V. Cate. </author> <title> Alex A Global Filesystem. </title> <booktitle> In Proc. USENIX File Systems Workshop, </booktitle> <pages> pp. 1-11. </pages> <publisher> USENIX, </publisher> <month> May </month> <year> 1992. </year>
Reference-contexts: Consequently, contact must always be made with the page's server, and the page will have to be transferred when the cache entry turns out to be stale. Performance can be improved if a weaker cache coherency protocol is applied. For example, in the Alex global file system <ref> [9] </ref>, a staleness factor is introduced, defined as: staleness = T now T last update T last update T last modification In other words, a page that is 10 days old will be 10% stale after being cached for 1 day.
Reference: [10] <author> D. Wessels. </author> <title> Intelligent Caching for World-Wide Web Objects. </title> <booktitle> In Proc. </booktitle> <address> INET '95, Honolulu, Hawaii, </address> <month> June </month> <year> 1995. </year> <institution> Internet Society. </institution>
Reference-contexts: This suggests adopting server-initiated invalidation protocols, but these do not scale. An intermediate scheme is to have a server record where its objects are cached so that it can invalidate those caches when necessary <ref> [10] </ref>. As invalidation messages may be lost, the proxy cache uses its own coherence protocol as a fall-back mechanism. However, in general, as the Web grows and the fraction of pages frequently referenced falls, no caching scheme will work well. One step further is to adopt true replication schemes.
Reference: [11] <author> J. Gwertzman and M. Seltzer. </author> <title> The Case for Geographical Push-Caching. </title> <booktitle> In Proc. 5th Hot Topics in Operating Systems, </booktitle> <address> Orcas Island, WA, </address> <month> May </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: However, in general, as the Web grows and the fraction of pages frequently referenced falls, no caching scheme will work well. One step further is to adopt true replication schemes. Gwertzman and Seltzer propose using geographical push-caching <ref> [11] </ref>. In this scheme, a server replicates a popular object to a location where it is frequently requested, preferably by many clients in possibly different domains. The scheme requires that such clients can share a single cache at a nearby site.
Reference: [12] <author> M. Baentsch, G. Molter, and P. Sturm. </author> <title> Introducing Application-level Replication and Naming into today's Web. Computer Networks and ISDN Systems, </title> <address> 28(7-11):920-930, </address> <year> 1996. </year>
Reference: [13] <author> J. </author> <title> Donnelley. WWW Media Distribution via Hopwise Reliable Multicast. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 27(6) </volume> <pages> 781-788, </pages> <year> 1995. </year> <month> 17 </month>
Reference-contexts: The scheme requires that such clients can share a single cache at a nearby site. A similar approach has been proposed by Baentsch et al.[12] which makes use of application-level multicasting. The distribution point model <ref> [13] </ref> is also based on multicasting, but is tailored towards active replication of relatively static sets of bulk, non real-time data. It is mainly applicable to magazine-like Web documents such as those that appear as electronic periodical publications.
Reference: [14] <author> C. Partridge, T. Mendez, and W. Milliken. </author> <title> Host Anycasting Service. </title> <type> RFC 1546, </type> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Assuming that the replicas register their contact address at the location service, finding the nearest contact address is easy, as the location service searches in incrementally expanding regions. In this sense, it inherently supports anycasting <ref> [14] </ref>. 5 Related Work on Distributed-Object Models There is much academic and industrial activity on the design and implementation of object-based distributed systems. However, the notion of an object varies considerably.
Reference: [15] <author> V. Sunderam. </author> <title> PVM: A Framework for Parallel Distributed Computing. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 24(4) </volume> <pages> 315-339, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Despite its low level of abstraction, the message-passing model is popular because it scales relatively well (although few people have thought of dealing with billion-user systems). Examples include applications based directly on TCP and UDP implementations, distributed computations based on communication libraries such as PVM <ref> [15] </ref> and MPI [16], group communication systems such as ISIS [17], and RPC-based systems like DCE [18]. However, developing distributed applications using message passing is hard.
Reference: [16] <author> M. Snir, S. Otto, S. Huss-Lederman, D. Walker, and J. Dongarra. </author> <title> MPI: The Complete Reference. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA., </address> <year> 1996. </year>
Reference-contexts: Despite its low level of abstraction, the message-passing model is popular because it scales relatively well (although few people have thought of dealing with billion-user systems). Examples include applications based directly on TCP and UDP implementations, distributed computations based on communication libraries such as PVM [15] and MPI <ref> [16] </ref>, group communication systems such as ISIS [17], and RPC-based systems like DCE [18]. However, developing distributed applications using message passing is hard.
Reference: [17] <author> K. Birman and R. van Renesse, </author> <title> (eds.). Reliable Distributed Computing with the Isis Toolkit. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA., </address> <year> 1994. </year>
Reference-contexts: Examples include applications based directly on TCP and UDP implementations, distributed computations based on communication libraries such as PVM [15] and MPI [16], group communication systems such as ISIS <ref> [17] </ref>, and RPC-based systems like DCE [18]. However, developing distributed applications using message passing is hard. The main limitation is that data placement, replication, consistency, and persistence management are left to the application, and each application must invent and implement these mechanisms all over again.
Reference: [18] <author> W. Rosenberry, D. Kenney, and G. Fisher. </author> <title> Understanding DCE. </title> <publisher> O'Reilly & Associates, </publisher> <address> Sebastopol, CA., </address> <year> 1992. </year>
Reference-contexts: Examples include applications based directly on TCP and UDP implementations, distributed computations based on communication libraries such as PVM [15] and MPI [16], group communication systems such as ISIS [17], and RPC-based systems like DCE <ref> [18] </ref>. However, developing distributed applications using message passing is hard. The main limitation is that data placement, replication, consistency, and persistence management are left to the application, and each application must invent and implement these mechanisms all over again.
Reference: [19] <author> E. Levy and A. Silberschatz. </author> <title> Distributed File Systems: Concepts and Examples. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 321-375, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Having each application create its own infrastructure from scratch makes developing new applications unnecessarily difficult. More recent systems base interprocess communication on operations on shared data. Typical examples are network file systems <ref> [19] </ref> and distributed shared memory (DSM) implementations [20]. The shared data model offers a small set of primitives for reading and writing bytes. The main problem here is achieving performance and scalability while keeping data consistent.
Reference: [20] <author> J. Protic, M. Tomasevic, and V. Milutinovic. </author> <title> Distributed Shared Memory: Concepts and Systems. </title> <journal> IEEE Parallel and Distributed Technology, </journal> <volume> 4(2) </volume> <pages> 63-79, </pages> <month> Summer </month> <year> 1996. </year>
Reference-contexts: Having each application create its own infrastructure from scratch makes developing new applications unnecessarily difficult. More recent systems base interprocess communication on operations on shared data. Typical examples are network file systems [19] and distributed shared memory (DSM) implementations <ref> [20] </ref>. The shared data model offers a small set of primitives for reading and writing bytes. The main problem here is achieving performance and scalability while keeping data consistent.
Reference: [21] <author> N. Brown and C. Kindel. </author> <title> Distributed Component Object Model Protocol - DCOM/1.0. </title> <type> Internet Draft, </type> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: The problem is that remote-object invocations cannot adequately deal with network latencies. Additional mechanisms such as object replication and asynchronous method invocations are therefore necessary. In its simplest form, remote-method invocation is actually implemented the same as a traditional RPC. This is the approach followed in DCOM <ref> [21, 22] </ref>, which is constructed as an enhancement to DCE. Clients in DCOM are offered only interfaces that are implemented by (remote) servers rather than by objects. More interesting are approaches that explicitly support objects.
Reference: [22] <author> Microsoft Corporation. </author> <title> The Component Object Model Specification, </title> <note> Version 0.9, </note> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: The problem is that remote-object invocations cannot adequately deal with network latencies. Additional mechanisms such as object replication and asynchronous method invocations are therefore necessary. In its simplest form, remote-method invocation is actually implemented the same as a traditional RPC. This is the approach followed in DCOM <ref> [21, 22] </ref>, which is constructed as an enhancement to DCE. Clients in DCOM are offered only interfaces that are implemented by (remote) servers rather than by objects. More interesting are approaches that explicitly support objects.
Reference: [23] <author> A. Grimshaw and W. Wulf. </author> <title> The Legion Vision of a Worldwide Virtual Computer. </title> <journal> Communications of the ACM, </journal> <volume> 40(1) </volume> <pages> 39-45, </pages> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: This is the approach followed in DCOM [21, 22], which is constructed as an enhancement to DCE. Clients in DCOM are offered only interfaces that are implemented by (remote) servers rather than by objects. More interesting are approaches that explicitly support objects. In the Legion system <ref> [23] </ref>, objects are located in different address spaces, and method invocation is implemented directly through message passing. Although this violates distribution transparency, the Legion approach is one of the few which explicitly addresses wide-area scalability.
Reference: [24] <author> I. Foster, J. Geisler, C. Kesselman, and S. Tuecke. </author> <title> Multimethod Communication for High-Performance Networked Computing Systems. </title> <journal> Journal of Parallel and Distributed Computing. </journal> <note> To appear. </note>
Reference-contexts: For example, their model does not prescribe how objects should be implemented, but only how they should interact, thus leaving room for different implementations. The Globus project has developed global pointers to support flexible implementations <ref> [24] </ref>. A global pointer is a reference to a remote compute object. The pointer identifies a number of protocols to communicate with the object, of which one is to be selected by the client.
Reference: [25] <author> B. Janssen and M. Spreitzer. </author> <title> ILU Reference Manual. </title> <institution> Xerox Corporation, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: An object is contained in the address space of a server, and a client invokes methods by means of a surrogate or proxy object in its own address space. Basic ORBs provide only support for language-independent and location-transparent method invocation as in the case of ILU <ref> [25] </ref>. ORBs that comply to CORBA [26] offer additional distribution services such as naming, persistence, transactions, etc. Unfortunately, CORBA has not yet defined services for transparently replicating objects, or for keeping replicas consistent. Whether objects in CORBA can set their own replication policy remains to be seen.
Reference: [26] <author> OMG. </author> <title> The Common Object Request Broker: Architecture and Specification, revision 2.0. OMG Document 96.03.04, </title> <booktitle> Object Management Group, </booktitle> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: Basic ORBs provide only support for language-independent and location-transparent method invocation as in the case of ILU [25]. ORBs that comply to CORBA <ref> [26] </ref> offer additional distribution services such as naming, persistence, transactions, etc. Unfortunately, CORBA has not yet defined services for transparently replicating objects, or for keeping replicas consistent. Whether objects in CORBA can set their own replication policy remains to be seen.
Reference: [27] <author> G. Hamilton, M. Powell, and J. Mitchell. Subcontract: </author> <title> A Flexible Base for Distributed Programming. </title> <booktitle> In Proc. 14th Symposium on Operating System Principles, </booktitle> <address> Asheville, N.C., </address> <month> Dec. </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: In addition, it is unclear to what extent the current services can be implemented in a scalable way. When an ORB is responsible for distribution services, we require additional mechanisms independent of the core object model. One such mechanism is the subcontract used in the Spring system <ref> [27] </ref>. A subcontract implements an invocation protocol: it describes the effect of a method invocation at the client side in terms of the method invocation (s) at the object's side.
Reference: [28] <author> M. Shapiro, Y. Gourhant, S. Habert, L. Mosseri, M. Ruffin, and C. Valot. </author> <title> SOS: An Object-Oriented Operating System Assessment and Perspectives. </title> <journal> Computing Systems, </journal> <volume> 2(4) </volume> <pages> 287-337, </pages> <month> Fall </month> <year> 1989. </year>
Reference-contexts: In other words, all distribution aspects of an object, including its location, migration, relocation, and replication, are part of its implementation. This leads to a model of partitioned objects. Partitioned objects appeared in SOS in the form of fragmented objects <ref> [28] </ref>. Globe's distributed shared objects form another implementation of partitioned objects, and have been derived from the Orca object-based shared data model [29]. To our knowledge, there are no other comparable approaches to partitioned objects. Fragmented objects in SOS are mostly language independent.
Reference: [29] <author> H. Bal and A. Tanenbaum. </author> <title> Distributed Programming with Shared Data. </title> <booktitle> In Proc. Int'l. Conf. on Computer Languages, </booktitle> <pages> pp. 82-91, </pages> <address> Miami Beach, FL., </address> <month> Oct. </month> <year> 1988. </year> <note> IEEE. </note>
Reference-contexts: This leads to a model of partitioned objects. Partitioned objects appeared in SOS in the form of fragmented objects [28]. Globe's distributed shared objects form another implementation of partitioned objects, and have been derived from the Orca object-based shared data model <ref> [29] </ref>. To our knowledge, there are no other comparable approaches to partitioned objects. Fragmented objects in SOS are mostly language independent. Distribution is achieved manually by allowing interfaces to act as object references that can be freely copied between different address spaces.
Reference: [30] <author> B. Neuman. </author> <title> Scale in Distributed Systems. </title> <editor> In T. Casavant and M. Singhal, (eds.), </editor> <booktitle> Readings in Distributed Computing Systems, </booktitle> <pages> pp. 463-489. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA., </address> <year> 1994. </year> <month> 18 </month>
Reference-contexts: The only way to achieve worldwide scalability is to provide extensive support for partitioning and replicating objects, and allow very different consistency strategies to co-exist <ref> [30] </ref>. Globe provides this flexibility. We have finished the initial architectural design of our system, leaving a number of subjects open for further research. For example, we are currently working on the design of a security architecture.
References-found: 30

