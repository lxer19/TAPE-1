URL: http://polaris.cs.uiuc.edu/reports/1345.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/polaris/rep2.html
Root-URL: http://www.cs.uiuc.edu
Email: blume@csrd.uiuc.edu eigenman@csrd.uiuc.edu  
Title: The Range Test: A Dependence Test for Symbolic, Non-linear Expressions  
Author: William Blume Rudolf Eigenmann 
Address: 1308 W. Main St., Urbana, Illinois 61801-2307  
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  
Abstract: Most current data dependence tests cannot handle loop bounds or array subscripts that are symbolic, nonlinear expressions (e.g. A(nfli+j), where 0 j n). In this paper, we describe a dependence test, called the range test, that can handle such expressions. Briefly, the range test proves independence by determining whether certain symbolic inequalities hold for a permutation of the loop nest. Powerful symbolic analyses and constraint propagation techniques were developed to prove such inequalities. The range test has been implemented in Polaris, a parallelizing compiler being developed at the University of Illinois. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Utpal Banerjee. </author> <title> Dependence Analysis for Supercomputing. </title> <publisher> Kluwer. </publisher> <address> Boston, MA., </address> <year> 1988. </year>
Reference-contexts: Powerful dependence tests are needed to effectively exploit the inherent parallelism in these sequential programs. There has been much research in the area of data dependence analysis <ref> [1, 14, 20, 21, 24] </ref>. Modern day data fl This work was supported by contract DABT63-92-C-0033 from the Advanced Research Project Agency. This work is not necessarily representative of the positions or policies of the U.S. Army or the government. ISSN 1063-9535. Copyright c fl1994 IEEE. All rights reserved. <p> Section 7 presents our conclusions and plans for future work. 2 Data dependence In this section we will give a brief definition of data dependences. For a more thorough description of data dependence and dependence analysis, see Banerjee et al <ref> [3, 1, 24] </ref>. To ease the presentation of the range test, we will assume that we have a perfectly nested, normalized, FORTRAN-77 loop nest as shown in Figure 2. We will also assume that the tested array A has only one dimension. <p> The following discussion compares our test to one of the most effective state-of-the-art tests and points out related ideas of other projects. Mathematically, the range test can be thought of as an extension of a symbolic version of the Triangular Banerjee's Inequalities test with dependence direction vectors <ref> [1, 23] </ref>, although our implementation differs. The only drawback of our test, compared to the Triangular Baner-jee's test with directions, is that it cannot test arbitrary direction vectors, particularly those containing more than one `&lt;' or `&gt;' (e.g., (&lt;; &lt;)).
Reference: [2] <author> Utpal Banerjee. </author> <title> A Theory of Loop Permutations. </title> <editor> In A. Nicolau D. Gelernter and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Processing, </booktitle> <pages> pages 54-74. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: To prove that all loops not carrying dependences in the permuted loop nest generated by the heuristic above also do not carry dependences in the original loop nest, we will need the following lemma. Due to lack of space, no proof is given, but techniques similar to Banerjee's <ref> [2] </ref> can be used to do so. Lemma 1 A loop that does not carry a dependence can be legally moved deeper into the loop nest and all loops that didn't carry a dependence beforehand would still not do so.
Reference: [3] <author> Utpal Banerjee, Rudolf Eigenmann, Alexandru Nico-lau, and David Padua. </author> <title> Automatic Program Paral-lelization. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 81(2), </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: 1 Introduction To allow sequential programs to run efficiently on parallel machines, parallelizing compilers were developed to transform these programs into parallel ones <ref> [3] </ref>. These compilers must be able to identify the important loops that can be run in parallel if they are to achieve decent speedups. Powerful dependence tests are needed to effectively exploit the inherent parallelism in these sequential programs. <p> Section 7 presents our conclusions and plans for future work. 2 Data dependence In this section we will give a brief definition of data dependences. For a more thorough description of data dependence and dependence analysis, see Banerjee et al <ref> [3, 1, 24] </ref>. To ease the presentation of the range test, we will assume that we have a perfectly nested, normalized, FORTRAN-77 loop nest as shown in Figure 2. We will also assume that the tested array A has only one dimension.
Reference: [4] <author> M. Berry, D. Chen, P. Koss, D. Kuck, L. Pointer, S. Lo, Y. Pang, R. Roloff, A. Sameh, E. Clementi, S. Chin, D. Schneider, G. Fox, P. Messina, D. Walker, C. Hsiung, J. Schwarzmeier, K. Lue, S. Orszag, F. Seidl, O. Johnson, G. Swanson, R. Goodrum, and J. Martin. </author> <title> The Perfect Club Benchmarks: Effective Performance Evalution of Supercomputers. </title> <booktitle> Int'l. Journal of Supercomputer Applications, Fall 1989, </booktitle> <volume> 3(3) </volume> <pages> 5-40, </pages> <month> Fall </month> <year> 1989. </year>
Reference-contexts: After simplification, this becomes [1 : 1]. From this range, we can now see that x fl y + 1 &gt; y. 5 Examples In this section, we will provide examples of important loop nests, taken from the Perfect Benchmarks <ref> [4] </ref>, that the range test can determine to be parallel but which conventional data dependence tests cannot. One example is a loop nest taken from subroutine FTRVMT from the code OCEAN. This loop nest accounts for 44% of the code's sequential execution time on an Al-liant FX/80.
Reference: [5] <author> Bill Blume, Rudolf Eigenmann, Keith Faigin, John Grout, Jay Hoeflinger, David Padua, Paul Petersen, Bill Pottenger, Lawrence Rauchwerger, Peng Tu, and Stephen Weatherford. </author> <title> Polaris: The Next Generation in Parallelizing Compilers. </title> <booktitle> Proceedings of the Seventh Annual Languages and Compilers for Parallelism Workshop, </booktitle> <address> Portland, Oregon, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: We have implemented the range test together with a symbolic range propagation algorithm in Polaris, a par-allelizing compiler being developed at the University of Illinois <ref> [13, 5] </ref>. Currently, the range test is the only data dependence test implemented in Polaris. <p> However, with the range test, along with other advanced techniques mentioned in <ref> [5] </ref>, we are able to optimize the codes close to the hand parallelized versions, which reached a speedup of 43 for TRFD and 16 for OCEAN.
Reference: [6] <author> William Blume and Rudolf Eigenmann. </author> <title> An Overview of Symbolic Analysis Techniques Needed for the Effective Parallelization of the Perfect Benchmarks. </title> <booktitle> Proceedings of ICPP'94, </booktitle> <address> St. Charles, IL, </address> <year> 1994. </year>
Reference-contexts: For example, a parallelizing compiler could achieve a speedup of at most two for the codes OCEAN and TRFD from the Perfect Benchmarks if it could not parallelize loops with nonlinear array subscripts <ref> [6] </ref>. For some of these loops, nonlinear expressions occurred in the original program text. For other loops, nonlinear expressions were introduced by the compiler. Two common compiler passes can introduce nonlinearities into array subscript expressions: induction variable substitution and array linearization. <p> Early ideas of such a test were described in <ref> [12, 18, 6] </ref>. The most distinguished feature of the test may be the fact that it is now available in an actual compiler, which has proven to parallelize important programs to an unprecedented degree.
Reference: [7] <author> Franc~ois Bourdoncle. </author> <title> Abstract Debugging of Higher-Order Imperative Languages. </title> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 46-55, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: There has been some work in the determination of variable constraints. Much work has been done in determining the possible range, or interval, of values that variables can take, for the purpose of array bounds checking or program verification <ref> [17, 7] </ref>. These algorithms, however, only propagate integer ranges.
Reference: [8] <author> Partrick Cousot and Radhia Cousot. </author> <title> Abstract Interpretation: A unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> Proceedings of the 4th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: The expression comparison facility uses these variable constraints to determine arithmetic relationships between two symbolic expressions. The range propagation algorithm centers on the collection and propagation of symbolic lower and upper bounds on variables, called ranges, through a program unit. Abstract interpretation <ref> [8] </ref> is used to compute the ranges for variables at each point of a program unit. <p> These merged ranges are computed by taking the largest upper bound and smallest lower bound of the ranges belonging to each of the entering control flow paths. To guarantee that the algorithm eventually reaches a fixed point and halts, a widening operator <ref> [8] </ref> is also applied to merge points that are loop headers. This widening operator sets a range to a conservative value if the range has changed too often during the course of computation.
Reference: [9] <author> Partrick Cousot and Nicolas Halbwachs. </author> <title> Automatic Discovery of Linear Restraints Among Variables of a Program. </title> <booktitle> Proceedings of the 5th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-97, </pages> <year> 1978. </year>
Reference-contexts: Much work has been done in determining the possible range, or interval, of values that variables can take, for the purpose of array bounds checking or program verification [17, 7]. These algorithms, however, only propagate integer ranges. Cousot and Halbwachs <ref> [9] </ref> offer a powerful algorithm for determining symbolic linear constraints between variables. (Their algorithm is used by Haghighat's symbolic dependence test to determine variable constraints.) Their algorithm is based upon the calculation, intersection, and merging of convex polyhedrons in the n-space of variable values.
Reference: [10] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently Computing Static Single Assignment Form and the Control Dependence Graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: In these versions, the range test should not significantly increase the compiler's execution time. The range propagation algorithm can be somewhat costly, although not prohibitively so. Because of this, we will look into several techniques to improve its efficiency, such as using Static Single Assignment form <ref> [10] </ref>, propagating ranges derived only from control flow, or propagating ranges only on demand [22].
Reference: [11] <author> Rudolf Eigenmann, Jay Hoeflinger, G. Jaxon, and David Padua. </author> <title> The Cedar Fortran Project. </title> <type> Technical Report 1262, </type> <institution> Univ. of Illinois at Urbana-Champaign, Cntr. for Supercomputing Res, & Dev., </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Unfortunately, not all nonlinear expressions can be removed. It was believed that this would not be a problem for dependence testing real programs since nonlinear expressions would be rare. However, our manual paralleliza-tion effort of the Perfect Benchmarks have shown us that this is not the case <ref> [12, 11] </ref>. For example, a parallelizing compiler could achieve a speedup of at most two for the codes OCEAN and TRFD from the Perfect Benchmarks if it could not parallelize loops with nonlinear array subscripts [6]. For some of these loops, nonlinear expressions occurred in the original program text.
Reference: [12] <author> Rudolf Eigenmann, Jay Hoeflinger, Zhiyuan Li, and David Padua. </author> <title> Experience in the Automatic Paral-lelization of Four Perfect-Benchmark Programs. </title> <booktitle> Lecture Notes in Computer Science 589. Proceedings of the Fourth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Santa Clara, CA, </address> <pages> pages 65-83, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Unfortunately, not all nonlinear expressions can be removed. It was believed that this would not be a problem for dependence testing real programs since nonlinear expressions would be rare. However, our manual paralleliza-tion effort of the Perfect Benchmarks have shown us that this is not the case <ref> [12, 11] </ref>. For example, a parallelizing compiler could achieve a speedup of at most two for the codes OCEAN and TRFD from the Perfect Benchmarks if it could not parallelize loops with nonlinear array subscripts [6]. For some of these loops, nonlinear expressions occurred in the original program text. <p> Early ideas of such a test were described in <ref> [12, 18, 6] </ref>. The most distinguished feature of the test may be the fact that it is now available in an actual compiler, which has proven to parallelize important programs to an unprecedented degree.
Reference: [13] <author> Keith A. Faigin, Jay P. Hoeflinger, David A. Padua, Paul M. Petersen, and Stephen A. Weatherford. </author> <title> The Polaris Internal Representation. </title> <type> Technical Report 1317, </type> <institution> Univ. of Illinois at Urbana-Champaign, Cntr. for Supercomputing Res. and Dev., </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: We have implemented the range test together with a symbolic range propagation algorithm in Polaris, a par-allelizing compiler being developed at the University of Illinois <ref> [13, 5] </ref>. Currently, the range test is the only data dependence test implemented in Polaris.
Reference: [14] <author> Gina Goff, Ken Kennedy, and Chau-Wen Tseng. </author> <title> Practical Dependence Testing. </title> <booktitle> In Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 15-29, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Powerful dependence tests are needed to effectively exploit the inherent parallelism in these sequential programs. There has been much research in the area of data dependence analysis <ref> [1, 14, 20, 21, 24] </ref>. Modern day data fl This work was supported by contract DABT63-92-C-0033 from the Advanced Research Project Agency. This work is not necessarily representative of the positions or policies of the U.S. Army or the government. ISSN 1063-9535. Copyright c fl1994 IEEE. All rights reserved. <p> For example, constant propagation and induction variable substitution are used to remove loop-variant variables. Other techniques have also been developed to handle additive, loop-invariant, symbolic terms or to eliminate unwanted operations such as divisions <ref> [14, 20, 21] </ref>. Unfortunately, not all nonlinear expressions can be removed. It was believed that this would not be a problem for dependence testing real programs since nonlinear expressions would be rare.
Reference: [15] <author> Mohammad Haghighat and Constantine Polychronopoulos. </author> <title> Symbolic Dependence Analysis for High-Performance Parallelizing Compilers. </title> <booktitle> Parallel and Distributed Computing: Advances in Languages and Compilers for Parallel Processing, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <pages> pages 310-330, </pages> <year> 1991. </year>
Reference-contexts: Haghighat and Polychronopoulos, presented a dependence test to handle nonlinear, symbolic expressions <ref> [15] </ref>. Their algorithm is essentially a symbolic version of Baner-jee's Inequalities test.
Reference: [16] <author> Mohammad Haghighat and Constan-tine Polychronopoulos. </author> <title> Symbolic Analysis: A Basis for Paralleliziation, Optimization, and Scheduling of Programs. </title> <booktitle> Proceedings of the Sixth Annual Languages and Compilers for Parallelism Workshop, </booktitle> <address> Portland, Oregon, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: We also determine variable constraints and perform symbolic inequality tests, although we use different techniques. We will compare these two methods later in this section. In a separate paper, Haghighat and Polychronopou-los <ref> [16] </ref> describe a technique to prove that a symbolic expression is strictly increasing or decreasing. By using this technique, self-dependences for an array reference can be eliminated. Their example can prove that all the loops in Figure 8, after induction variable substitution, are parallel.
Reference: [17] <author> William H. Harrison. </author> <title> Compiler Analysis of the Value Ranges for Variables. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-3(3):243-250, </volume> <month> May </month> <year> 1977. </year>
Reference-contexts: There has been some work in the determination of variable constraints. Much work has been done in determining the possible range, or interval, of values that variables can take, for the purpose of array bounds checking or program verification <ref> [17, 7] </ref>. These algorithms, however, only propagate integer ranges.
Reference: [18] <author> Jay Hoeflinger. </author> <title> Run-Time Dependence Testing by Integer Sequence Analysis. </title> <type> Technical Report 1194, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: Early ideas of such a test were described in <ref> [12, 18, 6] </ref>. The most distinguished feature of the test may be the fact that it is now available in an actual compiler, which has proven to parallelize important programs to an unprecedented degree.
Reference: [19] <author> Vadim Maslov. Delinearization: </author> <title> An Efficient Way to Break Multiloop Dependence Equations. </title> <booktitle> Proceedings of the SIGPLAN `92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 152-161, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: However, as described, the test only handles self-dependences. The subroutine OLDA in TRFD has other important loop nests that has multiple array accesses with nonlinear subscript expressions similar to the subscripts from Figure 8. Maslov <ref> [19] </ref> presents an alternate way to handle symbolic, non-linear expressions. Instead of testing these expressions directly, his algorithm partitions the expression into several independent subexpressions, then tests these partitions using conventional data dependence tests. Essentially, it delinearizes array references.
Reference: [20] <author> D. Maydan, J. Hennessy, and M. Lam. </author> <title> Efficient and Exact Data Dependence Analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-14, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Powerful dependence tests are needed to effectively exploit the inherent parallelism in these sequential programs. There has been much research in the area of data dependence analysis <ref> [1, 14, 20, 21, 24] </ref>. Modern day data fl This work was supported by contract DABT63-92-C-0033 from the Advanced Research Project Agency. This work is not necessarily representative of the positions or policies of the U.S. Army or the government. ISSN 1063-9535. Copyright c fl1994 IEEE. All rights reserved. <p> For example, constant propagation and induction variable substitution are used to remove loop-variant variables. Other techniques have also been developed to handle additive, loop-invariant, symbolic terms or to eliminate unwanted operations such as divisions <ref> [14, 20, 21] </ref>. Unfortunately, not all nonlinear expressions can be removed. It was believed that this would not be a problem for dependence testing real programs since nonlinear expressions would be rare. <p> However, with the range test, along with other advanced techniques mentioned in [5], we are able to optimize the codes close to the hand parallelized versions, which reached a speedup of 43 for TRFD and 16 for OCEAN. With the aid of memoization <ref> [20] </ref>, or the caching of already tested array subscript pairs, we have found the execution time of the range test to be acceptable, even when applied as the only test. In future versions of Po-laris, we will only invoke this test when other dependence tests fail due to nonlinear expressions.
Reference: [21] <author> William Pugh. </author> <title> A Practical Algorithm for Exact Array Dependence Analysis. </title> <journal> Communications of the ACM, </journal> <volume> 35(8) </volume> <pages> 102-114, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Powerful dependence tests are needed to effectively exploit the inherent parallelism in these sequential programs. There has been much research in the area of data dependence analysis <ref> [1, 14, 20, 21, 24] </ref>. Modern day data fl This work was supported by contract DABT63-92-C-0033 from the Advanced Research Project Agency. This work is not necessarily representative of the positions or policies of the U.S. Army or the government. ISSN 1063-9535. Copyright c fl1994 IEEE. All rights reserved. <p> For example, constant propagation and induction variable substitution are used to remove loop-variant variables. Other techniques have also been developed to handle additive, loop-invariant, symbolic terms or to eliminate unwanted operations such as divisions <ref> [14, 20, 21] </ref>. Unfortunately, not all nonlinear expressions can be removed. It was believed that this would not be a problem for dependence testing real programs since nonlinear expressions would be rare. <p> For example, it converts an array reference A (n fl i + j), where 1 j n, into a two-dimensional array A (j; i). The greatest strength of this technique is that it can convert non-linear expressions into linear ones, allowing exact data tests like the Omega Test <ref> [21] </ref> to be applied. Because of this, there are situations where Maslov's algorithm whereas we cannot, such as the array references A (n fl i + j) and A (i + n fl j), where 1 i j n.
Reference: [22] <author> Peng Tu and David Padua. </author> <title> Demand-Driven Symbolic Analysis. </title> <type> Technical Report 1336, </type> <institution> Univ. of Illinois at Urbana-Champaign, Cntr. for Supercomputing Res. & Dev., </institution> <month> Febraury </month> <year> 1994. </year>
Reference-contexts: The range propagation algorithm can be somewhat costly, although not prohibitively so. Because of this, we will look into several techniques to improve its efficiency, such as using Static Single Assignment form [10], propagating ranges derived only from control flow, or propagating ranges only on demand <ref> [22] </ref>.
Reference: [23] <author> Michael Wolfe. </author> <title> Triangular Banerjee's Inequalities with Directions. </title> <type> Technical report, </type> <institution> Oregon Graduate Institute of Science and Technology, </institution> <month> June </month> <year> 1992. </year> <pages> CS/E 92-013. </pages>
Reference-contexts: The following discussion compares our test to one of the most effective state-of-the-art tests and points out related ideas of other projects. Mathematically, the range test can be thought of as an extension of a symbolic version of the Triangular Banerjee's Inequalities test with dependence direction vectors <ref> [1, 23] </ref>, although our implementation differs. The only drawback of our test, compared to the Triangular Baner-jee's test with directions, is that it cannot test arbitrary direction vectors, particularly those containing more than one `&lt;' or `&gt;' (e.g., (&lt;; &lt;)).
Reference: [24] <author> Michael Wolfe and Utpal Banerjee. </author> <title> Data Dependence and its Application to Parallel Processing. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 16(2) </volume> <pages> 137-178, </pages> <year> 1987. </year>
Reference-contexts: Powerful dependence tests are needed to effectively exploit the inherent parallelism in these sequential programs. There has been much research in the area of data dependence analysis <ref> [1, 14, 20, 21, 24] </ref>. Modern day data fl This work was supported by contract DABT63-92-C-0033 from the Advanced Research Project Agency. This work is not necessarily representative of the positions or policies of the U.S. Army or the government. ISSN 1063-9535. Copyright c fl1994 IEEE. All rights reserved. <p> Section 7 presents our conclusions and plans for future work. 2 Data dependence In this section we will give a brief definition of data dependences. For a more thorough description of data dependence and dependence analysis, see Banerjee et al <ref> [3, 1, 24] </ref>. To ease the presentation of the range test, we will assume that we have a perfectly nested, normalized, FORTRAN-77 loop nest as shown in Figure 2. We will also assume that the tested array A has only one dimension.
References-found: 24

