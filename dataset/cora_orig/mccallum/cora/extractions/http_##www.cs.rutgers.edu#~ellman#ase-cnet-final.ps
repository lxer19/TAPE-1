URL: http://www.cs.rutgers.edu/~ellman/ase-cnet-final.ps
Refering-URL: http://www.cs.rutgers.edu/~ellman/ellman-publications.html
Root-URL: 
Email: fellman,muratag@cs.rutgers.edu  
Title: Deductive Synthesis of Numerical Simulation Programs from Networks of Algebraic and Ordinary Differential Equations  
Author: Thomas Ellman Takahiro Murata 
Address: Piscataway, New Jersey 08855  
Affiliation: Department of Computer Science Hill Center for Mathematical Sciences Rutgers University,  
Abstract: Scientists and engineers face recurring problems of constructing, testing and modifying numerical simulation programs. The process of coding and revising such simulators is extremely time-consuming, because they are almost always written in conventional programming languages. Scientists and engineers can therefore benefit from software that facilitates construction of programs for simulating physical systems. Our research adapts the methodology of deductive program synthesis to the problem of constructing numerical simulation codes. We have focused on simulators that can be represented as second order functional programs composed of numerical integration and root extraction routines. We have developed a system that uses first order Horn logic to synthesize numerical simulators built from these components. Our approach is based on two ideas: First, we axiomatize only the relationship between integration and differentiation. We neither attempt nor require a complete axiomatization of mathematical analysis. Second, our system uses a representation in which functions are reified as objects. Function objects are encoded as lambda expressions. Our knowledge base includes an axiomatization of term equality in the lambda calculus. It also includes axioms defining the semantics of numerical integration and root extraction routines. We use depth bounded SLD resolution to construct proofs and synthesize programs. Our system has successfully constructed numerical simulators for computational design of jet engine nozzles and sailing yachts, among others. Our results demonstrate that deductive synthesis techniques can be used to construct numerical simulation programs for realistic applications. fl Automated Software Engineering, 5, 3, 1998.
Abstract-found: 1
Intro-found: 1
Reference: [ Buchberger, 1987 ] <author> B. </author> <title> Buchberger. History and basic features of the critical-pair / completion procedure. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3(1) </volume> <pages> 3-38, </pages> <year> 1987. </year>
Reference-contexts: We used the critical-pair completion technique (by hand) to replace these rules with a new set of rules <ref> [ Buchberger, 1987 ] </ref> . <p> In other cases, the final step is justified by a rule that was obtained from a rule in Figure 7, 8 or 9, by combining it with a rule for beta-reduction, according to the critical-pair completion procedure <ref> [ Buchberger, 1987 ] </ref> . In these cases, we say that the step is justified by a "beta-reduced form" of the original rule. 1. Proof of Constraint: zero (apply (minus,[apply (MASS,[duration]),TAKEOFF_MASS])) a. Rewrite by Beta Reduction: apply (minus,[apply (MASS,[duration]),TAKEOFF_MASS]) ==&gt; apply (minus,[TAKEOFF_MASS,TAKEOFF_MASS]) b.
Reference: [ Ellman and Murata, 1996 ] <author> T. Ellman and T. Murata. </author> <title> Deductive synthesis of numerical simulation programs from networks of algebraic and ordinary differential equations. </title> <booktitle> In Proceedings of the Eleventh Knowledge-Based Software Engineering Conference, </booktitle> <address> Syracuse, NY, </address> <year> 1996. </year>
Reference-contexts: In our first effort, we developed a recursive algorithm for synthesizing nested second order functional programs <ref> [ Ellman and Murata, 1996 ] </ref> . In order to generate a simulator with lambda expressions nested n levels deep inside each other, the theorem prover would call itself n times. This approach was successful in handling a fair number of test problems.
Reference: [ Ellman et al., 1993 ] <author> T. Ellman, J. Keane, and M. Schwabacher. </author> <title> Intelligent model selection for hillclimbing search in computer-aided design. </title> <booktitle> In Proceedings of the Eleventh National Conference on Artificial Intelligence, </booktitle> <pages> pages 594-599, </pages> <address> Washington, DC, </address> <year> 1993. </year>
Reference-contexts: A wide variety of systems can be modeled by networks of algebraic and ordinary differential equations. Examples include an aircraft simulator for computational design of jet-engine nozzles [ Gelsey et al., 1996 ] ; a sailing yacht simulator for computational design of hull geometries <ref> [ Ellman et al., 1993 ] </ref> ; and a planetary scientist's model of the atmosphere of the moon Titan [ Keller et al., 1994 ] . Simulators for such systems can be constructed as configurations of numerical integration and root extraction routines.
Reference: [ Ellman et al., 1998 ] <author> T. Ellman, J. Keane, A. Banerjee, and G. Armhold. </author> <title> A transformation system for interactive reformulation of design optimization strategies. </title> <note> To Appear in Research in Engineering Design, </note> <year> 1998. </year>
Reference-contexts: The catalog includes transforms for solving equations symbolically, selecting numerical methods or tolerance parameters, approximating functions and reformulating design parameter 3 spaces, among others. The transformation system used in this part of the DA-MSA is described in <ref> [ Ellman et al., 1998 ] </ref> . <p> (V,FS,AS,IMAGE). tions. (The suggestive names of the formal parameters of lambda expressions, mass, time, mdot and attack angle, were inserted by the authors in place of corresponding arbitrary symbols generated by our back-end translator.) This Lisp function has a form that is amenable to transformation using the tools described in <ref> [ Ellman et al., 1998 ] </ref> , e.g., transformations that use symbolic algebra to replace numeric root extraction expressions with closed-form solutions. This function is also presented to the user as a collection of data flow graphs, as shown in Figures 13, 14 and 15.
Reference: [ Gelsey et al., 1996 ] <author> Andrew Gelsey, Don Smith, Mark Schwabacher, Khaled Rasheed, and Keith Miyake. </author> <title> A search space toolkit. Decision Support Systems, </title> <journal> special issue on Unification of Artificial Intelligence with Optimization, </journal> <year> 1996. </year>
Reference-contexts: This unfortunate situation appears not to be inevitable. A wide variety of systems can be modeled by networks of algebraic and ordinary differential equations. Examples include an aircraft simulator for computational design of jet-engine nozzles <ref> [ Gelsey et al., 1996 ] </ref> ; a sailing yacht simulator for computational design of hull geometries [ Ellman et al., 1993 ] ; and a planetary scientist's model of the atmosphere of the moon Titan [ Keller et al., 1994 ] . <p> An example of such a system is described informally in Figure 1. This example is a simplified version of an aircraft simulation problem used in research on design of jet-engine nozzles <ref> [ Gelsey et al., 1996 ] </ref> . The required simulator takes as input a description n of the nozzle, the empty mass m e of the aircraft, and the velocity v and duration d of a flight.
Reference: [ Gunter, 1992 ] <author> C. Gunter. </author> <title> Semantics of Programming Languages: Structures and Techniques. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Our implementation language includes an unusual notation for lambda expressions. We use a notation based on de Bruijn indexes <ref> [ Gunter, 1992 ] </ref> . Each lambda expression indicates only the number of formal parameters it requires. Within the body of a lambda expression, formal parameters are referenced by the standard names v (i)(i = 1 : : : n) in any context where n formal parameters are in scope. <p> The fifth rule asserts that T 1 equals T 2 if T 1 can be converted into T 2 using beta-reduction <ref> [ Gunter, 1992 ] </ref> .
Reference: [ Kant, 1993 ] <author> E. Kant. </author> <title> Synthesis of mathematical modeling software. </title> <journal> IEEE Software, </journal> <volume> 10(3) </volume> <pages> 30-41, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Nevertheless, Amphion is not immediately applicable to our class of problems because it does not provide facilities for reasoning about differential equations. Our research may be seen as an approach to extending a system like Amphion in order to handle such problems. The Synapse system <ref> [ Kant, 1993 ] </ref> constructs finite element codes for simulating systems governed by partial differential equations, a class of problems that is distinct from the one we have attacked.
Reference: [ Keane, 1996 ] <author> J. Keane. </author> <title> Extensions to Franz, Inc.'s Allegro Common Lisp foreign function interface. </title> <type> Technical Report HPCD-TR-41, </type> <institution> Department of Computer Science, Rutgers University, </institution> <year> 1996. </year>
Reference-contexts: The integration and root extraction functions are implemented in a working run-time system. The implementation is composed of C routines taken from [ Press et al., 1986 ] . The C routines are wrapped by Lisp functions providing the interfaces described above <ref> [ Keane, 1996 ] </ref> . The integration functions are computed using a Runge-Kutta method. The root extraction functions are computed using the Newton-Raphson method. An example (in Prolog syntax) of a program in our implementation language is shown in Figure 11.
Reference: [ Keller et al., 1994 ] <author> R. Keller, M. Rimon, and A. Das. </author> <title> A knowledge-based prototyping environment for construction of scientific modeling software. </title> <journal> Automated Software Engineering, </journal> <volume> 1(1) </volume> <pages> 79-128, </pages> <year> 1994. </year>
Reference-contexts: Examples include an aircraft simulator for computational design of jet-engine nozzles [ Gelsey et al., 1996 ] ; a sailing yacht simulator for computational design of hull geometries [ Ellman et al., 1993 ] ; and a planetary scientist's model of the atmosphere of the moon Titan <ref> [ Keller et al., 1994 ] </ref> . Simulators for such systems can be constructed as configurations of numerical integration and root extraction routines. Libraries of such generic numerical tools are now widely available [ Press et al., 1986 ] . <p> In practice, this means the user must experiment with various different numerical algorithms and tolerance levels, in order to have a program with suitable levels of efficiency, accuracy and stability. 9 Related Work Our research was originally motivated by difficulties encountered in attempting to apply the SIGMA scientific modeling system <ref> [ Keller et al., 1994 ] </ref> to the task of constructing numerical simulators for automated optimization of designs of jet-engine nozzles and sailing yachts. SIGMA uses a graphical first order data flow language to represent scientific models.
Reference: [ Kowalski and Peskin, 1990 ] <author> A. Kowalski and R. Peskin. </author> <title> Anatomy of Agnes: An automatic generator of numerical equation solutions. </title> <editor> In E. N. Houstis, editor, </editor> <booktitle> Intelligent Mathematical Software Systems, </booktitle> <pages> pages 33-42. </pages> <publisher> Elsevier Science Publishers, </publisher> <address> New York, New York, </address> <year> 1990. </year> <month> 30 </month>
Reference-contexts: The Synapse system [ Kant, 1993 ] constructs finite element codes for simulating systems governed by partial differential equations, a class of problems that is distinct from the one we have attacked. The Agnes system <ref> [ Kowalski and Peskin, 1990 ] </ref> also constructs numerical solvers for problems specified in terms of partial differential equations; however, it appears to handle some types of problems involving ordinary differential equations as well. Agnes operates by parsing the input equations, classifying them and choosing an appropriate numerical solution method.
Reference: [ Lloyd, 1987 ] <author> J. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1987. </year>
Reference-contexts: The binding b i of each output quantity o i is used to define a separate function f i = (i 1 ; : : : ; i m ):b i for each output of the specification. Our synthesis system uses SLD resolution <ref> [ Lloyd, 1987 ] </ref> , [ Shapiro and Sterling, 1986 ] to prove theorems of this form. SLD resolution is a strategy for searching for proofs constructed from Horn clauses. <p> It conducts a depth-first search of the space of proof trees, always choosing a most recently generated literal for the next resolution step. SLD resolution is a complete theorem proving strategy for theories axiomatized in Horn clauses <ref> [ Lloyd, 1987 ] </ref> . SLD resolution is applicable to our synthesis problem because our knowledge base has been encoded in first order Horn logic, and because the negation of the proof goal is also a Horn clause. Our theorem prover is implemented in Quintus Prolog.
Reference: [ Lowry et al., 1994 ] <author> M. Lowry, A. Philpot, T. Pressberger, and I. Underwood. </author> <title> A formal approach to domain-oriented software design environments. </title> <booktitle> In Proceedings of the Ninth Knowledge-Based Software Engineering Conference, </booktitle> <address> Monterey, CA, </address> <year> 1994. </year>
Reference-contexts: Thus, in general, one must prove a theorem of the following form: (8 i) (9 o) (9 n) u ( i; o; n) ^ (8 t) q ( i; o; n; t) This type of proof goal is similar to the one used in Amphion <ref> [ Lowry et al., 1994 ] </ref> . The principal difference is the appearance in our proof goal of the universally quantified constraints. Our system uses a resolution-refutation procedure to prove theorems in this form. <p> The solution was to split the representation into two parts. A network of algebraic and differential equations represents 18 specifications. A second order data flow language represents executable models. Our deductive synthesis system provides a mapping between these two levels of representation. The Amphion system <ref> [ Lowry et al., 1994 ] </ref> is similar to the system we have described here. Amphion takes as input a problem specification in the form of a network of relationships among quantities and objects to be modeled. The network is provided by the user via a graphical user interface.
Reference: [ Manna and Waldinger, 1992 ] <author> Z. Manna and R. Waldinger. </author> <title> Fundamentals of deductive program synthesis. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(8) </volume> <pages> 674-705, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Finally, in the third stage of operation, the simulation/optimization program is compiled and linked with routines drawn from a library of numerical tools [ Press et al., 1986 ] and used to solve design problems. 2 Approach Our approach is based on deductive program synthesis <ref> [ Manna and Waldinger, 1992 ] </ref> . A specification in our system defines a relation S (x; y) between a program input x and a desired output y.
Reference: [ Matlab, 1992 ] <author> MATLAB: </author> <title> High Performance Numerical Computation and Visualization Software. The Math Works, </title> <publisher> Inc., </publisher> <address> Natick, MA, </address> <year> 1992. </year>
Reference-contexts: It appears unable to synthesize numerical simulators composed of combinations of numerical integration and root extraction routines, as we have done in our work. 19 Commercial mathematical toolkits, such as Matlab <ref> [ Matlab, 1992 ] </ref> provide tools for integrating dynamic systems; however, Matlab's tools require that the system derivatives be given explicitly in closed form.
Reference: [ Nadathar and Miller, 1990 ] <author> G. Nadathar and D. Miller. </author> <title> Higher-order horn clauses. </title> <journal> JACM, </journal> <volume> 37(4) </volume> <pages> 777-814, </pages> <year> 1990. </year>
Reference-contexts: Verification of programs containing second order functions might seem to require a second order logic, i.e., one that can quantify over functions. Unfortunately, logic programming systems based on higher order logic, such as Prolog <ref> [ Nadathar and Miller, 1990 ] </ref> , are not as mature as systems based on first order logic. The practical considerations of building an experimental prototype system thus argue in favor of using first order logic, if possible. <p> It may ultimately be necessary to combine deductive methods with computational experiments, in order to complete the program development process. We are currently investigating the use of a higher order logic programming language, Prolog <ref> [ Nadathar and Miller, 1990 ] </ref> , as a platform for re-implementing our system. Prolog differs from ordinary Prolog in allowing clauses with quantification over functions encoded as lambda expressions. It includes a mechanism for performing unification modulo the axioms of term equality in the lambda calculus.
Reference: [ Press et al., 1986 ] <author> W. Press, W. Vetterling, S. Teukolsky, and B. Flannery. </author> <title> Numerical Recipes. </title> <publisher> Cambridge University Press, </publisher> <address> New York, NY, </address> <year> 1986. </year>
Reference-contexts: Simulators for such systems can be constructed as configurations of numerical integration and root extraction routines. Libraries of such generic numerical tools are now widely available <ref> [ Press et al., 1986 ] </ref> . They are under-utilized because of the difficulty of bridging the gap between equations the language with which scientists and engineers are familiar and the facilities provided by numerical libraries. <p> The equations defining the simplified aircraft simulation problem do not have a closed-form symbolic solution. Nevertheless, a simulator for this problem can be constructed using a numerical integration code (e.g., Runge-Kutta <ref> [ Press et al., 1986 ] </ref> ) to integrate _m (t) backwards over the flight of the aircraft, starting with m e , the mass of the empty aircraft, and ending with m f , the mass of the fully fueled aircraft. <p> The function to be integrated, _m (t), can be computed from the instantaneous mass m (t) by using a numerical root extraction code (e.g., Newton-Raphson <ref> [ Press et al., 1986 ] </ref> ) to 2 Inputs: * Description of the jet engine nozzle: n. * Empty mass of the aircraft: m e . * Velocity of the aircraft: v. * Duration of the flight: d. Outputs: * Takeoff mass of the aircraft: m f . <p> The transformation system used in this part of the DA-MSA is described in [ Ellman et al., 1998 ] . Finally, in the third stage of operation, the simulation/optimization program is compiled and linked with routines drawn from a library of numerical tools <ref> [ Press et al., 1986 ] </ref> and used to solve design problems. 2 Approach Our approach is based on deductive program synthesis [ Manna and Waldinger, 1992 ] . A specification in our system defines a relation S (x; y) between a program input x and a desired output y. <p> The integration and root extraction functions are implemented in a working run-time system. The implementation is composed of C routines taken from <ref> [ Press et al., 1986 ] </ref> . The C routines are wrapped by Lisp functions providing the interfaces described above [ Keane, 1996 ] . The integration functions are computed using a Runge-Kutta method. The root extraction functions are computed using the Newton-Raphson method. <p> Another significant limitation results from the fact that our axioms do not distinguish between different numerical algorithms for integration and root extraction. Many different algorithms may be used to solve integration and root extraction problems <ref> [ Press et al., 1986 ] </ref> . These algorithms differ widely in terms of efficiency, accuracy and stability, among other things. Our system does not tell the user which numerical algorithm to use.
Reference: [ Pressburger and Lowry, 1995 ] <author> T. Pressburger and M. Lowry. </author> <title> Automatic domain oriented software design using formal methods. </title> <booktitle> In Software Systems in Engineering, Energy-Sources Technology Conference and Exhibition, </booktitle> <address> Houston, TX, </address> <year> 1995. </year>
Reference-contexts: In order to generate a simulator with lambda expressions nested n levels deep inside each other, the theorem prover would call itself n times. This approach was successful in handling a fair number of test problems. It appears similar to the approach described in <ref> [ Pressburger and Lowry, 1995 ] </ref> for synthesizing iterative programs to find roots, locate minima or solve constraints. Unfortunately we could not find a way to make this technique synthesize simulators that solve general boundary-value problems.
Reference: [ Shapiro and Sterling, 1986 ] <author> E. Shapiro and L. Sterling. </author> <title> The Art of Prolog. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1986. </year> <month> 31 </month>
Reference-contexts: The binding b i of each output quantity o i is used to define a separate function f i = (i 1 ; : : : ; i m ):b i for each output of the specification. Our synthesis system uses SLD resolution [ Lloyd, 1987 ] , <ref> [ Shapiro and Sterling, 1986 ] </ref> to prove theorems of this form. SLD resolution is a strategy for searching for proofs constructed from Horn clauses. It conducts a depth-first search of the space of proof trees, always choosing a most recently generated literal for the next resolution step.
References-found: 18

