URL: ftp://ftp.netcom.com/pub/hb/hbaker/LimitedRoots.ps.Z
Refering-URL: ftp://ftp.netcom.com/pub/hb/hbaker/home.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Safe and Leakproof Resource Management using Ada83 Limited Types improve the use of limited private
Author: Henry G. Baker 
Keyword: 2.Fully Automatic Resource Management  
Address: 16231 Meadow Ridge Way, Encino, CA 91436  
Affiliation: Nimble Computer Corp.,  
Note: ACM Ada Letters XIII,5 (Sept./Oct.1993), 32-42. 1992,1993 by Nimble Computer Corporation. 1  Suggestions are offered to  
Pubnum: 1.Introduction  
Phone: (818) 501-4956(818) 986-1360 (FAX)  
Abstract: Safe, leakproof and automatic resource managers are essential to the implementation of every embedded system, yet the standard examples of Ada83 resource managers are either unsafe: they risk allocating the same resource for two different purposes, leaky: they risk permanently losing track of some resources, or nonautomatic: they require explicit deallocation, which allows for a host of opportunities for single-point system failures. Nevertheless, it is possible to construct a safe, leakproof and automatic resource managerat least for systems with only a single task by a careful combination of certain features of Ada83, and a careful avoidance of other features. We illustrate our scheme with a safe, leakproof and fully automatic dynamicstring package. The same techniques also work for an arbitrary precision arithmetic package [Fisher83] and for managing the "roots" of a real-time garbage-collected heap [Baker78] [Baker91SP] [Baker92Tread]. Complex embedded systems require dynamic resource management to achieve flexibility. However, unless these resources are carefully controlled, the resource management process itself may become a significant source of system failures. If, for example, the same resource is accidently allocated for two different purposes at the same time, the inadvertent simultaneous use of the resource by the two different parties can result in total chaos, leading to immediate system failure. If, on the other hand, some portion of the resource becomes misplaced, then the system can fail due to resource "starvation". Although the first case is clearly worse than the second, resource starvation will quickly cause system failure in very dynamic systems where the turnover of a resource exceeds the amount available. It is not enough, however, that the individual resource management primitives are properly constructed; their use by the system must be capable of reclaiming resources automatically when they are no longer in use. 1 This is because as the size and complexity of a system grows, the likelihood also increases for the situation where a program which depends upon explicit deallocation either forgets to deallocate the resource, or worse, deallocates it twice, which may later lead to double allocation. Of course, there exist schemes for detecting some of these errors [Mendal87], but most of these schemes work only at runtime, when it may be too late. Furthermore, any scheme capable of recognizing every erroneous situation of this type has the same overhead as would a fully-automatic deallocation scheme. Finally, the overheads for fully-automatic resource management are not nearly as expensive as many assume. Thus, in a large and complex system, it becomes prudent and efficient to utilize fully-automatic resource deallocation, so that a much greater level of safety which can be achieved, coupled with a relatively small increase in overhead. One of the crucial issues to be faced in the building of a fully-automatic manager of dynamically-allocated resources in Ada83 is how to design the interface to the system in such a way that it is efficient, yet safe and leakproof. Such a manager is safe if it does not give access to the same resource to two different customers, and it is leakproof if it manages to eventually recover all resources when they can no longer be accessed by their current owner. Safety is clearly a primary concern, since the attempted use of a resource by two different customers for different purposes at the same time will almost certainly lead to disaster. That a resource manager is leakproof is also important, since the amount of the resource to be allocated is necessarily limited; otherwise, there would be no need for management. If resources are allowed to leak away, then the system will eventually fail from resource starvation. In [Baker91SP], we described one safe and leakproof scheme for allocating a certain scarce resourcea root of a garbage-collected heap. Because the safety and leakproofness of the entire garbage-collected heap depends critically upon the allocation and automatic deallocation of the roots of the heap, we used extraordinary efforts to design a safe and leakproof manager for these roots. Unfortunately, the scheme described in [Baker91SP] is still not totally safe, because it depends upon the program avoiding certain programming practises which, while deemed by Ada to be "erroneous", are not checked by either the compiler or the runtime system. For example, an aliasing of INOUT parameters can lead to an unsafe condition in the scheme of [Baker91SP] (see [Baker93Steal] for details). While this aliasing is considered "erroneous" by the Ada83 standard, it is nearly impossible to check for, and therefore most Ada83 systems don't bother to check for it. Since one of the primary 1 [Mendal87] states "there is no universal method by which an Ada program can itself automatically detect that its data will no longer be referenced". This paper and [Baker91SP] show that Mendal was needlessly pessimistic. 
Abstract-found: 1
Intro-found: 0
Reference: [Ada83LRM] <institution> Reference Manual for the Ada Programming Language. ANSI/MIL-STD-1815A-1983, U.S. Gov't Printing Office, </institution> <address> Wash., DC, </address> <year> 1983. </year>
Reference: [Baker78] <author> Baker, H.G. </author> <title> "List Processing in Real Time on a Serial Computer". </title> <journal> CACM 21,4 (April1978), </journal> <pages> 280-294. </pages>
Reference: [Baker89] <author> Baker, H. </author> <title> "The NIMBLE ProjectReal-Time Common Lisp for Embedded Exprt System Applications". </title> <booktitle> Proc. 1989 AIAA Computers in Aerospace Conf., </booktitle> <address> Monterey, CA, </address> <year> 1989. </year>
Reference-contexts: We have extended the scheme used here into a management scheme for the roots of a garbage-collected Lisp system written in Ada83 <ref> [Baker89] </ref>. Although generational garbage collectors are often more efficient than reference-counting collectors, we have found that the additional cost of performing both reference counting and tracing garbage collection in Ada83 is only marginally greater than the cost of performing simple tracing garbage collection.
Reference: [Baker91SP] <author> Baker, H.G. </author> <title> "Structured Programming with Limited Private Types in Ada: Nesting is for the Soaring Eagles". </title> <journal> ACM Ada Letters XI,5 (July/Aug. </journal> <year> 1991), </year> <pages> 79-90. </pages>
Reference-contexts: That a resource manager is leakproof is also important, since the amount of the resource to be allocated is necessarily limited; otherwise, there would be no need for management. If resources are allowed to leak away, then the system will eventually fail from resource starvation. In <ref> [Baker91SP] </ref>, we described one safe and leakproof scheme for allocating a certain scarce resourcea root of a garbage-collected heap. <p> Because the safety and leakproofness of the entire garbage-collected heap depends critically upon the allocation and automatic deallocation of the roots of the heap, we used extraordinary efforts to design a safe and leakproof manager for these roots. Unfortunately, the scheme described in <ref> [Baker91SP] </ref> is still not totally safe, because it depends upon the program avoiding certain programming practises which, while deemed by Ada to be "erroneous", are not checked by either the compiler or the runtime system. <p> For example, an aliasing of INOUT parameters can lead to an unsafe condition in the scheme of <ref> [Baker91SP] </ref> (see [Baker93Steal] for details). While this aliasing is considered "erroneous" by the Ada83 standard, it is nearly impossible to check for, and therefore most Ada83 systems don't bother to check for it. <p> Since one of the primary 1 [Mendal87] states "there is no universal method by which an Ada program can itself automatically detect that its data will no longer be referenced". This paper and <ref> [Baker91SP] </ref> show that Mendal was needlessly pessimistic. <p> The designer of a limited private datatype can deny to the user any variables of the type, if it exports no variables of the type and does not otherwise make such variables availablee.g., through generic units <ref> [Baker91SP] </ref>. <p> The semantics of the built-in task and file types already use "by reference" parameter passing to avoid chaos, so that same 7 We note that our previous scheme presented in <ref> [Baker91SP] </ref> could be more prompt in deallocating, since its stack expanded and contracted in strict synchrony with the main task's stack. The ability to return values of the managed type makes such synchrony impossible in the current scheme.
Reference: [Baker92Tread] <author> Baker, H.G. </author> <title> "The Treadmill: Real-Time Garbage Collection without Motion Sickness". </title> <journal> ACM Sigplan Not. 27,3 (March1992), </journal> <pages> 66-70. </pages>
Reference: [Baker92CONS] <author> Baker, H.G. </author> <title> "CONS Should not CONS its Arguments, or, a Lazy Alloc is a Smart Alloc". </title> <journal> ACM Sigplan Not. 27,3 (March1992), </journal> <pages> 24-34. </pages>
Reference-contexts: Our handling of references which escape to Ada has certain similarities to the scheme proposed in <ref> [Baker92Cons] </ref> as well as to certain "generational" garbage collection schemes [Lieberman83] [Ungar84]. We have extended the scheme used here into a management scheme for the roots of a garbage-collected Lisp system written in Ada83 [Baker89].
Reference: [Baker93ER] <author> Baker, H.G. </author> <title> "Equal Rights for Functional Object, or, The More Things Change, The More They Are the Same". </title> <journal> ACM OOPS Messenger 4,4 (Oct.1993), </journal> <pages> 2-27. </pages>
Reference-contexts: If DSTRING were not a limited type, we could have utilized the following code: declare fx: constant dstring := f (x); begin return h (fx,g (fx)); end; However, due to Ada83's confusion over the difference between a variablea container for a valueand a value itself [MacLennan82] <ref> [Baker93ER] </ref>, Ada83 mistakenly thinks that the ":=" in a "constant initialization" is a form of assignment, when it is just another form of renaming, only for values rather than for variables.
Reference: [Baker92LLL] <author> Baker, H.G. </author> <title> "Lively Linear Lisp'Look Ma, No Garbage!'". </title> <journal> ACM Sigplan Notices 27,8 (Aug.1992), </journal> <pages> 89-98. </pages>
Reference: [Baker93Steal] <author> Baker, H.G. </author> <title> "How to Steal from a Limited Private AccountWhy Mode INOUT Parameters for Limited Types Must be Passed by Reference". </title> <journal> ACM Ada Letters XIII,3 (May/June1993), </journal> <pages> 91-95. </pages>
Reference-contexts: For example, an aliasing of INOUT parameters can lead to an unsafe condition in the scheme of [Baker91SP] (see <ref> [Baker93Steal] </ref> for details). While this aliasing is considered "erroneous" by the Ada83 standard, it is nearly impossible to check for, and therefore most Ada83 systems don't bother to check for it. <p> Since a "copy-in, copy-out" implementation of mode INOUT can be used outside the defining package to destroy the integrity of the resource protected by a limited private type <ref> [Baker93Steal] </ref>, and since we aspire to the greatest level of safety, we are forced to emulate "by reference" parameter passing ourselves for our dynamic string variables. 2 Once we have a separate type for dynamic string variables, we will need a separate coercion to extract values from these variables; the function <p> The following comments are grouped in no particular order. The protection from unwanted copying and assignment of Ada83 limited types is severely compromised by Ada83's allowance of "copy-in, copy-out" semantics for INOUT parameters of these types (see <ref> [Baker93Steal] </ref> for an in-depth study of this problem). As we have discussed above, the insecurities of potential copying due to INOUT parameters mean that mode INOUT parameters are completely useless in an Ada83 secure limited private type.
Reference: [Beidler92] <author> Beidler, John. </author> <title> "Relaxing the Constraints on Ada's limited private Types through Functional Expressions". Ada Letters XII, </title> <address> 2 (Mar/Apr1992),57-61. </address>
Reference: [Fisher83] <author> Fisher, Gerry. </author> <title> "Universal Arithmetic Packages". </title> <journal> ACM Ada Letters III,6 (1983),30-47. </journal>
Reference: [Harms91] <author> Harms, D.E., and Weide, B.W. </author> <title> "Copying and Swapping: Influences on the Design of Reusable Software Components". </title> <journal> IEEE Trans. SW Engrg. 17,5 (May1991), </journal> <pages> 424-435. </pages>
Reference: [Kieburtz76] <author> Kieburtz, R.B. </author> <title> "Programming without pointer variables". </title> <booktitle> Proc. Conf. on Data: Abstraction, Definition and Structure, Sigplan Not. 11 (spec. issue 1976), </booktitle> <pages> 95-107. </pages>
Reference: [Kownacki87] <author> Kownacki, R., and Taft, S.T. </author> <title> "Portable and Efficient Dynamic Storage Management in Ada". </title> <booktitle> Proc. ACM SigAda Int'l. Conf. "Using Ada", </booktitle> <month> Dec. </month> <year> 1987, </year> <pages> 190-198. </pages>
Reference-contexts: First, we note that our DSTRINGS package exports two limited private typesone type for the dynamic strings themselves, and one type for dynamic string variables. Most books and papers recommend exporting only a single type, and then using mode INOUT for variables of the private value [Mendal87] <ref> [Kownacki87] </ref>. We cannot recommend this approach, however, because Ada83 steadfastly refuses to require the passing of mode INOUT parameters of a limited type "by reference". <p> ACM Ada Letters XIII,5 (Sept./Oct.1993), 32-42. 1992,1993 by Nimble Computer Corporation. 7 decrement were performed first, then the decrement routine could deallocate the value before it realized that a reference to it was being saved back again <ref> [Kownacki87] </ref>. Incrementing before decrementing, on the other hand, always works. The other generic unit defined by DSTRINGS is the generic LET function. The generic LET function is similar to the generic PROG package in that it takes a user subprogram formal parameter and passes a new string variable to it.
Reference: [Lieberman83] <author> Lieberman, H., and Hewitt, C. </author> <title> "A Real-Time Garbage Collector Based on the Lifetimes of Objects". </title> <journal> CACM 26,6 (June 1983), </journal> <pages> 419-429. </pages>
Reference-contexts: Our handling of references which escape to Ada has certain similarities to the scheme proposed in [Baker92Cons] as well as to certain "generational" garbage collection schemes <ref> [Lieberman83] </ref> [Ungar84]. We have extended the scheme used here into a management scheme for the roots of a garbage-collected Lisp system written in Ada83 [Baker89].
Reference: [MacLennan82] <author> MacLennan, B.J. </author> <title> "Values and Objects in Programming Languages". Sigplan Not. </title> <address> 17,12 (Dec. </address> <year> 1982), </year> <pages> 70-79. </pages>
Reference-contexts: If DSTRING were not a limited type, we could have utilized the following code: declare fx: constant dstring := f (x); begin return h (fx,g (fx)); end; However, due to Ada83's confusion over the difference between a variablea container for a valueand a value itself <ref> [MacLennan82] </ref> [Baker93ER], Ada83 mistakenly thinks that the ":=" in a "constant initialization" is a form of assignment, when it is just another form of renaming, only for values rather than for variables.
Reference: [Mendal87] <author> Mendal, </author> <title> G.O. "Storage Reclamation Models for Ada Programs". </title> <booktitle> Proc. ACM SigAda Int'l. Conf., Ada Letters, </booktitle> <month> Dec. </month> <year> 1987, </year> <pages> 180-189. </pages>
Reference-contexts: Of course, there exist schemes for detecting some of these errors <ref> [Mendal87] </ref>, but most of these schemes work only at runtime, when it may be too late. Furthermore, any scheme capable of recognizing every erroneous situation of this type has the same overhead as would a fully-automatic deallocation scheme. <p> While this aliasing is considered "erroneous" by the Ada83 standard, it is nearly impossible to check for, and therefore most Ada83 systems don't bother to check for it. Since one of the primary 1 <ref> [Mendal87] </ref> states "there is no universal method by which an Ada program can itself automatically detect that its data will no longer be referenced". This paper and [Baker91SP] show that Mendal was needlessly pessimistic. <p> First, we note that our DSTRINGS package exports two limited private typesone type for the dynamic strings themselves, and one type for dynamic string variables. Most books and papers recommend exporting only a single type, and then using mode INOUT for variables of the private value <ref> [Mendal87] </ref> [Kownacki87]. We cannot recommend this approach, however, because Ada83 steadfastly refuses to require the passing of mode INOUT parameters of a limited type "by reference".
Reference: [Rosen87] <author> Rosen, Steven M. </author> <title> "Controlling Dynamic Objects in Large Ada Systems". </title> <booktitle> ACM Ada Letters VII,5 (1987), </booktitle> <pages> 79-92. </pages>
Reference: [STEELMAN78] <author> Dept. </author> <title> of Defense STEELMAN requirements for high order computer programming languages. </title> <month> June, </month> <year> 1978. </year>
Reference: [Taft91] <author> Taft, S. Tucker, et al. </author> <title> Ada-9X Draft Mapping Document. </title> <institution> Wright Lab., AFSC, Eglin AFB,FL, </institution> <month> Feb. </month> <year> 1991. </year>
Reference: [Ungar84] <author> Unger, D. </author> <title> "Generation Scavenging: A nondisruptive, high performance storage reclamation algorithm". </title> <journal> ACM Soft. Eng. Symp. on Prac. SW Dev. Envs., Sigplan Not. </journal> <month> 19,6 (June </month> <year> 1984), </year> <pages> 157-167. </pages> <editor> [vanWijngaarden77] van Wijngaarden, A., et al. </editor> <title> "Revised Report on the Algorithmic Language Algol 68". </title> <journal> ACM Sigplan Not. 12,5 (May1977), </journal> <pages> 1-70. </pages>
Reference-contexts: Our handling of references which escape to Ada has certain similarities to the scheme proposed in [Baker92Cons] as well as to certain "generational" garbage collection schemes [Lieberman83] <ref> [Ungar84] </ref>. We have extended the scheme used here into a management scheme for the roots of a garbage-collected Lisp system written in Ada83 [Baker89].
Reference: [Yen90] <author> Yen, Mike. </author> <title> "Using a Dynamic Memory Management Package to Facilitate Building Lisp-like Data Structures in Ada". </title> <booktitle> Proc. </booktitle> <address> AIDA-90, </address> <month> Nov. </month> <year> 1990, </year> <pages> 85-93. </pages>
References-found: 22

