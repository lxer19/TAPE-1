URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/Web/People/rwh/papers/callcc/jfp.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/Web/People/rwh/papers.html
Root-URL: http://www.cs.cmu.edu
Title: Typing First-Class Continuations in ML  
Author: Robert Harper Bruce F. Duba David MacQueen 
Date: November 4, 1993  
Abstract: An extension of ML with continuation primitives similar to those found in Scheme is considered. A number of alternative type systems are discussed, and several programming examples are given. A continuation-based operational semantics is defined for a small, purely functional, language, and the soundness of the Damas-Milner polymorphic type assignment system with respect to this semantics is proved. The full Damas-Milner type system is shown to be unsound in the presence of first-class continuations. Restrictions on polymorphism similar to those introduced in connection with reference types are shown to suffice for soundness.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In J. Maluszynski and M. Wirsing, editors, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: It is here that the two constructs differ in an ML-like setting. Another way of typing continuations, and the one currently adopted in Standard ML of New Jersey <ref> [1] </ref>, is to abandon the view that continuations are functions in the ordinary sense and to consider t cont as a primitive type with an operation throw for invoking a continuation.
Reference: [2] <author> William Clinger, Daniel P. Friedman, and Mitchell Wand. </author> <title> A scheme for higher-level semantic algebra. </title> <editor> In Maurice Nivat and John C. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, </booktitle> <pages> pages 237-250. </pages> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1985. </year>
Reference-contexts: In a typical implementation the final result is passed to the interactive top-level, which prints the result, and continues by evaluating the next expression. Around 1982 the special-form catch was replaced by call-with-current-continuation or call/cc for short <ref> [2] </ref>. The act of capturing the current continuation did not require a special variable binding form, but could be performed by a primitive operator whose argument was a function that would be applied to the captured continuation. Therefore, (catch x body) becomes (call/cc (lambda (x) body)) in Scheme.
Reference: [3] <author> Eric C. Cooper and J. Gregory Morrisett. </author> <title> Adding threads to Standard ML. </title> <type> Technical Report CMU-CS-90-186, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: Continuations have been used as the basis for the implementations of several process facilities for Standard ML of New Jersey, some of which use preemptive scheduling <ref> [28, 3, 27, 35] </ref>.
Reference: [4] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <year> 1982. </year>
Reference-contexts: We begin by recalling the polymorphic type assignment system introduced by Damas and Milner <ref> [4] </ref>. This type system will form the basis of our investigation of the typing properties of the continuation-passing primitives introduced in Section 2. We then give a continuation-passing structured operational semantics for this language, and prove the soundness of type assignment with respect to this semantics. <p> We consider two approaches to recovering soundness, one based on the restriction of polymorphism to values, and the other based on Tofte's notion of imperative type variable [39]. 3.1 The Damas-Milner Language We begin by recalling the polymorphic type assignment system introduced by Damas and Milner <ref> [4] </ref>. <p> We sometimes abbreviate Close (t ) to just Close (t ) when is the empty context. The formal system of Table 1 is clearly a subsystem of the system given by Damas and Milner <ref> [4] </ref> in the sense that if ` e : t is derivable in the system of Table 1, then it is derivable in Damas and Milner's system.
Reference: [5] <author> Bruce Duba, Robert Harper, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1991. </year> <month> 13 </month>
Reference-contexts: To obtain such a result in this setting seems to require the use of an appropriate form of logical relation [26, 33]. An alternative is to consider the typing properties of the call-by-value cps transform, from which an observational soundness theorem may be extracted <ref> [5, 18, 24] </ref>. 3.4 First-Class Continuations To account for the continuation-passing primitives introduced in Section 2, we extend the language of mono-types as follows: monotypes t ::= . . . j t cont The signature cont is given by the following declarations: callcc : 8t:(t cont!t)!t throw : 8s:8t:s cont!s!t The
Reference: [6] <author> R. Kent Dybvig and Bob Hieb. </author> <title> Engines from continuations. </title> <journal> Journal of Computer Languages, </journal> <volume> 14(2):109--124, </volume> <year> 1989. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [22], exceptions [41], and logic variables [8, 19], for supporting multiple threads of control <ref> [6, 20, 28, 40] </ref>, for providing asynchronous signal handlers [29], and for implementing non-blind backtracking [15] and dynamic barriers such as unwind-protect [21]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [11, 12, 37].
Reference: [7] <author> Arthur Evans. </author> <title> PAL a language designed for teaching programming linguistics. </title> <booktitle> In Proc. ACM 23rd National Conference, </booktitle> <pages> pages 395-403, </pages> <address> Princeton, 1968. </address> <publisher> ACM, Brandin Systems Press. </publisher>
Reference-contexts: Research Projects Agency (DARPA) under ARPA order 6253. x AT&T Bell Laboratories, Murray Hill, NJ 07974 1 2 Adding First-Class Continuations to ML First-class continuations are an abstraction that evolved from various nonstandard control structures such as Landin's J-operator [23], Reynold's escape [31], label variables in Gedanken [30] and PAL <ref> [7] </ref>, and from the semantic analyses of general control structures, including jumps [34]. Scheme [36] originally introduced a binding construct (catch k body) that captured its own expression continuation and bound it to the variable k, with the expression body as the scope of the binding.
Reference: [8] <author> Matthias Felleisen. </author> <title> Transliterating Prolog into Scheme. </title> <type> Technical Report 182, </type> <institution> Indiana University Computer Science Department, </institution> <year> 1985. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [22], exceptions [41], and logic variables <ref> [8, 19] </ref>, for supporting multiple threads of control [6, 20, 28, 40], for providing asynchronous signal handlers [29], and for implementing non-blind backtracking [15] and dynamic barriers such as unwind-protect [21].
Reference: [9] <author> Matthias Felleisen. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 180-190, </pages> <address> San Diego, CA, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: Expressions differing only in the names of the bound variables are identified; we are therefore free to assume that bound variable names may always be chosen so as to avoid conflicts. 2 The interface between the interactive system and the object level evaluation is similar to a prompt <ref> [9] </ref>. 6 The syntax of type expressions is given by the following grammar: monotypes t ::= b j t j t 1 !t 2 polytypes ::= t j 8t: The metavariable t ranges over a countably infinite set of type variables, and the metavariable b ranges over a countable set of
Reference: [10] <author> Matthias Felleisen and Daniel Friedman. </author> <title> Control operators, the SECD machine, and the -calculus. In Formal Description of Programming Concepts III. </title> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: We sometimes write e ) a to mean [] ` e ) a. The idea underlying the operational semantics is that in a judgement k ` e ) a the continuation k represents an "evaluation context" (in the sense of Felleisen <ref> [10] </ref>), and e represents the expression being evaluated in that context. If e is a value, then evaluation continues by replacing the "hole" in k with v, and re-starting the evaluation process.
Reference: [11] <author> Matthias Felleisen, Daniel Friedman, Eugene Kohlbecker, and Bruce Duba. </author> <title> Reasoning with continuations. </title> <booktitle> In First Symposium on Logic in Computer Science. IEEE, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed <ref> [11, 12, 37] </ref>. Recent studies of continuations have addressed the question of their typing in a restricted setting [13, 14, 16] and their impact on full abstraction results [32].
Reference: [12] <author> Matthias Felleisen, Daniel Friedman, Eugene Kohlbecker, and Bruce Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Computer Science, </journal> <volume> 52(3) </volume> <pages> 205-237, </pages> <year> 1987. </year>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed <ref> [11, 12, 37] </ref>. Recent studies of continuations have addressed the question of their typing in a restricted setting [13, 14, 16] and their impact on full abstraction results [32].
Reference: [13] <author> Andrzej Filinski. </author> <title> Declarative continuations: An investigation of duality in programming language semantics. </title> <booktitle> In Summer Conference on Category Theory and Computer Science, volume 389 of Lecture Notes in Computer Science, </booktitle> <address> Manchester, UK, 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [11, 12, 37]. Recent studies of continuations have addressed the question of their typing in a restricted setting <ref> [13, 14, 16] </ref> and their impact on full abstraction results [32]. The subject of this paper is the extension of Standard ML with primitives for first-class continuations similar to those found in Scheme.
Reference: [14] <author> Andrzej Filinski. </author> <title> Declarative continuations and categorical duality. </title> <type> Master's thesis, </type> <institution> University of Copenhagen, Copenhagen, Denmark, </institution> <month> August </month> <year> 1989. </year> <type> (DIKU Report 89/11). </type>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [11, 12, 37]. Recent studies of continuations have addressed the question of their typing in a restricted setting <ref> [13, 14, 16] </ref> and their impact on full abstraction results [32]. The subject of this paper is the extension of Standard ML with primitives for first-class continuations similar to those found in Scheme.
Reference: [15] <author> Daniel P. Friedman, Christopher T. Haynes, and Eugene Kohlbecker. </author> <title> Programming with continuations. </title> <editor> In P. Pepper, editor, </editor> <booktitle> Program Transformations and Programming Environments, </booktitle> <pages> pages 263-274. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [22], exceptions [41], and logic variables [8, 19], for supporting multiple threads of control [6, 20, 28, 40], for providing asynchronous signal handlers [29], and for implementing non-blind backtracking <ref> [15] </ref> and dynamic barriers such as unwind-protect [21]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [11, 12, 37].
Reference: [16] <author> Timothy Griffin. </author> <title> A formulae-as-types notion of control. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year> <note> ACM, ACM. </note>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [11, 12, 37]. Recent studies of continuations have addressed the question of their typing in a restricted setting <ref> [13, 14, 16] </ref> and their impact on full abstraction results [32]. The subject of this paper is the extension of Standard ML with primitives for first-class continuations similar to those found in Scheme.
Reference: [17] <author> Timothy G. Griffin. </author> <title> Logical interpretations and computational simulations. </title> <type> Tech. memo., </type> <institution> AT&T Bell Laboratories, </institution> <year> 1992. </year> <note> in preparation. </note>
Reference-contexts: A stack of stamps is used because "top-level" evaluations may be nested when files are loaded with the use function. Another interesting issue is the relation between continuations and exception handling. (See also Griffin's recent work on this subject <ref> [17] </ref>.) In the dynamic semantics of Standard ML, an expression can produce either a normal value or an exception packet indicating that an exception has been raised but not handled during the evaluation of the expression.
Reference: [18] <author> Robert Harper and Mark Lillibridge. </author> <title> Polymorphic type assignment and cps conversion. </title> <editor> In Olivier Danvy and Carolyn Talcott, editors, </editor> <booktitle> Proceedings of the ACM SIGPLAN Workshop on Continuations CW92, </booktitle> <pages> pages 13-22, </pages> <address> Stanford, CA 94305, </address> <month> June </month> <year> 1992. </year> <institution> Department of Computer Science, Stanford University. </institution> <note> Published as technical report STAN-CS-92-1426. </note>
Reference-contexts: To obtain such a result in this setting seems to require the use of an appropriate form of logical relation [26, 33]. An alternative is to consider the typing properties of the call-by-value cps transform, from which an observational soundness theorem may be extracted <ref> [5, 18, 24] </ref>. 3.4 First-Class Continuations To account for the continuation-passing primitives introduced in Section 2, we extend the language of mono-types as follows: monotypes t ::= . . . j t cont The signature cont is given by the following declarations: callcc : 8t:(t cont!t)!t throw : 8s:8t:s cont!s!t The <p> Despite the superficial plausibility of the typing rules for callcc and throw, the full polymorphic type assignment system for the extended language is unsound. 3 Specifically, assume that we 3 This result was obtained jointly by Mark Lillibridge and the first author <ref> [18] </ref>. 10 have base types int and bool, and constants true : bool and 1 : int.
Reference: [19] <author> Christopher T. Haynes. </author> <title> Logic continuations. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 157-176, </pages> <year> 1987. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [22], exceptions [41], and logic variables <ref> [8, 19] </ref>, for supporting multiple threads of control [6, 20, 28, 40], for providing asynchronous signal handlers [29], and for implementing non-blind backtracking [15] and dynamic barriers such as unwind-protect [21].
Reference: [20] <author> Christopher T. Haynes and Daniel P. Friedman. </author> <title> Abstracting timed preemption with engines. </title> <journal> Journal of Computer Languages, </journal> <volume> 12 </volume> <pages> 109-121, </pages> <year> 1987. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [22], exceptions [41], and logic variables [8, 19], for supporting multiple threads of control <ref> [6, 20, 28, 40] </ref>, for providing asynchronous signal handlers [29], and for implementing non-blind backtracking [15] and dynamic barriers such as unwind-protect [21]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [11, 12, 37].
Reference: [21] <author> Christopher T. Haynes and Daniel P. Friedman. </author> <title> Embedding continuations in procedural objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9 </volume> <pages> 582-598, </pages> <year> 1987. </year>
Reference-contexts: provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [22], exceptions [41], and logic variables [8, 19], for supporting multiple threads of control [6, 20, 28, 40], for providing asynchronous signal handlers [29], and for implementing non-blind backtracking [15] and dynamic barriers such as unwind-protect <ref> [21] </ref>. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [11, 12, 37]. Recent studies of continuations have addressed the question of their typing in a restricted setting [13, 14, 16] and their impact on full abstraction results [32].
Reference: [22] <author> Christopher T. Haynes, Daniel P. Friedman, and Mitchell Wand. </author> <title> Obtaining coroutines from continuations. </title> <journal> Journal of Computer Languages, </journal> <volume> 11 </volume> <pages> 143-153, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction First-class continuations are a simple and natural way to provide access to the flow of evaluation in functional languages. The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines <ref> [22] </ref>, exceptions [41], and logic variables [8, 19], for supporting multiple threads of control [6, 20, 28, 40], for providing asynchronous signal handlers [29], and for implementing non-blind backtracking [15] and dynamic barriers such as unwind-protect [21].
Reference: [23] <author> Peter J. Landin. </author> <title> A correspondence between ALGOL-60 and Church's lambda notation. </title> <journal> Communications of the ACM, </journal> <volume> 8 </volume> <pages> 89-101, </pages> <year> 1965. </year>
Reference-contexts: This research was supported in part by the Defense Advanced Research Projects Agency (DARPA) under ARPA order 6253. x AT&T Bell Laboratories, Murray Hill, NJ 07974 1 2 Adding First-Class Continuations to ML First-class continuations are an abstraction that evolved from various nonstandard control structures such as Landin's J-operator <ref> [23] </ref>, Reynold's escape [31], label variables in Gedanken [30] and PAL [7], and from the semantic analyses of general control structures, including jumps [34].
Reference: [24] <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs, volume 224 of Lecture Notes in Computer Science, </booktitle> <pages> pages 219-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <month> 14 </month>
Reference-contexts: To obtain such a result in this setting seems to require the use of an appropriate form of logical relation [26, 33]. An alternative is to consider the typing properties of the call-by-value cps transform, from which an observational soundness theorem may be extracted <ref> [5, 18, 24] </ref>. 3.4 First-Class Continuations To account for the continuation-passing primitives introduced in Section 2, we extend the language of mono-types as follows: monotypes t ::= . . . j t cont The signature cont is given by the following declarations: callcc : 8t:(t cont!t)!t throw : 8s:8t:s cont!s!t The
Reference: [25] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Notational conventions similar to those for contexts apply to signatures. We shall work with a syntax-directed formulation of the Damas-Milner polymorphic type assignment system inspired by the static semantics of Standard ML <ref> [25] </ref>. The rules given in Table 1 define a formal system for deriving judgements of the form ` e : t , expressing that the expression e may be assigned the monotype t in context . The rules are parametric in a signature , which we leave implicit.
Reference: [26] <author> Gordon Plotkin. </author> <title> Lambda-definability in the full type hierarchy. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays in Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 363-373. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: To obtain such a result in this setting seems to require the use of an appropriate form of logical relation <ref> [26, 33] </ref>.
Reference: [27] <author> Norman Ramsey. </author> <title> Concurrent programming in ML. </title> <type> Technical Report CS-TR-262-90, </type> <institution> Computer Science Department, Princeton University, </institution> <year> 1990. </year>
Reference-contexts: Continuations have been used as the basis for the implementations of several process facilities for Standard ML of New Jersey, some of which use preemptive scheduling <ref> [28, 3, 27, 35] </ref>.
Reference: [28] <author> John Reppy. </author> <title> First-class synchronous operations in standard ML. </title> <type> Technical Report TR 89-1068, </type> <institution> Computer Science Department, Cornell University, </institution> <address> Ithaca, NY, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [22], exceptions [41], and logic variables [8, 19], for supporting multiple threads of control <ref> [6, 20, 28, 40] </ref>, for providing asynchronous signal handlers [29], and for implementing non-blind backtracking [15] and dynamic barriers such as unwind-protect [21]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [11, 12, 37]. <p> Continuations have been used as the basis for the implementations of several process facilities for Standard ML of New Jersey, some of which use preemptive scheduling <ref> [28, 3, 27, 35] </ref>.
Reference: [29] <author> John Reppy. </author> <title> Asynchronous signals in Standard ML. </title> <type> (Unpublished manuscript.), </type> <month> August </month> <year> 1990. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [22], exceptions [41], and logic variables [8, 19], for supporting multiple threads of control [6, 20, 28, 40], for providing asynchronous signal handlers <ref> [29] </ref>, and for implementing non-blind backtracking [15] and dynamic barriers such as unwind-protect [21]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [11, 12, 37]. <p> Another use of continuations is to provide a clean, typed interface for asynchronous signal handling <ref> [29] </ref>. In Standard ML of New Jersey the type of a signal handler is (int * unit cont) -&gt; unit cont, where the argument is a pair consisting of a count of pending signals of the kind being handled and a continuation representing the state of the interrupted process.
Reference: [30] <author> John C. Reynolds. </author> <title> GEDANKEN | a simple typeless languages based on the principle of completeness and the reference concept. </title> <journal> Communications of the ACM, </journal> <volume> 13(5) </volume> <pages> 308-319, </pages> <month> May </month> <year> 1970. </year>
Reference-contexts: the Defense Advanced Research Projects Agency (DARPA) under ARPA order 6253. x AT&T Bell Laboratories, Murray Hill, NJ 07974 1 2 Adding First-Class Continuations to ML First-class continuations are an abstraction that evolved from various nonstandard control structures such as Landin's J-operator [23], Reynold's escape [31], label variables in Gedanken <ref> [30] </ref> and PAL [7], and from the semantic analyses of general control structures, including jumps [34]. Scheme [36] originally introduced a binding construct (catch k body) that captured its own expression continuation and bound it to the variable k, with the expression body as the scope of the binding.
Reference: [31] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Conference Record of the 25th National ACM Conference, </booktitle> <pages> pages 717-740, </pages> <address> Boston, </address> <month> August </month> <year> 1972. </year> <note> ACM. </note>
Reference-contexts: was supported in part by the Defense Advanced Research Projects Agency (DARPA) under ARPA order 6253. x AT&T Bell Laboratories, Murray Hill, NJ 07974 1 2 Adding First-Class Continuations to ML First-class continuations are an abstraction that evolved from various nonstandard control structures such as Landin's J-operator [23], Reynold's escape <ref> [31] </ref>, label variables in Gedanken [30] and PAL [7], and from the semantic analyses of general control structures, including jumps [34].
Reference: [32] <author> Dorai Sitaram and Matthias Felleisen. </author> <title> Reasoning with continuations II: Full abstraction for models of control. </title> <booktitle> In Proc. 1990 Conference on LISP and Functional Programming, </booktitle> <pages> pages 161-175, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [11, 12, 37]. Recent studies of continuations have addressed the question of their typing in a restricted setting [13, 14, 16] and their impact on full abstraction results <ref> [32] </ref>. The subject of this paper is the extension of Standard ML with primitives for first-class continuations similar to those found in Scheme.
Reference: [33] <author> Richard Statman. </author> <title> Logical relations and the typed -calculus. </title> <journal> Information and Control, </journal> <volume> 65 </volume> <pages> 85-97, </pages> <year> 1985. </year>
Reference-contexts: To obtain such a result in this setting seems to require the use of an appropriate form of logical relation <ref> [26, 33] </ref>.
Reference: [34] <author> Christopher Strachey and Christopher Wadsworth. </author> <title> A mathematical semantics for handling full jumps. </title> <type> Technical Report Technical Monograph PRG-11, </type> <institution> Oxford University Computing Laboratory, </institution> <year> 1974. </year>
Reference-contexts: Murray Hill, NJ 07974 1 2 Adding First-Class Continuations to ML First-class continuations are an abstraction that evolved from various nonstandard control structures such as Landin's J-operator [23], Reynold's escape [31], label variables in Gedanken [30] and PAL [7], and from the semantic analyses of general control structures, including jumps <ref> [34] </ref>. Scheme [36] originally introduced a binding construct (catch k body) that captured its own expression continuation and bound it to the variable k, with the expression body as the scope of the binding.
Reference: [35] <author> Bernard Sufrin. </author> <title> CSP-style processes in ML. </title> <type> (Private communication), </type> <year> 1989. </year>
Reference-contexts: Continuations have been used as the basis for the implementations of several process facilities for Standard ML of New Jersey, some of which use preemptive scheduling <ref> [28, 3, 27, 35] </ref>.
Reference: [36] <author> Gerald Jay Sussman and Jr. Guy Lewis Steele. </author> <title> Scheme: An interpreter for extended lambda calculus. </title> <type> Technical Report Memo No. 349, </type> <institution> MIT AI Laboratory, </institution> <month> December </month> <year> 1975. </year>
Reference-contexts: Scheme <ref> [36] </ref> originally introduced a binding construct (catch k body) that captured its own expression continuation and bound it to the variable k, with the expression body as the scope of the binding.
Reference: [37] <author> Carolyn Talcott. Rum: </author> <title> An intensional theory of function and control abstractions. </title> <booktitle> In Proc. 1987 Workshop of Foundations of Logic and Functional Programming, volume 306 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed <ref> [11, 12, 37] </ref>. Recent studies of continuations have addressed the question of their typing in a restricted setting [13, 14, 16] and their impact on full abstraction results [32].
Reference: [38] <author> Mads Tofte. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> Edinburgh University, </institution> <year> 1988. </year> <note> Available as Edinburgh University Laboratory for Foundations of Computer Science Technical Report ECS-LFCS-88-54. </note>
Reference-contexts: For instance, if the identity function is stored into a cell, then a single instance of its polymorphic type must be chosen for all subsequent retrievals: its polymorphic character is lost. (See Tofte's thesis <ref> [38] </ref> for further discussion of this point.) Thus if a continuation was represented as a function of polymorphic result type, then the result type, which is irrelevant since no result is actually returned, would have to be fixed when the continuation is stored, rather than when it is invoked. <p> However, certain combinations of the polymorphic let construct and first-class continuations lead to run-time type errors, as will be explained in Section 3. Restrictions on the type system similar to those considered by Tofte in connection with mutable cells <ref> [38, 39] </ref> suffice to recover soundness without sacrificing too many useful programs. These issues will be discussed in detail in Section 3, and a suitable soundness theorem can be obtained. For the remainder of this section we gloss over these issues, focusing instead on the use of first-class continuations.
Reference: [39] <author> Mads Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <month> Novem-ber </month> <year> 1990. </year>
Reference-contexts: However, certain combinations of the polymorphic let construct and first-class continuations lead to run-time type errors, as will be explained in Section 3. Restrictions on the type system similar to those considered by Tofte in connection with mutable cells <ref> [38, 39] </ref> suffice to recover soundness without sacrificing too many useful programs. These issues will be discussed in detail in Section 3, and a suitable soundness theorem can be obtained. For the remainder of this section we gloss over these issues, focusing instead on the use of first-class continuations. <p> We then show that the extension of the Damas-Milner type system with the continuation-passing primitives of Section 2 is unsound. We consider two approaches to recovering soundness, one based on the restriction of polymorphism to values, and the other based on Tofte's notion of imperative type variable <ref> [39] </ref>. 3.1 The Damas-Milner Language We begin by recalling the polymorphic type assignment system introduced by Damas and Milner [4]. <p> This can be achieved to a limited extent, at the expense of introducing a somewhat more complex type system adapted from Tofte's treatment of polymorphic references <ref> [39] </ref>. The set of type variables is divided into two disjoint infinite subsets, the applicative and the imperative type variables. Imperative type variables are written here with an underscore; applicative type variables are left unadorned.
Reference: [40] <author> Mitchell Wand. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Conference Record of the 1980 LISP Conference, </booktitle> <pages> pages 19-28, </pages> <year> 1980. </year>
Reference-contexts: The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [22], exceptions [41], and logic variables [8, 19], for supporting multiple threads of control <ref> [6, 20, 28, 40] </ref>, for providing asynchronous signal handlers [29], and for implementing non-blind backtracking [15] and dynamic barriers such as unwind-protect [21]. Tractable logics for reasoning about program equivalence in the presence of first-class continuations in an untyped setting have been developed [11, 12, 37].
Reference: [41] <author> Andrew Wright and Matthias Felleisen. </author> <title> The nature of exceptions in polymorphic lannguages. </title> <type> Unpublished manuscript, </type> <institution> Rice University, </institution> <year> 1990. </year>
Reference-contexts: 1 Introduction First-class continuations are a simple and natural way to provide access to the flow of evaluation in functional languages. The ability to seize the "current continuation" (control state of the evaluator) provides a simple and natural basis for defining numerous higher-level constructs such as coroutines [22], exceptions <ref> [41] </ref>, and logic variables [8, 19], for supporting multiple threads of control [6, 20, 28, 40], for providing asynchronous signal handlers [29], and for implementing non-blind backtracking [15] and dynamic barriers such as unwind-protect [21].
Reference: [42] <author> Andrew K. Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Department of Computer Science, Rice University, </institution> <month> July </month> <year> 1991. </year> <note> To appear, Information and Computation. 15 </note>
Reference-contexts: We prove a slightly stronger result admitting general evaluation contexts, and phrase the theorem in terms of preservation of typing under evaluation. (See Felleisen and Wright <ref> [42] </ref> for a similar perspective.) Theorem 3.2 Let ff be an arbitrary monotype. If k ` e ) a with e : t and x: Close (t ) ` k [x] : ff, then a is a value and a : ff.
References-found: 42

