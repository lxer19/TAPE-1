URL: ftp://flint.cs.yale.edu/pub/flint/publications/tic97.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Email: shao-zhong@cs.yale.edu  
Title: An Overview of the FLINT/ML Compiler over across the higher-order module boundaries; recursive and mutable
Author: Zhong Shao 
Note: type-directed compilation is carried  
Address: New Haven, CT 06520-8285  
Affiliation: Dept. of Computer Science Yale University  
Abstract: This paper gives an overview of these novel aspects, and a preliminary report on the current status of the implementation.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: The middle-end does simple dataflow optimizations and local or cross-module type specializations, and then produces an optimized version of the FLINT code. The back-end compiles FLINT into machine code through usual phases such as representation analysis [26], conventional and loop optimizations <ref> [1] </ref>, CPS-based contractions and reductions [3], closure conversion [28], and machine-code generation [8]. All these compilation stages are made independent of each other so that they can also be used as compiler infrastructure for other programming languages. <p> Similarly, given a functor application such as "H (S)", the corresponding Core-FLINT term will be of the form: @(e H <ref> [ 1 ] </ref>[ 2 ]:::[ n ])(e S ) where @e 1 e 2 is the Core-FLINT syntax for function applications (applying e 1 to e 2 ); symbol e H and e S denote the corresponding Core-FLINT terms for functor H and structure S (matched against signature SIG); and 1
Reference: [2] <author> W. E. Aitken and J. H. Reppy. </author> <title> Abstract value constructors. </title> <booktitle> In ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <pages> pages 1-11, </pages> <month> June </month> <year> 1992. </year> <note> Longer version available as Cornell Univ. Tech. Report. </note>
Reference-contexts: syntactic classes: kinds (), constructors (), types (), and terms (e), defined as follows: (kinds) ::= j 1 ! 2 j 1 2 (con's) ::= t j Int j Real j ! ( 1 ; 2 ) j fi ( 1 ; 2 ) j t :: : j 1 <ref> [ 2 ] </ref> j ( 1 ; 2 ) j 1 ; 2 1 ; 2 (types) ::= T () j 8t :: : j 1 ! 2 j 1 fi 2 (terms) e ::= x j i j f j he 1 ; e 2 i 1 ; 2 j <p> In the previous example, applying functor H to structure T is not allowed in the old SML/NJ compiler [29, 5] because data representation for S.foo is inconsistent with that for T.foo; this is no longer a problem in FLINT/ML. Furthermore, unlike other solutions for this problem <ref> [2] </ref>, under our scheme, the implementation of formal data constructors remains to be concrete most of the time (e.g., S.D). 4 Compiling FLINT The back-end of the FLINT/ML compiler translates the FLINT intermediate code into the machine code.
Reference: [3] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: The middle-end does simple dataflow optimizations and local or cross-module type specializations, and then produces an optimized version of the FLINT code. The back-end compiles FLINT into machine code through usual phases such as representation analysis [26], conventional and loop optimizations [1], CPS-based contractions and reductions <ref> [3] </ref>, closure conversion [28], and machine-code generation [8]. All these compilation stages are made independent of each other so that they can also be used as compiler infrastructure for other programming languages.
Reference: [4] <author> A. W. Appel. </author> <title> A critque of Standard ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(4) </volume> <pages> 391-429, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: In FLINT/ML, the injection and projection functions for S.B are implemented as type-directed primitives, which will check the runtime value of t to decide whether to use flat record or indirect pointer representations. This scheme also solves the nasty datatype representation problem raised by Appel <ref> [4] </ref>. In the previous example, applying functor H to structure T is not allowed in the old SML/NJ compiler [29, 5] because data representation for S.foo is inconsistent with that for T.foo; this is no longer a problem in FLINT/ML.
Reference: [5] <author> A. W. Appel and D. B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: This scheme also solves the nasty datatype representation problem raised by Appel [4]. In the previous example, applying functor H to structure T is not allowed in the old SML/NJ compiler <ref> [29, 5] </ref> because data representation for S.foo is inconsistent with that for T.foo; this is no longer a problem in FLINT/ML.
Reference: [6] <author> M. Blume. </author> <title> A compilation manager for SML/NJ. as part of SML/NJ User's Guide, </title> <year> 1995. </year>
Reference-contexts: With the use of suspension terms, type application is always done on a by-need basis, and once it is done, the result will be memoized for future use. Our preliminary measurements have shown that on heavily functorized applications such as SML/NJ Compilation Manager <ref> [6] </ref>, our optimized implementation is an order-of-magnitude faster than naive implementations. 4 3 Translation into FLINT The front-end of the FLINT/ML compiler translates the entire SML'97 [21] plus higher-order modules [20]) into the FLINT intermediate language.
Reference: [7] <author> N. de Bruijn. </author> <title> A survey of the project AUTOMATH. In To H. </title> <editor> B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <note> Edited by J. </note> <editor> P. Seldin and J. R. Hindley, </editor> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Naive implementation of these operations would lead to duplicate copying, redundant traversal, and extremely slow compilation. We use the following techniques to optimize the representations of kinds, constructors, and types ( see * We represent type variables as de Bruijn indices <ref> [7] </ref>. Under de Bruijn notations, all constructors and types have unique representations. * We then hash-cons all the kinds, constructors, and types into three separate hash-tables. Each kind (tkind), constructor (tyc), or type (lty) is represented as an internal hash cell (or icell).
Reference: [8] <author> L. George, F. Guillaume, and J. Reppy. </author> <title> A portable and optimizing backend for the SML/NJ compiler. </title> <booktitle> In Proceedings of the 1994 International Conference on Compiler Construction, </booktitle> <pages> pages 83-97. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: The back-end compiles FLINT into machine code through usual phases such as representation analysis [26], conventional and loop optimizations [1], CPS-based contractions and reductions [3], closure conversion [28], and machine-code generation <ref> [8] </ref>. All these compilation stages are made independent of each other so that they can also be used as compiler infrastructure for other programming languages.
Reference: [9] <author> J. Y. Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieur. </title> <type> PhD thesis, </type> <institution> University of Paris VII, </institution> <year> 1972. </year>
Reference-contexts: FLINT/ML can compile both functors and polymorphic functions into a predicative variant of the Girard-Reynolds polymorphic calculus, F ! <ref> [9, 25] </ref>, so functor specialization is just type application in F ! . This is not supported in any of the other three compilers. * Fourth, FLINT/ML uses several techniques such as hash consing, memoization, and Nadathur's suspension-based -calculus [23, 24] to optimize the representation of its typed intermediate format. <p> Like the ML i calculus used in the TIL compiler [22, 30], the core of FLINT is simply a predicative variant of the Girard-Reynolds polymorphic calculus F ! <ref> [9, 25] </ref>.
Reference: [10] <author> R. Harper and M. Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Twenty-first Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 123-137, </pages> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Recent research on ML modules have focused on giving type-theoretic semantics using dependent types [19, 11], translucent sums <ref> [10] </ref>, or manifest types [17, 18], none of these map ML modules directly into Core-FLINT-like calculus. We have developed an algorithm that translates ML modules (including even higher-order ones) into the Core-FLINT calculus. We make two simplifications during our translation: * Type generativity is ignored.
Reference: [11] <author> R. Harper and J. C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Recent research on ML modules have focused on giving type-theoretic semantics using dependent types <ref> [19, 11] </ref>, translucent sums [10], or manifest types [17, 18], none of these map ML modules directly into Core-FLINT-like calculus. We have developed an algorithm that translates ML modules (including even higher-order ones) into the Core-FLINT calculus. We make two simplifications during our translation: * Type generativity is ignored.
Reference: [12] <author> R. Harper, J. C. Mitchell, and E. Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Seventeenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 341-344, </pages> <address> New York, Jan 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: To translate a functor declaration into Core-FLINT, we use a phase-splitting algorithm <ref> [27, 12] </ref>.
Reference: [13] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <type> Technical Report CMU-CS-94-185, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> September </month> <year> 1994. </year> <month> 9 </month>
Reference-contexts: For example, coercing an object of type fi fl fl into type ff would involve first unboxing the fi and fl fields, and then pairing them up based on the actual types fi and fl have at runtime. 8 Unlike in the type-passing approach <ref> [30, 13] </ref>, all polymorphic values in our flexible scheme are indeed always boxed. This dramatically simplifies the implementation of polymorphism, because all polymophic objects can be manipulated just as a single-word data.
Reference: [14] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 130-141, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The terms are an explicitly typed -calculus with explicit constructor abstraction and application forms. The static semantics and the operating semantics 2 for the core calculus are all standard as for ML i <ref> [14] </ref>. <p> The terms are an explicitly typed -calculus with explicit constructor abstraction and application forms. The static semantics and the operating semantics 2 for the core calculus are all standard as for ML i [14]. Harper and Morrisett <ref> [14, 22] </ref> have shown that type checking for predicative F ! is decidable, and furthermore, its typing rules are consistent with its operational semantics. type 'a icell = (int * 'a * aux_info) ref (* internal hash-cell *) datatype tkindI = TK_TYC (* the monotype kind *) | TK_SEQ of tkind
Reference: [15] <author> R. Harper and C. Stone. </author> <title> A type-theoretic account of Standard ML 1996 (version 2). </title> <type> Technical Report CMU-CS-96-136R, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: The translation on the SML core language is quite similar to Harper and Stone's recent work on the type theoretic semantics of SML'97 <ref> [15] </ref>; the translation on the module language is, however, rather different. Unlike Harper and Stone's Internal Language (IL) [15], the FLINT intermediate language does not contain a separate module calculus. All module expressions and declarations (including higher-order functors) are directly translated into regular lambda terms in Core-FLINT. <p> The translation on the SML core language is quite similar to Harper and Stone's recent work on the type theoretic semantics of SML'97 <ref> [15] </ref>; the translation on the module language is, however, rather different. Unlike Harper and Stone's Internal Language (IL) [15], the FLINT intermediate language does not contain a separate module calculus. All module expressions and declarations (including higher-order functors) are directly translated into regular lambda terms in Core-FLINT. <p> recursive sum types (i.e, TC_FIX in the following functor declaration, t is a datatype specification inside the argument signature, functor F (A : sig datatype t = A1 | A2 | ... | An | B1 of T1 | Bm of Tm = struct ... end 6 Harper and Stone <ref> [15] </ref> translates the datatype spec into a signature consisting of an abstract representation type plus a list of operations to create, destroy, and analyze values of that type. <p> The FLINT intermediate language provides the same set of generic injection (inj t i ) , projection (proj t i ), and roll and unroll operators for recursive sum types as in <ref> [15] </ref>. All occurrences of A1, ..., Bm in the body of functor F are implemented by the corresponding inj t i and proj t i primitives. Most often, the primitive inj t i and proj t i operators can be determined and inlined at compile time.
Reference: [16] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 177-188, </pages> <address> New York, </address> <month> Jan </month> <year> 1992. </year> <note> ACM Press. Longer version available as INRIA Tech Report. </note>
Reference-contexts: One important component of the FLINT system is a high-performance type-directed compiler for Standard ML 1997 (SML'97) [21] extended with higher-order modules [20]. The FLINT/ML compiler provides several new capabilities that are not available in other existing type-based compilers (i.e., Gallium <ref> [16] </ref>, SML/NJ [29], and TIL [30]): * First, type-directed compilation is carried over to the ML module system including even extensions such as higher-order functors [20]. Neither Gallium [16] nor TIL [30] provides full support of ML modules. <p> The FLINT/ML compiler provides several new capabilities that are not available in other existing type-based compilers (i.e., Gallium <ref> [16] </ref>, SML/NJ [29], and TIL [30]): * First, type-directed compilation is carried over to the ML module system including even extensions such as higher-order functors [20]. Neither Gallium [16] nor TIL [30] provides full support of ML modules. <p> Government. * Second, recursive and mutable data objects can use unboxed representations without incurring expensive runtime cost on heavily polymorphic code [26]. The coercion-based approach used in Gallium <ref> [16] </ref> and SML/NJ [29] does not support unboxed representations on recursive and mutable objects. The type-passing approach used in TIL [30] does handle all data objects, but it involves heavy-weight runtime type analysis and code manipulations. * Third, ML functors can be selectively specialized just as normal polymorphic functions. <p> Under flexible representation analysis, recursive and mutable data objects can use unboxed representations without incurring expensive runtime cost on heavily polymorphic code. In contrast, the coercion-based approach used in Gallium <ref> [16] </ref> and SML/NJ [29] does not support unboxed representations on recursive and mutable objects; the type-passing approach used in TIL [30] does handle all data objects, but it involves heavy-weight runtime type analysis and code manipulations. <p> Each box refers to one boxing layer. ML type real is abbreviated as the symbol r. Under Leroy's scheme <ref> [16] </ref>, both p and mv can use efficient unboxed representations (see Figure 3b): value p can stay in two floating-point (FP) registers and function mv can freely pass the arguments and return the results in two FP registers.
Reference: [17] <author> X. Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In Twenty-first Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 109-122, </pages> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Recent research on ML modules have focused on giving type-theoretic semantics using dependent types [19, 11], translucent sums [10], or manifest types <ref> [17, 18] </ref>, none of these map ML modules directly into Core-FLINT-like calculus. We have developed an algorithm that translates ML modules (including even higher-order ones) into the Core-FLINT calculus. We make two simplifications during our translation: * Type generativity is ignored.
Reference: [18] <author> X. Leroy. </author> <title> Applicative functors and fully transparent higher-order modules. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 142-153, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Recent research on ML modules have focused on giving type-theoretic semantics using dependent types [19, 11], translucent sums [10], or manifest types <ref> [17, 18] </ref>, none of these map ML modules directly into Core-FLINT-like calculus. We have developed an algorithm that translates ML modules (including even higher-order ones) into the Core-FLINT calculus. We make two simplifications during our translation: * Type generativity is ignored.
Reference: [19] <author> D. MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In Proc. 13th Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 277-286. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: Recent research on ML modules have focused on giving type-theoretic semantics using dependent types <ref> [19, 11] </ref>, translucent sums [10], or manifest types [17, 18], none of these map ML modules directly into Core-FLINT-like calculus. We have developed an algorithm that translates ML modules (including even higher-order ones) into the Core-FLINT calculus. We make two simplifications during our translation: * Type generativity is ignored.
Reference: [20] <author> D. B. MacQueen and M. Tofte. </author> <title> A semantics for higher order functors. </title> <booktitle> In The 5th European Symposium on Programming, </booktitle> <pages> pages 409-423, </pages> <address> Berlin, </address> <month> April </month> <year> 1994. </year> <pages> Spinger-Verlag. </pages>
Reference-contexts: 1 Introduction The FLINT project at Yale aims to build a state-of-the-art systems environment for modern type-safe languages. One important component of the FLINT system is a high-performance type-directed compiler for Standard ML 1997 (SML'97) [21] extended with higher-order modules <ref> [20] </ref>. The FLINT/ML compiler provides several new capabilities that are not available in other existing type-based compilers (i.e., Gallium [16], SML/NJ [29], and TIL [30]): * First, type-directed compilation is carried over to the ML module system including even extensions such as higher-order functors [20]. <p> (SML'97) [21] extended with higher-order modules <ref> [20] </ref>. The FLINT/ML compiler provides several new capabilities that are not available in other existing type-based compilers (i.e., Gallium [16], SML/NJ [29], and TIL [30]): * First, type-directed compilation is carried over to the ML module system including even extensions such as higher-order functors [20]. Neither Gallium [16] nor TIL [30] provides full support of ML modules. <p> Our preliminary measurements have shown that on heavily functorized applications such as SML/NJ Compilation Manager [6], our optimized implementation is an order-of-magnitude faster than naive implementations. 4 3 Translation into FLINT The front-end of the FLINT/ML compiler translates the entire SML'97 [21] plus higher-order modules <ref> [20] </ref>) into the FLINT intermediate language. The translation on the SML core language is quite similar to Harper and Stone's recent work on the type theoretic semantics of SML'97 [15]; the translation on the module language is, however, rather different. <p> = X.t -&gt; int fun x (z : X.t) = 1 end functor G (F : FSIG) (A : SIG) = F (A) structure Z = G F A Module languages The main challenge in translating ML modules into Core-FLINT is on how to deal with functors and higher-order functors <ref> [20] </ref>. Recent research on ML modules have focused on giving type-theoretic semantics using dependent types [19, 11], translucent sums [10], or manifest types [17, 18], none of these map ML modules directly into Core-FLINT-like calculus.
Reference: [21] <author> R. Milner, M. Tofte, R. Harper, and D. MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: 1 Introduction The FLINT project at Yale aims to build a state-of-the-art systems environment for modern type-safe languages. One important component of the FLINT system is a high-performance type-directed compiler for Standard ML 1997 (SML'97) <ref> [21] </ref> extended with higher-order modules [20]. The FLINT/ML compiler provides several new capabilities that are not available in other existing type-based compilers (i.e., Gallium [16], SML/NJ [29], and TIL [30]): * First, type-directed compilation is carried over to the ML module system including even extensions such as higher-order functors [20]. <p> Our preliminary measurements have shown that on heavily functorized applications such as SML/NJ Compilation Manager [6], our optimized implementation is an order-of-magnitude faster than naive implementations. 4 3 Translation into FLINT The front-end of the FLINT/ML compiler translates the entire SML'97 <ref> [21] </ref> plus higher-order modules [20]) into the FLINT intermediate language. The translation on the SML core language is quite similar to Harper and Stone's recent work on the type theoretic semantics of SML'97 [15]; the translation on the module language is, however, rather different. <p> We have developed an algorithm that translates ML modules (including even higher-order ones) into the Core-FLINT calculus. We make two simplifications during our translation: * Type generativity is ignored. This is fine because the elaborator in the front-end has already done the type-checking according to the SML'97 semantics <ref> [21] </ref>. Type generativity has little impact on the type-directed compilation in general. * Opaque signature matchings (i.e., abstractions) are implemented as explicit coercions. An abstract type t is represented as TC_ABS (s) in FLINT (see Figure 1), where s is the internal implementation type.
Reference: [22] <author> G. Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1995. </year> <note> Tech Report CMU-CS-95-226. </note>
Reference-contexts: All these compilation stages are made independent of each other so that they can also be used as compiler infrastructure for other programming languages. Like the ML i calculus used in the TIL compiler <ref> [22, 30] </ref>, the core of FLINT is simply a predicative variant of the Girard-Reynolds polymorphic calculus F ! [9, 25]. <p> The terms are an explicitly typed -calculus with explicit constructor abstraction and application forms. The static semantics and the operating semantics 2 for the core calculus are all standard as for ML i [14]. Harper and Morrisett <ref> [14, 22] </ref> have shown that type checking for predicative F ! is decidable, and furthermore, its typing rules are consistent with its operational semantics. type 'a icell = (int * 'a * aux_info) ref (* internal hash-cell *) datatype tkindI = TK_TYC (* the monotype kind *) | TK_SEQ of tkind
Reference: [23] <author> G. Nadathur. </author> <title> A notation for lambda terms II: Refinements and applications. </title> <type> Technical Report CS-1994-01, </type> <institution> Duke University, Durham, NC, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: This is not supported in any of the other three compilers. * Fourth, FLINT/ML uses several techniques such as hash consing, memoization, and Nadathur's suspension-based -calculus <ref> [23, 24] </ref> to optimize the representation of its typed intermediate format. The new representation can reduce the cost of type manipulations thus improving the compilation time. The rest of this paper gives a brief overview of these innovative aspects. <p> constructor) under this representation would involve: (1) calculating the hash code from its descendants; (2) look up the hash-table, if it is already in, we are done; otherwise, calculate the aux_info, and install the new icell into the hash-table. * To make type reduction lazy, we use Nadathur's suspension notations <ref> [23, 24] </ref> to represent the intermediate result of unevaluated type applications. Intuitively, a type suspension such as LT_ENV (t; i; j; e) is a quadruple consisting of a term t with two indices and an environment. <p> The environment e determines the bindings for the type variables. For more details about the suspension-based calculus, check out Nadathur <ref> [23, 24] </ref>. SML syntax). Here, constructor abstraction TC_FN and polymorphic type LT_POLY all abstract or quantify over a list of type variables; each type variable TC_VAR (i; j) is represented as a de Bruijn index i plus an integer j that indicates the exact position in the corresponding list.
Reference: [24] <author> G. Nadathur and D. S. Wilson. </author> <title> A representation of lambda terms suitable for operations on their intensions. </title> <booktitle> In 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 341-348, </pages> <address> New York, June 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: This is not supported in any of the other three compilers. * Fourth, FLINT/ML uses several techniques such as hash consing, memoization, and Nadathur's suspension-based -calculus <ref> [23, 24] </ref> to optimize the representation of its typed intermediate format. The new representation can reduce the cost of type manipulations thus improving the compilation time. The rest of this paper gives a brief overview of these innovative aspects. <p> constructor) under this representation would involve: (1) calculating the hash code from its descendants; (2) look up the hash-table, if it is already in, we are done; otherwise, calculate the aux_info, and install the new icell into the hash-table. * To make type reduction lazy, we use Nadathur's suspension notations <ref> [23, 24] </ref> to represent the intermediate result of unevaluated type applications. Intuitively, a type suspension such as LT_ENV (t; i; j; e) is a quadruple consisting of a term t with two indices and an environment. <p> The first index i indicates an embedding level with respect to which variable references have been determined within the term, and the second index j indicates a new embedding level <ref> [24] </ref>. The environment e determines the bindings for the type variables. For more details about the suspension-based calculus, check out Nadathur [23, 24]. SML syntax). <p> The environment e determines the bindings for the type variables. For more details about the suspension-based calculus, check out Nadathur <ref> [23, 24] </ref>. SML syntax). Here, constructor abstraction TC_FN and polymorphic type LT_POLY all abstract or quantify over a list of type variables; each type variable TC_VAR (i; j) is represented as a de Bruijn index i plus an integer j that indicates the exact position in the corresponding list.
Reference: [25] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings, Colloque sur la Programmation, Lecture Notes in Computer Science, </booktitle> <volume> volume 19, </volume> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year>
Reference-contexts: FLINT/ML can compile both functors and polymorphic functions into a predicative variant of the Girard-Reynolds polymorphic calculus, F ! <ref> [9, 25] </ref>, so functor specialization is just type application in F ! . This is not supported in any of the other three compilers. * Fourth, FLINT/ML uses several techniques such as hash consing, memoization, and Nadathur's suspension-based -calculus [23, 24] to optimize the representation of its typed intermediate format. <p> Like the ML i calculus used in the TIL compiler [22, 30], the core of FLINT is simply a predicative variant of the Girard-Reynolds polymorphic calculus F ! <ref> [9, 25] </ref>.
Reference: [26] <author> Z. Shao. </author> <title> Flexible representation analysis. </title> <type> Technical Report YALEU/DCS/RR-1125, </type> <institution> Dept. of Computer Science, Yale University, </institution> <address> New Haven, CT, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: Government. * Second, recursive and mutable data objects can use unboxed representations without incurring expensive runtime cost on heavily polymorphic code <ref> [26] </ref>. The coercion-based approach used in Gallium [16] and SML/NJ [29] does not support unboxed representations on recursive and mutable objects. <p> The middle-end does simple dataflow optimizations and local or cross-module type specializations, and then produces an optimized version of the FLINT code. The back-end compiles FLINT into machine code through usual phases such as representation analysis <ref> [26] </ref>, conventional and loop optimizations [1], CPS-based contractions and reductions [3], closure conversion [28], and machine-code generation [8]. All these compilation stages are made independent of each other so that they can also be used as compiler infrastructure for other programming languages. <p> One novel aspect in our back-end is to use the new flexible representation analysis technique <ref> [26] </ref> to compile the polymorphic functions and functors. Under flexible representation analysis, recursive and mutable data objects can use unboxed representations without incurring expensive runtime cost on heavily polymorphic code.
Reference: [27] <author> Z. Shao. </author> <title> Typed cross-module compilation. </title> <type> Technical Report YALEU/DCS/RR-1126, </type> <institution> Dept. of Computer Science, Yale University, </institution> <address> New Haven, CT, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: All module expressions and declarations (including higher-order functors) are directly translated into regular lambda terms in Core-FLINT. In the rest of this section, we summarize several important aspects about our translation; the detailed algorithm can be found in an upcoming technical report <ref> [27] </ref>. signature SIG = sig type t val x : t end funsig FSIG (X : SIG) = SIG structure A : SIG = struct type t = int val x = 3 end structure B :&gt; SIG = struct type t = real val x = 3.5 end functor F <p> To translate a functor declaration into Core-FLINT, we use a phase-splitting algorithm <ref> [27, 12] </ref>.
Reference: [28] <author> Z. Shao and A. W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 150-161, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The middle-end does simple dataflow optimizations and local or cross-module type specializations, and then produces an optimized version of the FLINT code. The back-end compiles FLINT into machine code through usual phases such as representation analysis [26], conventional and loop optimizations [1], CPS-based contractions and reductions [3], closure conversion <ref> [28] </ref>, and machine-code generation [8]. All these compilation stages are made independent of each other so that they can also be used as compiler infrastructure for other programming languages.
Reference: [29] <author> Z. Shao and A. W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In Proc. ACM SIGPLAN '95 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 116-129. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: One important component of the FLINT system is a high-performance type-directed compiler for Standard ML 1997 (SML'97) [21] extended with higher-order modules [20]. The FLINT/ML compiler provides several new capabilities that are not available in other existing type-based compilers (i.e., Gallium [16], SML/NJ <ref> [29] </ref>, and TIL [30]): * First, type-directed compilation is carried over to the ML module system including even extensions such as higher-order functors [20]. Neither Gallium [16] nor TIL [30] provides full support of ML modules. The type-based SML/NJ [29] does support the entire SML module language, but values of abstract <p> not available in other existing type-based compilers (i.e., Gallium [16], SML/NJ <ref> [29] </ref>, and TIL [30]): * First, type-directed compilation is carried over to the ML module system including even extensions such as higher-order functors [20]. Neither Gallium [16] nor TIL [30] provides full support of ML modules. The type-based SML/NJ [29] does support the entire SML module language, but values of abstract types must use recursively boxed data representations. fl This research was sponsored in part by the Defense Advanced Research Projects Agency ITO under the title "Building Evolutionary Software through Modular Executable Specifications and Incremental Derivations," DARPA Order No. <p> Government. * Second, recursive and mutable data objects can use unboxed representations without incurring expensive runtime cost on heavily polymorphic code [26]. The coercion-based approach used in Gallium [16] and SML/NJ <ref> [29] </ref> does not support unboxed representations on recursive and mutable objects. The type-passing approach used in TIL [30] does handle all data objects, but it involves heavy-weight runtime type analysis and code manipulations. * Third, ML functors can be selectively specialized just as normal polymorphic functions. <p> The new representation can reduce the cost of type manipulations thus improving the compilation time. The rest of this paper gives a brief overview of these innovative aspects. The FLINT/ML compiler is being developed based on the type-based version of the SML/NJ compiler <ref> [29] </ref>. Parts of the FLINT/ML code have also been incorporated into the most recent working release of SML/NJ (v109.27). 2 The FLINT Intermediate Language The FLINT/ML compiler is organized around a strongly typed intermediate language named FLINT. <p> This scheme also solves the nasty datatype representation problem raised by Appel [4]. In the previous example, applying functor H to structure T is not allowed in the old SML/NJ compiler <ref> [29, 5] </ref> because data representation for S.foo is inconsistent with that for T.foo; this is no longer a problem in FLINT/ML. <p> Under flexible representation analysis, recursive and mutable data objects can use unboxed representations without incurring expensive runtime cost on heavily polymorphic code. In contrast, the coercion-based approach used in Gallium [16] and SML/NJ <ref> [29] </ref> does not support unboxed representations on recursive and mutable objects; the type-passing approach used in TIL [30] does handle all data objects, but it involves heavy-weight runtime type analysis and code manipulations. <p> Parts of the FLINT/ML code have also been incorporated into the most recent working release of SML/NJ (v109.27). When compared with the old type-based SML/NJ compiler <ref> [29] </ref>, FLINT/ML gives better performance (about 20% speedup) on benchmarks involving recursive and mutable types. Benchmarks involving heavy polymorphic code remain as efficient as before.
Reference: [30] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 181-192. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: One important component of the FLINT system is a high-performance type-directed compiler for Standard ML 1997 (SML'97) [21] extended with higher-order modules [20]. The FLINT/ML compiler provides several new capabilities that are not available in other existing type-based compilers (i.e., Gallium [16], SML/NJ [29], and TIL <ref> [30] </ref>): * First, type-directed compilation is carried over to the ML module system including even extensions such as higher-order functors [20]. Neither Gallium [16] nor TIL [30] provides full support of ML modules. <p> The FLINT/ML compiler provides several new capabilities that are not available in other existing type-based compilers (i.e., Gallium [16], SML/NJ [29], and TIL <ref> [30] </ref>): * First, type-directed compilation is carried over to the ML module system including even extensions such as higher-order functors [20]. Neither Gallium [16] nor TIL [30] provides full support of ML modules. <p> Government. * Second, recursive and mutable data objects can use unboxed representations without incurring expensive runtime cost on heavily polymorphic code [26]. The coercion-based approach used in Gallium [16] and SML/NJ [29] does not support unboxed representations on recursive and mutable objects. The type-passing approach used in TIL <ref> [30] </ref> does handle all data objects, but it involves heavy-weight runtime type analysis and code manipulations. * Third, ML functors can be selectively specialized just as normal polymorphic functions. <p> All these compilation stages are made independent of each other so that they can also be used as compiler infrastructure for other programming languages. Like the ML i calculus used in the TIL compiler <ref> [22, 30] </ref>, the core of FLINT is simply a predicative variant of the Girard-Reynolds polymorphic calculus F ! [9, 25]. <p> In contrast, the coercion-based approach used in Gallium [16] and SML/NJ [29] does not support unboxed representations on recursive and mutable objects; the type-passing approach used in TIL <ref> [30] </ref> does handle all data objects, but it involves heavy-weight runtime type analysis and code manipulations. <p> For example, coercing an object of type fi fl fl into type ff would involve first unboxing the fi and fl fields, and then pairing them up based on the actual types fi and fl have at runtime. 8 Unlike in the type-passing approach <ref> [30, 13] </ref>, all polymorphic values in our flexible scheme are indeed always boxed. This dramatically simplifies the implementation of polymorphism, because all polymophic objects can be manipulated just as a single-word data.
References-found: 30

