URL: ftp://rtcl.eecs.umich.edu/outgoing/farnam/WPDRTS.ps.gz
Refering-URL: http://www.eecs.umich.edu/~farnam/papers/pubs.html
Root-URL: http://www.cs.umich.edu
Email: fmonicab,farnamg@eecs.umich.edu  email: fheitmeye,labawg@itd.nrl.navy.mil  
Title: An Approach to Monitoring and Assertion-Checking of Real-Time Specifications  
Author: Monica Brockmeyer Farnam Jahanian Constance Heitmeyer Bruce Labaw 
Address: Ann Arbor, MI 48109-2122 USA  Washington, DC 20375  
Affiliation: Electrical Engineering and Computer Science Department University of Michigan  Naval Research Laboratory  
Abstract: This paper describes the development of a monitoring and assertion checking tool, MAC, which supports monitoring of symbolic execution traces generated by the Modechart Toolset, permitting testing of specifications early in the design phase and providing a mechanism for evaluating properties of the system on a particular execution trace. This approach avoids the many of the difficulties of run-time monitoring and testing such as interference and the probe affect. Monitoring and assertion checking capabilities are provided by the automatic translation of assertions in a declarative language (such as Real Time Logic) into monitoring fragments, written in Modechart, which augment the original specification to perform monitoring and assertion checking during simulation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Gabel, </author> <title> "Technology 1994: </title> <journal> Software engineering," IEEE Spectrum, </journal> <volume> vol. 31, no. 1, </volume> <pages> pp. 38-41, </pages> <month> january </month> <year> 1994. </year>
Reference-contexts: The distributed nature of these systems introduces additional complications into the ascertainment of their correctness. Several studies have demonstrated that the cost of detecting and removing software errors increases significantly as the development process moves from requirements specification toward production <ref> [1] </ref>. The This work is supported in part by the Naval Research Laboratory under Grant N00014-94-P2015. source of safety-critical failures can often be traced to requirements, specification, or design errors very early in the software development process [2].
Reference: [2] <author> N. G. Leveson. </author> <title> Software safety. </title> <booktitle> 11th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <month> May </month> <year> 1994. </year> <type> Invited Talk. </type>
Reference-contexts: The This work is supported in part by the Naval Research Laboratory under Grant N00014-94-P2015. source of safety-critical failures can often be traced to requirements, specification, or design errors very early in the software development process <ref> [2] </ref>. It has been argued that formal specification methods can reduce the number of errors in a specification by preventing imprecision and ambiguity. Furthermore, formal specifications are amenable to formal analysis techniques including consistency and completeness checks, validation and testing, and verification.
Reference: [3] <author> J. J. P. Tsai and S. J. H. Yang, </author> <title> editors, Monitoring and Debugging of Distributed Real-Time Systems, </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1995. </year>
Reference-contexts: Testing, debugging, and monitoring describe a variety of techniques commonly used to guarantee the correctness of computer systems. When applied to real-time systems, especially distributed real-time systems, these approaches must address additional challenges such as interference, the probe effect, and the lack of a global clock. <ref> [3] </ref>. These difficulties can be avoided by performing monitoring and assertion checking in the context of a simulation of the behavior of the system under development. In this paper, we describe the incorporation of a monitoring and assertion checking tool into the Modechart Toolset. <p> Run-time monitoring systems must address problems related to the probe effect including perturbation and event reordering, in addition to the issues we describe. See <ref> [3] </ref> for many of the major con tributions with regard to distributed non-real time systems as well as several which address monitoring in the context of distributed real time systems.
Reference: [4] <author> P. C. Clements, C. L. Heitmeyer, B. G. Labaw, and A. T. Rose, </author> <title> "MT: A toolset for specifying and analyzing real-time systems," </title> <booktitle> in Proc. IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1993. </year>
Reference: [5] <author> F. Jahanian and A. K. Mok, "Modechart: </author> <title> A specification language for real-time systems," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 20, no. 10, </volume> , <year> 1994. </year>
Reference-contexts: The Modechart Toolset (MT)[4] is a collection of integrated tools developed by the Naval Research Laboratory together with researchers from the University of Texas to address these challenges. MT supports the formal specification of real time behavior for distributed systems in a language called Modechart <ref> [5] </ref> and formal analysis via formal verification, simulation, and completeness and consistency checking. We develop an approach to monitoring and asser tion checking in the context of symbolic executions of Modechart specifications. This approach is intended to complement the existing analysis techniques in the Modechart Toolset. <p> Section 3 describes our approach to monitoring and assertion checking. In Section 4 we discuss related work in monitoring and assertion checking and in Section 5 we describe the direction of our future efforts. 2 Specification in Modechart: A Robot Controller Example Modechart <ref> [5] </ref> is a graphical specification language based on concurrent finite state diagrams. It provides a compact and structured way to represent real time systems. Although similar to Harel's Statecharts [6], Modechart is specifically designed for the specification of real time systems. <p> More precisely, M was entered before the current moment of time, and since then, M has not exited before the current moment. Further discussion of the possible predicates on modes can be found in <ref> [5, 7] </ref>. Finally, more complex mode transition expressions can be formed from triggers and timing constraints. More elaborate triggers can be composed by taking the con-juncts of trigger expressions, and these conjuncts can be disjuncted together with timing expressions.
Reference: [6] <author> D. Harel, "Statecharts: </author> <title> A visual formalism for complex systems," </title> <booktitle> Science of Computer Programming, </booktitle> <volume> vol. 8, </volume> , <year> 1987. </year>
Reference-contexts: It provides a compact and structured way to represent real time systems. Although similar to Harel's Statecharts <ref> [6] </ref>, Modechart is specifically designed for the specification of real time systems. Modechart is extended from Statecharts with constructs for expressing timing constraints. It has a visual hierarchical structure and a small set of well defined constructs for the definition of event-driven real time systems. <p> Special hardware support for collecting run-time data in real time applications has been considered in a number of recent papers [11-13]. These approaches introduce specialized co-processors for the collection and analysis of run-time information. The STATEMATE system [14], based on State-charts <ref> [6] </ref>, provides symbolic execution of system specifications. In an approach similar to ours, these executions can be monitored via special "watchdog" code which is defined by the user in Statecharts. There is no automatic generation of watchdog code. History-checking of TRIO specifications is provided in the recent work of [15].
Reference: [7] <author> A. Rose, M. Perez, and P. Clements, </author> <title> "Mod-echart toolset user's guide," </title> <type> Technical Report NRL/MRL/5540-94-7427, </type> <institution> Center for Computer High Assurance Systems, Naval Research Lab, </institution> <address> Washington, D.C., </address> <month> February </month> <year> 1994. </year>
Reference-contexts: More precisely, M was entered before the current moment of time, and since then, M has not exited before the current moment. Further discussion of the possible predicates on modes can be found in <ref> [5, 7] </ref>. Finally, more complex mode transition expressions can be formed from triggers and timing constraints. More elaborate triggers can be composed by taking the con-juncts of trigger expressions, and these conjuncts can be disjuncted together with timing expressions.
Reference: [8] <author> M. Brockmeyer and F. Jahanian, </author> <title> "Monitoring and assertion checking of real-time specficiations in modechart," </title> <type> Technical Report 95-269, </type> <institution> Computer Science and Engineering, The University of Michi-gan, </institution> <address> Ann Arbor, MI, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: The necessary information is filled in the fragment and the resulting fragment is attached to the original Modechart specification. (c) The user can specify more complex assertions, composing primitive relationships described above in part (b). Composition of primitive assertions is described in <ref> [8] </ref>. Again the user can fill mode names into a form to specify the primitive assertions; these are then very easily composed using the usual logical connectives. <p> Moreover, at time point 32, the mode Monitor.B1 becomes active, while the mode Monitor.G2 becomes inactive. 4 Related Work In this section, we highlight the relevant work in this area. For a more complete discussion see <ref> [8] </ref>. The foundations for our work are found in [9] which develops the framework for understanding a system computation in terms of an event-based model. A more formal approach to real time monitoring, including the development of the idea of a computation prefix is provided in [10].
Reference: [9] <author> F. Jahanian, </author> <title> "Run-time monitoring of real-time systems," </title> <booktitle> in Advances in Real-Time Computing, </booktitle> <editor> S. H. Son, editor, </editor> <booktitle> chapter 18, </booktitle> <publisher> Prentice-Hall, </publisher> <address> En-glewood Cliffs, NJ, </address> <year> 1994. </year>
Reference-contexts: Moreover, at time point 32, the mode Monitor.B1 becomes active, while the mode Monitor.G2 becomes inactive. 4 Related Work In this section, we highlight the relevant work in this area. For a more complete discussion see [8]. The foundations for our work are found in <ref> [9] </ref> which develops the framework for understanding a system computation in terms of an event-based model. A more formal approach to real time monitoring, including the development of the idea of a computation prefix is provided in [10].
Reference: [10] <author> F. Jahanian and A. Goyal, </author> <title> "A formalism for monitoring real-time constraints at run-time," </title> <booktitle> in Proc. of Fault-Tolerant Computing Symposium (FTCS-20), </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: The foundations for our work are found in [9] which develops the framework for understanding a system computation in terms of an event-based model. A more formal approach to real time monitoring, including the development of the idea of a computation prefix is provided in <ref> [10] </ref>. More attention has been given to the issues of online or run-time monitoring than to that of monitoring and assertion checking of symbolic executions of real time systems.
Reference: [11] <author> D. Haban and K. G. Shin, </author> <title> "Application of real-time monitoring to scheduling tasks with random execution times," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 16, no. 12, </volume> <pages> pp. 1374-1389, </pages> <month> December </month> <year> 1990. </year>
Reference: [12] <author> H. Kopetz, A. Damm, C. Koza, M. Mulazzani, W. Schwabl, C. Senft, and R. Zainlinger, </author> <title> "Distributed fault-tolerant real-time systems: The MARS approach," </title> <journal> IEEE Micro, </journal> <volume> vol. 9, no. 1, </volume> <pages> pp. 25-40, </pages> <month> February </month> <year> 1989. </year>
Reference: [13] <author> J. J. P. Tsai, K.-Y. Fang, and H.-Y. Chen, </author> <title> "A non-invasive architecture to monitor real-time distributed systems," </title> <journal> IEEE Computer, </journal> <volume> vol. 23, no. 3, </volume> <pages> pp. 11-23, </pages> <month> March </month> <year> 1990. </year>
Reference: [14] <author> D. Harel et al., "Statemate: </author> <title> A working environment for the development of complex reactive systems," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. SE-16, no. 4, </volume> , <month> April </month> <year> 1990. </year>
Reference-contexts: Special hardware support for collecting run-time data in real time applications has been considered in a number of recent papers [11-13]. These approaches introduce specialized co-processors for the collection and analysis of run-time information. The STATEMATE system <ref> [14] </ref>, based on State-charts [6], provides symbolic execution of system specifications. In an approach similar to ours, these executions can be monitored via special "watchdog" code which is defined by the user in Statecharts. There is no automatic generation of watchdog code.
Reference: [15] <author> M. Felder and A. Morzenti, </author> <title> "Validating real-time systems by history-checking trio specifications," </title> <booktitle> in Procedings of the 14th International Confernence on Software Engineering, </booktitle> <address> New York, NY, 1992, </address> <publisher> ACM Press. </publisher>
Reference-contexts: In an approach similar to ours, these executions can be monitored via special "watchdog" code which is defined by the user in Statecharts. There is no automatic generation of watchdog code. History-checking of TRIO specifications is provided in the recent work of <ref> [15] </ref>. TRIO is a first order temporal logic which deals with time in a quantitative way by providing a metric to indicate distance in time between events.
References-found: 15

