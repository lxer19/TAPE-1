URL: http://www.cs.rice.edu/CS/PLT/Publications/thesis-sitaram.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: Models of Control and Their Implications for Programming Language Design  
Author: by Dorai Sitaram Matthias Felleisen Robert S. Cartwright Klaus Weissenberger 
Degree: A Thesis Submitted in Partial Fulfillment of the Requirements for the Degree Doctor of Philosophy Approved, Thesis Committee:  Professor of Computer Science  Professor of Computer Science  Professor  
Date: April, 1994  
Address: Houston, Texas  
Affiliation: RICE UNIVERSITY  of German and Slavic Studies  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> H. Abelson and G. J. Sussman with J. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1985. </year>
Reference-contexts: Subcases are: (a) Q is a lambda-abstraction. (b) Q is a primitive procedure. We now prove the lemma for each of the cases: 1. (Q R) is within one of the M i , i.e., for some j 2 <ref> [1; m] </ref>, M j is an application and contains (or is) the redex (Q R). Let M j = E 1 [(Q R)]. <p> Thus, condition 2a is satisfied. 18 2. (Q R) contains some of the M i . Subcases are: (a) Q is one of the M i , i.e., for some j 2 <ref> [1; m] </ref>, Q = M j . Thus M j is either a primitive procedural constant or a lambda-abstraction. <p> Since the 23 Of course, not all objects and certainly not all contexts warrant this immortality. To prevent them from taking up space, Scheme implementations invariably include a prudent garbage collector that hunts down objects that are guaranteed not to be used and reclaims their storage area <ref> [1, 2, 5] </ref>. 124 rest of computation subcomputation starts "# rest of computation during sub-computation # rest of com putation subcomputation ends (a) The control stack at the start of, during, and at the end of a subcomputation. ; call/cc invocation store away "contin uation," i.e., copy of control stack (=
Reference: [2] <author> A. Appel. </author> <title> Compiling with Continuations. </title> <address> Cambridge, </address> <year> 1992. </year>
Reference-contexts: Since the 23 Of course, not all objects and certainly not all contexts warrant this immortality. To prevent them from taking up space, Scheme implementations invariably include a prudent garbage collector that hunts down objects that are guaranteed not to be used and reclaims their storage area <ref> [1, 2, 5] </ref>. 124 rest of computation subcomputation starts "# rest of computation during sub-computation # rest of com putation subcomputation ends (a) The control stack at the start of, during, and at the end of a subcomputation. ; call/cc invocation store away "contin uation," i.e., copy of control stack (=
Reference: [3] <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <booktitle> Studies in Logic and the Foundations of Mathematics 103. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: PS is the purely functional subset of the programming language Scheme [5, 54], and is essentially the dynamically typed call-by-value -calculus <ref> [3, 39] </ref> with integers and some elementary arithmetic procedures. A control extension of PS is plain PS enhanced with one or more control-manipulating constructs. procedures and lambda-abstractions are procedure values. The numerals stand for the respective integers. If n is metasyntax for a number, then pnq is the corresponding numeral.
Reference: [4] <author> H. P. Barendregt. </author> <title> Functional programming and lambda calculus. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> volume Vol. </volume> <editor> B: </editor> <title> Formal Models and Semantics, </title> <booktitle> chapter 7, </booktitle> <pages> pages 321-363. </pages> <publisher> The MIT Press/Elsevier, </publisher> <year> 1990. </year>
Reference: [5] <editor> W. Clinger, J. Rees, et al. </editor> <title> Revised 4 Report on the Algorithmic Language Scheme, </title> <month> November </month> <year> 1991. </year>
Reference-contexts: Introduction This work uses denotational models to study and enhance programming language constructs that manipulate non-local context information. Non-local control operators occur in such diverse languages as Algol [12], Lisp [34, 49], C [30], C++ [53], Scheme <ref> [5, 54] </ref>, ML [23, 37], EuLisp [38] and Dylan [11]|they enable the programmer to identify and restore enclosing or arbitrary control contexts in the program execution path. <p> Finally, for each extended version of the language, we describe an abstract machine for evaluating the programs in the language. 2.1 Pure Scheme We use Pure Scheme or PS as the prototypical language to present control manipulation. PS is the purely functional subset of the programming language Scheme <ref> [5, 54] </ref>, and is essentially the dynamically typed call-by-value -calculus [3, 39] with integers and some elementary arithmetic procedures. A control extension of PS is plain PS enhanced with one or more control-manipulating constructs. procedures and lambda-abstractions are procedure values. The numerals stand for the respective integers. <p> An example is Scheme's and ML's call-with-current-continua 1 The symbol % is chosen for its similarity to an operating system prompt. Lisp's own prompt sign is usally &gt;|unfortunately, that symbol is taken. 23 tion <ref> [5, 9, 54] </ref>. 2 Like its historical forerunners J [31] and escape [41], call/cc is a control reifier : it reifies the control information of a running program and gives it to the user. The user can reinstate this control information at any time, thus creating arbitrary context jumps. <p> The following is a collection of some uses of the prompt, for both first- and higher-order abstractions. In this chapter, we will often use the additional capabilities of real Scheme instead of working within PS. These features include assignment, input/output procedures, and zero- and variable-argument procedures <ref> [5] </ref>. Sometimes, it is convenient to view the control-delimiting construct as a procedure. This procedure is named run, borrowing a term from an operating-system routine that runs programs [51]. <p> Since the 23 Of course, not all objects and certainly not all contexts warrant this immortality. To prevent them from taking up space, Scheme implementations invariably include a prudent garbage collector that hunts down objects that are guaranteed not to be used and reclaims their storage area <ref> [1, 2, 5] </ref>. 124 rest of computation subcomputation starts "# rest of computation during sub-computation # rest of com putation subcomputation ends (a) The control stack at the start of, during, and at the end of a subcomputation. ; call/cc invocation store away "contin uation," i.e., copy of control stack (=
Reference: [6] <author> W. F. Clocksin and C. S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: In our implementation, a detach simply aborts a result value to the current coroutine prompt: : : : (let* ([local-control-state : : : ] [resume : : : ] [detach (lambda (v ) (fcontrol 'coroutine (lambda () v )))]) : : : 6.7 Backtracking through handling Prolog-style backtracking <ref> [6, 50] </ref> solves problem or goal by trying to solve its subgoals. If the goal is a simple or atomic goal, it is solved by matching it with statements or facts in a database. A goal that is solved is said to succeed.
Reference: [7] <author> O.-J. Dahl and C. A. R. Hoare. </author> <title> Hierarchical program structure. </title> <editor> In O.-J. Dahl, E. Dijkstra, and C. A. R. Hoare, editors, </editor> <title> Structured Programming. </title> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference-contexts: The prompt's handler updates local-control-state and starts the new coroutine. The latter starts its remaining computation, as recorded within its local-control-state. All coroutine computations take place within their respective prompts, ensuring that their resumes only grab coroutine context. A more sophisticated coroutine paradigm <ref> [7, 27] </ref> includes an additional detach facility that allows a direct transfer of control back to the point where the coroutine (s) 106 were first called. In a call/cc world, detach requires remembering the continuation of the first coroutine call across all the encountered coroutines.
Reference: [8] <author> O. Danvy and A. Filinski. </author> <title> Abstracting control. </title> <booktitle> In Proc. 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 151-160, </pages> <year> 1990. </year> <month> 155 </month>
Reference-contexts: First introduced as an operationally useful mechanism by Felleisen [16], higher-order delim-iters, also called prompts, have been suggested in various settings. Examples include the reset of Danvy and Filinski <ref> [8] </ref>, Hieb, Dybvig and Anderson's spawn [28, 29], and Queinnec and Serpette's splitter [40]. In all cases, the delimiter endows the programmer with the ability to run a subcomputation as an independent program, in so far as control actions are concerned. <p> Furthermore, these declarations are valuable in enabling compiler optimizations and proving correctness. Several control alternatives that go beyond Scheme's call/cc have been recently proposed. All of them involve control delimiting and some form of "composable" or "partial" continuations. Danvy and Filinski's shift and reset <ref> [8] </ref> and Queinnec and Serpette's splitter [40] are two such control proposals for a sequential language: The operator reset delimits the context reified by shift; the splitter operator delimits a computation, and provides it a fresh call/cc-like operator for internal use.
Reference: [9] <author> B. F. Duba, R. Harper, and D. MacQueen. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Proc. 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <year> 1991. </year>
Reference-contexts: An example is Scheme's and ML's call-with-current-continua 1 The symbol % is chosen for its similarity to an operating system prompt. Lisp's own prompt sign is usally &gt;|unfortunately, that symbol is taken. 23 tion <ref> [5, 9, 54] </ref>. 2 Like its historical forerunners J [31] and escape [41], call/cc is a control reifier : it reifies the control information of a running program and gives it to the user. The user can reinstate this control information at any time, thus creating arbitrary context jumps.
Reference: [10] <author> R. K. Dybvig and R. Hieb. </author> <title> Engines from Continuations. </title> <journal> Journal of Computer Languages (Pergamon Press), </journal> <volume> 14(2) </volume> <pages> 109-124, </pages> <year> 1989. </year>
Reference-contexts: This ability to substitute the current context by a previously stored context is simple and powerful, as attested by the several elegant programming metaphors that it allows <ref> [10, 13, 22, 24, 26, 27, 46] </ref>. The stepping rule for call/cc is: E [(call =cc M )] &gt; E [(M (lambda (v) (abort E [v])))] Thus, the reduction language supports abort expressions even if PS+call/cc itself does not. <p> an ample substitute for a prompt and its abort. 6 Second, delimiters for true higher-order continuations can be created in an ad hoc fashion by employing additional higher-order continuations. 7 Keeping track of several such continuations with their respective quasi-delimiters requires sophisticated bookkeeping effort even for a single control metaphor <ref> [10, 26] </ref>, not to mention simultaneous uses of different control abstractions. Thus it is useful to seek a higher-order generalization of the first-order prompt. A straightforward extrapolation of the first-order delimiter suggests that higher-order prompts delimit the extent of evaluation context captured or erased by control operators and their continuations. <p> An engine <ref> [10, 25] </ref> represents computation subject to timed preemption. It forms a tractable building block for realizing a variety of communicating concurrent processes. An engine's underlying computation is a thunk that can be run as a preemptable process. <p> Extending it to allow nestable engines entails more than adding code for tick management, since the continuations to be captured while transferring control across the generations of engines need involved bookkeeping <ref> [10] </ref>. We show here an implementation of nestable engines using control handlers. <p> The following describes the type of clock we shall use: it may be defined using either natively provided alarms or through syntactic extensions <ref> [10] </ref> that simulate tick consumption.
Reference: [11] <institution> Dylan | an object-oriented dynamic language. Apple Computer Eastern Research and Technology, </institution> <year> 1992. </year>
Reference-contexts: It is no coincidence that many of the operators mentioned here are related to error or condition signalers and their handlers. Indeed, the condition systems of ML, Common Lisp, Dylan <ref> [11] </ref> and C++ [53] are sophisticated instances of first-order control usage.
Reference: [12] <author> P. Naur (ed.). </author> <title> Revised report on the algorithmic language Algol 60. </title> <journal> Communications of the ACM, </journal> <volume> 6(1) </volume> <pages> 1-17, </pages> <year> 1963. </year>
Reference-contexts: Introduction This work uses denotational models to study and enhance programming language constructs that manipulate non-local context information. Non-local control operators occur in such diverse languages as Algol <ref> [12] </ref>, Lisp [34, 49], C [30], C++ [53], Scheme [5, 54], ML [23, 37], EuLisp [38] and Dylan [11]|they enable the programmer to identify and restore enclosing or arbitrary control contexts in the program execution path.
Reference: [13] <author> M. Felleisen. </author> <title> Transliterating Prolog into Scheme. </title> <type> Technical Report 182, </type> <institution> Indiana University Computer Science Department, </institution> <year> 1985. </year>
Reference-contexts: This ability to substitute the current context by a previously stored context is simple and powerful, as attested by the several elegant programming metaphors that it allows <ref> [10, 13, 22, 24, 26, 27, 46] </ref>. The stepping rule for call/cc is: E [(call =cc M )] &gt; E [(M (lambda (v) (abort E [v])))] Thus, the reduction language supports abort expressions even if PS+call/cc itself does not. <p> Implementing backtracking in Scheme provides an apt illustration of continuations. While "purely functional" solutions with goals returning boolean values are possible, such methods require that goals explicitly call success and failure procedures to allow resumption of subgoals at backtrack points. In contrast, Scheme approaches <ref> [13, 24] </ref> aim for more concise and readable code using call/cc-continuations to identify and jump to backtrack points. <p> (The unification process itself is a predicate: thus, the unification of two terms is an example of an atomic goal.) In this treatment, we will concentrate on the backtracking capabilities provided by control handlers and assume an implementation of both the logic variable datatype and a corresponding unification procedure (refer <ref> [13, 24] </ref>). 6.7.2 Goals In this treatment, a goal is a Scheme expression that throw s (instead of just returning) the boolean false if it fails and a true value if it succeeds.
Reference: [14] <author> M. Felleisen. </author> <title> The Calculi of Lambda-v-CS-Conversion: A Syntactic Theory of Control and State in Imperative Higher-Order Programming Languages. </title> <type> PhD thesis, </type> <institution> Indiana University, </institution> <year> 1987. </year>
Reference-contexts: As can be expected, higher-order control operators are even more expressive than their first-order counterparts. 1.2 Prior motivating work The expressiveness of control operators comes at a cost|they invalidate many of the familiar laws of reasoning that hold for functional languages <ref> [14] </ref>. As Meyer and Riecke observed, terms that once behaved identically now act very differently, suggesting that control operators are "unreasonable" [35].
Reference: [15] <author> M. Felleisen. -v-CS: </author> <title> An Extended -Calculus for Scheme. </title> <booktitle> In Proc. 1988 Conference on Lisp and Functional Programming, </booktitle> <pages> pages 72-84, </pages> <year> 1988. </year>
Reference-contexts: For any term M , a program context is a context C [ ] such that C [M ] is a program, i.e., a closed term. 2.2 An abstract machine for PS primitive reduction rules describes an abstract machine <ref> [15, 20] </ref>. The chief reduction rule, the fi-value rule, is the application of a lambda-procedure to an argument value|this produces the body of the procedure, with the argument substituted for the bound variable. <p> This is indeed a useful delimiter. Together with higher-order control reifiers like call/cc, call/cc 0 or fcontrol, the prompt supports a multitude of programming idioms <ref> [15, 46] </ref>. However, it does not completely generalize first-order abort and prompt. In the first-order scenario, an abort merely signals a control action, leaving it to the prompt to handle the control action by collecting the aborted value.
Reference: [16] <author> M. Felleisen. </author> <title> The Theory and Practice of First-Class Prompts. </title> <booktitle> In Proc. 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 180-190, </pages> <year> 1988. </year>
Reference-contexts: More interestingly, we show that the traditional continuation model for higher - order control operators such as Scheme's call/cc also has control delimiters. First introduced as an operationally useful mechanism by Felleisen <ref> [16] </ref>, higher-order delim-iters, also called prompts, have been suggested in various settings. Examples include the reset of Danvy and Filinski [8], Hieb, Dybvig and Anderson's spawn [28, 29], and Queinnec and Serpette's splitter [40]. <p> In all cases, the delimiter endows the programmer with the ability to run a subcomputation as an independent program, in so far as control actions are concerned. The uses of the prompt are diverse: it allows cleaner realizations of existing control abstractions and makes possible completely new programming styles <ref> [16, 46] </ref>. As a radically different model for higher-order control, we use Felleisen and Cart-wright's technique for extending the basic direct model to our control sublanguages. <p> Indeed, the condition systems of ML, Common Lisp, Dylan [11] and C++ [53] are sophisticated instances of first-order control usage. In our idealized language, we call our delimiter the "prompt," %, recognizing that it treats its operand as an independent program, in so far as control actions are concerned <ref> [16, 51] </ref>, much like the prompt sign in a read-eval-print loop. 1 The syntax for a prompt expression is (% M ). <p> Thus it is useful to seek a higher-order generalization of the first-order prompt. A straightforward extrapolation of the first-order delimiter suggests that higher-order prompts delimit the extent of evaluation context captured or erased by control operators and their continuations. Thus, a higher-order prompt <ref> [16] </ref> for fcontrol would use the following stepping rules: 6 Indeed, this call/cc-translation works too well, since the "exit" it simulates works even after program control has gone past the delimiting context! This is usually not a problem, but if it is absolutely necessary to ensure failure when such exits are <p> The procedure equal? can thus examine both the abort-values, yielding differing results for M 0 and M 1 . Such an abort-delimiter is the prompt operator % <ref> [16] </ref>.
Reference: [17] <author> M. Felleisen. </author> <booktitle> The principles of programming languages. Course Notes, COMP 511, </booktitle> <institution> Rice University, </institution> <year> 1989. </year>
Reference-contexts: This information is captured succinctly in the form of an activity lemma. The formulation and proof of activity used here is a refinement of Plotkin's activity lemma for PCF [39] due to Felleisen <ref> [17] </ref>. We first introduce two definitions. Definition 2.1 (Generalized contexts) A generalized context is like a context except that it can have zero or more holes.
Reference: [18] <author> M. Felleisen. </author> <title> On the expressive power of programming languages. </title> <editor> In N. Jones, editor, </editor> <booktitle> Proc. 1990 European Symposium on Programming, </booktitle> <pages> pages 134-151. </pages> <booktitle> Lecture Notes in Computer Science 432, </booktitle> <year> 1990. </year> <month> 156 </month>
Reference-contexts: Higher-order control operators provide a rich array of control metaphors|e.g., corou-tines, task scheduling, stream processing, and non-blind backtracking [24, 25, 26, 27]. In a quantifiable sense, control operators are expressive <ref> [18] </ref>: Neither purely functional languages nor those augmented with an assignment operator can simulate control actions with local syntactic translations.
Reference: [19] <author> M. Felleisen and R. S. Cartwright. </author> <title> Extended direct semantics. </title> <type> Technical Report 105, </type> <institution> Rice University, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: The control models are of two kinds: The first is the traditional continuation semantics propounded by Strachey and Wadsworth [52]. The second is an extension of the usual basic direct model used for the functional subset, and was recently proposed by Felleisen and Cartwright <ref> [19] </ref>. The continuation model, also called the cps (for continuation-passing-style) model, provides a straightforward description of the language PS enhanced with call-with-current-continuation (or call/cc), the canonical higher-order control reifier present in Scheme and ML. The model describes control operations by including an additional, "continuation" argument to the model's meaning function. <p> Then the context (Ck [(: : : : : : 64 distinguishes the terms. 65 Chapter 5 Modeling PS+control directly The basic direct model of Chapter 3 can be extended to accommodate enhancements of PS that include control operators <ref> [19, 48] </ref>. <p> Thus, for example, the values in the procedure subdomain now include procedures that may yield extension values. However, the extended domain remains similar enough to the original domain that values can be projected and injected across the two with fair ease and clarity <ref> [19] </ref>.
Reference: [20] <author> M. Felleisen, D. P. Friedman, E. Kohlbecker, and B. Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Computer Science, </journal> <volume> 52(3) </volume> <pages> 205-237, </pages> <year> 1987. </year> <title> Preliminary version: Reasoning with Continuations, </title> <booktitle> Proc. Symposium on Logic in Computer Science, </booktitle> <year> 1986, </year> <pages> 131-141. </pages>
Reference-contexts: For any term M , a program context is a context C [ ] such that C [M ] is a program, i.e., a closed term. 2.2 An abstract machine for PS primitive reduction rules describes an abstract machine <ref> [15, 20] </ref>. The chief reduction rule, the fi-value rule, is the application of a lambda-procedure to an argument value|this produces the body of the procedure, with the argument substituted for the bound variable. <p> The stepping rule for call/cc is: E [(call =cc M )] &gt; E [(M (lambda (v) (abort E [v])))] Thus, the reduction language supports abort expressions even if PS+call/cc itself does not. A syntactically cleaner approach would be to use call/cc 0 , a call/cc variant <ref> [20] </ref>, as the control primitive, with the following stepping rule: 4 E [(call =cc 0 M )] &gt; (M (lambda (v) (call =cc 0 (lambda (d) E [v])))) The operator call/cc 0 captures context like call/cc and aborts context like abort. <p> A closer analog is the setjmp/longjmp pair in the C standard library. 4 call/cc 0 is called C in <ref> [20] </ref>. Similarly, fcontrol (see below) is called F. <p> Although it is simpler than call/cc in not containing implicit continuation invocations, it is not simple where aborts are concerned: Both call/cc 0 and a call/cc 0 -based continuation abort when invoked. A variant of call/cc 0 , called fcontrol <ref> [20] </ref>, resolves this complexity by providing functional continuations. The stepping rule for fcontrol -expressions is: E [(fcontrol M )] &gt; (M (lambda (v) E [v])) Thus, the continuation obtained through fcontrol does not include an implicit abort.
Reference: [21] <author> A. Filinski. </author> <title> Representing monads. </title> <booktitle> Proc. 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 446-457, </pages> <year> 1994. </year>
Reference-contexts: An interesting question is whether we can get analogous results for other language extensions: notably assignment, either by itself or in concert with control extensions. Filinski's <ref> [21] </ref> simulation of composable continuations with non-composable ones using a single storage cell, as also our Scheme embedding of handlers and fcon-trol (Chapter 7) suggest an interesting interference between the extensions for advanced control and assignment.
Reference: [22] <author> D. P. Friedman, C. T. Haynes, and E. Kohlbecker. </author> <title> Programming with continuations. </title> <editor> In P. Pepper, editor, </editor> <booktitle> Program Transformations and Programming Environments, </booktitle> <pages> pages 263-274. </pages> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1985. </year>
Reference-contexts: This ability to substitute the current context by a previously stored context is simple and powerful, as attested by the several elegant programming metaphors that it allows <ref> [10, 13, 22, 24, 26, 27, 46] </ref>. The stepping rule for call/cc is: E [(call =cc M )] &gt; E [(M (lambda (v) (abort E [v])))] Thus, the reduction language supports abort expressions even if PS+call/cc itself does not.
Reference: [23] <author> R. Harper. </author> <title> Introduction to Standard ML. </title> <type> LFCS Report Series ECS-LFCS-86-14, </type> <institution> University of Edinburgh, </institution> <year> 1986. </year>
Reference-contexts: Introduction This work uses denotational models to study and enhance programming language constructs that manipulate non-local context information. Non-local control operators occur in such diverse languages as Algol [12], Lisp [34, 49], C [30], C++ [53], Scheme [5, 54], ML <ref> [23, 37] </ref>, EuLisp [38] and Dylan [11]|they enable the programmer to identify and restore enclosing or arbitrary control contexts in the program execution path. <p> Arbitrarily delimitable aborts are not just a theoretical necessity to ensure full abstraction|they are widely used in languages with first-order control, e.g., Lisp 1.5's errorset and error [34], Common Lisp's catch and throw [49] and ML's handle and raise <ref> [23, 37] </ref>. A common embellishment for this setup is the association of tags on both abort and delimiter|e.g., a tagged throw can be delimited only a catch with an identical tag. <p> In this more general version, first-order control manipulation is that which allows computations to abort to any dynamically enclosing control context, not necessarily the topmost program context. Examples of such controlled aborts are Lisp 1.5's error [34], Common Lisp's throw [49] and ML's raise <ref> [23, 37] </ref>. The corresponding control delimiters are respectively errorset, catch and handle. Typically, languages allow tags on the aborting and delimiting forms. For instance, in Common Lisp, a tagged throw can only be delimited by a catch with an identical tag.
Reference: [24] <author> C. T. Haynes. </author> <title> Logic Continuations. </title> <journal> J. Logic Program., </journal> <volume> 4 </volume> <pages> 157-176, </pages> <year> 1987. </year> <title> Preliminary version: </title> <booktitle> In Proc. of the Third International Conference on Logic Programming, </booktitle> <month> July </month> <year> 1985, </year> <title> London, </title> <booktitle> England, Lecture Notes in Computer Science, </booktitle> <volume> Vol. 225, </volume> <publisher> Springer-Verlag, Berlin, </publisher> <pages> 671-685. </pages>
Reference-contexts: First-order control is the foundation for the sophisticated exception- or condition-handling systems in languages such as Common Lisp, ML, C++, EuLisp, and Dylan. Higher-order control operators provide a rich array of control metaphors|e.g., corou-tines, task scheduling, stream processing, and non-blind backtracking <ref> [24, 25, 26, 27] </ref>. In a quantifiable sense, control operators are expressive [18]: Neither purely functional languages nor those augmented with an assignment operator can simulate control actions with local syntactic translations. <p> This ability to substitute the current context by a previously stored context is simple and powerful, as attested by the several elegant programming metaphors that it allows <ref> [10, 13, 22, 24, 26, 27, 46] </ref>. The stepping rule for call/cc is: E [(call =cc M )] &gt; E [(M (lambda (v) (abort E [v])))] Thus, the reduction language supports abort expressions even if PS+call/cc itself does not. <p> Implementing backtracking in Scheme provides an apt illustration of continuations. While "purely functional" solutions with goals returning boolean values are possible, such methods require that goals explicitly call success and failure procedures to allow resumption of subgoals at backtrack points. In contrast, Scheme approaches <ref> [13, 24] </ref> aim for more concise and readable code using call/cc-continuations to identify and jump to backtrack points. <p> (The unification process itself is a predicate: thus, the unification of two terms is an example of an atomic goal.) In this treatment, we will concentrate on the backtracking capabilities provided by control handlers and assume an implementation of both the logic variable datatype and a corresponding unification procedure (refer <ref> [13, 24] </ref>). 6.7.2 Goals In this treatment, a goal is a Scheme expression that throw s (instead of just returning) the boolean false if it fails and a true value if it succeeds.
Reference: [25] <author> C. T. Haynes and D. P. Friedman. </author> <title> Abstracting Timed Preemption with Engines. </title> <journal> Journal of Computer Languages (Pergamon Press), </journal> <volume> 12(2) </volume> <pages> 109-121, </pages> <year> 1987. </year> <title> Preliminary version: Engines Build Process Abstractions. </title> <booktitle> In Proc. Conference on Lisp and Functional Programming, </booktitle> <year> 1985, </year> <pages> 18-24. </pages>
Reference-contexts: First-order control is the foundation for the sophisticated exception- or condition-handling systems in languages such as Common Lisp, ML, C++, EuLisp, and Dylan. Higher-order control operators provide a rich array of control metaphors|e.g., corou-tines, task scheduling, stream processing, and non-blind backtracking <ref> [24, 25, 26, 27] </ref>. In a quantifiable sense, control operators are expressive [18]: Neither purely functional languages nor those augmented with an assignment operator can simulate control actions with local syntactic translations. <p> Too 3 often, a heavy price in terms of excessive bookkeeping code and makeshift modularity is paid. For example, it is difficult to keep multiple uses of control idioms from interfering, or to enforce arbitrary patterns of desired interference. Haynes, Friedman and Wand <ref> [25, 26, 27] </ref> present several sophisticated examples of programming that addresses the problem of "constraining control," but because of its ad hoc nature, and its willing sacrifice of the more powerful raw control operator in favor of one of its constrained uses, more satisfactory techniques are needed. 1.3 Denotational models Denotational <p> An engine <ref> [10, 25] </ref> represents computation subject to timed preemption. It forms a tractable building block for realizing a variety of communicating concurrent processes. An engine's underlying computation is a thunk that can be run as a preemptable process. <p> This thunk, when called, resumes the interrupted engine computation. 17 Haynes and Friedman <ref> [25] </ref> distinguish two varieties of engines: flat (unnestable) and nestable. Flat engines cannot run other engines, but as the authors say, this restriction "considerably simplifies the implementation of engines," where the implementation uses Scheme-style continuations.
Reference: [26] <author> C. T. Haynes and D. P. Friedman. </author> <title> Embedding Continuations in Procedural Objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(4) </volume> <pages> 245-254, </pages> <year> 1987. </year> <month> 157 </month>
Reference-contexts: First-order control is the foundation for the sophisticated exception- or condition-handling systems in languages such as Common Lisp, ML, C++, EuLisp, and Dylan. Higher-order control operators provide a rich array of control metaphors|e.g., corou-tines, task scheduling, stream processing, and non-blind backtracking <ref> [24, 25, 26, 27] </ref>. In a quantifiable sense, control operators are expressive [18]: Neither purely functional languages nor those augmented with an assignment operator can simulate control actions with local syntactic translations. <p> Too 3 often, a heavy price in terms of excessive bookkeeping code and makeshift modularity is paid. For example, it is difficult to keep multiple uses of control idioms from interfering, or to enforce arbitrary patterns of desired interference. Haynes, Friedman and Wand <ref> [25, 26, 27] </ref> present several sophisticated examples of programming that addresses the problem of "constraining control," but because of its ad hoc nature, and its willing sacrifice of the more powerful raw control operator in favor of one of its constrained uses, more satisfactory techniques are needed. 1.3 Denotational models Denotational <p> This ability to substitute the current context by a previously stored context is simple and powerful, as attested by the several elegant programming metaphors that it allows <ref> [10, 13, 22, 24, 26, 27, 46] </ref>. The stepping rule for call/cc is: E [(call =cc M )] &gt; E [(M (lambda (v) (abort E [v])))] Thus, the reduction language supports abort expressions even if PS+call/cc itself does not. <p> an ample substitute for a prompt and its abort. 6 Second, delimiters for true higher-order continuations can be created in an ad hoc fashion by employing additional higher-order continuations. 7 Keeping track of several such continuations with their respective quasi-delimiters requires sophisticated bookkeeping effort even for a single control metaphor <ref> [10, 26] </ref>, not to mention simultaneous uses of different control abstractions. Thus it is useful to seek a higher-order generalization of the first-order prompt. A straightforward extrapolation of the first-order delimiter suggests that higher-order prompts delimit the extent of evaluation context captured or erased by control operators and their continuations. <p> call/cc-translation works too well, since the "exit" it simulates works even after program control has gone past the delimiting context! This is usually not a problem, but if it is absolutely necessary to ensure failure when such exits are attempted, it is possible to constrain call/cc appropriately with some effort <ref> [26] </ref>. The continuations that the constrained call/cc issues are first-order continuations. 7 See Chapter 7 for a Scheme ( PS+call/cc+assignment) implementation of higher-order prompts that is necessarily inefficient. <p> Other higher-order operators like call/cc use continuations to mark the entry/exit point, and indeed, need extra code to ensure that (a) such continuations are disabled when they can no longer reflect first-order usage and (b) the garbage collector can reach such 94 disabled continuations <ref> [26] </ref>. <p> In programming styles making heavy use of control manipulation, postludes maintain the integrity of local state as control jumps across far-off points. Postludes are used in both first-order and higher-order control arenas. Some well-known forms for invoking postludes are Common Lisp's unwind-protect [49] and Scheme's dynamic-wind <ref> [26] </ref>. The latter form also allows preludes, since local state needs to be safeguarded on both incoming as well as outgoing call/cc-jumps. In our case, an illustrative example of the need for postludes is the engine code in Chapter 6.
Reference: [27] <author> C. T. Haynes, D. P. Friedman, and M. Wand. </author> <title> Obtaining Coroutines from Continuations. </title> <journal> Journal of Computer Languages (Pergamon Press), </journal> 11(3/4):109-121, 1986. 
Reference-contexts: First-order control is the foundation for the sophisticated exception- or condition-handling systems in languages such as Common Lisp, ML, C++, EuLisp, and Dylan. Higher-order control operators provide a rich array of control metaphors|e.g., corou-tines, task scheduling, stream processing, and non-blind backtracking <ref> [24, 25, 26, 27] </ref>. In a quantifiable sense, control operators are expressive [18]: Neither purely functional languages nor those augmented with an assignment operator can simulate control actions with local syntactic translations. <p> Too 3 often, a heavy price in terms of excessive bookkeeping code and makeshift modularity is paid. For example, it is difficult to keep multiple uses of control idioms from interfering, or to enforce arbitrary patterns of desired interference. Haynes, Friedman and Wand <ref> [25, 26, 27] </ref> present several sophisticated examples of programming that addresses the problem of "constraining control," but because of its ad hoc nature, and its willing sacrifice of the more powerful raw control operator in favor of one of its constrained uses, more satisfactory techniques are needed. 1.3 Denotational models Denotational <p> This ability to substitute the current context by a previously stored context is simple and powerful, as attested by the several elegant programming metaphors that it allows <ref> [10, 13, 22, 24, 26, 27, 46] </ref>. The stepping rule for call/cc is: E [(call =cc M )] &gt; E [(M (lambda (v) (abort E [v])))] Thus, the reduction language supports abort expressions even if PS+call/cc itself does not. <p> In other words, the system's error procedure contains an fcontrol -application with the tag 'error. The user can employ the 'error prompt to catch errors dynamically at arbitrary points of the program in a manner reminiscent of the pre-Common-Lisp form errorset [34]. 6.6 Coroutines A coroutine <ref> [27, 32] </ref> generalizes a procedure by allowing interruptions and resumptions. Invoking a coroutine is much like invoking a procedure. However, at any point during the execution of the coroutine, a resume statement can transfer control to a different coroutine. <p> The suspended coroutine stores its remaining computation as its local control state. On resumption, the coroutine computation proceeds from exactly the point where it was interrupted. Haynes, Friedman and Wand <ref> [27] </ref> describe a succinct coroutine implementation that exploits call/cc. Each resume statement records the current continuation as 105 the coroutine's local control state. <p> The prompt's handler updates local-control-state and starts the new coroutine. The latter starts its remaining computation, as recorded within its local-control-state. All coroutine computations take place within their respective prompts, ensuring that their resumes only grab coroutine context. A more sophisticated coroutine paradigm <ref> [7, 27] </ref> includes an additional detach facility that allows a direct transfer of control back to the point where the coroutine (s) 106 were first called. In a call/cc world, detach requires remembering the continuation of the first coroutine call across all the encountered coroutines.
Reference: [28] <author> R. Hieb and R. K. Dybvig. </author> <title> Continuations and Concurrency. </title> <booktitle> In Second ACM SIG-PLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 128-136, </pages> <year> 1990. </year>
Reference-contexts: First introduced as an operationally useful mechanism by Felleisen [16], higher-order delim-iters, also called prompts, have been suggested in various settings. Examples include the reset of Danvy and Filinski [8], Hieb, Dybvig and Anderson's spawn <ref> [28, 29] </ref>, and Queinnec and Serpette's splitter [40]. In all cases, the delimiter endows the programmer with the ability to run a subcomputation as an independent program, in so far as control actions are concerned. <p> Both 142 approaches underscore the elegance and pragmatic utility of working with delimited contexts. Hieb, Dybvig and Anderson's spawn <ref> [28, 29] </ref> presents control manipulation in the presence of tree-structured concurrency. The spawn operator delimits a subcomputation and provides it a controller, a call/cc- or fcontrol -like operator that reifies "subcontinuations" and permits nonlocal exits to arbitrary points in a tree of processes.
Reference: [29] <author> R. Hieb, R. K. Dybvig, and C. W. Anderson III. </author> <title> Subcontinuations. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 7 </volume> <pages> 83-109, </pages> <year> 1994. </year>
Reference-contexts: First introduced as an operationally useful mechanism by Felleisen [16], higher-order delim-iters, also called prompts, have been suggested in various settings. Examples include the reset of Danvy and Filinski [8], Hieb, Dybvig and Anderson's spawn <ref> [28, 29] </ref>, and Queinnec and Serpette's splitter [40]. In all cases, the delimiter endows the programmer with the ability to run a subcomputation as an independent program, in so far as control actions are concerned. <p> Both 142 approaches underscore the elegance and pragmatic utility of working with delimited contexts. Hieb, Dybvig and Anderson's spawn <ref> [28, 29] </ref> presents control manipulation in the presence of tree-structured concurrency. The spawn operator delimits a subcomputation and provides it a controller, a call/cc- or fcontrol -like operator that reifies "subcontinuations" and permits nonlocal exits to arbitrary points in a tree of processes.
Reference: [30] <author> B. W. Kernighan and D. M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, 2nd edition, </address> <year> 1988. </year>
Reference-contexts: Introduction This work uses denotational models to study and enhance programming language constructs that manipulate non-local context information. Non-local control operators occur in such diverse languages as Algol [12], Lisp [34, 49], C <ref> [30] </ref>, C++ [53], Scheme [5, 54], ML [23, 37], EuLisp [38] and Dylan [11]|they enable the programmer to identify and restore enclosing or arbitrary control contexts in the program execution path. <p> Indeed, call/cc 0 applied to a vacuous application (i.e., thunk) is equivalent to an abort. 2 Abbreviated call/cc or cwcc in Scheme and callcc in ML. 3 The goto construct in the C language <ref> [30] </ref> provides only a limited form of call/cc's power: it can manipulate only the control within a procedure body. A closer analog is the setjmp/longjmp pair in the C standard library. 4 call/cc 0 is called C in [20]. Similarly, fcontrol (see below) is called F.
Reference: [31] <author> P. J. Landin. </author> <title> A Correspondence between Algol 60 and Church's Lambda Notation. </title> <journal> Communications of the ACM, </journal> <volume> 8(2) </volume> <pages> 89-101; 158-165, </pages> <year> 1965. </year>
Reference-contexts: An example is Scheme's and ML's call-with-current-continua 1 The symbol % is chosen for its similarity to an operating system prompt. Lisp's own prompt sign is usally &gt;|unfortunately, that symbol is taken. 23 tion [5, 9, 54]. 2 Like its historical forerunners J <ref> [31] </ref> and escape [41], call/cc is a control reifier : it reifies the control information of a running program and gives it to the user. The user can reinstate this control information at any time, thus creating arbitrary context jumps. <p> The value of the model consists in suggesting that the model's continuations can also be provided at the level of the language itself, thereby creating a more powerful facility for nonlocal control manipulation than untagged or tagged abort. Indeed, the introduction of higher-order control operators such as J <ref> [31] </ref>, escape [41] and catch or call/cc [54] is a recognition of this idea from abstract machines like the continuation model.
Reference: [32] <author> C. D. Marlin. </author> <title> Coroutines A Programming Methodology, a Language Design and an Implementation, </title> <booktitle> volume 95 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1980. </year>
Reference-contexts: In other words, the system's error procedure contains an fcontrol -application with the tag 'error. The user can employ the 'error prompt to catch errors dynamically at arbitrary points of the program in a manner reminiscent of the pre-Common-Lisp form errorset [34]. 6.6 Coroutines A coroutine <ref> [27, 32] </ref> generalizes a procedure by allowing interruptions and resumptions. Invoking a coroutine is much like invoking a procedure. However, at any point during the execution of the coroutine, a resume statement can transfer control to a different coroutine.
Reference: [33] <author> J. McCarthy. </author> <title> A basis for a mathematical theory of computation. </title> <booktitle> In Computer Programming and Formal Systems, </booktitle> <pages> pages 33-70. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1963. </year>
Reference-contexts: A simple procedure definition can retrieve the traditional variant. 138 On the other hand, some uses of the engine might entail legitimate exits outside the engine computation. For example, consider the following implementation of McCarthy's amb (ambiguous or nondeterministic parallel or) operator <ref> [33] </ref> using engines: (amb e : : : ) (let ([q (make-queue)]) (enqueue! q (make-engine (lambda () e))) : : : (let loop () (if (queue-empty? q) #f ((dequeue! q) *slice-of-time* (lambda (v n) (or v (loop))) (lambda (th) (enqueue! q (make-engine th)) (loop)))))) Thus, an amb-expression constructs engines out of
Reference: [34] <author> J. McCarthy et al. </author> <title> Lisp 1.5 Programmer's Manual. </title> <publisher> The MIT Press, </publisher> <address> 2nd edition, </address> <year> 1965. </year>
Reference-contexts: Introduction This work uses denotational models to study and enhance programming language constructs that manipulate non-local context information. Non-local control operators occur in such diverse languages as Algol [12], Lisp <ref> [34, 49] </ref>, C [30], C++ [53], Scheme [5, 54], ML [23, 37], EuLisp [38] and Dylan [11]|they enable the programmer to identify and restore enclosing or arbitrary control contexts in the program execution path. <p> For instance, the extended direct model for a functional language enhanced with abort also has the 6 ability to delimit aborting computations. Arbitrarily delimitable aborts are not just a theoretical necessity to ensure full abstraction|they are widely used in languages with first-order control, e.g., Lisp 1.5's errorset and error <ref> [34] </ref>, Common Lisp's catch and throw [49] and ML's handle and raise [23, 37]. A common embellishment for this setup is the association of tags on both abort and delimiter|e.g., a tagged throw can be delimited only a catch with an identical tag. <p> One can view the delimiter as receiving or handling the aborted value. In this more general version, first-order control manipulation is that which allows computations to abort to any dynamically enclosing control context, not necessarily the topmost program context. Examples of such controlled aborts are Lisp 1.5's error <ref> [34] </ref>, Common Lisp's throw [49] and ML's raise [23, 37]. The corresponding control delimiters are respectively errorset, catch and handle. Typically, languages allow tags on the aborting and delimiting forms. For instance, in Common Lisp, a tagged throw can only be delimited by a catch with an identical tag. <p> In other words, the system's error procedure contains an fcontrol -application with the tag 'error. The user can employ the 'error prompt to catch errors dynamically at arbitrary points of the program in a manner reminiscent of the pre-Common-Lisp form errorset <ref> [34] </ref>. 6.6 Coroutines A coroutine [27, 32] generalizes a procedure by allowing interruptions and resumptions. Invoking a coroutine is much like invoking a procedure. However, at any point during the execution of the coroutine, a resume statement can transfer control to a different coroutine.
Reference: [35] <author> A. R. Meyer and J. R. Riecke. </author> <title> Continuations may be unreasonable. </title> <booktitle> In Proc. 1988 Conference on Lisp and Functional Programming, </booktitle> <pages> pages 63-71, </pages> <year> 1988. </year> <month> 158 </month>
Reference-contexts: As Meyer and Riecke observed, terms that once behaved identically now act very differently, suggesting that control operators are "unreasonable" <ref> [35] </ref>. In technical terms, the operational equivalence relation that identifies interchangeable terms for a functional language is not a subset of the same relation for the language extended with a control operator.
Reference: [36] <author> R. Milner. </author> <title> Fully abstract models of typed -calculi. </title> <journal> Theoretical Computer Science, </journal> <volume> 4 </volume> <pages> 1-22, </pages> <year> 1977. </year>
Reference-contexts: The mapping is defined compositionally: In other words, a term's meaning depends only on the meanings|and no other property|of its subterms. The meanings mapped to are elements in a collection called the domain. A model determines two natural equivalence relations on the terms in the language <ref> [36, 39] </ref>. First, two terms are deemed denotationally equivalent if they map to the same meaning or denotation. The second relation focuses on the behavior of the terms as it appears to a user, who can only observe the working of whole programs. <p> The first step toward using the model is to connect the two equivalences in some tractable way. Ideally, the two relations should describe the same equivalence, a property called full abstraction of the model <ref> [36, 39] </ref>. A sound model ensures that the assignment of meanings does not result in any observable inconsistency. In other words, if the model assigns the same meaning to two terms, then a program context filled with either term should have the same meaning. <p> = ? (for other values of f ) 32 3.3 Semantic equivalence relations The crucial point about reasoning with the terms of a language is the ability to identify those terms that have the same "behavior." The model determines two natural equivalence relations on the closed terms in the language <ref> [36, 39] </ref>.
Reference: [37] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts and London, England, </address> <year> 1990. </year>
Reference-contexts: Introduction This work uses denotational models to study and enhance programming language constructs that manipulate non-local context information. Non-local control operators occur in such diverse languages as Algol [12], Lisp [34, 49], C [30], C++ [53], Scheme [5, 54], ML <ref> [23, 37] </ref>, EuLisp [38] and Dylan [11]|they enable the programmer to identify and restore enclosing or arbitrary control contexts in the program execution path. <p> Arbitrarily delimitable aborts are not just a theoretical necessity to ensure full abstraction|they are widely used in languages with first-order control, e.g., Lisp 1.5's errorset and error [34], Common Lisp's catch and throw [49] and ML's handle and raise <ref> [23, 37] </ref>. A common embellishment for this setup is the association of tags on both abort and delimiter|e.g., a tagged throw can be delimited only a catch with an identical tag. <p> In this more general version, first-order control manipulation is that which allows computations to abort to any dynamically enclosing control context, not necessarily the topmost program context. Examples of such controlled aborts are Lisp 1.5's error [34], Common Lisp's throw [49] and ML's raise <ref> [23, 37] </ref>. The corresponding control delimiters are respectively errorset, catch and handle. Typically, languages allow tags on the aborting and delimiting forms. For instance, in Common Lisp, a tagged throw can only be delimited by a catch with an identical tag.
Reference: [38] <author> J. A. Padget, G. Nuyens, and H. </author> <title> Bretthauer. An overview of EuLisp. </title> <journal> Lisp and Symbolic Computation, </journal> 6(1/2):9-98, 1993. 
Reference-contexts: Introduction This work uses denotational models to study and enhance programming language constructs that manipulate non-local context information. Non-local control operators occur in such diverse languages as Algol [12], Lisp [34, 49], C [30], C++ [53], Scheme [5, 54], ML [23, 37], EuLisp <ref> [38] </ref> and Dylan [11]|they enable the programmer to identify and restore enclosing or arbitrary control contexts in the program execution path. We show here that widely differing denotational models for any kind of control language invariably include facilities for delimiting and handling control actions|even though the language itself does not.
Reference: [39] <author> G. D. Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-255, </pages> <year> 1977. </year>
Reference-contexts: The mapping is defined compositionally: In other words, a term's meaning depends only on the meanings|and no other property|of its subterms. The meanings mapped to are elements in a collection called the domain. A model determines two natural equivalence relations on the terms in the language <ref> [36, 39] </ref>. First, two terms are deemed denotationally equivalent if they map to the same meaning or denotation. The second relation focuses on the behavior of the terms as it appears to a user, who can only observe the working of whole programs. <p> The first step toward using the model is to connect the two equivalences in some tractable way. Ideally, the two relations should describe the same equivalence, a property called full abstraction of the model <ref> [36, 39] </ref>. A sound model ensures that the assignment of meanings does not result in any observable inconsistency. In other words, if the model assigns the same meaning to two terms, then a program context filled with either term should have the same meaning. <p> The converse typically fails for the general run of languages and models|there are many instances of observationally indistinguishable terms that nevertheless map to different denotations. For example, in his treatment of the typed -calculus language PCF <ref> [39] </ref>, Plotkin showed that the conventional basic direct model is not fully abstract, by presenting two terms that are observationally, but not denotationally, equivalent. In essence, the program contexts possible in the language syntax are not powerful enough to bring forth the difference between the terms as a program answer. <p> PS is the purely functional subset of the programming language Scheme [5, 54], and is essentially the dynamically typed call-by-value -calculus <ref> [3, 39] </ref> with integers and some elementary arithmetic procedures. A control extension of PS is plain PS enhanced with one or more control-manipulating constructs. procedures and lambda-abstractions are procedure values. The numerals stand for the respective integers. If n is metasyntax for a number, then pnq is the corresponding numeral. <p> This information is captured succinctly in the form of an activity lemma. The formulation and proof of activity used here is a refinement of Plotkin's activity lemma for PCF <ref> [39] </ref> due to Felleisen [17]. We first introduce two definitions. Definition 2.1 (Generalized contexts) A generalized context is like a context except that it can have zero or more holes. <p> = ? (for other values of f ) 32 3.3 Semantic equivalence relations The crucial point about reasoning with the terms of a language is the ability to identify those terms that have the same "behavior." The model determines two natural equivalence relations on the closed terms in the language <ref> [36, 39] </ref>. <p> I.e., fully abstract models are those where M ' N iff M N , or a fully abstract model is implicitly sound. 37 not. Plotkin <ref> [39] </ref> describes a similar failure of the call-by-name language PCF with respect to its model, by producing two language terms that are denotationally different but observationally indistinguishable. <p> (e) if thaw (b) is 0 thaw (t) if it is neither 0 nor ? n if thaw (t) = thaw (e) = n, a number v:pif* b (freeze ((thaw (t))v)) (freeze ((thaw (e))v)) if thaw (t) and thaw (e) are both procedures Note that unlike the typed languages PCF <ref> [39] </ref> and value-PCF [47], the PS form of pif has to deal with procedures in the branches of the conditional. In this case, the selection of the branch is dependent on the eventual application of the entire pif-expression. <p> (pif (m 0) 1 (pif (n 0) 1 0)))) Now, using the context ([ ] por-th), the terms M 0 and M 1 are indeed observationally different. 3.5 Proving full abstraction To prove that the model is fully abstract for PS+pif, we follow a modification of the proof for PCF <ref> [39] </ref>. We first prove a lemma that all the compact elements in the 40 model are definable in PS, i.e., each compact element is the meaning of some term in the model. Using this result, we show that denotationally inequivalent terms cannot be observationally equivalent.
Reference: [40] <author> C. Queinnec and B. Serpette. </author> <title> A Dynamic Extent Control Operator for Partial Continuations. </title> <booktitle> In Proc. 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-184, </pages> <year> 1991. </year>
Reference-contexts: First introduced as an operationally useful mechanism by Felleisen [16], higher-order delim-iters, also called prompts, have been suggested in various settings. Examples include the reset of Danvy and Filinski [8], Hieb, Dybvig and Anderson's spawn [28, 29], and Queinnec and Serpette's splitter <ref> [40] </ref>. In all cases, the delimiter endows the programmer with the ability to run a subcomputation as an independent program, in so far as control actions are concerned. <p> Several control alternatives that go beyond Scheme's call/cc have been recently proposed. All of them involve control delimiting and some form of "composable" or "partial" continuations. Danvy and Filinski's shift and reset [8] and Queinnec and Serpette's splitter <ref> [40] </ref> are two such control proposals for a sequential language: The operator reset delimits the context reified by shift; the splitter operator delimits a computation, and provides it a fresh call/cc-like operator for internal use. Both 142 approaches underscore the elegance and pragmatic utility of working with delimited contexts.
Reference: [41] <author> J. C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proc. ACM Conference, </booktitle> <pages> pages 717-740, </pages> <year> 1972. </year>
Reference-contexts: An example is Scheme's and ML's call-with-current-continua 1 The symbol % is chosen for its similarity to an operating system prompt. Lisp's own prompt sign is usally &gt;|unfortunately, that symbol is taken. 23 tion [5, 9, 54]. 2 Like its historical forerunners J [31] and escape <ref> [41] </ref>, call/cc is a control reifier : it reifies the control information of a running program and gives it to the user. The user can reinstate this control information at any time, thus creating arbitrary context jumps. <p> Indeed, the introduction of higher-order control operators such as J [31], escape <ref> [41] </ref> and catch or call/cc [54] is a recognition of this idea from abstract machines like the continuation model.
Reference: [42] <author> J. Riecke. </author> <title> Delimiting the scope of effects. </title> <booktitle> ACM Conference on Functional Programming and Computer Architecture, </booktitle> <year> 1993. </year>
Reference-contexts: In particular, he has presented a full abstraction result for the typed cps model and PCF V +call/cc+% as a corollary of the theorem for plain PCF V . The method also promises to serve well for newer language extensions. Riecke's recent work <ref> [42] </ref> shows that the delimiter approach may also be useful in languages with imperative features other than control. His effects delimiters allow separation of the purely functional parts of a program from those using state, control or exceptions.
Reference: [43] <author> D. S. Scott. </author> <title> Domains for denotational semantics. </title> <booktitle> In Proc. International Conference on Automata, Languages, and Programming, </booktitle> <address> Berlin, </address> <year> 1982. </year> <booktitle> Lecture Notes in Mathematics 140, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: several sophisticated examples of programming that addresses the problem of "constraining control," but because of its ad hoc nature, and its willing sacrifice of the more powerful raw control operator in favor of one of its constrained uses, more satisfactory techniques are needed. 1.3 Denotational models Denotational or mathematical models <ref> [43] </ref> provide a mathematically amenable reasoning tool for a programming language. A denotational model offers a meaning function that maps the syntactic phrases ("terms") of the language to mathematical objects called meanings or denotations. <p> The purely functional language is an idealized but powerful, nonimperative subset of the real language Scheme: hence the name. The basic direct model that describes PS consists of a reflexive domain constructed using Scott's information systems <ref> [43] </ref> and the traditional mapping of syntax to semantics for the -calculus. The control models are of two kinds: The first is the traditional continuation semantics propounded by Strachey and Wadsworth [52]. <p> The model provides a mathematical description of the behavior of a program as a well-defined function of the behavior of the program's subterms. This chapter studies the basic direct model for the simple (purely functional) call-by-value language PS. 3.1 Building models We use Scott's information systems framework <ref> [43] </ref> to construct our models. For some basic background and notation about information systems, see Appendix A. A domain is a collection of consistent, deductively closed sets of propositions. <p> Some of them are beyond finite description. Hence it would be helpful to have more primitive means of characterizing a domain than just enumerating its contents. A.1 Information systems To this end, we follow the information systems approach propounded by Scott <ref> [43] </ref>. Each object in a domain is specified by the set of propositions that are true of it: we thus move from discussing objects to discussing propositions about objects. An information system (I.S.) D is a collection of atomic 30 propositions p, with a relation entails (`) over them. <p> These last two, however, are not related by the "entails" relation. Further, unless we intend to define roundness and redness by more finely grained properties, these propositions are atomic. (Every proposition entails .) 30 Contrary to Scott <ref> [43] </ref>, conjunctions of atomic propositions are not treated as elements of D. 144 The three propositions above are consistent, i.e., they could all hold simultaneously for an object, e.g., an apple. However, the propositions "it is red" and "it is green" are inconsistent.
Reference: [44] <author> K. Sieber. </author> <title> Relating full abstraction results for different programming languages. </title> <editor> In K. V. Nori and C. E. Veni Madhavan, editors, </editor> <booktitle> 10th Conference on Foundations of Software Engineering and Theoretical Computer Science, </booktitle> <pages> pages 373-387, </pages> <address> Berlin, </address> <year> 1990. </year> <note> Springer-Verlag. Lecture Notes in Computer Science 472. 159 </note>
Reference-contexts: The results are useful and pragmatically feasible, and solve many current problems of control programming. 8.2 Contemporary work There has been a significant amount of recent related work in the area we have just explored. Sieber <ref> [44] </ref>, who identified and corrected an error in my earlier investigation in the full abstraction of domains for PCF V (the typed -calculus with arithmetic), has presented a general method for relating full abstraction results across various languages.
Reference: [45] <author> D. Sitaram. </author> <title> Handling control. </title> <booktitle> Proc. SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 147-155, </pages> <year> 1993. </year>
Reference-contexts: These typeless models not only describe a more realistic and powerful language a la Scheme than [47], but also provide additional insight into the form of higher-order control delimiting|including control handling, a higher-order generalization of first-order exception handling and condition systems. 8 In "Handling Control" <ref> [45] </ref>, we readdressed pragmatic issues, and described important classes of use where the higher-order control-handling approach comes into its own. 1.6 Outline The following chapter describes the prototype bare-bones functional language Pure Scheme or PS, the vehicle for the upcoming discussion. <p> The prompt invokes the handling procedure on them. If the body of the prompt's first subexpression did not cause any control actions, its value is returned normally. This comprehensive higher-order generalization of the simple abort/prompt mechanism provides an excellent tool for diverse forms of control programs <ref> [45] </ref>. 2.9 The activity lemma for PS's control extensions The activity lemma, Lemma 2.3, holds in identical form for the control extensions of PS too.
Reference: [46] <author> D. Sitaram and M. Felleisen. </author> <title> Control Delimiters and Their Hierarchies. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(1) </volume> <pages> 67-99, </pages> <year> 1990. </year>
Reference-contexts: In all cases, the delimiter endows the programmer with the ability to run a subcomputation as an independent program, in so far as control actions are concerned. The uses of the prompt are diverse: it allows cleaner realizations of existing control abstractions and makes possible completely new programming styles <ref> [16, 46] </ref>. As a radically different model for higher-order control, we use Felleisen and Cart-wright's technique for extending the basic direct model to our control sublanguages. <p> Furthermore, control handlers are true higher-order versions of the popular exception-handling mechanisms. 1.5 Publications of results Components of this thesis and some related results were published separately. In "Control Delimiters and Their Hierarchies" <ref> [46] </ref>, we showed that control delimiters allow cleaner realizations of existing control abstractions and make possible completely new programming styles. <p> This ability to substitute the current context by a previously stored context is simple and powerful, as attested by the several elegant programming metaphors that it allows <ref> [10, 13, 22, 24, 26, 27, 46] </ref>. The stepping rule for call/cc is: E [(call =cc M )] &gt; E [(M (lambda (v) (abort E [v])))] Thus, the reduction language supports abort expressions even if PS+call/cc itself does not. <p> This is indeed a useful delimiter. Together with higher-order control reifiers like call/cc, call/cc 0 or fcontrol, the prompt supports a multitude of programming idioms <ref> [15, 46] </ref>. However, it does not completely generalize first-order abort and prompt. In the first-order scenario, an abort merely signals a control action, leaving it to the prompt to handle the control action by collecting the aborted value. <p> Plain run and fcontrol can build such control hierarchies. Several variations on this theme are possible <ref> [46] </ref>. As an example, we show here one approach to the problem of selectively interacting control operators: multiple tags. From several possible modes of interplay, we choose 135 the following scenario: Both run and fcontrol can take multiple tags.
Reference: [47] <author> D. Sitaram and M. Felleisen. </author> <title> Reasoning with Continuations II: How to Get Full Abstraction for Models of Control. </title> <booktitle> In Proc. 1990 Conference on Lisp and Functional Programming, </booktitle> <pages> pages 161-175, </pages> <year> 1990. </year>
Reference-contexts: In "Control Delimiters and Their Hierarchies" [46], we showed that control delimiters allow cleaner realizations of existing control abstractions and make possible completely new programming styles. In "Reasoning with Continuations II: How to Get Full Abstraction for Models of Control" <ref> [47] </ref>, we presented the full abstraction result for the basic direct model for PCF V , a call-by-value version of the typed - calculus. <p> In particular, we used the Felleisen and Cartwright extension technique to create control models that are very similar to the basic direct model. These typeless models not only describe a more realistic and powerful language a la Scheme than <ref> [47] </ref>, but also provide additional insight into the form of higher-order control delimiting|including control handling, a higher-order generalization of first-order exception handling and condition systems. 8 In "Handling Control" [45], we readdressed pragmatic issues, and described important classes of use where the higher-order control-handling approach comes into its own. 1.6 Outline <p> (b) is 0 thaw (t) if it is neither 0 nor ? n if thaw (t) = thaw (e) = n, a number v:pif* b (freeze ((thaw (t))v)) (freeze ((thaw (e))v)) if thaw (t) and thaw (e) are both procedures Note that unlike the typed languages PCF [39] and value-PCF <ref> [47] </ref>, the PS form of pif has to deal with procedures in the branches of the conditional. In this case, the selection of the branch is dependent on the eventual application of the entire pif-expression. <p> This is because models for control usually can also delimit control <ref> [47] </ref>. In the case of the extended direct model for PS+abort, the function :strip (thaw ()) provides this control-delimiting capability.
Reference: [48] <author> D. Sitaram and M. Felleisen. </author> <title> Modeling Continuations without Continuations. </title> <booktitle> In Proc. 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 185-196, </pages> <year> 1991. </year>
Reference-contexts: All three models possess the call-by-value variant of Plotkin's parallel-or. In addition, the control models also delimit control actions, be they first- or higher-order. In "Modeling Continuations without Continuations" <ref> [48] </ref>, we presented a preliminary investigation of reflexive models for PS, a latently typed language and its control extensions. In particular, we used the Felleisen and Cartwright extension technique to create control models that are very similar to the basic direct model. <p> Then the context (Ck [(: : : : : : 64 distinguishes the terms. 65 Chapter 5 Modeling PS+control directly The basic direct model of Chapter 3 can be extended to accommodate enhancements of PS that include control operators <ref> [19, 48] </ref>.
Reference: [49] <author> G. L. Steele Jr. </author> <title> Common Lisp: the Language. </title> <publisher> Digital Press, </publisher> <address> 2nd edition, </address> <year> 1990. </year> <editor> 1st ed., </editor> <year> 1984. </year>
Reference-contexts: Introduction This work uses denotational models to study and enhance programming language constructs that manipulate non-local context information. Non-local control operators occur in such diverse languages as Algol [12], Lisp <ref> [34, 49] </ref>, C [30], C++ [53], Scheme [5, 54], ML [23, 37], EuLisp [38] and Dylan [11]|they enable the programmer to identify and restore enclosing or arbitrary control contexts in the program execution path. <p> Arbitrarily delimitable aborts are not just a theoretical necessity to ensure full abstraction|they are widely used in languages with first-order control, e.g., Lisp 1.5's errorset and error [34], Common Lisp's catch and throw <ref> [49] </ref> and ML's handle and raise [23, 37]. A common embellishment for this setup is the association of tags on both abort and delimiter|e.g., a tagged throw can be delimited only a catch with an identical tag. <p> In this more general version, first-order control manipulation is that which allows computations to abort to any dynamically enclosing control context, not necessarily the topmost program context. Examples of such controlled aborts are Lisp 1.5's error [34], Common Lisp's throw <ref> [49] </ref> and ML's raise [23, 37]. The corresponding control delimiters are respectively errorset, catch and handle. Typically, languages allow tags on the aborting and delimiting forms. For instance, in Common Lisp, a tagged throw can only be delimited by a catch with an identical tag. <p> This tagging protocol, among others, is described in further detail in Chapter 7. The simple abort provided by the handler (lambda (r k ) r ) turns out in the tagged scenario to be identical to the catch/throw mechanism of traditional Lisp systems <ref> [49] </ref>, a useful embellishment of the basic procedure/loop exit. 6.5.1 Error handling A useful special tag (say 'error) may be reserved for user-manipulable error handling. Thus, computations run inside a call to a prompt tagged 'error will throw any errors to the prompt's handler. <p> In programming styles making heavy use of control manipulation, postludes maintain the integrity of local state as control jumps across far-off points. Postludes are used in both first-order and higher-order control arenas. Some well-known forms for invoking postludes are Common Lisp's unwind-protect <ref> [49] </ref> and Scheme's dynamic-wind [26]. The latter form also allows preludes, since local state needs to be safeguarded on both incoming as well as outgoing call/cc-jumps. In our case, an illustrative example of the need for postludes is the engine code in Chapter 6.
Reference: [50] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: In our implementation, a detach simply aborts a result value to the current coroutine prompt: : : : (let* ([local-control-state : : : ] [resume : : : ] [detach (lambda (v ) (fcontrol 'coroutine (lambda () v )))]) : : : 6.7 Backtracking through handling Prolog-style backtracking <ref> [6, 50] </ref> solves problem or goal by trying to solve its subgoals. If the goal is a simple or atomic goal, it is solved by matching it with statements or facts in a database. A goal that is solved is said to succeed.
Reference: [51] <author> J. E. Stoy and C. Strachey. OS6: </author> <title> An operating system for a small computer. </title> <journal> Comp. J., </journal> <volume> 15(2) </volume> <pages> 117-124, 195-203, </pages> <year> 1972. </year>
Reference-contexts: Indeed, the condition systems of ML, Common Lisp, Dylan [11] and C++ [53] are sophisticated instances of first-order control usage. In our idealized language, we call our delimiter the "prompt," %, recognizing that it treats its operand as an independent program, in so far as control actions are concerned <ref> [16, 51] </ref>, much like the prompt sign in a read-eval-print loop. 1 The syntax for a prompt expression is (% M ). <p> These features include assignment, input/output procedures, and zero- and variable-argument procedures [5]. Sometimes, it is convenient to view the control-delimiting construct as a procedure. This procedure is named run, borrowing a term from an operating-system routine that runs programs <ref> [51] </ref>. In a call-by-value language, a procedural delimiter like run, in contrast to the syntactic form prompt, requires its arguments to be values.
Reference: [52] <author> C. Strachey and C. P. Wadsworth. </author> <title> Continuations: A mathematical semantics for handling full jumps. </title> <type> Technical Report PRG-11, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <year> 1974. </year>
Reference-contexts: The basic direct model that describes PS consists of a reflexive domain constructed using Scott's information systems [43] and the traditional mapping of syntax to semantics for the -calculus. The control models are of two kinds: The first is the traditional continuation semantics propounded by Strachey and Wadsworth <ref> [52] </ref>. The second is an extension of the usual basic direct model used for the functional subset, and was recently proposed by Felleisen and Cartwright [19]. <p> gives B in the case of M , and something else for N , which can then be distinguished by a further surrounding context as above. 46 Chapter 4 The continuation model When modeling languages with control operators, the customary tool is the continuation model pioneered by Strachey and Wadsworth <ref> [52] </ref>. This model is also called the continuation-passing-style (or simply: cps) model, since its semantic function uses an additional "continuation" argument. At any point, the continuation argument represents the rest of the computation. In essence, the model encodes a stack machine for the language.
Reference: [53] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> 2nd edition, </address> <year> 1991. </year>
Reference-contexts: Introduction This work uses denotational models to study and enhance programming language constructs that manipulate non-local context information. Non-local control operators occur in such diverse languages as Algol [12], Lisp [34, 49], C [30], C++ <ref> [53] </ref>, Scheme [5, 54], ML [23, 37], EuLisp [38] and Dylan [11]|they enable the programmer to identify and restore enclosing or arbitrary control contexts in the program execution path. <p> It is no coincidence that many of the operators mentioned here are related to error or condition signalers and their handlers. Indeed, the condition systems of ML, Common Lisp, Dylan [11] and C++ <ref> [53] </ref> are sophisticated instances of first-order control usage.
Reference: [54] <author> G. J. Sussman and G. L. Steele Jr. </author> <title> Scheme: An interpreter for extended lambda calculus. </title> <type> Memo 349, </type> <institution> MIT AI Lab, </institution> <year> 1975. </year>
Reference-contexts: Introduction This work uses denotational models to study and enhance programming language constructs that manipulate non-local context information. Non-local control operators occur in such diverse languages as Algol [12], Lisp [34, 49], C [30], C++ [53], Scheme <ref> [5, 54] </ref>, ML [23, 37], EuLisp [38] and Dylan [11]|they enable the programmer to identify and restore enclosing or arbitrary control contexts in the program execution path. <p> Finally, for each extended version of the language, we describe an abstract machine for evaluating the programs in the language. 2.1 Pure Scheme We use Pure Scheme or PS as the prototypical language to present control manipulation. PS is the purely functional subset of the programming language Scheme <ref> [5, 54] </ref>, and is essentially the dynamically typed call-by-value -calculus [3, 39] with integers and some elementary arithmetic procedures. A control extension of PS is plain PS enhanced with one or more control-manipulating constructs. procedures and lambda-abstractions are procedure values. The numerals stand for the respective integers. <p> An example is Scheme's and ML's call-with-current-continua 1 The symbol % is chosen for its similarity to an operating system prompt. Lisp's own prompt sign is usally &gt;|unfortunately, that symbol is taken. 23 tion <ref> [5, 9, 54] </ref>. 2 Like its historical forerunners J [31] and escape [41], call/cc is a control reifier : it reifies the control information of a running program and gives it to the user. The user can reinstate this control information at any time, thus creating arbitrary context jumps. <p> Indeed, the introduction of higher-order control operators such as J [31], escape [41] and catch or call/cc <ref> [54] </ref> is a recognition of this idea from abstract machines like the continuation model.
References-found: 54

