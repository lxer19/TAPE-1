URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/fu-bin/Papers/istcs.ps
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/fu-bin/research.html
Root-URL: http://www.cs.yale.edu
Email: binfu@cs.umd.edu  beigel-richard@cs.yale.edu  
Title: A Comparison of Resource-Bounded Molecular Computation Models  
Author: Richard Beigel 
Address: P.O. Box 208285 New Haven, CT 06520-8285  College Park College Park, MD 20742-3251  
Affiliation: Dept. of Computer Science Yale University  Dept. of Computer Science University of Maryland at  
Abstract: The number of molecular strands used by a molecular algorithm is an important measure of the algorithm's complexity. This measure is also called the space used by the algorithm. We prove that three important polynomial-time models of molecular computation with bounded space are equivalent to models of polynomial-time Turing machine computation with bounded nondeterminism. Without any assumption, we show that the Split operation does not increase the power of polynomial-time molecular computation. Assuming a plausible separation between Turing machine complexity classes, the Amplify operation does increase the power of polynomial-time molecular computation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Adleman. </author> <title> Molecular computation of solutions to combi natorial problems. </title> <journal> Science, </journal> <volume> 266 </volume> <pages> 1021-1024, </pages> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: 1. Introduction Molecular computation was first studied in <ref> [1, 15] </ref>, which identified the number of molecular strands used as an important resource. This measure is also called the space (or the size of the solution space) used by the algorithm. Recent papers [3, 16, 4] have attempted to optimize solution space size for particular combinatorial problems. <p> His results suggest that the Amplify operation might increase the power of molecular computation. However, he considers only time complexity and not space complexity for molecular computation. Furthermore, only brute-force algorithms have been implemented in the memoryless models he describes. 2. Molecular Operations Molecular computation was first studied in <ref> [1, 15] </ref>. The models we define were inspired as well by the work of [3, 19]. A molecular sequence is a string over an alphabet S (we can use any alphabet we like, encoding characters of S by finite sequences of base pairs).
Reference: [2] <author> L. Adleman. </author> <title> On construction a molecular computer. </title> <booktitle> In 1st DIMACS workshop on DNA Computing, </booktitle> <year> 1995. </year>
Reference-contexts: The running time for a molecular algorithm is proportional to the number of operations on test tubes. An important complexity measure is the solution space size, i.e., the maximum number of strings in a tube, counting multiplicities. Adleman <ref> [2] </ref> has speculated that molecular computation with a solution space of size 2 70 might be possible. Recent papers [3, 16] attempt to optimize solution space size for particular combinatorial problems. 2.1.
Reference: [3] <author> E. Bach, A. Condon, E. Glaser, and C. Tanguay. </author> <title> DNA models and algorithms for NP-complete problems. </title> <booktitle> In Proceedings of the 11th Annual Conference on Structure in Complexity Theory, </booktitle> <pages> pages 290-299, </pages> <year> 1996. </year>
Reference-contexts: 1. Introduction Molecular computation was first studied in [1, 15], which identified the number of molecular strands used as an important resource. This measure is also called the space (or the size of the solution space) used by the algorithm. Recent papers <ref> [3, 16, 4] </ref> have attempted to optimize solution space size for particular combinatorial problems. In this paper we begin a systematic study of space-bounded molecular computation, and we determine the relations among several models of molecular computation and Turing machine computation. <p> However, he considers only time complexity and not space complexity for molecular computation. Furthermore, only brute-force algorithms have been implemented in the memoryless models he describes. 2. Molecular Operations Molecular computation was first studied in [1, 15]. The models we define were inspired as well by the work of <ref> [3, 19] </ref>. A molecular sequence is a string over an alphabet S (we can use any alphabet we like, encoding characters of S by finite sequences of base pairs). A test tube is a multiset of molecular sequences. We describe the allowable operations below. <p> An important complexity measure is the solution space size, i.e., the maximum number of strings in a tube, counting multiplicities. Adleman [2] has speculated that molecular computation with a solution space of size 2 70 might be possible. Recent papers <ref> [3, 16] </ref> attempt to optimize solution space size for particular combinatorial problems. 2.1. Example: satisfying a simple Boolean for mula This example, finding all satisfying assignments to the formula (x 1 _ x 2 ) ^ (x 1 _ x 2 ), is from [15]. <p> Corollary 2. MOL 0 (s (n)) = MOL (s (n)) = NPinit (s (n)) Note 1: Bach et al <ref> [3] </ref> define an asymmetric split operation that splits T 1 in a specified ratio r : 1 r. An ordinary split cannot simulate even an asymmetric split because an ordinary split is undefined on a tube with an odd number of elements.
Reference: [4] <author> R. Beigel and B. Fu. </author> <title> Molecular computing, bounded nonde terminism, and efficient recursion. </title> <type> YALEU/DCS/TR 1116, </type> <institution> Yale University, Dept. of Computer Science, </institution> <year> 1996. </year>
Reference-contexts: 1. Introduction Molecular computation was first studied in [1, 15], which identified the number of molecular strands used as an important resource. This measure is also called the space (or the size of the solution space) used by the algorithm. Recent papers <ref> [3, 16, 4] </ref> have attempted to optimize solution space size for particular combinatorial problems. In this paper we begin a systematic study of space-bounded molecular computation, and we determine the relations among several models of molecular computation and Turing machine computation. <p> Then use Split, Append, and Merge to generate the numbers 2 a 1 + + 2 a i1 + 1; : : : ; 2 a 1 + + 2 a i in tube T i . Second, Boneh et al [6] and independently Beigel and Fu <ref> [4] </ref> have shown that NPinit (s (n)) MOL (s (n)). In this section we will show that MOL 0 (s (n)) NPinit (s (n)). Thus MOL 0 (s (n)) = MOL (s (n)) = NPinit (s (n)). Theorem 1. <p> However, our proof of Theorem 1 works for asymmetric splits (just replace one half by the fraction r). Thus asymmetric splits are no better than ordinary splits as far as space is concerned. Note 2: In our simulation and in <ref> [4, 6] </ref> there is a 1-1 correspondence between molecular sequences and computational paths. Thus the counting versions of the classes above also coincide. 5. MOL-A (s (n)) = NPpaths (s (n)) Lemma 3. <p> If the gate depends on two bits of y, then this procedure is repeated for the second bit. At this point the gate's value is determined, and can be computed using the techniques of <ref> [4, 6] </ref>. Thus we have Theorem 5. NPpaths (s (n)) = MOL-A (s (n)) Note that this section's simulations provide a 1-1 correspondence between molecular sequences and computational paths. Thus the counting versions of NPpaths (s (n)) and MOL-A (s (n)) also coincide. 6. <p> Obviously, if P = NP then NPinit (s (n)) = NPpaths (s (n)). How does NPinit (s (n)) ? NPpaths (s (n)) relate to other questions in complexity theory? A large class of recursive algorithms can be converted to NPinit (s (n)) algorithms <ref> [4] </ref>. It would be interesting to look for a larger class of algorithm thats could be converted to NPpaths (s (n)) algorithms. <p> Our simulation of MOL 0 (s (n)) by NPinit (s (n)) maps t (n)-time molecular algorithms to t (n) 4 -time RAM algorithms (we have not closely examined the Turing machine implementation of these algorithms). Beigel and Fu's <ref> [4] </ref> and Boneh et al's [6] simulation of NPinit (s (n)) by MOL (s (n)) maps t (n)-time Turing machine algorithms to t (n) log t (n)-time molecular algorithms, because of the overhead for converting a Turing machine to a circuit.
Reference: [5] <author> R. Beigel and J. Goldsmith. </author> <title> Downward separation fails catas trophically for limited nondeterminism classes. </title> <booktitle> In Proceed ings of the 9th Annual Conferenceon Structure in Complexity Theory, </booktitle> <pages> pages 134-138, </pages> <year> 1994. </year>
Reference-contexts: Bounded Nondeterminism NP computation with a limited amount of nondetermin-ism was introduced in [12, 13, 14] and studied further in <ref> [8, 9, 17, 7, 10, 20, 11, 5] </ref>.
Reference: [6] <author> D. Boneh, C. Dunworth, R. J. Lipton, and J. Sgall. </author> <title> On the computational power of DNA. </title> <type> Manuscript, </type> <year> 1996. </year>
Reference-contexts: Then use Split, Append, and Merge to generate the numbers 2 a 1 + + 2 a i1 + 1; : : : ; 2 a 1 + + 2 a i in tube T i . Second, Boneh et al <ref> [6] </ref> and independently Beigel and Fu [4] have shown that NPinit (s (n)) MOL (s (n)). In this section we will show that MOL 0 (s (n)) NPinit (s (n)). Thus MOL 0 (s (n)) = MOL (s (n)) = NPinit (s (n)). Theorem 1. <p> However, our proof of Theorem 1 works for asymmetric splits (just replace one half by the fraction r). Thus asymmetric splits are no better than ordinary splits as far as space is concerned. Note 2: In our simulation and in <ref> [4, 6] </ref> there is a 1-1 correspondence between molecular sequences and computational paths. Thus the counting versions of the classes above also coincide. 5. MOL-A (s (n)) = NPpaths (s (n)) Lemma 3. <p> If the gate depends on two bits of y, then this procedure is repeated for the second bit. At this point the gate's value is determined, and can be computed using the techniques of <ref> [4, 6] </ref>. Thus we have Theorem 5. NPpaths (s (n)) = MOL-A (s (n)) Note that this section's simulations provide a 1-1 correspondence between molecular sequences and computational paths. Thus the counting versions of NPpaths (s (n)) and MOL-A (s (n)) also coincide. 6. <p> Our simulation of MOL 0 (s (n)) by NPinit (s (n)) maps t (n)-time molecular algorithms to t (n) 4 -time RAM algorithms (we have not closely examined the Turing machine implementation of these algorithms). Beigel and Fu's [4] and Boneh et al's <ref> [6] </ref> simulation of NPinit (s (n)) by MOL (s (n)) maps t (n)-time Turing machine algorithms to t (n) log t (n)-time molecular algorithms, because of the overhead for converting a Turing machine to a circuit.
Reference: [7] <author> J. F. Buss and J. Goldsmith. </author> <title> Nondeterminism within P. </title> <journal> SICOMP, </journal> <volume> 22 </volume> <pages> 560-572, </pages> <year> 1993. </year>
Reference-contexts: Bounded Nondeterminism NP computation with a limited amount of nondetermin-ism was introduced in [12, 13, 14] and studied further in <ref> [8, 9, 17, 7, 10, 20, 11, 5] </ref>.
Reference: [8] <author> J. D. C. Alvarez and J. Toran. </author> <title> Complexity classes with complete problems between P and NP-complete. </title> <booktitle> In Foundations of Computation Theory, </booktitle> <pages> pages 13-24. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <note> LNCS 380. </note>
Reference-contexts: Bounded Nondeterminism NP computation with a limited amount of nondetermin-ism was introduced in [12, 13, 14] and studied further in <ref> [8, 9, 17, 7, 10, 20, 11, 5] </ref>.
Reference: [9] <author> J. Daz and J. Toran. </author> <title> Classes of bounded nondeterminism. </title> <journal> MST, </journal> <volume> 23 </volume> <pages> 21-32, </pages> <year> 1990. </year>
Reference-contexts: Bounded Nondeterminism NP computation with a limited amount of nondetermin-ism was introduced in [12, 13, 14] and studied further in <ref> [8, 9, 17, 7, 10, 20, 11, 5] </ref>.
Reference: [10] <author> J. Goldsmith, M. Levy, and M. Mundhenk. </author> <title> Limited nonde terminism. </title> <journal> SIGACT News, </journal> <pages> pages 20-29, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Bounded Nondeterminism NP computation with a limited amount of nondetermin-ism was introduced in [12, 13, 14] and studied further in <ref> [8, 9, 17, 7, 10, 20, 11, 5] </ref>.
Reference: [11] <author> L. Hemachandra and S. Jha. </author> <title> Defying upward and downward separation. </title> <booktitle> In Proceedings of the 10th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 185-195. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> LNCS 665. </note>
Reference-contexts: Bounded Nondeterminism NP computation with a limited amount of nondetermin-ism was introduced in [12, 13, 14] and studied further in <ref> [8, 9, 17, 7, 10, 20, 11, 5] </ref>.
Reference: [12] <author> C. M. R. Kintala. </author> <title> Computations with a restricted number of nondeterministic steps. </title> <type> PhD thesis, </type> <institution> Pennsylvania State University, University Park, </institution> <address> PA, </address> <year> 1977. </year>
Reference-contexts: Bounded Nondeterminism NP computation with a limited amount of nondetermin-ism was introduced in <ref> [12, 13, 14] </ref> and studied further in [8, 9, 17, 7, 10, 20, 11, 5].
Reference: [13] <author> C. M. R. Kintala and P. C. Fischer. </author> <title> Computations with a restricted number of nondeterministic steps. </title> <booktitle> In Proceedings of the 9th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 178-185, </pages> <year> 1977. </year>
Reference-contexts: Bounded Nondeterminism NP computation with a limited amount of nondetermin-ism was introduced in <ref> [12, 13, 14] </ref> and studied further in [8, 9, 17, 7, 10, 20, 11, 5].
Reference: [14] <author> C. M. R. Kintala and P. C. Fischer. </author> <title> Refining nondetermin ism in relativized polynomial-time bounded computations. </title> <journal> SICOMP, </journal> <volume> 9(1) </volume> <pages> 46-53, </pages> <month> Feb. </month> <year> 1980. </year>
Reference-contexts: Bounded Nondeterminism NP computation with a limited amount of nondetermin-ism was introduced in <ref> [12, 13, 14] </ref> and studied further in [8, 9, 17, 7, 10, 20, 11, 5].
Reference: [15] <author> R. Lipton. </author> <title> Using DNA to solve NP-complete problems. </title> <journal> Science, </journal> <volume> 268 </volume> <pages> 542-545, </pages> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: 1. Introduction Molecular computation was first studied in <ref> [1, 15] </ref>, which identified the number of molecular strands used as an important resource. This measure is also called the space (or the size of the solution space) used by the algorithm. Recent papers [3, 16, 4] have attempted to optimize solution space size for particular combinatorial problems. <p> His results suggest that the Amplify operation might increase the power of molecular computation. However, he considers only time complexity and not space complexity for molecular computation. Furthermore, only brute-force algorithms have been implemented in the memoryless models he describes. 2. Molecular Operations Molecular computation was first studied in <ref> [1, 15] </ref>. The models we define were inspired as well by the work of [3, 19]. A molecular sequence is a string over an alphabet S (we can use any alphabet we like, encoding characters of S by finite sequences of base pairs). <p> Recent papers [3, 16] attempt to optimize solution space size for particular combinatorial problems. 2.1. Example: satisfying a simple Boolean for mula This example, finding all satisfying assignments to the formula (x 1 _ x 2 ) ^ (x 1 _ x 2 ), is from <ref> [15] </ref>. We will show how to solve this problem in the MOL (), MOL 0 (), and MOL-A () models.
Reference: [16] <author> M. Ogihara. </author> <title> Breadth first search 3SAT algorithms for DNA computers. </title> <type> Technical Report 629, </type> <institution> University of Rochester, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: 1. Introduction Molecular computation was first studied in [1, 15], which identified the number of molecular strands used as an important resource. This measure is also called the space (or the size of the solution space) used by the algorithm. Recent papers <ref> [3, 16, 4] </ref> have attempted to optimize solution space size for particular combinatorial problems. In this paper we begin a systematic study of space-bounded molecular computation, and we determine the relations among several models of molecular computation and Turing machine computation. <p> An important complexity measure is the solution space size, i.e., the maximum number of strings in a tube, counting multiplicities. Adleman [2] has speculated that molecular computation with a solution space of size 2 70 might be possible. Recent papers <ref> [3, 16] </ref> attempt to optimize solution space size for particular combinatorial problems. 2.1. Example: satisfying a simple Boolean for mula This example, finding all satisfying assignments to the formula (x 1 _ x 2 ) ^ (x 1 _ x 2 ), is from [15].
Reference: [17] <author> C. H. Papadimitriou and M. Yannakakis. </author> <title> On limited non-determinism and the complexity of the V-C dimension. </title> <booktitle> In Proceedings of the 8th Annual Conference on Structure in Complexity Theory, </booktitle> <pages> pages 12-18, </pages> <year> 1993. </year> <month> 5 </month>
Reference-contexts: Bounded Nondeterminism NP computation with a limited amount of nondetermin-ism was introduced in [12, 13, 14] and studied further in <ref> [8, 9, 17, 7, 10, 20, 11, 5] </ref>.
Reference: [18] <author> N. Pippenger and M. Fischer. </author> <title> Relations among complexity measures. </title> <journal> J. ACM, </journal> <volume> 26, </volume> <year> 1979. </year>
Reference-contexts: Call its input x. Modify the machine so that it behaves deterministically all choices specified by an auxiliary binary input y. Convert that machine to an equivalent circuit by the techniques of <ref> [18] </ref>. For a given x, we wish to evaluate that circuit for all s (jxj) possible y using molecular computation. The molecular algorithm evaluates the circuit bottom up.
Reference: [19] <author> D. Roos and K. Wagner. </author> <title> On the power of bio-computers. </title> <type> Technical report, </type> <institution> University of Wurzburg, </institution> <month> Feb. </month> <year> 1995. </year> <month> ftp://haegar.informatik.uni-wuerzburg.de/pub/TRs/ro-wa95.ps.gz. </month>
Reference-contexts: However, he considers only time complexity and not space complexity for molecular computation. Furthermore, only brute-force algorithms have been implemented in the memoryless models he describes. 2. Molecular Operations Molecular computation was first studied in [1, 15]. The models we define were inspired as well by the work of <ref> [3, 19] </ref>. A molecular sequence is a string over an alphabet S (we can use any alphabet we like, encoding characters of S by finite sequences of base pairs). A test tube is a multiset of molecular sequences. We describe the allowable operations below.
Reference: [20] <author> L. Sanchis. </author> <title> Constructing language instances based on partial information. </title> <journal> International Jour. Found. Comp. Sci., </journal> <volume> 5(2) </volume> <pages> 209-229, </pages> <year> 1994. </year>
Reference-contexts: Bounded Nondeterminism NP computation with a limited amount of nondetermin-ism was introduced in [12, 13, 14] and studied further in <ref> [8, 9, 17, 7, 10, 20, 11, 5] </ref>.
Reference: [21] <author> E. Winfree. </author> <title> Complexity of restricted and unrestricted models of molecular computation. </title> <note> http://dope.caltech.edu/winfree/Papers/models.ps.gz, May 1995. </note>
Reference-contexts: We conjecture that NPinit (s (n)) NPpaths (s (n)), so we believe that the Amplify operation does increase the power of polynomial-time molecular computation. Finally, we note that Winfree <ref> [21] </ref> has proved some relations between branching programs and memoryless molecular computation (where the Append operation is not allowed). His results suggest that the Amplify operation might increase the power of molecular computation. However, he considers only time complexity and not space complexity for molecular computation.
References-found: 21

