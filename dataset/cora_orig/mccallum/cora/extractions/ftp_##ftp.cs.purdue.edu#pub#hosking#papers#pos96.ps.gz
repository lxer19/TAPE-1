URL: ftp://ftp.cs.purdue.edu/pub/hosking/papers/pos96.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/hosking/papers.html
Root-URL: http://www.cs.purdue.edu
Email: hosking@cs.purdue.edu  
Title: Residency check elimination for object-oriented persistent languages  
Author: Antony L. Hosking 
Keyword: residency checks, optimization, object-orientation, static/dynamic dispatch  
Address: West Lafayette, IN 47907-1398, USA  
Affiliation: Department of Computer Sciences Purdue University  
Abstract: We explore the ramifications of object residency assumptions and their impact on residency checking for several subroutine dispatch scenarios: procedural, static object-oriented, and dynamic (virtual) object-oriented. We obtain dynamic counts of the residency checks necessary for execution of several benchmark persistent programs under each of these scenarios. The results reveal that significant reductions in the number of residency checks can be achieved through application of residency rules derived from the dispatch scenario under which a program executes, as well as additional constraints specific to the language in which it is implemented. 
Abstract-found: 1
Intro-found: 1
Reference: [ABC + 83] <author> M. P. Atkinson, P. J. Bailey, K. J. Chisholm, P. W. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal, </journal> <volume> 26(4) </volume> <pages> 360-365, </pages> <month> November </month> <year> 1983. </year>
Reference-contexts: Rather, the language implementation and run-time system contrive to make objects resident in memory on demand, much as non-resident pages are automatically made resident by a paged virtual memory system. Treating persistence as orthogonal to type <ref> [ABC + 83] </ref> has important ramifications for the design of persistent programming languages, since it encourages the view that a language can be extended to support persistence with minimal disturbance of its existing syntax and store semantics.
Reference: [ACC82] <author> Malcolm Atkinson, Ken Chisolm, and Paul Cockshott. </author> <title> PS-Algol: an Algol with a persistent heap. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 17(7) </volume> <pages> 24-31, </pages> <month> July </month> <year> 1982. </year>
Reference: [BBB + 88] <author> Francois Bancilhon, Gilles Barbedette, Veronique Benzaken, Claude Delobel, Sophie Gamerman, Christophe Lecluse, Patrick Pfeffer, Philippe Richard, and Fernando Velez. </author> <title> The design and implementation of O 2 , an object-oriented database system. </title> <booktitle> In Dittrich [Dit88], </booktitle> <pages> pages 1-22. </pages>
Reference: [BC86] <author> A. L. Brown and W. P. Cockshott. </author> <title> The CPOMS persistent object management system. Technical Report Persistent Programming Research Project 13, </title> <institution> University of St. </institution> <address> Andrews, Scotland, </address> <year> 1986. </year>
Reference: [CG94] <author> Brad Calder and Dirk Grunwald. </author> <title> Reducing indirect function call overhead in C++ programs. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 397-408, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Again, no target object residency checks are necessary in the called method. Note that although optimizations <ref> [Cha92, HU94, CG94, Fer95, DGC95, GDGC95, DMM96] </ref> may convert many indirect calls to direct calls, so increasing the number of explicit checks required, it is also likely that similarly aggressive optimizations can discover and eliminate redundant residency checks through intra- and inter-procedural data flow analysis.
Reference: [Cha92] <author> Craig Chambers. </author> <title> The design and implementation of the SELF compiler, an optimizing compiler for object-oriented programming languages. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1992. </year>
Reference-contexts: Again, no target object residency checks are necessary in the called method. Note that although optimizations <ref> [Cha92, HU94, CG94, Fer95, DGC95, GDGC95, DMM96] </ref> may convert many indirect calls to direct calls, so increasing the number of explicit checks required, it is also likely that similarly aggressive optimizations can discover and eliminate redundant residency checks through intra- and inter-procedural data flow analysis.
Reference: [Cha95] <author> Craig Chambers. </author> <title> The CECIL language: specification and rationale. </title> <note> Version 2.0. http://www.cs.washington.edu/research/projects/cecil/www/Papers/cecil-spec.html, December 1995. </note>
Reference-contexts: They include the selectors, constants and shared variables directly manipulated by the bytecodes of the method. Send bytecodes directly access literal selectors and certain stack bytecodes directly access shared variables. Thus, these bytecodes need not check the residency of the literals they manipulate. 3 Multi-methods, as in Cecil <ref> [Cha95] </ref>, in which method dispatch occurs on more than one argument of the method, would submit to folding of residency checks on all qualified arguments into the indirection of dispatch. 7 These special coresidency rules for Smalltalk force preloading of objects critical to the forward progress of computation, so that all
Reference: [CM84] <author> George Copeland and David Maier. </author> <title> Making Smalltalk a database system. </title> <booktitle> In Proceedings of the ACM International Conference on Management of Data, </booktitle> <pages> pages 316-325, </pages> <address> Boston, Massachusetts, </address> <month> June </month> <year> 1984. </year>
Reference: [CS92] <author> R. G. G. Cattell and J. Skeen. </author> <title> Object operations benchmark. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(1) </volume> <pages> 1-31, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: literal frame of the active method Jump bytecodes change the instruction pointer of the current activation Send bytecodes invoke compiled or primitive methods Return bytecodes terminate execution of the current activation, and return control to the calling activation 4.2 Benchmarks The performance evaluation draws on the OO1 object operations benchmarks <ref> [CS92] </ref> to compare the alternative execution scenarios. The operations are retrieval-oriented and operate on substantial data structures, although the benchmarks themselves are simple, and so easily understood.
Reference: [DGC95] <author> Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Optimization of object-oriented programs using static class hierarchy analysis. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: Again, no target object residency checks are necessary in the called method. Note that although optimizations <ref> [Cha92, HU94, CG94, Fer95, DGC95, GDGC95, DMM96] </ref> may convert many indirect calls to direct calls, so increasing the number of explicit checks required, it is also likely that similarly aggressive optimizations can discover and eliminate redundant residency checks through intra- and inter-procedural data flow analysis.
Reference: [Dit88] <editor> K. R. Dittrich, editor. </editor> <booktitle> Proceedings of the International Workshop on Object Oriented Database Systems, volume 334 of Lecture Notes in Computer Science, </booktitle> <address> Bad Munster am Stein-Ebernburg, Germany, </address> <month> September </month> <year> 1988. </year> <title> Advances in Object-Oriented Database Systems, </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <month> 8 </month>
Reference: [DMM96] <author> Amer Diwan, J. Eliot B. Moss, and Kathryn S. McKinley. </author> <title> Simple and effective analysis of statically-typed object-oriented programs. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> San Jose, California, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Again, no target object residency checks are necessary in the called method. Note that although optimizations <ref> [Cha92, HU94, CG94, Fer95, DGC95, GDGC95, DMM96] </ref> may convert many indirect calls to direct calls, so increasing the number of explicit checks required, it is also likely that similarly aggressive optimizations can discover and eliminate redundant residency checks through intra- and inter-procedural data flow analysis.
Reference: [DSZ90] <editor> Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, editors. </editor> <booktitle> Proceedings of the International Workshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, Massachusetts, </address> <month> September </month> <year> 1990. </year> <title> Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference: [Fer95] <author> Mary F. Fernandez. </author> <title> Simple and effective link-time optimization of Modula-3 programs. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 103-115, </pages> <address> La Jolla, California, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Again, no target object residency checks are necessary in the called method. Note that although optimizations <ref> [Cha92, HU94, CG94, Fer95, DGC95, GDGC95, DMM96] </ref> may convert many indirect calls to direct calls, so increasing the number of explicit checks required, it is also likely that similarly aggressive optimizations can discover and eliminate redundant residency checks through intra- and inter-procedural data flow analysis.
Reference: [GDGC95] <author> David Grove, Jeffrey Dean, Charles Garrett, and Craig Chambers. </author> <title> Profile-guided receiver class prediction. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 108-123, </pages> <address> Austin, Texas, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Again, no target object residency checks are necessary in the called method. Note that although optimizations <ref> [Cha92, HU94, CG94, Fer95, DGC95, GDGC95, DMM96] </ref> may convert many indirect calls to direct calls, so increasing the number of explicit checks required, it is also likely that similarly aggressive optimizations can discover and eliminate redundant residency checks through intra- and inter-procedural data flow analysis.
Reference: [GR83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: We also consider the effect of additional coresidency constraints arising from specific knowledge of Smalltalk's bytecode instruction set and execution semantics. 4.1 A prototype implementation: Persistent Smalltalk The prototype is an implementation of Smalltalk <ref> [GR83] </ref>, extended for persistence. It has two components: a virtual machine and a virtual image. The virtual machine implements the bytecode instruction set to which Smalltalk source code is compiled, along with certain primitive methods whose functionality is built directly into the virtual machine. <p> Otherwise, the full method lookup locates the compiled method and loads the cache entry with the selector, class and method, before invoking the method. 4.1.2 The bytecode instruction set We retain the standard Smalltalk-80 bytecode instruction set <ref> [GR83] </ref>, which is partitioned by functionality as follows: Stack bytecodes move object references between the evaluation stack of the current activation and: 1. the named instance variables of the receiver for that activation 2. the temporary variables local to that activation 3. the shared variables of the literal frame of the
Reference: [HBM93] <author> Antony L. Hosking, Eric Brown, and J. Eliot B. Moss. </author> <title> Update logging for persistent programming languages: A comparative performance evaluation. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <pages> pages 429-440, </pages> <address> Dublin, Ireland, August 1993. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Some approaches drive all faulting with memory protection traps and make object faulting entirely transparent to compiled code; these have only one representation: virtual memory pointers to apparently resident objects. However, there is evidence to suggest that such totally transparent schemes do not always offer the best performance <ref> [HMS92, HM93a, HM93b, HBM93, Hos95, HM95] </ref>. Thus, multiple representations arise for references to resident objects (which can be used without causing an object fault), versus references to non-resident objects, along with explicit residency checks to distinguish them.
Reference: [HM90] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Towards compile-time optimisations for persistence. </title> <editor> In Dearle et al. </editor> <booktitle> [DSZ90], </booktitle> <pages> pages 17-27. </pages>
Reference-contexts: The mechanism must be sufficiently lightweight as to represent only marginal overhead to frequently-executed operations on fine-grained objects. Nevertheless, even marginal overhead will have a cumulatively significant impact on overall performance. Thus, any opportunity should be exploited to elide residency checks where they are not strictly necessary <ref> [HM90, HM91, MH94] </ref>. Such optimizations rely on data flow analysis and code transformations (e.g., hoisting or combining residency checks) and the imposition of special rules about the residency of particular objects.
Reference: [HM91] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Compiler support for persistent programming. </title> <type> Technical Report 91-25, </type> <institution> Department of Computer Science, University of Massachusetts at Amherst, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: The mechanism must be sufficiently lightweight as to represent only marginal overhead to frequently-executed operations on fine-grained objects. Nevertheless, even marginal overhead will have a cumulatively significant impact on overall performance. Thus, any opportunity should be exploited to elide residency checks where they are not strictly necessary <ref> [HM90, HM91, MH94] </ref>. Such optimizations rely on data flow analysis and code transformations (e.g., hoisting or combining residency checks) and the imposition of special rules about the residency of particular objects.
Reference: [HM93a] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Object fault handling for persistent programming languages: A performance evaluation. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 288-303, </pages> <address> Washington, DC, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: Some approaches drive all faulting with memory protection traps and make object faulting entirely transparent to compiled code; these have only one representation: virtual memory pointers to apparently resident objects. However, there is evidence to suggest that such totally transparent schemes do not always offer the best performance <ref> [HMS92, HM93a, HM93b, HBM93, Hos95, HM95] </ref>. Thus, multiple representations arise for references to resident objects (which can be used without causing an object fault), versus references to non-resident objects, along with explicit residency checks to distinguish them.
Reference: [HM93b] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Protection traps and alternatives for memory management of an object-oriented language. </title> <booktitle> In Proceedings of the ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 106-119, </pages> <address> Asheville, North Carolina, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Some approaches drive all faulting with memory protection traps and make object faulting entirely transparent to compiled code; these have only one representation: virtual memory pointers to apparently resident objects. However, there is evidence to suggest that such totally transparent schemes do not always offer the best performance <ref> [HMS92, HM93a, HM93b, HBM93, Hos95, HM95] </ref>. Thus, multiple representations arise for references to resident objects (which can be used without causing an object fault), versus references to non-resident objects, along with explicit residency checks to distinguish them.
Reference: [HM95] <author> Antony L. Hosking and J. Eliot B. Moss. </author> <title> Lightweight write detection and checkpointing for fine-grained persistence. </title> <type> Technical Report 95-084, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: Some approaches drive all faulting with memory protection traps and make object faulting entirely transparent to compiled code; these have only one representation: virtual memory pointers to apparently resident objects. However, there is evidence to suggest that such totally transparent schemes do not always offer the best performance <ref> [HMS92, HM93a, HM93b, HBM93, Hos95, HM95] </ref>. Thus, multiple representations arise for references to resident objects (which can be used without causing an object fault), versus references to non-resident objects, along with explicit residency checks to distinguish them.
Reference: [HMB90] <author> Antony L. Hosking, J. Eliot B. Moss, and Cynthia Bliss. </author> <title> Design of an object faulting persistent Smalltalk. </title> <type> Technical Report 90-45, </type> <institution> Department of Computer Science, University of Massachusetts at Amherst, </institution> <month> May </month> <year> 1990. </year>
Reference: [HMS92] <author> Antony L. Hosking, J. Eliot B. Moss, and Darko Stefanovic. </author> <title> A comparative performance evaluation of write barrier implementations. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 92-109, </pages> <address> Vancouver, Canada, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Some approaches drive all faulting with memory protection traps and make object faulting entirely transparent to compiled code; these have only one representation: virtual memory pointers to apparently resident objects. However, there is evidence to suggest that such totally transparent schemes do not always offer the best performance <ref> [HMS92, HM93a, HM93b, HBM93, Hos95, HM95] </ref>. Thus, multiple representations arise for references to resident objects (which can be used without causing an object fault), versus references to non-resident objects, along with explicit residency checks to distinguish them.
Reference: [Hos91] <author> Antony L. Hosking. </author> <title> Main memory management for persistence, </title> <month> October </month> <year> 1991. </year> <note> Position paper presented at the OOPSLA'91 Workshop on Garbage Collection. </note>
Reference: [Hos95] <author> Antony L. Hosking. </author> <title> Lightweight Support for Fine-Grained Persistence on Stock Hardware. </title> <type> PhD thesis, </type> <institution> University of Massachusetts at Amherst, </institution> <month> February </month> <year> 1995. </year> <note> Available as Department of Computer Science Technical Report 95-02. </note>
Reference-contexts: Some approaches drive all faulting with memory protection traps and make object faulting entirely transparent to compiled code; these have only one representation: virtual memory pointers to apparently resident objects. However, there is evidence to suggest that such totally transparent schemes do not always offer the best performance <ref> [HMS92, HM93a, HM93b, HBM93, Hos95, HM95] </ref>. Thus, multiple representations arise for references to resident objects (which can be used without causing an object fault), versus references to non-resident objects, along with explicit residency checks to distinguish them. <p> We consider the effect of specific coresidency rules below in the context of the prototype persistent system used in the experiments. 4 Experiments We have instrumented the execution of several benchmark persistent programs executing in our prototype persistent Smalltalk system <ref> [Hos95] </ref> to obtain dynamic counts of residency checks performed under each of the above scenarios.
Reference: [HU94] <author> Urs Holzle and David Ungar. </author> <title> Optimizing dynamically-dispatched calls with run-time type feedback. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 326-336, </pages> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Again, no target object residency checks are necessary in the called method. Note that although optimizations <ref> [Cha92, HU94, CG94, Fer95, DGC95, GDGC95, DMM96] </ref> may convert many indirect calls to direct calls, so increasing the number of explicit checks required, it is also likely that similarly aggressive optimizations can discover and eliminate redundant residency checks through intra- and inter-procedural data flow analysis.
Reference: [Kae86] <author> Ted Kaehler. </author> <title> Virtual memory on a narrow machine for an object-oriented language. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 87-106, </pages> <address> Portland, Oregon, </address> <month> September </month> <year> 1986. </year>
Reference: [KK83] <author> Ted Kaehler and Glenn Krasner. </author> <title> LOOMlarge object-oriented memory for Smalltalk-80 systems. </title> <editor> In Glenn Krasner, editor, </editor> <title> Smalltalk-80: Bits of History, Words of Advice, </title> <booktitle> chapter 14, </booktitle> <pages> pages 251-270. </pages> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference: [LLOW91] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinreb. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year> <month> 9 </month>
Reference: [MH94] <author> J. Eliot B. Moss and Antony L. Hosking. </author> <title> Expressing object residency optimizations using pointer type annotations. </title> <editor> In Malcolm Atkinson, David Maier, and Veronique Benzaken, editors, </editor> <booktitle> Proceedings of the International Workshop on Persistent Object Systems, Workshops in Computing, </booktitle> <pages> pages 3-15, </pages> <address> Tarascon, France, September 1994. </address> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The mechanism must be sufficiently lightweight as to represent only marginal overhead to frequently-executed operations on fine-grained objects. Nevertheless, even marginal overhead will have a cumulatively significant impact on overall performance. Thus, any opportunity should be exploited to elide residency checks where they are not strictly necessary <ref> [HM90, HM91, MH94] </ref>. Such optimizations rely on data flow analysis and code transformations (e.g., hoisting or combining residency checks) and the imposition of special rules about the residency of particular objects.
Reference: [RC90] <author> Joel E. Richardson and Michael J. Carey. </author> <title> Persistence in the E language: Issues and implementation. </title> <journal> Software: Practice and Experience, </journal> 19(12) 1115-1150, December 1990. 
Reference: [Ric89] <author> Joel Edward Richardson. E: </author> <title> A Persistent Systems Implementation Language. </title> <type> PhD thesis, </type> <institution> University of Wisconsin - Madison, </institution> <month> August </month> <year> 1989. </year> <note> Available as Computer Sciences Technical Report 868. </note>
Reference: [Ric90] <author> Joel E. Richardson. </author> <title> Compiled item faulting: A new technique for managing I/O in a persistent language. </title> <editor> In Dearle et al. </editor> <booktitle> [DSZ90], </booktitle> <pages> pages 3-16. </pages>
Reference: [RMS88] <author> Steve Riegel, Fred Mellender, and Andrew Straw. </author> <title> Integration of database management with an object-oriented programming language. </title> <booktitle> In Dittrich [Dit88], </booktitle> <pages> pages 317-322. </pages>
Reference: [SCD90] <author> D. Schuh, M. Carey, and D. DeWitt. </author> <title> Persistence in E revisitedimplementation experiences. </title> <editor> In Dearle et al. </editor> <booktitle> [DSZ90], </booktitle> <pages> pages 345-359. </pages>
Reference: [SKW92] <author> Vivek Singhal, Sheetal V. Kakkad, and Paul R. Wilson. </author> <title> Texas, an efficient, portable persistent store. </title> <editor> In Antonio Albano and Ronald Morrison, editors, </editor> <booktitle> Proceedings of the International Workshop on Persistent Object Systems, Workshops in Computing, </booktitle> <pages> pages 11-33, </pages> <address> San Miniato, Italy, September 1992. </address> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [SMR89] <author> Andrew Straw, Fred Mellender, and Steve Riegel. </author> <title> Object management in a persistent Smalltalk system. </title> <journal> Software: Practice and Experience, </journal> <volume> 19(8) </volume> <pages> 719-737, </pages> <month> August </month> <year> 1989. </year>
Reference: [Sun95a] <institution> The Java language specification. </institution> <type> Technical white paper, </type> <institution> Sun Microsystems Computer Corporation, </institution> <month> August </month> <year> 1995. </year> <note> Release 1.0 Beta. </note>
Reference-contexts: It would be interesting to consider the application of similar techniques for persistence to other dynamic object-oriented languages, such as Java <ref> [Sun95a, Sun95b] </ref>.
Reference: [Sun95b] <institution> The Java virtual machine specification. </institution> <type> Technical white paper, </type> <institution> Sun Microsystems Computer Corporation, </institution> <month> October </month> <year> 1995. </year> <note> Version 1.0 Beta. </note>
Reference-contexts: It would be interesting to consider the application of similar techniques for persistence to other dynamic object-oriented languages, such as Java <ref> [Sun95a, Sun95b] </ref>.
Reference: [WD92] <author> Seth J. White and David J. DeWitt. </author> <title> A performance study of alternative object faulting and pointer swizzling strategies. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <pages> pages 419-431, </pages> <address> Vancouver, Canada, August 1992. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Although this operation is a reasonable measure of update overhead, it is hampered by a lack of control over the number and distribution of the locations modified, and its mixing of updates to parts and the index. A more easily controlled benchmark is the following: Update <ref> [WD92] </ref> operates in the same way as the Traversal measure, but instead of calling a null procedure it performs a simple update to each part object encountered, with some fixed probability. The update consists of incrementing the x and y scalar integer fields of the part.
Reference: [WK92] <author> Paul R. Wilson and Sheetal V. Kakkad. </author> <title> Pointer swizzling at page fault time: Efficiently and compatibly supporting huge address spaces on standard hardware. </title> <booktitle> In Proceedings of the 1992 International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 364-377, </pages> <address> Paris, France, </address> <month> September </month> <year> 1992. </year> <journal> IEEE. </journal> <volume> 10 </volume>
References-found: 42

