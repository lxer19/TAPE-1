URL: http://www.cse.ucsc.edu/~clay/ocbt/ton.ps
Refering-URL: http://www.cse.ucsc.edu/~clay/ocbt/ocbt.html
Root-URL: http://www.cse.ucsc.edu
Title: OCBT A Protocol for Loop-Free Shared Multicast Trees  
Author: Clay Shields J.J. Garcia-Luna-Aceves 
Address: Santa Cruz, CA 95064  
Affiliation: Computer Engineering Department School of Engineering University of California, Santa Cruz  
Abstract: We present a new protocol called the Ordered Core Based Tree (OCBT) protocol, which extends the operation of the Core Based Tree (CBT) protocol to use multiple cores in the construction and maintenance of multicast trees. OCBT avoids the termination and undetected looping problems we have identified with multiple core versions of CBT in the past. The use of multiple cores improves both scalability and the robustness of the multicast tree by eliminating the single point of failure inherent in using a single core. OCBT is loop free at all times, and, using the redundancy provided by multiple cores, is the only existing shared-tree multicast routing protocol builds a multicast tree in finite time following a failure or network partition. Simulation results indicate that the amount of control traffic in OCBT is comparable to that in CBT and demonstrate the effectiveness of OCBT in preventing loops from forming in a shared multicast tree. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Ballardie, B. Cain, and Z. Zhang. </author> <title> Core Based Trees (CBT version 3) Multicast Routing. </title> <type> Internet-Draft, </type> <month> March </month> <year> 1998. </year>
Reference-contexts: The later version of CBT <ref> [1] </ref> no longer uses hard state and instead uses periodic refreshes to maintain the state od the tree. Shared-tree protocols are very attractive, because they lower the amount of state maintained at each multicast router and the control traffic required to build and maintain the multicast tree. <p> Besides the looping problem, we also show that CBT with multiple cores might not always form a multicast tree [9]. As a result of these findings, CBT has returned to the single-core model <ref> [1] </ref>, which ensures loop freedom but retains the original limitations of a single-core model. Section 2 presents a new protocol that eliminates the looping problem and other problems that can keep a multiple-core multicast tree from forming in CBT. <p> OCBT does this without increasing the complexity of the protocol. The ideas presented in OCBT have influenced the latest version of CBT <ref> [1] </ref>. Section 3 presents a proof of correctness of OCBT, which also shows that under normal operation the a single-core version of CBT is correct, given that it corresponds to a single-core instance of OCBT. <p> In contrast, under CBT, nodes must wait for an acknowledgment from the parent before leaving the tree. OCBT uses the keep-alive mechanism to detect lost quit-notices and flush messages instead of using explicit acknowledgments. More recent specifications of CBT <ref> [1] </ref> have abandoned the use of multiple cores but has included OCBT's quit mechanism. A parent-assert message is included in OCBT to insure that consistent state information is maintained between nodes. A parent keeps track of reception of keep-alive packets from its children.
Reference: [2] <author> A.J. Ballardie, P. Francis, and J. Crowcroft. </author> <title> Core based trees (CBT). </title> <booktitle> In Proc. ACM SIGCOMM 93, </booktitle> <pages> pages 85-95, </pages> <address> San Francisco, California, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: Within a large network with a multicast group containing many sources, the overhead required at on-tree routers can be excessive. Other protocols assume a different approach in forming the tree. In both the Core Based Tree (CBT) multicast protocol <ref> [2] </ref> and in the Protocol Independent Multicast-Sparse Mode (PIM-SM) protocol [7] [6], a single shared tree is created for distribution of data from all senders to all receivers in the group. In each of these receiver-initiated protocols, a well known router exists that accepts connection requests from other routers. <p> Sparse-mode PIM maintains branches in a soft state, in which not all senders are connected directly to the rendezvous point, though all receivers are part of a shared distribution tree that is periodically refreshed. As proposed, CBT <ref> [2] </ref> operates in a hard state, such that all receivers, and senders who desire to be, are connected to the tree by branches that stay in place once they are created, until they are removed explicitly by the protocol or by some link or node failure; this allows orderly data packet <p> Shared-tree protocols are very attractive, because they lower the amount of state maintained at each multicast router and the control traffic required to build and maintain the multicast tree. The specific mechanisms used in CBT have changed as the protocol has evolved. The original CBT design <ref> [2] </ref> constructs multicast trees by specifying a single core for any multicast group. A router wishing to participate in the multicast session sends a join-request towards the single core; this request travels fl This work was supported in part by the Defense Advanced Research Projects Agency under contract No. <p> In addition, in a tree with many link failures, OCBT's reduced repair costs actually makes the amortized cost of construction lower than CBT. 5 CONCLUDING REMARKS We have described an extension to CBT <ref> [2] </ref> using multiple cores that is scalable, has low repair latency, is loop free, and is proven correct in forming a multicast tree.
Reference: [3] <author> A.J. Ballardie, S. Reeve, and N. Jain. </author> <title> Core Based Trees (CBT) Multicast Protocol Specification. </title> <type> Internet draft, </type> <institution> University College London, </institution> <month> April </month> <year> 1996. </year> <title> Work in progress. </title>
Reference-contexts: Second, using a single global core can result in very poor paths between senders and receivers located close to each other. As a solution to these problems, a revision of the original CBT was presented <ref> [3] </ref> that used multiple cores. Under this scheme, senders and receivers can join a secondary core that helps provide a shorter path between local members of the multicast group. Each secondary core then joins a primary core that serves as a connection point for the secondary cores. <p> Section 4 includes simulation results showing the performance of OCBT and CBT, based on the CBT specifications of April 1996 <ref> [3] </ref> which first introduced multiple cores. These simulation results illustrate the importance of the ordering concepts introduced in OCBT. <p> This results in less traffic following a link failure than in CBT, in which flush messages originating near a core or rejoin messages originating far from the core have to travel relatively long distances. More recent specifications for CBT <ref> [3] </ref> have a single primary core that forms a point of connection for secondary 8 3. CORRECTNESS OF OCBT cores that stay off-tree until required to join. <p> For each run of the simulation, we chose distributed nodes of relatively high degree to serve as cores. For OCBT, the cores were divided into two logical levels. We constructed the CBT backbone before allowing receivers to connect even though the April 1996 protocol specification <ref> [3] </ref> does not; we did this because of the difficulty CBT has in connecting secondary cores to the primary cores. Building each of the trees for each receiver group, we measured the construction costs in terms of the traffic required. <p> We compared the performance of OCBT against that of the multiple core CBT specification <ref> [3] </ref> over the 12 different core sets shown in Figure 5.1. The results are summarized in Table 5.2. Each run shows the averaged performance of OCBT and CBT for a sparse and dense receiver group for the selected core set. <p> As each set of simulation runs included 138 runs of the CBT protocol, and an average of 15.6 disconnected sub-trees were formed during those runs, we found a disconnection rate of 11.3% under the April 1996 protocol specifications <ref> [3] </ref>. Clearly, a routing protocol that is unable to find a correct path when one exists one time out of nine is hardly suitable for use in a large Internet. <p> OCBT is also the first receiver-initiated multicast protocol that can tolerate partitions. As our verification shows, OCBT eliminates the loops and disconnected sub-trees that occur in the multiple-core version of the CBT <ref> [3] </ref> protocol; our simulation experiments confirm this as well.
Reference: [4] <author> S. Deering, D. Estrin, D. Farinacci, V. Jacobson, A. Helmy, and L. Wei. </author> <title> Protocol Independent Multicast Version 2, Dense Mode Specification. </title> <type> Internet draft, </type> <month> May </month> <year> 1997. </year> <note> Work in progess. </note>
Reference-contexts: 1 INTRODUCTION There are a variety of existing and proposed protocols to perform multicast routing in the Internet. Some protocols, such as the Distance Vector Multicast Routing Protocol (DVMRP) [5] and the Protocol Independent Multicast-Dense Mode (PIM-DM) protocol <ref> [4] </ref>, form a source-based tree from each sender and require that each router maintain information for each source in a multicast group. Additionally, DVMRP requires routers that do not wish to be part of the multicast group to send messages to prune themselves from the tree.
Reference: [5] <author> S. E. Deering. </author> <title> Multicast Routing in a Datagram Internetwork. </title> <type> PhD thesis, </type> <institution> Stanford University, Palo Alto, California, </institution> <month> December </month> <year> 1991. </year> <note> References 17 </note>
Reference-contexts: 1 INTRODUCTION There are a variety of existing and proposed protocols to perform multicast routing in the Internet. Some protocols, such as the Distance Vector Multicast Routing Protocol (DVMRP) <ref> [5] </ref> and the Protocol Independent Multicast-Dense Mode (PIM-DM) protocol [4], form a source-based tree from each sender and require that each router maintain information for each source in a multicast group.
Reference: [6] <author> S.E. Deering, D. Estrin, D. Farinacci, V. Jacobson, C. Liu, and L. Wei. </author> <title> An Arcitecture for Wide-Area Multicast Routing. </title> <booktitle> In Proc.of the ACM SIGCOMM94, </booktitle> <pages> pages 126-135, </pages> <address> London, UK, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Other protocols assume a different approach in forming the tree. In both the Core Based Tree (CBT) multicast protocol [2] and in the Protocol Independent Multicast-Sparse Mode (PIM-SM) protocol [7] <ref> [6] </ref>, a single shared tree is created for distribution of data from all senders to all receivers in the group. In each of these receiver-initiated protocols, a well known router exists that accepts connection requests from other routers.
Reference: [7] <author> D. Estrin, D. Farinacci, A. Helmy, D. Thaler, S. Deering, M. Handley, V. Jacobson, C. Liu, P. Sharma, and L. Wei. </author> <title> Protocol Independent Multicast-Sparse Mode (PIM-SM):Protocol Specification. </title> <type> Internet draft, </type> <month> September </month> <year> 1997. </year> <title> Work in progress. </title>
Reference-contexts: Within a large network with a multicast group containing many sources, the overhead required at on-tree routers can be excessive. Other protocols assume a different approach in forming the tree. In both the Core Based Tree (CBT) multicast protocol [2] and in the Protocol Independent Multicast-Sparse Mode (PIM-SM) protocol <ref> [7] </ref> [6], a single shared tree is created for distribution of data from all senders to all receivers in the group. In each of these receiver-initiated protocols, a well known router exists that accepts connection requests from other routers.
Reference: [8] <author> J.J. Garcia-Luna-Aceves. </author> <title> Loop-Free Routing Using Diffusing Computations. </title> <journal> IEEE/ACM Trans. Networking, </journal> <volume> 1(1) </volume> <pages> 130-141, </pages> <month> February 1193. </month>
Reference-contexts: The proof that the diffusing computation upon which the election is based returns the correct list of cores within the partition is essentially equivalent to the correctness proof in <ref> [8] </ref>; it is clear that given the same list of n-level cores in the partition, all select the same highest addressed core to promote. Once this core has been promoted to level n + 1, the other cores join with it forming a tree. The logical ordering is again correct.
Reference: [9] <author> C. Shields and J.J. Garcia-Luna-Aceves. </author> <title> The Ordered Core Based Tree Protocol. </title> <booktitle> In Proceedings of the IEEE INFOCOM97, </booktitle> <address> Kobe, Japan, </address> <month> April </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: Secondary cores remain disconnected from the primary core until they are required to join the multicast group, at which point they join the primary core in the same manner as an individual receiver. While the logic behind using multiple cores was sound, the implementation was not. We have shown <ref> [9] </ref> that during times of underlying unicast instability, the multiple-core versions of CBT can form loops. <p> This situation gets worse as more traffic finds its way into the loop, because more and more packet duplications occur, creating congestion. Besides the looping problem, we also show that CBT with multiple cores might not always form a multicast tree <ref> [9] </ref>. As a result of these findings, CBT has returned to the single-core model [1], which ensures loop freedom but retains the original limitations of a single-core model. <p> In contrast, multiple-core versions of CBT allow the formation of loops <ref> [9] </ref>. Join-requests in OCBT carry a field containing the level a node must have to safely acknowledge the request. If a node receives a join-request carrying a level higher than its level, it quits from its parent and joins the branch that the join-request is forming.

References-found: 9

