URL: http://www.cs.umn.edu/crisys/Publications/thesis.ps
Refering-URL: http://www.cs.umn.edu/crisys/pubs.htm
Root-URL: http://www.cs.umn.edu
Title: Static Analysis of State-based Requirements Analysis for Completeness and Consistency  
Author: Mats Per Erik Heimdahl Professor Nancy G. Leveson, Chair Professor Debra J. Richardson Professor Richard N. Taylor 
Degree: A dissertation submitted in partial satisfaction of the requirements for the degree Doctor of Philosophy in Information and Computer Science by  Committee in charge:  
Date: 1994  
Affiliation: UNIVERSITY OF CALIFORNIA Irvine  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Aho, Hopcroft, and Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: Some of the algorithms require manipulation of rather large boolean functions, representing the guarding conditions on the transitions. Unfortunately, the manipulation of boolean functions is a known complex problem and a bottleneck when implementing automated analysis procedures <ref> [1, 11] </ref>. The second section is dedicated to a discussion of one approach to represent and manipulate large boolean expressions. The core section of the chapter describes the different algorithms used to analyze a model expressed in RSML for internal 87 88 completeness.
Reference: [2] <author> J. Atlee and J. Gannon. </author> <title> State-based model checking of event-driven system requirements. </title> <booktitle> In Proceedings of the ACM SIGSOFT '91 Conference on Software for Critical Systems. Software Engineering Notes. </booktitle> <volume> Volume 16 Number 5, </volume> <year> 1991. </year>
Reference-contexts: A system modeled in any of these languages can be compiled to a CTL structure which can then be analyzed 17 using the automated model checker. A verifier written in C has been operational since 1982. The checker has been applied to several examples <ref> [13, 14, 2, 57] </ref> showing that the model checker can handle systems of moderate size. It is, however, clear that the model checker cannot deal with a state space of a size greater than 10 6 states. <p> This restriction makes it impossible to express certain properties described by more complex temporal operators, causing problems even in small systems. For example, a manual procedure for translating a SCR-like system requirements specification [25] into a CTL structure was developed by Joanne Atlee and John Gannon <ref> [2] </ref> showing the applicability of model checking as a tool for analysis of high level requirements specifications. However, some desirable safety properties of the system could not be expressed as CTL formulas. Much weaker invariants than intended had to suffice in the verification process.
Reference: [3] <author> George S. Avrunin, Ugo A. Buy, and James A. Corbett. </author> <title> Interger programming in the analysis of concurrent systems. </title> <booktitle> In Proceedings of the Third Workshop on Computer Aided Verification, </booktitle> <year> 1991. </year>
Reference-contexts: Cycles in the FSAs are also ignored. These inaccuracies are, however, conservative and will not cause solutions to an inconsistent system to be generated. The generation of the equations from an FSM is best illustrated with an example from <ref> [3] </ref>. channel with infinite buffer capacity. +a represents the sending of a message to channel a and -a represents the removal of a message from channel a. <p> The "path" corresponding to this solution is obviously not feasible and would be rejected in the reachability analysis. It has been reported <ref> [3] </ref> that the result from the integer programming guides the reachability analysis very successfully, e.g., no backtracking was required when verifying a path leading to deadlock in the dining philosopher problem with 100 philosophers. However, the efficiency of this approach may not be as great as indicated by this example. <p> Alt-Layer s-30 Trigger Event: Surveillance-Complete-Event e-279 Condition: Own-Tracked-Alt f-248 Alt-Layer-Thr-Top <ref> [3] </ref> T Output Action: None equipped aircraft. Altitude layer gives a rough indication of the current altitude of the aircraft. The transitions (taken from the baselined TCAS requirements) defining when altitude layer 3 is exited can be seen in figures 7.10 and 7.11. <p> This transition defines when the model stays in Auto-SL state 1. Analyzed with all other transitions leading out of the state 1, the condition when 126 Transition (s): Layer-3 ! Layer-2 Location: Own-Aircraft . Alt-Layer s-30 Trigger Event: Surveillance-Complete-Event e-279 Condition: Own-Tracked-Alt f-248 Alt-Layer-Thr-Bot <ref> [3] </ref> T Output Action: None No transition out of Layer_3 is satisfied under Surveillance_Complete_Event if : F : Own_Tracked_Alt &lt;= Alt_Layer_Thr_Bot (3) F : Own_Tracked_Alt &gt;= Alt_Layer_Thr_Top (3) Transition (s): Layer-3 ! Layer-2 Location: Own-Aircraft . Alt-Layer s-30 Trigger Event: Surveillance-Complete-Event e-279 Condition: Own-Tracked-Alt f-248 &lt; Alt-Layer-Thr-Top [3] T Own-Tracked-Alt f-248 <p> Own-Tracked-Alt f-248 Alt-Layer-Thr-Bot <ref> [3] </ref> T Output Action: None No transition out of Layer_3 is satisfied under Surveillance_Complete_Event if : F : Own_Tracked_Alt &lt;= Alt_Layer_Thr_Bot (3) F : Own_Tracked_Alt &gt;= Alt_Layer_Thr_Top (3) Transition (s): Layer-3 ! Layer-2 Location: Own-Aircraft . Alt-Layer s-30 Trigger Event: Surveillance-Complete-Event e-279 Condition: Own-Tracked-Alt f-248 &lt; Alt-Layer-Thr-Top [3] T Own-Tracked-Alt f-248 &gt; Alt-Layer-Thr-Bot [3] T Output Action: None 127 Transition (s): ANY ! 1 Location: Own-Aircraft . <p> Alt-Layer s-30 Trigger Event: Surveillance-Complete-Event e-279 Condition: Own-Tracked-Alt f-248 &lt; Alt-Layer-Thr-Top <ref> [3] </ref> T Own-Tracked-Alt f-248 &gt; Alt-Layer-Thr-Bot [3] T Output Action: None 127 Transition (s): ANY ! 1 Location: Own-Aircraft .
Reference: [4] <author> George S. Avrunin, Ugo A. Buy, James A. Corbett, Laura K. Dillon, and Jack C. Wilden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <type> Technical Report 90-116, </type> <institution> Department of Mathematics and Statistics. University of Massachusetts Amherst, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: not have a compact BDD representation [11], and more work is clearly required to characterize the models for which the BDD-based model checker is efficient. 2.1.3 Constrained Expressions Instead of focusing on the reachability graph and determining if a certain state is reachable, the constrained expression approach by Avrunin et.al. <ref> [4, 5] </ref> focuses on the sequencing of events describing the externally visible behavior of a system. An execution of a system (concurrent or sequential) can be viewed as a sequence of events, i.e., a trace of the execution.
Reference: [5] <author> George S. Avrunin, Ugo A. Buy, James C. Corbett, Laura K. Dillon, and Jack C. Wielden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(11), </volume> <month> November </month> <year> 1991. </year>
Reference-contexts: not have a compact BDD representation [11], and more work is clearly required to characterize the models for which the BDD-based model checker is efficient. 2.1.3 Constrained Expressions Instead of focusing on the reachability graph and determining if a certain state is reachable, the constrained expression approach by Avrunin et.al. <ref> [4, 5] </ref> focuses on the sequencing of events describing the externally visible behavior of a system. An execution of a system (concurrent or sequential) can be viewed as a sequence of events, i.e., a trace of the execution.
Reference: [6] <author> H. Barringer, R. Kuiper, and A. Pnueli. </author> <title> Now you may compose temporal logic specifications. </title> <booktitle> In Proceedings of the ACM symposium on the Principles of Programming Languages, </booktitle> <year> 1984. </year>
Reference-contexts: The ultimate goal would be to analyze every individual component in isolation and 37 then recombine the individual results according to firm rules <ref> [6] </ref>. Unfortunately, applying this method most often requires significant human guidance. Nevertheless, dividing a model into several simpler models, known as parceling, seems to be a promising approach. Groundbreaking work with parceling has been performed by Young et.al. [56] where the applicability of parceling is shown for static concur-rency analysis.
Reference: [7] <author> B. W. Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Software requirements errors have been found to account for a majority of production software failures [8, 16] and have been implicated in a large number of accidents [34]. Errors introduced during the requirements phase are also more costly to correct than errors introduced later in the life cycle <ref> [7] </ref> and can have a major impact on safety. Therefore, techniques to provide adequate requirements specifications and to find errors early are of great importance. In critical systems, minor behavioral distinctions often have significant consequences.
Reference: [8] <author> B.W. Boehm. </author> <title> Verifying and Validating Software Requirements and Software Specifications. </title> <journal> IEEE Software, </journal> <volume> 1(1) </volume> <pages> 75-88, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: The very first stages of software development have the fewest formal procedures to aid the analyst, and this is also the time at which many problems are introduced. Software requirements errors have been found to account for a majority of production software failures <ref> [8, 16] </ref> and have been implicated in a large number of accidents [34]. Errors introduced during the requirements phase are also more costly to correct than errors introduced later in the life cycle [7] and can have a major impact on safety.
Reference: [9] <author> F. P. Brooks. </author> <title> The mythical man-month. </title> <journal> Datamation, </journal> <month> 20(12), December </month> <year> 1974. </year>
Reference-contexts: Introduction Computers are increasingly being used in critical applications (e.g., air-traffic control systems, missile systems, and medical care) and in other complex systems, such as advanced process control. Unfortunately, our ability to produce the complex software supporting these kinds of systems is limited <ref> [48, 9, 10, 34] </ref>. The very first stages of software development have the fewest formal procedures to aid the analyst, and this is also the time at which many problems are introduced.
Reference: [10] <author> F. P. Brooks. </author> <title> No silver bullet: </title> <journal> Essence and accidents of software engineering. Computer, </journal> <volume> 20(4), </volume> <month> April </month> <year> 1987. </year>
Reference-contexts: Introduction Computers are increasingly being used in critical applications (e.g., air-traffic control systems, missile systems, and medical care) and in other complex systems, such as advanced process control. Unfortunately, our ability to produce the complex software supporting these kinds of systems is limited <ref> [48, 9, 10, 34] </ref>. The very first stages of software development have the fewest formal procedures to aid the analyst, and this is also the time at which many problems are introduced.
Reference: [11] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> Transactions on Computers, </journal> <volume> C-35(8), </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: By representing the state space symbolically, this regularity can be exploited to produce a com-pacter representation. The structure used for the symbolic representation is BDD (Binary Decision Diagrams) <ref> [11] </ref>. The basic steps behind symbolic model checking can be described as: 1. Represent all boolean functions labeling the states as binary decision dia grams, which are a canonical representation of boolean formulas. 2. <p> If the transition relation satisfies the specification, the result after composition should be the BDD representation of the constant true. For a more detailed description of the use of BDDs in symbolic model checking, the reader is referred to <ref> [11, 12] </ref>. In [12], a model checking algorithm using BDDs to represent relations and formulas is described. <p> It has been shown that there are structures that do not have a compact BDD representation <ref> [11] </ref>, and more work is clearly required to characterize the models for which the BDD-based model checker is efficient. 2.1.3 Constrained Expressions Instead of focusing on the reachability graph and determining if a certain state is reachable, the constrained expression approach by Avrunin et.al. [4, 5] focuses on the sequencing of <p> Some of the algorithms require manipulation of rather large boolean functions, representing the guarding conditions on the transitions. Unfortunately, the manipulation of boolean functions is a known complex problem and a bottleneck when implementing automated analysis procedures <ref> [1, 11] </ref>. The second section is dedicated to a discussion of one approach to represent and manipulate large boolean expressions. The core section of the chapter describes the different algorithms used to analyze a model expressed in RSML for internal 87 88 completeness. <p> The cost of performing these operations is known to be exponential (worst case) in the number of predicates included in the guarding conditions [32]. In the implementation of the algorithms in this chapter, Binary Decision Diagrams <ref> [11] </ref> have been used to represent and manipulate the conditions. <p> A link to the right represents TRUE and to the left FALSE. Figure 6.1 shows the BDD representation of the boolean function (x 1 ^ x 2 ) _ (x 3 ^ x 4 ) The interested reader is referred to <ref> [11] </ref> for more information about the details of binary decision diagrams. One of the more important decisions when building a BDD is an encoding of the decision variables used in the boolean function represented by the BDD.
Reference: [12] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1990. </year> <pages> 135 136 </pages>
Reference-contexts: Another, more promising, approach is symbolic model checking <ref> [12] </ref>. The idea behind the symbolic approach is to represent the state space symbolically, instead of explicitly generating the entire state space. It is argued that the intuitive "complexity" of a system is often much less than the number of states a FSM representation would indicate. <p> If the transition relation satisfies the specification, the result after composition should be the BDD representation of the constant true. For a more detailed description of the use of BDDs in symbolic model checking, the reader is referred to <ref> [11, 12] </ref>. In [12], a model checking algorithm using BDDs to represent relations and formulas is described. <p> If the transition relation satisfies the specification, the result after composition should be the BDD representation of the constant true. For a more detailed description of the use of BDDs in symbolic model checking, the reader is referred to [11, 12]. In <ref> [12] </ref>, a model checking algorithm using BDDs to represent relations and formulas is described.
Reference: [13] <author> E. M. Clarke, M. C. Browne, E. A. Emerson, and A. P. Sistla. </author> <title> Using temporal logic for automatic verification of finite state systems. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 3-26. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: However, verification techniques for temporal logics require manual construction of the proofs and, thus, are incredibly tedious and error prone to construct. To overcome the problems with manual proofs, Model Checking was developed by Ed Clarke et.al. <ref> [13] </ref>. The Approach The main idea behind model checking is to model a system as a finite state system and view the transition graph as a labeled state-transition graph (called a Kripke structure) and apply an efficient algorithm to determine if the structure is a model of a particular formula. <p> The semantics of CTL formulas are defined with respect to a labeled state-transition graph (or a CTL structure) <ref> [13, 14] </ref>. Formally a CTL structure is a 3-tuple M = (S, R, P) where S is a finite set of states. R is a binary relation on S (R S fi S) which gives the possible transitions between states. <p> The formal semantic of CTL is not included here, but a complete description can be found in <ref> [13, 14] </ref>. The Model Checker When a system has been modeled as a CTL structure, it is possible to check if a specific formula f , expressed in CTL, is satisfied in the model. <p> The Model Checker When a system has been modeled as a CTL structure, it is possible to check if a specific formula f , expressed in CTL, is satisfied in the model. An algorithm presented in <ref> [13] </ref> runs in time O (length (f ) (card (S) + card (R)) 2 ). An improved version linear in the size of the CTL structure, i.e., O (length (f ) (card (S) + card (R))) is presented in [14]. <p> A system modeled in any of these languages can be compiled to a CTL structure which can then be analyzed 17 using the automated model checker. A verifier written in C has been operational since 1982. The checker has been applied to several examples <ref> [13, 14, 2, 57] </ref> showing that the model checker can handle systems of moderate size. It is, however, clear that the model checker cannot deal with a state space of a size greater than 10 6 states. <p> However, some desirable safety properties of the system could not be expressed as CTL formulas. Much weaker invariants than intended had to suffice in the verification process. The large size of a CTL structure is also a major limitation. The experience from <ref> [13, 14] </ref> indicates that the basic model checking algorithm developed can 18 handle a CTL structure with somewhere between 10 3 to 10 6 states.
Reference: [14] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The semantics of CTL formulas are defined with respect to a labeled state-transition graph (or a CTL structure) <ref> [13, 14] </ref>. Formally a CTL structure is a 3-tuple M = (S, R, P) where S is a finite set of states. R is a binary relation on S (R S fi S) which gives the possible transitions between states. <p> The formal semantic of CTL is not included here, but a complete description can be found in <ref> [13, 14] </ref>. The Model Checker When a system has been modeled as a CTL structure, it is possible to check if a specific formula f , expressed in CTL, is satisfied in the model. <p> An algorithm presented in [13] runs in time O (length (f ) (card (S) + card (R)) 2 ). An improved version linear in the size of the CTL structure, i.e., O (length (f ) (card (S) + card (R))) is presented in <ref> [14] </ref>. Assume a structure is to be checked to see if formula f holds in it. Let i be the length of f . <p> A system modeled in any of these languages can be compiled to a CTL structure which can then be analyzed 17 using the automated model checker. A verifier written in C has been operational since 1982. The checker has been applied to several examples <ref> [13, 14, 2, 57] </ref> showing that the model checker can handle systems of moderate size. It is, however, clear that the model checker cannot deal with a state space of a size greater than 10 6 states. <p> However, some desirable safety properties of the system could not be expressed as CTL formulas. Much weaker invariants than intended had to suffice in the verification process. The large size of a CTL structure is also a major limitation. The experience from <ref> [13, 14] </ref> indicates that the basic model checking algorithm developed can 18 handle a CTL structure with somewhere between 10 3 to 10 6 states.
Reference: [15] <author> E.M. Clarke, O. Grumberg, and M.C. Browne. </author> <title> Reasoning about Networks with Many Identical Finite-State Processes. </title> <booktitle> In Proceedings of Principles of Distributed Computation, </booktitle> <pages> pages 240-248, </pages> <year> 1986. </year>
Reference-contexts: Several methods to overcome this problem have been suggested by Clarke et.al., all involving the utilization of the fact that in many applications there are many identical processes contributing to the state explosion. In <ref> [15] </ref>, a theory for reasoning about systems of this type is developed. The basic idea is that if a system with a few processes can be analyzed for a property, conclusions about how that system will work with many processes can be drawn.
Reference: [16] <author> A. Endres. </author> <title> An analysis of errors and their causes in system programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1(6):140-149, </volume> <month> June </month> <year> 1975. </year>
Reference-contexts: The very first stages of software development have the fewest formal procedures to aid the analyst, and this is also the time at which many problems are introduced. Software requirements errors have been found to account for a majority of production software failures <ref> [8, 16] </ref> and have been implicated in a large number of accidents [34]. Errors introduced during the requirements phase are also more costly to correct than errors introduced later in the life cycle [7] and can have a major impact on safety.
Reference: [17] <author> P. Godefroid. </author> <title> Using partial orders to improve automatic verification methods. </title> <booktitle> In Proceedings of te 2nd International Conference on Computer-Aided Verification, </booktitle> <year> 1990. </year>
Reference-contexts: States can be reachable by several different paths in the graph. By reducing the number of transitions in a reachability graph without limiting the power of the analysis. Sleep sets were introduced by Godefroid <ref> [17, 18] </ref> and it was shown that most state space exploration due to the modeling of concurrency as interleaving can be avoided. The basic idea is to describe the behavior of a system in terms of partial orders instead of sequences.
Reference: [18] <author> Patrice Godefroid, Gerhard J. Holzmann, and Dieder Pirottin. </author> <title> State space caching revisited. </title> <booktitle> In Proceedings of the Fourth Workshop on Computer-Aided Verification, </booktitle> <year> 1992. </year>
Reference-contexts: Due to efficiency reasons, it is highly desirable to store visited states in the fast main memory of the computer where the algorithm is executed. Typically, it only takes a few minutes to fill up the main memory on a classical computer. The state space caching approach by Holzmann <ref> [28, 29, 30, 27, 18] </ref> addresses this problem and makes efficient exploration of fairly large state machines possible. 10 The Approach During an exploration of a state space, once states have been visited they are stored to avoid redundant work. <p> It has been shown that with state space caching the number of stored states can be reduced to about one half to one third of the full state space without significantly affecting run time <ref> [18] </ref>. An important factor when replacing a state in the cache is determining which state to replace. Holzmann has investigated several different replacement schemes [29]. <p> This result is mostly due to the overhead cost associated with complex schemes and partly to the low correlation between the selection criteria (such as age of a state in the cache) and the probability of encountering the state again. In a recent paper <ref> [18] </ref>, replacement schemes based on a typing of nodes are investigated. It was found that nodes representing, for example, the target of a goto jump or the beginning of a control loop, were much more likely to reoccur in the search and therefore desirable in the cache. <p> States can be reachable by several different paths in the graph. By reducing the number of transitions in a reachability graph without limiting the power of the analysis. Sleep sets were introduced by Godefroid <ref> [17, 18] </ref> and it was shown that most state space exploration due to the modeling of concurrency as interleaving can be avoided. The basic idea is to describe the behavior of a system in terms of partial orders instead of sequences.
Reference: [19] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: Chapter 3 A Functional Framework The RSML notation is in many ways similar to the Statecharts notation developed by David Harel <ref> [21, 19, 20] </ref>. The structure of the hierarchical state machines and the use of transitions are identical in the two languages. The main changes between RSML and Statecharts are syntactic and only effects the readability of the language. However, some small but significant semantic differences exist. <p> Thus, this formalism is not suitable for automated analysis of large specifications using the full power of the RSML notation. 40 41 The model defined in this chapter is influenced by David Harel's work on Statecharts and Hi-Graphs <ref> [21, 19, 20] </ref>. The definition of the structure of the state-space is identical to the definitions provided in [20, 49]. However, the definition of the dynamic behavior provided in this dissertation is significantly different that any previous approach. <p> The structure of the state values in RSML is identical to the one defined for M . The simple functions in f are in RSML represented as by state transitions and the compositions are defined by the structure of the state-space and a mechanism known as event propagation <ref> [37, 19] </ref>. This formalization of the RSML semantics introduces compositionality in the language and allows for analysis of many interesting properties directly in the high level RSML notation. Thus, this formalization provides the foundation for efficient static analysis of RSML requirements specifications. <p> There are several additional features of the graphical language available, but they will not be described here. The interested reader is referred to appendix A and <ref> [19, 37] </ref> for additional information. 4.2 Computation of the Next State The previous section presented examples of how transitions in the graphical model are represented by basic functions.
Reference: [20] <author> D. Harel. </author> <title> On visual formalisms. </title> <journal> Communications of the ACM, </journal> <volume> 31(5) </volume> <pages> 514-530, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Chapter 3 A Functional Framework The RSML notation is in many ways similar to the Statecharts notation developed by David Harel <ref> [21, 19, 20] </ref>. The structure of the hierarchical state machines and the use of transitions are identical in the two languages. The main changes between RSML and Statecharts are syntactic and only effects the readability of the language. However, some small but significant semantic differences exist. <p> Thus, this formalism is not suitable for automated analysis of large specifications using the full power of the RSML notation. 40 41 The model defined in this chapter is influenced by David Harel's work on Statecharts and Hi-Graphs <ref> [21, 19, 20] </ref>. The definition of the structure of the state-space is identical to the definitions provided in [20, 49]. However, the definition of the dynamic behavior provided in this dissertation is significantly different that any previous approach. <p> The definition of the structure of the state-space is identical to the definitions provided in <ref> [20, 49] </ref>. However, the definition of the dynamic behavior provided in this dissertation is significantly different that any previous approach. An RSML specification is here viewed as a collection of rather simple mathematical functions mapping one system state to the next.
Reference: [21] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive systems. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 477-498. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Chapter 3 A Functional Framework The RSML notation is in many ways similar to the Statecharts notation developed by David Harel <ref> [21, 19, 20] </ref>. The structure of the hierarchical state machines and the use of transitions are identical in the two languages. The main changes between RSML and Statecharts are syntactic and only effects the readability of the language. However, some small but significant semantic differences exist. <p> Thus, this formalism is not suitable for automated analysis of large specifications using the full power of the RSML notation. 40 41 The model defined in this chapter is influenced by David Harel's work on Statecharts and Hi-Graphs <ref> [21, 19, 20] </ref>. The definition of the structure of the state-space is identical to the definitions provided in [20, 49]. However, the definition of the dynamic behavior provided in this dissertation is significantly different that any previous approach.
Reference: [22] <author> D. Harel, A. Pnueli, J.P. Schmidt, and R. Sherman. </author> <title> On the formal semantics of statecharts (extended abstract). </title> <booktitle> In 2nd Symposium on Logic in Computer Science, </booktitle> <pages> pages 54-64, </pages> <address> Ithaca, NY, </address> <year> 1987. </year>
Reference-contexts: Many of these definitions are derived from Harel <ref> [22] </ref> and Pnueli [49]. 3.2.1 Auxiliary Definitions Definition 3 The least common component (lcc) of the state values in the set X 2 2 S . lcc (X) = y is defined as: [ X fl (y) ] ^ [ 8s 2 S : (X fl (s)) ) (y 2 fl
Reference: [23] <author> Mats P. E. Heimdahl. </author> <title> Static Analysis of State Based Requirements: Analysis for Internal Completeness. </title> <type> PhD thesis, </type> <institution> University of California, Irvine, </institution> <year> 1994. </year>
Reference-contexts: The analysis has been developed as an 96 integral part of an interpreter for the RSML notation. The interpreter parses a textual representation of RSML and builds data structures suitable for analysis. For a more detailed description of the simulator and the simulation capabilities the reader is referred to <ref> [23] </ref>. The BNF defining the textual RSML notation can be found in appendix C. It should be noted that the algorithms presented in this section have been designed to maximize clarity.
Reference: [24] <author> David P. Helmbold and Charles E. McDowell. </author> <title> Computing reachable states of parallel programs. </title> <editor> In Barton P. Miller and Charles McDowell, editors, </editor> <booktitle> ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 76-84. </pages> <address> acmpress, </address> <month> May </month> <year> 1991. </year> <note> Appeared as ACM SIGPLAN Notices 26 (12). </note>
Reference-contexts: These two folding techniques are just examples; many additional foldings have been suggested in the literature <ref> [24, 53, 55] </ref>. Unfortunately, the applicability of a folding technique is analysis dependent, value folding may in some cases be used successfully (as in the example above) but, in other types of analysis, the information loss may be unacceptable.
Reference: [25] <author> K. L. Heninger. </author> <title> Specifying software for complex systems: New techniques and their application. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(1), </volume> <month> January </month> <year> 1980. </year> <month> 137 </month>
Reference-contexts: This restriction makes it impossible to express certain properties described by more complex temporal operators, causing problems even in small systems. For example, a manual procedure for translating a SCR-like system requirements specification <ref> [25] </ref> into a CTL structure was developed by Joanne Atlee and John Gannon [2] showing the applicability of model checking as a tool for analysis of high level requirements specifications. However, some desirable safety properties of the system could not be expressed as CTL formulas.
Reference: [26] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: In CSP <ref> [26] </ref>, a process state would represent a state value. Unfortunately, these analogies are not completely accurate.
Reference: [27] <author> G. J. Holzmann. </author> <title> Design and validation of computer protocols. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Due to efficiency reasons, it is highly desirable to store visited states in the fast main memory of the computer where the algorithm is executed. Typically, it only takes a few minutes to fill up the main memory on a classical computer. The state space caching approach by Holzmann <ref> [28, 29, 30, 27, 18] </ref> addresses this problem and makes efficient exploration of fairly large state machines possible. 10 The Approach During an exploration of a state space, once states have been visited they are stored to avoid redundant work. <p> Unfortunately, the number of reachable states is often very large and it is impossible to store all states in H. An exhaustive search of the state space can also be performed completely without H, a so-called stack-search <ref> [27] </ref>. This approach minimizes the memory requirements while still assuring a complete coverage of the state space. This strategy has successfully been implemented by Holzmann [28, 30]. <p> Limitations State space caching was developed to enable reachability analysis of finite state descriptions of telecommunication networks. State space caching is capable of reducing the memory requirements of reachability analysis by a factor of two to three. This has proven to be adequate in some applications <ref> [27] </ref> but is in most applications inadequate. The use of sleep sets decreases the memory requirements by another factor of 50-100 depending on the semantics of the system being modeled. <p> However, static analysis has been used successfully for certain real life applications where the state space has been of a moderate size <ref> [27, 41] </ref>. If static analysis is to be made feasible as an alternative or complement to walkthroughs of requirements documents and testing and walkthroughs of implementations, methods to effectively reduce the size of the state space have to be developed.
Reference: [28] <author> Gerhard J. Holzmann. </author> <title> The Pandora system: An interactive system for the design of data communication protocols. </title> <journal> Computer Networks, </journal> <volume> 8(2), </volume> <year> 1984. </year>
Reference-contexts: Due to efficiency reasons, it is highly desirable to store visited states in the fast main memory of the computer where the algorithm is executed. Typically, it only takes a few minutes to fill up the main memory on a classical computer. The state space caching approach by Holzmann <ref> [28, 29, 30, 27, 18] </ref> addresses this problem and makes efficient exploration of fairly large state machines possible. 10 The Approach During an exploration of a state space, once states have been visited they are stored to avoid redundant work. <p> An exhaustive search of the state space can also be performed completely without H, a so-called stack-search [27]. This approach minimizes the memory requirements while still assuring a complete coverage of the state space. This strategy has successfully been implemented by Holzmann <ref> [28, 30] </ref>. The problem with a stack-search is that if the search path joins a previously explored path in a state that is no longer on the stack, redundant exploration of previously visited states will be performed.
Reference: [29] <author> Gerhard J. Holzmann. </author> <title> Tracing protocols. </title> <journal> AT& T Technical Journal, </journal> <volume> 64(10), </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: Due to efficiency reasons, it is highly desirable to store visited states in the fast main memory of the computer where the algorithm is executed. Typically, it only takes a few minutes to fill up the main memory on a classical computer. The state space caching approach by Holzmann <ref> [28, 29, 30, 27, 18] </ref> addresses this problem and makes efficient exploration of fairly large state machines possible. 10 The Approach During an exploration of a state space, once states have been visited they are stored to avoid redundant work. <p> An important factor when replacing a state in the cache is determining which state to replace. Holzmann has investigated several different replacement schemes <ref> [29] </ref>. Surprisingly, he has shown that a simple random replacement of the states in the cache gave better performance than other, more elaborate, schemes, e.g., oldest in cache, most visited, and least visited.
Reference: [30] <author> Gerhard J. Holzmann. </author> <title> Automated protocol validation in Argos: Assertion proving and scatter searching. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(6), </volume> <month> June </month> <year> 1987. </year>
Reference-contexts: Due to efficiency reasons, it is highly desirable to store visited states in the fast main memory of the computer where the algorithm is executed. Typically, it only takes a few minutes to fill up the main memory on a classical computer. The state space caching approach by Holzmann <ref> [28, 29, 30, 27, 18] </ref> addresses this problem and makes efficient exploration of fairly large state machines possible. 10 The Approach During an exploration of a state space, once states have been visited they are stored to avoid redundant work. <p> An exhaustive search of the state space can also be performed completely without H, a so-called stack-search [27]. This approach minimizes the memory requirements while still assuring a complete coverage of the state space. This strategy has successfully been implemented by Holzmann <ref> [28, 30] </ref>. The problem with a stack-search is that if the search path joins a previously explored path in a state that is no longer on the stack, redundant exploration of previously visited states will be performed.
Reference: [31] <author> J. J. M. Hooman, S. Ramesh, and W. P. de Roever. </author> <title> A compositional axiomatisation of Statecharts. </title> <year> 1991. </year>
Reference-contexts: Unfortunately, an operational definition of the semantics is rather incomplete and does not allow for formal analysis for many interesting properties, e.g., completeness and consistency. An axiomatic definition of the semantics of Statecharts enabling analysis for safety and liveness properties has been developed <ref> [31] </ref>. However, the definition is not complete (e.g., the use of guarding conditions on the transitions is not considered) nor intended for formal proofs.
Reference: [32] <author> Hopcroft and Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The cost of performing these operations is known to be exponential (worst case) in the number of predicates included in the guarding conditions <ref> [32] </ref>. In the implementation of the algorithms in this chapter, Binary Decision Diagrams [11] have been used to represent and manipulate the conditions. <p> It is possible that an execution may terminate even with loops in the event propagation graph, but analyzing for termination under general conditions is known to intractable <ref> [32] </ref>. Restricting the model to acyclic event propagation does not seem to put undue restrictions on the expressiveness of the language. Freedom from Nondeterminism The notion of nondeterminism in section 6.3.2 can easily be modified to apply to the complete behavior of the model.
Reference: [33] <author> M. S. Jaffe, N. G. Leveson, M. P. E. Heimdahl, and B. Melhart. </author> <title> Software requirements analysis for real-time process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3), </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: In critical systems, minor behavioral distinctions often have significant consequences. It is therefore particularly important that the requirements specification distinguish the behavior of the desired software from that of any other, undesired program that might be designed <ref> [33] </ref>; that is, the software must be both precise 1 2 (unambiguous), complete (no missing requirements), consistent (no conflicting requirements), and correct with respect to the encompassing system requirements. The work described in this dissertation addresses some of these properties. <p> Requirements for critical systems must be both consistent and complete in order to be specified in sufficient detail to be adequate as a base for system development <ref> [33] </ref>. It has been shown empirically that requirements inconsistencies and incompleteness cause a significant number of safety related problems in critical systems [44]. 3 Requirements completeness requires the behavior of a system to be defined under all possible conditions. <p> In many types of analysis the ordering of actions in the system is important (or of unknown importance and therefore considered important) <ref> [33] </ref> leading to a high dependency of the actions in the system and a more limited efficiency of the sleep sets approach. <p> In some applications this is not a problem, but in many systems the invariants often involve sequences of events <ref> [33] </ref>. The integer programming package used in the constrained expression approach in many cases produces a large number of invalid solutions that have to be checked by guided reachability analysis. <p> could be very costly to find traces satisfying the integer solution. 25 2.1.4 Safety Analysis The serious safety implications arising from the increased use of computer as controllers or monitors of safety critical systems was identified by Leveson in 1980 [39] and has since been discussed in numerous papers, e.g., <ref> [39, 34, 33, 42] </ref>. The properties interesting in safety analysis are often fundamentally different from the properties in other types of analysis. <p> Thus, a mathematical function is both complete and consistent. Functions are also deterministic, a desirable property in requirements for many types of systems, e.g., critical systems <ref> [33] </ref>. The simple formalism defined in this chapter has few of the desirable characteristics of a requirements specification language. However, the formalism can be used to define the semantics of higher level languages suitable as a modeling languages for complex systems.
Reference: [34] <author> N. G. Leveson. </author> <title> Software safety: What, why, and how. </title> <journal> ACM Computing surveys, </journal> <volume> 18(2), </volume> <month> June </month> <year> 1986. </year>
Reference-contexts: Introduction Computers are increasingly being used in critical applications (e.g., air-traffic control systems, missile systems, and medical care) and in other complex systems, such as advanced process control. Unfortunately, our ability to produce the complex software supporting these kinds of systems is limited <ref> [48, 9, 10, 34] </ref>. The very first stages of software development have the fewest formal procedures to aid the analyst, and this is also the time at which many problems are introduced. <p> Software requirements errors have been found to account for a majority of production software failures [8, 16] and have been implicated in a large number of accidents <ref> [34] </ref>. Errors introduced during the requirements phase are also more costly to correct than errors introduced later in the life cycle [7] and can have a major impact on safety. Therefore, techniques to provide adequate requirements specifications and to find errors early are of great importance. <p> could be very costly to find traces satisfying the integer solution. 25 2.1.4 Safety Analysis The serious safety implications arising from the increased use of computer as controllers or monitors of safety critical systems was identified by Leveson in 1980 [39] and has since been discussed in numerous papers, e.g., <ref> [39, 34, 33, 42] </ref>. The properties interesting in safety analysis are often fundamentally different from the properties in other types of analysis.
Reference: [35] <author> N. G. Leveson, M. Heimdahl, H. Hildreth, and J. Reese. </author> <title> TCAS II requirements specification. </title>
Reference-contexts: The work described in this dissertation addresses some of these properties. A graphical requirements language, known as RSML (Requirements State Machine Language), suitable for critical systems has been developed by the Irvine Safety Research Group under the leadership of Dr. Nancy G. Leveson <ref> [36, 37, 35] </ref>. This dissertation contains: a formal definition of a graphical requirements language suitable for critical systems, definitions of consistency and completeness criteria for the language, and automated analysis procedures for completeness and consistency. <p> In statecharts, on the other hand, the guarding conditions can be extremely complex <ref> [35] </ref> and the cost of calculating 30 P red and Succ could be prohibitively expensive. It is not clear how this added complexity affects the algorithm since no experimental or theoretical evaluation of the efficiency has been done. <p> The model could be viewed as nondeterministic and F considered to be a nondeterministic relation. However, there does not seem to be a need for nondeterministic behavior of M . Experience from the TCAS project have not exposed any instances where nondeterminism has been desirable <ref> [37, 35] </ref> 5 . 5 It is also clear that it is much easier to validate that a specific deterministic behavior is acceptable than to show that all possible nondeterministic behaviors are acceptable. 51 To illustrate the equivalence between this description and algebra, 6 a simple function suffices.
Reference: [36] <author> N. G. Leveson, M. Heimdahl, H. Hildreth, J. Reese, and R. Ortega. </author> <title> Experiences using statecharts for a system requirements specification. </title> <booktitle> In Proceedings of the Sixth International Workshop on Software Specification and Design, </booktitle> <year> 1991. </year>
Reference-contexts: The work described in this dissertation addresses some of these properties. A graphical requirements language, known as RSML (Requirements State Machine Language), suitable for critical systems has been developed by the Irvine Safety Research Group under the leadership of Dr. Nancy G. Leveson <ref> [36, 37, 35] </ref>. This dissertation contains: a formal definition of a graphical requirements language suitable for critical systems, definitions of consistency and completeness criteria for the language, and automated analysis procedures for completeness and consistency.
Reference: [37] <author> N. G. Leveson, M.P.E. Heimdahl, H. Hildreth, and J.D. Reese. </author> <title> Requirements specification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <note> (To Appear), </note> <year> 1994. </year>
Reference-contexts: The work described in this dissertation addresses some of these properties. A graphical requirements language, known as RSML (Requirements State Machine Language), suitable for critical systems has been developed by the Irvine Safety Research Group under the leadership of Dr. Nancy G. Leveson <ref> [36, 37, 35] </ref>. This dissertation contains: a formal definition of a graphical requirements language suitable for critical systems, definitions of consistency and completeness criteria for the language, and automated analysis procedures for completeness and consistency. <p> In other applications, such as requirements specifications, these properties are seldom present <ref> [37] </ref>. The effectiveness of the methods is, if the finite state representation is lacking desirable properties, not as impressive and in most practical instances not adequate. <p> The model could be viewed as nondeterministic and F considered to be a nondeterministic relation. However, there does not seem to be a need for nondeterministic behavior of M . Experience from the TCAS project have not exposed any instances where nondeterminism has been desirable <ref> [37, 35] </ref> 5 . 5 It is also clear that it is much easier to validate that a specific deterministic behavior is acceptable than to show that all possible nondeterministic behaviors are acceptable. 51 To illustrate the equivalence between this description and algebra, 6 a simple function suffices. <p> The structure of the state values in RSML is identical to the one defined for M . The simple functions in f are in RSML represented as by state transitions and the compositions are defined by the structure of the state-space and a mechanism known as event propagation <ref> [37, 19] </ref>. This formalization of the RSML semantics introduces compositionality in the language and allows for analysis of many interesting properties directly in the high level RSML notation. Thus, this formalization provides the foundation for efficient static analysis of RSML requirements specifications. <p> There are several additional features of the graphical language available, but they will not be described here. The interested reader is referred to appendix A and <ref> [19, 37] </ref> for additional information. 4.2 Computation of the Next State The previous section presented examples of how transitions in the graphical model are represented by basic functions. <p> The restrictions are artifacts of the graphical model and are introduced with the sole purpose of making the semantics of the graphical representation more intuitive. For a more detailed description of the reasons behind the semantic choices in RSML the reader is referred to <ref> [37] </ref>. 4.2.1 Function Composition and Event Propagation. more transitions between state values. The initial state is indicated by the small 62 D G I C output-2 output-1 input-2 input-1 A b d e arrows without a source, i.e., c 0 = fA; D; Bg.
Reference: [38] <author> N. G. Leveson and J. L. Stolzy. </author> <title> Safety analysis using Petri nets. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(3), </volume> <month> March </month> <year> 1987. </year>
Reference-contexts: An algorithm determining whether a set of markings of a Petri-net considered to be unsafe are possible to achieve has been developed by Leveson and Stolzy <ref> [38] </ref> and has been modified to apply to Statecharts by Melhart and Leveson [47, 46]. The Approach The first step in any safety analysis is to identify and classify the possible hazards in the system. <p> For the purposes of the following discussion, we assume that the state space is divided into only two sets containing low-risk and high-risk states. The goal of the safety analysis suggested in <ref> [38, 47] </ref> 3 Typically, preliminary hazard analysis, failure modes and effects analysis, and fault tree analysis 26 is to show that no high-risk states are reachable, i.e., that the system always will be in an acceptable low-risk state. <p> The algorithm is described in detail in figure 2.3. When a critical state is identified, it necessary to modify the model in some way to ensure that the path to the high-risk state is eliminated. There are many different ways of modifying a model. Some methods are discussed in <ref> [38] </ref>, e.g., the use of interlocks, locking places, and watchdog timers. The algorithm described in figure 2.3 is a basic version not containing several improvements suggested by Leveson [38]. As an example, consider the description of a high-risk state. <p> There are many different ways of modifying a model. Some methods are discussed in <ref> [38] </ref>, e.g., the use of interlocks, locking places, and watchdog timers. The algorithm described in figure 2.3 is a basic version not containing several improvements suggested by Leveson [38]. As an example, consider the description of a high-risk state.
Reference: [39] <author> N.G. Leveson and P.R. Harvey. </author> <title> Analyzing Software Safety. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-9(5):569-579, </volume> <month> September </month> <year> 1983. </year>
Reference-contexts: traces and a more complex interaction, it seems that it could be very costly to find traces satisfying the integer solution. 25 2.1.4 Safety Analysis The serious safety implications arising from the increased use of computer as controllers or monitors of safety critical systems was identified by Leveson in 1980 <ref> [39] </ref> and has since been discussed in numerous papers, e.g., [39, 34, 33, 42]. The properties interesting in safety analysis are often fundamentally different from the properties in other types of analysis. <p> could be very costly to find traces satisfying the integer solution. 25 2.1.4 Safety Analysis The serious safety implications arising from the increased use of computer as controllers or monitors of safety critical systems was identified by Leveson in 1980 [39] and has since been discussed in numerous papers, e.g., <ref> [39, 34, 33, 42] </ref>. The properties interesting in safety analysis are often fundamentally different from the properties in other types of analysis.
Reference: [40] <author> D. L. Levine and R. N. Taylor. </author> <title> Metric-driven reengineering for static con-currency analysis. </title> <type> Technical Report XXX, </type> <institution> University of California, Irvine, Department of Information and Computer Science, </institution> <note> XX 1992. 138 </note>
Reference-contexts: Therefore, parceling criteria must be evaluated with respect to large realistic problems. There is a possibility that the only feasible way to enable efficient parceling is to structure the problems (e.g., a concurrent program or a requirements specification) with analyzability as one of the main design goals <ref> [40] </ref>.
Reference: [41] <author> David L. Levine and Richard N. Taylor. </author> <title> Lessons learned from an application of static concurrency analysis. </title> <type> UCI-ICS Technical Report TR-91-72, </type> <institution> Department of Information and Computer Science, University of California, </institution> <month> October </month> <year> 1991. </year> <note> Also published as Arcadia Technical Report UCI-91-16. </note>
Reference-contexts: However, static analysis has been used successfully for certain real life applications where the state space has been of a moderate size <ref> [27, 41] </ref>. If static analysis is to be made feasible as an alternative or complement to walkthroughs of requirements documents and testing and walkthroughs of implementations, methods to effectively reduce the size of the state space have to be developed.
Reference: [42] <author> B. Littlewood and L. Strigini. </author> <title> The risk of software. </title> <journal> Scientific American, </journal> <volume> (11), </volume> <month> November </month> <year> 1992. </year>
Reference-contexts: could be very costly to find traces satisfying the integer solution. 25 2.1.4 Safety Analysis The serious safety implications arising from the increased use of computer as controllers or monitors of safety critical systems was identified by Leveson in 1980 [39] and has since been discussed in numerous papers, e.g., <ref> [39, 34, 33, 42] </ref>. The properties interesting in safety analysis are often fundamentally different from the properties in other types of analysis.
Reference: [43] <author> D. L. Long and L. A. Clarke. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> In Proceedings of the 11th international conference on software engineering, </booktitle> <year> 1989. </year>
Reference-contexts: Many of these simplifications have the effect of folding the state space representing the model, i.e., the simplified model uses fewer states than the original model. Each state in the simplified model represents several states in the original model. For example, both Taylor [53] and Long and Clarke <ref> [43] </ref> abstract away much detail out of Ada task flowgraphs in order to enable static concurrency analysis. Static Concurrency Analysis Any Ada task can be described by a flowgraph fully capturing all aspects of the task execution. <p> A detailed description of analysis procedures applicable to flowgraphs like this can be found in <ref> [53, 43] </ref> and will not be further discussed here. The construction of the two flowgraphs in the example above shows how different types of folding can be applied to a problem and thus reduce the size 35 of the finite state structure that needs to be considered in analysis.
Reference: [44] <author> R. Lutz. </author> <title> Targeting safety-related errors during software requirements analysis. </title> <booktitle> In Proceedings of the First ACM SOGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <year> 1993. </year>
Reference-contexts: Requirements for critical systems must be both consistent and complete in order to be specified in sufficient detail to be adequate as a base for system development [33]. It has been shown empirically that requirements inconsistencies and incompleteness cause a significant number of safety related problems in critical systems <ref> [44] </ref>. 3 Requirements completeness requires the behavior of a system to be defined under all possible conditions. Requirements consistency requires deterministic requirements, i.e., one and only one behavior is allowed by the requirements.
Reference: [45] <author> S. W. Malasky. </author> <title> System Safety. </title> <publisher> Garland STPM Press, </publisher> <year> 1982. </year>
Reference-contexts: The Approach The first step in any safety analysis is to identify and classify the possible hazards in the system. This identification and classification can be accomplish using well-known methods, for example, preliminary hazard analysis (PHA) <ref> [50, 45] </ref>. After all identifiable hazards have been classified, the system state space can be divided into disjoint subsets of states with the same hazard classification, e.g., safe, low-risk, high-risk, and catastrophic.
Reference: [46] <author> B. E. Melhart. </author> <title> An external interaction model for specifying requirements of embedded software. </title> <type> Technical Report Draft, </type> <institution> Texas Christian University, </institution> <month> Jan </month> <year> 1991. </year>
Reference-contexts: An algorithm determining whether a set of markings of a Petri-net considered to be unsafe are possible to achieve has been developed by Leveson and Stolzy [38] and has been modified to apply to Statecharts by Melhart and Leveson <ref> [47, 46] </ref>. The Approach The first step in any safety analysis is to identify and classify the possible hazards in the system. This identification and classification can be accomplish using well-known methods, for example, preliminary hazard analysis (PHA) [50, 45].
Reference: [47] <author> B.E. Melhart. </author> <title> Specification and Analysis of the Requirements for Embedded Software with an External Interaction Model. </title> <type> PhD thesis, </type> <institution> University of California, Irvine, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: An algorithm determining whether a set of markings of a Petri-net considered to be unsafe are possible to achieve has been developed by Leveson and Stolzy [38] and has been modified to apply to Statecharts by Melhart and Leveson <ref> [47, 46] </ref>. The Approach The first step in any safety analysis is to identify and classify the possible hazards in the system. This identification and classification can be accomplish using well-known methods, for example, preliminary hazard analysis (PHA) [50, 45]. <p> For the purposes of the following discussion, we assume that the state space is divided into only two sets containing low-risk and high-risk states. The goal of the safety analysis suggested in <ref> [38, 47] </ref> 3 Typically, preliminary hazard analysis, failure modes and effects analysis, and fault tree analysis 26 is to show that no high-risk states are reachable, i.e., that the system always will be in an acceptable low-risk state.
Reference: [48] <author> D. L. Parnas. </author> <title> Software aspects of strategic defence systems. </title> <journal> American Scientist, </journal> <volume> 73, </volume> <month> Septembe-October </month> <year> 1985. </year>
Reference-contexts: Introduction Computers are increasingly being used in critical applications (e.g., air-traffic control systems, missile systems, and medical care) and in other complex systems, such as advanced process control. Unfortunately, our ability to produce the complex software supporting these kinds of systems is limited <ref> [48, 9, 10, 34] </ref>. The very first stages of software development have the fewest formal procedures to aid the analyst, and this is also the time at which many problems are introduced.
Reference: [49] <author> A. Pnueli and M. Shalev. </author> <title> What is in a step? In J. </title> <editor> Klop, J. Meijer, and J. Rutten, editors, J.W. De Baker, </editor> <booktitle> Liber Amicorum, </booktitle> <pages> pages 373-400. </pages> <address> CWI Amsterdam, </address> <year> 1989. </year>
Reference-contexts: The definition of the structure of the state-space is identical to the definitions provided in <ref> [20, 49] </ref>. However, the definition of the dynamic behavior provided in this dissertation is significantly different that any previous approach. An RSML specification is here viewed as a collection of rather simple mathematical functions mapping one system state to the next. <p> Many of these definitions are derived from Harel [22] and Pnueli <ref> [49] </ref>. 3.2.1 Auxiliary Definitions Definition 3 The least common component (lcc) of the state values in the set X 2 2 S . lcc (X) = y is defined as: [ X fl (y) ] ^ [ 8s 2 S : (X fl (s)) ) (y 2 fl (s)) ]; Informally, <p> F is evaluated every time a new element is added to V I . The evaluation of F is instantaneous, i.e., no external events can interfere with each other. This property is known as the synchrony hypothesis <ref> [49] </ref>. If there is a possibility of two external events occurring at the exactly same time, the behavior of F can either be considered to be nondeterministic (just pick one of the events) or the two events can be viewed as a third composite event and the exact behavior specified.
Reference: [50] <author> W. P. Rodgers. </author> <title> Introduction to System Safety Engineering. </title> <publisher> John Wiley and Sons, Inc., </publisher> <year> 1971. </year>
Reference-contexts: The Approach The first step in any safety analysis is to identify and classify the possible hazards in the system. This identification and classification can be accomplish using well-known methods, for example, preliminary hazard analysis (PHA) <ref> [50, 45] </ref>. After all identifiable hazards have been classified, the system state space can be divided into disjoint subsets of states with the same hazard classification, e.g., safe, low-risk, high-risk, and catastrophic.
Reference: [51] <author> A. P. Sistla and E. M. Clarke. </author> <title> The complexity of propositional linear temporal logics. </title> <journal> Journal of the ACM, </journal> <volume> 32(3) </volume> <pages> 733-749, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: The model checker is able to verify formulas expressed in a branching time temporal logic; it has been shown that verifying linear temporal logic properties has inherently high complexity <ref> [51] </ref>. The Specification Language and the Transition Graph The specification language used to express the formulas the modeled system is to be verified against is Computational Tree Logic (CTL). In the description below AP is the underlying set of axiomatic propositions from which a specification is constructed. 1.
Reference: [52] <author> B. Strustrup. </author> <title> The C++ Programming Language: Second Edition. </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: The data structures and the analysis algorithms are expressed in a C++ like syntax <ref> [52] </ref> 1 accompanied with an English description of the ideas behind the algorithms.
Reference: [53] <author> Richard N. Taylor. </author> <title> A general purpose algorithm for analyzing concurrent programs. </title> <journal> Communications of the ACM, </journal> <volume> 26(5), </volume> <month> May </month> <year> 1983. </year>
Reference-contexts: Many of these simplifications have the effect of folding the state space representing the model, i.e., the simplified model uses fewer states than the original model. Each state in the simplified model represents several states in the original model. For example, both Taylor <ref> [53] </ref> and Long and Clarke [43] abstract away much detail out of Ada task flowgraphs in order to enable static concurrency analysis. Static Concurrency Analysis Any Ada task can be described by a flowgraph fully capturing all aspects of the task execution. <p> A detailed description of analysis procedures applicable to flowgraphs like this can be found in <ref> [53, 43] </ref> and will not be further discussed here. The construction of the two flowgraphs in the example above shows how different types of folding can be applied to a problem and thus reduce the size 35 of the finite state structure that needs to be considered in analysis. <p> These two folding techniques are just examples; many additional foldings have been suggested in the literature <ref> [24, 53, 55] </ref>. Unfortunately, the applicability of a folding technique is analysis dependent, value folding may in some cases be used successfully (as in the example above) but, in other types of analysis, the information loss may be unacceptable. <p> Nevertheless, dividing a model into several simpler models, known as parceling, seems to be a promising approach. Groundbreaking work with parceling has been performed by Young et.al. [56] where the applicability of parceling is shown for static concur-rency analysis. The approach described in <ref> [53] </ref> based on biconnected components is an example of parceling. The organization of a large concurrent program is characterized by its task graph. The vertices of the graph are tasks and an edge in the graph represents direct synchronization between tasks. <p> Each biconnected component interacts with other components only through these articulation tasks. It has been shown that tasks comprising bicon-nected components may be analyzed in isolation if the structure of the articulation task is sufficiently simple. Sufficient conditions and procedures are defined in <ref> [53] </ref>. Unfortunately, in reality it is unusual to detect biconnected components in a large concurrent program. <p> The global system state is maintained using these state values 1 . The graphical representation of S = fA; B; C; D; E; F; G; H; Ig is shown in figure 3.1. 1 In concurrency analysis, <ref> [53, 56] </ref> a concurrency state is analogous to the global system state and the state of a concurrent task is represented by a state value. In CSP [26], a process state would represent a state value. Unfortunately, these analogies are not completely accurate.
Reference: [54] <author> W.E. Vesely, F.F. Goldberg, N.H. Roberts, and D.F. Haasl. </author> <title> Fault Tree Handbook. U.S. </title> <publisher> Nuclear Regulatory Commission, </publisher> <address> Washington, D.C., </address> <month> January </month> <year> 1981. </year> <month> NUREG-0492. </month>
Reference-contexts: Therefore, no experimental data is available to evaluate the efficiency of the approach. It is clear that the backwards approach is feasible only if one considers a relatively small number of high risk states, but this has been found to be adequate in practice <ref> [54] </ref>. However, intuitive properties of the basic algorithm suggest high efficiency. For example, it is adequate to search backwards to the first critical state. This limits the length of a worst case search path to the maximum length of a noncyclic path in the reachability graph.
Reference: [55] <author> Michal Young. </author> <title> How to leave out details: Error-preserving abstractions of state-space models. </title> <booktitle> In TAV 2, </booktitle> <year> 1988. </year> <month> 139 </month>
Reference-contexts: These two folding techniques are just examples; many additional foldings have been suggested in the literature <ref> [24, 53, 55] </ref>. Unfortunately, the applicability of a folding technique is analysis dependent, value folding may in some cases be used successfully (as in the example above) but, in other types of analysis, the information loss may be unacceptable. <p> The properties of a simplification maintaining desirable characteristics in the transformation from one representation of a model to another, simplified representation have been discussed in detail by Young <ref> [55] </ref>. Preserving properties Young defines a simplification to be falseness preserving with respect to a formula f if and only if, for all models M belonging to a class of models (e.g., finite state machines), if M does not satisfy f then (M ) also does not satisfy f . <p> Simplifying transformations of a class of models can be investigated and classified according to their preservation properties with respect to sets of formulas f , e.g., simplifications of finite state machines can be classified according to their preservation properties with respect to temporal logic formulas. In <ref> [55] </ref>, a set of criteria for falseness preserving abstractions with respect to temporal logic was developed.
Reference: [56] <author> Michal Young, Richard N. Taylor, Kari Forester, and Debra Brodbeck. </author> <title> Integrated concurrency analaysis in a software development environment. </title> <booktitle> In Proceedings of the 3rd International Workshop on Testing, Analysis, and Verification, </booktitle> <year> 1989. </year>
Reference-contexts: Unfortunately, applying this method most often requires significant human guidance. Nevertheless, dividing a model into several simpler models, known as parceling, seems to be a promising approach. Groundbreaking work with parceling has been performed by Young et.al. <ref> [56] </ref> where the applicability of parceling is shown for static concur-rency analysis. The approach described in [53] based on biconnected components is an example of parceling. The organization of a large concurrent program is characterized by its task graph. <p> The global system state is maintained using these state values 1 . The graphical representation of S = fA; B; C; D; E; F; G; H; Ig is shown in figure 3.1. 1 In concurrency analysis, <ref> [53, 56] </ref> a concurrency state is analogous to the global system state and the state of a concurrent task is represented by a state value. In CSP [26], a process state would represent a state value. Unfortunately, these analogies are not completely accurate.
Reference: [57] <author> Michal Young, Richard N. Taylor, David L. Levine, Kari Forester, and Debra Brodbeck. </author> <title> A concurrency analysis tool suite: Rationale, design, and preliminary experience. </title> <type> Technical Report TR-128-P, </type> <institution> Software Engineering Research Center, 1398 Computer Sciences, Purdue University, West Lafayette, </institution> <note> IN 47907-1398, </note> <month> October </month> <year> 1992. </year>
Reference-contexts: A system modeled in any of these languages can be compiled to a CTL structure which can then be analyzed 17 using the automated model checker. A verifier written in C has been operational since 1982. The checker has been applied to several examples <ref> [13, 14, 2, 57] </ref> showing that the model checker can handle systems of moderate size. It is, however, clear that the model checker cannot deal with a state space of a size greater than 10 6 states.
References-found: 57

