URL: http://cs.uni-bonn.de/~marek/publications/final.ps.Z
Refering-URL: http://cs.uni-bonn.de/~marek/index-en.html
Root-URL: http://cs.uni-bonn.de
Phone: 2  
Title: Randomized Efficient Algorithms for Compressed Strings: the Finger-Print Approach (Extended Abstract)  
Author: Leszek Gasieniec Marek Karpinski Wojciech Plandowski Wojciech Rytter 
Address: Im Stadtwald, Saarbrucken D-66123, Germany.  Bonn, D-53117, Bonn, Germany. 3 Instytut Informatyki, Uniwersytet Warszawski, Banacha 2, 02-097 Warszawa, Poland.  
Affiliation: 1 Max-Planck Institut fur Informatik,  Dept. of Computer Science, University of  
Abstract: Denote by LZ(w) the coded form of a string w produced by Lempel-Ziv encoding algorithm. We consider several classical algorithmic problems for texts in the compressed setting. The first of them is the equality-testing: given LZ(w) and integers i; j; k test the equality: w[i : : : i + k] = w[j : : : j + k]. We give a simple and efficient randomized algorithm for this problem using the finger-printing idea. The equality testing is reduced to the equivalence of certain context-free grammars generating single strings. The equality-testing is the bottleneck in other algorithms for compressed texts. We relate the time complexity of several classical problems for texts to the complexity Eq(n) of equality-testing. Assume n = jLZ(T )j, m = jLZ(P )j and U = jT j. Then we can compute the compressed representations of the sets of occurrences of P in T , periods of T , palindromes of T , and squares of T respectively in times O(n log 2 U Eq(m) + n 2 log U ), O(n log 2 U Eq(n) + n 2 log U ), O(n log 2 U Eq(n)+ n 2 log U ) and O(n 2 log 3 U Eq(n) +n 3 log 2 U ), where Eq(n) = O(n log log n). The randomization improves considerably upon the known deterministic algorithms ([7] and [8]). 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A.Amir, G. Benson and M. Farach, </author> <title> Let sleeping files lie: pattern-matching in Z compressed files, </title> <booktitle> in SODA'94. </booktitle>
Reference-contexts: Assume that is an underlying alphabet and let w be a string over . The factorization of w is given by a decomposition: w = c 1 f 1 c 2 : : : f k c k+1 , where c 1 = w <ref> [1] </ref> and for each 1 i k, c i 2 and f i is the longest prefix of f i c i+1 : : : f k c k+1 which appears in c 1 f 1 c 2 : : : f i1 c i . <p> After identifying each subword f i with its corresponding interval we obtain the following LZ encoding of the string: LZ (aababbabbababbabb#) = a <ref> [1; 1] </ref>b [1; 2]b [4; 6]a [2; 10]#. First we make the following modification of the LZ encoding, which allows to move all terminal symbols to the beginning of the code. The encoding starts from all terminal symbols from the word. <p> After identifying each subword f i with its corresponding interval we obtain the following LZ encoding of the string: LZ (aababbabbababbabb#) = a [1; 1]b <ref> [1; 2] </ref>b [4; 6]a [2; 10]#. First we make the following modification of the LZ encoding, which allows to move all terminal symbols to the beginning of the code. The encoding starts from all terminal symbols from the word.
Reference: 2. <author> A.Amir, G. Benson, </author> <title> Efficient two dimensional compressed matching, </title> <booktitle> Proc. of the 2nd IEEE Data Compression Conference 279-288 (1992) </booktitle>
Reference-contexts: 1 Introduction In the algorithmics of textual problems only recently the problems related to compressed objects were investigated ([1], <ref> [2] </ref>, [3] and [8]). A very natural way ? On leave from Institute of Informatics, Warsaw University, ul. Banacha 2, 02-097, Warszawa, Poland. WWW: http://zaa.mimuw.edu.pl/lechu/lechu.html, Email:leszek@mpi-sb.mpg.de ?? This research was partially supported by the DFG Grant KA 673/4-1, and by the ESPRIT BR Grant 7097 and the ECUS 030. <p> After identifying each subword f i with its corresponding interval we obtain the following LZ encoding of the string: LZ (aababbabbababbabb#) = a [1; 1]b <ref> [1; 2] </ref>b [4; 6]a [2; 10]#. First we make the following modification of the LZ encoding, which allows to move all terminal symbols to the beginning of the code. The encoding starts from all terminal symbols from the word. <p> After identifying each subword f i with its corresponding interval we obtain the following LZ encoding of the string: LZ (aababbabbababbabb#) = a [1; 1]b [1; 2]b [4; 6]a <ref> [2; 10] </ref>#. First we make the following modification of the LZ encoding, which allows to move all terminal symbols to the beginning of the code. The encoding starts from all terminal symbols from the word. <p> The symbols are assumed to stay at positions 1; 2 : : : of the word. Then each reference to a terminal symbol is replaced by an interval inside those positions. After this modification the LZ-code of the word in the Example is ab <ref> [2; 2] </ref>[1; 1][1; 1][1; 2][1; 1][4; 6][2; 2][2; 10]#: The Lempel-Ziv code defines a natural factorization of the encoded word into subwords which correspond to intervals in the code. The subwords are called factors.
Reference: 3. <author> A.Amir, G. Benson and M. Farach, </author> <title> Optimal two-dimensional compressed matching, </title> <booktitle> in ICALP'94 </booktitle>
Reference-contexts: 1 Introduction In the algorithmics of textual problems only recently the problems related to compressed objects were investigated ([1], [2], <ref> [3] </ref> and [8]). A very natural way ? On leave from Institute of Informatics, Warsaw University, ul. Banacha 2, 02-097, Warszawa, Poland. WWW: http://zaa.mimuw.edu.pl/lechu/lechu.html, Email:leszek@mpi-sb.mpg.de ?? This research was partially supported by the DFG Grant KA 673/4-1, and by the ESPRIT BR Grant 7097 and the ECUS 030.
Reference: 4. <author> A. Apostolico, D. Breslauer, Z. Galil, </author> <title> Optimal parallel algorithms for periods, palindromes and squares, </title> <booktitle> in ICALP'92, </booktitle> <pages> 296-307 </pages>
Reference-contexts: After identifying each subword f i with its corresponding interval we obtain the following LZ encoding of the string: LZ (aababbabbababbabb#) = a [1; 1]b [1; 2]b <ref> [4; 6] </ref>a [2; 10]#. First we make the following modification of the LZ encoding, which allows to move all terminal symbols to the beginning of the code. The encoding starts from all terminal symbols from the word. <p> Then we can compute in O ((n log U )Eq (m)) time the compressed representation of the set Periods (P ). The representation consists (in this case) of log U number of linear sets. Our algorithms for compressed palindromes and squares use ideas which apeared in <ref> [4] </ref>: palindromes are searched using periodicities implied by sequences of many palindromes which are close to each other and searching of squares is reduced to multiple application of pattern-matching. <p> The squares whose larger part is in C = T [a i1 + 1 : : : U ] can be processed in the same way. Similarly as in <ref> [4] </ref> we consider the sample v of size 2 k1 which is a suffix of B. Then s = uvw, for some u and w. An occurrence of the sample v is found in C by applying the pattern-matching algorithm. The size of s is the distance between two occurrences.
Reference: 5. <author> M. Farach and M. </author> <title> Thorup, String matching in Lempel-Ziv compressed strings, </title> <booktitle> in STOC'95, </booktitle> <pages> pp. 703-712. </pages>
Reference-contexts: The key concepts in our algorithms are finger-printing, periodicity and linearly-succinct representations of exponentially many periods. Due to space limitations we omit several technical proofs. 2 The Lempel-Ziv compression and LZ-factorization. We consider the same version of the LZ compression algorithm as one used in <ref> [5] </ref> (where it is called LZ1). Intuitively, LZ algorithm compresses the input word because it is able to discover some repeated subwords. We consider here the version of LZ algorithm without self-referencing but our algorithms can be extended to the general self-referential case.
Reference: 6. <author> R.M. Karp and M. Rabin, </author> <title> Efficient randomized pattern matching algorithms, </title> <journal> IBM Journal of Research and Dev. </journal> <volume> 31, </volume> <month> pp.249-260 </month> <year> (1987). </year>
Reference-contexts: After identifying each subword f i with its corresponding interval we obtain the following LZ encoding of the string: LZ (aababbabbababbabb#) = a [1; 1]b [1; 2]b <ref> [4; 6] </ref>a [2; 10]#. First we make the following modification of the LZ encoding, which allows to move all terminal symbols to the beginning of the code. The encoding starts from all terminal symbols from the word.
Reference: 7. <author> M. Karpinski, W. Plandowski and W. Rytter, </author> <title> The fully compressed string matching for Lempel-Ziv encoding. </title> <type> Technical Report, </type> <institution> Institute of Informatics, Bonn Univer sity (1995) </institution>
Reference: 8. <author> M. Karpinski, W. Rytter and A. Shinohara, </author> <title> Pattern-matching for strings with short description, in Combinatorial Pattern Matching, </title> <year> 1995 </year>
Reference-contexts: 1 Introduction In the algorithmics of textual problems only recently the problems related to compressed objects were investigated ([1], [2], [3] and <ref> [8] </ref>). A very natural way ? On leave from Institute of Informatics, Warsaw University, ul. Banacha 2, 02-097, Warszawa, Poland. WWW: http://zaa.mimuw.edu.pl/lechu/lechu.html, Email:leszek@mpi-sb.mpg.de ?? This research was partially supported by the DFG Grant KA 673/4-1, and by the ESPRIT BR Grant 7097 and the ECUS 030. <p> A set of integers forming an arithmetic progression is called here linear. We say that a set of positive integers from [1 : : : U ] is linearly-succinct iff it can be decomposed in at most blog 2 (U )c+1 linear sets. The following lemma was shown in <ref> [8] </ref>. Lemma 2 linearly-succinct sets lemma. The set Periods (w) is linearly-succinct. The lemma below shows that there are strings w i which are "well compressible" but the sets of occurrences of a given pattern P in w i are not well representable as families of linear sets. Lemma 3. <p> Assume a string w given in LZ-compressed form, then we can preprocess w in O (n 2 log n) time in such a way that each equality query about w can be answered in O (n log log n) time with a very small probability of error. Proof. In <ref> [8, 11] </ref> the compressed strings were considered in terms of context-free grammars (grammars, in short) generating single words. We can prove: Claim. Let n = jLZ (w)j. <p> During the ith iteration, for each arithmetic sequence in Suffs (a i1 + 1; i), we compute the set of maximal pattern suffixes which end at the positions of the sequence. As it is proved in <ref> [8] </ref> such a set can be represented in constant space and it is enough to compute such suffixes only for three positions in the sequence.
Reference: 9. <author> D. Knuth, </author> <booktitle> The Art of Computing, Vol. II: Seminumerical Algorithms. Second edi tion. </booktitle> <publisher> Addison-Wesley (1981). </publisher>
Reference-contexts: Using the information about Prefs (b; i) and Suffs (b; i) we can test for the pattern occurrence and compute number of occurrences by solving certain linear diofantine equations (see <ref> [9] </ref>) related to arithmetic progressions representing local occurrences. Now we show how in the ith iteration the sets Suffs (b; i) for active fingers b are computed. The sets Prefs (b; i) are computed similarly.
Reference: 10. <author> A. Lempel and J.Ziv, </author> <title> On the complexity of finite sequences, </title> <journal> IEEE Trans. on Inf. Theory 22, </journal> <month> 75-81 </month> <year> (1976) </year>
Reference-contexts: After identifying each subword f i with its corresponding interval we obtain the following LZ encoding of the string: LZ (aababbabbababbabb#) = a [1; 1]b [1; 2]b [4; 6]a <ref> [2; 10] </ref>#. First we make the following modification of the LZ encoding, which allows to move all terminal symbols to the beginning of the code. The encoding starts from all terminal symbols from the word.
Reference: 11. <author> W. Plandowski, </author> <title> Testing equivalence of morphisms on context-free languages, </title> <booktitle> ESA'94, Lecture Notes in Computer Science 855, </booktitle> <publisher> Springer-Verlag, </publisher> <month> 460-470 </month> <year> (1994). </year>
Reference-contexts: Assume a string w given in LZ-compressed form, then we can preprocess w in O (n 2 log n) time in such a way that each equality query about w can be answered in O (n log log n) time with a very small probability of error. Proof. In <ref> [8, 11] </ref> the compressed strings were considered in terms of context-free grammars (grammars, in short) generating single words. We can prove: Claim. Let n = jLZ (w)j.
Reference: 12. <author> J.Ziv and A.Lempel, </author> <title> A universal algorithm for sequential data compression, </title> <journal> IEEE Trans. on Inf. Theory 17, </journal> <month> 8-19, </month> <title> 1984 This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Email:marek@cs.uni-bonn.de ??? Supported partially by the grant KBN 8T11C01208. Email:wojtekpl@mimuw.edu.pl y Supported partially by the grant KBN 8T11C01208. Email:rytter@mimuw.edu.pl and practical method of the text compression is the LZ-compression (see <ref> [12] </ref>). In this paper we consider several problems for LZ-compressed strings: pattern matching and computation of all periods, palindromes and squares of a given compressed string (without decompression).
References-found: 12

