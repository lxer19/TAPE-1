URL: ftp://ftp.cl.cam.ac.uk/hvg/papers/MLinHOL.thesis.ps.gz
Refering-URL: http://www.cl.cam.ac.uk/users/drs1004/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Machine Assisted Reasoning About Standard ML Using HOL  
Author: Donald Syme 
Degree: A subthesis submitted to the Australian National University in partial fulfillment of the requirements for the degree of Bachelor of Science (Honours)  
Date: November 1992  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Mark Aargaard and Miriam Lesser. </author> <title> A formally verified system for logic synthesis. </title> <type> Masters Thesis, </type> <month> April </month> <year> 1992. </year> <institution> School of Electrical Engineering, Cornell University. </institution>
Reference-contexts: It is ultimately our aim to prove these and other theorems using HOL. 2.3.1 Related Works The largest example known to the author of formal reasoning with Standard ML is the verification proof carried out by Aargaard and Lesser <ref> [1] </ref>. The program they verified implemented an algorithm which automatically designed circuits for logic synthesis. The program was written in a purely functional subset of Standard ML. The verification was 2.3.
Reference: [2] <author> Richard Bird and Philip Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference: [3] <institution> University Of Calgary. HOL90 System Notes, </institution> <year> 1992. </year>
Reference-contexts: The one which was used for this project was HOL88 Version 2.0, developed at the University of Cambridge. Of future importance will be HOL90, which is built using Standard ML as its meta language, rather then the early version of ML found in HOL88 <ref> [3] </ref>. ICL Secure Systems use a HOL derivative in their commercial work known as Proof Power. 3.1 Higher Order Logic To the newcomer, the logic of HOL often seems somewhat confusing.
Reference: [4] <author> A. Cant and M.A. Ozols. </author> <title> A verification environment for ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <pages> pages 151-155, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Furthermore, we aim to base our reasoning on the Formal Definition, rather than our own interpretation of the language. A Standard ML verification environment is being developed by Tony Cant at Adelaide, using the Isabelle proof system <ref> [4] </ref>. The system presently deals with a pure-functional subset of the Core language, and the semantics are embedded in Isabelle's first-order logic. It would seem that the representation they use may well suffer from some of the incompleteness problems that will be encountered in Chapters 4 and 6.
Reference: [5] <author> A. Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: however, one of the strong features of the system that it can be understood on several levels, so the beginner need not understand all the subtleties of the underlying logic before using it. 3.1.1 Types, Terms, Formulae and Sentences The HOL logic is based on Church's simple theory of types <ref> [5] </ref>, extended to include type variables as part of the logic itself. There are four sorts of terms in the logic: constants, variables, function applications and -abstractions. Types, written as subscripts, are assigned to each term, and terms must obey polymorphic typing rules not unlike those of ML.
Reference: [6] <editor> R.L. Constable et al. </editor> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: The program was written in a purely functional subset of Standard ML. The verification was 2.3. REASONING ABOUT STANDARD ML 13 not based on the Formal Definition of the language, but instead the ML functions were translated directly into functions in the Nuprl proof development system <ref> [6] </ref>. Thus the verification exercise was reduced to reasoning about mathematical functions directly. This is, of course, one of the beauties of Standard ML, in that its style of definition is so close to mathematics that given enough restrictions we may treat the functions we define as mathematical descriptions.
Reference: [7] <author> Michael J. C. Gordon. </author> <title> The Denotational Description of Programming Languages: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: One of the earliest was Axiomatic Semantics, developed by Hoare, where a language was described using a series of logical axioms, each of which relates the pre and post conditions of a program fragment. Another prominent style is Denotational Semantics, developed initially by Scott and Strachey <ref> [7] </ref>. Here the aim is to describe the effect of the evaluation of program fragments on objects such as machine memory and environments. Denotational Semantics inevitably requires extensive use of higher-order functions, and perhaps a special purpose logic such as LCF.
Reference: [8] <author> Michael J. C. Gordon. </author> <title> Mechanizing programming languages in Higher Order Logic. HOL System Documentation, </title> <year> 1988. </year>
Reference-contexts: Styles of proof are often mixed freely within the proof of a theorem. 3.3 Using HOL to Embed Programming Logics It is the aim of this project to embed the formal definition of Standard ML in HOL. Michael Gordon's paper <ref> [8] </ref> illustrates the practicality of this approach. His object of study is a simple imperative language for which Hoare's axiomatic semantics hold. Gordon first describes the representation of the syntactic constructs of the language in HOL using the type definition features of the system. <p> HOL provides a pretty printing library, but it is unfortunately extremely slow. To solve this problem we follow the example of Gordon in <ref> [8] </ref> and modify the underlying Lisp implementation of the standard HOL pretty printer. The modifications, though lengthy, are routine and do not need to be described here in detail. Lastly, we need a set of functions which will allow us to manipulate program fragments.
Reference: [9] <editor> Michael J. C. Gordon et al. </editor> <title> The HOL System Description, </title> <month> December </month> <year> 1989. </year>
Reference-contexts: There are eight primitive rules of inference in the HOL system, each of which is documented in <ref> [9] </ref>. They include the rule of modus ponens (MP), a rule of substitution (SUBST), a rule to eliminate type variables (INST TYPE) plus rules to introduce assumptions, equality and lambda abstractions. The HOL system incorporates five basic axioms, defining the semantics of implication, lambda abstraction, choice and the bool type. <p> For example, the functions mk_imp : (term # term) -&gt; term dest_imp : term -&gt; (term # term) is_imp : term -&gt; bool 1 For a formalisation of the notion of "logical validity" in HOL in terms of models and standard models, see <ref> [9] </ref>. 20 CHAPTER 3. HOL construct, destruct and test for terms of the form t 1 t 2 . Similar functions are defined to manipulate higher level constructs, for instance the functions list mk forall and strip forall construct and destruct multiple 8 quantifications from terms.
Reference: [10] <author> Brian Graham. </author> <title> Dealing with the Choice operator in HOL88. HOL System Documentation, </title> <year> 1990. </year>
Reference-contexts: While often useful in definitions, it is a difficult operator to use in mechanical proofs for an excellent description of the semantics of the operator and techniques available to eliminate it from proofs, see <ref> [10] </ref>. 3.1.2 Deduction and Theorems One of the first things a newcomer to HOL notices is the restrictions on the production of theorems. Theorems in HOL correspond to sentences which are logically deducible from a set of axioms using a set of primitive rules of inference.
Reference: [11] <author> Robert W. Harper. </author> <title> Standard ML input/output. </title> <journal> Polymorphism, </journal> <volume> 2(2), </volume> <year> 1985. </year>
Reference: [12] <author> Matthew Hutchins. </author> <title> Machine assisted reasoning about Standard ML using HOL. </title> <type> Honours Thesis, </type> <month> November </month> <year> 1990. </year> <institution> Australian National University. </institution>
Reference-contexts: For more detailed information about the language, we direct the reader to the formal definition of the language, the commentary on the formal definition, and the textbooks written on the language <ref> [12, 20, 17, 19, 18] </ref>. 1.1 Core Constructs Standard ML is first and foremost a functional language. Functions are treated as first-class objects and may be used like other values. <p> Two good sources of examples of reasoning based on the formal definition are available to us. The first is the project by Matthew Hutchins, which forms the immediate background to this thesis. In chapter 2 of <ref> [12] </ref>, Hutchins provides a detailed proof of the non-trivial append associativity theorem. This is not a verification theorem, as it asserts the semantic equivalence of two program fragments. This theorem shall be one of the main examples of this thesis, and shall be discussed shortly. <p> What we need to know is exactly what information can be assumed about the type of value that A, B and C produce when they are evaluated. In <ref> [12] </ref> Hutchins demonstrates that the associativity result does, in fact, hold for arbitrary expressions A, B and C regardless of the values that might be inferred for them. <p> For example, the paired value (100,200) is represented by the record: f1 Lab 7! 100 V al ; 2 Lab 7! 200 V al g In <ref> [12] </ref>, Hutchins correctly recognises that these maps are functions from a finite subset of a (perhaps infinite) domain to a range set. As functions in HOL are "total", he rejects 35 36 CHAPTER 5. <p> The deductions performed by the evaluator are based on the forward inference rules developed in the previous chapter. The design of the evaluator is covered in some detail in <ref> [12] </ref>. <p> PROOFS B.3 The Forward Inference Rules This section outlines the proof techniques employed in proving the forward inference rules of Chapter 7. These were originally proved by Matthew Hutchins in <ref> [12] </ref>, and the reader may wish to refer to that work also. We shall show the proof for only one rule a forward rule for Exp Raise phrases.
Reference: [13] <author> David MacQueen. </author> <title> Modules for Standard ML. </title> <journal> Polymorphism, </journal> <volume> 2(2), </volume> <year> 1985. </year>
Reference: [14] <author> Robin Milner. </author> <booktitle> Lecture notes on language semantics. </booktitle> <institution> Computer Science 3, University of Edinburgh. </institution>
Reference-contexts: Denotational Semantics inevitably requires extensive use of higher-order functions, and perhaps a special purpose logic such as LCF. The Formal Definition of Standard ML uses a style known as Natural Semantics. An excellent introduction to Natural Semantics and other semantic styles is given in Milner's series of lecture notes <ref> [14] </ref>. The heart of a definition written in Natural Semantics is a collection of inference rules. Each inference rule allows sentences of the form A ` phrase ) A 0 to be deduced, given certain premises.
Reference: [15] <author> Robin Milner. </author> <title> How ML evolved. </title> <journal> Polymorphism, </journal> <volume> 1(1), </volume> <year> 1983. </year>
Reference-contexts: Chapter 1 Introducing Standard ML The programming language now known as "Standard ML" has been evolving steadily for the last 20 years. The language was originally developed as the meta-language 1 for the LCF proof system. In <ref> [15] </ref> Milner describes how the needs of LCF led directly to the main features of the ML language: its functional nature; polymorphism; strong typing; exceptions; and imperative constructs. LCF eventually led to systems such as HOL.
Reference: [16] <author> Robin Milner. </author> <title> The Standard ML Core language. </title> <journal> Polymorphism, </journal> <volume> 2(2), </volume> <year> 1985. </year> <note> 129 130 BIBLIOGRAPHY </note>
Reference: [17] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: For more detailed information about the language, we direct the reader to the formal definition of the language, the commentary on the formal definition, and the textbooks written on the language <ref> [12, 20, 17, 19, 18] </ref>. 1.1 Core Constructs Standard ML is first and foremost a functional language. Functions are treated as first-class objects and may be used like other values.
Reference: [18] <author> Larry Paulson. </author> <title> ML For the working programmer. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: For more detailed information about the language, we direct the reader to the formal definition of the language, the commentary on the formal definition, and the textbooks written on the language <ref> [12, 20, 17, 19, 18] </ref>. 1.1 Core Constructs Standard ML is first and foremost a functional language. Functions are treated as first-class objects and may be used like other values.
Reference: [19] <author> Chris Reade. </author> <title> Elements of Functional Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: For more detailed information about the language, we direct the reader to the formal definition of the language, the commentary on the formal definition, and the textbooks written on the language <ref> [12, 20, 17, 19, 18] </ref>. 1.1 Core Constructs Standard ML is first and foremost a functional language. Functions are treated as first-class objects and may be used like other values. <p> In 1985 a proposal to add modules to the language was accepted by the ML community. Unlike object-oriented systems, Standard ML maintains a distinction between types and modules. Modules are essentially fragments of environments (structures) and operations on environments (functors). <ref> [19] </ref> provides a good introduction to the notion of modules in Standard ML. The purpose of adding modules to the system is to support the abstraction of functionality and types at a level beyond polymorphism in lambda abstractions. Structures may contain types and values (including functions).
Reference: [20] <author> Robin Milner Robert Harper and Mads Tofte. </author> <title> The Definition Of Standard ML, Version 2. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: For more detailed information about the language, we direct the reader to the formal definition of the language, the commentary on the formal definition, and the textbooks written on the language <ref> [12, 20, 17, 19, 18] </ref>. 1.1 Core Constructs Standard ML is first and foremost a functional language. Functions are treated as first-class objects and may be used like other values. <p> INTRODUCING STANDARD ML Chapter 2 The Definition of Standard ML This chapter discusses the Formal Definition of Standard ML as set out by Milner, Tofte and Harper in <ref> [20] </ref>. This is a necessary preliminary before an attempt can be made to reason about the language using the HOLsystem. <p> This was used for the definition of the semantic types in HOLin Chapter 5. Both sections are based on the corresponding portions of the Formal Definition of Standard ML <ref> [20] </ref>. They have been modified slightly to reflect the fact that input/output, modules, strings and real numbers were not considered in this project. Core Syntax This ection gives the syntax of the reduced language considered in this thesis.
Reference: [21] <author> Claudio V. Russo. </author> <title> Automating mutually recursive type definitions in HOL. </title> <type> Honours Thesis, </type> <month> June </month> <year> 1992. </year> <institution> University Of Edinburgh. </institution>
Reference-contexts: In addition, several groups have worked on producing packages to automate this process. Of the packages that have been developed, only one appears to be both correct and useful that developed during 1992 by Claudio Russo at the University of Edinburgh <ref> [21] </ref>. It is this package which we will use initially to define our type structures. The package is capable of defining types for mutually recursive grammars of a definitional style similar to those handled by the existing HOL define type package.
References-found: 21

