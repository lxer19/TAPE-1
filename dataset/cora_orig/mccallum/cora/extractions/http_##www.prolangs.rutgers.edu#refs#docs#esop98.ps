URL: http://www.prolangs.rutgers.edu/refs/docs/esop98.ps
Refering-URL: http://www.csd.uu.se/~thomasl/wpo/oo-compilation-papers.html
Root-URL: 
Email: framkrish,ryderg@cs.rutgers.edu  wlandi@scr.siemens.com  
Phone: Fax: 732 445 0537,  2  
Title: Complexity of Concrete Type-inference in the Presence of Exceptions  
Author: Ramkrishna Chatterjee Barbara G. Ryder William A. Landi 
Address: Piscataway, NJ 08855 USA,  755 College Rd. East, Princeton, NJ 08540 USA,  
Affiliation: 1 Department of Computer Science, Rutgers University,  Siemens Corporate Research Inc,  
Abstract: Concrete type-inference for statically typed object-oriented programming languages (e.g., Java, C ++ ) determines at each program point, those objects to which a reference may refer or a pointer may point during execution. A precise compile-time solution for this problem requires a flow-sensitive analysis. Our new complexity results for concrete type-inference distinguish the difficulty of the intraprocedural and interprocedural problem for languages with combinations of single-level types 3 , exceptions with or without subtyping, and dynamic dispatch. Our results include: The first polynomial-time algorithm for concrete type-inference in the presence of exceptions, which handles Java without threads, and C ++ ; Proofs that the above algorithm is always safe and provably precise on programs with single-level types, exceptions without subtyping, and without dynamic dispatch; Proof that intraprocedural concrete type-inference problem with single-level types and exceptions with subtyping is PSPACE-complete, while the interprocedural problem without dynamic dis patch is PSPACE-hard. Other complexity characterizations of concrete type-inference for pro grams without exceptions are also presented.
Abstract-found: 1
Intro-found: 1
Reference: [Age95] <author> Ole Agesen. </author> <title> The cartesian product algorithm: Simple and precise type inference of parametric polymorphism. </title> <booktitle> In Proceedings of European Conference on Object-oriented Programming (ECOOP '95), </booktitle> <year> 1995. </year>
Reference-contexts: While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive. Approaches like <ref> [PS91, PC94, Age95] </ref> are in between the above two extremes. An intraprocedurally flow-insensitive algorithm does not distinguish between program points within a method; hence it reports the same solution for all program points within each method. <p> This way of maintaining context is similar to Landi-Ryder's [LR92] method of storing context using reaching aliases, except that our algorithm uses points-tos rather than aliases. Our algorithm also differs from approaches like <ref> [PS91, Age95] </ref> in being intraprocedurally flow-sensitive. 6 Conclusion In this paper, we have studied the complexity CTI for a subset of Java, which includes exceptions. To the best of our knowledge, the complexity of CTI in the presence of exceptions has not been studied before.
Reference: [And94] <author> L. O. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <year> 1994. </year> <note> Also available as DIKU report 94/19. </note>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for CTI of Java without exceptions and threads, or C ++ without exceptions. At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [Ste96, SH97, ZRL96, And94] </ref>, which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive.
Reference: [Bar78] <author> J. M. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> Com--munications of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <year> 1978. </year>
Reference-contexts: Unfortunately, all paths in a program are not necessarily executable and determining which are executable is undecidable. Barth <ref> [Bar78] </ref> defined precise up to symbolic execution to be the precise solution under the assumption that all program paths are executable (i.e., the result of a test is independent of previous tests and all the branches are possible).
Reference: [CBC93] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches [Ste96, SH97, ZRL96, And94], which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches <ref> [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95] </ref>, which are the most precise, but also the most expensive. Approaches like [PS91, PC94, Age95] are in between the above two extremes. <p> The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed--points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions.
Reference: [CRL97] <author> Ramkrishna Chatterjee, Barbara Ryder, and William Landi. </author> <title> Complexity of concrete type-inference in the presence of exceptions. </title> <type> Technical Report DCS-TR-341, </type> <institution> Dept of CS, Rutgers University, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: Finally, we present PSPACE-hardness results about CTI in the presence of exceptions. Due to lack of space, we have omitted all proofs. These proofs and further details about the results in this paper are given in <ref> [CRL97] </ref> 5 . 2 Basic definitions Program representation. Our algorithm operates on an interprocedural control flow graph or ICFG [LR91]. An ICFG contains a control flow graph (CFG) for each method in the program. Each statement in a method is represented by a node in the method's CFG. <p> Appendix A contains an example which illustrates the basic algorithm. Precision of the basic algorithm. By induction on the number of iterations needed to compute a data-flow element and the length of a path associated with a data-flow element, in <ref> [CRL97] </ref>, we prove that the basic algorithm computes the // initialize worklist. <p> Note that O (n 3 ) is a trivial worst-case lower bound for obtaining a precise solution for this case. For programs written in JavaWoThreads, but without exceptions, the basic algorithm is polynomial-time. Other results on the complexity of CTI in the absence of exceptions. In <ref> [CRL97] </ref>, we prove the following two theorems: Theorem 1 Intraprocedural CTI for programs with only single-level types is in non-deterministic log-space and hence NC. void process exit node ( exit node, ndf elm ) f // Let M be the method containing the exit node. if ( ndf elm represents the <p> The lattice for data-flow analysis associated with a program point is a subset lattice consisting of sets of these data-flow elements. In the rest of this section, we present definitions of these data-flow elements and a brief description of how they are propagated. Further details are given in <ref> [CRL97] </ref>. First we describe how a throw statement is handled. Next, we describe propagation at a method exit-node. <p> A mechanism similar to the one used for handling a call is used for handling a try statement nested inside a finally because it can cause labels and exceptions to stack up. Details of this are given in <ref> [CRL97] </ref>. If the finally generates a reason of its own for exiting itself, the previous label/exception-type associated with a data-flow element is discarded, and the new label/exception-type representing this reason for leaving the finally is associated with the data-flow element. Example. The example in Figure 5 illustrates the above algorithm. <p> Example. The example in Figure 5 illustrates the above algorithm. Precision of the extended algorithm. In <ref> [CRL97] </ref>, we prove that the extended algorithm described in Section 4 computes the precise solution for programs with only single-level types, exceptions without subtyping, and without dynamic dispatch. We also prove that this algorithm computes a safe solution for programs written in JavaWoThreads. Complexity of the extended algorithm. <p> If we disallow trys nested inside a finally, the worst-case complexity is O (n 6 ). For general programs written in JavaWoThreads, the extended algorithm is polynomial-time. Complexity due to exceptions with subtyping. In <ref> [CRL97] </ref>, we prove the following theorem: Theorem 3 Intraprocedural CTI for programs with only single-level types and exceptions with subtyping is PSPACE-complete; while the interprocedural case (even) without dynamic dispatch is PSPACE-hard. // Note: for simplicity only a part of the solution is shown class A fg; class excp t extends <p> To the best of our knowledge, the complexity of CTI in the presence of exceptions has not been studied before. The following are the main contributions of this work (proofs are not presented in this paper, but appear in <ref> [CRL97] </ref>): 1. The first polynomial-time algorithm for CTI in the presence of exceptions which handles a robust subset of Java without threads, and C ++ . 2.
Reference: [EGH94] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming language design and implementation, </booktitle> <pages> pages 242-256, </pages> <year> 1994. </year>
Reference-contexts: At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches [Ste96, SH97, ZRL96, And94], which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches <ref> [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95] </ref>, which are the most precise, but also the most expensive. Approaches like [PS91, PC94, Age95] are in between the above two extremes. <p> The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> Information flows from a call-node to the entry-node of a target method and comes back from the exit-node of the target method to the return-node of the call-node. Due to dynamic dispatch, interprocedural edges are constructed iteratively during data-flow analysis as in <ref> [EGH94] </ref>. Details of this construction are shown in Figure 3. We will denote the entry-node of main by start-node in the rest of this paper. Representation of dynamically created objects. All run-time objects (or arrays) created at a program point n are represented symbolically by object n. <p> Due to dynamic dispatch, the set of methods invoked from a call site is iteratively computed during the data-flow analysis as in <ref> [EGH94] </ref>. Suppose hx, ti holds at a call site C which has a method M in its set of invocable methods computed so far. <p> C, ndf elm )f // R is the return-node for call node C. if ( ndf elm implies an increase in the set CM of methods invoked from this site ) f // Recall that due to dynamic dispatch, the interprocedural // edges are constructed on the fly, as in <ref> [EGH94] </ref>. add this new method nM to CM; for ( each dfelm in the solution set of C ) interprocedurally propagate ( dfelm, C, nM ); // defined in Figure 4 g if ( ndf elm represents value of a local variable ) f if ( solution set for R contains <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed--points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Single-level type. A single-level type is one of the following: (1) a primitive type defined in <ref> [GJS96] </ref> (e.g., int, float etc.), (2) a class that has all non-static data-members of primitive types (e.g., class A f int i,j; g) or (3) an array of a primitive type. Subtype.
Reference: [KU76] <author> J.B. Kam and J.D. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of ACM, </journal> <volume> 23(1) </volume> <pages> 158-171, </pages> <year> 1976. </year>
Reference-contexts: If all statements that can potentially generate run-time exceptions are considered, we will get a safe solution; however, this may generate far more information than what is useful. 3 CTI in the absence of exceptions Our basic algorithm for CTI is an iterative worklist algorithm <ref> [KU76] </ref>. It operates on an ICFG and is similar to the Landi-Ryder algorithm [LR92] for alias analysis, but instead of aliases, it computes points-tos. In Section 4, we will extend this algorithm to handle exceptions. Lattice for data-flow analysis.
Reference: [LR91] <author> W.A. Landi and Barbara G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: In contrast, an intraprocedurally flow-sensitive algorithm tries to compute different solutions for distinct program points. An interprocedurally flow-sensitive (i.e. context-sensitive) algorithm considers (sometimes approximately) only interprocedurally realizable paths <ref> [RHS95, LR91] </ref>: paths along which calls and returns are properly matched, while an inter-procedurally flow-insensitive (i.e. context-insensitive) algorithm does not make this distinction. For the rest of this paper, we will use the term flow-sensitive to refer to an intra- and interprocedurally flow-sensitive analysis. <p> Due to lack of space, we have omitted all proofs. These proofs and further details about the results in this paper are given in [CRL97] 5 . 2 Basic definitions Program representation. Our algorithm operates on an interprocedural control flow graph or ICFG <ref> [LR91] </ref>. An ICFG contains a control flow graph (CFG) for each method in the program. Each statement in a method is represented by a node in the method's CFG. Each call site is represented using a pair of nodes: a call-node and a return-node. <p> This an improvement over the O (n 7 ) worst-case bound achievable by applying previous approaches of [RHS95] and <ref> [LR91] </ref> to this case. Note that O (n 3 ) is a trivial worst-case lower bound for obtaining a precise solution for this case. For programs written in JavaWoThreads, but without exceptions, the basic algorithm is polynomial-time. Other results on the complexity of CTI in the absence of exceptions. <p> A proof that CTI for programs with only single-level types can be done in O (n 5 ) time. This is an improvement over the O (n 7 ) worst-case bound achievable by applying previous approaches of [RHS95] and <ref> [LR91] </ref> to this case. 3. A proof that intraprocedural CTI for programs with only single-level types is in non-deterministic log-space and hence NC.
Reference: [LR92] <author> W.A. Landi and Barbara G. Ryder. </author> <title> A safe approximation algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches [Ste96, SH97, ZRL96, And94], which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches <ref> [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95] </ref>, which are the most precise, but also the most expensive. Approaches like [PS91, PC94, Age95] are in between the above two extremes. <p> The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> It operates on an ICFG and is similar to the Landi-Ryder algorithm <ref> [LR92] </ref> for alias analysis, but instead of aliases, it computes points-tos. In Section 4, we will extend this algorithm to handle exceptions. Lattice for data-flow analysis. In order to restrict data-flow only to realizable paths, points-tos are computed conditioned on assumed-points-tos (akin to reaching alias in [LR92] [PR96]), which represent points-tos <p> to the Landi-Ryder algorithm <ref> [LR92] </ref> for alias analysis, but instead of aliases, it computes points-tos. In Section 4, we will extend this algorithm to handle exceptions. Lattice for data-flow analysis. In order to restrict data-flow only to realizable paths, points-tos are computed conditioned on assumed-points-tos (akin to reaching alias in [LR92] [PR96]), which represent points-tos reaching the entry of a method, and approximate the calling context in which the method has been called (see the example in Appendix A). A points-to along with its assumed-points-to is called a conditional-points-to. <p> This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions. This way of maintaining context is similar to Landi-Ryder's <ref> [LR92] </ref> method of storing context using reaching aliases, except that our algorithm uses points-tos rather than aliases. Our algorithm also differs from approaches like [PS91, Age95] in being intraprocedurally flow-sensitive. 6 Conclusion In this paper, we have studied the complexity CTI for a subset of Java, which includes exceptions.
Reference: [MLR + 93] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. Choi, M. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: A clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches [Ste96, SH97, ZRL96, And94], which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches <ref> [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95] </ref>, which are the most precise, but also the most expensive. Approaches like [PS91, PC94, Age95] are in between the above two extremes. <p> The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed--points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions.
Reference: [Pap94] <author> C. H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Code for processing an exit-node Recall that non-deterministic log-space is the set of languages accepted by non deterministic Turing machines using logarithmic space <ref> [Pap94] </ref> and NC is the class of efficiently parallelizable problems which contains non-deterministic log space.
Reference: [PC94] <author> J. Plevyak and A. Chien. </author> <title> Precise concrete type inference for object oriented languages. </title> <booktitle> In Proceeding of Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '94), </booktitle> <pages> pages 324-340, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive. Approaches like <ref> [PS91, PC94, Age95] </ref> are in between the above two extremes. An intraprocedurally flow-insensitive algorithm does not distinguish between program points within a method; hence it reports the same solution for all program points within each method. <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed--points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions.
Reference: [PR96] <author> Hemant Pande and Barbara G. Ryder. </author> <title> Data-flow-based virtual function resolution. </title> <booktitle> In LNCS 1145, Proceedings of the Third International Symposium on Static Analysis, </booktitle> <year> 1996. </year>
Reference-contexts: The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> In Section 4, we will extend this algorithm to handle exceptions. Lattice for data-flow analysis. In order to restrict data-flow only to realizable paths, points-tos are computed conditioned on assumed-points-tos (akin to reaching alias in [LR92] <ref> [PR96] </ref>), which represent points-tos reaching the entry of a method, and approximate the calling context in which the method has been called (see the example in Appendix A). A points-to along with its assumed-points-to is called a conditional-points-to.
Reference: [PS91] <author> J. Palsberg and M. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proceedings of Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '91), </booktitle> <pages> pages 146-161, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive. Approaches like <ref> [PS91, PC94, Age95] </ref> are in between the above two extremes. An intraprocedurally flow-insensitive algorithm does not distinguish between program points within a method; hence it reports the same solution for all program points within each method. <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed--points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions. <p> This way of maintaining context is similar to Landi-Ryder's [LR92] method of storing context using reaching aliases, except that our algorithm uses points-tos rather than aliases. Our algorithm also differs from approaches like <ref> [PS91, Age95] </ref> in being intraprocedurally flow-sensitive. 6 Conclusion In this paper, we have studied the complexity CTI for a subset of Java, which includes exceptions. To the best of our knowledge, the complexity of CTI in the presence of exceptions has not been studied before.
Reference: [RHS95] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <year> 1995. </year>
Reference-contexts: In contrast, an intraprocedurally flow-sensitive algorithm tries to compute different solutions for distinct program points. An interprocedurally flow-sensitive (i.e. context-sensitive) algorithm considers (sometimes approximately) only interprocedurally realizable paths <ref> [RHS95, LR91] </ref>: paths along which calls and returns are properly matched, while an inter-procedurally flow-insensitive (i.e. context-insensitive) algorithm does not make this distinction. For the rest of this paper, we will use the term flow-sensitive to refer to an intra- and interprocedurally flow-sensitive analysis. <p> This an improvement over the O (n 7 ) worst-case bound achievable by applying previous approaches of <ref> [RHS95] </ref> and [LR91] to this case. Note that O (n 3 ) is a trivial worst-case lower bound for obtaining a precise solution for this case. For programs written in JavaWoThreads, but without exceptions, the basic algorithm is polynomial-time. <p> A proof that CTI for programs with only single-level types can be done in O (n 5 ) time. This is an improvement over the O (n 7 ) worst-case bound achievable by applying previous approaches of <ref> [RHS95] </ref> and [LR91] to this case. 3. A proof that intraprocedural CTI for programs with only single-level types is in non-deterministic log-space and hence NC.
Reference: [Ruf95] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming language design and implementation, </booktitle> <pages> pages 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches [Ste96, SH97, ZRL96, And94], which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches <ref> [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95] </ref>, which are the most precise, but also the most expensive. Approaches like [PS91, PC94, Age95] are in between the above two extremes. <p> The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed--points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions.
Reference: [SH97] <author> M. Shapiro and S. Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <year> 1997. </year>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for CTI of Java without exceptions and threads, or C ++ without exceptions. At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [Ste96, SH97, ZRL96, And94] </ref>, which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive.
Reference: [Ste96] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Proceedings of the ACM SIGPLAN/SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <year> 1996. </year>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for CTI of Java without exceptions and threads, or C ++ without exceptions. At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [Ste96, SH97, ZRL96, And94] </ref>, which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive.
Reference: [WL95] <author> Robert P. Wilson and Monica S. Lam. </author> <title> Efficient context-sensitive pointer analysis for c programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming language design and implementation, </booktitle> <pages> pages 1-12, </pages> <year> 1995. </year>
Reference-contexts: At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches [Ste96, SH97, ZRL96, And94], which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches <ref> [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95] </ref>, which are the most precise, but also the most expensive. Approaches like [PS91, PC94, Age95] are in between the above two extremes. <p> The complexity of flow-sensitive CTI in the presence of exceptions has not been studied previously. None of the previous flow-sensitive pointer analysis algorithms <ref> [LR92, WL95, EGH94, PR96, Ruf95, CBC93, MLR + 93] </ref> for C/C ++ handle exceptions. However, unlike in C ++ , exceptions are frequently used in Java programs, making it an important problem for Java. <p> This work takes state-of-the-art in pointer analysis one step further by handling exceptions. Our algorithm differs from other pointer analysis and CTI algorithms <ref> [EGH94, WL95, Ruf95, PC94, PS91, CBC93, MLR + 93] </ref> in the way it maintains context-sensitivity by associating assumed--points-tos with each data-flow element, rather than using some approximation of the call stack. This way of handling context-sensitivity enables us to obtain precise solution for polynomial-time solvable cases, and handle exceptions.
Reference: [ZRL96] <author> S. Zhang, B. G. Ryder, and W. Landi. </author> <title> Program decomposition for pointer aliasing: A step towards practical analyses. </title> <booktitle> In Proceedings of the 4th Sym posium on the Foundations of Software Engineering, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Although some of these have been used for pointer analysis of C, they can be adapted for CTI of Java without exceptions and threads, or C ++ without exceptions. At the one end of the spectrum are intraprocedurally and interprocedurally flow-insensitive approaches <ref> [Ste96, SH97, ZRL96, And94] </ref>, which are the least expensive, but also the most imprecise. While at the other end are intraprocedurally and interprocedurally flow-sensitive approaches [LR92, EGH94, WL95, CBC93, MLR + 93, Ruf95], which are the most precise, but also the most expensive.
References-found: 21

