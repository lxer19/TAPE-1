URL: ftp://ftp.cs.man.ac.uk/pub/IPG/sw94.ps.Z
Refering-URL: http://www.cs.man.ac.uk/ipg/publications.html
Root-URL: http://www.cs.man.ac.uk
Title: Modelling Processes Using a Stepwise Refinement Technique  
Author: Jin Sa and B.C. Warboys, 
Date: February, 1994,  
Note: Published in the proceedings of the Third Workshop on Software Process Technology EWSPT'94,  also in LNCS 772.  
Address: Manchester M13 9PL, England.  Lans (Grenoble), France,  
Affiliation: Department of Computer Science, University of Manchester,  Villard de  
Abstract-found: 0
Intro-found: 0
Reference: 1. <institution> ISS400 Technical Introduction. </institution> <type> Technical Report 53423/001, </type> <institution> Internationl Computer Limited, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Investigation on supporting executable OBM with Enact is underway. This involves defining the semantics of the OBM constructs in Enact. A case study, called "Integrated Store Solution" (ISS400) <ref> [1] </ref>, is being undertaken to illustrate both the development process of OBM and the use of the executable OBM. 9.8 Data Refinement In this paper, we have described component refinement and coperation refinement. What remains to be studied is data refinement.
Reference: 2. <author> V. Ambriola and Carlo Montangero. </author> <title> Oikos at the Age of Three. </title> <booktitle> In Proceedings EWSPT'92, volume 635 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: An example of this type of approach is Process Weaver [11]. Another type of approach is incremental definitions. Examples of this type of approach include: tasks in Epos [8], activities in Slang [3], blackboard in Oikos <ref> [2] </ref>. However there is no support for formal reasoning between different levels of abstraction. Since Slang is based on Petri-net, it should be possible to perform formal reasoning, however, it is not clear to the authors whether such a facility is provided by [3]. <p> Since Slang is based on Petri-net, it should be possible to perform formal reasoning, however, it is not clear to the authors whether such a facility is provided by [3]. Work on consistency proof for refinement in Oikos is in development <ref> [2, 7] </ref>. In [16], a method based on data flow diagram (DFD) for modelling process interface is defined.
Reference: 3. <author> S. Bandinelli, A. Fuggetta, and S. Grigolli. </author> <title> Sprocess Modelling In-the-Large with SLANG. </title> <booktitle> In Proceedings of the Second International Conference on the Software Process, </booktitle> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: An example of this type of approach is Process Weaver [11]. Another type of approach is incremental definitions. Examples of this type of approach include: tasks in Epos [8], activities in Slang <ref> [3] </ref>, blackboard in Oikos [2]. However there is no support for formal reasoning between different levels of abstraction. Since Slang is based on Petri-net, it should be possible to perform formal reasoning, however, it is not clear to the authors whether such a facility is provided by [3]. <p> activities in Slang <ref> [3] </ref>, blackboard in Oikos [2]. However there is no support for formal reasoning between different levels of abstraction. Since Slang is based on Petri-net, it should be possible to perform formal reasoning, however, it is not clear to the authors whether such a facility is provided by [3]. Work on consistency proof for refinement in Oikos is in development [2, 7]. In [16], a method based on data flow diagram (DFD) for modelling process interface is defined.
Reference: 4. <author> H. Barringer, R. Kuiper, and A. Pnueli. </author> <title> Now you may compose temporal logic specifications. </title> <booktitle> In Proceedings of the 16th A.C.M. Symposium on Theory of Computing, </booktitle> <year> 1984. </year>
Reference-contexts: A logic framework for reasoning about properties of concurrent programs was later developed by Pnueli [18]. Although that framework provided very powerful specification and verification tools for global programs, it did not provide much support for decomposition and composition of components. In <ref> [4] </ref>, a compositional temporal logic proof system for specification and verification of concurrent program was introduced. This approach offered support for development of concurrent systems. In this paper, we will use the temporal logic described in [4] to define the semantics of OBM. 6.1 Temporal Operators The following temporal operators are <p> In <ref> [4] </ref>, a compositional temporal logic proof system for specification and verification of concurrent program was introduced. This approach offered support for development of concurrent systems. In this paper, we will use the temporal logic described in [4] to define the semantics of OBM. 6.1 Temporal Operators The following temporal operators are used in the semantic definitions in this paper. Their intuitive meanings are described below: fin: end of the sequence. flP : P is true at the next moment. flP : P is true always.
Reference: 5. <author> R.F. Bruynoghe, J.M. Parker, and J.S. </author> <title> Rowles. PSS: A system for Process Enactment. </title> <booktitle> In Proceedings of the first International Conference on the Software Process, Manufacturing Complex Systems. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: The case study showed that although BM could be used as a specification method for some applications, particularly those targeted by the process modelling language PML <ref> [5] </ref>, there was still a wide scope for improvement so that BM could be a more suitable technique for process modelling. Our subsequent work mainly concentrated on specifying 1 the ISPW-6 software process problem example (ISPW-6 example for short) [15].
Reference: 6. <author> R.M. Burstall. </author> <title> Program Proving as Hand Simulation with a Little Induction. </title> <booktitle> In Information Processing 74, </booktitle> <pages> Pages 308-312, </pages> <publisher> North-Holland Pub. Co., </publisher> <year> 1974. </year>
Reference-contexts: The application of temporal logic in computer science was first introduced in <ref> [6] </ref>. A logic framework for reasoning about properties of concurrent programs was later developed by Pnueli [18]. Although that framework provided very powerful specification and verification tools for global programs, it did not provide much support for decomposition and composition of components.
Reference: 7. <author> X.J. Chen and C. Montangero. </author> <title> Compositional Refinement in Multiple Blackboard Systems. </title> <booktitle> In ESOP'92 European Symposium on Programming, </booktitle> <month> February. </month>
Reference-contexts: Since Slang is based on Petri-net, it should be possible to perform formal reasoning, however, it is not clear to the authors whether such a facility is provided by [3]. Work on consistency proof for refinement in Oikos is in development <ref> [2, 7] </ref>. In [16], a method based on data flow diagram (DFD) for modelling process interface is defined.
Reference: 8. <author> R. Conradi et al. </author> <title> Design, Use and Implementation of SPELL, a Language for Software Process Modeling and Evolution. </title> <booktitle> In Proceedings EWSPT'92, volume 635 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Some of these are based on hybrid formalisms that use different notations for large-grain and small-grain aspects of process. An example of this type of approach is Process Weaver [11]. Another type of approach is incremental definitions. Examples of this type of approach include: tasks in Epos <ref> [8] </ref>, activities in Slang [3], blackboard in Oikos [2]. However there is no support for formal reasoning between different levels of abstraction.
Reference: 9. <author> Mark Dowson. </author> <title> Software Process Themes and Issues. </title> <booktitle> In Proceedings of the Second International Conference on the Software Process. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: We believe this gives better control to where the information is going and when the information may be transferred. 9.2 Multiple Levels of Abstractions The need for modelling processes in multiple levels of abstraction has been clearly recognised. Dowson pointed out in <ref> [9] </ref> that modelling formalism should accommodate a wide range of model granularity, and allow the refinement of initially large-grain models to address increasing details. The example above has shown that OBM has achieved this requirement. In OBM, multiple levels of abstraction can be reflected in two ways.
Reference: 10. <editor> J. C. Derniame (Editor). </editor> <booktitle> Lecture Notes in Computer Science 635: Software Process Technology. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 1 Background and Introduction In EWSPT'92 <ref> [10] </ref>, we reported a small case study [24] which we undertook to investigate the application of an existing concurrent formal specification method, Base Model (BM) [23], to process modelling.
Reference: 11. <author> C. Fernstrom. </author> <title> PROCESS WEAVER: Adding Process Support to UNIX. </title> <booktitle> In Proceedings of the Second International Conference on the Software Process, </booktitle> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Several existing approaches also provide means to represent a model in multiple levels of abstraction. Some of these are based on hybrid formalisms that use different notations for large-grain and small-grain aspects of process. An example of this type of approach is Process Weaver <ref> [11] </ref>. Another type of approach is incremental definitions. Examples of this type of approach include: tasks in Epos [8], activities in Slang [3], blackboard in Oikos [2]. However there is no support for formal reasoning between different levels of abstraction.
Reference: 12. <author> V. Gruhn and A. Saalmann. </author> <title> Software Process Validation Based on FUNSOFT Net. </title> <booktitle> In Proceedings EWSPT'92, volume 635 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This is particularly useful in process modification. 9.4 Verification and Validation In <ref> [12] </ref>, the concepts of verification of a software process model and validation of a software process model are defined. Verification means to prove the correctness of a model. Validation means to test if a model behaves as expected using simulation.
Reference: 13. <author> P. Henderson. </author> <title> Object-Oriented Specification and Design with C++. </title> <booktitle> International Series in Software Engineering. </booktitle> <publisher> McGraw-Hill, </publisher> <year> 1993. </year>
Reference-contexts: The BM stepper is implemented using the object-oriented proto-typing language Enact <ref> [13] </ref>. Our experience has shown that the BM stepper has proved to be useful with identifying errors and gaining confidences [21]. At the moment, the BM stepper only covers a sub-set of the operators used in OBM operation patterns.
Reference: 14. <author> C.B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> Computer Science. Prentice-Hall International, </booktitle> <year> 1986. </year>
Reference-contexts: What remains to be studied is data refinement. One aspect of our future work is to investigate how to reason about the consistency between the refinement and its abstract object if data refinement is included. A possible solution is to use the data reification technique as described in <ref> [14] </ref>. The work on OBM is ongoing. There is still a wide scope for improvement. However, we believe the concepts and features offered by OBM can play an important part in the area of process modelling. Acknowledgements The authors would like to thank Professor P.
Reference: 15. <author> M. Kellner, P. Feiler, A. Finkelstein, T. Katayama, L. Osterweil, M. Penedo, and H.D.Rombach. </author> <title> ISPW-6 Software Process Example. </title> <booktitle> In Proceedings of the First International Conference on Software Process, </booktitle> <address> Washington, DC, 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Our subsequent work mainly concentrated on specifying 1 the ISPW-6 software process problem example (ISPW-6 example for short) <ref> [15] </ref>. As a result of this work, BM was specialised with some constructs specific to modelling software process. The details of this work have been described in [21]. <p> the fact that it is a well known example within the software process community, in this paper, we will still use this example to illustrate how to gradually develop a model using our approach. 8.1 Brief Description of the ISPW-6 Example A full description of the example is given in <ref> [15] </ref>. The core problem focuses on the designing, coding, unit testing, and management of a rather localized change to a software system. <p> In reality, the produced software should be supplied to some clients. Since this is not mentioned in <ref> [15] </ref>, it is not modelled here. ISPW 6-top provides two coperations for receiving information from CCB: reqfrCCB receives the requirements; canfrCCB receives cancellation. It also provides one action operation, produce, which produces the changes required.
Reference: 16. <author> C. Kung. </author> <title> Process Interface Modelling and Consistency Checking. </title> <journal> Journal of System and Software, </journal> <volume> 15 </volume> <pages> 185-191, </pages> <year> 1991. </year>
Reference-contexts: Since Slang is based on Petri-net, it should be possible to perform formal reasoning, however, it is not clear to the authors whether such a facility is provided by [3]. Work on consistency proof for refinement in Oikos is in development [2, 7]. In <ref> [16] </ref>, a method based on data flow diagram (DFD) for modelling process interface is defined. Although the method has a formal basis for process decomposition, it provides very limited expressive power. 9.3 Alternative Refinement In OBM, it is possible to have different refinements for the same abstract object.
Reference: 17. <author> L. Lamport. </author> <title> What Good is Temporal Logic? In R.E.A. </title> <editor> Mason, editor, </editor> <booktitle> Information Processing 83, </booktitle> <pages> pages 657-668, </pages> <publisher> IFIP, </publisher> <year> 1983. </year>
Reference-contexts: OBM is based on BM. The specification constructs are defined using a tempo-ral logic as it is a widely accepted formal tool for the specification and verification of concurrent systems <ref> [17] </ref>. 2 Brief Overview of OBM In OBM, a system is considered to be composed of components which may be executed concurrently. Each component provides a number of operations and contains some variables which can only be accessed by the operations. An operation may call other operations in other components.
Reference: 18. <author> A. Pnueli. </author> <title> The Temporal Semantics of Concurrent Programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 45-60, </pages> <year> 1981. </year>
Reference-contexts: The application of temporal logic in computer science was first introduced in [6]. A logic framework for reasoning about properties of concurrent programs was later developed by Pnueli <ref> [18] </ref>. Although that framework provided very powerful specification and verification tools for global programs, it did not provide much support for decomposition and composition of components. In [4], a compositional temporal logic proof system for specification and verification of concurrent program was introduced.
Reference: 19. <author> A.N. </author> <title> Prior. Time and Modality. </title> <publisher> Oxford University Press, </publisher> <year> 1957. </year>
Reference-contexts: The temporal semantics of boxed objects are defined in section 6.3. 6 Temporal Semantics Long before temporal logic was used to reason about programs, there was substantial work on temporal logic in philosophy for reasoning about time, e.g. <ref> [19, 20] </ref>. The application of temporal logic in computer science was first introduced in [6]. A logic framework for reasoning about properties of concurrent programs was later developed by Pnueli [18].
Reference: 20. <author> N. Rescher and A. Urquhart. </author> <title> Temporal Logic. </title> <publisher> Springer-Verlag Wien New York 1971. </publisher>
Reference-contexts: The temporal semantics of boxed objects are defined in section 6.3. 6 Temporal Semantics Long before temporal logic was used to reason about programs, there was substantial work on temporal logic in philosophy for reasoning about time, e.g. <ref> [19, 20] </ref>. The application of temporal logic in computer science was first introduced in [6]. A logic framework for reasoning about properties of concurrent programs was later developed by Pnueli [18].
Reference: 21. <author> I. Robertson J. Sa R.A. Snowdon R.F. Bruynooghe, R.M. Greenwood and B.C. Warboys. </author> <title> Towards a Total Process Modelling System: A Case Study Using ISPW-6. A Chapter in "Advances in Software Process Technology", </title> <note> to be published by Research Studies Press, J. Wiley, In Preparation, </note> <year> 1993. </year>
Reference-contexts: Our subsequent work mainly concentrated on specifying 1 the ISPW-6 software process problem example (ISPW-6 example for short) [15]. As a result of this work, BM was specialised with some constructs specific to modelling software process. The details of this work have been described in <ref> [21] </ref>. Since the ISPW-6 example was clearly described, the emphasis of the mod-elling exercise as reported in [21] was mainly on the representation of a model, but not so much on the development of a model. This emphasis is in fact also true with many existing process modelling techniques. <p> As a result of this work, BM was specialised with some constructs specific to modelling software process. The details of this work have been described in <ref> [21] </ref>. Since the ISPW-6 example was clearly described, the emphasis of the mod-elling exercise as reported in [21] was mainly on the representation of a model, but not so much on the development of a model. This emphasis is in fact also true with many existing process modelling techniques. However, in reality, processes are often unclear to the process participants and to the process modeller. <p> The BM stepper is implemented using the object-oriented proto-typing language Enact [13]. Our experience has shown that the BM stepper has proved to be useful with identifying errors and gaining confidences <ref> [21] </ref>. At the moment, the BM stepper only covers a sub-set of the operators used in OBM operation patterns. More work will be done to extend the BM stepper to include all the operators. 9.6 Tool Support OBM was first used in a case study reported in [25].
Reference: 22. <author> J. Sa. OBM: </author> <title> A Tutorial. </title> <type> Project Report, </type> <month> March </month> <year> 1993. </year>
Reference-contexts: Each supply coperation may be matched with a number of receive coperations. Operation patterns are defined using ordering expressions. Section 6.6 describes a subset of ordering expressions. The full definition can be found in <ref> [23, 22] </ref>. Operation patterns are defined in terms of coperation names. <p> The semantics of a subset of the ordering expression is defined in section 6.6. Due to lack of space, atmostone (X ) is not defined in this paper. Its definition can be found in <ref> [22] </ref>. 6.3 Temporal Semantics of Boxed Objects Let - Bobj denote the name of a boxed object containing two sub-components C 1 and C 2; - W , W 1 and W 2 denote the contexts of Bobj , C 1 and C 2 respectively; - Iops denote the internal coperations <p> The definitions of idle, interleave, synchronise and hide are given in <ref> [22] </ref>. 6.4 Temporal Semantics of Coperations The semantics of the different types of coperations are slightly different. To save space, only the semantics of passive compound operations are defined here. <p> When the executions of the calling component and the called component are synchronised on the send event and the corresponding accept event of op1, the value of apar-O1-op1 is passed on to the formal parameter of op1. This property is defined by the predicate synchronise in <ref> [22] </ref>. The definition of the receive event is similar. 6.6 Temporal Semantics of Ordering Expression In this section, only a subset of the ordering expression is defined. The full definition can be found in [22]. [[ffi]] C 4 fin ffi indicates the end. [[P1; P 2]] C 4 [[P 1]] C <p> This property is defined by the predicate synchronise in <ref> [22] </ref>. The definition of the receive event is similar. 6.6 Temporal Semantics of Ordering Expression In this section, only a subset of the ordering expression is defined. The full definition can be found in [22]. [[ffi]] C 4 fin ffi indicates the end. [[P1; P 2]] C 4 [[P 1]] C C [[P 2]] C P ; Q means that P is followed by Q . [[P 1 jj P2]] C 4 ([[P 1]] C1 C (idle (C 1) U fin)) ^ ([[P 2]] C
Reference: 23. <author> J. Sa and B.C. Warboys. </author> <title> Specifying Concurrent Object-based Systems using Combined Specification Notations. </title> <type> Technical Report UMCS-91-9-2, </type> <institution> Department of Computer Science, University of Manchester, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: 1 Background and Introduction In EWSPT'92 [10], we reported a small case study [24] which we undertook to investigate the application of an existing concurrent formal specification method, Base Model (BM) <ref> [23] </ref>, to process modelling. <p> Each supply coperation may be matched with a number of receive coperations. Operation patterns are defined using ordering expressions. Section 6.6 describes a subset of ordering expressions. The full definition can be found in <ref> [23, 22] </ref>. Operation patterns are defined in terms of coperation names.
Reference: 24. <author> J. Sa and B.C. Warboys. </author> <title> Integrating a Formal Specification Method with PML: A Case Study. </title> <booktitle> In Proceedings EWSPT'92, volume 635 of Lecture Notes in Computer Science, </booktitle> <pages> pages 106-123. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 1 Background and Introduction In EWSPT'92 [10], we reported a small case study <ref> [24] </ref> which we undertook to investigate the application of an existing concurrent formal specification method, Base Model (BM) [23], to process modelling.
Reference: 25. <author> J. Sa, B.C. Warboys and J.A. Keane. OBM: </author> <title> A Specification Method for Mod-elling Organisational Process. </title> <booktitle> Proceeding of Workshop on Constraint Processing at CSAM'93, </booktitle> <address> St. Petersburg, </address> <month> July </month> <year> 1993. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: At the moment, the BM stepper only covers a sub-set of the operators used in OBM operation patterns. More work will be done to extend the BM stepper to include all the operators. 9.6 Tool Support OBM was first used in a case study reported in <ref> [25] </ref>. The details of the proofs for the example described above and the one in [25] are very similar. In fact, for most part of the proof, it is only necessary to substitute the names. <p> More work will be done to extend the BM stepper to include all the operators. 9.6 Tool Support OBM was first used in a case study reported in <ref> [25] </ref>. The details of the proofs for the example described above and the one in [25] are very similar. In fact, for most part of the proof, it is only necessary to substitute the names. This similarity suggests that tools may be built to assist the proofs. 9.7 Executable Specifications The BM stepper allows us to simulate simple operation patterns.
References-found: 25

