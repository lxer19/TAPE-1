URL: ftp://ftp.cs.vu.nl/pub/papers/theory/IR-434.ps.Z
Refering-URL: http://www.cs.vu.nl/vakgroepen/ti/ftpindex.html
Root-URL: 
Email: email: ariola@cs.uoregon.edu  email: sccblom@cs.vu.nl  
Title: Lambda Calculi plus Letrec  
Author: Zena M. Ariola Stefan Blom 
Date: October 14, 1997  
Address: OR 97401, USA  Boelelaan 1081a, 1081 HV Amsterdam  
Affiliation: Department of Computer Information Sciences University of Oregon. Eugene,  Department of Mathematics and Computer Science Vrije Universiteit, De  
Abstract: Part I: We establish an isomorphism between the well-formed cyclic lambda-graphs and their syntactic representations. To define the well-formed cyclic lambda-graphs we introduce the notion of a scoped lambda-graph. The well-formed lambda-graphs are those that have associated scoped lambda-graphs. The scoped lambda-graphs are represented by terms defined over lambda calculus extended with the letrec construct. On this set of terms we define a sound and complete axiom system (the representational calculus) that equates different representations of the same scoped lambda-graph. Since a well-formed lambda-graph can have different scoped lambda-graphs associated to it, we extend the representational calculus with axioms that equate different representations of the same well-formed graph. Finally, we consider the unwinding of well-formed graphs to possibly infinite trees and give a sound and complete axiomatization of tree unwinding. Part II: We add computational power to our graphs and terms by defining fi-reduction on scoped lambda-graphs and its associated notion on terms. The representational axiom system developed in the first part combined with fi-reduction constitutes our cyclic extension of lambda calculus. In contrast to current theories, which impose restrictions on where the rewriting can take place, our reduction theory is very liberal, e.g., it allows rewriting under lambda-abstractions and on cycles. As shown previously, the reduction theory is non-confluent. We thus introduce an approximate notion of confluence, which guarantees uniqueness of infinite normal forms. We show that the infinite normal form defines a congruence on the set of terms. We relate our cyclic lambda calculus to the plain lambda calculus and to the infinitary lambda calculi. We conclude by presenting a variant of our cyclic lambda calculus, which follows the tradition of the explicit substitution calculi. Part III: Since most implementations of non-strict functional languages rely on sharing to avoid repeating computations, we develop a variant of our cyclic lambda calculus that enforces the sharing of computations and show that the two calculi are observationally equivalent. For reasoning about strict languages we develop a call-by-value variant of the sharing calculus. We state the difference between strict and non-strict computations in terms of different garbage collection rules. We relate the call-by-value calculus to Moggi's computational lambda calculus and to Hasegawa's calculus. Note: The research of the first author is supported by NSF grants CCR-9410237 and CCR-9624711. The second author was partially supported by NWO grants SIR 13-3416 and SIR 13-3908 and by NSF grant CCR-9624711. This work has appeared as technical report CIS-TR-97-05, department of computer and information science, University of Oregon. A shorter version of this paper appears in the Proceedings of TACS '97 as "Cyclic Lambda Calculi" [AB97]. 
Abstract-found: 1
Intro-found: 1
Reference: [AA95] <author> Z. M. Ariola and Arvind. </author> <title> Properties of a first-order functional language with sharing. </title> <journal> Theoretical Computer Science, </journal> <volume> 146 </volume> <pages> 69-108, </pages> <year> 1995. </year>
Reference-contexts: Consider the reduction given in Fig. 2. If the cyclic graph on the left-hand side of the reduction reduces to itself then confluence is lost (see <ref> [AA95] </ref>). A more thorough discussion of the black hole is given in [AKK + 94].
Reference: [AAH + 93] <author> Arvind, L. Augusston, J. Hicks, R. S. Nikhil, S. Peyton-Jones, J. Stoy, and W. Williams. </author> <note> pH: </note>
Reference-contexts: proof of Lemma 17.4 only uses steps from the shared evaluation calculus. 17.2 Lazy and lenient strategies of ffi share ffi share captures the essence of lazy languages, such as Haskell [HPJW + 92], and of the functional core of lenient languages, such as Id [Nik91, AMNS97] and Parallel Haskell <ref> [AAH + 93] </ref>. We substantiate our claim by showing that both the lazy and lenient strategies are complete with respect to different observations.
References-found: 2

