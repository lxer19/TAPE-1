URL: ftp://cse.ogi.edu/pub/pacsoft/papers/ppiso.ps
Refering-URL: http://www.cse.ogi.edu/~walton/pub.html
Root-URL: http://www.cse.ogi.edu
Title: Generating the Parser-Pretty-Printer Isomorphism (Correct-by-Construction Proofs of Properties of Domain-Specific Language)  
Author: Lisa A. Walton P. O. 
Keyword: Application Generators, Domain-Specific Languages, Denotational Semantics, Monads.  
Address: Box 91000, Portland, OR 97291-1000 USA  
Affiliation: Pacific Software Research Center Department of Computer Science and Engineering Oregon Graduate Institute of Science and Technology  
Email: walton@cse.ogi.edu  
Web: http://www.cse.ogi.edu/PacSoft  
Date: August 30, 1998  
Abstract: A Domain-Specific Language (DSL) is a small, usually declarative, language expressive over the distinguishing characteristics of a set of programs in a particular problem domain. Often they are used as input to application generators that create program instances possessing the distinguishing characteristics described in input specifications. When reasoning about the correctness of a generated application with respect to some criteria, it quite useful to be able to utilize the logic of the generator (the semantics) to prove that any generated application must satisfy the correctness criteria. This paper describes how classical techniques in language design and formal methods can be utilized in the development of a DSL that meets certain correctness criteria. Specifically, we take a small but real DSL, give it a semantics, and use the logic of the DSL semantics to prove that certain properties are true for any application produced by the generator. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Balzer, M. Feather, N. Goldman, and D. Wile. </author> <title> Domain specific notations for command and control message processing. </title> <type> Technical report, </type> <institution> USC/Information Science Institute, </institution> <address> 4676 Admiralty Way, Marina del Rey CA 90292, </address> <year> 1994. </year>
Reference-contexts: We chose MSL to demonstrate our approach to DSL design because it is * A successful solution to a real problem that has been well-studied by a variety of groups <ref> [13, 1] </ref> * A tractable problem that exposes non-trivial issues * A representative example of a larger class of data formatting DSLs The MSL example demonstrates an approach that supports safe semantic mod ifications and illustrates several reusable techniques including: * Semantics-based Language Design * Modeling Effects and Effect Interactions with
Reference: [2] <author> O Danvy, J Koslowski, and K Malmkjaer. </author> <title> Compiling monads. </title> <type> Technical Report CIS-92-3, </type> <institution> Kansas State University, Manhattan, Kansas, </institution> <month> December 91. </month>
Reference-contexts: They utilize monads and monad transformers. 4 3.0.1 Monads and Monad Constructors Introduced to the functional community by Moggi [12, 11], popularized by Wadler [16, 17], and since used by many others <ref> [2, 6, 15, 5, 9, 7] </ref> monads are particularly appropriate for structuring the semantics of DSLs because they make a clear separation of control (not usually explicit in the syntax of DSLs) and data.
Reference: [3] <author> David Espinosa. </author> <title> Modular denotational semantics. </title> <type> Technical report, </type> <institution> Columbia University, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Monad transformers (or constructors), were first described by Moggi [12], used in modular semantics by Espinosa <ref> [3, 4] </ref>, and incorporated into interpreters by Liang, Hudak, and Jones [14]. They are particularly useful for structuring extensible semantics because one can change the base monad without changing the overall structure of the semantics.
Reference: [4] <author> David Espinosa. </author> <title> Semantic Lego. </title> <note> http://www-swiss.ai.mit.edu/ftpdir/users/dae/home.html, January 1994. </note>
Reference-contexts: Monad transformers (or constructors), were first described by Moggi [12], used in modular semantics by Espinosa <ref> [3, 4] </ref>, and incorporated into interpreters by Liang, Hudak, and Jones [14]. They are particularly useful for structuring extensible semantics because one can change the base monad without changing the overall structure of the semantics.
Reference: [5] <author> M. M. Fokkinga. </author> <title> Monadic maps and folds for arbitrary datatypes. </title> <institution> Memoranda Informatica 94-28, University of Twente, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: They utilize monads and monad transformers. 4 3.0.1 Monads and Monad Constructors Introduced to the functional community by Moggi [12, 11], popularized by Wadler [16, 17], and since used by many others <ref> [2, 6, 15, 5, 9, 7] </ref> monads are particularly appropriate for structuring the semantics of DSLs because they make a clear separation of control (not usually explicit in the syntax of DSLs) and data.
Reference: [6] <author> Graham Hutton. </author> <title> Higher order functions for parsing. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3) </volume> <pages> 323-343, </pages> <year> 1992. </year>
Reference-contexts: They utilize monads and monad transformers. 4 3.0.1 Monads and Monad Constructors Introduced to the functional community by Moggi [12, 11], popularized by Wadler [16, 17], and since used by many others <ref> [2, 6, 15, 5, 9, 7] </ref> monads are particularly appropriate for structuring the semantics of DSLs because they make a clear separation of control (not usually explicit in the syntax of DSLs) and data.
Reference: [7] <author> Graham Hutton and Erik Meijer. </author> <title> Monadic combinator parsers. </title> <type> Technical report, </type> <institution> University of Nottingham, </institution> <year> 1996. </year> <month> NOTTCS-TR-96-4. </month>
Reference-contexts: The denotational monadic semantics for the generator takes a MSL specification and produces both a parser and unparser for the set of data corresponding to the specification. The generated parsers will be instances of monadic parser combinators <ref> [7] </ref>, higher-order functions that implement grammar constructions such as sequencing and choice that are used to build recursive descent parsers. <p> They utilize monads and monad transformers. 4 3.0.1 Monads and Monad Constructors Introduced to the functional community by Moggi [12, 11], popularized by Wadler [16, 17], and since used by many others <ref> [2, 6, 15, 5, 9, 7] </ref> monads are particularly appropriate for structuring the semantics of DSLs because they make a clear separation of control (not usually explicit in the syntax of DSLs) and data.
Reference: [8] <author> Richard B. Kieburtz, Laura McKinney, Jeffrey Bell, James Hook, Alex Ko-tov, Jeffrey Lewis, Dino Oliva, Tim Sheard, Ira Smith, and Lisa Walton. </author> <title> A software engineering experiment in software component generation. </title> <booktitle> In 18th International Conference in Software Engineering, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: Our primary goal was to build a generator that was correct, robust, and usable. These criteria were met, as demonstrated in a live-subject experiment documented by Kieburtz, McKinney, and others <ref> [8] </ref>. The software engineering processes followed are explained by Widen and Hook [21], and the full language design process by Walton and Hook [20].
Reference: [9] <author> John Launchbury and Simon L. Peyton-Jones. </author> <title> State in haskell. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 293-342, </pages> <month> December </month> <year> 1995. </year> <month> pldi94. </month>
Reference-contexts: They utilize monads and monad transformers. 4 3.0.1 Monads and Monad Constructors Introduced to the functional community by Moggi [12, 11], popularized by Wadler [16, 17], and since used by many others <ref> [2, 6, 15, 5, 9, 7] </ref> monads are particularly appropriate for structuring the semantics of DSLs because they make a clear separation of control (not usually explicit in the syntax of DSLs) and data.
Reference: [10] <author> Jeffrey R. Lewis. </author> <title> A specification for an MTV generator. </title> <type> Technical Report 94-003, </type> <institution> Department of Computer Science and Engineering, Oregon Graduate Institute, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: Period 3 2.2 Requirements of an MTV Generator Our solution to developing software in this domain is to build an application generator that produces MTV modules (message translators) from formal specifications. The following design requirements for a generator were obtained from a domain analysis performed by Lewis <ref> [10] </ref>. * The DSL should be usable by domain experts (i.e. readily comprehensible to users familiar with their current informal specification documents) * Given a specification, the generator must produce a module that Distinguishes between valid and invalid messages of the specified type.
Reference: [11] <author> E. Moggi. </author> <title> Notions of computations and monads. </title> <booktitle> Information and Computations, </booktitle> <month> July </month> <year> 1991. </year>
Reference-contexts: The generated parsers will be instances of monadic parser combinators [7], higher-order functions that implement grammar constructions such as sequencing and choice that are used to build recursive descent parsers. They utilize monads and monad transformers. 4 3.0.1 Monads and Monad Constructors Introduced to the functional community by Moggi <ref> [12, 11] </ref>, popularized by Wadler [16, 17], and since used by many others [2, 6, 15, 5, 9, 7] monads are particularly appropriate for structuring the semantics of DSLs because they make a clear separation of control (not usually explicit in the syntax of DSLs) and data.
Reference: [12] <author> Eugenio Moggi. </author> <title> An abstract view of programming languages. </title> <type> Technical Report LFCS-90-113, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: The generated parsers will be instances of monadic parser combinators [7], higher-order functions that implement grammar constructions such as sequencing and choice that are used to build recursive descent parsers. They utilize monads and monad transformers. 4 3.0.1 Monads and Monad Constructors Introduced to the functional community by Moggi <ref> [12, 11] </ref>, popularized by Wadler [16, 17], and since used by many others [2, 6, 15, 5, 9, 7] monads are particularly appropriate for structuring the semantics of DSLs because they make a clear separation of control (not usually explicit in the syntax of DSLs) and data. <p> Monad transformers (or constructors), were first described by Moggi <ref> [12] </ref>, used in modular semantics by Espinosa [3, 4], and incorporated into interpreters by Liang, Hudak, and Jones [14]. They are particularly useful for structuring extensible semantics because one can change the base monad without changing the overall structure of the semantics.
Reference: [13] <author> Plinta, Lee, and Rissman. </author> <title> A model solution for C 3 I message translation and validation. </title> <type> Technical report, </type> <institution> Software Engineering Institute, Carnegie Mellon University, </institution> <month> December </month> <year> 1989. </year> <note> CMU/SEI-89-TR-12 ESD-89-TR-20. </note>
Reference-contexts: We chose MSL to demonstrate our approach to DSL design because it is * A successful solution to a real problem that has been well-studied by a variety of groups <ref> [13, 1] </ref> * A tractable problem that exposes non-trivial issues * A representative example of a larger class of data formatting DSLs The MSL example demonstrates an approach that supports safe semantic mod ifications and illustrates several reusable techniques including: * Semantics-based Language Design * Modeling Effects and Effect Interactions with
Reference: [14] <author> Paul Hudak Sheng Liang and Mark Jones. </author> <title> Monad transformers and modular interpreters. </title> <booktitle> In Proceedings of the 22nd ACM-SIGACT Symposium on the Principles of Programming Langauges, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: Monad transformers (or constructors), were first described by Moggi [12], used in modular semantics by Espinosa [3, 4], and incorporated into interpreters by Liang, Hudak, and Jones <ref> [14] </ref>. They are particularly useful for structuring extensible semantics because one can change the base monad without changing the overall structure of the semantics.
Reference: [15] <author> Guy Steele. </author> <title> Building interpreters by composing monads. </title> <booktitle> In 21st Annual ACM Symposium on Principles of Programming Languages (POPL'94), </booktitle> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: They utilize monads and monad transformers. 4 3.0.1 Monads and Monad Constructors Introduced to the functional community by Moggi [12, 11], popularized by Wadler [16, 17], and since used by many others <ref> [2, 6, 15, 5, 9, 7] </ref> monads are particularly appropriate for structuring the semantics of DSLs because they make a clear separation of control (not usually explicit in the syntax of DSLs) and data.
Reference: [16] <author> P. Wadler. </author> <title> Comprehending monads. </title> <booktitle> Proceedings of the 1990 ACM Symposium on Lisp and Functional Programming, </booktitle> <year> 1990. </year> <month> 12 </month>
Reference-contexts: They utilize monads and monad transformers. 4 3.0.1 Monads and Monad Constructors Introduced to the functional community by Moggi [12, 11], popularized by Wadler <ref> [16, 17] </ref>, and since used by many others [2, 6, 15, 5, 9, 7] monads are particularly appropriate for structuring the semantics of DSLs because they make a clear separation of control (not usually explicit in the syntax of DSLs) and data.
Reference: [17] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: They utilize monads and monad transformers. 4 3.0.1 Monads and Monad Constructors Introduced to the functional community by Moggi [12, 11], popularized by Wadler <ref> [16, 17] </ref>, and since used by many others [2, 6, 15, 5, 9, 7] monads are particularly appropriate for structuring the semantics of DSLs because they make a clear separation of control (not usually explicit in the syntax of DSLs) and data.
Reference: [18] <author> Lisa Walton. </author> <title> The semantics of message specification langauge MSL. </title> <type> Technical report, </type> <institution> Oregon Graduate Institute, </institution> <year> 1997. </year>
Reference-contexts: In the next two sections we show how to weaken these theorems to establish some correctness properties that are validatable. The complete proofs of all of the theorems below proceed by induction over the structure of Expressions E, and are available in a technical report <ref> [18] </ref>. 4.1 Modeling Simple Exceptions In this section we define theorems that are as close to our ideal theorems as possible for parsers utilizing a model of simple exceptions. The UnparseParse Theorem states that parsing an unparsed value results in the original value.
Reference: [19] <author> Lisa Walton and James Hook. </author> <title> A definition of MSL, a domain-specific design language for message translation and validation. </title> <type> Technical report, </type> <institution> Oregon Graduate Institute, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: For example, ENat 2 is an expression denoting the following: 1. fn j 0 n 3g (set of natural numbers representable in 2 bits) 2. The relation specified by the following Nat, bit sequence pairs f (00; 0); (01; 1); (10; 2); (11; 3)g. A type checker for MSL <ref> [19] </ref> verifies that expressions can be given the first kind of meaning, and a parser/unparser generator yields a pair of functions corresponding to the relationship between representations.
Reference: [20] <author> Lisa Walton and James Hook. </author> <title> The design of message specification language MSL. </title> <type> Technical report, </type> <institution> Oregon Graduate Institute, </institution> <year> 1997. </year> <note> ftp://cse.ogi.edu/pub/pacsoft/papers/msl rev.ps. </note>
Reference-contexts: These criteria were met, as demonstrated in a live-subject experiment documented by Kieburtz, McKinney, and others [8]. The software engineering processes followed are explained by Widen and Hook [21], and the full language design process by Walton and Hook <ref> [20] </ref>. This paper concentrates on one primary aspect of the DSL design process, namely, developing modular denotational monadic semantics that support defining and proving appropriate correctness criteria for application generators in these kinds of domains. <p> occurred. * The module must process and return valid messages in their original formats The input to our MTV generator is a DSL for describing data, Message Specification Language. 3 Message Specification Language (MSL) The full MSL language is expressive over the complete range of information provided in an ICD <ref> [20] </ref>. However, to illustrate our approach here we focus on the sub-language of expressions used to denote the structure and (to a certain extent) the type of messages. It captures the information provided in the Field Size and Values sections exemplified in Figure 2.
Reference: [21] <author> Tanya Widen and James Hook. </author> <title> Software design automation: Language design in the context of domain engineering. </title> <booktitle> Proceedings of the Tenth International Conference on Software Engineering and Knowledge Engineering, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: Our primary goal was to build a generator that was correct, robust, and usable. These criteria were met, as demonstrated in a live-subject experiment documented by Kieburtz, McKinney, and others [8]. The software engineering processes followed are explained by Widen and Hook <ref> [21] </ref>, and the full language design process by Walton and Hook [20]. This paper concentrates on one primary aspect of the DSL design process, namely, developing modular denotational monadic semantics that support defining and proving appropriate correctness criteria for application generators in these kinds of domains.
References-found: 21

