URL: http://swarm.cs.wustl.edu/csg/papers/1993-1.ps.Z
Refering-URL: http://swarm.cs.wustl.edu/cgi-bin/pubs/papers/
Root-URL: http://www.cs.wustl.edu
Title: A Taxonomy of Program Visualization Systems  
Author: Gruia-Catalin Roman Kenneth C. Cox 
Date: Printed June 30, 1993  February 1993  
Address: IN ST LOUIS  Saint Louis, MO 63130-4899 One Brookings Drive Campus Box 1045  
Affiliation: WASHINGTON UNIVERSITY  Washington School of Engineering Applied Science  Washington University Department of Computer Science  
Pubnum: WUCS-93-22  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Brown, M. H., </author> <title> Exploring Algorithms using Balsa-II, </title> <journal> IEEE Computer, </journal> <volume> vol. 21, no. 5, </volume> <pages> pp. 14-36, </pages> <year> 1988. </year>
Reference-contexts: The authors hope that this taxonomy will increase awareness of the status of program visualization and prompt consideration of the applicability of program visualization to the activities of the larger computing community. We illustrate the taxonomy using three program visualization systems: Balsa <ref> [1] </ref> and its successor Zeus [2]; Tango [3]; and Pavane [4]. Additional examples of program visualization systems may be found in a two-volume collection of papers recently published by the IEEE Computer Society Press [5]. The three systems mentioned above, however, are representative of research trends in the area.
Reference: [2] <author> Brown, M. H., Zeus: </author> <title> A System for Algorithm Animation and Multi-View Editing, </title> <booktitle> 1991 IEEE Workshop on Visual Languages, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> Kobe, Japan, </address> <pages> pp. 4-9, </pages> <year> 1991. </year>
Reference-contexts: The authors hope that this taxonomy will increase awareness of the status of program visualization and prompt consideration of the applicability of program visualization to the activities of the larger computing community. We illustrate the taxonomy using three program visualization systems: Balsa [1] and its successor Zeus <ref> [2] </ref>; Tango [3]; and Pavane [4]. Additional examples of program visualization systems may be found in a two-volume collection of papers recently published by the IEEE Computer Society Press [5]. The three systems mentioned above, however, are representative of research trends in the area.
Reference: [3] <author> Stasko, J., </author> <title> TANGO: A Framework and System for Algorithm Animation, </title> <booktitle> Computer 23, Nr. </booktitle> <volume> 9, </volume> <pages> pp. 27-39, </pages> <year> 1990. </year>
Reference-contexts: The authors hope that this taxonomy will increase awareness of the status of program visualization and prompt consideration of the applicability of program visualization to the activities of the larger computing community. We illustrate the taxonomy using three program visualization systems: Balsa [1] and its successor Zeus [2]; Tango <ref> [3] </ref>; and Pavane [4]. Additional examples of program visualization systems may be found in a two-volume collection of papers recently published by the IEEE Computer Society Press [5]. The three systems mentioned above, however, are representative of research trends in the area.
Reference: [4] <author> Roman, G.-C., Cox, K. C., Wilcox, C. D., and Plun, J. Y., Pavane: </author> <title> a System for Declarative Visualization of Concurrent Computations, </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> vol. 3, </volume> <year> 1992. </year>
Reference-contexts: We illustrate the taxonomy using three program visualization systems: Balsa [1] and its successor Zeus [2]; Tango [3]; and Pavane <ref> [4] </ref>. Additional examples of program visualization systems may be found in a two-volume collection of papers recently published by the IEEE Computer Society Press [5]. The three systems mentioned above, however, are representative of research trends in the area.
Reference: [5] <author> Glinert, E. P. </author> <title> (editor), Visual Programming Environments, </title> <publisher> IEEE Computer Society Press Tutorial, </publisher> <year> 1990. </year>
Reference-contexts: We illustrate the taxonomy using three program visualization systems: Balsa [1] and its successor Zeus [2]; Tango [3]; and Pavane [4]. Additional examples of program visualization systems may be found in a two-volume collection of papers recently published by the IEEE Computer Society Press <ref> [5] </ref>. The three systems mentioned above, however, are representative of research trends in the area. A formal definition of program visualization as a mapping from programs to graphical representations (Section 2) supplies an objective technical justification for the taxonomy proposed in this paper.
Reference: [6] <author> Shu, N. C., </author> <title> Visual Programming, </title> <publisher> Van Nostrand Reinhold Company, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: Each published survey to date employs a different taxonomy. Shu <ref> [6] </ref> focuses on increasing degrees of sophistication exhibited by program visualization systems, from pretty-printing to complex algorithm animations. Myers [7] uses a classification along two axes: the aspect of the program that is illustrated (code, data, algorithm) and the display style (static or dynamic).
Reference: [7] <author> Myers, B. A., </author> <title> Taxonomies of visual programming and program visualization, </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> vol. 1, no. 1, </volume> <pages> pp. 97-123, </pages> <year> 1990. </year> <month> 14 </month>
Reference-contexts: Each published survey to date employs a different taxonomy. Shu [6] focuses on increasing degrees of sophistication exhibited by program visualization systems, from pretty-printing to complex algorithm animations. Myers <ref> [7] </ref> uses a classification along two axes: the aspect of the program that is illustrated (code, data, algorithm) and the display style (static or dynamic).
Reference: [8] <author> Brown, M., </author> <title> Perspectives on Algorithm Animation, </title> <booktitle> CHI'88 Human Factors in Computing Systems, </booktitle> <address> Washington, DC, USA, </address> <pages> pp. 33-38, </pages> <year> 1988. </year>
Reference-contexts: Shu [6] focuses on increasing degrees of sophistication exhibited by program visualization systems, from pretty-printing to complex algorithm animations. Myers [7] uses a classification along two axes: the aspect of the program that is illustrated (code, data, algorithm) and the display style (static or dynamic). Brown <ref> [8] </ref> proposes classifying algorithm animations along three axes: content (direct or synthetic representation of information about the program), transformation (discretely or smoothly changing images), and persistence (representations of the current state or of the entire execution history).
Reference: [9] <author> Stasko, T. J., and Patterson, C., </author> <title> "Understanding and Characterizing Software Visualization Systems," </title> <booktitle> Proceedings of the IEEE Workshop on Visual Languages, </booktitle> <month> September </month> <year> 1992, </year> <pages> pp. 3-10. </pages>
Reference-contexts: Brown [8] proposes classifying algorithm animations along three axes: content (direct or synthetic representation of information about the program), transformation (discretely or smoothly changing images), and persistence (representations of the current state or of the entire execution history). Finally, Stasko and Patterson <ref> [9] </ref> advocate a categorization scheme involving four dimensions: aspect, abstractness, animation, and automation (a new criterion not discussed by others).
Reference: [10] <author> Baecker, R. M., </author> <title> Sorting Out Sorting (film), Dynamic Graphics Project, </title> <institution> University of Toronto, Toronto, Canada, </institution> <year> 1981. </year>
Reference-contexts: For example, Balsa allows the animator to display the program code and highlight the current statement. Data state. Early data-visualization systems were hampered by the relatively slow processors available, necessitating somewhat oblique methods. Some early algorithm animations (e.g., Sorting Out Sorting <ref> [10] </ref>) were recorded on film frame-by-frame, with each frame representing the results of a single state snapshot. The visualizations in these films use a relatively low level of abstraction, typically extracting only scalar variables such as the values held in an array.
Reference: [11] <author> Helttula, E., Hyrskykari, A., and Raiha, K.-J., </author> <title> Graphical Specification of Algorithm Animations with ALADDIN, </title> <booktitle> in Proceedings of the 22nd Annual Conference on Systems Sciences, </booktitle> <pages> pp. 892-901, </pages> <year> 1988. </year>
Reference-contexts: However, declaration does have disadvantages. One problem typically arises when several primitive state changes should be considered as a single logical change and the image should not reflect the intermediate results. This can be avoided in several ways, such as the approach used by Aladdin <ref> [11] </ref> in which the relationship between program variables and graphical objects is defined declaratively, while code annotations indicate where the image should be updated. The Animus system [12] uses the declarative approach in two ways.
Reference: [12] <author> Duisberg, R. A., </author> <title> Animation Using Temporal Constraints, </title> <booktitle> Human Computer Interaction, </booktitle> <volume> vol. 3, </volume> <pages> pp. 257-3071, </pages> <year> 1987. </year>
Reference-contexts: This can be avoided in several ways, such as the approach used by Aladdin [11] in which the relationship between program variables and graphical objects is defined declaratively, while code annotations indicate where the image should be updated. The Animus system <ref> [12] </ref> uses the declarative approach in two ways. Each object can have a graphical representation that is automatically updated in response to changes in the object.

References-found: 12

