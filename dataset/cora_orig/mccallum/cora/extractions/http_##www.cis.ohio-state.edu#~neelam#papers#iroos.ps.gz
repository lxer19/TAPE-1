URL: http://www.cis.ohio-state.edu/~neelam/papers/iroos.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~neelam/papers/research.html
Root-URL: 
Email: e-mail: neelam@cis.ohio-state.edu  
Phone: Tel: (614) 292 1444. FAX: (614) 292 2911  
Title: Interaction Refinement in Object-Oriented Systems (Extended Abstract)  
Author: Neelam Soundarajan 
Address: 2015 Neil Avenue Mall Columbus, OH 43210 USA  
Affiliation: Computer and Information Science The Ohio State University  
Abstract: An OO designer typically starts with a high-level idea of the interactions between the key objects in the system. As the design progresses, the designer refines these interactions by identifying the exact operations of each object that other objects will invoke and the order of invocations, or by introducing new objects with appropriate operations to mediate the required interactions between existing objects, etc. These refinements are usually not recorded, so the rationale behind the design maybe lost. We motivate the notion of interaction refinement with a few examples, provide a precise definition of the concept, and develop a formalism that can be an important tool in recording and validating OO designs. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> B Boehm, </author> <title> A spiral model of software development and enhancement, </title> <journal> Software Eng. Notes, </journal> <volume> vol. 11, </volume> <year> 1986. </year>
Reference-contexts: We believe that the reason for the similarity is that both are refinements, with the added complexity in the case of analysis that questions of intention often arise. Thus one can recast software life-cycles such as Boehm's <ref> [1] </ref> spiral model in terms of different types of refinements. (The remark towards the end of the last paragraph that a step of SR may suggest a rethinking of a just-completed sequence of IR-steps, should perhaps be taken to mean that the spiral might occasionally loop back on itself, rather than
Reference: 2. <author> R Buhr, R Casselman, </author> <title> Use case maps for OO systems, </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: of refinement, we would probably refine this action into a sequence of three actions: Establish a connection between M 1 and M 2 , send the document from M 1 to M 2 , and 7 This example was suggested by the presentation by Buhr and Casselman in their book <ref> [2] </ref> on use-case-maps. Use-case-maps are essentially pictorial representations of use-cases. One important advantage of use-case-maps is that they make it easier to see the causal link between the various calls to operations in various objects more easily than if we looked at, say, a textual description of the corresponding use-case.
Reference: 3. <author> JV Guttag, </author> <title> Notes on type abstractions, </title> <journal> IEEE TSE, </journal> <volume> vol. 6, </volume> <year> 1980. </year>
Reference-contexts: be, how do we know that a particular refinement of the structure of a given object into certain specific component objects and the implementation of its operations in terms of operations on these components, results in the object exhibiting correct external behavior? This question has been addressed by many authors <ref> [3, 5, 6] </ref> and several formal systems proposed to establish the correctness of a structure-refinement-step. 1 1 The corresponding question for the case of procedural refinement was answered by the classic formalisms of Hoare, Dijkstra, and others. 2 It is worth noting at this point that the reason we prefer the
Reference: 4. <author> I Jacobson, </author> <title> Object-oriented software engineering, </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Indeed, once the interaction sequences have been fully refined, what we have is essentially the complete collection of use-cases <ref> [4] </ref> for the system; and as Jacobson [4] argues, use-cases play an important role in designing the system. <p> Indeed, once the interaction sequences have been fully refined, what we have is essentially the complete collection of use-cases <ref> [4] </ref> for the system; and as Jacobson [4] argues, use-cases play an important role in designing the system. <p> This latter requirement that only allowed sequences of S satisfy I is not critical to the development of our formalism. We decided to impose this requirement mainly in order to mirror the usual style in which use-cases are used <ref> [4] </ref>. We will return to this point shortly. Suppose we have another specification I 0 for S. <p> Our discussion of these examples is quite informal and far from complete, the main point of the section being to show the role IR plays in the design of these systems. 3.1 A Recycling System For our first example, we consider the `recycling system' from Jacobson <ref> [4] </ref>. The problem is to design a recycling machine that a customer can use to return recyclable objects such as cans and bottles. <p> The customer and the operator would be entirely unaware that a jam occurred or that the unjamming mechanism was invoked. The second approach would involve refining the interactions between the machine, the customer, and very likely, the operator. This is the approach that <ref> [4] </ref> takes. An alarm () operation is provided by the operator which is invoked (by the machine) if an item is stuck.
Reference: 5. <author> GT Leavens, </author> <title> WE Weihl, Specification and verification of object-oriented programs using supertype abstraction, </title> <journal> Acta Informatica, </journal> <volume> vol. 32, </volume> <year> 1995. </year>
Reference-contexts: be, how do we know that a particular refinement of the structure of a given object into certain specific component objects and the implementation of its operations in terms of operations on these components, results in the object exhibiting correct external behavior? This question has been addressed by many authors <ref> [3, 5, 6] </ref> and several formal systems proposed to establish the correctness of a structure-refinement-step. 1 1 The corresponding question for the case of procedural refinement was answered by the classic formalisms of Hoare, Dijkstra, and others. 2 It is worth noting at this point that the reason we prefer the
Reference: 6. <author> B Liskov, J Wing, </author> <title> A behavioral notion of subtyping, </title> <journal> ACM TOPLAS, </journal> <volume> vol. 16, </volume> <year> 1994. </year>
Reference-contexts: be, how do we know that a particular refinement of the structure of a given object into certain specific component objects and the implementation of its operations in terms of operations on these components, results in the object exhibiting correct external behavior? This question has been addressed by many authors <ref> [3, 5, 6] </ref> and several formal systems proposed to establish the correctness of a structure-refinement-step. 1 1 The corresponding question for the case of procedural refinement was answered by the classic formalisms of Hoare, Dijkstra, and others. 2 It is worth noting at this point that the reason we prefer the
Reference: 7. <author> N Soundarajan, </author> <title> Refining interactions in a distributed system, </title> <note> submitted to PODC '97. 12 </note>
Reference-contexts: Before concluding, it is worth noting that the considerations in this paper, in particular the 11 idea of interaction refinement are especially important in dealing with distributed objects <ref> [7] </ref>. In a system of distributed objects, much of the system's (important) activity consists of communications between the objects.
References-found: 7

