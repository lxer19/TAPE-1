URL: http://theory.lcs.mit.edu/~miccianc/papers/oblivious.ps
Refering-URL: http://theory.lcs.mit.edu/~cis/cis-publications.html
Root-URL: 
Email: email: miccianc@theory.lcs.mit.edu  
Title: Oblivious Data Structures: Applications to Cryptography  achieve privacy using Oblivious Trees instead of 2-3 Trees.  
Author: Daniele Micciancio 
Note: Goldwasser can be made  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: We introduce the notion of oblivious data structure, motivated by the use of data structures in cryptography. Informally, an oblivious data structure yields no knowledge about the sequence of operations that have been applied to it other than the final result of the operations. In particular we define Oblivious Tree, a data structure very similar to 2-3 Tree, but with the additional property that the only information conveyed by an Oblivious Tree is the set of values stored at its leaves. This property is achieved through the use of randomization by the update algorithms. We use the Oblivious Tree data structure to solve the privacy problem for incremental digital signatures raised by Bellare, Goldreich and Goldwasser. An incremental signing algorithm is private if the digital signature it outputs does not give any information on the sequence of edit operations that have been applied to produce the final document. We show how the incremental signature scheme of Bellare, Goldreich and 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Bellare, O. Goldreich and S. Goldwasser, </author> <title> "Incremental Cryptography and Application to Virus Protection", </title> <booktitle> Proc. of the 27th Ann. ACM Symp. on the Theory of Computing. </booktitle> <year> 1995, </year> <pages> pp 45-56. </pages>
Reference-contexts: Informally, a data structure is oblivious if it yields no knowledge about the sequence of operations that have been applied to it other than the final result of the operations. In particular we reduce the privacy problem for incremental digital signatures raised in <ref> [1] </ref> to the data structuring problem of designing efficient and oblivious search trees. We design Oblivious Tree, a data structure similar to 2-3 Tree [5], but with the additional property of being oblivious. <p> The Oblivious Tree data structure is defined and analyzed in Section 5. In Section 6 we describe a private incremental digital signature scheme based on the tree signature scheme of <ref> [1] </ref> which uses the Oblivious Tree data structure to achieve privacy. Section 7 concludes with possible extensions to this work. 2 Incremental Cryptography The idea of incremental cryptography, as outlined in [1], is to take advantage of the knowledge of the result of applying a cryptographic transformation (e.g. producing a digital <p> In Section 6 we describe a private incremental digital signature scheme based on the tree signature scheme of <ref> [1] </ref> which uses the Oblivious Tree data structure to achieve privacy. Section 7 concludes with possible extensions to this work. 2 Incremental Cryptography The idea of incremental cryptography, as outlined in [1], is to take advantage of the knowledge of the result of applying a cryptographic transformation (e.g. producing a digital signature) to a document D, to compute the cryptographic transformation of a different but related document D 0 quicker than performing it from scratch. <p> In some applications it is also prudent to assume that the adversary can tamper with the incremental signatures before the incremental signature algorithm is 2 applied to them. In <ref> [1] </ref> is defined a strong notion of security (tamper proof security) against these more powerful adversaries. Privacy: A second issue concerns the notion of privacy with respect to the intended recipient of the signed messages. <p> For example, suppose you are drafting a sensitive and important letter using the above mentioned text editor with incremental signature generation. When the final letter is complete, you certainly don't want the intermediate versions to be revealed through the signature. 3 3 Privacy and Oblivious Data Structure In <ref> [1] </ref>, Bellare, Goldreich and Goldwasser propose a digital signature method for which the signature algorithm is incremental. We shall call the digital signature of [1] a tree signature as it works essentially as follows. The document to be signed is first divided into blocks D [1]; D [2]; : : : <p> the final letter is complete, you certainly don't want the intermediate versions to be revealed through the signature. 3 3 Privacy and Oblivious Data Structure In <ref> [1] </ref>, Bellare, Goldreich and Goldwasser propose a digital signature method for which the signature algorithm is incremental. We shall call the digital signature of [1] a tree signature as it works essentially as follows. The document to be signed is first divided into blocks D [1]; D [2]; : : : ; D [n] which are signed using a standard (i.e., non incremental) digital signature algorithm and the resulting signatures stored at the leaves of <p> and Oblivious Data Structure In <ref> [1] </ref>, Bellare, Goldreich and Goldwasser propose a digital signature method for which the signature algorithm is incremental. We shall call the digital signature of [1] a tree signature as it works essentially as follows. The document to be signed is first divided into blocks D [1]; D [2]; : : : ; D [n] which are signed using a standard (i.e., non incremental) digital signature algorithm and the resulting signatures stored at the leaves of a search tree. <p> Nevertheless, we can prove that the final probability distribution is independent from the sequence of operations performed. This data structure solves the private signature problem introduced in <ref> [1] </ref>. Perhaps, more interestingly, Oblivious Trees offer advantages over other deterministic and probabilistic data structures, even from a purely algorithmic point of view. Algorithmic improvements: The expected height of an Oblivious Tree is log 2:5 n, slightly improving the log 2 n bound offered by 2-3 Tree. <p> Proposition 2 For all L = L <ref> [1] </ref>L [2] L [n], i n and b the following equalities hold between probability distributions: Insert (b; i; Create (L)) = Create (L [1]; : : : ; L [i]; b; L [i + 1]; : : : ; L [n]) Delete (i; Create (L)) = Create (L [1]; : : : ; L [i 1]; L [i + 1]; : : : ; L [n]): 11 Proof: (Sketch) We will prove only the <p> = L <ref> [1] </ref>L [2] L [n], i n and b the following equalities hold between probability distributions: Insert (b; i; Create (L)) = Create (L [1]; : : : ; L [i]; b; L [i + 1]; : : : ; L [n]) Delete (i; Create (L)) = Create (L [1]; : : : ; L [i 1]; L [i + 1]; : : : ; L [n]): 11 Proof: (Sketch) We will prove only the first equality. The proof of the second one is analogous. Consider how the nodes at level l are grouped by Insert. <p> M = finsert (b; i); delete (i)g, where insert (b; i) is the operation of inserting a new block b at position i of a text and delete (i) is the operation of deleting the ith block). 12 The following definitions are slightly different, but equivalent to those given in <ref> [1] </ref>, the main difference being that in [1] IncSig (see definition below) is defined as an interactive Turing machine, while here it is defined as a probabilistic algorithm. <p> where insert (b; i) is the operation of inserting a new block b at position i of a text and delete (i) is the operation of deleting the ith block). 12 The following definitions are slightly different, but equivalent to those given in <ref> [1] </ref>, the main difference being that in [1] IncSig (see definition below) is defined as an interactive Turing machine, while here it is defined as a probabilistic algorithm. <p> Another difference between our definition and that in <ref> [1] </ref> is that the current document is not input to IncSig. In fact, IncSig cannot read the whole document because otherwise it wouldn't be incremental. <p> We made an explicit parameter to IncSig to emphasize that resides externally to IncSig and a malicious user could alter the incrementable signature before issuing a command to IncSig in the attempt of breaking the scheme. As pointed out in <ref> [1] </ref>, in order to define a notion of security for an incremental signature scheme it is necessary to refer to the documents by name. The reason is that forgery is defined as the ability to produce a signature to a new document. <p> The scheme is essentially the same as the tree scheme described in <ref> [1] </ref>, with 2-3 Trees replaced by Oblivious Trees. Let (G; S; V ) be a standard (non incremental) signature scheme. <p> The proof of this theorem is essentially the same as that in <ref> [1] </ref> and is sketched in Appendix A. Theorem 2 For any update operations, the expected running time of IncSig is O (log n). Proof: The running time of a document modification operation is proportional to the running time of the corresponding insert or delete tree operation. <p> We call the resulting data structure Oblivious Tree (supporting insertion and deletion operations). 16 An efficient incremental digital signature scheme is defined using the Oblivious Tree data structure. The incremental signature scheme achieves tamper proof security and perfect privacy, and thus solves an open problem raised in <ref> [1] </ref>. Perfect privacy (see Definition 6) is defined with respect to a computationally unbounded adversary which chooses the sequence of edit operations to issue to the incremental signing algorithm, but which only sees the final result of the operations.
Reference: [2] <author> M. Bellare, O. Goldreich and S. Goldwasser, </author> <title> "Incremental Cryptography: The case of Hashing and Signing", </title> <booktitle> Advances in cryptology. Proceedings of the 14th Ann. International Conference. </booktitle> <pages> pp 216-233. </pages> <note> 1994 Springer-Verlag, LNCS 839. 17 </note>
Reference-contexts: We shall call the digital signature of [1] a tree signature as it works essentially as follows. The document to be signed is first divided into blocks D [1]; D <ref> [2] </ref>; : : : ; D [n] which are signed using a standard (i.e., non incremental) digital signature algorithm and the resulting signatures stored at the leaves of a search tree. <p> This concludes the running time analysis. Let's now get to obliviousness. We already said that the only thing to be proved is that the update algorithms preserve the probability distribution defined by Create. Proposition 2 For all L = L [1]L <ref> [2] </ref> L [n], i n and b the following equalities hold between probability distributions: Insert (b; i; Create (L)) = Create (L [1]; : : : ; L [i]; b; L [i + 1]; : : : ; L [n]) Delete (i; Create (L)) = Create (L [1]; : : :
Reference: [3] <author> W. Pugh, </author> <title> "Skip Lists: A Probabilistic Alternative to Balanced Trees", </title> <institution> Univ. of Mary--land, Tech. Report CS-TR-2190. </institution> <year> 1989. </year>
Reference-contexts: Therefore randomization is necessary to achieve a O (log (n)) running time for all update operations. The idea of using randomization in performing tree operations has apparently appeared in the data structure literature before (see [4] and <ref> [3] </ref>) in order to improve on the algorithmic aspects of the tree operations. Both randomized search trees ([4]) and skip lists ([3]) achieve O (log n) expected running time for insert and delete operations.
Reference: [4] <author> C. R. Aragon and R. G. Seidel, </author> <title> "Randomized Search Trees", </title> <booktitle> Proc. of the 30th Ann. IEEE Symp. on Foundations of Computer Science. </booktitle> <year> 1983. </year> <pages> pp 540-545. </pages>
Reference-contexts: Therefore randomization is necessary to achieve a O (log (n)) running time for all update operations. The idea of using randomization in performing tree operations has apparently appeared in the data structure literature before (see <ref> [4] </ref> and [3]) in order to improve on the algorithmic aspects of the tree operations. Both randomized search trees ([4]) and skip lists ([3]) achieve O (log n) expected running time for insert and delete operations.
Reference: [5] <author> A. Aho, J. Hopcroft and J. Ullman, </author> <title> "The design and analysis of computer algorithms", </title> <publisher> Addison Wesley, </publisher> <year> 1974. </year>
Reference-contexts: In particular we reduce the privacy problem for incremental digital signatures raised in [1] to the data structuring problem of designing efficient and oblivious search trees. We design Oblivious Tree, a data structure similar to 2-3 Tree <ref> [5] </ref>, but with the additional property of being oblivious. <p> Then each internal node is tagged with a (standard) digital signature of its children and an integer counting the number of leaves in the subtree rooted at that node. In particular they use 2-3 Trees <ref> [5] </ref> to maintain the tree balanced. For each basic edit operation (insertion or deletion of a sequence of blocks), the signature of the document can be updated using the corresponding update algorithm for 2-3 Tree and recomputing the signatures of the internal nodes that have been modified.
Reference: [6] <author> M. Wirsing, </author> <title> "Algebraic Specification", </title> <booktitle> in Handbook of Theoretical Computer Science. </booktitle> <editor> Edited by J. van Leeuwen. </editor> <booktitle> Elsevier 1990. </booktitle> <volume> Vol. B, Chapter 13, </volume> <pages> pp 677-788. </pages>
Reference: [7] <author> S. Goldwasser, S. Micali and R. L. Rivest, </author> <title> "A Digital Signature Scheme Secure Against Adaptive Chosen-Message Attacks", </title> <journal> SIAM Journal of Computing, </journal> <volume> 17(2), </volume> <year> 1988, </year> <pages> pp. 281-308. </pages>
Reference-contexts: Security: The most important issue concerns the definition of security against attacks from an outsider (the adversary) who does not know the secret key. In the standard notion of security <ref> [7] </ref> the adversary can get signatures to messages of its choice and then must produce a signature for a new message (see Section 6 for more details). <p> Vf Pk (m; ) = 1 iff is a possible output of Sig Sk (m)). The standard definition of security for a digital signature scheme (security against chosen message attack <ref> [7] </ref>) is that no probabilistic polynomial time algorithm A, capable of obtaining from Sig signatures of messages of its choice, can produce a forgery with non-negligible probability, i.e. a valid signature for a message which has not been previously signed by Sig.
Reference: [8] <author> B. Pfitzmann and M. Waidner, </author> <title> "How to Break and Repair a Provably Secure Untraceable Payment System", </title> <booktitle> Advances in Cryptology: Proceedings of the 11th Ann. International Conference. 1991, </booktitle> <publisher> LNCS 576, Springer-Verlag. </publisher> <pages> pp. 338-350. </pages>
Reference-contexts: However the tree scheme is not private: a tree signature gives information on how the corresponding document has been obtained. This is not the first time that the use of tree based signatures causes information leakage (see for example <ref> [8] </ref> where tree based signatures are shown inappropriate as "blind signatures" in Damgaard's payment scheme). We make the following key observation: the information about the previous versions of the signed document is given by the structure of the 2-3 Tree.
Reference: [9] <author> A. Andersson and T. Ottmann, </author> <title> "Faster Uniquely Represented Dictionaries", </title> <booktitle> Proc. of the 38th Ann. IEEE Symp. on Foundations of Computer Science. </booktitle> <year> 1991. </year> <month> pp.642-649. </month>
Reference-contexts: user being slowed down by the malicious behavior of another user accessing the same data structure, is not present. 4 Related work on Data Structures Oblivious Tree offers a probabilistic solution to the "uniquely represented dictionary" problem for which a deterministic (n 1=3 ) lower bound has been shown in <ref> [9] </ref>. Therefore randomization is necessary to achieve a O (log (n)) running time for all update operations.
References-found: 9

