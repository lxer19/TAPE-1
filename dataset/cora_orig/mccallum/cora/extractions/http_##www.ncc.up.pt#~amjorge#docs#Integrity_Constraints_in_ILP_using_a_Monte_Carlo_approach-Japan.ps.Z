URL: http://www.ncc.up.pt/~amjorge/docs/Integrity_Constraints_in_ILP_using_a_Monte_Carlo_approach-Japan.ps.Z
Refering-URL: http://www.ncc.up.pt/~amjorge/publications.html
Root-URL: 
Title: Integrity Constraints in ILP using a Monte Carlo approach  
Author: Alpio Jorge, Pavel B. Brazdil 
Keyword: Inductive Logic Programming, I ntegrity Constraints, Monte Carlo strategy.  
Abstract: Many state-of-the-art ILP systems require large numbers of negative examples to avoid overgeneralization. This is a considerable disadvantage for many ILP applications, namely indu ctive program synthesis where relativelly small and sparse example sets are a more realistic scenario. Integrity constraints are first order clauses that can play the role of negative examples in an inductive process. One integrity constraint can replace a long list of ground negative examples. However, checking the consistency of a program with a set of integrity constraints usually involves heavy the orem-proving. We propose an efficient constraint satisfaction algorithm that applies to a wide variety of useful integrity constraints and uses a Monte Carlo strategy. It looks for inconsistencies by ra ndom generation of queries to the program. This method allows the use of integrity constraints instead of (or together with) negative examples. As a consequence programs to induce can be specified more rapidly by the user and the ILP system tends to obtain more accurate definitions. Average running times are not greatly affected by the use of integrity constraints compared to ground negative examples. 
Abstract-found: 1
Intro-found: 1
Reference: [Aha et al.94] <author> Aha, D. W., Lapointe, S., Ling, C. X., </author> <title> Matwin S (1994): Inverting Implication with Small Training Sets, </title> <booktitle> in Proceedings of the European Conference on Machine Learning, </booktitle> <editor> ECML-94, ed. F. Bergadano and L. De Raedt, </editor> <publisher> Springer Verlag. </publisher>
Reference-contexts: This limits the usability of ILP systems when examples are manually provided by the user, as in the case of program synthesis. This problem already drew some attention from the ILP community. Some systems like CRUSTACEAN <ref> [Aha et al.94] </ref> employ a very strong language bias, which restricts the number of necessary negative examples. However, the system seems difficult to extend to handle a wider variety of logic programs. System FOIL [Quinlan89] a llows the use of a closed world assumption (CWA).
Reference: [Bergadano et al.95] <author> Bergadano, F., Gunneti, D. and Trinchero, U. </author> <year> (1993): </year> <title> The Difficulties of Learning Logic Programs with Cut, </title> <journal> in Journal of Artificial Intelligence Research 1, </journal> <pages> 91-107, </pages> <publisher> AI A ccess Foundation and Morgan Kaufmann Publishers. </publisher>
Reference: [Brazdil&Jorge94] <author> Brazdil, P., Jorge, A. </author> <year> (1994): </year> <title> Learning by Refining Algorithm Sketches, </title> <booktitle> in Proceedings of ECAI-94 , T. </booktitle> <editor> Cohn (ed.), </editor> <address> Amsterdam, The Netherlands. </address>
Reference-contexts: System SKILit [Jorge&Brazdil96] induces logic programs from positive examples, negative examples, input/output mode and type declarations, and also from algorithm sketches <ref> [Brazdil&Jorge94] </ref>, if available. This system co nstructs a logic program P by adding one clause C at each cycle to an initial theory P 0 . At each cycle, program P is also cleaned up for elimination of redundant clauses.
Reference: [DeRaedt et al.93] <author> De Raedt, L., Lavrac, N., Dzeroski, S. </author> <year> (1993): </year> <booktitle> Multiple Predicate Learning in Proceedings of IJCAI-93 , Chamberry, </booktitle> <address> France. </address>
Reference: [DeRaedt92] <author> De Raedt, L. </author> <year> (1992): </year> <title> Interactive Theory Revision:An Inductive Logic Programming Approach, </title> <publisher> Academic Press. </publisher>
Reference-contexts: Luc De Raedt proposed that an ILP . 1 LIACC-University of Porto, Rua do Campo Alegre, 823, 4150 PORTO, PORTUGAL. email: -amjorge, pbrazdil-@ncc.up.pt http://www.up.pt/liacc/ML system could use integrity constraints by checking that these are satisfied by any generated program <ref> [DeRaedt92] </ref>. Although integrity constraints are non-Horn clauses, plain SLDNF proof procedure can be a pplied to check the consistency of a logic program and a constraint by transforming the integrity constraint into a query and posing it to the logic pr ogram. <p> When negative information is represented by an integrity constraint I, satisfaction means that P is logically consistent with I. In the following we define the notions of satisfaction, violation and violating instance <ref> [DeRaedt92] </ref>. Definition 2: Given a constraint I = B 1 m 1 n and a program P, the constraint is satisfied by P if and only if the query B 1 m 1 n fails on P. If P does not satisfy I we say that P violates I. <p> This problem gets exp onentially hard as the arity of the predicate in the first literal increases. Little attention has been given to integrity co nstraints in machine learning, inductive logic pr ogramming included. Luc De Raedt used integrity constraints to enhance system CLINT <ref> [DeRaedt92] </ref>. The constraint handler used in CLINT employs the strategy defined above. For that reason, the search for a violating instance is inefficient. If a violating instance is found, CLINT tries to determine which predicate definition is wrong with the help of an oracle. <p> The first condition still imposes that the leftmost literal of the antecedent has predicate p/k. This guarantees that we can find an instance of the co nstraint by starting with a logical consequence of program P. The integrity constraints we handle are restrictive constraints in the sense given by <ref> [DeRaedt92] </ref>. Such constraints have the literals of the predicate being induced as antecedents. An example of a restrictive constraint for the predicate union/3 is union (A,B,C) member (X,A) fi member (X,C).
Reference: [Deville&Lau94] <author> Deville, Y., Lau, K.,(1994): </author> <title> Logic Program Synthesis in The Journal of Logic Programming, special issue Ten Years of Logic Programming, </title> <booktitle> volumes 19,20, </booktitle> <month> May/July </month> <year> 1994. </year>
Reference-contexts: 1. Introduction An Inductive Logic Programming (ILP) system generates logic programs from incomplete info rmation. This process can either be seen as concept formation from examples [Muggleton&DeRaedt94] or as program synthesis from incomplete specific ations <ref> [Deville&Lau94] </ref>. The information given to an ILP system includes positive examples, negative examples, auxiliary logic programs, etc. The output is a logic program that generalizes the positive examples while negative examples are used to r eject undesirable solutions, namely overgeneral programs.
Reference: [Hogger90] <author> Hogger, C. J. </author> <year> (1990): </year> <title> Essentials of Logic Programming, graduate texts in computer science series, </title> <publisher> Oxford University Press. </publisher>
Reference-contexts: In that sense MONIC is correct or sound. It does not find false inconsistencies. However, we can say that it is only as correct as the proof procedure we are using. To ensure correctness of the proof procedure a safe computation rule must be used <ref> [Hogger90] </ref>. As we saw above MONIC may fail to find a violating instance even if one exists. For that re ason it is incomplete. However, when MONIC finds no inconsistency we have an associated level of confidence ( a ).
Reference: [Idestam-Almquist96] <institution> Idestam-Almquist P (1996) Efficient Induction of Recursive Defin itions by Efficient Analysis of Saturations, </institution> , <note> in Advances in Inductive Logic Programming, </note> <editor> Ed. by Luc De Raedt, </editor> <publisher> IOS Press. </publisher>
Reference: [Jorge&Brazdil96] <author> Jorge, A. and Brazdil, P. </author> <year> (1996): </year> <title> Architecture for Iterative Learning of R ecursive Definitions, </title> <booktitle> in Advances in Inductive Logic Programming, </booktitle> <editor> Ed. by Luc De Raedt, </editor> <publisher> IOS Press. </publisher>
Reference-contexts: Regarding positive e xamples, some systems were proposed recently for the synthesis of logic programs from a small nu mber of positive examples [Aha et al.94,Idestam-Almquist96]. Our own system SKILit <ref> [Jorge&Brazdil96] </ref> handles the lack of crucial training positive examples (also known as the sparse or the incomplete example set problem ) by generating properties. These are clauses that ca pture regularities within the positive examples, ge neralize them, and enable the introduction of recursive clauses. <p> The problem with this kind of constraint handlers is their inefficiency. 3. MONIC: The Monte Carlo Integrity Checker In this section we describe MONIC, a Monte Carlo method for handling integrity constraints, which is then used together with our ILP system SKILit. System SKILit <ref> [Jorge&Brazdil96] </ref> induces logic programs from positive examples, negative examples, input/output mode and type declarations, and also from algorithm sketches [Brazdil&Jorge94], if available. This system co nstructs a logic program P by adding one clause C at each cycle to an initial theory P 0 . <p> Probability (length of list L=n)=0.2 for n=0,...,4. Probability (any element of a list L is d)=0.1 for d=0,...,9. This makes the probability to obtain the empty list equal to 0.2. The probability of obtaining the list [3] is 0.20.1=0.02. 4. Empirical Evaluation In <ref> [Jorge&Brazdil96] </ref> we evaluated our system SKILit by synthesizing definitons of predicates like delete/3, append/3, rv/2, union/3, among others. The experiments were made by randomly generating training sets, and then testing the produced definitions on randomly generated test sets.
Reference: [Manthey&Bry88] <author> Manthey, R. and Bry, F. </author> <year> (1988): </year> <title> SATCHMO: </title> <booktitle> a theorem prover impl emented in Prolog in proceedings of CADE 88 (9th Conference on Automated Deduction),Springer-Verlag. </booktitle>
Reference-contexts: This strategy, however, suffers from severe efficiency problems, since finding a violating i nstance of the constraint may involve trying all its possible instantiations. Other more sophisticated special integrity constraint handlers, like SATCHMO <ref> [Manthey&Bry88] </ref>, still seem computationally too heavy for pratical use in ILP. We propose a new method to handle integrity constraints. It enables the use of constraints in ILP systems without high efficiency costs. Experime ntal results show that we can induce more accurate recursive logic programs quite efficiently this way. <p> For that reason, the search for a violating instance is inefficient. If a violating instance is found, CLINT tries to determine which predicate definition is wrong with the help of an oracle. Other constraint handlers exist in the logic pr ogramming literature, like SATCHMO <ref> [Manthey&Bry88] </ref>, and the one by [Sadri&Kowalski88]. The problem with this kind of constraint handlers is their inefficiency. 3. MONIC: The Monte Carlo Integrity Checker In this section we describe MONIC, a Monte Carlo method for handling integrity constraints, which is then used together with our ILP system SKILit. <p> The number of queries was 100. 5. Related Work More general procedures for constraint sati sfaction exist, like Sadri and Kowalskis [Sadri&Kowalski88] and SATCHMO <ref> [Manthey&Bry88] </ref>. However, this kind of integrity checkers use a systematic approach to search for inconsistencies. To find a violating i nstance of an integrity constraint, an enormous number of different instanciations may have to be tried.
Reference: [Muggleton&DeRaedt94] <author> Muggleton, S., De Raedt, L., </author> <year> (1994): </year> <title> Inductive Logic Programming in The Journal of Logic Programming, special issue Ten Years of Logic Programming, </title> <booktitle> volumes 19,20, </booktitle> <month> May/July </month> <year> 1994. </year>
Reference-contexts: 1. Introduction An Inductive Logic Programming (ILP) system generates logic programs from incomplete info rmation. This process can either be seen as concept formation from examples <ref> [Muggleton&DeRaedt94] </ref> or as program synthesis from incomplete specific ations [Deville&Lau94]. The information given to an ILP system includes positive examples, negative examples, auxiliary logic programs, etc. The output is a logic program that generalizes the positive examples while negative examples are used to r eject undesirable solutions, namely overgeneral programs.
Reference: [Muggleton93] <author> Muggleton, S. </author> <year> (1993): </year> <title> Inductive Logic Programming: derivations, </title> <booktitle> successes and shortcomings in Proceedings of ECML-93, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference: [Muggleton95] <author> Muggleton, S. </author> <year> (1993): </year> <title> Stochastic Logic Programs: extended abstract in Proceedings of ILP-95 , Ed. by Luc De Raedt, </title> <type> Scientific Report, </type> <institution> Katholiek Universiteit Leuven. </institution>
Reference-contexts: This distribution is d efined by the ILP system designer or by the user himself. Currently we define the distribution of a set of terms by specifying the probability of obtaining terms of length 0,1,2,etc. One alternative for the definition of type distributions are stochastic logic program <ref> [Muggleton95] </ref>. Example: We define a distribution for the set of lists of length 0 to 4, with elements 0 to 9, as follows. Probability (length of list L=n)=0.2 for n=0,...,4. Probability (any element of a list L is d)=0.1 for d=0,...,9.
Reference: [Quinlan89] <author> Quinlan, J.R. </author> <year> (1990): </year> <title> Learning logical definitions from relations. </title> <booktitle> Machine Learning 5, </booktitle> <pages> 239-266. </pages>
Reference-contexts: This problem already drew some attention from the ILP community. Some systems like CRUSTACEAN [Aha et al.94] employ a very strong language bias, which restricts the number of necessary negative examples. However, the system seems difficult to extend to handle a wider variety of logic programs. System FOIL <ref> [Quinlan89] </ref> a llows the use of a closed world assumption (CWA). This technique is not practical in many learning situations since it forces the user to give a complete set of positive examples. A very promising alternative is the use of i ntegrity constraints.
Reference: [Quinlan93] <author> Quinlan, J.R. </author> <year> (1993): </year> <title> FOIL: A Mi dterm Report, </title> <booktitle> in Proceedings of ECML-93, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: To illustrate this problem we give two examples me ntioned in the literature: the ILP system FOIL is reported to learn predicate reverse/2 with 1560 to 92 796 negative examples <ref> [Quinlan93] </ref>; system CHILLIN [Zelle et al94] is reported to learn the predicate member/2 with an accuracy of about 50% given more than 80 negative examples. This limits the usability of ILP systems when examples are manually provided by the user, as in the case of program synthesis.
Reference: [Sadri&Kowalski88] <author> Sadri, F., Kowalski, R. </author> <year> (1988): </year> <title> A Theorem Proving Approach to Database Integrity in Deductive Databases and Logic Programming , ed. by Jack Minker, </title> <publisher> Morgan Kau fmann Publishers. </publisher>
Reference-contexts: For that reason, the search for a violating instance is inefficient. If a violating instance is found, CLINT tries to determine which predicate definition is wrong with the help of an oracle. Other constraint handlers exist in the logic pr ogramming literature, like SATCHMO [Manthey&Bry88], and the one by <ref> [Sadri&Kowalski88] </ref>. The problem with this kind of constraint handlers is their inefficiency. 3. MONIC: The Monte Carlo Integrity Checker In this section we describe MONIC, a Monte Carlo method for handling integrity constraints, which is then used together with our ILP system SKILit. <p> In the case of rv/2 learning times were practically the same, and in the case of qsort/2 there was a slow down of less than 20%. The number of queries was 100. 5. Related Work More general procedures for constraint sati sfaction exist, like Sadri and Kowalskis <ref> [Sadri&Kowalski88] </ref> and SATCHMO [Manthey&Bry88]. However, this kind of integrity checkers use a systematic approach to search for inconsistencies. To find a violating i nstance of an integrity constraint, an enormous number of different instanciations may have to be tried.
Reference: [Shapiro82] <author> Shapiro, E. Y., </author> <title> (1982) Algorithmic Program Debugging, </title> <publisher> MIT Press, </publisher> <address> Cambridge MA. </address>
Reference-contexts: However, this strategy does not seem to help in determining which predicate definition is wrong, when a viola ting instance is found. This credit assignment problem arises mainly in a multiple predicate learning situation and can be solved with the help of an oracle, as in CLINT or MIS <ref> [Shapiro82] </ref>. In single predicate learning situations as the ones considered in this paper, no credit assignment needs to be done. 8. Conclusion Integrity constraints can be efficiently used in ILP using MONIC, the Monte Carlo Integrity Checker we propose.
Reference: [Zelle et al94] <author> Zelle J M, Mooney R J, Konvisser J B, </author> <year> (1994): </year> <booktitle> Combining Top-down and Bottom-up Techniques in Inductive Logic Programming in Proceedings of the Eleventh International Conference on Machine Learning ML-94, </booktitle> <publisher> Morgan-Kaufmann. </publisher>
Reference-contexts: To illustrate this problem we give two examples me ntioned in the literature: the ILP system FOIL is reported to learn predicate reverse/2 with 1560 to 92 796 negative examples [Quinlan93]; system CHILLIN <ref> [Zelle et al94] </ref> is reported to learn the predicate member/2 with an accuracy of about 50% given more than 80 negative examples. This limits the usability of ILP systems when examples are manually provided by the user, as in the case of program synthesis.
References-found: 18

