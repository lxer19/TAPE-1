URL: ftp://ftp.cs.umd.edu/pub/papers/TRs/3243.ps.Z
Refering-URL: http://www.cs.umd.edu/projects/hermes/publications/abstracts/papers_akbiii.html
Root-URL: 
Email: fsibel; vsg@cs.umd.edu  
Title: Amalgamating Knowledge Bases, II: Algorithms, Data Structures, and Query Processing  
Author: Sibel Adal and V.S. Subrahmanian 
Address: College Park, Maryland 20742.  
Affiliation: Department of Computer Science Institute for Advanced Computer Studies Institute for Systems Research University of Maryland  
Abstract: Integrating knowledge from multiple sources is an important aspect of automated reasoning systems. In the first part of this series of papers, we presented a uniform declarative framework, based on annotated logics, for amalgamating multiple knowledge bases when these knowledge bases (possibly) contain inconsistencies, uncertainties, and non-monotonic modes of negation. We showed that annotated logics may be used, with some modifications, to mediate between different knowledge bases. The multiple knowledge bases are amalgamated by embedding the individual knowledge bases into a lattice. In this paper, we briefly describe an SLD-resolution based proof procedure that is sound and complete w.r.t. our declarative semantics. We will then develop an OLDT-resolution based query processing procedure, MULTI OLDT, that satisfies two important properties: (1) efficient reuse of previous computations is achieved by maintaining a table we describe the structure of this table and show that table operations can be efficiently executed, and (2) approximate, interruptable query answering is achieved, i.e. it is possible to obtain an "intermediate, approximate" answer from the QPP by interrupting it at any point in time during its execution. The design of the MULTI OLDT procedure will include: (1) development of data structures for tabling (substitution, truth value) pairs, and (2) the development of algorithms to incrementally and efficiently update the table.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal, R. Cochrane and B. Lindsay. </author> <title> (1991) On Maintaining Priorities in a Production Rule System, </title> <booktitle> Proc. </booktitle> <address> VLDB-91, pps 479-487. </address>
Reference-contexts: For instance, (T ; ) may be any one of the following: (1) Fuzzy Values: We can take T = <ref> [0; 1] </ref> the set of rea l numbers between 0 and 1 (inclusive) and to be the usual ordering on reals. (2) Time Points: We can take T to be the set TIME = 2 R + where R + is the set of non-negative real numbers , 2 R + <p> Time Points: We can take T to be the set TIME = 2 R + where R + is the set of non-negative real numbers , 2 R + is the power-set of the reals, and is the inclusion ordering. (3) Fuzzy Values + Time: We could take T = <ref> [0; 1] </ref>fiTIME and take to be the ordering: [u 1 ; T 1 ][u 2 ; T 2 ] iff u 1 u 2 and T 1 T 2 . Here u 1 ; u 2 are real numbers in the [0; 1] interval and T 1 ; T 2 are <p> Fuzzy Values + Time: We could take T = <ref> [0; 1] </ref>fiTIME and take to be the ordering: [u 1 ; T 1 ][u 2 ; T 2 ] iff u 1 u 2 and T 1 T 2 . Here u 1 ; u 2 are real numbers in the [0; 1] interval and T 1 ; T 2 are sets of real numbers. (4) Four-Valued Logic: Four valued logic [7, 19] uses the truth values FOUR = f?; t; f ; &gt;g ordered as follows: ?x and x&gt; for all x 2 FOUR. <p> For instance, if T = <ref> [0; 1] </ref>, and +; fl are preinterpreted annotation functions defined in the usual ways, and V is an annotation variable, then (V + 1) fl 0:5 is an annotation term. <p> If A is an atom (in the usual sense of logic), and is an annotation, then A : is an annotated atom. For example, when considering T = <ref> [0; 1] </ref>, the atom broken (c 1 ) : 0:75 may be used to say: "there is at least a 75% degree of certainty that component c 1 is broken." If T = [0; 1] fi TIME, then annotations are pairs, and an annotated atom like at robot (3; 5) : <p> For example, when considering T = <ref> [0; 1] </ref>, the atom broken (c 1 ) : 0:75 may be used to say: "there is at least a 75% degree of certainty that component c 1 is broken." If T = [0; 1] fi TIME, then annotations are pairs, and an annotated atom like at robot (3; 5) : [0:4; f1; 2; 3g] says that at each of the time points 1; 2; 3, there is at least a 40% certainty that the robot is at xy-coordinates (3; 5). <p> Kifer and Subrahmanian developed a formal model theory, proof theory, and fixpoint theory for GAPs that accurately captures the above-mentioned notion of `firability." In brief, an interpretation I assigns to each ground atom, an element of T . Intuitively, if T = <ref> [0; 1] </ref>, then the assignment of 0:7 to atom A means that according to interpretation I, A is true with certainty 70% or more. Interpretation 3 I satisfies a ground annotated atom A : iff I (A). <p> If A : is an atom over lattice T , V is a DNAME-variable, and D f1; : : :; n; sg, then A : [D; ] and A : [V; ] are called amalgamated atoms. Intuitively, if T = <ref> [0; 1] </ref>, the amalgamated atom at robot (3; 4) : [f1; 2; 3g; 0:8] says that according to the (joint) information of databases 1; 2 and 3, the degree of certainty that the robot is at location (3; 4) is 80% or more . <p> An amalgamated clause is a statement of the form: A 0 : [D 0 ; 0 ] A 1 : <ref> [D 1 ; 1 ] </ref> & : : :& A n : [D n ; n ] where A 0 : [D 0 ; 0 ]; : : : ; A n : [D n ; n ] are amalgamated atoms. <p> Mediator/Supervisory Database: Suppose DB 1 ; : : : ; DB n are GAPs. A supervisory database 1 S is a set of amalgamated clauses such that every ground instance of a clause in S is of the form: A 0 : [fsg; ] A 1 : <ref> [D 1 ; 1 ] </ref> & : : : & A n : [D n ; n ] where, for all 1 i (n + m), D i f1; : : :; n; sg. <p> In this paper, we will not study issues relating to implementing distributed mediators (though we are doing so in a separate, concurrent effort). 4 is replaced by the amalgamated clause, AT (C): A 0 : [fig; 0 ] A 1 : <ref> [fig; 1 ] </ref> & : : : & A n : [fig; n ]: We use AT (DB i ) to denote the set fAT (C) j C 2 DB i g. <p> that robot r1 moves right at time T and T + 1 with probabilities V 1 ; V 2 respectively, then the probability that it will continue to move right is a function, f , is some function of V 1 ; V 2 ." Using the truth value lattice <ref> [0; 1] </ref> fi 2 R + , we may encode this information as: at (r1; X + 2; Y ) : [f (V 1 ; V 2 ); fT + 2g] at (r1; X + 1; Y ) : [V 1 ; fT + 1g] & at (r1; X + 1; <p> : [1 f (V 1 ; V 2 ); fT + 2g] at (r1; X + 1; Y ) : [V 1 ; fT + 1g] & Here, T is a variable ranging over time points, and V; V 1 ; V 2 are variables ranging over the unit interval <ref> [0; 1] </ref>. <p> is at location (X + 1; Y ) at time (T + 1) with certainty V 1 , then the certainty of its being at location (X + 2; Y ) at time (T + 2) is f (V 1 ; V 2 ) where f is some function from <ref> [0; 1] </ref> fi [0; 1] to [0; 1]. The second clause says that the probability that the robot will be at location (X + 1; Y + 1) at time (T + 2) (i.e. it moves "down" instead of "right") is 1 f (V 1 ; V 2 ). <p> (X + 1; Y ) at time (T + 1) with certainty V 1 , then the certainty of its being at location (X + 2; Y ) at time (T + 2) is f (V 1 ; V 2 ) where f is some function from <ref> [0; 1] </ref> fi [0; 1] to [0; 1]. The second clause says that the probability that the robot will be at location (X + 1; Y + 1) at time (T + 2) (i.e. it moves "down" instead of "right") is 1 f (V 1 ; V 2 ). <p> Y ) at time (T + 1) with certainty V 1 , then the certainty of its being at location (X + 2; Y ) at time (T + 2) is f (V 1 ; V 2 ) where f is some function from <ref> [0; 1] </ref> fi [0; 1] to [0; 1]. The second clause says that the probability that the robot will be at location (X + 1; Y + 1) at time (T + 2) (i.e. it moves "down" instead of "right") is 1 f (V 1 ; V 2 ). <p> The truth value lattice being used in this example is <ref> [0; 1] </ref> fi 2 R + . An annotated atom of the form A : [u; t] intuitively says that "for all time points t fl 2 t, atom A is true with certainty u or more." The lattice ordering on [0; 1] fi 2 R + is defined as: [u <p> truth value lattice being used in this example is <ref> [0; 1] </ref> fi 2 R + . An annotated atom of the form A : [u; t] intuitively says that "for all time points t fl 2 t, atom A is true with certainty u or more." The lattice ordering on [0; 1] fi 2 R + is defined as: [u 1 ; t 1 ] [u 2 ; t 2 ] iff u 1 u 2 and t 1 t 2 . <p> Definition 5 Given a clause C of the form: A 0 : [D 0 ; 0 ] A 1 : <ref> [D 1 ; 1 ] </ref>& : : : &A n : [D n ; n ] the regular representation of C, denoted by C fl , is the expression: A 0 : EXP ([D 0 ; 0 ]) A 1 : EXP ([D 1 ; 1 ])& : : : &A <p> expansion form A : f s 1 (<ref> [D 1 ; 1 ] </ref>) is said to be an S-consequence of another atom B : f s 2 [D 2 ; 2 ] (denoted by B : f s 2 ([D 2 ; 2 ]) j= S A : f s 1 [D 1 ; 1 ]), iff any A-interpretation I that S-satisfies B : f s 2 ([D 2 ; 2 ]) also S-satisfies A : f s 1 ([D 1 ; 1 ]). <p> Definition 8 A query Q is a statement of the form: A 1 : <ref> [D 1 ; 1 ] </ref>& : : : &A n : [D m ; m ] where all the free variables of the query are assumed to be universally quantified 3 . <p> The negation of the above query is the statement (9)(A 1 : <ref> [D 1 ; 1 ] </ref>& : : : &A n : [D m ; m ]). <p> Definition 11 [32] Suppose Q is an amalgamated knowledge base. We may associate with Q, an operator, A Q , that maps A-interpretations to A-interpretations as follows. A Q (I)(A)(D) = tf j A : [D; ] B 1 : <ref> [D 1 ; 1 ] </ref>& : : : &B n : [D n ; n ]& not (B n+1 : [D n+1 ; n+1 ])& : : :&not (B n+m : [D n+m ; n+m ])g is a ground instance of a clause in Q and for all 1 i n, <p> Dubois, Lang and Prade [12], also suggest that formulas in knowledge bases can be annotated with, for each source, a lower bound of a degree of certainty associated with that source. The spirit behind their approach is similar to ours, though interest is restricted to the <ref> [0; 1] </ref> lattice, the stable and well-founded semantics are not addressed, and amalgamation theorems are not studied. However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. <p> The spirit behind their approach is similar to ours, though interest is restricted to the <ref> [0; 1] </ref> lattice, the stable and well-founded semantics are not addressed, and amalgamation theorems are not studied. However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. In [15], Fitting generalizes results in [35, 4], to obtain a well-founded semantics for bilattice-based logic programs. We have given a detailed comparison of our declarative framework with Fitting's in [32].
Reference: [2] <author> C. Baral, S. Kraus and J. Minker. </author> <title> (1991) Combining Multiple Knowledge Bases, </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 3, 2, </volume> <pages> pps 200-220. </pages>
Reference-contexts: 1], the atom broken (c 1 ) : 0:75 may be used to say: "there is at least a 75% degree of certainty that component c 1 is broken." If T = [0; 1] fi TIME, then annotations are pairs, and an annotated atom like at robot (3; 5) : <ref> [0:4; f1; 2; 3g] </ref> says that at each of the time points 1; 2; 3, there is at least a 40% certainty that the robot is at xy-coordinates (3; 5). <p> Intuitively, if T = [0; 1], the amalgamated atom at robot (3; 4) : <ref> [f1; 2; 3g; 0:8] </ref> says that according to the (joint) information of databases 1; 2 and 3, the degree of certainty that the robot is at location (3; 4) is 80% or more . <p> This asymmetry is a key distinction between our work and the concurrently developed work of [24]. For example, suppose we consider the lattice FOUR and consider the amalgamated annotations: <ref> [f1; 2; 3g; ft; &gt;g] </ref> and [f1; 3g; ff ; &gt;g], then S-INT ([f1; 2; 3g; ft; &gt;g]; [f1; 3g; ff ; &gt;g]) = [f1; 2; 3g; f&gt;g] but S-INT ([f1; 3g; ff ; &gt;g]; [f1; 2; 3g; ft; &gt;g]) is undefined. <p> For example, suppose we consider the lattice FOUR and consider the amalgamated annotations: [f1; 2; 3g; ft; &gt;g] and [f1; 3g; ff ; &gt;g], then S-INT ([f1; 2; 3g; ft; &gt;g]; [f1; 3g; ff ; &gt;g]) = <ref> [f1; 2; 3g; f&gt;g] </ref> but S-INT ([f1; 3g; ff ; &gt;g]; [f1; 2; 3g; ft; &gt;g]) is undefined. Using the concept of set expansions of amalgamated atoms, we now define the concept of a regular representation of a clause. <p> For example, suppose we consider the lattice FOUR and consider the amalgamated annotations: <ref> [f1; 2; 3g; ft; &gt;g] </ref> and [f1; 3g; ff ; &gt;g], then S-INT ([f1; 2; 3g; ft; &gt;g]; [f1; 3g; ff ; &gt;g]) = [f1; 2; 3g; f&gt;g] but S-INT ([f1; 3g; ff ; &gt;g]; [f1; 2; 3g; ft; &gt;g]) is undefined. Using the concept of set expansions of amalgamated atoms, we now define the concept of a regular representation of a clause. <p> Definition 7 An amalgamated atom in set expansion form A : f s 1 ([D 1 ; 1 ]) is said to be an S-consequence of another atom B : f s 2 <ref> [D 2 ; 2 ] </ref> (denoted by B : f s 2 ([D 2 ; 2 ]) j= S A : f s 1 [D 1 ; 1 ]), iff any A-interpretation I that S-satisfies B : f s 2 ([D 2 ; 2 ]) also S-satisfies A : f s <p> As a preview, we give a small example. Example 6 Consider the databases DB 1 ; DB 2 and DB 3 in the static robot example, and suppose we ask the query: can lif t (r1; b) : <ref> [f1; 2; 3g; V ] </ref>: The query Q says: "What is the maximal truth value V such that can lif t (r1; b) : [f1; 2; 3g; V ] can be concluded ?" Q fl is: can lif t (r1; b) : [f1; 2; 3g; T * V ] . <p> databases DB 1 ; DB 2 and DB 3 in the static robot example, and suppose we ask the query: can lif t (r1; b) : <ref> [f1; 2; 3g; V ] </ref>: The query Q says: "What is the maximal truth value V such that can lif t (r1; b) : [f1; 2; 3g; V ] can be concluded ?" Q fl is: can lif t (r1; b) : [f1; 2; 3g; T * V ] . Let us see what happens. 1. <p> the query: can lif t (r1; b) : [f1; 2; 3g; V ]: The query Q says: "What is the maximal truth value V such that can lif t (r1; b) : [f1; 2; 3g; V ] can be concluded ?" Q fl is: can lif t (r1; b) : <ref> [f1; 2; 3g; T * V ] </ref> . Let us see what happens. 1. <p> Let us see what happens. 1. Resolving this query with the (regular representation of the) first rule in DB 2 yields, as resolvent, Q fl can lif t (r1; b) : <ref> [f1; 2; 3g; (T * V ) " * t] </ref> _ weight (b; W ) : [f2g; T * t] _ W 50 : 2. <p> t (r1; b) : <ref> [f1; 2; 3g; (T * V ) " * t] </ref> _ weight (b; W ) : [f2g; T * t] _ W 50 : 2. Resolving this query with the (regular representation of the) second fact in DB 2 yields can lif t (r1; b) : [f1; 2; 3g; (T * V ) " * t] _ weight (b; 19) : [f2g; (T * t) " * t] _ 19 50 : As (T * t) " * t = ;, the atom weight (b; 19) : [(T * t) " * t] can be eliminated from <p> As (T * t) " * t = ;, the atom weight (b; 19) : [(T * t) " * t] can be eliminated from the resolvent, and the evaluable atom 19 50 may also be so eliminated, thus leaving us with the resolvent can lif t (r1; b) : <ref> [f1; 2; 3g; (T * V ) " * t] </ref> : Note that at this stage, we are in a position to conclude that V must be at least t for the following reasons: 16 * All atoms in the body of the first rule in DB 2 have been resolved <p> The initial query was: can lif t (r1; b) : <ref> [f1; 2; 3g; T * V ] </ref> : Initially both the table and the linked list of query atoms are both empty. We insert the node (can lif t (r1; b) : [f1; 2; 3g; V ] Entry 1) into QUERY. <p> The initial query was: can lif t (r1; b) : [f1; 2; 3g; T * V ] : Initially both the table and the linked list of query atoms are both empty. We insert the node (can lif t (r1; b) : <ref> [f1; 2; 3g; V ] </ref> Entry 1) into QUERY. <p> Atom V (*; ?) &gt; 0 nil nil 1 V 1 (*; ?) t 1 Entry 1 nil 2 V 2 (*; ?) t 1 Entry 1 nil 3 (fX = bg,nil) t 1 nil nil nil The atoms in QUERY are the following: (can lif t (r1; b) : <ref> [f1; 2; 3g; V ] </ref> Entry 1), (weight (b; W ) : [f2g; V 1 ] Entry 2), (leq (W; 50) : V 2 Entry 3). 2 5.3.1 Substitution and Truth Value Propagation. <p> Example 17 Consider example 6. We specify below, the information stored in the table, the QUERY and the GARBAGE lists immediately before the last step of example 6 is completed. QUERY (can lif t (r1; b) : <ref> [f1; 2; 3g; V ] </ref> Entry 1), (weight (b; W ) : [f2g; V 1 ] Entry 2), (leq (W; 50) : V 2 Entry 3), (temp (b; T ) : [f3g; V 3 ] Entry 5), (le (T; 60) : V 4 Entry 6), GARBAGE (), the table: Index Known <p> In fact, the approach of Whang et. al. is in the same spirit as that of metalogic programming discussed earlier. Whang et. al. do not give a formal semantics for multi-databases containing inconsistency and/or uncertainty and/or non-monotonicity and/or temporal information. Baral et. al. <ref> [2, 3] </ref> have developed algorithms for combining different logic databases which generalizes the update strategy by giving priorities to some updates (when appropriate) and as well as not giving priorities to updates (which corresponds to combining two theories without any preferences). <p> Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. [13, 14]). As we have shown in [32], our framework can express maximal consistency as well. <ref> [2, 3] </ref> do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [2, 3] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework is able to do so. <p> As we have shown in [32], our framework can express maximal consistency as well. <ref> [2, 3] </ref> do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [2, 3] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework is able to do so.
Reference: [3] <author> C. Baral, S. Kraus, J. Minker and V.S. Subrahmanian. </author> <title> (1992) Combining Knowledge Bases Consisting of First Order Theories, </title> <journal> Computational Intelligence, </journal> <volume> 8, 1, </volume> <pages> pps 45-71. </pages>
Reference-contexts: In fact, the approach of Whang et. al. is in the same spirit as that of metalogic programming discussed earlier. Whang et. al. do not give a formal semantics for multi-databases containing inconsistency and/or uncertainty and/or non-monotonicity and/or temporal information. Baral et. al. <ref> [2, 3] </ref> have developed algorithms for combining different logic databases which generalizes the update strategy by giving priorities to some updates (when appropriate) and as well as not giving priorities to updates (which corresponds to combining two theories without any preferences). <p> Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. [13, 14]). As we have shown in [32], our framework can express maximal consistency as well. <ref> [2, 3] </ref> do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [2, 3] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework is able to do so. <p> As we have shown in [32], our framework can express maximal consistency as well. <ref> [2, 3] </ref> do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [2, 3] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework is able to do so.
Reference: [4] <author> C. Baral and V.S. Subrahmanian. </author> <title> (19910 Dualities between Alternative Semantics for Logic Programming and Nonmonotonic Reasoning, </title> <booktitle> Proc. 1991 Intl. Workshop on Logic Programming and Nonmonotonic Reasoning, </booktitle> <address> MIT Press. </address> <note> Full version in: Journal of Automated Reasoning, 10, pps 339-420, </note> <year> 1993. </year>
Reference-contexts: However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. In [15], Fitting generalizes results in <ref> [35, 4] </ref>, to obtain a well-founded semantics for bilattice-based logic programs. We have given a detailed comparison of our declarative framework with Fitting's in [32]. Warren and his co-workers [10, 9] have studied OLDT-resolution for ordinary logic programs (both with,and without nonmonotonic forms of negation).
Reference: [5] <author> F. Bancilhon, D. Maier, Y. Sagiv and J. Ullman. </author> <title> (1986) Magic Sets and Other Strange Ways to Implement Logic Programs, </title> <booktitle> Proc. 5th Symp. on Principles of Database Systems, </booktitle> <address> pps 1-15. </address>
Reference-contexts: The theory and implementation of OLDT has been studied extensively by several researchers including Seki [28, 27] and Warren and his colleagues [9, 10]. Furthermore, it is known that OLDT and magic set computations <ref> [5, 6, 26] </ref> are essentially equivalent, though they differ in many (relatively minor) details.
Reference: [6] <author> C. Beeri and R. Ramakrishnan. </author> <title> (1987) On the Power of Magic, </title> <booktitle> Proc. 6th Symp. on Principles of Database Systems, </booktitle> <address> pps 269-283. </address>
Reference-contexts: The theory and implementation of OLDT has been studied extensively by several researchers including Seki [28, 27] and Warren and his colleagues [9, 10]. Furthermore, it is known that OLDT and magic set computations <ref> [5, 6, 26] </ref> are essentially equivalent, though they differ in many (relatively minor) details.
Reference: [7] <author> H. A. Blair and V.S. Subrahmanian. </author> <title> (1987) Paraconsistent Logic Programming, </title> <journal> Theoretical Computer Science, </journal> <volume> 68, </volume> <pages> pp 35-54. </pages> <note> Preliminary version in: LNCS 287, Dec. 1987, Springer. 39 </note>
Reference-contexts: Here u 1 ; u 2 are real numbers in the [0; 1] interval and T 1 ; T 2 are sets of real numbers. (4) Four-Valued Logic: Four valued logic <ref> [7, 19] </ref> uses the truth values FOUR = f?; t; f ; &gt;g ordered as follows: ?x and x&gt; for all x 2 FOUR. <p> In particular, t and f are not comparable relative to this ordering. <ref> [7] </ref> and [19] show how this FOUR-valued logic may be used to reason about databases containing inconsistencies. This is only a small sample of what T could be. <p> The detailed description of annotated logics is beyond the scope of this paper it is well-documented in the literature <ref> [7, 20, 32, 33] </ref>. 4 A Resolution-Based Query Processing Procedure In this section, we will develop a framework for processing queries to amalgamated databases. This procedure is a resolution-based procedure, and hence, inherits many of the disadvantages of existing resolution-based strategies.
Reference: [8] <author> Y. Breitbart, H. Garcia-Molina and A. Silberschatz. </author> <title> (1992) Overview of Multidatabase Transac--tion Management, </title> <journal> VLDB Journal, </journal> <volume> 2, </volume> <pages> pps 181-239. </pages>
Reference: [9] <author> W. Chen and D.S. Warren. </author> <title> (1992) A Goal-Oriented Approach to Computing Well-Founded Semantics, </title> <booktitle> Proc. 1992 Intl. Conf. on Logic Programming (ed. K.R. Apt), </booktitle> <publisher> MIT Press. </publisher>
Reference-contexts: OLDT-resolution, due to Tamaki and Sato [34] is a technique which caches previously derived solutions in a table. The theory and implementation of OLDT has been studied extensively by several researchers including Seki [28, 27] and Warren and his colleagues <ref> [9, 10] </ref>. Furthermore, it is known that OLDT and magic set computations [5, 6, 26] are essentially equivalent, though they differ in many (relatively minor) details. <p> Warren <ref> [9, 10] </ref>). When a single database with neither uncertainty nor time is considered, the structure of the OLDT-table can be relatively simple. However, when multiple database operations, uncertainty estimates (that are constantly being revised), and temporal reasoning are being performed simultaneously, the management of the OLDT-table becomes a significant issue. <p> In [15], Fitting generalizes results in [35, 4], to obtain a well-founded semantics for bilattice-based logic programs. We have given a detailed comparison of our declarative framework with Fitting's in [32]. Warren and his co-workers <ref> [10, 9] </ref> have studied OLDT-resolution for ordinary logic programs (both with,and without nonmonotonic forms of negation).
Reference: [10] <author> S. Dietrich and D.S. Warren. </author> <title> (1986) Extension Tables: Memo Relations in Logic Programming, </title> <type> SUNY Stonybrook Tech. Report 86/18. </type>
Reference-contexts: OLDT-resolution, due to Tamaki and Sato [34] is a technique which caches previously derived solutions in a table. The theory and implementation of OLDT has been studied extensively by several researchers including Seki [28, 27] and Warren and his colleagues <ref> [9, 10] </ref>. Furthermore, it is known that OLDT and magic set computations [5, 6, 26] are essentially equivalent, though they differ in many (relatively minor) details. <p> Warren <ref> [9, 10] </ref>). When a single database with neither uncertainty nor time is considered, the structure of the OLDT-table can be relatively simple. However, when multiple database operations, uncertainty estimates (that are constantly being revised), and temporal reasoning are being performed simultaneously, the management of the OLDT-table becomes a significant issue. <p> In [15], Fitting generalizes results in [35, 4], to obtain a well-founded semantics for bilattice-based logic programs. We have given a detailed comparison of our declarative framework with Fitting's in [32]. Warren and his co-workers <ref> [10, 9] </ref> have studied OLDT-resolution for ordinary logic programs (both with,and without nonmonotonic forms of negation).
Reference: [11] <author> D. Dubois, J. Lang and H. Prade. </author> <title> (1991) Towards Possibilistic Logic Programming, </title> <booktitle> Proc. 1991 Intl. Conf. on Logic Programming, </booktitle> <editor> ed. K. Furukawa, </editor> <address> pps 581-595, </address> <publisher> MIT Press. </publisher>
Reference: [12] <author> D. Dubois, J. Lang and H. Prade. </author> <title> (1992) Dealing with Multi-Source Information in Possibilistic Logic, </title> <booktitle> Proc. 10th European Conf. on Artificial Intelligence, </booktitle> <publisher> Wiley. </publisher>
Reference-contexts: Dubois, Lang and Prade <ref> [12] </ref>, also suggest that formulas in knowledge bases can be annotated with, for each source, a lower bound of a degree of certainty associated with that source.
Reference: [13] <author> R. Fagin, J.D. Ullman, and M.Y. Vardi. </author> <title> (1983) On the Semantics of Updates in Databases, </title> <booktitle> Proc. ACM SIGACT/SIGMOD Symposium on Principles of Database Systems, </booktitle> <address> pps 352-365. </address>
Reference-contexts: Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. <ref> [13, 14] </ref>).
Reference: [14] <author> R. Fagin, G. Kuper, J. Ullman, and M. Vardi. </author> <title> (1986) Updating Logical Databases, </title> <booktitle> In Advances in Computing Research, </booktitle> <volume> volume 3, </volume> <pages> pages 1-18, </pages> <year> 1986. </year>
Reference-contexts: Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. <ref> [13, 14] </ref>).
Reference: [15] <author> M. C. </author> <title> Fitting. (1991) Well-Founded Semantics, Generalized, </title> <booktitle> Proc. 1991 Intl. Logic Programming Symposium, </booktitle> <address> pps 71-83, </address> <publisher> MIT Press. </publisher>
Reference-contexts: However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. In <ref> [15] </ref>, Fitting generalizes results in [35, 4], to obtain a well-founded semantics for bilattice-based logic programs. We have given a detailed comparison of our declarative framework with Fitting's in [32]. Warren and his co-workers [10, 9] have studied OLDT-resolution for ordinary logic programs (both with,and without nonmonotonic forms of negation).
Reference: [16] <author> J. Grant, W. Litwin, N. Roussopoulos and T. Sellis. </author> <title> (1991) An Algebra and Calculus for Relational Multidatabase Systems, </title> <booktitle> Proc. First International Workshop on Interoperability in Multi-database Systems, </booktitle> <publisher> IEEE Computer Society Press (1991) 118-124. </publisher>
Reference-contexts: 61g; f ) f 1 Entry 1 nil 4 V 4 (*; ?); (fT = 61g; t) t 1 Entry 1 nil 5 (fX = bg,nil) t 1 nil nil nil 37 6 Related Work A great deal of work has been done in multidatabase systems and interoperable database systems <ref> [39, 16, 36] </ref>. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. <p> However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. The work of Grant et. al. <ref> [16] </ref> is an exception: the authors develop a calculus and an algebra for integrating information from multiple databases. This calculus extends the standard relational calculus. Further work specialized to handle inter-operability of multidatabases is critically needed.
Reference: [17] <author> Y. Ioannidis and T. Sellis. </author> <title> (1989) Conflict Resolution of Rules Assigning Values to Virtual Attributes, </title> <booktitle> Proc. ACM SIGMOD Symp. on Management of Data. </booktitle>
Reference: [18] <author> M. Kifer, G. Lausen and J. Wu. </author> <title> (1990) Logical Foundations of Object-Oriented and Frame-Based Languages, </title> <type> Tech. Report 90/14, </type> <institution> SUNY at Stonybrook. </institution>
Reference: [19] <author> M. Kifer and E. Lozinskii. </author> <title> (1989) RI: A Logic for Reasoning with Inconsistency, </title> <booktitle> 4-th Symposium on Logic in Computer Science, Asilomar, </booktitle> <address> CA, </address> <pages> pp. 253-262. </pages> <note> Full version to appear in: Journal of Automated Reasoning. </note>
Reference-contexts: Here u 1 ; u 2 are real numbers in the [0; 1] interval and T 1 ; T 2 are sets of real numbers. (4) Four-Valued Logic: Four valued logic <ref> [7, 19] </ref> uses the truth values FOUR = f?; t; f ; &gt;g ordered as follows: ?x and x&gt; for all x 2 FOUR. <p> In particular, t and f are not comparable relative to this ordering. [7] and <ref> [19] </ref> show how this FOUR-valued logic may be used to reason about databases containing inconsistencies. This is only a small sample of what T could be. <p> Later in this section, we will define a resolution-based strategy that uses regular representations of amalgamated clauses instead of the amalgamated clauses themselves. The advantage is that the expensive reductant rule of inference introduced by Kifer and Lozinskii <ref> [19] </ref> and later studied by Kifer and Subrahmanian [20] can be eliminated by using regular representations.
Reference: [20] <author> M. Kifer and V.S. Subrahmanian. </author> <title> (1989) Theory of Generalized Annotated Logic Programming and its Applications, </title> <journal> Journal of Logic Programming, </journal> <volume> 12, 4, </volume> <pages> pps 335-368, </pages> <year> 1992. </year> <title> Preliminary version in: </title> <booktitle> Proc. 1989 North American Conf. on Logic Programming, </booktitle> <publisher> MIT Press. </publisher>
Reference-contexts: DAAL-03-92-G-0225 and by the Air Force Office of Scientific Research under Grant Nr. F49620-93-1-0065, and by ARPA Order Nr. A716 administered by Rome Labs under contract F30602-93-C-0241. NOTE TO REFEREES: Appendix A contains material that can be removed from the paper after acceptance. 1 paradigm of Kifer and Subrahmanian <ref> [20] </ref> may be used to express mediators. <p> We compare our results with relevant work by other researchers in Section 6. 2 2 Preliminaries In this section, we give a quick overview of GAPs and the amalgamation theory developed in the first of this series of papers [32]. 2.1 Overview of GAPs The GAP framework proposed in <ref> [20] </ref> assumes that we have a set T of truth values that forms a complete lattice under an ordering . <p> These examples will be used throughout the paper to illustrate various intuitions as they arise in the paper. We will assume that the reader is familiar with generalized annotated programs (GAPs) as defined in <ref> [20] </ref>. 3.1 Robot Example: Static Case Consider two mobile robots, r1 and r2, that are operating in a common workspace. Each of these two robots has access to three databases; one of these databases represents information about the locations of objects in the workspace (cf. <p> The detailed description of annotated logics is beyond the scope of this paper it is well-documented in the literature <ref> [7, 20, 32, 33] </ref>. 4 A Resolution-Based Query Processing Procedure In this section, we will develop a framework for processing queries to amalgamated databases. This procedure is a resolution-based procedure, and hence, inherits many of the disadvantages of existing resolution-based strategies. <p> Later in this section, we will define a resolution-based strategy that uses regular representations of amalgamated clauses instead of the amalgamated clauses themselves. The advantage is that the expensive reductant rule of inference introduced by Kifer and Lozinskii [19] and later studied by Kifer and Subrahmanian <ref> [20] </ref> can be eliminated by using regular representations. <p> The fixpoint reachability property is critical for completeness because otherwise, we need to take recourse to infinitary proofs. It is well-known <ref> [20] </ref> that even in the case of GAPs, the fixpoint reachability property is critically necessary for obtaining completeness results. The proof of the following result is contained in Appendix A.
Reference: [21] <author> W. Kim and J. Seo. </author> <title> (1991) Classifying Schematic and Data Heterogeneity in Multidatabase Systems, </title> <booktitle> IEEE Computer, </booktitle> <month> Dec. </month> <year> 1991. </year>
Reference: [22] <author> R. Krishnamurthy, W. Litwin and W. Kent. </author> <title> (1991) Language Features for Interoperability of Databases with Schematic Discrepancies, </title> <booktitle> Proc. ACM SIGMOD 1991. </booktitle>
Reference: [23] <author> A. Lefebvre, P. Bernus and R. Topor. </author> <title> (1992) Querying Heterogeneous Databases: A Case Study, </title> <type> draft manuscript. 40 </type>
Reference: [24] <author> J. Lu, N. Murray and E. Rosenthal. </author> <title> (1993) Signed Formulas and Annotated Logics, draft manuscript. Preliminary version in: </title> <booktitle> Proceedings of the International Symposium on Multiple-Valued Logic, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1993, </year> <pages> 48-53. </pages>
Reference-contexts: This procedure is a resolution-based procedure, and hence, inherits many of the disadvantages of existing resolution-based strategies. It is similar to work by Lu, Murray and Rosenthal <ref> [24] </ref> who have inde pendently developed a more general framework for query processing in GAPs. The work described 2 This is only an illustration. <p> This asymmetry is a key distinction between our work and the concurrently developed work of <ref> [24] </ref>. <p> An S-deduction is called an S-refutation if it is finite and the last query is the empty clause. Lu, Murray and Rosenthal <ref> [24] </ref> have proved a more general version of the soundness and completeness result which we therefore state without proof 5 .
Reference: [25] <author> A. Martelli and U. Montanari. </author> <title> (1982) An Efficient Unification Algorithm, </title> <journal> ACM Trans. on Prog. Lang. and Systems, </journal> <volume> 4, 2, </volume> <pages> pps 258-282. </pages>
Reference-contexts: In this paper, we will consider a substitution to be a set of equations in solved-form (cf. Martelli and Montanari <ref> [25] </ref>). Definition 13 Let 1 and 2 be two substitutions. is said to be the most general common denominator (MGCD) of 1 and 2 iff 1. is less general than both 1 and 2 , i.e. there exists substitutions 0 00 such that = 1 = 2 . 2.
Reference: [26] <author> R. Ramakrishnan. </author> <title> (1991) Magic Templates: A Spellbinding Approach to Logic Programs, </title> <journal> J. of Logic Programming, </journal> <volume> 11, </volume> <pages> pps 189-216. </pages>
Reference-contexts: The theory and implementation of OLDT has been studied extensively by several researchers including Seki [28, 27] and Warren and his colleagues [9, 10]. Furthermore, it is known that OLDT and magic set computations <ref> [5, 6, 26] </ref> are essentially equivalent, though they differ in many (relatively minor) details.
Reference: [27] <author> H. Seki and H. Itoh. </author> <title> (1989) A Query Evaluation Method for Stratified Programs under the Extended CWA, </title> <booktitle> Proc. 5th Intl. Conf./Symp. on Logic Programming (eds. </booktitle> <editor> K. Bowen and R. Kowalski), </editor> <address> pps 195-211. </address>
Reference-contexts: OLDT-resolution, due to Tamaki and Sato [34] is a technique which caches previously derived solutions in a table. The theory and implementation of OLDT has been studied extensively by several researchers including Seki <ref> [28, 27] </ref> and Warren and his colleagues [9, 10]. Furthermore, it is known that OLDT and magic set computations [5, 6, 26] are essentially equivalent, though they differ in many (relatively minor) details.
Reference: [28] <author> H. Seki. </author> <title> (1989) On the Power of Alexander Templates, </title> <booktitle> Proc. 8th ACM Symp. on Principles of Database Systems, </booktitle> <address> pps 150-159. </address>
Reference-contexts: OLDT-resolution, due to Tamaki and Sato [34] is a technique which caches previously derived solutions in a table. The theory and implementation of OLDT has been studied extensively by several researchers including Seki <ref> [28, 27] </ref> and Warren and his colleagues [9, 10]. Furthermore, it is known that OLDT and magic set computations [5, 6, 26] are essentially equivalent, though they differ in many (relatively minor) details.
Reference: [29] <author> A. Sheth and J. Larson. </author> <title> (1990) Federated Database Systems for Managing Distributed, Heterogeneous and Autonomous Databases, </title> <journal> ACM Computing Surveys, </journal> <volume> 22, 3, </volume> <pages> pp 183-236. </pages>
Reference: [30] <author> J. Shoenfield. </author> <title> (1967) Mathematical Logic, </title> <publisher> Addison Wesley. </publisher>
Reference-contexts: Interpretation 3 I satisfies a ground annotated atom A : iff I (A). The notion of satisfaction of formulas containing other connectives, such as &; _; and quantifiers 8; 9 is the usual one <ref> [30] </ref>.
Reference: [31] <author> A. Silberschatz, M. Stonebraker and J. D. Ullman. </author> <title> (1991) Database Systems: Achievements and Opportunities, </title> <journal> Comm. of the ACM, </journal> <volume> 34, 10, </volume> <pages> pps 110-120. </pages>
Reference: [32] <author> V.S. Subrahmanian. </author> <title> (1992) Amalgamating Knowledge Bases, </title> <institution> Univ. of Maryland Tech. Report CS-TR-2949, </institution> <month> Aug. </month> <year> 1992. </year> <note> Submitted to ACM - TODS, August 1992, revised May 1993. </note>
Reference-contexts: We compare our results with relevant work by other researchers in Section 6. 2 2 Preliminaries In this section, we give a quick overview of GAPs and the amalgamation theory developed in the first of this series of papers <ref> [32] </ref>. 2.1 Overview of GAPs The GAP framework proposed in [20] assumes that we have a set T of truth values that forms a complete lattice under an ordering . <p> In this section, we recall, from <ref> [32] </ref>, how the theory of GAPs may be successfully applied to defining a new lattice of truth values that forms the basis for a "mediator" or "supervisory database." To do so, we first define the DNAME lattice; this is the power set, 2 f1;:::;n;sg . <p> the databases in set D i , 1 i n, (jointly) imply that the truth value of A i is at least i , then the supervisor will conclude that the truth value of A 0 is at least ." This mode of expressing supervisory information is very rich in <ref> [32] </ref>, it is shown that we can express prioritized knowledge about predicates, prioritized knowledge about objects, as well as methods to achieve consensus. We now define the concept of an amalgam of local databases DB 1 ; : : : ; DB n via a supervisor S. <p> The second rule says that the supervisor only concludes that r2 can lift an object if both databases DB 2 and DB 3 say it can (consensus). 8 The amalgam of local databases DB 1 ; DB 2 ; DB 3 with the supervisory database S, as defined in <ref> [32] </ref> is: at (r2; 4; 4) : [f1g; t] at (b; 2; 2) : [f1g; t] at (d; 4; 2) : [f1g; t] right (E1; E2) : [f1g; t] at (E1; X1; Y 1) : [f1g; t] & at (E2; X2; Y 1) : [f1g; t] & X1 &gt; X2: lef <p> The detailed description of annotated logics is beyond the scope of this paper it is well-documented in the literature <ref> [7, 20, 32, 33] </ref>. 4 A Resolution-Based Query Processing Procedure In this section, we will develop a framework for processing queries to amalgamated databases. This procedure is a resolution-based procedure, and hence, inherits many of the disadvantages of existing resolution-based strategies. <p> Example 2 (Static Robot Example Revisited) Consider the following rule from DB 2 of the Static Robot example. can lif t (r1; X) : t weight (X; W ) : t & W &lt; 50: The amalgamated form of this, as defined in <ref> [32] </ref>, is can lif t (r1; X) : [f2g; t] weight (X; W ) : [f2g; t] & W &lt; 50: The regular representation of this is: can lif t (r1; X) : EXP ([f2g; t]) weight (X; W ) : EXP ([f2g; t]) & W &lt; 50: (We assume that <p> Then, I S-satisfies the S-resolvent of C fl and Q fl k . 2 The following definition from <ref> [32] </ref> is needed for proving the Completeness results for amalgamated knowledge bases. Given an amalgamated knowledge base Q, it is possible to associate with Q, an operator A Q that maps A-interpretations to A-interpretations. Definition 11 [32] Suppose Q is an amalgamated knowledge base. <p> S-resolvent of C fl and Q fl k . 2 The following definition from <ref> [32] </ref> is needed for proving the Completeness results for amalgamated knowledge bases. Given an amalgamated knowledge base Q, it is possible to associate with Q, an operator A Q that maps A-interpretations to A-interpretations. Definition 11 [32] Suppose Q is an amalgamated knowledge base. We may associate with Q, an operator, A Q , that maps A-interpretations to A-interpretations as follows. <p> n+m : [D n+m ; n+m ])g is a ground instance of a clause in Q and for all 1 i n, i I (B i )(D i ) and for all (n + 1) j (n + m), j 6 I (B j )(D j ). 0 0 Subrahmanian <ref> [32] </ref> proved that when Q is negation-free, A Q is monotonic. Hence, A Q has a least fixpoint which is identical to A Q " for some ordinal . <p> Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. [13, 14]). As we have shown in <ref> [32] </ref>, our framework can express maximal consistency as well. [2, 3] do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [2, 3] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework <p> However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. In [15], Fitting generalizes results in [35, 4], to obtain a well-founded semantics for bilattice-based logic programs. We have given a detailed comparison of our declarative framework with Fitting's in <ref> [32] </ref>. Warren and his co-workers [10, 9] have studied OLDT-resolution for ordinary logic programs (both with,and without nonmonotonic forms of negation). <p> As OLDT-resolution is known to be closely related to magic set computations, we will not discuss those separately. 38 7 Conclusions Wiederhold has proposed mediators as a framework within which multiple databases may be integrated. In the first of this series of papers <ref> [32] </ref>, it has been shown that certain forms of annotated logic provide a simple language within which mediators can be expressed. In particular, it was shown that the semantics of "local" databases can be viewed as embeddings within the semantics of amalgamated databases. In [32], we did not develop an operational <p> first of this series of papers <ref> [32] </ref>, it has been shown that certain forms of annotated logic provide a simple language within which mediators can be expressed. In particular, it was shown that the semantics of "local" databases can be viewed as embeddings within the semantics of amalgamated databases. In [32], we did not develop an operational theory for query processing in amalgamated KBs. In this paper, we have provided a framework for implementing such a query processing paradigm.
Reference: [33] <author> V.S. Subrahmanian. </author> <title> (1992) Paraconsistent Disjunctive Deductive Databases, </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 93, </volume> <pages> pps 115-141. </pages>
Reference-contexts: The detailed description of annotated logics is beyond the scope of this paper it is well-documented in the literature <ref> [7, 20, 32, 33] </ref>. 4 A Resolution-Based Query Processing Procedure In this section, we will develop a framework for processing queries to amalgamated databases. This procedure is a resolution-based procedure, and hence, inherits many of the disadvantages of existing resolution-based strategies.
Reference: [34] <author> H. Tamaki and T. Sato. </author> <title> (1986) OLD Resolution with Tabulation, </title> <booktitle> Proc. 3rd Intl. Conf. on Logic Programming (ed. </booktitle> <editor> E. Shapiro), </editor> <address> pps 84-98, </address> <publisher> Springer. </publisher>
Reference-contexts: We will first develop a resolution-based QPP and show it to be sound and complete. However, it is well known that resolution proof procedures are notoriously inefficient, often solving previously solved goals over and over again. OLDT-resolution, due to Tamaki and Sato <ref> [34] </ref> is a technique which caches previously derived solutions in a table. The theory and implementation of OLDT has been studied extensively by several researchers including Seki [28, 27] and Warren and his colleagues [9, 10].
Reference: [35] <author> A. van Gelder. </author> <title> (1989) The Alternating Fixpoint of Logic Programs with Negation, </title> <booktitle> Proc. 8th ACM Symp. on Principles of Database Systems, </booktitle> <volume> pps 1 - 10. </volume>
Reference-contexts: However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. In [15], Fitting generalizes results in <ref> [35, 4] </ref>, to obtain a well-founded semantics for bilattice-based logic programs. We have given a detailed comparison of our declarative framework with Fitting's in [32]. Warren and his co-workers [10, 9] have studied OLDT-resolution for ordinary logic programs (both with,and without nonmonotonic forms of negation).
Reference: [36] <author> W.K. Whang, S. B. Navathe and S. Chakravarthy. </author> <title> (1991) Logic-Based Approach for Realizing a Federated Information System, </title> <booktitle> Proc. First International Workshop on Interoperability in Multidatabase Systems, </booktitle> <publisher> IEEE Computer Society Press (1991) 92-100. [37] , G. </publisher> <editor> Wiederhold, S. Jajodia, and W. Litwin. </editor> <title> Dealing with granularity of time in temporal databases. </title> <booktitle> In Proc. 3rd Nordic Conf. on Advanced Information Systems Engineering, Lecture Notes in Computer Science, </booktitle> <volume> Vol. 498, </volume> <editor> (R. Anderson et al. eds.), </editor> <publisher> Springer-Verlag, </publisher> <year> 1991, </year> <pages> pages 124-140. </pages>
Reference-contexts: 61g; f ) f 1 Entry 1 nil 4 V 4 (*; ?); (fT = 61g; t) t 1 Entry 1 nil 5 (fX = bg,nil) t 1 nil nil nil 37 6 Related Work A great deal of work has been done in multidatabase systems and interoperable database systems <ref> [39, 16, 36] </ref>. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. <p> Zicari et. al [39] describe how interoperability may be achieved between a rule-based system (deductive DB) and an object-oriented database using special import/export primitives. No formal theory is developed in [39]. Perhaps closer to our goal is that of Whang et. al. <ref> [36] </ref> who argue that Prolog is a suitable framework for schema integration. In fact, the approach of Whang et. al. is in the same spirit as that of metalogic programming discussed earlier.
Reference: [38] <author> G Wiederhold, S. Jajodia, and W. Litwin. </author> <title> Integrating temporal data in a heterogeneous environment. In Temporal Databases. </title> <address> Benjamin/Cummings, </address> <month> Jan </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Complex reasoning tasks in the real world utilize information from a multiplicity of sources. These sources may represent data and/or knowledge about different aspects of a problem in a number of ways. Wiederhold and his colleagues <ref> [37, 38] </ref> have proposed the concept of a mediator a device that will express how such an integration is to be achieved. This is the second in a series of papers developing the theory and practice of federated databases.
Reference: [39] <author> R. Zicari, S. Ceri, and L. Tanca. </author> <title> (1991) Interoperability between a Rule-Based Database Language and an Object-Oriented Language, </title> <booktitle> Proc. First International Workshop on Interoperability in Multidatabase Systems, </booktitle> <publisher> IEEE Computer Society Press (1991) 125-135. </publisher> <pages> 41 </pages>
Reference-contexts: 61g; f ) f 1 Entry 1 nil 4 V 4 (*; ?); (fT = 61g; t) t 1 Entry 1 nil 5 (fX = bg,nil) t 1 nil nil nil 37 6 Related Work A great deal of work has been done in multidatabase systems and interoperable database systems <ref> [39, 16, 36] </ref>. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. <p> This calculus extends the standard relational calculus. Further work specialized to handle inter-operability of multidatabases is critically needed. However, our paper addresses a different topic that of integrating multiple deductive databases containing (possibly) inconsistencies, uncertainty, non-monotonic negation, and possibly even temporal information. Zicari et. al <ref> [39] </ref> describe how interoperability may be achieved between a rule-based system (deductive DB) and an object-oriented database using special import/export primitives. No formal theory is developed in [39]. <p> Zicari et. al <ref> [39] </ref> describe how interoperability may be achieved between a rule-based system (deductive DB) and an object-oriented database using special import/export primitives. No formal theory is developed in [39]. Perhaps closer to our goal is that of Whang et. al. [36] who argue that Prolog is a suitable framework for schema integration. In fact, the approach of Whang et. al. is in the same spirit as that of metalogic programming discussed earlier.
References-found: 38

