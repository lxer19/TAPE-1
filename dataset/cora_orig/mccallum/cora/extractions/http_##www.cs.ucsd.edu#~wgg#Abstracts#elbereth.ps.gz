URL: http://www.cs.ucsd.edu/~wgg/Abstracts/elbereth.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/Abstracts/elbereth.html
Root-URL: http://www.cs.ucsd.edu
Title: Elbereth: Tool Support for Refactoring Java Programs  
Author: Walter Korman and William G. Griswold 
Keyword: programming environments, software engineering practices, experience with object-oriented applications and systems.  
Note: Research submission.  This research is supported in part by NSF grant CCR-9508745.  
Address: San Diego, CA 92093-0114 USA  
Affiliation: Department of Computer Science Engineering, 0114 University of California, San Diego  
Email: fwkorman,wggg@cs.ucsd.edu  
Phone: (619) 534-6898  
Abstract: As object-oriented software is modified its structure tends to degrade. The potentially large number of classes and the large number of dependencies between them can complicate the analysis and planning needed to maintain a program written in an object-oriented language. Restructuring software to improve its design can lower the cost of future changes. To ease the task of software restructuring, we describe the application of the star diagram concept to Java programs. The star diagram visualization affords programmers a cross-cutting view of the project source code that can simplify software maintenance tasks by allowing the programmer to rapidly assess complicated class hierarchies and complex class interrelationships. The recording of detailed refactoring tasks to be performed, accompanied by relevant portions of star diagrams for the source code undergoing modification, provides the programmer with a visualization of the work that assists in recall and execution of the software restructuring. 
Abstract-found: 1
Intro-found: 1
Reference: [Berners-Lee et al. 94] <author> T. Berners-Lee, L. Masinter, and M. McCahill. </author> <title> Uniform Resource Locators (URL). </title> <type> RFC 1738, </type> <month> December </month> <year> 1994. </year>
Reference-contexts: For example, the programmer might need to change instantiations of the base class to instead instantiate the new subclass. This subclassing was performed on Elbereth to allow inclusion of network-accessible source files specified via Uniform Resource Locators (URLs) <ref> [Berners-Lee et al. 94] </ref>. The SourceFile class was enhanced by creating a new URLSourceFile class that subclassed the SourceFile class, overriding methods to allow reading source file data over the network instead of directly from a local hard drive.
Reference: [Bischofberger 92] <author> W. R. Bischofberger. </author> <title> SniffA Pragmatic Approach to a C++ Programming Environment. </title> <booktitle> In USENIX C++ Technical Conference Proceedings, </booktitle> <pages> pages 6781, </pages> <address> Portland, OR, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: The disadvantage with such tools is that the programmer loses control over the class design and the software may end up with a counterintuitive class structure [Opdyke 92, Casais 94]. Other visualization tools such as Rigi and Sniff can be used for planning refactorings <ref> [Muller et al. 92, Bischofberger 92] </ref>. However, they cannot serve as the user interface for a refactoring tool. For example, the Rigi environment constructs a view based on entities such as functions, files, classes, or modules. This view is then augmented by the programmer.
Reference: [Bowdidge & Griswold 94] <author> R. W. Bowdidge and W. G. Griswold. </author> <title> Automated support for encapsulating abstract data types. </title> <booktitle> In ACM SIGSOFT '94 Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 97110, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Finally, in planning a complex redesign, it is desirable to have support for recording the designer's many discoveries, thoughts, and refactoring plans. 1.2 The Star Diagram For programs written in a procedural programming language, this problem has been addressed by a restructuring tool designed around the star diagram visualization <ref> [Bowdidge 95, Bowdidge & Griswold 94] </ref>. A star diagram provides a compact, hierarchical, tree-structured visual representation of the source code relating to a particular data structure, eliding code unrelated to the data structure's use and maintenance. Similar code fragments are merged into node stacks to reveal potentially redundant computations. <p> Elbereth can serve as the user interface for an interactive restructuring tool like Opdyke's automated refactoring tool [Opdyke 92]. Bowdidge's restructuring tool uses the star diagram visualization in an analogous manner to perform automatic restructurings of Scheme programs <ref> [Bowdidge & Griswold 94, Bowdidge 95] </ref>. A text-oriented user interface for a star diagram-based interactive restructuring tool allows a programmer to fill in a transformation form with keyboard entry and selections from program text.
Reference: [Bowdidge 95] <author> R. W. Bowdidge. </author> <title> Supporting the Restructuring of Data Abstractions through Manipulation of a Program Visualization. </title> <type> PhD dissertation, </type> <institution> University of California, San Diego, Department of Computer Science & Engineering, </institution> <month> November </month> <year> 1995. </year> <note> Technical Report CS95-457. </note>
Reference-contexts: Finally, in planning a complex redesign, it is desirable to have support for recording the designer's many discoveries, thoughts, and refactoring plans. 1.2 The Star Diagram For programs written in a procedural programming language, this problem has been addressed by a restructuring tool designed around the star diagram visualization <ref> [Bowdidge 95, Bowdidge & Griswold 94] </ref>. A star diagram provides a compact, hierarchical, tree-structured visual representation of the source code relating to a particular data structure, eliding code unrelated to the data structure's use and maintenance. Similar code fragments are merged into node stacks to reveal potentially redundant computations. <p> Elbereth can serve as the user interface for an interactive restructuring tool like Opdyke's automated refactoring tool [Opdyke 92]. Bowdidge's restructuring tool uses the star diagram visualization in an analogous manner to perform automatic restructurings of Scheme programs <ref> [Bowdidge & Griswold 94, Bowdidge 95] </ref>. A text-oriented user interface for a star diagram-based interactive restructuring tool allows a programmer to fill in a transformation form with keyboard entry and selections from program text.
Reference: [Casais 94] <author> E. Casais. </author> <title> Automatic reorganization of object-oriented hierarchies: A case study. Object Oriented Systems, </title> <address> 1(2):95115, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: Batch restructuring tools free the programmer from all manual tasks by enforcing specific design requirements upon the software, restructuring as needed without programmer intervention. Examples of such tools include Lieberherr's Demeter System [Lieberherr et al. 94] and Casais' tool for performing reorganization of class hierarchies <ref> [Casais 94] </ref>. The disadvantage with such tools is that the programmer loses control over the class design and the software may end up with a counterintuitive class structure [Opdyke 92, Casais 94]. <p> Examples of such tools include Lieberherr's Demeter System [Lieberherr et al. 94] and Casais' tool for performing reorganization of class hierarchies [Casais 94]. The disadvantage with such tools is that the programmer loses control over the class design and the software may end up with a counterintuitive class structure <ref> [Opdyke 92, Casais 94] </ref>. Other visualization tools such as Rigi and Sniff can be used for planning refactorings [Muller et al. 92, Bischofberger 92]. However, they cannot serve as the user interface for a refactoring tool.
Reference: [Gamma et al. 93] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design patterns: Abstraction and reuse of object-oriented design. </title> <booktitle> Proceedings of ECOOP, </booktitle> <year> 1993. </year>
Reference-contexts: The intrinsic difficulty of good object-oriented design in complex systems is emphasized by the growing popularity of design patterns, which can impart experience and design knowledge to software designers <ref> [Gamma et al. 93] </ref>. Opdyke proposes that refactoring existing class hierarchies can improve their maintainability and reusability [Opdyke 92, Opdyke & Johnson 90]. A refactoring activity changes the organization of an object-oriented program without changing its behavior. <p> The code elsewhere in the system to handle file loading was then modified to take advantage of the new subclass by instantiating a URLSourceFile object for filenames specified as URLs, or a SourceFile object otherwise. A Factory method <ref> [Gamma et al. 93] </ref> was implemented to create the appropriate kind of SourceFile object. Elbereth helped the programmer navigate among the numerous source files.
Reference: [Gosling et al. 96] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: We believe that these techniques can be extended to take advantage of object-oriented constructs, thereby providing more effective assistance in the maintenance of object-oriented programs. To empirically evaluate these claims we have implemented Elbereth [Korman & Griswold], a tool for exploring, planning, and carrying out refactorings of Java programs <ref> [Gosling et al. 96] </ref>. Elbereth is based on a restructuring planning tool for C [Griswold et al. 96, Griswold 97] with enhancements that not only exploit the hierarchical type information provided by classes and inheritance, but also streamline common refactoring scenarios.
Reference: [Griswold 97] <author> W. G. Griswold. </author> <title> Tool support for planning the restructuring of data abstractions in large systems. </title> <type> Technical report, </type> <institution> University of California, San Diego, Department of Computer Science & Engineering, </institution> <month> October </month> <year> 1997. </year> <note> Technical Report CS95-457. </note>
Reference-contexts: To empirically evaluate these claims we have implemented Elbereth [Korman & Griswold], a tool for exploring, planning, and carrying out refactorings of Java programs [Gosling et al. 96]. Elbereth is based on a restructuring planning tool for C <ref> [Griswold et al. 96, Griswold 97] </ref> with enhancements that not only exploit the hierarchical type information provided by classes and inheritance, but also streamline common refactoring scenarios. <p> The star diagram visualization has previously been shown to ease the task of restructuring software written in procedural programming languages such as C and MUMPS <ref> [Griswold 97] </ref>. This paper has shown that the use of Elbereth and the star diagram visualization can aid in refactoring moderately-sized Java programs.
Reference: [Griswold et al. 96] <author> W. G. Griswold, M. I. Chen, R. W. Bowdidge, and J. D. Morgenthaler. </author> <title> Tool support for planning the restructuring of data abstractions in large systems. </title> <booktitle> In ACM SIGSOFT '96 Symposium on the Foundations of Software Engineering, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: To empirically evaluate these claims we have implemented Elbereth [Korman & Griswold], a tool for exploring, planning, and carrying out refactorings of Java programs [Gosling et al. 96]. Elbereth is based on a restructuring planning tool for C <ref> [Griswold et al. 96, Griswold 97] </ref> with enhancements that not only exploit the hierarchical type information provided by classes and inheritance, but also streamline common refactoring scenarios.
Reference: [Korman & Griswold] <author> W. Korman and W. G. Griswold. </author> <note> Elbereth Home Page. http://www-cse.ucsd.edu/users/wkorman/elbereth/. 25 </note>
Reference-contexts: Stacked fragments are frequently candidates for a refactoring such as abstraction into new methods. We believe that these techniques can be extended to take advantage of object-oriented constructs, thereby providing more effective assistance in the maintenance of object-oriented programs. To empirically evaluate these claims we have implemented Elbereth <ref> [Korman & Griswold] </ref>, a tool for exploring, planning, and carrying out refactorings of Java programs [Gosling et al. 96].
Reference: [Lieberherr et al. 94] <author> K. Lieberherr, W. Hursch, and C. Xiao. </author> <title> Object-extending class transformations. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6(4):391416, </volume> <year> 1994. </year>
Reference-contexts: Batch restructuring tools free the programmer from all manual tasks by enforcing specific design requirements upon the software, restructuring as needed without programmer intervention. Examples of such tools include Lieberherr's Demeter System <ref> [Lieberherr et al. 94] </ref> and Casais' tool for performing reorganization of class hierarchies [Casais 94]. The disadvantage with such tools is that the programmer loses control over the class design and the software may end up with a counterintuitive class structure [Opdyke 92, Casais 94].
Reference: [Muller et al. 92] <author> H. A. Muller, S. R. Tilley, M. A. Orgun, and B. D. Corrie. </author> <title> A reverse engineering environment based on spatial and visual software interconnection models. </title> <booktitle> In SIGSOFT '92: Fifth Symposium on Software Development Environments, </booktitle> <pages> pages 8898, </pages> <year> 1992. </year>
Reference-contexts: The disadvantage with such tools is that the programmer loses control over the class design and the software may end up with a counterintuitive class structure [Opdyke 92, Casais 94]. Other visualization tools such as Rigi and Sniff can be used for planning refactorings <ref> [Muller et al. 92, Bischofberger 92] </ref>. However, they cannot serve as the user interface for a refactoring tool. For example, the Rigi environment constructs a view based on entities such as functions, files, classes, or modules. This view is then augmented by the programmer.
Reference: [Opdyke & Johnson 90] <author> W. F. Opdyke and R. E. Johnson. </author> <title> Refactoring: An aid in designing application frameworks and evolving object-oriented systems. </title> <booktitle> Symposium on Object-Oriented Programming Emphasizing Practical Applications, </booktitle> <volume> 40(2), </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: The intrinsic difficulty of good object-oriented design in complex systems is emphasized by the growing popularity of design patterns, which can impart experience and design knowledge to software designers [Gamma et al. 93]. Opdyke proposes that refactoring existing class hierarchies can improve their maintainability and reusability <ref> [Opdyke 92, Opdyke & Johnson 90] </ref>. A refactoring activity changes the organization of an object-oriented program without changing its behavior. It includes changes such as encapsulating public references to member data in a new method or creating abstract superclasses from shared behavior in similar classes.
Reference: [Opdyke 92] <author> W. F. Opdyke. </author> <title> Refactoring Object-Oriented Frameworks. </title> <type> Ph.D. dissertation, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: The intrinsic difficulty of good object-oriented design in complex systems is emphasized by the growing popularity of design patterns, which can impart experience and design knowledge to software designers [Gamma et al. 93]. Opdyke proposes that refactoring existing class hierarchies can improve their maintainability and reusability <ref> [Opdyke 92, Opdyke & Johnson 90] </ref>. A refactoring activity changes the organization of an object-oriented program without changing its behavior. It includes changes such as encapsulating public references to member data in a new method or creating abstract superclasses from shared behavior in similar classes. <p> We also briefly describe how we used Elbereth to plan the addition of a new subclass. Although Elbereth is not currently integrated with a tool that performs refactorings for the programmer, it could be used as a graphical front-end for an automatic restructuring tool <ref> [Opdyke 92] </ref>. The tool implementation consists of approximately 21,000 lines of source code in 80 files. 12,000 of these lines and 11 of the files are code produced by the JavaCC parser generator [SunTest]. <p> The disadvantage is that the programmer must engage in a great deal of interaction, although the tool may provide composite transformations that can speed the task. Elbereth can serve as the user interface for an interactive restructuring tool like Opdyke's automated refactoring tool <ref> [Opdyke 92] </ref>. Bowdidge's restructuring tool uses the star diagram visualization in an analogous manner to perform automatic restructurings of Scheme programs [Bowdidge & Griswold 94, Bowdidge 95]. <p> Examples of such tools include Lieberherr's Demeter System [Lieberherr et al. 94] and Casais' tool for performing reorganization of class hierarchies [Casais 94]. The disadvantage with such tools is that the programmer loses control over the class design and the software may end up with a counterintuitive class structure <ref> [Opdyke 92, Casais 94] </ref>. Other visualization tools such as Rigi and Sniff can be used for planning refactorings [Muller et al. 92, Bischofberger 92]. However, they cannot serve as the user interface for a refactoring tool.
Reference: [SunTest] <institution> SunTest. JavaCC Home Page. </institution> <note> http://www.suntest.com/JavaCC/. 26 </note>
Reference-contexts: The tool implementation consists of approximately 21,000 lines of source code in 80 files. 12,000 of these lines and 11 of the files are code produced by the JavaCC parser generator <ref> [SunTest] </ref>. Since analysis of the generated files is largely irrelevant from the perspective of software design, we omitted them from our refactoring projects. The resulting source code then consists of 9,000 lines of source and 69 source files.
References-found: 15

