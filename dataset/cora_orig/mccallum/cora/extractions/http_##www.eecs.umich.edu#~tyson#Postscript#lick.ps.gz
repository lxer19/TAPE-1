URL: http://www.eecs.umich.edu/~tyson/Postscript/lick.ps.gz
Refering-URL: http://www.eecs.umich.edu/~tyson/publications.html
Root-URL: http://www.cs.umich.edu
Title: Hybrid Branch Prediction Using Limited Dual Path Execution  
Author: Kelsey Lynn Lick Professor Y. C. Hong 
Degree: A Thesis submitted in partial satisfaction of the requirements for the degree of Master of Science in Computer Science by  Thesis Committee: Professor Gary Tyson, Chairperson Professor Frank Vahid, Co-Chairperson  
Date: December, 1996  
Affiliation: UNIVERSITY OF CALIFORNIA RIVERSIDE  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> T. Ball and J. R. Larus. </author> <title> Branch prediction for free. </title> <type> Technical Report TN-1137, </type> <institution> CS Department, Univeristy of Wisconsin-Madison, </institution> <month> Feb </month> <year> 1993. </year>
Reference-contexts: Thus, this approach works well for loop-intensive programs. It achieves an average of 70% accuracy across a variety of benchmark applications [16]. A branch can also be predicted based on the opcode of the branch <ref> [1] </ref>. A study showed that "branch if negative", "branch if equal", and "branch if greater than or equal" are usually taken. This is due to these types of branches usually being used to terminate loops. This scheme tends to outperform the previously described methods by averaging 75% accuracy [16].
Reference: [2] <institution> UC Berkeley CPU Info Center. Cpu info and system performance summary. </institution> <note> Web address: http://infopad.eecs.berkeley.edu/CIC/summary/local/. </note>
Reference-contexts: This increase of stages between the fetch and execute directly leads to more cycles being wasted while the direction of the branch is decided. The trend towards processors with deeper pipelines and wider issue width can be seen by examining some real machines. The 80486 <ref> [2] </ref> uses a pipeline with 5 stages and an issue width of 1 and the Pentium has 5 stages with an increased issue width of 2. The more recent PentiumPro [2] has 14 stages in its pipeline and has increased its issue width to 3. 3 4 5 An early approach <p> The 80486 <ref> [2] </ref> uses a pipeline with 5 stages and an issue width of 1 and the Pentium has 5 stages with an increased issue width of 2. The more recent PentiumPro [2] has 14 stages in its pipeline and has increased its issue width to 3. 3 4 5 An early approach to reducing branch penalty involved the use of delay slots.
Reference: [3] <author> Po-Yung Chang, Eric Hao, and Yale N. Patt. </author> <title> Alternative implementations of hybrid branch predictors. </title> <booktitle> In Proceedings of the 28th Annual International Symposium on Microarchitecture (MICRO-28), </booktitle> <pages> pages 252-257, </pages> <month> Nov </month> <year> 1995. </year>
Reference-contexts: A selector is used to determine which predictor component to use for each branch. Hybrid predictors are useful in combining the strengths of its single predictors and thus achieving even higher accuracy <ref> [3] </ref>. McFarling's selector keeps track of which of the two predictors being used has the highest accuracy for that branch thus far, and then uses that prediction. After the branch is resolved the selector is incremented or decremented based on which predictor was correct. <p> A positive selector counter means that predictor 1 has been correct 24 more often than predictor 2. A negative counter means that predictor 2 has been correct more often. A hybrid predictor consisting of gshare and PAs was found <ref> [3] </ref> to achieve a prediction accuracy of around 97%. 2.3 Dual Path Execution To reduce the branch penalty to zero, dual path execution can be implemented. Dual Path Execution (DPE) executes the code on both paths of a branch.
Reference: [4] <author> J. A. Fisher and S. M. Freudenberger. </author> <title> Predicting conditional branch directions from previous runs of a program. </title> <booktitle> In Proceedings of the 5th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 85-95, </pages> <month> Oct </month> <year> 1992. </year>
Reference-contexts: Information gathered from profiling has been used to decrease the effects of branches on performance. The profile of a program gives the number of times that a basic block and control flow direction is executed [13]. The technique of profiling <ref> [4, 5, 6] </ref> uses data gathered from previous runs to determine the path 11 tendencies of branches. Most branches have a strong bias towards being either mostly TAKEN or mostly NOT-TAKEN. These biases can be found by running the program and keeping track of their patterns. <p> The second model, the limiting two-bit predictor, will take the opposite approach, letting cost be a factor. 29 Predictor sc heme T e Reference Av erage Accuracy Cost Branc h a static [16] 0 BTFNT static [9, ] 0 co based static [1, ] 0 Profiling static <ref> [4, 6, ] </ref> 0 dynamic [9, ] n o-bit dynamic [16] 2n dynamic [16] 128K As (6,16) dynamic [16] 8K gshare (12) dynamic [7] 8K gshare (18)/P As (15,4) dynamic [3, 97% T able 2.2: Summary of Branc h Prediction Sc hemes 30 Chapter 3 Assigning Confidence to Branch Prediction Hybrid
Reference: [5] <author> W-M Hwu, T. M. Conte, and P. P. Chang. </author> <title> Comparing software and hardware schemes for reducing the cost of branches. </title> <booktitle> In Proceedings of the 16th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 224-233, </pages> <month> May </month> <year> 1989. </year> <month> 73 </month>
Reference-contexts: Information gathered from profiling has been used to decrease the effects of branches on performance. The profile of a program gives the number of times that a basic block and control flow direction is executed [13]. The technique of profiling <ref> [4, 5, 6] </ref> uses data gathered from previous runs to determine the path 11 tendencies of branches. Most branches have a strong bias towards being either mostly TAKEN or mostly NOT-TAKEN. These biases can be found by running the program and keeping track of their patterns.
Reference: [6] <author> S. McFarling and J. Hennessy. </author> <title> Reducing the cost of branches. </title> <booktitle> In Proceedings of the 13th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 396-403, </pages> <year> 1986. </year>
Reference-contexts: Information gathered from profiling has been used to decrease the effects of branches on performance. The profile of a program gives the number of times that a basic block and control flow direction is executed [13]. The technique of profiling <ref> [4, 5, 6] </ref> uses data gathered from previous runs to determine the path 11 tendencies of branches. Most branches have a strong bias towards being either mostly TAKEN or mostly NOT-TAKEN. These biases can be found by running the program and keeping track of their patterns. <p> Another drawback to profiling is the time and effort it takes to run the program prior. This effort will prove to be worthwhile, however, if the program is one that is to be run frequently. The average accuracy of this scheme was found to be 85% <ref> [6] </ref>. 2.2 Dynamic Schemes An increase in prediction accuracy can be gained by allowing the predictor to adapt to changes during the program. Dynamic prediction methods use information gathered at run-time to determine the prediction path.
Reference: [7] <author> Scott McFarling. </author> <title> Combining branch predictors. </title> <type> Technical Report TN-36, </type> <institution> DEC-WRL, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: PAs was found to be the best design for the cost. It can achieve an average of 96% accuracy. 2.2.4 Gshare Gshare is a variant on the two-level scheme which McFarling <ref> [7] </ref> introduced as a way to use both the branch address and the global history to gain more accuracy than pure global schemes. <p> Hybrid branch predictors were introduced as a means to use several predictors at once in order to take advantage of the best predictor at a particular time in the program. McFarling proposed the first hybrid 23 branch predictor <ref> [7] </ref> which combines various predictor methods into a single scheme. A selector is used to determine which predictor component to use for each branch. Hybrid predictors are useful in combining the strengths of its single predictors and thus achieving even higher accuracy [3]. <p> heme T e Reference Av erage Accuracy Cost Branc h a static [16] 0 BTFNT static [9, ] 0 co based static [1, ] 0 Profiling static [4, 6, ] 0 dynamic [9, ] n o-bit dynamic [16] 2n dynamic [16] 128K As (6,16) dynamic [16] 8K gshare (12) dynamic <ref> [7] </ref> 8K gshare (18)/P As (15,4) dynamic [3, 97% T able 2.2: Summary of Branc h Prediction Sc hemes 30 Chapter 3 Assigning Confidence to Branch Prediction Hybrid branch predictors have been introduced to exploit the strengths of its single scheme components.
Reference: [8] <author> B. Ramakrishna Rau and Joseph A. Fisher. </author> <title> Instruction-level parallel processing: History, overview, and perspective. </title> <journal> The Journal of Supercomputing, </journal> <month> Oct </month> <year> 1992. </year>
Reference-contexts: Similarly, architectures that allow multiple independent instructions to be executed at the same time are said to exploit ILP. Thus, normal sequential execution can be replaced by executing instructions in an order that exploits instruction level parallelism. Previous studies <ref> [8, 12] </ref> have shown, however, that there are limits to the amount of parallelism that can be found within programs, often limited by the basic block size.
Reference: [9] <author> J. E. Smith. </author> <title> A study of branch prediction strategies. </title> <booktitle> In Proceedings of the 8th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 135-148, </pages> <month> May </month> <year> 1981. </year>
Reference-contexts: An average of 60% accuracy [16] is obtained using this technique. Programs with many loops may even obtain accuracies as high as 90% or more. An improved static scheme is to use the direction to the target address as a means of predicting the branch <ref> [9] </ref>. If the branch is a backward branch, the target address has a lower address than the branch address, the branch is predicted to be taken. Forward branches are predicted to not be taken. This scheme also targets loops in order to achieve its higher accuracy. <p> Thus, the prediction can vary during the run of the program, adapting to branch patterns and changes in the program. 2.2.1 One-bit Prediction A simple version of dynamic prediction is to make the prediction based on the direction the branch took the last time it was executed <ref> [9] </ref>. This can be done on a per-branch basis or based on the direction of the last execution of any branch.
Reference: [10] <author> Augustus K. Uht. </author> <title> Reducing the ill effects of branches. </title> <note> To appear in: IEEE COMPUTER, </note> <year> 1996. </year>
Reference-contexts: Due to one branch leading to another, a cascading effect can occur causing the resources that would be necessary for this method to be extremely high and even unrealizable in particular implementations or programs. In order to limit the cost necessary for dual path execution Uht <ref> [11, 10] </ref> proposed Disjoint Eager Execution (DEE) which limits the number of concurrent executing paths by using a selector to decide which paths to execute. The overall probability of each path is calculated; this is referred to as cp, the cumulative probability.
Reference: [11] <author> Augustus K. Uht and Vijay Sindagi. </author> <title> Disjoint eager execution: An optimal form of speculative execution. </title> <booktitle> In Proceedings of the 28th Annual International Symposium on Microarchitecture (MICRO-28), </booktitle> <pages> pages 313-325, </pages> <month> Nov </month> <year> 1995. </year>
Reference-contexts: Due to one branch leading to another, a cascading effect can occur causing the resources that would be necessary for this method to be extremely high and even unrealizable in particular implementations or programs. In order to limit the cost necessary for dual path execution Uht <ref> [11, 10] </ref> proposed Disjoint Eager Execution (DEE) which limits the number of concurrent executing paths by using a selector to decide which paths to execute. The overall probability of each path is calculated; this is referred to as cp, the cumulative probability. <p> If the paths that had the highest cps were the paths that were actually taken, then the execution would proceed 2 branches farther down the path with fewer instructions needing to be undone. Disjoint eager execution was shown <ref> [11] </ref> to perform better than other predictors and dual path execution for the same cost. 2.4 New Branch Prediction Approaches This thesis will combine the Dual Path Execution model with a current branch predictor to form a hybrid predictor that can use the strengths of each.
Reference: [12] <author> David W. Wall. </author> <title> Limits of instruction-level parallelism. </title> <booktitle> In Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 176-188, </pages> <year> 1991. </year>
Reference-contexts: Similarly, architectures that allow multiple independent instructions to be executed at the same time are said to exploit ILP. Thus, normal sequential execution can be replaced by executing instructions in an order that exploits instruction level parallelism. Previous studies <ref> [8, 12] </ref> have shown, however, that there are limits to the amount of parallelism that can be found within programs, often limited by the basic block size.
Reference: [13] <author> Yougend Wu and James R. Larus. </author> <title> Static branch frequency and program profile analysis. </title> <booktitle> In Proceedings of the 27th Annual International Symposium on Microarchitecture (MICRO-27), </booktitle> <pages> pages 1-11, </pages> <month> Nov </month> <year> 1994. </year> <month> 74 </month>
Reference-contexts: This scheme tends to outperform the previously described methods by averaging 75% accuracy [16]. Information gathered from profiling has been used to decrease the effects of branches on performance. The profile of a program gives the number of times that a basic block and control flow direction is executed <ref> [13] </ref>. The technique of profiling [4, 5, 6] uses data gathered from previous runs to determine the path 11 tendencies of branches. Most branches have a strong bias towards being either mostly TAKEN or mostly NOT-TAKEN.
Reference: [14] <author> T-Y Yeh and Y. N. Patt. </author> <title> Alternative implementations of two-level adaptive branch prediction. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 124-134, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Thus the accuracy of the 2-bit predictor can achieve higher accuracies for loop-intensive programs as well as those in which branches have strong tendencies towards one direction. It averages an accuracy of around 92% [16]. 2.2.3 Two-Level Adaptive Yeh and Patt proposed a two-level adaptive scheme <ref> [14, 15] </ref> to take advantage of history-based branch correlation. The first level keeps track of the direction of the last k branches. This information is kept in a register called the Branch History 16 Register (BHR). <p> Also, the state of the two-bit counter for the branch history pattern is updated. The two-level adaptive approach has nine variations that are based on changing the associativity of both levels <ref> [14, 16] </ref>. The possibilities for the first level are global (G) which means that k is the last of all branches encountered and that all the branches map to the same BHR. The next two options use a table of branch history registers called the Branch History Register Table (BHRT).
Reference: [15] <author> T-Y Yeh and Y. N. Patt. </author> <title> A comparison of dynamic branch predictors that use two levels of branch history. </title> <booktitle> In Proceedings of the 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 257-266, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Thus the accuracy of the 2-bit predictor can achieve higher accuracies for loop-intensive programs as well as those in which branches have strong tendencies towards one direction. It averages an accuracy of around 92% [16]. 2.2.3 Two-Level Adaptive Yeh and Patt proposed a two-level adaptive scheme <ref> [14, 15] </ref> to take advantage of history-based branch correlation. The first level keeps track of the direction of the last k branches. This information is kept in a register called the Branch History 16 Register (BHR).
Reference: [16] <author> Tse-Yu Yeh. </author> <title> Two-Level Adaptive Branch Prediction and Instruction Fetch Mechanisms for High Performance Superscalar Processors. </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <year> 1993. </year> <month> 75 </month>
Reference-contexts: This is called the Branch Always method. This method usually increases performance since it has been found that the majority of branches are taken. The results, however, vary greatly between different programs based on the programmer awareness and the compiler. An average of 60% accuracy <ref> [16] </ref> is obtained using this technique. Programs with many loops may even obtain accuracies as high as 90% or more. An improved static scheme is to use the direction to the target address as a means of predicting the branch [9]. <p> Loops are a common occurrence in programs and have a strong tendency to be terminated by backward conditional branches that are disproportionately taken. Thus, this approach works well for loop-intensive programs. It achieves an average of 70% accuracy across a variety of benchmark applications <ref> [16] </ref>. A branch can also be predicted based on the opcode of the branch [1]. A study showed that "branch if negative", "branch if equal", and "branch if greater than or equal" are usually taken. This is due to these types of branches usually being used to terminate loops. <p> A study showed that "branch if negative", "branch if equal", and "branch if greater than or equal" are usually taken. This is due to these types of branches usually being used to terminate loops. This scheme tends to outperform the previously described methods by averaging 75% accuracy <ref> [16] </ref>. Information gathered from profiling has been used to decrease the effects of branches on performance. The profile of a program gives the number of times that a basic block and control flow direction is executed [13]. <p> The actual path of the branch determines the state the counter is set to next. This scheme helps increase performance for programs that are loop-intensive since loops tend to go in one direction for several iterations. This simple dynamic scheme obtains an accuracy averaging 85% <ref> [16] </ref>. 2.2.2 Two-bit Counter Further improvement in prediction accuracy can be made by increasing the amount of history that is kept for each branch. Two-bit saturating up-down counters are employed to maintain information about previous branch activity. Figure 2.2 13 shows the state transitions for this approach. <p> Later, the branch may be executed again and the same pattern may be seen. Thus the accuracy of the 2-bit predictor can achieve higher accuracies for loop-intensive programs as well as those in which branches have strong tendencies towards one direction. It averages an accuracy of around 92% <ref> [16] </ref>. 2.2.3 Two-Level Adaptive Yeh and Patt proposed a two-level adaptive scheme [14, 15] to take advantage of history-based branch correlation. The first level keeps track of the direction of the last k branches. This information is kept in a register called the Branch History 16 Register (BHR). <p> Also, the state of the two-bit counter for the branch history pattern is updated. The two-level adaptive approach has nine variations that are based on changing the associativity of both levels <ref> [14, 16] </ref>. The possibilities for the first level are global (G) which means that k is the last of all branches encountered and that all the branches map to the same BHR. The next two options use a table of branch history registers called the Branch History Register Table (BHRT). <p> The DPE hybrid model will show that current implementations can be combined to achieve even higher accuracy. The second model, the limiting two-bit predictor, will take the opposite approach, letting cost be a factor. 29 Predictor sc heme T e Reference Av erage Accuracy Cost Branc h a static <ref> [16] </ref> 0 BTFNT static [9, ] 0 co based static [1, ] 0 Profiling static [4, 6, ] 0 dynamic [9, ] n o-bit dynamic [16] 2n dynamic [16] 128K As (6,16) dynamic [16] 8K gshare (12) dynamic [7] 8K gshare (18)/P As (15,4) dynamic [3, 97% T able 2.2: Summary <p> will take the opposite approach, letting cost be a factor. 29 Predictor sc heme T e Reference Av erage Accuracy Cost Branc h a static <ref> [16] </ref> 0 BTFNT static [9, ] 0 co based static [1, ] 0 Profiling static [4, 6, ] 0 dynamic [9, ] n o-bit dynamic [16] 2n dynamic [16] 128K As (6,16) dynamic [16] 8K gshare (12) dynamic [7] 8K gshare (18)/P As (15,4) dynamic [3, 97% T able 2.2: Summary of Branc h Prediction Sc hemes 30 Chapter 3 Assigning Confidence to Branch Prediction Hybrid branch predictors have been introduced to exploit the strengths of <p> opposite approach, letting cost be a factor. 29 Predictor sc heme T e Reference Av erage Accuracy Cost Branc h a static <ref> [16] </ref> 0 BTFNT static [9, ] 0 co based static [1, ] 0 Profiling static [4, 6, ] 0 dynamic [9, ] n o-bit dynamic [16] 2n dynamic [16] 128K As (6,16) dynamic [16] 8K gshare (12) dynamic [7] 8K gshare (18)/P As (15,4) dynamic [3, 97% T able 2.2: Summary of Branc h Prediction Sc hemes 30 Chapter 3 Assigning Confidence to Branch Prediction Hybrid branch predictors have been introduced to exploit the strengths of its single scheme <p> a factor. 29 Predictor sc heme T e Reference Av erage Accuracy Cost Branc h a static <ref> [16] </ref> 0 BTFNT static [9, ] 0 co based static [1, ] 0 Profiling static [4, 6, ] 0 dynamic [9, ] n o-bit dynamic [16] 2n dynamic [16] 128K As (6,16) dynamic [16] 8K gshare (12) dynamic [7] 8K gshare (18)/P As (15,4) dynamic [3, 97% T able 2.2: Summary of Branc h Prediction Sc hemes 30 Chapter 3 Assigning Confidence to Branch Prediction Hybrid branch predictors have been introduced to exploit the strengths of its single scheme components.
References-found: 16

