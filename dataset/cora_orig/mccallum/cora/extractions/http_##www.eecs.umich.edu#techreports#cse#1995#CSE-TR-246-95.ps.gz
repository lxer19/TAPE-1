URL: http://www.eecs.umich.edu/techreports/cse/1995/CSE-TR-246-95.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse95.html
Root-URL: http://www.eecs.umich.edu
Email: e-mail: kuno@umich.edu, rundenst@eecs.umich.edu  
Phone: fax: (313) 763-1503 phone: (313) 936-2971  
Title: The MultiView OODB View System: Design and Implementation  
Author: Harumi A. Kuno and Elke A. Rundensteiner 
Address: 1301 Beal Avenue Ann Arbor, MI 48109-2122  
Affiliation: Dept. of Elect. Engineering and Computer Science Software Systems Research Laboratory The University of Michigan,  
Abstract: Views are an established technique for restructuring and repartitioning the format of data, classes, and schemata so that applications can customize shared data objects without affecting other applications' perceptions of the data. The MultiView system is one of the first OODB systems to support dynamic and updatable materialized object-oriented database views. MultiView is fully functional and is being used for a number of projects. In this paper, we describe our system's architecture, the services it provides, and the decisions we made during our implementation. Although the GemStone system we chose for our implementation base offers many features that greatly aided our implementation, it does not support several key object-model properties that are critical for the realization of our design principles. These fundamental properties include multiple classification, dynamic object-restructuring, and the ability to make dynamic changes to the schema. In this paper, we describe a flexible and powerful technique known as object-slicing that we adopted to construct the MultiView object model this now successfully addresses our requirements. The MultiView system is distinguished by a number of unique features, including the incorporation of virtual classes into the global schema as first-class database citizens, support for capacity-augmenting views (virtual classes that add new extrinsic properties or behavior), view materialization strategies that take advantage of object-oriented modeling features, and a graphical interface that is tailored to provide easy access to the MultiView system. The resulting system preserves all of the capabilities of the underlying GemStone OODB while providing support for dynamic and updatable materialized object-oriented views. fl This work was supported in part by the NSF RIA grant #IRI-9309076, NSF NYI grant #IRI 94-57609, and the University of Michigan Faculty Award Program. We would also like to thank our industrial sponsors, in particular, AT&T, Illustra, and Intel. Harumi Kuno is grateful for support from the NASA Graduate Student Researchers Program. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and A. Bonner. </author> <title> Objects and views. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 238-247, </pages> <year> 1991. </year>
Reference-contexts: In fact, this provides us with a basis for the arbitrary restructuring of an object's look and feel without compromising its identity. Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 6, 15, 26, 36, 39] </ref>. MultiView differs from other view systems in that it does not simply adopt assumptions made by current OODB architectures; instead we re-examine key features required as foundation for views. <p> Finally, the last approach completely ignores the issue of classification, thus resulting in a flat class structure. O2 Views [26] [35], based on Abiteboul and Bonner <ref> [1] </ref>, is the first and only commercial implementation of an object-oriented view management system, currently realized.
Reference: [2] <author> R. Agrawal and H. V. Jagadish. </author> <title> Materialization and incremental update of path information. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 374-383, </pages> <year> 1989. </year>
Reference-contexts: Finally, we conclude in Section 8 with a summary of the implementation status of MultiView, and a discussion of our contributions and future work. 2 Related Work Relational Versus Object-Oriented Views. View mechanisms have been extensively studied for the relational model by <ref> [7, 13, 2, 16] </ref>. Although we can benefit from this work, there are some significant differences between relational and object-oriented views. * Tables in relational databases (RDBs) are arranged in a "flat" fashion in the schema.
Reference: [3] <author> T. Atwood, R. Cattell, J. Duhl, G. Ferran, and D. Wade. </author> <title> The ODMG object model. </title> <journal> Journal of Object Oriented Programming, </journal> <pages> pages 64-69, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: J. Kim [18]. Furthermore, the proposed ODMG standard <ref> [3] </ref> recently formulated by several key OODB vendors also follows this approach.
Reference: [4] <author> T. Barsalou, N. Siambela, A. M. Keller, and G. Wiederhold. </author> <title> Updating relational databases through object-based views. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 248-257, </pages> <year> 1991. </year>
Reference: [5] <author> E. Bertino. </author> <title> Integration of heterogeneous data repositories by using object-oriented views. </title> <booktitle> International Workshop on Interoperability in Multidatabase Systems, </booktitle> <pages> pages 22-29, </pages> <month> April </month> <year> 1991. </year>
Reference: [6] <author> E. Bertino. </author> <title> A view mechanism for object-oriented databases. </title> <booktitle> In 3rd International Conference on Extending Database Technology, </booktitle> <pages> pages 136-151, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: In fact, this provides us with a basis for the arbitrary restructuring of an object's look and feel without compromising its identity. Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 6, 15, 26, 36, 39] </ref>. MultiView differs from other view systems in that it does not simply adopt assumptions made by current OODB architectures; instead we re-examine key features required as foundation for views. <p> require the user to specify explicitly the relationship between a virtual class and existing base classes [18, 41]; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [36]; or (3) simply relate a virtual class with its source class via a derived-from relationship <ref> [6] </ref>, (4) or with the root of the schema [15, 19]. The first approach is vulnerable to potential consistency problems, since the users might introduce an inconsistency in the schema graph by inserting is-a arcs between two classes not related by a subclass relationship. <p> In addition, MultiView supports capacity-augmenting virtual classes. First introduced by <ref> [6] </ref>, a capacity-augmenting virtual class is a virtual class that includes instance variables that are not derived from the source classes of the virtual class.
Reference: [7] <author> J. Blakeley, P. Larson, and F. Tompa. </author> <title> Efficiently updating materialized views. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 61-71, </pages> <year> 1986. </year>
Reference-contexts: Finally, we conclude in Section 8 with a summary of the implementation status of MultiView, and a discussion of our contributions and future work. 2 Related Work Relational Versus Object-Oriented Views. View mechanisms have been extensively studied for the relational model by <ref> [7, 13, 2, 16] </ref>. Although we can benefit from this work, there are some significant differences between relational and object-oriented views. * Tables in relational databases (RDBs) are arranged in a "flat" fashion in the schema. <p> Our research on view materialization in OODBs borrows several techniques from the relational arena. <ref> [7, 8] </ref> tests modified tuples to see if they fulfill view predicates, thereby detecting irrelevant and autonomously computable updates. This resembles our solution of filtering irrelevant updates by exploiting the generalization hierarchy and the derivation structure.
Reference: [8] <author> J. A. Blakeley, N. Coburn, and P-A Larson. </author> <title> Updating derived relations: Detecting irrelevant and autonomously computable updates. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(3) </volume> <pages> 369-400, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Our research on view materialization in OODBs borrows several techniques from the relational arena. <ref> [7, 8] </ref> tests modified tuples to see if they fulfill view predicates, thereby detecting irrelevant and autonomously computable updates. This resembles our solution of filtering irrelevant updates by exploiting the generalization hierarchy and the derivation structure.
Reference: [9] <author> M. J. Carey, D. J. DeWitt, and J. F. Naughton. </author> <title> The OO7 benchmark. </title> <booktitle> SIGMOD, </booktitle> <year> 1993. </year>
Reference-contexts: Object-Slicing Architecture 19 In order to determine the base cost of implementing the object-slicing representation paradigm, we have run test queries from the University of Wisconsin's OO7 benchmark suite <ref> [9] </ref> with the intention of comparing GemStone's native implementation versus our object-slicing extension to GemStone. For this study, we used MultiView to create and populate the OO7 benchmark's parts-assembly database with 10,000 Atomic Parts.
Reference: [10] <author> S. Ceri and J. Widom. </author> <title> Deriving production rules for incremental view maintenance. </title> <booktitle> In International Conference on Very Large Data Bases, </booktitle> <pages> pages 577-589, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: This resembles our solution of filtering irrelevant updates by exploiting the generalization hierarchy and the derivation structure. The system provided by <ref> [10] </ref> performs incremental view maintenance using production rules that are triggered by update operations. Similarly, we override generic-update operations with type-specific update operators for virtual classes. However, there are significant differences between view materialization in OODBs and relational systems.
Reference: [11] <author> D.H. Fishman. </author> <title> Iris: An object oriented database management system. </title> <journal> In ACM Transactions on Office Information Systems, </journal> <volume> volume 5, </volume> <pages> pages 48-69, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Rather than handle an object as being of a single fixed type, a MultiView object is distributed among multiple object-slicing implementation objects. The Iris functional database system resembles our system in that, being built on top of a relational engine, it distributes data over several relational tables <ref> [11] </ref>. Iris does not support view mechanisms, and does not address issues of classification, inheritance for virtual classes, etc. Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. <p> To the best of our knowledge, current OODB systems do not support multiple classification | with the exception of IRIS <ref> [11] </ref>, which is a functional database system that uses a relational database as a storage system, to store data from one object across many relations 6 . Inspired by this approach we have developed an object-slicing technique to address these advanced features in the context of the OODB technology [29].
Reference: [12] <author> G. Gottlob, M. Schrefl, and B. Rock. </author> <title> Extending object-oriented systems with roles. </title> <type> manuscript, </type> <year> 1993. </year>
Reference-contexts: These requirements include multiple classification and dynamic object migration. The flexibility offered by the object-slicing approach naturally lends itself to implementing role systems: object-slicing's implementation objects can easily be adapted to represent the various roles of objects in a role system <ref> [12] </ref>. Although the object-slicing techniques underlying the current implementation of MultiView can be compared to mechanisms used in role modeling approaches [12, 27], no other research in the literature discusses the application of the object-slicing paradigm regarding the support of object-oriented views. <p> Although the object-slicing techniques underlying the current implementation of MultiView can be compared to mechanisms used in role modeling approaches <ref> [12, 27] </ref>, no other research in the literature discusses the application of the object-slicing paradigm regarding the support of object-oriented views. In role modeling systems, objects dynamically gain and lose multiple interfaces (a.k.a. roles) throughout their lifetimes. <p> This achieves an efficient and uniform inheritance scheme. Also, unlike many role systems, in our implementation conceptual objects can be associated with at most one implementation object of a given type <ref> [12] </ref>. Role systems do not deal with the issues of virtual class derivation, classification, nor with method promotion. The role system proposed by Gottlob et al. was implemented using techniques similar to object-slicing [12]. This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. The difference between [12] <p> our implementation conceptual objects can be associated with at most one implementation object of a given type <ref> [12] </ref>. Role systems do not deal with the issues of virtual class derivation, classification, nor with method promotion. The role system proposed by Gottlob et al. was implemented using techniques similar to object-slicing [12]. This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. The difference between [12] and our implementation is that [12] is a role system while we are developing a view system. Also, the [12] system does not permit the derivation of new virtual classes, and thus does <p> <ref> [12] </ref>. Role systems do not deal with the issues of virtual class derivation, classification, nor with method promotion. The role system proposed by Gottlob et al. was implemented using techniques similar to object-slicing [12]. This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. The difference between [12] and our implementation is that [12] is a role system while we are developing a view system. Also, the [12] system does not permit the derivation of new virtual classes, and thus does not address issues related to view management. Deputy Mechanisms. <p> The role system proposed by Gottlob et al. was implemented using techniques similar to object-slicing <ref> [12] </ref>. This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. The difference between [12] and our implementation is that [12] is a role system while we are developing a view system. Also, the [12] system does not permit the derivation of new virtual classes, and thus does not address issues related to view management. Deputy Mechanisms. <p> system proposed by Gottlob et al. was implemented using techniques similar to object-slicing <ref> [12] </ref>. This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. The difference between [12] and our implementation is that [12] is a role system while we are developing a view system. Also, the [12] system does not permit the derivation of new virtual classes, and thus does not address issues related to view management. Deputy Mechanisms. The Deputy Mechanisms proposed by Peng and Kambayashi unify the concepts of object views, roles, and migration in the form of deputy objects and deputy classes [28]. <p> Because although object-slicing is a known technique that is being utilized for view systems [24], schema evolution [30], and role systems <ref> [12] </ref>, to our knowledge no other work has been done evaluating the costs of object-slicing, we were motivated to perform some initial experiments evaluating the relative costs and benefits of adopting the object-slicing techniques. The results of these experiments are presented in [21].
Reference: [13] <author> E. N. Hanson. </author> <title> A performance analysis of view materialization strategies. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 440-453, </pages> <year> 1987. </year>
Reference-contexts: Finally, we conclude in Section 8 with a summary of the implementation status of MultiView, and a discussion of our contributions and future work. 2 Related Work Relational Versus Object-Oriented Views. View mechanisms have been extensively studied for the relational model by <ref> [7, 13, 2, 16] </ref>. Although we can benefit from this work, there are some significant differences between relational and object-oriented views. * Tables in relational databases (RDBs) are arranged in a "flat" fashion in the schema.
Reference: [14] <author> M. Hardwick and B. R. Downie. </author> <title> On object-oriented databases, materialized views, </title> <booktitle> and concurrent engineering. In Proceedings of the 1991 ASME International Computers for Engineering Conference and Exposition. Engineering Databases: An Engineering Resource, </booktitle> <year> 1991. </year>
Reference-contexts: Thus, when an object is updated, the update method triggers a notification function that informs all virtual classes that have registered with the class of the update to the object. Only a few published papers address issues of view materialization in OODBs. <ref> [14] </ref> provide a view materialization model in which updates are propagated by use of change files, representing histories of design sessions. However, [14] duplicate objects (including identifiers) for virtual classes rather than merely storing references to objects. [20] address maintaining consistency for a particular type of join class formed along an <p> Only a few published papers address issues of view materialization in OODBs. <ref> [14] </ref> provide a view materialization model in which updates are propagated by use of change files, representing histories of design sessions. However, [14] duplicate objects (including identifiers) for virtual classes rather than merely storing references to objects. [20] address maintaining consistency for a particular type of join class formed along an existing path in the aggregation graph.
Reference: [15] <author> S. Heiler and S. B. Zdonik. </author> <title> Object views: Extending the vision. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 86-93, </pages> <year> 1990. </year>
Reference-contexts: In fact, this provides us with a basis for the arbitrary restructuring of an object's look and feel without compromising its identity. Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 6, 15, 26, 36, 39] </ref>. MultiView differs from other view systems in that it does not simply adopt assumptions made by current OODB architectures; instead we re-examine key features required as foundation for views. <p> a virtual class and existing base classes [18, 41]; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [36]; or (3) simply relate a virtual class with its source class via a derived-from relationship [6], (4) or with the root of the schema <ref> [15, 19] </ref>. The first approach is vulnerable to potential consistency problems, since the users might introduce an inconsistency in the schema graph by inserting is-a arcs between two classes not related by a subclass relationship.
Reference: [16] <author> H. Jakobsson. </author> <title> On materializing views and on-line queries. </title> <booktitle> In ICDT, </booktitle> <pages> pages 407-420, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Finally, we conclude in Section 8 with a summary of the implementation status of MultiView, and a discussion of our contributions and future work. 2 Related Work Relational Versus Object-Oriented Views. View mechanisms have been extensively studied for the relational model by <ref> [7, 13, 2, 16] </ref>. Although we can benefit from this work, there are some significant differences between relational and object-oriented views. * Tables in relational databases (RDBs) are arranged in a "flat" fashion in the schema.
Reference: [17] <author> M. Kaul, K. Drosten, and E. J. Neuhold. Viewsystem: </author> <title> Integrating heterogeneous information bases by object-oriented views. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 2-10, </pages> <month> February </month> <year> 1990. </year> <note> Acknowledgements and Thanks 28 </note>
Reference: [18] <author> H. J. Kim. </author> <title> Issues in Object-Oriented Database Systems. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: Note that our approach of providing for the integration of virtual classes into a single unified global schema is distinct from others found in the literature. Existing approaches either: (1) require the user to specify explicitly the relationship between a virtual class and existing base classes <ref> [18, 41] </ref>; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [36]; or (3) simply relate a virtual class with its source class via a derived-from relationship [6], (4) or with the root of the schema [15, 19]. <p> Others define view schemata through the manipulation of the object schema graph rather than solely by query languages. Tanaka et al. [41] propose that view schemata be defined by manually manipulating the edges in the global schema graph. Kim also uses DAG rearrangement for view schema definition <ref> [18] </ref>. Such DAG manipulation approaches must deal with the issues of (1) possibly introducing inconsistencies into the view schema due to human error and of (2) unintentionally modifying the semantics of a virtual class due to side effects of graph manipulation. View Materialization Research. <p> Although there is no general agreement on whether or not classes in OODBs should incorporate their own extents rather than requiring users to maintain their own collections of class-instances, several systems follow this philosophy, including Orion and the system proposed by H. J. Kim <ref> [18] </ref>. Furthermore, the proposed ODMG standard [3] recently formulated by several key OODB vendors also follows this approach.
Reference: [19] <author> W. Kim. </author> <title> A model of queries in object-oriented databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 423-432, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: a virtual class and existing base classes [18, 41]; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [36]; or (3) simply relate a virtual class with its source class via a derived-from relationship [6], (4) or with the root of the schema <ref> [15, 19] </ref>. The first approach is vulnerable to potential consistency problems, since the users might introduce an inconsistency in the schema graph by inserting is-a arcs between two classes not related by a subclass relationship.
Reference: [20] <author> S. Konomi, T. Furukawa, and Y. Kambayashi. </author> <title> Super-key classes for updating materialized derived classes in object bases. </title> <booktitle> In International Conference on Deductive and Object-Oriented Databases, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: Only a few published papers address issues of view materialization in OODBs. [14] provide a view materialization model in which updates are propagated by use of change files, representing histories of design sessions. However, [14] duplicate objects (including identifiers) for virtual classes rather than merely storing references to objects. <ref> [20] </ref> address maintaining consistency for a particular type of join class formed along an existing path in the aggregation graph. Our work instead focuses on the exploitation of the structure of the schema hierarchy and derivation dependency graph in order to reduce update propagation.
Reference: [21] <author> H. A. Kuno, Y. G. Ra, and E. A. Rundensteiner. </author> <title> The object-slicing technique: A flexible object representation and its evaluation. </title> <type> Technical Report CSE-TR-241-95, </type> <institution> University of Michigan, </institution> <year> 1995. </year>
Reference-contexts: The results of these experiments are presented in <ref> [21] </ref>. In the remainder of this section, we summarize the conclusions of our evaluation. In evaluating the performance of databases, I/O operation time typically dominates CPU operation time. Consequently, an evaluation of object-slicing must consider the effect of object-slicing on I/O time. <p> it is preferable to cluster the implementation objects by class (which we call class clustering), and under which circumstances it is better to cluster all the components of a MultiView object together (which we term object clustering), we designed and carried out an extensive experimental study evaluating both clustering techniques <ref> [21] </ref>. Based on these results, we conclude that as in a conventional architecture, various types of access patterns can best be optimized by providing distinct types of clustering techniques. <p> In a related paper, we explore the use of clustering to ameliorate the overhead of the object-slicing technique employed by our implementation <ref> [21] </ref>. Because it is one of the only implemented view systems, MultiView is currently being used in a number of projects.
Reference: [22] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Implementation experience with building an object-oriented view management system. </title> <type> Technical Report CSE-TR-191-93, </type> <institution> Univ. of Michigan, </institution> <address> Ann Arbor, </address> <year> 1993. </year>
Reference: [23] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Incremental update propagation algorithms for materialized object-oriented views in MultiView. </title> <type> Technical report, </type> <institution> Univ. of Michigan, </institution> <address> Ann Arbor, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: The code used to implement object-slicing makes up about 5% of the total code. The graphic interface was implemented separately, using Tcl. We have performed several studies to evaluate the MultiView system and its embedded algorithms. Our experiments demonstrate the benefit of techniques used by our update propagation algorithms <ref> [23] </ref>. Namely, we show that the potential problems of self-cancelling propagation and of early branch condition termination are indeed handled by our solution and result in significant performance gains.
Reference: [24] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Materialized object-oriented views in MultiView. </title> <booktitle> In ACM Research Issues in Data Engineering Workshop, </booktitle> <pages> pages 78-85, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Because although object-slicing is a known technique that is being utilized for view systems <ref> [24] </ref>, schema evolution [30], and role systems [12], to our knowledge no other work has been done evaluating the costs of object-slicing, we were motivated to perform some initial experiments evaluating the relative costs and benefits of adopting the object-slicing techniques. The results of these experiments are presented in [21].
Reference: [25] <author> J. Martin and J. Odell. </author> <title> Object-Oriented Analysis and Design. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1992. </year>
Reference-contexts: In object-slicing, a real-world object corresponds to a hierarchy of implementation objects (one for each class whose type the object possesses) linked to a conceptual object (used to represent the object-itself) rather than associating one implementation with each conceptual object as is commonly assumed in OODB systems <ref> [25] </ref>. For example, Figure 14 depicts a schema composed of two base classes, Cat and HouseCat, and two virtual classes, HeavyCat (derived from a selection query upon the Cat class) and DietingHeavyCat (derived by refining HeavyCat to add a new instance variable, diet).
Reference: [26] <author> O2 Technology. </author> <title> O2 Views User Manual, </title> <note> version 1 edition, </note> <month> December </month> <year> 1993. </year>
Reference-contexts: In fact, this provides us with a basis for the arbitrary restructuring of an object's look and feel without compromising its identity. Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 6, 15, 26, 36, 39] </ref>. MultiView differs from other view systems in that it does not simply adopt assumptions made by current OODB architectures; instead we re-examine key features required as foundation for views. <p> Finally, the last approach completely ignores the issue of classification, thus resulting in a flat class structure. O2 Views <ref> [26] </ref> [35], based on Abiteboul and Bonner [1], is the first and only commercial implementation of an object-oriented view management system, currently realized.
Reference: [27] <author> M. P. Papazoglou. </author> <title> Roles: A methodology for representing multifaceted objects. </title> <booktitle> In International Conference on Database and Expert Systems Applications, </booktitle> <pages> pages 7-12. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Although the object-slicing techniques underlying the current implementation of MultiView can be compared to mechanisms used in role modeling approaches <ref> [12, 27] </ref>, no other research in the literature discusses the application of the object-slicing paradigm regarding the support of object-oriented views. In role modeling systems, objects dynamically gain and lose multiple interfaces (a.k.a. roles) throughout their lifetimes.
Reference: [28] <author> Z. Peng and Y. Kambayashi. </author> <title> Deputy mechanisms for object-oriented databases. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 333-340, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Deputy Mechanisms. The Deputy Mechanisms proposed by Peng and Kambayashi unify the concepts of object views, roles, and migration in the form of deputy objects and deputy classes <ref> [28] </ref>. In the deputy mechanism paradigm, view objects are treated as roles of database objects. The deputy mechanism object model is probably the work most closely related to MultiView's. In particular, the similarities of the two systems include the following: Both support capacity-augmenting views, dynamic classification, and multiple classification.
Reference: [29] <author> Y. G. Ra, H. A. Kuno, and E. A. Rundensteiner. </author> <title> A flexible object-oriented database model and implementation for capacity-augmenting views. </title> <type> Technical Report CSE-TR-215-94, </type> <institution> University of Michigan, </institution> <year> 1994. </year>
Reference-contexts: Inspired by this approach we have developed an object-slicing technique to address these advanced features in the context of the OODB technology <ref> [29] </ref>.
Reference: [30] <author> Y. G. Ra and E. A. Rundensteiner. </author> <title> A transparent object-oriented schema change approach using view schema evolution. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: Because although object-slicing is a known technique that is being utilized for view systems [24], schema evolution <ref> [30] </ref>, and role systems [12], to our knowledge no other work has been done evaluating the costs of object-slicing, we were motivated to perform some initial experiments evaluating the relative costs and benefits of adopting the object-slicing techniques. The results of these experiments are presented in [21].
Reference: [31] <author> E. A. Rundensteiner. </author> <title> MultiView: A methodology for supporting multiple views in object-oriented databases. </title> <booktitle> In 18th VLDB Conference, </booktitle> <pages> pages 187-198, </pages> <year> 1992. </year>
Reference-contexts: Figure 8 displays the view-forming queries currently supported by our model. If a complex query is specified by nesting algebra operators, then each intermediate algebra operator generates a separate virtual class <ref> [31] </ref>. <p> For example, the system must be able to make dynamic changes to the class hierarchy, possibly inserting a new class between two existing classes without affected the types or extents of previously-existing classes in the hierarchy. We have proposed elsewhere <ref> [34, 31] </ref> algorithms and techniques by which the global class hierarchy can be maintained. Virtual classes are often simply called "views," but we interpret an object-oriented view to imply a complete view schema, which is a user-selected subgraph of the global schema.
Reference: [32] <author> E. A. Rundensteiner. </author> <title> Tools for view generation in OODBs. </title> <booktitle> In CIKM, </booktitle> <pages> pages 635-644, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: C i is-a C k , C j is-a C k , and p l 2 properties (C k ). This axiom follows from our classification algorithm, which places each newly-created virtual class into the global class hierarchy in a consistent and correct way <ref> [32] </ref>. Proposition 1 Only two classes will be involved in any property migration caused by virtual class integration. 9 The methods used to set or retrieve an instance variable's value are called that instance variable's accessing methods. <p> The MultiView view creation process includes the invocation of methods which use deterministic algorithms to perform the automatic integration of virtual classes into the global schema. In <ref> [32] </ref> we described the problem of how sometimes there may be no correct location for the placement of a new virtual class in an existent global schema graph in order to allow for both the full inheritance invariant as well as subsumption. <p> The current implementation of the MultiView system includes this classifier, further described in <ref> [32] </ref>, which generates one or more intermediate classes in order to guarantee these properties. This solution is both necessary and sufficient to guarantee the closure of the resulting class hierarchy. <p> We have shown elsewhere that the resulting global schema incorporates the virtual class in a consistent and most efficient manner [33]. 6.2 View Schemata As proven in <ref> [32] </ref>, once the global schema integration has been achieved, the tasks of specifying and constructing view schemata can be reduced to simple graph algorithms. The MultiView provides a simple graphical interface for the definition of view schemata.
Reference: [33] <author> E. A. Rundensteiner. </author> <title> A classification algorithm for supporting object-oriented views. </title> <booktitle> In CIKM, </booktitle> <pages> pages 18-25, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Both the classification algorithm and its proof of correctness are presented in <ref> [33] </ref>. Classification in MultiView is automatic and compulsory. That is to say, every time a class is added to a MultiView database, the system automatically integrates it into the inheritance hierarchy. <p> We have shown elsewhere that the resulting global schema incorporates the virtual class in a consistent and most efficient manner <ref> [33] </ref>. 6.2 View Schemata As proven in [32], once the global schema integration has been achieved, the tasks of specifying and constructing view schemata can be reduced to simple graph algorithms. The MultiView provides a simple graphical interface for the definition of view schemata.
Reference: [34] <author> E. A. Rundensteiner and L. Bic. </author> <title> Set operations in new generation data models. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 4 </volume> <pages> 382-398, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: For example, the system must be able to make dynamic changes to the class hierarchy, possibly inserting a new class between two existing classes without affected the types or extents of previously-existing classes in the hierarchy. We have proposed elsewhere <ref> [34, 31] </ref> algorithms and techniques by which the global class hierarchy can be maintained. Virtual classes are often simply called "views," but we interpret an object-oriented view to imply a complete view schema, which is a user-selected subgraph of the global schema.
Reference: [35] <author> C. Souza dos Santos, S. Abiteboul, and C. Delobel. </author> <title> Virtual schemas and bases. </title> <booktitle> International Conference on Extending Database Technology (EDBT), </booktitle> <year> 1994. </year>
Reference-contexts: Finally, the last approach completely ignores the issue of classification, thus resulting in a flat class structure. O2 Views [26] <ref> [35] </ref>, based on Abiteboul and Bonner [1], is the first and only commercial implementation of an object-oriented view management system, currently realized.
Reference: [36] <author> M. H. Scholl, C. Laasch, and M. Tresch. </author> <title> Updatable views in object-oriented databases. </title> <booktitle> In Proceedings of the Second DOOD Conference, </booktitle> <month> December </month> <year> 1991. </year>
Reference-contexts: In fact, this provides us with a basis for the arbitrary restructuring of an object's look and feel without compromising its identity. Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 6, 15, 26, 36, 39] </ref>. MultiView differs from other view systems in that it does not simply adopt assumptions made by current OODB architectures; instead we re-examine key features required as foundation for views. <p> Existing approaches either: (1) require the user to specify explicitly the relationship between a virtual class and existing base classes [18, 41]; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship <ref> [36] </ref>; or (3) simply relate a virtual class with its source class via a derived-from relationship [6], (4) or with the root of the schema [15, 19]. <p> The O2 Views approach does include the integration of view classes into a view schema, but rather than supporting a global class hierarchy and migrating properties, it instead daisy-chains views and "bases." Scholl et al. <ref> [36, 37] </ref> have developed an object-preserving algebra to define virtual classes and thus achieve updatable views. Their system, named Cocoon, has been implemented on top of a nested relational 2 Note that some materialized RDB views may be implemented using techniques such as view indices that resemble membership materialization.
Reference: [37] <author> M. H. Scholl and H. J. Schek. </author> <title> Survey of the cocoon project. </title> <institution> Objektbanken fur Experten, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: The O2 Views approach does include the integration of view classes into a view schema, but rather than supporting a global class hierarchy and migrating properties, it instead daisy-chains views and "bases." Scholl et al. <ref> [36, 37] </ref> have developed an object-preserving algebra to define virtual classes and thus achieve updatable views. Their system, named Cocoon, has been implemented on top of a nested relational 2 Note that some materialized RDB views may be implemented using techniques such as view indices that resemble membership materialization.
Reference: [38] <author> E. Sciore. </author> <title> Object specialization. </title> <journal> ACM Transactions on Information Systems, </journal> <pages> pages 103-122, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Such changes are done explicitly by user request, and on an object-by-object basis. View systems, on the other hand, enable users to restructure the types and class membership of complete classes|based on content-based queries. In <ref> [38] </ref>, Sciore proposed an object specialization approach, in which a real world entity is modeled by multiple objects arranged in an object hierarchy. These object hierarchy objects inherit from each other, enabling each individual entity object to decide its own inheritance hierarchy. <p> This single-point-of-inheritance allows us to optimize view update propagation. Unlike many role systems, which allow object hierarchies to exist independently from class hierarchies <ref> [38] </ref>, objects in our model always conform to the existing global class hierarchy. In short, if an object possesses an implementation object of a given class's type, it must also possess an implementation object for every class that is a superclass of that given type.
Reference: [39] <author> J. Shilling and P. Sweeney. </author> <title> Three steps to views: Extending the object-oriented paradigm. </title> <booktitle> In OOPSLA, </booktitle> <pages> pages 353 - 361, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: In fact, this provides us with a basis for the arbitrary restructuring of an object's look and feel without compromising its identity. Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 6, 15, 26, 36, 39] </ref>. MultiView differs from other view systems in that it does not simply adopt assumptions made by current OODB architectures; instead we re-examine key features required as foundation for views.
Reference: [40] <author> K. Sugiyama, S. Tagawa, and M. </author> <title> Toda. Methods for visual understanding of hierarchical system structures. </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <pages> pages 109-125, </pages> <month> February </month> <year> 1981. </year>
Reference-contexts: In the remainder of this section, we describe the main features. 7.1 Schema Views The MultiViewer displays a class hierarchy using a directed graph representing inheritance relationships. The graph layout is determined by an algorithm designed to minimize the number of edge crossings <ref> [40] </ref>. This results in a clean-looking directed graph that simplifies visualization of the generalization relationships by grouping similar classes together on the display. A sample schema graph is shown in Figure 19.
Reference: [41] <author> K. Tanaka, M. Yoshikawa, and K. Ishihara. </author> <title> Schema virtualization in object-oriented databases. </title> <booktitle> IEEE International Conference on Data Engineering, </booktitle> <month> February </month> <year> 1988. </year> <note> REFERENCES 29 </note>
Reference-contexts: Note that our approach of providing for the integration of virtual classes into a single unified global schema is distinct from others found in the literature. Existing approaches either: (1) require the user to specify explicitly the relationship between a virtual class and existing base classes <ref> [18, 41] </ref>; or (2) relate a virtual class only with its direct source class via a subclass/superclass relationship [36]; or (3) simply relate a virtual class with its source class via a derived-from relationship [6], (4) or with the root of the schema [15, 19]. <p> Others define view schemata through the manipulation of the object schema graph rather than solely by query languages. Tanaka et al. <ref> [41] </ref> propose that view schemata be defined by manually manipulating the edges in the global schema graph. Kim also uses DAG rearrangement for view schema definition [18].
References-found: 41

