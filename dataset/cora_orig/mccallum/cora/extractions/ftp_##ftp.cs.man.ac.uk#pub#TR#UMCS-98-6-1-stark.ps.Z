URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-stark.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Email: Email: jamie@cee.hw.ac.uk, air@cee.hw.ac.uk  
Title: Invariant Discovery via Failed Proof Attempts  
Author: Jamie Stark and Andrew Ireland 
Address: Edinburgh EH14 4AS Scotland, UK  
Affiliation: Department of Computing Electrical Engineering, Heriot-Watt University, Riccarton,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R.C. Backhouse. </author> <title> Program Construction and Verification. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: It is this verification condition which establishes I to be an invariant of the loop body S and is the focus of our work. The literature <ref> [1, 7, 9, 16] </ref> contains many heuristics for constructing invariants in a systematic way, which involves making successive approximations at the invariant.
Reference: [2] <author> David Basin and Toby Walsh. </author> <title> Annotated rewriting in inductive theorem proving. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 16(1-2):147-180, </volume> <year> 1996. </year>
Reference-contexts: Directed wave-fronts enable the termination of rippling to be guaranteed <ref> [2] </ref>. The movement of wave-fronts is performed by wave-rules, a syntactic class of rewrite rule which preserves skeleton while making progress to eliminating wave-fronts. Wave-rules are generated automatically by clam for all definitions and properties loaded into the system. For any equation there are usually a number of corresponding wave-rules. <p> Example wave-rules are provided in the following sections. Proofs guided by rippling can be classified in terms of the direction in which wave-fronts are moved with respect to the skeleton term structure. For a full account of rippling see <ref> [2, 4] </ref>. Middle-out reasoning is a proof planning strategy where meta terms are used to delay choice within the proof. The motivation is that the middle of a proof is typically more constrained than the start.
Reference: [3] <author> A. Bundy. </author> <title> The use of explicit plans to guide inductive proofs. </title> <type> Research Paper 349, </type> <institution> Dept. of Artificial Intelligence, University of Edinburgh, </institution> <year> 1988. </year> <note> Short version published in the proceedings of CADE-9. </note>
Reference-contexts: Previously [15] we showed how proof planing was able to successfully discover tail invariants. Here this work is extended by adding heuristics to replace program constants and strengthen invariants. A general strategy is presented that enables the successive approximation of invariants using these heuristics. Proof planning <ref> [3] </ref> consists of tactics, methods and critics. Tactics are compounded basic rules of inference. Methods partial specify a tactic and allow the use of heuristics. A method has preconditions and effects. Proof planning involves the search for a plan at the meta level by using the methods.
Reference: [4] <author> A. Bundy, A. Stevens, F. van Harmelen, A. Ireland, and A. Smaill. Rippling: </author> <title> A heuristic for guiding inductive proofs. </title> <journal> Artificial Intelligence, </journal> <volume> 62 </volume> <pages> 185-253, </pages> <year> 1993. </year> <note> Also available from Edinburgh as DAI Research Paper No. 567. </note>
Reference-contexts: Critics [12] are used to handle the failure of a methods precondition. They patch the failed proof attempt and provide a powerful mechanism for dealing with failure. The clam proof planner [5] has been used, amongst other applications, for inductive proof <ref> [4] </ref>. The success of the proof plan for induction is due to the ripple heuristic. Rewriting often involves the manipulation of a goal formula so that a target formula, e.g. a hypothesis or previously established result, can be applied. <p> Example wave-rules are provided in the following sections. Proofs guided by rippling can be classified in terms of the direction in which wave-fronts are moved with respect to the skeleton term structure. For a full account of rippling see <ref> [2, 4] </ref>. Middle-out reasoning is a proof planning strategy where meta terms are used to delay choice within the proof. The motivation is that the middle of a proof is typically more constrained than the start.
Reference: [5] <author> A. Bundy, F. van Harmelen, C. Horn, and A. Smaill. </author> <title> The Oyster-Clam system. </title> <type> Research Paper 507, </type> <institution> Dept. of Artificial Intelligence, University of Edinburgh, </institution> <year> 1990. </year> <note> Appeared in the proceedings of CADE-10. </note>
Reference-contexts: A proof at the object level is extracted from a plan and run for completeness. Critics [12] are used to handle the failure of a methods precondition. They patch the failed proof attempt and provide a powerful mechanism for dealing with failure. The clam proof planner <ref> [5] </ref> has been used, amongst other applications, for inductive proof [4]. The success of the proof plan for induction is due to the ripple heuristic. Rewriting often involves the manipulation of a goal formula so that a target formula, e.g. a hypothesis or previously established result, can be applied.
Reference: [6] <author> Chadha and Plaisted. </author> <title> On the mechanical derivation of loop invariants. </title> <journal> JSL, </journal> <volume> 15 </volume> <pages> 705-744, </pages> <year> 1993. </year>
Reference-contexts: The proof planning framework in which our heuristics are expressed enables this close relationship to be exploited. Our approach, like all heuristic based techniques, is not complete. A complete approach has been designed <ref> [6] </ref> based upon a novel unskolemization technique for deriving logical consequences of first-order formulae. Completeness, however, comes with a price. In practice this means that any inductive lemmas required for a particular verification task must be provided by hand.
Reference: [7] <author> E. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: It is this verification condition which establishes I to be an invariant of the loop body S and is the focus of our work. The literature <ref> [1, 7, 9, 16] </ref> contains many heuristics for constructing invariants in a systematic way, which involves making successive approximations at the invariant.
Reference: [8] <author> D. Gries. </author> <title> A note on a standard strategy for developing loop invariants and loops. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2 </volume> <pages> 207-214, </pages> <year> 1982. </year>
Reference-contexts: This is done by applying wave-rules backwards until all the difference surrounds only one constant. Strengthening invariants Gries <ref> [8] </ref> explains a simple, but powerful, heuristic for dealing with stuck proof obligations. The idea is to assume the very thing that we are trying to prove. This has the effect of instantly making the proof obligation trivial. <p> It describes a systematic framework for refining initial approximations to a loop invariant automatically in a principled way. Initial results using examples from the literature are promising, see table (1). The heuristics described have been used for more complex problems involving arrays, notably Gries' minimum sum segment problem <ref> [8] </ref>. Our approach is syntactically driven and requires defining equations and properties needed to complete the proof. There is no restriction that these defining equations are recursive or the specification is immediately executable.
Reference: [9] <editor> David Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: It is this verification condition which establishes I to be an invariant of the loop body S and is the focus of our work. The literature <ref> [1, 7, 9, 16] </ref> contains many heuristics for constructing invariants in a systematic way, which involves making successive approximations at the invariant.
Reference: [10] <author> J.T. Hesketh. </author> <title> Using Middle-Out Reasoning to Guide Inductive Theorem Proving. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1991. </year>
Reference-contexts: The implementation makes use if the higher-order features of -prolog [20]. Rippling is used to constrain the matching of wave-rules, by taking the annotations into account. Middle-out techniques have been used for generalisation <ref> [10, 13] </ref>, logic program synthesis [18], lemma discovery and induction revision [14]. 3 A Proof Plan for Invariant Verification exp1: fx = X ^ y = Yg while (y &gt; 0) do begin r := r fl x; end Consider the program in figure (1).
Reference: [11] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12 </volume> <pages> 576-583, </pages> <year> 1969. </year>
Reference-contexts: This enables us to communicate proof attempts, and specifications in the same language. i.e. we choose to talk about invariants rather than generalisations. 2 Background Hoare <ref> [11] </ref> first introduced his axiomatic proof rules for imperative programs involving loops in 1969. The aim was to assist the understanding of programs using rigourous logical techniques. The proof rules allow the transformation of a program with suitable assertions, into a set of purely logical implications called verification conditions.
Reference: [12] <author> A. Ireland. </author> <title> The Use of Planning Critics in Mechanizing Inductive Proofs. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> International Conference on Logic Programming and Automated Reasoning - LPAR 92, St. Petersburg, Lecture Notes in Artificial Intelligence No. </booktitle> <volume> 624, </volume> <pages> pages 178-189. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <note> Also available from Edinburgh as DAI Research Paper 592. </note>
Reference-contexts: Methods partial specify a tactic and allow the use of heuristics. A method has preconditions and effects. Proof planning involves the search for a plan at the meta level by using the methods. A proof at the object level is extracted from a plan and run for completeness. Critics <ref> [12] </ref> are used to handle the failure of a methods precondition. They patch the failed proof attempt and provide a powerful mechanism for dealing with failure. The clam proof planner [5] has been used, amongst other applications, for inductive proof [4].
Reference: [13] <author> A. Ireland and A. Bundy. </author> <title> Extensions to a Generalization Critic for Inductive Proof. In M.A. </title> <editor> McRobbie and J.K. Slaney, editors, </editor> <booktitle> 13th Conference on Automated Deduction, </booktitle> <pages> pages 47-61. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <note> Springer Lecture Notes in Artificial Intelligence No. 1104. Also available from Edinburgh as DAI Research Paper 786. </note>
Reference-contexts: The implementation makes use if the higher-order features of -prolog [20]. Rippling is used to constrain the matching of wave-rules, by taking the annotations into account. Middle-out techniques have been used for generalisation <ref> [10, 13] </ref>, logic program synthesis [18], lemma discovery and induction revision [14]. 3 A Proof Plan for Invariant Verification exp1: fx = X ^ y = Yg while (y &gt; 0) do begin r := r fl x; end Consider the program in figure (1).
Reference: [14] <author> A. Ireland and A. Bundy. </author> <title> Productive use of failure in inductive proof. </title> <journal> Journal of Automated Reasoning, </journal> <note> 16(1-2):79-111, 1996. Also available as DAI Research Paper No 716, </note> <institution> Dept. of Artificial Intelligence, Edinburgh. </institution> <month> 8 </month>
Reference-contexts: The implementation makes use if the higher-order features of -prolog [20]. Rippling is used to constrain the matching of wave-rules, by taking the annotations into account. Middle-out techniques have been used for generalisation [10, 13], logic program synthesis [18], lemma discovery and induction revision <ref> [14] </ref>. 3 A Proof Plan for Invariant Verification exp1: fx = X ^ y = Yg while (y &gt; 0) do begin r := r fl x; end Consider the program in figure (1). To verify this program we need a loop invariant.
Reference: [15] <author> A. Ireland and J. Stark. </author> <title> On the Automatic Discovery of Loop Invariants. </title> <booktitle> In Fourth NASA Langley Formal Methods Workshop, number 3356 in NASA Conference Publications, </booktitle> <year> 1997. </year> <note> Also available from Dept. </note> <institution> of Computing and Electrical Engineering, Heriot-Watt University, </institution> <note> Research Memo RM/97/1. </note>
Reference-contexts: This enables us to exploit the relationship between failed proof attempts and invariant discovery. The framework described here builds upon previous work <ref> [15] </ref> and shows how successive approximations are used to find a suitable invariant by a system automatically. This work was motivated by previous work on discovering generalisations for inductive proofs. <p> Report number UMCS-98-6-1. http://www.cs.man.ac.uk/cstechrep/titles98.html y This work is supported by an EPSRC student ship award 96307451 z This work is supported by EPSRC grant GL/L/11724 1 Program constants are denoted as calligraphic letters throughout (e.g. X ). 1 tail invariants. Previously <ref> [15] </ref> we showed how proof planing was able to successfully discover tail invariants. Here this work is extended by adding heuristics to replace program constants and strengthen invariants. A general strategy is presented that enables the successive approximation of invariants using these heuristics.
Reference: [16] <author> A. Kaldewaij. </author> <title> Programming: The Derivation of Algorithms. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: It is this verification condition which establishes I to be an invariant of the loop body S and is the focus of our work. The literature <ref> [1, 7, 9, 16] </ref> contains many heuristics for constructing invariants in a systematic way, which involves making successive approximations at the invariant.
Reference: [17] <author> S.M. Katz and Z. Manna. </author> <title> A heuristic approach to program verification. </title> <booktitle> In Proceedings of IJCAI-73. International Joint Conference on Artificial Intelligence, </booktitle> <year> 1973. </year>
Reference-contexts: 1 Introduction Loop invariants are a well understood technique for specifying the behaviour of imperative loop programs. The discovery of suitable invariants, however, is a major bottle neck for automatic verification of imperative programs. Early research into heuristic based methods <ref> [17, 21] </ref> focused on the heuristic and the theorem proving components separately. The proof planning framework, in which we reconstruct the standard heuristics, couples the heuristic and theorem proving components tightly, allowing us to focus on both of these components together. <p> The choice of refinement was guided by the satisfiability and validity of the current candidate invariant. The theorem proving and heuristic components were only loosely coupled. This was reflected in other heuristic approaches 7 at the time <ref> [17] </ref>. Wegbreit hinted, however, that a closer relationship between the heuristic guidance and the theorem prover would be desirable. The proof planning framework in which our heuristics are expressed enables this close relationship to be exploited. Our approach, like all heuristic based techniques, is not complete.
Reference: [18] <author> I. Kraan, D. Basin, and A. Bundy. </author> <title> Logic program synthesis via proof planning. </title> <editor> In K.K. Lau and T. Clement, editors, </editor> <booktitle> Logic Program Synthesis and Transformation, </booktitle> <pages> pages 1-14. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> Also available as Max-Planck-Institut fur Informatik Report MPI-I-92-244 and Edinburgh DAI Research Report 603. </note>
Reference-contexts: The implementation makes use if the higher-order features of -prolog [20]. Rippling is used to constrain the matching of wave-rules, by taking the annotations into account. Middle-out techniques have been used for generalisation [10, 13], logic program synthesis <ref> [18] </ref>, lemma discovery and induction revision [14]. 3 A Proof Plan for Invariant Verification exp1: fx = X ^ y = Yg while (y &gt; 0) do begin r := r fl x; end Consider the program in figure (1). To verify this program we need a loop invariant.
Reference: [19] <author> A. Mili, J. Desharhais, and F. Mili. </author> <title> Computer Program Construction. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: Completeness, however, comes with a price. In practice this means that any inductive lemmas required for a particular verification task must be provided by hand. Our technique is very tightly coupled to the syntactic structure of the initial invariant. A more semantic approach to verification is described by Mili <ref> [19] </ref>, where program semantics are found independently of their specifications and heuristics are given for discovering invariant properties. We are currently investigating the relationship between these alternatives and whether a combined approach has merit. 8 Conclusion Discovering a loop invariant is a bottle neck for automatic imperative program verification.
Reference: [20] <author> D. Miller and G. Nadathur. </author> <title> An overview of Prolog. </title> <editor> In R. Bowen, K. & Kowalski, editor, </editor> <booktitle> Proceedings of the Fifth International Logic Programming Conference/ Fifth Symposium on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: The motivation is that the middle of a proof is typically more constrained than the start. The aim of middle-out reasoning is to use the proof to add structure where we do not know what it is. The implementation makes use if the higher-order features of -prolog <ref> [20] </ref>. Rippling is used to constrain the matching of wave-rules, by taking the annotations into account.
Reference: [21] <author> Wegbreit. </author> <title> Heuristic methods for mechanically deriving inductive assertions. </title> <booktitle> In Proceedings of IJCAI-73. International Joint Conference on Artificial Intelligence, </booktitle> <year> 1973. </year> <month> 9 </month>
Reference-contexts: 1 Introduction Loop invariants are a well understood technique for specifying the behaviour of imperative loop programs. The discovery of suitable invariants, however, is a major bottle neck for automatic verification of imperative programs. Early research into heuristic based methods <ref> [17, 21] </ref> focused on the heuristic and the theorem proving components separately. The proof planning framework, in which we reconstruct the standard heuristics, couples the heuristic and theorem proving components tightly, allowing us to focus on both of these components together. <p> In the example above for the program (1) we use a constructive definition of exp to prove a destructive version of the program. 7 Related Work Early research into Automatic Programming investigated heuristic based methods for discovering loop invariants. Wegbreit <ref> [21] </ref> developed an approach in which a candidate invariant was incremen tally refined using both domain-independent and domain-specific heuristics. The choice of refinement was guided by the satisfiability and validity of the current candidate invariant. The theorem proving and heuristic components were only loosely coupled.
References-found: 21

