URL: ftp://theory.lcs.mit.edu/pub/tds/ICALP94.ps.Z
Refering-URL: http://theory.lcs.mit.edu/tds/reflist.html
Root-URL: 
Title: Liveness in Timed and Untimed Systems  
Author: Rainer Gawlick Roberto Segala Jtrgen Stgaard-Andersen ; Nancy Lynch 
Address: Denmark  
Affiliation: 1 Laboratory for Computer Science, MIT 2 Department of Computer Science, Technical University of  
Abstract: We present a coordinated pair of general labeled transition system models for describing timed and untimed concurrent systems. Both of the models incorporate liveness properties as well as safety properties. The models are related via an embedding of the untimed model into the timed model, which preserves all the interesting attributes of the untimed model. Both models include notions of environment-freedom, which express the idea that the liveness properties can be guaranteed by the system, independently of the behavior of the environment in which it operates. These environment-freedom conditions are used to prove com-positionality results for both models. This pair of models, which generalize several existing models, is intended to comprise a general formalism for the verification of timed and untimed concurrent systems.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Abadi and L. Lamport. </author> <title> An old-fashioned recipe for real time. </title> <booktitle> In [5], </booktitle> <pages> pages 1-27. </pages>
Reference-contexts: It generalizes the notion of strong I/O feasibility introduced in [17]. The untimed model is similar to the model of [2]. However, the generalization of [2] to the timed case <ref> [1] </ref> is very complex, possibly because of the absence of a clear role for time in the interaction between the automaton and its environment. In contrast, our generalization to the timed case is simple, and follows naturally from the untimed case. <p> However, they are not adequate to describe systems whenever their state structure is important. The model of [2] is closely related to our model (c.f. Example 2). However, our timed model departs from the key ideas of <ref> [1] </ref>, leading to a more natural treatment of time. The work in [17] does not deal with general liveness, and uses finite and admissible timed traces inclusion as an implementation relation.
Reference: 2. <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> TOPLAS, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference-contexts: This motivates the attempt to generalize the I/O automaton model to handle more general liveness properties, while retaining an implementation notion based on some form of trace inclusion. A simple and natural generalization is suggested by the work of Abadi and Lamport <ref> [2] </ref>, which models a machine as a pair (A; L) consisting of an automaton A and a subset L of its executions satisfying the desired liveness property. The implementation notion can then be expressed by live trace inclusion just as fair trace inclusion expresses implementation for I/O automata. <p> It captures the I/O automata of [10], the failure free complete trace structures of [7], and the timed I/O automata of [13]. It generalizes the notion of strong I/O feasibility introduced in [17]. The untimed model is similar to the model of <ref> [2] </ref>. However, the generalization of [2] to the timed case [1] is very complex, possibly because of the absence of a clear role for time in the interaction between the automaton and its environment. <p> It captures the I/O automata of [10], the failure free complete trace structures of [7], and the timed I/O automata of [13]. It generalizes the notion of strong I/O feasibility introduced in [17]. The untimed model is similar to the model of <ref> [2] </ref>. However, the generalization of [2] to the timed case [1] is very complex, possibly because of the absence of a clear role for time in the interaction between the automaton and its environment. In contrast, our generalization to the timed case is simple, and follows naturally from the untimed case. <p> Thus, any finite execution of A must be extendible to an execution in L. This requirement is closely related to the liveness relative to a safety property of [6] and to the machine-closure of <ref> [2] </ref>. Definition 1. A liveness condition L for an automaton A is a subset of the executions of A such that any finite execution of A is a prefix of an execution in L. <p> L is trivially a liveness condition for A. However, the live automaton (A; L) would not behave properly if the environment does not provide more than four i actions. A similar problem is noted in <ref> [2, 7] </ref>, leading to the notion of receptiveness. Intuitively, a system is receptive if it behaves properly independently of the inputs provided by its environment. <p> (A) fi in (A) ! states (A) and f : exec fl (A) ! (local (A) fi states (A)) [ f?g such that 1. g (ff; a) = s implies ffas 2 exec fl (A) 2. f (ff) = (a; s) implies ffas 2 exec fl (A) The strategies of <ref> [2, 7] </ref> consist of function f only, since in [7] there is no notion of state, and in [2] the environment moves by changing the state of the system. <p> (A)) [ f?g such that 1. g (ff; a) = s implies ffas 2 exec fl (A) 2. f (ff) = (a; s) implies ffas 2 exec fl (A) The strategies of [2, 7] consist of function f only, since in [7] there is no notion of state, and in <ref> [2] </ref> the environment moves by changing the state of the system. The moves of the environment can be represented as an infinite sequence I, called an environment sequence, of input actions interleaved with infinitely many symbols, where represents the points at which the system is allowed to move. <p> Function f chooses to perform action o whenever applied to an execution ending in s 0 or s 2 and chooses ? otherwise; function g always moves to the only possible next state. In <ref> [2] </ref> the pair (A; L) is said to be realizable and is identified with its realizable part (A 0 ; L 0 ). Realizability can be defined in our model by considering only those outcomes O (g;f) (ff; I) where ff consists of a start state. However, the approach of [2] <p> <ref> [2] </ref> the pair (A; L) is said to be realizable and is identified with its realizable part (A 0 ; L 0 ). Realizability can be defined in our model by considering only those outcomes O (g;f) (ff; I) where ff consists of a start state. However, the approach of [2] implies that state s 4 should never be reached in (A; L), thus adding new safety requirements to A via L. <p> The failure free complete trace structures of [7] are a special case of our model, where the state structure of a machine is not considered. However, they are not adequate to describe systems whenever their state structure is important. The model of <ref> [2] </ref> is closely related to our model (c.f. Example 2). However, our timed model departs from the key ideas of [1], leading to a more natural treatment of time.
Reference: 3. <author> B. Alpern and F. Schneider. </author> <title> Defining liveness. </title> <journal> IPL, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <year> 1985. </year>
Reference-contexts: Particularly important are formalisms that can model distributed and concurrent systems and those that can model real time systems, i.e., systems that rely on time constraints in order to guarantee correct behavior. Formalisms should be able to support the verification of both safety and liveness properties <ref> [3] </ref>. Roughly speaking, a liveness property specifies that certain desirable events will eventually occur, while a safety property specifies that certain undesirable events will never occur. In this paper, we present a coordinated formalism that permits modeling and verification of safety and liveness properties for both timed and untimed systems. <p> This property will be used to compose live automata in parallel. 2.2 Live Automata A safe automaton A can be thought of as expressing safety properties. Liveness properties can be expressed by a subset L of its executions, as suggested in <ref> [3] </ref>. In order to ensure that the set L of executions does not introduce additional safety restrictions, it should not be possible to violate L in a finite number of steps. Thus, any finite execution of A must be extendible to an execution in L.
Reference: 4. <institution> Proceedings of CONCUR 92, Stony Brook, </institution> <address> NY, USA, </address> <publisher> LNCS 630, </publisher> <year> 1992. </year>
Reference: 5. <institution> Proceedings of the REX Workshop "Real-Time: </institution> <note> Theory in Practice", LNCS 600, </note> <year> 1991. </year>
Reference: 6. <author> F. Dederichs and R. Weber. </author> <title> Safety and liveness from a methodological point of view. </title> <journal> Information Processing Letters, </journal> <volume> 36(1) </volume> <pages> 25-30, </pages> <year> 1990. </year>
Reference-contexts: Thus, any finite execution of A must be extendible to an execution in L. This requirement is closely related to the liveness relative to a safety property of <ref> [6] </ref> and to the machine-closure of [2]. Definition 1. A liveness condition L for an automaton A is a subset of the executions of A such that any finite execution of A is a prefix of an execution in L.
Reference: 7. <author> D. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-Independent Circuits. </title> <publisher> ACM Distinguished Dissertations. MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: The restrictions on L are given by a property called environment-freedom, which captures the intuitive idea that a live (timed) I/O automaton may not constrain its environment. The environment-freedom property is defined, using ideas from Dill <ref> [7] </ref>, by means of a two-person game between a live (timed) I/O automaton and its environment. Specifically, the environment provides any input, while the system tries to react so that it behaves according to its liveness property L. <p> Furthermore, it commutes with the parallel composition operator. Our model is closely related to several others in the literature. It captures the I/O automata of [10], the failure free complete trace structures of <ref> [7] </ref>, and the timed I/O automata of [13]. It generalizes the notion of strong I/O feasibility introduced in [17]. The untimed model is similar to the model of [2]. <p> L is trivially a liveness condition for A. However, the live automaton (A; L) would not behave properly if the environment does not provide more than four i actions. A similar problem is noted in <ref> [2, 7] </ref>, leading to the notion of receptiveness. Intuitively, a system is receptive if it behaves properly independently of the inputs provided by its environment. <p> (A) fi in (A) ! states (A) and f : exec fl (A) ! (local (A) fi states (A)) [ f?g such that 1. g (ff; a) = s implies ffas 2 exec fl (A) 2. f (ff) = (a; s) implies ffas 2 exec fl (A) The strategies of <ref> [2, 7] </ref> consist of function f only, since in [7] there is no notion of state, and in [2] the environment moves by changing the state of the system. <p> : exec fl (A) ! (local (A) fi states (A)) [ f?g such that 1. g (ff; a) = s implies ffas 2 exec fl (A) 2. f (ff) = (a; s) implies ffas 2 exec fl (A) The strategies of [2, 7] consist of function f only, since in <ref> [7] </ref> there is no notion of state, and in [2] the environment moves by changing the state of the system. <p> In a similar way a timed I/O automaton of [13] can be represented in our timed model. The failure free complete trace structures of <ref> [7] </ref> are a special case of our model, where the state structure of a machine is not considered. However, they are not adequate to describe systems whenever their state structure is important. The model of [2] is closely related to our model (c.f. Example 2).
Reference: 8. <author> R. Gawlick, R. Segala, J. Stgaard-Andersen, and N. Lynch. </author> <title> Liveness in timed and untimed systems. </title> <type> Technical Report MIT/LCS/TR-587, </type> <month> November </month> <year> 1993. </year>
Reference-contexts: A key feature of I/O automata is the explicit distinction between input and output actions, which characterize the events under the control of the environment and those under the control ? Full report appears as <ref> [8] </ref>. Supported by NSF grant CCR-92-25124, DARPA contract N00014 92-J-4033, ONR contract N00014-91-J-1046, and by the Danish Technical Research Council. of the automaton, respectively. I/O automata include a special type of liveness prop-erty called fairness, also known as weak fairness. <p> Specifically, we define an embedding, similar to the patient transducer of [17], that converts live I/O automata into live timed I/O automata without timing constraints. The embedding, which is omitted from this abstract (see <ref> [8] </ref>), preserves the environment-freedom property and the trace preorder relations of the untimed model. Furthermore, it commutes with the parallel composition operator. Our model is closely related to several others in the literature. <p> In contrast, our generalization to the timed case is simple, and follows naturally from the untimed case. It is already clear that our formalism supports a wide range of proof methods, including simulation methods as described in [11, 12] (and extended to handle liveness in <ref> [8, 16] </ref>), compositional reasoning as justified by the theorems of this paper, and tempo ral logic methods, as described in [16].
Reference: 9. <author> Butler Lampson. </author> <title> Principles for computer system design, 1993. Turing Award Talk. </title>
Reference-contexts: An extensive verification project that uses the formalism described in this paper can be found in <ref> [9, 15, 16] </ref>; in fact, that verification project provided a major impetus to the development of our formalism. The paper is divided in two main sections, dealing with the untimed and timed model, respectively.
Reference: 10. <author> N. Lynch and M. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proc. </booktitle> <address> PODC, </address> <year> 1987. </year> <note> A full version is available as MIT Technical Report MIT/LCS/TR-387. </note>
Reference-contexts: Both models come equipped with notions of external behavior and of implementation, which are based simply on traces. The formalism is intended to support a variety of verification techniques, including simulation methods, compositional reasoning, algebraic methods, and temporal logic methods. The Input/Output (I/O) automaton model of Lynch and Tuttle <ref> [10] </ref> and it timed extension by Merritt, Modugno and Tuttle [13], have been used successfully in the past as a formalism for verification. I/O automata are state machines with a labeled transition relation where the labels, also called actions, model communication. <p> The embedding, which is omitted from this abstract (see [8]), preserves the environment-freedom property and the trace preorder relations of the untimed model. Furthermore, it commutes with the parallel composition operator. Our model is closely related to several others in the literature. It captures the I/O automata of <ref> [10] </ref>, the failure free complete trace structures of [7], and the timed I/O automata of [13]. It generalizes the notion of strong I/O feasibility introduced in [17]. The untimed model is similar to the model of [2]. <p> The paper is divided in two main sections, dealing with the untimed and timed model, respectively. The two sections have a similar structure: first they present the basic safe models, taken from <ref> [10] </ref> and [12], respectively, then they present the live model along with the main theorems and some examples showing that our environment-freedom condition cannot easily be relaxed. <p> The most natural extensions of the notion of implementation used for I/O automata, fair trace inclusion, are the following preorders, where the safe preorder coincides with the unfair preorder of <ref> [10] </ref>, and the live preorder generalizes the fair preorder of [10]. Definition 2. <p> The most natural extensions of the notion of implementation used for I/O automata, fair trace inclusion, are the following preorders, where the safe preorder coincides with the unfair preorder of <ref> [10] </ref>, and the live preorder generalizes the fair preorder of [10]. Definition 2. <p> If, for each i, (A i ; L i ) v X (A 0 i ), then (A 1 ; L 1 )k k (A N ; L N ) v X (A 0 1 ; L 0 N ; L 0 4 Related Work An I/O automaton M of <ref> [10] </ref> can be represented in our model as the environment-free pair (A; L) where A is M without the partition of its locally-controlled actions and L is the set of fair executions of M . <p> It is easy to show, given our definition of environment-freedom, that the set of live traces of any live automaton is union-game realizable according to [14], and thus describable by means of a standard I/O automaton of <ref> [10] </ref>. However in general the I/O automaton description would be extremely unnatural. Acknowledgments: We thank Hans Henrik Ltvengreen and Frits Vaandrager for their valuable criticism and useful comments.
Reference: 11. <author> N. Lynch and F. Vaandrager. </author> <title> Forward and backward simulations part I: Untimed systems. </title> <type> Technical Report MIT/LCS/TM-486, </type> <month> May </month> <year> 1993. </year> <note> Preliminary version in [5]. </note>
Reference-contexts: In contrast, our generalization to the timed case is simple, and follows naturally from the untimed case. It is already clear that our formalism supports a wide range of proof methods, including simulation methods as described in <ref> [11, 12] </ref> (and extended to handle liveness in [8, 16]), compositional reasoning as justified by the theorems of this paper, and tempo ral logic methods, as described in [16].
Reference: 12. <author> N. Lynch and F. Vaandrager. </author> <title> Forward and backward simulations part II: Timing-based systems. </title> <type> Technical Report MIT/LCS/TM-487, </type> <month> September </month> <year> 1993. </year> <note> Preliminary version in [5]. </note>
Reference-contexts: In contrast, our generalization to the timed case is simple, and follows naturally from the untimed case. It is already clear that our formalism supports a wide range of proof methods, including simulation methods as described in <ref> [11, 12] </ref> (and extended to handle liveness in [8, 16]), compositional reasoning as justified by the theorems of this paper, and tempo ral logic methods, as described in [16]. <p> The paper is divided in two main sections, dealing with the untimed and timed model, respectively. The two sections have a similar structure: first they present the basic safe models, taken from [10] and <ref> [12] </ref>, respectively, then they present the live model along with the main theorems and some examples showing that our environment-freedom condition cannot easily be relaxed. <p> This provides an example where in absence of environment-freedom an implementation (A 1 ; L 1 ) cannot be safely substituted for its specification (A 2 ; L 2 ). 3 The Timed Setting 3.1 Safe Timed Automata A safe timed automaton A <ref> [12] </ref> is a safe automaton whose set of external actions contains a special time-passage action -. Define the set vis (A) of visible actions to be ext (A) n f-g.
Reference: 13. <author> M. Merritt, F. Modugno, and M. Tuttle. </author> <title> Time constrained automata. </title> <booktitle> In Proceedings CONCUR 91, </booktitle> <address> Amsterdam, </address> <publisher> LNCS 527, </publisher> <year> 1991. </year>
Reference-contexts: The formalism is intended to support a variety of verification techniques, including simulation methods, compositional reasoning, algebraic methods, and temporal logic methods. The Input/Output (I/O) automaton model of Lynch and Tuttle [10] and it timed extension by Merritt, Modugno and Tuttle <ref> [13] </ref>, have been used successfully in the past as a formalism for verification. I/O automata are state machines with a labeled transition relation where the labels, also called actions, model communication. <p> Furthermore, it commutes with the parallel composition operator. Our model is closely related to several others in the literature. It captures the I/O automata of [10], the failure free complete trace structures of [7], and the timed I/O automata of <ref> [13] </ref>. It generalizes the notion of strong I/O feasibility introduced in [17]. The untimed model is similar to the model of [2]. <p> The environment-free strategy (g; f ) for (A; L) simply gives turns (say in a round robin way) to all the components of M that are continuously willing to perform some locally-controlled action. In a similar way a timed I/O automaton of <ref> [13] </ref> can be represented in our timed model. The failure free complete trace structures of [7] are a special case of our model, where the state structure of a machine is not considered. However, they are not adequate to describe systems whenever their state structure is important.
Reference: 14. <author> N. Reingold, D. Wang, and L. Zuck. </author> <title> Games I/O automata play. </title> <booktitle> In [4], </booktitle> <pages> pages 325-339. </pages>
Reference-contexts: Our notion of environment-freedom solves the same problem in a more general way. It is easy to show, given our definition of environment-freedom, that the set of live traces of any live automaton is union-game realizable according to <ref> [14] </ref>, and thus describable by means of a standard I/O automaton of [10]. However in general the I/O automaton description would be extremely unnatural. Acknowledgments: We thank Hans Henrik Ltvengreen and Frits Vaandrager for their valuable criticism and useful comments.
Reference: 15. <author> J. Stgaard-Andersen, B. Lampson, and N. Lynch. </author> <title> Correctness of at-most-once message delivery protocols. </title> <booktitle> In Proc. FORTE 93, </booktitle> <year> 1993. </year>
Reference-contexts: Unfortunately, I/O automata do not quite meet our needs. The problem is that there are some liveness properties that cannot be expressed naturally using just the simple notion of I/O automaton fairness; see <ref> [15] </ref> for an example. This motivates the attempt to generalize the I/O automaton model to handle more general liveness properties, while retaining an implementation notion based on some form of trace inclusion. <p> An extensive verification project that uses the formalism described in this paper can be found in <ref> [9, 15, 16] </ref>; in fact, that verification project provided a major impetus to the development of our formalism. The paper is divided in two main sections, dealing with the untimed and timed model, respectively.
Reference: 16. <author> J. Stgaard-Andersen, N. Lynch, and B. Lampson. </author> <title> Correctness of communication protocols, a case study. </title> <type> Technical Report MIT/LCS/TR-589, </type> <month> November </month> <year> 1993. </year>
Reference-contexts: In contrast, our generalization to the timed case is simple, and follows naturally from the untimed case. It is already clear that our formalism supports a wide range of proof methods, including simulation methods as described in [11, 12] (and extended to handle liveness in <ref> [8, 16] </ref>), compositional reasoning as justified by the theorems of this paper, and tempo ral logic methods, as described in [16]. <p> It is already clear that our formalism supports a wide range of proof methods, including simulation methods as described in [11, 12] (and extended to handle liveness in [8, 16]), compositional reasoning as justified by the theorems of this paper, and tempo ral logic methods, as described in <ref> [16] </ref>. An extensive verification project that uses the formalism described in this paper can be found in [9, 15, 16]; in fact, that verification project provided a major impetus to the development of our formalism. <p> An extensive verification project that uses the formalism described in this paper can be found in <ref> [9, 15, 16] </ref>; in fact, that verification project provided a major impetus to the development of our formalism. The paper is divided in two main sections, dealing with the untimed and timed model, respectively.
Reference: 17. <author> F. Vaandrager and N. Lynch. </author> <title> Action transducers and timed automata. </title> <booktitle> In [4]. </booktitle>
Reference-contexts: The close relation between the two definitions allows the timed and untimed models to be tied together, thus (for example) permitting the verification for timed implementations of untimed specifications. Specifically, we define an embedding, similar to the patient transducer of <ref> [17] </ref>, that converts live I/O automata into live timed I/O automata without timing constraints. The embedding, which is omitted from this abstract (see [8]), preserves the environment-freedom property and the trace preorder relations of the untimed model. Furthermore, it commutes with the parallel composition operator. <p> Our model is closely related to several others in the literature. It captures the I/O automata of [10], the failure free complete trace structures of [7], and the timed I/O automata of [13]. It generalizes the notion of strong I/O feasibility introduced in <ref> [17] </ref>. The untimed model is similar to the model of [2]. However, the generalization of [2] to the timed case [1] is very complex, possibly because of the absence of a clear role for time in the interaction between the automaton and its environment. <p> However, they are not adequate to describe systems whenever their state structure is important. The model of [2] is closely related to our model (c.f. Example 2). However, our timed model departs from the key ideas of [1], leading to a more natural treatment of time. The work in <ref> [17] </ref> does not deal with general liveness, and uses finite and admissible timed traces inclusion as an implementation relation. The automata of [17] need not be environment-free, however, to avoid trivial implementations and guarantee closure under composition, [17] assumes some form of I/O distinction and some more restrictive form of environment-freedom, <p> Example 2). However, our timed model departs from the key ideas of [1], leading to a more natural treatment of time. The work in <ref> [17] </ref> does not deal with general liveness, and uses finite and admissible timed traces inclusion as an implementation relation. The automata of [17] need not be environment-free, however, to avoid trivial implementations and guarantee closure under composition, [17] assumes some form of I/O distinction and some more restrictive form of environment-freedom, called strong I/O feasibility , at the lower level of implementation. <p> The work in <ref> [17] </ref> does not deal with general liveness, and uses finite and admissible timed traces inclusion as an implementation relation. The automata of [17] need not be environment-free, however, to avoid trivial implementations and guarantee closure under composition, [17] assumes some form of I/O distinction and some more restrictive form of environment-freedom, called strong I/O feasibility , at the lower level of implementation. Our notion of environment-freedom solves the same problem in a more general way.
References-found: 17

