URL: ftp://ftp.csd.uu.se/pub/papers/theses/0023.ps.gz
Refering-URL: http://www.csd.uu.se/~thomasl/reform.html
Root-URL: 
Title: Igor: A tool for developing abstract domains for Prolog analyzers  
Author: Magnus Nordin UPMAIL 
Degree: Thesis for the Degree of Licentiate of Philosophy  
Address: Box 311 S-751 05 UPPSALA SwedenISSN 0283-359X  
Affiliation: Computing Science Department Uppsala University  
Note: UPPSALA THESES IN COMPUTING SCIENCE No. 23/95  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> A. Aiken, E.L. </author> <title> Wimmers & T.K Lakshman, Soft Typing with Conditional Types, </title> <booktitle> Proc. Symp. Principles of Programming Languages, </booktitle> <address> POPL'94, </address> <year> 1994. </year>
Reference-contexts: This would make it possible to calculate domain or program statistics from the analysis result. The current type system should be replaced with a stronger type system that is able to handle type inclusions. One such type system is Aiken's set constraint based type system <ref> [1] </ref>. This would enable Igor to detect more situations where data representation optimizations can be applied and the more precise types would facilitate the discovery of more specification errors. The generated code is quite efficient but there is room for improvement.
Reference: 2. <author> T. Armstrong, K. Marriott, P. Schacte & H. Sondergaard, </author> <title> Boolean functions for dependency analysis: Algebraic properties and efficient representation, Static Analysis Symp. 94, </title> <publisher> Springer LNCS 864, Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Language support for handling graphs should be added. One possibility would be graph explorations [14], a language construct similar to set expressions and list comprehensions, but intended to express graph algorithms. Definite boolean functions <ref> [2] </ref> is another representation used by abstract domain designers that need some basic support in the language to be easily used in Igor-specifications. The disjunctive lattice type automatically augments a lattice with disjunctive elements.
Reference: 3. <author> D. Berque, R. Cecchini, M. Goldberg, R. Rivenburgh, </author> <title> The SetPlayer System for Symbolic Computation on Power Sets, </title> <journal> J. of Symbolic Computation, </journal> <volume> Vol. 14, </volume> <pages> pp. 645-662, </pages> <year> 1992. </year>
Reference-contexts: We also tried a different approach to set representation. Instead of explicitly representing every element of a set (often very large power sets), an implicit representation, power set expressions <ref> [3] </ref>, were tried. All sets can be represented with this method, but very compact representation of large sets is only achieved when the contents of the sets are easily described by certain power set formula. Tests showed that this was not the case with our test domains.
Reference: 4. <author> J. Bevemyr, T. Lindgren & H. Millroth, </author> <title> Exploiting recursion-parallelism in Prolog, </title> <booktitle> Intl. Conf. </booktitle> <editor> PARLE-93 (eds. A. Bode, M. Reeve & G. Wolf), </editor> <publisher> Springer LNCS 694, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The sharing analysis of &-Prolog 1 [17] (called share, based on Jacob's and Langen's sharing domain [19]) was compared with J&L. The hand-coded freeness, sharing, and linearity analysis of &-Prolog (called shfrson) was compared with Sund. The type, mode, aliasing, linearity, locality and determinism analysis of Reform Prolog 2 <ref> [4, 21] </ref> was compared with Dep. The compared systems were all executed by SICStus Prolog 2.1.9. The compared domains are not identical but similar enough to serve for our approximate comparisons. Only the execution time for analysis is included in the measurements.
Reference: 5. <author> M. Carlsson, J. Widen, J. Andersson, S. Andersson, K. Boortz, H. Nilsson, T. Sjoland, </author> <title> SICStus Prolog User's Manual, </title> <institution> Swedish Institute of Computer Science, </institution> <year> 1993. </year>
Reference-contexts: All measurements were made on a Sun 630 MP with a 55 MHz processor and 128 Mb of memory. The time unit is seconds. The benchmarks were interrupted if they had not completed within 1000 seconds. SICStus Prolog <ref> [5] </ref> version 2.1.9, with the fastcode option on, was used.
Reference: 6. <author> M. Codish, A. Mulkers, M. Bruynooghe, M. Garca de la Banda & M. Hermenegildo, </author> <title> Improving abstract interpretations by combining domains, </title> <booktitle> Proc. Symp. Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <institution> PEPM'91, Yale University, </institution> <address> Connecticut, </address> <year> 1991. </year>
Reference-contexts: This upgrade results in more accurate domains. 36 Related work Open products is a method for combining domains to obtain a more sophisticated domain. The implementation of new abstract domains by combining old ones is also described in <ref> [6] </ref>. This method can successfully be used in Igor-specifications. Van Roy [26] notes that the actual use of the analysis results is less well-researched, as compared to design of generic analysis frameworks or abstract domains.
Reference: 7. <author> A. Cortesi, B. Le Charlier & P. van Hentenryck, </author> <title> Conceptual and software support for abstract domain design: Generic structural domain and open product, </title> <booktitle> Proc. Symp. Principles of Programming Languages, </booktitle> <address> POPL'94, </address> <year> 1994. </year>
Reference-contexts: Cousot and Cousot [9] proposed theoretical methods for systematic design of new abstract domains out of old ones, by combinations of domains and application of various transformations on domains. Related methods have been developed by Cortesi et al <ref> [7] </ref> who propose two kinds of support for domain construction. Generic pattern domains is software support for upgrading simpler domains to include structural information. This upgrade results in more accurate domains. 36 Related work Open products is a method for combining domains to obtain a more sophisticated domain. <p> It would be possible to automatically augment lattices with other types of elements, i.e. complementary elements, using similar methods. 38 Conclusion Among the most complicated domains to implement are domains that contain information on the form or structure of data. The generic pattern domains described by Cortesi et al <ref> [7] </ref> alleviate much of the design work on these domains by automatically extending non-structural domains with structure information. It would be possible and desirable to add such a method to Igor. Igor can be told to annotate an analyzed program with the result of the analysis.
Reference: 8. <author> P. Cousot & R. Cousot, </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints, </title> <booktitle> in Conference Record of the 4th ACM Symposium on Principles of Programming Languages, 1977. </booktitle> <volume> 59 60 </volume>
Reference-contexts: Introduction Program analysis is increasingly being used for optimization of programming language implementations. Abstract interpretation <ref> [8] </ref> is a method that provides a semantic approach to program analysis. A non-standard abstract semantics is used to simulate the execution of the program to be analyzed. The result of the abstract interpretation is an approximate description of the execution of the program.
Reference: 9. <author> P. Cousot & R. Cousot, </author> <title> Systematic design of program analysis frameworks, </title> <booktitle> Proc. 6th Conf. Principles of Programming Languages, </booktitle> <pages> pp. 269-282, </pages> <year> 1979. </year>
Reference-contexts: Genesis [31] is a tool that generates complex optimizers from specifications that describes the combination of several simpler optimizations. The tool is primarily intended to help prototyping optimizers during the design of compilers for parallel imperative languages. Cousot and Cousot <ref> [9] </ref> proposed theoretical methods for systematic design of new abstract domains out of old ones, by combinations of domains and application of various transformations on domains. Related methods have been developed by Cortesi et al [7] who propose two kinds of support for domain construction.
Reference: 10. <author> P. Cousot & R. Cousot, </author> <title> Abstract interpretation and application to logic programs, </title> <journal> J. of Logic Programming, </journal> <volume> Vol. 13, </volume> <pages> pp. 103-179, </pages> <year> 1992. </year>
Reference: 11. <author> S.K. Debray, </author> <title> Static inference of modes and data dependencies in logic programs, </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> Vol. 11, No. 3, </volume> <pages> pp. 418-450, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: The domains used in the evaluation are Sund, Sundararajan's domain for freeness, sharing, and linearity [27]; J&L, Jacobs's and Langen's sharing domain [19]; Str, a simple depth-k structure domain; Deb, one of Debray's substitution-closed type domains [12]; Dep, Debray's mode and dependency domain <ref> [11] </ref>. The set of programs analyzed in the evaluation is a subset of the Berkeley benchmarks [26]. A description of the benchmarks is found in Appendix B. Domain and compilation statistics The size of the specifications of domains we have implemented range between 1 to 3 pages of non-commented code.
Reference: 12. <author> S.K. Debray, </author> <title> Efficient dataflow analysis of logic programs, </title> <journal> J. ACM , Vol. </journal> <volume> 39, No. 4, </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: The user can override these operations with his own if needed. These operations together with an abstract interpretation framework make up a complete analyzer. The mode domain above must be combined with a domain for variable aliasing, since it is not substitution-closed <ref> [12] </ref>. We can specify an aliasing domain that is a set of sets of variables in a clause C as follows. type aliasing (C) =&gt; set (set (variables (C))). <p> SICStus Prolog [5] version 2.1.9, with the fastcode option on, was used. The domains used in the evaluation are Sund, Sundararajan's domain for freeness, sharing, and linearity [27]; J&L, Jacobs's and Langen's sharing domain [19]; Str, a simple depth-k structure domain; Deb, one of Debray's substitution-closed type domains <ref> [12] </ref>; Dep, Debray's mode and dependency domain [11]. The set of programs analyzed in the evaluation is a subset of the Berkeley benchmarks [26]. A description of the benchmarks is found in Appendix B. <p> C.2. A Simple Type Domain, deb.ad 49 C.2 A SIMPLE TYPE DOMAIN, DEB.AD This is one of Debray's substitution closed type domains <ref> [12] </ref>. It keeps track on integers, lists of integers, constants, lists of constants, lists, and non-variables. % any % nv % list c % |/ " % clist integer % " / % none :- set_flag (normalize (all)).
Reference: 13. <author> S.K. Debray, QD-Janus: </author> <title> a sequential implementation of Janus in Prolog, </title> <journal> Software | Practice and Experience, </journal> <volume> Vol. 23, No. 12, </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: The Compiler The functional domain specification is compiled into a Prolog program ready to be interfaced with an analyzer framework. The feasibility of compiling high-level languages to Prolog has been convincingly shown by Debray <ref> [13] </ref>.
Reference: 14. <author> M. Erwig, </author> <title> Graph Algorithms = Iteration + Data Structures?, </title> <booktitle> Graph-Theoretic Concepts in Computer Science, LNCS 657, </booktitle> <year> 1992. </year>
Reference-contexts: Language support for handling graphs should be added. One possibility would be graph explorations <ref> [14] </ref>, a language construct similar to set expressions and list comprehensions, but intended to express graph algorithms. Definite boolean functions [2] is another representation used by abstract domain designers that need some basic support in the language to be easily used in Igor-specifications.
Reference: 15. <author> T.W. Getzinger, </author> <title> Abstract interpretation for the compile-time optimization of logic programs, </title> <type> Ph.D. Thesis, </type> <institution> University of South California, </institution> <type> Report 93/09, </type> <year> 1993. </year>
Reference-contexts: Domain specifications are written in a first-order, statically typed strict functional language. This language has operations for manipulating sets and lattices, for projecting domains, and for combining domains. Specifications are compiled to 2 Introduction Prolog code and optionally linked with an analysis framework based on Getzinger's algorithm <ref> [15] </ref>. There is a completely customizable interface to the automatically-generated domain code for users that want to provide their own fixpoint engines. <p> This method can successfully be used in Igor-specifications. Van Roy [26] notes that the actual use of the analysis results is less well-researched, as compared to design of generic analysis frameworks or abstract domains. Get-zinger <ref> [15] </ref> performs an evaluation of the advantages gained from of a large number of domains, when used to compile logic programs. In Igor, this type of domain evaluation is facilitated by the provided support for specifying code annotations, information which can be utilized by any subsequent compilation phase. <p> Initialize analyzer. Set initial entry and exit descriptions. 5. Analyze program. Perform the analysis of the program, and, if not running quietly, report the result. The analyzer framework is based on Getzinger's generic abstract interpretation framework <ref> [15] </ref>. The global data used in the analysis algorithm, as shown in the figure, are: A.1.
Reference: 16. <author> P. van Hentenryck, A. Cortesi & B. Le Charlier, </author> <title> Type analysis of prolog using type graphs, </title> <journal> J. Logic Programming, </journal> <volume> Vol. 22, No. 3, </volume> <year> 1995. </year>
Reference-contexts: be instrumental in helping to change the task of implementing static analysis domains from being a black art into a routine task on the same level as using Lex or Yacc for lexical analysis and parsing. 7.2 DISCUSSION AND FUTURE WORK The language does not provide support for type graphs <ref> [16] </ref>. Language support for handling graphs should be added. One possibility would be graph explorations [14], a language construct similar to set expressions and list comprehensions, but intended to express graph algorithms.
Reference: 17. <author> M. Hermenegildo & K. Greene, </author> <title> The &-Prolog system: Exploiting independent and-parallelism, </title> <journal> New Generation Computing, </journal> <volume> Vol. 9, </volume> <pages> pp. 233-257, </pages> <year> 1991. </year>
Reference-contexts: Efficiency of generated code Comparisons of hand-coded with auto-generated domains were performed as follows. The sharing analysis of &-Prolog 1 <ref> [17] </ref> (called share, based on Jacob's and Langen's sharing domain [19]) was compared with J&L. The hand-coded freeness, sharing, and linearity analysis of &-Prolog (called shfrson) was compared with Sund. The type, mode, aliasing, linearity, locality and determinism analysis of Reform Prolog 2 [4, 21] was compared with Dep.
Reference: 18. <author> S.C. Johnson, </author> <title> Yacc | Yet another compiler-compiler, </title> <institution> Comp. Sci. </institution> <type> Tech. Rep. No. 32, </type> <institution> Bell Laboratories, </institution> <month> July </month> <year> 1975. </year>
Reference-contexts: Most of the time the performance of the generated code is within a factor 0.5-3 of the hand-coded domain. Chapter 6 Related work The most well-known predecessors to Igor are the tools Yacc <ref> [18] </ref>, a parser generator, and Lex [20], a tool that generates lexical analyzers. These were developed at Bell Laboratories in the mid-seventies and are still two of the most widely used tools for compiler development.
Reference: 19. <author> D. Jacobs & A. Langen, </author> <title> Accurate and efficient approximation of variable aliasing in logic programs, </title> <booktitle> Proc. North American Conf. Logic Programming 1989, </booktitle> <pages> pp. 154-165, </pages> <year> 1989. </year>
Reference-contexts: The benchmarks were interrupted if they had not completed within 1000 seconds. SICStus Prolog [5] version 2.1.9, with the fastcode option on, was used. The domains used in the evaluation are Sund, Sundararajan's domain for freeness, sharing, and linearity [27]; J&L, Jacobs's and Langen's sharing domain <ref> [19] </ref>; Str, a simple depth-k structure domain; Deb, one of Debray's substitution-closed type domains [12]; Dep, Debray's mode and dependency domain [11]. The set of programs analyzed in the evaluation is a subset of the Berkeley benchmarks [26]. A description of the benchmarks is found in Appendix B. <p> Efficiency of generated code Comparisons of hand-coded with auto-generated domains were performed as follows. The sharing analysis of &-Prolog 1 [17] (called share, based on Jacob's and Langen's sharing domain <ref> [19] </ref>) was compared with J&L. The hand-coded freeness, sharing, and linearity analysis of &-Prolog (called shfrson) was compared with Sund. The type, mode, aliasing, linearity, locality and determinism analysis of Reform Prolog 2 [4, 21] was compared with Dep. The compared systems were all executed by SICStus Prolog 2.1.9. <p> C.3. Jacobs's and Langen's Sharing Domain, jl.ad 51 C.3 JACOBS'S AND LANGEN'S SHARING DOMAIN, JL.AD This is Jacobs's and Langen's simple sharing domain <ref> [19] </ref>. It has no knowledge of linearity and can be extremely time consuming when analyzing clauses containing many variables. :- set_flag (normalize (head)), set_flag (terminate_on_bot (off)). Type definitions type desc (Term) =&gt; set (set (variables (Term))).
Reference: 20. <author> M.E. Lesk, </author> <title> Lex | A lexical analyzer generator, </title> <institution> Comp. Sci. </institution> <type> Tech. Rep. No. 39, </type> <institution> Bell Laboratories, </institution> <month> October </month> <year> 1975. </year>
Reference-contexts: Most of the time the performance of the generated code is within a factor 0.5-3 of the hand-coded domain. Chapter 6 Related work The most well-known predecessors to Igor are the tools Yacc [18], a parser generator, and Lex <ref> [20] </ref>, a tool that generates lexical analyzers. These were developed at Bell Laboratories in the mid-seventies and are still two of the most widely used tools for compiler development. Venkatesh [30] designed a denotational semantics specification language augmented with a collecting semantics mechanism for program analysis.
Reference: 21. <author> T. Lindgren, </author> <title> The compilation and execution of recursion-parallel Prolog on shared-memory multiprocessors, </title> <booktitle> Licentiate of Philosophy Thesis, Uppsala Theses in Computer Science 18/93, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: The sharing analysis of &-Prolog 1 [17] (called share, based on Jacob's and Langen's sharing domain [19]) was compared with J&L. The hand-coded freeness, sharing, and linearity analysis of &-Prolog (called shfrson) was compared with Sund. The type, mode, aliasing, linearity, locality and determinism analysis of Reform Prolog 2 <ref> [4, 21] </ref> was compared with Dep. The compared systems were all executed by SICStus Prolog 2.1.9. The compared domains are not identical but similar enough to serve for our approximate comparisons. Only the execution time for analysis is included in the measurements.
Reference: 22. <author> T. Lindgren, </author> <type> personal communication. </type>
Reference-contexts: For example, during the development of a compiler in a Prolog system it was found that altering or extending the implementation of a moderately complex (120 Kb of Prolog code) analyzer took more than one person-week even for relatively straightforward changes <ref> [22] </ref>. Major redesigns or extensions would probably require complete re-implementation, a task of several person-months. To improve upon this situation, we have designed and implemented a tool called Igor that, given a high-level specification of the analysis domain, generates large parts of the analyzer automatically.
Reference: 23. <author> R. Milner, </author> <title> A theory of type polymorphism in programming, </title> <journal> J. of Computer and System Science, </journal> <volume> Vol. 17, </volume> <pages> pp. 348-375, </pages> <year> 1978. </year> <month> 61 </month>
Reference-contexts: Using the type annotations, the last phase also sees to that the correct and most efficient Prolog primitives are chosen for overloaded functions and set functions. The type checker checks and infers the types of all expressions in the specification. It uses the Hindley/Milner type system <ref> [23] </ref> to produce an annotated version of domain specification. The type consistency of the specification is of course decided by the type checker, but the primary use of the inferred types is to decide when it is possible to use a more efficient set representation using bit vectors.
Reference: 24. <author> M. Nordin, </author> <title> Manual of Igor: A tool for developing abstract domains for Pro-log, </title> <type> technical report, </type> <institution> Computing Science Dept., Uppsala University, forthcoming, </institution> <year> 1995. </year>
Reference-contexts: Built-in functions Igor provides a large set of built-in functions suited for abstract domain specification. We will give a short overview of the the most important built-in functions and refer to the Igor manual <ref> [24] </ref> for a complete description. This overview should enable the reader to understand the domain examples in Appendix C. <p> This representation is used when the type checker can infer that a data object is a set of program variables. For a complete description of the type annotations see the Igor manual <ref> [24] </ref>. The compiler checks that the chains of all defined lattice types really constitute proper lattices. Inclusion of Prolog Predicates It is possible to include deterministic Prolog predicates in specifications. <p> This predicate decides where to start the analysis. The body of the top/0 predicate should be a query that reflects the use of the program to be analyzed. * annotate (Filename) Analyzes the Prolog program contained in Filename, annotates (see the manual <ref> [24] </ref>) the program with the result, and writes the annotated program to the file Filename.an. * debug level (Level) sets the debugging level to Level. The specification must have been compiled with cons/1 to be debuggable. More information on debugging levels can be found in the Igor manual [24]. * timing <p> the manual <ref> [24] </ref>) the program with the result, and writes the annotated program to the file Filename.an. * debug level (Level) sets the debugging level to Level. The specification must have been compiled with cons/1 to be debuggable. More information on debugging levels can be found in the Igor manual [24]. * timing level (Level) set the timing level to Level. More information on timing levels can be found in the Igor manual [24]. <p> The specification must have been compiled with cons/1 to be debuggable. More information on debugging levels can be found in the Igor manual <ref> [24] </ref>. * timing level (Level) set the timing level to Level. More information on timing levels can be found in the Igor manual [24].
Reference: 25. <editor> S.L. Peyton Jones, </editor> <booktitle> The Implementation of Functional Programming Languages, </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: There are no local function definitions. 3.4. User-Defined Functions 25 Set Expressions As most of the expressions in the abstract domain specifications work with sets, Igor supports set expressions. These expressions are based upon Turner's ZF-expressions [29] and are implemented as a variant of list comprehensions <ref> [25] </ref>. A set expression looks like: fexpr | V 1 &lt;- expr 1 , ..., V n &lt;- expr n , pred g expr stands for an expression and pred for a boolean function.
Reference: 26. <author> P.L. van Roy, </author> <title> Can Logic Programming Execute as Fast as Imperative Programming?, </title> <type> Ph.D. Thesis, </type> <institution> UCB/CSD 90/600, Computer Science Division (EECS), University of California, Berkeley, </institution> <year> 1990. </year>
Reference-contexts: The set of programs analyzed in the evaluation is a subset of the Berkeley benchmarks <ref> [26] </ref>. A description of the benchmarks is found in Appendix B. Domain and compilation statistics The size of the specifications of domains we have implemented range between 1 to 3 pages of non-commented code. <p> This upgrade results in more accurate domains. 36 Related work Open products is a method for combining domains to obtain a more sophisticated domain. The implementation of new abstract domains by combining old ones is also described in [6]. This method can successfully be used in Igor-specifications. Van Roy <ref> [26] </ref> notes that the actual use of the analysis results is less well-researched, as compared to design of generic analysis frameworks or abstract domains. Get-zinger [15] performs an evaluation of the advantages gained from of a large number of domains, when used to compile logic programs.
Reference: 27. <author> R. Sundararajan, </author> <title> An abstract interpretation scheme for groundness, freeness, and sharing analysis of logic programs, </title> <type> Technical Report CIS-TR-91-06, </type> <institution> Dept. of Computer and Information Science, University of Oregon, </institution> <year> 1991 </year>
Reference-contexts: The time unit is seconds. The benchmarks were interrupted if they had not completed within 1000 seconds. SICStus Prolog [5] version 2.1.9, with the fastcode option on, was used. The domains used in the evaluation are Sund, Sundararajan's domain for freeness, sharing, and linearity <ref> [27] </ref>; J&L, Jacobs's and Langen's sharing domain [19]; Str, a simple depth-k structure domain; Deb, one of Debray's substitution-closed type domains [12]; Dep, Debray's mode and dependency domain [11]. The set of programs analyzed in the evaluation is a subset of the Berkeley benchmarks [26]. <p> C.4. Sundararajan's Domain, sund.ad 53 C.4 SUNDARARAJAN'S DOMAIN, SUND.AD Sundararajan's domain <ref> [27] </ref> keeps track of definite freeness, linearity, and aliasing. This domain is more precise and faster than Jacobs's and Langen's domain, but can still be extremely time consuming when analyzing clauses with a large number of variables.
Reference: 28. <author> S.W-K. Tjiang, </author> <title> Automatic Generation of Data-Flow Analyzers: A Tool for Building Optimizers, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computer Science, Stanford University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Our system extends the capabilities of Z1 with disjunctive and structure-based domains and more flexible projection operations. Igor is furthermore substantially faster. We do not, however, include the analysis framework in the specifications. Tjiang <ref> [28] </ref> describes a tool that greatly simplifies the implementation of optimizers by using high-level specifications to combine several simpler optimization specifications. This tool works with flow-graphs, using a data-flow analysis method called path simplification, and is aimed at imperative rather than declarative languages.
Reference: 29. <author> D.A. Turner, </author> <title> Recursion equations as a programming language, Functional Programming and Its Applications, </title> <editor> Darlington et al., editors, </editor> <publisher> Cambridge University Press, </publisher> <year> 1982. </year>
Reference-contexts: There are no local function definitions. 3.4. User-Defined Functions 25 Set Expressions As most of the expressions in the abstract domain specifications work with sets, Igor supports set expressions. These expressions are based upon Turner's ZF-expressions <ref> [29] </ref> and are implemented as a variant of list comprehensions [25]. A set expression looks like: fexpr | V 1 &lt;- expr 1 , ..., V n &lt;- expr n , pred g expr stands for an expression and pred for a boolean function.
Reference: 30. <author> G.A. Venkatesh, </author> <title> A framework for construction and evaluation of high-level specifications for program analysis techniques, </title> <booktitle> SIGPLAN Conf. Programming Language Design and Implementation, PLDI'89, </booktitle> <pages> pp. 1-12, </pages> <year> 1989. </year>
Reference-contexts: These were developed at Bell Laboratories in the mid-seventies and are still two of the most widely used tools for compiler development. Venkatesh <ref> [30] </ref> designed a denotational semantics specification language augmented with a collecting semantics mechanism for program analysis. The abstract domains, that are similar to Igor's, are combined with semantic functions over these domains to make up an analyzer. The specifications are interpreted rather than compiled.
Reference: 31. <author> D. Whitfield & M.L. Soffa, </author> <title> The Design and Implementation of Genesis, </title> <journal> Software | Practice and Experience, </journal> <volume> Vol. 24, No. 3, </volume> <pages> pp. 307-325, </pages> <year> 1994. </year>
Reference-contexts: Tjiang [28] describes a tool that greatly simplifies the implementation of optimizers by using high-level specifications to combine several simpler optimization specifications. This tool works with flow-graphs, using a data-flow analysis method called path simplification, and is aimed at imperative rather than declarative languages. Genesis <ref> [31] </ref> is a tool that generates complex optimizers from specifications that describes the combination of several simpler optimizations. The tool is primarily intended to help prototyping optimizers during the design of compilers for parallel imperative languages.
Reference: 32. <author> K. Yi & W.L. Harrison III, </author> <title> Automatic generation and management of interpro-cedural program analyses, </title> <booktitle> The 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year> <institution> UPMAIL Computing Science Department Uppsala University Box 311 S-751 05 UPPSALA Sweden Phone: </institution> <note> Nat 018 - 18 25 00 Int +46 18 18 25 00 Fax: Nat 018 - 52 12 70 Int +46 18 52 12 70 ISSN 0283-359X </note>
Reference-contexts: Venkatesh [30] designed a denotational semantics specification language augmented with a collecting semantics mechanism for program analysis. The abstract domains, that are similar to Igor's, are combined with semantic functions over these domains to make up an analyzer. The specifications are interpreted rather than compiled. The Z1 system <ref> [32] </ref> allows the programmer to specify an interprocedural analyzer, consisting of an abstract interpreter and an abstract domain, which is compiled into executable C-code. Our system extends the capabilities of Z1 with disjunctive and structure-based domains and more flexible projection operations. Igor is furthermore substantially faster.
References-found: 32

