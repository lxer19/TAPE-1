URL: http://www.cs.tamu.edu/people/anishk/publications/TR_95-009.ps.Z
Refering-URL: http://www.cs.tamu.edu/people/anishk/publications.html
Root-URL: http://www.cs.tamu.edu
Title: DCE(Distributed Computing Environment) Porting Tool  
Author: Sridhar Muppidi, Rakesh Burudgunte, Anish Karmarkar, Ganesha Beedubail, Neal Krawatz, Anil Gurijala, Paul Brutch, Kyle Walzel, Vance Swaggerty, Ganesh Jayadevan, Ramesh Narayanan, Charlie Richardson, Sunil Santha, Willis Marti, Udo Pooch. 
Keyword: Remote Procedure Call (RPC), Distributed Computing Environment (DCE), Open Network Computing (ONC), Interface Definition Language (IDL), Porting Tool.  
Date: February 28, 1995  
Abstract: This paper describes the design and implementation of a conversion tool. This tool, called Distributed Computing Environment (DCE) Porting Tool, converts an Open Network Computing (ONC) Remote Procedure Call (RPC) application to a DCE RPC application. The manual intervention needed during the conversion process in minimal. The paper briefly describes RPC programming and highlights the difference between ONC RPC and DCE RPC. The design decisions of the Porting Tool is explained. The implementation uses LEX and YACC (language processing tools supported by Unix) for conversion logic and OSF/MOTIF for Graphical User Interface (GUI). The paper concludes with current limitations of the Tool and the possible future work. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. W. Lockhart, </author> <title> "OSF DCE, Guide to Developing Distributed Applications," </title> <publisher> McGraw Hill, Inc., </publisher> <year> 1994. </year>
Reference-contexts: over a network, the availability of large computing power of small computers and inherent fault tolerance associated with the distribution of computing resources. 1 This project was supported by IBM Austin under contract number 32525-42640-CS. 1 From the programming point of view, distributed processing can be categorized into various models <ref> [1] </ref>. Here we explain the client-server model, the model used in this paper. For a discussion of other models refer [1]. In the client server model, each interaction is characterized by an asymmetrical relationship between two software processes. <p> of computing resources. 1 This project was supported by IBM Austin under contract number 32525-42640-CS. 1 From the programming point of view, distributed processing can be categorized into various models <ref> [1] </ref>. Here we explain the client-server model, the model used in this paper. For a discussion of other models refer [1]. In the client server model, each interaction is characterized by an asymmetrical relationship between two software processes. One, the client, makes requests for service and the other, the server, provides the service on request. The processing flow is characteristically synchronous (blocking) in nature. <p> Since the objective of this project is the conversion of applications from the ONC RPC platform to the DCE RPC platform, only DCE RPC programming is explained here. For a detailed description of programming in DCE see <ref> [1, 2, 6, 7] </ref>. The first step is to write an interface. In case of DCE, the interface specification language is called IDL (Interface Definition Language) and the compiler is idl compiler. In DCE each interface is uniquely identified (in time and space) by a UUID ( Universal Unique Identifier).
Reference: [2] <author> John Shirly, </author> <title> "Guide to Writing DCE Applications," </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> Sebastopol, CA 1993. </address>
Reference-contexts: Since the objective of this project is the conversion of applications from the ONC RPC platform to the DCE RPC platform, only DCE RPC programming is explained here. For a detailed description of programming in DCE see <ref> [1, 2, 6, 7] </ref>. The first step is to write an interface. In case of DCE, the interface specification language is called IDL (Interface Definition Language) and the compiler is idl compiler. In DCE each interface is uniquely identified (in time and space) by a UUID ( Universal Unique Identifier). <p> IDL does not have procedure numbers. * The procedure has only one parameter in the .x file (basically the input parameter to the procedure). In the .idl file one more parameter is added to the procedure. The added parameter is the binding handler parameter. Binding handler <ref> [2] </ref> is used by DCE RPC call when explicit binding method is used. In the converted DCE RPC program, explicit binding method (to retain the same semantic of ONC RPC call) is used. * Some constructs of RPCL (the .x file) are not supported in IDL.
Reference: [3] <author> J. Bloomer, </author> <title> "Power Programming with RPC," </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> Sebastopol, CA 1992. </address>
Reference-contexts: Below we will explain RPC programming in two common platforms (ONC and DCE). 2.2 ONC RPC Programming In the ONC environment, the interface (or protocol) is specified in the XDR (eXternal Data Representation) language. The detailed description of XDR is given in <ref> [3] </ref>. The protocol compiler is called RPCGEN. RPCGEN [3]. It also shows the various conventions that are generally used. Note that in the ONC environment, an RPC application can be developed without the use of RPCGEN 4 and a Protocol specification. <p> The detailed description of XDR is given in <ref> [3] </ref>. The protocol compiler is called RPCGEN. RPCGEN [3]. It also shows the various conventions that are generally used. Note that in the ONC environment, an RPC application can be developed without the use of RPCGEN 4 and a Protocol specification. In fact it is possible to develop an RPC application with various levels of details [3]. <p> RPCGEN <ref> [3] </ref>. It also shows the various conventions that are generally used. Note that in the ONC environment, an RPC application can be developed without the use of RPCGEN 4 and a Protocol specification. In fact it is possible to develop an RPC application with various levels of details [3]. But in this paper and for the tool only ONC RPC programming using RPCGEN is considered. 2.3 DCE RPC Programming DCE RPC programming is slightly more involved than ONC RPC programming. This is because DCE provides more services to a distributed application developer. <p> A detailed discussion of the findings is outside the scope of this paper. Interested readers can refer to the SDD (System Design Document) for the DCE Porting Tool [5]. Interested readers can also refer to the grammars of ONC RPCL and DCE IDL in <ref> [3, 6] </ref>. For brevity the grammars are not presented here. However an example of the ONC RPCL interface file ( the .x file) and the converted (ported) DCE IDL interface file (the .idl file) is given in appendix A. This will illustrate most of the points discussed here.
Reference: [4] <author> J. R. Levine, J. Mason, D. Brown, </author> <title> "LEX & YACC," </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> Sebastopol, CA 1992. </address>
Reference-contexts: It is also necessary to parse the .x file, so that the logically equivalent .idl file can be generated. This is something similar to interpreting the .x file. Language processing tools LEX and YACC being ideal for such a job. Thus LEX and YACC <ref> [4] </ref> are used in the implementation of the Porting Tool. The implementation of the Porting Tool contains three main modules. 10 X2IDL This module converts the ONC RPC .x file into DCE RPC .idl file. This module also generates M.h (macro header file) and svc DCE.c (Server registration logic) files.
Reference: [5] <institution> System Design Document for DCE Porting Tool, Prepared for IBM Austin, Contract No. 32525-42640-CS, Texas A&M University, </institution> <year> 1994. </year>
Reference-contexts: In the following, some of the findings of the above analysis are discussed. A detailed discussion of the findings is outside the scope of this paper. Interested readers can refer to the SDD (System Design Document) for the DCE Porting Tool <ref> [5] </ref>. Interested readers can also refer to the grammars of ONC RPCL and DCE IDL in [3, 6]. For brevity the grammars are not presented here. <p> A detailed discussion of the result of the above study is given in the appendices of SDD (System Design Document) <ref> [5] </ref>. Some of the salient design decisions are discussed here. In the converted application the explicit binding method of the DCE RPC is used. This is because in ONC RPC, the client knows the server location and directs the RPC call to a specific server. <p> The rationale for this file was explained before. It also contains macro definitions that will change the structure of ONC RPC calls so that now they work in DCE. It also contains some other miscellaneous definitions. For details see SDD <ref> [5] </ref>. svc DCE.c file : This file is the svc.template file with the proper interface related vari able names substituted. The X2IDL module has two major sub modules called pass1 and pass2. In effect these two modules make two passes on the .x file. <p> The program-name in the .x file is available some where at the middle of the the .x file and it is needed for deriving the interface name for the .idl file. In .idl file interface name appears near the beginning of the file. For details refer to SDD <ref> [5] </ref>. Module pass1 is the parser for X2IDL. It uses .x grammar (ONC RPCL grammar) to parse the .x file. The parser is implemented using YACC. The parser calls the LEXER for getting the tokens from the .x file. The logic of this module is straight forward. <p> It need not understand the syntax of the input files. Thus the LEXER is enough to do the job. In the implementation, the same LEXER code is used for pass1 and pass2. Of course different lexer states are used in the two passes. Details are given in SDD <ref> [5] </ref>. 4.2 Implementation of Function Converter The implementation of function conversion module (function converter) is quite straight forward.
Reference: [6] <author> OSF, </author> <title> "OSF DCE Application Development Reference," </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1991. </year>
Reference-contexts: Since the objective of this project is the conversion of applications from the ONC RPC platform to the DCE RPC platform, only DCE RPC programming is explained here. For a detailed description of programming in DCE see <ref> [1, 2, 6, 7] </ref>. The first step is to write an interface. In case of DCE, the interface specification language is called IDL (Interface Definition Language) and the compiler is idl compiler. In DCE each interface is uniquely identified (in time and space) by a UUID ( Universal Unique Identifier). <p> A detailed discussion of the findings is outside the scope of this paper. Interested readers can refer to the SDD (System Design Document) for the DCE Porting Tool [5]. Interested readers can also refer to the grammars of ONC RPCL and DCE IDL in <ref> [3, 6] </ref>. For brevity the grammars are not presented here. However an example of the ONC RPCL interface file ( the .x file) and the converted (ported) DCE IDL interface file (the .idl file) is given in appendix A. This will illustrate most of the points discussed here.
Reference: [7] <author> OSF, </author> <title> "OSF DCE User's Guide and Reference," </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1991. </year>
Reference-contexts: Since the objective of this project is the conversion of applications from the ONC RPC platform to the DCE RPC platform, only DCE RPC programming is explained here. For a detailed description of programming in DCE see <ref> [1, 2, 6, 7] </ref>. The first step is to write an interface. In case of DCE, the interface specification language is called IDL (Interface Definition Language) and the compiler is idl compiler. In DCE each interface is uniquely identified (in time and space) by a UUID ( Universal Unique Identifier).
Reference: [8] <author> OSF, </author> <title> "OSF/MOTIF Programmers Guide," </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1990. </year>
Reference-contexts: GUI Graphical User Interface This module is responsible for presenting the Porting Tool to the user in a friendly manner. It has the necessary pull down menus and data entry windows. It is developed using OSF/MOTIF according to the suggested style <ref> [8, 9, 10] </ref>. 11 4 Implementation Details In this section some of the salient features of the implementation is discussed. <p> GUI is developed using OSF/MOTIF in accordance with the suggested style <ref> [8, 9, 10] </ref>. It provides convenient pull down menus, text entry fields and file browse windows for the easy access of Porting Tool components. The implementation logic of GUI follows the event-driven programming model that is generally used in the case of Motif/X Window system programming.
Reference: [9] <author> OSF, </author> <title> "OSF/MOTIF Programmers Reference," </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1990. </year>
Reference-contexts: GUI Graphical User Interface This module is responsible for presenting the Porting Tool to the user in a friendly manner. It has the necessary pull down menus and data entry windows. It is developed using OSF/MOTIF according to the suggested style <ref> [8, 9, 10] </ref>. 11 4 Implementation Details In this section some of the salient features of the implementation is discussed. <p> GUI is developed using OSF/MOTIF in accordance with the suggested style <ref> [8, 9, 10] </ref>. It provides convenient pull down menus, text entry fields and file browse windows for the easy access of Porting Tool components. The implementation logic of GUI follows the event-driven programming model that is generally used in the case of Motif/X Window system programming.
Reference: [10] <author> OSF, </author> <title> "OSF/MOTIF Style Guide," </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1990. </year> <month> 18 </month>
Reference-contexts: GUI Graphical User Interface This module is responsible for presenting the Porting Tool to the user in a friendly manner. It has the necessary pull down menus and data entry windows. It is developed using OSF/MOTIF according to the suggested style <ref> [8, 9, 10] </ref>. 11 4 Implementation Details In this section some of the salient features of the implementation is discussed. <p> GUI is developed using OSF/MOTIF in accordance with the suggested style <ref> [8, 9, 10] </ref>. It provides convenient pull down menus, text entry fields and file browse windows for the easy access of Porting Tool components. The implementation logic of GUI follows the event-driven programming model that is generally used in the case of Motif/X Window system programming.
References-found: 10

