URL: file://ftp.cs.wisc.edu/coral/doc/bupeval.survey.ps
Refering-URL: http://www.cs.wisc.edu/coral/coral.papers.html
Root-URL: 
Title: EFFICIENT BOTTOM-UP EVALUATION OF LOGIC PROGRAMS  
Author: RAGHU RAMAKRISHNAN, DIVESH SRIVASTAVA and S. SUDARSHAN 
Keyword: Key words: Logic Programs, Bottom-Up Evaluation, Deductive Databases, Database Query Languages.  
Address: Madison WI 53706, U.S.A.  
Affiliation: Computer Sciences Department University of Wisconsin Madison  
Abstract: In recent years, much work has been directed towards evaluating logic programs and queries on deductive databases by using an iterative bottom-up fixpoint computation. The resulting techniques offer an attractive alternative to Prolog-style top-down evaluation in several situations. They are sound and complete for positive Horn clause programs, are well-suited to applications with large volumes of data (facts), and can support a variety of extensions to the standard logic programming paradigm. We present the basics of database query evaluation and logic programming evaluation, and then discuss bottom-up fixpoint evaluation. We discuss an approach based upon using a program transformation ("Magic Templates") to restrict search, followed by fixpoint computation using a technique ("Semi-naive evaluation") that avoids repeated inferences. The program transformation technique focuses the fixpoint evaluation, which is a forward-chaining strategy, by propagating bindings in the goal in a manner that essentially mimics the backward-chaining behavior of top-down evaluation strategies. After presenting the basic framework for bottom-up evaluation, we discuss several refinements that optimize the treatment of non-ground terms, improve memory utilization, reduce the cost of duplicate checking, and utilize the declarative semantics of the program to perform semantic query optimization in a number of ways. We also consider several extensions to the logic programming paradigm, and discuss how the bottom-up evaluation framework can be used to support these extensions. The extensions include support for negation, set-terms, constraint manipulation and quantitative reasoning. Finally, we discuss several systems based upon bottom-up evaluation, including Aditi (Univ. of Melbourne), EKS-V1 (ECRC-Munich), Glue/NAIL! (Stanford Univ.) and LDL (MCC-Austin). We have developed such a system, called CORAL, and we present this in more detail. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Alfred V. Aho and Jeffrey D. Ullman. </author> <title> Universality of data retrieval languages. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 110-120, </pages> <address> San Antonio, Texas, </address> <year> 1979. </year>
Reference-contexts: program in which the recursive predicate is unary. 2 The previous example illustrated how the adornment algorithm can sometimes push the projection through recursion and thereby reduce the arity of recursive predicates. (The observation that pushing projections could reduce arity of recursive predicates was first made by Aho and Ullman <ref> [1] </ref>, and later Kifer and Lozinskii [47] and Apers et al. [2]. The adornment algorithm in [76] generalizes their results.) The acute reader will have observed that more can be achieved | the recursive rule may be deleted entirely. <p> CORAL allows facts to have variables within them. Thus, it is possible to query append as follows: Query: ?-append ([1; 2; 3; 4; X]; [Y; Z]; AN S): and get the answer AN S = <ref> [1; 2; 3; 4; X; Y; Z] </ref> In this CORAL differs from Aditi, EKS-V1, LDL, Glue/NAIL! and Star-burst SQL, which restrict the facts in a database to be ground. The cost and benefits of non-ground facts is discussed in Section 5.10. 8.1.1.
Reference: 2. <author> P.M.G. Apers, M.A.W. Houtsma, and F. Brandse. </author> <title> Processing recursive queries in relational algebra. </title> <booktitle> In Data and Knowledge (DS-2), Proc. of the Second IFIP 2.6 Working Conference on Database Semantics, </booktitle> <pages> pages 17-39. </pages> <publisher> North Holland, </publisher> <year> 1986. </year> <title> EFFICIENT BOTTOM-UP EVALUATION OF LOGIC PROGRAMS 33 </title>
Reference-contexts: example illustrated how the adornment algorithm can sometimes push the projection through recursion and thereby reduce the arity of recursive predicates. (The observation that pushing projections could reduce arity of recursive predicates was first made by Aho and Ullman [1], and later Kifer and Lozinskii [47] and Apers et al. <ref> [2] </ref>. The adornment algorithm in [76] generalizes their results.) The acute reader will have observed that more can be achieved | the recursive rule may be deleted entirely. <p> CORAL allows facts to have variables within them. Thus, it is possible to query append as follows: Query: ?-append ([1; 2; 3; 4; X]; [Y; Z]; AN S): and get the answer AN S = <ref> [1; 2; 3; 4; X; Y; Z] </ref> In this CORAL differs from Aditi, EKS-V1, LDL, Glue/NAIL! and Star-burst SQL, which restrict the facts in a database to be ground. The cost and benefits of non-ground facts is discussed in Section 5.10. 8.1.1.
Reference: 3. <author> K. R. Apt, H. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> San Mateo, Calif., </address> <year> 1988. </year>
Reference-contexts: The meaning of a program with negation is usually given by some "intended" model ([18; 3; 72; 71; 34; 85; 73; 104], among others). One important class of negation that has been extensively studied is stratified negation <ref> [18; 3] </ref>. Intuitively, a program is stratified if there is no recursion through negation. Programs in this class have an intuitive semantics and can also be efficiently evaluated. The following example describes a stratified program. EXAMPLE 6.1. <p> CORAL allows facts to have variables within them. Thus, it is possible to query append as follows: Query: ?-append ([1; 2; 3; 4; X]; [Y; Z]; AN S): and get the answer AN S = <ref> [1; 2; 3; 4; X; Y; Z] </ref> In this CORAL differs from Aditi, EKS-V1, LDL, Glue/NAIL! and Star-burst SQL, which restrict the facts in a database to be ground. The cost and benefits of non-ground facts is discussed in Section 5.10. 8.1.1.
Reference: 4. <author> I. Balbin, G. S. Port, K. Ramamohanarao, and K. Meenakshi. </author> <title> Efficient bottom-up computation of queries on stratified databases. </title> <journal> Journal of Logic Programming. </journal> <note> To Appear. </note>
Reference-contexts: CORAL allows facts to have variables within them. Thus, it is possible to query append as follows: Query: ?-append ([1; 2; 3; 4; X]; [Y; Z]; AN S): and get the answer AN S = <ref> [1; 2; 3; 4; X; Y; Z] </ref> In this CORAL differs from Aditi, EKS-V1, LDL, Glue/NAIL! and Star-burst SQL, which restrict the facts in a database to be ground. The cost and benefits of non-ground facts is discussed in Section 5.10. 8.1.1.
Reference: 5. <author> I. Balbin and K. Ramamohanarao. </author> <title> A generalization of the differential approach to recursive query evaluation. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(3), </volume> <month> September </month> <year> 1987. </year>
Reference-contexts: Consequently, Semi-naive iteration terminates if and only if S is finite. In this presentation we ignore the issue of how to ensure that only derivations that use a new fact are carried out. This is addressed in several papers (e.g. <ref> [6; 9; 5] </ref>). The problem becomes more complicated when it is desired to apply rules in a specified order in each iteration. This issue is discussed in [50; 79; 91]. The set GC is the set of generated consequences of the program.
Reference: 6. <author> Francois Bancilhon. </author> <title> Naive evaluation of recursively defined relations. </title> <editor> In Brodie and Mylopoulos, editors, </editor> <title> On Knowledge Base Management Systems | Integrating Database and AI Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Consequently, Semi-naive iteration terminates if and only if S is finite. In this presentation we ignore the issue of how to ensure that only derivations that use a new fact are carried out. This is addressed in several papers (e.g. <ref> [6; 9; 5] </ref>). The problem becomes more complicated when it is desired to apply rules in a specified order in each iteration. This issue is discussed in [50; 79; 91]. The set GC is the set of generated consequences of the program.
Reference: 7. <author> Francois Bancilhon, David Maier, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Cambridge, Mas-sachusetts, </address> <month> March </month> <year> 1986. </year>
Reference: 8. <author> Marianne Baudinet, Marc Niezette, and Pierre Wolper. </author> <title> On the representation of infinite temporal data and queries. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 280-290, </pages> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year>
Reference: 9. <author> R. Bayer. </author> <title> Query evaluation and recursion in deductive database systems. </title> <note> Unpublished Memorandum, </note> <year> 1985. </year>
Reference-contexts: Consequently, Semi-naive iteration terminates if and only if S is finite. In this presentation we ignore the issue of how to ensure that only derivations that use a new fact are carried out. This is addressed in several papers (e.g. <ref> [6; 9; 5] </ref>). The problem becomes more complicated when it is desired to apply rules in a specified order in each iteration. This issue is discussed in [50; 79; 91]. The set GC is the set of generated consequences of the program.
Reference: 10. <author> C. Beeri, R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Valid computations and the Magic implementation of stratified programs. </title> <type> Manuscript, </type> <month> September 91. </month>
Reference: 11. <author> Catriel Beeri, Shamim Naqvi, Raghu Ramakrishnan, Oded Shmueli, and Shalom Tsur. </author> <title> Sets and negation in a logic database language. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 21-37, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: Set Grouping and Aggregation The group-by construct is used in SQL to partition a relation based on the values of some of the attributes of the relation. A variant of this construct is used in LDL <ref> [11; 60] </ref> to create nested sets within facts. We use the syntax of LDL in our discussion; however, the semantics we use is from the CORAL [77] system, and is a minor variant of the LDL semantics.
Reference: 12. <author> Catriel Beeri, Shamim Naqvi, Oded Shmueli, and Shalom Tsur. </author> <title> Set constructors in a logic database language. </title> <journal> The Journal of Logic Programming, </journal> <pages> pages 181-232, </pages> <year> 1991. </year>
Reference-contexts: When programs allow the creation of sets (and nested structures that include sets) the domain (or universe) of discourse has to be extended beyond the Herbrand universe that is standard in logic programming. Beeri et al. <ref> [12] </ref> describe such an extended Herbrand universe. CORAL provides several standard operations on sets and multisets as built-in predicates. These include member, union, intersection, difference, multisetunion, cardinality, subset, and set.
Reference: 13. <author> Catriel Beeri and Raghu Ramakrishnan. </author> <title> On the power of Magic. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: Subsection 3.1 describes the initial rewriting, while Subsection 3.2 investigates the computation of the fixpoint of the rewritten program. Both these steps can be refined further; this is discussed in later sections. 3.1. The Magic Templates Rewriting Algorithm As described in <ref> [13; 74] </ref>, the initial rewriting of a program and query is guided by a choice of sideways information passing strategies, or sips. For each rule, the associated sip determines the order in which the body literals are evaluated. <p> The supplementary version of the rewriting algorithm essentially identifies these common sub-expressions and stores them (with some optimizations that allow us to delete some columns from these intermediate, or supplementary, relations). We refer the reader to <ref> [13] </ref> for details. Magic Templates is often presented along with an adornment rewriting that annotates predicates with a string composed of characters `f' and `b', with one character for each argument. <p> In contrast, N additionally generates in each iteration all the facts that it generated in previous iterations. 2 3.3. Related Work The Alexander method was proposed independently of the Magic Sets approach in [84]. It is essentially the supplementary variant of the Magic Templates method, described in <ref> [13] </ref>. Seki has generalized the method to deal with non-ground facts and function symbols, and has called the generalized version Alexander Templates [92]. The Alexander methods always use a single left-to-right sip for each rule, for all possible goals.
Reference: 14. <author> R. S. Boyer and J. S. Moore. </author> <title> The sharing of structure in theorem-proving programs. </title> <booktitle> Computational Logic, </booktitle> <pages> pages 101-116, </pages> <year> 1972. </year>
Reference-contexts: If the query uses non-ground lists, and the program is evaluated without any special optimizations for non-ground terms, the evaluation takes O (n 2 ) time. The structure sharing scheme of Boyer and Moore <ref> [14] </ref> addresses the first three problems. The idea is to maintain binding environments with terms, and note variable bindings there; this also makes sharing subterms easier. A somewhat complicated naming scheme helps rename all variables in a term in constant time.
Reference: 15. <author> F. Bry, H. Decker, and R. Manthey. </author> <title> A uniform approach to constraint satisfaction and constraint satisfiability in deductive databases. </title> <booktitle> In Procs. International Conference on Extending Database Technology, </booktitle> <month> February </month> <year> 1988. </year>
Reference-contexts: note that some related evaluation techniques (e.g., Vieille's QSQR and QoSaQ [109; 110; 111], parallel evaluation techniques (e.g., work by Gonzalez-Rubio, Bradier and Rohmer [35], Ganguly, Silberschatz and Tsur [32], Cohen and Wolfson [24], and others, e.g. [29; 75; 105; 113]), work on integrity constraints (e.g., Bry, Decker and Manthey <ref> [15] </ref>, Vieille et al. [107] and others), work on production rule systems (e.g., Forgy [30], Sellis, Lin and Raschid [93], Widom et al. [112], and others, and systems such as OPS 5), work on intelligent query answering (e.g. [55; 22]) etc. are not discussed in this tutorial presentation due to lack
Reference: 16. <author> Francois Bry. </author> <title> Query evaluation in recursive databases: Bottom-up and top-down reconciled. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5 </volume> <pages> 289-312, </pages> <year> 1990. </year>
Reference-contexts: Seki [92] presents a direct comparison between the set of facts computed using Alexander Templates rewriting, and using SLD-AL resolution. Bry <ref> [16] </ref> shows that several top-down and bottom-up evaluation techniques can be viewed as specializations of a technique called Backward Fixpoint Procedure. Thus the least fixpoints of all these techniques have the same set of facts.
Reference: 17. <author> U. S. Chakravarthy, J. Grant, and J. Minker. </author> <title> Logic-based approach to semantic query optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(2) </volume> <pages> 162-207, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: For lack of space we do not cover some approaches to query optimization such as the semantic query optimization techniques proposed by Minker, King and others (see e.g. <ref> [49; 17] </ref>). 5.1. Predicate Factoring The basic idea behind predicate factoring is to replace a predicate by two predicates of strictly smaller arity. This can result in significant speedups, as the example in this section illustrates.
Reference: 18. <author> Ashok K. Chandra and David Harel. </author> <title> Horn clause queries and generalizations. </title> <journal> J. Logic Programming, </journal> <volume> 2(1) </volume> <pages> 1-15, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: The meaning of a program with negation is usually given by some "intended" model ([18; 3; 72; 71; 34; 85; 73; 104], among others). One important class of negation that has been extensively studied is stratified negation <ref> [18; 3] </ref>. Intuitively, a program is stratified if there is no recursion through negation. Programs in this class have an intuitive semantics and can also be efficiently evaluated. The following example describes a stratified program. EXAMPLE 6.1.
Reference: 19. <author> Weidong Chen, Michael Kifer, and Davis S. Warren. Hilog: </author> <title> A first-order semantics for higher-order logic programming constructs. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 1090-1114, </pages> <year> 1989. </year>
Reference-contexts: NAIL! [99; 54; 53] was another early deductive database system. The current version is compiled into a set-oriented procedural language called Glue [70]. NAIL! provides higher order syntactic features, using the semantics of Hilog <ref> [19] </ref>. Glue/NAIL! is currently implemented on top of Prolog, and is main-memory oriented. EKS-V1 [108] is a deductive database system that combines features of disk-oriented and in-memory databases. It is implemented on top of the MEGALOG logic programming system which supports access to secondary storage.
Reference: 20. <author> D. Chimenti, R. Gamboa, and R. Krishnamurthy. </author> <title> Towards an open architecture for LDL. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 195-204, </pages> <year> 1989. </year>
Reference-contexts: Again, this mimics the top-down evaluation, and no irrelevant facts are computed. 2 7. Deductive Database System Implementations There have been a number of implementations of deductive databases. In this section we briefly discuss some of them. One of the early implementations was LDL <ref> [60; 20; 21] </ref>. LDL is a main-memory database system implemented at MCC Austin. It extends the declarative semantics of Horn clauses by allowing set grouping and aggregate operations. The treatment of sets allows set-terms to be specified in the body of rules; set-matching is used to support this feature.
Reference: 21. <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference-contexts: Again, this mimics the top-down evaluation, and no irrelevant facts are computed. 2 7. Deductive Database System Implementations There have been a number of implementations of deductive databases. In this section we briefly discuss some of them. One of the early implementations was LDL <ref> [60; 20; 21] </ref>. LDL is a main-memory database system implemented at MCC Austin. It extends the declarative semantics of Horn clauses by allowing set grouping and aggregate operations. The treatment of sets allows set-terms to be specified in the body of rules; set-matching is used to support this feature.
Reference: 22. <author> L. Cholvy and R. Demelombe. </author> <title> Querying a rule base. </title> <booktitle> In Procs. 1st International 34 RAGHU RAMAKRISHNAN, </booktitle> <editor> DIVESH SRIVASTAVA AND S. </editor> <booktitle> SUDARSHAN Conference on Expert Database Systems, </booktitle> <pages> pages 365-371, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: 75; 105; 113]), work on integrity constraints (e.g., Bry, Decker and Manthey [15], Vieille et al. [107] and others), work on production rule systems (e.g., Forgy [30], Sellis, Lin and Raschid [93], Widom et al. [112], and others, and systems such as OPS 5), work on intelligent query answering (e.g. <ref> [55; 22] </ref>) etc. are not discussed in this tutorial presentation due to lack of space. Our coverage attempts to present one coherent set of results that are indicative of the field, rather than a survey, and is doubtless influenced by our personal perspectives. 2.
Reference: 23. <author> Jan Chomicki. </author> <title> Polynomial time query processing in temporal deductive databases. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 379-391, </pages> <address> Nashville, Tennessee, </address> <month> April </month> <year> 1990. </year>
Reference: 24. <author> S.R. Cohen and O. Wolfson. </author> <title> Why a single parallelization strategy is not enough in knowledge bases. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 200-216, </pages> <address> Philadelphia, Pennsylvania, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: We note that some related evaluation techniques (e.g., Vieille's QSQR and QoSaQ [109; 110; 111], parallel evaluation techniques (e.g., work by Gonzalez-Rubio, Bradier and Rohmer [35], Ganguly, Silberschatz and Tsur [32], Cohen and Wolfson <ref> [24] </ref>, and others, e.g. [29; 75; 105; 113]), work on integrity constraints (e.g., Bry, Decker and Manthey [15], Vieille et al. [107] and others), work on production rule systems (e.g., Forgy [30], Sellis, Lin and Raschid [93], Widom et al. [112], and others, and systems such as OPS 5), work on
Reference: 25. <author> M. P. Consens and A. O. Mendelzon. </author> <title> Low complexity aggregation in Graphlog and Datalog. </title> <booktitle> In Procs. International Symposium on Database Theory, </booktitle> <address> Paris, </address> <year> 1990. </year>
Reference-contexts: Extensions of the well-founded and stable models to deal with aggregates are considered in [44]. Monotonic programs, where a derivation using an incomplete set does not affect the set of facts computed, are discussed in <ref> [25; 57] </ref>. In certain contexts, an incomplete set may be used to generate facts that would not be generated using a complete set, without affecting the final answer to some queries on a program.
Reference: 26. <author> Stavros S. Cosmadakis, Haim Gaifman, Paris Kanellakis, and Moshe Y. Vardi. </author> <title> Decidable optimization problems for database logic programs. </title> <booktitle> In Proceedings of the Twentieth Symposium on the Theory of Computation, </booktitle> <pages> pages 477-490, </pages> <address> Chicago, Illi-nois, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: A rich classification of sets of programs for which detecting boundedness is decidable or undecidable has been developed in the literature; see, for example, <ref> [26; 38; 31; 62; 67; 106] </ref>. A related problem is to identify literals and rules that are redundant, i.e., that do not change the set of answers for any input database. For more details about detecting and eliminating redundancy from recursive Datalog programs, see [68]. 5.9.
Reference: 27. <author> I. F. Cruz and T. S. Norvell. </author> <title> Aggregative closure: An extension of transitive closure. </title> <booktitle> In Proc. IEEE 5th Int'l Conf. Data Engineering, </booktitle> <pages> pages 384-389, </pages> <year> 1989. </year>
Reference-contexts: One such context is when subsumption of facts is defined in such a way that facts created using incomplete sets will be found to be subsumed and will be discarded. Ross and Sagiv [87] examine such classes of programs. Cruz and Norvell <ref> [27] </ref> examine the use of such forms of aggregation in the context of transitive closure. Ganguly, Greco and Zaniolo [33] examine how to evaluate a class of programs that are monotonic in a sense different from that used in [57].
Reference: 28. <author> Suzanne W. Dietrich and David S. Warren. </author> <title> Extension tables: Memo relations in logic programming. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <pages> pages 264-272, </pages> <year> 1987. </year>
Reference-contexts: However, there are two important differences: 1) whenever possible, goals and facts are propagated set-at-a-time, and 2) all generated goals and facts are memoed. If a newly generated goal is already memoed, this is recognized by duplicate elimination. Dietrich and Warren have proposed a method called Extension Tables <ref> [28] </ref>. This method is very similar to QSQ, but performs computation tuple at a time. Finally, Kifer and Lozinskii have proposed a method called Filtering, which is based on constructing a rule-goal graph [47; 48]. <p> One example of a powerful optimization made possible by the declarative semantics is factoring, discussed in Section 5. There are a number of top-down evaluation techniques for logic programs such as Prolog, the Query-Subquery (QSQ) approach and its extensions [109; 111], and Extension Tables <ref> [28] </ref>. SLD-AL resolution is a theoretical model of the execution of top-down evaluation techniques that perform memoization of facts. Memoing top-down evaluations are similar to the bottom-up approach with respect to advantages (1), (2), and to some extent (3) above.
Reference: 29. <author> G. Dong. </author> <title> On distributed processing of Datalog queries by decomposing databases. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 26-35, </pages> <address> Portland, Oregon, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: We note that some related evaluation techniques (e.g., Vieille's QSQR and QoSaQ [109; 110; 111], parallel evaluation techniques (e.g., work by Gonzalez-Rubio, Bradier and Rohmer [35], Ganguly, Silberschatz and Tsur [32], Cohen and Wolfson [24], and others, e.g. <ref> [29; 75; 105; 113] </ref>), work on integrity constraints (e.g., Bry, Decker and Manthey [15], Vieille et al. [107] and others), work on production rule systems (e.g., Forgy [30], Sellis, Lin and Raschid [93], Widom et al. [112], and others, and systems such as OPS 5), work on intelligent query answering (e.g.
Reference: 30. <author> C. Forgy. </author> <title> Rete: A fast algorithm for the many pattern/many object pattern matching problem. </title> <journal> Artificial Intelligence, </journal> <volume> 19(1) </volume> <pages> 17-37, </pages> <year> 1982. </year>
Reference-contexts: parallel evaluation techniques (e.g., work by Gonzalez-Rubio, Bradier and Rohmer [35], Ganguly, Silberschatz and Tsur [32], Cohen and Wolfson [24], and others, e.g. [29; 75; 105; 113]), work on integrity constraints (e.g., Bry, Decker and Manthey [15], Vieille et al. [107] and others), work on production rule systems (e.g., Forgy <ref> [30] </ref>, Sellis, Lin and Raschid [93], Widom et al. [112], and others, and systems such as OPS 5), work on intelligent query answering (e.g. [55; 22]) etc. are not discussed in this tutorial presentation due to lack of space.
Reference: 31. <author> Haim Gaifman, Harry Mairson, Yehoshua Sagiv, and Moshe Y. Vardi. </author> <title> Undecidable optimization problems for database logic programs. </title> <booktitle> In Proceedings of the Second IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 106-115, </pages> <address> Ithaca, New York, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: A rich classification of sets of programs for which detecting boundedness is decidable or undecidable has been developed in the literature; see, for example, <ref> [26; 38; 31; 62; 67; 106] </ref>. A related problem is to identify literals and rules that are redundant, i.e., that do not change the set of answers for any input database. For more details about detecting and eliminating redundancy from recursive Datalog programs, see [68]. 5.9.
Reference: 32. <author> S. Ganguly, A. Silberschatz, and S. Tsur. </author> <title> A framework for the parallel processing of Datalog queries. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <address> Atlantic City, New Jersey, </address> <month> May </month> <year> 1990. </year> <note> To appear. </note>
Reference-contexts: We note that some related evaluation techniques (e.g., Vieille's QSQR and QoSaQ [109; 110; 111], parallel evaluation techniques (e.g., work by Gonzalez-Rubio, Bradier and Rohmer [35], Ganguly, Silberschatz and Tsur <ref> [32] </ref>, Cohen and Wolfson [24], and others, e.g. [29; 75; 105; 113]), work on integrity constraints (e.g., Bry, Decker and Manthey [15], Vieille et al. [107] and others), work on production rule systems (e.g., Forgy [30], Sellis, Lin and Raschid [93], Widom et al. [112], and others, and systems such as
Reference: 33. <author> Sumit Ganguly, Sergio Greco, and Carlo Zaniolo. </author> <title> Minimum and maximum predicates in logic programming. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference-contexts: Ross and Sagiv [87] examine such classes of programs. Cruz and Norvell [27] examine the use of such forms of aggregation in the context of transitive closure. Ganguly, Greco and Zaniolo <ref> [33] </ref> examine how to evaluate a class of programs that are monotonic in a sense different from that used in [57]. Ganguly et al. [33] and Sudarshan and Ramakrishnan [96] examine rewrite optimizations of programs that use aggregation, and the rewriting can result in unstratified programs. <p> Cruz and Norvell [27] examine the use of such forms of aggregation in the context of transitive closure. Ganguly, Greco and Zaniolo <ref> [33] </ref> examine how to evaluate a class of programs that are monotonic in a sense different from that used in [57]. Ganguly et al. [33] and Sudarshan and Ramakrishnan [96] examine rewrite optimizations of programs that use aggregation, and the rewriting can result in unstratified programs. The following program for computing the shortest path length 22 RAGHU RAMAKRISHNAN, DIVESH SRIVASTAVA AND S.
Reference: 34. <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <year> 1988. </year>
Reference: 35. <author> R Gonzalez-Rubio, J. Rohmer, and A. Bradier. </author> <title> An overview of DDC: Delta Driven Computer. </title> <booktitle> In Parallel Architectures and Languages Europe, Volume 1: Parallel Architectures, Lecture Notes in Computer Science, </booktitle> <volume> No. 258, </volume> <pages> pages 414-433, </pages> <year> 1987. </year>
Reference-contexts: We describe some systems based upon bottom-up evaluation in Section 7, and discuss one of them (CORAL) in more detail in Section 8. We note that some related evaluation techniques (e.g., Vieille's QSQR and QoSaQ [109; 110; 111], parallel evaluation techniques (e.g., work by Gonzalez-Rubio, Bradier and Rohmer <ref> [35] </ref>, Ganguly, Silberschatz and Tsur [32], Cohen and Wolfson [24], and others, e.g. [29; 75; 105; 113]), work on integrity constraints (e.g., Bry, Decker and Manthey [15], Vieille et al. [107] and others), work on production rule systems (e.g., Forgy [30], Sellis, Lin and Raschid [93], Widom et al. [112], and
Reference: 36. <author> E. Goto. </author> <title> Monocopy and associative algorithms in an extended lisp. </title> <type> Technical Report 74-03, </type> <institution> Information Science Laboratory, Univ. of Tokyo, </institution> <address> Tokyo, Japan, </address> <month> May </month> <year> 1974. </year>
Reference-contexts: structure sharing becomes more difficult. (3) If variables in a large term get instantiated during the inference, creation of the head fact is made more complicated. (4) Unification of large non-ground terms using currently known techniques is inefficient, especially compared to the cost of unification for ground terms using hash-consing <ref> [36; 90] </ref>. (5) Indexing of facts containing variables using currently known techniques is inefficient, especially compared to the cost of indexing ground facts using, say, hash tables. <p> It uses a variety of optimization techniques including program transformations such as Magic Templates ([13; 74]), optimizations of bottom-up evaluation such as Semi-naive evaluation, rule and predicate orderings, efficient unification techniques such as hash-consing <ref> [36; 90] </ref> and sharing of structure for ground terms, and efficient indexing techniques. Currently, evaluation is completely in-memory, although we plan to implement disk-resident relations in future versions of CORAL. More optimization techniques will be incorporated in future versions of CORAL. Modules are the unit of compilation in CORAL.
Reference: 37. <author> A. Richard Helm. </author> <title> Detecting and eliminating redundant derivations in deductive database systems. </title> <type> Technical Report RC 14244 (#63767), </type> <institution> IBM Thomas Watson Research Center, </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: Algebraic Properties of Programs The fixpoint evaluation of a logic program can be refined by taking certain algebraic properties of the program into consideration. Such refinements, and techniques for detecting when they are applicable, have been investigated by several researchers <ref> [37; 39; 51; 61; 78] </ref>. Ioannidis presents an algebraic formulation of Datalog programs that is particularly suited to reasoning about such properties of programs [39]. The following idea is illustrative of this class of optimizations. EXAMPLE 5.6. We begin with an example that illustrates commutativity of rules.
Reference: 38. <author> Yannis E. Ioannidis. </author> <title> Bounded recursion in deductive databases. </title> <journal> Algorithmica, </journal> <volume> 1(4) </volume> <pages> 361-385, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: A rich classification of sets of programs for which detecting boundedness is decidable or undecidable has been developed in the literature; see, for example, <ref> [26; 38; 31; 62; 67; 106] </ref>. A related problem is to identify literals and rules that are redundant, i.e., that do not change the set of answers for any input database. For more details about detecting and eliminating redundancy from recursive Datalog programs, see [68]. 5.9.
Reference: 39. <author> Yannis E. Ioannidis and Eugene Wong. </author> <title> Towards an algebraic theory of recursion. </title> <type> Technical Report 801, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, </institution> <month> October </month> <year> 1988. </year>
Reference-contexts: Maher and Ramakrishnan study this issue in detail in [52], and provide sufficient conditions to detect if a program will not compute duplicate facts. 5.7. Linearizing Programs An interesting class of program transformations has recently been explored by a number of researchers <ref> [39; 114; 89; 78] </ref>. The objective is to transform a program that contains non-linear rules into an equivalent one that contains only linear rules; this may make some of the other transformations surveyed in this paper applicable, or permit simplifications in the implementation of the fixpoint evaluation phase. <p> Algebraic Properties of Programs The fixpoint evaluation of a logic program can be refined by taking certain algebraic properties of the program into consideration. Such refinements, and techniques for detecting when they are applicable, have been investigated by several researchers <ref> [37; 39; 51; 61; 78] </ref>. Ioannidis presents an algebraic formulation of Datalog programs that is particularly suited to reasoning about such properties of programs [39]. The following idea is illustrative of this class of optimizations. EXAMPLE 5.6. We begin with an example that illustrates commutativity of rules. <p> Such refinements, and techniques for detecting when they are applicable, have been investigated by several researchers [37; 39; 51; 61; 78]. Ioannidis presents an algebraic formulation of Datalog programs that is particularly suited to reasoning about such properties of programs <ref> [39] </ref>. The following idea is illustrative of this class of optimizations. EXAMPLE 5.6. We begin with an example that illustrates commutativity of rules.
Reference: 40. <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the 14th ACM POPL, </booktitle> <pages> pages 111-119, </pages> <address> Munich, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: Constraint query languages provide a model for reasoning about (potentially) infinite sets of ground facts using finite representations. This is because a constraint fact p (X; C) is a finite representation of the (potentially) infinite set of ground facts that satisfy the conjunction of constraints C. Jaffar and Lassez <ref> [40] </ref> gave a model theory, a fixpoint theory, and a top-down operational semantics for such programs. Kanellakis et al. [41] gave a bottom-up operational semantics for some classes of constraint query languages. EXAMPLE 6.3.
Reference: 41. <author> Paris C. Kanellakis, Gabriel M. Kuper, and Peter Z. Revesz. </author> <title> Constraint query languages. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 299-313, </pages> <address> Nashville, Tennessee, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Jaffar and Lassez [40] gave a model theory, a fixpoint theory, and a top-down operational semantics for such programs. Kanellakis et al. <ref> [41] </ref> gave a bottom-up operational semantics for some classes of constraint query languages. EXAMPLE 6.3.
Reference: 42. <author> D. Kemp, K. Ramamohanarao, and Z. Somogyi. Right-, </author> <title> left-, and multi-linear rule EFFICIENT BOTTOM-UP EVALUATION OF LOGIC PROGRAMS 35 transformations that maintain context information. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <pages> pages 380-391, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Kemp et al. <ref> [42] </ref> generalized this transformation so that it can be applied even if a subprogram satisfies the required conditions; this allows for sharing of subcomputation across multiple calls to a factored predicate. EFFICIENT BOTTOM-UP EVALUATION OF LOGIC PROGRAMS 13 5.2.
Reference: 43. <author> David Kemp, Divesh Srivastava, and Peter Stuckey. </author> <title> Magic sets and bottom-up evaluation of well-founded models. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <pages> pages 337-351, </pages> <address> San Diego, CA, U.S.A., </address> <month> October </month> <year> 1991. </year>
Reference-contexts: However, it is modularly stratified. Locally and modularly stratified programs can be evaluated using the techniques described in <ref> [85; 43] </ref>. The evaluation of the Magic Templates transformation of this class of programs has also been considered in the literature ([85; 43; 80]). 2 6.2.
Reference: 44. <author> David Kemp and Peter Stuckey. </author> <title> Semantics of logic programs with aggregates. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <pages> pages 387-401, </pages> <address> San Diego, CA, U.S.A., </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Several of the approaches used for negation carry over to set grouping. There are approaches based on weaker forms of stratification such as group stratification and magical stratification [57], or modular stratification [85]. Extensions of the well-founded and stable models to deal with aggregates are considered in <ref> [44] </ref>. Monotonic programs, where a derivation using an incomplete set does not affect the set of facts computed, are discussed in [25; 57].
Reference: 45. <author> J.M. Kerisit and J.M. Pugin. </author> <title> Efficient query answering on stratified databases. </title> <booktitle> In Proc. of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 719-725, </pages> <address> Tokyo, Japan, </address> <month> November </month> <year> 1988. </year>
Reference: 46. <author> Michael Kifer and Ai Li. </author> <title> On the semantics of rule based expert systems with uncertainty. </title> <booktitle> In Proceedings of 2nd ICDT, </booktitle> <address> Bruges, Belgium, </address> <year> 1988. </year>
Reference-contexts: This provides a model for rule-based reasoning in expert systems, where the usual logical reasoning in terms of the truth values true and false is insufficient. We describe the restricted case of K-standard sequence logics ([94; 102]), and refer the interested reader to Kifer and Li <ref> [46] </ref> for more general types of quantitative logic programs. Quantitative logic programs based on K-standard sequence logics were considered by Van Emden [102], who gave a model theory, a fixpoint theory, and a top-down operational semantics for such programs.
Reference: 47. <author> Michael Kifer and Eliezer L. Lozinskii. </author> <title> A framework for an efficient implementation of deductive databases. </title> <booktitle> In Proceedings of the Advanced Database Symposium, </booktitle> <address> Tokyo, Japan, </address> <year> 1986. </year>
Reference-contexts: Dietrich and Warren have proposed a method called Extension Tables [28]. This method is very similar to QSQ, but performs computation tuple at a time. Finally, Kifer and Lozinskii have proposed a method called Filtering, which is based on constructing a rule-goal graph <ref> [47; 48] </ref>. There is a node in the graph for each predicate, and for each rule, and arcs from predicate nodes to each rule node in whose body it appears, and from rule nodes to the predicates that they define. <p> is unary. 2 The previous example illustrated how the adornment algorithm can sometimes push the projection through recursion and thereby reduce the arity of recursive predicates. (The observation that pushing projections could reduce arity of recursive predicates was first made by Aho and Ullman [1], and later Kifer and Lozinskii <ref> [47] </ref> and Apers et al. [2]. The adornment algorithm in [76] generalizes their results.) The acute reader will have observed that more can be achieved | the recursive rule may be deleted entirely.
Reference: 48. <author> Michael Kifer and Eliezer L. Lozinskii. SYGRAF: </author> <title> Implementing logic programs in a database style. </title> <journal> IEEE Transactions on Software Engineering, </journal> <year> 1988. </year>
Reference-contexts: Dietrich and Warren have proposed a method called Extension Tables [28]. This method is very similar to QSQ, but performs computation tuple at a time. Finally, Kifer and Lozinskii have proposed a method called Filtering, which is based on constructing a rule-goal graph <ref> [47; 48] </ref>. There is a node in the graph for each predicate, and for each rule, and arcs from predicate nodes to each rule node in whose body it appears, and from rule nodes to the predicates that they define.
Reference: 49. <author> J. J. King. QUIST: </author> <title> A system for semantic query optimization in relational databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 510-517, </pages> <month> August </month> <year> 1981. </year>
Reference-contexts: For lack of space we do not cover some approaches to query optimization such as the semantic query optimization techniques proposed by Minker, King and others (see e.g. <ref> [49; 17] </ref>). 5.1. Predicate Factoring The basic idea behind predicate factoring is to replace a predicate by two predicates of strictly smaller arity. This can result in significant speedups, as the example in this section illustrates.
Reference: 50. <author> J. Kuittinen, O. Nurmi, S. Sippu, and E. Soisalon-Soininen. </author> <title> Efficient implementation of loops in bottom-up evaluation of logic queries. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: This is addressed in several papers (e.g. [6; 9; 5]). The problem becomes more complicated when it is desired to apply rules in a specified order in each iteration. This issue is discussed in <ref> [50; 79; 91] </ref>. The set GC is the set of generated consequences of the program.
Reference: 51. <author> Michael J. Maher. </author> <title> Semantics of Logic Programs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <address> Melbourne, Australia, </address> <year> 1985. </year>
Reference-contexts: Algebraic Properties of Programs The fixpoint evaluation of a logic program can be refined by taking certain algebraic properties of the program into consideration. Such refinements, and techniques for detecting when they are applicable, have been investigated by several researchers <ref> [37; 39; 51; 61; 78] </ref>. Ioannidis presents an algebraic formulation of Datalog programs that is particularly suited to reasoning about such properties of programs [39]. The following idea is illustrative of this class of optimizations. EXAMPLE 5.6. We begin with an example that illustrates commutativity of rules.
Reference: 52. <author> Michael J. Maher and Raghu Ramakrishnan. </author> <title> Deja vu in fixpoints of logic programs. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <address> Cleveland, Ohio, </address> <year> 1990. </year>
Reference-contexts: Derivations made in one iteration are not repeated in subsequent iterations since in each iteration, only rule instantiations that utilize at least one new fact (i.e., one generated for the first time in the previous iteration) are considered. We follow the presentation in <ref> [52] </ref> in the rest of this section, with some simplifications. Let us first define a binary operator W P , whose role is similar to that of the well-known T P operator of [103]. <p> For details, see [82]. EFFICIENT BOTTOM-UP EVALUATION OF LOGIC PROGRAMS 7 The multiplicity of an element h [] is determined by the number of distinct rule instantiations of which it is the head literal. A more rigorous definition that formally accounts for the multiplicity is given in <ref> [52] </ref>; we have chosen to use an informal presentation for ease of exposition. Intuitively, W P only allows deductions from the set of facts X that use the "new" facts Y , and "counts" a fact as often as it is derived (using distinct rule instantia-tions). <p> The following result shows that the above iterative methods are consistent with the usual least Herbrand model semantics of [103]; here implicitly D is the domain for the program in question. We denote the least Herbrand model of the program by M. PROPOSITION 3.1. <ref> [52] </ref> The set of generated consequences GC of a program computed using Semi-naive Iteration (either SN S or SN I ) is such that ground (GC) = M. 2 8 RAGHU RAMAKRISHNAN, DIVESH SRIVASTAVA AND S. <p> This check is important for termination of many programs. However, for some programs such as the fibonacci program above, with Semi-naive bottom-up evaluation, duplicate facts are never generated. Hence duplicate elimination need not be done for such programs. Maher and Ramakrishnan study this issue in detail in <ref> [52] </ref>, and provide sufficient conditions to detect if a program will not compute duplicate facts. 5.7. Linearizing Programs An interesting class of program transformations has recently been explored by a number of researchers [39; 114; 89; 78].
Reference: 53. <author> Katherine Morris, Jeffrey F. Naughton, Yatin Saraiya, Jeffrey D. Ullman, and Allen Van Gelder. </author> <title> YAWN! (Yet Another Window on NAIL!). </title> <booktitle> Database Engineering, </booktitle> <month> December </month> <year> 1987. </year>
Reference-contexts: Rather, their semantics is defined in a constructive fashion [59]. LDL also provides some control primitives such as choice, provides a module feature for organizing code, and provides primitives for integration with C. NAIL! <ref> [99; 54; 53] </ref> was another early deductive database system. The current version is compiled into a set-oriented procedural language called Glue [70]. NAIL! provides higher order syntactic features, using the semantics of Hilog [19]. Glue/NAIL! is currently implemented on top of Prolog, and is main-memory oriented.
Reference: 54. <author> Katherine Morris, Jeffrey D. Ullman, and Allen Van Gelder. </author> <title> Design overview of the NAIL! system. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <year> 1986. </year>
Reference-contexts: Rather, their semantics is defined in a constructive fashion [59]. LDL also provides some control primitives such as choice, provides a module feature for organizing code, and provides primitives for integration with C. NAIL! <ref> [99; 54; 53] </ref> was another early deductive database system. The current version is compiled into a set-oriented procedural language called Glue [70]. NAIL! provides higher order syntactic features, using the semantics of Hilog [19]. Glue/NAIL! is currently implemented on top of Prolog, and is main-memory oriented.
Reference: 55. <author> A. Motro. SEAVE: </author> <title> The mechanism for verifying user presuppositions. </title> <journal> ACM TOIS, </journal> <volume> 4(4) </volume> <pages> 312-330, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: 75; 105; 113]), work on integrity constraints (e.g., Bry, Decker and Manthey [15], Vieille et al. [107] and others), work on production rule systems (e.g., Forgy [30], Sellis, Lin and Raschid [93], Widom et al. [112], and others, and systems such as OPS 5), work on intelligent query answering (e.g. <ref> [55; 22] </ref>) etc. are not discussed in this tutorial presentation due to lack of space. Our coverage attempts to present one coherent set of results that are indicative of the field, rather than a survey, and is doubtless influenced by our personal perspectives. 2.
Reference: 56. <author> I. S. Mumick, S. Finkelstein, H. Pirahesh, and R. Ramakrishnan. </author> <title> Magic is relevant. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <address> Atlantic City, New Jersey, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: Although the Magic Templates idea was introduced to deal with recursion, it provides significant improvements for non-recursive queries as well. In [57; 58] it is shown that the technique can be extended to deal with SQL programs, including those containing features like group-by, aggregation and arithmetic conditions. In <ref> [56] </ref> a performance evaluation, carried out on a DB2 relational system, is presented, demonstrating that the technique performs comparably to standard database techniques, and is often significantly better. The Magic and Alexander methods are based on program transformations.
Reference: 57. <author> Inderpal S. Mumick, Hamid Pirahesh, and Raghu Ramakrishnan. </author> <title> Duplicates and aggregates in deductive databases. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: Although this results in some irrelevant computation, it may be possible to compute supersets more efficiently than the magic sets themselves [95]. Although the Magic Templates idea was introduced to deal with recursion, it provides significant improvements for non-recursive queries as well. In <ref> [57; 58] </ref> it is shown that the technique can be extended to deal with SQL programs, including those containing features like group-by, aggregation and arithmetic conditions. <p> There are several approaches to relaxing the assumption of stratification. Several of the approaches used for negation carry over to set grouping. There are approaches based on weaker forms of stratification such as group stratification and magical stratification <ref> [57] </ref>, or modular stratification [85]. Extensions of the well-founded and stable models to deal with aggregates are considered in [44]. Monotonic programs, where a derivation using an incomplete set does not affect the set of facts computed, are discussed in [25; 57]. <p> Extensions of the well-founded and stable models to deal with aggregates are considered in [44]. Monotonic programs, where a derivation using an incomplete set does not affect the set of facts computed, are discussed in <ref> [25; 57] </ref>. In certain contexts, an incomplete set may be used to generate facts that would not be generated using a complete set, without affecting the final answer to some queries on a program. <p> Cruz and Norvell [27] examine the use of such forms of aggregation in the context of transitive closure. Ganguly, Greco and Zaniolo [33] examine how to evaluate a class of programs that are monotonic in a sense different from that used in <ref> [57] </ref>. Ganguly et al. [33] and Sudarshan and Ramakrishnan [96] examine rewrite optimizations of programs that use aggregation, and the rewriting can result in unstratified programs. The following program for computing the shortest path length 22 RAGHU RAMAKRISHNAN, DIVESH SRIVASTAVA AND S. <p> All relational operations are performed with relations assumed to be disk resident, and join techniques such as sort-merge and hash-join are used, which means that Aditi is aimed at applications that are I/O intensive, but typically perform few iterations. Starburst SQL (see e.g. <ref> [57] </ref>) extends SQL with recursive view definitions. This provides greater expressive power to SQL users, while providing the I/O optimization facilities of SQL in a direct manner for recursive applications. CORAL [77] is a deductive database system developed by the authors, and is described in detail in a separate section.
Reference: 58. <author> Inderpal Singh Mumick, Sheldon J. Finkelstein, Hamid Pirahesh, and Raghu Ra-makrishnan. </author> <title> Magic conditions. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 314-330, </pages> <address> Nashville, Tennessee, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Although this results in some irrelevant computation, it may be possible to compute supersets more efficiently than the magic sets themselves [95]. Although the Magic Templates idea was introduced to deal with recursion, it provides significant improvements for non-recursive queries as well. In <ref> [57; 58] </ref> it is shown that the technique can be extended to deal with SQL programs, including those containing features like group-by, aggregation and arithmetic conditions.
Reference: 59. <author> S. Naqvi and R. Krishnamurthy. </author> <title> Database updates in logic programming. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1988. </year>
Reference-contexts: The treatment of sets allows set-terms to be specified in the body of rules; set-matching is used to support this feature. It also allows rules to perform updates, which means that such rules do not have the usual declarative semantics. Rather, their semantics is defined in a constructive fashion <ref> [59] </ref>. LDL also provides some control primitives such as choice, provides a module feature for organizing code, and provides primitives for integration with C. NAIL! [99; 54; 53] was another early deductive database system. The current version is compiled into a set-oriented procedural language called Glue [70].
Reference: 60. <author> Shamim Naqvi and Shalom Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <booktitle> Principles of Computer Science. </booktitle> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Set Grouping and Aggregation The group-by construct is used in SQL to partition a relation based on the values of some of the attributes of the relation. A variant of this construct is used in LDL <ref> [11; 60] </ref> to create nested sets within facts. We use the syntax of LDL in our discussion; however, the semantics we use is from the CORAL [77] system, and is a minor variant of the LDL semantics. <p> Again, this mimics the top-down evaluation, and no irrelevant facts are computed. 2 7. Deductive Database System Implementations There have been a number of implementations of deductive databases. In this section we briefly discuss some of them. One of the early implementations was LDL <ref> [60; 20; 21] </ref>. LDL is a main-memory database system implemented at MCC Austin. It extends the declarative semantics of Horn clauses by allowing set grouping and aggregate operations. The treatment of sets allows set-terms to be specified in the body of rules; set-matching is used to support this feature.
Reference: 61. <author> Jeffrey F. Naughton. </author> <title> Compiling separable recursions. </title> <booktitle> In Proceedings of the SIGMOD International Symposium on Management of Data, </booktitle> <pages> pages 312-319, </pages> <address> Chicago, Illinois, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: Algebraic Properties of Programs The fixpoint evaluation of a logic program can be refined by taking certain algebraic properties of the program into consideration. Such refinements, and techniques for detecting when they are applicable, have been investigated by several researchers <ref> [37; 39; 51; 61; 78] </ref>. Ioannidis presents an algebraic formulation of Datalog programs that is particularly suited to reasoning about such properties of programs [39]. The following idea is illustrative of this class of optimizations. EXAMPLE 5.6. We begin with an example that illustrates commutativity of rules.
Reference: 62. <author> Jeffrey F. Naughton. </author> <title> Data independent recursion in deductive databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 38(2) </volume> <pages> 259-289, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Note that here we are not asking when recursion can be replaced by iteration; rather, we are asking when a logic program containing recursive clauses has an equivalent finite logic program in which no clause is recursive. EXAMPLE 5.5. The following example is from <ref> [62] </ref>. buys (X; Y ) : likes (X; Y ): buys (X; Y ) : trendy (X); buys (Z; Y ): In English, a person X buys a product Y if either X likes Y , or X is trendy and a person Z has bought Y . <p> A rich classification of sets of programs for which detecting boundedness is decidable or undecidable has been developed in the literature; see, for example, <ref> [26; 38; 31; 62; 67; 106] </ref>. A related problem is to identify literals and rules that are redundant, i.e., that do not change the set of answers for any input database. For more details about detecting and eliminating redundancy from recursive Datalog programs, see [68]. 5.9.
Reference: 63. <author> Jeffrey F. Naughton and Raghu Ramakrishnan. </author> <title> How to forget the past without 36 RAGHU RAMAKRISHNAN, </title> <editor> DIVESH SRIVASTAVA AND S. SUDARSHAN repeating it. </editor> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: SUDARSHAN all derivations using such facts have been made, and the facts will not be derived again. Such facts can then be discarded during the evaluation. This issue is studied in detail in <ref> [63; 98] </ref>, where several sufficient conditions for discarding facts are developed. 5.6. Duplicate Elimination In general, when a fact is derived in a bottom-up evaluation, duplicate checking needs to be done to see if the fact was derived earlier. If it was not, derivations can be made using the fact.
Reference: 64. <author> Jeffrey F. Naughton and Raghu Ramakrishnan. </author> <title> Bottom-up evaluation of logic programs. </title> <editor> In J-L. Lassez, editor, </editor> <booktitle> Computational Logic: Essays in Honor of Alan Robin-son. </booktitle> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The idea is to compute the fixpoint by propagating tuples along these arcs, and to restrict the computation by attaching "filters" to arcs. The reader is referred to <ref> [64] </ref> for a more detailed discussion of related work. 4. Top-Down Versus Bottom-Up In the past, bottom-up methods have not been seriously considered for the evaluation of logic programs because of a serious drawback: no techniques were known that avoided computing an unbounded number of irrelevant facts. <p> Systems based upon these methods are being developed, and offer rich support for rule-based applications. Acknowledgements This paper is based upon a tutorial to be presented at COMPEURO 92 by R. Ramakrishnan. It has borrowed some material from other papers, in particular <ref> [64] </ref>. This work was supported by a David and Lucile Packard Foundation Fellowship in Science and Engineering, a Presidential Young Investigator Award, with matching grants from Digital Equipment Corporation, Tandem and Xerox, and NSF grant IRI-9011563.
Reference: 65. <author> Jeffrey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Argument reduction through factoring. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Databases, </booktitle> <pages> pages 173-182, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: Our presentation is through the use of examples, and we do not describe sufficient conditions for the optimization to apply in general. We refer the reader to <ref> [65] </ref> for a detailed treatment. In essence, we seek to take advantage of the magic predicates to replace the original predicate in P mg by its projection onto its f argument positions. <p> That is, t bf (X; Y ) can be factored into bt (X) and f t (Y ) in the Magic program. Doing this and applying some simple syntactic optimizations, which are discussed in <ref> [65] </ref>, we finally obtain the following unary program: magic t bf (W ) : f t (W ): magic t bf (5): f t (Y ) : magic t bf (X); e (X; Y ): query (Y ) : f t (Y ): 2 Predicate factoring, as described above, requires the
Reference: 66. <author> Jeffrey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Efficient evaluation of right-, left-, and multi-linear rules. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 235-242, </pages> <address> Portland, Oregon, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: EXAMPLE 5.1. We begin with a familiar example, transitive closure. While efficient algorithms are known, the rewriting algorithms presented in <ref> [66] </ref> were the first to automatically derive unary programs for single-selection queries, for all three forms (left-linear, right-linear, non-linear) of the recursive rule. We achieve the same result here by first applying the Magic Templates transformation and then factoring the rewritten program.
Reference: 67. <author> Jeffrey F. Naughton and Yehoshua Sagiv. </author> <title> A decidable class of bounded recursions. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 227-236, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: A rich classification of sets of programs for which detecting boundedness is decidable or undecidable has been developed in the literature; see, for example, <ref> [26; 38; 31; 62; 67; 106] </ref>. A related problem is to identify literals and rules that are redundant, i.e., that do not change the set of answers for any input database. For more details about detecting and eliminating redundancy from recursive Datalog programs, see [68]. 5.9.
Reference: 68. <author> Jeffrey F. Naughton and Yehoshua Sagiv. </author> <title> Minimizing expansions of recursions. </title> <editor> In Hasan Ait-Kaci and Maurice Nivat, editors, </editor> <booktitle> Resolution of Equations in Algebraic Structures, </booktitle> <volume> volume 1, </volume> <pages> pages 321-349, </pages> <address> San Diego, California, 1989. </address> <publisher> Academic Press, Inc. </publisher>
Reference-contexts: A related problem is to identify literals and rules that are redundant, i.e., that do not change the set of answers for any input database. For more details about detecting and eliminating redundancy from recursive Datalog programs, see <ref> [68] </ref>. 5.9. Algebraic Properties of Programs The fixpoint evaluation of a logic program can be refined by taking certain algebraic properties of the program into consideration. Such refinements, and techniques for detecting when they are applicable, have been investigated by several researchers [37; 39; 51; 61; 78].
Reference: 69. <author> F.C.N. Pereira and D.H.D. Warren. </author> <title> Parsing as deduction. </title> <booktitle> In Proceedings of the twenty-first Annual Meeting of the Association for Computational Linguistics, </booktitle> <year> 1983. </year>
Reference-contexts: The Magic and Alexander methods are based on program transformations. Other methods use a combination of top-down and bottom-up control EFFICIENT BOTTOM-UP EVALUATION OF LOGIC PROGRAMS 9 to propagate bindings. Pereira and Warren presented a memoing top-down evaluation procedure based on Earley deduction <ref> [69] </ref>. This evaluation procedure may be viewed as a top-down evaluation procedure that incorporates memoing. Vieille has proposed a method called QSQ [109; 110; 111] that can be viewed as follows. Goals are generated with a top-down invocation of rules, as in Prolog.
Reference: 70. <author> Geoffrey Phipps, Marcia A. Derr, and Kenneth A. Ross. </author> <title> Glue-NAIL!: A deductive database system. </title> <booktitle> In Proceedings of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 308-317, </pages> <year> 1991. </year>
Reference-contexts: LDL also provides some control primitives such as choice, provides a module feature for organizing code, and provides primitives for integration with C. NAIL! [99; 54; 53] was another early deductive database system. The current version is compiled into a set-oriented procedural language called Glue <ref> [70] </ref>. NAIL! provides higher order syntactic features, using the semantics of Hilog [19]. Glue/NAIL! is currently implemented on top of Prolog, and is main-memory oriented. EKS-V1 [108] is a deductive database system that combines features of disk-oriented and in-memory databases.
Reference: 71. <author> H. Przymusinska and T.C. Przymusinski. </author> <title> Weakly perfect model semantics for logic programs. </title> <booktitle> In Proceedings of the Fifth International Conference/Symposium on Logic Programming, </booktitle> <year> 1988. </year>
Reference: 72. <author> T.C. Przymusinski. </author> <title> On the declarative semantics of stratified deductive databases. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216, </pages> <year> 1988. </year>
Reference-contexts: SUDARSHAN A natural extension of stratified programs is the class of locally stratified programs <ref> [72] </ref>. Intuitively, a program P is locally stratified if the (propositional) program Gr (P ) obtained by taking all ground instances of all rules in P is stratified. Local stratification has been extended to modular stratification in [85].
Reference: 73. <author> T.C. Przymusinski. </author> <title> Extended stable semantics for normal and disjunctive programs. </title> <booktitle> In Seventh International Logic Programming Conference, </booktitle> <pages> pages 459-477, </pages> <year> 1990. </year>
Reference: 74. <author> Raghu Ramakrishnan. </author> <title> Magic Templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Subsection 3.1 describes the initial rewriting, while Subsection 3.2 investigates the computation of the fixpoint of the rewritten program. Both these steps can be refined further; this is discussed in later sections. 3.1. The Magic Templates Rewriting Algorithm As described in <ref> [13; 74] </ref>, the initial rewriting of a program and query is guided by a choice of sideways information passing strategies, or sips. For each rule, the associated sip determines the order in which the body literals are evaluated. <p> U ); sg (U; V ); down (V; Y ): magic sg (U; V ) : magic sg (X; Y ); up (X; U ): magic sg (john; Z): 2 We present some results that characterize the transformed program P mg with respect to the original program P , from <ref> [74] </ref>. The following theorem ensures soundness. THEOREM 3.1. [74] hP; Qi is equivalent to hP mg ; Qi with respect to the set of answers to the query. DEFINITION 3.2. Let us define the Magic Templates Evaluation Method as follows: 1. <p> Y ): magic sg (U; V ) : magic sg (X; Y ); up (X; U ): magic sg (john; Z): 2 We present some results that characterize the transformed program P mg with respect to the original program P , from <ref> [74] </ref>. The following theorem ensures soundness. THEOREM 3.1. [74] hP; Qi is equivalent to hP mg ; Qi with respect to the set of answers to the query. DEFINITION 3.2. Let us define the Magic Templates Evaluation Method as follows: 1. <p> A natural question is how bottom-up evaluation techniques compare with memoing as well as non-memoing top-down evaluation techniques. 10 RAGHU RAMAKRISHNAN, DIVESH SRIVASTAVA AND S. SUDARSHAN Initial comparisons were based on the number of facts derived by the different techniques. Thus, Ramakrishnan <ref> [74; 75] </ref> presents a class of evaluations and shows that within this class bottom-up evaluation of a program rewritten using Magic Templates computes an optimal number of facts. Seki [92] presents a direct comparison between the set of facts computed using Alexander Templates rewriting, and using SLD-AL resolution.
Reference: 75. <author> Raghu Ramakrishnan. </author> <title> Parallelism in logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, California, </address> <year> 1990. </year>
Reference-contexts: We note that some related evaluation techniques (e.g., Vieille's QSQR and QoSaQ [109; 110; 111], parallel evaluation techniques (e.g., work by Gonzalez-Rubio, Bradier and Rohmer [35], Ganguly, Silberschatz and Tsur [32], Cohen and Wolfson [24], and others, e.g. <ref> [29; 75; 105; 113] </ref>), work on integrity constraints (e.g., Bry, Decker and Manthey [15], Vieille et al. [107] and others), work on production rule systems (e.g., Forgy [30], Sellis, Lin and Raschid [93], Widom et al. [112], and others, and systems such as OPS 5), work on intelligent query answering (e.g. <p> A natural question is how bottom-up evaluation techniques compare with memoing as well as non-memoing top-down evaluation techniques. 10 RAGHU RAMAKRISHNAN, DIVESH SRIVASTAVA AND S. SUDARSHAN Initial comparisons were based on the number of facts derived by the different techniques. Thus, Ramakrishnan <ref> [74; 75] </ref> presents a class of evaluations and shows that within this class bottom-up evaluation of a program rewritten using Magic Templates computes an optimal number of facts. Seki [92] presents a direct comparison between the set of facts computed using Alexander Templates rewriting, and using SLD-AL resolution.
Reference: 76. <author> Raghu Ramakrishnan, Catriel Beeri, and Ravi Krishnamurthy. </author> <title> Optimizing existential Datalog queries. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 89-102, </pages> <address> Austin, Texas, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: Pushing selections is achieved through the use of the Magic Templates transformation; the introduction of recursion makes it necessary to compute auxiliary sets. Pushing projections has also been explored, and the gains can be significant. We will illustrate the idea through examples, and refer the reader to <ref> [76] </ref> for details. EXAMPLE 5.2. <p> Note that such queries are likely to arise during the course of query optimization. 2 An adornment that distinguishes don't-care argument positions (d) from the rest (needed or n) was used in <ref> [76] </ref> to push projections. 14 RAGHU RAMAKRISHNAN, DIVESH SRIVASTAVA AND S. SUDARSHAN EXAMPLE 5.3. <p> The adornment algorithm in <ref> [76] </ref> generalizes their results.) The acute reader will have observed that more can be achieved | the recursive rule may be deleted entirely. <p> The following program is obtained in the above example using the techniques of <ref> [76] </ref>: query (Y ) : t dn (Y ): 5.4. Counting Counting ([7; 88; 13]) is a refinement of the Magic Sets approach.
Reference: 77. <author> Raghu Ramakrishnan, Per Bothner, Divesh Srivastava, and S. Sudarshan. </author> <title> Coral: A database programming language. </title> <editor> In Jan Chomicki, editor, </editor> <booktitle> Proceedings of the NACLP `90 Workshop on Deductive Databases, </booktitle> <month> October </month> <year> 1990. </year> <note> Available as Report TR-CS-90-14, </note> <institution> Department of Computing and Information Sciences, Kansas State University. </institution>
Reference-contexts: A variant of this construct is used in LDL [11; 60] to create nested sets within facts. We use the syntax of LDL in our discussion; however, the semantics we use is from the CORAL <ref> [77] </ref> system, and is a minor variant of the LDL semantics. <p> Starburst SQL (see e.g. [57]) extends SQL with recursive view definitions. This provides greater expressive power to SQL users, while providing the I/O optimization facilities of SQL in a direct manner for recursive applications. CORAL <ref> [77] </ref> is a deductive database system developed by the authors, and is described in detail in a separate section. LDL, NAIL! and CORAL belong in one family of deductive database systems in that they are main-memory oriented.
Reference: 78. <author> Raghu Ramakrishnan, Yehoshua Sagiv, Jeffrey D. Ullman, and Moshe Vardi. </author> <title> Proof-tree transformation theorems and their applications. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <address> Philadelphia, Pennsylvania, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: Maher and Ramakrishnan study this issue in detail in [52], and provide sufficient conditions to detect if a program will not compute duplicate facts. 5.7. Linearizing Programs An interesting class of program transformations has recently been explored by a number of researchers <ref> [39; 114; 89; 78] </ref>. The objective is to transform a program that contains non-linear rules into an equivalent one that contains only linear rules; this may make some of the other transformations surveyed in this paper applicable, or permit simplifications in the implementation of the fixpoint evaluation phase. <p> Algebraic Properties of Programs The fixpoint evaluation of a logic program can be refined by taking certain algebraic properties of the program into consideration. Such refinements, and techniques for detecting when they are applicable, have been investigated by several researchers <ref> [37; 39; 51; 61; 78] </ref>. Ioannidis presents an algebraic formulation of Datalog programs that is particularly suited to reasoning about such properties of programs [39]. The following idea is illustrative of this class of optimizations. EXAMPLE 5.6. We begin with an example that illustrates commutativity of rules.
Reference: 79. <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Rule ordering in bottom-up fixpoint evaluation of logic programs. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: This is addressed in several papers (e.g. [6; 9; 5]). The problem becomes more complicated when it is desired to apply rules in a specified order in each iteration. This issue is discussed in <ref> [50; 79; 91] </ref>. The set GC is the set of generated consequences of the program.
Reference: 80. <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Controlling the search EFFICIENT BOTTOM-UP EVALUATION OF LOGIC PROGRAMS 37 in bottom-up evaluation. </title> <type> Manuscript, </type> <note> submitted for publication, </note> <year> 1991. </year>
Reference-contexts: Similarly, utilities for output of relations in tabular form are also provided. This provides some of the features of the AWK string manipulation language that is available on Unix systems. 30 RAGHU RAMAKRISHNAN, DIVESH SRIVASTAVA AND S. SUDARSHAN CORAL supports Ordered Search <ref> [80] </ref>, which is an evaluation mechanism that orders the use of generated subgoals in a program. Subgoals and answers to subgoals are generated asynchronously, as in the regular bottom-up evaluation of the magic program.
Reference: 81. <author> Raghu Ramakrishnan and S. Sudarshan. </author> <title> Top-Down vs. Bottom-Up Revisited. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <year> 1991. </year>
Reference-contexts: This comparison showed that for the class of safe Datalog programs (i.e., only ground facts are computed and no uninterpreted function symbols are allowed), bottom-up evaluation can be performed with a cost that is no more than that of the top-down evaluation in order of magnitude. Ramakrishnan and Sudarshan <ref> [81] </ref> compared a model of Prolog evaluation that performs tail recursion optimization with a model of bottom-up evaluation that uses a rewriting due to Ross [86] that performs tail recursion optimization.
Reference: 82. <author> Raghu Ramakrishnan and S. Sudarshan. </author> <title> Top-Down vs. Bottom-Up Revisited. </title> <note> In preparation (full version of paper that appeared in ILPS'91), </note> <year> 1992. </year>
Reference-contexts: The method can be modified slightly to make the claim valid for all programs and to allow tail recursion optimization. For details, see <ref> [82] </ref>. EFFICIENT BOTTOM-UP EVALUATION OF LOGIC PROGRAMS 7 The multiplicity of an element h [] is determined by the number of distinct rule instantiations of which it is the head literal.
Reference: 83. <author> Peter Z. Revesz. </author> <title> A closed form for datalog queries with integer order. </title> <booktitle> In International Conference on Database Theory, </booktitle> <pages> pages 187-201, </pages> <address> France, </address> <month> December </month> <year> 1990. </year>
Reference: 84. <author> J. Rohmer, R. Lescoeur, and J. M. Kerisit. </author> <title> The Alexander method | a technique for the processing of recursive axioms in deductive database queries. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 522-528, </pages> <year> 1986. </year>
Reference-contexts: In contrast, N additionally generates in each iteration all the facts that it generated in previous iterations. 2 3.3. Related Work The Alexander method was proposed independently of the Magic Sets approach in <ref> [84] </ref>. It is essentially the supplementary variant of the Magic Templates method, described in [13]. Seki has generalized the method to deal with non-ground facts and function symbols, and has called the generalized version Alexander Templates [92].
Reference: 85. <author> Kenneth Ross. </author> <title> Modular Stratification and Magic Sets for DATALOG programs with negation. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 161-171, </pages> <year> 1990. </year>
Reference-contexts: Intuitively, a program P is locally stratified if the (propositional) program Gr (P ) obtained by taking all ground instances of all rules in P is stratified. Local stratification has been extended to modular stratification in <ref> [85] </ref>. A program P is said to be modularly stratified if each strongly connected component (SCC) of P is locally stratified after removing instantiated rules containing literals that are false in lower SCCs. EXAMPLE 6.2. <p> However, it is modularly stratified. Locally and modularly stratified programs can be evaluated using the techniques described in <ref> [85; 43] </ref>. The evaluation of the Magic Templates transformation of this class of programs has also been considered in the literature ([85; 43; 80]). 2 6.2. <p> There are several approaches to relaxing the assumption of stratification. Several of the approaches used for negation carry over to set grouping. There are approaches based on weaker forms of stratification such as group stratification and magical stratification [57], or modular stratification <ref> [85] </ref>. Extensions of the well-founded and stable models to deal with aggregates are considered in [44]. Monotonic programs, where a derivation using an incomplete set does not affect the set of facts computed, are discussed in [25; 57]. <p> A program is non-floundering if all variables in a negated literal are ground before the literal is evaluated (in the left-to-right rule order). CORAL supports a class of programs with negation that properly contains the class of non-floundering modularly stratified programs (Ross <ref> [85] </ref>). Sets can be constructed by set-enumeration, or by set-grouping. Set grouping was discussed in Section 6.2. The following rule (fact) illustrates set-enumeration. children (john; fmary; peter; paulg): EFFICIENT BOTTOM-UP EVALUATION OF LOGIC PROGRAMS 29 All elements of sets generated thus must be ground terms (i.e., not contain any variables).
Reference: 86. <author> Kenneth Ross. </author> <title> Modular acyclicity and tail recursion in logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference-contexts: Ramakrishnan and Sudarshan [81] compared a model of Prolog evaluation that performs tail recursion optimization with a model of bottom-up evaluation that uses a rewriting due to Ross <ref> [86] </ref> that performs tail recursion optimization. <p> Applying this optimization for each goal on this rule, when the goal ? p (0; X) succeeds, an answer p (10; 1) is created directly, rather than an answer p (0; 1). Ross <ref> [86] </ref> shows how the same optimization can be performed in bottom-up evaluation.
Reference: 87. <author> Kenneth Ross and Yehoshua Sagiv. </author> <title> Monotonic aggregation in deductive databases. </title> <booktitle> In Proceedings of the post-ILPS'91 Workshop on Deductive Databases, </booktitle> <year> 1991. </year>
Reference-contexts: One such context is when subsumption of facts is defined in such a way that facts created using incomplete sets will be found to be subsumed and will be discarded. Ross and Sagiv <ref> [87] </ref> examine such classes of programs. Cruz and Norvell [27] examine the use of such forms of aggregation in the context of transitive closure. Ganguly, Greco and Zaniolo [33] examine how to evaluate a class of programs that are monotonic in a sense different from that used in [57].
Reference: 88. <author> Domenico Sacca and Carlo Zaniolo. </author> <title> The generalized counting methods for recursive logic queries. </title> <booktitle> In Proceedings of the First International Conference on Database Theory, </booktitle> <year> 1986. </year>
Reference: 89. <author> Yatin Saraiya. </author> <title> Linearizing nonlinear recursions in polynomial time. </title> <booktitle> In Proceedings of the ACM SIGACT-SIGART-SIGMOD Symposium on Principles of Database Systems, </booktitle> <pages> pages 182-189, </pages> <address> Philadelphia, Pennsylvania, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: Maher and Ramakrishnan study this issue in detail in [52], and provide sufficient conditions to detect if a program will not compute duplicate facts. 5.7. Linearizing Programs An interesting class of program transformations has recently been explored by a number of researchers <ref> [39; 114; 89; 78] </ref>. The objective is to transform a program that contains non-linear rules into an equivalent one that contains only linear rules; this may make some of the other transformations surveyed in this paper applicable, or permit simplifications in the implementation of the fixpoint evaluation phase.
Reference: 90. <author> M. Sassa and E. Goto. </author> <title> A hashing method for fast set operations. </title> <journal> Information Processing Letters, </journal> <volume> 5(4) </volume> <pages> 31-34, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: structure sharing becomes more difficult. (3) If variables in a large term get instantiated during the inference, creation of the head fact is made more complicated. (4) Unification of large non-ground terms using currently known techniques is inefficient, especially compared to the cost of unification for ground terms using hash-consing <ref> [36; 90] </ref>. (5) Indexing of facts containing variables using currently known techniques is inefficient, especially compared to the cost of indexing ground facts using, say, hash tables. <p> It uses a variety of optimization techniques including program transformations such as Magic Templates ([13; 74]), optimizations of bottom-up evaluation such as Semi-naive evaluation, rule and predicate orderings, efficient unification techniques such as hash-consing <ref> [36; 90] </ref> and sharing of structure for ground terms, and efficient indexing techniques. Currently, evaluation is completely in-memory, although we plan to implement disk-resident relations in future versions of CORAL. More optimization techniques will be incorporated in future versions of CORAL. Modules are the unit of compilation in CORAL.
Reference: 91. <author> Helmut Schmidt. </author> <title> Meta-Level Control for Deductive Database Systems. </title> <booktitle> Lecture Notes in Computer Science, Number 479. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: This is addressed in several papers (e.g. [6; 9; 5]). The problem becomes more complicated when it is desired to apply rules in a specified order in each iteration. This issue is discussed in <ref> [50; 79; 91] </ref>. The set GC is the set of generated consequences of the program.
Reference: 92. <author> H. Seki. </author> <title> On the power of Alexander templates. </title> <booktitle> In Proc. of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 150-159, </pages> <year> 1989. </year>
Reference-contexts: It is essentially the supplementary variant of the Magic Templates method, described in [13]. Seki has generalized the method to deal with non-ground facts and function symbols, and has called the generalized version Alexander Templates <ref> [92] </ref>. The Alexander methods always use a single left-to-right sip for each rule, for all possible goals. The Magic Templates idea was developed in a series of papers ([7; 13; 74]). Several variants of the Magic Templates idea have also been proposed. <p> SUDARSHAN Initial comparisons were based on the number of facts derived by the different techniques. Thus, Ramakrishnan [74; 75] presents a class of evaluations and shows that within this class bottom-up evaluation of a program rewritten using Magic Templates computes an optimal number of facts. Seki <ref> [92] </ref> presents a direct comparison between the set of facts computed using Alexander Templates rewriting, and using SLD-AL resolution. Bry [16] shows that several top-down and bottom-up evaluation techniques can be viewed as specializations of a technique called Backward Fixpoint Procedure.
Reference: 93. <author> T. Sellis, C. Lin, and L. Raschid. </author> <title> Implementing large production systems in a DBMS environment. </title> <booktitle> In Proceedings of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 404-412, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: by Gonzalez-Rubio, Bradier and Rohmer [35], Ganguly, Silberschatz and Tsur [32], Cohen and Wolfson [24], and others, e.g. [29; 75; 105; 113]), work on integrity constraints (e.g., Bry, Decker and Manthey [15], Vieille et al. [107] and others), work on production rule systems (e.g., Forgy [30], Sellis, Lin and Raschid <ref> [93] </ref>, Widom et al. [112], and others, and systems such as OPS 5), work on intelligent query answering (e.g. [55; 22]) etc. are not discussed in this tutorial presentation due to lack of space.
Reference: 94. <author> Ehud Shapiro. </author> <title> Logic programs with uncertainties: A tool for implementing rule-based systems. </title> <booktitle> In Proceedings of IJCAI, </booktitle> <pages> pages 529-532, </pages> <year> 1983. </year>
Reference: 95. <author> Seppo Sippu and Eljas Soisalon-Soinen. </author> <title> An optimization strategy for recursive queries in logic databases. </title> <booktitle> In Proceedings of the Fourth International Conference on Data Engineering, </booktitle> <address> Los Angeles, California, </address> <year> 1988. </year>
Reference-contexts: Several variants of the Magic Templates idea have also been proposed. For example, it is possible to compute supersets of the magic sets without compromising soundness. Although this results in some irrelevant computation, it may be possible to compute supersets more efficiently than the magic sets themselves <ref> [95] </ref>. Although the Magic Templates idea was introduced to deal with recursion, it provides significant improvements for non-recursive queries as well. In [57; 58] it is shown that the technique can be extended to deal with SQL programs, including those containing features like group-by, aggregation and arithmetic conditions.
Reference: 96. <author> S. Sudarshan and Raghu Ramakrishnan. </author> <title> Aggregation and relevance in deductive databases. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Databases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: Ganguly, Greco and Zaniolo [33] examine how to evaluate a class of programs that are monotonic in a sense different from that used in [57]. Ganguly et al. [33] and Sudarshan and Ramakrishnan <ref> [96] </ref> examine rewrite optimizations of programs that use aggregation, and the rewriting can result in unstratified programs. The following program for computing the shortest path length 22 RAGHU RAMAKRISHNAN, DIVESH SRIVASTAVA AND S.
Reference: 97. <author> S. Sudarshan and Raghu Ramakrishnan. </author> <title> Optimizations of bottom-up evaluation with non-ground terms. </title> <note> In preparation, </note> <year> 1992. </year>
Reference-contexts: No variable instantiation occurs within large terms, and this makes sharing of subterms easy. Putting these optimizations together, the program can be evaluated in O (n) time. A class of programs for which these optimizations are possible is discussed in Sudarshan and Ramakrishnan <ref> [97] </ref>. 6. Extensions to the Horn Clause Logic Programming Paradigm 6.1. Negation A deductive database query language can be enhanced by permitting negated literals in the bodies of rules in programs. This provides the ability to deal with non-monotonic deduction.
Reference: 98. <author> S. Sudarshan, Divesh Srivastava, Raghu Ramakrishnan, and Jeff Naughton. </author> <title> Space optimization in the bottom-up evaluation of logic programs. </title> <booktitle> In Proceedings of the ACM SIGMOD Conf. on Management of Data, </booktitle> <year> 1991. </year>
Reference-contexts: SUDARSHAN all derivations using such facts have been made, and the facts will not be derived again. Such facts can then be discarded during the evaluation. This issue is studied in detail in <ref> [63; 98] </ref>, where several sufficient conditions for discarding facts are developed. 5.6. Duplicate Elimination In general, when a fact is derived in a bottom-up evaluation, duplicate checking needs to be done to see if the fact was derived earlier. If it was not, derivations can be made using the fact.

References-found: 98

