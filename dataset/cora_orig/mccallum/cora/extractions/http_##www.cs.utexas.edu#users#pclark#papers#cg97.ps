URL: http://www.cs.utexas.edu/users/pclark/papers/cg97.ps
Refering-URL: http://www.cs.utexas.edu/users/pclark/papers/cg97.abs.html
Root-URL: 
Email: (clarkp@redwood.rt.cs.boeing.com)  (porter@cs.utexas.edu)  
Phone: 2  
Title: Using Access Paths to Guide Inference with Conceptual Graphs  
Author: D. Lukose, H. Delugach, M. Keeler, L. Searle, J. Sowa. Berlin:Springer Peter Clark and Bruce Porter 
Address: PO Box 3707, Seattle, WA 98124  Austin, TX 78712  
Affiliation: 1 The Boeing Company,  University of Texas at  
Web: http://www.cs.utexas.edu/users/pclark/papers/cg97.ps  
Note: In Proc 5th Int Conf on Conceptual Structures ICCS'97 (Lecture Notes in AI vol 1257) pp521-535. Eds:  (1997).  
Abstract: Conceptual Graphs (CGs) are a natural and intuitive notation for expressing first-order logic statements. However, the task of performing inference with a large-scale CG knowledge base remains largely unexplored. Although basic inference operators are defined for CGs, few methods are available for guiding their application during automated reasoning. Given the expressive power of CGs, this can result in inference being intractable. In this paper we show how a method used elsewhere for achieving tractability | namely the use of access paths | can be applied to conceptual graphs. Access paths add to CGs domain-specific information that guides inference by specifying preferred chains of subgoals for each inference goal (and hence, other chains will not be tried). This approach trades logical completeness for focussed inference, and allows incompleteness to be introduced in a controlled way (through the knowledge engineer's choice of which access paths to attach to CGs). The result of this work is an inference algorithm for CGs that significantly improves the efficiency of reasoning.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> James Crawford. </author> <title> Access-limited logic: A language for knowledge representation. </title> <type> Technical Report AI90-141, </type> <institution> Dept CS, Univ Texas at Austin, Austin, TX, </institution> <month> Oct </month> <year> 1990. </year>
Reference-contexts: Although conceptual graph research has significantly improved the efficiency of basic inference operations (eg. performing joins), there is still a need for methods that guide their application so that questions can be efficiently answered from large CG knowledge-bases. In this paper, we apply ideas from Access-Limited Logic <ref> [1] </ref> to Conceptual Graphs, as a means of guiding CG inference. Access-Limited Logic specifies access paths that (1) relate together the concepts in a knowledge-base, and (2) constrain inference to follow only those paths when answering queries that require navigating the knowledge-base. <p> In particular, the original research proved polynomial time inference for `pure' Algernon, which did not include statements involving existential quantification or restrictions on the car-dinality of relations (and thus is similar to Datalog [14]), and achieved tractibility by limiting the number of bindings a variable in a rule could take <ref> [1] </ref>. In contrast, our interest has been in `full' Algernon (due to our requirements for these features), and we exploit different sources of incompleteness, and hence efficiency, in its reasoning. There are three sources of incompleteness in full Algernon which we exploit.
Reference: 2. <author> B. W. Porter, J. Lester, K. Murray, K. Pittman, A. Souther, L. Acker, and T. Jones. </author> <title> The botany knowledge base project. </title> <type> Tech Report AI-88-88, </type> <institution> Dept CS, Univ Texas at Austin, </institution> <month> Sept </month> <year> 1988. </year>
Reference-contexts: The result of this approach is that complex chains of reasoning become possible with conceptual graphs because the inference process is focused in fruitful ways. We have used the representation language described here, which adds access paths to standard CGs, to build a large knowledge-base about plant biology <ref> [2] </ref> and a smaller knowledge-base about distributed computing [3]. We have fully implemented the inference algorithm presented here, and used it in conjunction with these knowledge bases [4]. The paper is organized as follows. Section 2 outlines the CG semantics used in this work.
Reference: 3. <author> Peter Clark and Bruce Porter. </author> <title> The dce help-desk project. </title> <note> (http://www.cs.utexas.edu/users/mfkb/dce.html), 1996. </note>
Reference-contexts: We have used the representation language described here, which adds access paths to standard CGs, to build a large knowledge-base about plant biology [2] and a smaller knowledge-base about distributed computing <ref> [3] </ref>. We have fully implemented the inference algorithm presented here, and used it in conjunction with these knowledge bases [4]. The paper is organized as follows. Section 2 outlines the CG semantics used in this work.
Reference: 4. <author> Peter Clark. KM/KQL: </author> <title> Syntax and semantics. (Internal document, </title> <institution> AI Lab, Univ Texas at Austin. </institution> <note> http://www.cs.utexas.edu/users/mfkb/manuals/kql.ps), 1996. </note>
Reference-contexts: We have fully implemented the inference algorithm presented here, and used it in conjunction with these knowledge bases <ref> [4] </ref>. The paper is organized as follows. Section 2 outlines the CG semantics used in this work. Section 3 describes access paths and how they can be used to guide inference, and Section 4 presents an inference algorithm based on this approach. <p> Based on this view, we can extend the path language, and hence the query language also, to include other forms of computation besides chains of relations. The full path language we use is described in <ref> [4] </ref>, and includes additional constructs for equality, negation (as failure), conditionals, arithmetic, and filtering of values.
Reference: 5. <author> J. F. Sowa. </author> <title> Conceptual structures Addison Wesley, </title> <year> 1984. </year>
Reference-contexts: Fig. 1. Semantics used for CG schemata and type definitions. rules provide a set of graph rewriting rules for CGs, equivalent in power to the rules of first-order predicate calculus <ref> [5, page 154] </ref>. These rules can be thought of as the "assembly code" for CG inference, in that they are building blocks with which other inference rules ("derived rules" [5, page 151]) can be described. For example, modus ponens is equivalent to applying a particular sequence of four alpha/beta rules. <p> These rules can be thought of as the "assembly code" for CG inference, in that they are building blocks with which other inference rules ("derived rules" <ref> [5, page 151] </ref>) can be described. For example, modus ponens is equivalent to applying a particular sequence of four alpha/beta rules. This approach is used in other CG implementations (eg. Prolog+CG [7]), and also here. <p> A type refinement is equivalent to type contraction, but without detaching items from the CG, and corresponds to applying the type definition's inference rule in the y This definition slightly deviates from that in <ref> [5] </ref>, in that RED-WINE in the initial CG is not replaced by WINE in the final graph, but instead is retained. <p> This enables types/schemas for RED-WINE and its generalizations to be located for future expansions. z Type refinement is equivalent to type contraction <ref> [5, page 108] </ref> without detaching items from the CG. Fig. 2. The three basic CG inference operators used. backward direction ("facts imply concept membership"). Expansions correspond to the elaboration of initial knowledge, and type refinements correspond to the classification of concepts in a conceptual graph. <p> initial scenario CG) and an unknown variable (the target) * FIND: * A sequence of expansions/refinements to the initial scenario CG which results in it containing a value for the target. 3.2 The Search Problem A simple example of this inference task is shown in Figure 3, an adaptation of <ref> [5, page 110] </ref>. (We ignore issues related to temporal reasoning, as they are not our concern here).
Reference: 6. <author> R. J. Brachman, D. L. McGuinness, P. F. Patel-Schneider, L. A. Resnick, and A. Borgida. </author> <title> Living with CLASSIC: When and how to use a KL-ONE like language. </title> <editor> In J. Sowa, editor, </editor> <booktitle> Principles of Semantic Networks. </booktitle> <publisher> Kaufmann, </publisher> <address> CA, </address> <year> 1991. </year>
Reference-contexts: A type definition corresponds to bi-directional logical implication. In terms of Description Logics (eg. <ref> [6] </ref>), type definitions express terminological (TBox) knowledge, while schemata express assertional (ABox) knowledge. In a knowledge-base, a concept will typically have both a type definition (describing its definitional properties) and a schema (describing additional implied properties). <p> One solution to this problem is to significantly weaken the language's expressive power. This approach is pursued by many within the Description Logic community (eg. <ref> [6] </ref>). However, the language restrictions required to guarantee tractability are severe and can limit the language's applicability [8]. The alternative we have chosen is to restrict the inference process, thus achieving tractability at the expense of completeness. <p> A chain of predicates like this is very common in knowledge-based systems (and object-oriented programming) and has many different names, including "attribute paths" in CLASSIC <ref> [6, page 425] </ref>, "relation compositions" in LOOM [10], "role chains" in KRYPTON [11, page 421], and "chains" in [12].
Reference: 7. <author> Adil Kabbaj. </author> <title> Prolog cg-object-oriented programming with PROLOG+CG. </title> <type> Master's thesis, </type> <institution> Univ Montreal, Canada, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: For example, modus ponens is equivalent to applying a particular sequence of four alpha/beta rules. This approach is used in other CG implementations (eg. Prolog+CG <ref> [7] </ref>), and also here.
Reference: 8. <author> Jon Doyle and Ramesh S. Patil. </author> <title> Two theses of knowledge representation: Language restrictions, taxonomic classification, and the utility of representation services. </title> <booktitle> Artificial Intelligence, </booktitle> <pages> pages 261-297, </pages> <year> 1991. </year>
Reference-contexts: One solution to this problem is to significantly weaken the language's expressive power. This approach is pursued by many within the Description Logic community (eg. [6]). However, the language restrictions required to guarantee tractability are severe and can limit the language's applicability <ref> [8] </ref>. The alternative we have chosen is to restrict the inference process, thus achieving tractability at the expense of completeness. The challenge is to adopt restrictions that, in practice, have minimal effect on question-answering ability.
Reference: 9. <author> J. M. Crawford and B. J. Kuipers. </author> <title> Algernon a tractable system for knowledge-representation. </title> <journal> SIGART Bulletin, </journal> <volume> 2(3) </volume> <pages> 35-44, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The challenge is to adopt restrictions that, in practice, have minimal effect on question-answering ability. The inference control method we present for CGs is based on "access limitation", which is used elsewhere in the knowledge representation community <ref> [9] </ref>. Access limitation is based on the use of access paths, which state how a value can be computed via a chain of inferences. <p> the same as the first argument of P i+1 : P 1 (X0; x 1 ); P 2 (x 1 ; x 2 ); :::; P n (x n1 ; x n ) where the x i 's are free variables. (This is a slightly more restricted definition than in <ref> [9] </ref>, but one suitable for conceptual graphs.) An access path denotes the set S of values for x n (the last variable in the path) for which there exists at least one value for all the other variables in the path, ie. 8x n ( x n 2 S $ 9x <p> Without the classify step in Figure 4, the inference engine would have failed to answer this query. 5 Discussion 5.1 Sources of Incompleteness Our use of access paths is inspired by the work on Algernon <ref> [9] </ref>, which similarly uses incomplete reasoning and access paths to achieve tractable inference. However, our work has evolved to exploit different properties of Algernon compared with those that Algernon was originally based on. <p> This property, in which all logical consequences are inferable by some sequence of questions, is referred to as "Socratic completeness" in access-limited logic <ref> [9] </ref>. 5.2 Extensions Access paths can be viewed as a special case of defining a CG node's value as a computation. Based on this view, we can extend the path language, and hence the query language also, to include other forms of computation besides chains of relations.
Reference: 10. <author> R. MacGregor. </author> <title> Loom users guide (version 1.4). </title> <type> Tech report, ISI, </type> <address> CA, </address> <year> 1991. </year>
Reference-contexts: A chain of predicates like this is very common in knowledge-based systems (and object-oriented programming) and has many different names, including "attribute paths" in CLASSIC [6, page 425], "relation compositions" in LOOM <ref> [10] </ref>, "role chains" in KRYPTON [11, page 421], and "chains" in [12].
Reference: 11. <author> Ronald J. Brachman, Richard E. Fikes, and Hector J. Levesque. </author> <title> KRYPTON: A functional approach to knowledge representation. </title> <editor> In Ronald J. Brachman and Hector J. Levesque, editors, </editor> <booktitle> Readings in Knowledge Representation, </booktitle> <pages> pages 412-429. </pages> <publisher> Kaufmann, </publisher> <address> CA, </address> <year> 1985. </year>
Reference-contexts: A chain of predicates like this is very common in knowledge-based systems (and object-oriented programming) and has many different names, including "attribute paths" in CLASSIC [6, page 425], "relation compositions" in LOOM [10], "role chains" in KRYPTON <ref> [11, page 421] </ref>, and "chains" in [12].
Reference: 12. <author> William A. Woods. </author> <title> Understanding subsumption and taxonomy. </title> <editor> In John F. Sowa, editor, </editor> <booktitle> Principles of Semantic Networks, </booktitle> <pages> pages 45-94. </pages> <publisher> Kaufmann, </publisher> <address> CA, </address> <year> 1991. </year>
Reference-contexts: A chain of predicates like this is very common in knowledge-based systems (and object-oriented programming) and has many different names, including "attribute paths" in CLASSIC [6, page 425], "relation compositions" in LOOM [10], "role chains" in KRYPTON [11, page 421], and "chains" in <ref> [12] </ref>.
Reference: 13. <author> Hassan Ait-Kaci and Andreas Podelski. </author> <title> Towards a meaning of LIFE. </title> <journal> Logic Programming, </journal> <volume> 16 </volume> <pages> 195-234, </pages> <year> 1993. </year>
Reference-contexts: It is thus important to retain paths within the CG knowledge-base, rather than "compile them out" into shared variables (as is done, for example, in the language LIFE <ref> [13] </ref>). Replacing paths with shared variables loses the control information that paths contain. 4 Inference with Access Paths 4.1 An Algorithm for Inference Inference is performed when a query is issued to the KB, either from a user or an application system.
Reference: 14. <author> Stefano Ceri, Georg Gottlob, and Letizia Tanca. </author> <title> What you always wanted to know about datalog (and never dared to ask). </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(1) </volume> <pages> 146-166, </pages> <month> Mar </month> <year> 1989. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: In particular, the original research proved polynomial time inference for `pure' Algernon, which did not include statements involving existential quantification or restrictions on the car-dinality of relations (and thus is similar to Datalog <ref> [14] </ref>), and achieved tractibility by limiting the number of bindings a variable in a rule could take [1]. In contrast, our interest has been in `full' Algernon (due to our requirements for these features), and we exploit different sources of incompleteness, and hence efficiency, in its reasoning.
References-found: 14

