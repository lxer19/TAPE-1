URL: http://www.cs.uoregon.edu/paracomp/proj/papers/spdt96/spdt96.ps.gz
Refering-URL: http://www.cs.uoregon.edu/paracomp/proj/tau/papers.html
Root-URL: http://www.cs.uoregon.edu
Title: Event and State-Based Debugging in TAU: A Prototype  
Author: Sameer Shende, Janice Cuny Lars Hansen, Joydip Kundu Stephen McLaughry, and Odile Wolf 
Affiliation: Department of Computer and Information Science University of Oregon Eugene, Oregon  
Abstract: Parallel programs are complex and often require a multilevel debugging strategy that combines both event-and state-based debugging. We report here on preliminary work that combines these approaches within the TAU program analysis environment for pC++. This work extends the use of event-based modeling to object-parallel languages, provides an alternative mechanism for establishing meaningful global breakpoints in object-oriented languages, introduces the TAU program interaction and control infrastructure, and provides an environment for the assessment of mixed event- and state-based strategies. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Z. Aral and I. Gertner, </author> <title> "High-Level Debugging in Parasight," </title> <booktitle> Proceedings of the ACM Workshop on Parallel and Distributed Debugging, ACM SIGPLAN Notices 24(1) </booktitle> <pages> 151-162, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Sneaky itself is a programmable, state-based debugger that we are currently developing; it is in the style of Acid [23], Dalek [20], and Parasight <ref> [1] </ref>. Many debugging abstractions are context and application dependent, making it difficult to anticipate all of the debugging needs of the user ahead of time. <p> The performance of Sneezy on larger systems (where the client might be a bottleneck in terms of being a focus for messages from many nodes) is somewhat unclear. At some point we will have to consider a mechanism like that of Parasight <ref> [1] </ref>, where lightweight parasites can be moved into the program and execute there for event filtering and generation.
Reference: [2] <author> P. C. Bates. </author> <title> Debugging Programs in a Distributed System Environment. </title> <type> PhD Thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <year> 1986. </year>
Reference-contexts: It matches user-specified models of intended program behavior against actual program behavior as captured in event traces <ref> [2] </ref>. The traces record low-level interprocess communication, pre-defined language specific-events, and user-defined events. They are stored internally as execution history graphs with nodes representing events and edges representing orderings imposed by Lamport's happened before relation [17].
Reference: [3] <author> D. Brown, S. Hackstadt, A. Malony, and B. Mohr, </author> <title> "Program Analysis Environments for Parallel Language Systems: The TAU Environment," </title> <booktitle> Proceedings of the 2nd Workshop on Environments and Tools for Parallel Scientific Computing, </booktitle> <pages> pp. 162-171, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: The combination of these techniques provides comprehensive debugging support. We report here on preliminary work that combines event-and state-based debugging approaches within the TAU program analysis environment <ref> [3] </ref>. We build on an earlier prototype [15] which combined our event-based debugger, Ari-adne, with Intel's state-based debugger, ipd [11].
Reference: [4] <author> D. Brown, A. Malony, and B. Mohr, </author> <title> "Language-Based Parallel Program Interaction: The Breezy Approach," </title> <booktitle> International Conference on Performance Computing, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: a scatter plot of the same data. of element ids on merged and nonmerged nodes. the remaining processes be stopped in order to provide a meaningful state? One possibility is to allow breakpoints to be set dynamically but only at barrier synchronizations as was done in the TAU Breezy debugger <ref> [4] </ref>. This, however, will be overly constraining in multithreaded and multitasked extensions to pC++, in which programs can have more of an MIMD flavor, with considerable amounts of computation occurring between global synchronization points. In addition, it does not exploit any event-based analysis that the user might have already done.
Reference: [5] <author> Object Management Group, </author> <title> "The Common Object Request Broker: Architecture and Specification," Framingham, </title> <address> MA, </address> <year> 1994. </year>
Reference-contexts: It is our intention that such distributed-object frameworks as CORBA <ref> [5] </ref> and ILU [12] could serve as implementation vehicles for Sneezy. The programmer-visible part of Sneezy is realized as two APIs, one for the parallel program (server API ) and one for the client (client API ). These APIs depend on the agent implementation and the client language, respectively.
Reference: [6] <author> D. Gannon and J.K. Lee, </author> <title> "Object Oriented Parallelism: pC++ Ideas and Experiments," </title> <booktitle> Proceedings 1991 Japan Society for Parallel Processing, </booktitle> <pages> pp. 13-23, </pages> <year> 1991. </year>
Reference-contexts: TAU is an environment for programming in the pC++ data-parallel language <ref> [6] </ref>; in this paper, we introduce extensions to event-based behavioral modeling that support object-parallel languages and provide new mechanisms for establishing meaningful breakpoints in object-oriented code.
Reference: [7] <author> A. P. Goldberg, A. Gopal, A, Lowry, and R. Strom, </author> <title> "Restoring Consistent Global States of Distributed Computations," </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. 144-154, </pages> <year> 1991. </year>
Reference-contexts: In some cases, this procedure results in a state that is not consistent, that is, a state that could not have occurred in an actual execution. We define consistency as in <ref> [7] </ref>. Whenever a user's breakpointing request would result in an inconsistent state, our debugger automatically constructs an earlier, consistent state using a greedy algorithm [13].
Reference: [8] <author> A. A. Hough and J. E. Cuny, </author> <title> "Perspective Views: A Technique for Enchancing Visualizations of Parallel Programs," </title> <booktitle> 1990 International Conference on Parallel Processing, </booktitle> <pages> pp. II 124-132, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: they are matched in two steps: first the individual p-chains are matched and then the asserted temporal relations between those events are verified. (Since the temporal relations are not used in the examples in this paper, we do not discuss them further here but refer the reader to existing literature <ref> [8] </ref>.) When a pt-chain is matched or partially matched, its events are returned as a match tree in which internal nodes represent user-defined abstractions and leaves represent primitive events. The levels of a match tree correspond to the hierarchical levels of its model.
Reference: [9] <institution> The HPC++ working group. </institution> <note> "HPC++ Whitepapers and Draft Working Documents." </note>
Reference-contexts: A computation is divided into contexts (address spaces), each of which has one or more threads of computation. In the current system, we assume that a barrier synchronization is program-wide, 4 but by adopting the concept of a collector as originally proposed for HPC++ <ref> [9] </ref>, this restriction could be relaxed. Events occur at (thread,location) pairs. Clients enable and disable event pairs by invoking procedures in the agent, which performs instrumentation of the running program. When an event occurs, notification is sent via the agent to the client.
Reference: [10] <editor> IEEE Standard 1178-1990. </editor> <title> Standard for the Scheme Programming Language. </title> <publisher> IEEE, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: A programmable debugger alleviates this problem by allowing the user to build new abstractions, synthesizing complex events from sequences of simpler ones, as in Dalek [20]. Our programming language will be high-level, dynamically typed, with powerful data structuring capabilities and closures; the initial prototype uses Scheme <ref> [10] </ref>. Sneaky will include a large and ever-growing library of packaged functionality to aid rapid debugger extension. 5 Integration within the Tau Debugging Architecture 5.1 Overview To integrate Ariadne and Sneaky, we made use of the TAU program interaction and control infrastructure, called Sneezy.
Reference: [11] <author> Intel Supercomputer Systems Division. </author> <title> Paragon Interactive Parallel Debugger Reference Manual. Paragon Documentation, </title> <year> 1994. </year>
Reference-contexts: The combination of these techniques provides comprehensive debugging support. We report here on preliminary work that combines event-and state-based debugging approaches within the TAU program analysis environment [3]. We build on an earlier prototype [15] which combined our event-based debugger, Ari-adne, with Intel's state-based debugger, ipd <ref> [11] </ref>.
Reference: [12] <institution> Inter-Language Unification. </institution> <note> Available from ftp://parcftp.parc.xerox.com/pub/ilu/ilu.html </note>
Reference-contexts: It is our intention that such distributed-object frameworks as CORBA [5] and ILU <ref> [12] </ref> could serve as implementation vehicles for Sneezy. The programmer-visible part of Sneezy is realized as two APIs, one for the parallel program (server API ) and one for the client (client API ). These APIs depend on the agent implementation and the client language, respectively.
Reference: [13] <author> J. Kundu. </author> <title> Integrating Event- and State- Based Approaches to Debugging of Parallel Programs. </title> <type> PhD Thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <year> 1996. </year>
Reference-contexts: Finally, in Section 6, we present our conclusions and outline future directions, focusing on the debugging facilities that will be needed for more complex object-parallel languages that incorporate task parallelism. 2 The Ariadne Debugger: An Overview Ariadne is a post mortem, event-based debugger <ref> [13, 16] </ref>. It matches user-specified models of intended program behavior against actual program behavior as captured in event traces [2]. The traces record low-level interprocess communication, pre-defined language specific-events, and user-defined events. <p> We define consistency as in [7]. Whenever a user's breakpointing request would result in an inconsistent state, our debugger automatically constructs an earlier, consistent state using a greedy algorithm <ref> [13] </ref>. For the binary image compression example, we had already used event-based analysis to show that there was some node that was not compressed at level two in the tree that was subsequently compressed at level three. It makes sense to stop the program immediately after level two is processed.
Reference: [14] <author> J. Kundu and J. E. Cuny, </author> <title> "A Scalable, Visual Interface for Debugging with Event-Based Behavioral Abstraction," </title> <booktitle> Frontiers of Massively Parallel Computing '95. </booktitle> <pages> pp. 472-479, </pages> <year> 1995. </year>
Reference-contexts: Ariadne's matching language is quite simple and, as a result, it is not always expressive enough; often its patterns are too coarse, matching program behavior in unexpected ways. To compensate, Ariadne provides a scalable, spreadsheet like interface for exploring match trees, called AVE (Ariadne Visualization Engine) <ref> [14] </ref>. AVE features the automatic compression of hierarchical visualizations, dynamic attribute calculation, and the partitioning of matched behaviors and attributes.
Reference: [15] <author> J. Kundu and J. E. Cuny, </author> <title> "The Integration of Event- and State-Based Debugging in Ariadne," </title> <booktitle> Proceedings 1995 International Conference on Parallel Processing, </booktitle> <pages> pp. II 130-134, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: The combination of these techniques provides comprehensive debugging support. We report here on preliminary work that combines event-and state-based debugging approaches within the TAU program analysis environment [3]. We build on an earlier prototype <ref> [15] </ref> which combined our event-based debugger, Ari-adne, with Intel's state-based debugger, ipd [11]. <p> In order to halt a computation, the state most relevant to the abstract event is restored <ref> [15] </ref>: 1. Processes in the other set are stopped at their earliest state; 2. Processes in the influence set are stopped immediately after their latest events that could have causally influ enced the abstract event; and 3.
Reference: [16] <author> J. Kundu and J. E. Cuny, </author> <title> Integrated Event- and State-Based Debugging of Parallel Programs. </title> <type> Technical Report, </type> <institution> University of Oregon, </institution> <year> 1996. </year>
Reference-contexts: Finally, in Section 6, we present our conclusions and outline future directions, focusing on the debugging facilities that will be needed for more complex object-parallel languages that incorporate task parallelism. 2 The Ariadne Debugger: An Overview Ariadne is a post mortem, event-based debugger <ref> [13, 16] </ref>. It matches user-specified models of intended program behavior against actual program behavior as captured in event traces [2]. The traces record low-level interprocess communication, pre-defined language specific-events, and user-defined events.
Reference: [17] <author> L. Lamport, </author> <title> "Time, Clocks, and the Ordering of Events in a Distributed System," </title> <journal> Communications of the ACM, </journal> <volume> 21(7), </volume> <pages> pp. 558-565, </pages> <year> 1978. </year>
Reference-contexts: The traces record low-level interprocess communication, pre-defined language specific-events, and user-defined events. They are stored internally as execution history graphs with nodes representing events and edges representing orderings imposed by Lamport's happened before relation <ref> [17] </ref>. Ariadne matches user-models against the execution history graph, extracting matched or partially matched subgraphs for further investigation. The extracted subgraphs can be explored through additional modeling, functional queries, and manipulations of logical, temporal orderings. Ariadne's modeling language for describing intended behavior is quite simple.
Reference: [18] <author> T. Ludwig, R.Wismuller, V. Sunderam, and A. Bode. "OMIS: </author> <title> On-line Monitoring Interface Specification, </title> <note> Version 1.0." February 1, 1996. </note> <institution> Technische Universitat Munchen, Germany. </institution> <note> Available from http://wwwbode.informatik.tu-muenchen.de/~omis. </note>
Reference-contexts: Sneezy's design is minimalist, making it lightweight, rela-tively easy to implement, and potentially simple to port and verify. Implementations of complex but common functionality will exist as portable libraries available to the clients. Other systems with functionality similar to that of Sneezy include Dynascope [21] and OMIS <ref> [18] </ref>. 5.2 Event Model The Sneezy event model defines the manner in which events, data, and control flow between the program, the agent, and the tools. The computational model targeted by Sneezy is SPMD/ MIMD.
Reference: [19] <author> Y. Manabe and M. Imase, </author> <title> Global "Conditions in Debugging Distributed Programs," </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol. 15, </volume> <pages> pp. 62-69, </pages> <year> 1992. </year>
Reference-contexts: Thus each process is stopped at the last point at which it could have influenced the event (s) triggering the breakpoint. This is the consistent state that is most meaningful to the programmer. In related work, Manabe and Imase <ref> [19] </ref> also set break-points that were used to find consistent states during replay. They, however, used a state-based approach, specifying breakpoints with conjunctions and disjunctions of local state predicates.
Reference: [20] <author> R. A. Olsson, R. H. Crawford, and W. Wilson Ho, </author> <title> "A Dataflow Approach to Event-based Debugging" Software-Practice and Experience 21(2), </title> <journal> pp. </journal> <pages> 209-229, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Sneaky itself is a programmable, state-based debugger that we are currently developing; it is in the style of Acid [23], Dalek <ref> [20] </ref>, and Parasight [1]. Many debugging abstractions are context and application dependent, making it difficult to anticipate all of the debugging needs of the user ahead of time. <p> Many debugging abstractions are context and application dependent, making it difficult to anticipate all of the debugging needs of the user ahead of time. A programmable debugger alleviates this problem by allowing the user to build new abstractions, synthesizing complex events from sequences of simpler ones, as in Dalek <ref> [20] </ref>. Our programming language will be high-level, dynamically typed, with powerful data structuring capabilities and closures; the initial prototype uses Scheme [10].
Reference: [21] <author> R. Sosic. </author> <title> "Design and Implementation of Dynascope, a Directing Platform for Compiled Programs." </title> <journal> Computing Systems. </journal> <volume> Vol. 8, 2, pp.107-134, </volume> <month> Spring </month> <year> 1995. </year>
Reference-contexts: Sneezy's design is minimalist, making it lightweight, rela-tively easy to implement, and potentially simple to port and verify. Implementations of complex but common functionality will exist as portable libraries available to the clients. Other systems with functionality similar to that of Sneezy include Dynascope <ref> [21] </ref> and OMIS [18]. 5.2 Event Model The Sneezy event model defines the manner in which events, data, and control flow between the program, the agent, and the tools. The computational model targeted by Sneezy is SPMD/ MIMD.
Reference: [22] <author> P. Scheuermann, A. Yaagoub, and M. Aris-Ouksel, </author> <title> "Compression of Binary Images on a Hypercube Machine," </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> Vol 23, </volume> <pages> pp. 49-59, </pages> <year> 1994. </year>
Reference-contexts: Example: Binary Image Compression. To illustrate the use of Ariadne and the extended modeling language, we debug a parallel version of an algorithm to compress black and white images stored as bintrees <ref> [22] </ref>. Working up from the leaves, the algorithm compresses homogeneously colored siblings into single nodes represented at their parent as shown in Figure 1. The parallel version of the algorithm distributes entire subtrees of the initial bintree to processes. We ran our code on images with 256 nodes.
Reference: [23] <author> P. Winterbottom, </author> <title> "ACID: A Debugger Built from a Language," </title> <booktitle> Proceedings of the Winter 1993 USENIX Technical Conference, </booktitle> <pages> pp. 192-212, </pages> <year> 1994. </year>
Reference-contexts: Sneaky itself is a programmable, state-based debugger that we are currently developing; it is in the style of Acid <ref> [23] </ref>, Dalek [20], and Parasight [1]. Many debugging abstractions are context and application dependent, making it difficult to anticipate all of the debugging needs of the user ahead of time.
References-found: 23

