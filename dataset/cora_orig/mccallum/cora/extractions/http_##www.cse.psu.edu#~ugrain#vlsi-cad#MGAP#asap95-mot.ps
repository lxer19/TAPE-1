URL: http://www.cse.psu.edu/~ugrain/vlsi-cad/MGAP/asap95-mot.ps
Refering-URL: http://www.cse.psu.edu/~ugrain/publications.html
Root-URL: 
Email: info.pub.permission@ieee.org.  
Note: Copyright 1995 IEEE. All rights reserved. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution must be obtained from the IEEE. For information on obtaining permission, send a blank email message to  By choosing to view this document, you agree to all provisions of the copyright laws protecting it.  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> A. Artieri and F. Jutand, </author> <title> A Versatile and Powerfull Chip for Real Time Motion Estimation, </title> <booktitle> in Proc. ICASSP 89, </booktitle> <pages> pp. 2453-2456. </pages>
Reference-contexts: A BMA can be implemented by hierarchical algorithms [5] or full-search algorithms <ref> [1] </ref>[6][11]. When those algorithms are implemented via array processors, full-search algorithms are preferred because of lower control overhead. Full-search BMAs can be categorized into two classes, broadcasting [1] and non-broadcasting [6][11] schemes. In a broadcasting scheme, each processing element (PE) is assigned to a specific displacement. The absolute difference values between the candidate and the template pixel are accumulated within each PE after broadcasting template pixels to all PEs. <p> Shifting data, sh, is shifted up and copied into running data, r1, of WP [n]. After shifting up global distance, di, the local distance, |te - r1|, is accumulated in global distance. WP <ref> [1] </ref> finds the minimum global distance and keeps the corresponding index. These steps are iterated (n+d) times. Note that the resident data is not changed during computation. This feature will be used in 2-D BMA. <p> + d) do - /* Main iteration */ if (step &gt;= 2) then - temporary [i] := r1 [i+1]; r1 [i] := r2 [i]; r2 [i] := temporary [i]; te re sh r1 r2 to di WP [2] WP [4] WP [6] x2 y2 y2 y4 y4 y6 y6 WP <ref> [1] </ref> WP [3] WP [5] x1 y1 y2 x3 y3 y4 y4 D2 y5 y6 te re sh r1 r2 to di WP [2] WP [4] WP [6] x2 y2 y4 y3 y4 D2 y4 y6 y6 1st step 2nd step 3rd step te : template re : resident data sh
Reference: [2] <author> R. Bajwa, R.M. Owens, and M.J. Irwin, </author> <title> Area Time Trade-offs in Micro-Grained VLSI Array Architectures, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 43, </volume> <pages> pp. 1121-1128, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: == 1) then count [i] := -n; For Step = 1 to (n + d) do - /* Main iteration */ if (step &gt;= 2) then - temporary [i] := r1 [i+1]; r1 [i] := r2 [i]; r2 [i] := temporary [i]; te re sh r1 r2 to di WP <ref> [2] </ref> WP [4] WP [6] x2 y2 y2 y4 y4 y6 y6 WP [1] WP [3] WP [5] x1 y1 y2 x3 y3 y4 y4 D2 y5 y6 te re sh r1 r2 to di WP [2] WP [4] WP [6] x2 y2 y4 y3 y4 D2 y4 y6 y6 1st <p> [i]; r2 [i] := temporary [i]; te re sh r1 r2 to di WP <ref> [2] </ref> WP [4] WP [6] x2 y2 y2 y4 y4 y6 y6 WP [1] WP [3] WP [5] x1 y1 y2 x3 y3 y4 y4 D2 y5 y6 te re sh r1 r2 to di WP [2] WP [4] WP [6] x2 y2 y4 y3 y4 D2 y4 y6 y6 1st step 2nd step 3rd step te : template re : resident data sh : shifting data r1,r2 : running data to : token di : global distance n |x3-y3| |x3-y4| |x3-y4| + |x2-y3| D1 to [i]
Reference: [3] <author> R. Bajwa, R.M. Owens, and M.J. Irwin, </author> <title> The MGAPs Programming Environment and the *C++ Language, </title> <booktitle> in Proc. Intl. Conf. on Application-Specific Array Processors, </booktitle> <month> Jul. </month> <year> 1995. </year>
Reference-contexts: The second generation of the MGAP, the MGAP-2, containing 256 x 256 DPs clocked at 50 MHz is being developed using 0.8 m CMOS technology. The MGAP is supported by an easy-to-use programming environment that allows a relatively naive user to develop applications in a high level language (*C++) <ref> [3] </ref>. 4: Mapping Full-Search BMA onto the MGAP Full-search BMAs can be grouped into two classes, broadcasting and non-broadcasting schemes. To map the full-search BMA efficiently onto the MGAP, we need regular dataow on the array processor and a reduction of data memory accesses. <p> do - /* Main iteration */ if (step &gt;= 2) then - temporary [i] := r1 [i+1]; r1 [i] := r2 [i]; r2 [i] := temporary [i]; te re sh r1 r2 to di WP [2] WP [4] WP [6] x2 y2 y2 y4 y4 y6 y6 WP [1] WP <ref> [3] </ref> WP [5] x1 y1 y2 x3 y3 y4 y4 D2 y5 y6 te re sh r1 r2 to di WP [2] WP [4] WP [6] x2 y2 y4 y3 y4 D2 y4 y6 y6 1st step 2nd step 3rd step te : template re : resident data sh : shifting
Reference: [4] <author> K.E. Batcher, </author> <title> Design of a Massively Parallel Processor, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 29, </volume> <pages> pp. 836-840, </pages> <month> Sep. </month> <year> 1980. </year>
Reference-contexts: The versatility of the architecture allows us to target numerous applications such as video compression, computer vision, speech recognition, and problems in computational biology. Unlike the CLIP4 [7], the MPP <ref> [4] </ref>, and the CM [8], the MGAP is designed to be used as a low-cost massively parallel co-processor in a desktop computing environment. It consists of a mesh of fine grain processing elements each of which is referred as a Digit Processor (DP). <p> then count [i] := -n; For Step = 1 to (n + d) do - /* Main iteration */ if (step &gt;= 2) then - temporary [i] := r1 [i+1]; r1 [i] := r2 [i]; r2 [i] := temporary [i]; te re sh r1 r2 to di WP [2] WP <ref> [4] </ref> WP [6] x2 y2 y2 y4 y4 y6 y6 WP [1] WP [3] WP [5] x1 y1 y2 x3 y3 y4 y4 D2 y5 y6 te re sh r1 r2 to di WP [2] WP [4] WP [6] x2 y2 y4 y3 y4 D2 y4 y6 y6 1st step 2nd <p> [i] := temporary [i]; te re sh r1 r2 to di WP [2] WP <ref> [4] </ref> WP [6] x2 y2 y2 y4 y4 y6 y6 WP [1] WP [3] WP [5] x1 y1 y2 x3 y3 y4 y4 D2 y5 y6 te re sh r1 r2 to di WP [2] WP [4] WP [6] x2 y2 y4 y3 y4 D2 y4 y6 y6 1st step 2nd step 3rd step te : template re : resident data sh : shifting data r1,r2 : running data to : token di : global distance n |x3-y3| |x3-y4| |x3-y4| + |x2-y3| D1 to [i] := to
Reference: [5] <author> L. De Vos, </author> <title> VLSI-Architectures for the Hierarchical Block-Matching Algorithm for HDTV applications, </title> <booktitle> SPIE Vol. 1360 Visual Comm. and Image Proc. </booktitle> <volume> 90, </volume> <pages> pp. 398-409. </pages>
Reference-contexts: The favorite scheme appears to be block matching algorithms (BMA) because of its simplicity for realization in hardware. A BMA can be implemented by hierarchical algorithms <ref> [5] </ref> or full-search algorithms [1][6][11]. When those algorithms are implemented via array processors, full-search algorithms are preferred because of lower control overhead. Full-search BMAs can be categorized into two classes, broadcasting [1] and non-broadcasting [6][11] schemes. In a broadcasting scheme, each processing element (PE) is assigned to a specific displacement. <p> /* Main iteration */ if (step &gt;= 2) then - temporary [i] := r1 [i+1]; r1 [i] := r2 [i]; r2 [i] := temporary [i]; te re sh r1 r2 to di WP [2] WP [4] WP [6] x2 y2 y2 y4 y4 y6 y6 WP [1] WP [3] WP <ref> [5] </ref> x1 y1 y2 x3 y3 y4 y4 D2 y5 y6 te re sh r1 r2 to di WP [2] WP [4] WP [6] x2 y2 y4 y3 y4 D2 y4 y6 y6 1st step 2nd step 3rd step te : template re : resident data sh : shifting data r1,r2
Reference: [6] <author> L. De Vos and M. Schbinger, </author> <title> Efficient Architecture of a Programmable Block Matching Processor, </title> <booktitle> in Proc. Intl. Conf. on Application-Specific Array Processors, </booktitle> <pages> pp. 560-571, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: The absolute difference values are then accumulated over all PEs systolically. Komarek et. al. [11] used a skewed and chained data stream of candidate blocks which requires preprocessing and repeated video memory access for the same data. De Vos et. al. <ref> [6] </ref> solved this problem using on-chip memory with additional adder trees to sum partial results. Most of these algorithms were implemented using specialized VLSI chips [1][5][6][11] and all of them match one block at a time. There exist, however, shared data in search areas for adjacent template blocks. <p> [i] := -n; For Step = 1 to (n + d) do - /* Main iteration */ if (step &gt;= 2) then - temporary [i] := r1 [i+1]; r1 [i] := r2 [i]; r2 [i] := temporary [i]; te re sh r1 r2 to di WP [2] WP [4] WP <ref> [6] </ref> x2 y2 y2 y4 y4 y6 y6 WP [1] WP [3] WP [5] x1 y1 y2 x3 y3 y4 y4 D2 y5 y6 te re sh r1 r2 to di WP [2] WP [4] WP [6] x2 y2 y4 y3 y4 D2 y4 y6 y6 1st step 2nd step 3rd <p> temporary [i]; te re sh r1 r2 to di WP [2] WP [4] WP <ref> [6] </ref> x2 y2 y2 y4 y4 y6 y6 WP [1] WP [3] WP [5] x1 y1 y2 x3 y3 y4 y4 D2 y5 y6 te re sh r1 r2 to di WP [2] WP [4] WP [6] x2 y2 y4 y3 y4 D2 y4 y6 y6 1st step 2nd step 3rd step te : template re : resident data sh : shifting data r1,r2 : running data to : token di : global distance n |x3-y3| |x3-y4| |x3-y4| + |x2-y3| D1 to [i] := to [i+1]; if
Reference: [7] <author> M.J.B. Duff and T.J. Fountain, </author> <title> Computing Structures for Image Processing, </title> <publisher> Academic Press, </publisher> <year> 1983. </year>
Reference-contexts: The versatility of the architecture allows us to target numerous applications such as video compression, computer vision, speech recognition, and problems in computational biology. Unlike the CLIP4 <ref> [7] </ref>, the MPP [4], and the CM [8], the MGAP is designed to be used as a low-cost massively parallel co-processor in a desktop computing environment. It consists of a mesh of fine grain processing elements each of which is referred as a Digit Processor (DP).
Reference: [8] <author> W.D. Hillis, </author> <title> The Connection Machine, </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: The versatility of the architecture allows us to target numerous applications such as video compression, computer vision, speech recognition, and problems in computational biology. Unlike the CLIP4 [7], the MPP [4], and the CM <ref> [8] </ref>, the MGAP is designed to be used as a low-cost massively parallel co-processor in a desktop computing environment. It consists of a mesh of fine grain processing elements each of which is referred as a Digit Processor (DP). A DP is just a small RAM and some multiplexers.
Reference: [9] <author> M.J. Irwin and R.M. Owens, </author> <title> A micro-grained VLSI signal processor, </title> <booktitle> in Proc. ICASSP 92, </booktitle> <pages> pp. </pages> <address> V.641-V.644, </address> <month> Mar. </month> <year> 1992. </year>
Reference: [10] <author> H.N. Kim, R.M. Owens, and M.J. Irwin, </author> <title> 2-D Discrete Cosine Transforms on Fine-Grain Array Processors, </title> <booktitle> in Proc. VLSI Signal Processing VII, </booktitle> <pages> pp. 356-367, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Our architecture, the MGAP, can be used as a massively parallel co-processor in a desktop computing environment. Therefore, with the 2-D DCT on the MGAP <ref> [10] </ref>, the development of a complete video codec algorithm is a goal of future studies. Acknowledgments This research was partially supported by National Science Foundation under Grant no. NSF/ CISE/MIPS-9408921.
Reference: [11] <author> T. Komarek and P. Pirsch, </author> <title> Array Architectures for Block Matching Algorithms, </title> <journal> IEEE Trans. Circuits and Systems, </journal> <volume> vol. 36, </volume> <pages> pp. 1301-1308, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: In a non-broadcasting scheme, each PE is assigned to one pixel of the template block. The absolute difference values are then accumulated over all PEs systolically. Komarek et. al. <ref> [11] </ref> used a skewed and chained data stream of candidate blocks which requires preprocessing and repeated video memory access for the same data. De Vos et. al. [6] solved this problem using on-chip memory with additional adder trees to sum partial results.
Reference: [12] <author> J. Lim, </author> <title> Two-Dimensional Signal and Image Processing, </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference: [13] <author> C. Nagendra, R.M. Owens, and M.J. Irwin, </author> <title> Digit Systolic Algorithms for Fine-grain Architectures, </title> <booktitle> in Proc. Application Specific Array Processors, </booktitle> <pages> pp. 466-477, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: A WP of p digit precision consists of subarray of DPs. The MGAP is reconfigurable to handle applications that require various precisions. A radix 4, fully redundant number system is used to allow constant time addition and linear time multiplication <ref> [13] </ref>. The Table 1 shows the cycles and Ops/sec for some relevant operations for the BMA when p=16 on the MGAP-1. The first generation of the MGAP, the MGAP-1, contains 128 x 128 DPs in 132-pin 32 PGA custom 1.2m CMOS chips and is clocked at 25 MHz.
References-found: 13

