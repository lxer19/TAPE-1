URL: http://www.cs.indiana.edu/hyplan/jbalasub/html/paper.ps
Refering-URL: http://www.cs.indiana.edu/hyplan/jbalasub/html/resume.html
Root-URL: http://www.cs.indiana.edu
Title: Java RMI Performance and Object Model Interoperability: Experiments with Java/HPC++ Distributed Components  
Author: Fabian Breg, Shridhar Diwan, Juan Villacis, Jayashree Balasubramanian, Esra Akman, Dennis Gannon 
Affiliation: Department of Computer Science Indiana University  
Abstract: Java RMI provides an elegant and powerful model for invoking member functions on objects that exist in remote address spaces. Unfortunately, it is a Java-to-Java communication model and many of the objects we would like java to interact with may be scientific application written in C++ or Fortran. This paper explores the design of RMI and extracts a subset of the RMI object model that is compatible with C++ and HPC++ remote object semantics. This RMI-subset has been implemented to run over the Nexus runtime system and is being used as part of the LSA distributed linear system analyzer project. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Mani Chandy and Carl Kesselman. </author> <title> CC++: A declarative concurrent object-oriented programming notation, </title> <booktitle> 1993. In Research Directions in Concurrent Object Oriented Programming, </booktitle> <publisher> MIT Press. </publisher>
Reference-contexts: Each node is a shared-memory multiprocessor (SMP) and may have several contexts, or virtual address spaces. The central problem associated with multi-context computation is the communication and synchronization of events between two contexts. HPC++ is based on the CC++ <ref> [1] </ref> global pointer concept and the library implements this with a GlobalP tr &lt; T &gt; template as is done in the MPC++ Template Library [7]. A global pointer is a generalization of the C pointer type to support pointers to objects that exist in other address spaces.
Reference: [2] <author> I. Foster, C. Kesselman, and S. Tuecke. </author> <title> The Nexus Approach to Integrating Multithread-ing and Communication. </title> <journal> J. Parallel and Distributed Computing, </journal> <volume> 37 </volume> <pages> 70-82, </pages> <year> 1996. </year>
Reference-contexts: As a first step towards implementing a Java RMI to HPC++ communication system, we implemented a Java to Java RMI system on top of NexusJava [3], a Java interface to the Nexus communication library <ref> [2] </ref>. This system is called Nexus RMI. Next we extended the communication mechanism underlying HPC++ so that it became compatible with the Nexus RMI communication mechanism. This established the communication link between Nexus RMI and HPC++. The rest of the section is organized as follows.
Reference: [3] <author> I. Foster and S. Tuecke. </author> <title> Enabling technologies for web-based ubiquitous supercomputing. </title> <booktitle> In Proc. 5th IEEE Symp. on High Performance Distributed Computing, </booktitle> <year> 1997. </year>
Reference-contexts: As a first step towards implementing a Java RMI to HPC++ communication system, we implemented a Java to Java RMI system on top of NexusJava <ref> [3] </ref>, a Java interface to the Nexus communication library [2]. This system is called Nexus RMI. Next we extended the communication mechanism underlying HPC++ so that it became compatible with the Nexus RMI communication mechanism. This established the communication link between Nexus RMI and HPC++.
Reference: [4] <author> D. Gannon, P. Beckman, E. Johnson, and T. Green. </author> <title> Compilation Issues on Distributed Memory Systems, chapter 3 HPC++ and the HPC++Lib Toolkit. </title> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Java is used to program the front end of the system which serves as the graphical environment for composing computation components. The components are Fortran modules that run on sequential servers or, with the help of MPI, on parallel systems. These modules are encapsulated with HPC++ <ref> [4] </ref>, which is a library based extension to C++ to support multi-threaded computation and remote method calls on distributed objects. In the construction of the LSA we were presented with the following problem.
Reference: [5] <author> D. Gannon, R. Bramley, T. Stuckey, J. Villacis, J. Balasubramanian, E. Akman, F. Breg, S. Diwan, and M. Govindaraju. </author> <title> Component architectures for distributed scientific problem solving. </title> <type> Technical report, </type> <institution> Indiana University, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: While some of the components in these systems will be built as Java clients and servers, many others will be built using Fortran and C++. In one such system, the Linear System Analyzer (LSA) <ref> [5] </ref>, about 22% of the source is Java, 15% is C++ and 63% is Fortran. Java is used to program the front end of the system which serves as the graphical environment for composing computation components.
Reference: [6] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and specification, </title> <month> July </month> <year> 1995. </year> <note> Revision 2.0. </note>
Reference-contexts: What is the best way for our Java application to communicate with remote objects written with HPC++? There were three obvious choices: 1. Use a low level socket model or simple RPC mechanisms built on that. 2. Use the emerging Java CORBA <ref> [6] </ref> standard. 1 3. Find a way to allow the Java programmer to use a subset of the standard Java Remote Method Invocation (RMI) mechanism that can interoperate with the corresponding HPC++ remote object model. Our first implementation followed the first solution, but that approach proved to be awkward.
Reference: [7] <author> Yutaka Ishikawa. </author> <title> Multiple threads template library. </title> <type> Technical Report TR-96-012, </type> <institution> Real World Computing Partnership, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: The central problem associated with multi-context computation is the communication and synchronization of events between two contexts. HPC++ is based on the CC++ [1] global pointer concept and the library implements this with a GlobalP tr &lt; T &gt; template as is done in the MPC++ Template Library <ref> [7] </ref>. A global pointer is a generalization of the C pointer type to support pointers to objects that exist in other address spaces. It is closely linked to the idea of a global reference which is an object that is a proxy for a remote object.
Reference: [8] <institution> JavaSoft. RMI, </institution> <year> 1997. </year> <note> in The JDK 1.1 Specification see http:// javasoft.com/ products/ jdk/1.1/ docs/guide/ rmi/index.html. 18 </note>
Reference-contexts: While it is extremely fast in some cases, it is subject to non-linear anomalies in others. We demonstrate that our Java-to-HPC++ prototype is able to avoid these performance problems. 2 A Java - HPC++ RMI System The Java RMI invocation system <ref> [8] </ref> has become a de facto standard for communication between different Java virtual machines (JVM). Java RMI provides a mechanism for making method invocations on Java objects residing in different virtual machines.
References-found: 8

