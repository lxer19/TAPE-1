URL: http://www.win.tue.nl/cs/pa/janz/concatenation.ps
Refering-URL: http://www.win.tue.nl/cs/pa/janz/publications.html
Root-URL: http://www.win.tue.nl
Email: e-mail janz@win.tue.nl  
Title: A Type System for Record Concatenation and Subtyping (Extended Abstract)  
Author: Jan Zwanenburg 
Address: P.O.Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Department of Mathematics and Computing Science Eindhoven University of Technology  
Abstract: We define an extension of a second-order type system with records, subtyping and record concatenation. This system can model the most important concepts of object-oriented languages. The novelty in our approach is that concatenation is only permitted if the types on common fields agree. We give examples of how object-oriented concepts can be modeled and show how the system can be translated to a type system without subtyping. 
Abstract-found: 1
Intro-found: 1
Reference: [AC95] <author> Martin Abadi and Luca Cardelli. </author> <title> On subtyping and matching. </title> <booktitle> In Nineth European Conference on Object-Oriented Programming, </booktitle> <pages> pages 145-167, </pages> <year> 1995. </year>
Reference-contexts: This means that a term of that type can only be applied to types that are a width-subtype of S. (This form of bounded quantification should not be confused with match-bounded quantification, e.g. in <ref> [AC95] </ref>.) The rule (LB) says the concatenation S 1 With S 2 is a subtype of both S 1 and S 2 , thus effectuating width-subtyping.
Reference: [BCGS91] <author> Val Breazu-Tannen, Thierry Coquand, Carl Gunter, and An-dre Scedrov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year>
Reference-contexts: CPointM [FinalR] super1 is well typed, because FinalR is both a subtype of and compatible with PointR. The transitivity laws for subtyping and compatibility are needed to derive this. 4 Translation In the style of <ref> [BCGS91] </ref>, we here give the translation of the most important constructs in our language to F fi , which is F with cartesian products. * [[T U ]] = [[T ]]![[U ]] This is fairly standard: a coercion from T to U is associated with the subtyping judgment T U .
Reference: [CD78] <author> M. Coppo and M. Dezani-Ciancaglini. </author> <title> A new type assignment for -terms. </title> <journal> Archiv Math. Logik, </journal> <volume> 19 </volume> <pages> 139-156, </pages> <year> 1978. </year>
Reference-contexts: Combined with rule (LB) it can be used to derive that records 3 with fields in a different order are equivalent (we don't identify them!). Note that (G) and (LB) are the basic subtyping rules for intersection types <ref> [CD78] </ref>. Depth-subtyping is possible because of (Depth). <p> Conclusion We defined an extension of F that can model multiple inheritance in a natural way. The concatenation is strong enough to implement the polymorphic record update, while the subtyping rules are very simple. In fact the concatenation shares these rules with intersection types <ref> [CD78] </ref>, so the proof of a number of meta-theoretical properties can easily be transferred. 7 Acknowledgements We would like to thank Benjamin Pierce and three anonymous referees for their helpful suggestions.
Reference: [CM91] <author> Luca Cardelli and John Mitchell. </author> <title> Operations on records. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 1 </volume> <pages> 3-48, </pages> <year> 1991. </year>
Reference-contexts: If this is the case, it is safe to extend the record with this field. Coupled with record restriction (removing a field), the polymorphic record update can be made <ref> [CM91] </ref>. However this demands more complex typing rules, while record concatenation is still impossible. In this paper, we present a system with concatenation and simple (sub)typing rules. By concatenating a record with a new value, the record can be updated, since the concatenation gives preference to the right hand side. <p> The main difference to F # is that their system does not include subtyping, which we feel is necessary for a natural encoding of objects. Cardelli and Mitchell present in <ref> [CM91] </ref> a system with subtyping. One important difference with our calculus is that subtyping is also used to express the absence of fields, instead of using the # relation.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: In this way rules for objects can be derived from the rules for their building blocks. Subtyping is then needed to handle records in a flexible way. In <ref> [CW85] </ref> Cardelli and Wegner defined a second-order, explicitly typed language with records, subtyping and bounded quantification, i.e. an abstraction over a type variable that has to be a subtype of some type. It turned out however, that this calculus was not powerful enough to model objects satisfactorily. <p> We conclude with related work and possible extensions of our calculus. 2 Calculus F # Our calculus is an extension of F , the second order lambda calculus with subtyping <ref> [CW85] </ref>. First, we give the interpretation of and # . * T U means that it is possible to convert a value of type T to a value of type U .
Reference: [HP91] <author> Robert Harper and Benjamin Pierce. </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> In Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 131-142, </pages> <year> 1991. </year>
Reference-contexts: This is used to implement a polymorphic record update. For both calculi, we will give the implementation corresponding to the following update in F # . R # fjx:Intjg: r:R: (r:R) with (fx=r:x + 1g:fjx:Intjg) :8R # fjx:Intjg: R!R Harper and Pierce give in <ref> [HP91] </ref> a calculus with record concatenation, and a compatibility relation # .
Reference: [HP96] <author> Martin Hofmann and Benjamin Pierce. </author> <title> Positive subtyping. </title> <journal> Information and Computation, </journal> <volume> 126(1) </volume> <pages> 11-33, </pages> <year> 1996. </year>
Reference-contexts: Such a function is called a polymorphic record update. 1 The second problem is caused by the fact that ordinary subtyping is too liberal, so it seems natural to restrict subtyping. This approach is taken in <ref> [HP96] </ref>, but it seems that for some programs still ordinary subtyping is needed. Another way to solve the problem is to introduce more powerful types, that express the absence of a field from a record. If this is the case, it is safe to extend the record with this field. <p> To solve the polymorphic update problem a new form of bounded quantification is introduced. The type variable must be both a subtype of, and compatible with, a certain record type, effectively imposing the same stringent form of subtyping as in <ref> [HP96] </ref>. In this way problems 1 and 2 are both solved without resorting to record restriction. Systems than can remove a field from a record are in some sense more powerful, but this power is not needed for encoding most concepts of OOP. <p> So if T and U are disjoint, the overwriter doesn't change t. This overwriter is a generalization of the update occurring in <ref> [HP96] </ref>, where U is always a part of T . * [[T With U ]] = [[T ]] fi [[U ]] So if T and U have fields in common, these fields will be represented twice.
Reference: [MHF93] <author> John C. Mitchell, Furio Honsell, and Kathleen Fisher. </author> <title> A lambda calculus of objects and method specialization. </title> <booktitle> In Eighth Symposium on Logic in Computer Science, </booktitle> <pages> pages 26-38, </pages> <year> 1993. </year>
Reference-contexts: Mitchell, Fisher and Honsell present in <ref> [MHF93] </ref> a calculus that has objects as primitives, instead of encoding them with records. In one respect their system resembles our calculus: a field of an object can be updated with a value of the same type. In this way, there is no need for record restriction. <p> Multiple inheritance cannot be modelled because record concatenation is not available. Remy proposes in [Rem92] an implicitly typed calculus with record concatenation. There is no subtyping, but the polymorphic record update is implemented with help of row-variables, that represent unknown fields. These row-variables also play an important role in <ref> [MHF93] </ref>. The next two calculi that we discuss are second-order explicitly typed systems. Both possess record restriction, denoted by n, so fields can be removed. This is used to implement a polymorphic record update.
Reference: [Pol94] <author> Erik Poll. </author> <title> A Programming Logic Based on Type Theory. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1994. </year>
Reference-contexts: Two approaches can be distinguished. Some prefer a calculus with objects as primitive, while others build objects with records. We choose for the latter approach, since our long-term goal is an object-oriented language and a programming logic both based on type theory <ref> [Pol94] </ref>. In this way rules for objects can be derived from the rules for their building blocks. Subtyping is then needed to handle records in a flexible way.
Reference: [PT94] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <year> 1994. </year>
Reference-contexts: We don't use recursive types, but a simple version of <ref> [PT94] </ref>; self-reference and encapsulation are left out. For lack of space, the explanation will be brief, [Zwa95] gives an extensive explanation.
Reference: [Rem92] <author> Didier Remy. </author> <title> Typing record concatenation for free. </title> <booktitle> In Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 166-176, </pages> <year> 1992. </year>
Reference-contexts: In this way, there is no need for record restriction. In other respects, however, there are big differences. They work with an implicit typing system, without subtyping. Multiple inheritance cannot be modelled because record concatenation is not available. Remy proposes in <ref> [Rem92] </ref> an implicitly typed calculus with record concatenation. There is no subtyping, but the polymorphic record update is implemented with help of row-variables, that represent unknown fields. These row-variables also play an important role in [MHF93]. The next two calculi that we discuss are second-order explicitly typed systems.
Reference: [Zwa95] <author> Jan Zwanenburg. </author> <title> Record concatenation with intersection types. </title> <type> Technical Report 95-34, </type> <institution> Eindhoven University of Technology, </institution> <year> 1995. </year> <note> Web address: http://www.win.tue.nl/ win/cs/csr/csr95.html 8 </note>
Reference-contexts: They also introduce the syntax; for a more rigorous treatment see <ref> [Zwa95] </ref>. The typing rules introduce one-field records, a concatenation operator and a special form of bounded quantification. <p> We don't use recursive types, but a simple version of [PT94]; self-reference and encapsulation are left out. For lack of space, the explanation will be brief, <ref> [Zwa95] </ref> gives an extensive explanation.
References-found: 12

