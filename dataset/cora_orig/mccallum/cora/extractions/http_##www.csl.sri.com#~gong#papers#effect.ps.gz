URL: http://www.csl.sri.com/~gong/papers/effect.ps.gz
Refering-URL: http://www.csl.sri.com/~gong/papers/pubs94.html
Root-URL: 
Title: On the Security Effectiveness of Cryptographic Protocols 1 On the Security Effectiveness of Cryptographic Protocols  
Author: Rajashekar Kailar Virgil D. Gligor Li Gong 
Keyword: Categories and Subject Descriptors: C.2.4 [Computer-Communication Networks]: General- Security and Protection, Distributed Systems; D.4.6 [Operating Systems]: Security and Protection authentication, cryptographic controls; K.6.5 [Management of Computing and Information Systems]: Security and Protection authentication; E.3 [Data]: Data Encryption. Key Words and Phrases: Security effectiveness, cryptographic protocol, cryptographic assumption, logic, dependency, threat countermeasure.  
Abstract: We introduce the notion of security effectiveness, illustrate its use in the context of cryptographic protocol analysis, and argue that it requires analysis of protocol property dependencies. We provide examples to show that, without dependency analysis, the use of some logics for cryptographic protocol analysis yields results that are inconsistent or unrealistic in practice. We identify several types of property dependencies whose use in protocol analysis methods can yield realistic analyses. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Bird, I. Gopal, A. Herzberg, P. Janson, S. Kutten, R. Molva, and M. Jung. </author> <title> Systematic design of two-party authentication protocols. </title> <journal> IEEE Journal on Selected Areas of Communications, </journal> <year> 1993. </year>
Reference-contexts: permit the simultaneous generation of the same nonce in two or more sessions, the freshness of message contents would depend on the fact that principals can identify the source which generates the On the Security Effectiveness of Cryptographic Protocols 13 nonce (e.g., an interleaved attack on the ISO protocol in <ref> [1] </ref>).
Reference: [2] <author> M. Burrows, M. Abadi, and R.M. Needham. </author> <title> A logic of authentication. </title> <type> Technical Report 39, </type> <institution> DEC Systems Research Center, </institution> <year> 1989. </year>
Reference-contexts: Engineering Department, University of Maryland, College Park, MD 20742. 2 SRI International, Computer Science Laboratory, 333 Ravenswood Avenue, Menlo Park, CA 94025. 3 Here, and in the rest of the paper, we will use the term logics and protocol analysis methods to refer primarily to the logics presented in references <ref> [2] </ref>, [10] and [11], or other similar logics. 2 Rajashekar Kailar, Virgil D. Gligor and Li Gong However, logics for the analysis of cryptographic protocols derive properties based on cryptographic assumptions about the underlying system. <p> In this section, we provide examples of protocol analyses using a fairly well understood logic <ref> [2] </ref> to illustrate the consequence of disregarding property dependencies on specific cryptographic properties. 4.1 Kerberos IV In the analysis of the Kerberos protocol using [2], the protocol is shown to achieve its goal, namely that of securely distributing session keys to the two parties A and B in the presence of <p> In this section, we provide examples of protocol analyses using a fairly well understood logic <ref> [2] </ref> to illustrate the consequence of disregarding property dependencies on specific cryptographic properties. 4.1 Kerberos IV In the analysis of the Kerberos protocol using [2], the protocol is shown to achieve its goal, namely that of securely distributing session keys to the two parties A and B in the presence of a hostile environment. <p> However, the results derived are dependent on the lifetime constraints of the long-term keys, and in particular, can be false if the number of available plaintext and ciphertext pairs are not limited by limiting the lifetime of those keys. We reproduce the simplified protocol description used in the analysis <ref> [2] </ref>. Protocol Description 1. A ! S : A; B 3. A ! B : fT s ; L; K ab ; Ag K bs ; fA; T a g K ab The notation fM g k denotes plaintext message M encrypted with key k. <p> The analysis shows that at the end of the protocol run, both A and B obtain beliefs about the source that generated the key K ab , and that K ab is a key that was not used prior to the start of the session <ref> [2] </ref>. This is represented as: A believes A K ab B believes A K ab The protocol, however, can be vulnerable to at least two types of attacks. For example, 1. <p> However, that protocol still depends on the strength of the ticket-granting server's long-term key; i.e., K T GS . The lifetime of this key can be limited appropriately.) 4.2 Needham-Schroeder Shared Key Protocol The analysis of the Needham-Schroeder protocol [16] using the BAN logic <ref> [2] </ref> indicates that the protocol falls short of its goals, namely that of distributing a fresh session key K ab to A and On the Security Effectiveness of Cryptographic Protocols 9 B, and in particular, causing the two parties to believe" that the key is fresh and was created by the <p> For example, the analysis of the Kerberos and Needham-Schroeder protocols above removes the first message from both protocols during the idealization step <ref> [2] </ref>. An assumption is made that a separate means of establishing the freshness of the second message exists [8]. <p> The purpose of the attack is that of obtaining plaintext-ciphertext pairs, which can lead to the eventual discovery and replay of that key. The simplified protocol description <ref> [2] </ref> for the Andrew Secure RPC handshake is shown below. Protocol Description 1. A ! B : A; fN a g K ab 3. <p> Possession of Session Key only by trusted parties: If this property is not supported, the source of an encrypted message cannot be identified with certainty. The property Freshness of Distributed Session Key is established using 1. Nonce Verification Rule <ref> [2] </ref>, and 2. Jurisdiction Rule [2]. Hence, the freshness of distributed session keys is dependent on the validity of these two rules. In some protocols (e.g., [16]), freshness of session keys is also dependent on the fact that old session keys are unbreakable. <p> Possession of Session Key only by trusted parties: If this property is not supported, the source of an encrypted message cannot be identified with certainty. The property Freshness of Distributed Session Key is established using 1. Nonce Verification Rule <ref> [2] </ref>, and 2. Jurisdiction Rule [2]. Hence, the freshness of distributed session keys is dependent on the validity of these two rules. In some protocols (e.g., [16]), freshness of session keys is also dependent on the fact that old session keys are unbreakable. <p> The validity of jurisdiction rule <ref> [2] </ref> in analyzing protocol messages is dependent on the 1. competence of the key generation source in generating random keys. 2. competence of the key generation source in preserving the secrecy of the key, and 3. the message meaning rule, since the former uses the latter to establish the message source. <p> Message meaning rule <ref> [2] </ref> can be applied for the analysis of protocol messages only if the sender of the message can be identified. Without message sender recognition, statements of the 14 Rajashekar Kailar, Virgil D. Gligor and Li Gong form X said M essage" cannot be derived.
Reference: [3] <author> P.-C. Cheng and V.D. Gligor. </author> <title> On the formal specification and verification of a multiparty session protocol. </title> <booktitle> IEEE Symposium on Research in Security and Privacy, </booktitle> <year> 1990. </year>
Reference-contexts: The invariants (P ) obtained by analyzing the system functions imply that specific threat properties (T ) are infeasible (i.e., P ) :T ) if the functions are implemented correctly. For example, the specification and verification of cryptographic protocols of <ref> [3] </ref> uses a state transition model whose semantics allow the specification of system function properties as well as properties of threats. In the formal policy model of [3], the notion of an intruder On the Security Effectiveness of Cryptographic Protocols 7 process formally models external threats. <p> For example, the specification and verification of cryptographic protocols of <ref> [3] </ref> uses a state transition model whose semantics allow the specification of system function properties as well as properties of threats. In the formal policy model of [3], the notion of an intruder On the Security Effectiveness of Cryptographic Protocols 7 process formally models external threats. Intruder actions (i.e., security threats) are modeled as state transforms which can be initiated by untrusted processes or intruder processes. The policy properties (P ) are restrictions enforced on state transforms.
Reference: [4] <author> D. Davis and R. Swick. </author> <title> Network security via private-key certificates. </title> <journal> ACM Operating Systems Review, </journal> <volume> 24(4), </volume> <month> October </month> <year> 1990. </year>
Reference-contexts: While it seems essential that the lifetimes of all long-term keys must be limited, the dependency of message secrecy on their non-derivability from the plaintext-ciphertext pairs may not exist in all protocols. For instance, the protocol proposed by Davis and Swick <ref> [4] </ref>, and implemented as the ENC TKT IN SKEY option of the Ticket Granting Server exchange in [14] eliminates this dependency by using limited lifetime session keys instead of the long-term keys, thereby reducing the amount of ciphertext that can be obtained using any one key (viz., [12]).
Reference: [5] <author> D.E. Denning and G.M. Sacco. </author> <title> Timestamps in key distribution protocols. </title> <journal> Communications of the ACM, </journal> <year> 1981. </year>
Reference-contexts: Replay of message 3 from a previous session would be successful only if the party which replays the message has also compromised the expired session key K ab (expired) <ref> [5] </ref>. Replay of message 3 without the knowledge of K ab (expired) would only allow the intruder (say X) to obtain fN b g K ab (expired) , but would not enable X to reply with fN b 1g K ab (expired) .
Reference: [6] <institution> Federal criteria for information technology security. </institution> <note> Vol. 1, Protection Profile Development, version 1.0, </note> <institution> National Institute of Standards and Technology and National Security Agency, </institution> <year> 1992. </year>
Reference-contexts: Figure 4 shows a graph which has properties (or assumptions) as its vertices and arcs showing dependencies. Cyclic dependencies are not illustrated because their elimination is reasonably well-understood <ref> [6] </ref>. The dependencies shown here are of two types - (policy) goal-specific and protocol-specific. The first type of dependencies (shown with straight arcs in Figure 4) appears in the analysis of all protocols that aim to establish specific (policy) goals (shown with dark ovals).
Reference: [7] <institution> Des modes of operation. Federal Information Processing Standard, National Bureau of Standards, </institution> <year> 1980. </year>
Reference-contexts: This is represented as: A believes A K ab B believes A K ab The protocol, however, can be vulnerable to at least two types of attacks. For example, 1. If encryption is performed using DES <ref> [7] </ref> (in Cipher Block Chaining mode since the text exceeds one block), party A can use all 2 56 values of keys K to encrypt known text fT s ; L; K ab ; Ag.
Reference: [8] <author> V.D. Gligor, R. Kailar, S.G. Stubblebine, and L. Gong. </author> <title> Logics for cryptographic protocols virtues and limitations. </title> <booktitle> IEEE Computer Security Foundations Workshop, </booktitle> <year> 1991. </year> <title> On the Security Effectiveness of Cryptographic Protocols 17 </title>
Reference-contexts: This axiomatization aids in comparing threat properties to those of the message integrity protection goals. 4 Examples of Protocol Dependencies In earlier work <ref> [8] </ref>, we noted that the logics for cryptographic protocols must ensure that whenever the required assumptions or policies are not satisfied by a protocol, the use of the logic's inference rules should fail to achieve desired, but unsupported, conclusions. <p> For example, the analysis of the Kerberos and Needham-Schroeder protocols above removes the first message from both protocols during the idealization step [2]. An assumption is made that a separate means of establishing the freshness of the second message exists <ref> [8] </ref>. For Kerberos, this assumption implies that (1) an authenticated source of time is available to all parties prior to running the authentication protocol; and (2) party A has a replay detection cache, and therefore has non-volatile memory, to verify the freshness of T s .
Reference: [9] <author> L. Gong. </author> <title> Variations on the themes of message freshness and replay. </title> <booktitle> IEEE Computer Security Foundations Workshop, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Message freshness may be established using (and hence, is dependent on) one or more of * Synchronous nature of clocks, * Randomness of strings (nonces), or * Monotonicity of timestamps. Depending on the types of replay threats assumed, the establishment of message freshness may have additional property dependencies <ref> [9] </ref>.
Reference: [10] <author> L. Gong, R. Needham, and R. Yahalom. </author> <title> Reasoning about beliefs in cryptographic protocols. </title> <booktitle> IEEE Computer Society Symposium on Research in Security and Privacy, </booktitle> <year> 1990. </year>
Reference-contexts: In the last few years, several logics have been proposed and have been used in the analysis of protocols to show that the protocols can (not) achieve certain goals ([2], <ref> [10] </ref>, [11]). The application of logics 3 allows one to derive properties which imply that certain threats are infeasible in the system. By doing this, one attempts to show that a protocol is effective in countering a specified (set of) threat (s). <p> Department, University of Maryland, College Park, MD 20742. 2 SRI International, Computer Science Laboratory, 333 Ravenswood Avenue, Menlo Park, CA 94025. 3 Here, and in the rest of the paper, we will use the term logics and protocol analysis methods to refer primarily to the logics presented in references [2], <ref> [10] </ref> and [11], or other similar logics. 2 Rajashekar Kailar, Virgil D. Gligor and Li Gong However, logics for the analysis of cryptographic protocols derive properties based on cryptographic assumptions about the underlying system.
Reference: [11] <author> R. Kailar and V.D. Gligor. </author> <title> On belief evolution in authentication protocols. </title> <booktitle> IEEE Computer Security Foundations Workshop, </booktitle> <year> 1991. </year>
Reference-contexts: In the last few years, several logics have been proposed and have been used in the analysis of protocols to show that the protocols can (not) achieve certain goals ([2], [10], <ref> [11] </ref>). The application of logics 3 allows one to derive properties which imply that certain threats are infeasible in the system. By doing this, one attempts to show that a protocol is effective in countering a specified (set of) threat (s). <p> of Maryland, College Park, MD 20742. 2 SRI International, Computer Science Laboratory, 333 Ravenswood Avenue, Menlo Park, CA 94025. 3 Here, and in the rest of the paper, we will use the term logics and protocol analysis methods to refer primarily to the logics presented in references [2], [10] and <ref> [11] </ref>, or other similar logics. 2 Rajashekar Kailar, Virgil D. Gligor and Li Gong However, logics for the analysis of cryptographic protocols derive properties based on cryptographic assumptions about the underlying system.
Reference: [12] <author> R. Kailar, V.D. Gligor, and L. Gong. </author> <title> On the security effectiveness of cryptographic protocols. </title> <type> Technical Report 93066, </type> <institution> Electrical Engineering Department, University of Maryland, College park, MD 20742, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: In section 4, we present a dependency graph that underlies much of the analyses and illustrate its use. Section 5 concludes this paper. Additional examples of protocol dependencies appear in <ref> [12] </ref>. On the Security Effectiveness of Cryptographic Protocols 3 2 Security Effectiveness In figure 1, we illustrate the intuitive notion of security effectiveness of a system. The figure shows a set of reachable system states U . Threats are properties of intruder actions in a given environment. <p> Davis and Swick [4], and implemented as the ENC TKT IN SKEY option of the Ticket Granting Server exchange in [14] eliminates this dependency by using limited lifetime session keys instead of the long-term keys, thereby reducing the amount of ciphertext that can be obtained using any one key (viz., <ref> [12] </ref>). However, that protocol still depends on the strength of the ticket-granting server's long-term key; i.e., K T GS . <p> Without this property, confidentiality cannot be established. In protocols which transmit plaintext messages, confidentiality is dependent on whether responses to plaintext messages are checked to see whether the plaintext was modified (e.g., <ref> [12] </ref>).
Reference: [13] <author> R. Kailar, V.D. Gligor, and S.G. Stubblebine. </author> <title> Reasoning about message integrity. </title> <booktitle> IFIP Conference on Dependable Computing for Critical Applications, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: If these restrictions are correctly enforced, the transforms that describe intruder actions are not permissible, and hence, the threat (s) due to these illegal" state transforms (i.e., which result in unsafe states) are countered. An example of implicit threat modeling can be found in <ref> [13] </ref>, where the properties of message integrity intruder actions are axiomatized in relation to the design parameters of message integrity protection mechanisms. <p> We briefly discuss both goal-specific and protocol-specific dependencies shown in the graph of Figure 4. In the dependency graph, the leaf nodes should be properties which can be related to actual design parameters (e.g., <ref> [13] </ref>). We begin at the root of the dependency graph and proceed towards the leaves. The property identity authentication using distributed session key or ticket is dependent on 1.
Reference: [14] <author> J. Kohl and B.C. Neuman. </author> <title> The kerberos network authentication service, </title> <type> draft (revision 5). </type> <institution> MIT Project Athena. </institution>
Reference-contexts: For instance, the protocol proposed by Davis and Swick [4], and implemented as the ENC TKT IN SKEY option of the Ticket Granting Server exchange in <ref> [14] </ref> eliminates this dependency by using limited lifetime session keys instead of the long-term keys, thereby reducing the amount of ciphertext that can be obtained using any one key (viz., [12]). However, that protocol still depends on the strength of the ticket-granting server's long-term key; i.e., K T GS .
Reference: [15] <author> S.M. Matyas. </author> <title> Key handling with control vectors. </title> <journal> IBM Systems Journal, </journal> <volume> 30(2), </volume> <year> 1991. </year>
Reference-contexts: In addition, in the Needham-Schroeder protocol, an intruder could not obtain known plaintext-ciphertext block pairs for a session key beyond a preset limit, if this limit is specified and enforced within the underlying system (e.g., within the cryptographic facility <ref> [15] </ref>). In contrast, the Andrew Secure RPC Protocol permits an intruder to obtain known plaintext-ciphertext pairs even beyond the limits set by the underlying system.
Reference: [16] <author> R.M. Needham and M.D. Schroeder. </author> <title> Using encryption for authentication in large networks of computers. </title> <journal> Communications of the ACM, </journal> <volume> 21(12), </volume> <month> December </month> <year> 1978. </year>
Reference-contexts: However, that protocol still depends on the strength of the ticket-granting server's long-term key; i.e., K T GS . The lifetime of this key can be limited appropriately.) 4.2 Needham-Schroeder Shared Key Protocol The analysis of the Needham-Schroeder protocol <ref> [16] </ref> using the BAN logic [2] indicates that the protocol falls short of its goals, namely that of distributing a fresh session key K ab to A and On the Security Effectiveness of Cryptographic Protocols 9 B, and in particular, causing the two parties to believe" that the key is fresh <p> The property Freshness of Distributed Session Key is established using 1. Nonce Verification Rule [2], and 2. Jurisdiction Rule [2]. Hence, the freshness of distributed session keys is dependent on the validity of these two rules. In some protocols (e.g., <ref> [16] </ref>), freshness of session keys is also dependent on the fact that old session keys are unbreakable. <p> Honesty of session members, and 3. Possession Assumption: All other ways in which the key can be compromised are very unlikely to succeed (e.g., accidentally chancing upon the right key.) In addition, in protocols which generate plaintext-ciphertext pairs (e.g., Needham-Schroeder Protocol generates plaintext-ciphertext pairs encrypted with long-term keys <ref> [16] </ref>), unbreakabil-ity of these keys is also dependent on non-derivability of keys from these pairs encrypted with the corresponding keys made available by the protocol message exchanges. Non-derivability of plaintext from ciphertext is dependent on non-derivability of the encryption key from ciphertext.
Reference: [17] <author> S.G. Stubblebine and V.D. Gligor. </author> <title> On message integrity in cryptographic protocols. </title> <booktitle> IEEE Symposium on Research and Privacy, </booktitle> <year> 1992. </year>
Reference-contexts: However, the presence of confounding text cannot prevent the intruder from obtaining known plaintext and ciphertext block pairs in the second attack. This is true because the presence of a confounder in the plaintext only affects its neighboring ciphertext block in Cipher Block Chaining mode <ref> [17] </ref>. However, from the complexity of the encryption algorithm and the size of the block cipher (i.e., those of DES in this case), a limit may be derived on N , the number of known plaintext-ciphertext block pairs required to uniquely determine the encryption key. <p> Unfortunately, this may not always be the case. For instance, in cipher-block chaining, message portions of known plaintext-ciphertext pairs can be spliced together to form new messages which pass checksum tests with high probability <ref> [17] </ref>. The contents of such spliced messages are not secret. Hence, secrecy is a function of whether integrity is preserved or not. 2. Non-derivability of plaintext: from the knowledge of ciphertext, without knowing the encryption key. 3.
Reference: [18] <author> M. Weiner. </author> <title> Cryptanalysis of short rsa secret exponents. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 36(3), </volume> <month> May </month> <year> 1990. </year>
Reference-contexts: Non-derivability of encryption key from plaintext-ciphertext pairs made available by the protocol messages is dependent on the limited availability of such pairs, and on the established minimum number of plaintext-ciphertext block pairs that are required to derive the key (e.g., <ref> [18] </ref>).
References-found: 18

