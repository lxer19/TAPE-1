URL: http://www.cs.iastate.edu/tech-reports/TR92-28d.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Subtyping, Modular Specification, and Modular Verification for Applicative Object-Oriented Programs  
Author: Gary T. Leavens and William E. Weihl TR #-d 
Keyword: verification, specification, supertype abstraction, subtype, message passing, polymorphism, type checking, modularity, soundness, object-oriented, abstract data type.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  
Note: and January, September 1994  
Date: September 1992, revised September, October 1993,  
Abstract: 1992 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications | Languages; D.2.4 [Software Engineering] Program Verification | Correctness proofs; D.3.3 [Programming Languages] Language Constructs | Abstract data types, procedures, functions, and subroutines; F.3.1 [Logics and Meanings of Programs] Specifying and verifying and reasoning about programs | logics of programs, pre- and post-conditions, specification techniques; F.3.2 [Logics and Meanings of Programs] Semantics of Programming Languages | algebraic approaches to semantics, denotational semantics. c fl Gary T. Leavens and William E. Weihl, 1992, 1993, 1994. All rights reserved. Much of this report will appear in Acta Informatica, and so the copyright for those portions will be assumed by the Springer-Verlag. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> America, P. </author> <title> Inheritance and subtyping in a parallel object-oriented language. </title> <editor> In Bezivin, J. et al., editors, </editor> <booktitle> ECOOP '87, European Conference on Object-Oriented Programming, Paris, France, </booktitle> <pages> pages 234-242, </pages> <address> New York, N.Y., </address> <month> June </month> <year> 1987. </year> <title> Springer-Verlag. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 276. </volume>
Reference-contexts: The notion of legal subtyping must even be stronger than the syntactic guarantee that the new type will not cause type checking (or "message not understood") errors (see, for example, [8]). It must instead be a behavioral notion, based on the specification of an abstract data type <ref> [1] </ref> [42] [40] [30] [15] [2] [44] [45]. (See Section 8 for a discussion of related work.) As an example of the distinction between legal subtyping and subclassing, consider two types IntSet and Interval, where Interval is a type of closed intervals of integers, and IntSet is a type of integer <p> For each type T, the relation R T includes both the identity relation on the abstract values of objects of type T and all relations R S such that S T; for example, the integer set f1g is related by R IntSet to itself and R Interval relates the interval <ref> [1; 2] </ref> to itself. Furthermore, the relationships compose transitively in the following sense: if S T and a R S b R T c, then a R T c. <p> Consider the relation R defined in example 3.20, with C substituted for A II . This R is not a simulation relation between C and C, because <ref> [1; 3] </ref> R IntSet f1; 2; 3g, but choose C ([1; 3]) = f1g (21) choose C (f1; 2; 3g) = f3g (22) and 1 is not related by R Int to 3. Furthermore, no simulation relation exists between C and itself. There are two main theorems about simulation relations. <p> P is partially correct with respect to SPEC 2 and p. 7 Proving Legal Subtyping from Specifications and Sound ness of Supertype Abstraction In this section we study the technical relationship between our definition of legal subtype relations and Meyer's [47, Section 11.1] [48, Sections 10.15 and 10.22] and America's <ref> [1] </ref> [2] definitions. (Similar definitions were proposed earlier by the designers of Trellis/Owl [55], and also figure in the recent work of Liskov and Wing [44] [45].) We first show how to adapt their technique for proving legal subtype relationships to our formalism. <p> combined into such formulas because the subtype inherits the instance variables and abbreviations from the supertype, and so the formulas are all in the language of the subtype. 8.3.2 America's formalization of Meyer's techniques Meyer's specification technique and his definition of legal subtyping has been studied more formally by America <ref> [1] </ref> [2]. Although America and de Boer have done work on formal verification [3], their verification logic handles pointers, aliasing, and object creation, but explicitly excludes subtyping and message passing. It is America's definition of legal sub-typing, based on behavioral specifications, which is most closely related to our work.
Reference: [2] <author> America, P. </author> <title> Designing an object-oriented programming language with behavioural subtyping. </title> <editor> In de Bakker, J. W., de Roever, W. P., and Rozenberg, G., editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: It must instead be a behavioral notion, based on the specification of an abstract data type [1] [42] [40] [30] [15] <ref> [2] </ref> [44] [45]. (See Section 8 for a discussion of related work.) As an example of the distinction between legal subtyping and subclassing, consider two types IntSet and Interval, where Interval is a type of closed intervals of integers, and IntSet is a type of integer sets. (Both types of objects <p> For each type T, the relation R T includes both the identity relation on the abstract values of objects of type T and all relations R S such that S T; for example, the integer set f1g is related by R IntSet to itself and R Interval relates the interval <ref> [1; 2] </ref> to itself. Furthermore, the relationships compose transitively in the following sense: if S T and a R S b R T c, then a R T c. <p> For example, to show (II; inBoth) ` true fs2 : IntSet create (Interval,2,5)g s2 eqSet <ref> [2; 5] </ref> (54) it suffices to show the following (II; inBoth) ` true fiv : Interval create (Interval,2,5)g iv eqSet [2; 5]: (55) Recall that the trait function "eqSet" is defined for combinations of IntSet and Interval arguments. So both triples make sense. <p> For example, to show (II; inBoth) ` true fs2 : IntSet create (Interval,2,5)g s2 eqSet <ref> [2; 5] </ref> (54) it suffices to show the following (II; inBoth) ` true fiv : Interval create (Interval,2,5)g iv eqSet [2; 5]: (55) Recall that the trait function "eqSet" is defined for combinations of IntSet and Interval arguments. So both triples make sense. <p> See [34] for details of the other rules. 6.2 Verification Examples Example 6.2 The way that the logic handles explicit use of subtyping is shown by the proof of the formula: (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fi : Int inBoth (s,iv)g i = 3 (62) where II is as in Example 2.1, s has nominal type IntSet, and iv has nominal type Interval. Both type specifications are used in the verification below, because the type Interval is used explicitly. <p> Proof: Since the second argument expression (iv) has a different nominal type from the formal specified for inBoth, the rule [call] is used first to obtain the following goal triple. (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fi (fun (s1,s2:IntSet) inBoth (s1,s2)) (s,iv)g i = 3 The rule [comb] then gives the following subgoals: (II; inBoth) ` (s1 eqSet f3g) ^ (s2 eqSet [2; 5]) fi inBoth (s1,s2)g i = 3 (64) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs1 sg s1 <p> inBoth, the rule [call] is used first to obtain the following goal triple. (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fi (fun (s1,s2:IntSet) inBoth (s1,s2)) (s,iv)g i = 3 The rule [comb] then gives the following subgoals: (II; inBoth) ` (s1 eqSet f3g) ^ (s2 eqSet [2; 5]) fi inBoth (s1,s2)g i = 3 (64) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs1 sg s1 eqSet f3g (65) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs2 : IntSet ivg s2 eqSet [2; 5] (66) The proof of the third <p> f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fi (fun (s1,s2:IntSet) inBoth (s1,s2)) (s,iv)g i = 3 The rule [comb] then gives the following subgoals: (II; inBoth) ` (s1 eqSet f3g) ^ (s2 eqSet [2; 5]) fi inBoth (s1,s2)g i = 3 (64) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs1 sg s1 eqSet f3g (65) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs2 : IntSet ivg s2 eqSet [2; 5] (66) The proof of the third subgoal is the most interesting of the three subgoals. <p> [comb] then gives the following subgoals: (II; inBoth) ` (s1 eqSet f3g) ^ (s2 eqSet <ref> [2; 5] </ref>) fi inBoth (s1,s2)g i = 3 (64) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs1 sg s1 eqSet f3g (65) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs2 : IntSet ivg s2 eqSet [2; 5] (66) The proof of the third subgoal is the most interesting of the three subgoals. The rule [up] is used to generate the following goal (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fiv2 : Interval ivg iv2 <p> ` (s1 eqSet f3g) ^ (s2 eqSet <ref> [2; 5] </ref>) fi inBoth (s1,s2)g i = 3 (64) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs1 sg s1 eqSet f3g (65) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs2 : IntSet ivg s2 eqSet [2; 5] (66) The proof of the third subgoal is the most interesting of the three subgoals. The rule [up] is used to generate the following goal (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fiv2 : Interval ivg iv2 eqSet [2; 5] (67) By the traits of <p> (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fs2 : IntSet ivg s2 eqSet [2; 5] (66) The proof of the third subgoal is the most interesting of the three subgoals. The rule [up] is used to generate the following goal (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fiv2 : Interval ivg iv2 eqSet [2; 5] (67) By the traits of II, the post-condition follows from the precondition conjoined with "iv2 eqSet iv" (s eqSet f3g) ^ (iv eqSet [2; 5]) ^ (iv2 eqSet iv) ) (iv2 eqSet [2; 5]) (68) so by the rule [conseq] it <p> fs2 : IntSet ivg s2 eqSet <ref> [2; 5] </ref> (66) The proof of the third subgoal is the most interesting of the three subgoals. The rule [up] is used to generate the following goal (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fiv2 : Interval ivg iv2 eqSet [2; 5] (67) By the traits of II, the post-condition follows from the precondition conjoined with "iv2 eqSet iv" (s eqSet f3g) ^ (iv eqSet [2; 5]) ^ (iv2 eqSet iv) ) (iv2 eqSet [2; 5]) (68) so by the rule [conseq] it suffices to prove Formula (67) with the antecedent <p> [up] is used to generate the following goal (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fiv2 : Interval ivg iv2 eqSet [2; 5] (67) By the traits of II, the post-condition follows from the precondition conjoined with "iv2 eqSet iv" (s eqSet f3g) ^ (iv eqSet [2; 5]) ^ (iv2 eqSet iv) ) (iv2 eqSet [2; 5]) (68) so by the rule [conseq] it suffices to prove Formula (67) with the antecedent in the above implication substituted for the post-condition. <p> inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fiv2 : Interval ivg iv2 eqSet [2; 5] (67) By the traits of II, the post-condition follows from the precondition conjoined with "iv2 eqSet iv" (s eqSet f3g) ^ (iv eqSet [2; 5]) ^ (iv2 eqSet iv) ) (iv2 eqSet [2; 5]) (68) so by the rule [conseq] it suffices to prove Formula (67) with the antecedent in the above implication substituted for the post-condition. <p> Using the rule [carry] "backwards", the conjunction of the pre-condition can be dropped from the post-condition, so it suffices to prove the following. (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fiv2 : Interval ivg iv2 eqSet iv (69) By the traits of II II ` ((s eqSet f3g) ^ (iv eqSet [2; 5])) ) true (70) so by the rule [conseq], it suffices to prove the following. (II; inBoth) ` true fiv2 : Interval ivg iv2 eqSet iv (71) <p> the conjunction of the pre-condition can be dropped from the post-condition, so it suffices to prove the following. (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fiv2 : Interval ivg iv2 eqSet iv (69) By the traits of II II ` ((s eqSet f3g) ^ (iv eqSet [2; 5])) ) true (70) so by the rule [conseq], it suffices to prove the following. (II; inBoth) ` true fiv2 : Interval ivg iv2 eqSet iv (71) By the traits of II II ` iv2 eqSet iv = iv eqSet iv ) iv2 eqSet iv (72) since "iv eqSet iv" <p> The first subgoal follows from the axiom [fcall] for inBoth and the subgoal's pre-condition. The key observation is that, by the traits of II, II ` ((i 2 s1) ^ (i 2 s2) ^ (s1 eqSet f3g) ^ (s2 eqSet <ref> [2; 5] </ref>)) ) (i = 3) (75) so by the rule [conseq] it suffices to prove the first subgoal with the antecedent of the above implication replacing the post-condition. <p> is partially correct with respect to SPEC 2 and p. 7 Proving Legal Subtyping from Specifications and Sound ness of Supertype Abstraction In this section we study the technical relationship between our definition of legal subtype relations and Meyer's [47, Section 11.1] [48, Sections 10.15 and 10.22] and America's [1] <ref> [2] </ref> definitions. (Similar definitions were proposed earlier by the designers of Trellis/Owl [55], and also figure in the recent work of Liskov and Wing [44] [45].) We first show how to adapt their technique for proving legal subtype relationships to our formalism. <p> The following theorem is the promised one that shows that if one can prove a subtype relation is legal according to Meyer's [47] [48] and America's definition <ref> [2] </ref>, then the subtype relation is a legal subtype relation by our definition. As stated above, the proof is not completely general, but does give at least one way to construct the appropriate algebra and simulation relation from the assumed method refinement condition and the assumed coercion (transfer) functions. <p> That is, one can reason about objects of subtypes as if they were objects of a supertype. The soundness of supertype abstraction also bears on the question of the extent to which our definition of legal subtype relations implies something like Meyer's [47] [48] and America's definitions <ref> [2] </ref> of subtypes? Are our definitions fundamentally equivalent? We believe that the answers to the above questions are "yes". <p> separation of the notions of inheritance and subtyping is a tool of great conceptual power in object-oriented programming, since it allows one to use inheritance to implement types in the most economical manner, and use subtyping to organize and reason about the use of types [58] [31] [30] [42] [15] <ref> [2] </ref>. The distinction between subtypes and subclasses is not just academic. If one passes an argument whose type is not a subtype of the expected formal argument type to a procedure, the procedure will not act as desired. <p> However, because of this difference in class operations, Interval is not a refinement of IntSet. On the other hand, whenever S is a refinement of T, then S must be a subtype of T. In his work on subtyping, America does not make a distinction between refinement and subtyping <ref> [2] </ref>. This is because in his language POOL-I, a type consists only of instance operations. Classes implement types and have class operations, but there is no hard and fast link between classes and types, since a type can be implemented by more than one class. <p> into such formulas because the subtype inherits the instance variables and abbreviations from the supertype, and so the formulas are all in the language of the subtype. 8.3.2 America's formalization of Meyer's techniques Meyer's specification technique and his definition of legal subtyping has been studied more formally by America [1] <ref> [2] </ref>. Although America and de Boer have done work on formal verification [3], their verification logic handles pointers, aliasing, and object creation, but explicitly excludes subtyping and message passing. It is America's definition of legal sub-typing, based on behavioral specifications, which is most closely related to our work.
Reference: [3] <author> America, P. and de Boer, F. </author> <title> A sound and complete proof theory for SPOOL. </title> <type> Technical Report 505, </type> <institution> Philips Research Laboratories, Nederlandse Philips Bedrijven B. V., </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: If E 1 and E 2 have different sorts, they may easily be either not equal or equal in different algebras. For example, in an algebra where the carrier set for each sort is disjoint from the other carrier sets, <ref> [[[3; 3] </ref> = f3g]] would be false. In an algebra where the carrier set Interval is a subset of the carrier set for IntSet, [[[3; 3] = f3g]] might be true. <p> For example, in an algebra where the carrier set for each sort is disjoint from the other carrier sets, <ref> [[[3; 3] </ref> = f3g]] would be false. In an algebra where the carrier set Interval is a subset of the carrier set for IntSet, [[[3; 3] = f3g]] might be true. Thus the formula "[3,3] = f3g" is not valid in all algebras that satisfy the set of type specifications II; this is one reason that Larch/LOAL specifications are restricted to subtype-constraining assertions. <p> Consider the relation R defined in example 3.20, with C substituted for A II . This R is not a simulation relation between C and C, because <ref> [1; 3] </ref> R IntSet f1; 2; 3g, but choose C ([1; 3]) = f1g (21) choose C (f1; 2; 3g) = f3g (22) and 1 is not related by R Int to 3. Furthermore, no simulation relation exists between C and itself. There are two main theorems about simulation relations. <p> Although America and de Boer have done work on formal verification <ref> [3] </ref>, their verification logic handles pointers, aliasing, and object creation, but explicitly excludes subtyping and message passing. It is America's definition of legal sub-typing, based on behavioral specifications, which is most closely related to our work.
Reference: [4] <author> Broy, M. </author> <title> A theory for nondeterminism, parallelism, </title> <journal> communication, and concurrency. Theoretical Computer Science, </journal> <volume> 45(1) </volume> <pages> 1-61, </pages> <year> 1986. </year>
Reference-contexts: Let v be the domain ordering on a carrier set. For sets of possible results, the ordering v E is defined so that Q v E R if for each q 2 Q there is some r 2 R such that q v r <ref> [4, Page 13] </ref>. Definition 3.4 (monotonic) A set-valued function g is monotonic if and only if for all ~q 1 , ~q 2 , if ~q 1 v ~q 2 , then g (~q 1 ) v E g (~q 2 ). <p> Although there are no facilities in LOAL itself for introducing nondeterminism, the addition of such facilities does not invalidate the results of this paper [34]. LOAL uses lazy evaluation for evaluating function arguments [56, Page 181] <ref> [4] </ref>. Because of lazy evaluation, functions need not be strict. However, each actual parameter is only evaluated once; hence formal parameters are not sources of nondeterminism. <p> The semantics of systems of mutually recursive LOAL functions is given by a sequence of approximations. Approximations are obtained by textually expanding recursive calls <ref> [4, Page 20] </ref>. Fix an algebra A.
Reference: [5] <author> Bruce, K. B. and Longo, G. </author> <title> A modest model of records, inheritance, and bounded quantification. </title> <editor> In Gurevich, Y., editor, </editor> <booktitle> Third Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 38-51. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1988. </year>
Reference-contexts: However, we also permit models where the carrier sets are not disjoint. Such models have been used by Cardelli and others to discuss subtyping [8] [6] <ref> [5] </ref> [21]. In such a model, when one is given a tuple of arguments to a trait function ~q, there may be no unique tuple of sorts ~ S such that ~q 2 A ~ S . <p> For example, to show (II; inBoth) ` true fs2 : IntSet create (Interval,2,5)g s2 eqSet <ref> [2; 5] </ref> (54) it suffices to show the following (II; inBoth) ` true fiv : Interval create (Interval,2,5)g iv eqSet [2; 5]: (55) Recall that the trait function "eqSet" is defined for combinations of IntSet and Interval arguments. So both triples make sense. <p> For example, to show (II; inBoth) ` true fs2 : IntSet create (Interval,2,5)g s2 eqSet <ref> [2; 5] </ref> (54) it suffices to show the following (II; inBoth) ` true fiv : Interval create (Interval,2,5)g iv eqSet [2; 5]: (55) Recall that the trait function "eqSet" is defined for combinations of IntSet and Interval arguments. So both triples make sense. <p> See [34] for details of the other rules. 6.2 Verification Examples Example 6.2 The way that the logic handles explicit use of subtyping is shown by the proof of the formula: (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fi : Int inBoth (s,iv)g i = 3 (62) where II is as in Example 2.1, s has nominal type IntSet, and iv has nominal type Interval. Both type specifications are used in the verification below, because the type Interval is used explicitly. <p> Proof: Since the second argument expression (iv) has a different nominal type from the formal specified for inBoth, the rule [call] is used first to obtain the following goal triple. (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fi (fun (s1,s2:IntSet) inBoth (s1,s2)) (s,iv)g i = 3 The rule [comb] then gives the following subgoals: (II; inBoth) ` (s1 eqSet f3g) ^ (s2 eqSet [2; 5]) fi inBoth (s1,s2)g i = 3 (64) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs1 sg s1 <p> inBoth, the rule [call] is used first to obtain the following goal triple. (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fi (fun (s1,s2:IntSet) inBoth (s1,s2)) (s,iv)g i = 3 The rule [comb] then gives the following subgoals: (II; inBoth) ` (s1 eqSet f3g) ^ (s2 eqSet [2; 5]) fi inBoth (s1,s2)g i = 3 (64) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs1 sg s1 eqSet f3g (65) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs2 : IntSet ivg s2 eqSet [2; 5] (66) The proof of the third <p> f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fi (fun (s1,s2:IntSet) inBoth (s1,s2)) (s,iv)g i = 3 The rule [comb] then gives the following subgoals: (II; inBoth) ` (s1 eqSet f3g) ^ (s2 eqSet [2; 5]) fi inBoth (s1,s2)g i = 3 (64) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs1 sg s1 eqSet f3g (65) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs2 : IntSet ivg s2 eqSet [2; 5] (66) The proof of the third subgoal is the most interesting of the three subgoals. <p> [comb] then gives the following subgoals: (II; inBoth) ` (s1 eqSet f3g) ^ (s2 eqSet <ref> [2; 5] </ref>) fi inBoth (s1,s2)g i = 3 (64) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs1 sg s1 eqSet f3g (65) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs2 : IntSet ivg s2 eqSet [2; 5] (66) The proof of the third subgoal is the most interesting of the three subgoals. The rule [up] is used to generate the following goal (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fiv2 : Interval ivg iv2 <p> ` (s1 eqSet f3g) ^ (s2 eqSet <ref> [2; 5] </ref>) fi inBoth (s1,s2)g i = 3 (64) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs1 sg s1 eqSet f3g (65) (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fs2 : IntSet ivg s2 eqSet [2; 5] (66) The proof of the third subgoal is the most interesting of the three subgoals. The rule [up] is used to generate the following goal (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fiv2 : Interval ivg iv2 eqSet [2; 5] (67) By the traits of <p> (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fs2 : IntSet ivg s2 eqSet [2; 5] (66) The proof of the third subgoal is the most interesting of the three subgoals. The rule [up] is used to generate the following goal (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fiv2 : Interval ivg iv2 eqSet [2; 5] (67) By the traits of II, the post-condition follows from the precondition conjoined with "iv2 eqSet iv" (s eqSet f3g) ^ (iv eqSet [2; 5]) ^ (iv2 eqSet iv) ) (iv2 eqSet [2; 5]) (68) so by the rule [conseq] it <p> fs2 : IntSet ivg s2 eqSet <ref> [2; 5] </ref> (66) The proof of the third subgoal is the most interesting of the three subgoals. The rule [up] is used to generate the following goal (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fiv2 : Interval ivg iv2 eqSet [2; 5] (67) By the traits of II, the post-condition follows from the precondition conjoined with "iv2 eqSet iv" (s eqSet f3g) ^ (iv eqSet [2; 5]) ^ (iv2 eqSet iv) ) (iv2 eqSet [2; 5]) (68) so by the rule [conseq] it suffices to prove Formula (67) with the antecedent <p> [up] is used to generate the following goal (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fiv2 : Interval ivg iv2 eqSet [2; 5] (67) By the traits of II, the post-condition follows from the precondition conjoined with "iv2 eqSet iv" (s eqSet f3g) ^ (iv eqSet [2; 5]) ^ (iv2 eqSet iv) ) (iv2 eqSet [2; 5]) (68) so by the rule [conseq] it suffices to prove Formula (67) with the antecedent in the above implication substituted for the post-condition. <p> inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fiv2 : Interval ivg iv2 eqSet [2; 5] (67) By the traits of II, the post-condition follows from the precondition conjoined with "iv2 eqSet iv" (s eqSet f3g) ^ (iv eqSet [2; 5]) ^ (iv2 eqSet iv) ) (iv2 eqSet [2; 5]) (68) so by the rule [conseq] it suffices to prove Formula (67) with the antecedent in the above implication substituted for the post-condition. <p> Using the rule [carry] "backwards", the conjunction of the pre-condition can be dropped from the post-condition, so it suffices to prove the following. (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fiv2 : Interval ivg iv2 eqSet iv (69) By the traits of II II ` ((s eqSet f3g) ^ (iv eqSet [2; 5])) ) true (70) so by the rule [conseq], it suffices to prove the following. (II; inBoth) ` true fiv2 : Interval ivg iv2 eqSet iv (71) <p> the conjunction of the pre-condition can be dropped from the post-condition, so it suffices to prove the following. (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet <ref> [2; 5] </ref>) fiv2 : Interval ivg iv2 eqSet iv (69) By the traits of II II ` ((s eqSet f3g) ^ (iv eqSet [2; 5])) ) true (70) so by the rule [conseq], it suffices to prove the following. (II; inBoth) ` true fiv2 : Interval ivg iv2 eqSet iv (71) By the traits of II II ` iv2 eqSet iv = iv eqSet iv ) iv2 eqSet iv (72) since "iv eqSet iv" <p> The first subgoal follows from the axiom [fcall] for inBoth and the subgoal's pre-condition. The key observation is that, by the traits of II, II ` ((i 2 s1) ^ (i 2 s2) ^ (s1 eqSet f3g) ^ (s2 eqSet <ref> [2; 5] </ref>)) ) (i = 3) (75) so by the rule [conseq] it suffices to prove the first subgoal with the antecedent of the above implication replacing the post-condition.
Reference: [6] <author> Bruce, K. B. and Wegner, P. </author> <title> An algebraic model of subtype and inheritance. </title> <editor> In Ban~cilhon, F. and Buneman, P., editors, </editor> <booktitle> Advances in Database Programming Languages, </booktitle> <pages> pages 75-96. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Less importantly, we present a model theory for specifications that generalizes the work of [53] and <ref> [6] </ref>. Our simulation relations are tailored to handle incomplete specifications and are preserved by assertions in Larch/LOAL and by LOAL expressions and programs. Simulation relations are the main technical tool used to define legal subtype relations. Note, however, that we only deal with first-order 2 , immutable, abstract data types. <p> However, we also permit models where the carrier sets are not disjoint. Such models have been used by Cardelli and others to discuss subtyping [8] <ref> [6] </ref> [5] [21]. In such a model, when one is given a tuple of arguments to a trait function ~q, there may be no unique tuple of sorts ~ S such that ~q 2 A ~ S . <p> W, for all trait function symbols f such that ResSort (f; ~ U) is defined, SPEC j= to ResSort (f; ~ U) (f (~w)) = f (to ~ U (~w)): (119) The requirement of a legal system of coercion functions resembles requirements used by Reynolds [53] and Bruce and Wegner <ref> [6] </ref>. America does not have these exact requirements, because his definition of subtyping is not concerned with modular specification, and thus makes no restrictions on how the abstract values of types are specified. <p> His transfer functions, which map the abstract values of subtypes to the abstract values of supertypes, are similar to our simulation relations. Simulation relations, since they need not be functions, are more general than transfer functions [57], and the coercion functions of [53] and <ref> [6] </ref>. Larch/LOAL gives form to the expression of such relations on abstract values. The technical relationship between our definition and America's is the subject of Sec 87 tion 7. 8.3.3 Comparisons to America's Specification Techniques America's work provides both a definition of legal subtyping and a specification method.
Reference: [7] <author> Burstall, R. M. and Goguen, J. A. </author> <title> Algebras, theories and freeness: An introduction for computer scientists. </title> <editor> In Broy, M. and Schmidt, G., editors, </editor> <booktitle> Theoretical Foundations of Programming Methodology: Lecture Notes of an International Summer School directed by F. </booktitle> <editor> L. Bauer, E. W. Dijkstra and C. A. R. </editor> <booktitle> Hoare, volume 91 of series C, </booktitle> <pages> pages 329-348. </pages> <address> D. Ridel, Dordrecht, Holland, </address> <year> 1982. </year>
Reference-contexts: Technically, the specifier states that there are not two distinct Crowd abstract values of size 2 containing 2 and 3 by specifying in the trait CrowdTrait that the abstract values of Crowd objects are generated 6 ; i.e., there is "no junk" <ref> [7] </ref>. Our simulation relations preserve a specification of "no junk" because they must relate every element of a subtype to some element of each supertype in one algebra.
Reference: [8] <author> Cardelli, L. </author> <title> A semantics of multiple inheritance. </title> <editor> In G. Kahn, D. B. M. and Plotkin, G., editors, </editor> <booktitle> Semantics of Data Types: International Symposium, Sophia-Antipolis, France, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 51-66. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> June </month> <year> 1984. </year> <note> A revised version of this paper appears in Information and Computation, </note> <institution> volume 76, </institution> <type> numbers 2/3, </type> <pages> pages 138-164, </pages> <month> February/March </month> <year> 1988. </year>
Reference-contexts: The notion of legal subtyping must even be stronger than the syntactic guarantee that the new type will not cause type checking (or "message not understood") errors (see, for example, <ref> [8] </ref>). <p> However, we also permit models where the carrier sets are not disjoint. Such models have been used by Cardelli and others to discuss subtyping <ref> [8] </ref> [6] [5] [21]. In such a model, when one is given a tuple of arguments to a trait function ~q, there may be no unique tuple of sorts ~ S such that ~q 2 A ~ S . <p> The above example also shows the difference between our models, which allow disjoint carrier sets for subtypes, and models that require the carrier set of a supertype to include the carrier set of each of its subtypes <ref> [8] </ref> [21]. <p> The notion of an expression's nominal type is similar to Reynolds's notion of the minimal type of an expression [53] [54]. Like Reynolds, each type-safe expression is given a single nominal type. This is in contrast to type systems with a rule of subsumption, such as Cardelli's <ref> [8] </ref>, where expressions have multiple types. As with Reynolds's system, the nominal type of an if expression is the least upper bound of the nominal types of the arms, if the least upper bound exists. <p> The most important property of the definition of legal subtype relations is that it allows abstract types to be compared, based on their specifications. This is in contrast with the work of Cardelli and others, which only described subtype relationships for a syntactically characterized set of built-in types <ref> [8] </ref>. 8 Cardelli's landmark paper gives rules for what 8 While existential types used by Mitchell, Cardelli and others [50] [10] [9] are sometimes said to describe abstract data types, they do not characterize the behavior of such types.
Reference: [9] <author> Cardelli, L. </author> <title> Structural subtyping and the notion of power type. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, Calif., </address> <pages> pages 70-79. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1988. </year>
Reference-contexts: This is in contrast with the work of Cardelli and others, which only described subtype relationships for a syntactically characterized set of built-in types [8]. 8 Cardelli's landmark paper gives rules for what 8 While existential types used by Mitchell, Cardelli and others [50] [10] <ref> [9] </ref> are sometimes said to describe abstract data types, they do not characterize the behavior of such types. An existential type only describes the syntactic interface of an abstract data type.
Reference: [10] <author> Cardelli, L. and Wegner, P. </author> <title> On understanding types, data abstraction and polymor-phism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: This is in contrast with the work of Cardelli and others, which only described subtype relationships for a syntactically characterized set of built-in types [8]. 8 Cardelli's landmark paper gives rules for what 8 While existential types used by Mitchell, Cardelli and others [50] <ref> [10] </ref> [9] are sometimes said to describe abstract data types, they do not characterize the behavior of such types. An existential type only describes the syntactic interface of an abstract data type.
Reference: [11] <author> Chen, J. </author> <title> The Larch/Generic interface language. </title> <type> Technical report, </type> <institution> Massachusetts Institute of Technology, EECS department, </institution> <month> May </month> <year> 1989. </year> <note> The author's Bachelor's thesis. Available from John Guttag at MIT (guttag@lcs.mit.edu). 91 </note>
Reference-contexts: eqSet s 2 ) == (s 1 = s 2 ) isEmpty (s 1 ) == (s 1 = fg) 2 Polymorphic Type Specifications The interface specification language Larch/LOAL is adapted from Wing's interface specification language for CLU [64] [43, Chapter 10] [24] [63] and Chen's Larch/Generic interface specification language <ref> [11] </ref>. However, unlike Larch/CLU, Larch/LOAL specifications deal only with immutable types. An interface specification describes both the behavior of abstract types and how they can be used in a program [33] [26]. In Larch/LOAL, the interface describes how a LOAL program can use the types.
Reference: [12] <author> Cheon, Y. Larch/Smalltalk: </author> <title> A specification language for Smalltalk. </title> <type> Technical Re--port 91-15, </type> <institution> Department of Computer Science, Iowa State University, Ames, IA, </institution> <month> June </month> <year> 1991. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Our point is that these techniques are of no more concern to a client than the data structures used to implement the specification <ref> [12] </ref>. 6 CrowdTrait specifies that the abstract values are generated because it includes the trait IntSetTrait, which includes the trait SetBasics from the LSL Handbook [26, Page 166], which has a generated by clause. 39 LFPSchd immutable type subtype of Crowd by c simulates toCrowd (c) class ops [new] instance ops
Reference: [13] <author> Cook, S. A. </author> <title> Soundness and completeness of an axiom system for program verification. </title> <journal> SIAM Journal on Computing, </journal> <volume> 7 </volume> <pages> 70-90, </pages> <year> 1978. </year>
Reference-contexts: We have also extended these techniques to higher-order functions [37]. The main limitation to bear in mind is that the verification technique has not been proved relatively complete <ref> [13] </ref> [46, Section 8.2]. This means, for example, that ours may not be the only way to prove the correctness of object-oriented programs, and that, even for types with immutable objects, ours may not be the best definition of legal subtype relations.
Reference: [14] <author> Cook, W. R. </author> <title> Object-oriented programming versus abstract data types. </title> <editor> In de Bakker, J. W., de Roever, W. P., and Rozenberg, G., editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 151-178. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: The trait function "choice" must do the same thing, but because "choice" is not used in the specification of LFPSchd's choose operation, the construction still produces a (LFPSchd + Crowd)-algebra. 5 The implementor may have good reasons for wanting multiple code modules to be used in an implementation <ref> [14] </ref>, as in Smalltalk where the Boolean is implemented by 3 classes [22].
Reference: [15] <author> Cook, W. R., Hill, W. L., and Canning, P. S. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, California, </address> <pages> pages 125-135, </pages> <month> January </month> <year> 1990. </year> <note> Also STL-89-17, </note> <institution> Software Technology Laboratory, Hewlett-Packard Laboratories, Palo Alto, Calif., </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: It must instead be a behavioral notion, based on the specification of an abstract data type [1] [42] [40] [30] <ref> [15] </ref> [2] [44] [45]. (See Section 8 for a discussion of related work.) As an example of the distinction between legal subtyping and subclassing, consider two types IntSet and Interval, where Interval is a type of closed intervals of integers, and IntSet is a type of integer sets. (Both types of <p> clear separation of the notions of inheritance and subtyping is a tool of great conceptual power in object-oriented programming, since it allows one to use inheritance to implement types in the most economical manner, and use subtyping to organize and reason about the use of types [58] [31] [30] [42] <ref> [15] </ref> [2]. The distinction between subtypes and subclasses is not just academic. If one passes an argument whose type is not a subtype of the expected formal argument type to a procedure, the procedure will not act as desired.
Reference: [16] <author> Dhara, K. K. </author> <title> Subtyping among mutable types in object-oriented programming languages. </title> <type> Master's thesis, </type> <institution> Iowa State University, Department of Computer Science, Ames, Iowa, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: However, these formal limitations should not all be taken as fundamental weaknesses. We believe that our techniques can be extended to handle mutation and assignment, and work is in progress to do so <ref> [16] </ref> [17]. We have also extended these techniques to higher-order functions [37]. The main limitation to bear in mind is that the verification technique has not been proved relatively complete [13] [46, Section 8.2].
Reference: [17] <author> Dhara, K. K. and Leavens, G. T. </author> <title> Subtyping for mutable types in object-oriented programming languages. </title> <type> Technical Report 92-36, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, November </month> <year> 1992. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Simulation relations are the main technical tool used to define legal subtype relations. Note, however, that we only deal with first-order 2 , immutable, abstract data types. Subtyping for mutable types (types whose objects have time-varying state) is still a subject of research <ref> [17] </ref> [44] [45]. <p> However, these formal limitations should not all be taken as fundamental weaknesses. We believe that our techniques can be extended to handle mutation and assignment, and work is in progress to do so [16] <ref> [17] </ref>. We have also extended these techniques to higher-order functions [37]. The main limitation to bear in mind is that the verification technique has not been proved relatively complete [13] [46, Section 8.2].
Reference: [18] <author> Ehrig, H. and Mahr, B. </author> <title> Fundamentals of Algebraic Specification 1: Equations and Initial Semantics. </title> <booktitle> EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1985. </year>
Reference-contexts: They are mathematical abstractions of the objects and procedures of the code that one would write to implement such type specifications. For brevity, we call algebraic models algebras. Our algebras are an extension of the usual algebraic structures found in the study of equational logic or algebraic specifications <ref> [18] </ref>. As such, an algebra includes a carrier set and a set of trait functions; to these are added a set of methods. <p> Thus we will assume from now on that the visible types are the same in all algebras. To state this assumption precisely requires the notion of the reduct of an algebra <ref> [18, Section 6.8] </ref> [34]. Briefly, the reduct A ( 0 ) has as its carrier sets the carrier sets of the sorts in A that appear in 0 , and as its trait functions and methods those named in 0 . <p> The denotation of an identifier forms one basis for the inductive definition of the evalua-tion of assertions. (The other basis is the meaning of a constant, which is directly interpreted by an algebra.) We inductively extend the environment to a map from terms to abstract values in the standard way <ref> [18, Section 1.10] </ref>. The notation means the extension of the -environment : X ! jAj to a mapping from -terms to jAj.
Reference: [19] <author> Enderton, H. B. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, Inc., </publisher> <address> Orlando, Florida, </address> <year> 1972. </year>
Reference-contexts: Since [[1 2 s]] = true, (A II ; ) j= 1 2 s. Since [[4 2 s]] = false, (A II ; ) does not model "4 2 s." The above definition of "models" specializes to the standard definition <ref> [19] </ref> when the subtype relation is equality (=). 3.2.4 Satisfaction for Type Specifications We give a "loose" semantics to type specifications. That is, the meaning of a set of type specifications is a family of algebras with the same signature. <p> to these domains. (The trait functions are well-defined on carrier sets without ? because they are strict and their result is only ? when one of their arguments is ?.) There is a standard notion of when something like a trait structure satisfies a set of sentences in second-order logic <ref> [19] </ref>, and the formal semantics of the Larch Shared Language (LSL) provides a translation into such sentences [27]. (The generated by and partitioned by constructs in LSL are translated into second-order sentences.) Hence the following.
Reference: [20] <author> Goguen, J. A. </author> <title> Parameterized programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(5):528-543, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: back and reverify the implementation of inBoth when it becomes possible to pass it arguments of type Interval? The standard technique used to specify a polymorphic module is to specify the behavior of the operations that the polymorphic module needs to do its work [25, Page 21] [64, Section 4.2.3] <ref> [20, Page 537] </ref>. The specification of such operations is often collected into the specification of a "type parameter". For example, roughly following Goguen, one might specify the function inBoth as in Figure 3.
Reference: [21] <author> Goguen, J. A. and Meseguer, J. </author> <title> Order-sorted algebra solves the constructor-selector, multiple representation and coercion problems. </title> <type> Technical Report CSLI-87-92, </type> <institution> Center for the Study of Language and Information, </institution> <month> March </month> <year> 1987. </year> <booktitle> Appears in Second Annual Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <month> June, </month> <year> 1987, </year> <pages> pages 18-29. </pages>
Reference-contexts: Another way to avoid the work of defining the trait functions that apply to the supertype for the subtype would be to use a language for specifying abstract values that had an explicit notion of subsorts; for example, one might use order-sorted algebra <ref> [21] </ref>. 2.3 Type Specifications Examples of Larch/LOAL type specifications are given in Figures 7 and 10. <p> However, we also permit models where the carrier sets are not disjoint. Such models have been used by Cardelli and others to discuss subtyping [8] [6] [5] <ref> [21] </ref>. In such a model, when one is given a tuple of arguments to a trait function ~q, there may be no unique tuple of sorts ~ S such that ~q 2 A ~ S . <p> The above example also shows the difference between our models, which allow disjoint carrier sets for subtypes, and models that require the carrier set of a supertype to include the carrier set of each of its subtypes [8] <ref> [21] </ref>.
Reference: [22] <author> Goldberg, A. and Robson, D. </author> <title> Smalltalk-80, The Language and its Implementation. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: The problem with the specification of Figure 3 is that to check that an instantiation is correct during design or verification, the actual type parameter must be statically shown to satisfy the formal's specification. In a language with message passing, such as Smalltalk-80 <ref> [22] </ref> or LOAL, the actual type parameter cannot, in general, be uniquely determined during design or verification. One might try an exhaustive case analysis by doing the verification for each possible type parameter. However, this case analysis would have to be extended when new subtypes are added to the program. <p> because "choice" is not used in the specification of LFPSchd's choose operation, the construction still produces a (LFPSchd + Crowd)-algebra. 5 The implementor may have good reasons for wanting multiple code modules to be used in an implementation [14], as in Smalltalk where the Boolean is implemented by 3 classes <ref> [22] </ref>. <p> We call this kind of reasoning supertype abstraction. We believe that good object-oriented programmers use supertype abstraction to reason about their programs, hence they speak of protocols common to different types of objects <ref> [22] </ref>. The main pitfall in common use of supertype abstraction is failing to ensure that one's subtype relation is legal. Having a legal subtype relation allows one to safely use supertype abstraction in reasoning about a program that uses message passing.
Reference: [23] <author> Gratzer, G. </author> <title> Universal Algebra. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1979. </year>
Reference-contexts: A continuous method will be defined as preserving least upper bounds of sequences. A sequence in v is a nonempty set Q = fq i j i 2 Ig indexed by some well-ordered set <ref> [23, Page12] </ref> I (whose elements are ordered by ) with the property that, if i j, then q i v q j .
Reference: [24] <author> Guttag, J. V., Horning, J. J., and Wing, J. M. </author> <title> Larch in five easy pieces. </title> <type> Technical Report 5, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> July </month> <year> 1985. </year> <title> Order from src-report@src.dec.com. </title> <type> 92 </type>
Reference-contexts: 1 , s 2 : C (s 1 eqSet s 2 ) == (s 1 = s 2 ) isEmpty (s 1 ) == (s 1 = fg) 2 Polymorphic Type Specifications The interface specification language Larch/LOAL is adapted from Wing's interface specification language for CLU [64] [43, Chapter 10] <ref> [24] </ref> [63] and Chen's Larch/Generic interface specification language [11]. However, unlike Larch/CLU, Larch/LOAL specifications deal only with immutable types. An interface specification describes both the behavior of abstract types and how they can be used in a program [33] [26].
Reference: [25] <author> Guttag, J. </author> <title> Notes on type abstractions (version 2). </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):13-23, </volume> <month> January </month> <year> 1980. </year> <title> Version 1 in Proceedings Specifications of Reliable Software, </title> <address> Cambridge, Mass., </address> <publisher> IEEE, </publisher> <month> April, </month> <year> 1979. </year>
Reference-contexts: Does one have to go back and reverify the implementation of inBoth when it becomes possible to pass it arguments of type Interval? The standard technique used to specify a polymorphic module is to specify the behavior of the operations that the polymorphic module needs to do its work <ref> [25, Page 21] </ref> [64, Section 4.2.3] [20, Page 537]. The specification of such operations is often collected into the specification of a "type parameter". For example, roughly following Goguen, one might specify the function inBoth as in Figure 3.
Reference: [26] <author> Guttag, J. V., Horning, J. J., Garland, S., Jones, K., Modet, A., and Wing, J. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: Terms in Larch/LOAL are composed of identifiers, "=", and various trait functions, such as 2 for the values of IntSet. The trait functions come from the traits of the Larch Shared Language <ref> [26] </ref>. We require that each trait function defined on arguments of a supertype be overloaded for each possible subtype. In this way we can give a meaning to function and type specifications that is independent of any assumption of legal subtyping. <p> However, unlike Larch/CLU, Larch/LOAL specifications deal only with immutable types. An interface specification describes both the behavior of abstract types and how they can be used in a program [33] <ref> [26] </ref>. In Larch/LOAL, the interface describes how a LOAL program can use the types. <p> The program sees a polymorphic method, which is implemented by the operations of all the abstract types with the same name and number of arguments. 2.1 Traits Larch/LOAL specifications describe behavior in terms of the abstract values of objects [29] [43] [35] <ref> [26] </ref>. In Larch/LOAL, the abstract values of objects are specified by a trait written in the Larch Shared Language [28] [27] [26]. (The Larch Shared language is used by Larch/LOAL, but is a distinct language. Both are distinct from LOAL itself. <p> all the abstract types with the same name and number of arguments. 2.1 Traits Larch/LOAL specifications describe behavior in terms of the abstract values of objects [29] [43] [35] <ref> [26] </ref>. In Larch/LOAL, the abstract values of objects are specified by a trait written in the Larch Shared Language [28] [27] [26]. (The Larch Shared language is used by Larch/LOAL, but is a distinct language. Both are distinct from LOAL itself. <p> The trait IntSetTrait defines the usual notation for sets. It does this by importing the trait Set found in the Larch Shared Language Handbook <ref> [26, Appendix A] </ref>, renaming the sort "E" in Set to "Int" in IntSetTrait. (A sort is a name for a kind of abstract value, which may be defined by a trait.) In IntSetTrait the names and signatures of additional trait functions are described after the keyword introduces. <p> As such, an algebra includes a carrier set and a set of trait functions; to these are added a set of methods. The trait functions are used to generate the carrier sets as specified in the used traits <ref> [26] </ref>; they are also used in the evaluation of the assertions used in specifications [64, Chapter 2]. The methods are used by LOAL programs for computation. The trait functions cannot be invoked by programs, and the methods cannot be used in specifications. <p> Our point is that these techniques are of no more concern to a client than the data structures used to implement the specification [12]. 6 CrowdTrait specifies that the abstract values are generated because it includes the trait IntSetTrait, which includes the trait SetBasics from the LSL Handbook <ref> [26, Page 166] </ref>, which has a generated by clause. 39 LFPSchd immutable type subtype of Crowd by c simulates toCrowd (c) class ops [new] instance ops [ins, elem, choose, size, remove, leastFirst] based on sort C from PSchdTrait op new (c:LFPSchdClass) returns (p:LFPSchd) ensures p eqPSchd [true, fg] op ins (p:LFPSchd,
Reference: [27] <author> Guttag, J. V., Horning, J. J., and Modet, A. </author> <title> Report on the Larch Shared Language: Version 2.3. </title> <type> Technical Report 58, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> April </month> <year> 1990. </year> <title> Order from src-report@src.dec.com. </title>
Reference-contexts: In Larch/LOAL, the abstract values of objects are specified by a trait written in the Larch Shared Language [28] <ref> [27] </ref> [26]. (The Larch Shared language is used by Larch/LOAL, but is a distinct language. Both are distinct from LOAL itself. <p> An hassertioni is a boolean-valued term. A term is boolean-valued if its sort is boolean, as described in Section 3.2.1. The concrete syntax of terms is simplified from the Larch Shared Language <ref> [27] </ref>. Essentially, terms are as in the predicate calculus with equality, over the language of the traits. <p> and their result is only ? when one of their arguments is ?.) There is a standard notion of when something like a trait structure satisfies a set of sentences in second-order logic [19], and the formal semantics of the Larch Shared Language (LSL) provides a translation into such sentences <ref> [27] </ref>. (The generated by and partitioned by constructs in LSL are translated into second-order sentences.) Hence the following.
Reference: [28] <author> Guttag, J. V., Horning, J. J., and Wing, J. M. </author> <title> The Larch family of specification languages. </title> <journal> IEEE Software, </journal> <volume> 2(4), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: In Larch/LOAL, the abstract values of objects are specified by a trait written in the Larch Shared Language <ref> [28] </ref> [27] [26]. (The Larch Shared language is used by Larch/LOAL, but is a distinct language. Both are distinct from LOAL itself.
Reference: [29] <author> Hoare, C. A. R. </author> <title> Notes on data structuring. </title> <editor> In Ole-J. Dahl, E. D. and Hoare, C. A. R., editors, </editor> <booktitle> Structured Programming, </booktitle> <pages> pages 83-174. </pages> <publisher> Academic Press, Inc., </publisher> <address> New York, N.Y., </address> <year> 1972. </year>
Reference-contexts: The program sees a polymorphic method, which is implemented by the operations of all the abstract types with the same name and number of arguments. 2.1 Traits Larch/LOAL specifications describe behavior in terms of the abstract values of objects <ref> [29] </ref> [43] [35] [26]. In Larch/LOAL, the abstract values of objects are specified by a trait written in the Larch Shared Language [28] [27] [26]. (The Larch Shared language is used by Larch/LOAL, but is a distinct language. Both are distinct from LOAL itself.
Reference: [30] <author> LaLonde, W. R. </author> <title> Designing families of data types using exemplars. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(2) </volume> <pages> 212-248, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: It must instead be a behavioral notion, based on the specification of an abstract data type [1] [42] [40] <ref> [30] </ref> [15] [2] [44] [45]. (See Section 8 for a discussion of related work.) As an example of the distinction between legal subtyping and subclassing, consider two types IntSet and Interval, where Interval is a type of closed intervals of integers, and IntSet is a type of integer sets. (Both types <p> hand, a clear separation of the notions of inheritance and subtyping is a tool of great conceptual power in object-oriented programming, since it allows one to use inheritance to implement types in the most economical manner, and use subtyping to organize and reason about the use of types [58] [31] <ref> [30] </ref> [42] [15] [2]. The distinction between subtypes and subclasses is not just academic. If one passes an argument whose type is not a subtype of the expected formal argument type to a procedure, the procedure will not act as desired.
Reference: [31] <author> LaLonde, W. R., Thomas, D. A., and Pugh, J. R. </author> <title> An exemplar based Smalltalk. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 322-330, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: We give a formal definition of legal subtyping that guarantees that verification using supertype abstraction is sound. To make such a guarantee, the notion of a legal subtype relation has to be stronger than the implementation inheritance (or subclass) relation [58] <ref> [31] </ref> [55]. The notion of legal subtyping must even be stronger than the syntactic guarantee that the new type will not cause type checking (or "message not understood") errors (see, for example, [8]). <p> other hand, a clear separation of the notions of inheritance and subtyping is a tool of great conceptual power in object-oriented programming, since it allows one to use inheritance to implement types in the most economical manner, and use subtyping to organize and reason about the use of types [58] <ref> [31] </ref> [30] [42] [15] [2]. The distinction between subtypes and subclasses is not just academic. If one passes an argument whose type is not a subtype of the expected formal argument type to a procedure, the procedure will not act as desired.
Reference: [32] <author> Lamping, J. </author> <title> Typing the specialization interface. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(10) </volume> <pages> 201-214, </pages> <month> October </month> <year> 1993. </year> <booktitle> OOPSLA '93 Proceedings, Andreas Paepcke (editor). </booktitle>
Reference-contexts: For example, one would like to be able to specify the behavior of classes to compare them with types. One would also like to specify enough about a class so that a subclass could be programmed without looking at the code of the superclass (see <ref> [32] </ref>). In verification, one would like to use the fact that a subtype is implemented by a subclass (of a class that implements the supertype) to help prove legal subtyping. 8.2 Subtyping versus Refinement One justification for subtype relationships might be that they are similar to refinement relationships among specifications.
Reference: [33] <author> Lamport, L. </author> <title> A simple approach to specifying concurrent systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: However, unlike Larch/CLU, Larch/LOAL specifications deal only with immutable types. An interface specification describes both the behavior of abstract types and how they can be used in a program <ref> [33] </ref> [26]. In Larch/LOAL, the interface describes how a LOAL program can use the types.
Reference: [34] <author> Leavens, G. T. </author> <title> Modular verification of object-oriented programs with subtypes. </title> <type> Technical Report 90-09, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, July </month> <year> 1990. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: For example, the MN II includes null, create, ins, elem, IntSet, Interval, Bool, Int, and message names for the visible types such as true, false, not, and add. (See <ref> [34, Appendix B] </ref> for details on the visible types.) The requirement on signatures that the ResSort mapping is monotone in does not affect the construction of ResSort. However, if this requirement is not met, then the set of type specifications is invalid, as it will not determine a proper signature. <p> Thus we will assume from now on that the visible types are the same in all algebras. To state this assumption precisely requires the notion of the reduct of an algebra [18, Section 6.8] <ref> [34] </ref>. Briefly, the reduct A ( 0 ) has as its carrier sets the carrier sets of the sorts in A that appear in 0 , and as its trait functions and methods those named in 0 . <p> For Larch/LOAL, there is a fixed signature B and a fixed B-algebra, B, that defines the visible types <ref> [34, Appendix B] </ref>. We assume that all signatures have B as a subsignature and all algebras have B as their B-reduct. 3.2 Formal Semantics of Type Specifications In this section we formalize the semantics of sets of type specifications. <p> So there cannot be a simulation relation such that the method choose satisfies the substitution property. So PSchd cannot be a legal subtype of Crowd <ref> [34, Section 4.1.2] </ref>. The above example shows the failing of the informal motto, "S is a subtype of T if every object of type S acts like some object of type T," in the face of incomplete specifications. <p> LOAL programs and functions may be nondeterministic, since the operations of an abstract type may be nondeterministic. Although there are no facilities in LOAL itself for introducing nondeterminism, the addition of such facilities does not invalidate the results of this paper <ref> [34] </ref>. LOAL uses lazy evaluation for evaluating function arguments [56, Page 181] [4]. Because of lazy evaluation, functions need not be strict. However, each actual parameter is only evaluated once; hence formal parameters are not sources of nondeterminism. <p> In the study of the lambda calculus, this kind of theorem is known as the fundamental theorem of logical relations [59] [49] [37]. Showing such a theorem is another route to justifying the definition of legal subtype relations <ref> [34, Chapter 7] </ref> [37, Section 2.4], but one that is outside the scope of this paper. For the present paper, the following serves as another confirmation that our definition of simulation relations, on which the definition of subtype relations is reasonable. Theorem 5.16 Let be a signature. <p> The inference rule [equal] allows one to draw conclusions from equations in post-conditions; this ability is sometimes needed to weaken a post-condition that results from using the [ident] rule to one that is subtype constraining, because the rule [conseq] only permits one to use subtype-constraining assertions. See <ref> [34] </ref> for details of the other rules. 6.2 Verification Examples Example 6.2 The way that the logic handles explicit use of subtyping is shown by the proof of the formula: (II; inBoth) ` (s eqSet f3g) ^ (iv eqSet [2; 5]) fi : Int inBoth (s,iv)g i = 3 (62) where <p> With supertype abstraction both informal reasoning about programs and formal verification is modular. That is, one can add new types to a program without rethinking or reverifying unchanged parts of the program <ref> [34] </ref> [39]. The only qualitative difference from standard program verification is that the verifier must also show that the specified subtype relation is legal. For the practicing software designer, the main lesson of this work is that one can use subtype polymorphism to write polymorphic specifications. <p> Indeed, a definition that says that there should be no way to get surprising behavior from a legal subtype is more general and certainly more fundamental [40] [38] <ref> [34, Chapter 7] </ref> [37]. Nevertheless, our soundness results and Corollary 7.5 show that a legal subtype cannot exhibit surprising behavior. In addition to the removing the limitations mentioned above, we suggest the following as interesting open problems. There are several issues relating to classes that we ignored.
Reference: [35] <author> Leavens, G. T. </author> <title> Modular specification and verification of object-oriented programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: This causes difficulties in verification, because many different operations may be invoked by a single message at different times, and these operations may have different specifications. The technique of supertype abstraction [40] [38] <ref> [35] </ref> overcomes this problem by reasoning using static (what we call nominal ) type information, and restricting the run-time types of the objects denoted by expressions to be subtypes of their nominal types. That is, supertype abstraction means using supertypes to stand for all their subtypes. <p> By ruling out mutation, attention is focused on two other features that make reasoning difficult in object-oriented languages: message passing and subtyping. 1.2 An Example of the Reasoning Problem This section motivates the need for supertype abstraction and modularity. (See also [38] and <ref> [35] </ref> for more background.) Consider the specification of Figure 1. In that figure, the meaning of the operators used in the pre-condition (following requires) and the post-condition (following ensures) is expressed using trait functions from the specification of IntSet, for example 2, ", and "isEmpty". <p> The program sees a polymorphic method, which is implemented by the operations of all the abstract types with the same name and number of arguments. 2.1 Traits Larch/LOAL specifications describe behavior in terms of the abstract values of objects [29] [43] <ref> [35] </ref> [26]. In Larch/LOAL, the abstract values of objects are specified by a trait written in the Larch Shared Language [28] [27] [26]. (The Larch Shared language is used by Larch/LOAL, but is a distinct language. Both are distinct from LOAL itself. <p> For the same reason, the simulates clause in 40 In view of the previous two examples we believe that a better informal motto for legal subtyping is: "subtyping means no surprises" [40] [38] <ref> [35] </ref> [36]. The idea behind this motto is that if one has a legal subtype relation, then a program cannot observe anything that would not be expected based on the specification of the supertypes. This is, we believe, the ultimate justification for a definition of "legal subtype relations". <p> That is, most parts of a program's proof of correctness are unaffected by subtypes, and would be the same if LOAL did not have subtyping. However, the verifier must also prove that the specified relation is a legal subtype relation. We call this separation of concerns supertype abstraction [38] <ref> [35] </ref>, because during verification one ignores the subtypes. An unusual feature of LOAL verification is that we use a Hoare logic, despite the applicative nature of LOAL programs. <p> We then show the converse, that legal subtyping implies something like their conditions. The converse also says that supertype abstraction [38] <ref> [35] </ref> is sound. That is, one can reason about objects of subtypes as if they were objects of a supertype. 7.1 Proving Legal Subtype Relations from Specifications In this section we show that our definition of legal subtype relations is implied by something like Meyer's and America's. <p> and Post (g; ~ U) is subtype-constrainingi (A; A [r 0 =t]) j= Post (g; ~ U) Since the last formula holds for all r 0 2 g A (~q), A satisfies SPEC . 81 7.2 Soundness of Supertype Abstraction In this brief section we show that supertype abstraction [38] <ref> [35] </ref> is sound. That is, one can reason about objects of subtypes as if they were objects of a supertype.
Reference: [36] <author> Leavens, G. T. and Pigozzi, D. </author> <title> Typed homomorphic relations extended with sub-types. </title> <type> Technical Report 91-14, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, June </month> <year> 1991. </year> <booktitle> Appears in the proceedings of Mathematical Foundations of Programming Semantics '91, Springer-Verlag, Lecture Notes in Computer Science, </booktitle> <volume> volume 598, </volume> <pages> pages 144-167, </pages> <year> 1992. </year>
Reference-contexts: For the same reason, the simulates clause in 40 In view of the previous two examples we believe that a better informal motto for legal subtyping is: "subtyping means no surprises" [40] [38] [35] <ref> [36] </ref>. The idea behind this motto is that if one has a legal subtype relation, then a program cannot observe anything that would not be expected based on the specification of the supertypes. This is, we believe, the ultimate justification for a definition of "legal subtype relations". <p> Notice that this extension of R preserves the substitution property of simulation relations. Since operations are not first-class objects in LOAL, it is not necessary to show that this extension has all the properties of a simulation relation at each function signature. (See <ref> [36] </ref> for such an extension and the corresponding fundamental theorem of logical relations.) To deal with LOAL expressions that have free function identifiers, environments are allowed to map typed function identifiers to their denotations in the algebra that is the environment's range (i.e., to set-valued functions).
Reference: [37] <author> Leavens, G. T. and Pigozzi, D. </author> <title> Typed homomorphic relations extended with subtypes. </title> <editor> In Brookes, S., editor, </editor> <booktitle> Mathematical Foundations of Programming Semantics '91, volume 598 of Lecture Notes in Computer Science, </booktitle> <pages> pages 144-167. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year> <month> 93 </month>
Reference-contexts: In the study of the lambda calculus, this kind of theorem is known as the fundamental theorem of logical relations [59] [49] <ref> [37] </ref>. Showing such a theorem is another route to justifying the definition of legal subtype relations [34, Chapter 7] [37, Section 2.4], but one that is outside the scope of this paper. <p> In the study of the lambda calculus, this kind of theorem is known as the fundamental theorem of logical relations [59] [49] [37]. Showing such a theorem is another route to justifying the definition of legal subtype relations [34, Chapter 7] <ref> [37, Section 2.4] </ref>, but one that is outside the scope of this paper. For the present paper, the following serves as another confirmation that our definition of simulation relations, on which the definition of subtype relations is reasonable. Theorem 5.16 Let be a signature. <p> Although we do not handle higher-order types, for first-order types our definition of legal subtype relations is more general, since it applies to abstract data types. (An extension of our definition to higher-order types is described in <ref> [37] </ref>.) Like Cardelli, we have also attempted to give a definition of subtype relationships that is theoretically justified, instead of just appealing to intuition. 8.1 Limitations and Open Problems Our theoretical results have certain formal limitations: * The verification technique: only handles LOAL client programs (not the implementations of types), does <p> However, these formal limitations should not all be taken as fundamental weaknesses. We believe that our techniques can be extended to handle mutation and assignment, and work is in progress to do so [16] [17]. We have also extended these techniques to higher-order functions <ref> [37] </ref>. The main limitation to bear in mind is that the verification technique has not been proved relatively complete [13] [46, Section 8.2]. <p> Indeed, a definition that says that there should be no way to get surprising behavior from a legal subtype is more general and certainly more fundamental [40] [38] [34, Chapter 7] <ref> [37] </ref>. Nevertheless, our soundness results and Corollary 7.5 show that a legal subtype cannot exhibit surprising behavior. In addition to the removing the limitations mentioned above, we suggest the following as interesting open problems. There are several issues relating to classes that we ignored.
Reference: [38] <author> Leavens, G. T. and Weihl, W. E. </author> <title> Reasoning about object-oriented programs that use subtypes (extended abstract). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 212-223, </pages> <month> October </month> <year> 1990. </year> <booktitle> OOPSLA ECOOP '90 Proceedings, N. Meyrowitz (editor). </booktitle>
Reference-contexts: This causes difficulties in verification, because many different operations may be invoked by a single message at different times, and these operations may have different specifications. The technique of supertype abstraction [40] <ref> [38] </ref> [35] overcomes this problem by reasoning using static (what we call nominal ) type information, and restricting the run-time types of the objects denoted by expressions to be subtypes of their nominal types. That is, supertype abstraction means using supertypes to stand for all their subtypes. <p> That is, supertype abstraction means using supertypes to stand for all their subtypes. Supertype abstraction has the advantage of modularity: one does not have to respecify or reverify unchanged program parts when new subtypes of existing types are added to a program <ref> [38] </ref> [39]. Our results can thus provide formal support for the common informal practice of object-oriented programming, as it shows conditions under which programmers do not have to rethink unchanged code, and those which might be dangerous. <p> By ruling out mutation, attention is focused on two other features that make reasoning difficult in object-oriented languages: message passing and subtyping. 1.2 An Example of the Reasoning Problem This section motivates the need for supertype abstraction and modularity. (See also <ref> [38] </ref> and [35] for more background.) Consider the specification of Figure 1. In that figure, the meaning of the operators used in the pre-condition (following requires) and the post-condition (following ensures) is expressed using trait functions from the specification of IntSet, for example 2, ", and "isEmpty". <p> However, to exploit subtype polymorphism in a typed language, one must allow expressions of type T to denote objects of subtypes of T. 1.3 Overview of the Method To solve the specification and verification problem discussed above, we use the following method <ref> [38] </ref>. 4 * One specifies the data types to be used along with their subtype relationships. * One specifies the operations of data types and functions using supertype abstraction. That is, one assumes that each argument has a specified type, which is that formal's nominal type. <p> An example is given in <ref> [38] </ref>. 19 3.1.3 Subsignatures The notion of subsignature is used in the study of modular verification, and for technical purposes in this paper. When a new type specification is added to a set of type specifications, the old specification's signature is a subsignature of the new signature. <p> If there are separate code modules, that makes no difference from the point of view of one reading the specification. If there are subtypes, this also makes no difference, as we wish to reason 38 based on the specification at hand, ignoring subtypes <ref> [38] </ref>. 5 For example, this allows one to conclude that, because the choose operation is specified to be deterministic on Crowd abstract values, when one has two Crowd objects with abstract value "f2,3g", choose returns the same integer when applied to each object. <p> For the same reason, the simulates clause in 40 In view of the previous two examples we believe that a better informal motto for legal subtyping is: "subtyping means no surprises" [40] <ref> [38] </ref> [35] [36]. The idea behind this motto is that if one has a legal subtype relation, then a program cannot observe anything that would not be expected based on the specification of the supertypes. This is, we believe, the ultimate justification for a definition of "legal subtype relations". <p> That is, most parts of a program's proof of correctness are unaffected by subtypes, and would be the same if LOAL did not have subtyping. However, the verifier must also prove that the specified relation is a legal subtype relation. We call this separation of concerns supertype abstraction <ref> [38] </ref> [35], because during verification one ignores the subtypes. An unusual feature of LOAL verification is that we use a Hoare logic, despite the applicative nature of LOAL programs. <p> The soundness of the Hoare logic justifies our definition of legal subtype relations. Put another way, the reason we care about the soundness of the Hoare logic is that we want a definition of legal subtype relations that makes our style of modular verification work <ref> [38] </ref>. Completeness, the converse of soundness, is beyond the scope of this paper. <p> We then show the converse, that legal subtyping implies something like their conditions. The converse also says that supertype abstraction <ref> [38] </ref> [35] is sound. That is, one can reason about objects of subtypes as if they were objects of a supertype. 7.1 Proving Legal Subtype Relations from Specifications In this section we show that our definition of legal subtype relations is implied by something like Meyer's and America's. <p> =t], and Post (g; ~ U) is subtype-constrainingi (A; A [r 0 =t]) j= Post (g; ~ U) Since the last formula holds for all r 0 2 g A (~q), A satisfies SPEC . 81 7.2 Soundness of Supertype Abstraction In this brief section we show that supertype abstraction <ref> [38] </ref> [35] is sound. That is, one can reason about objects of subtypes as if they were objects of a supertype. <p> Informally, another way to read it is that it says a legal subtype relationship allows one to use the specifications of supertypes to reason about subtypes; that is, supertype abstraction <ref> [38] </ref> is valid. Corollary 7.5 Let (SPEC ; FSPEC) be a pair of type and function specification sets. Let be the subtype relation of SIG (SPEC ). Let g be a message name of SIG (SPEC ). <p> Indeed, a definition that says that there should be no way to get surprising behavior from a legal subtype is more general and certainly more fundamental [40] <ref> [38] </ref> [34, Chapter 7] [37]. Nevertheless, our soundness results and Corollary 7.5 show that a legal subtype cannot exhibit surprising behavior. In addition to the removing the limitations mentioned above, we suggest the following as interesting open problems. There are several issues relating to classes that we ignored.
Reference: [39] <author> Leavens, G. T. and Weihl, W. E. </author> <title> Subtyping, modular specification, and modular verification for applicative object-oriented programs. </title> <type> Technical Report 92-28d, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, August </month> <year> 1994. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: That is, supertype abstraction means using supertypes to stand for all their subtypes. Supertype abstraction has the advantage of modularity: one does not have to respecify or reverify unchanged program parts when new subtypes of existing types are added to a program [38] <ref> [39] </ref>. Our results can thus provide formal support for the common informal practice of object-oriented programming, as it shows conditions under which programmers do not have to rethink unchanged code, and those which might be dangerous. <p> With supertype abstraction both informal reasoning about programs and formal verification is modular. That is, one can add new types to a program without rethinking or reverifying unchanged parts of the program [34] <ref> [39] </ref>. The only qualitative difference from standard program verification is that the verifier must also show that the specified subtype relation is legal. For the practicing software designer, the main lesson of this work is that one can use subtype polymorphism to write polymorphic specifications.
Reference: [40] <author> Leavens, G. T. </author> <title> Verifying object-oriented programs that use subtypes. </title> <type> Technical Report 439, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> February </month> <year> 1989. </year> <title> The author's Ph.D. </title> <type> thesis. </type>
Reference-contexts: 1 Introduction In object-oriented programming, message passing allows the manipulation of objects without knowledge of their exact run-time types. This causes difficulties in verification, because many different operations may be invoked by a single message at different times, and these operations may have different specifications. The technique of supertype abstraction <ref> [40] </ref> [38] [35] overcomes this problem by reasoning using static (what we call nominal ) type information, and restricting the run-time types of the objects denoted by expressions to be subtypes of their nominal types. That is, supertype abstraction means using supertypes to stand for all their subtypes. <p> The notion of legal subtyping must even be stronger than the syntactic guarantee that the new type will not cause type checking (or "message not understood") errors (see, for example, [8]). It must instead be a behavioral notion, based on the specification of an abstract data type [1] [42] <ref> [40] </ref> [30] [15] [2] [44] [45]. (See Section 8 for a discussion of related work.) As an example of the distinction between legal subtyping and subclassing, consider two types IntSet and Interval, where Interval is a type of closed intervals of integers, and IntSet is a type of integer sets. (Both <p> In more detail the important contributions are as follows. * A formal interface specification language, called Larch/LOAL (in Section 2), and its model-theoretic semantics (in Section 3). 1 This verification logic is the first to formally treat code that uses both subtyping and message passing <ref> [40] </ref>. fun inBoth (s1,s2: IntSet) returns (i:Int) requires :(isEmpty (s1 " s2)) ensures (i 2 s1) ^ (i 2 s2) * A model-theoretic definition of legal subtype relations (in Section 4), which is based on the semantics of type specifications. <p> For the same reason, the simulates clause in 40 In view of the previous two examples we believe that a better informal motto for legal subtyping is: "subtyping means no surprises" <ref> [40] </ref> [38] [35] [36]. The idea behind this motto is that if one has a legal subtype relation, then a program cannot observe anything that would not be expected based on the specification of the supertypes. This is, we believe, the ultimate justification for a definition of "legal subtype relations". <p> Indeed, a definition that says that there should be no way to get surprising behavior from a legal subtype is more general and certainly more fundamental <ref> [40] </ref> [38] [34, Chapter 7] [37]. Nevertheless, our soundness results and Corollary 7.5 show that a legal subtype cannot exhibit surprising behavior. In addition to the removing the limitations mentioned above, we suggest the following as interesting open problems. There are several issues relating to classes that we ignored.
Reference: [41] <author> Lieberman, H. </author> <title> Using prototypical objects to implement shared behavior in object oriented systems. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 214-223, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: But using instance variables also has problems, because implementations are no longer free to choose their own instance variables and because such instance variables must be visible to clients. 9 Some object-oriented languages do not have classes, but are based on the notion of delegation <ref> [41] </ref> [60]. In such languages, specified class operations might be implemented by functions that clone prototypes, or by instance operations of prototypes.
Reference: [42] <author> Liskov, B. </author> <title> Data abstraction and hierarchy. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(5) </volume> <pages> 17-34, </pages> <month> May </month> <year> 1988. </year> <note> Revised version of the keynote address given at OOPSLA '87. </note>
Reference-contexts: The notion of legal subtyping must even be stronger than the syntactic guarantee that the new type will not cause type checking (or "message not understood") errors (see, for example, [8]). It must instead be a behavioral notion, based on the specification of an abstract data type [1] <ref> [42] </ref> [40] [30] [15] [2] [44] [45]. (See Section 8 for a discussion of related work.) As an example of the distinction between legal subtyping and subclassing, consider two types IntSet and Interval, where Interval is a type of closed intervals of integers, and IntSet is a type of integer sets. <p> a clear separation of the notions of inheritance and subtyping is a tool of great conceptual power in object-oriented programming, since it allows one to use inheritance to implement types in the most economical manner, and use subtyping to organize and reason about the use of types [58] [31] [30] <ref> [42] </ref> [15] [2]. The distinction between subtypes and subclasses is not just academic. If one passes an argument whose type is not a subtype of the expected formal argument type to a procedure, the procedure will not act as desired.
Reference: [43] <author> Liskov, B. and Guttag, J. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: asserts 8 s 1 , s 2 : C (s 1 eqSet s 2 ) == (s 1 = s 2 ) isEmpty (s 1 ) == (s 1 = fg) 2 Polymorphic Type Specifications The interface specification language Larch/LOAL is adapted from Wing's interface specification language for CLU [64] <ref> [43, Chapter 10] </ref> [24] [63] and Chen's Larch/Generic interface specification language [11]. However, unlike Larch/CLU, Larch/LOAL specifications deal only with immutable types. An interface specification describes both the behavior of abstract types and how they can be used in a program [33] [26]. <p> The program sees a polymorphic method, which is implemented by the operations of all the abstract types with the same name and number of arguments. 2.1 Traits Larch/LOAL specifications describe behavior in terms of the abstract values of objects [29] <ref> [43] </ref> [35] [26]. In Larch/LOAL, the abstract values of objects are specified by a trait written in the Larch Shared Language [28] [27] [26]. (The Larch Shared language is used by Larch/LOAL, but is a distinct language. Both are distinct from LOAL itself. <p> We believe that the close link between class operations and instance operations that our semantics and the definition of legal subtype relations requires will help one to reason about programs using datatype induction <ref> [43, Section 4.9.4] </ref>, although this remains to be shown.
Reference: [44] <author> Liskov, B. and Wing, J. M. </author> <title> A new definition of the subtype relation. </title> <editor> In Nierstrasz, O. M., editor, </editor> <booktitle> ECOOP '93 | Object-Oriented Programming, 7th European Conference, Kaiserslautern, Germany, volume 707 of Lecture Notes in Computer Science, </booktitle> <pages> pages 118-141. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> July </month> <year> 1993. </year>
Reference-contexts: It must instead be a behavioral notion, based on the specification of an abstract data type [1] [42] [40] [30] [15] [2] <ref> [44] </ref> [45]. (See Section 8 for a discussion of related work.) As an example of the distinction between legal subtyping and subclassing, consider two types IntSet and Interval, where Interval is a type of closed intervals of integers, and IntSet is a type of integer sets. (Both types of objects are <p> Simulation relations are the main technical tool used to define legal subtype relations. Note, however, that we only deal with first-order 2 , immutable, abstract data types. Subtyping for mutable types (types whose objects have time-varying state) is still a subject of research [17] <ref> [44] </ref> [45]. <p> section we study the technical relationship between our definition of legal subtype relations and Meyer's [47, Section 11.1] [48, Sections 10.15 and 10.22] and America's [1] [2] definitions. (Similar definitions were proposed earlier by the designers of Trellis/Owl [55], and also figure in the recent work of Liskov and Wing <ref> [44] </ref> [45].) We first show how to adapt their technique for proving legal subtype relationships to our formalism. We then show the converse, that legal subtyping implies something like their conditions. The converse also says that supertype abstraction [38] [35] is sound. <p> SPEC j= (Pre (g; ~ W) ) Post (g; ~ W)) ) ((Pre (g; ~ U) ) Post (g; ~ U))[~w; s=~u; t]); (125) A similar condition figures in the work of Liskov and Wing <ref> [44] </ref> (at our suggestion). However, the following corollary does not prove Formula (125). The problem is that Formula (125) does not require s to be a possible result of a call of g, and our model-theoretic conditions on legal subtype relations seem to require that. <p> The theoretical and practical implications of these distinctions is unknown, but we believe that programmers and language designers should be cautious in using operators like typeOf, as it will certainly complicate reasoning with supertype abstraction. 8.3.5 Liskov and Wing's work Liskov and Wing <ref> [44] </ref> [45] formulate a definition of legal subtype relations that is similar to America's, except that it has explicit provisions to deal with aliasing for mutable types; their definition is thus more widely applicable than ours. <p> Liskov and Wing do not give a formal logic for program verification. However, their approach to reasoning about programs is the same as our approach of supertype abstraction. (Note that this contradicts their discussion on page 138 of <ref> [44] </ref> of our work. We use simulation relations to coerce abstract values of subtypes to supertypes, not vice versa.) 88 8.4 Wider applications The paradigm of supertype abstraction has wider application than just object-oriented programming. It is possible to view many table-driven programs, including compilers, in the same light.
Reference: [45] <author> Liskov, B. and Wing, J. M. </author> <title> Specifications and their use in defining subtypes. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(10) </volume> <pages> 16-28, </pages> <month> October </month> <year> 1993. </year> <booktitle> OOPSLA '93 Proceedings, Andreas Paepcke (editor). </booktitle>
Reference-contexts: It must instead be a behavioral notion, based on the specification of an abstract data type [1] [42] [40] [30] [15] [2] [44] <ref> [45] </ref>. (See Section 8 for a discussion of related work.) As an example of the distinction between legal subtyping and subclassing, consider two types IntSet and Interval, where Interval is a type of closed intervals of integers, and IntSet is a type of integer sets. (Both types of objects are immutable|they <p> Simulation relations are the main technical tool used to define legal subtype relations. Note, however, that we only deal with first-order 2 , immutable, abstract data types. Subtyping for mutable types (types whose objects have time-varying state) is still a subject of research [17] [44] <ref> [45] </ref>. <p> we study the technical relationship between our definition of legal subtype relations and Meyer's [47, Section 11.1] [48, Sections 10.15 and 10.22] and America's [1] [2] definitions. (Similar definitions were proposed earlier by the designers of Trellis/Owl [55], and also figure in the recent work of Liskov and Wing [44] <ref> [45] </ref>.) We first show how to adapt their technique for proving legal subtype relationships to our formalism. We then show the converse, that legal subtyping implies something like their conditions. The converse also says that supertype abstraction [38] [35] is sound. <p> The theoretical and practical implications of these distinctions is unknown, but we believe that programmers and language designers should be cautious in using operators like typeOf, as it will certainly complicate reasoning with supertype abstraction. 8.3.5 Liskov and Wing's work Liskov and Wing [44] <ref> [45] </ref> formulate a definition of legal subtype relations that is similar to America's, except that it has explicit provisions to deal with aliasing for mutable types; their definition is thus more widely applicable than ours.
Reference: [46] <author> Loeckx, J. and Sieber, K. </author> <title> The Foundations of Program Verification (Second edition). </title> <publisher> John Wiley and Sons, </publisher> <address> New York, N.Y., </address> <year> 1987. </year>
Reference-contexts: We have also extended these techniques to higher-order functions [37]. The main limitation to bear in mind is that the verification technique has not been proved relatively complete [13] <ref> [46, Section 8.2] </ref>. This means, for example, that ours may not be the only way to prove the correctness of object-oriented programs, and that, even for types with immutable objects, ours may not be the best definition of legal subtype relations.
Reference: [47] <author> Meyer, B. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: ; FSPEC) ` R fy Eg Q, then the program P is partially correct with respect to SPEC 2 and p. 7 Proving Legal Subtyping from Specifications and Sound ness of Supertype Abstraction In this section we study the technical relationship between our definition of legal subtype relations and Meyer's <ref> [47, Section 11.1] </ref> [48, Sections 10.15 and 10.22] and America's [1] [2] definitions. (Similar definitions were proposed earlier by the designers of Trellis/Owl [55], and also figure in the recent work of Liskov and Wing [44] [45].) We first show how to adapt their technique for proving legal subtype relationships to <p> The following theorem is the promised one that shows that if one can prove a subtype relation is legal according to Meyer's <ref> [47] </ref> [48] and America's definition [2], then the subtype relation is a legal subtype relation by our definition. <p> That is, one can reason about objects of subtypes as if they were objects of a supertype. The soundness of supertype abstraction also bears on the question of the extent to which our definition of legal subtype relations implies something like Meyer's <ref> [47] </ref> [48] and America's definitions [2] of subtypes? Are our definitions fundamentally equivalent? We believe that the answers to the above questions are "yes". <p> connection between subtyping and refinement of the types of instances. 8.3 Related Work Meyer, America, and Utting have discussed both subtyping and the specification and verification of object-oriented programs. 8.3.1 Meyer's work on Eiffel Of authors who discuss specification and verification, Meyer's work on Eiffel is perhaps the best known <ref> [47] </ref> [48]. Meyer concentrates on specification and does not give a formal logic for the verification of Eiffel programs. In contrast to Larch/LOAL, Eiffel specifications may invoke methods. This can be used to give specifications an axiomatic flavor, where the methods and axioms mutually constrain each other. <p> So like our specifications, the specifications in Eiffel are modular. Meyer's definition of legal subtyping is based on implications between the pre- and post-conditions of corresponding operations of the subtype and supertype <ref> [47, Section 11.1] </ref>. (Similar definitions were proposed earlier by the designers of Trellis/Owl [55].) In the latest version of Eiffel, specifications of subtypes, if not inherited as is, must use a special form that automatically ensures that the pre-condition of the subtype is weaker than the precondition of the supertype, and
Reference: [48] <author> Meyer, B. </author> <title> Eiffel: The Language. Object-Oriented Series. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: R fy Eg Q, then the program P is partially correct with respect to SPEC 2 and p. 7 Proving Legal Subtyping from Specifications and Sound ness of Supertype Abstraction In this section we study the technical relationship between our definition of legal subtype relations and Meyer's [47, Section 11.1] <ref> [48, Sections 10.15 and 10.22] </ref> and America's [1] [2] definitions. (Similar definitions were proposed earlier by the designers of Trellis/Owl [55], and also figure in the recent work of Liskov and Wing [44] [45].) We first show how to adapt their technique for proving legal subtype relationships to our formalism. <p> The following theorem is the promised one that shows that if one can prove a subtype relation is legal according to Meyer's [47] <ref> [48] </ref> and America's definition [2], then the subtype relation is a legal subtype relation by our definition. <p> That is, one can reason about objects of subtypes as if they were objects of a supertype. The soundness of supertype abstraction also bears on the question of the extent to which our definition of legal subtype relations implies something like Meyer's [47] <ref> [48] </ref> and America's definitions [2] of subtypes? Are our definitions fundamentally equivalent? We believe that the answers to the above questions are "yes". <p> between subtyping and refinement of the types of instances. 8.3 Related Work Meyer, America, and Utting have discussed both subtyping and the specification and verification of object-oriented programs. 8.3.1 Meyer's work on Eiffel Of authors who discuss specification and verification, Meyer's work on Eiffel is perhaps the best known [47] <ref> [48] </ref>. Meyer concentrates on specification and does not give a formal logic for the verification of Eiffel programs. In contrast to Larch/LOAL, Eiffel specifications may invoke methods. This can be used to give specifications an axiomatic flavor, where the methods and axioms mutually constrain each other. <p> the latest version of Eiffel, specifications of subtypes, if not inherited as is, must use a special form that automatically ensures that the pre-condition of the subtype is weaker than the precondition of the supertype, and that the post-condition of the subtype is stronger than the post-condition of the supertype <ref> [48, Sections 10.15 and 10.22] </ref>.
Reference: [49] <author> Mitchell, J. C. </author> <title> Representation independence and data abstraction (preliminary version). </title> <booktitle> In Conference Record of the Thirteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, </address> <pages> pages 263-276. </pages> <publisher> ACM, </publisher> <month> Jan-uary </month> <year> 1986. </year>
Reference-contexts: For a given algebra, the denotation of a LOAL function is a mapping from tuples of arguments to sets of possible results. Such mappings are related by analogy to the definition 52 of logical relations [59] <ref> [49] </ref>. <p> In the study of the lambda calculus, this kind of theorem is known as the fundamental theorem of logical relations [59] <ref> [49] </ref> [37]. Showing such a theorem is another route to justifying the definition of legal subtype relations [34, Chapter 7] [37, Section 2.4], but one that is outside the scope of this paper.
Reference: [50] <author> Mitchell, J. C. </author> <title> Lambda Calculus Models of Typed Programming Languages. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> August </month> <year> 1984. </year>
Reference-contexts: This is in contrast with the work of Cardelli and others, which only described subtype relationships for a syntactically characterized set of built-in types [8]. 8 Cardelli's landmark paper gives rules for what 8 While existential types used by Mitchell, Cardelli and others <ref> [50] </ref> [10] [9] are sometimes said to describe abstract data types, they do not characterize the behavior of such types. An existential type only describes the syntactic interface of an abstract data type.
Reference: [51] <author> Nipkow, T. </author> <title> Non-deterministic data types: Models and implementations. </title> <journal> Acta Infor-matica, </journal> <volume> 22(16) </volume> <pages> 629-661, </pages> <month> March </month> <year> 1986. </year> <month> 94 </month>
Reference-contexts: The methods are used by LOAL programs for computation. The trait functions cannot be invoked by programs, and the methods cannot be used in specifications. To model nondeterministic procedures, the methods are set-valued functions; that is, a method returns a set of the possible results <ref> [51] </ref> [52]. The special value ? is used to model procedure calls that do not halt or that encounter run-time errors. <p> Below (A; T) def [ A U (9) If A is a -algebra, then the preorder used in this abbreviation is the preorder on the sorts of . Our extension of homomorphic relations to nondeterministic algebras was inspired by <ref> [51] </ref>. However, to make the analogy to the deterministic case clearer, we would like to deemphasize the nondeterminism in our notation. So we use another abbreviation when comparing sets of possible results with a relation R T .
Reference: [52] <author> Nipkow, T. </author> <title> Behavioural Implementation Concepts for Nondeterministic Data Types. </title> <type> PhD thesis, </type> <institution> University of Manchester, </institution> <month> May </month> <year> 1987. </year>
Reference-contexts: The methods are used by LOAL programs for computation. The trait functions cannot be invoked by programs, and the methods cannot be used in specifications. To model nondeterministic procedures, the methods are set-valued functions; that is, a method returns a set of the possible results [51] <ref> [52] </ref>. The special value ? is used to model procedure calls that do not halt or that encounter run-time errors.
Reference: [53] <author> Reynolds, J. C. </author> <title> Using category theory to design implicit conversions and generic operators. </title> <editor> In Jones, N. D., editor, </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, volume 94 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1980. </year>
Reference-contexts: For incomplete specifications which do not have a "best" implementation, the informal motto allows surprising behavior| several objects of the subtype could collectively act differently than what one would expect from the supertype's specification. Less importantly, we present a model theory for specifications that generalizes the work of <ref> [53] </ref> and [6]. Our simulation relations are tailored to handle incomplete specifications and are preserved by assertions in Larch/LOAL and by LOAL expressions and programs. Simulation relations are the main technical tool used to define legal subtype relations. <p> ResSort must be monotone in the following sense: for all g 2 OPS, and for all tuples of sorts ~ S ~ T, if ResSort (g; ~ T) is defined, then so is ResSort (g; ~ S), and furthermore ResSort (g; ~ S) ResSort (g; ~ T) <ref> [53, Page 217] </ref>. The restriction on prohibits subtypes of a visible type. This restriction is reasonable, because only visible types can appear as the output of programs, so an object of some other type cannot behave quite like an object of a visible type. <p> In the following we present LOAL examples in the concrete syntax, but we only consider the abstract syntax in the semantics and proofs. 5.4 Type Checking and Nominal Types Type checking for LOAL is based on subtyping, using techniques from Reynolds's category sorted algebras <ref> [53] </ref> [54]. Each type-safe expression is statically assigned a "nominal type", determined from the information given in type specifications and program declarations. Thus the nominal type of an expression is just the expression's static type; for example, the nominal type of an identifier is given in its declaration. <p> The notion of an expression's nominal type is similar to Reynolds's notion of the minimal type of an expression <ref> [53] </ref> [54]. Like Reynolds, each type-safe expression is given a single nominal type. This is in contrast to type systems with a rule of subsumption, such as Cardelli's [8], where expressions have multiple types. <p> for all ~w : ~ W, for all trait function symbols f such that ResSort (f; ~ U) is defined, SPEC j= to ResSort (f; ~ U) (f (~w)) = f (to ~ U (~w)): (119) The requirement of a legal system of coercion functions resembles requirements used by Reynolds <ref> [53] </ref> and Bruce and Wegner [6]. America does not have these exact requirements, because his definition of subtyping is not concerned with modular specification, and thus makes no restrictions on how the abstract values of types are specified. <p> His transfer functions, which map the abstract values of subtypes to the abstract values of supertypes, are similar to our simulation relations. Simulation relations, since they need not be functions, are more general than transfer functions [57], and the coercion functions of <ref> [53] </ref> and [6]. Larch/LOAL gives form to the expression of such relations on abstract values. The technical relationship between our definition and America's is the subject of Sec 87 tion 7. 8.3.3 Comparisons to America's Specification Techniques America's work provides both a definition of legal subtyping and a specification method.
Reference: [54] <author> Reynolds, J. C. </author> <title> Three approaches to type structure. </title> <editor> In Ehrig, H., Floyd, C., Nivat, M., and Thatcher, J., editors, </editor> <booktitle> Mathematical Foundations of Software Development, Proceedings of the International Joint Conference on Theory and Practice of Software Development (TAPSOFT), Berlin. Volume 1: Colloquium on Trees in Algebra and Programming (CAAP '85), volume 185 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-138. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> March </month> <year> 1985. </year>
Reference-contexts: In the following we present LOAL examples in the concrete syntax, but we only consider the abstract syntax in the semantics and proofs. 5.4 Type Checking and Nominal Types Type checking for LOAL is based on subtyping, using techniques from Reynolds's category sorted algebras [53] <ref> [54] </ref>. Each type-safe expression is statically assigned a "nominal type", determined from the information given in type specifications and program declarations. Thus the nominal type of an expression is just the expression's static type; for example, the nominal type of an identifier is given in its declaration. <p> The notion of an expression's nominal type is similar to Reynolds's notion of the minimal type of an expression [53] <ref> [54] </ref>. Like Reynolds, each type-safe expression is given a single nominal type. This is in contrast to type systems with a rule of subsumption, such as Cardelli's [8], where expressions have multiple types.
Reference: [55] <author> Schaffert, C., Cooper, T., Bullis, B., Kilian, M., and Wilpolt, C. </author> <title> An introduction to Trellis/Owl. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 9-16, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: We give a formal definition of legal subtyping that guarantees that verification using supertype abstraction is sound. To make such a guarantee, the notion of a legal subtype relation has to be stronger than the implementation inheritance (or subclass) relation [58] [31] <ref> [55] </ref>. The notion of legal subtyping must even be stronger than the syntactic guarantee that the new type will not cause type checking (or "message not understood") errors (see, for example, [8]). <p> Such specifications are important because they leave design decisions open for both implementors and subtypes. Our definition of legal subtype relations also provides additional intuition beyond the informal motto that each object of a subtype should act like some object of its supertypes <ref> [55] </ref>, for certain kinds of incomplete specifications. For incomplete specifications which do not have a "best" implementation, the informal motto allows surprising behavior| several objects of the subtype could collectively act differently than what one would expect from the supertype's specification. <p> Legal Subtyping from Specifications and Sound ness of Supertype Abstraction In this section we study the technical relationship between our definition of legal subtype relations and Meyer's [47, Section 11.1] [48, Sections 10.15 and 10.22] and America's [1] [2] definitions. (Similar definitions were proposed earlier by the designers of Trellis/Owl <ref> [55] </ref>, and also figure in the recent work of Liskov and Wing [44] [45].) We first show how to adapt their technique for proving legal subtype relationships to our formalism. We then show the converse, that legal subtyping implies something like their conditions. <p> So like our specifications, the specifications in Eiffel are modular. Meyer's definition of legal subtyping is based on implications between the pre- and post-conditions of corresponding operations of the subtype and supertype [47, Section 11.1]. (Similar definitions were proposed earlier by the designers of Trellis/Owl <ref> [55] </ref>.) In the latest version of Eiffel, specifications of subtypes, if not inherited as is, must use a special form that automatically ensures that the pre-condition of the subtype is weaker than the precondition of the supertype, and that the post-condition of the subtype is stronger than the post-condition of the
Reference: [56] <author> Schmidt, D. A. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <address> Boston, Mass., </address> <year> 1986. </year>
Reference-contexts: To allow recursive functions to be defined over algebras, we require that each "carrier set" be a flat domain and that each trait function and method be monotonic and continuous. (See, for example, <ref> [56] </ref> for definitions of these terms.) Since a method is a set-valued function, we need to define precisely what we mean by "monotonic" and "continuous" for set-valued functions. We first extend the domain ordering to sets of possible results. Let v be the domain ordering on a carrier set. <p> Although there are no facilities in LOAL itself for introducing nondeterminism, the addition of such facilities does not invalidate the results of this paper [34]. LOAL uses lazy evaluation for evaluating function arguments <ref> [56, Page 181] </ref> [4]. Because of lazy evaluation, functions need not be strict. However, each actual parameter is only evaluated once; hence formal parameters are not sources of nondeterminism.
Reference: [57] <author> Schoett, O. </author> <title> Behavioural correctness of data representations. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14(1) </volume> <pages> 43-57, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: His transfer functions, which map the abstract values of subtypes to the abstract values of supertypes, are similar to our simulation relations. Simulation relations, since they need not be functions, are more general than transfer functions <ref> [57] </ref>, and the coercion functions of [53] and [6]. Larch/LOAL gives form to the expression of such relations on abstract values.
Reference: [58] <author> Snyder, A. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 38-45, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: We give a formal definition of legal subtyping that guarantees that verification using supertype abstraction is sound. To make such a guarantee, the notion of a legal subtype relation has to be stronger than the implementation inheritance (or subclass) relation <ref> [58] </ref> [31] [55]. The notion of legal subtyping must even be stronger than the syntactic guarantee that the new type will not cause type checking (or "message not understood") errors (see, for example, [8]). <p> the other hand, a clear separation of the notions of inheritance and subtyping is a tool of great conceptual power in object-oriented programming, since it allows one to use inheritance to implement types in the most economical manner, and use subtyping to organize and reason about the use of types <ref> [58] </ref> [31] [30] [42] [15] [2]. The distinction between subtypes and subclasses is not just academic. If one passes an argument whose type is not a subtype of the expected formal argument type to a procedure, the procedure will not act as desired.
Reference: [59] <author> Statman, R. </author> <title> Logical relations and the typed -calculus. </title> <journal> Information and Control, </journal> 65(2/3):85-97, May/June 1985. 
Reference-contexts: This property is analogous to the "fundamental theorem of logical relations" <ref> [59] </ref>. We show that simulation is preserved by all type-safe LOAL expressions in two steps. The first step, Lemma 5.11, assumes that the denotations of LOAL functions are related by a simulation relation (in a way described below), and shows that the possible results of an expression preserve simulation. <p> For a given algebra, the denotation of a LOAL function is a mapping from tuples of arguments to sets of possible results. Such mappings are related by analogy to the definition 52 of logical relations <ref> [59] </ref> [49]. <p> In the study of the lambda calculus, this kind of theorem is known as the fundamental theorem of logical relations <ref> [59] </ref> [49] [37]. Showing such a theorem is another route to justifying the definition of legal subtype relations [34, Chapter 7] [37, Section 2.4], but one that is outside the scope of this paper.
Reference: [60] <author> Stein, L. A., Lieberman, H., and Ungar, D. </author> <title> A shared view of sharing: The treaty of Orlando. </title> <editor> In Kim, W. and Lochovsky, F. H., editors, </editor> <booktitle> Object-Oriented Concepts, Databases, and Applications, chapter 3, </booktitle> <pages> pages 31-48. </pages> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1989. </year>
Reference-contexts: But using instance variables also has problems, because implementations are no longer free to choose their own instance variables and because such instance variables must be visible to clients. 9 Some object-oriented languages do not have classes, but are based on the notion of delegation [41] <ref> [60] </ref>. In such languages, specified class operations might be implemented by functions that clone prototypes, or by instance operations of prototypes.
Reference: [61] <author> Utting, M. </author> <title> An Object-Oriented Refinement Calculus with Modular Reasoning. </title> <type> PhD thesis, </type> <institution> University of New South Wales, Kensington, Australia, </institution> <year> 1992. </year> <note> Draft of February 1992 obtained from the Author. </note>
Reference-contexts: Their requirements for the pre-condition are similar, but in the opposite order. SPEC j= (Pre (g; U)[w=u]) ) (Post (g; W)) (116) That such implications only have to hold for objects of the subtype is key <ref> [61] </ref>. <p> trait functions is more general. * Because we do not require transfer functions, but allow relations, we can specify subtypes for which abstract values of the subtype simulate more than one abstract value of the supertype. 8.3.4 Utting's work Utting's work on the specification and verification of object-oriented programs [62] <ref> [61] </ref> is in the framework of the refinement calculus. He also shows how to do modular reasoning. His work handles mutation, unlike ours which only deals with immutable objects. However, his work does not allow for change of object representations (data refinement).
Reference: [62] <author> Utting, M. and Robinson, K. </author> <title> Modular reasoning in an object-oriented refinement calculus. In Bird, </title> <editor> R. S., Morgan, C. C., and Woodcock, J. C. P., editors, </editor> <booktitle> Mathematics of Program Construction, Second International Conference, Oxford, U.K., June/July, volume 669 of Lecture Notes in Computer Science, </booktitle> <pages> pages 344-367. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: the trait functions is more general. * Because we do not require transfer functions, but allow relations, we can specify subtypes for which abstract values of the subtype simulate more than one abstract value of the supertype. 8.3.4 Utting's work Utting's work on the specification and verification of object-oriented programs <ref> [62] </ref> [61] is in the framework of the refinement calculus. He also shows how to do modular reasoning. His work handles mutation, unlike ours which only deals with immutable objects. However, his work does not allow for change of object representations (data refinement).
Reference: [63] <author> Wing, J. M. </author> <title> Writing Larch interface language specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: , s 2 : C (s 1 eqSet s 2 ) == (s 1 = s 2 ) isEmpty (s 1 ) == (s 1 = fg) 2 Polymorphic Type Specifications The interface specification language Larch/LOAL is adapted from Wing's interface specification language for CLU [64] [43, Chapter 10] [24] <ref> [63] </ref> and Chen's Larch/Generic interface specification language [11]. However, unlike Larch/CLU, Larch/LOAL specifications deal only with immutable types. An interface specification describes both the behavior of abstract types and how they can be used in a program [33] [26].
Reference: [64] <author> Wing, J. M. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year> <month> 95 </month>
Reference-contexts: have to go back and reverify the implementation of inBoth when it becomes possible to pass it arguments of type Interval? The standard technique used to specify a polymorphic module is to specify the behavior of the operations that the polymorphic module needs to do its work [25, Page 21] <ref> [64, Section 4.2.3] </ref> [20, Page 537]. The specification of such operations is often collected into the specification of a "type parameter". For example, roughly following Goguen, one might specify the function inBoth as in Figure 3. <p> Bool asserts 8 s 1 , s 2 : C (s 1 eqSet s 2 ) == (s 1 = s 2 ) isEmpty (s 1 ) == (s 1 = fg) 2 Polymorphic Type Specifications The interface specification language Larch/LOAL is adapted from Wing's interface specification language for CLU <ref> [64] </ref> [43, Chapter 10] [24] [63] and Chen's Larch/Generic interface specification language [11]. However, unlike Larch/CLU, Larch/LOAL specifications deal only with immutable types. An interface specification describes both the behavior of abstract types and how they can be used in a program [33] [26]. <p> The trait functions are used to generate the carrier sets as specified in the used traits [26]; they are also used in the evaluation of the assertions used in specifications <ref> [64, Chapter 2] </ref>. The methods are used by LOAL programs for computation. The trait functions cannot be invoked by programs, and the methods cannot be used in specifications. To model nondeterministic procedures, the methods are set-valued functions; that is, a method returns a set of the possible results [51] [52].
References-found: 64

