URL: http://www.iro.umontreal.ca/~caussinu/CaMcThVo.ps
Refering-URL: http://www.iro.umontreal.ca/~caussinu/
Root-URL: http://www.iro.umontreal.ca
Title: Nondeterministic NC 1 computation  
Author: Herve Caussinus and Pierre McKenzie Denis Therien Heribert Vollmer 
Address: C.P. 6128, Succursale Centre-ville Montreal (Quebec), H3C 3J7 Canada  3480 University Street Am Exerzierplatz 3 Montreal (Quebec), H3A 2A7 Canada D-97072 Wurzburg, Germany  
Affiliation: Dep. d'informatique et recherche operationnelle Universite de Montreal  School of Computer Science Theoretische Informatik McGill University Universitat Wurzburg  
Abstract: We define the counting classes #NC 1 , GapNC 1 , PNC 1 and C = NC 1 . We prove that boolean circuits, algebraic circuits, programs over nondeterministic finite automata, and programs over constant integer matrices yield equivalent definitions of the latter three classes. We investigate closure properties. We observe that #NC 1 #L and that C = NC 1 L. Then we exploit our finite automaton model and extend the padding techniques used to investigate leaf languages. Finally, we draw some consequences from the resulting body of leaf language characterizations of complexity classes, including the unconditional separation of ACC 0 from MOD-PH as well as that of TC 0 from the counting hierarchy. Moreover we obtain that dlogtime-uniformity and logspace-uniformity for AC 0 coincide if and only if the polynomial time hierarchy equals PSPACE . 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Allender and M. Ogihara. </author> <title> Relationships among PL, #L, and the determinant. </title> <booktitle> Proc. 9th Structure in Complexity Theory, </booktitle> <pages> pages 267-278, </pages> <year> 1994. </year>
Reference-contexts: Corollary 4.11 PNC 1 is closed under union and intersection. Proof. Follows from the established closure properties by reproducing the corresponding proof for PP from [6] or for PL from <ref> [1] </ref> essentially word for word.
Reference: [2] <author> E. Allender and V. Gore. </author> <title> A uniform circuit lower bound for the permanent. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23 </volume> <pages> 1026-1049, </pages> <year> 1994. </year>
Reference-contexts: Corollary 5.4 1. ACC 0 6= MOD-PH. 2. TC 0 6= CH. Proof. Immediate from Theorem 5.3 and known leaf language characterizations from [12, 14]. Statement 1 of Corollary 5.4 improves a result by Allender and Gore <ref> [2] </ref> who showed that ACC 0 ae C = P .
Reference: [3] <author> C. Alvarez and B. Jenner. </author> <title> A very hard log-space counting class. </title> <journal> Theoretical Computer Science, </journal> <volume> 107 </volume> <pages> 3-30, </pages> <year> 1993. </year>
Reference-contexts: Then, the logspace fl Work supported by NSERC of Canada and by FCAR du Quebec. y Work supported by the Alexander von Humboldt Foundation under a Feodor Lynen scholarship. counting class #L was investigated <ref> [3] </ref>, together with many logspace variants adapted from the polynomial time case. Recently, counting classes based on finite model theory and on one-way logspace have been considered as well [20, 9].
Reference: [4] <author> D. </author> <title> Mix Barrington. Bounded-width polynomial-size branching programs recognize exactly those languages in N C 1 . Journal of Computer and System Sciences, </title> <booktitle> 38 </booktitle> <pages> 150-164, </pages> <year> 1989. </year>
Reference-contexts: Motivated by Barrington's characterization of NC 1 via bounded-width branching programs of polynomial size <ref> [4] </ref>, we also consider a class we call #BP . <p> The automaton will never change its state when reading the symbol $, so we can assume w.l.o.g. that T x 2 QBF ? . Now consider a "Barrington word" <ref> [4] </ref>, defined over the group S 5 and the variables X and Y as 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 This word has the property that it calculates NAND (X; Y ) if the identity permutation () represents "false" and the <p> A model which we chose not to exploit in the present paper is the program-over-monoid model, instrumental to the known algebraic characterizations of NC 1 subclasses (see <ref> [4, 5, 19] </ref>). However, nonde-terminism can be introduced into that model in natural ways. The first author has shown that much of the padding discussed in the present paper can be performed using very restricted monoids.
Reference: [5] <author> D. Barrington and D. Therien, </author> <title> Finite Monoids and the Fine Structure of NC 1 , Journal of the Association of Computing Machinery, </title> <address> 35:4:941-952, </address> <year> 1988. </year>
Reference-contexts: A model which we chose not to exploit in the present paper is the program-over-monoid model, instrumental to the known algebraic characterizations of NC 1 subclasses (see <ref> [4, 5, 19] </ref>). However, nonde-terminism can be introduced into that model in natural ways. The first author has shown that much of the padding discussed in the present paper can be performed using very restricted monoids.
Reference: [6] <author> R. Beigel, N. Reingold, and D. Spielman. </author> <title> P P is closed under intersection. </title> <booktitle> Proc. 23rd Symposium on Theory of Computing, </booktitle> <pages> pages 1-9, </pages> <year> 1991. </year>
Reference-contexts: Corollary 4.11 PNC 1 is closed under union and intersection. Proof. Follows from the established closure properties by reproducing the corresponding proof for PP from <ref> [6] </ref> or for PL from [1] essentially word for word.
Reference: [7] <author> M. Ben-Or and R. Cleve. </author> <title> Computing algebraic formulas using a constant number of register. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21(1) </volume> <pages> 54-58, </pages> <year> 1992. </year>
Reference-contexts: This result is proved in two steps: First, we observe that #BP can be characterized by what we call programs over constant matrices; and then we use a result by Ben-Or and Cleve <ref> [7] </ref> who show that evaluating an arithmetic circuit reduces to iterated product of constant-size matrices. <p> Theorem 3.2 GapBP = BP M (Z) = ALG (Z) = GapNC 1 : Proof sketch. GapNC 1 ALG (Z) follows from #NC 1 ALG (N), and ALG (Z) BP M (Z) is a consequence of Ben-Or and Cleve's theorem <ref> [7] </ref>. Now to prove BP M (Z) GapBP , we expand each matrix entry x 2 Z: x becomes 0 x if x 0, and x be comes x 0 otherwise.
Reference: [8] <author> D. Bovet, P. Crescenzi, and R. Silvestri. </author> <title> A uniform approach to define complexity classes. </title> <journal> Theoretical Computer Science, </journal> <volume> 104 </volume> <pages> 263-283, </pages> <year> 1992. </year>
Reference-contexts: x) 2 Y g : The class Leaf NC 1 (Y ) is the class of languages rec ognized by uniform polynomial length programs with leaf language Y . 5.1 Padding techniques Leaf language classes have been studied in the context of polynomial time, logarithmic space, and logarithmic time computations <ref> [8, 12, 13, 14] </ref>. The numerous characterizations obtained in those papers make use of padding. Here we observe that in some sense the padding can be done by an automaton. This allows transferring in one blow many known character izations to the Leaf NC 1 () setting.
Reference: [9] <author> H.-J. Burtschick, </author> <title> Comparing Counting Classes for Logspace, One-Way Logspace, and First-Order. </title> <booktitle> Proc. of the 20th Symposium on Mathematical Foundations of Computer Science, </booktitle> <pages> pages 139-148, </pages> <year> 1995. </year>
Reference-contexts: Recently, counting classes based on finite model theory and on one-way logspace have been considered as well <ref> [20, 9] </ref>.
Reference: [10] <author> S. Fenner, L. Fortnow, and S. Kurtz. </author> <title> Gap-definable counting classes. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 48 </volume> <pages> 116-148, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction Counting classes have been studied extensively since the introduction of #P by Valiant [22]. A number of such classes were first defined in the context of polynomial time computation <ref> [16, 10] </ref>. Then, the logspace fl Work supported by NSERC of Canada and by FCAR du Quebec. y Work supported by the Alexander von Humboldt Foundation under a Feodor Lynen scholarship. counting class #L was investigated [3], together with many logspace variants adapted from the polynomial time case. <p> Corollary 4.10 GapNC 1 is closed under subtraction, weak sum, weak product, and binomial coefficients. Proof sketch. The only nontrivial point is closure under binomial coefficients, but this follows from the other closure properties by expressing binomial coeffi cients involving negative numbers as in <ref> [10] </ref>. Corollary 4.11 PNC 1 is closed under union and intersection. Proof. Follows from the established closure properties by reproducing the corresponding proof for PP from [6] or for PL from [1] essentially word for word.
Reference: [11] <author> U. Hertrampf. </author> <title> Complexity classes defined via k-valued logic. </title> <booktitle> Proc. 9th Structure in Complexity Theory, </booktitle> <pages> pages 224-234, </pages> <year> 1994. </year>
Reference-contexts: Which value to take and which function to evaluate depends only on the state of the machine. For an exact definition, see <ref> [11, 13] </ref>.) Then we can state the following: Theorem 5.1 Leaf NC 1 ((F )LOGTIME) = (F )P . Proof sketch. <p> Leaf NC 1 (AC 0 ) = PH . 4. Leaf NC 1 (ACC 0 ) = MOD-PH. 5. Leaf NC 1 (TC 0 ) = CH. 6. Leaf NC 1 (NC 1 ) = PSPACE . Proof. All mentioned classes are locally definable as shown in <ref> [11] </ref> or can be shown with very similar meth ods to those used there. Using our leaf language padding techniques we can now observe the following: Theorem 5.3 1. If C L Leaf NC 1 (C), then C 6= Leaf NC 1 (C). 2.
Reference: [12] <author> U. Hertrampf, C. Lautemann, T. Schwentick, H. Vollmer, and K.W. Wagner. </author> <title> On the power of polynomial time bit-reductions. </title> <booktitle> Proc. 8th Structure in Complexity Theory, </booktitle> <pages> pages 200-207, </pages> <year> 1993. </year>
Reference-contexts: We then proceed to refine known leaf language characterizations of complexity classes, using the formal framework of leaf languages for branching programs (which we call NC 1 leaf languages). We argue that many characterizability results carry over from the polynomial time <ref> [12] </ref> and logspace [14] cases to that of NC 1 . We then draw consequences from the leaf language characterizations 2 . <p> x) 2 Y g : The class Leaf NC 1 (Y ) is the class of languages rec ognized by uniform polynomial length programs with leaf language Y . 5.1 Padding techniques Leaf language classes have been studied in the context of polynomial time, logarithmic space, and logarithmic time computations <ref> [8, 12, 13, 14] </ref>. The numerous characterizations obtained in those papers make use of padding. Here we observe that in some sense the padding can be done by an automaton. This allows transferring in one blow many known character izations to the Leaf NC 1 () setting. <p> If C L Leaf NC 1 (C), then C 6= Leaf NC 1 (C). 2. If C P Leaf NC 1 (C), then C 6= Leaf NC 1 (C). Proof. Suppose C P Leaf NC 1 (C) = D. Then Leaf NC 1 (D) EXPTIME <ref> [12] </ref>. Thus the assumption that C = Leaf NC 1 (C) leads to the wrong conclusion that P = EXPTIME . The proof for the first claim is completely analogous. <p> Let SAC (log log n) denote the class of functions computable by semi-unbounded circuits of depth log log n (see [14]). Corollary 5.4 1. ACC 0 6= MOD-PH. 2. TC 0 6= CH. Proof. Immediate from Theorem 5.3 and known leaf language characterizations from <ref> [12, 14] </ref>. Statement 1 of Corollary 5.4 improves a result by Allender and Gore [2] who showed that ACC 0 ae C = P .
Reference: [13] <author> U. Hertrampf, H. Vollmer, K. Wagner. </author> <title> On balanced vs. unbalanced computation trees. </title> <journal> Mathematical Systems Theory, </journal> <note> to appear. </note>
Reference-contexts: x) 2 Y g : The class Leaf NC 1 (Y ) is the class of languages rec ognized by uniform polynomial length programs with leaf language Y . 5.1 Padding techniques Leaf language classes have been studied in the context of polynomial time, logarithmic space, and logarithmic time computations <ref> [8, 12, 13, 14] </ref>. The numerous characterizations obtained in those papers make use of padding. Here we observe that in some sense the padding can be done by an automaton. This allows transferring in one blow many known character izations to the Leaf NC 1 () setting. <p> Which value to take and which function to evaluate depends only on the state of the machine. For an exact definition, see <ref> [11, 13] </ref>.) Then we can state the following: Theorem 5.1 Leaf NC 1 ((F )LOGTIME) = (F )P . Proof sketch. <p> Observe that the length of leaves (P; x 1 x n ) is 2 p (n) . The proof now follows that of Theorem 3.1 in <ref> [13] </ref>. Let CH denote the counting hierarchy, i.e., the union of all classes of the oracle hierarchy obtained by using the class PP as base class (see [25]). Corollary 5.2 1. Leaf NC 1 ( k LOGTIME) = p 2. Leaf NC 1 ( k LOGTIME) = p 3.
Reference: [14] <author> B. Jenner, P. McKenzie, and D. Therien. </author> <title> Logspace and logtime leaf languages. </title> <booktitle> Proc. 9th Structure in Complexity Theory, </booktitle> <pages> pages 242-254, </pages> <year> 1994. </year>
Reference-contexts: We then proceed to refine known leaf language characterizations of complexity classes, using the formal framework of leaf languages for branching programs (which we call NC 1 leaf languages). We argue that many characterizability results carry over from the polynomial time [12] and logspace <ref> [14] </ref> cases to that of NC 1 . We then draw consequences from the leaf language characterizations 2 . <p> x) 2 Y g : The class Leaf NC 1 (Y ) is the class of languages rec ognized by uniform polynomial length programs with leaf language Y . 5.1 Padding techniques Leaf language classes have been studied in the context of polynomial time, logarithmic space, and logarithmic time computations <ref> [8, 12, 13, 14] </ref>. The numerous characterizations obtained in those papers make use of padding. Here we observe that in some sense the padding can be done by an automaton. This allows transferring in one blow many known character izations to the Leaf NC 1 () setting. <p> Thus the assumption that C = Leaf NC 1 (C) leads to the wrong conclusion that P = EXPTIME . The proof for the first claim is completely analogous. Let SAC (log log n) denote the class of functions computable by semi-unbounded circuits of depth log log n (see <ref> [14] </ref>). Corollary 5.4 1. ACC 0 6= MOD-PH. 2. TC 0 6= CH. Proof. Immediate from Theorem 5.3 and known leaf language characterizations from [12, 14]. Statement 1 of Corollary 5.4 improves a result by Allender and Gore [2] who showed that ACC 0 ae C = P . <p> Let SAC (log log n) denote the class of functions computable by semi-unbounded circuits of depth log log n (see [14]). Corollary 5.4 1. ACC 0 6= MOD-PH. 2. TC 0 6= CH. Proof. Immediate from Theorem 5.3 and known leaf language characterizations from <ref> [12, 14] </ref>. Statement 1 of Corollary 5.4 improves a result by Allender and Gore [2] who showed that ACC 0 ae C = P . <p> Then we give a two-fold improvement to the surprising (but already somewhat technical) result, shown in <ref> [14] </ref>, that Leaf Logspace (DCFL) = PSPACE : first, we can produce the leaf string with an automaton instead of a log space Turing machine, and second, the language at the leaves can be taken to be a linear deterministic language. (A context-free language is said to be linear if it <p> This concludes the proof that PSPACE Leaf NC 1 (logspace-uniform AC 0 ); the reverse inclusion follows from the known fact that Leaf NC 1 (L) PSPACE <ref> [14] </ref>. Corollary 5.6 If AC 0 is equal to logspace-uniform AC 0 then PH = PSPACE . Eric Allender (personal communication, 1995) pointed out that the converse also holds. Thus we have that dlogtime and logspace uniformity for AC 0 coincide iff PH = PSPACE . <p> We will now prove that PSPACE Leaf NC 1 (L D1C ); the reverse inclusion is immediate from <ref> [14] </ref>.
Reference: [15] <author> J. Jiao. </author> <title> Some questions concerning circuit counting classes and other low level complexity classes. </title> <type> Manuscript. </type>
Reference-contexts: Thus we define #NC 1 as the set of functions counting the number of accepting proof trees of NC 1 circuits. (This definition has also been suggested by Jia Jiao <ref> [15] </ref>.) It is common folklore that this class equals the class of functions computed by logarithmic depth arithmetic circuits over the semiring of the natural numbers. Motivated by Barrington's characterization of NC 1 via bounded-width branching programs of polynomial size [4], we also consider a class we call #BP . <p> tree which includes the output gate of C n , which has one wire into each OR gate, which has two wires into each AND gate, and which evaluates to 1 on input x. (That we unwound the circuit into a tree before counting proof trees follows recent literature, e.g. <ref> [15, 23] </ref>.) We denote by #accept (C; x) the number of proof trees for x. A function f : fl ! N is in #NC 1 iff there exists a uniform boolean circuit C such that f (x) = #accept (C; x). <p> The inclusion BP M (N) ALG (N) follows by divide and conquer, since the matrices involved in BP M (N) are constant matrices. Equality of #NC 1 and ALG (N) is common folklore, see e.g. <ref> [15, 23] </ref>. Finally, to show #NC 1 #L, consider a #NC 1 circuit. A nondeterministic logspace machine can perform a modified depth-first search of this circuit, as follows.
Reference: [16] <author> J. Kobler, U. Schoning, and J. Toran. </author> <title> On counting and approximation. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 363-379, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Counting classes have been studied extensively since the introduction of #P by Valiant [22]. A number of such classes were first defined in the context of polynomial time computation <ref> [16, 10] </ref>. Then, the logspace fl Work supported by NSERC of Canada and by FCAR du Quebec. y Work supported by the Alexander von Humboldt Foundation under a Feodor Lynen scholarship. counting class #L was investigated [3], together with many logspace variants adapted from the polynomial time case.
Reference: [17] <author> K.-J. Lange, </author> <title> Unambiguity of circuits, </title> <journal> Theoretical Computer Science, </journal> <volume> 107 </volume> <pages> 77-94, </pages> <year> 1993. </year>
Reference-contexts: Now we say that a circuit C is unambiguous if, for each input x, #accept (C; x) 2 f0; 1g. For later use, we mention that the class NC 1 is unchanged if unambigious circuits alone are used to define it <ref> [17] </ref>. 4 Closure properties Clearly all the function classes examined in the previous sections are closed under addition and multiplication.
Reference: [18] <author> R. J. Lipton and Y. Zalcstein. </author> <title> Word problems solvable in logspace. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 24(3) </volume> <pages> 522-526, </pages> <year> 1977. </year>
Reference-contexts: All equalities are immediate consequences of Theorem 3.2. Now Lipton and Zalcstein in effect prove C =0 BP M (Z) L <ref> [18] </ref>, and C BP PL is obvious. Corollary 3.3 motivates defining PNC 1 as C NC 1 . Theorem 3.1 and the definition of N C 1 imply that C &gt;0 ALG (N) = NC 1 .
Reference: [19] <author> P. McKenzie, P. Peladeau and D. Therien, </author> <title> NC 1 : The Automata-Theoretic Viewpoint, </title> <booktitle> Computational Complexity 1, </booktitle> <pages> 330-359, </pages> <year> 1991. </year>
Reference-contexts: A model which we chose not to exploit in the present paper is the program-over-monoid model, instrumental to the known algebraic characterizations of NC 1 subclasses (see <ref> [4, 5, 19] </ref>). However, nonde-terminism can be introduced into that model in natural ways. The first author has shown that much of the padding discussed in the present paper can be performed using very restricted monoids.
Reference: [20] <author> S. Saluja, K. V. Subrahmanyam, and M. N. Thakur. </author> <title> Descriptive complexity of #P functions. </title> <booktitle> Proc. 7th Structure in Complexity Theory, </booktitle> <pages> pages 169-184, </pages> <year> 1992. </year>
Reference-contexts: Recently, counting classes based on finite model theory and on one-way logspace have been considered as well <ref> [20, 9] </ref>. <p> This class is defined by counting accepting paths in nondeterministic branching programs (which are defined as 1 It is well known that adding nondeterministic input bits to an NC 1 circuit results in a computation model powerful enough to solve NP-complete problems (see e.g. <ref> [20, 24] </ref>). regular branching programs having the extra capabil-ity to branch nondeterministically without consuming an input bit). This class can equivalently be defined by considering regular (i.e., deterministic) branching programs which output a sequence of elements from a given alphabet.
Reference: [21] <author> S. </author> <title> Toda. Classes of arithmetic circuits capturing the complexity of computing the determinant. </title> <journal> IEICE Transactions on Communications/Electronics/Information and Systems, </journal> <volume> E75-D: </volume> <pages> 116-124, </pages> <year> 1992. </year>
Reference-contexts: The inclusion #BP BP M (N) is straightforward. To show BP M (N) #BP , we appeal to Toda's expression of an entry in a product of matrices over N as the number of paths from a node s to a node t in a layered graph <ref> [21] </ref>. The number of layers in Toda's graph grows with the number of matrices to be multiplied, but the number of nodes in a layer only depends on the entries and dimensions of the matrices (and is hence bounded by some constant c here).
Reference: [22] <author> L. Valiant. </author> <title> The complexity of computing the permanent. </title> <booktitle> Theoretical Computer Science 8 </booktitle> <pages> 189-201, </pages> <year> 1979 </year>
Reference-contexts: 1 Introduction Counting classes have been studied extensively since the introduction of #P by Valiant <ref> [22] </ref>. A number of such classes were first defined in the context of polynomial time computation [16, 10].
Reference: [23] <author> V. Vinay. </author> <title> Counting auxiliary pushdown automata and semi-unbounded arithmetic circuits. </title> <booktitle> Proc. 6th Structure in Complexity Theory, </booktitle> <pages> pages 270-284, </pages> <year> 1991. </year>
Reference-contexts: Given that the basic counting classes #P and #L are defined by counting the number of accepting paths in a nondeterministic computation, what "nondeterministic NC 1 " accepting paths are there to be counted 1 ? We propose a definition inspired by Vinay's circuit characterization of #LOGCFL <ref> [23] </ref>. <p> tree which includes the output gate of C n , which has one wire into each OR gate, which has two wires into each AND gate, and which evaluates to 1 on input x. (That we unwound the circuit into a tree before counting proof trees follows recent literature, e.g. <ref> [15, 23] </ref>.) We denote by #accept (C; x) the number of proof trees for x. A function f : fl ! N is in #NC 1 iff there exists a uniform boolean circuit C such that f (x) = #accept (C; x). <p> The inclusion BP M (N) ALG (N) follows by divide and conquer, since the matrices involved in BP M (N) are constant matrices. Equality of #NC 1 and ALG (N) is common folklore, see e.g. <ref> [15, 23] </ref>. Finally, to show #NC 1 #L, consider a #NC 1 circuit. A nondeterministic logspace machine can perform a modified depth-first search of this circuit, as follows.
Reference: [24] <author> H. Vollmer and K.W. Wagner. </author> <title> Recursion theoretic characterizations of complexity classes of counting functions. </title> <note> To appear in Theoretical Computer Science. </note>
Reference-contexts: This class is defined by counting accepting paths in nondeterministic branching programs (which are defined as 1 It is well known that adding nondeterministic input bits to an NC 1 circuit results in a computation model powerful enough to solve NP-complete problems (see e.g. <ref> [20, 24] </ref>). regular branching programs having the extra capabil-ity to branch nondeterministically without consuming an input bit). This class can equivalently be defined by considering regular (i.e., deterministic) branching programs which output a sequence of elements from a given alphabet. <p> Corollary 4.7 C = NC 1 PNC 1 . To establish more closure properties of PNC 1 , we first address some nontrivial closure properties of #NC 1 and GapNC 1 . The following terminology is from <ref> [24] </ref>: Let F be a class of functions. We say that F is closed under weak summation if for every f 2 F and every c 2 N we have that the function h defined as h (x) = y=0 f (x; y) is also in F.
Reference: [25] <author> K.W. Wagner. </author> <title> Some observations on the connection between counting and recursion. </title> <journal> Theoretical Computer Science, </journal> <volume> 47 </volume> <pages> 131-147, </pages> <year> 1986. </year>
Reference-contexts: The proof now follows that of Theorem 3.1 in [13]. Let CH denote the counting hierarchy, i.e., the union of all classes of the oracle hierarchy obtained by using the class PP as base class (see <ref> [25] </ref>). Corollary 5.2 1. Leaf NC 1 ( k LOGTIME) = p 2. Leaf NC 1 ( k LOGTIME) = p 3. Leaf NC 1 (AC 0 ) = PH . 4. Leaf NC 1 (ACC 0 ) = MOD-PH. 5. Leaf NC 1 (TC 0 ) = CH. 6.
References-found: 25

