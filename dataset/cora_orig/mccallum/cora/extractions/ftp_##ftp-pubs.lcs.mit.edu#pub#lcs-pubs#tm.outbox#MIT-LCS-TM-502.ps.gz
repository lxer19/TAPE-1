URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tm.outbox/MIT-LCS-TM-502.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/catatm.html
Root-URL: 
Email: rosario,silvio@theory.lcs.mit.edu  
Title: Verifiable Secret Sharing as Secure Computation  
Author: Rosario Gennaro Silvio Micali 
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: We present a stronger notion of verifiable secret sharing and exhibit a protocol implementing it. We show that our new notion is preferable to the old ones whenever verifiable secret sharing is used as a tool within larger protocols, rather than being a goal in itself. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M.BenOr, S.Goldwasser, A.Wigderson, </author> <title> Completeness Theorems for Non-Cryptographic Fault-Tolerant Distributed Computation, </title> <booktitle> Proceedings of STOC 1988 </booktitle>
Reference-contexts: In the second stage, the already committed value v will be recovered by all good players (again, no matter what the bad players might do). Prior work. Several definitions and protocols for VSS have been proposed in the past ten years (E.g., <ref> [3, 1, 2, 4, 11] </ref>.) We contend, however, that these notions and these protocols are of very limited use. <p> We modify an earlier VSS protocol of <ref> [1] </ref> and show that it is secure according to our notion. 2 Prior work In order to focus on the difficulties that are proper of VSS, in this extended abstract we shall deal with a simple computational model, both when reviewing prior work and when presenting our new one. <p> 2. (t-uniformity.) 8l t there exists an integer n l such that 8 s i 1 ; : : : ; s i l 2 and 8 v 1 ; : : : ; v n1 2 , 8 s 2 S, and 8~x 2 n such that 8j 2 <ref> [1; l] </ref> x i j = s i j , there exist exactly n l values r 1 ; : : : ; r n l 2 R such that for i = 1; : : : ; n l , shar (v 1 ; : : : ; v n1 <p> For the time being, we will be content of exhibiting a simpler VSS protocol secure in our sense and with fault-tolerance n=3, by modifying an older protocol of Ben-Or, Goldwasser, and Wigderson <ref> [1] </ref>. The modification actually occurs only in the Recover part, and uses techniques also developed by [1], but within their "computational protocol" rather than in their VSS protocol. <p> For the time being, we will be content of exhibiting a simpler VSS protocol secure in our sense and with fault-tolerance n=3, by modifying an older protocol of Ben-Or, Goldwasser, and Wigderson <ref> [1] </ref>. The modification actually occurs only in the Recover part, and uses techniques also developed by [1], but within their "computational protocol" rather than in their VSS protocol. Let n = 3t + 1 and P 1 ; : : : ; P n1 ; P n = D be the set of players, D being the dealer. <p> Then we can state that Lemma 2 Protocol Share-Verify securely evaluates the function shar according to Definition 2. Proof To be presented in the full paper. (No proof of this protocol has yet appeared.) The Recover protocol is modified with respect to the one in <ref> [1] </ref> in order to make it a secure computation of the function rec. Protocol Recover (Modified): 1. Each player P i chooses random polynomials p i (x); q i1 (x); : : : ; q im (x) all with free term 0.
Reference: [2] <author> D.Chaum, C.Crepeau, I.Damgard, </author> <title> Multiparty Unconditionally Secure Protocols, </title> <booktitle> Proceedings of STOC 1988, </booktitle> <address> pp.11-19 </address>
Reference-contexts: In the second stage, the already committed value v will be recovered by all good players (again, no matter what the bad players might do). Prior work. Several definitions and protocols for VSS have been proposed in the past ten years (E.g., <ref> [3, 1, 2, 4, 11] </ref>.) We contend, however, that these notions and these protocols are of very limited use.
Reference: [3] <author> B.Chor, S.Goldwasser, S.Micali, B.Awerbuch, </author> <title> Verifiable Secret Sharing and achieving simultaneity in the presence of faults, </title> <booktitle> Proceedings of FOCS 1985, </booktitle> <pages> pp. 383-395. </pages>
Reference-contexts: Despite the centrality and the maturity of this concept (almost 10 years passed from its original introduction), we shall advocate that a stronger and better definition of a VSS is needed. The intuitive notion of a VSS. As first introduced by Chor, Goldwasser, Micali and Awerbuch in <ref> [3] </ref>, a VSS protocol consists of a two-stage protocol. Informally, there are n players, t of which may be bad and deviate from their prescribed instructions. One of the players, the dealer, possesses a value s as a secret input. <p> In the second stage, the already committed value v will be recovered by all good players (again, no matter what the bad players might do). Prior work. Several definitions and protocols for VSS have been proposed in the past ten years (E.g., <ref> [3, 1, 2, 4, 11] </ref>.) We contend, however, that these notions and these protocols are of very limited use.
Reference: [4] <author> P.Feldman, S.Micali, </author> <title> An Optimal Probabilistic Protocol for synchronous Byzan-tine Agreement, </title> <note> Proceedings of STOC 1988, final version in MIT-LCS TR425.b </note>
Reference-contexts: In the second stage, the already committed value v will be recovered by all good players (again, no matter what the bad players might do). Prior work. Several definitions and protocols for VSS have been proposed in the past ten years (E.g., <ref> [3, 1, 2, 4, 11] </ref>.) We contend, however, that these notions and these protocols are of very limited use. <p> Indeed, and unfortunately, it is by now a well-known phenomenon that protocols that are secure by themselves, cease to be secure when used as a sub-protocols. (For instance, <ref> [4] </ref> used their VSS as a tool to reach Byzantine agreement, and thus had to argue that their overall protocol was secure "from scratch" rather than in a "modular way." Of course, such proofs from scratch tend to be overly long and complex.) Our work. <p> We say that such an adversary is a t-adversary ( 0 t n ) if t is an upper bound on the number of processors she can corrupt (t is also referred to as the fault-tolerance of the protocol.) This computational model is precisely discussed in <ref> [4] </ref> and [9]. Prior definitions of VSS To exactly capture the informal idea of a VSS, has proven to be an hard task in itself. The definition reviewed below is that of [4], which relies on the notion of a fixed event: Definition: We say that an event X is fixed <p> (t is also referred to as the fault-tolerance of the protocol.) This computational model is precisely discussed in <ref> [4] </ref> and [9]. Prior definitions of VSS To exactly capture the informal idea of a VSS, has proven to be an hard task in itself. The definition reviewed below is that of [4], which relies on the notion of a fixed event: Definition: We say that an event X is fixed at a given round in an execution E of a protocol, if X occurs in any execution E 0 of the protocol coinciding with E up to the given round. <p> Also, as we shall see below, by demanding that both components (and particularly the second one) of a share-reconstructing pair be securely evaluated, we are putting an unusually strong requirement on a VSS protocol. But it is exactly this requirement that will guarantee the desired reducibility property. 2 In <ref> [4] </ref> they use the terminology sequence protocols for this kind of interaction between two protocols 6 4 Comparison with previous definitions of VSS Let us compare now Definition 3 and Definition 1, our token example of prior VSS definitions. <p> This problem with Definition 1 could be easily solved by substituting property 3 (unpredictability) with a stronger one based on zero-knowledge and simulatability of Share-Verify. In <ref> [4] </ref> they shortly address this point. But, still, this would not solve all the problems. Indeed, another important difference between our definition and the previous one is that we require the computation of the function rec to be secure, i.e. simulatable.
Reference: [5] <author> O.Goldreich, S.Micali, A.Wigderson, </author> <title> Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems, </title> <journal> J. of the ACM, Vol.38, </journal> <volume> No.1, </volume> <pages> pp. 691-729, </pages> <year> 1991 </year>
Reference: [6] <author> O.Goldreich, S.Micali, A.Wigderson, </author> <title> How to play any mental game, </title> <booktitle> Proceedings of STOC 1987 </booktitle>
Reference-contexts: And she can still corrupt players after the function has been evaluated and learn their outputs. These problems should, however, be regarded as inevitable. Indeed, following <ref> [6] </ref>, [9] call a protocol for evaluating f secure if it approximates the above ideal scenario "as closely as possible." The nature of this approximation is informally summarized below. Definition (Initial configuration, traffic, input and output): Let us define the following quantities within the context of a protocol P .
Reference: [7] <author> S.Goldwasser, S.Micali, </author> <title> Probabilistic Encryption, </title> <journal> J. of Computer and System Sciences, Vol.18, No.1, pp.186-208 </journal>
Reference: [8] <author> S.Goldwasser, S.Micali, C.Rackoff, </author> <title> The knowledge complexity of interactive proof systems, </title> <journal> in SIAM J. Comput. Vol.18 No.1, </journal> <pages> pp 186-208, </pages> <year> 1989. </year>
Reference: [9] <author> S.Micali, P.Rogaway, </author> <title> Secure Computation, </title> <note> Proceedings of CRYPTO 1991, final version available from the authors. </note>
Reference-contexts: In this paper we put forward a definition of VSS that guarantees reducibility; that is, security even when VSS is used as a sub-routine in an otherwise secure protocol. A notion of security that guarantees reducibility has been presented by Micali and Rogaway <ref> [9] </ref>, but for the problem of function evaluation. We thus wish to extend reducibility-guaranteeing notions of security to verifiable secret sharing protocols and concretely exhibit VSS protocols that provably satisfy these notions. More precisely, in this paper we achieve the following goals: 1. <p> We say that such an adversary is a t-adversary ( 0 t n ) if t is an upper bound on the number of processors she can corrupt (t is also referred to as the fault-tolerance of the protocol.) This computational model is precisely discussed in [4] and <ref> [9] </ref>. Prior definitions of VSS To exactly capture the informal idea of a VSS, has proven to be an hard task in itself. <p> Let us summarize the definition of secure function evaluation of <ref> [9] </ref>. <p> And she can still corrupt players after the function has been evaluated and learn their outputs. These problems should, however, be regarded as inevitable. Indeed, following [6], <ref> [9] </ref> call a protocol for evaluating f secure if it approximates the above ideal scenario "as closely as possible." The nature of this approximation is informally summarized below. Definition (Initial configuration, traffic, input and output): Let us define the following quantities within the context of a protocol P . <p> In particular, the following one: the <ref> [9] </ref> definition allows one to prove formally many desirable properties of secure protocols, the most interesting for us being reducibility: Theorem 1 ([9]) Let f and g be two functions. <p> Denote with P Q the protocol in which the code for Q is substituted in P in the places where P ideally computes g. Then P Q is secure. Interested readers are referred to the original (80-page!) paper <ref> [9] </ref> for a proof of this statement and a complete and a formal description of their definition. 3 Our definition of VSS In this section we provide a new definition of VSS that guarantees reducibility. <p> The key idea for achieving this property is to cast VSS in terms of secure function evaluation. Accordingly, we shall define two special functions shar and rec, and demand that both of them be securely evaluated in the sense of <ref> [9] </ref>. We assume a network of n players P 1 ; : : : ; P n1 and P n , where P n = D the dealer. Let = f0; 1g fl .
Reference: [10] <author> W.Peterson, E.Weldon, </author> <title> Error Correcting Codes, </title> <publisher> MIT Press 1972 </publisher>
Reference-contexts: For details on this error-correcting encoding of a polynomial known as the Reed-Solomon code readers can refer to a standard text like <ref> [10] </ref>. Let m be a security parameter. Protocol Share-Verify ([1]): 1. The dealer chooses a random polynomial f 0 (x) of degree t with the only condition that f 0 (0) = s his secret.
Reference: [11] <author> T.Rabin, </author> <title> M.BenOr Verifiable Secret Sharing and multiparty protocols with honest majority, </title> <booktitle> Proceedings of STOC 1989 </booktitle>
Reference-contexts: In the second stage, the already committed value v will be recovered by all good players (again, no matter what the bad players might do). Prior work. Several definitions and protocols for VSS have been proposed in the past ten years (E.g., <ref> [3, 1, 2, 4, 11] </ref>.) We contend, however, that these notions and these protocols are of very limited use.
Reference: [12] <author> A.Shamir, </author> <title> How to share a secret, </title> <journal> Comm. of the ACM, </journal> <volume> 22(11), </volume> <month> Nov. </month> <year> 1979, </year> <pages> pp. 612-613 </pages>
References-found: 12

