URL: ftp://cse.ogi.edu/pub/tech-reports/1997/97-TH-001.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Title: A Meta-theory for Structured Presentations in the COC  
Author: Sherri Shulman 
Degree: B.S., Shimer College, 1973 M.S. Illinois Institute of Technology, 1979 A dissertation submitted to the faculty of the Oregon Graduate Institute of Science and Technology in partial fulfillment of the requirements for the degree Doctor of Philosophy in Computer Science and Engineering  
Date: February 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A it-Kaci, H., and Nasr, R. </author> <title> LOGIN: A logic-programming language with built-in inheritance. </title> <journal> Journal of Logic Programming 3 (1986), </journal> <pages> 185-215. </pages>
Reference-contexts: The particular results that contributed to the ideas in this thesis are the work of A it-Kaci <ref> [1] </ref> and its formalization in order-sorted equational logic by Smolka and A it-Kaci [47]. 21 22 A it-Kaci introduced the notion of inheritance hierarchies built up from feature types. Feature types are ordered by subtyping and the elements of a feature type are records. <p> The original terms introduced by A it-Kaci ( terms) were conceived as organizing and defining inheritance hierarchies that represented the subset structure of information. The hierarchy could then be incorporated into a logic query language such as LOGIN <ref> [1] </ref>.
Reference: [2] <author> Barendregt, H. P. </author> <title> The type free lambda calculus. In Mathematical Logic, </title> <editor> J. Bar-wise, Ed. </editor> <publisher> North Holland, </publisher> <year> 1977, </year> <pages> pp. 1091-1132. </pages>
Reference-contexts: For both the goal is to describe mathematics whatever the 30 semantics ascribed to this description might be. 2.3.3 The -calculus The -calculus [12] and combinatory logic [16] were developed as devices to study rules <ref> [2] </ref>, [3]a, where the rules are represented as functions. Looking at the functional definition as embodied in the -terms led to many results from the perspective of what is computable via these functional definitions what terminates and what can be represented. <p> Looking at the functional definition as embodied in the -terms led to many results from the perspective of what is computable via these functional definitions what terminates and what can be represented. Again, as in the logics above, the system of -terms was intended as a foundation for mathematics <ref> [2] </ref>. This goal was not entirely realized, though many more limited goals were. <p> ) = x 3 T 2 extend S 0 ( 3 ; c 3 ; x 3 ) u 2 (T 1 ) = [[S 0 fi 1 7! c 1 ; 2 7! c 2 ]] 2 u 2 T 3 instantiate T 2 T 1 [ 3 ] <ref> [ 1 ; 2 ] </ref> [ 4 ][c 4 ] T 1 extend S 0 ( 1 ; c 1 ; x 1 ); ( 2 ; c 2 ; x 2 ) u 1 (c 4 ) = [[T 3 : 4 ]] 2 u 2 = [[T 2 :
Reference: [3] <author> Barendregt, H. P. </author> <title> The Lambda Calculus: Its Syntax and Semantics, second ed., </title> <booktitle> vol. II of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <year> 1984. </year>
Reference-contexts: 1 (c 3 ) = x 3 T 2 extend S 0 ( 3 ; c 3 ; x 3 ) u 2 (T 1 ) = [[S 0 fi 1 7! c 1 ; 2 7! c 2 ]] 2 u 2 T 3 instantiate T 2 T 1 <ref> [ 3 ] </ref> [ 1 ; 2 ] [ 4 ][c 4 ] T 1 extend S 0 ( 1 ; c 1 ; x 1 ); ( 2 ; c 2 ; x 2 ) u 1 (c 4 ) = [[T 3 : 4 ]] 2 u 2 =
Reference: [4] <author> Barendregt, H. P. </author> <title> Introduction to generalized type systems. </title> <journal> Journal of Functional Programming 1, </journal> <volume> 2 (1991), </volume> <pages> 125-154. </pages>
Reference-contexts: The key characteristic to a language's ability to generally describe theories using arbitrary discursive methods is the first item. Barendregt in Introduction to Generalised Type Systems <ref> [4] </ref> characterizes type systems by the dependencies of the terms and the types in the systems. In his model, languages that allow types to be dependent on terms are capable of describing what is legal or provable in a theory. <p> Similarly, some research has started with existing computational forms: where a computational form exists, find a suitable meaning expressed in the logic. Both of these perspectives use the type system as an intermediary between the logic and the computational form <ref> [4] </ref>. Using the type system as an initial point is often confused with the logic, because of the pervasive viewpoint of the proposition as types. <p> 2 extend S 0 ( 3 ; c 3 ; x 3 ) u 2 (T 1 ) = [[S 0 fi 1 7! c 1 ; 2 7! c 2 ]] 2 u 2 T 3 instantiate T 2 T 1 [ 3 ] [ 1 ; 2 ] <ref> [ 4 ] </ref>[c 4 ] T 1 extend S 0 ( 1 ; c 1 ; x 1 ); ( 2 ; c 2 ; x 2 ) u 1 (c 4 ) = [[T 3 : 4 ]] 2 u 2 = [[T 2 : 3 ]] 2 u 2
Reference: [5] <author> Bishop, E. </author> <title> Foundations of Constructive Analysis. </title> <publisher> McGraw Hill, </publisher> <year> 1967. </year>
Reference-contexts: So a proof of a logical statement describing this real object must produce this object if we are to believe it exists. The object justifies the meaning of the logical statement. There have been substantial attempts to formalize the constructive portion (i.e., the real portion) of mathematics (Bishop <ref> [5] </ref>, Heyting [25], and Kreisel [28]). While there is a certain philosophical distinction in determining which of mathematics or logic is prior (which provides the meaning for the other), to some extent it is moot.
Reference: [6] <author> Brachman, R. J., and Schmolze, J. </author> <title> An overview of the KL-ONE knowledge representation system. </title> <booktitle> Cognitive Science 9, 2 (1985), </booktitle> <pages> 171-216. </pages>
Reference: [7] <author> Brouwer, L. E. J. </author> <title> Historical background, principles and methods of intuitionism. </title> <institution> South African J. Sci, </institution> <month> 49 </month> <year> (1952), </year> <pages> 139-146. </pages>
Reference-contexts: So, while Gentzen's natural deduction specifies how a particular construction is formed, it does not specify in what way the underlying logic has been extended, or in what way the context has been defined, instantiated, or discharged. 29 2.3.2 Intuitionism The intuitionistic (constructive) view of logic due to Brouwer <ref> [7] </ref> arose in a similar context: that of trying to understand the logical underpinnings of mathematics. Brouwer, however, questioned the logical constants from the standpoint of questioning when a statement can be judged true or what is a valid proof of a proposition [25] [20] [51].
Reference: [8] <author> Bruijn, N. G. d. </author> <title> A survey of the project AUTOMATH. In To H. </title> <editor> B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <editor> J. P. Seldin and J. R. Hindley, Eds. </editor> <publisher> Academic Press, </publisher> <year> 1980, </year> <pages> pp. 579-606. </pages>
Reference-contexts: There are types of objects and types of types (sets of sets), and so on. The utility of higher-order types is partially dependent on what one wants to say and how one wants to say it. Automath <ref> [8] </ref> is first-order; de Bruijn justifies this restriction to first-order by referring to additional axioms (extra-logical notions) that extend the power of the language. <p> These different components (structure, algorithm refinement, and program realization) could be used together 121 122 to provide support for the different aspects of program development: algorithm design, refinement, implementation, and verification. I will look at systems that have provided similar or overlapping capabilities: Automath <ref> [8] </ref>, CLEAR [11], Institutions [21], [41] , consequence relations in LF [24], ELF [37], Extended ML [42], a system of Deliverables [9], and Specware [49]. <p> They did not investigate theory construction as a process, but as a static description. 4. They did not have general higher order types, by intent. This limited their uniformity, although at least one of the Automath languages was higher order, Aut-SL <ref> [8] </ref>. By using a constructive, higher order language as the base language for theory construction in MF, we are able to provide a fully expressive language in which to describe arbitrary theories.
Reference: [9] <author> Burstall, R., and McKinna, J. Deliverables: </author> <title> an approach to program development in the calculus of constructions. </title> <booktitle> In Proceedings of the First Annual Workshop on Logical Frameworks (Antibes, </booktitle> <address> France, </address> <year> 1990), </year> <pages> pp. 113-122. </pages>
Reference-contexts: I will look at systems that have provided similar or overlapping capabilities: Automath [8], CLEAR [11], Institutions [21], [41] , consequence relations in LF [24], ELF [37], Extended ML [42], a system of Deliverables <ref> [9] </ref>, and Specware [49]. <p> Combining MF with an Extended ML base could provide both the structuring support needed by Extended ML and the interface restrictions needed in the base language. 5.7 Deliverables James Hugh McKinna in his thesis Deliverables: A Categorical Approach to Program Development in Type Theory <ref> [9] </ref> investigates Burstall's notion of deliverables: a program along with its proof of correctness. The objects in this system are more stringently defined than in ours: an object in MF may indeed fit the descriptions of a deliverable, although it need not.
Reference: [10] <author> Burstall, R. M., and Goguen, J. A. </author> <title> Putting theories together to make specifications. </title> <booktitle> In Proceedings of the Fifth International Joint Conference on Artificial Intelligence (Cambridge, </booktitle> <address> Mass., </address> <year> 1977), </year> <pages> pp. 1045-1058. </pages>
Reference-contexts: This structure would also accommodate theory changes, both those that maintain relationships among presentations and those that don't, and a framework to accommodate state changes in dependencies such as versions. This approach was suggested by the structural treatment of theories in Clear <ref> [10, 11] </ref>. A similar structural approach is also being used by Harper, Sannella and Tarlecki [24] to describe a treatment and meta-theory for theories They are working on structuring theories in LF, which itself is a means to uniformly express the meta-theory of an object logic via encoding.
Reference: [11] <author> Burstall, R. M., and Goguen, J. A. </author> <title> The semantics of Clear, a specification language. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> vol. 86. </volume> <publisher> Springer-Verlag, </publisher> <year> 1980, </year> <pages> pp. 293-329. 161 </pages>
Reference-contexts: We call the finite or partial representation of a theory a theory presentation. A theory presentation comprises the assumptions or proofs that it depends on and the propositions that directly characterize the theory as elaborated so far. There are many similarities with this approach and CLEAR <ref> [11] </ref>. We will discuss the relation of theory presentations to CLEAR in Chapter 5. <p> This structure would also accommodate theory changes, both those that maintain relationships among presentations and those that don't, and a framework to accommodate state changes in dependencies such as versions. This approach was suggested by the structural treatment of theories in Clear <ref> [10, 11] </ref>. A similar structural approach is also being used by Harper, Sannella and Tarlecki [24] to describe a treatment and meta-theory for theories They are working on structuring theories in LF, which itself is a means to uniformly express the meta-theory of an object logic via encoding. <p> These different components (structure, algorithm refinement, and program realization) could be used together 121 122 to provide support for the different aspects of program development: algorithm design, refinement, implementation, and verification. I will look at systems that have provided similar or overlapping capabilities: Automath [8], CLEAR <ref> [11] </ref>, Institutions [21], [41] , consequence relations in LF [24], ELF [37], Extended ML [42], a system of Deliverables [9], and Specware [49].
Reference: [12] <author> Church, A. </author> <title> The Calculi of Lambda Conversion. </title> <publisher> Princeton University Press, </publisher> <year> 1941. </year>
Reference-contexts: For the classical logician, the logic is justified logically as it were, and then shown that it is sufficient to describe existing mathematics. For both the goal is to describe mathematics whatever the 30 semantics ascribed to this description might be. 2.3.3 The -calculus The -calculus <ref> [12] </ref> and combinatory logic [16] were developed as devices to study rules [2], [3]a, where the rules are represented as functions.
Reference: [13] <author> Constable, R. L., et al. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: A consequence of a strong separation of structure from content is that specific algorithm development is associated with the content. There are existing tools and systems that focus on this content-oriented development (such as KIDS [45] and NuPRL <ref> [13] </ref>). Additionally, MF does not provide any support for a realization of a specification. Again, there are systems whose sole goal is to take constructive specifications and extract their computable component (such as Christine Paulin-Mohring's [36]).
Reference: [14] <author> Coquand, T., and Huet, G. </author> <title> Constructions: A higher order proof system for mechanizing mathematics. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> vol. 203. </volume> <publisher> Springer-Verlag, </publisher> <year> 1986, </year> <pages> pp. 151-184. </pages>
Reference-contexts: If we go to an impredicative system, first-order languages are no longer sufficient. So the conjunction of higher-order types with impredicativity provides the base for a pure, uniform, formalization of constructive mathematics and computer science <ref> [14, 15, 29, 30] </ref>. 2.3.7 The Use of Higher-Order Logic in MF Taking these developments together has led to systems, both predicative and impredica-tive, exploring what portions of mathematics and computer science are definable.
Reference: [15] <author> Coquand, T., and Huet, G. </author> <title> The calculus of constructions. </title> <booktitle> Information and Computation 76 (1988), </booktitle> <pages> 95-120. </pages>
Reference-contexts: We use the term logical framework in the same sense as is used by Harper, Honsell, and Plotkin [23]: a language for defining formal systems. It must be sufficiently powerful to encode the statements in the prior development and the current theory. The Calculus of Constructions <ref> [15] </ref> is such a language, as is LF [23]. We present another approach to constructing a logical framework in which the structure is defined and manipulated separately from the statements of the theory. An example of a mathematical discourse is the propositional logic defined using truth and falsity. <p> If we go to an impredicative system, first-order languages are no longer sufficient. So the conjunction of higher-order types with impredicativity provides the base for a pure, uniform, formalization of constructive mathematics and computer science <ref> [14, 15, 29, 30] </ref>. 2.3.7 The Use of Higher-Order Logic in MF Taking these developments together has led to systems, both predicative and impredica-tive, exploring what portions of mathematics and computer science are definable. <p> If there are any duplicate context entries, the duplication is irrelevant. The definition of a context is generally as a sequence, 91 and the most rightmost entry for an identifier is taken to be the definition (this definition is used in the COC implementation <ref> [15] </ref>, [31]). However, from a pragmatic standpoint, different implementations treat contexts differently. For instance, it is ill-defined in the LEGO implementation [32] for a context to introduce a second value or type for an identifier in the context.
Reference: [16] <author> Curry, H. B., and Feys, R. </author> <booktitle> Combinatory Logic, </booktitle> <volume> vol. </volume> <editor> I. </editor> <publisher> North-Holland, </publisher> <year> 1958. </year>
Reference-contexts: For both the goal is to describe mathematics whatever the 30 semantics ascribed to this description might be. 2.3.3 The -calculus The -calculus [12] and combinatory logic <ref> [16] </ref> were developed as devices to study rules [2], [3]a, where the rules are represented as functions. Looking at the functional definition as embodied in the -terms led to many results from the perspective of what is computable via these functional definitions what terminates and what can be represented.
Reference: [17] <author> D orre, J., and Rounds, W. C. </author> <title> On subsumption and semiunification in feature algebras. </title> <booktitle> In Proceedings Symposium on Logic in Computer Science (1990), </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 300-310. </pages>
Reference-contexts: The work reported by Gert Smolka [46] describes a feature logic that generalizes and unifies formalisms developed for knowledge representation, such as A it-Kaci's terms and linguistic structures of Rounds, Kasper, and Dorre <ref> [17] </ref>, [27]. This work specifies a set description logic and identifies which interpretations are admissible. An interpretation assigns a set of elements to each sort. This work is more extensive than needed for theory presentations: it provides descriptive terms that would construct theory presentation terms with no meaning.
Reference: [18] <author> Dummett, M. </author> <title> Truth and Other Enigmas. </title> <address> Duckworth, </address> <year> 1978. </year>
Reference-contexts: The question that I look at is not how an individual construction (proof) is formed or other properties of a construction per se. There is substantial work on supporting proof construction at present, in several variants of constructive type systems, with varying properties. Dummett <ref> [18] </ref> states that what we know is entirely determined by use. The meaning of a mathematical statement determines and is exhaustively determined by its use.
Reference: [19] <author> Gentzen, G. </author> <title> Investigations into logical deduction. In The Collected Papers of Gerhard Gentzen, </title> <editor> M. E. Szabo, Ed. </editor> <publisher> North-Holland, </publisher> <year> 1969, </year> <pages> pp. 68-131. </pages>
Reference-contexts: So proof theory consists in part in analyzing the (constructive) logical connectors to determine their intent, elaborating (explicitly) the connectives and what constitutes a proof for each connective. Gentzen's formal system <ref> [19] </ref> analyzed the deductive operations of constructive logic into its component parts and transformed the study of proof theory from an intensional analysis to an analysis of extensional objects: the proof is a derivation from initial premises to the desired conclusion.
Reference: [20] <author> Girard, J.-Y. </author> <title> Proof Theory and Logical Complexity, </title> <journal> vol. </journal> <volume> 1. </volume> <pages> Bibliopolis, </pages> <year> 1987. </year>
Reference-contexts: Brouwer, however, questioned the logical constants from the standpoint of questioning when a statement can be judged true or what is a valid proof of a proposition [25] <ref> [20] </ref> [51]. From that stance he limits the logical constants and valid inference rules to those that embody his notion of truth as proof. <p> This exploration can be done most effectively by isolating the structure rather than embedding it in another formal system. Girard suggests that proof theory is the logic of logic <ref> [20] </ref>. Research in proof theory focuses on the proofs independent of the content of what is being proved. Similarly, I suggest that the formalization of theories should be constructed independent of the content of the theories.
Reference: [21] <author> Goguen, J., and Burstall, R. </author> <title> Introducing institutions. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> vol. 164. </volume> <publisher> Springer-Verlag, </publisher> <year> 1983, </year> <pages> pp. 221-256. </pages>
Reference-contexts: These different components (structure, algorithm refinement, and program realization) could be used together 121 122 to provide support for the different aspects of program development: algorithm design, refinement, implementation, and verification. I will look at systems that have provided similar or overlapping capabilities: Automath [8], CLEAR [11], Institutions <ref> [21] </ref>, [41] , consequence relations in LF [24], ELF [37], Extended ML [42], a system of Deliverables [9], and Specware [49].
Reference: [22] <author> Goguen, J. A., and Tardo, J. </author> <title> An introduction to OBJ: A language for writing and testing software. In Specification of Reliable Software. </title> <publisher> IEEE Press, </publisher> <year> 1979, </year> <pages> pp. 170-189. </pages>
Reference: [23] <author> Harper, R., Honsell, F., and Plotkin, G. </author> <title> A framework for defining logics. </title> <booktitle> In Proceedings Symposium on Logic in Computer Science (Washington, </booktitle> <address> D.C., 1987), </address> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 194-204. </pages>
Reference-contexts: A logical framework is a formal system that may be used to codify such discourses of mathematical arguments. We use the term logical framework in the same sense as is used by Harper, Honsell, and Plotkin <ref> [23] </ref>: a language for defining formal systems. It must be sufficiently powerful to encode the statements in the prior development and the current theory. The Calculus of Constructions [15] is such a language, as is LF [23]. <p> logical framework in the same sense as is used by Harper, Honsell, and Plotkin <ref> [23] </ref>: a language for defining formal systems. It must be sufficiently powerful to encode the statements in the prior development and the current theory. The Calculus of Constructions [15] is such a language, as is LF [23]. We present another approach to constructing a logical framework in which the structure is defined and manipulated separately from the statements of the theory. An example of a mathematical discourse is the propositional logic defined using truth and falsity. <p> If we want to investigate this claim, we need to look at the connection between the artifacts, rather than at the artifacts. Systems such as Harper, Honsell, and Plotkin's LF <ref> [23] </ref> encode this position in their judgement-as-types paradigm. The kinds of judgement that a system makes can be treated as types. This view of judgements is reminiscent of the role that proof theory took on as it became a manipulable artifact. <p> Because of the similarity of theory dependencies to proof dependencies, some systems 35 have reflected some of the meta-theory of a sequence of proofs into the logic itself. Systems such as LF <ref> [23] </ref> define the primitives that allow more complex and interrelated structures to be constructed.
Reference: [24] <author> Harper, R., Sannella, D., and Tarlecki, A. </author> <title> Structure and representation in LF. </title> <booktitle> In Proceedings Symposium on Logic in Computer Science (Washington, </booktitle> <address> D.C., 1989), </address> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 226-241. </pages>
Reference-contexts: Systems such as LF [23] define the primitives that allow more complex and interrelated structures to be constructed. Designs such as the work on structure and representation in LF's <ref> [24] </ref> define higher level structures at a significantly more general level, facilitating a formalism that can be used to describe a system that encodes a meta-theory. <p> This approach was suggested by the structural treatment of theories in Clear [10, 11]. A similar structural approach is also being used by Harper, Sannella and Tarlecki <ref> [24] </ref> to describe a treatment and meta-theory for theories They are working on structuring theories in LF, which itself is a means to uniformly express the meta-theory of an object logic via encoding. <p> I will look at systems that have provided similar or overlapping capabilities: Automath [8], CLEAR [11], Institutions [21], [41] , consequence relations in LF <ref> [24] </ref>, ELF [37], Extended ML [42], a system of Deliverables [9], and Specware [49].
Reference: [25] <author> Heyting, A. </author> <title> Intuitionism, an Introduction. </title> <publisher> North-Holland, </publisher> <year> 1956. </year>
Reference-contexts: Brouwer, however, questioned the logical constants from the standpoint of questioning when a statement can be judged true or what is a valid proof of a proposition <ref> [25] </ref> [20] [51]. From that stance he limits the logical constants and valid inference rules to those that embody his notion of truth as proof. <p> The object justifies the meaning of the logical statement. There have been substantial attempts to formalize the constructive portion (i.e., the real portion) of mathematics (Bishop [5], Heyting <ref> [25] </ref>, and Kreisel [28]). While there is a certain philosophical distinction in determining which of mathematics or logic is prior (which provides the meaning for the other), to some extent it is moot. In both approaches there is an attempt to elaborate a portion of mathematics formally in a logic.
Reference: [26] <author> Jean-Yvew Girard, Y. L., and Taylor, P. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year> <month> 162 </month>
Reference-contexts: In particular, syntactic proofs 31 were susceptible to manipulation, a normal form, and had termination properties similar to those for the -calculus. 2.3.5 Formulas as Types and the Curry-Howard Isomorphism In the previous section, we discussed how proofs came to be viewed as syntactic objects. Alternatively, in Heyting's semantics <ref> [26] </ref>, proofs were given a meaning as abstract constructions. For instance, the proof of a sentence A ^ B is a pair (p; q) consisting of a proof p of A and a proof q of B.
Reference: [27] <author> Kasper, R. T., and Rounds, W. C. </author> <title> A logical semantics for feature structures. </title> <booktitle> In Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics (Columbia University, </booktitle> <year> 1986). </year>
Reference-contexts: The work reported by Gert Smolka [46] describes a feature logic that generalizes and unifies formalisms developed for knowledge representation, such as A it-Kaci's terms and linguistic structures of Rounds, Kasper, and Dorre [17], <ref> [27] </ref>. This work specifies a set description logic and identifies which interpretations are admissible. An interpretation assigns a set of elements to each sort. This work is more extensive than needed for theory presentations: it provides descriptive terms that would construct theory presentation terms with no meaning.
Reference: [28] <author> Kreisel, G. </author> <title> Interpretation of analysis by means of constructive functionals of finite type. </title> <editor> In Constructivity in Mathematics, A. Heyting, Ed. </editor> <publisher> North Holland, </publisher> <year> 1959, </year> <pages> pp. 101-128. </pages>
Reference-contexts: The object justifies the meaning of the logical statement. There have been substantial attempts to formalize the constructive portion (i.e., the real portion) of mathematics (Bishop [5], Heyting [25], and Kreisel <ref> [28] </ref>). While there is a certain philosophical distinction in determining which of mathematics or logic is prior (which provides the meaning for the other), to some extent it is moot. In both approaches there is an attempt to elaborate a portion of mathematics formally in a logic.
Reference: [29] <author> Luo, Z. </author> <title> cc 1 and its meta theory. </title> <type> Tech. Rep. </type> <institution> ECS-LFCS-88-58, LFCS Report Series, 1988. University of Edinburgh, Department of Computer Science. </institution>
Reference-contexts: If we go to an impredicative system, first-order languages are no longer sufficient. So the conjunction of higher-order types with impredicativity provides the base for a pure, uniform, formalization of constructive mathematics and computer science <ref> [14, 15, 29, 30] </ref>. 2.3.7 The Use of Higher-Order Logic in MF Taking these developments together has led to systems, both predicative and impredica-tive, exploring what portions of mathematics and computer science are definable.
Reference: [30] <author> Luo, Z. </author> <title> A higher-order calculus and theory abstraction. </title> <type> Tech. Rep. </type> <institution> ECS-LFCS-88-57, LFCS Report Series, 1988. University of Edinburgh, Department of Computer Science. </institution>
Reference-contexts: If we go to an impredicative system, first-order languages are no longer sufficient. So the conjunction of higher-order types with impredicativity provides the base for a pure, uniform, formalization of constructive mathematics and computer science <ref> [14, 15, 29, 30] </ref>. 2.3.7 The Use of Higher-Order Logic in MF Taking these developments together has led to systems, both predicative and impredica-tive, exploring what portions of mathematics and computer science are definable.
Reference: [31] <author> Luo, Z. </author> <title> ECC, an extended calculus of constructions. </title> <type> Tech. Rep. </type> <institution> ECS-LFCS-90-118, LFCS Report Series, 1989. University of Edinburgh, Department of Computer Science. </institution>
Reference-contexts: Chapter 3 Examples of Presentation Construction and Manipulation MF defines a language to manage sequences of statements in a logical framework. For the purposes of the definition of MF we chose the Calculus of Constructions as implemented in LEGO <ref> [31] </ref> [32], although any logical framework with certain properties will do (see Chapter 1). <p> If there are any duplicate context entries, the duplication is irrelevant. The definition of a context is generally as a sequence, 91 and the most rightmost entry for an identifier is taken to be the definition (this definition is used in the COC implementation [15], <ref> [31] </ref>). However, from a pragmatic standpoint, different implementations treat contexts differently. For instance, it is ill-defined in the LEGO implementation [32] for a context to introduce a second value or type for an identifier in the context.
Reference: [32] <author> Luo, Z., Pollack, R., and Taylor, P. </author> <title> How to use Lego. </title> <type> Tech. Rep. </type> <institution> ECS-LFCS-92-211, LFCS Report Series, 1992. University of Edinburgh, Department of Computer Science. </institution>
Reference-contexts: Arity is a variant of the natural numbers, over types rather than propositions. The notation f g, from the Lego implementation <ref> [32] </ref> of the Calculus of Constructions, denotes a product () type. The form: P rophnamei [hcontext elementsi]hpropositionexpressioni denotes that hnamei when applied to elements of the appropriate type, as specified in hcontext elementsi will be a P rop with value hpropositionexpressioni. <p> Chapter 3 Examples of Presentation Construction and Manipulation MF defines a language to manage sequences of statements in a logical framework. For the purposes of the definition of MF we chose the Calculus of Constructions as implemented in LEGO [31] <ref> [32] </ref>, although any logical framework with certain properties will do (see Chapter 1). <p> However, from a pragmatic standpoint, different implementations treat contexts differently. For instance, it is ill-defined in the LEGO implementation <ref> [32] </ref> for a context to introduce a second value or type for an identifier in the context. In MF, we do not currently allow an identifier to have more than one definition. Therefore, however many times that identifier is included in the context it must have the same definition.
Reference: [33] <author> Martin-L of, P. </author> <title> An intuitionistic theory of types: Predicative part. In Logic Collo quium '73, </title> <editor> H. E. Rose and J. C. Shepherdson, Eds. </editor> <publisher> North Holland, </publisher> <year> 1975, </year> <pages> pp. 73-118. </pages>
Reference-contexts: Using this notion of a proposition, one can define (for instance) a proposition that captures the properties of integers, lists, stacks, and so on. Systems such as Martin Lof's predicative system <ref> [33] </ref> provide definitions and behaviors for primitive constants, such as the recursive rules for different constructors. These rules are then used in building new types and propositions. In the drive to formalize mathematics foundationally, the ultimate goal is for a system that is entirely formalized without any extra-logical components. <p> Martin-Lof concluded at one point with the comment <ref> [33] </ref>: ... formalization taken together with the ensuing proof-theoretical analysis effectuates the computerization of abstract intuitionistic mathematics that above all Bishop has asked for.
Reference: [34] <author> Martin-L of, P. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Sixth International Congress for Logic, Methodology, and Philosophy of Science (1982), </booktitle> <publisher> North Holland, </publisher> <pages> pp. 153-175. </pages>
Reference-contexts: But, in a sense, the flavor is foundational. While the overall goal of intuitionistic philosophy was to expose the foundations of mathematics, it has met a more limited and fruitful domain in the field of computer science. As Martin-Lof <ref> [34] </ref> believed, if we view a program as the design of a method for computing a value, then the construction of a program (function) is identical to the construction of a proof of a mathematical object (value). 34 The research has been driven from two directions.
Reference: [35] <author> Nerode, A., and Shore, R. A. </author> <title> Logic for Applications. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: (c i ) = ([Context i ]; LFval i ; LFtyp i ) The abstract value pair: the u 1 environment. 4.3.1 Frames The presentation base is represented as a frame, similar to Kripke's frames. (The treatment given below is derived from the presentation by Anil Nerode and Richard Shore, <ref> [35] </ref>.) 107 Frames are a method for organizing sets of related statements in a language.
Reference: [36] <author> Paulin-Mohring, C. </author> <title> Extracting F ! 's programs from proofs in the calculus of constructions. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Prin ciples of Programming Languages. ACM, </booktitle> <year> 1989, </year> <pages> pp. 89-104. </pages>
Reference-contexts: Additionally, MF does not provide any support for a realization of a specification. Again, there are systems whose sole goal is to take constructive specifications and extract their computable component (such as Christine Paulin-Mohring's <ref> [36] </ref>). These different components (structure, algorithm refinement, and program realization) could be used together 121 122 to provide support for the different aspects of program development: algorithm design, refinement, implementation, and verification.
Reference: [37] <author> Pfenning, F. </author> <title> ELF: A language for logic definition and verified metaprogramming. </title> <booktitle> In Proceedings Symposium on Logic in Computer Science (Washington, </booktitle> <address> D.C., 1989), </address> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 313-323. </pages>
Reference-contexts: I will look at systems that have provided similar or overlapping capabilities: Automath [8], CLEAR [11], Institutions [21], [41] , consequence relations in LF [24], ELF <ref> [37] </ref>, Extended ML [42], a system of Deliverables [9], and Specware [49]. <p> Questions still to be explored are how MF can be used with different LF's and or logical systems, each describing a different aspect, as in Institution changes. 5.5 ELF ELF, a language for logic definition and verified metaprogramming by Frank Pfenning <ref> [37] </ref> again attempts to define a meta-language for proof manipulation that is independent of any particular logical system. Independence from particular logical systems is a strong motif, leveraging off of the common factors of logical systems.
Reference: [38] <author> Prawitz, D. </author> <title> Natural Deduction. </title> <publisher> Almqvist & Wiksell, </publisher> <year> 1965. </year> <month> 163 </month>
Reference-contexts: correspondence of -terms with functions (in particular the partial recursive functions), the normal form properties of the typed -terms, termination properties of these terms, computational models, etc. 2.3.4 Proof Theory Proof theory is the study of formal arguments; in particular, it characterizes how we know an argument to be valid <ref> [38] </ref>, [39]. Proof theory has been a topic for both classical and constructive logic. In particular, for constructive logic, proof theory is of interest because of the relation of a proof to a construction.
Reference: [39] <author> Prawitz, D. </author> <title> Ideas and results in proof theory. </title> <booktitle> In Proceedings of the Second Scan-dinavian Logic Symposium (Amsterdam, 1971), </booktitle> <publisher> North-Holland, </publisher> <pages> pp. 235-307. </pages>
Reference-contexts: of -terms with functions (in particular the partial recursive functions), the normal form properties of the typed -terms, termination properties of these terms, computational models, etc. 2.3.4 Proof Theory Proof theory is the study of formal arguments; in particular, it characterizes how we know an argument to be valid [38], <ref> [39] </ref>. Proof theory has been a topic for both classical and constructive logic. In particular, for constructive logic, proof theory is of interest because of the relation of a proof to a construction.
Reference: [40] <author> Russell, B. </author> <booktitle> Principles of Mathematics. </booktitle> <publisher> Norton, </publisher> <year> 1938. </year>
Reference-contexts: The Curry-Howard isomorphism: i.e. the correspondence between logical formulas and types. 6. The correspondence between proofs and terms of functional types. 7. The role of impredicativity and higher order types. 2.3.1 Development of the notion of types The theory of types originated with Russell <ref> [40] </ref> with the goal of resolving the contradictions of assuming a set of all sets (predicates not predicable of themselves). This contradiction arises in an attempt to formalize mathematics by reducing mathematics to logic. <p> Impredicative definitions often seem circular as they don't refer to anything outside themselves. However, there are always extra-logical constants: ones that we believe to be intuitively true or valid in some external sense (see Russell's comments on Peano <ref> [40] </ref>). As mentioned above, first-order languages may be extended with axioms allowing higher-order concepts to be expressed; this extension is obviously predicative. Their properties and our understanding of the meaning of the statements produced in such a system are contingent on our understanding or believing the predicative base.
Reference: [41] <author> Sanella, D., and Tarlecki, A. </author> <title> Building specifications in an arbitrary institution. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> vol. 173. </volume> <publisher> Springer-Verlag, </publisher> <year> 1984, </year> <pages> pp. 337-356. </pages>
Reference-contexts: These different components (structure, algorithm refinement, and program realization) could be used together 121 122 to provide support for the different aspects of program development: algorithm design, refinement, implementation, and verification. I will look at systems that have provided similar or overlapping capabilities: Automath [8], CLEAR [11], Institutions [21], <ref> [41] </ref> , consequence relations in LF [24], ELF [37], Extended ML [42], a system of Deliverables [9], and Specware [49]. <p> reusability of the presentations and environments in MF, the freeing of parameterized specifications from a specific presentation to satisfying structural environments (lattices, diagrams), and the move of the details of presentation instantiation (application) to the object level. 130 5.3 Institutions The goal of Goguen and Burstall's work on Institutions ([21], <ref> [41] </ref>) is to: 1. Support as many computer science features as possible independently of the under lying logical system. 2. Facilitate the transfer of results from one logical system to another. 3. Permit the combining of different logical systems naturally.
Reference: [42] <author> Sannella, D. </author> <title> Formal program development in extended ML for the working programmer. </title> <booktitle> In Proceeding 3rd BCS.FACS Workshop on Refinement (1990). </booktitle>
Reference-contexts: I will look at systems that have provided similar or overlapping capabilities: Automath [8], CLEAR [11], Institutions [21], [41] , consequence relations in LF [24], ELF [37], Extended ML <ref> [42] </ref>, a system of Deliverables [9], and Specware [49]. <p> Tarlecki have defined an extended version of ML to facilitate the production of correct programs from requirements <ref> [42] </ref>. Extended ML is a specification framework for program development in Standard ML. The design choices made in Extended ML were influenced by this restricted goal.
Reference: [43] <author> Sannella, D., and Tarlecki, A. </author> <title> Toward formal development of programs from algebraic specifications: Implementations revisited. </title> <booktitle> Acta Infrormatica 25 (1988), </booktitle> <pages> 233-282. </pages>
Reference-contexts: In MF, diagram refinements are captured by theory specialization (or structural environment instantiation) with no distinction between a 153 category of specifications and interpretations. Specware distinquished the kind of horizontal composition they provide from that defined in Sannella and Tarlecki <ref> [43] </ref>, saying that their "distributive law is a generalization of Sannella and Tarlecki's, which uses parameterization and does not handle colimits; moreover, it's semantically oriented." Similarly, MF theory instantiation is not semantically oriented (although it obeys the semantic conditions of Sannella and Tarlecki). <p> In the next section we explore some of the relationships that can be captured structurally by the composition of theory instantiations by examining a case study. 6.2.1 Horizontal Composition Horizontal composition as defined by Sanella and Tarlecki <ref> [43] </ref> expresses the relationship between parameterized theories and their arguments (written in an MF style notation): given theory presentations P ; P 0 ; Q, and Q 0 , if P &gt; P 0 and Q &gt; Q 0 , then P (Q) &gt; P 0 (Q 0 ).
Reference: [44] <author> Sannella, D. T., and Burstall, R. M. </author> <title> Structured theories in LCF. </title> <booktitle> In Proc. of the 8th Colloquium on Algebra and Trees in Programming (1983), </booktitle> <pages> pp. 377-391. </pages>
Reference-contexts: MF does not provide a methodology to support the construction of theories nor does it provide support for successive decomposition of specifications into executable modules. What it does provide in the context of program development is a tangible scoping mechanism. Like suggestions for LCF in Structured Theories in LCF <ref> [44] </ref>, MF environments can be used to limit the context of search (for a solution or a proof) to a problem. Extended ML's use of signatures with axioms provides much of the detail not present in MF environments.
Reference: [45] <author> Smith, D. R. </author> <title> KIDS A Knowledge-Based Softwqare Development System. </title> <publisher> AAAI/MIT Press, </publisher> <year> 1991, </year> <pages> pp. 483-514. </pages>
Reference-contexts: A consequence of a strong separation of structure from content is that specific algorithm development is associated with the content. There are existing tools and systems that focus on this content-oriented development (such as KIDS <ref> [45] </ref> and NuPRL [13]). Additionally, MF does not provide any support for a realization of a specification. Again, there are systems whose sole goal is to take constructive specifications and extract their computable component (such as Christine Paulin-Mohring's [36]). <p> The goal of distinguishing propositional from computational information in Deliverables is reminiscent of MF's goal of distinguishing structure from content. 5.8 Specware Specware [49] was developed in the context of the KIDS (Kestrel Interactive Development System) <ref> [45] </ref> project at Kestrel Institute. Specware is defined in the context of a category of specifications and specification morphisms. Much like CLEAR, diagrams in this category describe system structure. A Specware specification is a finite presentation of a theory in a higher-order logic.
Reference: [46] <author> Smolka, G. </author> <title> A feature logic with subsorts. </title> <type> Tech. Rep. 33, LILOG, </type> <year> 1988. </year>
Reference-contexts: It's difficult to completely separate the language from the persistent (or semi-persistent) artifacts that they describe and introduce. The work reported by Gert Smolka <ref> [46] </ref> describes a feature logic that generalizes and unifies formalisms developed for knowledge representation, such as A it-Kaci's terms and linguistic structures of Rounds, Kasper, and Dorre [17], [27]. This work specifies a set description logic and identifies which interpretations are admissible.
Reference: [47] <author> Smolka, G., and A iT-Kaci, H. </author> <title> Inheritance hierarchies: Semantics and unification. </title> <editor> J. </editor> <booktitle> Symbolic Computation 7 (1989), </booktitle> <pages> 343-370. </pages>
Reference-contexts: The particular results that contributed to the ideas in this thesis are the work of A it-Kaci [1] and its formalization in order-sorted equational logic by Smolka and A it-Kaci <ref> [47] </ref>. 21 22 A it-Kaci introduced the notion of inheritance hierarchies built up from feature types. Feature types are ordered by subtyping and the elements of a feature type are records. The features of a feature type prescribe the fields of its record elements.
Reference: [48] <author> Smorynski, C. </author> <title> The incompleteness theorems. In Mathematical Logic, </title> <editor> J. Barwise, Ed. </editor> <publisher> North Holland, </publisher> <year> 1977, </year> <pages> pp. 821-866. </pages>
Reference-contexts: Because of the desire to formalize mathematics, and because of the incompleteness theorems of Goedel <ref> [48] </ref>, higher-order types were explored to attain the expressivity necessary to define mathematics in a uniform context in a way that avoided the incompleteness problems. Hierarchies of types allowed the consistency and meta-logical properties of each level to be expressed at a higher level.
Reference: [49] <author> Srinivas, Y. V., and J ullig, R. Specware: </author> <title> Formal support for composing software. </title> <type> Tech. Rep. </type> <institution> KES.U.95.5, The Kestrel Institute, </institution> <address> Palo Alto, Ca., </address> <year> 1995. </year>
Reference-contexts: I will look at systems that have provided similar or overlapping capabilities: Automath [8], CLEAR [11], Institutions [21], [41] , consequence relations in LF [24], ELF [37], Extended ML [42], a system of Deliverables [9], and Specware <ref> [49] </ref>. <p> Allowing a change in deliverables also suggests that several activities such as developing proofs of correctness or extracting computational components might have parallel development environments. The goal of distinguishing propositional from computational information in Deliverables is reminiscent of MF's goal of distinguishing structure from content. 5.8 Specware Specware <ref> [49] </ref> was developed in the context of the KIDS (Kestrel Interactive Development System) [45] project at Kestrel Institute. Specware is defined in the context of a category of specifications and specification morphisms. Much like CLEAR, diagrams in this category describe system structure.
Reference: [50] <author> Streicher, T. </author> <title> Semantics of Type Theory. </title> <publisher> Birkhauser, </publisher> <year> 1991. </year>
Reference-contexts: We let u 2 be a Level 2 environment, assigning meanings to pre-defined identifiers. The superscript on the environments and the semantic functions distinguishes among the environments and semantic functions for each Level. We propose a model suggested by the term model defined by Thomas Streicher <ref> [50] </ref>, and based on the semantics function of Level 2 terms. This model meets the criteria that only provably well-defined contexts, types, and objects are given an interpretation.
Reference: [51] <author> Troelstra, A. S. </author> <title> Aspects of constructive mathematics. In Mathematical Logic, </title> <editor> J. Barwise, Ed. </editor> <publisher> North Holland, </publisher> <year> 1977, </year> <pages> pp. 973-1052. </pages>
Reference-contexts: Brouwer, however, questioned the logical constants from the standpoint of questioning when a statement can be judged true or what is a valid proof of a proposition [25] [20] <ref> [51] </ref>. From that stance he limits the logical constants and valid inference rules to those that embody his notion of truth as proof.
References-found: 51

