URL: http://www.cs.gatech.edu/grads/c/Richard.Clayton/repr.ps
Refering-URL: http://www.cs.gatech.edu/grads/c/Richard.Clayton/pubs.html
Root-URL: 
Title: The Representation Problem in Reverse Engineering  
Author: Spencer Rugaber and Richard Clayton 
Address: Atlanta, GA 30332-0280  
Affiliation: College of Computing and Software Research Center Georgia Institute of Technology  
Abstract: Building models to understand software systems is an important part of reverse engineering. Formal and explicit model building is important because it focuses attention on modeling as an aid to understanding and results in artifacts that may be useful to others. The representation used to build models has great influence over the success and value of the result. Choosing the proper representation during reverse engineering is the representation problem. This paper examines the representation problem by presenting a taxonomy of solutions. It also illustrates the issues involved in choosing a representation through an example reverse engineering task. 
Abstract-found: 1
Intro-found: 1
Reference: [ABFP86] <author> Guillermo Arango, Ira Baxter, Peter Freeman, and Christopher Pidgeon. </author> <title> TMM: Software maintenance by transformation. </title> <journal> IEEE Software, </journal> <volume> 3(3) </volume> <pages> 27-39, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: Most representation techniques used during software design emphasize one of these three views. Representation Examples Object-Oriented Frameworks [JF88] Category theory [Sri91] Concept hierarchies [Big89, Lub91] Mini-languages <ref> [Nei84, ABFP86] </ref> Database languages [CR86] Narrow spectrum languages [Web87] Wide spectrum languages [Wil87, WCM89] Knowledge Representation [Bar85] Text Table 1: Application domain models A way of representing the rationale for a program's computational structures is in terms of the design decisions they implement [ROL90].
Reference: [Bar85] <author> David Barstow. </author> <title> On convergence toward a database of program transformations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 1-9, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Most representation techniques used during software design emphasize one of these three views. Representation Examples Object-Oriented Frameworks [JF88] Category theory [Sri91] Concept hierarchies [Big89, Lub91] Mini-languages [Nei84, ABFP86] Database languages [CR86] Narrow spectrum languages [Web87] Wide spectrum languages [Wil87, WCM89] Knowledge Representation <ref> [Bar85] </ref> Text Table 1: Application domain models A way of representing the rationale for a program's computational structures is in terms of the design decisions they implement [ROL90]. Design is a rational process involving a series of decisions transforming a specification into an implementation.
Reference: [Big89] <author> Ted J. Biggerstaff. </author> <title> Design recovery for maintenance and reuse. </title> <journal> IEEE Computer, </journal> <volume> 22(7), </volume> <month> July </month> <year> 1989. </year>
Reference-contexts: Most representation techniques used during software design emphasize one of these three views. Representation Examples Object-Oriented Frameworks [JF88] Category theory [Sri91] Concept hierarchies <ref> [Big89, Lub91] </ref> Mini-languages [Nei84, ABFP86] Database languages [CR86] Narrow spectrum languages [Web87] Wide spectrum languages [Wil87, WCM89] Knowledge Representation [Bar85] Text Table 1: Application domain models A way of representing the rationale for a program's computational structures is in terms of the design decisions they implement [ROL90].
Reference: [Byr91] <author> Eric J. Byrne. </author> <title> Software reverse engineering: A case study. </title> <journal> Software|Practice and Experience, </journal> <volume> 21(12) </volume> <pages> 1349-1364, </pages> <month> Decem-ber </month> <year> 1991. </year>
Reference-contexts: There were also many cosmetic transformations. These included renaming variables to better indicate their purpose within the code, removing data items not referenced in the code, and introducing new functions to perform data retrieval from encapsulated objects. The value of these cosmetic transformations has been pointed out by Byrne <ref> [Byr91] </ref>. Each of the transformations reflected a refinement to the reverse engineer's understanding of the program.
Reference: [CC90] <author> Elliot J. Chikofsky and James H. </author> <title> Cross II. Reverse engineering and design recovery: A taxonomy. </title> <journal> IEEE Software, </journal> <volume> 7(1) </volume> <pages> 13-17, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Chikofsky and Cross define reverse engineering to be "the process of analyzing a subject system to identify the system's components and their interrelationships and create representations of the system in another form or at a higher level of abstraction <ref> [CC90] </ref>." They go on to describe six key objectives of reverse engineering: controlling complexity, generating alternative views, recovering lost information, detecting side effects, synthesizing higher abstractions, and facilitating reuse. The concept of representation is central both to the process and the objectives of reverse engineering.
Reference: [CR86] <author> Y. F. Chen and C. V. Ramamoorthy. </author> <title> The C information abstractor. </title> <booktitle> In Proceedings COMPSASC 86, </booktitle> <pages> pages 291-298. </pages> <publisher> IEEE, </publisher> <year> 1986. </year>
Reference-contexts: Most representation techniques used during software design emphasize one of these three views. Representation Examples Object-Oriented Frameworks [JF88] Category theory [Sri91] Concept hierarchies [Big89, Lub91] Mini-languages [Nei84, ABFP86] Database languages <ref> [CR86] </ref> Narrow spectrum languages [Web87] Wide spectrum languages [Wil87, WCM89] Knowledge Representation [Bar85] Text Table 1: Application domain models A way of representing the rationale for a program's computational structures is in terms of the design decisions they implement [ROL90].
Reference: [Jac75] <author> M. A. Jackson. </author> <title> Principles of Program Design. </title> <publisher> Academic Press, </publisher> <year> 1975. </year>
Reference-contexts: P13AGU reads two input files. One file contains a single record, called the DATE record, describing the circumstances under which a report is requested. A model for the DATE record file was constructed directly from the FILE DESCRIPTION section of the source code and represented by a Jackson diagram <ref> [Jac75] </ref>. An analysis of the source code indicated that the file is only read once, so no repetition is involved. Later analysis indicated some of the DATE record fields are never referenced by the program. This led to refinement of the original model and edits to its representation.
Reference: [JF88] <author> R. E. Johnson and B. Foote. </author> <title> Design--ing reusable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(2) </volume> <pages> 22-35, </pages> <month> June-July </month> <year> 1988. </year>
Reference-contexts: Most representation techniques used during software design emphasize one of these three views. Representation Examples Object-Oriented Frameworks <ref> [JF88] </ref> Category theory [Sri91] Concept hierarchies [Big89, Lub91] Mini-languages [Nei84, ABFP86] Database languages [CR86] Narrow spectrum languages [Web87] Wide spectrum languages [Wil87, WCM89] Knowledge Representation [Bar85] Text Table 1: Application domain models A way of representing the rationale for a program's computational structures is in terms of the design decisions they
Reference: [KR90] <author> Kit Kamper and Spencer Rugaber. </author> <title> A reverse engineering methodology for data processing applications. </title> <type> Technical Report GIT-SERC-90/02, </type> <institution> Software Engineering Research Center, Georgia Institute of Technology, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: The P13AGU program produces a report summarizing the status of all equipment described in an input file. 3.2 Approach Synchronized Refinement was the technique used to reverse engineer P13AGU <ref> [KR90, OR92] </ref>. Synchronized Refinement begins by constructing two related models of the software: one describing the program text and the other the application problem. Once the two models are in place, they are refined towards each other.
Reference: [Lam87] <author> David Alex Lamb. </author> <title> IDL: Sharing intermediate representations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 297-318, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: A universal representation claims to provide more or less equal support for all models. Examples of universal representations are Lisp symbolic expressions and relational database tables. A more sophisticated approach aimed directly at the software representation problem is IDL <ref> [Lam87] </ref>. Universal representations move the trade-off balance away from diversity towards integration. A software backplane is essentially an interconnection and communication standard understood by all models [Pas88].
Reference: [Lub91] <author> Mitchell D. Lubars. </author> <title> Domain analysis and domain engineering in IDeA. </title> <editor> In Ruben Prieto-Diaz and Guillermo Arango, editors, </editor> <booktitle> Domain Analysis and Software Systems Modeling, </booktitle> <pages> pages 163-178. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Most representation techniques used during software design emphasize one of these three views. Representation Examples Object-Oriented Frameworks [JF88] Category theory [Sri91] Concept hierarchies <ref> [Big89, Lub91] </ref> Mini-languages [Nei84, ABFP86] Database languages [CR86] Narrow spectrum languages [Web87] Wide spectrum languages [Wil87, WCM89] Knowledge Representation [Bar85] Text Table 1: Application domain models A way of representing the rationale for a program's computational structures is in terms of the design decisions they implement [ROL90].
Reference: [Nei84] <author> James M. Neighbors. </author> <title> The Draco approach to constructing software from reusable components. </title> <journal> IEEE Transactions on Software Engineerings, </journal> <volume> SE-10(5):564-574, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: Most representation techniques used during software design emphasize one of these three views. Representation Examples Object-Oriented Frameworks [JF88] Category theory [Sri91] Concept hierarchies [Big89, Lub91] Mini-languages <ref> [Nei84, ABFP86] </ref> Database languages [CR86] Narrow spectrum languages [Web87] Wide spectrum languages [Wil87, WCM89] Knowledge Representation [Bar85] Text Table 1: Application domain models A way of representing the rationale for a program's computational structures is in terms of the design decisions they implement [ROL90].
Reference: [OR92] <author> Stephen B. Ornburn and Spencer Rugaber. </author> <title> Reverse engineering: Resolving conflicts between expected and actual software designs. </title> <booktitle> In Proceedings of the Conference on Software Maintenance, </booktitle> <pages> pages 206-213, </pages> <address> Or-lando, Flordia., </address> <month> November </month> <year> 1992. </year>
Reference-contexts: The P13AGU program produces a report summarizing the status of all equipment described in an input file. 3.2 Approach Synchronized Refinement was the technique used to reverse engineer P13AGU <ref> [KR90, OR92] </ref>. Synchronized Refinement begins by constructing two related models of the software: one describing the program text and the other the application problem. Once the two models are in place, they are refined towards each other.
Reference: [Pas88] <author> W. Paseman. </author> <title> Architecture of an integration and portability platform. </title> <booktitle> In COMP-CON Spring 88, </booktitle> <pages> pages 254-8, </pages> <address> San Fran-cisco, California, </address> <month> February 29-March 3 </month> <year> 1988. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: A more sophisticated approach aimed directly at the software representation problem is IDL [Lam87]. Universal representations move the trade-off balance away from diversity towards integration. A software backplane is essentially an interconnection and communication standard understood by all models <ref> [Pas88] </ref>. The interconnection standard insures the models can be linked together; the communication standard insures the models can be made to do useful things once linked together. Software backplanes try to compromise, moving one piece towards diversity and the other towards integration.
Reference: [Raj92] <editor> Vaclav Rajlich, editor. </editor> <booktitle> Workshop Notes | Program Comprehension, </booktitle> <address> Orlando, Florida, </address> <month> November 9 </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: Understanding a software system by constructing mental models is an important part of any task involving a software system. A large part of current work in reverse engineering is concerned with making explicit the usually implicit comprehension activities and models involved in software tasks <ref> [Van92, Raj92] </ref>. Explicit knowledge representation results in greater awareness and attention to reverse engineering activities, better prediction of the activities' expected efforts and results, and a collection of well-defined system models valuable to every task being carried out on the software system.
Reference: [RBP + 91] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference: [ROL90] <author> Spencer Rugaber, Stephen B. Ornburn, and Richard J. LeBlanc, Jr. </author> <title> Recognizing design decisions in programs. </title> <journal> IEEE Software, </journal> <volume> 7(1) </volume> <pages> 46-54, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: theory [Sri91] Concept hierarchies [Big89, Lub91] Mini-languages [Nei84, ABFP86] Database languages [CR86] Narrow spectrum languages [Web87] Wide spectrum languages [Wil87, WCM89] Knowledge Representation [Bar85] Text Table 1: Application domain models A way of representing the rationale for a program's computational structures is in terms of the design decisions they implement <ref> [ROL90] </ref>. Design is a rational process involving a series of decisions transforming a specification into an implementation. If reverse engineering can detect clues to the decisions made, it can use the clues to "untransform" the program back to a higher level. <p> The application model suggests what kinds of design decisions the code model might implement, and the source code contains manifestations of actual design decisions for which the application model must account. <ref> [ROL90] </ref> provides a characterization of useful categories of design decisions; section 2.1.1 of this paper contains a summary. We chose to use Synchronized Refinement for a number of reasons. First, we are familiar with the technique and have used it successfully on similar problems in the past.
Reference: [RW90] <author> Charles Rich and Richard C. Waters. </author> <title> The Programmer's Apprentice. </title> <publisher> Addison Wes-ley, </publisher> <year> 1990. </year>
Reference-contexts: Two important categories of domain knowledge are programming skills and application domain. Programmers use a collection of mechanisms for constructing their programs. These are often described as "plans" or "schemes" in program understanding literature <ref> [RW90] </ref>. There also is work going on in "domain analysis/engineering/modeling" to support forward engineering activities via reuse.
Reference: [Sha89] <author> Mary Shaw. </author> <title> Large scale systems require higher level abstractions. </title> <booktitle> In Proceedings of the Fifth Workshop on Software Specification and Design, </booktitle> <pages> pages 143-146. </pages> <booktitle> ACM SIGSOFT Notes, ACM, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: The pipeline model of the compiler architecture is one of many emerging high-level idioms for software designs. Shaw discusses the issues related to this approach to software development <ref> [Sha89] </ref>. Semantically oriented representations can be classed as to how operational they are. The more operational representations serve as algorithms for some specific computational mechanism or abstract machine. Expressing a program in another programming language is an operational representation; so is a virtual machine description.
Reference: [Sri91] <author> Yellamraju V. Srinivas. </author> <title> Pattern Matching: </title>
Reference-contexts: Most representation techniques used during software design emphasize one of these three views. Representation Examples Object-Oriented Frameworks [JF88] Category theory <ref> [Sri91] </ref> Concept hierarchies [Big89, Lub91] Mini-languages [Nei84, ABFP86] Database languages [CR86] Narrow spectrum languages [Web87] Wide spectrum languages [Wil87, WCM89] Knowledge Representation [Bar85] Text Table 1: Application domain models A way of representing the rationale for a program's computational structures is in terms of the design decisions they implement [ROL90].
References-found: 20

