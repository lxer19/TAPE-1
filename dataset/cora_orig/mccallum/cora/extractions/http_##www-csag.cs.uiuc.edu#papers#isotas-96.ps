URL: http://www-csag.cs.uiuc.edu/papers/isotas-96.ps
Refering-URL: http://www-csag.cs.uiuc.edu/papers/index.html
Root-URL: http://www.cs.uiuc.edu
Title: ICC++ A C++ Dialect for High Performance Parallel Computing  
Author: A. A. Chien, U. S. Reddy, J. Plevyak and J. Dolby 
Keyword: concurrent languages, parallelism, object-parallel programming, memory consistency, concurrent object-oriented programming.  
Address: 1304 W. Springfield Avenue Urbana, IL 61801  
Affiliation: Department of Computer Science  
Abstract: ICC++ is a new concurrent C++ dialect which supports a single source code for sequential and parallel program versions, the construction of concurrent data abstractions, convenient expression of irregular and fine-grained concurrency, and high performance implementations. ICC++ programs are annotated with potential concurrency, facilitating both sharing source with sequential programs and automatic grain size tuning for efficient execution. Concurrency control is at the object level; each object ensures the consistency of its own state. This consistency can be extended over larger data abstractions. Finally, ICC++ integrates arrays into the object system and the concurrency model. In short, ICC++ addresses concurrency and its relation to abstractions - whether they are implemented by single objects, several objects, or object collections. The design of the language, its rationale, and current status are all described. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> G. Agha. </author> <title> Concurrent object-oriented programming. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 33(9) </volume> <pages> 125-41, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: These operations perform logically atomic updates to the abstraction's state; and each operation must maintain the consistency of that state. Support for such abstractions in sequential languages is well understood [30, 34], but the situation is more complex for concurrent languages <ref> [1, 43, 17, 2, 4, 9, 24, 22] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages [43, 2, 17, 33, 27, 3], we focus on Actor-based languages <ref> [1] </ref> because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation. However, the actor model provides no clear basis for building data abstractions from collections of objects, and the actor model provides no concurrency guarantees.
Reference: 2. <author> Pierre America. </author> <title> A parallel object-oriented language with inheritance and subtyp-ing. </title> <booktitle> In Proceedings of ECOOP/OOPSLA '90, </booktitle> <pages> pages 161-8, </pages> <year> 1990. </year>
Reference-contexts: These operations perform logically atomic updates to the abstraction's state; and each operation must maintain the consistency of that state. Support for such abstractions in sequential languages is well understood [30, 34], but the situation is more complex for concurrent languages <ref> [1, 43, 17, 2, 4, 9, 24, 22] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages <ref> [43, 2, 17, 33, 27, 3] </ref>, we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation.
Reference: 3. <author> Birger Andersen. </author> <title> A genereal, grain-size adaptable, object-oriented programming language for distributed computers. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Copenhagen, Copenhagen, Denmark, </institution> <month> June </month> <year> 1992. </year> <type> Ph.D. thesis (partial). </type>
Reference-contexts: This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages <ref> [43, 2, 17, 33, 27, 3] </ref>, we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation.
Reference: 4. <author> Henri E. Bal. </author> <title> The Shared Data-Object Model as a Paradigm for Programming Distributed Systems. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit Te Amsterdam, </institution> <address> Amsterdam, </address> <year> 1989. </year>
Reference-contexts: These operations perform logically atomic updates to the abstraction's state; and each operation must maintain the consistency of that state. Support for such abstractions in sequential languages is well understood [30, 34], but the situation is more complex for concurrent languages <ref> [1, 43, 17, 2, 4, 9, 24, 22] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting.
Reference: 5. <author> Adam Beguelin, Erik Seligman, and Micheal Starkey. Dome: </author> <title> Distributed object migration environment. </title> <type> Technical Report CMU-CS-94-153, </type> <institution> School of Computer Science, Carnegie-Mellon University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: Data parallel calls across the collection would use the Grid [][] member function do all to fan a given Grid member function out across each element. Such collection members allow vector operation syntax like that in pC++ or Dome <ref> [5] </ref> to be used, as shown below. Grid grid [50][50]; for (int i = 0; i &lt; NUM_ITERATIONS; i++) - grid.do_all (Grid::check_collisions); grid.do_all (Grid::update); - 4.3 Concurrent Abstractions Collections are a convenient way of expressing distributed abstractions which present a concurrent interface. <p> These systems require the programmer to build concurrency control by convention, providing no language support for object consistency or for building abstractions from larger collections of objects. Second, many languages (or libraries) use objects to encapsulate concurrency, exploiting objects to represent data parallel collections or coarse-grained tasks <ref> [5, 22] </ref>. In these languages concurrency control may be expressed explicitly in a library, or implicitly via data flow dependences [22]. Concurrency in these models is generally expensive, and used only sparingly for coarse-grained abstractions.
Reference: 6. <author> B.N. Bershad, E.D. Lazowska, and H.M. Levy. </author> <title> Presto: A system for object-oriented parallel programming. </title> <journal> Software | Practice and Experience, </journal> <volume> 18(8) </volume> <pages> 713-732, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: The consistency model preserves the notion of logically atomic operations by ensuring that method calls do not disrupt each other. Since this model is defined by the language, it does not depend on usage conventions for correctness as in <ref> [8, 24, 9, 40, 6] </ref>. Concurrency guarantees define which member calls will run concurrently, allowing programmers to reason about progress and deadlock. <p> The diversity of task-parallel extensions of C++ is much greater and can be loosely categorized based on their treatment of objects and concurrency. First, there are languages (or libraries) that introduce concurrency without changing the object model <ref> [6, 8, 40, 24] </ref>. These systems require the programmer to build concurrency control by convention, providing no language support for object consistency or for building abstractions from larger collections of objects.
Reference: 7. <author> M. Carson and J. Hermans. </author> <title> Molecular Dynamics and Protein Structure, </title> <booktitle> chapter The Molecular Dynamics Workshop Laboratory, </booktitle> <pages> pages 165-6. </pages> <institution> University of North Carolina, Chapel Hill, </institution> <year> 1985. </year>
Reference-contexts: The Concert system has demonstrated sequential performance matching C and surpassing C++ on demanding numerical benchmarks such as the Livermore Kernels [38], and superior speedups and high absolute performance on a parallel molecular dynamics application (CEDAR <ref> [7] </ref>) on the the Cray T3D [20] and Thinking Machines CM-5 [42].
Reference: 8. <author> Rohit Chandra, Anoop Gupta, and John L. Hennessy. </author> <title> Data locality and load balancing in COOL. </title> <booktitle> In Proceedings of the Fourth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <year> 1993. </year>
Reference-contexts: The consistency model preserves the notion of logically atomic operations by ensuring that method calls do not disrupt each other. Since this model is defined by the language, it does not depend on usage conventions for correctness as in <ref> [8, 24, 9, 40, 6] </ref>. Concurrency guarantees define which member calls will run concurrently, allowing programmers to reason about progress and deadlock. <p> The diversity of task-parallel extensions of C++ is much greater and can be loosely categorized based on their treatment of objects and concurrency. First, there are languages (or libraries) that introduce concurrency without changing the object model <ref> [6, 8, 40, 24] </ref>. These systems require the programmer to build concurrency control by convention, providing no language support for object consistency or for building abstractions from larger collections of objects.
Reference: 9. <author> K. Mani Chandy and Carl Kesselman. </author> <title> Compositional C++: Compositional parallel programming. </title> <booktitle> In Proceedings of the Fifth Workshop on Compilers and Languages for Parallel Computing, </booktitle> <address> New Haven, Connecticut, </address> <year> 1992. </year> <note> YALEU/DCS/RR-915, Springer-Verlag Lecture Notes in Computer Science, </note> <year> 1993. </year>
Reference-contexts: These operations perform logically atomic updates to the abstraction's state; and each operation must maintain the consistency of that state. Support for such abstractions in sequential languages is well understood [30, 34], but the situation is more complex for concurrent languages <ref> [1, 43, 17, 2, 4, 9, 24, 22] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> The consistency model preserves the notion of logically atomic operations by ensuring that method calls do not disrupt each other. Since this model is defined by the language, it does not depend on usage conventions for correctness as in <ref> [8, 24, 9, 40, 6] </ref>. Concurrency guarantees define which member calls will run concurrently, allowing programmers to reason about progress and deadlock. <p> Another important distinction amongst parallel C++'s is the scheduling or concurrency guarantees provided by the language. Data parallel languages have sequential semantics, so the data parallel C++'s provide no concurrency guarantees. Of the task parallel C++ dialects, Charm++ provides explicit control over scheduling [24], and Compositional C++ <ref> [9] </ref> provides guaranteed fair thread 8 MPC++ is another parallel C++ dialect worthy of mention, but since MPC++ provides a programmable language syntax and semantics it is difficult to make specific comparisons. scheduling for all par constructs.
Reference: 10. <author> S. Chatterjee. </author> <title> Compiling nested data parallel programs for shared memory multiprocessors. </title> <journal> ACM Transactions of Programming Languages and Systems, </journal> <volume> 15(3), </volume> <year> 1993. </year>
Reference-contexts: This combination supports reusable libraries of concurrent abstractions. 4.4 Discussion Collections in ICC++ represent a unification of collections as distributed arrays of objects as in <ref> [29, 10] </ref> and the aggregate approach as in [18]. The array approach is more compatible with the preexisting C++ notion of arrays and offers the advantage of separating the collection and constituent types. This can allow distinct members to be defined upon each type.
Reference: 11. <author> A. A. Chien and W. J. Dally. </author> <title> Concurrent Aggregates (CA). </title> <booktitle> In Proceedings of Second Symposium on Principles and Practice of Parallel Programming. ACM, </booktitle> <month> March </month> <year> 1990. </year>
Reference-contexts: Recent work in our group [37, 38, 36] and others [41, 26] demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates <ref> [17, 11] </ref>). The Illinois Concert system is a complete development environment for irregular parallel applications [19]. It supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development.
Reference: 12. <author> A. A. Chien, W. Feng, V. Karamcheti, and J. Plevyak. </author> <title> Techniques for efficient execution of fine-grained concurrent programs. </title> <booktitle> In Proceedings of the Fifth Workshop on Compilers and Languages for Parallel Computing, </booktitle> <pages> pages 103-13, </pages> <address> New Haven, Connecticut, </address> <year> 1992. </year> <note> YALEU/DCS/RR-915, Springer-Verlag Lecture Notes in Computer Science, </note> <year> 1993. </year>
Reference-contexts: We have researched the design of concurrent object oriented programs [35, 13, 17, 16], building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation <ref> [38, 37, 25, 14, 12] </ref>, exploring a variety of aggressive compiler and runtime techniques. The design of ICC++ was based on this experience, and an extensive survey of parallel object-oriented approaches.
Reference: 13. <author> A. A. Chien, M. Straka, J. Dolby, V. Karamcheti, J. Plevyak, and X. Zhang. </author> <title> A case study in irregular parallel programming. </title> <booktitle> In DIMACS Workshop on Specification of Parallel Algorithms, </booktitle> <month> May </month> <year> 1994. </year> <note> Also available as Springer-Verlag LNCS. </note>
Reference-contexts: These object collections can be used to build concurrent abstractions, providing modularity for a wide range of concurrent program structures. ICC++ was designed as part of the Illinois Concert project, and is described fully in [15, 23]. We have researched the design of concurrent object oriented programs <ref> [35, 13, 17, 16] </ref>, building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation [38, 37, 25, 14, 12], exploring a variety of aggressive compiler and runtime techniques. <p> The three phases proceed as follows. handling collisions applies a test for contact among particles. All forces imparted by collisions are also calculated. The code for this phase was presented in Section 4.2; recall that parallelism was exposed both across particles, and across collisions. It was noted in <ref> [13] </ref> that an auxiliary contact list had to be generated for each particle to vectorize this loop, but ICC++'s more flexible concurrency model makes this unnecessary. updating particles velocities and positions merely involves updating the velocities of the particles with the forces calculated from the collisions and changing their positions based <p> Thus all phases can be parallelized with ICC++. Contrast this with <ref> [13] </ref>, where part of the particle interaction phase (the contact list generation) was completely sequential in the data-parallel version, limiting the potential speedup. 6 Discussion and Related Work 6.1 C++ Compatibility In the design of ICC++, our intention was to avoid any gratuitous incompatibilities with sequential C++ programs.
Reference: 14. <author> Andrew Chien, Vijay Karamcheti, and John Plevyak. </author> <title> The Concert system compiler and runtime support for efficient fine-grained concurrent object-oriented programs. </title> <type> Technical Report UIUCDCS-R-93-1815, </type> <institution> Department of Computer Science, University of Illinois, Urbana, Illinois, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: We have researched the design of concurrent object oriented programs [35, 13, 17, 16], building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation <ref> [38, 37, 25, 14, 12] </ref>, exploring a variety of aggressive compiler and runtime techniques. The design of ICC++ was based on this experience, and an extensive survey of parallel object-oriented approaches. <p> An implementation based on the Illinois Concert system has been in progress since February 1995, and has recently become operational. Performance results are not yet available, but we expect them to be in line with previous published studies using the Concert system <ref> [14, 19, 37, 38, 36] </ref>. The remainder of the paper is organized as follows. The three key features enumerated above are described in Sections 2, 3 and 4 respectively. An extended example ICC++ program is examined in Section 5.
Reference: 15. <author> Andrew Chien and Uday Reddy. </author> <title> ICC++ language definition. Concurrent Systems Architecture Group Memo, </title> <note> Also available from http://www-csag.cs.uiuc.edu/, February 1995. </note>
Reference-contexts: These object collections can be used to build concurrent abstractions, providing modularity for a wide range of concurrent program structures. ICC++ was designed as part of the Illinois Concert project, and is described fully in <ref> [15, 23] </ref>. We have researched the design of concurrent object oriented programs [35, 13, 17, 16], building numerous application programs totaling over 40,000 lines.
Reference: 16. <author> Andrew A. Chien. </author> <title> Application studies for concurrent aggregates. </title> <type> Technical report, </type> <institution> Massachusetts Institute of Technology, Artificial Intelligence Laboratory, Cam-bridge, Massachusetts, </institution> <year> 1990. </year>
Reference-contexts: These object collections can be used to build concurrent abstractions, providing modularity for a wide range of concurrent program structures. ICC++ was designed as part of the Illinois Concert project, and is described fully in [15, 23]. We have researched the design of concurrent object oriented programs <ref> [35, 13, 17, 16] </ref>, building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation [38, 37, 25, 14, 12], exploring a variety of aggressive compiler and runtime techniques.
Reference: 17. <author> Andrew A. Chien. </author> <title> Concurrent Aggregates: Supporting Modularity in Massively-Parallel Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993. </year>
Reference-contexts: These object collections can be used to build concurrent abstractions, providing modularity for a wide range of concurrent program structures. ICC++ was designed as part of the Illinois Concert project, and is described fully in [15, 23]. We have researched the design of concurrent object oriented programs <ref> [35, 13, 17, 16] </ref>, building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation [38, 37, 25, 14, 12], exploring a variety of aggressive compiler and runtime techniques. <p> These operations perform logically atomic updates to the abstraction's state; and each operation must maintain the consistency of that state. Support for such abstractions in sequential languages is well understood [30, 34], but the situation is more complex for concurrent languages <ref> [1, 43, 17, 2, 4, 9, 24, 22] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> The ability of elements to access the entire collection allows the MultiSet elements to cooperatively implement a concurrent interface to the abstraction: multiple calls to add elt can proceed simultaneously when called upon different elements of the collection, as shown below. MultiSet&lt;int&gt; set <ref> [17] </ref>; conc for (int i = 0; i &lt; 100; i++) set [i%17].add_elt (i); Note that the use of templates and collections allows the MultiSet to be a reusable abstraction that presents a concurrent interface. <p> All synchronization must be ensured through control structures, such as sequential blocks, provided by the language. 6.3 Parallel C++ Efforts The many approaches to parallel C++ can be divided into two categories: data-parallel and task-parallel extensions. Data parallel extensions of C++ [29, 28] employ collections or aggregates <ref> [17, 39] </ref> to describe parallelism, using objects to increase the flexibility of the data parallel model. However, data parallel languages cannot easily express more irregular and client-server forms of con-currency, limiting their domain of applications. <p> This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages <ref> [43, 2, 17, 33, 27, 3] </ref>, we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation. <p> Recent work in our group [37, 38, 36] and others [41, 26] demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates <ref> [17, 11] </ref>). The Illinois Concert system is a complete development environment for irregular parallel applications [19]. It supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development.
Reference: 18. <author> Andrew A. Chien and William J. Dally. </author> <title> Experience with concurrent aggregates (ca): </title> <booktitle> Implementation and programming. In Proceedings of the Fifth Distributed Memory Computers Conference, </booktitle> <address> Charleston, South Carolina, </address> <month> April 8-12 </month> <year> 1990. </year> <note> SIAM. </note>
Reference-contexts: This combination supports reusable libraries of concurrent abstractions. 4.4 Discussion Collections in ICC++ represent a unification of collections as distributed arrays of objects as in [29, 10] and the aggregate approach as in <ref> [18] </ref>. The array approach is more compatible with the preexisting C++ notion of arrays and offers the advantage of separating the collection and constituent types. This can allow distinct members to be defined upon each type.
Reference: 19. <author> Andrew A. Chien and Julian Dolby. </author> <title> The Illinois Concert system: A problem-solving environment for irregular applications. </title> <booktitle> In Proceedings of DAGS'94, The Symposium on Parallel Computation and Problem Solving Environments., </booktitle> <year> 1994. </year>
Reference-contexts: An implementation based on the Illinois Concert system has been in progress since February 1995, and has recently become operational. Performance results are not yet available, but we expect them to be in line with previous published studies using the Concert system <ref> [14, 19, 37, 38, 36] </ref>. The remainder of the paper is organized as follows. The three key features enumerated above are described in Sections 2, 3 and 4 respectively. An extended example ICC++ program is examined in Section 5. <p> The Illinois Concert system is a complete development environment for irregular parallel applications <ref> [19] </ref>. It supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development.
Reference: 20. <institution> Cray Research, Inc., Eagan, Minnesota 55121. CRAY T3D Software Overview Technical Note, </institution> <year> 1992. </year>
Reference-contexts: The Concert system has demonstrated sequential performance matching C and surpassing C++ on demanding numerical benchmarks such as the Livermore Kernels [38], and superior speedups and high absolute performance on a parallel molecular dynamics application (CEDAR [7]) on the the Cray T3D <ref> [20] </ref> and Thinking Machines CM-5 [42]. The implementation of ICC++ which has just become operational exploits the same aggressive compiler analysis and code optimization, so we expect similar performance in the near future. 7 Summary ICC++ is a new C++ dialect designed to support both efficient sequential and parallel execution.
Reference: 21. <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1993. </year>
Reference-contexts: Note that this does not prevent interference, since the object whose reference is declared integral could be shared. 3.3 Composing Abstractions Procedurally friend A fundamental aspect of coordinating concurrent activities is the need to perform coordinated updates across several distinct abstractions <ref> [21, 31] </ref>, involving some form of transactions. friend functions in C++ are considered member functions upon all arguments for which they are friends, and thus friend functions in ICC++ can be used to procedurally compose operations on several objects into a single consistent operation subject to the same object consistency and
Reference: 22. <author> A. Grimshaw. </author> <title> Easy-to-use object-oriented parallel processing with Mentat. </title> <journal> IEEE Computer, </journal> <volume> 5(26) </volume> <pages> 39-51, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: These operations perform logically atomic updates to the abstraction's state; and each operation must maintain the consistency of that state. Support for such abstractions in sequential languages is well understood [30, 34], but the situation is more complex for concurrent languages <ref> [1, 43, 17, 2, 4, 9, 24, 22] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> These systems require the programmer to build concurrency control by convention, providing no language support for object consistency or for building abstractions from larger collections of objects. Second, many languages (or libraries) use objects to encapsulate concurrency, exploiting objects to represent data parallel collections or coarse-grained tasks <ref> [5, 22] </ref>. In these languages concurrency control may be expressed explicitly in a library, or implicitly via data flow dependences [22]. Concurrency in these models is generally expensive, and used only sparingly for coarse-grained abstractions. <p> Second, many languages (or libraries) use objects to encapsulate concurrency, exploiting objects to represent data parallel collections or coarse-grained tasks [5, 22]. In these languages concurrency control may be expressed explicitly in a library, or implicitly via data flow dependences <ref> [22] </ref>. Concurrency in these models is generally expensive, and used only sparingly for coarse-grained abstractions.
Reference: 23. <institution> Concurrent Systems Architecture Group. </institution> <note> The ICC++ reference manual. </note> <institution> Concurrent Systems Architecture Group Memo, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: These object collections can be used to build concurrent abstractions, providing modularity for a wide range of concurrent program structures. ICC++ was designed as part of the Illinois Concert project, and is described fully in <ref> [15, 23] </ref>. We have researched the design of concurrent object oriented programs [35, 13, 17, 16], building numerous application programs totaling over 40,000 lines. <p> introducing available concurrency is the conc block, an extension of the C++ compound statement, which specifies that the contained statements are only partially ordered based upon local data dependences. conc blocks are defined as follows: 3 ICC++ also includes primitives which guarantee concurrency for situations where a guarantee is required <ref> [23] </ref>; however, these primitives are expensive as they dictate an implementation to the system, and should be used with care. conc f S 1 ; ... ; S n ; g is a compound statement which defines the following partial order on its constituents: S i S j () i &lt; <p> They are related to collections in pC++ [29] when used for data parallelism, but each element can access the entire collection, allowing them to implement more complex composite behavior as well. Finally, collections allow distributions to be explicitly specified (see <ref> [23] </ref>). 4.1 Defining Object Collections Collections are defined with standard class declarations, with the addition of [ ] to the class name and are declared just as arrays. This declaration creates separate classes for the elements, called type, and for the collection itself, called type [ ]. <p> []; int elt_count; public: Element add_elt (Element elt) - return elts [elt_count++] = elt; - int find_elt (Element elt) - return MultiSet []::this-&gt;find_elt (elt); - int find_elt_internal (Element elt) - int count = 0; for (int i = 0; i &lt; elt_count; i++) 6 There are other predefined collection members <ref> [23] </ref> if (elts [i] == elt) count++; return count; - int MultiSet []::find_elt (Element elt) - int count = 0; conc for (int i = 0; i &lt; size (); i++) count += (*this)[i].find_elt_internal (elt); - The MultiSet abstraction is a distributed multi-set in which different elements are stored in each <p> First, it increases type safety by preventing the confusion of arrays of objects and pointers to single object allowed by using pointers for arrays. Second, and more importantly, it eliminates one difficulty for program analysis: pointer arithmetic. 7 This necessitates some changes to C++ syntax <ref> [23] </ref> 5 Extended Example The constructs described so far are designed to allow flexible expression of con-currency and incremental parallelization of existing programs. We illustrate how these constructs are used in a simple distinct element example, in which particles are moving about in space, colliding with one another.
Reference: 24. <author> L. V. Kale and Sanjeev Krishnan. CHARM++: </author> <title> A portable concurrent object oriented system based on C++. </title> <booktitle> In Proceedings of OOPSLA'93, </booktitle> <year> 1993. </year>
Reference-contexts: These operations perform logically atomic updates to the abstraction's state; and each operation must maintain the consistency of that state. Support for such abstractions in sequential languages is well understood [30, 34], but the situation is more complex for concurrent languages <ref> [1, 43, 17, 2, 4, 9, 24, 22] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> The consistency model preserves the notion of logically atomic operations by ensuring that method calls do not disrupt each other. Since this model is defined by the language, it does not depend on usage conventions for correctness as in <ref> [8, 24, 9, 40, 6] </ref>. Concurrency guarantees define which member calls will run concurrently, allowing programmers to reason about progress and deadlock. <p> The diversity of task-parallel extensions of C++ is much greater and can be loosely categorized based on their treatment of objects and concurrency. First, there are languages (or libraries) that introduce concurrency without changing the object model <ref> [6, 8, 40, 24] </ref>. These systems require the programmer to build concurrency control by convention, providing no language support for object consistency or for building abstractions from larger collections of objects. <p> Another important distinction amongst parallel C++'s is the scheduling or concurrency guarantees provided by the language. Data parallel languages have sequential semantics, so the data parallel C++'s provide no concurrency guarantees. Of the task parallel C++ dialects, Charm++ provides explicit control over scheduling <ref> [24] </ref>, and Compositional C++ [9] provides guaranteed fair thread 8 MPC++ is another parallel C++ dialect worthy of mention, but since MPC++ provides a programmable language syntax and semantics it is difficult to make specific comparisons. scheduling for all par constructs.
Reference: 25. <author> Vijay Karamcheti and Andrew Chien. </author> <title> Concert efficient runtime support for concurrent object-oriented programming languages on stock hardware. </title> <booktitle> In Proceedings of Supercomputing'93, </booktitle> <year> 1993. </year>
Reference-contexts: We have researched the design of concurrent object oriented programs [35, 13, 17, 16], building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation <ref> [38, 37, 25, 14, 12] </ref>, exploring a variety of aggressive compiler and runtime techniques. The design of ICC++ was based on this experience, and an extensive survey of parallel object-oriented approaches. <p> The Illinois Concert system is a complete development environment for irregular parallel applications [19]. It supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development. This system employs novel compiler techniques [37, 38, 36] and run-time techniques <ref> [38, 25] </ref> to achieve efficient execution of fine-grained programs on both sequential and parallel platforms.
Reference: 26. <author> Woo Young Kim and Gul Agha. </author> <title> Efficient support for location transparency in concurrent object-oriented programming languages. </title> <booktitle> In Proceedings of the Supercomputing '95 Conference, </booktitle> <address> San Diego, CA, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: In contrast, ICC++ includes both concurrency guarantees and language support for building abstractions from ensembles (structures or collections) of objects. In addition, to date most of the Actor based languages have been inefficient in implementation. Recent work in our group [37, 38, 36] and others <ref> [41, 26] </ref> demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates [17, 11]). The Illinois Concert system is a complete development environment for irregular parallel applications [19].
Reference: 27. <author> H. Konaka. </author> <title> An overview of ocore: A massively parallel object-based language. </title> <type> Technical Report TR-P-93-002, </type> <institution> Tsukuba Research Center, Real World Computing Partnership, Tsukuba Mitsui Building 16F, </institution> <address> 1-6-1 Takezono, Tsukuba-shi, Ibaraki 305, JAPAN, </address> <year> 1993. </year>
Reference-contexts: This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages <ref> [43, 2, 17, 33, 27, 3] </ref>, we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation.
Reference: 28. <author> James Larus. </author> <title> C**: a large-grain, object-oriented, </title> <booktitle> data parallel programming language. In Proceedings of the Fifth Workshop for Languages and Compilers for Parallel Machines, </booktitle> <pages> pages 326-341. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: All synchronization must be ensured through control structures, such as sequential blocks, provided by the language. 6.3 Parallel C++ Efforts The many approaches to parallel C++ can be divided into two categories: data-parallel and task-parallel extensions. Data parallel extensions of C++ <ref> [29, 28] </ref> employ collections or aggregates [17, 39] to describe parallelism, using objects to increase the flexibility of the data parallel model. However, data parallel languages cannot easily express more irregular and client-server forms of con-currency, limiting their domain of applications.
Reference: 29. <author> J. Lee and D. Gannon. </author> <title> Object oriented parallel programming. </title> <booktitle> In Proceedings of the ACM/IEEE Conference on Supercomputing. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: This allows array-level functionality to be expressed as members of an array class. These collection classes support a wide variety of concurrency patterns, from a data-parallel array model to more complex concurrent abstractions. They are related to collections in pC++ <ref> [29] </ref> when used for data parallelism, but each element can access the entire collection, allowing them to implement more complex composite behavior as well. <p> This combination supports reusable libraries of concurrent abstractions. 4.4 Discussion Collections in ICC++ represent a unification of collections as distributed arrays of objects as in <ref> [29, 10] </ref> and the aggregate approach as in [18]. The array approach is more compatible with the preexisting C++ notion of arrays and offers the advantage of separating the collection and constituent types. This can allow distinct members to be defined upon each type. <p> All synchronization must be ensured through control structures, such as sequential blocks, provided by the language. 6.3 Parallel C++ Efforts The many approaches to parallel C++ can be divided into two categories: data-parallel and task-parallel extensions. Data parallel extensions of C++ <ref> [29, 28] </ref> employ collections or aggregates [17, 39] to describe parallelism, using objects to increase the flexibility of the data parallel model. However, data parallel languages cannot easily express more irregular and client-server forms of con-currency, limiting their domain of applications.
Reference: 30. <author> Barbara Liskov. </author> <title> Data abstraction and hierarchy. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(5) </volume> <pages> 17-34, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: These operations perform logically atomic updates to the abstraction's state; and each operation must maintain the consistency of that state. Support for such abstractions in sequential languages is well understood <ref> [30, 34] </ref>, but the situation is more complex for concurrent languages [1, 43, 17, 2, 4, 9, 24, 22]. Concurrency allows only a partial order on state updates, complicating the notion of consistency.
Reference: 31. <author> Barbara Liskov. </author> <title> Distributed programming in argus. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 300-313, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Note that this does not prevent interference, since the object whose reference is declared integral could be shared. 3.3 Composing Abstractions Procedurally friend A fundamental aspect of coordinating concurrent activities is the need to perform coordinated updates across several distinct abstractions <ref> [21, 31] </ref>, involving some form of transactions. friend functions in C++ are considered member functions upon all arguments for which they are friends, and thus friend functions in ICC++ can be used to procedurally compose operations on several objects into a single consistent operation subject to the same object consistency and
Reference: 32. <author> S. Matsuoka and A. Yonezawa. </author> <title> Research Directions in Object-Based Concurrency, chapter "Analysis of Inheritance Anomaly in Object-Oriented Concurrent Languages". </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: We are exploring alternate implementations for such classes, using helper classes. 6.2 Derivation and Concurrency The Inheritance Anomaly threatens to undermine the concurrent object-oriented approach by turning two basic mechanisms against each other: derivation and concurrency. The problems described by <ref> [32] </ref> involve the sequencing of messages; that is, when certain messages may be handled by a given object. <p> In a sequential object-oriented language, when one tries to dequeue from an empty queue, the dequeue generates an error rather than being delayed until such time as there is something to get, as in the examples in <ref> [32] </ref>. Due to its C++ heritage, ICC++ takes the same approach, and there is no notion of messages being delayed until they can be handled.
Reference: 33. <author> Stephan Murer, Jerome A. Feldman, Chu-Cheow Lim, and Martina-Maria Seidel. pSather: </author> <title> Layered extensions to an object-oriented language for efficient parallel computation. </title> <type> Technical Report TR-93-028, </type> <institution> International Computer Science Institute, Berkeley, </institution> <address> CA, </address> <month> June </month> <year> 1993 </year> <month> November </month> <year> 1993. </year>
Reference-contexts: This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages <ref> [43, 2, 17, 33, 27, 3] </ref>, we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation.
Reference: 34. <author> N. Wirth and M. Reiser. </author> <title> Programming in Oberon Steps beyond Pascal and Modula. </title> <publisher> Addison Wesley, </publisher> <year> 1992. </year>
Reference-contexts: These operations perform logically atomic updates to the abstraction's state; and each operation must maintain the consistency of that state. Support for such abstractions in sequential languages is well understood <ref> [30, 34] </ref>, but the situation is more complex for concurrent languages [1, 43, 17, 2, 4, 9, 24, 22]. Concurrency allows only a partial order on state updates, complicating the notion of consistency.
Reference: 35. <author> T. Ng, X. Zhang, V. Karamcheti, and A. A. Chien. </author> <title> Parallel macromolecular dynamics on the Concert System. </title> <note> In Submitted for publication, </note> <year> 1995. </year>
Reference-contexts: These object collections can be used to build concurrent abstractions, providing modularity for a wide range of concurrent program structures. ICC++ was designed as part of the Illinois Concert project, and is described fully in [15, 23]. We have researched the design of concurrent object oriented programs <ref> [35, 13, 17, 16] </ref>, building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation [38, 37, 25, 14, 12], exploring a variety of aggressive compiler and runtime techniques.
Reference: 36. <author> John Plevyak and Andrew Chien. </author> <title> Efficient cloning to eliminate dynamic dispatch in object-oriented languages. </title> <note> Submitted for Publication, </note> <year> 1995. </year>
Reference-contexts: An implementation based on the Illinois Concert system has been in progress since February 1995, and has recently become operational. Performance results are not yet available, but we expect them to be in line with previous published studies using the Concert system <ref> [14, 19, 37, 38, 36] </ref>. The remainder of the paper is organized as follows. The three key features enumerated above are described in Sections 2, 3 and 4 respectively. An extended example ICC++ program is examined in Section 5. <p> In contrast, ICC++ includes both concurrency guarantees and language support for building abstractions from ensembles (structures or collections) of objects. In addition, to date most of the Actor based languages have been inefficient in implementation. Recent work in our group <ref> [37, 38, 36] </ref> and others [41, 26] demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates [17, 11]). The Illinois Concert system is a complete development environment for irregular parallel applications [19]. <p> The Illinois Concert system is a complete development environment for irregular parallel applications [19]. It supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development. This system employs novel compiler techniques <ref> [37, 38, 36] </ref> and run-time techniques [38, 25] to achieve efficient execution of fine-grained programs on both sequential and parallel platforms.
Reference: 37. <author> John Plevyak and Andrew A. Chien. </author> <title> Precise concrete type inference of object-oriented programs. </title> <booktitle> In Proceedings of OOPSLA'94, Object-Oriented Programming Systems, Languages and Architectures, </booktitle> <pages> pages 324-340, </pages> <year> 1994. </year>
Reference-contexts: We have researched the design of concurrent object oriented programs [35, 13, 17, 16], building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation <ref> [38, 37, 25, 14, 12] </ref>, exploring a variety of aggressive compiler and runtime techniques. The design of ICC++ was based on this experience, and an extensive survey of parallel object-oriented approaches. <p> An implementation based on the Illinois Concert system has been in progress since February 1995, and has recently become operational. Performance results are not yet available, but we expect them to be in line with previous published studies using the Concert system <ref> [14, 19, 37, 38, 36] </ref>. The remainder of the paper is organized as follows. The three key features enumerated above are described in Sections 2, 3 and 4 respectively. An extended example ICC++ program is examined in Section 5. <p> In contrast, ICC++ includes both concurrency guarantees and language support for building abstractions from ensembles (structures or collections) of objects. In addition, to date most of the Actor based languages have been inefficient in implementation. Recent work in our group <ref> [37, 38, 36] </ref> and others [41, 26] demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates [17, 11]). The Illinois Concert system is a complete development environment for irregular parallel applications [19]. <p> The Illinois Concert system is a complete development environment for irregular parallel applications [19]. It supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development. This system employs novel compiler techniques <ref> [37, 38, 36] </ref> and run-time techniques [38, 25] to achieve efficient execution of fine-grained programs on both sequential and parallel platforms.
Reference: 38. <author> John Plevyak, Xingbin Zhang, and Andrew A. Chien. </author> <title> Obtaining sequential efficiency in concurrent object-oriented programs. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 311-321, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: We have researched the design of concurrent object oriented programs [35, 13, 17, 16], building numerous application programs totaling over 40,000 lines. In addition, we have studied the design of concurrent object-oriented languages and their implementation <ref> [38, 37, 25, 14, 12] </ref>, exploring a variety of aggressive compiler and runtime techniques. The design of ICC++ was based on this experience, and an extensive survey of parallel object-oriented approaches. <p> An implementation based on the Illinois Concert system has been in progress since February 1995, and has recently become operational. Performance results are not yet available, but we expect them to be in line with previous published studies using the Concert system <ref> [14, 19, 37, 38, 36] </ref>. The remainder of the paper is organized as follows. The three key features enumerated above are described in Sections 2, 3 and 4 respectively. An extended example ICC++ program is examined in Section 5. <p> In contrast, ICC++ includes both concurrency guarantees and language support for building abstractions from ensembles (structures or collections) of objects. In addition, to date most of the Actor based languages have been inefficient in implementation. Recent work in our group <ref> [37, 38, 36] </ref> and others [41, 26] demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates [17, 11]). The Illinois Concert system is a complete development environment for irregular parallel applications [19]. <p> The Illinois Concert system is a complete development environment for irregular parallel applications [19]. It supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development. This system employs novel compiler techniques <ref> [37, 38, 36] </ref> and run-time techniques [38, 25] to achieve efficient execution of fine-grained programs on both sequential and parallel platforms. <p> The Illinois Concert system is a complete development environment for irregular parallel applications [19]. It supports a concurrent object-oriented programming model and includes a globally optimizing compiler, efficient runtime, symbolic debugger, and an emulator for program development. This system employs novel compiler techniques [37, 38, 36] and run-time techniques <ref> [38, 25] </ref> to achieve efficient execution of fine-grained programs on both sequential and parallel platforms. <p> This system employs novel compiler techniques [37, 38, 36] and run-time techniques [38, 25] to achieve efficient execution of fine-grained programs on both sequential and parallel platforms. The Concert system has demonstrated sequential performance matching C and surpassing C++ on demanding numerical benchmarks such as the Livermore Kernels <ref> [38] </ref>, and superior speedups and high absolute performance on a parallel molecular dynamics application (CEDAR [7]) on the the Cray T3D [20] and Thinking Machines CM-5 [42].
Reference: 39. <author> G. Sabot. </author> <title> The Paralation Model. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: All synchronization must be ensured through control structures, such as sequential blocks, provided by the language. 6.3 Parallel C++ Efforts The many approaches to parallel C++ can be divided into two categories: data-parallel and task-parallel extensions. Data parallel extensions of C++ [29, 28] employ collections or aggregates <ref> [17, 39] </ref> to describe parallelism, using objects to increase the flexibility of the data parallel model. However, data parallel languages cannot easily express more irregular and client-server forms of con-currency, limiting their domain of applications.
Reference: 40. <author> K. Smith and A. Chatterjee. </author> <title> A C++ environment for distributed application execution. </title> <type> Technical Report ACT-ESP-015-91, </type> <institution> Microelectronics and Computer Technology Corporation (MCC), </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: The consistency model preserves the notion of logically atomic operations by ensuring that method calls do not disrupt each other. Since this model is defined by the language, it does not depend on usage conventions for correctness as in <ref> [8, 24, 9, 40, 6] </ref>. Concurrency guarantees define which member calls will run concurrently, allowing programmers to reason about progress and deadlock. <p> The diversity of task-parallel extensions of C++ is much greater and can be loosely categorized based on their treatment of objects and concurrency. First, there are languages (or libraries) that introduce concurrency without changing the object model <ref> [6, 8, 40, 24] </ref>. These systems require the programmer to build concurrency control by convention, providing no language support for object consistency or for building abstractions from larger collections of objects.
Reference: 41. <author> K. Taura, S. Matsuoka, and A. Yonezawa. </author> <title> An efficient implementation scheme of concurrent object-oriented languages on stock multicomputers. </title> <booktitle> In Proceedings of the Fifth ACM SIGPLAN Symposium on the Principles and Practice of Parallel Programming, </booktitle> <year> 1993. </year>
Reference-contexts: In contrast, ICC++ includes both concurrency guarantees and language support for building abstractions from ensembles (structures or collections) of objects. In addition, to date most of the Actor based languages have been inefficient in implementation. Recent work in our group [37, 38, 36] and others <ref> [41, 26] </ref> demonstrates that actor languages need not be inefficient. 6.5 Illinois Concert Project ICC++ is the second language supported by the Concert project (the first is Concurrent Aggregates [17, 11]). The Illinois Concert system is a complete development environment for irregular parallel applications [19].
Reference: 42. <institution> Thinking Machines Corporation, </institution> <address> 245 First Street, Cambridge, MA 02154-1264. </address> <booktitle> The Connection Machine CM-5 Technical Summary, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: The Concert system has demonstrated sequential performance matching C and surpassing C++ on demanding numerical benchmarks such as the Livermore Kernels [38], and superior speedups and high absolute performance on a parallel molecular dynamics application (CEDAR [7]) on the the Cray T3D [20] and Thinking Machines CM-5 <ref> [42] </ref>. The implementation of ICC++ which has just become operational exploits the same aggressive compiler analysis and code optimization, so we expect similar performance in the near future. 7 Summary ICC++ is a new C++ dialect designed to support both efficient sequential and parallel execution.
Reference: 43. <editor> Akinori Yonezawa, editor. </editor> <title> ABCL: An Object-Oriented Concurrent System. </title> <publisher> MIT Press, </publisher> <year> 1990. </year> <title> ISBN 0-262-24029-7. This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: These operations perform logically atomic updates to the abstraction's state; and each operation must maintain the consistency of that state. Support for such abstractions in sequential languages is well understood [30, 34], but the situation is more complex for concurrent languages <ref> [1, 43, 17, 2, 4, 9, 24, 22] </ref>. Concurrency allows only a partial order on state updates, complicating the notion of consistency. Any concurrent model must preserve the notion of logically atomic operations upon an abstraction in a concurrent setting. <p> This gives the implementation freedom to select an execution granularity (thread sizes) for efficiency, facilitating efficient sequential execution. 6.4 Other Concurrent Object-Oriented Languages Though there are a wide variety of non-C++ concurrent object-oriented languages <ref> [43, 2, 17, 33, 27, 3] </ref>, we focus on Actor-based languages [1] because they closely integrate the notion of actors (objects) and concurrency. This allows programmers to reason at the level of object-operation.
References-found: 43

