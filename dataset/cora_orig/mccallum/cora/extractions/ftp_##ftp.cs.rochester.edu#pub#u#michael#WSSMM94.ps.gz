URL: ftp://ftp.cs.rochester.edu/pub/u/michael/WSSMM94.ps.gz
Refering-URL: http://www.cs.rochester.edu/u/michael/
Root-URL: 
Title: Scalable Atomic Primitives for Distributed Shared Memory Multiprocessors (Extended Abstract)  
Author: Maged M. Michael Michael L. Scott 
Address: Rochester, NY 14627-0226 USA  Rochester, NY 14627-0226 USA  
Affiliation: Department of Computer Science University of Rochester  Department of Computer Science University of Rochester  
Abstract: Our research addresses the general topic of atomic update of shared data structures on large-scale shared-memory multiprocessors. In this paper we consider alternative implementations of the general-purpose single-address atomic primitives fetch and , compare and swap, load linked, and store conditional. These primitives have proven popular on small-scale bus-based machines, but have yet to become widely available on large-scale, distributed shared memory machines. We propose several alternative hardware implementations of these primitives, and then analyze the performance of these implementations for various data sharing patterns. Our results indicate that good overall performance can be obtained by implementing compare and swap in the cache controllers, and by pro viding an additional instruction to load an exclusive copy of a cache line.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Agarwal, B.-H. Lim, D. Kranz, and J. Kubiatowicz. </author> <month> APRIL: </month> <title> A Processor Architecture for Multiprocessing. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 104-114, </pages> <address> New York, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Most of them are special-purpose primitives designed to support particular synchronization operations. Examples include test and set with special semantics on the Stanford DASH [9], the QOLB primitives of the Wisconsin Multicube [3] and the IEEE Scalable Coherent Interface [10], the full/empty bits of the MIT Alewife <ref> [1] </ref>, and the primitives for locking and unlocking cache lines on the Kendall Square KSR1 [8].
Reference: [2] <author> S. J. Eggers and R. H. Katz. </author> <title> The Effect of Sharing on the Cache and Bus Performance of Parallel Programs. </title> <booktitle> In Proceedings of the Third International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 257-270, </pages> <address> Boston, MA, </address> <month> April </month> <year> 1989. </year>
Reference-contexts: The synthetic applications|lock-free, test-and-test-and-set lock-based, and MCS lock-based access to a counter|served to explore the parameter space and to provide controlled performance measurements. 3.1 SHARING PATTERNS Performance of atomic primitives is affected by two main sharing patterns, contention and average write-run length <ref> [2] </ref>. In this context, the level of contention is the number of processors that concurrently try to access an atomically accessed shared location.
Reference: [3] <author> J. R. Goodman, M. K. Vernon, and P. J. Woest. </author> <title> Efficient Synchronization Primitives for Large-Scale Cache-Coherent Multiprocessors. </title> <booktitle> In Proceedings of the Third International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 64-75, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Several atomic primitives have been proposed and implemented on DSM architec-tures. Most of them are special-purpose primitives designed to support particular synchronization operations. Examples include test and set with special semantics on the Stanford DASH [9], the QOLB primitives of the Wisconsin Multicube <ref> [3] </ref> and the IEEE Scalable Coherent Interface [10], the full/empty bits of the MIT Alewife [1], and the primitives for locking and unlocking cache lines on the Kendall Square KSR1 [8].
Reference: [4] <author> A. Gottlieb, B. D. Lubachevsky, and L. Rudolph. </author> <title> Basic Techniques for the Efficient Coordination of Very Large Numbers of Cooperating Sequential Processors. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 164-189, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: Although we do not recommend it as the sole atomic primitive, we find fetch and add to be useful with lock-free counters (and with many other objects <ref> [4] </ref>). We recommend implementing it in uncached memory as an extra atomic primitive.
Reference: [5] <author> M. Herlihy and J. Moss. </author> <title> Transactional Memory: Architectural Support for Lock-Free Data Structures. </title> <booktitle> In Proceedings of the 20th International Symposium on Computer Architecture, </booktitle> <pages> pages 289-300, </pages> <address> San Diego, CA, </address> <month> May 16-19, </month> <year> 1993. </year>
Reference-contexts: We recommend implementing it in uncached memory as an extra atomic primitive. Our plans for future research include extending this study to cover multiple-address atomic primitives such as transactional memory <ref> [5] </ref> and the Oklahoma update [12], and other alternatives for atomic update of multiple-address objects such as Her-lihy's lock-free methodology [7], function shipping (active messages [14]), and special-purpose concurrent lock-based and lock-free implementations.
Reference: [6] <author> M. P. Herlihy. </author> <title> Wait-Free Synchronization. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 124-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Because it is limited to only certain kinds of algorithms, however, we recommend it only in addition to a universal primitive <ref> [6] </ref> (compare and swap or load - linked/store conditional). EXC compare and swap almost always benefits from load exclusive, because compare and swap's are hits in the case of no contention and load exclusive helps minimize the failure rate of compare and swap as contention increases. <p> obtain the needed exclusive copy of the data with only 2 serialized messages (requesting node to home and back) instead of 4 (requesting node to home to current owner to home and back to requesting node). 4 CONCLUSIONS Based on the experimental results and the relative power of atomic primitives <ref> [6] </ref>, we recommend implementing compare and swap in the cache controllers of future DSM multiprocessors, with a write-invalidate coherence policy. We also recommend supporting load exclusive to enhance the performance of compare and swap, in addition to its benefits in efficient data migration.
Reference: [7] <author> M. P. Herlihy. </author> <title> A Methodology for Implementing Highly Concurrent Data Objects. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 15(5) </volume> <pages> 745-770, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Our plans for future research include extending this study to cover multiple-address atomic primitives such as transactional memory [5] and the Oklahoma update [12], and other alternatives for atomic update of multiple-address objects such as Her-lihy's lock-free methodology <ref> [7] </ref>, function shipping (active messages [14]), and special-purpose concurrent lock-based and lock-free implementations.
Reference: [8] <institution> KSR1 Principles of Operation. Kendall Square Research Corporation, </institution> <year> 1991. </year>
Reference-contexts: Examples include test and set with special semantics on the Stanford DASH [9], the QOLB primitives of the Wisconsin Multicube [3] and the IEEE Scalable Coherent Interface [10], the full/empty bits of the MIT Alewife [1], and the primitives for locking and unlocking cache lines on the Kendall Square KSR1 <ref> [8] </ref>. General-purpose primitives such as fetch and , compare and swap, and the pair load linked/store conditional can easily and efficiently implement a wide variety of styles of synchronization (e.g. operations on wait-free and lock-free objects, read-write locks, priority locks, etc.).
Reference: [9] <author> D. Lenoski, J. Laudon, K. Gharachorloo, W.-D. Weber, A. Gupta, J. Hennessy, M. Horowitz, and M. S. Lam. </author> <title> The Stanford DASH Multiprocessor. </title> <journal> Computer, </journal> <volume> 25(3) </volume> <pages> 63-79, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Several atomic primitives have been proposed and implemented on DSM architec-tures. Most of them are special-purpose primitives designed to support particular synchronization operations. Examples include test and set with special semantics on the Stanford DASH <ref> [9] </ref>, the QOLB primitives of the Wisconsin Multicube [3] and the IEEE Scalable Coherent Interface [10], the full/empty bits of the MIT Alewife [1], and the primitives for locking and unlocking cache lines on the Kendall Square KSR1 [8].
Reference: [10] <institution> IEEE Standard for Scalable Coherent Interface (SCI). IEEE, Inc., </institution> <year> 1993. </year>
Reference-contexts: Most of them are special-purpose primitives designed to support particular synchronization operations. Examples include test and set with special semantics on the Stanford DASH [9], the QOLB primitives of the Wisconsin Multicube [3] and the IEEE Scalable Coherent Interface <ref> [10] </ref>, the full/empty bits of the MIT Alewife [1], and the primitives for locking and unlocking cache lines on the Kendall Square KSR1 [8].
Reference: [11] <author> J. P. Singh, W.-D. Weber, and A. Gupta. </author> <title> SPLASH: Stanford Parallel Applications for Shared-Memory. </title> <journal> Computer Architecture News, </journal> <volume> 20(1) </volume> <pages> 5-44, </pages> <month> March </month> <year> 1992. </year>
Reference: [12] <author> J. M. Stone, H. S. Stone, P. Heidelberger, and J. Turek. </author> <title> Multiple Reservations and the Oklahoma Update. </title> <journal> IEEE Parallel and Distributed Technology, </journal> <volume> 1(4) </volume> <pages> 58-71, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: We recommend implementing it in uncached memory as an extra atomic primitive. Our plans for future research include extending this study to cover multiple-address atomic primitives such as transactional memory [5] and the Oklahoma update <ref> [12] </ref>, and other alternatives for atomic update of multiple-address objects such as Her-lihy's lock-free methodology [7], function shipping (active messages [14]), and special-purpose concurrent lock-based and lock-free implementations.
Reference: [13] <author> J. E. Veenstra and R. J. Fowler. MINT: </author> <title> A Front End for Efficient Simulation of Shared-Memory Multiprocessors. </title> <booktitle> In Proceedings of the Second International Workshop on Modeling, Analysis, and Simulation of Computer and Telecommunication Systems, </booktitle> <pages> pages 201-207, </pages> <year> 1994. </year>
Reference-contexts: Drop copy can be used to drop (self-invalidate) a cached datum, to reduce the number of serialized messages required for subsequent accesses by other processors. 3 EXPERIMENTAL RESULTS The experimental results were collected using an execution-driven simulator that uses MINT <ref> [13] </ref> as a front end. The back end simulates a 64-node multiprocessor with directory-based caches, 32-byte blocks, memory that queues conflicting accesses, and a 2-D worm-hole mesh network. We used two sets of applications, real and synthetic, to achieve different goals.
Reference: [14] <author> T. von Eicken, D. E. Culer, S. C. Goldstein, and K. E. Schauser. </author> <title> Active Messages: A Mechanism for Integrated Communication and Computation. </title> <booktitle> In Proceeedings of the 19th International Symposium on Computer Architecture, </booktitle> <pages> pages 256-266, </pages> <address> Gold Coast, Australia, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Our plans for future research include extending this study to cover multiple-address atomic primitives such as transactional memory [5] and the Oklahoma update [12], and other alternatives for atomic update of multiple-address objects such as Her-lihy's lock-free methodology [7], function shipping (active messages <ref> [14] </ref>), and special-purpose concurrent lock-based and lock-free implementations.
References-found: 14

