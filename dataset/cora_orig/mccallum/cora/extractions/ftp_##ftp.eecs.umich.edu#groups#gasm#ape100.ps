URL: ftp://ftp.eecs.umich.edu/groups/gasm/ape100.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: E-Mail: boerger@di.unipi.it  E-Mail: giusp@uni-paderborn.de  
Phone: Fax: ++39 50 887226  Fax: ++49 5251 603427  
Title: A formal method for provably correct composition of a real-life processor out of basic components
Author: Egon B orger Giuseppe Del Castillo 
Address: Corso Italia 40 56125 Pisa, Italy  FB17 Informatik Warburger Str. 100 33095 Paderborn, Germany  
Affiliation: Dipartimento di Informatica Universita di Pisa  Universitat Paderborn  
Abstract: We present a design approach which allows us to formally specify a real-life processor as composed out of its basic architectural (formally specified) components. The methodology provides means to rely upon hierarchical refinements and modular structuring of the specifications as a discipline to control the behaviour of complex units in terms of the behaviour of their components. In particular this enables us to prove interesting dynamic properties about the processor in terms of properties of its basic architectural components. The method makes use of Gurevich's concept of evolving algebra. We have developed the method to accomplish a reverse engineering project for the VLSI implemented microprocessor zCPU, the controller of the successful APE100 massively parallel machine.
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> The APE100 Collaboration, APE100 Primer , INFN, A100/PRIM/G02. </institution>
Reference-contexts: Mini-Course", Technical Report BRICS-NS-95-4, BRICS, University of Aarhus, July 1995. An abridged version of this paper is in the Proceedings of the First IEEE International Conference on Engineering of Complex Computer Systems (ICECCS'95). 1 characteristic part of the advanced software environment of APE100, see <ref> [1] </ref>). The ground model APESE has been defined in [7]; it reflects the APE100 model of parallel execution as viewed by the user who approaches the machine as programmer in the high level parallel programming language Apese, a parallel Fortran like user expandable language especially designed for APE100. <p> (ALU/Multiply/Divide) math code = DECODE:MAC 2 op 1 = RF:OutPort1 op 2 = RF:OutPort2 carry in = CC&STATUS:carry out extend in = CC&STATUS:extend out zero in = CC&STATUS:zero out mul in = DECODE:MulIn start div = DECODE:StartDiv md mux = DECODE:MDMux add mul = DECODE:AddMul where CC&STATUS:carry out CC&STATUS:status register <ref> [1] </ref> CC&STATUS:extend out CC&STATUS:status register [21] CC&STATUS:zero out CC&STATUS:status register [25] 21 C.3 Unit CC&STATUS (Condition Codes & Status Register) carry in = ALU:carry out divz in = ALU:divz out neg in = ALU:neg out overflow in = ALU:overflow out extend in = ALU:extend out zero in = ALU:zero out if <p> AGU:DMA val from mem = DATAMEM:data out C.9 Unit EVALCOND (Evaluation of Branch Conditions) which cond = INSTR:R1 carry in = CC&STATUS:carry out if status in = CC&STATUS:if status out neg in = CC&STATUS:neg out overflow in = CC&STATUS:overflow out zero in = CC&STATUS:zero out where CC&STATUS:carry out CC&STATUS:status register <ref> [1] </ref> CC&STATUS:if status out CC&STATUS:status register [9] CC&STATUS:neg out CC&STATUS:status register [13] CC&STATUS:overflow out CC&STATUS:status register [17] CC&STATUS:zero out CC&STATUS:status register [25] C.10 Unit DECODE (Instruction Decoding) math code = INSTR:MAC io code = INSTR:IOC yes no = EVALCOND:yes no C.11 Registers DECODE:WER 2 :in = DECODE:WER INSTR:RR 2 :in =
Reference: [2] <author> The APE100 Collaboration, </author> <title> zCPU User Guide, </title> <publisher> INFN, A100/ZCPU/G01. </publisher>
Reference-contexts: We concentrate our attention here on the VLSI superscalar integer processor zCPU which acts as controller for APE100 and represents the most original part of the project (including the pipelining and VLIW parallelism for the execution of compiled ZIC code; see <ref> [2] </ref> for technical details of the zCPU).
Reference: [3] <author> A. Bartoloni et al., </author> <title> A Hardware Implementation of the APE100 Architecture, in: </title> <journal> International Journal of Modern Physics, </journal> <note> C 4 (1993), p. 969. </note>
Reference-contexts: Introduction The APE100 massively parallel processor has been built as a dedicated machine for floating point intensive scientific applications and has proved to be rather successful for numerical simulations in Lattice Gauge Theory (see <ref> [3, 4] </ref>). As preparation for a possible upgrade to a new APE1000 machine (see [5]) we have accepted the challenging reverse engineering task to construct formal models for the architecture in such a way that the upgrading process can be guided by these models. <p> See below the "write cc math" rule. update mask (val) Msk Carry : = val <ref> [3] </ref> Msk Divz : = val [7] Msk iFstatus : = val [11] Msk Neg : = val [15] Msk oVerflow : = val [19] Msk eXtend : = val [23] Msk Zero : = val [27] Definitions: status register = Ex Parity : ParityErr : Ex Halt : Halt : <p> 3 + Disp delay DMA DMA 2 : = DMA write mem if MemWE then mem (DMA) : = val to store read mem Dat : = mem (DMA) write mask if WrMask 2 then update mask (val to load ) where update mask (val) Msk Carry : = val <ref> [3] </ref> Msk Divz : = val [7] Msk iFstatus : = val [11] Msk Neg : = val [15] Msk oVerflow : = val [19] Msk eXtend : = val [23] Msk Zero : = val [27] 27
Reference: [4] <author> A. Bartoloni et al., </author> <title> The Software of the APE100 Processor , in: </title> <journal> International Journal of Modern Physics, </journal> <note> C 4 (1993), p. 955. </note>
Reference-contexts: Introduction The APE100 massively parallel processor has been built as a dedicated machine for floating point intensive scientific applications and has proved to be rather successful for numerical simulations in Lattice Gauge Theory (see <ref> [3, 4] </ref>). As preparation for a possible upgrade to a new APE1000 machine (see [5]) we have accepted the challenging reverse engineering task to construct formal models for the architecture in such a way that the upgrading process can be guided by these models.
Reference: [5] <author> A. Bartoloni et al., APEmille: </author> <title> A Parallel Processor in the Teraflops Range, </title> <type> manuscript, </type> <year> 1995. </year>
Reference-contexts: Introduction The APE100 massively parallel processor has been built as a dedicated machine for floating point intensive scientific applications and has proved to be rather successful for numerical simulations in Lattice Gauge Theory (see [3, 4]). As preparation for a possible upgrade to a new APE1000 machine (see <ref> [5] </ref>) we have accepted the challenging reverse engineering task to construct formal models for the architecture in such a way that the upgrading process can be guided by these models.
Reference: [6] <author> G. Bastianello et al., </author> <title> A high performance single chip processing unit for parallel processing and data acquisition systems, in: Nuclear Instruments and Methods in Physics Research, </title> <note> A324 (1993), p. 543. </note>
Reference-contexts: 5 g write enable 5 ) addr 5 62 f addr 1 ; addr 2 ; addr 3 g write enable 4 ^ write enable 5 ) addr 4 6= addr 5 : 2 We denote internal registers by capital initial letters and try to adhere to the terminology of <ref> [6] </ref>. The reader should not confuse the general registers of the register file and the internal registers of the zCPU. <p> In this way we have obtained the following unit (arithmetic subunit) which suffices to compute the result of simple arithmetic instructions, such as the addition instruction ADD, as we show in the next section. Note that this unit formalizes a portion of the zCPU block diagram in <ref> [6] </ref>.
Reference: [7] <author> E. Borger, G. Del Castillo, P. Glavan, D. Rosenzweig, </author> <title> Towards a mathematical specification of the APE100 architecture: the APESE model , in: </title> <editor> B. Pehrson and I. Simon (Eds.), </editor> <booktitle> IFIP 13th World Computer Congress 1994 , Volume I: </booktitle> <address> Technology/Foundations, </address> <publisher> Elsevier, Amsterdam, </publisher> <pages> 396-401. </pages>
Reference-contexts: An abridged version of this paper is in the Proceedings of the First IEEE International Conference on Engineering of Complex Computer Systems (ICECCS'95). 1 characteristic part of the advanced software environment of APE100, see [1]). The ground model APESE has been defined in <ref> [7] </ref>; it reflects the APE100 model of parallel execution as viewed by the user who approaches the machine as programmer in the high level parallel programming language Apese, a parallel Fortran like user expandable language especially designed for APE100. <p> then reg (RR) : = reg (R1 ) + reg (R2 ): This rule is part of the evolving algebra ZIC defined in [13], which models APE100 as interpreter of ZCPU Intermediate Code (and which can easily be shown to implement correctly the APESE ground model for APE100 presented in <ref> [7] </ref>). <p> See below the "write cc math" rule. update mask (val) Msk Carry : = val [3] Msk Divz : = val <ref> [7] </ref> Msk iFstatus : = val [11] Msk Neg : = val [15] Msk oVerflow : = val [19] Msk eXtend : = val [23] Msk Zero : = val [27] Definitions: status register = Ex Parity : ParityErr : Ex Halt : Halt : Msk Zero : Ex Zero : <p> 2 : = DMA write mem if MemWE then mem (DMA) : = val to store read mem Dat : = mem (DMA) write mask if WrMask 2 then update mask (val to load ) where update mask (val) Msk Carry : = val [3] Msk Divz : = val <ref> [7] </ref> Msk iFstatus : = val [11] Msk Neg : = val [15] Msk oVerflow : = val [19] Msk eXtend : = val [23] Msk Zero : = val [27] 27
Reference: [8] <author> E. Borger, I. Durdanovic, </author> <title> Correctness of Compiling Occam to Transputer Code, </title> <month> March </month> <year> 1995. </year>
Reference-contexts: Defining the components as evolving algebras (in the sense of Gurevich [14]) to which we add entries and exits allows us to adopt also the evolving algebra refinement techniques which have been used successfully to formally specify and prove properties of complex systems (see for ex. <ref> [11, 8, 9] </ref>). In section 3 we explain how for the formal model LEX of the zCPU processor we can make the following informal statement into a precise mathematical assertion and give a mathematical proof for it. Main Theorem.
Reference: [9] <author> E. Borger, U. Glasser, W. Muller, </author> <title> Formal Definition of an Abstract VHDL'93 Simulator by EA-Machines, </title> <editor> in: Carlos Delgado Kloos and Peter T. Breuer (Eds.), </editor> <booktitle> Formal Semantics for VHDL, </booktitle> <pages> pp. 107-139, </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: Defining the components as evolving algebras (in the sense of Gurevich [14]) to which we add entries and exits allows us to adopt also the evolving algebra refinement techniques which have been used successfully to formally specify and prove properties of complex systems (see for ex. <ref> [11, 8, 9] </ref>). In section 3 we explain how for the formal model LEX of the zCPU processor we can make the following informal statement into a precise mathematical assertion and give a mathematical proof for it. Main Theorem. <p> out C.9 Unit EVALCOND (Evaluation of Branch Conditions) which cond = INSTR:R1 carry in = CC&STATUS:carry out if status in = CC&STATUS:if status out neg in = CC&STATUS:neg out overflow in = CC&STATUS:overflow out zero in = CC&STATUS:zero out where CC&STATUS:carry out CC&STATUS:status register [1] CC&STATUS:if status out CC&STATUS:status register <ref> [9] </ref> CC&STATUS:neg out CC&STATUS:status register [13] CC&STATUS:overflow out CC&STATUS:status register [17] CC&STATUS:zero out CC&STATUS:status register [25] C.10 Unit DECODE (Instruction Decoding) math code = INSTR:MAC io code = INSTR:IOC yes no = EVALCOND:yes no C.11 Registers DECODE:WER 2 :in = DECODE:WER INSTR:RR 2 :in = INSTR:RR DECODE:WED 2 :in = DECODE:WED
Reference: [10] <author> E. Borger, S. Mazzanti, </author> <title> A correctness proof for pipelining in RISC architectures (manuscript). </title>
Reference-contexts: Note also that the case of zCPU and of APE100 reverse engineering is not restrictive. Our methodology can be applied to other processors as well. Se for ex. <ref> [10] </ref> where the evolving algebra methodology is used to prove the correctness of general pipelining principles for RISC architectures.
Reference: [11] <author> E. Borger, D. Rosenzweig, </author> <title> The WAM Definition and Compiler Correctness, in: Logic Programming: Formal Methods and Practical Applications (C.Beierle, </title> <editor> L.Plumer, Eds.), </editor> <booktitle> Elsevier Science B.V./North-Holland, Series in Computer Science and Artificial Intelligence, </booktitle> <year> 1995, </year> <pages> pp. 20-90 (chapter 2). </pages>
Reference-contexts: Defining the components as evolving algebras (in the sense of Gurevich [14]) to which we add entries and exits allows us to adopt also the evolving algebra refinement techniques which have been used successfully to formally specify and prove properties of complex systems (see for ex. <ref> [11, 8, 9] </ref>). In section 3 we explain how for the formal model LEX of the zCPU processor we can make the following informal statement into a precise mathematical assertion and give a mathematical proof for it. Main Theorem. <p> See below the "write cc math" rule. update mask (val) Msk Carry : = val [3] Msk Divz : = val [7] Msk iFstatus : = val <ref> [11] </ref> Msk Neg : = val [15] Msk oVerflow : = val [19] Msk eXtend : = val [23] Msk Zero : = val [27] Definitions: status register = Ex Parity : ParityErr : Ex Halt : Halt : Msk Zero : Ex Zero : Zero : 0 : Msk eXtend <p> if MemWE then mem (DMA) : = val to store read mem Dat : = mem (DMA) write mask if WrMask 2 then update mask (val to load ) where update mask (val) Msk Carry : = val [3] Msk Divz : = val [7] Msk iFstatus : = val <ref> [11] </ref> Msk Neg : = val [15] Msk oVerflow : = val [19] Msk eXtend : = val [23] Msk Zero : = val [27] 27
Reference: [12] <author> A. Bruggemann, L. Priese, D. Rodding, R. Schatz, </author> <title> Modular decomposition of automata, in: </title> <publisher> Springer LNCS 171, </publisher> <year> 1984, </year> <pages> 198-236. </pages>
Reference-contexts: In section 2 we define a method by which given units can be composed in a precise way to complex units. Using well known techniques &gt;from the literature (see <ref> [12] </ref>) the composition can be done in a modular way. This greatly simplifies the task to prove properties of complex units in terms of properties of their simpler constituents. <p> In doing this, we use the natural pictorial representation of evolving algebras with entries and exits as boxes with ingoing and outgoing arrows. Composing units then means to connect outgoing with ingoing arrows. In this paper we can only refer to the literature (see for example <ref> [12] </ref>), where it is shown how the resulting notion of computation of a "composed" unit can be defined rigorously in terms of the notion of computation of the components.
Reference: [13] <author> G. </author> <type> Del Castillo, </type> <institution> Descrizione matematica dell'architettura parallela APE100 , Tesi di Laurea (in Italian), Universita di Pisa, Pisa, </institution> <year> 1995. </year>
Reference-contexts: the major steps for an example; we choose the addition instruction ([ADD RR R1 R2 ]), whose execution is defined by the rule if MAC = ADD then reg (RR) : = reg (R1 ) + reg (R2 ): This rule is part of the evolving algebra ZIC defined in <ref> [13] </ref>, which models APE100 as interpreter of ZCPU Intermediate Code (and which can easily be shown to implement correctly the APESE ground model for APE100 presented in [7]). <p> Conclusion We have shown on an example how to prove that the hardware level model LEX of the APE100 control processor zCPU executes compiled programs correctly if the compiler satisfies the assumptions which are realized by the APE100 compilation chain. Along these lines <ref> [13] </ref> has developed the specification of the zCPU processor which is the basis for the complete correctness proof, which we have to leave for a sequel to this paper. In the appendix we list the complete formal definition of the zCPU, without further explanation. <p> Therefore, the value of RR has to be taken during the second pipe stage | this is assured in APE100 by the compiler. In <ref> [13] </ref> the model is developed with all the details which are needed to describe exactly the behaviour of the zCPU on the basis of the APE100 compilation scheme. 10 Appendices In the following four appendices we list with only a few more explanations the full abstract definition of the zCPU processor. <p> of Branch Conditions) which cond = INSTR:R1 carry in = CC&STATUS:carry out if status in = CC&STATUS:if status out neg in = CC&STATUS:neg out overflow in = CC&STATUS:overflow out zero in = CC&STATUS:zero out where CC&STATUS:carry out CC&STATUS:status register [1] CC&STATUS:if status out CC&STATUS:status register [9] CC&STATUS:neg out CC&STATUS:status register <ref> [13] </ref> CC&STATUS:overflow out CC&STATUS:status register [17] CC&STATUS:zero out CC&STATUS:status register [25] C.10 Unit DECODE (Instruction Decoding) math code = INSTR:MAC io code = INSTR:IOC yes no = EVALCOND:yes no C.11 Registers DECODE:WER 2 :in = DECODE:WER INSTR:RR 2 :in = INSTR:RR DECODE:WED 2 :in = DECODE:WED INSTR:RD 2 :in = INSTR:RD <p> It is obtained by combining the units of Appendix A, performing the substitutions corresponding to the equations listed in Appendix C and to the equations defining the exits of the different units. For further explanations see <ref> [13] </ref>. Note that the zCPU itself can be seen as a unit, with its own entries and exits.
Reference: [14] <author> Y. Gurevich, </author> <title> Evolving Algebras 1993: Lipari Guide, in: Specification and Validation Methods, </title> <editor> Ed. E. Borger, </editor> <publisher> Oxford University Press, </publisher> <year> 1995. </year> <month> 28 </month>
Reference-contexts: Using well known techniques &gt;from the literature (see [12]) the composition can be done in a modular way. This greatly simplifies the task to prove properties of complex units in terms of properties of their simpler constituents. Defining the components as evolving algebras (in the sense of Gurevich <ref> [14] </ref>) to which we add entries and exits allows us to adopt also the evolving algebra refinement techniques which have been used successfully to formally specify and prove properties of complex systems (see for ex. [11, 8, 9]). <p> This explains also why we do not give here a formal definition of the underlying semantics of evolving algebras (which however has been rigorously defined in <ref> [14] </ref>); our specifications can be read and understood as abstract code which can serve as basis for the implementation of executable prototypes. 1 The Datapath Components of the zCPU The zCPU processor is built out of several main units, namely: * the register file RF; * the ALU MPY DIV unit <p> Each unit is specified as an evolving algebra (in the sense of <ref> [14] </ref>) with entries and exits. The latter are vehicles for an explicit description of a desired input/output behaviour. This behaviour is defined by finitely many rules of the evolving algebra and possibly some conditions on the functions which appear in the rules. <p> update f (t 1 ; : : : ; t n ) : = t are called external: they represent the environment for the evolving algebra. 3 in each step each rule which can be applied is applied. (For an exact definition of this lock-step semantics of evolving algebras see <ref> [14] </ref>). The entries and exits can be viewed as terms, which include 0-ary functions. As an experiment we will use in this paper essentially only 0-ary functions for entries and exits. Each function can be constrained by conditions, which can serve various purposes. <p> The second step in the proof of the proposition introduces the parallelism due to pipelining. The rules of ZIC PH are modified in such a way that no conflict arises when they are executed not any more sequentially, but in parallel (using the lock-step semantics of evolving algebras, see <ref> [14] </ref>), leading to the model LEX ("loadable executable code", the final level in the APE100 compilation chain). A rigorous formulation and a transparent proof can be given for the following statement. Lemma 2.
References-found: 14

