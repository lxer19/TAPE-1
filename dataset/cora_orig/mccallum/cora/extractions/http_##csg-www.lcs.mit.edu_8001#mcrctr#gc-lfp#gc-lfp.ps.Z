URL: http://csg-www.lcs.mit.edu:8001/mcrctr/gc-lfp/gc-lfp.ps.Z
Refering-URL: http://csg-www.lcs.mit.edu:8001/mcrctr/
Root-URL: 
Email: fshail,chfg@lcs.mit.edu  jamey@mcrc.mot.com  
Title: Garbage Collection for Strongly-Typed Languages using Run-time Type Reconstruction  
Author: Shail Aditya Christine H. Flood James E. Hicks 
Affiliation: MIT Laboratory for Computer Science  Motorola Cambridge Research Center  
Abstract: Garbage collectors perform two functions: live-object detection and dead-object reclamation. In this paper, we present a new technique for live-object detection based on run-time type reconstruction for a strongly-typed, polymorphic language. This scheme uses compile-time type information together with the run-time tree of activation frames to determine the exact type of every object participating in the computation. These reconstructed types are then used to identify and traverse the live heap objects during garbage collection. We describe an implementation of our scheme for the Id parallel programming language compiled for the *T multiprocessor architecture. We present simulation studies that compare the performance of type-reconstructing garbage collection with conservative garbage collection and compiler-directed storage reclamation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Shail Aditya and Alejandro Caro. </author> <title> Compiler-directed Type Reconstruction for Polymorphic Languages. </title> <booktitle> In Proceedings of the ACM Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pages 74-82, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Conventional techniques for object identification [3, 5] operate with a very simple memory model and make little or no use of language and compiler-specific information. In this paper, we present a new technique for object identification based on run-time "type reconstruction" for polymorphic languages <ref> [1] </ref>. Our scheme bridges the gap between the compiler and the garbage collector by using compiler-generated, polymorphic type information and the dynamic call tree of activation frames to compute the exact run-time types of all objects. <p> This framework serves as a general paradigm for cooperation between the compiler and the run-time system. We have already used this mechanism successfully within the Id debugger for the Monsoon machine for displaying arbitrary Id objects <ref> [1] </ref>. 1.2 Related Work Conservative and tagged mechanisms have been used extensively in various garbage collection systems (see [15] for a recent survey), but object identification based on type reconstruction for strongly-typed, polymorphic languages is a relatively new idea. <p> On the other hand, our object identification scheme is based on a complete run-time type reconstruction mechanism which ensures that the exact types of all objects are reconstructed even if those objects are created or embedded within polymorphic functions <ref> [1] </ref>. Our work also relates to compiler-directed storage reclamation shown by Hicks [9] since that scheme also manages dynamic storage in the context of a strongly-typed, polymorphic language without any run-time type-tags. <p> When the garbage collector is invoked at run-time, first we reconstruct the type of every activation frame present within the current dynamic call tree. The reconstruction mechanism instantiates the compile-time type description of each activation frame to its exact run-time type using the algorithm described in <ref> [1] </ref> (Section 3.2). 3. During the mark phase of the garbage collector, the reconstructed frame-slot types are used to mark the reachable heap objects as live. <p> One typemap datatype is defined for each function definition in the program as shown in Figure 4. The typemap of a function captures all the necessary compile-time information to reconstruct the complete type of its activation frame at run-time using the mechanism described in <ref> [1] </ref>. The typemap of a function is parameterized by the type-variables present in the function's type signature. The type-map records the function's signature, the types of its arguments and its bound identifiers, and the compile-time type-instances of all function application sites within the body of the given function. <p> In the preceding section, we described the compiler support necessary to facilitate run-time type reconstruction. In this section, we describe the run-time data-structures and the reconstruction algorithm. A more detailed description of the algorithm may be found in <ref> [1] </ref>. 3.2.1 Run-Time Type Encodings Run-time type reconstruction requires an encoding of the datatypes that may be computed and instantiated during reconstruction. <p> type from the parent's typemap is matched against the current function's type signature to determine the exact type-instances of its polymorphic type parameters. 4 This is because the exact run-time type of an object with a closed polymorphic type (e.g., nil :: 8ff:(list ff)) is that polymorphic type itself, see <ref> [1] </ref> for details. This instantiates the typemap of the current function which can then be used to traverse its activation frame. Note that the entire typemap for an activation frame is instantiated at once and is remembered subsequently. <p> In the above example, our reconstruction mechanism encodes the hidden type instantiation explicitly at the first application site and passes it to the eqlen function as an additional parameter <ref> [1] </ref>. This encoded type-hint is directly used to reconstruct the invisible type of the closure f and to instantiate eqlen's typemap.
Reference: [2] <author> Andrew W. Appel. </author> <title> Runtime tags aren't necessary. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2(2) </volume> <pages> 153-163, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: The basic concept for type reconstruction was suggested by Appel <ref> [2] </ref> and expanded by Goldberg and Gloger [6, 7]. These schemes were sometimes unable to compute the exact run-time type of objects embedded inside polymorphic functions. Traversal and marking of such live objects without complete type information remained a problem.
Reference: [3] <author> Andrew W. Appel. </author> <title> A runtime system. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(4) </volume> <pages> 343-380, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: For live-object detection, the garbage collector must be able to distinguish scalar objects from heap objects and determine their sizes (object identification). Conventional techniques for object identification <ref> [3, 5] </ref> operate with a very simple memory model and make little or no use of language and compiler-specific information. In this paper, we present a new technique for object identification based on run-time "type reconstruction" for polymorphic languages [1]. <p> Also, heap objects have headers that identify their type and size. Keeping tag bits in every word reduces the range of representable scalars and pointers in conventional architectures, and the user application also pays the additional cost of tag maintenance. In some systems such as SML <ref> [3] </ref>, scalar values (usually floating point numbers) are boxed in a heap data-structure to preserve their full range. This incurs the additional cost of allocating the box and accessing it indirectly.
Reference: [4] <author> Zena M. Ariola and Arvind. </author> <title> A syntactic approach to program transformations. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics Based Program Manipulation, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: We also assume a rich set of primitive functions for basetypes and array construction/selection, as well as standard predefined algebraic datatypes such as list and bool. The operational semantics of this language has been given elsewhere in terms of graph rewriting rules <ref> [4] </ref>. The Id source language supports special syntactic constructs such as list and array comprehensions, complex pattern matching, and nested function and type declarations [11]. <p> The Id source program is translated into a Kernel Id program using standard front-end analyses and transformations such as comprehension-desugaring, scope-analysis, type-checking, pattern-matching compilation, and lambda-lifting <ref> [4, 8, 14] </ref>. The lambda-lifting transformation is not essential for the purpose of this paper, but it helps to simplify our description of the Kernel Id language.
Reference: [5] <author> H.-J. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software: Practice and Experience, </journal> <volume> 18 </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: For live-object detection, the garbage collector must be able to distinguish scalar objects from heap objects and determine their sizes (object identification). Conventional techniques for object identification <ref> [3, 5] </ref> operate with a very simple memory model and make little or no use of language and compiler-specific information. In this paper, we present a new technique for object identification based on run-time "type reconstruction" for polymorphic languages [1]. <p> These exact type are then used by the garbage collector to identify and traverse the live objects residing on the heap. We describe our implementation and compare its performance with other storage management schemes, including a conservative garbage collector that does not use any type information <ref> [5] </ref> and a compiler-directed storage reclamation scheme that explicitly deallocates objects based on static life-time analysis [9]. 1.1 Motivation A common technique for object identification is to tag every object: a few bits (usually one or two) in every word are used as a tag to distinguish scalar objects from pointers <p> The type-reconstruction of a frame may be overlapped with marking of objects in another frame, so the overall cost of type-reconstructed marking is a combination of the two. 4.3.2 Conservative Garbage Collection The mark phase of the Conservative Garbage Collection (CGC) <ref> [5] </ref> requires no source type information. Conservative garbage collectors use a simple, conservative test to determine whether a value in a frame or a heap object is a pointer to another object.
Reference: [6] <author> Benjamin Goldberg. </author> <title> Tag-free garbage collection for strongly typed programming languages. </title> <booktitle> In SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 165-176, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The basic concept for type reconstruction was suggested by Appel [2] and expanded by Goldberg and Gloger <ref> [6, 7] </ref>. These schemes were sometimes unable to compute the exact run-time type of objects embedded inside polymorphic functions. Traversal and marking of such live objects without complete type information remained a problem.
Reference: [7] <author> Benjamin Goldberg and Michael Gloger. </author> <title> Polymorphic Type Reconstruction for Garbage Collection without Tags. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 53-65, </pages> <year> 1992. </year>
Reference-contexts: The basic concept for type reconstruction was suggested by Appel [2] and expanded by Goldberg and Gloger <ref> [6, 7] </ref>. These schemes were sometimes unable to compute the exact run-time type of objects embedded inside polymorphic functions. Traversal and marking of such live objects without complete type information remained a problem. <p> Without this information, the exact type of the elements of the list hidden inside the closure f can not be reconstructed. In such a situation, Goldberg and Gloger <ref> [7] </ref> argue that since those elements are never accessed by the function eqlen, they need not be traversed and marked as live. Only the spine of the list is marked as live. <p> Only the spine of the list is marked as live. Unfortunately, if this list is shared among other activation frames its elements may still be live and may not be garbage collected. Managing partially marked, shared objects is a difficult and unsolved problem <ref> [7] </ref>. Instead, our scheme guarantees full type reconstruction at every object reference so that an object can be marked completely the first time around.
Reference: [8] <author> Shail Aditya Gupta. </author> <title> An Incremental Type Inference System for the Programming Language Id. </title> <type> Master's thesis, </type> <institution> MIT, Laboratory for Computer Science, </institution> <note> Septem-ber 1990. Available as Technical Report MIT/LCS/TR-488. </note>
Reference-contexts: The Id source program is translated into a Kernel Id program using standard front-end analyses and transformations such as comprehension-desugaring, scope-analysis, type-checking, pattern-matching compilation, and lambda-lifting <ref> [4, 8, 14] </ref>. The lambda-lifting transformation is not essential for the purpose of this paper, but it helps to simplify our description of the Kernel Id language.
Reference: [9] <author> James E. Hicks. </author> <title> Experiences with compiler-directed storage reclamation. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architecture, </booktitle> <year> 1993. </year>
Reference-contexts: We describe our implementation and compare its performance with other storage management schemes, including a conservative garbage collector that does not use any type information [5] and a compiler-directed storage reclamation scheme that explicitly deallocates objects based on static life-time analysis <ref> [9] </ref>. 1.1 Motivation A common technique for object identification is to tag every object: a few bits (usually one or two) in every word are used as a tag to distinguish scalar objects from pointers to heap objects. Also, heap objects have headers that identify their type and size. <p> Our work also relates to compiler-directed storage reclamation shown by Hicks <ref> [9] </ref> since that scheme also manages dynamic storage in the context of a strongly-typed, polymorphic language without any run-time type-tags. In that scheme, the compiler performs life-time analysis of objects and automatically inserts explicit deallocation calls at appropriate places in the program. <p> However, the test is guaranteed to mark only actual heap objects. 4.3.3 Compiler-Directed Storage Reclamation For comparison purposes, we have also implemented the explicit, compiler-directed storage reclamation scheme (CDSR) <ref> [9] </ref> within the same compiler and run-time system framework. In this scheme, no separate garbage collection needs to be performed: the compiler inserts code to deallocate an object when it can determine the object to be garbage.
Reference: [10] <author> Harry G. Mairson. </author> <title> Deciding ML Typability is Complete for Deterministic Exponential Time. </title> <booktitle> In Proceedings of the 17th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 382-401, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: These functions are appropriately composed at run-time using the reconstructed types and then directly applied to the corresponding objects. 5 Each reconstruction step manipulates Hindley/Milner types of the original program which in the worst case could be very large <ref> [10] </ref>, but such cases rarely occur in practice. Marking Schema M Given a Type T n , define M [[T n ]] = mark T , where 1. T 0 is a BaseType (int j float): def mark T () = x:() 2.
Reference: [11] <author> Rishiyur S. Nikhil. </author> <title> Id 90.1 reference manual. </title> <type> CSG Memo 284-2, </type> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA 02139, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Our source language is Id, which is a polymorphic, strongly-typed, implicitly parallel programming language <ref> [11] </ref>. We are compiling Id for the *T multiprocessor architecture [12] and executing it on an emulator for that machine. We have chosen a very simple mark-and-sweep garbage collection algorithm so that the cost of object identification can be clearly identified during the mark phase. <p> The operational semantics of this language has been given elsewhere in terms of graph rewriting rules [4]. The Id source language supports special syntactic constructs such as list and array comprehensions, complex pattern matching, and nested function and type declarations <ref> [11] </ref>. The Id source program is translated into a Kernel Id program using standard front-end analyses and transformations such as comprehension-desugaring, scope-analysis, type-checking, pattern-matching compilation, and lambda-lifting [4, 8, 14].
Reference: [12] <author> G. M. Papadopoulos, G. A. Boughton, R. Greiner, and M. J. Beckerle. </author> <title> *T: Integrated building blocks for parallel computing. </title> <booktitle> In Proceedings of Supercomputing '93, </booktitle> <year> 1993. </year>
Reference-contexts: Our source language is Id, which is a polymorphic, strongly-typed, implicitly parallel programming language [11]. We are compiling Id for the *T multiprocessor architecture <ref> [12] </ref> and executing it on an emulator for that machine. We have chosen a very simple mark-and-sweep garbage collection algorithm so that the cost of object identification can be clearly identified during the mark phase. <p> The resulting function composition may be directly executed to mark all objects reachable from the activation frame. The compiled marking schema is currently unimplemented. 4 Implementation of Id on *T *T is a parallel, distributed-memory machine <ref> [12] </ref>. The *T architecture extends a basic RISC instruction set with low-overhead, user-mode communication and synchronization primitives. In this paper, we use a simulator for a machine based on the 88110MP processor. The 88110MP is Motorola's superscalar RISC processor extended with an on-chip message and synchronization unit (MSU).
Reference: [13] <author> Simon L. PeytonJones. </author> <title> Implementing lazy functional languages on stock hardware: </title> <journal> the Spineless Tag-less G-machine. Journal of Functional Programming, </journal> <volume> 2(2) </volume> <pages> 127-202, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: If the semantics of a language necessitates a tagged or boxed representation for objects, or if special hardware support for tags is available, then run-time type reconstruction is probably not the right choice. For example, in the implementation of lazy languages such as Haskell <ref> [13] </ref>, all objects need to be boxed into closures unless they are known to contribute towards the final result. These closures can easily identify themselves via their code pointers.
Reference: [14] <author> Kenneth R. Traub. </author> <title> A compiler for the MIT Tagged-Token Dataflow Architecture. </title> <type> Technical Report TR-370, </type> <institution> MIT Laboratory for Computer Science, </institution> <address> Cam-bridge, MA 02139, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: The Id source program is translated into a Kernel Id program using standard front-end analyses and transformations such as comprehension-desugaring, scope-analysis, type-checking, pattern-matching compilation, and lambda-lifting <ref> [4, 8, 14] </ref>. The lambda-lifting transformation is not essential for the purpose of this paper, but it helps to simplify our description of the Kernel Id language.
Reference: [15] <author> Paul R. Wilson. </author> <title> Uniprocessor Garbage Collection Techniques. </title> <booktitle> In Proceedings of the International Workshop on Memory Management, </booktitle> <address> St. Malo, France, </address> <pages> pages 1-42. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year> <note> LNCS 637. </note>
Reference-contexts: We have already used this mechanism successfully within the Id debugger for the Monsoon machine for displaying arbitrary Id objects [1]. 1.2 Related Work Conservative and tagged mechanisms have been used extensively in various garbage collection systems (see <ref> [15] </ref> for a recent survey), but object identification based on type reconstruction for strongly-typed, polymorphic languages is a relatively new idea. The basic concept for type reconstruction was suggested by Appel [2] and expanded by Goldberg and Gloger [6, 7].
References-found: 15

