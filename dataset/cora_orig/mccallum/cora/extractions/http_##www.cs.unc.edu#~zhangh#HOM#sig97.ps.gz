URL: http://www.cs.unc.edu/~zhangh/HOM/sig97.ps.gz
Refering-URL: http://www.cs.unc.edu/~zhangh/research.html
Root-URL: http://www.cs.unc.edu
Email: fzhangh,dm,hudson,hoffg@cs.unc.edu  
Title: Visibility Culling using Hierarchical Occlusion Maps  
Author: Hansong Zhang Dinesh Manocha Tom Hudson Kenneth E. Hoff III 
Web: http://www.cs.unc.edu/fzhangh,dm,hudson,hoffg  
Address: Chapel Hill, NC 27599-3175  
Affiliation: Department of Computer Science University of North Carolina  
Abstract: We present hierarchical occlusion maps (HOM) for visibility culling on complex models with high depth complexity. The culling algorithm uses an object space bounding volume hierarchy and a hierarchy of image space occlusion maps. Occlusion maps represent the aggregate of projections of the occluders onto the image plane. For each frame, the algorithm selects a small set of objects from the model as occluders and renders them to form an initial occlusion map, from which a hierarchy of occlusion maps is built. The occlusion maps are used to cull away a portion of the model not visible from the current viewpoint. The algorithm is applicable to all models and makes no assumptions about the size, shape, or type of occluders. It supports approximate culling in which small holes in or among occluders can be ignored. The algorithm has been implemented on current graphics systems and has been applied to large models composed of hundreds of thousands of polygons. In practice, it achieves significant speedup in interactive walkthroughs of models with high depth complexity. CR Categories and Subject Descriptors: I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling Key Words and Phrases: visibility culling, interactive display, image pyramid, occlusion culling, hierarchical data structures 
Abstract-found: 1
Intro-found: 1
Reference: [ARB90] <author> J. Airey, J. Rohlf, and F. Brooks. </author> <title> Towardsimage realism with interactive update rates in complex virtual building environments. </title> <booktitle> In Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 41-50, </pages> <year> 1990. </year>
Reference-contexts: Many algorithms structure the model database into cells or regions, and use a combination of off-line and on-line algorithms for cell-to-cell visibility and the conservative computation of the potentially visible set (PVS) of primitives <ref> [ARB90, TS91, LG95] </ref>. Such approaches have been successfully used to visualize architectural models, where the division of a building into discrete rooms lends itself to a natural division of the database into cells. It is not apparent that cell-based approaches can be generalized to an arbitrary model. <p> If a model under some the viewing conditions does not have sufficient occlusion, the overall frame rate may decrease due to the overhead, in which case occlusion culling should be turned off. 7.1 Comparison to Object Space Algorithms Work on cells and portals <ref> [ARB90, TS91, LG95] </ref> addresses a special class of densely occluded environments where there are plenty 8 different models. The total time to render each model without HOM culling is normalized to 100%. <p> The total time to render each model without HOM culling is normalized to 100%. Each bar shows the percentage of time spent in different stages of our algorithm. of cell and portal structures, as in an indoor architectural model. <ref> [ARB90, TS91] </ref> pre-processes the model to identify potentially visible set of primitives for each cell. [LG95] developed a dynamic version which eliminates the visibility pre-processing. These methods work very well for this particular type of environment, but are not applicable to models without cell/portal structures.
Reference: [BM96] <author> D. Blythe and T. McReynolds. </author> <title> Programming with Opengl: Advanced course. </title> <booktitle> Siggraph'96 Course Notes, </booktitle> <year> 1996. </year>
Reference-contexts: In such cases, the use of texture mapping hardware may slow down the computation of occlusion maps rather than accelerate it, and hierarchy building is faster on the host CPU. The break-even point between hardware and software hierarchy construction varies with different graphics systems. <ref> [BM96] </ref> presents a technique for generating mipmaps by using a hardware accumulation buffer.
Reference: [Bun89] <author> M. Bunker and R. </author> <title> Economy. Evolution of GE CIG Systems, SCSD document, General Electric Company, </title> <address> Daytona Beach, FL, </address> <year> 1989 </year>
Reference-contexts: General Electric's COMPU-SCENE PT2000 <ref> [Bun89] </ref> uses a similar algorithm but does not require the input polygons to be in front-to-back order and the mask buffer is not hierarchical. The Loral GT200 [LORA] first renders near objects and fills in a mask buffer, which is used to cull away far objects.
Reference: [Car84] <author> L. Carpenter. </author> <title> The A-buffer, an antialiased hiddensurface method. </title> <booktitle> Proc. of ACM Siggraph, </booktitle> <pages> pages 103-108, </pages> <year> 1984. </year>
Reference: [Cat74] <author> E. Catmull. </author> <title> A subdivision algorithm for computer display of curved surfaces. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <year> 1974. </year>
Reference-contexts: Section 7 analyses our algorithm and compares it with other approaches. Finally, in Section 8, we briefly describe some future directions. 2 Related Work Visibility computation and hidden surface removal are classic problems in computer graphics [FDHF90]. Some of the commonly used visibility algorithms are based on Z-buffer <ref> [Cat74] </ref> and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87] (see [Dor94] for a recent survey).
Reference: [Chu94] <author> J. C. Chauvin (Sogitec). </author> <title> An advanced Z-buffer technology. </title> <booktitle> IMAGE VII, </booktitle> <pages> pages 76-85, </pages> <year> 1994. </year>
Reference-contexts: The Loral GT200 [LORA] first renders near objects and fills in a mask buffer, which is used to cull away far objects. Sogitec's APOGEE system uses the Meta-Z-buffer, which is similar to hierarchical Z buffer <ref> [Chu94] </ref>.
Reference: [Cla76] <author> J.H. Clark. </author> <title> Hierarchical geometric models for visible surface algorithms. </title> <journal> Communications of the ACM, </journal> 19(10) 547-554, 1976. 
Reference-contexts: Finally, in Section 8, we briefly describe some future directions. 2 Related Work Visibility computation and hidden surface removal are classic problems in computer graphics [FDHF90]. Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling <ref> [Cla76, GBW90] </ref>. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87] (see [Dor94] for a recent survey).
Reference: [CT96a] <author> S. Coorg and S. Teller. </author> <title> A spatially and temproally coherent object space visibility algorithm. </title> <type> Technical Report TM 546, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <year> 1996. </year>
Reference-contexts: They used regular spatial subdivision to partition the model into cells and describe a 2D implementation. However, the resulting algorithm is very memory-intensive and does not scale well to large models. Object space algorithms for occlusion culling in general polygonal models have been presented by Coorg and Teller <ref> [CT96b, CT96a] </ref> and Hudson et al. [Hud96]. These algorithms dynamically compute a subset of the objects as occluders and use them to cull away portions of the model. In particular, [CT96b, CT96a] compute an arrangement corresponding to a linearized portion of an aspect graph and track the viewpoint within it to <p> Object space algorithms for occlusion culling in general polygonal models have been presented by Coorg and Teller <ref> [CT96b, CT96a] </ref> and Hudson et al. [Hud96]. These algorithms dynamically compute a subset of the objects as occluders and use them to cull away portions of the model. In particular, [CT96b, CT96a] compute an arrangement corresponding to a linearized portion of an aspect graph and track the viewpoint within it to check for occlusion. [Hud96] use shadow frusta and fast interference tests for occlusion culling. <p> In general, however, we do not expect to outperform the specialized algorithms in cell/portal environments. Two different object space solutions for more general models have been proposed by <ref> [CT96a, CT96b] </ref> and [Hud96]. They dynamically choose polygons and convex objects (or simple convex combination of polygons) as occluders and use them to cull away invisible portions of the model. However, many models do not have single big convex occluders.
Reference: [CT96b] <author> S. Coorg and S. Teller. </author> <title> Temporally coherent conservative visibility. </title> <booktitle> In Proc. of 12th ACM Symposium on Computational Geometry, </booktitle> <year> 1996. </year>
Reference-contexts: They used regular spatial subdivision to partition the model into cells and describe a 2D implementation. However, the resulting algorithm is very memory-intensive and does not scale well to large models. Object space algorithms for occlusion culling in general polygonal models have been presented by Coorg and Teller <ref> [CT96b, CT96a] </ref> and Hudson et al. [Hud96]. These algorithms dynamically compute a subset of the objects as occluders and use them to cull away portions of the model. In particular, [CT96b, CT96a] compute an arrangement corresponding to a linearized portion of an aspect graph and track the viewpoint within it to <p> Object space algorithms for occlusion culling in general polygonal models have been presented by Coorg and Teller <ref> [CT96b, CT96a] </ref> and Hudson et al. [Hud96]. These algorithms dynamically compute a subset of the objects as occluders and use them to cull away portions of the model. In particular, [CT96b, CT96a] compute an arrangement corresponding to a linearized portion of an aspect graph and track the viewpoint within it to check for occlusion. [Hud96] use shadow frusta and fast interference tests for occlusion culling. <p> In general, however, we do not expect to outperform the specialized algorithms in cell/portal environments. Two different object space solutions for more general models have been proposed by <ref> [CT96a, CT96b] </ref> and [Hud96]. They dynamically choose polygons and convex objects (or simple convex combination of polygons) as occluders and use them to cull away invisible portions of the model. However, many models do not have single big convex occluders.
Reference: [Dor94] <author> S. E. Dorward. </author> <title> A survey of object-space hidden surface removal. </title> <journal> Internat. J. Comput. Geom. Appl., </journal> <volume> 4 </volume> <pages> 325-362, </pages> <year> 1994. </year>
Reference-contexts: Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87] (see <ref> [Dor94] </ref> for a recent survey). However, the practical utility of these algorithms is unclear at the moment. Efficient algorithms for calculating the visibility relationship among a static group of 3D polygons from arbitrary viewpoints have been proposed based on the binary space-partitioning (BSP) tree [FKN80].
Reference: [FDHF90] <author> J. Foley, A. Van Dam, J. Hughes, and S. </author> <title> Feiner. </title> <booktitle> Computer Graphics: Principles and Practice. </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, Mass., </address> <year> 1990. </year>
Reference-contexts: We describe its implementation and performance in Section 6. Section 7 analyses our algorithm and compares it with other approaches. Finally, in Section 8, we briefly describe some future directions. 2 Related Work Visibility computation and hidden surface removal are classic problems in computer graphics <ref> [FDHF90] </ref>. Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. <p> Finally, in Section 8, we briefly describe some future directions. 2 Related Work Visibility computation and hidden surface removal are classic problems in computer graphics <ref> [FDHF90] </ref>. Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87] (see [Dor94] for a recent survey). However, the practical utility of these algorithms is unclear at the moment. <p> Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms <ref> [War69, FDHF90] </ref>. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87] (see [Dor94] for a recent survey). However, the practical utility of these algorithms is unclear at the moment. <p> Any rendered image can have an accompanying occlusion map which has the same resolution and stores the opacity for each pixel. In such a case, the occlusion map is essentially the ff channel <ref> [FDHF90] </ref> of the rendered image (assuming ff values for objects are set properly during rendering), though generally speaking a pixel in the occlusion map can correspond to a block of pixels in screen space. 4.1 Image Pyramid Given the lowest level occlusion map, the algorithm constructs from it a hierarchy of
Reference: [FKN80] <author> H. Fuchs, Z. Kedem, and B. Naylor. </author> <title> On visible surface generation by a priori tree structures. </title> <booktitle> Proc. of ACM Siggraph, </booktitle> <volume> 14(3) </volume> <pages> 124-133, </pages> <year> 1980. </year>
Reference-contexts: However, the practical utility of these algorithms is unclear at the moment. Efficient algorithms for calculating the visibility relationship among a static group of 3D polygons from arbitrary viewpoints have been proposed based on the binary space-partitioning (BSP) tree <ref> [FKN80] </ref>. The tree construction may involve considerable pre-processing in terms of time and space requirements for large models. In [Nay92], Naylor has given an output-sensitive visibility algorithm using BSPs.
Reference: [GBR91] <author> R. Coifman G. Beylkin and V. Rokhlin. </author> <title> Fast wavelet transforms and numerical algorithms: I. </title> <journal> Communications of Pure and Applied Mathematics, </journal> <volume> 44(2) </volume> <pages> 141-183, </pages> <year> 1991. </year>
Reference-contexts: The structure of hierarchical occlusion maps is similar to some of the hierarchies that have been proposed for images, such as image pyramids [TP75], MIP maps [Wil83], Z -pyramids [GKM93], coverage pyramids [Gre96], and two-dimensional wavelet transforms like the non-standard decomposition <ref> [GBR91] </ref>. 3 Overview In this paper we present a novel solution to the visibility problem. The heart of the algorithm is a hierarchy of occlusion maps, which records the aggregate projection of occluders onto the image plane at different resolutions.
Reference: [GBW90] <author> B. Garlick, D. Baum, and J. Winget. </author> <title> Interactive viewing of large geometric databases using multiprocessor graphics workstations. Sig-graph'90 course notes: Parallel Algorithms and Architectures for 3D Image Generation, </title> <year> 1990. </year>
Reference-contexts: Finally, in Section 8, we briefly describe some future directions. 2 Related Work Visibility computation and hidden surface removal are classic problems in computer graphics [FDHF90]. Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling <ref> [Cla76, GBW90] </ref>. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87] (see [Dor94] for a recent survey).
Reference: [GCS91] <author> Z. Gigus, J. Canny, and R. Seidel. </author> <title> Efficiently computingand representing aspect graphs of polyhedral objects. </title> <journal> IEEE Transactions on Pattern Analysis and Machine Intelligence, </journal> <volume> 13(6) </volume> <pages> 542-551, </pages> <year> 1991. </year> <title> 10 rine composed of 632,252 polygons. Average speed-up is about two due to occlusion culling. </title>
Reference-contexts: Another possibility is to pre-compute global visibility information for computing the useful occluders at every viewpoint. The fastest known algorithm for computing the effects on global visibility due to a single polyhedron with m vertices can take O (m 6 log m) time in the worst case <ref> [GCS91] </ref>. We present algorithms to estimate a set of occluders that are used to cull a significant fraction of the model. We perform preprocessing to derive an occluder database from the model.
Reference: [GK94] <author> N. Greene and M. Kass. </author> <title> Error-bounded antialiased rendering of complex environments. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 59-66, </pages> <year> 1994. </year>
Reference-contexts: These algorithms are unable to combine a forest" of small non-convex or disjoint occluders to cull away large portions of the model. A hierarchical Z-buffer algorithm combining spatial and temporal coherence has been presented in <ref> [GKM93, GK94, Gre95] </ref>. It uses two hierarchical data structures: an octree and a Z-pyramid. The algorithm exploits coherence by performing visibility queries on the Z-pyramid and is very effective in culling large portions of high-depth complexity models. <p> The algorithm exploits coherence by performing visibility queries on the Z-pyramid and is very effective in culling large portions of high-depth complexity models. However, most current graphics systems do not support the Z-pyramid capability in hardware, and simulating it in software can be relatively expensive. In <ref> [GK94] </ref>, Greene and Kass used a quadtree data structure to test visibility throughout image-space regions for anti-aliased rendering. [Geo95] describes an implementation of the Z-query operation on a parallel graphics architecture (PixelPlanes 5) for obscuration culling. More recently, Greene [Gre96] has presented a hierarchical tiling algorithm using coverage masks.
Reference: [GKM93] <author> N. Greene, M. Kass, and G. Miller. </author> <title> Hierarchical Z-buffer visibility. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 231-238, </pages> <year> 1993. </year>
Reference-contexts: These algorithms are unable to combine a forest" of small non-convex or disjoint occluders to cull away large portions of the model. A hierarchical Z-buffer algorithm combining spatial and temporal coherence has been presented in <ref> [GKM93, GK94, Gre95] </ref>. It uses two hierarchical data structures: an octree and a Z-pyramid. The algorithm exploits coherence by performing visibility queries on the Z-pyramid and is very effective in culling large portions of high-depth complexity models. <p> Sogitec's APOGEE system uses the Meta-Z-buffer, which is similar to hierarchical Z buffer [Chu94]. The structure of hierarchical occlusion maps is similar to some of the hierarchies that have been proposed for images, such as image pyramids [TP75], MIP maps [Wil83], Z -pyramids <ref> [GKM93] </ref>, coverage pyramids [Gre96], and two-dimensional wavelet transforms like the non-standard decomposition [GBR91]. 3 Overview In this paper we present a novel solution to the visibility problem. <p> Our algorithm lies between object space and image space and the occluder merging problem is solved in image space. 7.2 Comparison with Hierarchical Z-buffer Algorithm In many ways, we present an alternative approach to hierarchical Z -buffer visibility <ref> [GKM93] </ref>. The main algorithm presented in [GKM93] performs updates of the Z -buffer hierarchy as geometry is rendered. It assumes special-purpose hardware for fast depth updating and querying to obtain interactive performance. It is potentially a very powerful and effective algorithm for visibility culling. <p> Our algorithm lies between object space and image space and the occluder merging problem is solved in image space. 7.2 Comparison with Hierarchical Z-buffer Algorithm In many ways, we present an alternative approach to hierarchical Z -buffer visibility <ref> [GKM93] </ref>. The main algorithm presented in [GKM93] performs updates of the Z -buffer hierarchy as geometry is rendered. It assumes special-purpose hardware for fast depth updating and querying to obtain interactive performance. It is potentially a very powerful and effective algorithm for visibility culling. However, we are not aware of any hardware implementation. <p> However, we are not aware of any hardware implementation. There is a possible variation of hierarchical Z -buffer algorithm which selects occluders, renders them, reads back the depth buffer once per frame, builds the Z-pyramid, and use the screen-space bounding rectangles for fast culling. The algorithm proposed in <ref> [GKM93] </ref> uses the exact projection of octree nodes, which requires software scan-conversion. In this case, the HOM approach and the hierarchical Z-buffer are comparable, each with some advantages over the other. The HOM approach has the following advantages: 1. There is no need for a Z-buffer.
Reference: [Geo95] <author> C. Georges. </author> <title> Obscuration culling on parallel graphics architectures. </title> <type> Technical Report TR95-017, </type> <institution> Department of Computer Science, University of North Carolina, Chapel Hill, </institution> <year> 1995. </year>
Reference-contexts: However, most current graphics systems do not support the Z-pyramid capability in hardware, and simulating it in software can be relatively expensive. In [GK94], Greene and Kass used a quadtree data structure to test visibility throughout image-space regions for anti-aliased rendering. <ref> [Geo95] </ref> describes an implementation of the Z-query operation on a parallel graphics architecture (PixelPlanes 5) for obscuration culling. More recently, Greene [Gre96] has presented a hierarchical tiling algorithm using coverage masks. It uses an image hierarchy named a coverage pyramid for visibility culling.
Reference: [Gre95] <author> N. Greene. </author> <title> Hierarchical rendering of complex environments. </title> <type> PhD thesis, </type> <institution> University of California at Santa Cruz, </institution> <year> 1995. </year>
Reference-contexts: These algorithms are unable to combine a forest" of small non-convex or disjoint occluders to cull away large portions of the model. A hierarchical Z-buffer algorithm combining spatial and temporal coherence has been presented in <ref> [GKM93, GK94, Gre95] </ref>. It uses two hierarchical data structures: an octree and a Z-pyramid. The algorithm exploits coherence by performing visibility queries on the Z-pyramid and is very effective in culling large portions of high-depth complexity models.
Reference: [Gre96] <author> N. Greene. </author> <title> Hierarchical polygon tiling with coverage masks. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 65-74, </pages> <year> 1996. </year>
Reference-contexts: In [GK94], Greene and Kass used a quadtree data structure to test visibility throughout image-space regions for anti-aliased rendering. [Geo95] describes an implementation of the Z-query operation on a parallel graphics architecture (PixelPlanes 5) for obscuration culling. More recently, Greene <ref> [Gre96] </ref> has presented a hierarchical tiling algorithm using coverage masks. It uses an image hierarchy named a coverage pyramid for visibility culling. Traversing polygons from front to back, it can process densely occluded scenes efficiently and is well suited to anti-aliasing by oversam-pling and filtering. <p> Sogitec's APOGEE system uses the Meta-Z-buffer, which is similar to hierarchical Z buffer [Chu94]. The structure of hierarchical occlusion maps is similar to some of the hierarchies that have been proposed for images, such as image pyramids [TP75], MIP maps [Wil83], Z -pyramids [GKM93], coverage pyramids <ref> [Gre96] </ref>, and two-dimensional wavelet transforms like the non-standard decomposition [GBR91]. 3 Overview In this paper we present a novel solution to the visibility problem. The heart of the algorithm is a hierarchy of occlusion maps, which records the aggregate projection of occluders onto the image plane at different resolutions. <p> Updating the active occluder list is more difficult in our algorithm since we only have estimated farthest Z values. 7.3 Comparison with Hierarchical Tiling with Coverage Masks Hierarchical polygon tiling <ref> [Gre96] </ref> tiles polygons in front-to-back order and uses a coverage pyramid for visibility culling. <p> This has lead to desirable features, as discussed above. Like HOM, the coverage masks do not contain depth information and the algorithm in <ref> [Gre96] </ref> uses a BSP-tree for depth-ordering of polygons. Our algorithm is not restricted to rendering the polygons front to back. Rather, it only needs a conservatively estimated boundary between the occluders and potential occludees, which is represented by the depth estimation buffer.
Reference: [Hud96] <author> T. Hudson, D. Manocha, J. Cohen, M. Lin, K. Hoff and H. Zhang. </author> <title> Accelerated occlusion culling using shadow frusta. </title> <type> Technical Report TR96-052, </type> <institution> Department of Computer Science, University of North Car-olina, </institution> <year> 1996. </year> <note> To appear in Proc. of ACM Symposium on Computational Geometry, </note> <year> 1997. </year>
Reference-contexts: However, the resulting algorithm is very memory-intensive and does not scale well to large models. Object space algorithms for occlusion culling in general polygonal models have been presented by Coorg and Teller [CT96b, CT96a] and Hudson et al. <ref> [Hud96] </ref>. These algorithms dynamically compute a subset of the objects as occluders and use them to cull away portions of the model. In particular, [CT96b, CT96a] compute an arrangement corresponding to a linearized portion of an aspect graph and track the viewpoint within it to check for occlusion. [Hud96] use shadow <p> et al. <ref> [Hud96] </ref>. These algorithms dynamically compute a subset of the objects as occluders and use them to cull away portions of the model. In particular, [CT96b, CT96a] compute an arrangement corresponding to a linearized portion of an aspect graph and track the viewpoint within it to check for occlusion. [Hud96] use shadow frusta and fast interference tests for occlusion culling. All of them are object-space algorithms and the choice of occluder is restricted to convex objects or simple combination of convex objects (e.g. two convex polytope sharing an edge). <p> In general, however, we do not expect to outperform the specialized algorithms in cell/portal environments. Two different object space solutions for more general models have been proposed by [CT96a, CT96b] and <ref> [Hud96] </ref>. They dynamically choose polygons and convex objects (or simple convex combination of polygons) as occluders and use them to cull away invisible portions of the model. However, many models do not have single big convex occluders.
Reference: [Lat94] <author> R. Latham (CGSD). </author> <title> Advanced image generator architectures. Course reference material, </title> <year> 1994. </year>
Reference-contexts: There is substantial literature on the visibility problem from the flight simulator community. An overview of flight simulator architectures is given in [Mue95]. Most notably, the Singer Company's Modular Digital Image Generator <ref> [Lat94] </ref> renders front to back using a hierarchy of mask buffers to skip over already cov 2 The shaded blocks indicate components unique to culling with hierarchical occlusion map. ered spans, segments or rows in the image.
Reference: [LG95] <author> D. Luebke and C. Georges. </author> <title> Portals and mirrors: Simple, fast evaluation of potentiallyvisible sets. </title> <booktitle> In ACM Interactive 3D Graphics Conference, </booktitle> <address> Monterey, CA, </address> <year> 1995. </year>
Reference-contexts: Many algorithms structure the model database into cells or regions, and use a combination of off-line and on-line algorithms for cell-to-cell visibility and the conservative computation of the potentially visible set (PVS) of primitives <ref> [ARB90, TS91, LG95] </ref>. Such approaches have been successfully used to visualize architectural models, where the division of a building into discrete rooms lends itself to a natural division of the database into cells. It is not apparent that cell-based approaches can be generalized to an arbitrary model. <p> If a model under some the viewing conditions does not have sufficient occlusion, the overall frame rate may decrease due to the overhead, in which case occlusion culling should be turned off. 7.1 Comparison to Object Space Algorithms Work on cells and portals <ref> [ARB90, TS91, LG95] </ref> addresses a special class of densely occluded environments where there are plenty 8 different models. The total time to render each model without HOM culling is normalized to 100%. <p> Each bar shows the percentage of time spent in different stages of our algorithm. of cell and portal structures, as in an indoor architectural model. [ARB90, TS91] pre-processes the model to identify potentially visible set of primitives for each cell. <ref> [LG95] </ref> developed a dynamic version which eliminates the visibility pre-processing. These methods work very well for this particular type of environment, but are not applicable to models without cell/portal structures. Our algorithm works without modification for environments with cells and portals, but occluder selection can be optimized for these environments.
Reference: [LORA] <author> Loral ADS. </author> <title> GT200T Level II image generator productoverview, </title> <address> Belle-vue, WA. </address>
Reference-contexts: General Electric's COMPU-SCENE PT2000 [Bun89] uses a similar algorithm but does not require the input polygons to be in front-to-back order and the mask buffer is not hierarchical. The Loral GT200 <ref> [LORA] </ref> first renders near objects and fills in a mask buffer, which is used to cull away far objects. Sogitec's APOGEE system uses the Meta-Z-buffer, which is similar to hierarchical Z buffer [Chu94].
Reference: [McK87] <author> M. McKenna. </author> <title> Worst-case optimal hidden-surfaceremoval. </title> <journal> ACM Trans. Graph., </journal> <volume> 6 </volume> <pages> 19-28, </pages> <year> 1987. </year>
Reference-contexts: Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal <ref> [Mul89, McK87] </ref> (see [Dor94] for a recent survey). However, the practical utility of these algorithms is unclear at the moment. Efficient algorithms for calculating the visibility relationship among a static group of 3D polygons from arbitrary viewpoints have been proposed based on the binary space-partitioning (BSP) tree [FKN80].
Reference: [MEP92] <author> S. Molnar, J. Eyles and J. Poulton. PixelFlow: </author> <title> High speed rendering using image composition. </title> <booktitle> Proc. of ACM Siggraph, </booktitle> <pages> pp. 231-248, </pages> <year> 1992. </year>
Reference-contexts: The HOM approach has the following advantages: 1. There is no need for a Z-buffer. Many low-end systems do not support a Z-buffer and some image generators for flight simulators do not have one. Tile-based architectures like PixelFlow <ref> [MEP92] </ref> and Talisman [TK96] do not have a full-screen Z-buffer, but instead have volatile Z-buffers the size of a single tile. This makes getting Z values for the entire screen rather difficult. 2.
Reference: [Mue95] <author> C. Mueller. </author> <title> Architectures of image generators for flight simulators. </title> <type> Technical Report TR95-015, </type> <institution> Department of Computer Science, University of North Carolina, Chapel Hill, </institution> <year> 1995. </year>
Reference-contexts: They use techniques based on view-frustum culling, levels-of-detail, etc., but have little support for occlusion culling on arbitrary models. There is substantial literature on the visibility problem from the flight simulator community. An overview of flight simulator architectures is given in <ref> [Mue95] </ref>. Most notably, the Singer Company's Modular Digital Image Generator [Lat94] renders front to back using a hierarchy of mask buffers to skip over already cov 2 The shaded blocks indicate components unique to culling with hierarchical occlusion map. ered spans, segments or rows in the image.
Reference: [Mul89] <author> K. Mulmuley. </author> <title> An efficient algorithm for hidden surface removal. </title> <journal> Computer Graphics, </journal> <volume> 23(3) </volume> <pages> 379-388, </pages> <year> 1989. </year>
Reference-contexts: Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms [War69, FDHF90]. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal <ref> [Mul89, McK87] </ref> (see [Dor94] for a recent survey). However, the practical utility of these algorithms is unclear at the moment. Efficient algorithms for calculating the visibility relationship among a static group of 3D polygons from arbitrary viewpoints have been proposed based on the binary space-partitioning (BSP) tree [FKN80].
Reference: [Nay92] <author> B. Naylor. </author> <title> Partitioning tree imge representation and generation from 3d geometric models. </title> <booktitle> In Proc. of Graphics Interface, </booktitle> <pages> pages 201-12, </pages> <year> 1992. </year>
Reference-contexts: Efficient algorithms for calculating the visibility relationship among a static group of 3D polygons from arbitrary viewpoints have been proposed based on the binary space-partitioning (BSP) tree [FKN80]. The tree construction may involve considerable pre-processing in terms of time and space requirements for large models. In <ref> [Nay92] </ref>, Naylor has given an output-sensitive visibility algorithm using BSPs. It uses a 2D BSP tree to represent images and presents an algorithm to project a 3D BSP tree, representing the model in object space, into a 2D BSP tree representing its image.
Reference: [RB96] <editor> R. Brechner et al. </editor> <booktitle> Interactive walkthroughof large geometricdatabases. Siggraph'96 course notes, </booktitle> <year> 1996. </year>
Reference-contexts: A number of techniques for interactive walkthrough of large geometric databases have been proposed. Refer to <ref> [RB96] </ref> for a recent survey. A number of commercial systems like Performer [RH94], used for high performance graphics, and Brush [SBM + 94], used for visualizing architectural and CAD models, are available.
Reference: [RH94] <author> J. Rohlf and J. Helman. Iris performer: </author> <title> A high performance multiprocessor toolkit for realtime 3d graphics. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 381-394, </pages> <year> 1994. </year>
Reference-contexts: A number of techniques for interactive walkthrough of large geometric databases have been proposed. Refer to [RB96] for a recent survey. A number of commercial systems like Performer <ref> [RH94] </ref>, used for high performance graphics, and Brush [SBM + 94], used for visualizing architectural and CAD models, are available. They use techniques based on view-frustum culling, levels-of-detail, etc., but have little support for occlusion culling on arbitrary models.
Reference: [SBM + 94] <author> B. Schneider, P. Borrel, J. Menon, J. Mittleman, and J. Rossignac. </author> <title> Brush as a walkthroughsystem for architectural models. </title> <booktitle> In Fifth Eurographics Workshop on Rendering, </booktitle> <pages> pages 389-399, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: A number of techniques for interactive walkthrough of large geometric databases have been proposed. Refer to [RB96] for a recent survey. A number of commercial systems like Performer [RH94], used for high performance graphics, and Brush <ref> [SBM + 94] </ref>, used for visualizing architectural and CAD models, are available. They use techniques based on view-frustum culling, levels-of-detail, etc., but have little support for occlusion culling on arbitrary models. There is substantial literature on the visibility problem from the flight simulator community.
Reference: [SG96] <author> O. Sudarsky and C. Gotsman. </author> <title> Output sensitive visibility algorithms for dynamic scenes with applications to virtual reality. </title> <journal> Computer Graphics Forum, </journal> <volume> 15(3) </volume> <pages> 249-58, </pages> <year> 1996. </year> <note> Proc. of Eurographics'96. </note>
Reference-contexts: It uses an image hierarchy named a coverage pyramid for visibility culling. Traversing polygons from front to back, it can process densely occluded scenes efficiently and is well suited to anti-aliasing by oversam-pling and filtering. For dynamic environments, Sudarsky and Gotsman <ref> [SG96] </ref> have presented an output-sensitive algorithm which minimizes the time required to update the hierarchical data structure for a dynamic object and minimize the number of dynamic objects for which the structure has to be updated. A number of techniques for interactive walkthrough of large geometric databases have been proposed.
Reference: [TK96] <author> J. Torborg and J. Kajiya. Talisman: </author> <title> Commodity Realtime 3D Graphics for the PC. </title> <booktitle> Proc. of ACM Siggraph, </booktitle> <pages> pp. 353-363, </pages> <year> 1996. </year>
Reference-contexts: The HOM approach has the following advantages: 1. There is no need for a Z-buffer. Many low-end systems do not support a Z-buffer and some image generators for flight simulators do not have one. Tile-based architectures like PixelFlow [MEP92] and Talisman <ref> [TK96] </ref> do not have a full-screen Z-buffer, but instead have volatile Z-buffers the size of a single tile. This makes getting Z values for the entire screen rather difficult. 2.
Reference: [TP75] <author> S. Tanimoto and T. Pavlidis. </author> <title> A hierarchical data structure for picture processing. </title> <journal> Computer Graphics and Image Processing, </journal> <volume> 4(2) </volume> <pages> 104-119, </pages> <year> 1975. </year>
Reference-contexts: Sogitec's APOGEE system uses the Meta-Z-buffer, which is similar to hierarchical Z buffer [Chu94]. The structure of hierarchical occlusion maps is similar to some of the hierarchies that have been proposed for images, such as image pyramids <ref> [TP75] </ref>, MIP maps [Wil83], Z -pyramids [GKM93], coverage pyramids [Gre96], and two-dimensional wavelet transforms like the non-standard decomposition [GBR91]. 3 Overview In this paper we present a novel solution to the visibility problem.
Reference: [TS91] <author> S. Teller and C.H. Sequin. </author> <title> Visibility preprocessing for interactive walkthroughs. </title> <booktitle> In Proc. of ACM Siggraph, </booktitle> <pages> pages 61-69, </pages> <year> 1991. </year>
Reference-contexts: Many algorithms structure the model database into cells or regions, and use a combination of off-line and on-line algorithms for cell-to-cell visibility and the conservative computation of the potentially visible set (PVS) of primitives <ref> [ARB90, TS91, LG95] </ref>. Such approaches have been successfully used to visualize architectural models, where the division of a building into discrete rooms lends itself to a natural division of the database into cells. It is not apparent that cell-based approaches can be generalized to an arbitrary model. <p> If a model under some the viewing conditions does not have sufficient occlusion, the overall frame rate may decrease due to the overhead, in which case occlusion culling should be turned off. 7.1 Comparison to Object Space Algorithms Work on cells and portals <ref> [ARB90, TS91, LG95] </ref> addresses a special class of densely occluded environments where there are plenty 8 different models. The total time to render each model without HOM culling is normalized to 100%. <p> The total time to render each model without HOM culling is normalized to 100%. Each bar shows the percentage of time spent in different stages of our algorithm. of cell and portal structures, as in an indoor architectural model. <ref> [ARB90, TS91] </ref> pre-processes the model to identify potentially visible set of primitives for each cell. [LG95] developed a dynamic version which eliminates the visibility pre-processing. These methods work very well for this particular type of environment, but are not applicable to models without cell/portal structures.
Reference: [War69] <author> J. Warnock. </author> <title> A hidden-surface algorithm for computer generated halftone pictures. </title> <type> Technical Report TR 4-15, </type> <institution> NTIS AD-753 671, Department of Computer Science, University of Utah, </institution> <year> 1969. </year>
Reference-contexts: Some of the commonly used visibility algorithms are based on Z-buffer [Cat74] and view-frustum culling [Cla76, GBW90]. Others include Painter's Algorithm [FDHF90] and area-subdivision algorithms <ref> [War69, FDHF90] </ref>. There is significant literature on visible surface computation in computational geometry. Many asymptotically efficient algorithms have been proposed for hidden surface removal [Mul89, McK87] (see [Dor94] for a recent survey). However, the practical utility of these algorithms is unclear at the moment.
Reference: [Wil83] <editor> L. Williams. Pyramidal parametrics. </editor> <booktitle> ACM Computer Graphics, </booktitle> <pages> pages 1-11, </pages> <year> 1983. </year>
Reference-contexts: Sogitec's APOGEE system uses the Meta-Z-buffer, which is similar to hierarchical Z buffer [Chu94]. The structure of hierarchical occlusion maps is similar to some of the hierarchies that have been proposed for images, such as image pyramids [TP75], MIP maps <ref> [Wil83] </ref>, Z -pyramids [GKM93], coverage pyramids [Gre96], and two-dimensional wavelet transforms like the non-standard decomposition [GBR91]. 3 Overview In this paper we present a novel solution to the visibility problem.
Reference: [YR96] <author> R. Yagel and W. Ray. </author> <title> Visibility computations for efficient walkthrough of complex environments. </title> <journal> Presence, </journal> <volume> 5(1) </volume> <pages> 1-16, </pages> <year> 1996. </year> <title> 11 left image indicates the view-frustum. The right image highlights the holes among the leaves with a yellow background. The screen space bounding rectangle of the house is shown in cyan. The occlusion map hierarchy is shown on the left. opacity threshold values from 0:7 for the highest resolution map up to 1:0 for the lowest resolution map. </title> <type> 12 </type>
Reference-contexts: It is not apparent that cell-based approaches can be generalized to an arbitrary model. Other algorithms for densely-occluded but somewhat less-structured models have been proposed by Yagel and Ray <ref> [YR96] </ref>. They used regular spatial subdivision to partition the model into cells and describe a 2D implementation. However, the resulting algorithm is very memory-intensive and does not scale well to large models.
References-found: 39

