URL: http://www-cad.eecs.berkeley.edu/HomePages/tah/Publications/reactive_modules.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/tah/Publications/reactive_modules.html
Root-URL: http://www.cs.berkeley.edu
Title: Reactive Modules  
Author: Rajeev Alur Thomas A. Henzinger 
Abstract: We present a formal model for concurrent systems. The model represents synchronous and asynchronous components in a uniform framework that supports compositional (assume-guarantee) and hierarchical (stepwise-refinement) design and verification. While synchronous models are based on a notion of atomic computation step, and asynchronous models remove that notion by introducing stuttering, our model is based on a flexible notion of what constitutes a computation step: by applying an abstraction operator to a system, arbitrarily many consecutive steps can be collapsed into a single step. The abstraction operator, which may turn an asynchronous system into a synchronous one, allows us to describe systems at various levels of temporal detail. For describing systems at various levels of spatial detail, we use a hiding operator that may turn a synchronous system into an asynchronous one. We illustrate the model with diverse examples from synchronous circuits, asynchronous shared-memory programs, and synchronous message-passing protocols.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82 </volume> <pages> 253-284, </pages> <year> 1991. </year>
Reference-contexts: It is easy to check that the fair-implementation relation F is a preorder on fair modules. Machine closure. Every finite trajectory of a fair module P can be extended to a fair trajectory of P. This property of a reactive system is called machine closure <ref> [1] </ref>. Proposition 10 If P is a fair module, and a is a finite trace of P, then a is a finite prefix of some fair trace of P. 34 It follows that the set of fair trajectories of a fair module is always nonempty.
Reference: [2] <author> M. Abadi and L. Lamport. </author> <title> Conjoining specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17 </volume> <pages> 507-534, </pages> <year> 1995. </year>
Reference-contexts: In particular, P 1 may not implement Q 1 for all environments, but only if the environment behaves like P 2 , and vice versa. For such cases, an assume-guarantee proof rule is needed <ref> [25, 13, 2, 4] </ref>.
Reference: [3] <author> B. Alpern, A.J. Demers, and F.B. Schneider. </author> <title> Safety without stuttering. </title> <journal> Information Processing Letters, </journal> <volume> 23 </volume> <pages> 177-180, </pages> <year> 1986. </year>
Reference-contexts: Since all initial and update actions of the module P are executable, the set of !-traces of P is completely determined by the set L P of finite traces, and vice versa. This property of a reactive system is called limit closure, or safety <ref> [3] </ref>. Proposition 9 Let P be a module. An infinite sequence a of observations of P is an !-trace of P iff every finite prefix of a is a trace of P .
Reference: [4] <author> R. Alur and T.A. Henzinger. </author> <title> Local liveness for compositional modeling of fair reactive systems. </title> <booktitle> In CAV 95: Computer-aided Verification, Lecture Notes in Computer Science 939, </booktitle> <pages> pages 166-179. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: In particular, P 1 may not implement Q 1 for all environments, but only if the environment behaves like P 2 , and vice versa. For such cases, an assume-guarantee proof rule is needed <ref> [25, 13, 2, 4] </ref>. <p> The circularity in the fairness constraints needs to be broken, which leads to a somewhat weaker form of assume-guarantee principle in the presence of fairness <ref> [4] </ref>. For a fair module P, let unfair (P) be the trivially-fair module Q with safe (Q) = safe (P); that is, unfair (P) is obtained from P by discarding the fairness constraints.
Reference: [5] <author> R. Alur, T.A. Henzinger, and S.K. Rajamani. </author> <title> Symbolic exploration of transition hierarchies. </title> <booktitle> In TACAS 98: Tools and Algorithms for the Construction and Analysis of Systems, Lecture Notes in Computer Science 1384, </booktitle> <pages> pages 330-344, </pages> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: Each 30 single image-computation step for P corresponds to iterating the transition relation of P 1 until some variable in Y 1 changes, and iterating, independently, the transition relation of P 2 until some variable in Y 2 changes. The experiments reported in <ref> [5] </ref> indicate that this scheme can enable the analysis of P in cases where no analysis of P 1 kP 2 is feasible. 6.3 Triggering Hiding allows us to build asynchronous modules from synchronous parts, and round abstraction allows us to build synchronous and round-sensitive modules from asynchronous and/or round-insensitive parts. <p> This allows us to decompose a verification task into subtasks with smaller state spaces. Module-based case studies that exploit assume-guarantee reasoning can be found in [15]; case studies that expoit round abstraction, in <ref> [5] </ref>. A verification tool, called Mocha, whose system description language is based on reactive modules, is currently being implemented [6]. Acknowledgments. We thank Albert Benveniste, Bob Kurshan, Ken McMillan, Amir Pnueli, and the VIS group at UC Berkeley for fruitful discussions. We also thank the anonymous referees for suggesting improvements.
Reference: [6] <author> R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. Rajamani, and S. Tasiran. Mocha: </author> <title> modularity in model checking. </title> <booktitle> In CAV 98: Computer-aided Verification, Lecture Notes in Computer Science, to appear. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: Module-based case studies that exploit assume-guarantee reasoning can be found in [15]; case studies that expoit round abstraction, in [5]. A verification tool, called Mocha, whose system description language is based on reactive modules, is currently being implemented <ref> [6] </ref>. Acknowledgments. We thank Albert Benveniste, Bob Kurshan, Ken McMillan, Amir Pnueli, and the VIS group at UC Berkeley for fruitful discussions. We also thank the anonymous referees for suggesting improvements.
Reference: [7] <author> A. Benveniste, P. le Guernic, and C. Jacquemot. </author> <title> Synchronous programming with events and relations: the Signal language and its semantics. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 16 </volume> <pages> 103-149, </pages> <year> 1991. </year>
Reference-contexts: Atomic synchrony (Mealy machines [23, 18]; Csp rendezvous [16, 24]): The system and the environment simultaneously update variables in an interdependent fashion. This is a natural style for modeling synchronous communication via events or messages. Nonatomic synchrony (synchronous programming languages <ref> [8, 7, 9, 14] </ref>): Each round (macro-step) consists of several subrounds (micro-steps), and the system and the environment take turns in executing micro-steps to update variables. <p> Thus, while synchronous languages, such as Esterel [8] and Signal <ref> [7] </ref>, permit the dynamic scheduling of subrounds at run time, atoms can be scheduled statically at compile time by linearizing the partial order on the atoms. <p> The temporal operators next and trigger of reactive modules are similar in spirit to the polychronous operators of synchronous programming languages such as Signal <ref> [7] </ref> and Lustre [14]. Both approaches allow temporal abstraction by manipulating what happens during a round. However, there is a key difference. Reactive modules have a global notion of round, and applications of next and trigger only change what a module does within a round.
Reference: [8] <author> G. Berry and G. Gonthier. </author> <title> The synchronous programming language Esterel: design, seman-tics, implementation. </title> <type> Technical Report 842, </type> <institution> INRIA, </institution> <year> 1988. </year>
Reference-contexts: Atomic synchrony (Mealy machines [23, 18]; Csp rendezvous [16, 24]): The system and the environment simultaneously update variables in an interdependent fashion. This is a natural style for modeling synchronous communication via events or messages. Nonatomic synchrony (synchronous programming languages <ref> [8, 7, 9, 14] </ref>): Each round (macro-step) consists of several subrounds (micro-steps), and the system and the environment take turns in executing micro-steps to update variables. <p> If atom A precedes atom B in the partial order, then in each round, the A-subround must precede the B-subround, and the updated values of the variables controlled by B may depend on the updated values of the variables controlled by A. Thus, while synchronous languages, such as Esterel <ref> [8] </ref> and Signal [7], permit the dynamic scheduling of subrounds at run time, atoms can be scheduled statically at compile time by linearizing the partial order on the atoms. <p> On the other hand, many protocol description languages (like Promela [17]) assume asynchronous 37 interleaving, and the most effective verification strategy is explicit on-the-fly search with reduction techniques based on partial orders and symmetries. Finally, the verification tools for synchronous programming languages (like Esterel <ref> [8] </ref>) can afford to construct global state-transition graphs, because much of the complexity is hidden by the fact that a single transition involves several subtransitions between transient states.
Reference: [9] <author> G. Berry, S. Ramesh, and R.K. Shyamasundar. </author> <title> Communicating reactive processes. </title> <booktitle> In Proceedings of the 20th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 85-98. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: Atomic synchrony (Mealy machines [23, 18]; Csp rendezvous [16, 24]): The system and the environment simultaneously update variables in an interdependent fashion. This is a natural style for modeling synchronous communication via events or messages. Nonatomic synchrony (synchronous programming languages <ref> [8, 7, 9, 14] </ref>): Each round (macro-step) consists of several subrounds (micro-steps), and the system and the environment take turns in executing micro-steps to update variables.
Reference: [10] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1988. </year>
Reference-contexts: Asynchrony vs. synchrony. During the execution of the module P the variables in X P change their values in a sequence of rounds. Various models of reactivity propose different ways in which the variables are updated in a single round. Pure asynchrony (interleaving <ref> [20, 10, 17, 22] </ref>): Either the system performs an update, or the environment performs an update. Interleaving models usually distinguish only between private variables, which can be updated by the system alone, and shared variables, which can be updated by both the system and the environment. <p> The guarded command that specifies a union of actions consists simply of the union of all guarded assignments of the individual actions. This style of describing asynchronous programs as an unstructured collection of guarded assignments is pursued in formalisms such as Unity <ref> [10] </ref> and Mur' [12]. Write-shared variables. The original formulation of Peterson's protocol uses a single write-shared boolean variable x, whose value always corresponds to the value of the predicate x 1 = x 2 in our formulation.
Reference: [11] <author> D.L. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-independent Circuits. </title> <publisher> The MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: In fact, even in a stepwise game between module and environment, no matter how the environment plays, the module always has a strategy to produce a fair trajectory. This property of a reactive system is called receptiveness <ref> [11] </ref>. In a formalism that builds compound systems from atomic systems, in order to prove that all compound systems are machine-closed, it suffices to prove that all atomic systems are receptive.
Reference: [12] <author> D.L. Dill. </author> <title> The Mur verification system. </title> <booktitle> In CAV 96: Computer-aided Verification, Lecture Notes in Computer Science 1102, </booktitle> <pages> pages 390-393. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The guarded command that specifies a union of actions consists simply of the union of all guarded assignments of the individual actions. This style of describing asynchronous programs as an unstructured collection of guarded assignments is pursued in formalisms such as Unity [10] and Mur' <ref> [12] </ref>. Write-shared variables. The original formulation of Peterson's protocol uses a single write-shared boolean variable x, whose value always corresponds to the value of the predicate x 1 = x 2 in our formulation.
Reference: [13] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16 </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: In particular, P 1 may not implement Q 1 for all environments, but only if the environment behaves like P 2 , and vice versa. For such cases, an assume-guarantee proof rule is needed <ref> [25, 13, 2, 4] </ref>.
Reference: [14] <author> N. Halbwachs. </author> <title> Synchronous Programming of Reactive Systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: and processors; and temporal scaling provides computation steps at different levels of detail, such as gate operations, arithmetic operations, and processor instructions. 2 While spatial scalability is a standard feature of concurrency models, the concept of temporal scalability is inspired by the notion of multiform time in synchronous programming languages <ref> [14] </ref>, and by the notion of action refinement in process algebras [26]. <p> Atomic synchrony (Mealy machines [23, 18]; Csp rendezvous [16, 24]): The system and the environment simultaneously update variables in an interdependent fashion. This is a natural style for modeling synchronous communication via events or messages. Nonatomic synchrony (synchronous programming languages <ref> [8, 7, 9, 14] </ref>): Each round (macro-step) consists of several subrounds (micro-steps), and the system and the environment take turns in executing micro-steps to update variables. <p> This reduction of the reachable state space is similar to synchronous programming languages, where only macro-steps, rather than micro-steps, correspond to edges in the state-transition graph <ref> [14] </ref>. Also the symbolic verification of a system that consists of modules with next operators can be performed efficiently. Consider the module P = (next Y 1 for P 1 ) k (next Y 2 for P 2 ). <p> The temporal operators next and trigger of reactive modules are similar in spirit to the polychronous operators of synchronous programming languages such as Signal [7] and Lustre <ref> [14] </ref>. Both approaches allow temporal abstraction by manipulating what happens during a round. However, there is a key difference. Reactive modules have a global notion of round, and applications of next and trigger only change what a module does within a round.
Reference: [15] <author> T.A. Henzinger, S. Qadeer, and S.K. Rajamani. You assume, </author> <title> we guarantee: methodology and case studies. </title> <booktitle> In CAV 98: Computer-aided Verification, Lecture Notes in Computer Science, to appear. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: In addition, our framework supports modular proof principles, such as assume-guarantee reasoning, and hierarchical verification, based on built-in abstraction operators such as next. This allows us to decompose a verification task into subtasks with smaller state spaces. Module-based case studies that exploit assume-guarantee reasoning can be found in <ref> [15] </ref>; case studies that expoit round abstraction, in [5]. A verification tool, called Mocha, whose system description language is based on reactive modules, is currently being implemented [6]. Acknowledgments. We thank Albert Benveniste, Bob Kurshan, Ken McMillan, Amir Pnueli, and the VIS group at UC Berkeley for fruitful discussions.
Reference: [16] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: Observable asynchrony (I/O automata [21]): Either the system updates the controlled variables, or the environment updates the external variables and the system updates the private variables in response. This is a natural style for modeling asynchronous communication via events or messages. Atomic synchrony (Mealy machines [23, 18]; Csp rendezvous <ref> [16, 24] </ref>): The system and the environment simultaneously update variables in an interdependent fashion. This is a natural style for modeling synchronous communication via events or messages.
Reference: [17] <author> G.J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Asynchrony vs. synchrony. During the execution of the module P the variables in X P change their values in a sequence of rounds. Various models of reactivity propose different ways in which the variables are updated in a single round. Pure asynchrony (interleaving <ref> [20, 10, 17, 22] </ref>): Either the system performs an update, or the environment performs an update. Interleaving models usually distinguish only between private variables, which can be updated by the system alone, and shared variables, which can be updated by both the system and the environment. <p> The efficiency of current verification tools often depends on the specific synchrony assumption supported by the underlying model. For instance, hardware description languages (like Vhdl) assume synchronous progress, and BDD-based model checking is successful in this domain. On the other hand, many protocol description languages (like Promela <ref> [17] </ref>) assume asynchronous 37 interleaving, and the most effective verification strategy is explicit on-the-fly search with reduction techniques based on partial orders and symmetries. <p> For example, the use of stutter transitions in synchronous models to represent asynchronous progress increases the number of transitions exponentially over an asynchronous model [19]. Or, the introduction of synchronization points into asynchronous models restricts the applicability of efficient search methods in verification <ref> [17] </ref>. By contrast, our uniform framework allows us to separate intrinsic truths and complexities about verification methods from accidental and model-dependent idiosyncrasies. In addition, our framework supports modular proof principles, such as assume-guarantee reasoning, and hierarchical verification, based on built-in abstraction operators such as next.
Reference: [18] <author> R.P. Kurshan. </author> <title> Computer-aided Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: Observable asynchrony (I/O automata [21]): Either the system updates the controlled variables, or the environment updates the external variables and the system updates the private variables in response. This is a natural style for modeling asynchronous communication via events or messages. Atomic synchrony (Mealy machines <ref> [23, 18] </ref>; Csp rendezvous [16, 24]): The system and the environment simultaneously update variables in an interdependent fashion. This is a natural style for modeling synchronous communication via events or messages. <p> In this way, history-free variables are analogous to the combinational variables of hardware description languages, the selection variables of Cospan <ref> [18] </ref>, and the pointwise functions of dataflow languages. Hence, during the verification of a module by explicit search through the state space, the values of history-free variables can be omitted from the search stack.
Reference: [19] <author> R.P. Kurshan, M. Merritt, A. Orda, and S.R. Sachs. </author> <title> Modeling asynchrony with a synchronous model. </title> <booktitle> In CAV 95: Computer-aided Verification, Lecture Notes in Computer Science 939, </booktitle> <pages> pages 339-352. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: For example, the use of stutter transitions in synchronous models to represent asynchronous progress increases the number of transitions exponentially over an asynchronous model <ref> [19] </ref>. Or, the introduction of synchronization points into asynchronous models restricts the applicability of efficient search methods in verification [17]. By contrast, our uniform framework allows us to separate intrinsic truths and complexities about verification methods from accidental and model-dependent idiosyncrasies.
Reference: [20] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5 </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: Asynchrony vs. synchrony. During the execution of the module P the variables in X P change their values in a sequence of rounds. Various models of reactivity propose different ways in which the variables are updated in a single round. Pure asynchrony (interleaving <ref> [20, 10, 17, 22] </ref>): Either the system performs an update, or the environment performs an update. Interleaving models usually distinguish only between private variables, which can be updated by the system alone, and shared variables, which can be updated by both the system and the environment.
Reference: [21] <author> N.A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: The various classes of module variables and their relationships are summarized in Table 1. The distinction between private, interface, and external variables is similar to the distinction between internal, output, and input events in the formalism of I/O automata <ref> [21] </ref>. Asynchrony vs. synchrony. During the execution of the module P the variables in X P change their values in a sequence of rounds. Various models of reactivity propose different ways in which the variables are updated in a single round. <p> Interleaving models usually distinguish only between private variables, which can be updated by the system alone, and shared variables, which can be updated by both the system and the environment. This is a natural style for modeling asynchronous communication via a shared memory. Observable asynchrony (I/O automata <ref> [21] </ref>): Either the system updates the controlled variables, or the environment updates the external variables and the system updates the private variables in response. This is a natural style for modeling asynchronous communication via events or messages.
Reference: [22] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Asynchrony vs. synchrony. During the execution of the module P the variables in X P change their values in a sequence of rounds. Various models of reactivity propose different ways in which the variables are updated in a single round. Pure asynchrony (interleaving <ref> [20, 10, 17, 22] </ref>): Either the system performs an update, or the environment performs an update. Interleaving models usually distinguish only between private variables, which can be updated by the system alone, and shared variables, which can be updated by both the system and the environment.
Reference: [23] <author> K.L. McMillan. </author> <title> Symbolic Model Checking: An Approach to the State-explosion Problem. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Observable asynchrony (I/O automata [21]): Either the system updates the controlled variables, or the environment updates the external variables and the system updates the private variables in response. This is a natural style for modeling asynchronous communication via events or messages. Atomic synchrony (Mealy machines <ref> [23, 18] </ref>; Csp rendezvous [16, 24]): The system and the environment simultaneously update variables in an interdependent fashion. This is a natural style for modeling synchronous communication via events or messages.
Reference: [24] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: Observable asynchrony (I/O automata [21]): Either the system updates the controlled variables, or the environment updates the external variables and the system updates the private variables in response. This is a natural style for modeling asynchronous communication via events or messages. Atomic synchrony (Mealy machines [23, 18]; Csp rendezvous <ref> [16, 24] </ref>): The system and the environment simultaneously update variables in an interdependent fashion. This is a natural style for modeling synchronous communication via events or messages.
Reference: [25] <author> E.W. Stark. </author> <title> A proof technique for rely-guarantee properties. </title> <booktitle> In FST & TCS 85: Foundations of Software Technology and Theoretical Computer Science, Lecture Notes in Computer Science 206, </booktitle> <pages> pages 369-391. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <month> 39 </month>
Reference-contexts: In particular, P 1 may not implement Q 1 for all environments, but only if the environment behaves like P 2 , and vice versa. For such cases, an assume-guarantee proof rule is needed <ref> [25, 13, 2, 4] </ref>.
Reference: [26] <author> R.J. van Glabbeek. </author> <title> Comparative Concurrency Semantics and Refinement of Actions. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit te Amsterdam, </institution> <year> 1990. </year> <month> 40 </month>
Reference-contexts: of detail, such as gate operations, arithmetic operations, and processor instructions. 2 While spatial scalability is a standard feature of concurrency models, the concept of temporal scalability is inspired by the notion of multiform time in synchronous programming languages [14], and by the notion of action refinement in process algebras <ref> [26] </ref>. In verification, temporal scaling is usually performed in an informal, manual manner under the umbrella buzzword of "abstraction." We introduce temporal scaling as a modeling primitive, called next, that supports the formal construction and the automatic analysis of temporal abstractions.
References-found: 26

