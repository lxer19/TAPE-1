URL: http://www.neci.nj.nec.com/homepages/pny/papers/qccode/qccode.ps
Refering-URL: http://www.neci.nj.nec.com/homepages/pny/papers/qccode/main.html
Root-URL: 
Title: Solving the Minimum-Cost Matching Problem for Quasi-Convex Tours: An Efficient ANSI C Implementation 1 for
Author: Samuel R. Buss, Kirk G. Kanzelberger, David Robinson, Peter N. Yianilos, employed. 
Note: A constant-time is provided  As an additional  
Date: April 4, 1996  
Address: San Diego  San Diego  
Affiliation: University of California,  NEC Research Institute  University of California,  NEC Research Institute  
Abstract: We report an efficient and highly portable ANSI C implementation of the Buss-Yianilos minimum-cost matching algorithm for quasi-convex tours. A generic O(log n) time implementation of the required predicate is included, resulting in worst-case O(n log n) runtime for arbitrary cost functions. The test programs generate pseudorandom node patterns. To ensure correctness, a straightforward O(n 3 ) dynamic programming solution may be optionally enabled, and the test programs will compare its result with that of the Buss-Yianilos algorithm. The performance of the package is reported for several modern RISC pro cessors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. R. Buss and P. N. Yianilos, </author> <title> Linear and O(n log n) Time Minimum-Cost Matching Algorithms For Quasi-convex Tours (Extended Abstract), </title> <booktitle> in Proceedings of the 5th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1994, </year> <pages> pp. 65-76. 68 </pages>
Reference-contexts: 1 Introduction This technical memorandum describes an ANSI C implementation of the Buss-Yianilos minimum-cost matching algorithm for quasi-convex tours <ref> [1] </ref>. The algorithm is rather intricate but is free of large hidden constants. We report our implementation in the hope that this algorithm might sooner find practical application. We begin by reviewing the general problem. <p> The resulting matching is guaranteed to be a valid minimum-cost matching for the non-bipartite tour (see <ref> [1] </ref>). <p> See the example cost functions given in Appendices 2-4 for circular and linear tours. omega This is the function qc_match will use as the function. The purpose of the Boolean predicate is rather technical and is described in <ref> [1] </ref>. A generic function is supplied below that will work for any cost function. To use this generic , simply pass NULL as the omega argument to qc_match. Users can often improve performance for particular problem domains by writing their own constant-time functions. <p> Clearly, optimizing the cost calculation is paramount in efficient implementations for a particular problem domain. If costs were to be precomputed, then the cost function would reduce to a 2-D table lookup. Note that in certain problem domains, such as the string matching applications described in <ref> [1] </ref>, the costs (being a simple function of string displacement) are invariant over all problem instances, and can be stored in a 1-D array indexed by the (integral) displacement value. Subroutine linkage overhead can be dealt with by making the cost function a macro. <p> The heads of these lists are stored in LevelHeads, and a list is traversed by looking up each node's successor in LevelLinks. Since each node occurs in exactly one list, each node has exactly one successor, so a single array of "links" suffices. This "levelling process" is described in <ref> [1] </ref>. During the levelling process for line-like tours (specified with the linelike parameter to qc_match), any odd-size levels are forced to have even size through the creation of an "extra" node, as described in [1]. <p> This "levelling process" is described in <ref> [1] </ref>. During the levelling process for line-like tours (specified with the linelike parameter to qc_match), any odd-size levels are forced to have even size through the creation of an "extra" node, as described in [1]. This allows qc_match to handle both unbalanced line-like tours, and non-bipartite line-like tours of odd length. <p> It corresponds to Algorithm 2 of <ref> [1] </ref>. The subtour is retrieved by traversing the linked list corresponding to the level value. <p> Note that for line-like tours, the Buss-Yianilos algorithm's "second scan" through the tour is unnecessary and is therefore skipped altogether, thus improving performance. (The possibility of skipping the second scan for the line-like case is mentioned in <ref> [1] </ref>, but not reflected in the pseudocode.) hqcmatch.c 15i+ static void qc_match_alt ( int level, int matching [] ) - /* "Initialization" */ Psi = -1; M.rx = -1; L [RED].rx = -1; L [BLUE].lx = 0; L [BLUE].rx = -1; /* "Read Input into the M Deque" */ Xn = <p> [BLUE].lx)) - 20 Xn = pop_M_left (); if (Xn == L [Psi].l-&gt;x) - pop_L_left (Psi); - process_node (matching); Psi = -Psi; - /* "Windup Processing" */ while (M.lx &lt;= M.rx) - match_pair (matching); - 21 The internal function process_node below corresponds directly to the pseu- docode procedure Process_Node () in <ref> [1] </ref>, with two exceptions. First, [1] doesn't bother mentioning that one should check for at least two elements on the Ldeques before executing the while loops that reference those elements. <p> pop_M_left (); if (Xn == L [Psi].l-&gt;x) - pop_L_left (Psi); - process_node (matching); Psi = -Psi; - /* "Windup Processing" */ while (M.lx &lt;= M.rx) - match_pair (matching); - 21 The internal function process_node below corresponds directly to the pseu- docode procedure Process_Node () in <ref> [1] </ref>, with two exceptions. First, [1] doesn't bother mentioning that one should check for at least two elements on the Ldeques before executing the while loops that reference those elements. <p> The first three parameters are of type DEQNODE. A DEQNODE is a structure with two fields: an integer x, which is a particular node's index in the input array, and a real number i, which is that node's "I" value, as described in <ref> [1] </ref>. iLrm The deque node L iLr The deque node L iMr The deque node M R . input The array of input nodes. cost The cost function originally passed to qc_match. psi The value of [1]. <p> and a real number i, which is that node's "I" value, as described in <ref> [1] </ref>. iLrm The deque node L iLr The deque node L iMr The deque node M R . input The array of input nodes. cost The cost function originally passed to qc_match. psi The value of [1]. The return value of your omega function should be the (boolean) value of the predicate as defined by [1]. hqcmatch.c 15i+ static BOOLEAN generic_omega ( MNODE *iLrm, MNODE *iLr, MNODE *iMr, void *input [], COSTFUNC cost, int psi) - int ilow, ihigh, k; BOOLEAN pastxoverA, pastxoverB; void *np_Lrm, *np_Lr, *np_Mr, <p> L iLr The deque node L iMr The deque node M R . input The array of input nodes. cost The cost function originally passed to qc_match. psi The value of <ref> [1] </ref>. The return value of your omega function should be the (boolean) value of the predicate as defined by [1]. hqcmatch.c 15i+ static BOOLEAN generic_omega ( MNODE *iLrm, MNODE *iLr, MNODE *iMr, void *input [], COSTFUNC cost, int psi) - int ilow, ihigh, k; BOOLEAN pastxoverA, pastxoverB; void *np_Lrm, *np_Lr, *np_Mr, *np_Mk; ilow = M.lx; ihigh = (iLrm - &M.d [0]) + 1; /* Index of the node after iLrm <p> (stderr, ""t-n #"t"tSpecify number of problem instances <ref> [1] </ref>"n"); fprintf (stderr, ""t-r #"t"tSpecify seed for random generator [102]"n"); exit (1); - /* Process problem type key */ switch (TourType [0]) - case 'B': BalancedTours = TRUE; break; case 'U': BalancedTours = FALSE; break; default: err = TRUE; break; - switch (TourType [1]) - case 'R': AlternatingTours = FALSE; break; case 'A': AlternatingTours = TRUE; break; default: err = TRUE; break; - switch (TourType [2]) - case 'C': LineLike = FALSE; break; case 'L': LineLike = TRUE; break; default: err = TRUE; break; - if (!BalancedTours) - if (!LineLike) - fprintf (stderr, "Unbalanced <p> Clearly, for at least one such x 0 , the edge x $ x 0 must be part of a minimum-cost solution for [x; y]. In addition, we know by Lemma 4 of <ref> [1] </ref> that there exists a minimum-cost matching for [x; y] with no crossed edges. Let edgecost (x $ x 0 ) be the cost of the edge x $ x 0 .
References-found: 1

