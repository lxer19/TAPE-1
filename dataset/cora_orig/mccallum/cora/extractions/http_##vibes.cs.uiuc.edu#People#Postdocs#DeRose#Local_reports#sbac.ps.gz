URL: http://vibes.cs.uiuc.edu/People/Postdocs/DeRose/Local_reports/sbac.ps.gz
Refering-URL: http://vibes.cs.uiuc.edu/People/Postdocs/DeRose/falcon_publications.html
Root-URL: http://www.cs.uiuc.edu
Email: (fderose,paduag@cs.uiuc.edu)  
Title: Benchmarking FALCON's MATLAB-to-Fortran 90 Compiler on an SGI Power Challenge Esse artigo apresenta uma vis~ao
Author: Luiz De Rose and David Padua determina~c~ao do domnio das variaveis. Os testes de desempenho apresentados nesse artigo mostram que os programas gerados pelo compilador podem ser executados ate vezes m~ao para os mesmos algoritmos. 
Note: Resumo  This work was supported in part by Army contract DABT63-92-C-0033. This work is not necessarily representative of the positions or policies of the Army or the Government.  
Address: Urbana, Illinois 61801, U.S.A.  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: This paper presents an overview of the FALCON MATLAB-to-Fortran 90 compiler. FALCON is a programming environment for the development of high-performance scientific programs. It combines static and dynamic inference methods to translate MATLAB programs into Fortran 90. The static inference is supported with advanced value propagation techniques and symbolic algorithms for subscript analysis. The experiments presented in this paper show that FALCON's MATLAB compiler can generate code that performs more than 1000 times faster than the interpreted version of MATLAB and substantially faster than a commercially-available MATLAB compiler on one processor of an SGI Power Challenge. Furthermore, for most of the programs we have tested, the compiler-generated codes are as fast as the corresponding hand-written programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aho, A., Sethi, R., and Ullman, J. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1985. </year>
Reference-contexts: FALCON's MATLAB compiler uses conventional data-flow analysis <ref> [1] </ref>, and inference techniques that are either static inference mechanisms used to generate declarations at compile time, or dynamic strategies that are applied at execution time when a lack of statically available information prevents the automatic generation of a particular variable's declaration. <p> Examples of these additional techniques are advanced value propagation techniques and symbolic algorithms for subscript analysis [7]. FALCON's static inference algorithms are applied to a Static Single Assignment (SSA) [6] representation of the MATLAB program in the form of an abstract syntax tree (AST) <ref> [1] </ref>. Before the AST is generated, all function calls to M-files are inlined in the program.
Reference: [2] <author> Barrett, R., Berry, M., Chan, T., Demmel, J., Donato, J., Dongarra, J., Eijkhout, V., Pozo, R., Romine, C., and van der Vorst, H. </author> <title> Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods. </title> <publisher> SIAM, </publisher> <year> 1993. </year>
Reference-contexts: AQ This code uses the Simpson's rule in conjunction with adaptive quadrature [15] to numerically approximate the integral: Z 6 13 fl (x x 2 )e 2 dx: CG An iterative method for the solution of linear systems that uses the preconditioned Conjugate Gradient method with a diagonal preconditioner <ref> [2] </ref>. The input data is a 420 fi 420 stiffness matrix from the Harwell-Boeing Test Set (BCSSTK06). CN Anumerical approximation method for the solution of parabolic differential equations (the heat equation) [15]. The problem size is a 321 fi 321 grid. <p> RK Anumerical approximation method to solve ordinary differential equations. This program solves the orbit of a comet around the sun using a 4 th order Runge-Kutta method [11]. The program executes 3200 steps. QMR An iterative method for the solution of linear systems that uses the Quasi-Minimal Residual method <ref> [2] </ref>. The input data is the 420 fi 420 stiffness matrix BCSSTK06. SOR A third iterative method for the solution of linear systems that uses the Successive Overrelaxation method [2]. <p> QMR An iterative method for the solution of linear systems that uses the Quasi-Minimal Residual method <ref> [2] </ref>. The input data is the 420 fi 420 stiffness matrix BCSSTK06. SOR A third iterative method for the solution of linear systems that uses the Successive Overrelaxation method [2]. The input data is the 420fi420 stiffness matrix BCSSTK06. 3D Generates a three-dimension surface based on calculating Eigenvalues within a triply nested loop. 1 The dimensions of the surface are 51 fi 31 fi 21.
Reference: [3] <author> Blume, W., Doallo, R., Eigenmann, R., Grout, J., Hoeflinger, J., Lawrence, T., Lee, J., Padua, D., Paek, Y., Pottenger, B., Rauchwerger, L., and Tu, P. </author> <title> Parallel Programming with Polaris. </title> <booktitle> IEEE Computer 29, </booktitle> <month> 12 (December </month> <year> 1996), </year> <pages> 78-82. </pages>
Reference-contexts: Our ultimate goal is to generate parallel code by integrating FALCON with Polaris <ref> [3, 4] </ref>, a parallelizing compiler developed at Illinois.
Reference: [4] <author> Blume, W., Eigenmann, R., Faigin, K., Grout, J., Hoeflinger, J., Padua, D., Petersen, P., Pottenger, B., Rauchwerger, L., Tu, P., and Weather-ford, S. </author> <title> Polaris: Improving the Effectiveness of Parallelizing Compilers. In Languages and Compilers for Parallel Computing (August 1994), </title> <editor> K. Pingali, U. Banerjee, D. Gel-ernter, A. Nicolau, and D. Padua, Eds., </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 892, </volume> <publisher> Springer-Verlag, </publisher> <pages> pp. 141-154. </pages> <booktitle> 7th International Workshop, </booktitle> <address> Ithaca, NY, USA. </address>
Reference-contexts: Our ultimate goal is to generate parallel code by integrating FALCON with Polaris <ref> [3, 4] </ref>, a parallelizing compiler developed at Illinois.
Reference: [5] <author> Budd, T. </author> <title> An APL Compiler. </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The static inference mechanism was built upon techniques developed for SETL [16] and APL <ref> [5] </ref>, extended to deal with peculiarities of the MATLAB language. Also, additional techniques were used to improve accuracy and performance. Examples of these additional techniques are advanced value propagation techniques and symbolic algorithms for subscript analysis [7].
Reference: [6] <author> Cytron, R., Ferrante, J., Rosen, B. K., Wegman, M. N., and Zadeck, F. K. </author> <title> Efficiently Computing Static Single Assignment Form and the Control Dependence Graph. </title> <journal> ACM Transactions on Programming Language and Systems 13, </journal> <month> 4 (October </month> <year> 1991), </year> <pages> 451-490. </pages>
Reference-contexts: Also, additional techniques were used to improve accuracy and performance. Examples of these additional techniques are advanced value propagation techniques and symbolic algorithms for subscript analysis [7]. FALCON's static inference algorithms are applied to a Static Single Assignment (SSA) <ref> [6] </ref> representation of the MATLAB program in the form of an abstract syntax tree (AST) [1]. Before the AST is generated, all function calls to M-files are inlined in the program.
Reference: [7] <author> De Rose, L. A. </author> <title> Compiler Techniques for MATLAB Programs. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <year> 1996. </year>
Reference-contexts: Also, additional techniques were used to improve accuracy and performance. Examples of these additional techniques are advanced value propagation techniques and symbolic algorithms for subscript analysis <ref> [7] </ref>. FALCON's static inference algorithms are applied to a Static Single Assignment (SSA) [6] representation of the MATLAB program in the form of an abstract syntax tree (AST) [1]. Before the AST is generated, all function calls to M-files are inlined in the program. <p> For example, the outcome of p 1 A would be real if A 1, and complex otherwise. We refer to these expressions as ambiguous-typed expressions. In these cases, to improve the accuracy of the intrinsic type inference, we perform value-propagation analysis <ref> [7] </ref>. This value-propagation analysis keeps track statically of the range of possible values for each variable in the program. If this range of values is not sufficient to determine the intrinsic type of an ambiguous-typed expression, the output intrinsic type of the expression is promoted to complex. <p> Some optimizations in the shape inference mechanism are necessary to avoid the excessive number of tests and allocations. To this end, two static techniques were developed to support dynamic shape inference: coverage analysis and efficient placement of dynamic allocation <ref> [7] </ref>. The objective of the first technique is to determine whether an indexed array assignment may increase the size of the array. If this information is known at compile time, it is not necessary to generate an allocation test for the indexed assignment. <p> Finally, the speedup obtained by AQ resulted from the better handling of indexed assignments and the reallocation of matrices by the compiled program. However, according to a scalability study to determine how problem size affects the relative speed of the programs <ref> [7] </ref>, this improvement varies considerably, depending upon the number of reallocations required by the program, which is in turn dependent upon the input data set and the function being used for the numerical integration. 3.2 Comparison of Compiler Generated Programs with the Hand written Fortran 90 Programs generated versions. <p> In the hand-written code, due to a better knowledge of the algorithm, it was possible to optimize the reallocation process. 3.3 Comparison with the MathWorks MATLAB Compiler observe that all codes generated by FALCON ran faster than their MCC counterparts. In similar experiments, running on a SPARCstation 10 <ref> [7] </ref>, we observed that in three cases (CG, 2 MATLAB accepts complex variables in logical operations, but only take into consideration the real component of the variable. SOR, and QMR) MCC generated programs that ran slower than MATLAB, while all codes generated by FALCON ran faster than MATLAB.
Reference: [8] <author> DeRose, L., Gallivan, K., Gallopoulos, E., Marsolf, B., and Padua, D. </author> <title> FALCON: A MATLAB Interactive Restructuring Compiler. In Languages and Compilers for Parallel Computing (August 1995), </title> <editor> C.-H. Huang, P. Sadayappan, U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, Eds., </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 1033, </volume> <publisher> Springer-Verlag, </publisher> <pages> pp. 269-288. </pages> <booktitle> 8th International Workshop, </booktitle> <address> Columbus, Ohio. </address>
Reference-contexts: The situation in practice is that the overhead of reimplementing programs in a different language is sufficiently large that most people never get around to doing it. Clearly the best solution is for programmers to use a compiler that generates efficient code from MATLAB programs. FALCON <ref> [8, 9] </ref> is a programming environment for the development of scientific libraries and applications. It attempts to facilitate the development process by taking advantage of both the power of interactive array languages and the performance of compiled languages. One of FALCON's main components is a MATLAB to Fortran 90 compiler.
Reference: [9] <author> DeRose, L., Gallivan, K., Gallopoulos, E., Marsolf, B., and Padua, D. </author> <title> FALCON: An Environment for the Development of Scientific Libraries and Applications. </title> <booktitle> In Proc. of the KBUP95: First international workshop on Knowledge-Based systems for the (re)Use of Program libraries (Sophia Antipolis, </booktitle> <address> France, </address> <month> November </month> <year> 1995). </year>
Reference-contexts: The situation in practice is that the overhead of reimplementing programs in a different language is sufficiently large that most people never get around to doing it. Clearly the best solution is for programmers to use a compiler that generates efficient code from MATLAB programs. FALCON <ref> [8, 9] </ref> is a programming environment for the development of scientific libraries and applications. It attempts to facilitate the development process by taking advantage of both the power of interactive array languages and the performance of compiled languages. One of FALCON's main components is a MATLAB to Fortran 90 compiler.
Reference: [10] <author> Gallopoulos, E., Houstis, E., and Rice, J. R. </author> <title> Computer as Thinker/Doer: Problem-Solving Environments for Computational Science. </title> <booktitle> IEEE Computational Science & Engineering 1, 2 (Summer 1994), </booktitle> <pages> 11-23. </pages>
Reference-contexts: A convenient feature in these languages that facilitates prototyping of applications is the lack of specification of dimensions and intrinsic type of variables. Moreover, interactive array languages are usually contained within problem-solving environments which include easy-to-use facilities for displaying results both graphically and in tabular form <ref> [10] </ref>. Furthermore, the interactive nature of these languages provide an environment that tends to increase productivity in software development. The trade-off is that in order to provide this nicer programming environment, array languages are usually interpreted, with the resulting negative effect on performance.
Reference: [11] <author> Garcia, A. L. </author> <title> Numerical Methods for Physics. </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: The problem size is a 41 fi 41 grid. FD Anumerical approximation method for the solution of hyperbolic differential equations (the wave equation) [15]. The problem size is a 451 fi 451 grid. Ga Anumerical approximation method to solve the Poisson equations in two dimensions using the Galerkin method <ref> [11] </ref>. The problem size is a 40 fi 40 grid. IC Calculates the incomplete Cholesky factorization of a matrix. 1 The input data is a 400 fi 400 matrix. EC Anumerical approximation method to solve ordinary differential equations. <p> IC Calculates the incomplete Cholesky factorization of a matrix. 1 The input data is a 400 fi 400 matrix. EC Anumerical approximation method to solve ordinary differential equations. This program solves the orbit of a comet around the sun using the Euler-Cromer method <ref> [11] </ref>. The program executes 6240 steps. RK Anumerical approximation method to solve ordinary differential equations. This program solves the orbit of a comet around the sun using a 4 th order Runge-Kutta method [11]. The program executes 3200 steps. <p> This program solves the orbit of a comet around the sun using the Euler-Cromer method <ref> [11] </ref>. The program executes 6240 steps. RK Anumerical approximation method to solve ordinary differential equations. This program solves the orbit of a comet around the sun using a 4 th order Runge-Kutta method [11]. The program executes 3200 steps. QMR An iterative method for the solution of linear systems that uses the Quasi-Minimal Residual method [2]. The input data is the 420 fi 420 stiffness matrix BCSSTK06.
Reference: [12] <author> Gilman, L., and Rose, A. </author> <title> APL : An Interactive Approach. </title> <publisher> Wiley, </publisher> <year> 1984. </year>
Reference-contexts: The use of a very high-level language facilitates the development process by enhancing the ease of programming and portability of applications. Interactive array languages such as APL <ref> [12] </ref> and MATLAB [13] are powerful programming tools for the development of programs for numerical computation. A convenient feature in these languages that facilitates prototyping of applications is the lack of specification of dimensions and intrinsic type of variables.
Reference: [13] <author> The Math Works, Inc. </author> <title> MATLAB, High-Performance Numeric Computation and Visualization Software. User's Guide, </title> <year> 1992. </year>
Reference-contexts: The use of a very high-level language facilitates the development process by enhancing the ease of programming and portability of applications. Interactive array languages such as APL [12] and MATLAB <ref> [13] </ref> are powerful programming tools for the development of programs for numerical computation. A convenient feature in these languages that facilitates prototyping of applications is the lack of specification of dimensions and intrinsic type of variables. <p> Section 3 discuss experimental results. Finally, our conclusions are presented in Section 4. 2 FALCON's Compiler Overview MATLAB is a procedural language that operates on only one kind of data structure: a rectangular numerical matrix <ref> [13] </ref>. A MATLAB program consists of one or more Fortran-like statements which may involve function calls. There are two types of functions in MATLAB: built-ins and M-files. Built-in functions are intrinsic functions, such as sqrt, inv (for matrix inverse), and eig (for eigenvalues and eigenvectors).
Reference: [14] <institution> The Math Works, Inc. MATLAB Compiler, </institution> <year> 1995. </year>
Reference-contexts: This paper describes the main ideas of FALCON's MATLAB to Fortran 90 compiler and presents performance comparisons of Fortran 90 programs generated by FALCON against the interpreted MATLAB programs, C programs generated by a commercial MATLAB to C compiler (MCC) <ref> [14] </ref>, and Fortran 90 hand coded programs for the same algorithms. The rest of this paper is organized as follows: Section 2 presents an overview of FALCON's MATLAB to Fortran 90 compiler. Section 3 discuss experimental results. <p> The primary reason for these differences, is the lack of more in depth inference analyses by the MathWorks compiler. The MathWorks compiler does not perform use-coverage analysis and simplifies the handling of ambiguous-typed expressions by considering that they always return complex output. Moreover, as described in <ref> [14] </ref>, the code generated by MCC cannot handle complex values nor perform subscript checking. To solve these problems, the code generated by MCC calls MATLAB using "callback functions" provided in their library.
Reference: [15] <author> Mathews, J. H. </author> <title> Numerical Methods for Mathematics, </title> <booktitle> Science and Engineering, 2nd ed. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Where possible, the program parameters were set so that the time required to execute the program as a MATLAB M-file would be around 60 seconds. A brief description of each program is presented next. AQ This code uses the Simpson's rule in conjunction with adaptive quadrature <ref> [15] </ref> to numerically approximate the integral: Z 6 13 fl (x x 2 )e 2 dx: CG An iterative method for the solution of linear systems that uses the preconditioned Conjugate Gradient method with a diagonal preconditioner [2]. <p> The input data is a 420 fi 420 stiffness matrix from the Harwell-Boeing Test Set (BCSSTK06). CN Anumerical approximation method for the solution of parabolic differential equations (the heat equation) <ref> [15] </ref>. The problem size is a 321 fi 321 grid. Di An iterative method for the solution of Laplace's equations [15]. The problem size is a 41 fi 41 grid. FD Anumerical approximation method for the solution of hyperbolic differential equations (the wave equation) [15]. <p> CN Anumerical approximation method for the solution of parabolic differential equations (the heat equation) <ref> [15] </ref>. The problem size is a 321 fi 321 grid. Di An iterative method for the solution of Laplace's equations [15]. The problem size is a 41 fi 41 grid. FD Anumerical approximation method for the solution of hyperbolic differential equations (the wave equation) [15]. The problem size is a 451 fi 451 grid. <p> parabolic differential equations (the heat equation) <ref> [15] </ref>. The problem size is a 321 fi 321 grid. Di An iterative method for the solution of Laplace's equations [15]. The problem size is a 41 fi 41 grid. FD Anumerical approximation method for the solution of hyperbolic differential equations (the wave equation) [15]. The problem size is a 451 fi 451 grid. Ga Anumerical approximation method to solve the Poisson equations in two dimensions using the Galerkin method [11]. The problem size is a 40 fi 40 grid.
Reference: [16] <author> Schwartz, J. T. </author> <title> Automatic Data Structure Choice in a Language of a Very High Level. </title> <booktitle> Communications of the ACM 18 (1975), </booktitle> <pages> 722-728. </pages>
Reference-contexts: The static inference mechanism was built upon techniques developed for SETL <ref> [16] </ref> and APL [5], extended to deal with peculiarities of the MATLAB language. Also, additional techniques were used to improve accuracy and performance. Examples of these additional techniques are advanced value propagation techniques and symbolic algorithms for subscript analysis [7]. <p> Hence, the determination of the correct variable intrinsic type during compile time is very important for the efficiency of the generated code. The static mechanism for intrinsic type inference propagates intrinsic types through expressions using a type algebra similar to that described in <ref> [16] </ref> for SETL. For the case of logical operators, the result is always considered to be of intrinsic type logical. For the other operators and built-in functions, this algebra operates on the intrinsic type of MATLAB objects and is implemented using tables for all operations.
Reference: [17] <author> Tu, P., and Padua, D. </author> <title> Gated SSA-Based Demand-Driven Symbolic Analysis for Parallelizing Compilers. </title> <booktitle> In Proceedings of the 9th ACM International Conference on Supercomputing (Barcelona, </booktitle> <address> Spain, </address> <month> July </month> <year> 1995), </year> <pages> pp. 414-423. </pages>
Reference-contexts: If this information is known at compile time, it is not necessary to generate an allocation test for the indexed assignment. To determine whether there is definition coverage, we use a simplified version of a demand-driven symbolic analysis algorithm developed by Tu and Padua <ref> [17] </ref>. When an allocation test is required, the second technique is used to place the test where it will minimize the overhead. 3 Experimental Results To evaluate the overall effectiveness of the compiler, twelve MATLAB programs were tested.
References-found: 17

