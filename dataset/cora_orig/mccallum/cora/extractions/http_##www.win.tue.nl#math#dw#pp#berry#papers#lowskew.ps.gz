URL: http://www.win.tue.nl/math/dw/pp/berry/papers/lowskew.ps.gz
Refering-URL: http://www.win.tue.nl/math/dw/pp/berry/papers.html
Root-URL: http://www.win.tue.nl
Title: A Tight Lower Bound for Top-Down Skew Heaps  
Author: Berry Schoenmakers 
Note: G-sequence.  
Date: January, 1997  
Abstract: 5 + 1)=2 denotes the golden ratio. In this paper we present worst-case sequences of operations on top-down skew heaps in which each application of meld and delmin requires approximately log OE n comparisons. As the remaining heap operations require no comparisons, it then follows that the set of bounds is tight. The result relies on a particular class of self-recreating binary trees, which is related to a sequence known as Hofstadter's 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M.J. Fischer, </author> <title> Efficiency of equivalence algorithms, in: R.E. </title> <editor> Miller and J.W. Thatcher, eds., </editor> <publisher> Complexity of Computer Computations (Plenum Press, </publisher> <address> New York, </address> <year> 1972) </year> <month> 153-168. </month>
Reference-contexts: In the subsequent section we then show that these cases actually arise in applications of skew heaps, which implies that the bounds of Theorem 1 are tight. Our methods resemble the methods used to obtain lower bounds on the amortized complexity of union-find data structures (see, e.g., <ref> [1, 11, 12] </ref>), in which finding a suitable class of self-recreating (or, self-reproducing) trees also constitutes an important part of the solution.
Reference: [2] <author> D.R. Hofstadter, </author> <title> Godel, Escher, Bach: an Eternal Golden Braid, </title> <publisher> Basic Books (1979). </publisher>
Reference-contexts: k )) = f induction hypothesis g F k2 + R (n F k ) = f Lemma 2, using 0 n F k F k1 g R (n): 1 Through the on-line version of Sloane's "Encyclopedia of Integer Sequences" [10], we found out that we had rediscovered Hofstadter's G-sequence <ref> [2, p.137] </ref>, since function L (n) satisfies L (0) = 0 and L (n) = n L (L (n 1)), n 1 (use Lemmas 3 and 4). 3 2 Lemma 5 L (L (n) 1) = R (n 1), for n 1. Proof By induction on n.
Reference: [3] <author> D.W. Jones, </author> <title> Concurrent operations on priority queues, </title> <booktitle> Communications of the ACM 32 (1989) 132-137. </booktitle>
Reference-contexts: In actual implementations it is worthwhile to program meld performing a single pass over the rightmost paths, while at the same time building up the leftmost path (see [9]). As shown in <ref> [3] </ref>, it is then possible to get a simple implementation of mergeable priority queues that permits an interesting degree of concurrency.
Reference: [4] <author> A. Kaldewaij and B. Schoenmakers, </author> <title> The derivation of a tighter bound for top-down skew heaps, </title> <note> Information Processing Letters 37 (1991) 265-271. </note>
Reference-contexts: As shown in [3], it is then possible to get a simple implementation of mergeable priority queues that permits an interesting degree of concurrency. In <ref> [4, 8] </ref> the following upper bounds have been proven for the amortized costs of the operations in terms of comparisons (each unfolding of meld:x:y requires one comparison if fl Appears in Information Processing Letters 61 (5) 279-284, March 14, 1997 y DigiCash, Kruislaan 419, 1098 VA Amsterdam, Netherlands. berry@digicash.com 1 empty <p> It is also possible to define meld such that melding continues until both rightmost paths are completely traversed. The same bounds apply to this version of meld. (Actually, this version was analyzed in <ref> [4] </ref>, and in [8] it was shown that the same upper bounds hold for both versions.) It would be interesting to extend our results to bottom-up skew heaps as well. In [8] several sets of amortized bounds have been derived.
Reference: [5] <author> D. Knuth, </author> <title> The Art of Computing Programming, Volume 3, Sorting and Searching, </title> <publisher> Addison Wesley (1975). </publisher>
Reference-contexts: The golden trees can be seen as a supersequence of the Fibonacci trees <ref> [5, p.414] </ref> in the sense that a golden tree G n corresponds to the Fibonacci tree of order k whenever n = F k+1 1, k 0.
Reference: [6] <author> C. Okasaki, Amortization, </author> <title> lazy evaluation, and persistence: Lists with catenation via lazy linking, </title> <booktitle> in: IEEE Symposium on Foundations of Computer Science (October 1995) 646-654. </booktitle>
Reference-contexts: It is interesting to note that Okasaki has been able to remove this restriction of linear usage for many purely-functional data structures by making judicious use of lazy evaluation (see <ref> [6, 7] </ref>).
Reference: [7] <author> C. Okasaki, </author> <title> The role of lazy evaluation in amortized data structures, </title> <booktitle> in: ACM SIGPLAN International Conference on Functional Porgramming (May 1996) 62-72. </booktitle>
Reference-contexts: It is interesting to note that Okasaki has been able to remove this restriction of linear usage for many purely-functional data structures by making judicious use of lazy evaluation (see <ref> [6, 7] </ref>).
Reference: [8] <author> B. Schoenmakers, </author> <title> Data Structures and Amortized Complexity in a Functional Setting, </title> <type> Ph.D. thesis, </type> <institution> Eindhoven University of Technology, Eindhoven, </institution> <address> The Netherlands (1992). </address>
Reference-contexts: As shown in [3], it is then possible to get a simple implementation of mergeable priority queues that permits an interesting degree of concurrency. In <ref> [4, 8] </ref> the following upper bounds have been proven for the amortized costs of the operations in terms of comparisons (each unfolding of meld:x:y requires one comparison if fl Appears in Information Processing Letters 61 (5) 279-284, March 14, 1997 y DigiCash, Kruislaan 419, 1098 VA Amsterdam, Netherlands. berry@digicash.com 1 empty <p> These bounds improve upon the original bounds of Sleator and Tarjan [9] by more than a factor of two. As explained in <ref> [8, Chapter 5] </ref>, these bounds do only hold for functional programs that restrict the use of skew heaps to "linear usage" as if operations delmin and meld were destructive (e.g., using both delmin:x and meld:x:y in the same expression is not allowed). <p> It is interesting to note that Okasaki has been able to remove this restriction of linear usage for many purely-functional data structures by making judicious use of lazy evaluation (see [6, 7]). Theorem 1 (cf. <ref> [8, Lemma 9.2] </ref>) There exists a potential function such that the amortized costs for top-down skew heaps satisfy (in terms of comparisons): empty, isempty:x, and min:x cost 0, single:a costs at most 1, delmin:x costs at most log OE jxj, and meld:x:y costs at most log OE (jxj + jyj), where <p> It is also possible to define meld such that melding continues until both rightmost paths are completely traversed. The same bounds apply to this version of meld. (Actually, this version was analyzed in [4], and in <ref> [8] </ref> it was shown that the same upper bounds hold for both versions.) It would be interesting to extend our results to bottom-up skew heaps as well. In [8] several sets of amortized bounds have been derived. <p> The same bounds apply to this version of meld. (Actually, this version was analyzed in [4], and in <ref> [8] </ref> it was shown that the same upper bounds hold for both versions.) It would be interesting to extend our results to bottom-up skew heaps as well. In [8] several sets of amortized bounds have been derived. Just as for top-down skew heaps, operations empty, isempty, single, and min all take O (1) time. <p> In [8] several sets of amortized bounds have been derived. Just as for top-down skew heaps, operations empty, isempty, single, and min all take O (1) time. One set of bounds <ref> [8, Lemma 9.10] </ref> says that it is possible to amortize the costs (counting comparisons) such that the amortized costs are at most 3 for meld and at most 1 + 2log 2 jxj for delmin:x. <p> This improves upon the original 7 bounds by Sleator and Tarjan of [9] by a factor of two. A new parameterized set of bounds that is incomparable with previous bounds <ref> [8, Lemma 9.12] </ref> says that the amortized costs can be chosen at most 1 + "log fi (jxj + jyj) for meld:x:y and at most 1 + (" + 2)log fi jxj for delmin:x, where fi = ("+1) "+1 Picking " = OE in the latter case yields as upper bounds
Reference: [9] <author> D.D. Sleator and R.E. Tarjan, </author> <title> Self-adjusting heaps, </title> <note> SIAM Journal on Computing 15 (1986) 52-69. </note>
Reference-contexts: Figure 1 displays a purely functional version of top-down skew heaps, which is based on the original version of Sleator and Tarjan, the inventors of skew heaps <ref> [9] </ref>. Compared to the set of programs described in [9], however, we use operation single instead of an insert operation (note that insertion of a into heap x can be achieved as meld:(single:a):x). The efficiency of skew heaps is entirely due to the particular way operation meld is defined. <p> Figure 1 displays a purely functional version of top-down skew heaps, which is based on the original version of Sleator and Tarjan, the inventors of skew heaps <ref> [9] </ref>. Compared to the set of programs described in [9], however, we use operation single instead of an insert operation (note that insertion of a into heap x can be achieved as meld:(single:a):x). The efficiency of skew heaps is entirely due to the particular way operation meld is defined. <p> In actual implementations it is worthwhile to program meld performing a single pass over the rightmost paths, while at the same time building up the leftmost path (see <ref> [9] </ref>). As shown in [3], it is then possible to get a simple implementation of mergeable priority queues that permits an interesting degree of concurrency. <p> These bounds improve upon the original bounds of Sleator and Tarjan <ref> [9] </ref> by more than a factor of two. <p> This improves upon the original 7 bounds by Sleator and Tarjan of <ref> [9] </ref> by a factor of two.
Reference: [10] <author> N.J.A. Sloane and S. Plouffe, </author> <title> The Encyclopedia of Integer Sequences, </title> <publisher> Academic Press (1995). </publisher>
Reference-contexts: k2 g F k2 + L (L (n 1 F k )) = f induction hypothesis g F k2 + R (n F k ) = f Lemma 2, using 0 n F k F k1 g R (n): 1 Through the on-line version of Sloane's "Encyclopedia of Integer Sequences" <ref> [10] </ref>, we found out that we had rediscovered Hofstadter's G-sequence [2, p.137], since function L (n) satisfies L (0) = 0 and L (n) = n L (L (n 1)), n 1 (use Lemmas 3 and 4). 3 2 Lemma 5 L (L (n) 1) = R (n 1), for n
Reference: [11] <author> R.E. Tarjan, </author> <title> Efficiency of a good but not linear set union algorithm, </title> <note> Journal of the ACM 22 (1975) 215-225. </note>
Reference-contexts: In the subsequent section we then show that these cases actually arise in applications of skew heaps, which implies that the bounds of Theorem 1 are tight. Our methods resemble the methods used to obtain lower bounds on the amortized complexity of union-find data structures (see, e.g., <ref> [1, 11, 12] </ref>), in which finding a suitable class of self-recreating (or, self-reproducing) trees also constitutes an important part of the solution.
Reference: [12] <author> R.E. Tarjan and J. van Leeuwen, </author> <title> Worst-case analysis of set union algorithms, </title> <journal> Journal of the ACM 31 (1984) 245-281. </journal> <volume> 8 </volume>
Reference-contexts: In the subsequent section we then show that these cases actually arise in applications of skew heaps, which implies that the bounds of Theorem 1 are tight. Our methods resemble the methods used to obtain lower bounds on the amortized complexity of union-find data structures (see, e.g., <ref> [1, 11, 12] </ref>), in which finding a suitable class of self-recreating (or, self-reproducing) trees also constitutes an important part of the solution.
References-found: 12

