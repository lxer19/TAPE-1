URL: http://www.cs.virginia.edu/~nr/pubs/retargetable.ps
Refering-URL: http://www.cs.virginia.edu/~nr/activities.html
Root-URL: http://www.cs.virginia.edu
Email: nr@princeton.edu drh@princeton.edu  
Title: A Retargetable Debugger owes its retargetability to three techniques: getting help from the compiler, using
Author: Norman Ramsey and David R. Hanson 
Note: ldb  PostScript code that ldb later interprets; PostScript works well in this unusual context.  
Address: Princeton, NJ 08544  
Affiliation: Department of Computer Science, Princeton University  
Abstract: We are developing techniques for building retargetable debuggers. Our prototype, ldb, debugs C programs compiled for the MIPS R3000, Motorola 68020, SPARC, and VAX architectures. It can use a network to connect to faulty processes and can do cross-architecture debugging. ldb's total code size is about 16,000 lines, but it needs only 250-550 lines of machine-dependent code for each target. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Adams and S. S. Muchnick. Dbxtool: </author> <title> A window-based symbolic debugger for Sun workstations. </title> <journal> Software|Practice & Experience, </journal> <volume> 16(7) </volume> <pages> 653-669, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: When it reaches the root, it searches two PostScript dictionaries; one contains entries for symbols local to this 1 void fib (int n) 0 - 2 static int a [20]; 3 5 3 a [0] = a <ref> [1] </ref> = 1; 7 for ( 4 i=2; 5 i&lt;n; 7 i++) 9 - 11 for ( 8 j=0; 9 j&lt;n; 11 j++) 12 10 printf ("%d ", a [j]); 13 - 14 12 printf (""n"); 15 13 - Superscripts show stopping points. compilation unit (C statics) and the other contains <p> Like parts of the Cedar programming environment [23], ldb defines a client interface so that it can be used by other programs, e.g., user interfaces. If gdb and dbx defined client interfaces, it would simplify the implementation of better user interfaces (e.g., dbxtool <ref> [1] </ref>) and of higher-level debugging tools (e.g., Dalek [19]).
Reference: [2] <institution> Adobe Systems Incorporated, </institution> <address> Reading, Ma. </address> <note> PostScript Language Reference Manual, </note> <year> 1985. </year>
Reference-contexts: Although most of the benefits of using PostScript would also be obtained with Scheme, there are a number of reasons to prefer PostScript. Both the compiler and the expression server have to generate code for the debugger, and PostScript was designed to be generated by other programs <ref> [2, p. 2] </ref>. Our experience confirms that it is easy to generate PostScript; for example, the expression server code that rewrites lcc's intermediate representation into PostScript is only 124 lines of C, even though the intermediate representation has 112 operators. PostScript dictionaries provide a convenient notation for symbol-table entries.
Reference: [3] <author> P. C. Bates and J. C. Wileden. </author> <title> High-level debugging of distributed systems: The behavioral abstraction approach. </title> <journal> Journal of Systems and Software, </journal> <volume> 3(4) </volume> <pages> 255-264, </pages> <month> Dec. </month> <year> 1983. </year>
Reference-contexts: If gdb and dbx defined client interfaces, it would simplify the implementation of better user interfaces (e.g., dbxtool [1]) and of higher-level debugging tools (e.g., Dalek [19]). Event-action debugging techniques <ref> [3, 5, 19] </ref> seem well suited for implementation above ldb. ldb can debug on multiple architectures simultaneously, so it can process events from pieces of client-server applications that execute on different hardware. ldb's abstract memory model is low-level, close to the hardware.
Reference: [4] <author> B. Beander. </author> <title> VAX DEBUG: An interactive, symbolic, multilingual debugger. </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, in SIGPLAN Notices, </booktitle> <volume> 18(8) </volume> <pages> 173-179, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: DEC SRC's Vulcan debugger executes in the same address space as the compiler, sharing its annotated abstract syntax trees. The DICE debugger cooperates with an incremental compiler as part of an integrated environment [12]. Most debuggers, like VAX DEBUG <ref> [4] </ref> and dbx [15], are separate tools which communicate with the compiler only through symbol-table information. This information is placed in the object file in a machine-dependent format. ldb is like these debuggers, but it uses PostScript as a machine-independent, language-independent, symbol-table format. <p> This information is placed in the object file in a machine-dependent format. ldb is like these debuggers, but it uses PostScript as a machine-independent, language-independent, symbol-table format. Most debuggers must re-implement some facilities for every language that they support <ref> [4] </ref>.
Reference: [5] <author> B. Bruegge. </author> <title> Adaptability and Portability of Symbolic Debuggers. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> September </month> <year> 1985. </year>
Reference-contexts: If gdb and dbx defined client interfaces, it would simplify the implementation of better user interfaces (e.g., dbxtool [1]) and of higher-level debugging tools (e.g., Dalek [19]). Event-action debugging techniques <ref> [3, 5, 19] </ref> seem well suited for implementation above ldb. ldb can debug on multiple architectures simultaneously, so it can process events from pieces of client-server applications that execute on different hardware. ldb's abstract memory model is low-level, close to the hardware.
Reference: [6] <author> T. A. Cargill. </author> <title> Pi: A case study in object-oriented programming. </title> <journal> Proceedings of OOPSLA'86, SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 350-360, </pages> <month> Nov. </month> <year> 1986. </year>
Reference-contexts: The uplink values link symbol-table entries in a tree that handles nested scopes; using a tree avoids complications that can arise with the flattened tables emitted by typical assemblers and loaders <ref> [6] </ref>. Fig. 2 shows the tree for fib. The symbol-table entry for a procedure associates formals with the entry for the procedure's last parameter and loci with a PostScript array of stopping points.
Reference: [7] <author> D. Caswell and D. Black. </author> <title> Implementing a Mach debug-ger for multithreaded applications. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 25-39, </pages> <address> Wash-ington, DC, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Other remote debuggers use more complex interfaces [16]. One way to resume execution after a breakpoint is to return the overwritten instruction to memory, execute it by single-stepping the target machine, and replant the breakpoint <ref> [7] </ref>.
Reference: [8] <author> G. V. Cormack. </author> <title> A micro-kernel for concurrency in C. </title> <journal> Software|Practice & Experience, </journal> <volume> 18(5) </volume> <pages> 485-491, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: The target architecture determines the type of the signal handler and whether, as on the MIPS and SPARC, the struct sigcontext can serve as a context or, as on the VAX and 68020, another representation must be used <ref> [8] </ref>. On a big-endian MIPS, nub code for doubleword fetches and stores of saved floating-point registers must swap the words. 3 Each machine has a different one-line "pause" procedure, which stops the target program before it calls main.
Reference: [9] <institution> Digital Equipment Corporation, Maynard, MA. DDT|Dynamic Debugging Technique, </institution> <year> 1975. </year>
Reference-contexts: Other remote debuggers use more complex interfaces [16]. One way to resume execution after a breakpoint is to return the overwritten instruction to memory, execute it by single-stepping the target machine, and replant the breakpoint [7]. Single-stepping can be avoided by using a memory-patching implementation <ref> [9] </ref>; in that case, the overwritten instruction can be interpreted or transformed so that it can be correctly executed out of line [14]. 7 Discussion Work is divided between ldb and lcc to facilitate ldb's retargeting, even at the cost of sacrificing other features.
Reference: [10] <author> C. W. Fraser and D. R. Hanson. </author> <title> A code generation interface for ANSI C. </title> <journal> Software|Practice & Experience, </journal> <volume> 21(9) </volume> <pages> 963-988, </pages> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: The current abstract memory model (Sec. 4.1) uses three sizes of integers and three sizes of floating-point values. These values and types correspond closely to the values and types manipulated in lcc's intermediate representation <ref> [10] </ref>. The change simplified both ldb and the PostScript symbol tables, and it enables the expression server to share more code with the compiler front end. Floating point complicates cross-debugging. <p> We expect to use the existing nub protocol when adding procedure-call support. ldb's interface with the expression server is defined precisely by the relevant code, but our experience suggests that we can formulate a more abstract interface analogous to lcc's code generation interface <ref> [10] </ref>. The PostScript approach may extend gracefully to languages with more semantic complexity, like C++ and Modula-3.
Reference: [11] <author> C. W. Fraser and D. R. Hanson. </author> <title> A retargetable compiler for ANSI C. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(10) </volume> <pages> 29-43, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: We are developing techniques for building retargetable, multiple-target debuggers. This paper describes the design and implementation of ldb, a prototype retargetable debugger. ldb is a source-level debugger like gdb or dbx [15, 22]. It can be used with C programs compiled with lcc <ref> [11] </ref>, a retar-getable compiler that generates code for the MIPS R3000, Motorola 68020, SPARC, and VAX architectures. Users can set and remove breakpoints, start and stop programs, evaluate expressions, and make assignments to variables. ldb's contribution lies in implementing these operations in a retargetable way.
Reference: [12] <author> P. Fritzson. </author> <title> Symbolic debugging through incremental compilation in an integrated environment. </title> <journal> Journal of Systems and Software, </journal> <volume> 3(4) </volume> <pages> 285-294, </pages> <month> Dec. </month> <year> 1983. </year>
Reference-contexts: In some experimental systems, the compiler and debugger are tightly coupled. DEC SRC's Vulcan debugger executes in the same address space as the compiler, sharing its annotated abstract syntax trees. The DICE debugger cooperates with an incremental compiler as part of an integrated environment <ref> [12] </ref>. Most debuggers, like VAX DEBUG [4] and dbx [15], are separate tools which communicate with the compiler only through symbol-table information. This information is placed in the object file in a machine-dependent format. ldb is like these debuggers, but it uses PostScript as a machine-independent, language-independent, symbol-table format.
Reference: [13] <author> G. J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: The nub may be told to continue execution instead. The little-endian communication protocol between ldb and the nub has been used on all combinations of host and target byte orders and has been validated <ref> [13] </ref>. The nub supports several connection mechanisms, including debugging over the network. Since the nub is always loaded with the target program, it can catch unexpected faults and wait for a connection from ldb; the target program need not be a child of the debugger.
Reference: [14] <author> P. B. Kessler. </author> <title> Fast breakpoints: </title> <booktitle> Design and implementation. Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 25(6) </volume> <pages> 78-84, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Single-stepping can be avoided by using a memory-patching implementation [9]; in that case, the overwritten instruction can be interpreted or transformed so that it can be correctly executed out of line <ref> [14] </ref>. 7 Discussion Work is divided between ldb and lcc to facilitate ldb's retargeting, even at the cost of sacrificing other features. Having lcc insert no-ops at stopping points makes it possible to specify a breakpoint implementation in four lines, but makes target programs bigger and slower.
Reference: [15] <author> M. A. Linton. </author> <title> The evolution of Dbx. </title> <booktitle> In Proceedings of the Summer USENIX Conference, </booktitle> <pages> pages 211-220, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: For example, compiler writers use machine-independent intermediate representations and code-generator generators. We are developing techniques for building retargetable, multiple-target debuggers. This paper describes the design and implementation of ldb, a prototype retargetable debugger. ldb is a source-level debugger like gdb or dbx <ref> [15, 22] </ref>. It can be used with C programs compiled with lcc [11], a retar-getable compiler that generates code for the MIPS R3000, Motorola 68020, SPARC, and VAX architectures. <p> DEC SRC's Vulcan debugger executes in the same address space as the compiler, sharing its annotated abstract syntax trees. The DICE debugger cooperates with an incremental compiler as part of an integrated environment [12]. Most debuggers, like VAX DEBUG [4] and dbx <ref> [15] </ref>, are separate tools which communicate with the compiler only through symbol-table information. This information is placed in the object file in a machine-dependent format. ldb is like these debuggers, but it uses PostScript as a machine-independent, language-independent, symbol-table format. <p> The PostScript approach may extend gracefully to languages with more semantic complexity, like C++ and Modula-3. If dbx "stabs" are extended to describe a richer language, dbx itself must also be extended <ref> [15] </ref>, but ldb's capabilities can be extended by changing only the PostScript symbol tables; ldb itself need not change. ldb may well suit language implementations that compile to C, because the first compiler can emit PostScript code that manipulates the symbols emitted by the C compiler, producing one set of symbols <p> Implementing such facilities on top of breakpoints is complex, because the event that is expected may not be the one that occurs; a fault may occur when a breakpoint is expected. One solution is to make the debugger internals event-driven <ref> [15] </ref>. Exporting the mechanisms used to make the debugger event-driven would simplify the implementation of event-driven clients. Event-driven debugging subsumes conditional breakpoints as a special case. Sec. 4.2 describes the potential reliability and performance benefits of moving the nub into the kernel.
Reference: [16] <author> P. Maybee. </author> <title> pdb: A network oriented symbolic debugger. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 41-52, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: The important simplification in ldb is that the protocol and nub do not mention breakpoints or single-stepping; breakpoints are implemented entirely in ldb using fetches and stores without assuming the ability to single-step. Other remote debuggers use more complex interfaces <ref> [16] </ref>. One way to resume execution after a breakpoint is to return the overwritten instruction to memory, execute it by single-stepping the target machine, and replant the breakpoint [7].
Reference: [17] <institution> MIPS Computer Systems, Mountain View, CA. MIPS Assembly Language Programmer's Guide, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: The MIPS cannot use this implementation because it has no frame pointer. To be able to walk past a MIPS stack frame, ldb needs to know its size. That information is available, even for procedures without debugging symbols, in the MIPS runtime procedure table <ref> [17] </ref>. The MIPS implementation of ldb's linker interface uses the runtime procedure table to find the addresses and frame sizes of procedures, as well as other machine-dependent data. <p> additional cost is reasonable considering that the PostScript contains more information; it must be enough to enable the expression server to reconstruct the compiler's symbol-table and type information at debug time. 4 ldb's MIPS linker interface gets machine-dependent data from the runtime procedure table located in the target address space <ref> [17] </ref>, not from the object file. ldb's PostScript symbol tables can be manipulated by PostScript programs.
Reference: [18] <author> G. Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: The bulk of ldb, including its embedded PostScript interpreter, is written in Modula-3 <ref> [18] </ref>. The nub is written in C and assembly language, and much of the symbol table and expression evaluation support is written in PostScript. ldb's machine-dependent code depends only on which architecture the target program and its nub run on, not on which architecture ldb runs on. <p> When possible, machine-dependent function is specified by Modula-3 objects containing machine-dependent data but no code. Machine-independent classes 1 define the important abstractions in ldb; machine-dependent code is isolated in machine-dependent subtypes of such classes. (A similar technique has been used in implementations of I/O streams <ref> [18, p. 143] </ref>.) One such class is ldb's stack-frame abstraction. The machine-independent class includes the value of the program counter, the symbol-table entry of the corresponding procedure, and several machine-independent methods, which perform such tasks as computing scopes for name resolution.
Reference: [19] <author> R. A. Olsson, R. H. Crawford, and W. W. Ho. </author> <title> A dataflow approach to event-based debugging. </title> <journal> Software|Practice & Experience, </journal> <volume> 21(2) </volume> <pages> 209-229, </pages> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: If gdb and dbx defined client interfaces, it would simplify the implementation of better user interfaces (e.g., dbxtool [1]) and of higher-level debugging tools (e.g., Dalek <ref> [19] </ref>). Event-action debugging techniques [3, 5, 19] seem well suited for implementation above ldb. ldb can debug on multiple architectures simultaneously, so it can process events from pieces of client-server applications that execute on different hardware. ldb's abstract memory model is low-level, close to the hardware. <p> If gdb and dbx defined client interfaces, it would simplify the implementation of better user interfaces (e.g., dbxtool [1]) and of higher-level debugging tools (e.g., Dalek [19]). Event-action debugging techniques <ref> [3, 5, 19] </ref> seem well suited for implementation above ldb. ldb can debug on multiple architectures simultaneously, so it can process events from pieces of client-server applications that execute on different hardware. ldb's abstract memory model is low-level, close to the hardware.
Reference: [20] <author> J. K. Ousterhout. </author> <title> Tcl: An embeddable command language. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 133-146, </pages> <address> Washington, DC, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: When it reaches the root, it searches two PostScript dictionaries; one contains entries for symbols local to this 1 void fib (int n) 0 - 2 static int a <ref> [20] </ref>; 3 5 3 a [0] = a [1] = 1; 7 for ( 4 i=2; 5 i&lt;n; 7 i++) 9 - 11 for ( 8 j=0; 9 j&lt;n; 11 j++) 12 10 printf ("%d ", a [j]); 13 - 14 12 printf (""n"); 15 13 - Superscripts show stopping points. <p> The first is associated with statics in the current procedure's symbol-table entry; the second is associated with externs in the "top-level dictionary" for the program. a's symbol table entry is associated with S8: /S8 &lt;< /name (a) /type &lt;</decl (int %s <ref> [20] </ref>) /printer -ARRAY- ...&gt;> /sourcefile (fib.c) /sourcey 2 /sourcex 13 /kind (variable) /uplink S7 /where -(_stanchor__V2935334b_e288a) 8 LazyData &gt;> def uplink is associated with n's symbol-table entry, named S7. a is static, so its location is not determined until link time. <p> Designing a new language is best avoided, so we considered PostScript, Scheme, FORTH, and Tcl <ref> [20] </ref>. The latter two offer too few data types. Although most of the benefits of using PostScript would also be obtained with Scheme, there are a number of reasons to prefer PostScript.
Reference: [21] <author> D. D. Redell. </author> <title> Experience with Topaz TeleDebugging. </title> <booktitle> Proceedings of the ACM SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, in SIG-PLAN Notices, </booktitle> <volume> 24(1) </volume> <pages> 35-44, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The smaller and simpler the nub is, the more reasonable it is to consider putting it in the kernel. Finally, the nub interface should be small as well. A small interface will be easier to implement in a variety of environments, e.g., PCR [24] or the Topaz TeleDebug server <ref> [21] </ref>. 4.3 Retargeting ldb The debugger proper, the PostScript, and the nub all have machine-dependent parts, and each must be retargeted for a new machine. This section lists all such parts. <p> be built on top of ldb's PostScript symbol tables and abstract memories, but it, like the expression server, would need detailed knowledge of the contents of the symbol tables; it would not be isolated from the details of C. ldb's nub interface is derived from the Topaz TeleDebug protocol, TTD <ref> [21] </ref>, with some simplifications. ldb uses code outside the nub to connect to a target process. ldb's nub does not support multiple threads or multiple processors. ldb and TTD use different data models; ldb's model makes it easier to write code that is independent of tar-get byte order, but TTD's model
Reference: [22] <author> R. M. Stallman and R. H. Pesch. </author> <title> Using GDB: A guide to the GNU source-level debugger, GDB version 4.0. </title> <type> Technical report, </type> <institution> Free Software Foundation, </institution> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: For example, compiler writers use machine-independent intermediate representations and code-generator generators. We are developing techniques for building retargetable, multiple-target debuggers. This paper describes the design and implementation of ldb, a prototype retargetable debugger. ldb is a source-level debugger like gdb or dbx <ref> [15, 22] </ref>. It can be used with C programs compiled with lcc [11], a retar-getable compiler that generates code for the MIPS R3000, Motorola 68020, SPARC, and VAX architectures. <p> The name resolution algorithm could handle nested procedures, but not overloading. gdb 4.0 <ref> [22] </ref> supports 20 different target machines and many different versions of Unix, but of its more than 150,000 lines, over 47,000 are noted in the documentation as machine-dependent. This figure does not include over 10,000 lines that deal with machine-dependent object code formats like a.out and COFF.
Reference: [23] <author> D. C. Swinehart, P. T. Zellweger, R. J. Beach, and R. B. Hagmann. </author> <title> A structural view of the Cedar programming environment. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 419-490, </pages> <month> Oct. </month> <year> 1986. </year>
Reference-contexts: The long delay between the availability of MIPS machines and the availability of gdb for them also suggests that substantial effort is needed to retarget gdb. Like parts of the Cedar programming environment <ref> [23] </ref>, ldb defines a client interface so that it can be used by other programs, e.g., user interfaces. If gdb and dbx defined client interfaces, it would simplify the implementation of better user interfaces (e.g., dbxtool [1]) and of higher-level debugging tools (e.g., Dalek [19]). <p> By contrast, the Cedar debugger manipulates an abstract machine, whose abstractions are those of the Cedar programming language <ref> [23, x6.4] </ref>. The abstract machine's interface to Cedar data is used by clients other than the debugger, including a user interface tool that lets users manipulate fields (including procedures) of records chosen dynamically.

References-found: 23

