URL: http://www.cis.ohio-state.edu/~gb/Papers/Usenix-C++.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~gb/Papers/
Root-URL: 
Email: gb@cs.purdue.edu russo@cs.purdue.edu  
Title: Implementing Signatures for C  
Author: Gerald Baumgartner Vincent F. Russo 
Address: West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences Purdue University  
Abstract: In this paper we overview the design and implementation of a language extension to C ++ for abstracting types and for decoupling subtyping and inheritance. This extension gives the user more of the flexibility of dynamic typing while retaining the efficiency and security of static typing. We discuss the syntax and semantics of this language extension, show examples of its use, and present and analyze the cost of three different implementation techniques: a preprocessor to a C ++ compiler, an implementation in the front end of a C ++ compiler, and a low-level back-end based implementation.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Kamal Abdali, Guy W. Cherry, and Neil Soiffer. </author> <title> "An object-oriented approach to algebra system design." </title> <editor> In Bruce W. Char (ed.): </editor> <booktitle> Proceedings of the 1986 Symposium on Symbolic and Algebraic Computation (SYMSAC '86), </booktitle> <address> Waterloo, Ontario, Canada, </address> <month> 21-23 July </month> <year> 1986, </year> <pages> pp. 24-30. </pages> <institution> Association for Computing Machinery, </institution> <year> 1986. </year>
Reference-contexts: There is no syntax for selectively renaming functions depending on their return and argument types. While this would be possible, we feel it would make the syntax of views too complicated. A similar renaming mechanism can be found in the computer algebra system Views implemented in Smalltalk <ref> [1, 2] </ref> or in the algebraic specification language OBJ3 [13]. 3.6 Constants As mentioned in the definition of the conformance check, a signature can contain constant declarations. Unlike constant declarations elsewhere, constants in signatures need not be initialized. Instead, they are treated as nullary functions. <p> It is simple to use the display list. For example, int main (void); - displayList [0] = new OpenLookCircle; displayList <ref> [1] </ref> = new MotifSquare; // ... displayList [0]-&gt;display (); // executes OpenLookCircle::display displayList [1]-&gt;display (); // executes MotifSquare::show 8 return 0; - where OpenLookCircle is a subclass of OpenLookObject and MotifSquare is a subclass of Motif-Object. We can even make this example more compelling. <p> We can even make this example more compelling. Consider the possibility that the Motif class hierarchy used the name show rather than display for its rendering operation. We would simply need to add a view cast when assigning an object from the Motif hierarchy to our display list: displayList <ref> [1] </ref> = (XWindowsObject *; display = show) new MotifSquare; 4.2 Signatures to Separate Type and Class Hierarchies The solution to model the type and implementation hierarchies in the computer algebra example is to use signatures instead of abstract virtual classes for the type hierarchy: signature general_matrix - /* ... */ -;
Reference: [2] <author> S. Kamal Abdali, Guy W. Cherry, and Neil Soiffer. </author> <title> "A Smalltalk system for algebraic manipulation." </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> SIG-PLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 277-283. </pages>
Reference-contexts: There is no syntax for selectively renaming functions depending on their return and argument types. While this would be possible, we feel it would make the syntax of views too complicated. A similar renaming mechanism can be found in the computer algebra system Views implemented in Smalltalk <ref> [1, 2] </ref> or in the algebraic specification language OBJ3 [13]. 3.6 Constants As mentioned in the definition of the conformance check, a signature can contain constant declarations. Unlike constant declarations elsewhere, constants in signatures need not be initialized. Instead, they are treated as nullary functions.
Reference: [3] <author> Pierre America and Frank van der Linden. </author> <title> "A parallel object-oriented language with inheritance and subtyping." </title> <booktitle> In Proceedings of OOPSLA '90 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Ottawa, Canada, </address> <month> 21-25 October </month> <year> 1990. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 25, No. 10, </volume> <month> October </month> <year> 1990, </year> <pages> pp. 161-168. </pages>
Reference-contexts: is related to types in Russel [11], ML's signatures [19, 20], Haskell's type classes [16], definition modules in Modula-2 [26], interface modules in Modula-3 [8], abstract types in Emerald [6], type modules in Trellis/Owl [21], categories in Axiom [17] and its predecessor Scratchpad II [24, 25], and types in POOL-I <ref> [3] </ref>. The type system of C ++ with signatures comes closest to those of Axiom and POOL-I. Russel, ML, Haskell, and Modula-2 don't have class types, Modula-3 only has interfaces for modules but not for classes.
Reference: [4] <author> Gerald Baumgartner and Vincent F. Russo. </author> <title> Signatures: A C ++ Extension for Type Abstraction and Subtype Polymorphism. </title> <note> To appear in Software: Practice & Experience, </note> <year> 1994. </year>
Reference-contexts: The primary intent of this paper is to detail these implementation techniques. For this reason, the motivation and language specifications are of necessity brief. The reader interested in a more detailed motivation and complete syntax and semantics is referred to <ref> [4] </ref>. 2 Motivation Using inheritance as a subtyping mechanism suffers from three specific problems: 1. In some cases, it is difficult (if not impossible) to retroactively introduce abstract superclasses for the purpose of type abstraction. 2. <p> later time without altering any implementations. 2.2 Separation of Type and Class Hierarchies Another problem with a single class hierarchy defining both abstract data types and their implementations is that as the type hierarchy becomes more complex, it might become necessary to duplicate code, as an example from computer algebra <ref> [5, 4] </ref> demonstrates. Consider the abstract type general matrix with subtypes negative definite matrix and orthogonal matrix. Both subtypes have additional functions, such as inverse (), which are not present in general matrices. <p> For information on those constructs, as well as for more details on the semantics of signatures, see <ref> [4] </ref>. 3 defines an abstract type T with operations (member functions) f, g, and h. The specific difference from a class declaration is that only type declarations (typedefs), constant declarations, member function declarations, operator declarations, and conversion operator declarations are allowed within a signature declaration. <p> By using inheritance of signatures, as defined in <ref> [4] </ref>, we can simplify the definition of the latter two signatures.
Reference: [5] <author> Gerald Baumgartner and Ryan D. Stansifer. </author> <title> A Proposal to Study Type Systems for Computer Algebra. </title> <type> RISC-Linz Report 90-87.0, </type> <institution> Research Institute for Symbolic Computation, Linz, Aus-tria, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: later time without altering any implementations. 2.2 Separation of Type and Class Hierarchies Another problem with a single class hierarchy defining both abstract data types and their implementations is that as the type hierarchy becomes more complex, it might become necessary to duplicate code, as an example from computer algebra <ref> [5, 4] </ref> demonstrates. Consider the abstract type general matrix with subtypes negative definite matrix and orthogonal matrix. Both subtypes have additional functions, such as inverse (), which are not present in general matrices.
Reference: [6] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> "Object structure in the Emerald system." </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> SIG-PLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 78-86. </pages>
Reference-contexts: It is related to types in Russel [11], ML's signatures [19, 20], Haskell's type classes [16], definition modules in Modula-2 [26], interface modules in Modula-3 [8], abstract types in Emerald <ref> [6] </ref>, type modules in Trellis/Owl [21], categories in Axiom [17] and its predecessor Scratchpad II [24, 25], and types in POOL-I [3]. The type system of C ++ with signatures comes closest to those of Axiom and POOL-I.
Reference: [7] <author> Peter S. Canning, William R. Cook, Walter L. Hill, and Walter G. Olthoff. </author> <title> "Interfaces for strongly-typed object-oriented programming." </title> <booktitle> In Proceedings of OOPSLA '89 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> New Orleans, Louisiana, </address> <month> 1-6 October </month> <year> 1989. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 24, No. 10, </volume> <month> October </month> <year> 1989, </year> <pages> pp. 457-467. </pages>
Reference-contexts: The solution is to factor out the implementation aspect of classes into prototypical objects [18] or to factor out the type aspect into interfaces <ref> [7, 9] </ref>. 1 In C ++ , the task of creating these leaf and forwarding classes can be simplified using templates. 2 2.3 Implementation of Conflicting Type and Class Hierarchies Often the abstract type hierarchy and the implementation class hierarchy cannot be made to agree.
Reference: [8] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, Greg Nelson. </author> <title> "Modula-3 Language Definition." </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 27, No. 8, </volume> <month> August </month> <year> 1992, </year> <pages> pp. 15-43. </pages>
Reference-contexts: It is related to types in Russel [11], ML's signatures [19, 20], Haskell's type classes [16], definition modules in Modula-2 [26], interface modules in Modula-3 <ref> [8] </ref>, abstract types in Emerald [6], type modules in Trellis/Owl [21], categories in Axiom [17] and its predecessor Scratchpad II [24, 25], and types in POOL-I [3]. The type system of C ++ with signatures comes closest to those of Axiom and POOL-I.
Reference: [9] <author> William R. Cook. </author> <title> "Interfaces and specifications for the Smalltalk-80 collection classes." </title> <booktitle> In Proceedings of OOPSLA '92 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Vancouver, Canada, </address> <month> 18-22 October </month> <year> 1992. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 27, No. 10, </volume> <month> October </month> <year> 1992, </year> <pages> pp. 1-15. </pages>
Reference-contexts: The solution is to factor out the implementation aspect of classes into prototypical objects [18] or to factor out the type aspect into interfaces <ref> [7, 9] </ref>. 1 In C ++ , the task of creating these leaf and forwarding classes can be simplified using templates. 2 2.3 Implementation of Conflicting Type and Class Hierarchies Often the abstract type hierarchy and the implementation class hierarchy cannot be made to agree.
Reference: [10] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> "Inheritance is not subtyping." </title> <booktitle> In Proceedings of 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <month> 17-19 January </month> <year> 1990, </year> <pages> pp. 125-135. </pages>
Reference-contexts: A doubly ended queue is implemented naturally as a doubly linked list. A trivial implementation of queue would be to copy the doubly ended queue implementation through inheritance and remove, or ignore, the additional operations. In <ref> [10] </ref> it is argued that in order for a type system to be sound it should not be possible to use inheritance for subtyping purposes and also allow the removal of operations.
Reference: [11] <author> James Donahue and Alan Demers. </author> <title> "Data types are values." </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 7, No. 3, </volume> <month> July </month> <year> 1985, </year> <pages> pp. 426-445. </pages>
Reference-contexts: It is related to types in Russel <ref> [11] </ref>, ML's signatures [19, 20], Haskell's type classes [16], definition modules in Modula-2 [26], interface modules in Modula-3 [8], abstract types in Emerald [6], type modules in Trellis/Owl [21], categories in Axiom [17] and its predecessor Scratchpad II [24, 25], and types in POOL-I [3].
Reference: [12] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C ++ Reference Manual. </title> <address> Reading, Massachusetts: </address> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: In the absence of a more complex type hierarchy, the type T in the above example could have been defined as an abstract class, i.e., a class containing only pure virtual member function declarations <ref> [12] </ref>. The behavior of both implementations would be similar except that classes implementing the abstract class's interface need to explicitly code that fact by inheriting from the abstract class. When using signatures to specify abstract types, this relationship can be inferred by them compiler. <p> If several member functions of C conform to one member function of S, we find the one that conforms best using a variant of C ++ 's algorithm for finding the function declaration that best matches the call of an overloaded function <ref> [12] </ref>. If a member function of C conforms to several member functions of S, an error is reported by the compiler.
Reference: [13] <author> J.A. Goguen and T. Winkler. </author> <title> Introducing OBJ3. </title> <type> Technical Report CSL-88-9, </type> <institution> SRI International, </institution> <year> 1988. </year>
Reference-contexts: While this would be possible, we feel it would make the syntax of views too complicated. A similar renaming mechanism can be found in the computer algebra system Views implemented in Smalltalk [1, 2] or in the algebraic specification language OBJ3 <ref> [13] </ref>. 3.6 Constants As mentioned in the definition of the conformance check, a signature can contain constant declarations. Unlike constant declarations elsewhere, constants in signatures need not be initialized. Instead, they are treated as nullary functions.
Reference: [14] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <address> Reading, Massachusetts: </address> <publisher> Addison-Wesley, </publisher> <year> 1983. </year> <month> 19 </month>
Reference-contexts: Since permutation matrices are positive definite, this would violate the type hierarchy. The alternative of having a separate class sparse negative definite matrix is not satisfying either. Similar arguments have been given in the literature to show that the collection class hierarchy of Smalltalk-80 <ref> [14] </ref> is not appropriate as a basis for subtyping. While the problem does not arise with dynamic typing, it becomes an issue when trying to make Smalltalk-80 statically typed while retaining most of its flexibility.
Reference: [15] <author> Elana D. Granston and Vincent F. Russo. </author> <booktitle> "Signature-based polymorphism for C ++ ." In Pro--ceedings of USENIX C ++ Technical Conference, </booktitle> <address> Washington, D.C., </address> <year> 1991. </year>
Reference-contexts: We will show how signatures allow us to overcome these problems without a major overhaul of the C ++ type system. 1 2.1 Retroactive Type Abstraction A practical example of the need to introduce type abstractions of existing class hierarchies is illustrated in <ref> [15] </ref>. Summarizing their presentation, suppose we have two libraries containing hierarchies of classes for X-Windows display objects. One hierarchy is rooted at OpenLookObject and the other at MotifObject. <p> The key difference is that a signature declaration contains only interface descriptions. For example, the signature declaration signature T - int * f (); T & h (int *); 2 The additional features of signature inheritance, the sigof construct (as in <ref> [15] </ref>), and opaque types are left out since they only affect the type checking phase of the compiler. For information on those constructs, as well as for more details on the semantics of signatures, see [4]. 3 defines an abstract type T with operations (member functions) f, g, and h. <p> The thunks contain the appropriate code to set the this pointer correctly and branch to the class member function or perform a virtual function call. Such an implementation was proposed in <ref> [15] </ref>. Each thunk only contains the code necessary to call one specific class member function. We do not need to test any flags but just branch to the thunk, which does the right thing for the member function we want to call. <p> In the thunk implementation described in <ref> [15] </ref>, copying of signature table entries is avoided by having the optr field of the LHS signature pointer point to the RHS signature pointer instead of pointing to the object. This makes assignment more efficient but requires multiple indirections in a signature member function call. <p> This makes assignment more efficient but requires multiple indirections in a signature member function call. Furthermore, to allow assigning a local signature pointer to a non-local signature pointer the solution in <ref> [15] </ref> has to be corrected and signature pointers have to be allocated on the heap. There is one more detail in assigning a signature pointer to another signature pointer.
Reference: [16] <editor> Paul Hudak et al. </editor> <title> "Report on the programming Language Haskell: A non-strict, purely functional language, version 1.2." </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 27, No. 5, </volume> <month> May </month> <year> 1992, </year> <note> Section R. </note>
Reference-contexts: It is related to types in Russel [11], ML's signatures [19, 20], Haskell's type classes <ref> [16] </ref>, definition modules in Modula-2 [26], interface modules in Modula-3 [8], abstract types in Emerald [6], type modules in Trellis/Owl [21], categories in Axiom [17] and its predecessor Scratchpad II [24, 25], and types in POOL-I [3].
Reference: [17] <author> Richard D. Jenks and Robert S. Sutor. </author> <title> AXIOM: The Scientific Computation System. </title> <address> New York: </address> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: It is related to types in Russel [11], ML's signatures [19, 20], Haskell's type classes [16], definition modules in Modula-2 [26], interface modules in Modula-3 [8], abstract types in Emerald [6], type modules in Trellis/Owl [21], categories in Axiom <ref> [17] </ref> and its predecessor Scratchpad II [24, 25], and types in POOL-I [3]. The type system of C ++ with signatures comes closest to those of Axiom and POOL-I. Russel, ML, Haskell, and Modula-2 don't have class types, Modula-3 only has interfaces for modules but not for classes.
Reference: [18] <author> Wilf R. LaLonde, Dave A. Thomas, and John R. Pugh. </author> <title> "An exemplar based Smalltalk." </title> <booktitle> In Proceedings of OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 322-330. </pages>
Reference-contexts: While the problem does not arise with dynamic typing, it becomes an issue when trying to make Smalltalk-80 statically typed while retaining most of its flexibility. The solution is to factor out the implementation aspect of classes into prototypical objects <ref> [18] </ref> or to factor out the type aspect into interfaces [7, 9]. 1 In C ++ , the task of creating these leaf and forwarding classes can be simplified using templates. 2 2.3 Implementation of Conflicting Type and Class Hierarchies Often the abstract type hierarchy and the implementation class hierarchy cannot
Reference: [19] <author> David B. MacQueen. </author> <title> "Modules for Standard ML." </title> <journal> Polymorphism, </journal> <volume> Vol. 2, No. 2, </volume> <year> 1985. </year>
Reference-contexts: It is related to types in Russel [11], ML's signatures <ref> [19, 20] </ref>, Haskell's type classes [16], definition modules in Modula-2 [26], interface modules in Modula-3 [8], abstract types in Emerald [6], type modules in Trellis/Owl [21], categories in Axiom [17] and its predecessor Scratchpad II [24, 25], and types in POOL-I [3].
Reference: [20] <author> David B. MacQueen. </author> <title> "An implementation of Standard ML modules." </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Snowbird, Utah, </address> <month> 25-27 July </month> <year> 1988. </year> <journal> Association for Computing Machinery, </journal> <pages> pp. 212-223. </pages>
Reference-contexts: It is related to types in Russel [11], ML's signatures <ref> [19, 20] </ref>, Haskell's type classes [16], definition modules in Modula-2 [26], interface modules in Modula-3 [8], abstract types in Emerald [6], type modules in Trellis/Owl [21], categories in Axiom [17] and its predecessor Scratchpad II [24, 25], and types in POOL-I [3].
Reference: [21] <author> Craig Schaffert et al. </author> <title> "An introduction to Trellis/Owl." </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September-2 October </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 9-16. </pages>
Reference-contexts: It is related to types in Russel [11], ML's signatures [19, 20], Haskell's type classes [16], definition modules in Modula-2 [26], interface modules in Modula-3 [8], abstract types in Emerald [6], type modules in Trellis/Owl <ref> [21] </ref>, categories in Axiom [17] and its predecessor Scratchpad II [24, 25], and types in POOL-I [3]. The type system of C ++ with signatures comes closest to those of Axiom and POOL-I.
Reference: [22] <author> Alan Snyder. </author> <title> "Encapsulation and inheritance in object-oriented programming languages." </title> <booktitle> In Proceedings of OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 38-45. </pages>
Reference-contexts: An example similar to one in <ref> [22] </ref> illustrates this point. Consider two abstract types queue and dequeue (doubly ended queue). The abstract type dequeue provides the same operations as queue and two additional operations for enqueuing at the head and for dequeuing from the tail of the queue. Therefore, dequeue is a subtype of queue.
Reference: [23] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Cambridge, Massachusetts: Free Software Foundation, </title> <editor> V. 2.3, </editor> <month> 16 December </month> <year> 1992. </year>
Reference-contexts: This method has been implemented in the GNU C ++ compiler <ref> [23] </ref> as a modification of GCC's C ++ front end, cc1plus. The same techniques are equally applicable to AT&T's cfront, or other C ++ compilers.
Reference: [24] <author> Robert S. Sutor and Richard D. Jenks. </author> <title> "The type inference and coercion facilities in the Scratch-pad II interpreter." </title> <booktitle> In Proceedings of SIGPLAN '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <month> 24-26 June </month> <year> 1987, </year> <title> St. Paul, Minnesota. </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 22, No. 7, </volume> <year> 1987, </year> <pages> pp. 56-63. </pages>
Reference-contexts: It is related to types in Russel [11], ML's signatures [19, 20], Haskell's type classes [16], definition modules in Modula-2 [26], interface modules in Modula-3 [8], abstract types in Emerald [6], type modules in Trellis/Owl [21], categories in Axiom [17] and its predecessor Scratchpad II <ref> [24, 25] </ref>, and types in POOL-I [3]. The type system of C ++ with signatures comes closest to those of Axiom and POOL-I. Russel, ML, Haskell, and Modula-2 don't have class types, Modula-3 only has interfaces for modules but not for classes.
Reference: [25] <author> Stephen M. Watt, Richard D. Jenks, Robert S. Sutor, and Barry M. Trager. </author> <title> "The Scratchpad II Type System: Domains and Subdomains." </title> <editor> In Alfonso M. Miola (ed.): </editor> <title> Computing Tools for Scientific Problem Solving. </title> <publisher> London: Academic Press, </publisher> <year> 1990, </year> <pages> pp. 63-82. </pages>
Reference-contexts: It is related to types in Russel [11], ML's signatures [19, 20], Haskell's type classes [16], definition modules in Modula-2 [26], interface modules in Modula-3 [8], abstract types in Emerald [6], type modules in Trellis/Owl [21], categories in Axiom [17] and its predecessor Scratchpad II <ref> [24, 25] </ref>, and types in POOL-I [3]. The type system of C ++ with signatures comes closest to those of Axiom and POOL-I. Russel, ML, Haskell, and Modula-2 don't have class types, Modula-3 only has interfaces for modules but not for classes.
Reference: [26] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <booktitle> Texts and Monographs in Computer Science. </booktitle> <address> Berlin-Heidelberg, Germany: </address> <publisher> Springer Verlag, </publisher> <year> 1985. </year> <month> 20 </month>
Reference-contexts: It is related to types in Russel [11], ML's signatures [19, 20], Haskell's type classes [16], definition modules in Modula-2 <ref> [26] </ref>, interface modules in Modula-3 [8], abstract types in Emerald [6], type modules in Trellis/Owl [21], categories in Axiom [17] and its predecessor Scratchpad II [24, 25], and types in POOL-I [3]. The type system of C ++ with signatures comes closest to those of Axiom and POOL-I.
References-found: 26

