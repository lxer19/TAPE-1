URL: http://www.cs.man.ac.uk/~kung-kiu/pub/jlp99.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Title: STEADFAST LOGIC PROGRAMS  
Author: KUNG-KIU LAU, MARIO ORNAGHI AND STEN- AKE T ARNLUND 
Date: 1994:19, 20:1-679 1  
Note: J. LOGIC PROGRAMMING  
Abstract: We present the notion of steadfastness that at once embodies modularity, reusability, and formal correctness. A steadfast program is an open program with parameters, which is parametrically correct in the sense that it will always be correct with respect to its (open) specification whenever its parameters are computed correctly. Thus, a steadfast program is correct, modular and reusable. Therefore, steadfastness provides a basis for hierarchical construction of correct reusable modules. We first introduce the idea of steadfastness in an informal manner. Then we give a model-theoretic characterisation of steadfastness, followed by an operational semantics based on the (open) completion of an open program. Finally, we apply our general results to program correctness with respect to parametric specifications. / 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K.R. Apt. </author> <title> Logic Programming. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science Vol. B, </booktitle> <pages> pages 493-574, </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: Comp contains 8x : :p (x), for every open predicate p in P . In contrast, Ocomp does not contain axioms for the open predicates, since they are considered to be parameters. In addition, Comp contains Clark's equality theory CET <ref> [1, 6, 25] </ref>, which is left out of Ocomp. We do not assume any fixed equality theory, since the meaning of the constant and function symbols is pre-defined by the (open) framework F. <p> Then j P + j= Ocomp + (P ), j P j= Ocomp (P ) and, for every model m of Ocomp (P ), j P + ffi m ffi j P We omit the proofs for these propositions because they are mostly an adaptation of known results (see e.g. <ref> [1] </ref>) to j-models. In Section 5, we will introduce open SLD -derivations and we will show that j P + coincides with the success set, and j P is contained in the finite failure set, of P with respect to j. This will complete the picture. <p> A completeness result does not hold unconditionally for j-failure. Indeed there are programs and pre-interpretations such that j P ae ffi j P ff (see <ref> [1] </ref> for examples of Herbrand models). However, there are conditional completeness results, such as the following (we omit the easy proof): Theorem 5.4. (Completeness of j-failure) Let P : ffi ( be an open -program. <p> Our treatment of steadfastness, given for definite logic programs, immediately extends to constraint logic programs. Moreover, it can be easily extended to terminating normal programs. In fact, we have extended a kernel of the theory of (closed) logic programs <ref> [37, 7, 25, 1] </ref> to open logic programs. Thus, we have established soundness, and completeness results for open logic programs.
Reference: 2. <author> K.R. Apt. </author> <title> From Logic Programming to Prolog. </title> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: This correctness is defined in terms of steadfastness and thus `inherits' the latter's compositional properties. We have also discussed methods for proving correctness, involving the open completion and existential termination. Correctness of logic programs has been widely studied (see Chapter 8 of <ref> [2] </ref> for instance). What distinguishes our approach is the presence of a class of interpretations, wherein specifications assume their proper meaning, and wherein correctness must be established. From this point of view, Deville's [9] `correctness with respect to separate specifications' is more similar than most to our approach in spirit. <p> Then in the second, we adapt the program for execution by a specific interpreter. This is not discussed in this paper, and will most probably involve transformation techniques. To deal with termination, well-known techniques <ref> [8, 2] </ref> can be adapted for open programs. To handle modularity, and the effects of the computation rule and possible delay mechanisms, results like those given for example in [30] should be useful. 8.
Reference: 3. <author> A. Brogi, E. Lamma and P. Mello. </author> <title> Compositional model-theoretic semantics for logic programs. </title> <booktitle> New Generation Computing 11 </booktitle> <pages> 1-21, </pages> <year> 1992. </year>
Reference-contexts: The semantics of an open program P is given by the j-models j P + and j P , and steadfastness in a framework F = h; Ii intuitively means parametric correctness. Open logic programs have been considered by Brogi, Lamma and Mello. In <ref> [3] </ref>, they introduce Admissible Herbrand Models, to provide a model-theoretic semantics for program composition. Admissible models can be seen as a particular case of j-models, where only suitable Herbrand pre-interpretations j are considered. <p> Admissible models can be seen as a particular case of j-models, where only suitable Herbrand pre-interpretations j are considered. By contrast, in our approach, we place no restriction on j, since we need to compare j-models with the interpretations of an arbitrary framework. That is, whereas <ref> [3] </ref> is concerned with a model-theoretic semantics for program composition, our primary goal is `open correctness' in a class of interpretations. Modularity is a by-product of steadfastness, since the latter is preserved by composition. Moreover, allowing arbitrary pre-interpretations yields a greater generality. <p> The first approach is exemplified by Brogi, Mancarella, Pedreschi and Turini [4]. Here composition operators and their semantics are defined for composing programs. Compositional semantics is based on the immediate consequence operator, although in other papers (e.g. <ref> [3] </ref>) a compositional model-theoretic semantics is used. The second approach is exemplified by Miller [27], who extends Horn clauses by allowing implication goals whose bodies are sets of clauses defined in an external module. Monteiro and Porto [29] use a similar idea to introduce contextual logic programming.
Reference: 4. <author> A. Brogi, P. Mancarella, D. Pedreschi and F. Turini. </author> <title> Modular logic programming. </title> <journal> ACM TOPLAS 16(4) </journal> <pages> 1361-1398, </pages> <year> 1994. </year>
Reference-contexts: In logic programming, an in-depth survey of modularity can be found in [5]. There are broadly two main approaches: one based on an algebra for logic program composition, and one based on extensions of Horn logic. The first approach is exemplified by Brogi, Mancarella, Pedreschi and Turini <ref> [4] </ref>. Here composition operators and their semantics are defined for composing programs. Compositional semantics is based on the immediate consequence operator, although in other papers (e.g. [3]) a compositional model-theoretic semantics is used.
Reference: 5. <author> M. Bugliesi, E. Lamma and P. Mello. </author> <title> Modularity in logic programming. </title> <journal> J. Logic Programming 19,20:443-502, </journal> <note> 1994. Special issue: Ten years of logic programming. </note>
Reference-contexts: Modularity A steadfast program makes an ideal module, since it is parametrically correct and can be composed with different (correct) parameters into different correct programs. In logic programming, an in-depth survey of modularity can be found in <ref> [5] </ref>. There are broadly two main approaches: one based on an algebra for logic program composition, and one based on extensions of Horn logic. The first approach is exemplified by Brogi, Mancarella, Pedreschi and Turini [4]. Here composition operators and their semantics are defined for composing programs.
Reference: 6. <author> K.L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <year> 1978. </year>
Reference-contexts: Comp contains 8x : :p (x), for every open predicate p in P . In contrast, Ocomp does not contain axioms for the open predicates, since they are considered to be parameters. In addition, Comp contains Clark's equality theory CET <ref> [1, 6, 25] </ref>, which is left out of Ocomp. We do not assume any fixed equality theory, since the meaning of the constant and function symbols is pre-defined by the (open) framework F. <p> In general, the class J of the intended models is properly contained in the class of all first-order models of Ax and is defined by means of suitable higher-order assumptions such as the closed world assumption <ref> [6] </ref>. However, the results in this section are largely independent from any specific intended model semantics. Therefore we simply assume that there is a class J of intended models of Ax . Th is a set of theorems that are provable (in first-order logic) from Ax .
Reference: 7. <author> K.L. Clark. </author> <title> Predicate Logic as a Computational Formalism. </title> <type> Research Report 79/59, </type> <institution> Dept of Computing, Imperial College, </institution> <year> 1979. </year>
Reference-contexts: Our treatment of steadfastness, given for definite logic programs, immediately extends to constraint logic programs. Moreover, it can be easily extended to terminating normal programs. In fact, we have extended a kernel of the theory of (closed) logic programs <ref> [37, 7, 25, 1] </ref> to open logic programs. Thus, we have established soundness, and completeness results for open logic programs.
Reference: 8. <author> D. De Schreye and S. Decorte. </author> <title> Termination of logic programs: The never-ending story. </title> <journal> J. Logic Programming 19,20:199-260, </journal> <year> 1994. </year>
Reference-contexts: Then in the second, we adapt the program for execution by a specific interpreter. This is not discussed in this paper, and will most probably involve transformation techniques. To deal with termination, well-known techniques <ref> [8, 2] </ref> can be adapted for open programs. To handle modularity, and the effects of the computation rule and possible delay mechanisms, results like those given for example in [30] should be useful. 8.
Reference: 9. <author> Y. Deville. </author> <title> Logic Programming: Systematic Program Development. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The parameters p are symbols of , and their interpretations in J represent the possible instantiations of p. For example, in the parametric 8 This definition is very similar to that in <ref> [9] </ref>. 25 specification (6.2), we can consider the instantiation D := natural numbers, ffi := +, e := 0, fi := fl. Finally, each instance (S ffi (k); S (k)) of a parametric specification f (S ffi (p); S (p))g defines an interpretation i k of ffi and . <p> Correctness of logic programs has been widely studied (see Chapter 8 of [2] for instance). What distinguishes our approach is the presence of a class of interpretations, wherein specifications assume their proper meaning, and wherein correctness must be established. From this point of view, Deville's <ref> [9] </ref> `correctness with respect to separate specifications' is more similar than most to our approach in spirit. Even here, however, there is an important difference in that our characterisation is a more abstract, model-theoretic characterisation, based on steadfastness.
Reference: 10. <author> H. Ehrig and B. Mahr. </author> <title> Fundamentals of Algebraic Specification 1 . Springer-Verlag, </title> <year> 1985. </year>
Reference-contexts: Parametric Specifications Specification frameworks allow us to introduce parametric specifications in a simple and natural way, together with accompanying benefits like modularity. However, such specifications (and their benefits) can also be (and indeed have been) captured by other formalisms, such as algebraic specifications (e.g. <ref> [10, 11, 38] </ref>), and institutions [12]. The latter have even been applied to logic programs [33]. In functional programming, Sanella and Tarlecki [35, 34] have proposed formal development of (parametric) ML programs from algebraic specifications. Their work is very close to ours in spirit, and allows parametric specifications and programs.
Reference: 11. <author> H. Ehrig and B. Mahr. </author> <title> Fundamentals of Algebraic Specification 2 . Springer-Verlag, </title> <year> 1989. </year>
Reference-contexts: Parametric Specifications Specification frameworks allow us to introduce parametric specifications in a simple and natural way, together with accompanying benefits like modularity. However, such specifications (and their benefits) can also be (and indeed have been) captured by other formalisms, such as algebraic specifications (e.g. <ref> [10, 11, 38] </ref>), and institutions [12]. The latter have even been applied to logic programs [33]. In functional programming, Sanella and Tarlecki [35, 34] have proposed formal development of (parametric) ML programs from algebraic specifications. Their work is very close to ours in spirit, and allows parametric specifications and programs.
Reference: 12. <author> J.A. Goguen and R.M. Burstall. Institutions: </author> <title> Abstract model theory for specification and programming. </title> <editor> J. </editor> <booktitle> ACM 39(1) </booktitle> <pages> 95-146, </pages> <year> 1992. </year>
Reference-contexts: Parametric Specifications Specification frameworks allow us to introduce parametric specifications in a simple and natural way, together with accompanying benefits like modularity. However, such specifications (and their benefits) can also be (and indeed have been) captured by other formalisms, such as algebraic specifications (e.g. [10, 11, 38]), and institutions <ref> [12] </ref>. The latter have even been applied to logic programs [33]. In functional programming, Sanella and Tarlecki [35, 34] have proposed formal development of (parametric) ML programs from algebraic specifications. Their work is very close to ours in spirit, and allows parametric specifications and programs.
Reference: 13. <author> C.J. </author> <title> Hogger. Introduction to Logic Programming. </title> <publisher> Academic Press, </publisher> <year> 1984. </year>
Reference-contexts: Parametric Correctness In this section we show how parametric correctness, i.e., correctness of open programs, can be formalised in terms of steadfastness. The standard definition of 24 correctness (of closed programs) is with respect to a specification, as follows (see e.g. <ref> [13] </ref>): A (closed) program P for computing a relation r (x) is correct with respect to a specification S if, for every tuple t of ground terms, the following correctness condition holds: S j= r (t) iff P ` r (t) (6.1) We shall extend this definition to open programs.
Reference: 14. <author> J. Jaffar and M. Maher. </author> <title> Constraint logic programming: A survey. </title> <journal> J. Logic Programming 19,20:503-581, </journal> <note> 1994. Special issue: Ten years of logic programming. </note>
Reference-contexts: In this case, the notion of a j-model corresponds to that of a model based on the pre-interpretation j, as in [25]. We can prove the following closure properties: 5 5 This works for definite programs and for constraint logic programs <ref> [14] </ref>. Negation and full first-order languages are used in frameworks. 11 Proposition 4.2. Let P : ffi ( be a -program, and j be a pre-interpretation. <p> CONCLUSION In this paper, we have introduced the semantics of steadfast logic programs, and we have studied their compositional properties, in an abstract, model-theoretic way. We have also introduced an operational semantics for open programs, based on a `virtual interpreter', in the manner of constraint logic programs <ref> [14] </ref>. Our treatment of steadfastness, given for definite logic programs, immediately extends to constraint logic programs. Moreover, it can be easily extended to terminating normal programs. In fact, we have extended a kernel of the theory of (closed) logic programs [37, 7, 25, 1] to open logic programs.
Reference: 15. <author> C. Kreitz, K.-K. Lau, and M. Ornaghi. </author> <title> Formal reasoning about modules, reuse and their correctness. In D.M. </title> <editor> Gabbay and H.J. Ohlbach, editors, </editor> <booktitle> Proc. Int. Conf. on Formal and Applied Practical Reasoning, LNAI 1085, </booktitle> <pages> pages 384-399, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: 1. INTRODUCTION In (both standard and constraint) logic programming, we have developed a formal approach (see e.g. [17, 19]) to constructing programs in which we can define and reason about the correctness and reusability of not only parametric programs but also generic classes (see <ref> [20, 15, 16] </ref>). The cornerstone of our formalisation of reusability and correctness is the notion of steadfastness. In model-theoretic terms, steadfastness corresponds to parametric correctness in a class of interpretations. <p> In our approach, however, we always distinguish between frameworks, specifications and programs. A framework F defines a general problem domain, and specifications in F represent computational tasks in this domain. At the framework level, our approach <ref> [15] </ref> is very similar to the algebraic one, except that we use full first-order languages, since we require their expressiveness at the specification level. At the specification and program levels, we introduce a notion of model-theoretic correctness, based on steadfastness, which is the distinctive feature of our approach.
Reference: 16. <author> K.-K. Lau, C.D.M. Moss and M. Ornaghi. </author> <title> Formal development of correct classes in computational logic. In D.J. Duke and A.S. </title> <editor> Evans, editors, </editor> <booktitle> Proc. BCS-FACS Northern Formal Methods Workshop, Springer-Verlag, electronic Workshops in Computing Series, </booktitle> <year> 1997. </year> <note> Abstract on page 3. (http://ewic.springer.co.uk) </note>
Reference-contexts: 1. INTRODUCTION In (both standard and constraint) logic programming, we have developed a formal approach (see e.g. [17, 19]) to constructing programs in which we can define and reason about the correctness and reusability of not only parametric programs but also generic classes (see <ref> [20, 15, 16] </ref>). The cornerstone of our formalisation of reusability and correctness is the notion of steadfastness. In model-theoretic terms, steadfastness corresponds to parametric correctness in a class of interpretations.
Reference: 17. <author> K.-K. Lau, M. Ornaghi and S.-. A. </author> <title> Tarnlund. The halting problem for deductive synthesis of logic programs. </title> <editor> In P. van Hentenryck, editor, </editor> <booktitle> Proc. 11th Int. Conf. on Logic Programming, </booktitle> <pages> pages 665-683, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: 1. INTRODUCTION In (both standard and constraint) logic programming, we have developed a formal approach (see e.g. <ref> [17, 19] </ref>) to constructing programs in which we can define and reason about the correctness and reusability of not only parametric programs but also generic classes (see [20, 15, 16]). The cornerstone of our formalisation of reusability and correctness is the notion of steadfastness. <p> We have demonstrated the application of steadfastness to correctness with respect to parametric specifications in Section 6, and in the previous section we have briefly discussed related pieces of work and their differences with our approach. The idea of steadfastness is primarily motivated by our work in deductive synthesis <ref> [24, 17, 18] </ref> of logic programs. However, we believe that it is an important concept for formal software development in general. Indeed, steadfastness is a combination of modularity, reusability, and (formal) correctness.
Reference: 18. <author> K.-K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. LOPSTR 94 and META 94 , LNCS 883, </booktitle> <pages> pages 104-121, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: We have demonstrated the application of steadfastness to correctness with respect to parametric specifications in Section 6, and in the previous section we have briefly discussed related pieces of work and their differences with our approach. The idea of steadfastness is primarily motivated by our work in deductive synthesis <ref> [24, 17, 18] </ref> of logic programs. However, we believe that it is an important concept for formal software development in general. Indeed, steadfastness is a combination of modularity, reusability, and (formal) correctness.
Reference: 19. <author> K.-K. Lau and M. Ornaghi. </author> <title> A formal approach to deductive synthesis of constraint logic programs. </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proc. 1995 Int. Logic Programming Symp., </booktitle> <pages> pages 543-557, </pages> <publisher> MIT Press, </publisher> <year> 1995. </year> <month> 37 </month>
Reference-contexts: 1. INTRODUCTION In (both standard and constraint) logic programming, we have developed a formal approach (see e.g. <ref> [17, 19] </ref>) to constructing programs in which we can define and reason about the correctness and reusability of not only parametric programs but also generic classes (see [20, 15, 16]). The cornerstone of our formalisation of reusability and correctness is the notion of steadfastness.
Reference: 20. <author> K.-K. Lau and M. Ornaghi. </author> <title> Towards an object-oriented methodology for deductive synthesis of logic programs. </title> <editor> In M. Proietti, editor, </editor> <booktitle> Proc. </booktitle> <volume> LOPSTR 95 , LNCS 1048, </volume> <pages> pages 152-169, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: 1. INTRODUCTION In (both standard and constraint) logic programming, we have developed a formal approach (see e.g. [17, 19]) to constructing programs in which we can define and reason about the correctness and reusability of not only parametric programs but also generic classes (see <ref> [20, 15, 16] </ref>). The cornerstone of our formalisation of reusability and correctness is the notion of steadfastness. In model-theoretic terms, steadfastness corresponds to parametric correctness in a class of interpretations.
Reference: 21. <author> K.-K. Lau and M. Ornaghi. </author> <title> Forms of Logic Specifications: A Preliminary Study. </title> <editor> In J. Gallagher, editor, </editor> <booktitle> Proc. </booktitle> <volume> LOPSTR 96 , LNCS 1207, </volume> <pages> pages 295-312, </pages> <publisher> Springer-Verlag 1997. </publisher>
Reference-contexts: Therefore, SupSub r is non-strict. Other examples of non-strict specifications include conditional specifications and selector specifications. These are defined and discussed in <ref> [21] </ref>, where it is also shown that conditional specifications are a special case of super/sub specifications. <p> Our general re 34 sults can be used to introduce proof methods, based on the open completion and existential termination. There are other kinds of (strict and non-strict) specifications, besides those in Section 6. In general, different kinds of specifications may involve different kinds of termination proofs (see e.g. <ref> [21] </ref>). Using model-theoretic correctness, however, may cause problems with a real logic programmming language such as Prolog, owing to the discrepancy between the model-theoretic semantics and the operational semantics of the latter. For `real' programs, we have to take into account depth-search strategy with a given computation rule.
Reference: 22. <author> K.-K. Lau and M. Ornaghi. </author> <title> The relationship between logic programs and specifications the subset example revisited. </title> <editor> J. </editor> <booktitle> Logic Programming 30(3) </booktitle> <pages> 239-257, </pages> <year> 1997. </year>
Reference-contexts: A framework typically embodies an axiomatisation of the problem domain, that provides an unambiguous semantic underpinning for specifications and programs, as well as the correctness relationship between them (see <ref> [22] </ref>). Axioms and theorems should codify all the relevant knowledge on the domain. In an (open) axiomatised framework F = h; Ax [ Th; Ii, a parametric specification of r is a set S r of formulas, that define r in terms of the symbols of . <p> This allows us to introduce in a clear way both strict and non-strict specifications, and to define the corresponding notions of correctness. A discussion of this can be found in <ref> [22] </ref>. 7.4. Correctness and Termination We define correctness, in a declarative, model-theoretic manner, with respect to both strict and non-strict parametric specifications. This correctness is defined in terms of steadfastness and thus `inherits' the latter's compositional properties.
Reference: 23. <author> K.-K. Lau, M. Ornaghi, and A. Wills, </author> <title> Frameworks in Catalysis: Pictorial Notation and Formal Semantics, </title> <booktitle> Proceedings of the First IEEE International Conference on Formal Engineering Methods, </booktitle> <pages> pages 213-220, </pages> <publisher> IEEE Computer Society, </publisher> <year> 1997. </year>
Reference-contexts: Constructing steadfast programs should also contribute directly to component-based software development. This is because steadfastness is defined in the context of a framework formalising the problem domain. Our formalisation of a framework corresponds to what is called an Object-oriented Design (OOD framework <ref> [23] </ref>) in component-based software development. Thus developing steadfast programs entails constructing (libraries of) OOD frameworks. It is now widely recognised that such frameworks are a more promising answer to software reuse than objects, and industry is increasingly using (OOD) frameworks rather than objects as the unit of reuse.
Reference: 24. <author> K.-K. Lau and S.D. Prestwich. </author> <title> Synthesis of a Family of Recursive Sorting Procedures. </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Proc. 1991 Int. Logic Programming Symposium, </booktitle> <pages> pages 641-658. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: We have demonstrated the application of steadfastness to correctness with respect to parametric specifications in Section 6, and in the previous section we have briefly discussed related pieces of work and their differences with our approach. The idea of steadfastness is primarily motivated by our work in deductive synthesis <ref> [24, 17, 18] </ref> of logic programs. However, we believe that it is an important concept for formal software development in general. Indeed, steadfastness is a combination of modularity, reusability, and (formal) correctness.
Reference: 25. <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: (r (a); A 1 ) ^ B 1 ) _ _ (9y n : eq (r (a); A n ) ^ B n ) where 8y j : A j B j , 1 j n, are the clauses of P with defined predicate r (for more details, see e.g. <ref> [25] </ref>); (ii) Cdef + (P; r) stands for the if-definition of r in P , i.e., the -part of Cdef (P; r); (iii) Cdef (P; r) stands for the only-if-definition of r in P , i.e., the !-part of Cdef (P; r). <p> Ocomp + (P ) is, of course, logically equivalent to P , and we shall use them interchangeably. Ocomp is different from the usual completion, Comp, as defined in e.g. <ref> [25] </ref>. Comp contains 8x : :p (x), for every open predicate p in P . In contrast, Ocomp does not contain axioms for the open predicates, since they are considered to be parameters. In addition, Comp contains Clark's equality theory CET [1, 6, 25], which is left out of Ocomp. <p> Comp contains 8x : :p (x), for every open predicate p in P . In contrast, Ocomp does not contain axioms for the open predicates, since they are considered to be parameters. In addition, Comp contains Clark's equality theory CET <ref> [1, 6, 25] </ref>, which is left out of Ocomp. We do not assume any fixed equality theory, since the meaning of the constant and function symbols is pre-defined by the (open) framework F. <p> We will consider the meaning of to be pre-defined, and call j a pre-interpretation: Definition 4.7. (Pre-interpretations) Let P : ffi ( be a -program. A -interpretation will be called a pre interpretation of P . This definition of pre-interpretation is an extension of that in <ref> [25] </ref>. The two definitions become equivalent when P does not contain open predicates, and P 's signature coincides with . <p> In this case, the notion of a j-model corresponds to that of a model based on the pre-interpretation j, as in <ref> [25] </ref>. We can prove the following closure properties: 5 5 This works for definite programs and for constraint logic programs [14]. Negation and full first-order languages are used in frameworks. 11 Proposition 4.2. Let P : ffi ( be a -program, and j be a pre-interpretation. <p> Our treatment of steadfastness, given for definite logic programs, immediately extends to constraint logic programs. Moreover, it can be easily extended to terminating normal programs. In fact, we have extended a kernel of the theory of (closed) logic programs <ref> [37, 7, 25, 1] </ref> to open logic programs. Thus, we have established soundness, and completeness results for open logic programs.
Reference: 26. <author> B. Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: These theorems are useful for writing down the right specifications and to reason about program correctness and synthesis. Equally we believe that steadfastness is a contribution to object-oriented programming. The reusability afforded by steadfastness differs from that found in object-oriented programming (e.g. <ref> [26] </ref>) mainly in two ways. Firstly, steadfastness characterises reusability at a high level of abstraction, i.e., at the level of the framework.
Reference: 27. <author> D. Miller. </author> <title> A logical analysis of modules in logic programming. </title> <editor> J. </editor> <booktitle> Logic Programming 6 </booktitle> <pages> 79-108, </pages> <year> 1989. </year>
Reference-contexts: Here composition operators and their semantics are defined for composing programs. Compositional semantics is based on the immediate consequence operator, although in other papers (e.g. [3]) a compositional model-theoretic semantics is used. The second approach is exemplified by Miller <ref> [27] </ref>, who extends Horn clauses by allowing implication goals whose bodies are sets of clauses defined in an external module. Monteiro and Porto [29] use a similar idea to introduce contextual logic programming. Modularity can also be achieved by introducing types [31].
Reference: 28. <author> D. Miller. </author> <title> Abstractions in logic programs. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic in Computer Science, </booktitle> <pages> pages 329-356, </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: Monteiro and Porto [29] use a similar idea to introduce contextual logic programming. Modularity can also be achieved by introducing types [31]. In general, enriching first-order Horn logic yields scoping and abstraction mechanisms that support modules, data abstraction, and metaprogramming. This has been nicely explained in <ref> [28] </ref>, where different extensions of first-order Horn logic are considered, and the power of higher-order logic programming is briefly discussed. 33 However, in the above approaches, there is no notion of formal correctness like steadfastness, which ensures that the composed program is correct with respect to the intended interpretations of the
Reference: 29. <author> L. Monteiro and A. Porto. </author> <title> Contextual Logic Programming. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proc 6th Int. Conf. on Logic Programming, </booktitle> <pages> pages 284-299, </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: The second approach is exemplified by Miller [27], who extends Horn clauses by allowing implication goals whose bodies are sets of clauses defined in an external module. Monteiro and Porto <ref> [29] </ref> use a similar idea to introduce contextual logic programming. Modularity can also be achieved by introducing types [31]. In general, enriching first-order Horn logic yields scoping and abstraction mechanisms that support modules, data abstraction, and metaprogramming.
Reference: 30. <author> L. Naish. </author> <title> Coroutining and the construction of terminating logic programs. </title> <journal> Aus-tralian Computer Science Comm. </journal> <volume> 15(1) </volume> <pages> 181-190, </pages> <year> 1993. </year>
Reference-contexts: For real Prolog programs, however, this does not necessarily mean that termination is preserved. Indeed, our notion of correctness is model-theoretic, while in Prolog there is a discrepancy between operational and model-theoretic semantics. Moreover, we may require termination with respect to non-ground goals. These problems are important (see e.g. <ref> [30] </ref>), but they are beyond the scope of this paper. We will only briefly comment on them in Section 7. Finally, we remark that the theorems of a framework are useful in the proof of the completion. <p> This is not discussed in this paper, and will most probably involve transformation techniques. To deal with termination, well-known techniques [8, 2] can be adapted for open programs. To handle modularity, and the effects of the computation rule and possible delay mechanisms, results like those given for example in <ref> [30] </ref> should be useful. 8. CONCLUSION In this paper, we have introduced the semantics of steadfast logic programs, and we have studied their compositional properties, in an abstract, model-theoretic way.
Reference: 31. <author> F. Pfenning. </author> <title> Types in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: The second approach is exemplified by Miller [27], who extends Horn clauses by allowing implication goals whose bodies are sets of clauses defined in an external module. Monteiro and Porto [29] use a similar idea to introduce contextual logic programming. Modularity can also be achieved by introducing types <ref> [31] </ref>. In general, enriching first-order Horn logic yields scoping and abstraction mechanisms that support modules, data abstraction, and metaprogramming.
Reference: 32. <author> R. O'Keefe. </author> <title> The Craft of Prolog. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: every interpretation i 2 I of the open predicates: it means that P terminates under the assumption that open symbols are answered, during a computation, by some program Q that computes according to i. 1 Note that what we call a `steadfast logic program' is completely different from what O'Keefe <ref> [32, p. 96] </ref> calls a `steadfast predicate', although we also (need to) use `steadfast' in the sense of `unchanging'. 3 Steadfastness provides the model-theoretic basis for parametric correctness, i.e., correctness with respect to parametric specifications.
Reference: 33. <editor> F. Orejas, E. Pino and H. Ehrig. </editor> <booktitle> Institutions for Logic Programming. Theoretical Computer Science 173 </booktitle> <pages> 485-511, </pages> <year> 1997. </year>
Reference-contexts: However, such specifications (and their benefits) can also be (and indeed have been) captured by other formalisms, such as algebraic specifications (e.g. [10, 11, 38]), and institutions [12]. The latter have even been applied to logic programs <ref> [33] </ref>. In functional programming, Sanella and Tarlecki [35, 34] have proposed formal development of (parametric) ML programs from algebraic specifications. Their work is very close to ours in spirit, and allows parametric specifications and programs. In our approach, however, we always distinguish between frameworks, specifications and programs.
Reference: 34. <editor> D. Sannella, S. Sokolowski and A. Tarlecki. </editor> <title> Towards formal development of programs from algebraic specifications: parameterisation revisited. </title> <journal> Acta Informatica 29 </journal> <pages> 689-736, </pages> <year> 1992. </year>
Reference-contexts: However, such specifications (and their benefits) can also be (and indeed have been) captured by other formalisms, such as algebraic specifications (e.g. [10, 11, 38]), and institutions [12]. The latter have even been applied to logic programs [33]. In functional programming, Sanella and Tarlecki <ref> [35, 34] </ref> have proposed formal development of (parametric) ML programs from algebraic specifications. Their work is very close to ours in spirit, and allows parametric specifications and programs. In our approach, however, we always distinguish between frameworks, specifications and programs.
Reference: 35. <author> D. Sannella and A. Tarlecki. </author> <title> Toward formal development of programs from algebraic specifications: </title> <booktitle> model-theoretic foundations. Lecture Notes in Computer Science 623, </booktitle> <pages> pages 656-671, </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: However, such specifications (and their benefits) can also be (and indeed have been) captured by other formalisms, such as algebraic specifications (e.g. [10, 11, 38]), and institutions [12]. The latter have even been applied to logic programs [33]. In functional programming, Sanella and Tarlecki <ref> [35, 34] </ref> have proposed formal development of (parametric) ML programs from algebraic specifications. Their work is very close to ours in spirit, and allows parametric specifications and programs. In our approach, however, we always distinguish between frameworks, specifications and programs.
Reference: 36. <author> J.C. Shepherdson. </author> <title> Negation in logic programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88. </pages> <publisher> Morgan Kauf-mann, </publisher> <year> 1988. </year>
Reference-contexts: SLD E -proofs correspond to SLD-refutations, where the answer substitution oe is replaced by the equations E in the final goal. To extract oe from E, first-order logic with identity is not sufficient: we need the freeness axioms <ref> [36] </ref> which are included in Clark's equality theory CET. We do not assume CET here, however, and other equality theories could be considered, i.e., our treatment of steadfastness can be 17 extended to constraint logic programs for instance. Example 5.1.
Reference: 37. <author> M.H. van Emden and R. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <editor> J. </editor> <booktitle> ACM 23(4) </booktitle> <pages> 733-742, </pages> <month> October </month> <year> 1976. </year>
Reference-contexts: Our treatment of steadfastness, given for definite logic programs, immediately extends to constraint logic programs. Moreover, it can be easily extended to terminating normal programs. In fact, we have extended a kernel of the theory of (closed) logic programs <ref> [37, 7, 25, 1] </ref> to open logic programs. Thus, we have established soundness, and completeness results for open logic programs.
Reference: 38. <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: Parametric Specifications Specification frameworks allow us to introduce parametric specifications in a simple and natural way, together with accompanying benefits like modularity. However, such specifications (and their benefits) can also be (and indeed have been) captured by other formalisms, such as algebraic specifications (e.g. <ref> [10, 11, 38] </ref>), and institutions [12]. The latter have even been applied to logic programs [33]. In functional programming, Sanella and Tarlecki [35, 34] have proposed formal development of (parametric) ML programs from algebraic specifications. Their work is very close to ours in spirit, and allows parametric specifications and programs.
References-found: 38

