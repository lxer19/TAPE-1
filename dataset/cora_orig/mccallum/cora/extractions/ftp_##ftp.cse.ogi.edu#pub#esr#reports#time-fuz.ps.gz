URL: ftp://ftp.cse.ogi.edu/pub/esr/reports/time-fuz.ps.gz
Refering-URL: http://www.cse.ogi.edu/~calton/publication.html
Root-URL: http://www.cse.ogi.edu
Title: Multiversion Divergence Control of Time Fuzziness  
Author: Calton Pu Miu K. Tsang Kun-Lung Wu and Philip S. Yu 
Keyword: Index Terms: epsilon serializability, concurrency control, multiple versions, divergence control, transaction processing.  
Address: P.O. Box 91000 Portland, OR 97291-1000  P.O. Box 704 Yorktown Heights, NY 10598  
Affiliation: Department Computer Science and Engineering Oregon Graduate Institute  IBM T.J. Watson Research Center  
Abstract: Epsilon Serializability (ESR) has been proposed to manage and control inconsistency in extending the classic transaction processing that has been based on serializability. ESR increases transaction processing system concurrency by tolerating a bounded amount of inconsistency. In this paper, we present multiversion divergence control (mvDC) algorithms that support ESR with not only value but also time fuzziness in multiversion databases. Unlike value fuzziness, accumulating time fuzziness is semantically different. A simple summation of the length of two time intervals may either underestimate the total time fuzziness, resulting in incorrect execution, or overestimate the total time fuzziness, unnecessarily degrading the effectiveness of mvESR. In this paper, we present a new operation, called TimeUnion, to accurately accumulate the total time fuzziness. In addition, we describe two mvDC algorithms that can correctly bound the inconsistency in time and value for mvESR. Because of the accurate control of time and value fuzziness by the mvDC algorithms, mvESR is very suitable for the use of multiversion databases for real-time applications that may tolerate a limited degree of data inconsistency but prefer more data recency. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Agrawal and S. Sengupta. </author> <title> Modular synchronization in multiversion databases: Version control and concurrency control. </title> <booktitle> In Proc. of ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 408-417, </pages> <year> 1989. </year>
Reference-contexts: These algorithms are particularly effective for long queries, which otherwise cannot finish without stopping the update activity. However, most of the classic mvCC algorithms implicitly assume the database accommodates an infinite number of versions for each data item <ref> [1, 2, 3, 4, 5, 6, 13, 15] </ref>. If not, a long-running query may have to be aborted because some of the versions that it needs have been garbage collected prematurely.
Reference: [2] <author> P. A. Bernstein and N. Goodman. </author> <title> Multiversion concurrency control|theory and algorithms. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 8(4) </volume> <pages> 465-483, </pages> <month> Dec. </month> <year> 1983. </year>
Reference-contexts: These algorithms are particularly effective for long queries, which otherwise cannot finish without stopping the update activity. However, most of the classic mvCC algorithms implicitly assume the database accommodates an infinite number of versions for each data item <ref> [1, 2, 3, 4, 5, 6, 13, 15] </ref>. If not, a long-running query may have to be aborted because some of the versions that it needs have been garbage collected prematurely. <p> As an example, TimeUnion ([2; 5]; [9; 10]) = <ref> [2; 10] </ref>.
Reference: [3] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction In conventional transaction processing (TP) systems, the correctness criterion has been serializ-ability (SR) <ref> [3] </ref>. Epsilon Serializability (ESR) [11, 17, 10] is a compatible extension that relaxes SR's consistency constraints. In ESR, each transaction, called epsilon transaction (ET), has a specification of the inconsistency (fuzziness) allowed in its execution. ESR increases TP system concurrency by tolerating a bounded amount of inconsistency. <p> These algorithms are particularly effective for long queries, which otherwise cannot finish without stopping the update activity. However, most of the classic mvCC algorithms implicitly assume the database accommodates an infinite number of versions for each data item <ref> [1, 2, 3, 4, 5, 6, 13, 15] </ref>. If not, a long-running query may have to be aborted because some of the versions that it needs have been garbage collected prematurely. <p> Here we summarize a multiversion timestamp ordering (mvTO) algorithm in <ref> [3] </ref> as an example. In such an mvTO CC algorithm, each transaction is assigned a unique timestamp, denoted as ts (T i ). Each operation carries the timestamp of its corresponding transaction. Each version is labeled by the timestamp of the transaction that updated it. <p> In such a case, the time fuzziness has to be accumulated for all the query ETs. 5.3 Proof of correctness We first identify the cycle prevention properties for the corresponding multiversion serialization graph of the original multiversion timestamp ordering algorithm <ref> [3] </ref>. Following these properties, we show that the Saf e time condition is hold for any violation of the properties. Thus, database consistency and bounded inconsistency for ETs are guaranteed. In [3], every successful multiversion timestamp ordering execution history H has the following properties to guarantee its serializability [3]: 1. <p> first identify the cycle prevention properties for the corresponding multiversion serialization graph of the original multiversion timestamp ordering algorithm <ref> [3] </ref>. Following these properties, we show that the Saf e time condition is hold for any violation of the properties. Thus, database consistency and bounded inconsistency for ETs are guaranteed. In [3], every successful multiversion timestamp ordering execution history H has the following properties to guarantee its serializability [3]: 1. For each T i , ts (T i ) = ts (T j ) iff i = j, i.e., a unique timestamp for each transaction; 2. <p> ordering algorithm <ref> [3] </ref>. Following these properties, we show that the Saf e time condition is hold for any violation of the properties. Thus, database consistency and bounded inconsistency for ETs are guaranteed. In [3], every successful multiversion timestamp ordering execution history H has the following properties to guarantee its serializability [3]: 1. For each T i , ts (T i ) = ts (T j ) iff i = j, i.e., a unique timestamp for each transaction; 2. <p> In the following section, we describe a 2PL mvDC algorithm that bounds both value fuzziness and time fuzziness. 7 Two-phase locking mvDC for both time and value fuzziness 7.1 Summary of a classic 2PL mvCC algorithm In this 2PL mvCC <ref> [3] </ref>, there are two phases of transaction execution: the locking phase and the unlocking phase. During the locking phase a transaction must obtain all the locks it requests.
Reference: [4] <author> P. M. Bober and M. J. Carey. </author> <title> On mixing queries and transactions via multiversion locking. </title> <booktitle> In Proc. of Int. Conf. on Data Engineering, </booktitle> <pages> pages 535-545, </pages> <year> 1992. </year>
Reference-contexts: These algorithms are particularly effective for long queries, which otherwise cannot finish without stopping the update activity. However, most of the classic mvCC algorithms implicitly assume the database accommodates an infinite number of versions for each data item <ref> [1, 2, 3, 4, 5, 6, 13, 15] </ref>. If not, a long-running query may have to be aborted because some of the versions that it needs have been garbage collected prematurely.
Reference: [5] <author> M. J. Carey and W. A. Muhanna. </author> <title> The performance of multiversion concurrency control algorithms. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 4(4) </volume> <pages> 338-378, </pages> <month> Nov. </month> <year> 1986. </year>
Reference-contexts: These algorithms are particularly effective for long queries, which otherwise cannot finish without stopping the update activity. However, most of the classic mvCC algorithms implicitly assume the database accommodates an infinite number of versions for each data item <ref> [1, 2, 3, 4, 5, 6, 13, 15] </ref>. If not, a long-running query may have to be aborted because some of the versions that it needs have been garbage collected prematurely.
Reference: [6] <author> A. Chan and R. Gray. </author> <title> Implementing distributed read-only transactions. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> SE-11(2):205-212, </volume> <month> Feb. </month> <year> 1985. </year>
Reference-contexts: These algorithms are particularly effective for long queries, which otherwise cannot finish without stopping the update activity. However, most of the classic mvCC algorithms implicitly assume the database accommodates an infinite number of versions for each data item <ref> [1, 2, 3, 4, 5, 6, 13, 15] </ref>. If not, a long-running query may have to be aborted because some of the versions that it needs have been garbage collected prematurely.
Reference: [7] <author> T.-W. Kuo and A. K. Mok. </author> <title> Application semantics and concurrency control of real-time data-intensive applications. </title> <booktitle> In Proc. of Real-Time Systems Symposium, </booktitle> <pages> pages 35-45, </pages> <year> 1992. </year>
Reference-contexts: But this conservative approach is too restrictive, since SR may not be required in many real-time applications, where sufficiently "close" versions may be more important than strict SR. Thus, mvESR offers an attractive solution in this case. More recently, Mok <ref> [7] </ref> has introduced the notion of similarities to allow some fuzziness in the trade-off of data consistency and timeliness. Our work has the same goal as Mok's, but we build on the existing ESR framework, using ESR concepts, notation, and algorithms.
Reference: [8] <author> A. Merchant, K.-L. Wu, P. S. Yu, and M.-S. Chen. </author> <title> Performance analysis of dynamic finite ver-sioning for concurrent transaction and query processing. </title> <booktitle> In Proc. of 1992 ACM SIGMETRICS and PERFORMANCE '92, </booktitle> <pages> pages 103-114, </pages> <year> 1992. </year>
Reference-contexts: Thus, both storage overhead and version management complexity, such as version selection and garbage collection, can be a severe problem. Recently, a new class of mvCC algorithms, such as dynamic finite versioning (DFV) <ref> [16, 8] </ref> and transient versioning [9], have been proposed to allow a choice in the trade-off between the number of versions available (i.e., the storage space occupied) and the obsolescence of data being accessed. <p> Queries are guaranteed to read from a consistent database state, but that consistent state may be out-of-date <ref> [8] </ref>. Usually, a smaller number of versions available means less up-to-date versions being read. In contrast to these versioning algorithms that maintain a finite number of versions and preserve serializability, multiversion DC algorithms offer a different kind of trade-off.
Reference: [9] <author> C. Mohan, H. Pirahesh, and R. Lorie. </author> <title> Efficient and flexible methods for transient versioning of records to avoid locking by read-only transactions. </title> <booktitle> In Proc. of ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 124-133, </pages> <year> 1992. </year>
Reference-contexts: Thus, both storage overhead and version management complexity, such as version selection and garbage collection, can be a severe problem. Recently, a new class of mvCC algorithms, such as dynamic finite versioning (DFV) [16, 8] and transient versioning <ref> [9] </ref>, have been proposed to allow a choice in the trade-off between the number of versions available (i.e., the storage space occupied) and the obsolescence of data being accessed. Queries are guaranteed to read from a consistent database state, but that consistent state may be out-of-date [8]. <p> As an example, TimeUnion ([2; 5]; <ref> [9; 10] </ref>) = [2; 10].
Reference: [10] <author> C. Pu, W. Hseush, G. E. Kaiser, K.-L. Wu, and P. S. Yu. </author> <title> Distributed divergence control for epsilon serializability. </title> <booktitle> In Proc. of Int. Conf. on Distributed Computing Systems, </booktitle> <pages> pages 449-456, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction In conventional transaction processing (TP) systems, the correctness criterion has been serializ-ability (SR) [3]. Epsilon Serializability (ESR) <ref> [11, 17, 10] </ref> is a compatible extension that relaxes SR's consistency constraints. In ESR, each transaction, called epsilon transaction (ET), has a specification of the inconsistency (fuzziness) allowed in its execution. ESR increases TP system concurrency by tolerating a bounded amount of inconsistency. <p> As an example, TimeUnion ([2; 5]; <ref> [9; 10] </ref>) = [2; 10]. <p> As an example, TimeUnion ([2; 5]; [9; 10]) = <ref> [2; 10] </ref>.
Reference: [11] <author> C. Pu and A. Leff. </author> <title> Replica control in distributed systems: An asynchronous approach. </title> <booktitle> In Proc. of ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <pages> pages 377-386, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction In conventional transaction processing (TP) systems, the correctness criterion has been serializ-ability (SR) [3]. Epsilon Serializability (ESR) <ref> [11, 17, 10] </ref> is a compatible extension that relaxes SR's consistency constraints. In ESR, each transaction, called epsilon transaction (ET), has a specification of the inconsistency (fuzziness) allowed in its execution. ESR increases TP system concurrency by tolerating a bounded amount of inconsistency.
Reference: [12] <author> K. Ramamrithan and C. Pu. </author> <title> A formal characterization of epsilon-serializability. </title> <type> Technical Report CUCS-044-91, </type> <institution> Department of Computer Science, Columbia University, </institution> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: One important property of cartesian spaces is the triangle inequality of the distance function: dist (u; v) dist (u; w) + dist (w; v): (1) This property is used in DC algorithms to guarantee their correctness. If triangle inequality holds, each time a non-SR conflict occurs <ref> [17, 12] </ref> the total fuzziness of each ET can be controlled by simply accumulating the partial fuzziness in a counter. Note that, when we discuss time in this paper, we refer to the timestamp of data versions.
Reference: [13] <author> D. P. Reed. </author> <title> Implementing atomic actions on decentralized data. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 1(1) </volume> <pages> 3-23, </pages> <month> Feb. </month> <year> 1983. </year>
Reference-contexts: These algorithms are particularly effective for long queries, which otherwise cannot finish without stopping the update activity. However, most of the classic mvCC algorithms implicitly assume the database accommodates an infinite number of versions for each data item <ref> [1, 2, 3, 4, 5, 6, 13, 15] </ref>. If not, a long-running query may have to be aborted because some of the versions that it needs have been garbage collected prematurely.
Reference: [14] <author> S. H. Son and S. Kouloumbis. </author> <title> Replication control for distributed real-time database systems. </title> <booktitle> In Proc. of Int. Conf. on Distributed Computing Systems, </booktitle> <pages> pages 144-151, </pages> <year> 1992. </year>
Reference-contexts: We say that real-time jobs have urgency requirements to finish before the deadline and recency requirements to avoid old data. Although algorithms controlling only value fuzziness can help increase concurrency of real-time databases <ref> [14] </ref>, most real-time applications may also require a tight control over the time fuzziness in addition to value fuzziness. Intuitively, time fuzziness denotes how wide-spread in time the accessed data objects are, from the viewpoint of a serializable schedule.
Reference: [15] <author> W. E. Weihl. </author> <title> Distributed version management for read-only actions. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> SE-13(1):55-64, </volume> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: These algorithms are particularly effective for long queries, which otherwise cannot finish without stopping the update activity. However, most of the classic mvCC algorithms implicitly assume the database accommodates an infinite number of versions for each data item <ref> [1, 2, 3, 4, 5, 6, 13, 15] </ref>. If not, a long-running query may have to be aborted because some of the versions that it needs have been garbage collected prematurely.
Reference: [16] <author> K.-L. Wu, P. S. Yu, and M.-S. Chen. </author> <title> Dynamic finite versioning: An effective versioning approach to concurrent transaction and query processing. </title> <booktitle> In Proc. of Int. Conf. on Data Engineering, </booktitle> <pages> pages 577-586, </pages> <year> 1993. </year>
Reference-contexts: Thus, both storage overhead and version management complexity, such as version selection and garbage collection, can be a severe problem. Recently, a new class of mvCC algorithms, such as dynamic finite versioning (DFV) <ref> [16, 8] </ref> and transient versioning [9], have been proposed to allow a choice in the trade-off between the number of versions available (i.e., the storage space occupied) and the obsolescence of data being accessed.
Reference: [17] <author> K.-L. Wu, P. S. Yu, and C. Pu. </author> <title> Divergence control for epsilon-serializability. </title> <booktitle> In Proc. of Int. Conf. on Data Engineering, </booktitle> <pages> pages 506-515, </pages> <year> 1992. </year> <month> 19 </month>
Reference-contexts: 1 Introduction In conventional transaction processing (TP) systems, the correctness criterion has been serializ-ability (SR) [3]. Epsilon Serializability (ESR) <ref> [11, 17, 10] </ref> is a compatible extension that relaxes SR's consistency constraints. In ESR, each transaction, called epsilon transaction (ET), has a specification of the inconsistency (fuzziness) allowed in its execution. ESR increases TP system concurrency by tolerating a bounded amount of inconsistency. <p> One important property of cartesian spaces is the triangle inequality of the distance function: dist (u; v) dist (u; w) + dist (w; v): (1) This property is used in DC algorithms to guarantee their correctness. If triangle inequality holds, each time a non-SR conflict occurs <ref> [17, 12] </ref> the total fuzziness of each ET can be controlled by simply accumulating the partial fuzziness in a counter. Note that, when we discuss time in this paper, we refer to the timestamp of data versions. <p> Analogous to the divergency control algorithms which support ESR in a single version environment, we now describe the mvDC method to guarantee mvESR for a timestamp ordering multiversion concurrency control. We will extend the methodology described in <ref> [17] </ref> for 1vDC algorithms and modify a classical mvCC to produce the mvDC that supports mvESR. Our objective is to provide a systematic methodology to extend an existing mvCC protocol by relaxing the correctness criteria from mvSR to mvESR.
References-found: 17

