URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/1994/TR04.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/rsrg/bib-certify.html
Root-URL: 
Email: weide@cis.ohio-state.edu  jholly@ius.indiana.edu  
Title: On Local Certifiability of Software Components  
Author: Bruce W. Weide Joseph E. Hollingsworth 
Note: Copyright 1994 by the authors. All rights reserved.  
Address: Columbus, OH 43210  New Albany, IN 47150  
Affiliation: Department of Computer and Information Science The Ohio State University  Department of Computer Science Indiana University Southeast  
Abstract: Large software systems, like other large engineered systems, consist of components that are meant to be independent except at their interfaces. An important aspect of any large system is the need for local certifiability: to be able to establish properties of components out of the context of the larger system(s) in which they are embedded, and to be sure that any properties thus certified are certain to hold even when the components are composed with others to build larger ones. This is especially important for black-box reusable components, which need to be prequalified for inclusion in a component library. A good software engineering discipline must support local certifiability of important component properties, or life-cycle costs are inherently doomed to spiral out of control for larger and larger systems. No software engineering discipline in general use today can support local certifiability of most interesting properties. But local certifiability of many important properties including, crucially, correctness with respect to an abstract specification is possible in at least one practical discipline [Hollingsworth 92b]. (This paper is adapted, expanded, and updated from our position paper [Weide 92] for the 5th Annual Workshop on Software Reuse, held in Palo Alto, CA, in October 1992.) 
Abstract-found: 1
Intro-found: 1
Reference: [Batory 92] <author> Batory, D., and OMalley, S. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Trans. on Softw. Eng. and Meth. </journal> <volume> 1, </volume> <month> (Oct. </month> <year> 1992), </year> <pages> 355-398. </pages>
Reference: [Bernstein 92] <author> Bernstein, L. </author> <title> Software discipline and the war of 1812. </title> <journal> Software Eng. </journal> <note> Notes 17, </note> <month> 4 (Oct. </month> <year> 1992), </year> <month> 18. </month>
Reference-contexts: This is not necessarily the case. Large systems that really work still might exist in principle because mere difficulties do not imply impossibility. Heroic and costly efforts of software engineers working as individuals or as teams, plus some luck <ref> [Bernstein 92] </ref>, still might result in high-quality systems even though the developers follow practices that make the job hard. Whether any such systems actually exist is surely open to question, since even if they do, there would be no practical way to certify that they actually were of high quality.
Reference: [Booch 87] <author> Booch, G. </author> <title> Software Components with Ada. </title> <address> Benjamin/Cummings, Menlo Park, CA, </address> <year> 1987. </year>
Reference-contexts: How can you be sure that the storage management techniques used in the individual components do not interact to introduce a storage leak that will eventually crash the system? For example, the Booch Ada components <ref> [Booch 87] </ref> are subject to this problem, and simply adopting a functional style of programming would not fix it [Hollingsworth 91]. The program verification literature of the late 1970s addresses sound and relatively complete modular proof-of-correctness systems [Cook 78] which are defined for very simple, but still interesting, Pascal-like languages.
Reference: [Cook 78] <author> Cook, S.A. </author> <title> Soundness and completeness of an axiom system for program verification, </title> <journal> SIAM J. Comp. </journal> <volume> 7, </volume> <month> 1 (Feb. </month> <year> 1978), </year> <pages> 70-90. </pages>
Reference-contexts: On the other hand, you can locally certify correctness provided firewalls do exist above and below each component <ref> [Cook 78, Krone 88, Ernst 91] </ref>. For instance, in the above example if you can show that C and D are correct outside the particular context of A or B, then you can make each correctness argument once and for all. <p> Characterizing such a style for Ada is one of the main 2 A superficial analysis of the results of <ref> [Cook 78] </ref> suggests otherwise; but see Section 4 and [Weide 93]. 5 contributions of [Hollingsworth 92b]. <p> The program verification literature of the late 1970s addresses sound and relatively complete modular proof-of-correctness systems <ref> [Cook 78] </ref> which are defined for very simple, but still interesting, Pascal-like languages. The most exciting part of Cooks language, for example, is that it has procedures (although no recursive ones) with parameters like those Ada (later) termed in and in out mode.
Reference: [CSTB 90] <institution> Computer Science and Technology Board. Scaling up: a research agenda for software engineering. </institution> <note> Comm. ACM 33, </note> <month> 3 (Mar. </month> <year> 1990), </year> <pages> 281-293. </pages>
Reference-contexts: There is serious doubt within the software engineering community about whether any software engineering discipline can predictably deal with the technical problems of engineering systems that are too large for one person to fully understand <ref> [CSTB 90, McCarthy 93, Neumann 93] </ref>. Why? It is just amazingly hard to arrange a large software system so that you have the ability to reason locally about its behavior.
Reference: [Dennis 72] <author> Dennis, J.B. </author> <title> Modularity. In Software Engineering: An Advanced Course, </title> <editor> G. Goos and J. Hartmanis, eds., </editor> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1972. </year>
Reference-contexts: But there is surprisingly little work that pinpoints local certifiability as an essential aspect of a scalable software engineering discipline or that explicitly discusses the technical problems associated with it. The importance and difficulty of modular reasoning about program behavior is discussed in the context of data-flow programming by <ref> [Dennis 72] </ref>, who offers a form of programming-without-side-effects as a possible way to achieve it. Adopting a purely functional programming style is clearly one way of eliminating certain undesirable interactions among components.
Reference: [Edwards 90] <author> Edwards, S. </author> <title> The 3C model of reusable software components. </title> <booktitle> Proc. 3rd Ann.Workshop: Methods and Tools for Reuse, </booktitle> <institution> Syracuse Univ. CASE Center, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: For instance, part of the RESOLVE/Ada Discipline is intended to guarantee that the abstract concept which a component implements, and the expectations of the context within which that component operates <ref> [Edwards 90, Tracz 90b] </ref>, are fully defined, so that you can certify important component properties once and for all prior to entering the component into a library.
Reference: [Edwards 93] <author> Edwards, S.H. </author> <title> Common interface models for reusable software. </title> <journal> Intl. J. Software Eng. and Knowledge Eng. </journal> <volume> 3, </volume> <month> 2 (June </month> <year> 1993), </year> <pages> 193-206. </pages>
Reference-contexts: Composability A high-quality component should be readily composable with other high quality components designed according to the software engineering discipline. This is necessary in order to define and implement larger components. It is still a research matter to define properties such as efficiency [Sitaraman 92] and composability <ref> [Edwards 93] </ref> more precisely, to identify other objective properties that should be locally certifiable, and to determine whether and how local certification is to be achieved.
Reference: [Ernst 91] <author> Ernst, G.W., Hookway, R.J., Menegay, J.A., and Ogden, W.F. </author> <title> Modular verification of Ada generics. </title> <journal> Comp. Lang. </journal> <volume> 16, 3/4 (1991), </volume> <pages> 259-280. 9 </pages>
Reference-contexts: current software engineering practices. 1 It is essential that you should state them clearly and unambiguously in order that client programmers be able to reason in a sound manner about the behavior of component-built software (and in order that a formal, modular verification system for such programs should be sound <ref> [Ernst 91] </ref>). <p> On the other hand, you can locally certify correctness provided firewalls do exist above and below each component <ref> [Cook 78, Krone 88, Ernst 91] </ref>. For instance, in the above example if you can show that C and D are correct outside the particular context of A or B, then you can make each correctness argument once and for all. <p> like to believe otherwise (i.e., that local certifiability of correctness is a solved technical problem), the existence of a sound and relatively complete modular proof system for Cooks simple language and slight variants of it certainly does not imply that you can reason modularly about arbitrary Ada or C++ programs <ref> [Ernst 91, Weide 93] </ref>. There has been some work in the objectoriented programming community on making class correctness tantamount to system correctness. This work seems to be limited to one aspect of type correctness, i.e., making subtypes and supertypes behave properly in clients in all relevant respects. <p> But it, too, deals only with type correctness and not with other crucial properties of software such as overall behavioral correctness, performance, etc. Some of the challenges of locally certifying correctness with respect to an abstract specification are discussed in <ref> [Ernst 91] </ref> for Ada generics. This work points out the central role of formal methods in identifying threats to local certification of correctness and the inescapable relationship between program verification and modular informal reasoning about program behavior. <p> But this is just the start of the effort needed to make local certifiability a practical reality. For some properties particularly correctness with respect to an abstract specification, and reuse-related ones such as composability there is a firm foundation for achieving local certifiability <ref> [Krone 88, Ernst 91, Hollingsworth 92b] </ref>. For some other important properties there is little previous work to build on. As an example, consider the problem of locally certifying that a component implementation meets certain performance specifications for its execution time.
Reference: [Guaspari 90] <author> Guaspari, D., Marceau, C., and Polak, W. </author> <title> Formal verification of Ada programs. </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 16, </volume> <month> 9 (Sept. </month> <year> 1990), </year> <pages> 1058-1075. </pages>
Reference-contexts: Unfortunately, this is how almost all existing formal proof-of-correctness systems must work 2 if the proof rules are supposed to encompass any legal program in a typical real language, e.g., Ada <ref> [Guaspari 90] </ref>. The problem is that use of encapsulation mechanisms such as separation of specification from implementation, private types, etc., is not sufficient by itself to ensure that you can reason modularly about programs. <p> It also explains why a verification system that involves simple textual expansion of generics and procedure calls into their bodies (e.g., the approach described in <ref> [Guaspari 90] </ref>) cannot form the basis for modular reasoning about large programs. We believe [Hollingsworth 92b] contains to date the most comprehensive, technically rigorous discussion of scalability of software engineering disciplines.
Reference: [Harms 91] <author> Harms, D.E., and Weide, B.W. </author> <title> Copying and swapping: influences on the design of reusable software components. </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 17, </volume> <month> 5 (May </month> <year> 1991), </year> <pages> 424-435. </pages>
Reference-contexts: Many widely-practiced programming techniques ones taught in contemporary programming and software engineering textbooks and held up as good practice are the antithesis of those needed to support modular reasoning and local certification <ref> [Harms 91, Hollingsworth 91a, Hollingsworth 92a, Hollingsworth 92b, Weide 93] </ref>. The total amount of code that you must consider in an argument that treats a component-built program as a monolith grows combinatorially as you progress up the hierarchy to larger and larger components.
Reference: [Hollingsworth 91] <author> Hollingsworth, J.E., Weide, B.W., and Zweben, S.H. </author> <title> Abstraction leaks in Ada (extended abstract). </title> <booktitle> Proc. 14th Minnowbrook Workshop on Software Eng., </booktitle> <institution> Syracuse University, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: sure that the storage management techniques used in the individual components do not interact to introduce a storage leak that will eventually crash the system? For example, the Booch Ada components [Booch 87] are subject to this problem, and simply adopting a functional style of programming would not fix it <ref> [Hollingsworth 91] </ref>. The program verification literature of the late 1970s addresses sound and relatively complete modular proof-of-correctness systems [Cook 78] which are defined for very simple, but still interesting, Pascal-like languages.
Reference: [Hollingsworth 92a] <author> Hollingsworth, J.E., and Weide, B.W. </author> <title> Engineering unbounded reusable Ada generics. </title> <booktitle> Proc 10th Annual Natl. Conf. on Ada Technology, </booktitle> <address> Arlington, VA, </address> <month> Feb. </month> <year> 1992, </year> <pages> 82-97. </pages>
Reference-contexts: Many widely-practiced programming techniques ones taught in contemporary programming and software engineering textbooks and held up as good practice are the antithesis of those needed to support modular reasoning and local certification <ref> [Harms 91, Hollingsworth 91a, Hollingsworth 92a, Hollingsworth 92b, Weide 93] </ref>. The total amount of code that you must consider in an argument that treats a component-built program as a monolith grows combinatorially as you progress up the hierarchy to larger and larger components.
Reference: [Hollingsworth 92b] <author> Hollingsworth, </author> <title> J.E. Software Component Design-for-Reuse: A Language-Independent Discipline Applied to Ada. </title> <type> Ph.D. dissertation, </type> <institution> Dept. of Comp. and Inf. Sci., Ohio State Univ., Columbus, OH, </institution> <month> Aug. </month> <note> 1992; available by anonymous FTP from host ftp.cis.ohio-state.edu in pub/tech-report/1993/TR01-DIR/*. </note>
Reference-contexts: The primary contribution of this paper is an explanation in the context of reuse of the importance of answering these questions. While there has been some progress (e.g., <ref> [Hollingsworth 92b] </ref>) the problems in many respects remain open [Weide 92]. 1 The paper is organized as follows. Section 2 illustrates the fundamental problem of locality of reasoning about program behavior, which faces anyone who proposes a software engineering discipline that is purported to work for large systems. <p> Paradoxically, while the above claim about the need for local certifiability may seem to be only common sense, to our knowledge you cannot locally certify important properties such as correctness in any practical extant software engineering discipline or using any current software component library, except our own <ref> [Hollingsworth 92b] </ref>. 3. <p> Many widely-practiced programming techniques ones taught in contemporary programming and software engineering textbooks and held up as good practice are the antithesis of those needed to support modular reasoning and local certification <ref> [Harms 91, Hollingsworth 91a, Hollingsworth 92a, Hollingsworth 92b, Weide 93] </ref>. The total amount of code that you must consider in an argument that treats a component-built program as a monolith grows combinatorially as you progress up the hierarchy to larger and larger components. <p> Characterizing such a style for Ada is one of the main 2 A superficial analysis of the results of [Cook 78] suggests otherwise; but see Section 4 and [Weide 93]. 5 contributions of <ref> [Hollingsworth 92b] </ref>. How the RESOLVE/Ada Discipline lets you achieve local certifiability cannot be summarized acceptably in a short paper such as this one, but [Hollingsworth 92b] is readily available via the Internet (see the bibliography) if you are interested in details and numerous examples. <p> one of the main 2 A superficial analysis of the results of [Cook 78] suggests otherwise; but see Section 4 and [Weide 93]. 5 contributions of <ref> [Hollingsworth 92b] </ref>. How the RESOLVE/Ada Discipline lets you achieve local certifiability cannot be summarized acceptably in a short paper such as this one, but [Hollingsworth 92b] is readily available via the Internet (see the bibliography) if you are interested in details and numerous examples. The bottom line is this: Local certifiability is a necessary condition for tractable certifiability of large components and systems. <p> A related part of the discipline is intended to ensure that no client program which uses the component in a way that meets this contract can possibly invalidate its certification <ref> [Hollingsworth 92b] </ref>. Local certification of correctness illustrates the central issues in being able to reason either formally or informally about the behavior of individual components in the context of client programs. <p> Here you can show by an induction argument that no component designed, implemented, and used under the RESOLVE/Ada Discipline can have a storage leak <ref> [Hollingsworth 92b] </ref>. Sadly (as you are painfully aware as a sophisticated user of any other component library for, e.g., Ada or C++), it is essentially impossible to establish this property at all for a nontrivial program that is developed following accepted contemporary software engineering practices. <p> It also explains why a verification system that involves simple textual expansion of generics and procedure calls into their bodies (e.g., the approach described in [Guaspari 90]) cannot form the basis for modular reasoning about large programs. We believe <ref> [Hollingsworth 92b] </ref> contains to date the most comprehensive, technically rigorous discussion of scalability of software engineering disciplines. It identifies several important properties that should be locally certifiable: correctness with respect to an abstract specification (including correctness of storage management, which is usually left unspecified), composability, reusability, and comprehensibility. <p> Is there any hope that software engineering disciplines can support local certifiability? The foundation for such a discipline for sequential programs written in Ada already exists <ref> [Hollingsworth 92b] </ref>. But this is just the start of the effort needed to make local certifiability a practical reality. <p> But this is just the start of the effort needed to make local certifiability a practical reality. For some properties particularly correctness with respect to an abstract specification, and reuse-related ones such as composability there is a firm foundation for achieving local certifiability <ref> [Krone 88, Ernst 91, Hollingsworth 92b] </ref>. For some other important properties there is little previous work to build on. As an example, consider the problem of locally certifying that a component implementation meets certain performance specifications for its execution time.
Reference: [Knight 91] <author> Knight, J. </author> <title> Issues in the certification of reusable parts. </title> <booktitle> Proc. 4th Ann.Workshop on Software Reuse, </booktitle> <address> Herndon, VA, </address> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Related Work There are many recent books and papers promoting (partial) disciplines for component-built software, e.g., [Liskov 86, Booch 87, Meyer 88, Musser 89, Weide 91, Batory 92, Meyer 92]. There are papers on certification of various component properties (e.g., <ref> [Knight 91] </ref>), and questions about the very feasibility of dependable large systems [Neumann 93]. But there is surprisingly little work that pinpoints local certifiability as an essential aspect of a scalable software engineering discipline or that explicitly discusses the technical problems associated with it.
Reference: [Krone 88] <author> Krone, J. </author> <title> The Role of Verification in Software Reusability. </title> <type> Ph.D. dissertation, </type> <institution> Dept. of Comp. and Inf. Sci., Ohio State Univ., Columbus, OH, </institution> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: On the other hand, you can locally certify correctness provided firewalls do exist above and below each component <ref> [Cook 78, Krone 88, Ernst 91] </ref>. For instance, in the above example if you can show that C and D are correct outside the particular context of A or B, then you can make each correctness argument once and for all. <p> Because of the language definitions, you cannot modularly verify every syntactically legal program in, say, Ada or C++, even if they might be correct [Weide 93]. The proof rules in <ref> [Krone 88] </ref> apply to a version of our language, RESOLVE, in which practices that thwart modular verification are prohibited by the language itself. <p> But this is just the start of the effort needed to make local certifiability a practical reality. For some properties particularly correctness with respect to an abstract specification, and reuse-related ones such as composability there is a firm foundation for achieving local certifiability <ref> [Krone 88, Ernst 91, Hollingsworth 92b] </ref>. For some other important properties there is little previous work to build on. As an example, consider the problem of locally certifying that a component implementation meets certain performance specifications for its execution time.
Reference: [Leavens 90] <author> Leavens, G.T., and Weihl, </author> <title> W.E. Reasoning about objectoriented programs that use subtypes. </title> <booktitle> Proc. OOPSLA 90/SIGPLAN Notices 25, </booktitle> <address> 10 (Oct. </address> <year> 1990), </year> <pages> 212-223. </pages>
Reference-contexts: There has been some work in the objectoriented programming community on making class correctness tantamount to system correctness. This work seems to be limited to one aspect of type correctness, i.e., making subtypes and supertypes behave properly in clients in all relevant respects. The scenario described in <ref> [Leavens 90] </ref> includes an applicative language where side 7 effects are not a problem and therefore, by the authors admission, bears little relationship to the way objectoriented programming is practiced. This paper also does not deal with other desirable system properties that you might like to certify locally.
Reference: [Liskov 86] <author> Liskov, B., and Guttag, J. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1986. </year>
Reference: [McCarthy 93] <author> McCarthy, J. </author> <title> Merging CS and CE disciplines is not a good idea. </title> <journal> Comp. Res. </journal> <volume> News 5, </volume> <month> 1 (Jan </month> <year> 1993), </year> <pages> 2-3. </pages>
Reference-contexts: There is serious doubt within the software engineering community about whether any software engineering discipline can predictably deal with the technical problems of engineering systems that are too large for one person to fully understand <ref> [CSTB 90, McCarthy 93, Neumann 93] </ref>. Why? It is just amazingly hard to arrange a large software system so that you have the ability to reason locally about its behavior.
Reference: [Meyer 88] <author> Meyer, B. </author> <title> Objectoriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference: [Meyer 92] <author> Meyer, B. </author> <title> Applying design by contract. </title> <booktitle> Computer 25, </booktitle> <address> 10 (Oct. </address> <year> 1992) </year> <month> 40-51. </month>
Reference: [Musser 89] <author> Musser, D.R., and Stepanov, A.A. </author> <title> The Ada Generic Library: Linear List Processing Packages. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1989. </year>
Reference: [Neumann 93] <author> Neumann, P.G. </author> <title> Are dependable systems feasible? Comm. </title> <booktitle> ACM 36, </booktitle> <month> 2 (Feb. </month> <year> 1993), </year> <month> 146. </month>
Reference-contexts: There is serious doubt within the software engineering community about whether any software engineering discipline can predictably deal with the technical problems of engineering systems that are too large for one person to fully understand <ref> [CSTB 90, McCarthy 93, Neumann 93] </ref>. Why? It is just amazingly hard to arrange a large software system so that you have the ability to reason locally about its behavior. <p> There are papers on certification of various component properties (e.g., [Knight 91]), and questions about the very feasibility of dependable large systems <ref> [Neumann 93] </ref>. But there is surprisingly little work that pinpoints local certifiability as an essential aspect of a scalable software engineering discipline or that explicitly discusses the technical problems associated with it.
Reference: [Parnas 85] <author> Parnas, </author> <title> D.L. Software aspects of strategic defense systems. </title> <journal> Comm. ACM 28, </journal> <month> 12 (Dec. </month> <year> 1985), </year> <pages> 1326-1335. </pages>
Reference-contexts: Clearly, for a large system there is no feasible way to do this. For life-critical embedded systems the infeasibility of demonstrating correctness in advance is crucial. This was a key point of attack by Parnas and by others on anticipated problems with software for the Strategic Defense Initiative <ref> [Parnas 85] </ref>. Furthermore, adaptive and perfective maintenance problems for systems that do not support local certifiability remain incredibly difficult and costly even if you can make those systems work as they should in the current release. 6 4.
Reference: [Sitaraman 92] <author> Sitaraman, M. </author> <title> Performance-parameterized reusable software components. </title> <journal> Intl. J. Software Eng. and Knowledge Eng. </journal> <volume> 2, </volume> <month> 4 (Dec. </month> <year> 1992), </year> <pages> 567-587. 10 </pages>
Reference-contexts: Composability A high-quality component should be readily composable with other high quality components designed according to the software engineering discipline. This is necessary in order to define and implement larger components. It is still a research matter to define properties such as efficiency <ref> [Sitaraman 92] </ref> and composability [Edwards 93] more precisely, to identify other objective properties that should be locally certifiable, and to determine whether and how local certification is to be achieved. <p> Achieving local certification of this kind of property requires development of a calculus for composing summary performance information about components into comparable information about a client program, which is still an open problem <ref> [Sitaraman 92] </ref>. It turns out that you can easily establish certain negative results about local certifiability of performance, because many classical techniques for analysis of algorithms simply do not scale. <p> We postulate that methods similar to those we have applied to verify functionality will form the basis for verifying performance. But significant aspects of the approach, and many details, remain to be worked out <ref> [Sitaraman 92] </ref>. Acknowledgment Bill Ogden, Stu Zweben, Steve Edwards, Wayne Heym, Murali Sitaraman, Tim Long, Neelam Soundararajan, B. Chandrasekaran, and Dean Allemang have provided helpful insights and/or feedback on the ideas presented here.
Reference: [Tracz 90] <author> Tracz, W. </author> <title> The three cons of software reuse. </title> <booktitle> Proc. 3rd Ann. Workshop: Methods and Tools for Reuse, </booktitle> <institution> Syracuse Univ. CASE Center, </institution> <month> June </month> <year> 1990. </year>
Reference: [Weber 92] <author> Weber, F. </author> <title> Getting class correctness and system correctness equivalent: how to get covariance right. </title> <booktitle> In Proc. TOOLS USA 92, </booktitle> <editor> R. Ege, M. Singh, and B. Meyer, eds., </editor> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: This paper also does not deal with other desirable system properties that you might like to certify locally. The work of <ref> [Weber 92] </ref> is more practical in that it describes techniques for avoiding unwanted component coupling in a real objectoriented programming setting. But it, too, deals only with type correctness and not with other crucial properties of software such as overall behavioral correctness, performance, etc.
Reference: [Weide 91] <author> Weide, B.W., Ogden, W.F., and Zweben, S.H. </author> <title> Reusable software components. </title> <booktitle> In Advances in Computers, </booktitle> <volume> vol. 33, </volume> <editor> M.C. Yovits, ed., </editor> <publisher> Academic Press, </publisher> <year> 1991, </year> <pages> 1-65. </pages>
Reference: [Weide 92] <author> Weide, B.W., and Hollingsworth, </author> <title> J.E. Scalability of reuse technology to large systems requires local certifiability. </title> <booktitle> Proc. 5th Ann.Workshop on Software Reuse, </booktitle> <address> Palo Alto, CA, </address> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: The primary contribution of this paper is an explanation in the context of reuse of the importance of answering these questions. While there has been some progress (e.g., [Hollingsworth 92b]) the problems in many respects remain open <ref> [Weide 92] </ref>. 1 The paper is organized as follows. Section 2 illustrates the fundamental problem of locality of reasoning about program behavior, which faces anyone who proposes a software engineering discipline that is purported to work for large systems.
Reference: [Weide 93] <author> Weide, B.W., Heym, W.D., and Ogden, W.F. </author> <title> Procedure calls and local certifiability of component correctness. </title> <booktitle> Proc. 6th Ann.Workshop on Software Reuse, </booktitle> <address> Owego, NY, </address> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Many widely-practiced programming techniques ones taught in contemporary programming and software engineering textbooks and held up as good practice are the antithesis of those needed to support modular reasoning and local certification <ref> [Harms 91, Hollingsworth 91a, Hollingsworth 92a, Hollingsworth 92b, Weide 93] </ref>. The total amount of code that you must consider in an argument that treats a component-built program as a monolith grows combinatorially as you progress up the hierarchy to larger and larger components. <p> Because of the language definitions, you cannot modularly verify every syntactically legal program in, say, Ada or C++, even if they might be correct <ref> [Weide 93] </ref>. The proof rules in [Krone 88] apply to a version of our language, RESOLVE, in which practices that thwart modular verification are prohibited by the language itself. <p> Characterizing such a style for Ada is one of the main 2 A superficial analysis of the results of [Cook 78] suggests otherwise; but see Section 4 and <ref> [Weide 93] </ref>. 5 contributions of [Hollingsworth 92b]. How the RESOLVE/Ada Discipline lets you achieve local certifiability cannot be summarized acceptably in a short paper such as this one, but [Hollingsworth 92b] is readily available via the Internet (see the bibliography) if you are interested in details and numerous examples. <p> like to believe otherwise (i.e., that local certifiability of correctness is a solved technical problem), the existence of a sound and relatively complete modular proof system for Cooks simple language and slight variants of it certainly does not imply that you can reason modularly about arbitrary Ada or C++ programs <ref> [Ernst 91, Weide 93] </ref>. There has been some work in the objectoriented programming community on making class correctness tantamount to system correctness. This work seems to be limited to one aspect of type correctness, i.e., making subtypes and supertypes behave properly in clients in all relevant respects.
Reference: [Wilde 93] <author> Wilde, N., Matthews, P., and Huitt, R. </author> <title> Maintaining objectoriented software. </title> <booktitle> IEEE Software 10, </booktitle> <month> 1 (Jan </month> <year> 1993), </year> <pages> 75-80. 11 </pages>
Reference-contexts: Attention to local certifiability during design and development will be especially beneficial in reducing subsequent maintenance problems, which clearly are the most costly part of the software life-cycle, especially for objectoriented designs <ref> [Wilde 93] </ref>. If satisfactory answers cannot be found, then the software engineering field will find itself in serious trouble.
References-found: 31

