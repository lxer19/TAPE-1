URL: http://www.csc.ncsu.edu/eos/users/j/jrossie/www/papers/oopsla95.ps.gz
Refering-URL: http://www.csc.ncsu.edu/eos/users/j/jrossie/www/papers.html
Root-URL: http://www.csc.ncsu.edu
Email: fjrossie,dfriedg@cs.indiana.edu  
Title: An Algebraic Semantics of Subobjects  
Author: Jonathan G. Rossie, Jr. Daniel P. Friedman 
Address: 215 Lindley Hall, Bloomington, Indiana 47405  
Affiliation: Department of Computer Science, Indiana University  
Date: Revised: January 9, 1996  
Note: In Proceedings OOPSLA'95  
Abstract: Existing formalisms of inheritance are not sufficient to model the complexities of the kind of multiple inheritance exemplified in C++. Any satisfactory formalism must model the complicating effects of virtual and non-virtual base classes as well as virtual and non-virtual methods. By abstracting the implementational notion of a subobject and formalizing subobject selection, we develop a formalism to model this combination of features. Not intended as a formal semantics of C++, the resulting model should nevertheless provide an essential level of understanding for language theorists and implementors in their dealings with C++ and related languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> BOBROW, D. G., KAHN, K., KICZALES, G., MASINTER, L., STEFIK, M., AND ZDYBEL, F. CommonLoops: </author> <title> Merging Lisp and object-oriented programming. </title> <booktitle> In Proceedings OOPSLA '86, ACM SIGPLAN Notices (1986), </booktitle> <pages> pp. 17-29. </pages>
Reference-contexts: Some multiple-inheritance designs make no effort to maintain the integrity of subobjects. In CLOS [34] and related systems <ref> [1, 23, 14] </ref>, linearization of the inheritance hierarchy results in a collapsing of same-named methods and instance-variables; in some sense, they support only shared base classes. <p> Then b would no longer be ambiguous in H since the only reachable definition would be in hH; Fi. 6 Related Work The problem of combining multiple hierarchies has been dealt with in many ways. Snyder [32] divides these into linear and graph-oriented approaches. Linear approaches, such as <ref> [1, 23, 12, 13, 14] </ref>, do not model subobject integrity. Graph-oriented approaches, all of which are capable of supporting subobject integrity in some way, include extended Smalltalk [2], Trellis/Owl [29], CommonObjects [31], ROME [7], and the Krogdahl/Stroustrup model discussed here.
Reference: [2] <author> BORNING, A., AND INGALLS, D. </author> <title> Multiple inheritance in Smalltalk-80. </title> <booktitle> In Proceedings AAAI '82 (1982), </booktitle> <pages> pp. 234-237. </pages>
Reference-contexts: Snyder [32] divides these into linear and graph-oriented approaches. Linear approaches, such as [1, 23, 12, 13, 14], do not model subobject integrity. Graph-oriented approaches, all of which are capable of supporting subobject integrity in some way, include extended Smalltalk <ref> [2] </ref>, Trellis/Owl [29], CommonObjects [31], ROME [7], and the Krogdahl/Stroustrup model discussed here. Some formal models of graph-oriented multiple inheritance systems [20, 36] have been based on class-name posets rather than class-name graphs. As discussed earlier, the transition from graph to poset can lead to information loss.
Reference: [3] <author> CARDELLI, L. </author> <title> A semantics for multiple inheritance. In Semantics of Data Types, </title> <editor> G. Kahn, D. B. MacQueen, and G. Plotkin, Eds., </editor> <publisher> LNCS 173. Springer-Verlag, </publisher> <address> New York, </address> <year> 1984, </year> <pages> pp. 51-67. </pages>
Reference-contexts: Formal semantic models of single-inheritance languages [19, 26, 10, 9] are so deeply reliant on there being a single base class that they do not scale up into multiple inheritance. Formal models of multiple inheritance have arisen in the study of type systems for object-oriented languages <ref> [3, 4, 5, 25, 8] </ref>. Because these models treat objects as records, an object may only associate a single value with each name. Accordingly, such models do not address subobject integrity. <p> As discussed earlier, the transition from graph to poset can lead to information loss. At the class-name level, this loss of path information leads to the collapsing of some distinct subobjects, and is insufficient to model the kind of inheritance we have formalized. Cardelli's model of multiple inheritance <ref> [3, 5, 4] </ref> is closely tied to a record representation of objects, and does not attempt to maintain subobject integrity; similarly with Compagnoni and Pierce [25, 8].
Reference: [4] <author> CARDELLI, L. </author> <title> A semantics of multiple inheritance. </title> <booktitle> Information and Computation 76 (1988), </booktitle> <pages> 138-164. </pages> <booktitle> Special issue devoted to Symp. on Semantics of Data Types, Sophia-Antipolis (France), </booktitle> <year> 1984. </year>
Reference-contexts: Formal semantic models of single-inheritance languages [19, 26, 10, 9] are so deeply reliant on there being a single base class that they do not scale up into multiple inheritance. Formal models of multiple inheritance have arisen in the study of type systems for object-oriented languages <ref> [3, 4, 5, 25, 8] </ref>. Because these models treat objects as records, an object may only associate a single value with each name. Accordingly, such models do not address subobject integrity. <p> As discussed earlier, the transition from graph to poset can lead to information loss. At the class-name level, this loss of path information leads to the collapsing of some distinct subobjects, and is insufficient to model the kind of inheritance we have formalized. Cardelli's model of multiple inheritance <ref> [3, 5, 4] </ref> is closely tied to a record representation of objects, and does not attempt to maintain subobject integrity; similarly with Compagnoni and Pierce [25, 8].
Reference: [5] <author> CARDELLI, L., AND WEGNER, P. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys 17, </journal> <volume> 4 (1985), </volume> <pages> 471-522. </pages>
Reference-contexts: Formal semantic models of single-inheritance languages [19, 26, 10, 9] are so deeply reliant on there being a single base class that they do not scale up into multiple inheritance. Formal models of multiple inheritance have arisen in the study of type systems for object-oriented languages <ref> [3, 4, 5, 25, 8] </ref>. Because these models treat objects as records, an object may only associate a single value with each name. Accordingly, such models do not address subobject integrity. <p> As discussed earlier, the transition from graph to poset can lead to information loss. At the class-name level, this loss of path information leads to the collapsing of some distinct subobjects, and is insufficient to model the kind of inheritance we have formalized. Cardelli's model of multiple inheritance <ref> [3, 5, 4] </ref> is closely tied to a record representation of objects, and does not attempt to maintain subobject integrity; similarly with Compagnoni and Pierce [25, 8].
Reference: [6] <author> CARGILL, T. A. </author> <title> Controversy: The case against multiple inheritance in C++. </title> <booktitle> Computing Systems 4, 1 (1991), </booktitle> <pages> 69-82. </pages>
Reference-contexts: All of these issues contribute to the complexity of the inheritance model. Cargill <ref> [6] </ref> makes an ample case for the complexity of the system; arguing against the introduction of Stroustrup's multiple inheritance system into C++, he observes (p.71) Multiple inheritance in C++ is complicated to learn, write and read.
Reference: [7] <author> CARR E, B., AND GEIB, J.-M. </author> <title> The point of view notion for multiple inheritance. </title> <booktitle> In Proceedings OOPSLA-ECOOP '90, ACM SIGPLAN Notices (1990), </booktitle> <pages> pp. 312-321. </pages>
Reference-contexts: Subobject integrity simply means that distinct storage is maintained for every instance variable, even when more than one share the same name. The term is our own, but similar notions appear under different names, including object integrity [27] and the independence principle <ref> [7] </ref>. It has been vehemently argued that such a condition is necessary for the adequate separation of implementation and interface [32]. <p> Snyder [32] divides these into linear and graph-oriented approaches. Linear approaches, such as [1, 23, 12, 13, 14], do not model subobject integrity. Graph-oriented approaches, all of which are capable of supporting subobject integrity in some way, include extended Smalltalk [2], Trellis/Owl [29], CommonObjects [31], ROME <ref> [7] </ref>, and the Krogdahl/Stroustrup model discussed here. Some formal models of graph-oriented multiple inheritance systems [20, 36] have been based on class-name posets rather than class-name graphs. As discussed earlier, the transition from graph to poset can lead to information loss.
Reference: [8] <author> COMPAGNONI, A. B., AND PIERCE, B. C. </author> <title> Multiple inheritance via intersection types. </title> <type> Tech. Rep. </type> <institution> ECS-LFCS-93-275, University of Edinburgh, </institution> <year> 1993. </year> <type> Also Technical Report 93-18, C.S. </type> <institution> Department, Catholic University Nijmegen. </institution> <note> 197 In Proceedings OOPSLA'95 Revised: January 9, </note> <year> 1996 </year>
Reference-contexts: Formal semantic models of single-inheritance languages [19, 26, 10, 9] are so deeply reliant on there being a single base class that they do not scale up into multiple inheritance. Formal models of multiple inheritance have arisen in the study of type systems for object-oriented languages <ref> [3, 4, 5, 25, 8] </ref>. Because these models treat objects as records, an object may only associate a single value with each name. Accordingly, such models do not address subobject integrity. <p> Cardelli's model of multiple inheritance [3, 5, 4] is closely tied to a record representation of objects, and does not attempt to maintain subobject integrity; similarly with Compagnoni and Pierce <ref> [25, 8] </ref>. In effect, the 196 In Proceedings OOPSLA'95 Revised: January 9, 1996 same may be said for Eiffel [18, 22]: distinct storage is maintained only if the programmer renames all members to protect against conflicts.
Reference: [9] <author> COOK, W., AND PALSBERG, J. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proceedings OOPSLA '89, ACM SIGPLAN Notices (1989), </booktitle> <pages> pp. 433-443. </pages>
Reference-contexts: In CLOS [34] and related systems [1, 23, 14], linearization of the inheritance hierarchy results in a collapsing of same-named methods and instance-variables; in some sense, they support only shared base classes. Formal semantic models of single-inheritance languages <ref> [19, 26, 10, 9] </ref> are so deeply reliant on there being a single base class that they do not scale up into multiple inheritance. Formal models of multiple inheritance have arisen in the study of type systems for object-oriented languages [3, 4, 5, 25, 8].
Reference: [10] <author> COOK, W. R. </author> <title> A Denotational Semantics of Inheritance. </title> <type> PhD thesis, </type> <institution> Brown University, </institution> <year> 1989. </year> <note> Technical Report CS-89-33. </note>
Reference-contexts: In CLOS [34] and related systems [1, 23, 14], linearization of the inheritance hierarchy results in a collapsing of same-named methods and instance-variables; in some sense, they support only shared base classes. Formal semantic models of single-inheritance languages <ref> [19, 26, 10, 9] </ref> are so deeply reliant on there being a single base class that they do not scale up into multiple inheritance. Formal models of multiple inheritance have arisen in the study of type systems for object-oriented languages [3, 4, 5, 25, 8].
Reference: [11] <author> DAVEY, B. A., AND PRIESTLY, H. A. </author> <title> Introduction to Lattices and Order. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: See, for example, Davey and Priestly <ref> [11] </ref>. Throughout our discussion, we shall make reference to Figure 1, which shows both a class hierarchy (left) and the derived poset of subobjects (right). In each case x &lt; y implies that x appears lower than y, and that x inherits from (is derived from) y.
Reference: [12] <author> DUCOURNAU, R., AND HABIB, M. </author> <title> On some algorithms for multiple inheritance in object oriented programming. </title> <booktitle> In Proceedings ECOOP '87 (1987), </booktitle> <publisher> LNCS 276, Springer-Verlag, </publisher> <pages> pp. 243-252. </pages>
Reference-contexts: Then b would no longer be ambiguous in H since the only reachable definition would be in hH; Fi. 6 Related Work The problem of combining multiple hierarchies has been dealt with in many ways. Snyder [32] divides these into linear and graph-oriented approaches. Linear approaches, such as <ref> [1, 23, 12, 13, 14] </ref>, do not model subobject integrity. Graph-oriented approaches, all of which are capable of supporting subobject integrity in some way, include extended Smalltalk [2], Trellis/Owl [29], CommonObjects [31], ROME [7], and the Krogdahl/Stroustrup model discussed here.
Reference: [13] <author> DUCOURNAU, R., HABIB, M., HUCHARD, M., AND MUGNIER, M. L. </author> <title> Monotonic conflict resolution mechanisms for multiple inheritance. </title> <booktitle> In Proceedings OOPSLA '92, ACM SIGPLAN Notices (1992), </booktitle> <pages> pp. 16-24. </pages>
Reference-contexts: Then b would no longer be ambiguous in H since the only reachable definition would be in hH; Fi. 6 Related Work The problem of combining multiple hierarchies has been dealt with in many ways. Snyder [32] divides these into linear and graph-oriented approaches. Linear approaches, such as <ref> [1, 23, 12, 13, 14] </ref>, do not model subobject integrity. Graph-oriented approaches, all of which are capable of supporting subobject integrity in some way, include extended Smalltalk [2], Trellis/Owl [29], CommonObjects [31], ROME [7], and the Krogdahl/Stroustrup model discussed here.
Reference: [14] <author> DUCOURNAU, R., HABIB, M., HUCHARD, M., AND MUGNIER, M. L. </author> <title> Proposal for a monotonic multiple inheritance linearization. </title> <booktitle> In Proceedings OOPSLA '94, ACM SIGPLAN Notices (1994), </booktitle> <pages> pp. 164-175. </pages>
Reference-contexts: Some multiple-inheritance designs make no effort to maintain the integrity of subobjects. In CLOS [34] and related systems <ref> [1, 23, 14] </ref>, linearization of the inheritance hierarchy results in a collapsing of same-named methods and instance-variables; in some sense, they support only shared base classes. <p> Then b would no longer be ambiguous in H since the only reachable definition would be in hH; Fi. 6 Related Work The problem of combining multiple hierarchies has been dealt with in many ways. Snyder [32] divides these into linear and graph-oriented approaches. Linear approaches, such as <ref> [1, 23, 12, 13, 14] </ref>, do not model subobject integrity. Graph-oriented approaches, all of which are capable of supporting subobject integrity in some way, include extended Smalltalk [2], Trellis/Owl [29], CommonObjects [31], ROME [7], and the Krogdahl/Stroustrup model discussed here.
Reference: [15] <author> ELLIS, M. A., AND STROUSTRUP, B. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction The style of multiple inheritance first proposed for Sim-ula by Krogdahl [21] and later developed into the C++ multiple inheritance system by Stroustrup <ref> [35, 15] </ref> exemplifies a particular kind of inheritance in which the underlying imperative is to maintain the integrity of subobjects. Subobjects are historically an implementa-tional concept, consisting of the storage for any instance variables introduced by a given class, along with some header information. <p> By grouping all member names into a single set, we eliminate any distinction based on the name itself. Rather, we provide two operations for referencing members: dyn for dynamic (virtual) method references, and stat for the other (static) references. In both kinds of references, the dominance rule <ref> [15] </ref> is used to help disambiguate common inheritance situations that arise with shared base classes.
Reference: [16] <author> FRIEDMAN, D. P., HAYNES, C. T., MEND-HEKAR, A., AND ROSSIE, JR., J. G. </author> <title> Scheme++: </title>
Reference-contexts: Despite our formal simplifications, and partly thanks to them, we have found this model to be an invaluable aid in our design and implementation of a mostly-static multiple inheritance object system with first-class classes <ref> [16] </ref>. As Snyder suggests, modeling these features entails a certain amount of complexity. It must be remembered that the complexity is not artificially introduced by the formalism, but that the formalism is only as complicated as necessary to model its complex subject.
References-found: 16

