URL: http://www.csd.uu.se/~hamfelt/pub/NGCRevised.ps
Refering-URL: http://www.csd.uu.se/~hamfelt/
Root-URL: 
Title: Towards a Logic Programming Methodology based on Higher-order Predicates 1 induction principles (e.g. structural induction
Author: Andreas Hamfelt Jtrgen Fischer Nilsson 
Keyword: Higher-order and metalogic programming; recursion schemes; composition, parameterization, and modularization of logic programs.  
Note: Some of the proposed recursion operators are actualizations of mathematical  
Address: Denmark  
Affiliation: Computing Science Department Uppsala University  Department of Computer Science Technical University of  
Abstract: This paper outlines a logic programming methodology which applies standardized logic program recursion forms afforded by a system of general purpose recursion schemes. The recursion schemes are conceived of as quasi higher-order predicates which accept predicate arguments, thereby representing parameterized program modules. This use of higher-order predicates is analogous to higher-order functionals in functional programming. However, these quasi higher-order predicates are handled by a metalogic programming technique within ordinary logic programming. We carry out a pragmatic feasibility study of the proposed recursion operators with respect to the corpus of common textbook logic programs. This pragmatic investigation is accompanied with an analysis of the theoretical expressivity. The main theoretical results concerning computability are (1) Primitive recursive functions can be re-expressed in logic programming by predicates defined solely by non-recursive clauses augmented with a fold recursion predicate akin to the fold operators in functional programming. (2) General recursive functions can be re-expressed likewise since fold allows re-expression of a linrec recursion predicate facilitating linear, unbounded recursion. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Gegg-Harrison, </author> <title> T.S., "Representing Logic Program Schemata in Prolog," </title> <booktitle> in Proceedings of the Twelfth International Conference on Logic Programming 1995, </booktitle> <editor> (Sterling, L., ed.), </editor> <publisher> MIT Press, London, </publisher> <pages> pp. 467-481, </pages> <year> 1995. </year>
Reference-contexts: In this way the program is imposed a discipline concerning choice of recursion structures. Similar recursion structures are proposed in a related but independent work for pure higher-order logic programming in prolog <ref> [1] </ref>. Other proposals for recursion templates are found in [2, 3, 21, 22]. Use of higher-order functions for composition and structuring of programs is a well-established part of functional programming methodology, cf. e.g., [5, 6].
Reference: [2] <author> Marakakis, E. and Gallagher, J. P., </author> <title> "Schema-Based Top-Down Design of Logic Programs Using Abstract Data Types," </title> <editor> in Fribourg, L. and Turini, F. (eds.) </editor> <title> Logic Program Synthesis and Transformation - Meta-Programming in Logic, </title> <publisher> LNCS 883, Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In this way the program is imposed a discipline concerning choice of recursion structures. Similar recursion structures are proposed in a related but independent work for pure higher-order logic programming in prolog [1]. Other proposals for recursion templates are found in <ref> [2, 3, 21, 22] </ref>. Use of higher-order functions for composition and structuring of programs is a well-established part of functional programming methodology, cf. e.g., [5, 6].
Reference: [3] <author> Sterling, L. and Kirschenbaum, M., </author> <title> Applying Techniques to Skeleton, </title> <booktitle> in [4]. </booktitle>
Reference-contexts: In this way the program is imposed a discipline concerning choice of recursion structures. Similar recursion structures are proposed in a related but independent work for pure higher-order logic programming in prolog [1]. Other proposals for recursion templates are found in <ref> [2, 3, 21, 22] </ref>. Use of higher-order functions for composition and structuring of programs is a well-established part of functional programming methodology, cf. e.g., [5, 6].
Reference: [4] <author> Jacquet, J.-M., (ed.), </author> <title> Constructing Logic Programs, </title> <publisher> Wiley, </publisher> <year> 1993. </year>
Reference: [5] <author> Bird, R. and Wadler, Ph., </author> <title> Introduction to Functional Programming, </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Other proposals for recursion templates are found in [2, 3, 21, 22]. Use of higher-order functions for composition and structuring of programs is a well-established part of functional programming methodology, cf. e.g., <ref> [5, 6] </ref>. In analogy to functional programming recursion schemes (recursion operators) are provided here as higher-order predicates defined by appropriate clauses, from which concrete logic programs come about by instantiation of predicate parameters with predicate constants. All recursions are to be expressed by the higher-order predicates. <p> Thirdly, the higher-order logic framework avoids most of the computational overhead inherent in the general comprehensive metainterpreter approach. 3 Basic Higher-order Recursion Predicates We introduce in this section two quasi higher-order predicates (recursion operators) which are inspired by the following two functionals foldright and foldleft from higher-order functional programming <ref> [5, 6, 13, 14] </ref>: foldr f y nil = y foldr f y x.xs = f x (foldr f y xs) and foldl f y nil = y foldl f y x.xs = foldl f (f x y) xs The relational counterparts we formulate as foldr (P; Q)(Y; L; Z) Q
Reference: [6] <author> Reade, C., </author> <title> Elements of Functional Programming, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Other proposals for recursion templates are found in [2, 3, 21, 22]. Use of higher-order functions for composition and structuring of programs is a well-established part of functional programming methodology, cf. e.g., <ref> [5, 6] </ref>. In analogy to functional programming recursion schemes (recursion operators) are provided here as higher-order predicates defined by appropriate clauses, from which concrete logic programs come about by instantiation of predicate parameters with predicate constants. All recursions are to be expressed by the higher-order predicates. <p> Thirdly, the higher-order logic framework avoids most of the computational overhead inherent in the general comprehensive metainterpreter approach. 3 Basic Higher-order Recursion Predicates We introduce in this section two quasi higher-order predicates (recursion operators) which are inspired by the following two functionals foldright and foldleft from higher-order functional programming <ref> [5, 6, 13, 14] </ref>: foldr f y nil = y foldr f y x.xs = f x (foldr f y xs) and foldl f y nil = y foldl f y x.xs = foldl f (f x y) xs The relational counterparts we formulate as foldr (P; Q)(Y; L; Z) Q
Reference: [7] <author> Warren, D. H. D., </author> <title> "Higher-order extensions to PROLOG: are they needed ?," D. </title> <editor> Michie (ed.): </editor> <booktitle> Machine Intelligence 10, </booktitle> <publisher> Ellis Horwood and Edinburgh University Press, </publisher> <pages> pp. 441-454, </pages> <year> 1982. </year> <month> 22 </month>
Reference-contexts: Higher-order predicates (with the accompanying predicate argument variables) are not available in ordinary first-order logic programming languages. However, the facilities needed can be obtained in the setting of ordinary logic programming through a well-known metalogic programming technique originating in <ref> [7] </ref> as explained in sect. 2, which leaves intact the overall program structure. This choice puts our approach in between pure higher-order and pure metalogic programming thus avoiding intricacies of both. A basic repertoire of recursion operators are introduced in sect. 3, conforming with a previous paper [8]. <p> See however, sect. 10 for obtaining a declarative understanding of the programs. This extension of first-order clauses, which neglects concern to higher-order axioms, should be paralleled with the availability of higher-order functions in functional programming. 2.2 Basic Higher-order Functionality through Metalogic Using the method in <ref> [7] </ref> the above higher-order atom P term (t 1 ; : : : ; t n ) is handled in e.g., prolog as the first-order atom a (P term; t 1 ; : : : ; t n ) where a (for apply) is a distinguished predicate expressing predication, that is
Reference: [8] <author> Nilsson, J. Fischer and Hamfelt, A., </author> <title> "Constructing Logic Programs with Higher Order Predicates," </title> <booktitle> in Proceedings of GULP-PRODE'95, the Joint Conference on Declarative Programming 1995, </booktitle> <editor> (Alpuente, M., and Sessa, M. I. eds.), Universita Degli Studi di Salerno, </editor> <booktitle> Salerno, </booktitle> <pages> pp. 307-312, </pages> <year> 1995. </year>
Reference-contexts: This choice puts our approach in between pure higher-order and pure metalogic programming thus avoiding intricacies of both. A basic repertoire of recursion operators are introduced in sect. 3, conforming with a previous paper <ref> [8] </ref>. However in contrast to the quest for one universal recursion form in [8], the approach in the present paper is to conduct a "bottom-up" study of programs expressible within the HOLP technique starting from the repertoire of basic operators. <p> This choice puts our approach in between pure higher-order and pure metalogic programming thus avoiding intricacies of both. A basic repertoire of recursion operators are introduced in sect. 3, conforming with a previous paper <ref> [8] </ref>. However in contrast to the quest for one universal recursion form in [8], the approach in the present paper is to conduct a "bottom-up" study of programs expressible within the HOLP technique starting from the repertoire of basic operators. <p> is an indirect proof that solvel accommodates (all) general recursive functions and hence goes beyond the bounded recursion fold schemes. 19 9.4 Divide-and-Conquer Scheme as Derivative There is another useful specialization of the general solve operator, namely the so called divide and conquer scheme e.g. [20, 21, 22], see also <ref> [8] </ref>: divconq (Elemgoal ; Decomp; Comp)(G; R) Elemgoal (G; R) divconq (Elemgoal ; Decomp; Comp)(G; R) Decomp (G; G1; G2) divconq (Elemgoal; Decomp; Comp)(G1; R1) divconq (Elemgoal; Decomp; Comp)(G2; R2) Comp (G; R1; R2; R) with an omitted or-branching compared with the and-or problem reduction scheme, as well as with discarded <p> This operator affords logic programs such as flattening of lists and quicksort as shown in <ref> [8] </ref>. 9.5 Ackermann's Function Finally, we give an example of a logic program that calls for the expressive power of solve. ackermann ([],N,[[]jN]). ackermann ([[]jM],[],V) ackermann (M,[[]],V). ackermann ([[]jM],[[]jN],V) ackermann ([[]jM],N,V1), ackermann (M,V1,V).
Reference: [9] <author> Sterling, L. and Shapiro, E., </author> <title> The Art of Prolog, </title> <publisher> MIT Press, </publisher> <year> 1986, 1991. </year>
Reference-contexts: More sophisticated programs such as parsers and (meta)interpreters are considered in sect. 8 and 9. The primary intention of this exploration is to establish the pragmatic adequacy of the recursion operators by formulating within HOLP a comprehensive corpus of common logic programs, using mainly <ref> [9] </ref> as source and reference. This study in turn is to provide the foundation for a HOLP logic programming methodology encouraging and supporting reuse of program modules. <p> Some of them serve as predicate arguments to the recursion operators. 4 Basic Logic Programs In this section are given solutions to a representative selection of pure logic programming examples concerning natural numbers and lists in the text book <ref> [9] </ref>. The purpose of this section is to show that the programs can be coped with using solely the above foldright and foldleft operators. 4.1 Natural Number Processing The HOLP approach favours replacement of general compound terms with list terms. <p> Now times can be defined as times (X,Y,Z) foldr ((plus (X),null), ,Y,Z). a (null, ,[],[]). exponential analogously as exp (X,Y,Z) foldr ((times (X),one), ,Y,Z). a (times (X), ,Y,Z) a (times,X,Y,Z). a (one, ,[],[[]]). factorial (p. 39 in <ref> [9] </ref>) using the natural number recursion scheme can be expressed as factorial (X,Y) natrec ((times,isone),X,Y). a (isone,[[]]). <p> One observes that this program takes advantage of the generalized version of foldr where the bases case is not confined to the empty list. This applies to the following predicate as well. Suffix (p. 45 in <ref> [9] </ref>) can be expressed as suffix (Xs,Ys) foldr ((true,id1),Xs,Ys, ). a (id1,L,L, ). prefix (p. 45 in [9]) as prefix (Xs,Ys) foldr ((cons,trueq), ,Xs,Ys). a (cons,X,Xs,[XjXs]). a (trueq, ,[], ). Non-nave reverse (p. 48 in [9]) can be expressed simply as reverse (U,V) foldl ((cons,id),[],U,V). length (p. 49 in [9]) as <p> This applies to the following predicate as well. Suffix (p. 45 in <ref> [9] </ref>) can be expressed as suffix (Xs,Ys) foldr ((true,id1),Xs,Ys, ). a (id1,L,L, ). prefix (p. 45 in [9]) as prefix (Xs,Ys) foldr ((cons,trueq), ,Xs,Ys). a (cons,X,Xs,[XjXs]). a (trueq, ,[], ). Non-nave reverse (p. 48 in [9]) can be expressed simply as reverse (U,V) foldl ((cons,id),[],U,V). length (p. 49 in [9]) as length (X,Y) foldr ((p,nil), ,X,Y). 9 a (p,F,Z,[[]jZ]). delete (p. 53 in [9]) with currying as delete <p> This applies to the following predicate as well. Suffix (p. 45 in <ref> [9] </ref>) can be expressed as suffix (Xs,Ys) foldr ((true,id1),Xs,Ys, ). a (id1,L,L, ). prefix (p. 45 in [9]) as prefix (Xs,Ys) foldr ((cons,trueq), ,Xs,Ys). a (cons,X,Xs,[XjXs]). a (trueq, ,[], ). Non-nave reverse (p. 48 in [9]) can be expressed simply as reverse (U,V) foldl ((cons,id),[],U,V). length (p. 49 in [9]) as length (X,Y) foldr ((p,nil), ,X,Y). 9 a (p,F,Z,[[]jZ]). delete (p. 53 in [9]) with currying as delete (Xs,Z,Ys) foldr ((purge (Z),null), ,Xs,Ys). a (purge (Z),Z,Xs,Xs). a (purge (Z),F,Xs,[FjXs]) notequal (Z,F). a (null, ,[],[]). where the <p> in <ref> [9] </ref>) can be expressed as suffix (Xs,Ys) foldr ((true,id1),Xs,Ys, ). a (id1,L,L, ). prefix (p. 45 in [9]) as prefix (Xs,Ys) foldr ((cons,trueq), ,Xs,Ys). a (cons,X,Xs,[XjXs]). a (trueq, ,[], ). Non-nave reverse (p. 48 in [9]) can be expressed simply as reverse (U,V) foldl ((cons,id),[],U,V). length (p. 49 in [9]) as length (X,Y) foldr ((p,nil), ,X,Y). 9 a (p,F,Z,[[]jZ]). delete (p. 53 in [9]) with currying as delete (Xs,Z,Ys) foldr ((purge (Z),null), ,Xs,Ys). a (purge (Z),Z,Xs,Xs). a (purge (Z),F,Xs,[FjXs]) notequal (Z,F). a (null, ,[],[]). where the argument predicate purge leaves F if it is not equal to the Z to <p> prefix (p. 45 in <ref> [9] </ref>) as prefix (Xs,Ys) foldr ((cons,trueq), ,Xs,Ys). a (cons,X,Xs,[XjXs]). a (trueq, ,[], ). Non-nave reverse (p. 48 in [9]) can be expressed simply as reverse (U,V) foldl ((cons,id),[],U,V). length (p. 49 in [9]) as length (X,Y) foldr ((p,nil), ,X,Y). 9 a (p,F,Z,[[]jZ]). delete (p. 53 in [9]) with currying as delete (Xs,Z,Ys) foldr ((purge (Z),null), ,Xs,Ys). a (purge (Z),Z,Xs,Xs). a (purge (Z),F,Xs,[FjXs]) notequal (Z,F). a (null, ,[],[]). where the argument predicate purge leaves F if it is not equal to the Z to be removed. <p> The predicate select can be defined as select (X,Y,Z) split (Y,Y1,[XjY2]),append (Y1,Y2,Z). split (X,Y,Z) append (Y,Z,X). ordered (p. 55 in <ref> [9] </ref>) as ordered (X) foldr ((p,q), ,X, ). a (p,F,[],[F]). a (q,X,[],[]). insert as insert (E,Xs,Ys) split (Xs,X1s,X2s),append (X1s,[EjX2s],Ys). allowing permutation (p. 54 in [9]) to be expressed as perm (Xs,Ys) foldr ((p,q), ,Xs,Ys). a (p,F,Z,W) insert (F,Z,W). a (q, ,[],[]). permutation sort as sort (Xs,Ys) perm (Xs,Ys),ordered (Ys). <p> The predicate select can be defined as select (X,Y,Z) split (Y,Y1,[XjY2]),append (Y1,Y2,Z). split (X,Y,Z) append (Y,Z,X). ordered (p. 55 in <ref> [9] </ref>) as ordered (X) foldr ((p,q), ,X, ). a (p,F,[],[F]). a (q,X,[],[]). insert as insert (E,Xs,Ys) split (Xs,X1s,X2s),append (X1s,[EjX2s],Ys). allowing permutation (p. 54 in [9]) to be expressed as perm (Xs,Ys) foldr ((p,q), ,Xs,Ys). a (p,F,Z,W) insert (F,Z,W). a (q, ,[],[]). permutation sort as sort (Xs,Ys) perm (Xs,Ys),ordered (Ys).
Reference: [10] <author> Andrews, P. B., </author> <title> An Introduction to Mathematical Logic and Type Theory: To truth through Proof, </title> <publisher> Academic Press, </publisher> <year> 1986. </year>
Reference-contexts: In the higher-order framework of logical type theory predicate terms are formed as predicate constants, predicate variables, and appropriate compound predicate expressions. These expressions may include the (typed) -calculus with abstraction as a generalisation of first-order terms, as in Church's re-formulation of The Simple Theory of Types, cf. e.g., <ref> [10] </ref>. In this context, besides predicate constants and variables, we include some restricted expression forms, but we dispense with - abstractions. We distinguish two types of terms: ordinary logic programming terms (i.e., individual terms including list terms), predicate terms.
Reference: [11] <author> Miller, D. A. and Nadathur, G., </author> <title> "Higher-order Logic Programming," </title> <booktitle> in Proceedings of the Third International Logic Programming Conference, </booktitle> <publisher> LNCS 225, Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Some predicate symbols may be generic or overloaded. Below is explained how this extension is coped with straightforwardly in ordinary logic programming. It should be observed that (in contrast to prolog <ref> [11] </ref> and HiLog [12]) function variables in terms are not admitted in individual terms, so our individual terms are as in prolog.
Reference: [12] <author> Chen, W., Kifer, M. and Warren, D. S., "HiLog: </author> <title> A Foundation for Higher-Order Logic Programming," </title> <journal> J. Logic Programming, </journal> <volume> Vol. 15, </volume> <year> 1993. </year> <pages> pp. 187-230. </pages>
Reference-contexts: Some predicate symbols may be generic or overloaded. Below is explained how this extension is coped with straightforwardly in ordinary logic programming. It should be observed that (in contrast to prolog [11] and HiLog <ref> [12] </ref>) function variables in terms are not admitted in individual terms, so our individual terms are as in prolog.
Reference: [13] <author> Backus, J., </author> <title> "Can Programming be Liberated From the von Neumann Style ? A Functional Style and its Algebra of Programs," </title> <journal> Comm. of the ACM, </journal> <volume> Vol. 21, No. 8, </volume> <pages> pp. 613-641, </pages> <year> 1978. </year>
Reference-contexts: Thirdly, the higher-order logic framework avoids most of the computational overhead inherent in the general comprehensive metainterpreter approach. 3 Basic Higher-order Recursion Predicates We introduce in this section two quasi higher-order predicates (recursion operators) which are inspired by the following two functionals foldright and foldleft from higher-order functional programming <ref> [5, 6, 13, 14] </ref>: foldr f y nil = y foldr f y x.xs = f x (foldr f y xs) and foldl f y nil = y foldl f y x.xs = foldl f (f x y) xs The relational counterparts we formulate as foldr (P; Q)(Y; L; Z) Q
Reference: [14] <author> Bird, R., </author> <title> "Lectures on Constructive Functional Programming," in Constructive Methods in Computing Science, </title> <editor> (Broy, M., ed.), </editor> <publisher> Springer-Verlag, </publisher> <year> 1989, </year> <pages> pp. 151-216. </pages>
Reference-contexts: Thirdly, the higher-order logic framework avoids most of the computational overhead inherent in the general comprehensive metainterpreter approach. 3 Basic Higher-order Recursion Predicates We introduce in this section two quasi higher-order predicates (recursion operators) which are inspired by the following two functionals foldright and foldleft from higher-order functional programming <ref> [5, 6, 13, 14] </ref>: foldr f y nil = y foldr f y x.xs = f x (foldr f y xs) and foldl f y nil = y foldl f y x.xs = foldl f (f x y) xs The relational counterparts we formulate as foldr (P; Q)(Y; L; Z) Q
Reference: [15] <author> Hamfelt, A. and Nilsson, J. Fischer, </author> <title> "Declarative Logic Programming with Primitive Recursive Relations on Lists," </title> <booktitle> in Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <editor> (Maher, P., ed.), </editor> <publisher> MIT Press 1996. Forthcoming. </publisher>
Reference-contexts: However, it is convenient to generalize the relational fold schemes so as to allow the base case to be computed by a certain predicate argument Q, cf. e.g., <ref> [15] </ref>. Furthermore, partial traversal of the input list is facilitated if the base case is not confined to the empty list. <p> Proof: By induction on the length of the input list, for the full proof see <ref> [15] </ref>. Let us stress again that these recursion operators can be understood as ordinary logic programs by simple rewriting as explained in the preceding section and exemplified just above. <p> As mentioned in the conclusion foldl can be defined in terms of foldr and vice versa in the declarative conception of logic programs. These connections between foldl and foldr can be exploited in adapting the above programs to different data flow modes, cf. <ref> [15] </ref>. <p> In functional programming methodology there has moreover been suggestions for generalising functions to relations with the aim of establishing algebraic rules for relational program derivation [26]. Since this work is restricted to binary predicates it is not obvious how to connect with logic programming. In the companion paper <ref> [15] </ref> we address the derivation of operational logic programs from declarative ones by considering data flow patterns for logic programs expressed by means of the recursions predicates. Obviously the recursion schemes ease data flow analysis by restricting the recursion patterns to fixed forms. <p> However, replacement of one fold operator by the other according to this theorem leads to programs behaving procedurally differently. This is applied as a HOLP programming refinement methodology in <ref> [15] </ref> for automatically selecting a procedurally appropriate form of the program also honouring the termination obligation. Acknowledgements The second author gratefully acknowledges a grant from Uppsala University. Thanks are also due to the anonymous referees for detailed comments, further references and suggestions for future research.
Reference: [16] <author> Kleene, S. C., </author> <title> Introduction to Metamathematics, </title> <address> Amsterdam, </address> <year> 1952. </year>
Reference-contexts: This illustrates how the HOLP methodology supports abstraction and reuse of programs by first introducing a general program solution, and then obtaining concrete programs by supplying appropriate predicate parameters. 5 Primitive Recursive Functions as Logic Pro grams Recursive function theory <ref> [16] </ref>, see also e.g., [17], establishes the foundation for computation of functions of one or more arguments over natural numbers. Let us consider forms of logic programs for computing such functions. <p> : : ; X i ; : : : ; X n ; X i ): for i 2 f1 : : : ng for relevant finite number of arguments 1; 2; : : : ; n; : : :. 5.2 Primitive Recursive Functions The class of primitive recursive functions <ref> [16, 17] </ref> is established through the following principles of composition and primitive recursion using the basic recursive functions as building blocks.
Reference: [17] <author> Boolos, G. S. and Jeffrey, J. C., </author> <title> Computability & Logic, </title> <address> Cambridge U. P., </address> <year> 1974. </year>
Reference-contexts: This illustrates how the HOLP methodology supports abstraction and reuse of programs by first introducing a general program solution, and then obtaining concrete programs by supplying appropriate predicate parameters. 5 Primitive Recursive Functions as Logic Pro grams Recursive function theory [16], see also e.g., <ref> [17] </ref>, establishes the foundation for computation of functions of one or more arguments over natural numbers. Let us consider forms of logic programs for computing such functions. <p> : : ; X i ; : : : ; X n ; X i ): for i 2 f1 : : : ng for relevant finite number of arguments 1; 2; : : : ; n; : : :. 5.2 Primitive Recursive Functions The class of primitive recursive functions <ref> [16, 17] </ref> is established through the following principles of composition and primitive recursion using the basic recursive functions as building blocks.
Reference: [18] <author> Kleene, S. C., </author> <title> Mathematical Logic, </title> <publisher> Wiley, </publisher> <year> 1967. </year>
Reference-contexts: 1 ; : : : ; X n )(X; nil): next (X 1 ; : : : ; X n )(X; Y ) f 0 (X 1 ; : : : ; X n )(X; V ); pos (V ); succ (X; Y ): Referring to Church-Turing's thesis, cf. e.g. <ref> [18] </ref>, the HOLP reconstructions above prove the following theorem as a generalization of Theorem 1: Theorem 2: All computable functions can be expressed in logic programs solely by non-recursive clausal predicate definitions augmented with the linrec recursion operator and a fortiori the foldleft recursion operator. 7 Emulating a Universal Turing Machine
Reference: [19] <editor> Tarnlund, S. A., </editor> <title> "Horn Clause Computability," </title> <journal> BIT 17, </journal> <pages> pp. 215-226, </pages> <year> 1977. </year>
Reference-contexts: programs solely by non-recursive clausal predicate definitions augmented with the linrec recursion operator and a fortiori the foldleft recursion operator. 7 Emulating a Universal Turing Machine As an alternative approach consolidating the above universality result concerning linrec we devise a definite clausal logic program emulating the universal Turing machine, cf. <ref> [19] </ref>, using the linrec operator as the sole recursion form.
Reference: [20] <author> Smith, D. R., </author> <title> "The Design of Divide and Conquer Algorithms," </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 5, </volume> <pages> pp. 37-58, </pages> <year> 1985. </year>
Reference-contexts: On the theoretical side it is an indirect proof that solvel accommodates (all) general recursive functions and hence goes beyond the bounded recursion fold schemes. 19 9.4 Divide-and-Conquer Scheme as Derivative There is another useful specialization of the general solve operator, namely the so called divide and conquer scheme e.g. <ref> [20, 21, 22] </ref>, see also [8]: divconq (Elemgoal ; Decomp; Comp)(G; R) Elemgoal (G; R) divconq (Elemgoal ; Decomp; Comp)(G; R) Decomp (G; G1; G2) divconq (Elemgoal; Decomp; Comp)(G1; R1) divconq (Elemgoal; Decomp; Comp)(G2; R2) Comp (G; R1; R2; R) with an omitted or-branching compared with the and-or problem reduction scheme,
Reference: [21] <author> Flener, P., </author> <title> Logic Program Synthesis from Incomplete Specification, </title> <publisher> Kluwer, </publisher> <year> 1995. </year>
Reference-contexts: In this way the program is imposed a discipline concerning choice of recursion structures. Similar recursion structures are proposed in a related but independent work for pure higher-order logic programming in prolog [1]. Other proposals for recursion templates are found in <ref> [2, 3, 21, 22] </ref>. Use of higher-order functions for composition and structuring of programs is a well-established part of functional programming methodology, cf. e.g., [5, 6]. <p> On the theoretical side it is an indirect proof that solvel accommodates (all) general recursive functions and hence goes beyond the bounded recursion fold schemes. 19 9.4 Divide-and-Conquer Scheme as Derivative There is another useful specialization of the general solve operator, namely the so called divide and conquer scheme e.g. <ref> [20, 21, 22] </ref>, see also [8]: divconq (Elemgoal ; Decomp; Comp)(G; R) Elemgoal (G; R) divconq (Elemgoal ; Decomp; Comp)(G; R) Decomp (G; G1; G2) divconq (Elemgoal; Decomp; Comp)(G1; R1) divconq (Elemgoal; Decomp; Comp)(G2; R2) Comp (G; R1; R2; R) with an omitted or-branching compared with the and-or problem reduction scheme,
Reference: [22] <author> Flener, P. and Deville, Y., </author> <title> "Synthesis of Composition and Discrimination Operators for Divide-and-Conquer Programs," </title> <booktitle> in [4]. </booktitle>
Reference-contexts: In this way the program is imposed a discipline concerning choice of recursion structures. Similar recursion structures are proposed in a related but independent work for pure higher-order logic programming in prolog [1]. Other proposals for recursion templates are found in <ref> [2, 3, 21, 22] </ref>. Use of higher-order functions for composition and structuring of programs is a well-established part of functional programming methodology, cf. e.g., [5, 6]. <p> On the theoretical side it is an indirect proof that solvel accommodates (all) general recursive functions and hence goes beyond the bounded recursion fold schemes. 19 9.4 Divide-and-Conquer Scheme as Derivative There is another useful specialization of the general solve operator, namely the so called divide and conquer scheme e.g. <ref> [20, 21, 22] </ref>, see also [8]: divconq (Elemgoal ; Decomp; Comp)(G; R) Elemgoal (G; R) divconq (Elemgoal ; Decomp; Comp)(G; R) Decomp (G; G1; G2) divconq (Elemgoal; Decomp; Comp)(G1; R1) divconq (Elemgoal; Decomp; Comp)(G2; R2) Comp (G; R1; R2; R) with an omitted or-branching compared with the and-or problem reduction scheme,
Reference: [23] <author> Nilsson, U. and Ma luszynski, J., </author> <title> Logic, Programming and Prolog, </title> <publisher> Wiley, </publisher> <year> 1990. </year>
Reference-contexts: parameterization with component programs: For instance choice of another representation of the grammar, say, with a binary tree, is managed by replacement of the applyrule argument, leaving unaffected the defining clause for parse. 9.2 A Non-ground Metainterpreter The proposed recursion operator solvel is reminiscent of a non-ground metainter-preter, cf. e.g., <ref> [23] </ref>, for pure prolog. The ordinary double recursive definition of the vanilla interpreter is vanilla ([]). vanilla (A) clause (A,B),vanilla (B). 18 vanilla ([AjAl]) vanilla (A), vanilla (Al). <p> This program is obtained from solvel as follows. vanilla (G) solvel ((empty list,clause),G, , ). a (clause,A, ,B, ) clause (A,B) a (empty list,[], , ). 9.3 A Logic Program Metainterpreter Let us now outline an interpreter for pure logic programs employing ground representation of object logic programs, cf. e.g., <ref> [23] </ref>. We conduct a top-down elaboration of the metainterpreter employing the introduced recursion operators.
Reference: [24] <author> Meijer, E., Fokkinga, M. and Paterson, R., </author> <title> "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire," </title> <booktitle> in Proceedings of Fifth ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <editor> FPCA'91, (Hughes, J., ed.), </editor> <publisher> LNCS 523, Springer-Verlag, </publisher> <year> 1991, </year> <pages> pp. 124-144. </pages>
Reference-contexts: Let us add that as eventual fall back, however, we can refer to the above metainterpreter, accepting any candidate logic program as term data. In the context of functional programming theory the recursion fold schemes have been generalised to the concepts of catamorphism and paramorphism <ref> [24, 25] </ref>. These are functions over an underlying recursive data type whose definitional recursion pattern reflects that of the data type. These notions come with laws intended to assisting the calculation of programs from specifications. It is an open problem how these notions can be adapted to logic programming.
Reference: [25] <author> Meertens, L., </author> <title> "Paramorphism," </title> <journal> Formal Aspects of Computing, </journal> <volume> Vol. 4, No. 5, </volume> <year> 1992, </year> <pages> pp. 413-424. </pages>
Reference-contexts: Let us add that as eventual fall back, however, we can refer to the above metainterpreter, accepting any candidate logic program as term data. In the context of functional programming theory the recursion fold schemes have been generalised to the concepts of catamorphism and paramorphism <ref> [24, 25] </ref>. These are functions over an underlying recursive data type whose definitional recursion pattern reflects that of the data type. These notions come with laws intended to assisting the calculation of programs from specifications. It is an open problem how these notions can be adapted to logic programming.
Reference: [26] <author> Bird, R. and de Moor, O., </author> <title> "Relational Program Derivation and Context-free Lan--guage Recognition," in A Classical Mind, </title> <editor> (Roscoe, A. W., ed.), </editor> <publisher> Prentice Hall, </publisher> <year> 1994, </year> <pages> pp. 17-35. pp. 151-216. </pages>
Reference-contexts: It is an open problem how these notions can be adapted to logic programming. In functional programming methodology there has moreover been suggestions for generalising functions to relations with the aim of establishing algebraic rules for relational program derivation <ref> [26] </ref>. Since this work is restricted to binary predicates it is not obvious how to connect with logic programming. In the companion paper [15] we address the derivation of operational logic programs from declarative ones by considering data flow patterns for logic programs expressed by means of the recursions predicates.
References-found: 26

