URL: ftp://ftp.cs.rpi.edu/pub/adv-prog/formal-stl.ps.gz
Refering-URL: http://www.cs.rpi.edu/~musser/Tecton/
Root-URL: http://www.cs.rpi.edu
Title: A Basis for Formal Specification and Verification of Generic Algorithms in the C++ Standard Template Library  
Author: David R. Musser and Changqing Wang 
Keyword: Categories and Subject Descriptors: D.2.2. [Software Engineering]: Tools and Techniques|software libraries; D.2.4 [Software Engineering]: Program Verification| correctness proofs; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs|specification techniques. General Terms: Specification, Standardization, Verification Additional Key Words and Phrases: Generic algorithms, software libraries, C++, tem plates, Standard Template Library.  
Note: Partially supported by National Science Foundation Grant Number CCR-9308016 and subcontract CB0204 of SRI Contract MDA904-92-C-5186 with The Maryland Procurement Office.  
Address: Troy, NY 12180  
Affiliation: Computer Science Department Rensselaer Polytechnic Institute  
Abstract: Generic algorithms are algorithms designed to work with a variety of data structures. A software library in which most algorithms are generic can thus provide very extensive capabilities with a relatively small amount of source code. The high initial cost of applying formal methods to generic components becomes reasonable when amortized over the many different uses that can later be made. This paper is an attempt to provide a foundation for formal specification and verification of generic algorithms, paying particular attention to supporting the techniques by which generality is achieved in the C++ Standard Template Library. Axioms and inference rules are presented that support reasoning about essentially all the C++ language features and STL programming techniques used in the library's generic algorithms. Examples of applications to several simple STL generic algorithms are given. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E.W. Dijkstra, </author> <title> A Discipline of Programming, </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: discussed in [11], but they do not have the complexity of other axioms of that paper that are specific to linked structures. 3 Axioms and inference rules for imperative programs We adopt a notation and set of axioms and inference rules similar in spirit to Hoare's or Dijkstra's axiomatic systems <ref> [3, 1] </ref>, but substantially different in details. As in Hoare's logic, we use triples fQgSfRg, where Q and R are predicates and S is a program statement, as the primary notation for specifying the meaning of program statements and reducing claims about them to predicate logic.
Reference: [2] <editor> D. Gries, </editor> <booktitle> The Science of Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981, </year> <note> p. 120. </note>
Reference-contexts: but not necessarily as an lvalue, whereas the opposite is true of an OutputIterator . 4 Although the use of symbolic execution in software verification goes back at least to one of the earliest program verification systems [7], and forward assignment axioms are sometimes mentioned in the literature (e.g., see <ref> [2] </ref>, we are not aware of any axiomatic system with this approach as its basis. 3 AXIOMS AND INFERENCE RULES FOR IMPERATIVE PROGRAMS 9 other formulations of Hoare logic), but we use both unevaluated and evaluated references in the predicates.
Reference: [3] <author> C.A.R. Hoare, </author> <title> "An Axiomatic Basis for Computer Programming," </title> <journal> Comm. ACM, </journal> <volume> Vol. 12, No. 10, </volume> <month> October </month> <year> 1969, </year> <pages> 576-583. </pages>
Reference-contexts: discussed in [11], but they do not have the complexity of other axioms of that paper that are specific to linked structures. 3 Axioms and inference rules for imperative programs We adopt a notation and set of axioms and inference rules similar in spirit to Hoare's or Dijkstra's axiomatic systems <ref> [3, 1] </ref>, but substantially different in details. As in Hoare's logic, we use triples fQgSfRg, where Q and R are predicates and S is a program statement, as the primary notation for specifying the meaning of program statements and reducing claims about them to predicate logic.
Reference: [4] <author> D. Kapur and D. R. Musser, Tecton: </author> <title> a framework for specifying and verifying generic system components, </title> <institution> Rensselaer Polytechnic Institute Computer Science Technical Report 92-20, </institution> <month> July, </month> <year> 1992. </year> <month> 6 </month>
Reference-contexts: We plan to report on this example in a separate paper. We are also experimenting with partial automation of proofs about generic algorithms, using the PVS specification language [12] and prover [13], and the Tecton language <ref> [4, 5] </ref> and proof system [6]. Even if such proofs require extensive human direction and attention to detail, the fact that the algorithms are generic means that the necessary investments of effort can be amortized over the many subsequent uses of the algorithms.
Reference: [5] <author> D. Kapur, D. R. Musser, and A. A. Stepanov, "Tecton, </author> <title> A Language for Manipulating Generic Objects" Proc. </title> <booktitle> of Workshop on Program Specification, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1981, </year> <note> LNCS, vol. 134, </note> <year> 1982. </year>
Reference-contexts: We plan to report on this example in a separate paper. We are also experimenting with partial automation of proofs about generic algorithms, using the PVS specification language [12] and prover [13], and the Tecton language <ref> [4, 5] </ref> and proof system [6]. Even if such proofs require extensive human direction and attention to detail, the fact that the algorithms are generic means that the necessary investments of effort can be amortized over the many subsequent uses of the algorithms.
Reference: [6] <author> D. Kapur, D. R. Musser, and X. Nie, </author> <title> "An Overview of the Tecton Proof System," </title> <note> Theoretical Computer Science 133 (1994) 307-339. </note>
Reference-contexts: We plan to report on this example in a separate paper. We are also experimenting with partial automation of proofs about generic algorithms, using the PVS specification language [12] and prover [13], and the Tecton language [4, 5] and proof system <ref> [6] </ref>. Even if such proofs require extensive human direction and attention to detail, the fact that the algorithms are generic means that the necessary investments of effort can be amortized over the many subsequent uses of the algorithms. These efforts will be the subject of future papers. REFERENCES 24
Reference: [7] <author> J. C. King, </author> <title> A Program Verifier, </title> <type> Ph.D. thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1969. </year>
Reference-contexts: an InputIterator then it must be possible to use fli as an rvalue but not necessarily as an lvalue, whereas the opposite is true of an OutputIterator . 4 Although the use of symbolic execution in software verification goes back at least to one of the earliest program verification systems <ref> [7] </ref>, and forward assignment axioms are sometimes mentioned in the literature (e.g., see [2], we are not aware of any axiomatic system with this approach as its basis. 3 AXIOMS AND INFERENCE RULES FOR IMPERATIVE PROGRAMS 9 other formulations of Hoare logic), but we use both unevaluated and evaluated references in
Reference: [8] <author> J.H. Morris and B. Wegbreit, </author> <title> "Program Verification by Subgoal Induction," in Current Trends in Programming Methodology, </title> <editor> R. T. Yeh, ed., </editor> <volume> Vol. II, Ch. 8, </volume> <publisher> Prentice-Hall, </publisher> <year> 1977. </year>
Reference-contexts: Note that this approach is different from the more common method of inventing an invariant assertion for the while-loop, which asserts a relationship among memory references that is maintained by the loop as the iteration progresses. Our approach is more akin to the subgoal induction method <ref> [8] </ref>.
Reference: [9] <author> D. R. Musser and A. A. Stepanov, </author> <title> The Ada Generic Library: Linear List Processing Packages, </title> <address> Spring-Verlag, </address> <year> 1989. </year>
Reference: [10] <author> D. R. Musser and A. A. Stepanov, </author> <title> "Algorithm-Oriented Generic Libraries," </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 24(7), </volume> <month> 623-642 (July </month> <year> 1994) </year>
Reference-contexts: A fuller treatment using an axiomatic approach will be given in a separate paper (see also <ref> [10] </ref> for a specification of iterator properties using a model-based approach). 2.1 References and the evaluation and dereferencing operators STL iterators generalize C++ pointers, and operations on iterators as well as pointers involve the C++ notion of references. A reference is a name for a data object.
Reference: [11] <author> G. Nelson, </author> <title> "Verifying Reachability Invariants of Linked Structures," </title> <booktitle> Tenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, Texas, </address> <month> Jan. </month> <pages> 24-26, </pages> <year> 1983, </year> <pages> pp. 38-47. </pages>
Reference-contexts: Our axioms about iterator ranges generalize some of the reachability properties of linked structures discussed in <ref> [11] </ref>, but they do not have the complexity of other axioms of that paper that are specific to linked structures. 3 Axioms and inference rules for imperative programs We adopt a notation and set of axioms and inference rules similar in spirit to Hoare's or Dijkstra's axiomatic systems [3, 1], but
Reference: [12] <author> N. Shankar, S. Owre and J.M. Rushby, </author> <title> The PVS Specification Language, </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, March 1, </address> <year> 1993. </year>
Reference-contexts: We plan to report on this example in a separate paper. We are also experimenting with partial automation of proofs about generic algorithms, using the PVS specification language <ref> [12] </ref> and prover [13], and the Tecton language [4, 5] and proof system [6].
Reference: [13] <author> N. Shankar, S. Owre and J. M. Rushby, </author> <title> The PVS Proof Checker: A Reference Manual (Draft), </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, March 1, </address> <year> 1993. </year> <note> 6 Available as a Postscript file by anonymous ftp from ftp.cs.rpi.edu (do cd adv-prog then get tpcd-tecton.ps). REFERENCES 25 </note>
Reference-contexts: We plan to report on this example in a separate paper. We are also experimenting with partial automation of proofs about generic algorithms, using the PVS specification language [12] and prover <ref> [13] </ref>, and the Tecton language [4, 5] and proof system [6]. Even if such proofs require extensive human direction and attention to detail, the fact that the algorithms are generic means that the necessary investments of effort can be amortized over the many subsequent uses of the algorithms.
Reference: [14] <author> A. Stepanov and M. Lee, </author> <title> The Standard Template Library, </title> <type> Technical Report, </type> <institution> Hewlett-Packard Laboratories, </institution> <month> May 31, </month> <year> 1994, </year> <note> revised February 7, 1995; incorporated into the ANSI/ISO Draft Standard C++ Library (to be available for public comment approximately May 1, </note> <year> 1995). </year>
Reference-contexts: These axioms (though stated less formally) are a key part of the requirements placed on iterators in the STL standard <ref> [14] </ref>, and all iterator classes defined in STL satisfy these axioms.
Reference: [15] <author> A. Stepanov, M. Lee, and D. Musser, </author> <title> Hewlett-Packard Laboratories reference implementation of the Standard Template Library, </title> <note> source files available via anonymous ftp from butler.hpl.hp.com in =stl =sharfile.Z </note> . 
Reference-contexts: Both of these specifications can be shown to be theorems about the following implementation, from <ref> [15] </ref>, template &lt;class InputIterator, class OutputIterator &gt; OutputIterator copy (InputIterator first, InputIterator beyond, OutputIterator result ) f while (first != beyond ) flresult ++ = flfirst ++; return result ; g 4 SPECIFICATION AND PROOF OF THE COPY GENERIC ALGORITHM 20 which we model with the following definition: (OutputIterator r1 = <p> One such STL algorithm that we have studied in detail is unguarded partition , a particularly efficient form of partitioning used in implementing quick sort . In <ref> [15] </ref> the body of unguarded partition is a while loop that contains two nested while loops, certainly a more complex structure than we have dealt with in the examples of this paper.
Reference: [16] <author> C. Wallace, </author> <title> The Semantics of the C++ Programming Language, </title> <editor> in E. Boerger, ed., </editor> <title> Specification and Validation Methods, </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
References-found: 16

