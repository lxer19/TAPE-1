URL: file://ftp.cis.upenn.edu/pub/papers/kannan/memory.ps.Z
Refering-URL: http://www.cis.upenn.edu/~kannan/home.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Checking the Correctness of Memories  
Author: Manuel Blum Will Evans Peter Gemmell Sampath Kannan Moni Naor 
Address: Berkeley, CA 94720  P.O. Box 1179, Piscataway, NJ 08855  650 Harry Road, San Jose, CA 95120  
Affiliation: Department of Computer Science, University of California at  Rutgers University,  IBM Almaden,  
Note: Supported in part by NSF grant CCR 88-13632  
Date: July 8, 1995  
Pubnum: DIMACS,  
Abstract: Program checking has been thought of merely as checking the computation of a function which does not have any side effects. We extend the notion of program checking to include programs which alter their environment. In particular, we consider programs which store and retrieve data from memory. Checking such programs is a problem of great practical importance. The model we consider allows the checker a small amount of reliable (possibly secret) memory. The checker is presented with a sequence of requests (on-line) to a data structure which must reside in a large but unreliable memory. We view the data structure as being controlled by an adversary. We want the checker to perform each operation in the input sequence using its reliable memory and the unreliable data structure so that any error in the operation of the structure will be detected by the checker with high probability. We present checkers for various problems of storage and retrieval: random access memories, stacks, and queues. We prove lower bounds of log n on the amount of reliable memory needed by checkers to check these data structures where n is the size of the structure. The lower bounds are information theoretic and apply under various assumptions. We also show time-space tradeoffs for checking random access memories as a generalization of those for coherent functions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Blum and S. Kannan. </author> <title> Designing programs that check their work. </title> <booktitle> In 21st ACM Symposium on Theory of Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction The program checking model was introduced in <ref> [1] </ref> and several subsequent papers [2, 3, 4] have provided checkers for classical computational problems. In the context of program checking, programs for these problems have been thought of merely as computing a function and not as having any side effects.
Reference: [2] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-testing and self-correction programs with applications to numerical problems. </title> <booktitle> In 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 73-83, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction The program checking model was introduced in [1] and several subsequent papers <ref> [2, 3, 4] </ref> have provided checkers for classical computational problems. In the context of program checking, programs for these problems have been thought of merely as computing a function and not as having any side effects.
Reference: [3] <author> L. Adelman, M. Huang, and K. Kompella. </author> <title> Efficient checkers for number-theoretic computation. </title> <type> preprint. </type>
Reference-contexts: 1 Introduction The program checking model was introduced in [1] and several subsequent papers <ref> [2, 3, 4] </ref> have provided checkers for classical computational problems. In the context of program checking, programs for these problems have been thought of merely as computing a function and not as having any side effects.
Reference: [4] <author> R. Lipton. </author> <title> New directions in testing. </title> <type> preprint. </type>
Reference-contexts: 1 Introduction The program checking model was introduced in [1] and several subsequent papers <ref> [2, 3, 4] </ref> have provided checkers for classical computational problems. In the context of program checking, programs for these problems have been thought of merely as computing a function and not as having any side effects.
Reference: [5] <author> O. Goldreich. </author> <title> Towards a theory of software protection and simulation by oblivious rams. </title> <booktitle> In 19th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 182-194, </pages> <year> 1987. </year>
Reference-contexts: In this paper, we define a suitable model for checking such programs and present checkers for various problems of storage and retrieval. The question of checking a sequence of stores and retrieves from a random access memory has been addressed by the papers of Goldreich <ref> [5] </ref> and Ostrovsky [6]. These two papers actually solve the harder problem of software protection against a very powerful adversary. Consequently, the overheads involved in checking the sequence of memory accesses is quite large.
Reference: [6] <author> R. Ostrovsky. </author> <title> Efficient computation on oblivious rams. </title> <booktitle> In 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 514-523, </pages> <year> 1990. </year>
Reference-contexts: In this paper, we define a suitable model for checking such programs and present checkers for various problems of storage and retrieval. The question of checking a sequence of stores and retrieves from a random access memory has been addressed by the papers of Goldreich [5] and Ostrovsky <ref> [6] </ref>. These two papers actually solve the harder problem of software protection against a very powerful adversary. Consequently, the overheads involved in checking the sequence of memory accesses is quite large.
Reference: [7] <author> R. Lipton. </author> <title> Efficient checking of computations. </title> <booktitle> In 7th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 207-215, </pages> <year> 1990. </year>
Reference-contexts: One application of these results is a direct method of simulating a polytime verifier by a logspace verifier in the context of interactive proofs. Lipton <ref> [7] </ref> derives the same result to show that logspace verifiers can verify essentially the same proofs as polytime verifiers. Given a polytime verifier V (a Turing machine), we simulate V by a logspace verifier V 0 . V 0 maintains V 's head position on its logspace worktape.
Reference: [8] <author> J. Naor and M. Naor. </author> <title> Small-bias probability spaces: efficient constructions and applications. </title> <booktitle> In 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 213-223, </pages> <year> 1990. </year>
Reference-contexts: Some of them rely on cryptographic assumptions while others do not. We review these hashing techniques in this section. 3.1 *-biased Hash Functions This hashing scheme is drawn from <ref> [8] </ref>. We briefly describe the result in a communication complexity setting. Suppose two players A and B have n-bit strings x and y respectively and would like to decide if x = y. The scheme in [8] allows A to define a hash function h using O (log n+k) random bits <p> techniques in this section. 3.1 *-biased Hash Functions This hashing scheme is drawn from <ref> [8] </ref>. We briefly describe the result in a communication complexity setting. Suppose two players A and B have n-bit strings x and y respectively and would like to decide if x = y. The scheme in [8] allows A to define a hash function h using O (log n+k) random bits such that h (x) is small (O (k) bits) and h (x) = h (y) with probability 1=2 k if x 6= y.
Reference: [9] <author> O. Goldreich, S. Goldwasser, and S. Micali. </author> <title> How to construct random functions. </title> <journal> Journal of the ACM, </journal> <volume> 33(4) </volume> <pages> 792-807, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: We now list two (cryptographic) techniques for hashing. 3.2 Pseudorandom functions Assume that the reliable (and secret) memory of the checker can store the seed S of pseudorandom function f (a la Goldreich, Goldwasser and Micali <ref> [9] </ref>). Equivalently, assume that the checker is equipped with a private random oracle. <p> Since the construction of pseudorandom functions of <ref> [9] </ref> (the only one known) implies that the time to evaluate f is proportional to the (length of the argument) * (the time to pseudo generate a sequence twice as long as the seed), it makes sense to shorten the argument as much as possible.
Reference: [10] <author> M. Naor and M. Yung. </author> <title> Universal one-way hash functions and their cryptographic applications. </title> <booktitle> In 21st ACM Symposium on Theory of Computing, </booktitle> <pages> pages 33-43, </pages> <year> 1989. </year>
Reference-contexts: E is a family of universal one-way hash functions (UOWHF) if 8x 2 D, for f chosen at random from E it is hard to find y 6= x such that f (x) = f (y) (see exact definition in <ref> [10] </ref>.) It is possible to construct UOWHF given any one-way function ([10] shows this for any 1-1 one-way function and [11] shows this for any one-way function.) Using UOWHF, it is possible to authenticate several memory cells with one, without secrecy. <p> This scheme can be seen as a variant of Merkle's tree authentication scheme for digital signatures [12]. The signature scheme in <ref> [10] </ref> is based on it as well. The proof that this scheme is secure against a resource bounded adversary follows from the definition of universal one way hash functions. 5.1.2 Authentication using Pseudorandom Functions We describe how to use pseudorandom functions and time stamps to authenticate the memory.
Reference: [11] <author> J. Rompel. </author> <title> One way functions are necessary and sufficient for secure signatures. </title> <booktitle> In 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 387-394, </pages> <year> 1990. </year>
Reference-contexts: if 8x 2 D, for f chosen at random from E it is hard to find y 6= x such that f (x) = f (y) (see exact definition in [10].) It is possible to construct UOWHF given any one-way function ([10] shows this for any 1-1 one-way function and <ref> [11] </ref> shows this for any one-way function.) Using UOWHF, it is possible to authenticate several memory cells with one, without secrecy. Let E be a family of UOWHF such that 8f 2 E f : D 2 7! D.
Reference: [12] <author> R. Merkle. </author> <title> A certified digital signature. </title> <type> manuscript, </type> <year> 1979. </year>
Reference-contexts: This scheme can be seen as a variant of Merkle's tree authentication scheme for digital signatures <ref> [12] </ref>. The signature scheme in [10] is based on it as well.
Reference: [13] <author> N. Pippinger and M.J. Fischer. </author> <title> Relations among complexity measures. </title> <journal> Journal of the ACM, </journal> <volume> 26(2) </volume> <pages> 361-381, </pages> <year> 1979. </year>
Reference-contexts: The trick is the placement of the markers. We use an idea from the simulation by oblivious Turing machines of Pippenger and Fischer <ref> [13] </ref>. To simplify the explanation, we assume that we have h = log H stacks S 0 ; S 1 ; :::; S h1 . Each stack has its own h (W ) and h (R). We will see how to combine these stacks into one stack later.
Reference: [14] <author> A. Yao. </author> <title> Coherent functions and program checkers. </title> <booktitle> In 22nd ACM Symposium on Theory of Computing, </booktitle> <pages> pages 84-94, </pages> <year> 1990. </year> <month> 17 </month>
Reference-contexts: Space is the size m of the checker's reliable memory. Let n be 14 the size of the RAM. We show that n 2 O (mt). The proof is a generalization of the tradeoffs for coherent functions in <ref> [14] </ref>. For the sake of simplicity we assume that each RAM cell holds just 1 bit. Once again we assume that the checker is correct with probability p whenever it certifies the contents of a memory location. Clearly, the interesting case is when p &gt; 1=2.
References-found: 14

