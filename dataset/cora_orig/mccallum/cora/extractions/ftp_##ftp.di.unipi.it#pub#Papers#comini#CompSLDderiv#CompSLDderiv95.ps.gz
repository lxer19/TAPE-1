URL: ftp://ftp.di.unipi.it/pub/Papers/comini/CompSLDderiv/CompSLDderiv95.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: meog@di.unipi.it  
Title: Compositionality in SLD-derivations and their abstractions  
Author: Marco Comini, Giorgio Levi and Maria Chiara Meo fcomini, levi, 
Keyword: SLD-derivations, abstract semantics, compositionality.  
Address: Corso Italia 40, 56125 Pisa, Italy  
Affiliation: Dipartimento di Informatica, Universita di Pisa,  
Abstract: We define a semantic framework to reason about compositional properties of SLD-derivations and their abstractions (observables). The framework allows us to address problems such as the relation between the (top-down) operational semantics and the (bottom-up) denotational semantics, the existence of a denotation for a set of definite clauses and their properties (compositional-ity w.r.t. various syntactic operators, correctness and minimality). This leads us to a flexible classification of the observables, where we can reason about properties such as OR-compositionality and existence of abstract transition system. Using abstract interpretation techniques to model abstraction allows us to state very simple conditions on the observables which guarantee the validity of several general theorems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: Since it is based on standard operational and denotational semantic definitions, the framework can be adapted to other programming languages. 2 Preliminaries In the following sections, we assume familiarity with the standard notions of logic programming as introduced in <ref> [1] </ref> and [17]. We denote by G and B possibly empty sequences of atoms, by t; x tuples of, respectively, terms and distinct variables. Moreover we denote by t both the tuple and the set of corresponding syntactic objects. <p> An observable is any property which can be extracted from a goal computation, i.e., observables are abstractions of SLD-trees. We assume the reader to be familiar with the notions of SLD -resolution and SLD -tree (see <ref> [17, 1] </ref>). We represent here, for notational convenience, SLD -trees as sets of derivations. i. We define a preorder on derivations: d d 0 iff first (d) = first (d 0 ) and there exists a renaming such that d is a prefix of d 0 . ii.
Reference: [2] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> The s-semantics approach: </title> <journal> Theory and applications. Journal of Logic Programming, </journal> <volume> 19-20:149-197, </volume> <year> 1994. </year>
Reference-contexts: Similar problems have been studied in detail for various abstractions of SLD -deriva-tions. Computed answers were considered in [6, 7], call patterns and partial answers were considered in [11] and resultants were considered in [10] (see <ref> [2] </ref> for a survey of the approach). Moreover, a framework where one can define denotations modeling various observables (thus inheriting the basic constructions and results) was given in [9, 8], by defining abstractions by means of equivalence relations. <p> Moreover every goal G can be viewed as the collection f hG; f G gi g containing the "zero step" derivation G. The goal we want to achieve is to develop a denotation modeling partial SLD - trees. We follow the approach in <ref> [3, 2] </ref>, by defining a "syntactic" semantic domain (interpretation). Our modeling of partial SLD -trees is similar to the basic denotation defined in terms of clauses in [8, 9]. Definition 3.3 A most general collection is a collection such that each initial goal is a most general atomic goal.
Reference: [3] <author> M. Comini and G. Levi. </author> <title> An algebraic theory of observables. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proceedings of the 1994 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 172-186. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: Moreover, a framework where one can define denotations modeling various observables (thus inheriting the basic constructions and results) was given in [9, 8], by defining abstractions by means of equivalence relations. The same problem was tackled by <ref> [3] </ref> for CLP and by [12], by modeling abstractions according to abstract interpretation theory. This means that it is possible to accommodate in the framework observables which are useful for (approximate) program analysis. In this paper we build upon the idea in [3] of providing an algebraic characterization of the observables. <p> The same problem was tackled by <ref> [3] </ref> for CLP and by [12], by modeling abstractions according to abstract interpretation theory. This means that it is possible to accommodate in the framework observables which are useful for (approximate) program analysis. In this paper we build upon the idea in [3] of providing an algebraic characterization of the observables. We extend the approach, by taking two basic semantics: a denota-tional semantics and a transition system which define SLD -derivations. In addition, our semantic properties are expressed as compositionality properties. <p> Moreover every goal G can be viewed as the collection f hG; f G gi g containing the "zero step" derivation G. The goal we want to achieve is to develop a denotation modeling partial SLD - trees. We follow the approach in <ref> [3, 2] </ref>, by defining a "syntactic" semantic domain (interpretation). Our modeling of partial SLD -trees is similar to the basic denotation defined in terms of clauses in [8, 9]. Definition 3.3 A most general collection is a collection such that each initial goal is a most general atomic goal.
Reference: [4] <author> P. Cousot and R. Cousot. </author> <title> Systematic Design of Program Analysis Frameworks. </title> <booktitle> In Proc. Sixth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <year> 1979. </year>
Reference-contexts: We want then to develop a theory according to which the semantic properties of SLD -derivations shown in subsection 3.1 are inherited by the denotations which model abstractions of the SLD - derivations. We will model the abstractions by using the Abstract Interpretation theory <ref> [4] </ref>. 4.1 Galois Insertions and Abstract Interpretation Abstract Interpretation is a theory developed to reason about the abstraction relation between two different semantics.
Reference: [5] <author> S. K. Debray and P. Mishra. </author> <title> Denotational and Operational Semantics for Prolog. </title> <journal> Journal of Logic Programming, </journal> <volume> 5 </volume> <pages> 61-91, </pages> <year> 1988. </year>
Reference-contexts: All the definitions will be independent from the choice of the syntactic object. To simplify the notation, we denote the corresponding operators on I and D by the same name. Several denotational semantics have been defined for logic programs (see, for example, <ref> [13, 14, 5] </ref>). The main differences w.r.t. the above definitions are that we do not consider the PROLOG search rule and that our denotations model SLD -- derivations rather than just computed answers.
Reference: [6] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: Similar problems have been studied in detail for various abstractions of SLD -deriva-tions. Computed answers were considered in <ref> [6, 7] </ref>, call patterns and partial answers were considered in [11] and resultants were considered in [10] (see [2] for a survey of the approach). <p> In particular F ff [[P ]] = ff (O [[P ]]). Hence F ff is correct and minimal w.r.t. ff. Example 4.14 We show now how to reconstruct the s-semantics <ref> [6, 7] </ref> by means of the observable ~ of example 4.3. We can prove that ~ is indeed a denotational observable, since the condition (4.12.iv) now holds. <p> The proof of the same results, using classical methods <ref> [6] </ref>, is much harder. Example 4.15 The call patterns (with state) of a program P for a goal G are the atoms selected in any SLD -derivation of G in P via R.
Reference: [7] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A Model-Theoretic Reconstruction of the Operational Semantics of Logic Programs. </title> <journal> Information and Computation, </journal> <volume> 102(1) </volume> <pages> 86-113, </pages> <year> 1993. </year>
Reference-contexts: Similar problems have been studied in detail for various abstractions of SLD -deriva-tions. Computed answers were considered in <ref> [6, 7] </ref>, call patterns and partial answers were considered in [11] and resultants were considered in [10] (see [2] for a survey of the approach). <p> In particular F ff [[P ]] = ff (O [[P ]]). Hence F ff is correct and minimal w.r.t. ff. Example 4.14 We show now how to reconstruct the s-semantics <ref> [6, 7] </ref> by means of the observable ~ of example 4.3. We can prove that ~ is indeed a denotational observable, since the condition (4.12.iv) now holds.
Reference: [8] <author> M. Gabbrielli. </author> <title> The Semantics of Logic Programming as a Programming Language. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year>
Reference-contexts: Moreover, a framework where one can define denotations modeling various observables (thus inheriting the basic constructions and results) was given in <ref> [9, 8] </ref>, by defining abstractions by means of equivalence relations. The same problem was tackled by [3] for CLP and by [12], by modeling abstractions according to abstract interpretation theory. This means that it is possible to accommodate in the framework observables which are useful for (approximate) program analysis. <p> The goal we want to achieve is to develop a denotation modeling partial SLD - trees. We follow the approach in [3, 2], by defining a "syntactic" semantic domain (interpretation). Our modeling of partial SLD -trees is similar to the basic denotation defined in terms of clauses in <ref> [8, 9] </ref>. Definition 3.3 A most general collection is a collection such that each initial goal is a most general atomic goal. An interpretation I is a most general collection modulo variance. We denote by I the set of interpretations. (I; v) is a complete lattice.
Reference: [9] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Observational Equivalences for Logic Programs. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int'l Conf. and Symposium on Logic Programming, </booktitle> <pages> pages 131-145. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year> <note> Extended version to appear in Information and Computation. </note>
Reference-contexts: Moreover, a framework where one can define denotations modeling various observables (thus inheriting the basic constructions and results) was given in <ref> [9, 8] </ref>, by defining abstractions by means of equivalence relations. The same problem was tackled by [3] for CLP and by [12], by modeling abstractions according to abstract interpretation theory. This means that it is possible to accommodate in the framework observables which are useful for (approximate) program analysis. <p> The goal we want to achieve is to develop a denotation modeling partial SLD - trees. We follow the approach in [3, 2], by defining a "syntactic" semantic domain (interpretation). Our modeling of partial SLD -trees is similar to the basic denotation defined in terms of clauses in <ref> [8, 9] </ref>. Definition 3.3 A most general collection is a collection such that each initial goal is a most general atomic goal. An interpretation I is a most general collection modulo variance. We denote by I the set of interpretations. (I; v) is a complete lattice.
Reference: [10] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Resultants semantics for PROLOG. </title> <journal> Journal of Logic and Computation, </journal> <year> 1995. </year>
Reference-contexts: Similar problems have been studied in detail for various abstractions of SLD -deriva-tions. Computed answers were considered in [6, 7], call patterns and partial answers were considered in [11] and resultants were considered in <ref> [10] </ref> (see [2] for a survey of the approach). Moreover, a framework where one can define denotations modeling various observables (thus inheriting the basic constructions and results) was given in [9, 8], by defining abstractions by means of equivalence relations.
Reference: [11] <author> M. Gabbrielli and M. C. Meo. </author> <title> Fixpoint Semantics for Partial Computed Answer Substitutions and Call Patterns. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Algebraic and Logic Programming, Proceedings of the Third International Conference, volume 632 of Lecture Notes in Computer Science, </booktitle> <pages> pages 84-99. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Similar problems have been studied in detail for various abstractions of SLD -deriva-tions. Computed answers were considered in [6, 7], call patterns and partial answers were considered in <ref> [11] </ref> and resultants were considered in [10] (see [2] for a survey of the approach). Moreover, a framework where one can define denotations modeling various observables (thus inheriting the basic constructions and results) was given in [9, 8], by defining abstractions by means of equivalence relations.
Reference: [12] <author> R. Giacobazzi. </author> <title> On the Collecting Semantics of Logic Programs. </title> <editor> In F. S. de Boer and M. Gabbrielli, editors, </editor> <booktitle> Verification and Analysis of Logic Languages, Proc. of the Post-Conference ICLP Workshop, </booktitle> <pages> pages 159-174, </pages> <year> 1994. </year>
Reference-contexts: Moreover, a framework where one can define denotations modeling various observables (thus inheriting the basic constructions and results) was given in [9, 8], by defining abstractions by means of equivalence relations. The same problem was tackled by [3] for CLP and by <ref> [12] </ref>, by modeling abstractions according to abstract interpretation theory. This means that it is possible to accommodate in the framework observables which are useful for (approximate) program analysis. In this paper we build upon the idea in [3] of providing an algebraic characterization of the observables.
Reference: [13] <author> N. D. Jones and A. Mycroft. </author> <title> Stepwise Development of Operational and Denotational Semantics for PROLOG. </title> <editor> In Sten -Ake Tarnlund, editor, </editor> <booktitle> Proc. Second Int'l Conf. on Logic Programming, </booktitle> <pages> pages 281-288, </pages> <year> 1984. </year>
Reference-contexts: All the definitions will be independent from the choice of the syntactic object. To simplify the notation, we denote the corresponding operators on I and D by the same name. Several denotational semantics have been defined for logic programs (see, for example, <ref> [13, 14, 5] </ref>). The main differences w.r.t. the above definitions are that we do not consider the PROLOG search rule and that our denotations model SLD -- derivations rather than just computed answers.
Reference: [14] <author> N. D. Jones and H. Stndergaard. </author> <title> A Semantics-based Framework for the Abstract Interpretation of PROLOG. </title> <editor> In S. Abramsky and C. Hankin, editors, </editor> <booktitle> Abstract Interpretation of Declarative Languages, </booktitle> <pages> pages 123-142. </pages> <publisher> Ellis Horwood Ltd, </publisher> <year> 1987. </year>
Reference-contexts: All the definitions will be independent from the choice of the syntactic object. To simplify the notation, we denote the corresponding operators on I and D by the same name. Several denotational semantics have been defined for logic programs (see, for example, <ref> [13, 14, 5] </ref>). The main differences w.r.t. the above definitions are that we do not consider the PROLOG search rule and that our denotations model SLD -- derivations rather than just computed answers.
Reference: [15] <author> R. Kemp and G. Ringwood. </author> <title> Reynolds base, clark models and heyting semantics of logic programs. </title> <note> submitted for publication. </note>
Reference-contexts: Another interesting observable which can be proved to be perfect is the proof trees observable, whose corresponding derivation is the Heyting semantics in <ref> [16, 15] </ref>. Note that there exist observables which are not perfect. For example, the observable ~ of example 4.3 is not a perfect observable, since the axiom (4.4.iv) does not hold. The following theorem shows that the abstract denotational semantics and the bottom-up denotation are precise.
Reference: [16] <author> R. Kemp and G. Ringwood. </author> <title> An Algebraic Framework for the Abstract Interpretation of Logic Programs. </title> <editor> In S. K. Debray and M. Hermenegildo, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'90, </booktitle> <pages> pages 506-520. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: Another interesting observable which can be proved to be perfect is the proof trees observable, whose corresponding derivation is the Heyting semantics in <ref> [16, 15] </ref>. Note that there exist observables which are not perfect. For example, the observable ~ of example 4.3 is not a perfect observable, since the axiom (4.4.iv) does not hold. The following theorem shows that the abstract denotational semantics and the bottom-up denotation are precise.
Reference: [17] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: Since it is based on standard operational and denotational semantic definitions, the framework can be adapted to other programming languages. 2 Preliminaries In the following sections, we assume familiarity with the standard notions of logic programming as introduced in [1] and <ref> [17] </ref>. We denote by G and B possibly empty sequences of atoms, by t; x tuples of, respectively, terms and distinct variables. Moreover we denote by t both the tuple and the set of corresponding syntactic objects. B; B 0 denotes the concatenation of B and B 0 . <p> An observable is any property which can be extracted from a goal computation, i.e., observables are abstractions of SLD-trees. We assume the reader to be familiar with the notions of SLD -resolution and SLD -tree (see <ref> [17, 1] </ref>). We represent here, for notational convenience, SLD -trees as sets of derivations. i. We define a preorder on derivations: d d 0 iff first (d) = first (d 0 ) and there exists a renaming such that d is a prefix of d 0 . ii.
References-found: 17

