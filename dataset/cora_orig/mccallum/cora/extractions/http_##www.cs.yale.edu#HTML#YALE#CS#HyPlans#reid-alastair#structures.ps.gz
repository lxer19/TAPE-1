URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/structures.ps.gz
Refering-URL: http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/reid-alastair/
Root-URL: http://www.cs.yale.edu
Email: fpeterson-john,reid-alastairg@cs.yale.edu  
Title: Adding Records to Haskell  
Author: John Peterson and Alastair Reid 
Date: October 4, 1998  
Note: Electronic mail:  
Address: P.O. Box 208285, New Haven, CT 06520, USA.  
Affiliation: Department of Computer Science, Yale University,  
Abstract: The Haskell programming language has a very simple yet elegant view of data structures. Unfortunately, this minimalist approach to data structures, in particular record-like structures, presents serious software engineering problems. We have implemented an extension to standard Haskell which provides record-like structures in addition to ordinary algebraic data types. Our extension provides named fields in data structures, default field values, field update functions, detection of uninitialized slots and multiple inheritance. Our major design goal was to supply as much functionality as possible without changing any of the basic components of the Haskell language (in particular, we avoided further complication of the type system). The purpose of this paper is not to advocate this specific extension to Haskell, but to examine the basic engineering issues associated with records; describe our experiences with the implementation and use of one particular proposal; and consider alternative approaches (some of which have been used in other languages).
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> FW Burton and RD Cameron. </author> <title> Pattern matching with abstract data types. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(2) </volume> <pages> 171-190, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: It would certainly be better to add a general purpose mechanism flexible enough to define structure pattern matching than to add structure pattern matching as a special case, as in our implementation. Sadly, Wadler's "views" <ref> [8, 1] </ref> would not be flexible enough to handle this case. In practice, we found that we didn't use pattern matching very much, preferring to use selector functions to extract slots at the place where they are needed rather than at the head of a function.
Reference: [2] <author> P Hudak, SL Peyton Jones, PL Wadler, Arvind, B Boutel, J Fairbairn, J Fasel, M Guz-man, K Hammond, J Hughes, T Johnsson, R Kieburtz, RS Nikhil, W Partain, and J Peterson. </author> <title> Report on the functional programming language Haskell, Version 1.2. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction The Haskell language <ref> [2] </ref> includes only the most basic support for a fundamental programming language feature: the record type. In the most general sense of the term, a record simply groups a heterogeneous collection of objects into a single value. <p> The semantics of our proposal is defined as a translation into code like that given in the previous section. The additions to Haskell syntax rules (appendix B of <ref> [2] </ref>) are as follows: 3.1 Structure declarations topdecl ! structure [ ~ ] simple where f structbody [ ; ] g [ deriving ( tyclses ) ] simple ! tycon tyvar 1 . . . tyvar k structbody ! structsigns [ ;valdefs ] structsigns ! structsign 1 ;. . . ;structsign
Reference: [3] <author> R Milner, M Tofte, and R Harper. </author> <title> The definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: It would then be possible for the compiler to check that every slot had either a default value or an explicitly provided value. A similar restriction is imposed in ML <ref> [3] </ref>, where it is required by the combination of strict semantics and type safety. 5.4 Pattern Matching Pattern matching in Haskell lacks the extensibility of other language features.
Reference: [4] <author> Atsushi Ohori. </author> <title> A compilation method for ML-style polymorphic record calculi. </title> <booktitle> In Principles of Programming Languages, </booktitle> <pages> pages 154-165. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: as in Common Lisp. (For example, the function setFoo would be used to alter the values of slot foo.) However, no other Haskell feature uses name mangling so we hesitate to add this. 14 5.7 Record Types An entirely different system can be constructed using labeled records and subtype inference <ref> [5, 4] </ref>. The advantage of such as system would be that structure declarations would be unnecessary.
Reference: [5] <author> D Remy. </author> <title> Typechecking records in a natural extension of ML. </title> <booktitle> In Principles of Programming Languages, </booktitle> <pages> pages 242-249. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: as in Common Lisp. (For example, the function setFoo would be used to alter the values of slot foo.) However, no other Haskell feature uses name mangling so we hesitate to add this. 14 5.7 Record Types An entirely different system can be constructed using labeled records and subtype inference <ref> [5, 4] </ref>. The advantage of such as system would be that structure declarations would be unnecessary.
Reference: [6] <author> GL Steele. </author> <title> Common Lisp | The Language. </title> <publisher> Digital Press, </publisher> <address> 2nd edition, </address> <year> 1994. </year>
Reference-contexts: This avoids generating new names for these operations (as is done in Common Lisp <ref> [6] </ref>). * Explicit declarations are required for all record types. This avoids the efficiency and type-inference problems associated with more general record types and produces more accurate messages when type errors occur. * Structures may be polymorphic. * Multiple inheritance is allowed.
Reference: [7] <author> PL Wadler. </author> <title> Fixing a space leak with a garbage collector. </title> <journal> Software | Practice and Experience, </journal> <volume> 17(9) </volume> <pages> 595-608, </pages> <year> 1987. </year>
Reference-contexts: This translation has the drawback that it may occasionally cause a space leak if any p i is irrefutable. The problem is exactly that reported by Wadler <ref> [7] </ref>: slot extraction is only performed when the value of the slot is actually required; not when the pattern matching occurs. This can cause the entire structure to be retained when only one slot is required.
Reference: [8] <author> PL Wadler. </author> <title> Views | a way for pattern matching to cohabit with data abstraction. </title> <type> Technical Report 34, </type> <institution> Programming Methodology Group, Chalmers University, Sweden, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: It would certainly be better to add a general purpose mechanism flexible enough to define structure pattern matching than to add structure pattern matching as a special case, as in our implementation. Sadly, Wadler's "views" <ref> [8, 1] </ref> would not be flexible enough to handle this case. In practice, we found that we didn't use pattern matching very much, preferring to use selector functions to extract slots at the place where they are needed rather than at the head of a function.
Reference: [9] <author> PL Wadler and S Blott. </author> <title> How to make ad-hoc polymorphism less ad hoc. </title> <booktitle> In Principles of Programming Languages. ACM, </booktitle> <month> January </month> <year> 1989. </year> <month> 17 </month>
Reference-contexts: type Variable which inherits slots from the type Definition, we write: structure Definition =&gt; Variable where varType :: Signature varSignature :: Maybe Signature fixity :: Fixity definition :: Expression The major change required to make this work is that the functions to select slots and update structures must be overloaded <ref> [9] </ref>. That is, instead of translating a structure definition into just a datatype and a collection of slot selection and update functions, structure definitions are translated into a type class with selection and update functions as methods, a new datatype and an instance of the datatype for that class.
References-found: 9

