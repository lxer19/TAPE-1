URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1995/UM-CS-1995-079.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/95-079.html
Root-URL: 
Email: dwyer@cis.ksu.edu clarke@cs.umass.edu  
Phone: (913)532-6350  
Title: A Flexible Architecture for Building Data Flow Analyzers  
Author:  Matthew B. Dwyer Lori A. Clarke Nichols Hall 
Address: Manhattan, KS 66506  Amherst, MA 01003  
Affiliation: ?Department of Computing and Information Sciences  Kansas State University  yDepartment of Computer Science University of Massachusetts, Amherst  
Abstract: In this paper, we describe an architecture that facilitates the rapid prototyping of data flow analyzers. With this architecture, a developer chooses from a collection of pre-existing components or, using high-level component generators, constructs new components and combines them to produce a data flow analyzer. In addition to support for traditional data flow analysis problems, this architecture supports the development of analyzers for a class of combined data flow problems that offer increased precision. This architecture allows developers to investigate quickly and easily a wide variety of analyzer design alternatives and to understand the practical design tradeoffs better. We describe our experience using this architecture to construct a variety of different data flow analyzers. 
Abstract-found: 1
Intro-found: 1
Reference: [ASU85] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: Reasoning about these mathematical objects allows one to determine performance characteristics of analyzers for a given data flow problem. A number of theoretical results and algorithms related to specific classes of data flow frameworks have been developed <ref> [ASU85, Hec77, MR90] </ref>. Most of the work on data flow analysis is aimed at supporting analysis of sequential programs.
Reference: [BO92] <author> Don Batory and Sean O'Malley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> IEEE Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> October </month> <year> 1992. </year> <month> 11 </month>
Reference-contexts: Software engineering researchers have also used this technique to support software validation [CK93, DS91, FO76, OO92, TO80]. Even very different data flow analyzers share a number of common features. As has been found with domain analysis of other software areas, such as database systems, network protocols and data structures <ref> [BO92, BST + 94] </ref>, domain analysis of data flow analyzers can identify common reusable software components. In this paper, we describe an architecture that is built around such a collection of components. <p> In addition, we provide support for building analyzers for a class of combined data flow problems. Systems that facilitate the implementation of domain specific software systems, such as the GenVoca software system generators <ref> [BO92, BST + 94] </ref>, have been developed. Both GenVoca and our architecture are based on collections of parameterizable composable building blocks with standard interfaces. Consequently, we believe that programming languages designed to support GenVoca-style generators could be applied to produce an implementation of our architecture.
Reference: [BST + 94] <author> Don Batory, Vivek Singhal, Jeff Thomas, Sankar Dasari, Bart Geraci, and Marty Sirkin. </author> <title> The GenVoca model of software-system generators. </title> <journal> IEEE Software, </journal> <pages> pages 89-94, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Software engineering researchers have also used this technique to support software validation [CK93, DS91, FO76, OO92, TO80]. Even very different data flow analyzers share a number of common features. As has been found with domain analysis of other software areas, such as database systems, network protocols and data structures <ref> [BO92, BST + 94] </ref>, domain analysis of data flow analyzers can identify common reusable software components. In this paper, we describe an architecture that is built around such a collection of components. <p> In addition, we provide support for building analyzers for a class of combined data flow problems. Systems that facilitate the implementation of domain specific software systems, such as the GenVoca software system generators <ref> [BO92, BST + 94] </ref>, have been developed. Both GenVoca and our architecture are based on collections of parameterizable composable building blocks with standard interfaces. Consequently, we believe that programming languages designed to support GenVoca-style generators could be applied to produce an implementation of our architecture.
Reference: [CCF91] <author> Jong-Deok Choi, Ron Cytron, and Jeanne Ferrante. </author> <title> Automatic construction of sparse data flow evaluation graphs. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 55-66, </pages> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: The cost of solving a data flow problem is strongly dependent on flow graph size. A number of representations have been developed that effectively reduce flow graph size for some data flow analyses. Choi et. al <ref> [CCF91] </ref> describe a general algorithm for constructing sparse data flow evaluation graphs (SDFEG) for monotone data flow frameworks. Use of this representation eliminates propagation of data through flow graph regions that add no information to the results.
Reference: [CK93] <author> S.C. Cheung and J. Kramer. </author> <title> Tractable flow analysis for anomaly detection in distributed programs. </title> <booktitle> In Proceedings of the European Software Engineering Conference, </booktitle> <year> 1993. </year>
Reference-contexts: In these cases, the significant software development cost of building data flow analyzers is a barrier to comparing competing design. Various forms of data flow analysis have been used in program optimization. Software engineering researchers have also used this technique to support software validation <ref> [CK93, DS91, FO76, OO92, TO80] </ref>. Even very different data flow analyzers share a number of common features.
Reference: [CKS90] <author> David Callahan, Ken Kennedy, and Jaspal Subhlok. </author> <title> Analysis of event synchronization in a parallel programming tool. </title> <booktitle> In Proceedings of the Second Symposion on Principles and Practice of Parallel Programming. ACM, </booktitle> <year> 1990. </year>
Reference-contexts: Graph types for concurrent programs such as state reachability graphs, Petri nets, and a number of control-flow-graph-like representations <ref> [CKS90, DC94, GS93, MR93] </ref> can also be adapted to meet the interface. The cost of solving a data flow problem is strongly dependent on flow graph size. A number of representations have been developed that effectively reduce flow graph size for some data flow analyses.
Reference: [DC94] <author> Matthew B. Dwyer and Lori A. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <journal> Software Engineering Notes, </journal> <volume> 19(5) </volume> <pages> 62-75, </pages> <month> December </month> <year> 1994. </year> <booktitle> Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering. </booktitle>
Reference-contexts: This implementation has been used to construct a variety of data flow analyzers that are used in a toolset for analyzing explicitly stated correctness properties of distributed systems <ref> [DC94, Dwy95] </ref>. These include analyzers for traditional data flow problems, e.g., dominators, live variables, constant propagation, and for non-traditional problems, e.g., for complex reachability problems. These analyzers have been formulated over a variety of program representations, e.g., sequential and concurrent control flow graphs, reachability graphs for concurrent systems, Petri nets. <p> To illustrate the construction of a data flow analyzer with the architecture and library of components we present a running example. This example is taken from a toolset for analyzing explicitly stated correctness properties of distributed systems <ref> [DC94] </ref>. In this toolset distributed systems are represented as a directed graph, called a trace flow graph (TFG). The TFG can be viewed as a collection of task control flow graphs with additional nodes and edges to represent inter-task communication. <p> Graph types for concurrent programs such as state reachability graphs, Petri nets, and a number of control-flow-graph-like representations <ref> [CKS90, DC94, GS93, MR93] </ref> can also be adapted to meet the interface. The cost of solving a data flow problem is strongly dependent on flow graph size. A number of representations have been developed that effectively reduce flow graph size for some data flow analyses.
Reference: [DCN95] <author> Matthew B. Dwyer, Lori. A. Clarke, and Kari L. Nies. </author> <title> A compact petri net representation for concurrent programs. </title> <booktitle> In Proceedings of the 17th International Conference on Software Engineering, </booktitle> <pages> pages 147-157, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: MayDiffer (x, y) returns false if x = y or if one value is Both and the other is U nknown, otherwise it returns true. We have prototyped a data flow analyzer that is capable of finding dead transitions in a TIG-based Petri Net (TPN) <ref> [DCN95] </ref>. The problem is formulated over the set of TPN transitions. The lattice is a bit-vector encoding of the set of transitions.
Reference: [DS91] <author> E. Duesterwald and M.L. Soffa. </author> <title> Concurrency analysis in the presence of procedures using a data flow framework. </title> <booktitle> In Proceedings of the ACM SIGSOFT Symposium on Testing, Analysis and Verification (TAV4), </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: In these cases, the significant software development cost of building data flow analyzers is a barrier to comparing competing design. Various forms of data flow analysis have been used in program optimization. Software engineering researchers have also used this technique to support software validation <ref> [CK93, DS91, FO76, OO92, TO80] </ref>. Even very different data flow analyzers share a number of common features.
Reference: [Dwy95] <author> Matthew B. Dwyer. </author> <title> Data Flow Analysis for Verifying Correctness Properties of Concurrent Programs. </title> <type> PhD thesis, </type> <institution> University of Massachusetts, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: This implementation has been used to construct a variety of data flow analyzers that are used in a toolset for analyzing explicitly stated correctness properties of distributed systems <ref> [DC94, Dwy95] </ref>. These include analyzers for traditional data flow problems, e.g., dominators, live variables, constant propagation, and for non-traditional problems, e.g., for complex reachability problems. These analyzers have been formulated over a variety of program representations, e.g., sequential and concurrent control flow graphs, reachability graphs for concurrent systems, Petri nets. <p> For example, intra-process control flow predecessors and inter-process synchronization predecessors may be treated differently. Recently data flow frameworks and solution algorithms have been extended to support analysis of concurrent programs by allowing different combining operators to be defined for different classes of nodes <ref> [Dwy95] </ref>. We incorporate this extension in our architecture. For decades data flow analyzers have been an integral part of optimizing compilers. Well-engineered compilers often provide standard interfaces to analyzer components. <p> To date, we have provided an iterative worklist solution algorithm for frameworks with monotone function spaces formulated over both sequential [Hec77] and concurrent flow graphs <ref> [Dwy95] </ref>. For the communication dominator problem, the data flow analyzer is constructed using the bit-vector lattice, sparse flow graph, gen-kill function space and iterative solver. Figure 5 gives the details of this defi nition. <p> We also constructed a data flow analyzer for a non-traditional problem. This analyzer computes an approximate test to determine if paths in a TFG correspond to accepting strings for a deterministic finite automaton that represents an event sequencing specification. This is called state propagation analysis <ref> [Dwy95] </ref>. The problem is formulated over TFG nodes connected by the set of control flow edges and an additional set of inter-task edges. The lattice is a bit-vector encoding of sets of finite automaton states. The function space is constructed from ffi, the automaton state transition function.
Reference: [FO76] <author> Lloyd D. Fosdick and Leon J. Osterweil. </author> <title> Data flow analysis in software reliability. </title> <journal> ACM Computing Surveys, </journal> <volume> 8(3) </volume> <pages> 305-330, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: In these cases, the significant software development cost of building data flow analyzers is a barrier to comparing competing design. Various forms of data flow analysis have been used in program optimization. Software engineering researchers have also used this technique to support software validation <ref> [CK93, DS91, FO76, OO92, TO80] </ref>. Even very different data flow analyzers share a number of common features.
Reference: [Gra89] <author> Philippe Granger. </author> <title> Static analysis of arithmetical congruences. </title> <journal> International Journal of Computer Mathematics, </journal> <volume> 30 </volume> <pages> 165-190, </pages> <year> 1989. </year>
Reference-contexts: We are also building components for other common types of state variables, such as bounded counters, and for the lattice of singletons, lattice of intervals, and lattice of arithmetic congruences <ref> [Gra89] </ref>. In summary, we have identified classes of components of data flow analyzers, defined general interfaces to such components and created an architecture in which such components can be easily combined to produce an analyzer for a given data flow problem.
Reference: [GS93] <author> Dirk Grunwald and Harini Srinivasan. </author> <title> Efficient computation of precedence information in parallel programs. </title> <booktitle> In Proceedings of the Sixth Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Graph types for concurrent programs such as state reachability graphs, Petri nets, and a number of control-flow-graph-like representations <ref> [CKS90, DC94, GS93, MR93] </ref> can also be adapted to meet the interface. The cost of solving a data flow problem is strongly dependent on flow graph size. A number of representations have been developed that effectively reduce flow graph size for some data flow analyses.
Reference: [Hec77] <author> Matthew S. Hecht. </author> <title> Flow Analysis of Computer Programs. The Computer Science Library Programming Language Series. </title> <publisher> Elsevier North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: Reasoning about these mathematical objects allows one to determine performance characteristics of analyzers for a given data flow problem. A number of theoretical results and algorithms related to specific classes of data flow frameworks have been developed <ref> [ASU85, Hec77, MR90] </ref>. Most of the work on data flow analysis is aimed at supporting analysis of sequential programs. <p> Our intent is that those algorithms are to be implemented once, installed in the library of solver components, and incorporated into data flow analyzers as needed. To date, we have provided an iterative worklist solution algorithm for frameworks with monotone function spaces formulated over both sequential <ref> [Hec77] </ref> and concurrent flow graphs [Dwy95]. For the communication dominator problem, the data flow analyzer is constructed using the bit-vector lattice, sparse flow graph, gen-kill function space and iterative solver. Figure 5 gives the details of this defi nition.
Reference: [HMCCR93] <author> M.W. Hall, J. Mellor-Crummey, A. Carle, and R. Rodriguez. Fiat: </author> <title> A framework for interproce-dural analysis and transformation. </title> <booktitle> In Proceedings of the Sixth Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Compiler systems do not, however, provide high-level analyzer generator capabilities. Recent work has exploited the inherent generality of data flow frameworks and attempted to explore some of the issues in supporting a flexible, general approach for constructing data flow analyzers. FIAT <ref> [HMCCR93] </ref> is a framework for rapid prototyping of interprocedural analyses and transformations; it provide interfaces for describing a data flow analysis problem as a data flow framework and provides a general iterative solver with which to construct analyzers.
Reference: [HR81] <author> L. Howard Holley and Barry K. Rosen. </author> <title> Qualified data flow problems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(1):60-78, </volume> <month> January </month> <year> 1981. </year>
Reference-contexts: An alternate approach is to include information in the data flow problem that is used to restrict consideration of certain program paths. This has been done for individual data flow analyses, e.g., [WZ91]. A more general method, and one that we employ, is to use qualified data flow analysis <ref> [HR81] </ref>. We refer to the data flow problem of interest as the primary problem. We then formulate necessary conditions for path executability and encode those conditions as constraint data flow problems. A qualified 8 problem is a combination of a primary and a set of constraint data flow problems.
Reference: [MR90] <author> T.J. Marlowe and B.G. Ryder. </author> <title> Properties of data flow frameworks. </title> <journal> Acta Informatica, </journal> <volume> 28 </volume> <pages> 121-163, </pages> <year> 1990. </year>
Reference-contexts: Reasoning about these mathematical objects allows one to determine performance characteristics of analyzers for a given data flow problem. A number of theoretical results and algorithms related to specific classes of data flow frameworks have been developed <ref> [ASU85, Hec77, MR90] </ref>. Most of the work on data flow analysis is aimed at supporting analysis of sequential programs.
Reference: [MR93] <author> S.P. Masticola and B.G. Ryder. </author> <title> Non-concurrency analysis. </title> <booktitle> In Proceedings of the 4th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Graph types for concurrent programs such as state reachability graphs, Petri nets, and a number of control-flow-graph-like representations <ref> [CKS90, DC94, GS93, MR93] </ref> can also be adapted to meet the interface. The cost of solving a data flow problem is strongly dependent on flow graph size. A number of representations have been developed that effectively reduce flow graph size for some data flow analyses.
Reference: [OO92] <author> K.M. Olender and L.J. Osterweil. </author> <title> Interprocedural static analysis of sequencing constraints. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(1) </volume> <pages> 21-52, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: In these cases, the significant software development cost of building data flow analyzers is a barrier to comparing competing design. Various forms of data flow analysis have been used in program optimization. Software engineering researchers have also used this technique to support software validation <ref> [CK93, DS91, FO76, OO92, TO80] </ref>. Even very different data flow analyzers share a number of common features.
Reference: [TH92] <author> Steven W. K. Tjiang and John L. Hennessy. </author> <title> Sharlit a tool for building optimizers. </title> <journal> SIG-PLAN Notices, </journal> <volume> 27(7) </volume> <pages> 82-93, </pages> <month> July </month> <year> 1992. </year> <booktitle> Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation. </booktitle> <pages> 12 </pages>
Reference-contexts: FIAT [HMCCR93] is a framework for rapid prototyping of interprocedural analyses and transformations; it provide interfaces for describing a data flow analysis problem as a data flow framework and provides a general iterative solver with which to construct analyzers. Sharlit <ref> [TH92] </ref> is a tool for generating compiler optimization phases that incorporate data flow analyzers; it generates a data flow analyzer, based on an iterative solver, from code fragments that specify the components of a data flow framework.
Reference: [TO80] <author> R.N. Taylor and L.J. Osterweil. </author> <title> Anomaly detection in concurrent software by static data flow analysis. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(3):265-277, </volume> <month> May </month> <year> 1980. </year>
Reference-contexts: In these cases, the significant software development cost of building data flow analyzers is a barrier to comparing competing design. Various forms of data flow analysis have been used in program optimization. Software engineering researchers have also used this technique to support software validation <ref> [CK93, DS91, FO76, OO92, TO80] </ref>. Even very different data flow analyzers share a number of common features.
Reference: [WZ91] <author> Mark N. Wegman and F. Kenneth Zadeck. </author> <title> Constant propagation with conditional branches. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 181-210, </pages> <month> apr </month> <year> 1991. </year> <month> 13 </month>
Reference-contexts: When the domain of values of interest is too large or the mapping from values to indexes, required for bit-vectors, is too expensive, one can use a more general set component. The boolean variable lattice component can be represented as a special case of the lattice of singletons <ref> [WZ91] </ref>. This lattice, illustrated in Figure 3, is designed to work with the boolean variable function space to track the values of boolean variables. <p> An alternate approach is to include information in the data flow problem that is used to restrict consideration of certain program paths. This has been done for individual data flow analyses, e.g., <ref> [WZ91] </ref>. A more general method, and one that we employ, is to use qualified data flow analysis [HR81]. We refer to the data flow problem of interest as the primary problem. We then formulate necessary conditions for path executability and encode those conditions as constraint data flow problems.
References-found: 22

