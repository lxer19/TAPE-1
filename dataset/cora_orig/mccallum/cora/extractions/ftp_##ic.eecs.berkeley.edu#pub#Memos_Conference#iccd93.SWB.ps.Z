URL: ftp://ic.eecs.berkeley.edu/pub/Memos_Conference/iccd93.SWB.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~vigyan/publications/index.html
Root-URL: http://www.cs.berkeley.edu
Title: Heuristic Minimization of Synchronous Relations  
Author: Vigyan Singhal, Yosinori Watanabe and Robert K. Brayton 
Address: Berkeley, CA 94720  
Affiliation: Department of Electrical Engineering and Computer Sciences University of California,  
Abstract: Synchronous Boolean relations can represent sequential don't care information in synchronous systems. These allow greater flexibility in expressing don't care information than ordinary Boolean relations. Synchronous relations can be used to specify sequential designs both at the finite state machine level as well as at the level of combinational elements and latches. The main objective of this paper is to present a heuristic approach to find a minimal implementation for a given synchronous relation. We also show that the synchronous relation formulation can also be used to find a minimal sum-of-products form which implements a function compatible with an arbitrary set of Boolean relations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Damiani and G. De Micheli, </author> <title> Synthesis and Optimization of Synchronous Logic Circuits from Recurrence Equations, </title> <booktitle> in Proc. European Conf. on Design Automation, </booktitle> <pages> pp. 226-231, </pages> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This paper is concerned with the problem of finding minimal cost implementations for synchronous relations. Synchronous relations express the input-output behavior of synchronous systems. Using time-shifted variables it is possible to characterize sequences of input-output behavior using these relations <ref> [1] </ref>. This allows the specification of don't care sequences for sequential designs; such a specification permits a strictly greater expressibility of don't care information than ordinary Boolean relations [2]. <p> In such a situation, we wish to optimize a subcircuit based on the sequential implementation surrounding it. Synchronous relations can be derived to express the flexibility in such scenarios <ref> [1, 4] </ref>. Besides minimization for sequential circuits, synchronous relations can be used for other applications where one needs to express constraints among sets of input-output minterms, for example in the rectification problem for FPGA's [5]. <p> Recall that a function f : B m ! B n is compatible with Boolean relation R B m fi B n if and only if 8x : R (x; f (x)) = 1 [2]. Damiani and De Micheli <ref> [1] </ref> gave a procedure to explicitly compute the exact solution for a given synchronous relation. They introduced additional variables to express the constraints between outputs. The number of additional variables is equal to the number of minterms in the input space (2 m ).
Reference: [2] <author> R. K. Brayton and F. Somenzi, </author> <title> Minimization of Boolean Relations, </title> <booktitle> in Proc. Intl. Symposium on Circuits and Systems, </booktitle> <pages> pp. 738-743, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Using time-shifted variables it is possible to characterize sequences of input-output behavior using these relations [1]. This allows the specification of don't care sequences for sequential designs; such a specification permits a strictly greater expressibility of don't care information than ordinary Boolean relations <ref> [2] </ref>. A synchronous relation S is a Boolean relation which relates sets (of size d 1 ) of input minterms to sets (of size d 2 ) of output minterms, i.e. <p> The traditional approaches to find functions compatible with ordinary Boolean relations <ref> [2, 7] </ref> cannot be used to find solutions for synchronous relations. This is because, unlike synchronous relations, compatibility of a function with an ordinary Boolean relation cannot express constraints between outputs for different inputs. <p> Recall that a function f : B m ! B n is compatible with Boolean relation R B m fi B n if and only if 8x : R (x; f (x)) = 1 <ref> [2] </ref>. Damiani and De Micheli [1] gave a procedure to explicitly compute the exact solution for a given synchronous relation. They introduced additional variables to express the constraints between outputs. The number of additional variables is equal to the number of minterms in the input space (2 m ). <p> First they extract the prime implicant for a feasible compatible function. Then they express the synchronous constraints in terms of the additional variables, and solve a binate covering step, similar to the procedure in <ref> [2] </ref>. We believe that with increase in depth d and the number of input and output variables such an explicit and exact approach is infeasible. We will use a heuristic approach and implicit computations to solve the minimization problem.
Reference: [3] <author> J.-K. Rho, G. Hachtel, and F. Somenzi, </author> <title> Don't Care Sequences and the Optimization of Interacting Finite State Machines, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 418-421, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: The input-output sequences will denote the specification for M 1. and represent some flexibility in its implementation. Such finite sequences can be expressed by synchronous relations. It has been shown in <ref> [3] </ref> how to obtain such finite behavior sequences for the special case of two cascaded FSMs one driving machine and the other driven.
Reference: [4] <author> M. Damiani and G. De Micheli, </author> <title> Recurrence Equations and the Optimization of Synchronous Logic Circuits, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <pages> pp. 556-561, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: In such a situation, we wish to optimize a subcircuit based on the sequential implementation surrounding it. Synchronous relations can be derived to express the flexibility in such scenarios <ref> [1, 4] </ref>. Besides minimization for sequential circuits, synchronous relations can be used for other applications where one needs to express constraints among sets of input-output minterms, for example in the rectification problem for FPGA's [5].
Reference: [5] <author> Y. Kukimoto and M. Fujita, </author> <title> Rectification Method for Lookup-Table Type FPGA's, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 54-61, </pages> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Synchronous relations can be derived to express the flexibility in such scenarios [1, 4]. Besides minimization for sequential circuits, synchronous relations can be used for other applications where one needs to express constraints among sets of input-output minterms, for example in the rectification problem for FPGA's <ref> [5] </ref>. The relationship between synchronous relations and specifications where such constraints occur has been explored in detail in [6]. fl This research was supported by NSF/DARPA Grant MIP-8719546, NSF Grant EMC-8419744 and by various grants from BNR, California Micro Program, DEC, Intel, AT&T and Motorola. communication between the FSMs.
Reference: [6] <author> E. M. Sentovich, V. Singhal, and R. K. Brayton, </author> <title> Multiple Boolean Relations, </title> <booktitle> in Workshop Notes of the Intl. Workshop on Logic Synthesis, </booktitle> <address> (Tahoe City, CA), </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The relationship between synchronous relations and specifications where such constraints occur has been explored in detail in <ref> [6] </ref>. fl This research was supported by NSF/DARPA Grant MIP-8719546, NSF Grant EMC-8419744 and by various grants from BNR, California Micro Program, DEC, Intel, AT&T and Motorola. communication between the FSMs. A synchronous relation can be used to characterize the input-output behavior for the shaded machine M 1. <p> The least expressive specifications in this hierarchy are Boolean functions; more expressive than these are Boolean relations, and the most expressive specifications are Multiple Boolean relations (MBRs) which can represent any arbitrary subset of functions <ref> [6] </ref>. Unlike Boolean relations, synchronous relations can represent a set of functions where the choice of output value at an input minterm may constrain the choices for other minterms. A synchronous relation can be thought of as a Boolean relation with constraints. <p> Consider the two FSM system in Figure 4 (a), where M 1 drives M 2 (i.e. the output of M 1 serves as the input for M 2). Figure 4 (b) shows the values the transition edge outputs edges can take without changing the behavior of the entire system <ref> [6] </ref>. It can be verified that this table represents the complete characterization of the flexibility in choosing these output labels.
Reference: [7] <author> Y. Watanabe and R. K. Brayton, </author> <title> Heuristic Minimization of Boolean Relations, </title> <booktitle> in Proc. of the MCNC Intl. Workshop on Logic Synthesis, </booktitle> <volume> vol. 1, </volume> <month> May </month> <year> 1991. </year>
Reference-contexts: The traditional approaches to find functions compatible with ordinary Boolean relations <ref> [2, 7] </ref> cannot be used to find solutions for synchronous relations. This is because, unlike synchronous relations, compatibility of a function with an ordinary Boolean relation cannot express constraints between outputs for different inputs. <p> Definition 6 For a given synchronous relation S and a compatible representation F , a cube c fl is said to be a feasible cube for c 2 F if F fcg [ fc fl g is compatible with S. We also borrow the following notation from <ref> [7] </ref>. Notation 1 For a given representation F , a function f : B m ! B n is uniquely defined, where the algebraic expression of f is given by F . <p> We start with an initial representation F compatible with S. The cost function we use is the number of product terms in the representation. Our minimization procedure adopts the paradigm of ESPRESSO [10] and GYOCRO <ref> [7] </ref>, the two-level minimizers for incompletely specified functions and Boolean relations, respectively. We iteratively apply ESPRESSO-like procedures (REDUCE, EXPAND and IRREDUNDANT) to the sum of products until we cannot reduce the cost function further. <p> After EXPAND, IRREDUNDANT is invoked. This just eliminates cubes which are irredundant, looking at one cube at a time. 3.2 REDUCE procedure We define the maximally reduced cube just like for Boolean relations <ref> [7] </ref>. <p> Since synchronous relations subsume Boolean relations (as shown in Theorem 2.2), the examples which show the nonuniqueness and non-continuity of REDUCE for output parts in Boolean relations <ref> [7] </ref> hold for synchronous relations also. <p> We maintain two sets, R and L which respectively denote the literals that have been raised and the literals that have been determined not to be raised. Now we describe the operations used in EXPAND in some detail. For a more detailed description refer to <ref> [10, 7] </ref>. The ESSENTIAL operation finds literals which cannot be raised during the current expansion and adds them to L. Cubes in C which are impossible to be covered now are removed. The key operation in EXPAND is MFC. This determines the directions for the expansion of the cube. <p> The two programs that implement these versions are called CHAI-REI and CHAI-IDI, respectively. Since no synchronousrelation benchmarks exist, we constructed a few synchronous relations by composing Boolean relations (obtained from the benchmark examples in <ref> [7] </ref>) as described in Theorem 2.2. Our minimizer was able to jump from one relation to another in search for a smaller sum of products representation. <p> 19.26 16 39.37 c17e 5/3 5 0.91 5 4.55 5 9.44 c17i 5/3 15 1.79 15 13.00 15 29.33 she4 5/6 20 16.28 20 122.03 20 238.03 Table 1: Implementation results for CHAI We performed an experiment to compare the computational efficiency of CHAI-x with the Boolean relation minimizer GYOCRO <ref> [7] </ref>. We composed each of our synchronous relations from a single Boolean relation benchmark example using the method described in Theorem 2.2. We chose the depth of the synchronous relation to be 2.
Reference: [8] <author> R. Bryant, </author> <title> Graph-based Algorithms for Boolean Function Manipulation, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-35, </volume> <pages> pp. 677-691, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: We then present a heuristic approach to find a minimal compatible representation for a synchronous relation. Our approach represents and manipulates the synchronous relation and the candidate compatible function implicitly using Binary Decision Diagrams (BDDs) <ref> [8] </ref>.
Reference: [9] <author> V. Singhal, Y. Watanabe, and R. K. Brayton, </author> <title> Heuristic Minimization for Synchronous Relations, </title> <type> Tech. Rep. </type> <institution> UCB/ERL M93/30, Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <year> 1993. </year>
Reference-contexts: However, we can show that for a synchronous relation where the input depth is larger than the output depth, we can construct an equivalent synchronous relation with equal input/output depth so that a compatible function with the new synchronousrelation corresponds to a compatible function with the old relation <ref> [9] </ref>. The resulting implied implementation, unlike the synchronous relations with equal depth, may depend on the values of x at earlier clock cycles. So, in effect, we have a sequential implementation for the synchronous relation even though the minimization procedure for finding a compatible function f remains unchanged. <p> : ; u d ; v 1 ; : : : ; v d ) = 1 3. 8j 2 f1; : : : ; dg : (u j x j ) ) (v j y j ) Using the above definition, the nucleus can be computed implicitly using BDDs <ref> [9] </ref>. <p> The converse is not true. We need to compute the nucleus only once for a given syn chronous relation, at the beginning of the minimization procedure. The compatibility of a function is checked as described in the following theorem (for proofs of all theorems in this paper, see <ref> [9] </ref>). <p> Now, using the definition of I (c fl ), the function h (w; u; y) can be computed using BDDs (the computational expression is detailed in <ref> [9] </ref>). Once we calculate h (w; u; y), the maximally reduced cube corresponds to the minterm (w; u; y) of h which has the minimum number of 1's. <p> The implicit computations for obtaining the maximal expanded (or increased) cube are similar to those in Section 3.2. The details on these computations and other performance optimizations possible in EXPAND can be found in <ref> [9] </ref>. 3.4 IRREDUNDANT procedure The IRREDUNDANT procedure looks at one cube c 2 F at a time. The cube is removed from the representation if the function represented by F fcg is compatible with the synchronous relation. 4 Experiments We have implemented two versions of the minimizer. <p> For the initial representation, we used the same initial representation used by GYOCRO. For other techniques to obtain the initial representation the reader is referred to <ref> [9] </ref>. We selected the example circuits where GYOCRO did not give the exact minimum representation to see if CHAI does better. The purpose of the experiment is to display the computational efficiency of CHAI. It is not meant to be faster or better than GY-OCRO for solving ordinary Boolean relations.
Reference: [10] <author> R. K. Brayton, G. D. Hachtel, C. T. McMullen, and A. L. Sangiovanni-Vincentelli, </author> <title> Logic Minimization Algorithms for VLSI Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1984. </year>
Reference-contexts: We start with an initial representation F compatible with S. The cost function we use is the number of product terms in the representation. Our minimization procedure adopts the paradigm of ESPRESSO <ref> [10] </ref> and GYOCRO [7], the two-level minimizers for incompletely specified functions and Boolean relations, respectively. We iteratively apply ESPRESSO-like procedures (REDUCE, EXPAND and IRREDUNDANT) to the sum of products until we cannot reduce the cost function further. <p> We maintain two sets, R and L which respectively denote the literals that have been raised and the literals that have been determined not to be raised. Now we describe the operations used in EXPAND in some detail. For a more detailed description refer to <ref> [10, 7] </ref>. The ESSENTIAL operation finds literals which cannot be raised during the current expansion and adds them to L. Cubes in C which are impossible to be covered now are removed. The key operation in EXPAND is MFC. This determines the directions for the expansion of the cube.
Reference: [11] <author> B. Lin and F. Somenzi, </author> <title> Minimization of Symbolic Relations, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 88-91, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: This follows from a proof given in <ref> [11] </ref>. Maximally decreased cube The formulation described in this section to obtain a maximally reduced cube can be easily extended to obtain a maximally decreased cube. Here we relax the restriction that the replacing cube c is contained in the replaced cube c.
References-found: 11

