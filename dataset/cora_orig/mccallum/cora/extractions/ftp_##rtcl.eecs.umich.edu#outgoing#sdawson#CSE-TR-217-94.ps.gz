URL: ftp://rtcl.eecs.umich.edu/outgoing/sdawson/CSE-TR-217-94.ps.gz
Refering-URL: http://www.eecs.umich.edu/~farnam/papers/pubs.html
Root-URL: http://www.cs.umich.edu
Email: fsdawson,farnamg@eecs.umich.edu  
Title: Probing and Fault Injection of Distributed Protocol Implementations  
Author: Scott Dawson and Farnam Jahanian 
Keyword: distributed systems, communication protocol, fault injection, protocol testing, executable specifications  
Note: This work is supported in part by a research grant from the U.S. Office of Naval Research.  
Address: Ann Arbor, MI 48109-2122  
Affiliation: Real-Time Computing Laboratory Electrical Engineering and Computer Science Department University of Michigan  
Abstract: Ensuring that a distributed system with strict dependability constraints meets its prescribed specification is a growing challenge that confronts software developers and system engineers. This paper presents a technique for probing and fault injection of fault-tolerant distributed protocols. The proposed technique, called script-driven probing and fault injection, can be used for studying the behavior of distributed systems and for detecting design and implementation errors of fault-tolerant protocols. The focus of this work is on fault injection techniques that can be used to demonstrate three aspects of a target protocol: i) detection of design or implementation errors, ii) identification of violations of protocol specifications, and iii) insight into design decisions made by the implementors. The emphasis of our approach is on experimental techniques intended to identify specific "problems" in a protocol or its implementation rather than the evaluation of system dependability through statistical metrics such as fault coverage. To demonstrate the capabilities of this technique, the paper describes a probing and fault injection tool, called the PFI tool (Probe/Fault Injection Tool), and a summary of several extensive experiments that studied the behavior of two protocols: the Transmission Control Protocol (TCP) [5, 28] and the Group Membership Protocol (GMP) [20]. A shorter version of this paper will appear in the Proceedings of the International Conference on Distributed Computing Systems (ICDCS) in 1995. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Arlat, Y. Crouzet, and J.-C. Laprie. </author> <title> Fault injection for dependability validation of fault-tolerant computing systems. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 348-355, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Our experience in testing the fault-tolerance capabilities of the Group Membership Protocol (GMP), as described in Section 4, seems to support this view. 18 Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection <ref> [1, 13, 31] </ref> and simulation approaches for injecting hardware failures [7, 10, 14] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [6, 30].
Reference: [2] <author> Jean Arlat, Martine Aguera, Yves Crouzet, Jean-Charles Fabre, Eliane Martins, and David Powell. </author> <title> Experimental evaluation of the fault tolerance of an atomic multicast system. </title> <journal> IEEE Trans. Reliability, </journal> <volume> 39(4) </volume> <pages> 455-467, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 11, 12, 16]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. For example, the work reported in <ref> [2] </ref> calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol in the presence of faults. Other work can be characterized as probabilistic approaches to test generation [3, 11].
Reference: [3] <author> D. Avresky, J. Arlat, J.C. Laprie, and Yves Crouzet. </author> <title> Fault injection for the formal testing of fault tolerance. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 345-354. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [6, 30]. Others have emulated fault-injection into CPU components [21], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [3, 11, 12, 16] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> For example, the work reported in [2] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol in the presence of faults. Other work can be characterized as probabilistic approaches to test generation <ref> [3, 11] </ref>. The work reported in [16] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor.
Reference: [4] <author> O. Babaoglu and K. Marzullo. </author> <title> Consistent global states of distributed systems: Fundamental concepts and mechanism. In Sape Mullender, editor, Distributed Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year> <note> Second Edition. </note>
Reference-contexts: Methodology or formal framework for orchestrating a computation: Although script-driven probing and fault injection has been applied to several complex communication protocols and distributed applications, we need to develop a formal framework for orchestrating a computation. Past work on global snapshots or global 20 predicate detection <ref> [4] </ref> is closely related to this problem. Furthermore, we need to identify a minimal set of primitives for injecting faults given a certain failure model. Acknowledgment This work is supported by a grant from the U.S. Office of Naval Research.
Reference: [5] <author> R. Braden. RFC-1122: </author> <title> Requirements for internet hosts. Request for Comments, </title> <month> October </month> <year> 1989. </year> <institution> Network Information Center. </institution>
Reference-contexts: In describing the proposed fault injection approach, this paper focuses on experiments that studied the behavior of two protocols: the Transmission Control Protocol (TCP) <ref> [5, 28] </ref> and the Group Membership Protocol (GMP) [20]. In the case of TCP, we used the PFI tool to duplicate the experiments reported in [8] on several TCP implementations without access to the vendors' TCP source code in a very short time. <p> Because TCP is designed to operate over links of different speeds and reliability, it is widely used on the Internet. TCP was originally defined in RFC-793 [28] and was updated in RFC-1122 <ref> [5] </ref>. In order to meet the TCP standard, an implementation must follow both RFCs. To test vendor TCP implementations, we modified an x-Kernel protocol stack to include a layer which incorporates the PFI tool described in Section 3. <p> If the sender sends more data than the receiver is willing to receive, the receiver may drop the data (unless the window has reopened). Probing of zero (offered) windows MUST be supported <ref> [5, 28] </ref> because an ACK segment which reopens the window may be lost if it contains no data.
Reference: [6] <author> R. Chillarege and N. S. Bowen. </author> <title> Understanding large system failures | a fault injection experiment. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 356-363, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Hardware fault-injection [1, 13, 31] and simulation approaches for injecting hardware failures [7, 10, 14] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [6, 30] </ref>. Others have emulated fault-injection into CPU components [21], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 11, 12, 16].
Reference: [7] <author> G. Choi, R. Iyer, and V. Carreno. </author> <title> Simulated fault injection: A methodology to evaluate fault tolerant microprocessor architectures. </title> <journal> IEEE Trans. Reliability, </journal> <volume> 39(4) </volume> <pages> 486-490, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Hardware fault-injection [1, 13, 31] and simulation approaches for injecting hardware failures <ref> [7, 10, 14] </ref> have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [6, 30]. Others have emulated fault-injection into CPU components [21], typically by setting voltages on pins or wires.
Reference: [8] <author> Douglas E. Comer and John C. Lin. </author> <title> Probing TCP implementations. </title> <booktitle> In Proc. Summer USENIX Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: In describing the proposed fault injection approach, this paper focuses on experiments that studied the behavior of two protocols: the Transmission Control Protocol (TCP) [5, 28] and the Group Membership Protocol (GMP) [20]. In the case of TCP, we used the PFI tool to duplicate the experiments reported in <ref> [8] </ref> on several TCP implementations without access to the vendors' TCP source code in a very short time. We also ran several new experiments that are difficult to perform using past approaches based on packet monitoring and filtering. <p> The send script of the fault injection layer was set up to delay each outgoing ACK for 30 ACKs in a row. After doing this, the receive filter started dropping all incoming packets. Each incoming packet was logged. Approaches which depend on monitoring and filtering packets <ref> [8, 23] </ref> cannot perform tests like this one because they do not have the ability to manipulate messages. <p> Another closely related work is the active probing approach proposed in a recent paper by Comer and Lin <ref> [8] </ref> to study five TCP implementations. Active probing treats a TCP implementation as a black box, and it uses a set of user-level procedures to probe the black box. Using the NetMetrix protocol analyzer and monitor tools, trace data is gathered and analyzed to reveal characteristics of various TCP implementations. <p> Using the NetMetrix protocol analyzer and monitor tools, trace data is gathered and analyzed to reveal characteristics of various TCP implementations. In addition to repeating TCP experiments similar to those reported in <ref> [8] </ref>, our approach allows other tests that are not possible with techniques that are based primarily on monitoring and gathering trace data. In particular, our approach differs from the active probing technique in four major aspects.
Reference: [9] <author> F. Cristian. </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems. </title> <journal> Distributed Computing, </journal> (4):175-187, 1991. 
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., <ref> [9, 25, 29] </ref>. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in [20], ensures that membership changes are seen in the same order by all members.
Reference: [10] <author> E. Czeck and D. Siewiorek. </author> <title> Effects of transient gate-level faults on program behaviour. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 236-243. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: Hardware fault-injection [1, 13, 31] and simulation approaches for injecting hardware failures <ref> [7, 10, 14] </ref> have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [6, 30]. Others have emulated fault-injection into CPU components [21], typically by setting voltages on pins or wires.
Reference: [11] <author> K. Echtle and Y. Chen. </author> <title> Evaluation of deterministic fault injection for fault-tolerant protocol testing. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 418-425. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [6, 30]. Others have emulated fault-injection into CPU components [21], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [3, 11, 12, 16] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> For example, the work reported in [2] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol in the presence of faults. Other work can be characterized as probabilistic approaches to test generation <ref> [3, 11] </ref>. The work reported in [16] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. <p> The tool is used mainly for emulating a wide-area network in a local network development environment and allows the user to specify delays on certain paths which the application is using. This work and that reported in <ref> [11] </ref> are closest to the approach proposed here. Rather than estimating fault coverages for evaluating dependability of distributed systems, this work focuses on techniques for identifying violations of protocol specifications and for detecting design or implementations errors.
Reference: [12] <author> Klaus Echtle and Martin Leu. </author> <title> The EFA fault injector for fault-tolerant distributed system testing. </title> <booktitle> In Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <pages> pages 28-35. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [6, 30]. Others have emulated fault-injection into CPU components [21], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [3, 11, 12, 16] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [13] <author> G. Finelli. </author> <title> Characterization of fault recovery through fault injection on ftmp. </title> <journal> IEEE Trans. Reliability, </journal> <volume> 36(2) </volume> <pages> 164-170, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Our experience in testing the fault-tolerance capabilities of the Group Membership Protocol (GMP), as described in Section 4, seems to support this view. 18 Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection <ref> [1, 13, 31] </ref> and simulation approaches for injecting hardware failures [7, 10, 14] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [6, 30].
Reference: [14] <author> K. Goswami and R. Iyer. </author> <title> Simulation of software behaviour under hardware faults. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 218-227. </pages> <publisher> IEEE, </publisher> <year> 1993. </year> <month> 21 </month>
Reference-contexts: Hardware fault-injection [1, 13, 31] and simulation approaches for injecting hardware failures <ref> [7, 10, 14] </ref> have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [6, 30]. Others have emulated fault-injection into CPU components [21], typically by setting voltages on pins or wires.
Reference: [15] <author> Vassos Hadzilacos and Sam Toueg. </author> <title> Fault-tolerant broadcasts and related problems. In Sape Mullender, editor, Distributed Systems. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year> <note> Second Edition. </note>
Reference-contexts: Although a formal treatment of different failure models is beyond the scope of this presentation <ref> [15] </ref>, a brief outline of various failure assumptions that can be tested by our technique is described below. Process crash failures: A process/processor fails by halting prematurely and doing nothing from that point on. Before stopping, however, it behaves correctly.
Reference: [16] <author> Seungjae Han, Harold A. Rosenberg, and Kang G. Shin. DOCTOR: </author> <title> An integrateD sOftware fault injeCTOn enviRonment. </title> <type> Technical Report CSE-TR-192-93, </type> <institution> The University of Michigan, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [6, 30]. Others have emulated fault-injection into CPU components [21], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently <ref> [3, 11, 12, 16] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> Other work can be characterized as probabilistic approaches to test generation [3, 11]. The work reported in <ref> [16] </ref> focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. The Delayline tool presented in [18] allows the user to introduce delays into user-level protocols.
Reference: [17] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 17(1) </volume> <pages> 1-13, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: intrusiveness issue, and they describe future research directions of this work. 1 2 Approach 2.1 Script-Driven Probing and Fault Injection The proposed approach views a distributed protocol as an abstraction through which a collection of participants communicate by exchanging a set of messages, in the same spirit as the x-Kernel <ref> [17] </ref>. In this model, we make no distinction between application-level protocols, interprocess communication protocols, network protocols, or device layer protocols.
Reference: [18] <author> David B. Ingham and Graham D. Parrington. Delayline: </author> <title> A wide-area network emulation tool. </title> <journal> Computing Systems, </journal> <volume> 7(3) </volume> <pages> 313-332, </pages> <month> Summer </month> <year> 1994. </year>
Reference-contexts: The work reported in [16] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. The Delayline tool presented in <ref> [18] </ref> allows the user to introduce delays into user-level protocols. The tool is used mainly for emulating a wide-area network in a local network development environment and allows the user to specify delays on certain paths which the application is using.
Reference: [19] <author> Van Jacobson. </author> <title> Congestion avoidance and control. </title> <booktitle> In Proc. of ACM SIGCOMM, </booktitle> <pages> pages 314-329, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: The retransmission timeout value (RTO) for a TCP connection is calculated based on measured round trip time (RTT) from the time each packet is sent until the ACK for the packet is received. RFC-1122 specifies that a TCP must use Jacobson's algorithm <ref> [19] </ref> for computing the retransmission timeout coupled with Karn's algorithm [22] for selecting the RTT measurements. Karn's algorithm ensures that ambiguous round-trip times will not corrupt the calculation of the smoothed round-trip time. We ran two variations on the same experiment.
Reference: [20] <author> Farnam Jahanian, Ragunathan Rajkumar, and Sameh Fakhouri. </author> <title> Processor group membership protocols: Specification, </title> <booktitle> design and implementation. In Proceedings of the 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <address> Princeton, New Jersey, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: In describing the proposed fault injection approach, this paper focuses on experiments that studied the behavior of two protocols: the Transmission Control Protocol (TCP) [5, 28] and the Group Membership Protocol (GMP) <ref> [20] </ref>. In the case of TCP, we used the PFI tool to duplicate the experiments reported in [8] on several TCP implementations without access to the vendors' TCP source code in a very short time. <p> Table 4: TCP Zero Window Probe Results 4.2 Testing of GMP The objective of the experiments described in this subsection is to test the fault-tolerance capabilities of a prototype implementation of the strong group membership protocol <ref> [20] </ref> using the probe and fault injection technique presented earlier. In a distributed environment, a collection of processes (or processors) can be grouped together to provide a service. <p> The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., [9, 25, 29]. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in <ref> [20] </ref>, ensures that membership changes are seen in the same order by all members. In this protocol, a group of processors have a unique leader based on the processor id of each member.
Reference: [21] <author> G.A Kanawati, N.A. Kanawati, and J.A. Abraham. FERRARI: </author> <title> A tool for the validation of system dependability properties. </title> <booktitle> In Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pages 336-344. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Hardware fault-injection [1, 13, 31] and simulation approaches for injecting hardware failures [7, 10, 14] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [6, 30]. Others have emulated fault-injection into CPU components <ref> [21] </ref>, typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 11, 12, 16]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [22] <author> Phil Karn and Craig Partridge. </author> <title> Round trip time estimation. </title> <booktitle> In Proc. SIGCOMM 87, </booktitle> <address> Stowe, Vermont, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: RFC-1122 specifies that a TCP must use Jacobson's algorithm [19] for computing the retransmission timeout coupled with Karn's algorithm <ref> [22] </ref> for selecting the RTT measurements. Karn's algorithm ensures that ambiguous round-trip times will not corrupt the calculation of the smoothed round-trip time. We ran two variations on the same experiment.
Reference: [23] <author> Steven McCanne and Van Jacobson. </author> <title> The bsd packet filter: A new architecture for user-level packet capture. </title> <booktitle> In Winter USENIX Conference, </booktitle> <pages> pages 259-269, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The send script of the fault injection layer was set up to delay each outgoing ACK for 30 ACKs in a row. After doing this, the receive filter started dropping all incoming packets. Each incoming packet was logged. Approaches which depend on monitoring and filtering packets <ref> [8, 23] </ref> cannot perform tests like this one because they do not have the ability to manipulate messages. <p> Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [26], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator <ref> [23] </ref>, and the Mach Packet Filter (MPF) [32] which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
Reference: [24] <author> Clifford W. Mercer, Jim Zelenka, and Ragunathan Rajkumar. </author> <title> On predictable operating system protocol processing. </title> <type> Technical Report CMU-CS-94-165, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: In particular, certain features of RT-Mach will be utilized to compensate for the intrusiveness of the fault injection experiments on the target real-time protocol. First, since most of the intrusiveness of the proposed fault injection and probing technique will manifest itself as additional communication overhead, the capacity reservation facility <ref> [24] </ref> in RT-Mach is an effective mechanism for compensating for this overhead by allocating extra CPU resources to schedule communication activities.
Reference: [25] <author> Shivakant Mishra, Larry L. Peterson, and Richard D. Schlichting. </author> <title> A membership protocol based on partial order. </title> <booktitle> In Second Working Conference on Dependable Computing for Critical Applications, </booktitle> <month> February </month> <year> 1990. </year>
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., <ref> [9, 25, 29] </ref>. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in [20], ensures that membership changes are seen in the same order by all members.
Reference: [26] <author> J. Mogul, R. Rashid, and M. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proc. ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year> <note> ACM. </note>
Reference-contexts: To minimize data copying across kernel/user-space protection boundaries, a kernel agent, called a packet filter, is often used to discard unwanted packets as early as possible. Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter <ref> [26] </ref>, a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [23], and the Mach Packet Filter (MPF) [32] which is an extension of the BPF, are related to the work presented in this paper.
Reference: [27] <author> John K. Ousterhout. </author> <title> Tcl: An embeddable command language. </title> <booktitle> In Winter USENIX Conference, </booktitle> <pages> pages 133-146, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Figure 2 illustrates the various components of the PFI tool: send/receive scripts, filters (or interpreters), recognition/generation stubs, user-defined procedures, and system utilities. Send/receive scripts are the instructions for orchestrating a computation into a particular path and for injecting faults into a system. We chose Tcl <ref> [27] </ref> as the language for writing the scripts. Filters are the interpreters that execute the scripts as messages pass through the PFI layer. In Tcl, an interpreter is simply an object which contains some state about variables and procedures which have been defined.
Reference: [28] <author> Jon Postel. RFC-793: </author> <title> Transmission control protocol. Request for Comments, </title> <month> September </month> <year> 1981. </year> <institution> Network Information Center. </institution>
Reference-contexts: In describing the proposed fault injection approach, this paper focuses on experiments that studied the behavior of two protocols: the Transmission Control Protocol (TCP) <ref> [5, 28] </ref> and the Group Membership Protocol (GMP) [20]. In the case of TCP, we used the PFI tool to duplicate the experiments reported in [8] on several TCP implementations without access to the vendors' TCP source code in a very short time. <p> TCP is connection-oriented protocol and it uses flow-control between protocol 6 participants to operate over network connections that are inherently unreliable. Because TCP is designed to operate over links of different speeds and reliability, it is widely used on the Internet. TCP was originally defined in RFC-793 <ref> [28] </ref> and was updated in RFC-1122 [5]. In order to meet the TCP standard, an implementation must follow both RFCs. To test vendor TCP implementations, we modified an x-Kernel protocol stack to include a layer which incorporates the PFI tool described in Section 3. <p> If the sender sends more data than the receiver is willing to receive, the receiver may drop the data (unless the window has reopened). Probing of zero (offered) windows MUST be supported <ref> [5, 28] </ref> because an ACK segment which reopens the window may be lost if it contains no data.
Reference: [29] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Using process groups to implement failure detection in asynchronous environments. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, Quebec, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: A member may depart from a group due to a normal shutdown, such as a scheduled maintenance, or due to a failure. The group membership problem has been studied extensively in the past both for synchronous and asynchronous systems, e.g., <ref> [9, 25, 29] </ref>. A detailed exposition of this problem is beyond the scope of this presentation. Informally, the strong group membership protocol, as described in [20], ensures that membership changes are seen in the same order by all members.
Reference: [30] <author> Z. Segall et al. </author> <title> Fiat fault injection based automated testing environment. </title> <booktitle> In FTCS-18, </booktitle> <pages> pages 102-107, </pages> <year> 1988. </year>
Reference-contexts: Hardware fault-injection [1, 13, 31] and simulation approaches for injecting hardware failures [7, 10, 14] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [6, 30] </ref>. Others have emulated fault-injection into CPU components [21], typically by setting voltages on pins or wires. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [3, 11, 12, 16].
Reference: [31] <author> K. G. Shin and Y. H. Lee. </author> <title> Measurement and application of fault latency. </title> <journal> IEEE Trans. Computers, </journal> <volume> C-35(4):370-375, </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: Our experience in testing the fault-tolerance capabilities of the Group Membership Protocol (GMP), as described in Section 4, seems to support this view. 18 Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection <ref> [1, 13, 31] </ref> and simulation approaches for injecting hardware failures [7, 10, 14] have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [6, 30].
Reference: [32] <author> Masanobu Yuhara, Brian N. Bershad, Chris Maeda, and J. Eliot B. Moss. </author> <title> Efficient packet demultiplex-ing for multiple endpoints and large messages. </title> <booktitle> In Winter USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year> <note> Second Edition. 22 </note>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [26], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [23], and the Mach Packet Filter (MPF) <ref> [32] </ref> which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
References-found: 32

