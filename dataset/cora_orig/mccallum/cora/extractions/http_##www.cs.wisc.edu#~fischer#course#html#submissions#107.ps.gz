URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/107.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/
Root-URL: http://www.cs.wisc.edu
Email: e-mail: ilyas@bilkent.edu.tr  
Title: Procedure Backtracking Points And Variable Ages In An Intelligent Backtracking Schema  
Author: Ilyas Cicekli 
Address: 06533 Bilkent, Ankara, Turkey,  
Affiliation: Dept. of Comp. Eng. and Info. Sc., Bilkent University  
Abstract: We present a new method to represent variable bindings in the Warren Abstract Machine (WAM), so that ages of variable bindings can be easily found using this new representation in our intelligent backtracking schema. The age of a variable bound to a non-variable term will be the youngest choice point such that backtracking to that choice point can make that variable an unbound variable again. In other words, the age of a variable bound to a non-variable term will be the age of the youngest one of bindings causing that variable to be bound to that non-variable term. The procedure backtracking point is the choice point of the procedure being currently executed or the choice point of its first ancestor having a choice point. Variable ages and procedure backtracking points are used in the process of figuring out backtracking points in our intelligent backtracking schema. Our intelligent backtracking schema performs much better than results of other intelligent backtracking methods in the literature for deterministic programs, and its performance for non deterministic programs are comparable with their results. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> At-Kaci, H., </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction, </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1991. </year>
Reference-contexts: During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM <ref> [1] </ref>. Many intelligent backtracking schemes [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems.
Reference: [2] <editor> ALS Prolog Manual, </editor> <booktitle> Applied Logic Systems. </booktitle> <publisher> Inc., </publisher> <year> 1992. </year>
Reference-contexts: The WAM is recognized as a breakthrough in the design of Prolog systems and other computational logic systems by the logic programming community. Many commercial <ref> [2, 14] </ref> and non-commercial Prolog systems based on the WAM are implemented during last decade. During discussions in this paper, we will assume that the reader has a familiarity with the WAM.
Reference: [3] <author> Bruynooghe M. and Pereiara L. M., </author> <title> Deduction Revision by Intelligent Backtracking, in Implementations of Prolog, </title> <editor> ed. Cambell J. A., </editor> <publisher> Ellis Horwood, </publisher> <year> 1984. </year>
Reference-contexts: During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes <ref> [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] </ref> are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. <p> Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking <ref> [3, 8, 13] </ref> are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. Our intelligent backtracking schema whose some parts are presented in this paper is implemented as an extension of the WAM same as systems in [5, 10]. <p> The mechanism we proposed is naturally integrated with the WAM architecture, and our performance results are better than performance results of systems in <ref> [3, 5, 10] </ref> and some of them are presented in Section 7. We concentrate on a new representation for variable bindings in the WAM, so that ages of variables can be easily found using this new representation. <p> Finally, we present some of our performance results in the last section. 2 Related Research Research on intelligent backtracking has started in late 70's. Early works are done by Bruynooghe and Pereira <ref> [3] </ref>, and Cox and Pitrzykowski [8]. These first two systems are implemented by extending Prolog interpreters. These methods collect information about bindings during unification and analyze it to determine intelligent backtracking point when failure occurs. <p> Most of intelligent backtracking methods in the literature associate some kinds of sets with literals to store intelligent backtracking points. These sets are called alternative backtrack points in [5, 6], 2 B-lists in [11], rejected procedures in <ref> [3] </ref>, witness sets in [17] and candidate sets in [7]. These intelligent backtracking schemes associate these sets with literal of the proof tree and use them to choose intelligent backtracking points. Somehow they have to update these sets during unification or failure. <p> If there are a lot of failures, gains by avoiding redundant backtrackings will be more than overheads due to more complex failure routine. We also test our implementation with certain benchmarks to compare our results with other intelligent backtracking methods presented in <ref> [3, 11, 6] </ref>. Table 1 gives speed ups and slow downs of the intelligent backtracking methods with respect to Prolog. For example, our figures in Table 1 give comparison of our intelligent backtracking scheme to the byte-emulator of ALS Prolog.
Reference: [4] <author> Chang J.-H. and Despain A. M., </author> <title> Semi-Intelligent Backtracking of Prolog Based on a Static Data Dependency Analysis, </title> <booktitle> Proc. of 2 nd Int. Symp. on Logic Programming, </booktitle> <address> Boston, </address> <year> 1985. </year>
Reference-contexts: During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes <ref> [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] </ref> are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. <p> They also tag all variables to represent data dependency graph. These tags are used to figure out bindings causing the failure of a goal. To reduce the overhead for constructing the data dependency graph, Chang and Despain <ref> [4] </ref> construct a worst-case data dependency graph at compile time for each clause. Since backtrack literals are chosen at compile time, their schema has a little bit overhead at run time.
Reference: [5] <author> Codognet P., Codognet C. and File G., </author> <title> Yet Another Intelligent Backtracking Method, </title> <booktitle> Proc. of 5 th Int. Conf. and Symp. on Logic Programming, </booktitle> <address> Seattle, </address> <year> 1988. </year>
Reference-contexts: During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes <ref> [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] </ref> are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. <p> Many intelligent backtracking schemes [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works <ref> [5, 6, 10, 11] </ref> are WAM based systems. Our intelligent backtracking schema whose some parts are presented in this paper is implemented as an extension of the WAM same as systems in [5, 10]. <p> Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. Our intelligent backtracking schema whose some parts are presented in this paper is implemented as an extension of the WAM same as systems in <ref> [5, 10] </ref>. Our mechanism is similar to mechanisms used in those systems except that how we keep unification information for variable bindings and how we find reasons of failures. <p> The mechanism we proposed is naturally integrated with the WAM architecture, and our performance results are better than performance results of systems in <ref> [3, 5, 10] </ref> and some of them are presented in Section 7. We concentrate on a new representation for variable bindings in the WAM, so that ages of variables can be easily found using this new representation. <p> So, the main responsibility will be on the user in this schema. The efficiency of this method will depend on how well the possible activations of goals are marked. Codognet and his colleagues proposed a depth-first intelligent backtracking schema in <ref> [5] </ref> and gave its WAM-based implementation in [6]. In their schema, unification instructions record source of bindings and failure routines choose intelligent backtracking point and update sets of intelligent backtracking points. During unifications, they create a simplified version of the unification graph which records time of bindings. <p> For this reason, their schema gives less accurate results than the other unification based schemes including our schema. Most of intelligent backtracking methods in the literature associate some kinds of sets with literals to store intelligent backtracking points. These sets are called alternative backtrack points in <ref> [5, 6] </ref>, 2 B-lists in [11], rejected procedures in [3], witness sets in [17] and candidate sets in [7]. These intelligent backtracking schemes associate these sets with literal of the proof tree and use them to choose intelligent backtracking points.
Reference: [6] <author> Codognet P. and Sola T., </author> <title> Extending the WAM for Intelligent Backtracking, </title> <booktitle> Proc. of 8 th Int. Conf. on Logic Programming, </booktitle> <address> Paris, </address> <year> 1991. </year>
Reference-contexts: During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes <ref> [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] </ref> are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. <p> Many intelligent backtracking schemes [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works <ref> [5, 6, 10, 11] </ref> are WAM based systems. Our intelligent backtracking schema whose some parts are presented in this paper is implemented as an extension of the WAM same as systems in [5, 10]. <p> So, the main responsibility will be on the user in this schema. The efficiency of this method will depend on how well the possible activations of goals are marked. Codognet and his colleagues proposed a depth-first intelligent backtracking schema in [5] and gave its WAM-based implementation in <ref> [6] </ref>. In their schema, unification instructions record source of bindings and failure routines choose intelligent backtracking point and update sets of intelligent backtracking points. During unifications, they create a simplified version of the unification graph which records time of bindings. <p> For this reason, their schema gives less accurate results than the other unification based schemes including our schema. Most of intelligent backtracking methods in the literature associate some kinds of sets with literals to store intelligent backtracking points. These sets are called alternative backtrack points in <ref> [5, 6] </ref>, 2 B-lists in [11], rejected procedures in [3], witness sets in [17] and candidate sets in [7]. These intelligent backtracking schemes associate these sets with literal of the proof tree and use them to choose intelligent backtracking points. <p> If there are a lot of failures, gains by avoiding redundant backtrackings will be more than overheads due to more complex failure routine. We also test our implementation with certain benchmarks to compare our results with other intelligent backtracking methods presented in <ref> [3, 11, 6] </ref>. Table 1 gives speed ups and slow downs of the intelligent backtracking methods with respect to Prolog. For example, our figures in Table 1 give comparison of our intelligent backtracking scheme to the byte-emulator of ALS Prolog.
Reference: [7] <author> Conery J.S., </author> <title> Implementing Backward Execution in Nondeterministic AND-parallel Systems, </title> <booktitle> Proc. of 4 th Int. Conf. on Logic Programming, </booktitle> <address> Melbourne, </address> <year> 1987. </year>
Reference-contexts: Most of intelligent backtracking methods in the literature associate some kinds of sets with literals to store intelligent backtracking points. These sets are called alternative backtrack points in [5, 6], 2 B-lists in [11], rejected procedures in [3], witness sets in [17] and candidate sets in <ref> [7] </ref>. These intelligent backtracking schemes associate these sets with literal of the proof tree and use them to choose intelligent backtracking points. Somehow they have to update these sets during unification or failure.
Reference: [8] <author> Cox P. and Pietrzylowski T., </author> <title> Deduction Plans: A Basis for Intelligent Backtracking, </title> <journal> IEEE PAMI, </journal> <volume> Vol 3, </volume> <year> 1981. </year>
Reference-contexts: During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes <ref> [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] </ref> are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. <p> Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking <ref> [3, 8, 13] </ref> are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. Our intelligent backtracking schema whose some parts are presented in this paper is implemented as an extension of the WAM same as systems in [5, 10]. <p> Finally, we present some of our performance results in the last section. 2 Related Research Research on intelligent backtracking has started in late 70's. Early works are done by Bruynooghe and Pereira [3], and Cox and Pitrzykowski <ref> [8] </ref>. These first two systems are implemented by extending Prolog interpreters. These methods collect information about bindings during unification and analyze it to determine intelligent backtracking point when failure occurs. They also retain information from a failure to ensure that a failure is not repeated for the same reason.
Reference: [9] <author> Lin Y-J., Kumar V. and C. Leung, </author> <title> An Intelligent Backtracking Algorithm for Parallel Execution of Logic Programs, </title> <booktitle> Proc. of 3 rd Int. Conf. on Logic Programming, </booktitle> <address> London, </address> <year> 1986. </year>
Reference-contexts: Of course, our schema is implemented as a WAM-based system, theirs was a Prolog interpreter. These methods are known as intelligent backtracking methods based on unification failure analysis. Lin, Kumar and Leung's schema <ref> [9, 10, 11] </ref> chooses intelligent backtracking points by doing the analysis between literals instead of the analysis of unification failures. In their early work [9], they used data dependency at clause level for parallel execution of logic programs. <p> These methods are known as intelligent backtracking methods based on unification failure analysis. Lin, Kumar and Leung's schema [9, 10, 11] chooses intelligent backtracking points by doing the analysis between literals instead of the analysis of unification failures. In their early work <ref> [9] </ref>, they used data dependency at clause level for parallel execution of logic programs. A similar mechanism is used by Woo and Choe [18] for AND/OR parallel process model.
Reference: [10] <author> Lin Y-J. and Kumar V., </author> <title> An Intelligent Backtracking Schema for Prolog, </title> <booktitle> Proc. of 4 th Int. Symp. on Logic Programming, </booktitle> <address> San Francisco, </address> <year> 1987. </year>
Reference-contexts: During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes <ref> [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] </ref> are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. <p> Many intelligent backtracking schemes [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works <ref> [5, 6, 10, 11] </ref> are WAM based systems. Our intelligent backtracking schema whose some parts are presented in this paper is implemented as an extension of the WAM same as systems in [5, 10]. <p> Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. Our intelligent backtracking schema whose some parts are presented in this paper is implemented as an extension of the WAM same as systems in <ref> [5, 10] </ref>. Our mechanism is similar to mechanisms used in those systems except that how we keep unification information for variable bindings and how we find reasons of failures. <p> The mechanism we proposed is naturally integrated with the WAM architecture, and our performance results are better than performance results of systems in <ref> [3, 5, 10] </ref> and some of them are presented in Section 7. We concentrate on a new representation for variable bindings in the WAM, so that ages of variables can be easily found using this new representation. <p> Of course, our schema is implemented as a WAM-based system, theirs was a Prolog interpreter. These methods are known as intelligent backtracking methods based on unification failure analysis. Lin, Kumar and Leung's schema <ref> [9, 10, 11] </ref> chooses intelligent backtracking points by doing the analysis between literals instead of the analysis of unification failures. In their early work [9], they used data dependency at clause level for parallel execution of logic programs. <p> In their early work [9], they used data dependency at clause level for parallel execution of logic programs. A similar mechanism is used by Woo and Choe [18] for AND/OR parallel process model. Lin and Kumar <ref> [10, 11] </ref> extend their method for sequential execution of Prolog by using data dependency for the whole proof tree instead of data dependency at the clause level. Later they integrated their technique with the WAM.
Reference: [11] <author> Lin Y-J. and Kumar V., </author> <title> A Data-Dependency Based Intelligent Backtracking Schema for Prolog, </title> <journal> J. Logic Programming, </journal> <volume> Vol 4, </volume> <year> 1988. </year>
Reference-contexts: During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes <ref> [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] </ref> are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. <p> Many intelligent backtracking schemes [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works <ref> [5, 6, 10, 11] </ref> are WAM based systems. Our intelligent backtracking schema whose some parts are presented in this paper is implemented as an extension of the WAM same as systems in [5, 10]. <p> Of course, our schema is implemented as a WAM-based system, theirs was a Prolog interpreter. These methods are known as intelligent backtracking methods based on unification failure analysis. Lin, Kumar and Leung's schema <ref> [9, 10, 11] </ref> chooses intelligent backtracking points by doing the analysis between literals instead of the analysis of unification failures. In their early work [9], they used data dependency at clause level for parallel execution of logic programs. <p> In their early work [9], they used data dependency at clause level for parallel execution of logic programs. A similar mechanism is used by Woo and Choe [18] for AND/OR parallel process model. Lin and Kumar <ref> [10, 11] </ref> extend their method for sequential execution of Prolog by using data dependency for the whole proof tree instead of data dependency at the clause level. Later they integrated their technique with the WAM. <p> Most of intelligent backtracking methods in the literature associate some kinds of sets with literals to store intelligent backtracking points. These sets are called alternative backtrack points in [5, 6], 2 B-lists in <ref> [11] </ref>, rejected procedures in [3], witness sets in [17] and candidate sets in [7]. These intelligent backtracking schemes associate these sets with literal of the proof tree and use them to choose intelligent backtracking points. Somehow they have to update these sets during unification or failure. <p> If there are a lot of failures, gains by avoiding redundant backtrackings will be more than overheads due to more complex failure routine. We also test our implementation with certain benchmarks to compare our results with other intelligent backtracking methods presented in <ref> [3, 11, 6] </ref>. Table 1 gives speed ups and slow downs of the intelligent backtracking methods with respect to Prolog. For example, our figures in Table 1 give comparison of our intelligent backtracking scheme to the byte-emulator of ALS Prolog.
Reference: [12] <author> Matwin S. and Pietrzylowski T., </author> <title> Intelligent Backtracking in Plan Based Deduction, </title> <journal> IEEE PAMI, </journal> <volume> Vol 7, </volume> <year> 1985. </year>
Reference-contexts: During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes <ref> [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] </ref> are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems.
Reference: [13] <author> Pereiara L. M. and Porto A., </author> <title> Selective Backtracking, in Logic Programming, </title> <editor> ed. Clark K. L. and Tarnlund S.-A., </editor> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes <ref> [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] </ref> are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. <p> Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking <ref> [3, 8, 13] </ref> are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. Our intelligent backtracking schema whose some parts are presented in this paper is implemented as an extension of the WAM same as systems in [5, 10].
Reference: [14] <institution> Quintus Prolog Reference Manual, Quintus Computer Systems Ltd., </institution> <year> 1991. </year>
Reference-contexts: The WAM is recognized as a breakthrough in the design of Prolog systems and other computational logic systems by the logic programming community. Many commercial <ref> [2, 14] </ref> and non-commercial Prolog systems based on the WAM are implemented during last decade. During discussions in this paper, we will assume that the reader has a familiarity with the WAM.
Reference: [15] <author> Toh J. and Ramamohanrao K., </author> <title> Failure Directed Backtracking, </title> <type> Tech. Report 86/9, </type> <institution> CS Dept., Univ. of Melbourne, Australia, </institution> <year> 1986. </year>
Reference-contexts: During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes <ref> [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] </ref> are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. <p> They claim that the forward overhead of their schema which occurs during unifications is 10 15% compared with the WAM, and the backward overhead which occurs during failures is 5%. They accepts that the total overhead for deterministic programs is 20%. Toh and Ramamohanrao <ref> [15] </ref> propose an intelligent backtracking schema that does not require data-dependency analysis or information to be collected during unification. According to their method, the failed atom is itself used to figure out intelligent backtracking point. A failure-directed mechanism is less accurate than a unification-based schema.
Reference: [16] <author> Warren D.H.D., </author> <title> An Abstract Prolog Instruction Set, </title> <type> SRI Technical Report 309, </type> <year> 1983. </year>
Reference-contexts: Many commercial [2, 14] and non-commercial Prolog systems based on the WAM are implemented during last decade. During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper <ref> [16] </ref> and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters.
Reference: [17] <author> Winsborough W., </author> <title> Semantically Transparent Selective Reset for AND Parallel Interpreters Based on the Origin of Failures, </title> <booktitle> Proc. of 4 th Int. Symp. on Logic Programming, </booktitle> <address> San Francisco, </address> <year> 1987. </year>
Reference-contexts: Most of intelligent backtracking methods in the literature associate some kinds of sets with literals to store intelligent backtracking points. These sets are called alternative backtrack points in [5, 6], 2 B-lists in [11], rejected procedures in [3], witness sets in <ref> [17] </ref> and candidate sets in [7]. These intelligent backtracking schemes associate these sets with literal of the proof tree and use them to choose intelligent backtracking points. Somehow they have to update these sets during unification or failure.
Reference: [18] <author> Woo N. and Choe K., </author> <title> Selecting The Backtrack Literal in The AND/OR Process Model, </title> <booktitle> Proc. of 3 rd Int. Symp. on Logic Programming, </booktitle> <address> Salt Lake City, </address> <year> 1986. </year> <month> 11 </month>
Reference-contexts: During discussions in this paper, we will assume that the reader has a familiarity with the WAM. Details of the WAM can be found in Warren's original paper [16] and Kaci's tutorial book on the WAM [1]. Many intelligent backtracking schemes <ref> [3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 18] </ref> are presented to avoid unnecessary backtracking steps. Early works in intelligent backtracking [3, 8, 13] are implemented as Prolog interpreters. Implementations of later works [5, 6, 10, 11] are WAM based systems. <p> In their early work [9], they used data dependency at clause level for parallel execution of logic programs. A similar mechanism is used by Woo and Choe <ref> [18] </ref> for AND/OR parallel process model. Lin and Kumar [10, 11] extend their method for sequential execution of Prolog by using data dependency for the whole proof tree instead of data dependency at the clause level. Later they integrated their technique with the WAM.
References-found: 18

