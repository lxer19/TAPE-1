URL: http://www.cs.utexas.edu/users/vlr/papers/mincon.ps
Refering-URL: http://www.cs.utexas.edu/users/vlr/pub.html
Root-URL: 
Title: On Finding Minimal Two-Connected Subgraphs  
Author: Pierre Kelsen Vijaya Ramachandran 
Date: July 30, 1992  
Address: Austin, TX 78712  
Affiliation: Department of Computer Sciences University of Texas,  
Note: In JOURNAL OF ALGORITHMS, 1995. Copyright Academic Press  
Abstract: We present efficient parallel algorithms for the problems of finding a minimal 2-edge-connected spanning subgraph of a 2-edge-connected graph and finding a minimal biconnected spanning subgraph of a biconnected graph. The parallel algorithms run in polylog time using a linear number of PRAM processors. We also give linear time sequential algorithms for minimally augmenting a spanning tree into a 2-edge-connected or biconnected graph.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P.C.P. Bhatt, K. Diks, T. Hagerup, V.C. Prasad, T. Radzik, and S. Saxena. </author> <title> Improved deterministic parallel integer sorting. </title> <journal> Inform. and Comput., </journal> <volume> 94 </volume> <pages> 29-47, </pages> <year> 1991. </year>
Reference: [2] <author> R. Cole and U. Vishkin. </author> <title> Approximate and exact parallel scheduling with applications to list, tree, and graph problems. </title> <booktitle> In Proc. 27th Ann. IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 478-491, </pages> <year> 1986. </year> <month> 46 </month>
Reference: [3] <author> D. Fussell, V. Ramachandran, and R. Thurimella. </author> <title> Finding triconnected components by local replacements. </title> <booktitle> In Proc. ICALP 89, volume 372 of Lecture Notes in Computer Science, </booktitle> <pages> pages 379-393, </pages> <year> 1989. </year> <note> To appear in SIAM J. Comput. </note> . 
Reference-contexts: Hence, we identify the redundant edges in H by finding all separating pairs of edges in H. For this we modify the vertex triconnectivity algorithm in <ref> [3] </ref>, [18] (see also [19]). We now assign weight 0 to essential edges and weight 1 to redundant edges and choose for T H a minimum spanning tree in this graph. The implementation of step (1.2) will be discussed in the next section. <p> We analyze the work done in one such iteration. We identify redundant edges in H by finding separating pairs of edges in H. For this we modify the algorithm for finding triconnected components given in <ref> [3, 18] </ref> (see also [19]). Thus, we can compute separating pairs of edges A-optimally. The complexity of computing T H is the same as that of computing connected components on a graph with n nodes and at most 2n edges; we thus compute T H C-optimally.
Reference: [4] <author> H.N. Gabow, J.L. Bentley, and R.E. Tarjan. </author> <title> Scaling and related techniques for geometry problems. </title> <booktitle> In Proc. 16th Ann. ACM Symp. on Theory of Computing, </booktitle> <pages> pages 135-143, </pages> <year> 1984. </year>
Reference-contexts: In order to 21 answer maximum queries whose endpoints lie in the same segment of A, each processor constructs in time O (log n) a Cartesian tree for its segment (see <ref> [4] </ref>) and preprocesses the tree in O (log n) time so that lca queries can be answered in constant time (using the algorithm of [10]). As shown in [4] each maximum query whose endpoints lie in the same segment is answered by computing the lca of the endpoints in the Cartesian <p> lie in the same segment of A, each processor constructs in time O (log n) a Cartesian tree for its segment (see <ref> [4] </ref>) and preprocesses the tree in O (log n) time so that lca queries can be answered in constant time (using the algorithm of [10]). As shown in [4] each maximum query whose endpoints lie in the same segment is answered by computing the lca of the endpoints in the Cartesian tree for this segment; this takes constant time.
Reference: [5] <author> H.N. Gabow and R.E. Tarjan. </author> <title> A linear-time algorithm for a special case of disjoint set union. </title> <journal> J. Comput. System Sci., </journal> <volume> 30 </volume> <pages> 209-221, </pages> <year> 1985. </year>
Reference: [6] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability: a Guide to the Theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <address> San Francisco, CA, </address> <year> 1979. </year>
Reference: [7] <author> P. Gibbons, R.M. Karp, V. Ramachandran, D. Soroker, and R.E. Tarjan. </author> <title> Transitive compaction in parallel via branchings. </title> <journal> J. Algorithms, </journal> <volume> 12 </volume> <pages> 110-125, </pages> <year> 1991. </year>
Reference-contexts: A similar step is used in each iteration of an algorithm of <ref> [7] </ref> to compute a minimal strongly connected spanning subgraph of a strongly connected digraph (transitive compaction problem). We augment such a spanning tree with a minimal set of edges restoring the desired property (2-edge-connectivity or biconnectivity). We use tree contraction to construct such a minimal augmentation. <p> We augment such a spanning tree with a minimal set of edges restoring the desired property (2-edge-connectivity or biconnectivity). We use tree contraction to construct such a minimal augmentation. This part of our algorithm markedly differs from the corresponding step in the transitive compaction algorithm. As in <ref> [7] </ref> we show that O (log n) iterations of this procedure yield the desired spanning subgraph. We also give linear time algorithms for minimally augmenting a spanning tree into a 2-edge-connected or biconnected graph.
Reference: [8] <author> X. Han. </author> <title> An Algorithmic Approach to Extremal Graph Problems. </title> <type> PhD thesis, </type> <institution> Department of Computer Sciences, Princeton University, Princeton, NJ, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: Recently ([9]), linear time algorithms have been developed for these problems. These algorithms use the linear time augmentation procedures described in this section as subroutines. Similar linear time augmentation procedures (as well as linear time algorithms for finding minimal spanning subgraphs) have been found independently by <ref> [8] </ref>. 5.1 A Linear Time Algorithm for Computing a Minimal Augmentation for 2 Edge-Connectivity We shall first describe how to minimally augment a spanning tree with respect to 2-edge-connectivity.
Reference: [9] <author> X. Han, P. Kelsen, V. Ramachandran, and R.E. Tarjan. </author> <title> Computing minimal spanning subgraphs in linear time. </title> <booktitle> In Proc. of the Third ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 146-156, </pages> <year> 1992. </year>
Reference-contexts: Thus, the work done by our algorithms (time-processor product) is C (n; m) log n+A (n; 2n) log 3 n on an ARBITRARY PRAM. In <ref> [9] </ref> a linear time sequential algorithm for computing a minimal 2-edge-connected spanning subgraph is given. That algorithm can be parallelized. The parallel version uses our parallel minimal augmentation procedure as a subroutine. <p> In particular this approach gives similar algorithms for the problem of finding a minimal k-connected subgraph of a graph (for any k), assuming we have a method for augmenting a spanning tree with respect to these properties. In <ref> [9] </ref> we describe refinements for algorithm 1 that yield linear time sequential algorithms for the above problems. The algorithms for both problems use the linear time augmentation procedures described in section 5 as subroutines. These results reduce the parallel work required for these problems by a factor of fi (log n).
Reference: [10] <author> D. Harel and R.E. Tarjan. </author> <title> Fast algorithms for finding nearest common ancestors. </title> <journal> SIAM J. Comput., </journal> <volume> 13 </volume> <pages> 338-355, </pages> <year> 1984. </year>
Reference-contexts: maximum queries whose endpoints lie in the same segment of A, each processor constructs in time O (log n) a Cartesian tree for its segment (see [4]) and preprocesses the tree in O (log n) time so that lca queries can be answered in constant time (using the algorithm of <ref> [10] </ref>). As shown in [4] each maximum query whose endpoints lie in the same segment is answered by computing the lca of the endpoints in the Cartesian tree for this segment; this takes constant time. <p> In a preprocessing phase we number the vertices of T H in preorder from 1 to p. Henceforth, we shall identify a vertex with its preorder number. We compute the lca's of nontree edges in H in linear time using the algorithm of <ref> [10] </ref>. <p> In a preprocessing phase we compute for each vertex in T H the preorder number (henceforth identifying a vertex with its preorder number), we compute the lca's of nontree edges in H (using the algorithm of <ref> [10] </ref>), we sort the nontree edges by their lca, and compute for each lca u a sorted list L (u) of endpoints in T H of nontree edges with lca u (by traversing T H in preorder).
Reference: [11] <author> R.M. Karp and V. Ramachandran. </author> <title> Parallel algorithms for shared memory machines. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, Vol. A, </booktitle> <pages> pages 869-941. </pages> <publisher> MIT Press/Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: Thus, new techniques are required to obtain an efficient parallel solution for these problems. Several other well-known problems share this property, e.g., the problem of computing a maximal independent set in a graph and the problem of computing a depth-first search tree in a graph (see <ref> [11] </ref>). To illustrate this, consider the problem of finding a minimal 2-edge-connected spanning subgraph. Let the input graph G have n vertices and m edges. We assume that G is 2-edge-connected.
Reference: [12] <author> J.A. La Poutre. </author> <title> Dynamic Graph Algorithms and Data Structures. </title> <type> PhD thesis, </type> <institution> Department of Computer Sciences, University of Utrecht, </institution> <address> The Netherlands, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Hence, each vertex in T c represents the set of vertices of a 2-edge-connected component of T H + IN . We shall describe a method for maintaining T c that runs in time O (p + q). Our technique is similar to methods discovered independently by [23] and <ref> [12] </ref>. One result in [23] shows that the 2-edge-connected components of an initially connected graph 39 on n vertices can be maintained under m edge insertions in time O (mff (m; n) + n). This bound is improved to O (m + n) by [12]. Although the bound of [12] matches <p> methods discovered independently by [23] and <ref> [12] </ref>. One result in [23] shows that the 2-edge-connected components of an initially connected graph 39 on n vertices can be maintained under m edge insertions in time O (mff (m; n) + n). This bound is improved to O (m + n) by [12]. Although the bound of [12] matches our bound, we choose to present our method because it was discovered independently of [12]. Moreover, the presentation of our technique will be helpful in understanding the more complicated solution for the biconnected case. <p> and <ref> [12] </ref>. One result in [23] shows that the 2-edge-connected components of an initially connected graph 39 on n vertices can be maintained under m edge insertions in time O (mff (m; n) + n). This bound is improved to O (m + n) by [12]. Although the bound of [12] matches our bound, we choose to present our method because it was discovered independently of [12]. Moreover, the presentation of our technique will be helpful in understanding the more complicated solution for the biconnected case. <p> This bound is improved to O (m + n) by <ref> [12] </ref>. Although the bound of [12] matches our bound, we choose to present our method because it was discovered independently of [12]. Moreover, the presentation of our technique will be helpful in understanding the more complicated solution for the biconnected case. The tree T c is represented by a partition of the nodes of T H into disjoint nonempty sets. <p> We first describe how to maintain the block condensation T c of T H + IN at each step. Some methods are known (e.g., [23] and <ref> [12] </ref>) for maintaining the biconnected components of a graph under edge insertions. These methods however are superlinear in the number of edge insertions. We shall explain how T c can be maintained in linear time.
Reference: [13] <author> Y. Maon, B. Schieber, and U. Vishkin. </author> <title> Parallel ear decomposition search (eds) and st-numbering in graphs. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 47 </volume> <pages> 277-298, </pages> <year> 1986. </year>
Reference-contexts: The total time is dominated by m calls to the algorithm for testing 2-edge-connectivity ([21], [14], <ref> [13] </ref>, [18]), giving a time bound of O (m (n + m)). The time can be brought down to O (m + n 2 ) by first finding a sparse 2-edge-connected spanning subgraph of G (see section 3). <p> Let H = T H + B. The purpose of step (0) is to speed up subsequent iterations of the while-loop by computing a sparse subgraph of the input graph. In this step we compute an ear decomposition of G ([14], <ref> [13] </ref>, [18]) and eliminate all trivial ears. Let H be the resulting graph. H is clearly a 2-edge-connected spanning subgraph of G. Let m 0 denote the number of edges of H and let q be the number of (nontrivial) ears in the above ear decomposition. <p> This amounts to computing the 2-edge-connected components of T H + IN + R, which can be done using an ear decomposition algorithm ([14], <ref> [13] </ref>, [18]) that is A-optimal. For step (1) assume that each vertex in V l is assigned a unique number in the range 1 : : :n.
Reference: [14] <author> G.L. Miller and V. Ramachandran. </author> <title> Efficient parallel ear decomposition with applications. </title> <type> Manuscript, </type> <month> January </month> <year> 1986. </year>
Reference-contexts: The total time is dominated by m calls to the algorithm for testing 2-edge-connectivity ([21], <ref> [14] </ref>, [13], [18]), giving a time bound of O (m (n + m)). The time can be brought down to O (m + n 2 ) by first finding a sparse 2-edge-connected spanning subgraph of G (see section 3).
Reference: [15] <author> G.L. Miller and J.H. Reif. </author> <title> Parallel tree contraction and its applications. </title> <booktitle> In Proc. 26th Ann. IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 478-489, </pages> <year> 1985. </year> <month> 47 </month>
Reference: [16] <author> V. Ramachandran. </author> <title> Fast and processor-efficient parallel algorithms for reducible flow graphs. </title> <type> Technical Report ACT-103, </type> <institution> Coordinated Science Laboratory, University of Illinois, Urbana, IL, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: We shall make use of parallel tree contraction to compute such a minimal augmentation. Tree contraction was first introduced by Miller and Reif ([15]). We use a variant of tree contraction proposed in <ref> [17, 16] </ref>. This method is based on the operation Shrink which we shall now describe. Let T be an arbitrary rooted tree. <p> In the second stage we proceed to cover stem edges in T 0 that have not been covered in stage 1. The algorithm we use here is similar to an algorithm in <ref> [17, 16] </ref> for finding a minimum feedback-vertex-set in a reducible flow graph. To compute a minimal subset A 2 C covering the stem edges of T 0 not covered by edges of A 1 , we appeal again to lemma 3.
Reference: [17] <author> V. Ramachandran. </author> <title> Fast parallel algorithms for reducible flow graphs. </title> <editor> In S. Tewksbury, B. Dick-inson, and S. Schwartz, editors, </editor> <booktitle> Concurrent Computations: Algorithms, Architecture and Technology, </booktitle> <pages> pages 117-138. </pages> <publisher> Plenum Press, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: We shall make use of parallel tree contraction to compute such a minimal augmentation. Tree contraction was first introduced by Miller and Reif ([15]). We use a variant of tree contraction proposed in <ref> [17, 16] </ref>. This method is based on the operation Shrink which we shall now describe. Let T be an arbitrary rooted tree. <p> In the second stage we proceed to cover stem edges in T 0 that have not been covered in stage 1. The algorithm we use here is similar to an algorithm in <ref> [17, 16] </ref> for finding a minimum feedback-vertex-set in a reducible flow graph. To compute a minimal subset A 2 C covering the stem edges of T 0 not covered by edges of A 1 , we appeal again to lemma 3.
Reference: [18] <author> V. Ramachandran. </author> <title> Parallel open ear decomposition with applications to graph biconnectivity and triconnectivity. </title> <editor> In J. Reif, editor, </editor> <title> Synthesis of Parallel Algorithms. </title> <publisher> Morgan-Kaufmann, </publisher> <address> New York, NY, </address> <year> 1992. </year> <note> To appear. </note>
Reference-contexts: The total time is dominated by m calls to the algorithm for testing 2-edge-connectivity ([21], [14], [13], <ref> [18] </ref>), giving a time bound of O (m (n + m)). The time can be brought down to O (m + n 2 ) by first finding a sparse 2-edge-connected spanning subgraph of G (see section 3). <p> Let H = T H + B. The purpose of step (0) is to speed up subsequent iterations of the while-loop by computing a sparse subgraph of the input graph. In this step we compute an ear decomposition of G ([14], [13], <ref> [18] </ref>) and eliminate all trivial ears. Let H be the resulting graph. H is clearly a 2-edge-connected spanning subgraph of G. Let m 0 denote the number of edges of H and let q be the number of (nontrivial) ears in the above ear decomposition. <p> Hence, we identify the redundant edges in H by finding all separating pairs of edges in H. For this we modify the vertex triconnectivity algorithm in [3], <ref> [18] </ref> (see also [19]). We now assign weight 0 to essential edges and weight 1 to redundant edges and choose for T H a minimum spanning tree in this graph. The implementation of step (1.2) will be discussed in the next section. <p> We analyze the work done in one such iteration. We identify redundant edges in H by finding separating pairs of edges in H. For this we modify the algorithm for finding triconnected components given in <ref> [3, 18] </ref> (see also [19]). Thus, we can compute separating pairs of edges A-optimally. The complexity of computing T H is the same as that of computing connected components on a graph with n nodes and at most 2n edges; we thus compute T H C-optimally. <p> This amounts to computing the 2-edge-connected components of T H + IN + R, which can be done using an ear decomposition algorithm ([14], [13], <ref> [18] </ref>) that is A-optimal. For step (1) assume that each vertex in V l is assigned a unique number in the range 1 : : :n. <p> We use the high-level strategy given by algorithm 1 (replace "2-edge-connected" by "biconnected"). We compute a biconnected spanning subgraph H of G with fewer than 2n edges by finding an open ear decomposition for G ([3], <ref> [18] </ref>) and removing all trivial ears. <p> An efficient parallel algorithm for finding all separating pairs in H 0 ([3], <ref> [18] </ref>) can thus be modified to identify all redundant edges efficiently. 23 As for 2-edge-connectivity we remark that an alternative (sequential) method of Han and Tarjan ([8]) for computing a minimal biconnected spanning subgraph can be parallelized; the parallel implementation is similar to our method but it avoids the explicit computation <p> Both for 2-edge-connectivity and biconnectivity 37 steps (0), (1) and (1.1) of algorithm 1 can be implemented to execute in linear time by making use of linear time procedures for finding an ear decomposition and for vertex triconnectivity given in <ref> [18] </ref> (see section 3.3). Thus, if we adhere to the high-level structure of algorithm 1, we obtain algorithms for computing a minimal 2-edge-connected or biconnected spanning subgraph that run in time O (m + n log n). Recently ([9]), linear time algorithms have been developed for these problems.
Reference: [19] <author> V. Ramachandran. </author> <title> Class notes. </title> <institution> Dept. of Computer Sciences, Univ. of Texas at Austin, </institution> <month> Spring </month> <year> 1990. </year>
Reference-contexts: Hence, we identify the redundant edges in H by finding all separating pairs of edges in H. For this we modify the vertex triconnectivity algorithm in [3], [18] (see also <ref> [19] </ref>). We now assign weight 0 to essential edges and weight 1 to redundant edges and choose for T H a minimum spanning tree in this graph. The implementation of step (1.2) will be discussed in the next section. <p> We analyze the work done in one such iteration. We identify redundant edges in H by finding separating pairs of edges in H. For this we modify the algorithm for finding triconnected components given in [3, 18] (see also <ref> [19] </ref>). Thus, we can compute separating pairs of edges A-optimally. The complexity of computing T H is the same as that of computing connected components on a graph with n nodes and at most 2n edges; we thus compute T H C-optimally.
Reference: [20] <author> B. Schieber and U. Vishkin. </author> <title> On finding lowest common ancestors: Simplification and par-allelization. </title> <booktitle> In Proc. 3rd Aegean Workshop on Computing, volume 319 of Lecture Notes in Computer Science, </booktitle> <pages> pages 111-123. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: We prepare algorithm 2 by computing the lca's of nontree edges in H and identifying the vertices in T H that are lca's of nontree edges; this can be done optimally in time O (log n) using the algorithm of <ref> [20] </ref>. Next we construct the tree T lca . We shall not compute an explicit representation of the tree (in terms of adjacency lists) but rather compute enough information to identify the leaf chains quickly.
Reference: [21] <author> R.E. Tarjan. </author> <title> Depth first search and linear graph algorithms. </title> <journal> SIAM J. Comput., </journal> <volume> 1 </volume> <pages> 146-160, </pages> <year> 1972. </year>
Reference: [22] <author> R.E. Tarjan and U. Vishkin. </author> <title> An efficient parallel biconnectivity algorithm. </title> <journal> SIAM J. Comput., </journal> <volume> 14 </volume> <pages> 862-874, </pages> <year> 1984. </year>
Reference: [23] <author> J. Westbrook and R.E. Tarjan. </author> <title> Maintaining bridge-connected and biconnected components on-line. </title> <journal> Algorithmica, </journal> <volume> 7 </volume> <pages> 433-464, </pages> <year> 1992. </year> <month> 48 </month>
Reference-contexts: Hence, each vertex in T c represents the set of vertices of a 2-edge-connected component of T H + IN . We shall describe a method for maintaining T c that runs in time O (p + q). Our technique is similar to methods discovered independently by <ref> [23] </ref> and [12]. One result in [23] shows that the 2-edge-connected components of an initially connected graph 39 on n vertices can be maintained under m edge insertions in time O (mff (m; n) + n). This bound is improved to O (m + n) by [12]. <p> We shall describe a method for maintaining T c that runs in time O (p + q). Our technique is similar to methods discovered independently by <ref> [23] </ref> and [12]. One result in [23] shows that the 2-edge-connected components of an initially connected graph 39 on n vertices can be maintained under m edge insertions in time O (mff (m; n) + n). This bound is improved to O (m + n) by [12]. <p> We first describe how to maintain the block condensation T c of T H + IN at each step. Some methods are known (e.g., <ref> [23] </ref> and [12]) for maintaining the biconnected components of a graph under edge insertions. These methods however are superlinear in the number of edge insertions. We shall explain how T c can be maintained in linear time.
References-found: 23

