URL: http://www.cs.utexas.edu/users/kedar/papers/ring.ps
Refering-URL: http://www.cs.utexas.edu/users/kedar/papers/ring.html
Root-URL: 
Title: Reasoning about Rings  
Author: E. Allen Emerson Kedar S. Namjoshi 
Address: Austin, U.S.A.  
Affiliation: Department of Computer Sciences The University of Texas at  
Abstract: The ring is a useful means of structuring concurrent processes. Processes communicate by passing a token in a fixed direction; the process that possesses the token is allowed to make certain moves. Usually, correctness properties are expected to hold irrespective of the size of the ring. We show that the problem of checking many useful correctness properties for rings of all sizes can be reduced to checking them on a ring of small size. The results do not depend on the processes being finite state. We illustrate our results on examples.
Abstract-found: 1
Intro-found: 1
Reference: [AK 86] <author> Apt, K., Kozen, D. </author> <title> Limits for automatic verification of finite-state concurrent systems. </title> <journal> IPL 15, </journal> <pages> pp. 307-309. </pages>
Reference-contexts: ^ AG (stopped a i ) :started a i U started b i ) ^ AG (started b i ) :started a i U stopped b i ) ^ AG (stopped b i ) :started b i U started a i ) 5 Conclusions and related work Among related work, <ref> [AK 86, Su 88] </ref> show that the problem of automatically checking a specification for every instance of a parameterized system is in general undecidable. Positive results include those of Clarke, Grumberg and Browne [CG 87], [Br 89], [BCG 89] who introduce the idea of projections on the global state space.
Reference: [BCG 88] <author> Browne, M. C., Clarke, E. M., Grumberg, O. </author> <title> Characterizing Finite Kripke Structures in Propositional Temporal Logic, </title> <journal> Theor. Comp. Sci., </journal> <volume> vol. 59, </volume> <pages> pp. 115-131, </pages> <year> 1988. </year>
Reference-contexts: The correctness properties that we consider are expressed by formulae in the branching time logic CT L fl without the next-time operator X <ref> [BCG 88] </ref>. <p> H = init n If we show that H is bisimilar (up to stuttering of processes in I) to some other projected graph H 0 (formed by projecting onto I), then the two graphs will satisfy the same CT L fl formulae which do not include the next-time operator X <ref> [BCG 88] </ref>. 2.2 Stuttering equivalence In the projected graph H = M j fIg , since we erase information about actions of processes not in I, the label on a state in H may not change during a finite sequence of t actions. <p> Then stuttering equivalence is the greatest stuttering bisimulation. 3 This definition is similar to one presented in <ref> [BCG 88] </ref>. A related definition appears in [DV 90]. 4 3 Equivalences between large and small systems 3.1 Properties of the form V We will need this refinement of a lemma in [ES 93].
Reference: [BCG 89] <author> Browne, M. C., Clarke, E. M., Grumberg, O. </author> <title> Reasoning about Networks with Many Identical Finite State Processes, </title> <journal> Information and Computation, </journal> <volume> vol. 81, no. 1, </volume> <pages> pp. 13-31, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Positive results include those of Clarke, Grumberg and Browne [CG 87], [Br 89], <ref> [BCG 89] </ref> who introduce the idea of projections on the global state space. Their method requires the manual construction of bisimulations and a closure process which represents computations of an arbitrary number of processes. [KM 89] and [WL 89] introduce the related notion of a process invariant.
Reference: [Br 89] <author> Browne, M. </author> <title> Automatic Verification of Finite State Machines using Temporal Logic. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon Univ., CMU-CS-89-117. </institution>
Reference-contexts: Positive results include those of Clarke, Grumberg and Browne [CG 87], <ref> [Br 89] </ref>, [BCG 89] who introduce the idea of projections on the global state space. Their method requires the manual construction of bisimulations and a closure process which represents computations of an arbitrary number of processes. [KM 89] and [WL 89] introduce the related notion of a process invariant.
Reference: [C 93] <author> Cleaveland, R. </author> <title> Analyzing Concurrent Systems using the Concurrency Workbench. Functional Programming, Concurrency, Simulation, </title> <note> and Automated Reasoning , Springer-Verlag LNCS 693. </note>
Reference-contexts: The ring of size equal to the cutoff is analogous to a closure process, but is trivial to construct. In addition, the result holds even if the transition graph of the template process is not finite. If it is finite, then an automated tool such as the Concurrency Workbench <ref> [CPS 89, C 93, CH 93] </ref> can be used to model check the desired property for the small ring [CE 81]. This check can be done in time polynomial in the size of a process.
Reference: [CE 81] <author> Clarke, E. M., Emerson, E. A. </author> <title> Design and Synthesis of Synchronization Skeletons using Branching Time Temporal Logic. </title> <booktitle> in Workshop on Logics of Programs, </booktitle> <publisher> Springer-Verlag LNCS 131. </publisher>
Reference-contexts: In addition, the result holds even if the transition graph of the template process is not finite. If it is finite, then an automated tool such as the Concurrency Workbench [CPS 89, C 93, CH 93] can be used to model check the desired property for the small ring <ref> [CE 81] </ref>. This check can be done in time polynomial in the size of a process. We are currently investigating the extension of these results to tokens which carry values, and to systems with tokens and signals [D 85].
Reference: [CES 86] <author> Clarke, E. M., Emerson, E. A., and Sistla, A. P., </author> <title> Automatic Verification of Finite-State Concurrent Systems using Temporal Logic, </title> <journal> ACM Trans. Prog. Lang. and Sys., </journal> <volume> vol. 8, no. 2, </volume> <pages> pp. 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference: [CFJ 93] <author> Clarke, E. M., Filkorn, T., Jha, S. </author> <title> Exploiting Symmetry in Temporal Logic Model Checking, </title> <booktitle> 5th CAV, </booktitle> <publisher> Springer-Verlag LNCS 697. </publisher>
Reference: [CG 87] <author> Clarke, E. M., Grumberg, O. </author> <title> Avoiding the State Explosion Problem in Temporal Logic Model Checking Algorithms, </title> <booktitle> PODC 1987. </booktitle> <pages> 12 </pages>
Reference-contexts: Positive results include those of Clarke, Grumberg and Browne <ref> [CG 87] </ref>, [Br 89], [BCG 89] who introduce the idea of projections on the global state space.
Reference: [CH 93] <author> Cleaveland, R., Hennessy, M. </author> <title> Testing Equivalence as a Bisimulation Equivalence. </title> <journal> Formal Aspects of Computing, </journal> <volume> vol. 5, </volume> <year> 1993. </year>
Reference-contexts: The ring of size equal to the cutoff is analogous to a closure process, but is trivial to construct. In addition, the result holds even if the transition graph of the template process is not finite. If it is finite, then an automated tool such as the Concurrency Workbench <ref> [CPS 89, C 93, CH 93] </ref> can be used to model check the desired property for the small ring [CE 81]. This check can be done in time polynomial in the size of a process.
Reference: [CPS 89] <author> Cleaveland, R., Parrow, J., Steffen, B. </author> <title> The Concurrency Workbench. </title> <editor> In J.Sifakis (ed), </editor> <title> Automatic Verification Methods for Finite State Systems, </title> <publisher> Springer-Verlag, LNCS 407. </publisher>
Reference-contexts: The ring of size equal to the cutoff is analogous to a closure process, but is trivial to construct. In addition, the result holds even if the transition graph of the template process is not finite. If it is finite, then an automated tool such as the Concurrency Workbench <ref> [CPS 89, C 93, CH 93] </ref> can be used to model check the desired property for the small ring [CE 81]. This check can be done in time polynomial in the size of a process.
Reference: [D 85] <author> Dijkstra, E. W. </author> <title> Invariance and non-determinacy. </title> <booktitle> in Mathematical Logic and Programming Languages, Prentice-Hall International Series in Computer Science. eds. C.A.R Hoare and J.C Shep-herdson. </booktitle>
Reference-contexts: This check can be done in time polynomial in the size of a process. We are currently investigating the extension of these results to tokens which carry values, and to systems with tokens and signals <ref> [D 85] </ref>. The techniques used here are also likely to be applicable to logical star networks which model client-server interactions. The main requirement seems to be that of homogeneity a process' view is the same wherever it is in the network.
Reference: [DV 90] <author> De Nicola, R., Vaandrager, F. </author> <title> Three logics for Branching Bisimulation, </title> <booktitle> 5th Annual IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pp. 118-129, </pages> <year> 1990. </year>
Reference-contexts: Then stuttering equivalence is the greatest stuttering bisimulation. 3 This definition is similar to one presented in [BCG 88]. A related definition appears in <ref> [DV 90] </ref>. 4 3 Equivalences between large and small systems 3.1 Properties of the form V We will need this refinement of a lemma in [ES 93].
Reference: [Em 90] <author> Emerson, E. A., </author> <title> Temporal and Modal Logic, </title> <booktitle> in Handbook of Theoretical Computer Science, </booktitle> <editor> (J. van Leeuwen, ed.), Elsevier/North-Holland, </editor> <year> 1991. </year>
Reference-contexts: We write M; s j= f to mean that in LTG M , formula f holds at state s, as defined formally in the usual way <ref> [Em 90] </ref>. For an LTG M where the states are indexed by [n], Aut M is the group of permutations in Sym [n] that when applied to every state and transition of M , map M to itself.
Reference: [ES 93] <author> Emerson, E. A., Sistla, A. P. </author> <title> Symmetry and Model Checking, </title> <booktitle> 5th CAV, </booktitle> <publisher> Springer-Verlag LNCS 697. </publisher>
Reference-contexts: Then stuttering equivalence is the greatest stuttering bisimulation. 3 This definition is similar to one presented in [BCG 88]. A related definition appears in [DV 90]. 4 3 Equivalences between large and small systems 3.1 Properties of the form V We will need this refinement of a lemma in <ref> [ES 93] </ref>.
Reference: [GS 92] <author> German, S. M., Sistla, A. P. </author> <title> Reasoning about Systems with Many Processes. </title> <journal> J.ACM, </journal> <volume> Vol. 39, Number 3, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: All these methods rely on human ingenuity to manually construct a suitable process closure or invariant. <ref> [GS 92] </ref> use automata-theoretic methods to construct process closures (provided that the component processes of a system are exactly identical and finite-state), and use them to establish single index properties. Multi-index properties can be indirectly catered for, but the complexity then becomes multi-exponential.
Reference: [KM 89] <author> Kurshan, R. P., McMillan, K. </author> <title> A Structural Induction Theorem for Processes, </title> <month> PODC </month> <year> 1989. </year>
Reference-contexts: Positive results include those of Clarke, Grumberg and Browne [CG 87], [Br 89], [BCG 89] who introduce the idea of projections on the global state space. Their method requires the manual construction of bisimulations and a closure process which represents computations of an arbitrary number of processes. <ref> [KM 89] </ref> and [WL 89] introduce the related notion of a process invariant.
Reference: [LSY 94] <author> Li, J., Suzuki, I., Yamashita, M. </author> <title> A New Structural Induction Theorem for Rings of Temporal Petri Nets. </title> <journal> IEEE Trans. Soft. Engg., </journal> <volume> vol. 20, No. 2, </volume> <month> February </month> <year> 1994. </year>
Reference-contexts: Multi-index properties can be indirectly catered for, but the complexity then becomes multi-exponential. The closest results are those of Shtadler and Grumberg [ShG 89], who use a network grammar to specify a communication topology, and those of <ref> [LSY 94, LSY 92] </ref> which deal with ring networks of Petri nets. [ShG 89] show that if certain sufficient conditions are satisfied, every network generated by the grammar will satisfy specifications written in linear-time temporal logic. <p> However, the sufficiency check can require time exponential in the size of an individual process. The papers <ref> [LSY 94, LSY 92] </ref> contain another (exponential-time) sufficiency test which is used to show that certain parameterized protocols on rings satisfy a single-index linear-time specification.
Reference: [LSY 92] <author> Li, J., Suzuki, I., Yamashita, M. </author> <title> Temporal Petri Nets and structural induction for rings of processes. </title> <booktitle> Proceedings 35th Midwest Symp. Circuits Syst. </booktitle> <year> 1992. </year> <pages> pp. 377-380. </pages> <note> (final version to appear in Theoretical Computer Science) </note>
Reference-contexts: Multi-index properties can be indirectly catered for, but the complexity then becomes multi-exponential. The closest results are those of Shtadler and Grumberg [ShG 89], who use a network grammar to specify a communication topology, and those of <ref> [LSY 94, LSY 92] </ref> which deal with ring networks of Petri nets. [ShG 89] show that if certain sufficient conditions are satisfied, every network generated by the grammar will satisfy specifications written in linear-time temporal logic. <p> However, the sufficiency check can require time exponential in the size of an individual process. The papers <ref> [LSY 94, LSY 92] </ref> contain another (exponential-time) sufficiency test which is used to show that certain parameterized protocols on rings satisfy a single-index linear-time specification.
Reference: [Mil 90] <author> Milner, R. </author> <title> Communication and Concurrency, </title> <booktitle> Prentice-Hall International Series in Computer Science. </booktitle> <editor> ed. </editor> <title> C.A.R Hoare. </title>
Reference-contexts: Details are left to the full paper. 2 4 Applications To illustrate the use of our results, we look at two protocols, the distributed mutual exclusion protocol in [WL 89] and (a slight variation on) Milner's scheduler example <ref> [Mil 90] </ref>. Both are specified by CCS expressions. 4.1 Distributed Mutual Exclusion The protocol in [WL 89] is given below as a set of process equations. S0 = rcv:S1; S1 = *:S2 + *:S4; S2 = scs:S3; Initially, every process is in state S0.
Reference: [ShG 89] <author> Shtadler, Z., Grumberg, O. </author> <title> Network Grammars, Communication Behaviours and Automatic Verification. </title> <editor> In J.Sifakis (ed), </editor> <title> Automatic Verification Methods for Finite State Systems, </title> <publisher> Springer-Verlag, LNCS 407. </publisher>
Reference-contexts: Multi-index properties can be indirectly catered for, but the complexity then becomes multi-exponential. The closest results are those of Shtadler and Grumberg <ref> [ShG 89] </ref>, who use a network grammar to specify a communication topology, and those of [LSY 94, LSY 92] which deal with ring networks of Petri nets. [ShG 89] show that if certain sufficient conditions are satisfied, every network generated by the grammar will satisfy specifications written in linear-time temporal logic. <p> Multi-index properties can be indirectly catered for, but the complexity then becomes multi-exponential. The closest results are those of Shtadler and Grumberg <ref> [ShG 89] </ref>, who use a network grammar to specify a communication topology, and those of [LSY 94, LSY 92] which deal with ring networks of Petri nets. [ShG 89] show that if certain sufficient conditions are satisfied, every network generated by the grammar will satisfy specifications written in linear-time temporal logic. However, the sufficiency check can require time exponential in the size of an individual process.
Reference: [Su 88] <author> Suzuki, I. </author> <title> Proving properties of a ring of finite state machines. </title> <journal> IPL 28, </journal> <pages> pp. 213-214. </pages>
Reference-contexts: ^ AG (stopped a i ) :started a i U started b i ) ^ AG (started b i ) :started a i U stopped b i ) ^ AG (stopped b i ) :started b i U started a i ) 5 Conclusions and related work Among related work, <ref> [AK 86, Su 88] </ref> show that the problem of automatically checking a specification for every instance of a parameterized system is in general undecidable. Positive results include those of Clarke, Grumberg and Browne [CG 87], [Br 89], [BCG 89] who introduce the idea of projections on the global state space.
Reference: [WL 89] <author> Wolper, P., Lovinfosse, V. </author> <title> Verifying Properties of Large Sets of Processes with Network Invariants. </title> <editor> In J.Sifakis (ed), </editor> <title> Automatic Verification Methods for Finite State Systems, </title> <publisher> Springer-Verlag, LNCS 407. </publisher> <pages> 13 </pages>
Reference-contexts: Details are left to the full paper. 2 4 Applications To illustrate the use of our results, we look at two protocols, the distributed mutual exclusion protocol in <ref> [WL 89] </ref> and (a slight variation on) Milner's scheduler example [Mil 90]. Both are specified by CCS expressions. 4.1 Distributed Mutual Exclusion The protocol in [WL 89] is given below as a set of process equations. <p> to the full paper. 2 4 Applications To illustrate the use of our results, we look at two protocols, the distributed mutual exclusion protocol in <ref> [WL 89] </ref> and (a slight variation on) Milner's scheduler example [Mil 90]. Both are specified by CCS expressions. 4.1 Distributed Mutual Exclusion The protocol in [WL 89] is given below as a set of process equations. S0 = rcv:S1; S1 = *:S2 + *:S4; S2 = scs:S3; Initially, every process is in state S0. Here * is used to indicate a local action. It is easily checked that the process description satisfies the restrictions. <p> Their method requires the manual construction of bisimulations and a closure process which represents computations of an arbitrary number of processes. [KM 89] and <ref> [WL 89] </ref> introduce the related notion of a process invariant.
References-found: 23

