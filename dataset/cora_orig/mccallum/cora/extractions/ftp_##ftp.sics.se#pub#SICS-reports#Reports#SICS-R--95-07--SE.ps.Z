URL: ftp://ftp.sics.se/pub/SICS-reports/Reports/SICS-R--95-07--SE.ps.Z
Refering-URL: http://www.sics.se/libindex.html
Root-URL: 
Note: Bjorn Lisper  
Web: ISRN SICS-R-95/07-SE  
Abstract: SICS research report R95:07 ISSN 0283-3638 Computing in Unpredictable Environments: Semantics, Reduction Strategies, and Program Transformations 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Levy. </author> <title> Explicit substitutions. </title> <booktitle> In Proc. Seventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 31-46, </pages> <address> San Francisco, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Second, laziness also implies sharing of already computed results. This is not expressible in the simple term rewriting systems considered here, and must be modeled in a formalism such as explicit substitutions <ref> [1] </ref>. Furthermore, it seems that sharing must not be hidden in languages with nondeterminism, since reuse of a nondeterministic result is not the same as computing it anew. Third, lazy languages reduce to weak head normal form rather than normal form.
Reference: [2] <author> S. Abramsky. </author> <title> The lazy lambda calculus. </title> <editor> In D. A. Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, The UT Year of Programming Series, chapter 4, </booktitle> <pages> pages 65-116. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: Third, lazy languages reduce to weak head normal form rather than normal form. The semantic tree c.p.o. must then be modified accordingly, since the pure Bohm tree model is not appropriate for the lazy -calculus <ref> [2] </ref>. The correctness of fold/unfold-transformations was proved for TRS'es rather than CRS'es, but we believe the results carry over more or less verbatim. Furthermore, the correctness of folding was proved under the simplifying condition that a rule would not be used to fold itself.
Reference: [3] <author> J. Armstrong, R. Virding, and M. Williams. </author> <title> Concurrent Programming in ER-LANG. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Our framework is abstract and thus applicable to a range of languages, but the ones we have mainly in mind are recursive languages with concurrency constructs. Some existing, not referentially transparent languages in this class are Concurrent ML [22], Facile [25], and Erlang <ref> [3] </ref>. A goal of our work is to support the design of recursive languages with concurrency, where the "serial part" is referentially transparent also in the precence of nondeterminism arising from the concurrency. Our results about folding and unfolding extend classical results [8, 10, 18] for deterministic systems.
Reference: [4] <author> A. Arnold, P. Naudin, and M. Nivat. </author> <title> On semantics of nondeterministic recursive program schemes. </title> <editor> In M. Nivat and J. C. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, chapter 1, </booktitle> <pages> pages 1-33. </pages> <publisher> Cambridge University Press, </publisher> <year> 1985. </year>
Reference-contexts: The semantics we use is related to the one developed by Arnold, Naudin and Nivat for nondeterministic recursive schemes <ref> [4] </ref> and in particular to the one of Boudol [6] for first order term rewriting systems. <p> Formally, a term t can be defined as a partial function from the set of sequences of natural numbers ("positions") to operator symbols, such that dom (t) is prefix-closed and respects arities; see, e.g. <ref> [4, 11] </ref>. For p =2 dom (t), we define t (p) = ?. We can relax the conditions that arities are respected and allow also terms which are undefined at leaf positions, and we denote the set of these terms by T 1 ? .
Reference: [5] <author> H. P. Barendregt. </author> <title> The Lambda Calculus Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1981. </year> <month> 11 </month>
Reference-contexts: We have T T 1 T 1 ? . If T is the set of -terms, then T 1 ? are the Bohm trees <ref> [5, Ch. 10] </ref>. For the operator symbols, we define a flat partial order v by ? v s and s v s for all symbols s. <p> If T (F; X) is the set of pure -terms and if ! fi is the reduction relation given by fi-reduction to head normal form, then the single element of S (t; f ! fi ; ! fi ) is essentially the Bohm tree for t <ref> [5] </ref>.
Reference: [6] <author> G. Boudol. </author> <title> Computational semantics of term rewriting systems. </title> <editor> In M. Nivat and J. C. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, chapter 5, </booktitle> <pages> pages 170-236. </pages> <publisher> Cambridge University Press, </publisher> <year> 1985. </year>
Reference-contexts: The system itself is described by the union of these reduction systems. A semantics is defined as the set of limits, under some monotone interpretation to a c.p.o., for the various (possibly infinite) reduction paths, in the vein of Boudol <ref> [6] </ref>. This can be thought of as a "normal form semantics", but extended to deal with infinite and divergent (but "fair") computations. In particular, we consider reduction systems over terms, with interpretation to c.p.o.'s of trees over the same signature. Within this framework, we prove the following: 1. <p> The semantics we use is related to the one developed by Arnold, Naudin and Nivat for nondeterministic recursive schemes [4] and in particular to the one of Boudol <ref> [6] </ref> for first order term rewriting systems. See also the interesting discussion of referential transparency and unfoldability in [24]; one can say that our commutation condition on the computational and descriptive reduction systems preserves referential transparency for the computational system also in the presence of a non-deterministic environment. <p> Proposition 3 The a-rooted ~a is (strictly) majorated by some ~ a 0 iff is (strictly) majorated by some a-rooted ~ a 00 . We can now define the semantics for an element a 2 A, given a monotone interpretation f of hA; !i into hC; vi (cf. <ref> [6, Ch. 4.2] </ref>): Definition 3 The semantics of a 2 A w.r.t. f and !, S (a; f; !), is the set f f (~a) j ~a is a-rooted and not strictly majorated by any computation g. Definition 3 yields a semantics that takes only "fair" computations into account. <p> If ! is given by a first order term rewriting system, then S (t; f ! ; !) coincides with the semantics for such systems by Boudol <ref> [6, Ch. 4.2] </ref>. a 9a 000 fl ||y y y y y y y fl N C C C C C C !! fl ||z z z z z z 6 Modeling Systems with Computational and De scriptive Components In the setting of abstract reduction systems, we can model computational and
Reference: [7] <author> R. M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <month> Jan. </month> <year> 1977. </year>
Reference-contexts: Our results about folding and unfolding extend classical results [8, 10, 18] for deterministic systems. They are applicable to program transformation systems for program optimization <ref> [7, 13] </ref>, and partial evaluation of nondeterministic languages. Semantics-preserving partial evaluation of such languages is listed as the "challenging problem no. 10.9" in [14]. The only partial evaluator for such languages that we are aware of is for the concurrent constraint programming language AKL [23].
Reference: [8] <author> B. Courcelle. </author> <title> Infinite trees in normal form and recursive equations having a unique solution. </title> <journal> Math. System. Theory, </journal> <volume> 13 </volume> <pages> 131-180, </pages> <year> 1979. </year>
Reference-contexts: A goal of our work is to support the design of recursive languages with concurrency, where the "serial part" is referentially transparent also in the precence of nondeterminism arising from the concurrency. Our results about folding and unfolding extend classical results <ref> [8, 10, 18] </ref> for deterministic systems. They are applicable to program transformation systems for program optimization [7, 13], and partial evaluation of nondeterministic languages. Semantics-preserving partial evaluation of such languages is listed as the "challenging problem no. 10.9" in [14]. <p> Furthermore, the correctness of folding was proved under the simplifying condition that a rule would not be used to fold itself. In the classical theory for fold/unfold-tranformations, conditions relaxing this restriction have been given by Courcelle <ref> [8] </ref> and Kott [18]. We conjecture that these results carry over to our framework.
Reference: [9] <author> B. Courcelle. </author> <title> Equivalence and transformations of regular systems. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 42 </volume> <pages> 1-122, </pages> <year> 1986. </year>
Reference-contexts: Our results can be seen as generalizations of some classical results for deterministic such schemes <ref> [9] </ref> to a class of nondeterministic ones, although our basic results are formulated in the more abstract setting of abstract reduction systems.
Reference: [10] <author> B. Courcelle. </author> <title> Recursive applicative program schemes. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, chapter 9, </booktitle> <pages> pages 459-492. </pages> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1990. </year>
Reference-contexts: Due to space limitations, proofs are omitted or sketched in this paper. 2 Related Work Our work is most directly applicable to recursively defined programs (which often can be modeled as rewriting systems) and is thus strongly related to the theory of recursive applicative program schemes <ref> [10, 19] </ref>. Our results can be seen as generalizations of some classical results for deterministic such schemes [9] to a class of nondeterministic ones, although our basic results are formulated in the more abstract setting of abstract reduction systems. <p> A goal of our work is to support the design of recursive languages with concurrency, where the "serial part" is referentially transparent also in the precence of nondeterminism arising from the concurrency. Our results about folding and unfolding extend classical results <ref> [8, 10, 18] </ref> for deterministic systems. They are applicable to program transformation systems for program optimization [7, 13], and partial evaluation of nondeterministic languages. Semantics-preserving partial evaluation of such languages is listed as the "challenging problem no. 10.9" in [14]. <p> For deterministic recursive applicative program schemes there is a classical theory for fold/unfold-transformations, see, e.g., <ref> [10, 18] </ref>. The results in this section can be seen as generalizations of some classical results to the nondeterministic case. For simplicity we restrict the discussion below to pure term rewriting systems (TRS) without bound variables. <p> See Fig. 4 (the crucial steps are t ! s-reductions, all others are directly emulated in D 0 [ N ). We prove correctness of folding under the simplifying condition that a rule is not folded with itself. This corresponds to "restricted folding-unfolding" in <ref> [10] </ref>.
Reference: [11] <author> J. A. Goguen, J. W. Thatcher, E. G. Wagner, and J. B. Wright. </author> <title> Initial algebra semantics ans continuous algebras. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 24(1) </volume> <pages> 68-95, </pages> <month> Jan. </month> <year> 1977. </year>
Reference-contexts: Formally, a term t can be defined as a partial function from the set of sequences of natural numbers ("positions") to operator symbols, such that dom (t) is prefix-closed and respects arities; see, e.g. <ref> [4, 11] </ref>. For p =2 dom (t), we define t (p) = ?. We can relax the conditions that arities are respected and allow also terms which are undefined at leaf positions, and we denote the set of these terms by T 1 ? . <p> Thus, if S is a set of operator symbols with arities, ? is nullary, and T 1 ? are the terms formed according to the arity constraints, then hT 1 ? ; v; ?; Si is a free continuous S-algebra <ref> [11] </ref>. Two positions are disjoint if none is a prefix of the other.
Reference: [12] <author> G. Huet. </author> <title> Confluent reductions: Abstract properties and applications to term rewriting systems. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 27(4) </volume> <pages> 797-821, </pages> <month> Oct. </month> <year> 1980. </year>
Reference-contexts: We believe that our results can support the design of nondeterministic languages where it is more evident what "semantically correct" partial evaluation is. 3 Preliminaries In this paper, we will use reduction systems <ref> [12, 17] </ref> (sometimes called abstract reduction systems) to give semantics of computations. We give the definitions of the most central concepts being used here. 2 Let !, ! 1 , ! 2 be binary relations over some set A.
Reference: [13] <author> G. Huet and B. Lang. </author> <title> Proving and applying program transformations expressed with second-order patterns. </title> <journal> Acta Inform., </journal> <volume> 11(1) </volume> <pages> 31-55, </pages> <month> Jan. </month> <year> 1978. </year>
Reference-contexts: Our results about folding and unfolding extend classical results [8, 10, 18] for deterministic systems. They are applicable to program transformation systems for program optimization <ref> [7, 13] </ref>, and partial evaluation of nondeterministic languages. Semantics-preserving partial evaluation of such languages is listed as the "challenging problem no. 10.9" in [14]. The only partial evaluator for such languages that we are aware of is for the concurrent constraint programming language AKL [23].
Reference: [14] <author> N. D. Jones. </author> <title> Challenging problems in partial evaluation and mixed computation. </title> <editor> In D. Bjtrner, A. P. Ershov, and N. D. Jones, editors, </editor> <title> Partial Evaluation and Mixed Computation. </title> <booktitle> Proceedings of the IFIP TC2 Workshop, </booktitle> <address> Gammel Averns, Denmark, </address> <month> Oct. </month> <year> 1987, </year> <pages> pages 1-14. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Our results about folding and unfolding extend classical results [8, 10, 18] for deterministic systems. They are applicable to program transformation systems for program optimization [7, 13], and partial evaluation of nondeterministic languages. Semantics-preserving partial evaluation of such languages is listed as the "challenging problem no. 10.9" in <ref> [14] </ref>. The only partial evaluator for such languages that we are aware of is for the concurrent constraint programming language AKL [23]. But this partial evaluator gives correct results only under a number of restrictions on the program and assumptions about the intended semantics.
Reference: [15] <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <address> Hertfordshire, UK, </address> <year> 1993. </year>
Reference-contexts: A prime example is a purely functional program. Purely functional programming is highly appropriate for describing purely computational tasks (as long as explicit resource handling for efficiency is not a concern, anyway). The simple semantics makes it particularly simple to analyze and transform functional programs: see, for instance, <ref> [15, 26] </ref>. There are many situations, however, where the descriptive component cannot be neglected. Systems for control of finite resources (such as various servers), operating systems, embedded systems they all rely on the ability to model the environment where the specified computations are to take place.
Reference: [16] <author> J. W. Klop. </author> <title> Combinatory Reduction Systems. </title> <type> PhD thesis, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <year> 1980. </year> <note> Mathematical Centre Tracts Nr. 127. </note>
Reference-contexts: The concept of orthogonality can be extended to higher-order rewriting formalisms, in particular Klop's Combinatory Reduction Systems (CRS) <ref> [16] </ref>. CRS'es include first order rewriting, systems with bound variables such as various -calculi and certain process communication primitives (see Sect. 10), and combinations thereof. They therefore provide a suitable formalism for recursive languages with higher-order constructs. <p> The set of these computations yields the desired nondeterministic reduction strategy. When is a deterministic reduction strategy cofinal? For orthogonal CRS'es, the following result by Klop <ref> [16] </ref> applies. A reduction strategy F is fair (or secured ) if, for any term t, there exists an n such that F n (t) does not contain any residual of any redex in t.
Reference: [17] <author> J. W. Klop. </author> <title> Term rewriting systems. </title> <editor> In S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> vol. 2, chapter 1, </volume> <pages> pages 1-116. </pages> <publisher> Oxford University Press, Oxford, </publisher> <year> 1992. </year>
Reference-contexts: We believe that our results can support the design of nondeterministic languages where it is more evident what "semantically correct" partial evaluation is. 3 Preliminaries In this paper, we will use reduction systems <ref> [12, 17] </ref> (sometimes called abstract reduction systems) to give semantics of computations. We give the definitions of the most central concepts being used here. 2 Let !, ! 1 , ! 2 be binary relations over some set A.
Reference: [18] <author> L. </author> <title> Kott. Unfold/fold program transformations. </title> <editor> In M. Nivat and J. C. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, chapter 12, </booktitle> <pages> pages 411-434. </pages> <publisher> Cambridge University Press, </publisher> <year> 1985. </year>
Reference-contexts: A goal of our work is to support the design of recursive languages with concurrency, where the "serial part" is referentially transparent also in the precence of nondeterminism arising from the concurrency. Our results about folding and unfolding extend classical results <ref> [8, 10, 18] </ref> for deterministic systems. They are applicable to program transformation systems for program optimization [7, 13], and partial evaluation of nondeterministic languages. Semantics-preserving partial evaluation of such languages is listed as the "challenging problem no. 10.9" in [14]. <p> For deterministic recursive applicative program schemes there is a classical theory for fold/unfold-transformations, see, e.g., <ref> [10, 18] </ref>. The results in this section can be seen as generalizations of some classical results to the nondeterministic case. For simplicity we restrict the discussion below to pure term rewriting systems (TRS) without bound variables. <p> Furthermore, the correctness of folding was proved under the simplifying condition that a rule would not be used to fold itself. In the classical theory for fold/unfold-tranformations, conditions relaxing this restriction have been given by Courcelle [8] and Kott <ref> [18] </ref>. We conjecture that these results carry over to our framework.
Reference: [19] <author> M. Nivat. </author> <title> On the interpretation of recursive polyadic program schemes. </title> <journal> Symposia Mathematica, </journal> <volume> 15 </volume> <pages> 255-281, </pages> <year> 1975. </year>
Reference-contexts: Due to space limitations, proofs are omitted or sketched in this paper. 2 Related Work Our work is most directly applicable to recursively defined programs (which often can be modeled as rewriting systems) and is thus strongly related to the theory of recursive applicative program schemes <ref> [10, 19] </ref>. Our results can be seen as generalizations of some classical results for deterministic such schemes [9] to a class of nondeterministic ones, although our basic results are formulated in the more abstract setting of abstract reduction systems. <p> Sometimes we will abuse notation and write ~a even when considered as a relation, i.e. i2N f (~a i ; ~a i+1 )g. Consider an ARS hA; !i, a c.p.o. hC; vi, and a mapping f : A ! C which is monotone w.r.t. ! and v. Cf. <ref> [19] </ref>. f is then a monotone interpretation of hA; !i into hC; vi, and v models the increase of information as a computation proceeds along !. Any !-computation ~a yields a l.u.b. <p> Otherwise p =2 dom (f ! (t)). It is easy to verify that indeed f ! (t) 2 T 1 ? for all t 2 T . f ! extends the interpretation of Nivat <ref> [19] </ref> for recursive applicative program schemes to general term reduction systems. Proposition 4 f ! is monotone w.r.t. ! and v. Thus, we can define a semantics S (t; f ! ; !) w.r.t. f ! for terms t in T .
Reference: [20] <author> G. Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoret. Comput. Sci., </journal> <volume> 5(3) </volume> <pages> 223-256, </pages> <month> Dec. </month> <year> 1977. </year>
Reference-contexts: They therefore provide a suitable formalism for recursive languages with higher-order constructs. In practice, recursive languages can very often be described by combined CRS'es where the computational component is orthogonal (to itself) and also mutually orthogonal to the descriptive component. For instance, the computational component can be PCF-like <ref> [20] </ref>, as the sum of -calculus, first order term rewriting rules for "base operations" such as arithmetical operations, conditionals 5 etc., and recursive definitions of the form f (x 1 ; : : : ; x n ) ! t seen as rewrite rules.
Reference: [21] <author> J.-C. Raoult and J. Vuillemin. </author> <title> Operational and semantic equivalence between recursive programs. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 27(4) </volume> <pages> 772-796, </pages> <month> Oct. </month> <year> 1980. </year>
Reference-contexts: Two first order term rewriting systems are mutually orthogonal if all their rules are left-linear and no left-hand side in one system overlaps any left-hand side in the other system. The following result is due to Raoult and Vuillemin <ref> [21, Proposition 10] </ref>: Theorem 1 (Raoult and Vuillemin) If the term rewriting systems R and R 0 are mutually orthogonal, then ! R and ! R 0 commute. The concept of orthogonality can be extended to higher-order rewriting formalisms, in particular Klop's Combinatory Reduction Systems (CRS) [16].
Reference: [22] <author> J. H. Reppy. </author> <title> CML: A higher order concurrent language. </title> <booktitle> In Proc. SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 293-305, </pages> <year> 1991. </year>
Reference-contexts: Our framework is abstract and thus applicable to a range of languages, but the ones we have mainly in mind are recursive languages with concurrency constructs. Some existing, not referentially transparent languages in this class are Concurrent ML <ref> [22] </ref>, Facile [25], and Erlang [3]. A goal of our work is to support the design of recursive languages with concurrency, where the "serial part" is referentially transparent also in the precence of nondeterminism arising from the concurrency.
Reference: [23] <author> D. Sahlin. </author> <title> Partial evaluation of AKL. </title> <booktitle> In Proc. First International Workshop on Concurrent Constraint Programming, </booktitle> <address> Ca Dolfin, Venice, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Semantics-preserving partial evaluation of such languages is listed as the "challenging problem no. 10.9" in [14]. The only partial evaluator for such languages that we are aware of is for the concurrent constraint programming language AKL <ref> [23] </ref>. But this partial evaluator gives correct results only under a number of restrictions on the program and assumptions about the intended semantics.
Reference: [24] <author> H. Stndergaard and P. Sestoft. </author> <title> Referential transparency, definiteness and un-foldability. </title> <journal> Acta Informatica, </journal> <volume> 27 </volume> <pages> 505-517, </pages> <year> 1990. </year>
Reference-contexts: The semantics we use is related to the one developed by Arnold, Naudin and Nivat for nondeterministic recursive schemes [4] and in particular to the one of Boudol [6] for first order term rewriting systems. See also the interesting discussion of referential transparency and unfoldability in <ref> [24] </ref>; one can say that our commutation condition on the computational and descriptive reduction systems preserves referential transparency for the computational system also in the presence of a non-deterministic environment.
Reference: [25] <author> B. Thomsen, L. Leth, and A. Giacalone. </author> <title> Some Facile chemistry. </title> <type> Tech. Rep. ECRC-92-14, </type> <institution> European Computer-Industry Research Centre, </institution> <year> 1992. </year>
Reference-contexts: Our framework is abstract and thus applicable to a range of languages, but the ones we have mainly in mind are recursive languages with concurrency constructs. Some existing, not referentially transparent languages in this class are Concurrent ML [22], Facile <ref> [25] </ref>, and Erlang [3]. A goal of our work is to support the design of recursive languages with concurrency, where the "serial part" is referentially transparent also in the precence of nondeterminism arising from the concurrency.
Reference: [26] <editor> D. A. Turner, editor. </editor> <booktitle> Research Topics in Functional Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: A prime example is a purely functional program. Purely functional programming is highly appropriate for describing purely computational tasks (as long as explicit resource handling for efficiency is not a concern, anyway). The simple semantics makes it particularly simple to analyze and transform functional programs: see, for instance, <ref> [15, 26] </ref>. There are many situations, however, where the descriptive component cannot be neglected. Systems for control of finite resources (such as various servers), operating systems, embedded systems they all rely on the ability to model the environment where the specified computations are to take place.
Reference: [27] <author> R. J. van Glabbeek. </author> <title> The linear time branching time spectrum II: The semantics of sequential systems with silent moves. </title> <editor> In E. Best, editor, </editor> <booktitle> Proc. CONCUR'93, Volume 715 of Lecture Notes in Comput. Sci., </booktitle> <pages> pages 66-81, </pages> <address> Hildesheim, Germany, Aug. 1993. </address> <publisher> Springer-Verlag. </publisher> <pages> 13 </pages>
Reference-contexts: Our process primitives above compute traces. Thus, semantical equivalence is essentially trace equivalence. Trace equivalence is known to be the finest of a number of process algebra equivalences, such as bisimulation <ref> [27] </ref>. Therefore, program transformations which are correct in our sense will also preserve these equivalences. 11 Conclusion and Further Research We have presented results regarding semantically correct evaluation strategies and program transformations for programs with a computational, deterministic part and a descriptive, possibly non-deterministic part.
References-found: 27

