URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1019/CS-TR-91-1019.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1019/
Root-URL: http://www.cs.wisc.edu
Email: fseshad, naughtong@cs.wisc.edu  
Title: On the Expected Size of Recursive Datalog Queries  
Author: S. Seshadri and Jeffrey F. Naughton 
Affiliation: Department of Computer Sciences University of Wisconsin-Madison  
Abstract: We present asymptotically exact expressions for the expected sizes of relations defined by three well-studied Datalog recursions, namely the "transitive closure", "same generation" and "canonical factorable recursion". We consider the size of the fixpoints of the recursively defined relations in the above programs, as well as the size of the fixpoints of the relations defined by the rewritten programs generated by the Magic Sets and Factoring rewriting algorithms in response to selection queries. Our results show that even over relatively sparse base relations, the recursively defined relations are within a small constant factor of their worst-case size bounds, and that the Magic Sets rewriting algorithm on the average produces relations within a small constant factor of the corresponding bounds for the recursion without rewriting. The expected size of relations produced by the Factoring algorithm, when it applies, is significantly smaller than the expected size of relations produced by Magic Sets. This lends credence to the belief that reducing the arity of the recursive predicate is probably more important than restricting the recursion to relevant tuples.
Abstract-found: 1
Intro-found: 1
Reference: [AKS81] <author> M. Ajtai, J. Komlos, and E. Szemeredi. </author> <title> The longest path in a random graph. </title> <journal> Combinatoria, </journal> <volume> 1, </volume> <pages> pages 1-12, </pages> <year> 1981. </year>
Reference-contexts: Note that the presence of a large strong component does not imply the existence of a long simple cycle. Theorem 2.6 <ref> [AKS81] </ref> Let c be a constant greater than 1. Let D be a digraph drawn from D n;c=n .
Reference: [BKBR87] <author> Catriel Beeri, Paris Kanellakis, Francois Bancilhon, and Raghu Ramakrishnan. </author> <title> Bounds on the propagation of selection into logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 214-226, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year> <month> 21 </month>
Reference-contexts: This gain of a factor of n is not due to better "focusing" properties of the rewritten factored program; rather, it is due to the fact that the Factoring strategy reduces the arity of the recursively defined predicate. Our results lend credence to the hypothesis, stated in <ref> [BKBR87] </ref>, that using a selection to reduce the arity of the recursion is far more important than using the selection to avoid irrelevant tuples.
Reference: [BMSU86] <author> Francois Bancilhon, David Maier, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Cambridge, Mas-sachusetts, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: Our results lend credence to the hypothesis, stated in [BKBR87], that using a selection to reduce the arity of the recursion is far more important than using the selection to avoid irrelevant tuples. Related work on the performance of recursive queries and their evaluation algorithms <ref> [BMSU86, BR88, GKS91, HN88, HL86, MSPS87, Nau88, SZ87] </ref> has considered either worst-case performance, or performance over structured synthetic databases, or empirically measured performance over randomly generated relations. <p> We will call the above program T C henceforth. In response to a query tc (1; Y )?, the Magic Sets rewriting strategy <ref> [BMSU86, BR87, Ram88] </ref> will generate the program (which we call T C mg henceforth) m (1). mtc (X,Y) :- m (X), a (X,Z), mtc (Z,Y). The Factoring rewriting strategy [NRSU89] will produce the program (which we call T C factor henceforth) m (1). ftc (W) :- ftc (X), a (X,W).
Reference: [Bol85] <author> Bela Bollobas. </author> <title> Random Graphs. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: There is a vast and growing body of literature pertaining to random graph theory <ref> [Bol85] </ref>; the most closely related work to ours is a recent paper by Karp on the transitive closure [Kar90]. Many of the background results in Section 2 are taken from this paper. The remainder of this paper is organized as follows.
Reference: [BR87] <author> Catriel Beeri and Raghu Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: We will call the above program T C henceforth. In response to a query tc (1; Y )?, the Magic Sets rewriting strategy <ref> [BMSU86, BR87, Ram88] </ref> will generate the program (which we call T C mg henceforth) m (1). mtc (X,Y) :- m (X), a (X,Z), mtc (Z,Y). The Factoring rewriting strategy [NRSU89] will produce the program (which we call T C factor henceforth) m (1). ftc (W) :- ftc (X), a (X,W).
Reference: [BR88] <author> Francois Bancilhon and Raghu Ramakrishnan. </author> <title> Performance evaluation of data intensive logic programs. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 439-517, </pages> <address> Los Altos, California, 1988. </address> <publisher> Morgan Kauf-mann. </publisher>
Reference-contexts: Our results lend credence to the hypothesis, stated in [BKBR87], that using a selection to reduce the arity of the recursion is far more important than using the selection to avoid irrelevant tuples. Related work on the performance of recursive queries and their evaluation algorithms <ref> [BMSU86, BR88, GKS91, HN88, HL86, MSPS87, Nau88, SZ87] </ref> has considered either worst-case performance, or performance over structured synthetic databases, or empirically measured performance over randomly generated relations.
Reference: [GKS91] <author> S. Ganguly, R. Krishnamurthy, and A. Silberschatz. </author> <title> An analysis technique for transitive closure algorithms: a statistical approach. </title> <booktitle> In Proceedings of the IEEE Data Engineering Conference, </booktitle> <year> 1991. </year> <note> To appear. </note>
Reference-contexts: Our results lend credence to the hypothesis, stated in [BKBR87], that using a selection to reduce the arity of the recursion is far more important than using the selection to avoid irrelevant tuples. Related work on the performance of recursive queries and their evaluation algorithms <ref> [BMSU86, BR88, GKS91, HN88, HL86, MSPS87, Nau88, SZ87] </ref> has considered either worst-case performance, or performance over structured synthetic databases, or empirically measured performance over randomly generated relations.
Reference: [HL86] <author> Jiawei Han and Hongjun Lu. </author> <title> Some performance results on recursive query processing in relational database systems. </title> <booktitle> In Proceedings of the International Conference on Data Engineering, </booktitle> <pages> pages 533-541, </pages> <year> 1986. </year>
Reference-contexts: Our results lend credence to the hypothesis, stated in [BKBR87], that using a selection to reduce the arity of the recursion is far more important than using the selection to avoid irrelevant tuples. Related work on the performance of recursive queries and their evaluation algorithms <ref> [BMSU86, BR88, GKS91, HN88, HL86, MSPS87, Nau88, SZ87] </ref> has considered either worst-case performance, or performance over structured synthetic databases, or empirically measured performance over randomly generated relations.
Reference: [HN88] <author> Ramsey W. Haddad and Jeffrey F. Naughton. </author> <title> Counting methods for cyclic relations. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 333-340, </pages> <address> Austin, Texas, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: Our results lend credence to the hypothesis, stated in [BKBR87], that using a selection to reduce the arity of the recursion is far more important than using the selection to avoid irrelevant tuples. Related work on the performance of recursive queries and their evaluation algorithms <ref> [BMSU86, BR88, GKS91, HN88, HL86, MSPS87, Nau88, SZ87] </ref> has considered either worst-case performance, or performance over structured synthetic databases, or empirically measured performance over randomly generated relations.
Reference: [Kar90] <author> Richard M. Karp. </author> <title> The transitive closure of a random digraph. Random Structures and Algorithms, </title> <booktitle> 1(1) </booktitle> <pages> 73-93, </pages> <year> 1990. </year>
Reference-contexts: There is a vast and growing body of literature pertaining to random graph theory [Bol85]; the most closely related work to ours is a recent paper by Karp on the transitive closure <ref> [Kar90] </ref>. Many of the background results in Section 2 are taken from this paper. The remainder of this paper is organized as follows. Section 2 develops necessary terminology and presents relevant previous results in random graph theory. <p> In other words X (r) is the forward reachability and Y (r) is the reverse reachability. A vertex is reachable from and can reach itself by definition. 2 By symmetry, all the arguments in this paper hold for forward as well as reverse reachability. Theorem 2.1 <ref> [Kar90] </ref> Let c be a constant greater than 1. Let d be a positive constant. Let B be a constant greater than (d + 1)c (c 1) 2 . Let w (n) be a nondecreasing unbounded function. <p> The following theorem tells us that the probability that X (r) is small tends to a constant that depends on c alone. Furthermore, the expected size of X (r), given that X (r) is small tends to another constant that also depends only on c. Theorem 2.2 <ref> [Kar90] </ref> Let D be drawn from D n;c=n , where c &gt; 1. <p> A similar result is shown for the fraction of vertices that have a large forward and reverse reachability. Theorem 2.3 <ref> [Kar90] </ref> Let LARGEOUT be the set fujX (u) is largeg, LARGEIN be the set fvjY (v) is largeg, and LARGE be the set fujX (u) is large and Y (u) is largeg. Let w (n) be a non-decreasing unbounded function. <p> It states that there will be exactly one strong component with more than A ln n vertices for some constant A. In fact, the proof shows that the set LARGE of the previous theorem corresponds to the Giant Strong Component. Theorem 2.4 <ref> [Kar90] </ref> Let w (n) be a nondecreasing unbounded function. Let c be a constant greater than 1. <p> In particular, almost certainly, all the cycles in the graph will lie in LARGE. Theorem 2.5 <ref> [Kar90] </ref> Let c be a constant greater than 1. Let fi be the unique root in [0; 1] of the equation 1 x e cx = 0. <p> If k ln n, then P r [U jV ] fi O (ln 3 n=n). Proof: In <ref> [Kar90] </ref>, a lemma similar to this one was proved. The difference is, the event V there denoted that the reachability of a single vertex was small. We adapt that proof to suit our lemma. Consider an experiment to determine, by a fanning out process, whether X (u) is large. <p> The following argument is similar to one presented in <ref> [Kar90] </ref> for a simpler problem. Consider a fanning out process for constructing the set X (r).
Reference: [MSPS87] <author> Alberto Marchetti-Spaccamela, Antonella Pelaggi, and Domenico Sacca. </author> <title> Worst-case complexity analysis of methods for logic query implementation. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 294-301, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: Our results lend credence to the hypothesis, stated in [BKBR87], that using a selection to reduce the arity of the recursion is far more important than using the selection to avoid irrelevant tuples. Related work on the performance of recursive queries and their evaluation algorithms <ref> [BMSU86, BR88, GKS91, HN88, HL86, MSPS87, Nau88, SZ87] </ref> has considered either worst-case performance, or performance over structured synthetic databases, or empirically measured performance over randomly generated relations.
Reference: [Nau88] <author> Jeffrey F. Naughton. </author> <title> Benchmarking multi-rule recursion evaluation strategies. </title> <type> Technical Report CS-TR-141-88, </type> <institution> Princeton University, </institution> <year> 1988. </year>
Reference-contexts: Our results lend credence to the hypothesis, stated in [BKBR87], that using a selection to reduce the arity of the recursion is far more important than using the selection to avoid irrelevant tuples. Related work on the performance of recursive queries and their evaluation algorithms <ref> [BMSU86, BR88, GKS91, HN88, HL86, MSPS87, Nau88, SZ87] </ref> has considered either worst-case performance, or performance over structured synthetic databases, or empirically measured performance over randomly generated relations.
Reference: [NRSU89] <author> Jeffrey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Argument reduction through factoring. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Databases, </booktitle> <pages> pages 173-182, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: In response to a query tc (1; Y )?, the Magic Sets rewriting strategy [BMSU86, BR87, Ram88] will generate the program (which we call T C mg henceforth) m (1). mtc (X,Y) :- m (X), a (X,Z), mtc (Z,Y). The Factoring rewriting strategy <ref> [NRSU89] </ref> will produce the program (which we call T C factor henceforth) m (1). ftc (W) :- ftc (X), a (X,W).
Reference: [Rag86] <author> P. Raghavan. </author> <title> Probabilistic construction of deterministic algorithms: Approximating packing integer programs. </title> <booktitle> In Proceedings of the 27th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 10-18, </pages> <year> 1986. </year> <month> 22 </month>
Reference-contexts: We will require the following bound on the tail of the binomial distribution <ref> [Rag86] </ref>. Let the random variable X have the distribution BIN (n; p). Then, for every positive real fi, P r [X &gt; finp] &lt; fi fi The in-degree of any vertex has the distribution BIN (n; c=n).
Reference: [Ram88] <author> Raghu Ramakrishnan. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: We will call the above program T C henceforth. In response to a query tc (1; Y )?, the Magic Sets rewriting strategy <ref> [BMSU86, BR87, Ram88] </ref> will generate the program (which we call T C mg henceforth) m (1). mtc (X,Y) :- m (X), a (X,Z), mtc (Z,Y). The Factoring rewriting strategy [NRSU89] will produce the program (which we call T C factor henceforth) m (1). ftc (W) :- ftc (X), a (X,W).
Reference: [RS62] <author> J. B. Rosser and L. Schoenfeld. </author> <title> Approximate formulas for some functions of prime numbers. </title> <journal> Illinois Journal of Mathematics, </journal> <volume> 6 </volume> <pages> 64-94, </pages> <year> 1962. </year>
Reference-contexts: Proof: Let (n) be the cardinality of the set fm j m &lt; n and gcd (m; n) = 1g. It was proved in <ref> [RS62] </ref> that a lower bound for (n) is n= log log n. This implies that given a cycle of length k, there are k (k) possible edges between non-consecutive vertices on the cycle whose presence would result in a cycle whose length is relatively prime to k.
Reference: [SZ87] <author> Domenico Sacca and Carlo Zaniolo. </author> <title> Magic counting methods. </title> <booktitle> In Proceedings of the ACM-SIGMOD Symposium on the Management of Data, </booktitle> <pages> pages 49-59, </pages> <address> San Fran-sisco, California, </address> <month> June </month> <year> 1987. </year> <month> 23 </month>
Reference-contexts: Our results lend credence to the hypothesis, stated in [BKBR87], that using a selection to reduce the arity of the recursion is far more important than using the selection to avoid irrelevant tuples. Related work on the performance of recursive queries and their evaluation algorithms <ref> [BMSU86, BR88, GKS91, HN88, HL86, MSPS87, Nau88, SZ87] </ref> has considered either worst-case performance, or performance over structured synthetic databases, or empirically measured performance over randomly generated relations.
References-found: 17

