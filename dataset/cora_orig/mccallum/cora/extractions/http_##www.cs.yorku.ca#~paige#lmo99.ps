URL: http://www.cs.yorku.ca/~paige/lmo99.ps
Refering-URL: http://www.cs.toronto.edu/~hehner/
Root-URL: 
Email: paige@cs.yorku.ca  hehner@cs.utoronto.ca  
Phone: Phone: 1-416-736-5053. Fax: 1-416-736-5872.  2  Phone: 1-416-978-6026. Fax: 1-416-978-1931.  
Title: Bunches of Objects  
Author: Richard F. Paige and Eric C.R. Hehner 
Keyword: formal specification, object specification, method comparison  
Address: 4700 Keele St., Toronto, Ontario, M3J 1P3 Canada.  Toronto, Toronto, Ontario, M5S 3G4, Canada.  
Affiliation: 1 Dept. of Computer Science, York University,  Dept. of Computer Science, University of  
Abstract: We describe how to specify object-oriented systems using the bunch notation [5] of predicative programming [6]. We specify class interfaces and definitions, static and dynamic collections of objects, methods, inheritance, and polymorphism, and use the approach in two examples. In the process, we consider limitations with the technique, and contrast it with using the Z style of [4].
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K. Arnold and J. Gosling, </author> <title> The Java Programming Language (Addison-Wesley, </title> <year> 1996). </year>
Reference: 2. <author> R. Duke, G. Rose, and G. Smith, Object-Z: </author> <title> A Specification Language advocated for the description of standards, Computer Standards and Interfaces 17(5) (1995). </title>
Reference-contexts: 1 Introduction Formal methodslike Object-Z <ref> [2] </ref>, Larch [3], and many othershave been developed for rigorously specifying and proving properties about object-oriented (OO) systems. These object-oriented methods are often developed from existing (and often non-OO) techniques, such as Z [10] for Object-Z, or algebra-based methods, in the case of Larch. <p> For example, 2 ! 3 is a function that maps 2 to 3, which we could have written n : 2 3 with n unused. When the domain of a function is an initial segment of the natural numbers, we sometimes use a list notation, as in <ref> [3; 5; 2; 5] </ref>. The empty list is [nil]. We also use the asymmetric notation [m; ::n] for a list of integers starting with m and ending before n. List length is #, and list catenation is + . <p> For example, if L = <ref> [2; 5; 3; 4] </ref> then 2 ! 6 j L = [2; 5; 6; 4]. <p> For example, if L = [2; 5; 3; 4] then 2 ! 6 j L = <ref> [2; 5; 6; 4] </ref>. Another use is to create a record structure, as in "name" ! "Smith" j "age" ! 33 which is included in "name" ! list char j "age" ! nat A refinement relation can be applied to functions.
Reference: 3. <author> J. Guttag and J. Horning, </author> <title> Larch: Languages and Tools for Formal Specification (Springer-Verlag, </title> <year> 1993). </year>
Reference-contexts: 1 Introduction Formal methodslike Object-Z [2], Larch <ref> [3] </ref>, and many othershave been developed for rigorously specifying and proving properties about object-oriented (OO) systems. These object-oriented methods are often developed from existing (and often non-OO) techniques, such as Z [10] for Object-Z, or algebra-based methods, in the case of Larch. <p> For example, 2 ! 3 is a function that maps 2 to 3, which we could have written n : 2 3 with n unused. When the domain of a function is an initial segment of the natural numbers, we sometimes use a list notation, as in <ref> [3; 5; 2; 5] </ref>. The empty list is [nil]. We also use the asymmetric notation [m; ::n] for a list of integers starting with m and ending before n. List length is #, and list catenation is + . <p> For example, if L = <ref> [2; 5; 3; 4] </ref> then 2 ! 6 j L = [2; 5; 6; 4].
Reference: 4. <author> A. Hall, </author> <title> Specifying and Interpreting Class Hierarchies in Z, </title> <booktitle> in: Proc. Eighth Z User Meeting, Workshops in Computing Series (Springer-Verlag, </booktitle> <year> 1994). </year>
Reference-contexts: To study the breadth of applicability of predicative programming, by demonstrating the extent to which it can be used for specifying object-oriented conceptsi.e., to learn what OO concepts it can and cannot specify. To compare the method with the Z application to OO specification of Hall <ref> [4] </ref>. Following the work of [7], we unify an object-oriented theory and a predicative theory. We have learned that predicative programming is directly applicable to writing formal specifications of object-oriented systems. <p> For example, if L = <ref> [2; 5; 3; 4] </ref> then 2 ! 6 j L = [2; 5; 6; 4]. <p> For example, if L = [2; 5; 3; 4] then 2 ! 6 j L = <ref> [2; 5; 6; 4] </ref>. Another use is to create a record structure, as in "name" ! "Smith" j "age" ! 33 which is included in "name" ! list char j "age" ! nat A refinement relation can be applied to functions. <p> Because predicative notation uses bunches for types, and because a bunch can represent zero, one, or many instances of a type, the same declaration can be used for one instance as is used for many instances. See [9] for a case study that applies this approach. In <ref> [4] </ref>, the Z notation was used to specify objects and classes. In the style of [4], an object, specified as a Z schema, included a self attribute, which was used to establish object identity uniqueness. <p> See [9] for a case study that applies this approach. In <ref> [4] </ref>, the Z notation was used to specify objects and classes. In the style of [4], an object, specified as a Z schema, included a self attribute, which was used to establish object identity uniqueness. <p> In the approach of <ref> [4] </ref>, distinctness is established by modeling the system as a whole, using a new state schema with a set of Stacks, where the schema property would require self attribute uniqueness over the set. <p> We can avoid having a self field in every object, since in our approach instantiation is variable declaration. It is also possible to use the approach of <ref> [4] </ref>. This is useful when we want to represent multiple instances of a class with identical attribute values. <p> Only those aspects of Stack that are different from Sequence need be specified when writing class Stack. Unfortunately, there is no precise agreement on what `like' means when applied to classes <ref> [4] </ref>. The approach we use in this paper is one of subtyping: if a class B is derived from a class C, then B can be used everywhere C can be used. We take this approach predominantly because we want to ensure behavioral compatibility between classes related by inheritance. <p> Some of this simplicity arises because of the treatment of classes using bunch notation. We are also more rigorous in associating methods with classes and objects. In <ref> [4] </ref>, methods are associated with objects by schema inclusion and convention. We also have the ability to create new objects by variable declaration. In [4], new objects are created by adding them to a representation of system state, and specific methods (i.e., Z operation schemas for object creation) must be used <p> We are also more rigorous in associating methods with classes and objects. In <ref> [4] </ref>, methods are associated with objects by schema inclusion and convention. We also have the ability to create new objects by variable declaration. In [4], new objects are created by adding them to a representation of system state, and specific methods (i.e., Z operation schemas for object creation) must be used to carry out this system manipulation, thus making the overall specification larger. <p> In the predicative notation, all types are based upon a bunch representation, including lists and records. Because of this, classes and functional methods can be developed from bunch notation, and therefore object instantiation can be given its usual interpretation as variable declaration. This differs from the approach in <ref> [4] </ref>, where objects are specified in terms of their effect on a global system state. Furthermore, inheritance can be given an interpretation akin to that used in many languages. As well, state-change methods in base classes can be reused in state-change methods of derived classes, with appropriate restrictions on domains.
Reference: 5. <author> E.C.R. Hehner, </author> <title> Bunch Theory: A Simple Set Theory for Computer Science, </title> <journal> Information Processing Letters, </journal> <month> 12(1) </month> <year> (1981). </year>
Reference-contexts: We commence with an overview of the notations needed for specifying classes, objects, and methods. We summarize the predicative type system, which is based on bunches <ref> [5] </ref>. Class specification is considered in Sections 3 and 4. In Section 5, single and multiple inheritance is described. We discuss two standard problems with multiple inheritancename clashes and repeated inheritanceand propose solutions. We also show how to write virtual functions. Section 6 contains examples that demonstrate the techniques. <p> We also show how to write virtual functions. Section 6 contains examples that demonstrate the techniques. Finally, in Section 7, we discuss limitations, and suggest directions for future work. 2 Bunch Notation Bunches were introduced in <ref> [5] </ref>, and are used in [6] as a type system. A bunch is a collection of values, and can be written as in this example: 2; 3; 5. A bunch consisting of a single element is identical to the element. <p> For example, the declaration var x : 1 says that x can take on one value, 1. A variable declared with a bunch for a type can be used to represent zero or more elements of the type <ref> [5] </ref>. <p> For example, 2 ! 3 is a function that maps 2 to 3, which we could have written n : 2 3 with n unused. When the domain of a function is an initial segment of the natural numbers, we sometimes use a list notation, as in <ref> [3; 5; 2; 5] </ref>. The empty list is [nil]. We also use the asymmetric notation [m; ::n] for a list of integers starting with m and ending before n. List length is #, and list catenation is + . <p> For example, if L = <ref> [2; 5; 3; 4] </ref> then 2 ! 6 j L = [2; 5; 6; 4]. <p> For example, if L = [2; 5; 3; 4] then 2 ! 6 j L = <ref> [2; 5; 6; 4] </ref>. Another use is to create a record structure, as in "name" ! "Smith" j "age" ! 33 which is included in "name" ! list char j "age" ! nat A refinement relation can be applied to functions.
Reference: 6. <author> E.C.R. Hehner, </author> <title> A Practical Theory of Programming (Springer-Verlag, </title> <year> 1993). </year>
Reference-contexts: These object-oriented methods are often developed from existing (and often non-OO) techniques, such as Z [10] for Object-Z, or algebra-based methods, in the case of Larch. In this paper, we are interested in applying a general-purpose program design calculus, predicative programming <ref> [6] </ref>, to the specification of object-oriented systems. We are interested in such an application done without extending the predicative method, so that we can develop OO systems using its existing techniques. We apply predicative programming to object-oriented specification for several other reasons. <p> We also show how to write virtual functions. Section 6 contains examples that demonstrate the techniques. Finally, in Section 7, we discuss limitations, and suggest directions for future work. 2 Bunch Notation Bunches were introduced in [5], and are used in <ref> [6] </ref> as a type system. A bunch is a collection of values, and can be written as in this example: 2; 3; 5. A bunch consisting of a single element is identical to the element. <p> For example, if L = [2; 5; 3; 4] then 2 ! 6 j L = <ref> [2; 5; 6; 4] </ref>. Another use is to create a record structure, as in "name" ! "Smith" j "age" ! 33 which is included in "name" ! list char j "age" ! nat A refinement relation can be applied to functions. <p> Thus, we write P : S (informally read as P is refined by S), which means S : P. A few well-chosen operators can do the work of many over-specific operators. For any further details or clarifications of notation, the reader is directed to <ref> [6] </ref>. 3 Specifying Classes and Objects Several different formalizations of classes have been presented in the literature. The definition of a class that we use is derived from [8] Definition 1. A class is an abstract data type equipped with a possibly partial implementation. <p> By definition, B : C, because every value satisfactory to B is also satisfactory to C. In other words, class C includes all its extensions <ref> [6] </ref>. The names of attributes of C and b 1 ; ::b k+1 can coincide. If b i is also the name of an attribute of C, then the attribute in C will be replaced by new attribute b i in B. <p> Using the functional refinement laws from <ref> [6] </ref>, it is straightforward to prove that Delete : s : Sequence i; j : nat if 0 i &lt; #s"contents" then Shift s i 0 else s Sequence can now be used in constructing a derived Queue class. <p> This implies that we can specify and reason about key object-oriented concepts, as well as the real-time, interactive, concurrent, and timing characteristics of systems (using the approach outlined in <ref> [6] </ref>), using one notation and method. In the process, we have unified an object-oriented theory with the predicative theory.
Reference: 7. <author> C.A.R. Hoare and Jifeng He, </author> <title> Unifying Theories of Programming (Prentice Hall, </title> <year> 1998). </year>
Reference-contexts: To compare the method with the Z application to OO specification of Hall [4]. Following the work of <ref> [7] </ref>, we unify an object-oriented theory and a predicative theory. We have learned that predicative programming is directly applicable to writing formal specifications of object-oriented systems.
Reference: 8. <author> B. Meyer, </author> <title> Object-Oriented Software Construction, </title> <booktitle> Second Edition (Prentice-Hall, </booktitle> <year> 1997). </year>
Reference-contexts: For any further details or clarifications of notation, the reader is directed to [6]. 3 Specifying Classes and Objects Several different formalizations of classes have been presented in the literature. The definition of a class that we use is derived from <ref> [8] </ref> Definition 1. A class is an abstract data type equipped with a possibly partial implementation. <p> If a b i overrides an attribute in C, then the type of the new attribute must be a subbunch of the original: if attribute b i in C has type T, then this means that T i : T. For functional methods, this is the contravariant rule <ref> [8] </ref>. This is weaker than the restrictions on overriding functional methods in C++, where parameter types of the overriding method must match the types of the originals (the return type may be a subtype). <p> In C++, a virtual method in a class can be redefined in a derived class. In our formulation of classes, all functional methods are virtualthe definitions of functional methods in derived classes can replace definitions in base classes (as in the Java language); <ref> [8] </ref> suggests that this is more useful than the C++ default, because it guarantees that the semantics of method calls in a hierarchy will be the correct ones. We examine this in more detail. <p> It has also been described as problematic in implementation, which means that, often, restricted implementations exist. For example, multiple inheritance in Java is only permissible on class interfaces. We adopt the Eiffel <ref> [8] </ref> approach to multiple inheritance, as follows. Multiple inheritance takes base class definitions or interfaces, and produces a derived class definition or interface. <p> Should there be one or two occurrences of the shared name in the derived class? It has been suggested that dealing with name clashes is a `deep' semantic problem. Following Meyer <ref> [8] </ref>, we instead treat the problem syntactically, and use one of two mechanisms to resolve name clashes. 1. Order the base classes in the definition of the derived class, so as to override those features that we do not want in the derived class. <p> In this way, we can select the reoccurring feature that we want to inherit in the derived class. This may not be appropriate for modeling all problem domains <ref> [8] </ref>, especially if in the derived class we really need two instances of the common feature. This approach lets us model abstract base classes as in C++. <p> Apply a renaming to all the commonly named features of the base classes in order to eliminate name clashes. This is the approach used in Eiffel <ref> [8] </ref>. An example is shown in Fig. 1: attribute a is common to both C1 and C2. If we need two occurrences of the attribute in the derived class D, we rename the occurrences of a in the definition of D. Fig.1. <p> If both attributes a in C1 and C2 had the same type, e.g., A, then as specifiers we would have to decide which instance of a to use. (This is akin to the select clause in Eiffel <ref> [8] </ref>). 5.2.2 Repeated inheritance If a class is a descendent of another through two or more paths, then repeated inheritance has occurred. <p> This matches the notion of virtual base class in C++. If a renaming is applied to one or more methods or attributes, a derived class can have two or more instances of a method or attribute; <ref> [8] </ref> gives examples of when this is useful. The solution that we applied for resolving name clashes can also be used in resolving repeated inheritance (as is the case with Eiffel). 6 Examples We present two examples of specifying object-oriented systems. <p> It is possible to overload state-change methods in predicative programming, though overloaded functional methods cannot be specified in a class, since a class is expressed using selective union. The value and safety of overloading methods has been questioned in the past <ref> [8] </ref>. It could be useful to be able to specify visibility parameters on class members. Such features are inherent in languages like C++ or Java.
Reference: 9. <author> R.F. Paige, </author> <title> Using an Object-Oriented Predicative Style to Solve the Invoicing Case Study, </title> <booktitle> in: Proc. INVOICING 1998, </booktitle> <address> Nantes, France (IRIN, </address> <year> 1998). </year>
Reference-contexts: Because predicative notation uses bunches for types, and because a bunch can represent zero, one, or many instances of a type, the same declaration can be used for one instance as is used for many instances. See <ref> [9] </ref> for a case study that applies this approach. In [4], the Z notation was used to specify objects and classes. In the style of [4], an object, specified as a Z schema, included a self attribute, which was used to establish object identity uniqueness. <p> We can avoid having a self field in every object, since in our approach instantiation is variable declaration. It is also possible to use the approach of [4]. This is useful when we want to represent multiple instances of a class with identical attribute values. The case study in <ref> [9] </ref> provides a detailed example of using this technique in predicative programming. 4 State-Change Methods The formalization of classes given in Section 3 is sufficient for specifying attributes and methods that do not change the state and return a value.
Reference: 10. <author> J.M. Spivey, </author> <title> The Z Notation: A Reference Manual, </title> <publisher> (Prentice-Hall, </publisher> <year> 1989). </year>
Reference-contexts: 1 Introduction Formal methodslike Object-Z [2], Larch [3], and many othershave been developed for rigorously specifying and proving properties about object-oriented (OO) systems. These object-oriented methods are often developed from existing (and often non-OO) techniques, such as Z <ref> [10] </ref> for Object-Z, or algebra-based methods, in the case of Larch. In this paper, we are interested in applying a general-purpose program design calculus, predicative programming [6], to the specification of object-oriented systems.
Reference: 11. <author> S. Stepney, R. Barden, and D. Cooper, </author> <title> Object-Orientation in Z (Springer-Verlag, </title> <year> 1992). </year>
Reference-contexts: In our first example, we specify a Sequence class and derive a Queue class, so as to demonstrate the basic approach. Then, we reformulate part of the Quadrilaterals example of <ref> [11] </ref>. 6.1 Sequences and Queues We define a Sequence class, and derive a Queue class from it. <p> To Dequeue an element, we Delete the element at position front. Dequeue = q : Queue Delete q (q"front") j q In specifying Queue, we have specialized methods of Sequence. 6.2 Quadrilaterals The quadrilaterals example is described in <ref> [11] </ref>; it is used to compare several different object-oriented methods based on Z. The example requires specifying different sorts of quadrilaterals which may be used in a drawing system. We specify a predicative solution, and in the process compare it to the Z formulation in [11]. <p> quadrilaterals example is described in <ref> [11] </ref>; it is used to compare several different object-oriented methods based on Z. The example requires specifying different sorts of quadrilaterals which may be used in a drawing system. We specify a predicative solution, and in the process compare it to the Z formulation in [11]. <p> Rhombus = xr : RhomInt IsRhom (r"edges") ^ r"Angle" = cos 1 (: : :) Parallelogram = xp : ParInt IsPar (r"edges") ^ r"Angle" = cos 1 (: : :) Due to space constraints, we omit the full definitions of the Angle methods of Rhombus and Parallelogram (they are in <ref> [11] </ref>). IsSquare is true if and only if the list of edges forms a square ( in the body of IsSquare is dot product.) IsSquare = e : Edges (e0 e1 = 0 ^ e1 + e2 = 0) The predicates IsRect, IsPar, and IsRhom are similar. <p> TranslateRhom = r : Rhombus v : Vector TranslateQuad r v j r The formulation of the quadrilaterals above results in a shorter, more concise specification than that using the Z style in <ref> [11] </ref>. Some of this simplicity arises because of the treatment of classes using bunch notation. We are also more rigorous in associating methods with classes and objects. In [4], methods are associated with objects by schema inclusion and convention.
References-found: 11

