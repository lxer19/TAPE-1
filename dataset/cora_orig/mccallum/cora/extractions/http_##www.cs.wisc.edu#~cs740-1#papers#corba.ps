URL: http://www.cs.wisc.edu/~cs740-1/papers/corba.ps
Refering-URL: 
Root-URL: 
Email: fschmidt,gokhale,harrison,gurug@cs.wustl.edu  
Title: A High-performance Endsystem Architecture for Real-time CORBA application domains (such as avionics, telecommunications, and multimedia)
Author: Douglas C. Schmidt, Aniruddha Gokhale, Timothy H. Harrison, and Guru Parulkar 
Note: Many  
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper will appear in the feature topic issue on Distributed Object Computing in the IEEE Communications Magazine, Vol. 14, No. 2, February 1997. Abstract This paper describes the architectural features and optimizations required to develop real-time ORB endsystems that can deliver end-to-end QoS guarantees to applications. While some operating systems, networks, and protocols now support real-time scheduling, they do not provide integrated solutions. The main thrust of this paper is that advances in real-time distributed object computing can be achieved only by systematically pinpointing performance bottlenecks; optimizing the performance of networks, ORB endsystems, common services, and applications; and simultaneously integrating techniques and tools that simplify application development. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.0 ed., </editor> <month> July </month> <year> 1995. </year>
Reference-contexts: In addition to requiring QoS guarantees, these applications must be flexible and reusable. The Common Object Request Broker Architecture (CORBA) is a distributed object computing middleware standard defined by the Object Management Group (OMG) <ref> [1] </ref>. CORBA is intended to support the production of flexible and reusable distributed services and applications. Many implementations of CORBA are now available. Two of the most popular ORBs include IONA's Orbix, which is widely considered as the market leader, and Visigenic's VisiBroker, which is included in Netscape 4.0. <p> Therefore, ORB endsystems must provide a range of communication protocols that can be customized and optimized for specific application requirements and network/host environments. Section 4.2 outlines optimizations for the CORBA General Inter-ORB Protocol (GIOP) <ref> [1] </ref>, which specifies the request format and transmission protocol that enables inter 2 operability among heterogeneous ORBs. * Optimized real-time request demultiplexing and dispatching: ORB endsystems must demultiplex and dispatch incoming CORBA requests to the appropriate method of the target object. In conventional ORBs, demultiplexing occurs at multiple layers. <p> The buffer pools for I/O devices support direct demultiplexing of periodic and aperiodic CORBA requests into memory shared among user- and kernel-resident threads. 4.2 Real-time GIOP/IIOP Protocols The CORBA General Inter-ORB Protocol (GIOP) <ref> [1] </ref> specifies the request format and transmission protocol that enables ORB-to-ORB interoperability. Conventional CORBA implementations utilize inflexible, static strategies for selecting the GIOP implementation. For instance, ORBs commonly implement the GIOP using the Internet Inter-ORB Protocol (IIOP), which is layered above TCP/IP.
Reference: [2] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: Many implementations of CORBA are now available. Two of the most popular ORBs include IONA's Orbix, which is widely considered as the market leader, and Visigenic's VisiBroker, which is included in Netscape 4.0. Our experience using CORBA on telecommunication, avionics, and medical projects <ref> [2] </ref> indicates that it is well-suited for request/response applications over lower-speed networks (such as Ethernet and Token Ring). <p> As a result, it is hard to write a standard CORBA application that is guaranteed not to block indefinitely when endsystem and network resources are temporarily unavailable. * Lack of performance optimizations: Existing ORBs incur significant run-time throughput and latency overhead <ref> [3, 4, 2, 5] </ref>. <p> This paper is organized as follows: Section 2 outlines the features and optimizations required in ORB endsystems to provide end-to-end QoS guarantees for applications; Section 3 summarizes results from our studies <ref> [3, 4, 2, 5] </ref> of performance overhead in existing CORBA implementations; Section 4 describes the feature enhancements and optimizations we are developing to support high-performance, real-time ORB endsystems; and Section 5 presents concluding remarks. 2 Endsystem Requirements for Real time CORBA CORBA Object Request Brokers (ORBs) allow clients to invoke methods <p> The primary sources of overhead include (1) excessive presentation layer conversions and data copying, (2) inefficient server demultiplexing techniques, (3) unpredictable buffering algorithms used for network reads and writes, (4) long chains of intra-ORB virtual function calls, and (5) improper choice of underlying OS system calls <ref> [3, 4, 2, 5] </ref>. Figures 2, 3, and 4 illustrate the latency for sending pa-rameterless requests, octets, and structs between a client and a target object over an otherwise unused 155 Mbps ATM network. These tests were conducted using a modified version of the TTCP benchmarking tool.
Reference: [3] <author> A. Gokhale and D. C. Schmidt, </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks, </title> <booktitle> in Proceedings of SIGCOMM '96, </booktitle> <address> (Stanford, CA), </address> <pages> pp. 306-317, </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: As a result, it is hard to write a standard CORBA application that is guaranteed not to block indefinitely when endsystem and network resources are temporarily unavailable. * Lack of performance optimizations: Existing ORBs incur significant run-time throughput and latency overhead <ref> [3, 4, 2, 5] </ref>. <p> This paper is organized as follows: Section 2 outlines the features and optimizations required in ORB endsystems to provide end-to-end QoS guarantees for applications; Section 3 summarizes results from our studies <ref> [3, 4, 2, 5] </ref> of performance overhead in existing CORBA implementations; Section 4 describes the feature enhancements and optimizations we are developing to support high-performance, real-time ORB endsystems; and Section 5 presents concluding remarks. 2 Endsystem Requirements for Real time CORBA CORBA Object Request Brokers (ORBs) allow clients to invoke methods <p> The primary sources of overhead include (1) excessive presentation layer conversions and data copying, (2) inefficient server demultiplexing techniques, (3) unpredictable buffering algorithms used for network reads and writes, (4) long chains of intra-ORB virtual function calls, and (5) improper choice of underlying OS system calls <ref> [3, 4, 2, 5] </ref>. Figures 2, 3, and 4 illustrate the latency for sending pa-rameterless requests, octets, and structs between a client and a target object over an otherwise unused 155 Mbps ATM network. These tests were conducted using a modified version of the TTCP benchmarking tool.
Reference: [4] <author> A. Gokhale and D. C. Schmidt, </author> <title> The Performance of the CORBA Dynamic Invocation Interface and Dynamic Skeleton Interface over High-Speed ATM Networks, </title> <booktitle> in Proceedings of GLOBECOM '96, </booktitle> <address> (London, England), </address> <pages> pp. 50-56, </pages> <publisher> IEEE, </publisher> <month> November </month> <year> 1996. </year>
Reference-contexts: As a result, it is hard to write a standard CORBA application that is guaranteed not to block indefinitely when endsystem and network resources are temporarily unavailable. * Lack of performance optimizations: Existing ORBs incur significant run-time throughput and latency overhead <ref> [3, 4, 2, 5] </ref>. <p> This paper is organized as follows: Section 2 outlines the features and optimizations required in ORB endsystems to provide end-to-end QoS guarantees for applications; Section 3 summarizes results from our studies <ref> [3, 4, 2, 5] </ref> of performance overhead in existing CORBA implementations; Section 4 describes the feature enhancements and optimizations we are developing to support high-performance, real-time ORB endsystems; and Section 5 presents concluding remarks. 2 Endsystem Requirements for Real time CORBA CORBA Object Request Brokers (ORBs) allow clients to invoke methods <p> The primary sources of overhead include (1) excessive presentation layer conversions and data copying, (2) inefficient server demultiplexing techniques, (3) unpredictable buffering algorithms used for network reads and writes, (4) long chains of intra-ORB virtual function calls, and (5) improper choice of underlying OS system calls <ref> [3, 4, 2, 5] </ref>. Figures 2, 3, and 4 illustrate the latency for sending pa-rameterless requests, octets, and structs between a client and a target object over an otherwise unused 155 Mbps ATM network. These tests were conducted using a modified version of the TTCP benchmarking tool.
Reference: [5] <author> A. Gokhale and D. C. Schmidt, </author> <title> Evaluating Latency and Scalability of CORBA Over High-Speed ATM Networks, </title> <booktitle> in Proceedings of the International Confernce on Distributed Computing Systems, </booktitle> <address> (Baltimore, Maryland), </address> <publisher> IEEE, </publisher> <month> May </month> <year> 1997. </year>
Reference-contexts: As a result, it is hard to write a standard CORBA application that is guaranteed not to block indefinitely when endsystem and network resources are temporarily unavailable. * Lack of performance optimizations: Existing ORBs incur significant run-time throughput and latency overhead <ref> [3, 4, 2, 5] </ref>. <p> This paper is organized as follows: Section 2 outlines the features and optimizations required in ORB endsystems to provide end-to-end QoS guarantees for applications; Section 3 summarizes results from our studies <ref> [3, 4, 2, 5] </ref> of performance overhead in existing CORBA implementations; Section 4 describes the feature enhancements and optimizations we are developing to support high-performance, real-time ORB endsystems; and Section 5 presents concluding remarks. 2 Endsystem Requirements for Real time CORBA CORBA Object Request Brokers (ORBs) allow clients to invoke methods <p> The primary sources of overhead include (1) excessive presentation layer conversions and data copying, (2) inefficient server demultiplexing techniques, (3) unpredictable buffering algorithms used for network reads and writes, (4) long chains of intra-ORB virtual function calls, and (5) improper choice of underlying OS system calls <ref> [3, 4, 2, 5] </ref>. Figures 2, 3, and 4 illustrate the latency for sending pa-rameterless requests, octets, and structs between a client and a target object over an otherwise unused 155 Mbps ATM network. These tests were conducted using a modified version of the TTCP benchmarking tool.
Reference: [6] <author> S. Vinoski, </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments, </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 14, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: CISC. The components in Figure 1 support this level of transparency. Steve Vinoski's article <ref> [6] </ref> (in this issue of the IEEE Communications Magazine) describes the CORBA middleware components (e.g., the Object Request Broker, IDL Stubs and Skeletons, Object Adapter, etc.).
Reference: [7] <author> R. Gopalakrishnan and G. Parulkar, </author> <title> Bringing Real-time Scheduling Theory and Practice Closer for Multimedia Computing, </title> <booktitle> in SIGMETRICS Conference, </booktitle> <address> (Philadelphia, PA), </address> <publisher> ACM, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: For instance, OS scheduling mechanisms must allow high priority CORBA requests to run to completion and prevent them from being blocked indefinitely by lower priority operations <ref> [7, 8] </ref>. <p> In addition to increasing overhead, the layered demultiplexing and dispatching mechanisms in conventional ORBs neither schedule nor prioritize demultiplexing behavior. Therefore, the ORB endsystem must provide mechanisms (such as packet filters [9], de-layered protocol stacks [10], direct demultiplexing [11], and real-time upcalls <ref> [7] </ref>) that perform CORBA request demultiplexing and dispatching efficiently and predictably. <p> To support periodic delivery of CORBA requests, we have implemented a real-time upcall (RTU) mechanism <ref> [7] </ref>. RTUs are an OS scheduling mechanism that provides rate monotonic QoS guarantees to protocols and CORBA applications. <p> Since applications can have widely varying requirements, a structured and general way to specify QoS is necessary. TAO identifies four application service classes that encompass continuous media, bulk data, low-latency transaction message, and high-bandwidth message streams <ref> [7] </ref>. These four classes of QoS specifications are defined using high-level parameters; other low-level parameters are derived automatically. Several ORB endsystem resources (such as CPU, memory, network connections, and storage devices) are involved in satisfying application QoS requirements.
Reference: [8] <author> S. Khanna and et. al., </author> <title> Realtime Scheduling in SunOS5.0, </title> <booktitle> in Proceedings of the USENIX Winter Conference, </booktitle> <pages> pp. 375-390, </pages> <publisher> USENIX Association, </publisher> <year> 1992. </year>
Reference-contexts: For instance, OS scheduling mechanisms must allow high priority CORBA requests to run to completion and prevent them from being blocked indefinitely by lower priority operations <ref> [7, 8] </ref>.
Reference: [9] <author> S. McCanne and V. Jacobson, </author> <title> The BSD Packet Filter: A New Architecture for User-level Packet Capture, </title> <booktitle> in Proceedings of the Winter USENIX Conference, </booktitle> <address> (San Diego, CA), </address> <pages> pp. 259-270, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: In conventional ORBs, demultiplexing occurs at multiple layers. Layered demultiplexing is often inappropriate, however, for real-time applications. In addition to increasing overhead, the layered demultiplexing and dispatching mechanisms in conventional ORBs neither schedule nor prioritize demultiplexing behavior. Therefore, the ORB endsystem must provide mechanisms (such as packet filters <ref> [9] </ref>, de-layered protocol stacks [10], direct demultiplexing [11], and real-time upcalls [7]) that perform CORBA request demultiplexing and dispatching efficiently and predictably.
Reference: [10] <author> M. Abbott and L. Peterson, </author> <title> Increasing Network Throughput by Integrating Protocol Layers, </title> <journal> ACM Transactions on Networking, </journal> <volume> vol. 1, </volume> <month> October </month> <year> 1993. </year>
Reference-contexts: Layered demultiplexing is often inappropriate, however, for real-time applications. In addition to increasing overhead, the layered demultiplexing and dispatching mechanisms in conventional ORBs neither schedule nor prioritize demultiplexing behavior. Therefore, the ORB endsystem must provide mechanisms (such as packet filters [9], de-layered protocol stacks <ref> [10] </ref>, direct demultiplexing [11], and real-time upcalls [7]) that perform CORBA request demultiplexing and dispatching efficiently and predictably.
Reference: [11] <author> D. R. Engler and M. F. Kaashoek, DPF: </author> <title> Fast, Flexible Message Demultiplexing using Dynamic Code Generation, </title> <booktitle> in Proceedings of ACM SIGCOMM '96 Conference in Computer Communication Review, </booktitle> <address> (Stanford University, Califor-nia, USA), </address> <pages> pp. 53-59, </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: Layered demultiplexing is often inappropriate, however, for real-time applications. In addition to increasing overhead, the layered demultiplexing and dispatching mechanisms in conventional ORBs neither schedule nor prioritize demultiplexing behavior. Therefore, the ORB endsystem must provide mechanisms (such as packet filters [9], de-layered protocol stacks [10], direct demultiplexing <ref> [11] </ref>, and real-time upcalls [7]) that perform CORBA request demultiplexing and dispatching efficiently and predictably.
Reference: [12] <author> P. Druschel, M. B. Abbott, M. Pagels, and L. L. Peterson, </author> <title> Network subsystem design, </title> <journal> IEEE Network (Special Issue on End-System Support for High Speed Networks), </journal> <volume> vol. 7, </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: Therefore, multiple layers in an ORB endsystem (e.g., the network adapters, I/O subsystem protocol stacks, Object Adapter, and presentation layer) must collaborate to minimize data copying <ref> [12] </ref>. Section 4.1 outlines our zero-copy memory management mechanism, which behaves predictably and efficiently irrespective of user buffer sizes and endsystem workload. * Optimized presentation layer: Presentation layer conversions transform application-level data into a portable format that masks byte order, alignment, and word length differences.
Reference: [13] <author> P. Hoschka, </author> <title> Automating Performance Optimization by Heuristic Analysis of a Formal Specification, in Proceedings of Joint Conference for Formal Description Techniques (FORTE) and Protocol Specification, Testing and Verification (PSTV), </title> <address> (Kaiserslautern), </address> <year> 1996. </year> <note> To be published. 7 </note>
Reference-contexts: There are many techniques for reducing the cost of presentation layer conversions. For instance, <ref> [13] </ref> describes the tradeoffs between using compiled versus interpreted code for presentation layer conversions. Compiled marshaling code is efficient, but requires excessive amounts of memory, which is problematic in many embedded real-time environments. In contrast, interpreted marshaling code is slower, but more compact. <p> This flexibility can achieve an optimal tradeoff between interpreted code (which is slow, but compact in size) and compiled code (which is fast, but larger in size) <ref> [13] </ref>. Likewise, TAO can cache premarshaled application data units (ADUs) that are used repeatedly. Caching improves performance when ADUs are transferred sequentially in request chains and each ADU varies only slightly from one transmission to the other.
Reference: [14] <author> D. C. Schmidt and T. Suda, </author> <title> An Object-Oriented Framework for Dynamically Configuring Extensible Distributed Communication Systems, </title> <journal> IEE/BCS Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <volume> vol. 2, </volume> <pages> pp. 280-293, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: These tests were conducted using a modified version of the TTCP benchmarking tool. The TTCP tool was enhanced to support three communication mechanisms: two widely used implementations of CORBA (Orbix 2.1 and VisiBroker 2.0) and an implementation written in ACE <ref> [14] </ref> (which is a lightweight C++ network programming framework implemented directly atop sockets and TCP/IP). The results of the TTCP benchmarks over ATM were as follows: * Latency for parameterless invocations: Figure 2 illustrates the latency of the three communication mechanisms for invoking parameterless twoway operations.
Reference: [15] <author> Z. D. Dittia, J. Jerome R. Cox, and G. M. Parulkar, </author> <title> Design of the APIC: A High Performance ATM Host-Network Interface Chip, </title> <booktitle> in IEEE INFOCOM '95, </booktitle> <address> (Boston, USA), </address> <pages> pp. 179-187, </pages> <publisher> IEEE Computer Society Press, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: At the heart of this subsystem is a daisy-chained interconnect comprising a number of ATM Port Interconnect Controller (APIC) chips <ref> [15] </ref>. APIC is designed to sustain an aggregate bidirectional data rate of 2.4 Gbps. Our Gigabit I/O subsystem builds on the APIC to enhance conventional operating systems with a zero-copy buffer management system. <p> Our GIOP transport layer tightly integrates the underlying ATM/IP infrastructure via techniques such as ALF/ILP [17], our Gigabit I/O subsystem [18, 19, 20, 21], and the APIC <ref> [15] </ref> network adapter. 4.3 Real-Time Object Adapter The Object Adapter is the component in CORBA that associates object implementations with the ORB and delivers requests to the appropriate target object.
Reference: [16] <author> G. Parulkar, D. C. Schmidt, and J. S. Turner, </author> <title> a I t P m: a Strategy for Integrating IP with ATM, </title> <booktitle> in Proceedings of the Symposium on Communications Architectures and Protocols (SIG-COMM), ACM, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: To enhance flexibility and performance, therefore, TAO supports the run-time configuration of lightweight GIOP implementations. These protocols optimize the CORBA GIOP for high-speed networks (e.g., ATM LANs and ATM/IP WANs) <ref> [16] </ref> and can be customized for specific application requirements. For instance, certain applications that do not require complete reliability (e.g., teleconferencing or certain types of imaging). In this case, TAO can selectively omit transport layer functionality (such as retransmis-sions and end-to-end error handling) and run directly atop ATM or ATM/IP.
Reference: [17] <author> D. D. Clark and D. L. Tennenhouse, </author> <title> Architectural Considerations for a New Generation of Protocols, </title> <booktitle> in Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), </booktitle> <address> (Philadelphia, PA), </address> <pages> pp. 200-208, </pages> <publisher> ACM, </publisher> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: In this case, TAO can selectively omit transport layer functionality (such as retransmis-sions and end-to-end error handling) and run directly atop ATM or ATM/IP. Our GIOP transport layer tightly integrates the underlying ATM/IP infrastructure via techniques such as ALF/ILP <ref> [17] </ref>, our Gigabit I/O subsystem [18, 19, 20, 21], and the APIC [15] network adapter. 4.3 Real-Time Object Adapter The Object Adapter is the component in CORBA that associates object implementations with the ORB and delivers requests to the appropriate target object.
Reference: [18] <author> C. Cranor, </author> <title> OS Buffer Management System for Continuous Media I/O, </title> <type> tech. rep., </type> <institution> Washington University Department of Computer Science, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: In this case, TAO can selectively omit transport layer functionality (such as retransmis-sions and end-to-end error handling) and run directly atop ATM or ATM/IP. Our GIOP transport layer tightly integrates the underlying ATM/IP infrastructure via techniques such as ALF/ILP [17], our Gigabit I/O subsystem <ref> [18, 19, 20, 21] </ref>, and the APIC [15] network adapter. 4.3 Real-Time Object Adapter The Object Adapter is the component in CORBA that associates object implementations with the ORB and delivers requests to the appropriate target object.
Reference: [19] <author> C. Cranor and G. Parulkar, </author> <title> Design of Universal Continuous Media I/O, </title> <booktitle> in Proceedings of the 5th International Workshop on Network and Operating Systems Support for Digital Audio and Video (NOSSDAV '95), </booktitle> <address> (Durham, New Hampshire), </address> <pages> pp. 83-86, </pages> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: In this case, TAO can selectively omit transport layer functionality (such as retransmis-sions and end-to-end error handling) and run directly atop ATM or ATM/IP. Our GIOP transport layer tightly integrates the underlying ATM/IP infrastructure via techniques such as ALF/ILP [17], our Gigabit I/O subsystem <ref> [18, 19, 20, 21] </ref>, and the APIC [15] network adapter. 4.3 Real-Time Object Adapter The Object Adapter is the component in CORBA that associates object implementations with the ORB and delivers requests to the appropriate target object.
Reference: [20] <author> R. Gopalakrishnan and G. M. Parulkar, </author> <title> Efficient User Space Protocol Implementations with QoS Guarantees using Real-time Upcalls, </title> <type> Tech. Rep. 96-11, </type> <institution> Washington University Department of Computer Science, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: In this case, TAO can selectively omit transport layer functionality (such as retransmis-sions and end-to-end error handling) and run directly atop ATM or ATM/IP. Our GIOP transport layer tightly integrates the underlying ATM/IP infrastructure via techniques such as ALF/ILP [17], our Gigabit I/O subsystem <ref> [18, 19, 20, 21] </ref>, and the APIC [15] network adapter. 4.3 Real-Time Object Adapter The Object Adapter is the component in CORBA that associates object implementations with the ORB and delivers requests to the appropriate target object.
Reference: [21] <author> R. Gopalakrishnan and G. M. Parulkar, </author> <title> Real-time Upcalls: </title>
Reference-contexts: In this case, TAO can selectively omit transport layer functionality (such as retransmis-sions and end-to-end error handling) and run directly atop ATM or ATM/IP. Our GIOP transport layer tightly integrates the underlying ATM/IP infrastructure via techniques such as ALF/ILP [17], our Gigabit I/O subsystem <ref> [18, 19, 20, 21] </ref>, and the APIC [15] network adapter. 4.3 Real-Time Object Adapter The Object Adapter is the component in CORBA that associates object implementations with the ORB and delivers requests to the appropriate target object.
References-found: 21

