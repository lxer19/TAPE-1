URL: http://www.cs.wustl.edu/~schmidt/LCTES-99.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: http://www.cs.wustl.edu
Email: gokhale@research.bell-labs.com fschmidt,coryan,alexg@cs.wustl.edu  
Title: The Design and Performance of a OMG CORBA IDL Compiler Optimized for Embedded Systems at
Author: Aniruddha Gokhale Douglas C. Schmidt, Carlos O'Ryan, Alexander Arulanthu 
Note: First-generation CORBA middleware was reasonably successful  
Address: 600 Mountain Ave Rm 2B-434 Campus Box 1045 Murray Hill, NJ 07974 St. Louis, MO 63130  
Affiliation: Bell Labs, Lucent Technologies Washington University  
Abstract: This paper was submitted to the LCTES '99 workshop at PLDI, Atlanta, Georgia, May 1-4, 1999. Abstract This paper provides two contributions to the design and optimization of OMG IDL compilers for embedded systems. First, we illustrate how the IDL compiler for TAO, our real-time CORBA implementation, has been optimized to support stringent time and space requirements of real-time embedded systems. Second, we describe the results of benchmarks that compare the impact of alternative IDL compiler code optimization strategies on the efficiency, predictability, and scalability of real-time ORBs. Our results indicate that an ORB's IDL compiler must be highly configurable and adaptable to meet the QoS requirements for a wide range of embedded applications. In addition, we show how TAO's IDL compiler can be configured to perform predictably and scalably, which is essential to support real-time embedded applications. Keywords: CORBA Middleware, Design Patterns, Tools, Performance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.2 ed., </editor> <month> Feb. </month> <year> 1998. </year>
Reference-contexts: Ideally, these applications can be developed using standard middleware components, such as the Object Management Group's (OMG) Common Object Request Broker Architecture (CORBA) <ref> [1] </ref>, to improve their quality and reduce their cost and cycle time. However, stringent constraints on memory available in embedded systems imposes a severe limit on the footprint of CORBA middleware. <p> BACK END Generated AST DRIVER FRONT END PARSER AST Generator Generated Code IDL Definition TAO IDL Compiler interface Test_Param - short test_short (in short x); -; :be_root :be_interface :be_operation :be_argument :be_primitive :be_primitive .... class Test_Param - public: virtual CORBA::Short test_short (CORBA::Short x); ..... -; Compiler AST and generates CORBA 2.2-compliant <ref> [1] </ref> C++ source code. <p> In contrast, the TAO IDL compiler automatically generates stubs that use interpretive (de)marshaling. Algorithm overview for interpreted skeletons: The SunSoft IIOP skeletons use a dynamic skeleton interface (DSI) <ref> [1] </ref> approach to unmarshal parameters. An intuitive, though non 3 optimal, algorithm for an interpreted skeleton is shown in Fig- ure 5.
Reference: [2] <institution> Object Management Group, </institution> <note> Minimum CORBA Joint Revised Submission, OMG Document orbos/98-08-04 ed., </note> <month> August </month> <year> 1998. </year>
Reference-contexts: The issue of limitations on the footprint of the ORB Core for embedded systems is addressed by the OMG's Minimum CORBA <ref> [2] </ref> specification. However, there is no standard specification for minimizing the footprint of IDL compiler-generated stubs and skeletons.
Reference: [3] <author> D. C. Schmidt, D. L. Levine, and S. Mungee, </author> <title> The Design and Performance of Real-Time Object Request Brokers, </title> <journal> Computer Communications, </journal> <volume> vol. 21, </volume> <pages> pp. 294324, </pages> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: In this paper, therefore, we describe the optimization techniques we use to address this issue in the IDL compiler implementation for The ACE ORB (TAO), which is an open source, high-performance, and real-time CORBA implementation developed at Washington University <ref> [3] </ref>. A compiler for the OMG IDL parses IDL files containing CORBA interfaces and data types, and generates stubs and skeletons that marshal and demarshal data types, respectively, as shown in Figure 1.
Reference: [4] <author> E. Eide, K. Frei, B. Ford, J. Lepreau, and G. Lindstrom, </author> <month> Flick: </month>
Reference-contexts: For embedded applications, particularly ones with real-time QoS requirements, it is essential for ORB operation demultiplexing to be efficient, predictable, and scalable. Stubs/skeletons that use compiled (de)marshaling can achieve high efficiency at the cost of increased memory footprint <ref> [4] </ref>. Conversely, interpretive (de)marshaling is useful for applications that can trade less efficiency for a smaller memory footprint [5]. <p> According to the SunSoft IIOP developers, interpretive marshaling is preferable since it decreases code size and increases the likelihood of remaining in the processor cache. Our goal is to generate efficient stubs and skeletons by extending optimizations provided in USC [13] and Flick <ref> [4] </ref>, which is a flexible, optimizing IDL compiler. Flick uses an innovative scheme where intermediate representations guide the generation of optimized stubs.
References-found: 4

