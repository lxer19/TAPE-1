URL: http://www.cs.mu.oz.au/tr_db/mu_95_18.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Email: fkemp,raog@cs.mu.OZ.AU  
Title: A Deductive Database Solution to the Preferential Vote Counting Problem  
Author: David B. Kemp and Kotagiri Ramamohanarao 
Date: August 1994  
Address: Parkville 3052, Australia  
Affiliation: Department of Computer Science, University of Melbourne  
Abstract: To solve many complex database problems it is necessary to use recursive aggre-gatation. However, most existing deductive database implementations either cannot handle recursive aggregation, or do so in a very inefficient manner. To address this problem, efficient evaluation techniques were recently proposed in [5] for a class of programs called EMS-programs. We demonstrate the power of these techniques by solving a complex problem | the problem of vote counting in a preferential election system.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> I. Balbin and K. Ramamohanarao. </author> <title> A generalization of the differential approach to recursive query evaluation. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(3) </volume> <pages> 259-262, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: As usual, we are treating any term of the form s i (0) as the integer i. Note that, for a given i and l, the computation of i;l " ! can use an obvious adaptation of the "differential" or "semi-naive" techniques presented in <ref> [1] </ref> and [2]. Example 2 Here we show how to use to evaluate the `win' program for predicates win and mayW in. We use plevel (win) = 1 and plevel (mayW in) = 2. <p> To achieve the level of efficiency that would be expected of a good deductive database compiler, it was necessary to hand code some of the `optimization' techniques such as differential evaluation <ref> [1, 2] </ref>. The following empirical results were obtained on a SPARCserver 1000 with 4 50 MHz SuperSPARC processors and 256 megabytes of main memory. Although this machine has four processors, our translation of the program does not exploit this available parallelism.
Reference: [2] <author> F. Bancilhon. </author> <title> Naive evaluation of recursively defined relations. </title> <editor> In M. Brodie and J. Mylopoulos, editors, </editor> <booktitle> On knowledge-base management systems integrating database and AI systems, </booktitle> <pages> pages 165-178. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986. </year> <note> Also appeared in the Proceedings of the Islamadora Conference on Databases and AI, </note> <year> 1985. </year>
Reference-contexts: As usual, we are treating any term of the form s i (0) as the integer i. Note that, for a given i and l, the computation of i;l " ! can use an obvious adaptation of the "differential" or "semi-naive" techniques presented in [1] and <ref> [2] </ref>. Example 2 Here we show how to use to evaluate the `win' program for predicates win and mayW in. We use plevel (win) = 1 and plevel (mayW in) = 2. <p> To achieve the level of efficiency that would be expected of a good deductive database compiler, it was necessary to hand code some of the `optimization' techniques such as differential evaluation <ref> [1, 2] </ref>. The following empirical results were obtained on a SPARCserver 1000 with 4 50 MHz SuperSPARC processors and 256 megabytes of main memory. Although this machine has four processors, our translation of the program does not exploit this available parallelism.
Reference: [3] <institution> Australian Electoral Commission. </institution> <note> Fact Sheet , 1993. Also obtained from the AEC: Commonwealth electoral procedures 1992, and Electoral pocket book 1991. </note>
Reference-contexts: First we give a brief | and slightly simplified | summary of Australia's system of government. More details can be obtained from the Australian Electoral Commission <ref> [3] </ref>. Australia is governed by two houses of parliament: a House of Representatives and a Senate. For the purposes of choosing members of the House of Representatives, Australia's physical area is divided into 147 non-overlapping electoral divisions | each with a roughly similar population size. <p> There is room for improvement. According to the Australian Electoral Commission, 19 it is often possible to eliminate more than one candidate before redistributing their votes <ref> [3] </ref>. <p> The situation is very different in a typical senate election. According to the Australian Electoral Commission, for the federal election in 1990, 91.4% of voters used the top-half of the senate ballot paper <ref> [3] </ref>. Furthermore, more than 62% of voters selected as a first preference candidates from the two largest political parties.
Reference: [4] <author> David B. Kemp and Kotagiri Ramamohanarao. </author> <title> Syntactically recognizable modularly stratified programs. </title> <type> Technical report 93/15, </type> <institution> University of Melbourne, </institution> <address> Mel-bourne, Australia, </address> <year> 1993. </year>
Reference-contexts: We present techniques for evaluating the entire well-founded model of EMS-programs. Specialization of the program with respect to the query can be achieved using a restricted form of the magic sets transformation (see <ref> [4] </ref> for details). We start with a simple, yet effective technique, and then show how, for a large number of cases, further improvements can be made.
Reference: [5] <author> David B. Kemp and Kotagiri Ramamohanarao. </author> <title> Syntactically recognizable modularly stratified programs. </title> <booktitle> In Proceedings of the 5th Australasian Database Conference, </booktitle> <pages> pages 147-161, </pages> <month> January </month> <year> 1994. </year> <note> An extended version of this paper has been written as University of Melbourne, Computer Science Department Technical Report 93/15. </note>
Reference-contexts: 1 Introduction Efficient evaluation techniques have been developed for a class of programs that are modularly stratified [13] in a very explicit manner | these are called EMS-programs (Explicitly Modularly Stratified) <ref> [5] </ref>. Although the syntactic conditions that EMS-programs must satisfy are very strict, the conditions are independent of the extensional database (EDB) and, as shown by the large example given in Section 5, it is quite easy to express very complex problems in this manner 1 . <p> Simpler examples of EMS-programs are contained in <ref> [5] </ref> and in the extended technical report version of [5]: including solutions to the `shortest-distance', and `company ownership' problems. <p> Simpler examples of EMS-programs are contained in <ref> [5] </ref> and in the extended technical report version of [5]: including solutions to the `shortest-distance', and `company ownership' problems. <p> We make one further restriction: the variables N and N 0 must only occur in strata-level arguments or in atoms of the form N 0 s N . / Note that this definition differs slightly from the one we gave in <ref> [5] </ref>. Unlike the definition we have just given, [5] allows the variable N 0 to appear in an aggregate subgoal. We have found that this is not very useful and have simplified the definition by not allowing it. <p> We make one further restriction: the variables N and N 0 must only occur in strata-level arguments or in atoms of the form N 0 s N . / Note that this definition differs slightly from the one we gave in <ref> [5] </ref>. Unlike the definition we have just given, [5] allows the variable N 0 to appear in an aggregate subgoal. We have found that this is not very useful and have simplified the definition by not allowing it. <p> As a result, EMS-programs are more general than XY-Programs. An instance of this difference is the definition of the predicate nextPref presented in Section 5. 4 Evaluation of EMS-programs In this section, we consider evaluation methods for EMS-programs. Details and proofs can be found in <ref> [5] </ref>. Various query evaluation techniques have been developed for general programs (see for example [7]) and for programs that are modularly stratified (see for example [13]). These techniques suffer from various problems. <p> What we are aiming to do is to evaluate each local stratum one at a time, and it is the strata-level arguments that allow us to do this. We assume predicate level numbers have been determined; an efficient way of doing this is given in <ref> [5] </ref>. To simplify the presentation, we assume the predicate level numbers chosen are consecutive integers starting from 1. Once we know what each predicate's predicate level number is, we can start computing the program's well-founded model. <p> For all i 1: and fX : mayW in (X; i) 2 i;2 " !g = fX : mayW in (X; i + 1) 2 i+1;2 " !g and so there is no need to continue the computation. Proposition 1 <ref> [5] </ref> If P is a EMS-program, then the well-founded model of P is given by: [ 1l#plevels i;l " ! If the query for the above example is ` win (X; )', then there are a few things that can be done to ensure a reasonably efficient computation. <p> The following proposition formalizes this concept. Let the function project out strata-level arguments. For example: (fwin (m; s (0)); win (n; s (0))g) = fwin (m); win (n)g Proposition 2 <ref> [5] </ref> Suppose P is a EMS-program.
Reference: [6] <author> David B. Kemp and Peter J. Stuckey. </author> <title> Semantics of logic programs with aggregates. </title> <booktitle> In Proceedings of the 1991 International Symposium on Logic Programming, </booktitle> <pages> pages 387-401, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The terminology and definitions used for aggregates are the same as those given in <ref> [6] </ref>, which was, in turn, based on work done by others on the semantics of negation and aggregates (such as [17] and [11]). In some of our examples, program rules might contain expressions more complex than conjunctions of literals.
Reference: [7] <author> David B. Kemp, Peter J. Stuckey, and Divesh Srivastava. </author> <title> Bottom-up evaluation and query optimization of well-founded models. To appear in Theoretical Computer Science. This is an extension of two separate pieces of work by the same authors: </title> <booktitle> "Magic sets and bottom-up evaluation of well-founded models" in Proceedings of the 1991 International Symposium on Logic Programming, pages 336-351; and "Query restricted bottom-up evaluation in normal form logic" in Proceedings of the 1992 Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 288-302. </pages>
Reference-contexts: Details and proofs can be found in [5]. Various query evaluation techniques have been developed for general programs (see for example <ref> [7] </ref>) and for programs that are modularly stratified (see for example [13]). These techniques suffer from various problems. Some, such as those proposed in [7], only deal with programs containing negation, and they do not extend well to programs containing aggregation. <p> Details and proofs can be found in [5]. Various query evaluation techniques have been developed for general programs (see for example <ref> [7] </ref>) and for programs that are modularly stratified (see for example [13]). These techniques suffer from various problems. Some, such as those proposed in [7], only deal with programs containing negation, and they do not extend well to programs containing aggregation.
Reference: [8] <author> Phokion G. Kolaitis and Christos H. Papadimitriou. </author> <booktitle> Why not negation by fixpoint ? In Proceedings of the Seventh ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 231-239, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: following program is an example of an EMS-program. win (X; s (N )) edge (X; Y ); : mayW in (Y; N ) mayW in (X; N ) edge (X; Y ); : win (Y; N ) This is a different approach to solving the game playing program given in <ref> [8] </ref>. The intended meaning is that win (X; N ) is true if X is a winning position within 2N 1 moves. <p> The local stratification of this program is independent of the edge relation. Unlike the one line program given in <ref> [8] </ref>, our version of win will always have a two-valued well-founded model even when the edge relation represents a graph with cycles. If it does contain cycles, then it is possible that some nodes will be in the mayW in relation, but not in the win relation.
Reference: [9] <author> J.W. Lloyd. </author> <booktitle> Foundations of logic programming. Springer Series in Symbolic Computation. </booktitle> <publisher> Springer Verlag, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1987. </year>
Reference-contexts: 1 This paper extends the work in the paper of the same title presented at the Second ICLP-Workshop on deductive databases, June 1994, pages 143-158. 1 2 Terminology Where possible, we usually use the standard terminology and definitions for logic programs and deductive databases similar to those found in Lloyd <ref> [9] </ref> and in Ullman [14, 15]. The terminology and definitions used for aggregates are the same as those given in [6], which was, in turn, based on work done by others on the semantics of negation and aggregates (such as [17] and [11]).
Reference: [10] <author> J.W. Lloyd and R.W. Topor. </author> <title> Making prolog more expressive. </title> <journal> Journal of Logic Programming, </journal> <volume> 1(3) </volume> <pages> 225-240, </pages> <year> 1984. </year>
Reference-contexts: Much of the deductive database literature does not consider expressions such as `: 9 X a (X; Y )' or, equivalently, `not some X a (X,Y)'. We expect a transformation to normal form to be performed using techniques like those given in <ref> [10] </ref>. The expression `: 9 X a (X; Y )' would be replaced with `:a 0 (Y )' and a rule `a 0 (Y ) a (X; Y )'.
Reference: [11] <author> Inderpal Singh Mumick, Hamid Pirahesh, and Raghu Ramakrishnan. </author> <title> The magic of duplicates and aggregates. </title> <booktitle> In Proceedings of the Sixteenth Conference on Very Large Databases, </booktitle> <pages> pages 264-277, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: The terminology and definitions used for aggregates are the same as those given in [6], which was, in turn, based on work done by others on the semantics of negation and aggregates (such as [17] and <ref> [11] </ref>). In some of our examples, program rules might contain expressions more complex than conjunctions of literals. Much of the deductive database literature does not consider expressions such as `: 9 X a (X; Y )' or, equivalently, `not some X a (X,Y)'.
Reference: [12] <author> Teodor C. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1988. </year>
Reference-contexts: This can be used to model a game in which two players take turns to move an object one edge at a time around a directed graph a player loses when the player cannot move the object any further. This program is locally stratified <ref> [12] </ref> as the Herbrand base can be divided into local strata H 1 ; H 2 ; : : : as follows.
Reference: [13] <author> Ken A. Ross. </author> <title> Modular stratification and magic sets for DATALOG programs with negation. </title> <booktitle> In Proceedings of the Ninth ACM PODS Symposium on Principles of Database Systems, </booktitle> <pages> pages 161-171, </pages> <year> 1990. </year> <title> An extended version of this paper, containing new results, was obtained from the author. </title>
Reference-contexts: 1 Introduction Efficient evaluation techniques have been developed for a class of programs that are modularly stratified <ref> [13] </ref> in a very explicit manner | these are called EMS-programs (Explicitly Modularly Stratified) [5]. <p> Details and proofs can be found in [5]. Various query evaluation techniques have been developed for general programs (see for example [7]) and for programs that are modularly stratified (see for example <ref> [13] </ref>). These techniques suffer from various problems. Some, such as those proposed in [7], only deal with programs containing negation, and they do not extend well to programs containing aggregation. Existing techniques that are specialized to modularly stratified programs, such as the techniques given in [13], build tables of dependencies between <p> modularly stratified (see for example <ref> [13] </ref>). These techniques suffer from various problems. Some, such as those proposed in [7], only deal with programs containing negation, and they do not extend well to programs containing aggregation. Existing techniques that are specialized to modularly stratified programs, such as the techniques given in [13], build tables of dependencies between atoms | they effectively discover the local strata of atoms at runtime, and this is an unnecessary overhead for EMS-programs.
Reference: [14] <author> J.D. Ullman. </author> <title> Principles of database and knowledge-base systems, vol. I. </title> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: the work in the paper of the same title presented at the Second ICLP-Workshop on deductive databases, June 1994, pages 143-158. 1 2 Terminology Where possible, we usually use the standard terminology and definitions for logic programs and deductive databases similar to those found in Lloyd [9] and in Ullman <ref> [14, 15] </ref>. The terminology and definitions used for aggregates are the same as those given in [6], which was, in turn, based on work done by others on the semantics of negation and aggregates (such as [17] and [11]).
Reference: [15] <author> J.D. Ullman. </author> <title> Principles of database and knowledge-base systems, vol. II: The new technologies. </title> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: the work in the paper of the same title presented at the Second ICLP-Workshop on deductive databases, June 1994, pages 143-158. 1 2 Terminology Where possible, we usually use the standard terminology and definitions for logic programs and deductive databases similar to those found in Lloyd [9] and in Ullman <ref> [14, 15] </ref>. The terminology and definitions used for aggregates are the same as those given in [6], which was, in turn, based on work done by others on the semantics of negation and aggregates (such as [17] and [11]).
Reference: [16] <author> Jayen Vaghani, Kotagiri Ramamohanarao, David B. Kemp, Zoltan Somogyi, Peter J. Stuckey, Tim S. Leask, and James Harland. </author> <title> The Aditi deductive database system. </title> <journal> The VLDB Journal, </journal> <volume> 3(2) </volume> <pages> 245-288, </pages> <year> 1994. </year>
Reference-contexts: in the preferential election system used for the Australian senate | possibly the most complex electoral system ever devised! In Section 6 we analyse the efficiency of our EMS-program, and in Section 7 we describe the performance of the program when it is run on the Aditi deductive database system <ref> [16] </ref>. 1 This paper extends the work in the paper of the same title presented at the Second ICLP-Workshop on deductive databases, June 1994, pages 143-158. 1 2 Terminology Where possible, we usually use the standard terminology and definitions for logic programs and deductive databases similar to those found in Lloyd <p> Aditi-RL is the target language of the compiler for the Aditi deductive database system <ref> [16] </ref>; we intend enhancing the compiler so that it can correctly compile EMS-programs.
Reference: [17] <author> A. van Gelder, K. A. Ross, and J. S. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year> <title> A preliminary version of this paper appeared as "Unfounded sets and well-founded semantics of general logic programs", </title> <booktitle> in Proceedings of the Seventh ACM PODS Symposium on Principles of Database Systems, </booktitle> <pages> pages 221-230, </pages> <year> 1988. </year>
Reference-contexts: The terminology and definitions used for aggregates are the same as those given in [6], which was, in turn, based on work done by others on the semantics of negation and aggregates (such as <ref> [17] </ref> and [11]). In some of our examples, program rules might contain expressions more complex than conjunctions of literals. Much of the deductive database literature does not consider expressions such as `: 9 X a (X; Y )' or, equivalently, `not some X a (X,Y)'.
Reference: [18] <author> Carlo Zaniolo, Natraj Arni, and Kayliang Ong. </author> <title> Negation and aggregates in recursive rules: the LDL + + approach. </title> <booktitle> In Proceedings of the Third International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 204-221, </pages> <month> December </month> <year> 1993. </year> <month> 23 </month>
Reference-contexts: In general, we will require that queries never request values for strata-level arguments. The class of EMS-programs is very similar to the class of XY-Programs independently proposed by Zaniolo, Arni, and Ong <ref> [18] </ref>. The strata-level arguments of EMS-programs have the same purpose as the stage arguments of [18]. <p> In general, we will require that queries never request values for strata-level arguments. The class of EMS-programs is very similar to the class of XY-Programs independently proposed by Zaniolo, Arni, and Ong <ref> [18] </ref>. The strata-level arguments of EMS-programs have the same purpose as the stage arguments of [18]. The main difference is that EMS-programs allow a rule whose head atom has `N ' as a strata-level argument to contain positive body atoms with the same predicate as the head to also contain `N ' as a strata-level argument. As a result, EMS-programs are more general than XY-Programs. <p> Due to many of the similarities between EMS-programs and XY-stratified programs some of the optimization techniques presented in <ref> [18] </ref> can also be applied to EMS-programs. 5 Preferential vote counting For the remainder of this paper, we consider the problem of determining which candidates have secured seats in the preferential election system used for the Australian 7 senate.
References-found: 18

