URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-94-10.ps.Z
Refering-URL: ftp://ftp.cs.caltech.edu/tr/INDEX.html
Root-URL: http://www.cs.caltech.edu
Title: KRML 29 -0 Computing permutation encodings Consider an encoding B of A defined as A:i
Author: K. Rustan M. Leino p p p p p p p p p p p p p p p p p p p p p p B:i h j j &lt; i A:j &lt; A:j &lt; C :i h j j &lt; i A:j &gt; 
Keyword: 0 Overview 0.0 Permutation encodings  
Address: Pasadena, CA 91125, U.S.A. in  
Affiliation: California Institute of Technology,  
Note: Computer Science, Mail code 256-80,  For the rest of this section, i will implicitly be universally quantified over 0 i &lt; N  A:i i (2) Due to (0), a relationship between B and C is B:i C :i i  0 Supported in part by a research grant from the Digital Equipment Corporation Systems Research Center.  
Email: rustan@cs.caltech.edu  
Date: 27 May 1994  (3)  
Abstract: We consider some encodings of permutations of the first N natural numbers, discuss some relations among them and how one can be computed from others. We show a short proof of an existing efficient algorithm for one encoding, and present two new efficient algorithms for encoding permutations. One of these algorithms is constructed as the inverse of an existing algorithm for decoding, making it the first efficient permutation encoding algorithm obtained that way. Let A be a permutation of the first N natural numbers. For any i such that 0 i &lt; N , we let A:i denote element i of the permutation. As the elements of A are unique, we have, for all i ; j such that 0 i j &lt; N , from which we see that one can compute B from C or C from B in time O(N ) . 
Abstract-found: 1
Intro-found: 1
Reference: [0] <author> W. Chen and J.T. Udding. </author> <title> Program inversion: More than fun! Science of Computer Programming, </title> <booktitle> 15 </booktitle> <pages> 1-13, </pages> <year> 1990. </year>
Reference-contexts: This is because the only reference to an element of a occurs in one of the base cases. 2.4 Inverting the program In this section, we touch on the rules for program inversion (see <ref> [1, 2, 0] </ref>) and show how our final program from Figure 5 can be inverted. We do so by explaining how to invert an assignment statement, sequential composition, if statements, and do statements. <p> The time needed to compute ff ffi fi is then linear in the length of fffi . We display this algorithm, called circ , in Figure 7. Knuth leaves to the reader, and so do we, to verify that ffi is associative and that <ref> [E :0; 0] </ref> ffi [E :1; 1] ffi ffi [E :(N 1); N 1] = [0; A:0][0; A:1] [0; A:(N 1)] ; (24) where A and E are those from Section 0. Because ffi is associative, we can compute the ffi operators of (LHS-24) in any order. <p> We display this algorithm, called circ , in Figure 7. Knuth leaves to the reader, and so do we, to verify that ffi is associative and that [E :0; 0] ffi [E :1; 1] ffi ffi [E :(N 1); N 1] = <ref> [0; A:0] </ref>[0; A:1] [0; A:(N 1)] ; (24) where A and E are those from Section 0. Because ffi is associative, we can compute the ffi operators of (LHS-24) in any order. <p> We display this algorithm, called circ , in Figure 7. Knuth leaves to the reader, and so do we, to verify that ffi is associative and that [E :0; 0] ffi [E :1; 1] ffi ffi [E :(N 1); N 1] = [0; A:0][0; A:1] <ref> [0; A:(N 1)] </ref> ; (24) where A and E are those from Section 0. Because ffi is associative, we can compute the ffi operators of (LHS-24) in any order.
Reference: [1] <author> E.W. Dijkstra. </author> <title> Program Inversion. </title> <type> EWD 671, </type> <institution> Technological University Eindhoven, </institution> <year> 1978. </year> <title> Published in Selected Writings on Computing: a Personal Perspective. </title> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: This is because the only reference to an element of a occurs in one of the base cases. 2.4 Inverting the program In this section, we touch on the rules for program inversion (see <ref> [1, 2, 0] </ref>) and show how our final program from Figure 5 can be inverted. We do so by explaining how to invert an assignment statement, sequential composition, if statements, and do statements. <p> It is very reasonable that s be part of the input to a program that computes an array from its code, because the code only contains ordering information, not the array numbers themselves. The programs in <ref> [1, 2] </ref> require that the given array consists of a permutation of the first N natural numbers; hence, s is implied, and can be omitted. Our program, on the other hand, allows a to be any array of distinct integers. <p> The time needed to compute ff ffi fi is then linear in the length of fffi . We display this algorithm, called circ , in Figure 7. Knuth leaves to the reader, and so do we, to verify that ffi is associative and that [E :0; 0] ffi <ref> [E :1; 1] </ref> ffi ffi [E :(N 1); N 1] = [0; A:0][0; A:1] [0; A:(N 1)] ; (24) where A and E are those from Section 0. Because ffi is associative, we can compute the ffi operators of (LHS-24) in any order. <p> Both algorithms have running time O (N log N ) and use linear space. The concept of program inversion has been applied to several problems, including computing the code of a permutation, which was the example application used in the introduction of the concept <ref> [1] </ref>. We obtained one of our algorithms as an inverse of an existing algorithm, hence introducing the first efficient algorithm obtained in that way for a permutation encoding algorithm. Acknowledgements The two algorithms in Section 1 were developed jointly with Paolo A.G. Sivilotti.
Reference: [2] <editor> D. Gries. </editor> <booktitle> The Science of Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: This is because the only reference to an element of a occurs in one of the base cases. 2.4 Inverting the program In this section, we touch on the rules for program inversion (see <ref> [1, 2, 0] </ref>) and show how our final program from Figure 5 can be inverted. We do so by explaining how to invert an assignment statement, sequential composition, if statements, and do statements. <p> It is very reasonable that s be part of the input to a program that computes an array from its code, because the code only contains ordering information, not the array numbers themselves. The programs in <ref> [1, 2] </ref> require that the given array consists of a permutation of the first N natural numbers; hence, s is implied, and can be omitted. Our program, on the other hand, allows a to be any array of distinct integers.
Reference: [3] <author> E.C.R. Hehner. </author> <title> A Practical Theory of Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: We use the notation m::; n to mean the n m integers beginning at m , that is, m; m + 1; : : :; n 1 . (This notation is a variation of the one used in <ref> [3] </ref>.) We also use ++ as the operator that concatenates two lists. An empty list is denoted " , and we do not distinguish between an integer and a list containing one integer.
Reference: [4] <author> D.E. Knuth. </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. </volume> <month> 3: </month> <title> Sorting and searching. </title> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
References-found: 5

