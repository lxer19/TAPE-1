URL: http://www.cs.nyu.edu/phd_students/zheyang/papers/type-encoding.icfp98.ps
Refering-URL: http://www.cs.nyu.edu/phd_students/zheyang/papers.html
Root-URL: http://www.cs.nyu.edu
Email: E-mail: zheyang@cs.nyu.edu  
Title: Encoding Types in ML-like Languages  
Author: Zhe Yang 
Address: New York University 251 Mercer Street, New York, NY 10012, USA  
Affiliation: Department of Computer Science  
Abstract: A Hindley-Milner type system such as ML's seems to prohibit type-indexed values, i.e., functions that map a family of types to a family of values. Such functions generally perform case analysis on the input types and return values of possibly different types. The goal of our work is to demonstrate how to program with type-indexed values within a Hindley-Milner type system. Our first approach is to interpret an input type as its corresponding value, recursively. This solution is type-safe, in the sense that the ML type system statically prevents any mismatch between the input type and function arguments that depend on this type. Such specific type interpretations, however, prevent us from combining different type-indexed values that share the same type. To meet this objection, we focus on finding a value-independent type encoding that can be shared by different functions. We propose and compare two solutions. One requires first-class and higher-order polymor-phism, and, thus, is not implementable in the core language of ML, but it can be programmed using higher-order func-tors in Standard ML of New Jersey. Its usage, however, is clumsy. The other approach uses embedding/projection functions. It appears to be more practical. We demonstrate the usefulness of type-indexed values through examples including type-directed partial evaluation, C printf-like formatting, and subtype coercions. Finally, we discuss the tradeoffs between our approach and some other solutions based on more expressive typing disciplines. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martin Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin. </author> <title> Dynamic typing in a statically typed language. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 237-268., </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: In the following sections, we briefly go through some of these frameworks that provide solutions to type-indexed values. 5.1.1 Dynamic typing Realizing that static typing is too restrictive in some cases, there is a line of work on adding dynamic typing <ref> [1, 2] </ref> to languages with static type systems. Such an approach introduces a universal type Dynamic along with two operations for constructing values of type Dynamic and inspecting the type tag attached to these values.
Reference: [2] <author> Martin Abadi, Luca Cardelli, Benjamin Pierce, and Di-dier Remy. </author> <title> Dynamic typing in polymorphic languages. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(1) </volume> <pages> 111-130, </pages> <month> Jan-uary </month> <year> 1995. </year>
Reference-contexts: let fun reify v = let val x1 = Gensym.fresh "x" in LAM (x1, reify_2 (v (reflect_1 (VAR x1)))) end fun reflect e = fn v1 =&gt; reflect_2 (APP (e, reify_1 (v1))) in (reify, reflect) end fun reify (T as (reify_T, reflect_T)) v = reify_T v flatten (List (List Int)) <ref> [[1, 2] </ref>, [], [3], [4, 5]] evaluates to [1,2,3,4,5]. We apply the same method to program type-directed partial evaluation (Figure 4) using the type interpretation [[t ]] = (#; ") t defined in Figure 3. <p> In the following sections, we briefly go through some of these frameworks that provide solutions to type-indexed values. 5.1.1 Dynamic typing Realizing that static typing is too restrictive in some cases, there is a line of work on adding dynamic typing <ref> [1, 2] </ref> to languages with static type systems. Such an approach introduces a universal type Dynamic along with two operations for constructing values of type Dynamic and inspecting the type tag attached to these values.
Reference: [3] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In Jan Maluszynski and Martin Wirsing, editors, </editor> <booktitle> Third International Symposium on Programming Language Implementation and Logic Programming, number 528 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-13, </pages> <address> Passau, Germany, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: This gives rise to a Martin-Lof-style encoding of inductive types. The encoding uses first-class polymorphism and higher-order poly-morphism, and can be implemented using the higher-order module language of Standard ML of New Jersey <ref> [3] </ref>. 2. A type is encoded as the embedding and projection functions between verbatim values of that type and tagged values of a universal datatype. <p> v = let val x1 = Gensym.fresh "x" in LAM (x1, reify_2 (v (reflect_1 (VAR x1)))) end fun reflect e = fn v1 =&gt; reflect_2 (APP (e, reify_1 (v1))) in (reify, reflect) end fun reify (T as (reify_T, reflect_T)) v = reify_T v flatten (List (List Int)) [[1, 2], [], <ref> [3] </ref>, [4, 5]] evaluates to [1,2,3,4,5]. We apply the same method to program type-directed partial evaluation (Figure 4) using the type interpretation [[t ]] = (#; ") t defined in Figure 3. <p> To recast the higher-order functions in Figure 6 into functors, we also need to use higher-order functors which allows functors to have functor arguments or results. Such higher-order func-tors [31] are supported by Standard ML of New Jersey <ref> [3] </ref>.
Reference: [4] <editor> William Clinger and Jonathan Rees, editors. </editor> <title> Revised 4 report on the algorithmic language Scheme. LISP Pointers, </title> <address> IV(3):1-55, </address> <month> July-September </month> <year> 1991. </year>
Reference-contexts: The simplicity of the type system, however, also restricts the class of typeable programs. For example, one cannot examine the type of a value at run-time, as in a dynamically typed language such as Scheme <ref> [4] </ref>. Functions that take type arguments and accordingly return values of possibly different types are used frequently in abstract formulations of certain algorithms. Such functions form an interesting class of programs that seem to be forbidden by the Hindley-Milner type system. <p> = let val x1 = Gensym.fresh "x" in LAM (x1, reify_2 (v (reflect_1 (VAR x1)))) end fun reflect e = fn v1 =&gt; reflect_2 (APP (e, reify_1 (v1))) in (reify, reflect) end fun reify (T as (reify_T, reflect_T)) v = reify_T v flatten (List (List Int)) [[1, 2], [], [3], <ref> [4, 5] </ref>] evaluates to [1,2,3,4,5]. We apply the same method to program type-directed partial evaluation (Figure 4) using the type interpretation [[t ]] = (#; ") t defined in Figure 3.
Reference: [5] <author> Olivier Danvy. </author> <title> Type-directed partial evaluation. </title> <booktitle> In Steele [29], </booktitle> <pages> pages 242-257. </pages>
Reference-contexts: At first glance, their definitions do not fit into our canonical form of type-indexed values; however, pairing the two functions at each type index puts the definition into the standard form of a type-indexed value (Figure 3). In his article <ref> [5] </ref>, Danvy presents the Scheme code for this algorithm, where the type index is encoded as a value, thus reducing type analysis to case analysis. <p> = let val x1 = Gensym.fresh "x" in LAM (x1, reify_2 (v (reflect_1 (VAR x1)))) end fun reflect e = fn v1 =&gt; reflect_2 (APP (e, reify_1 (v1))) in (reify, reflect) end fun reify (T as (reify_T, reflect_T)) v = reify_T v flatten (List (List Int)) [[1, 2], [], [3], <ref> [4, 5] </ref>] evaluates to [1,2,3,4,5]. We apply the same method to program type-directed partial evaluation (Figure 4) using the type interpretation [[t ]] = (#; ") t defined in Figure 3.
Reference: [6] <author> Olivier Danvy. </author> <title> Formatting strings in ML. Research Series RS-98-5, </title> <type> BRICS, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> March </month> <year> 1998. </year> <note> To appear in the Journal of Functional Programming. </note>
Reference-contexts: We show how interpreting types t using corresponding values v t gives a type-safe solution to the problem. Based on our approach to type encodings, examples ranging from a printf-like formatting function 1 to type-directed par 1 Initially devised by Olivier Danvy <ref> [6] </ref>. A family of types t Corresponding values v t : T t t 1 types t to a family of values v t of types T t . <p> A first attempt is to make the input value (of some arbitrary homogeneous nested list type) be the only argument. This requires that both expression flatten 5 and expression flatten <ref> [6] </ref> type-check, so the function argument should be polymorphic and should generalize both type int and type int list, which must be a type variable ff. But ML's parametric polymorphism disallows `looking into' the type structure of a polymorphic value. <p> The next attempt is to have an extra argument describing the input type, i.e., a value that encodes the type. We expect to rewrite the aforementioned function invocations as flatten Int 5 and flatten (List Int) <ref> [6] </ref>, respectively. One might try to encode the type using a datatype as: datatype TypeExp = Int | List of TypeExp The fixed type TypeExp of the type encoding, however, also makes the result of applying function flatten to the type encoding have a fixed ML type. <p> Danvy observed that such an implementation of format out-performs the library version of formatting functions provided with SML/NJ and Objective Caml, without even applying partial evaluation to remove interpretive overhead <ref> [6] </ref>. Intuitively, the efficiency comes from the elimination of case-analysis by using function "dispatching" instead, which is similar to the practice of eliminating conditionals by hard-wiring data into code, or using jump-tables in machine language.
Reference: [7] <author> Olivier Danvy. </author> <title> A simple solution to type specialization. Research Series RS-98-1, </title> <type> BRICS, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> January </month> <year> 1998. </year> <booktitle> To appear in the Proceedings of the 25th International Colloquium on Automata, Languages, and Programming. </booktitle>
Reference-contexts: Function reify is safe, however, in the sense that if the argument v type-checks with the domain type of the embedding function emb, then, the resulting tagged expression must comply with the type expression tE. This value-independent type encoding can be used for the `type specialization' described in <ref> [7] </ref>, where the partial evaluator and the projection function are type-indexed by the same family of types. 4.3.2 Comments Finally, we briefly argue that the above approach based on embedding and projection functions is universal, in the sense that the type index t can appear at any position of the type <p> In particular, Danvy showed how it can be naturally combined with type-directed partial evaluation to get a 2-level embedding/projection function <ref> [7] </ref>. 4.4 Multiple type indices Though our previous examples only demonstrate type-indexed values which have only one type index, the embedding/projection-based approach can be readily applied to implementing values indexed by more than one type indices.
Reference: [8] <author> Olivier Danvy and Peter Dybjer, </author> <title> editors. Preliminary Proceedings of the 1998 APPSEM Workshop on Normalization by Evaluation, </title> <type> NBE '98, </type> <institution> (Goteborg, Swe-den, </institution> <month> May 8-9, </month> <year> 1998), </year> <title> number NS-98-1 in BRICS Notes Series, </title> <type> BRICS, </type> <institution> Department of Computer Science, University of Aarhus, </institution> <month> May </month> <year> 1998. </year>
Reference-contexts: Guided by the type information, the functions defined in Figure 2 eta-expand a value into a two-level lambda expression. The underlined constructs are dynamic constructs, which represent code-generating computations, while other constructs are static constructs, which represent computations during partial evaluation (hence the alternative name normalization by evaluation <ref> [8] </ref>). Andrzej Filinski first implemented type-directed partial evaluation in ML in 1995. In his presentations of type-directed partial evaluation, Danvy always challenged the attendees to program it in a typed language such as ML or Haskell.
Reference: [9] <author> Rowan Davies and Frank Pfenning. </author> <title> A modal analysis of staged computation. </title> <booktitle> In Steele [29], </booktitle> <pages> pages 258-283. </pages>
Reference-contexts: A recent approach along the line of dynamic typing, staged type inference [28] proposes to defer the type inference of some expressions until run-time when all related information is available. In particular, this approach is naturally combined with the framework of staged computation <ref> [9, 30] </ref> to support type-safe code generation at run-time. Staged programming helped to solve some of the original problems of dynamic typing, especially those concerning usages.
Reference: [10] <author> Jean-Yves Girard. </author> <title> The system F of variable types, fifteen years later. </title> <journal> Theoretical Computer Science, </journal> <volume> 45(2) </volume> <pages> 159-192, </pages> <year> 1986. </year>
Reference-contexts: In fact, such type encodings are similar to a Martin-Lof-style encoding of inductive types using the corresponding elimination rules in System F ! , which does support both first-class polymorphism and higher-order polymorphism in an explicit form <ref> [10, 25] </ref>. 4.2 Explicit first-class and higher-order polymor phism in SML/NJ The module system of Standard ML provides an explicit form of first-class polymorphism and higher-order polymor-phism.
Reference: [11] <author> Cordelia Hall, Kevin Hammond, Simon Peyton-Jones, and Philip Wadler. </author> <title> Type classes in Haskell. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 18(2) </volume> <pages> 109-138, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: However, the language ML i is explicitly polymorphic, requiring pervasive type annotations throughout the program and thus making it inconvenient to directly program in this language. Not surprisingly, the lan guage ML i is mainly used as a typed-intermediate language. 5.1.3 Haskell type classes The type-class mechanism in Haskell <ref> [11] </ref> also makes it easy to program type-indexed values: the declaration of a type class should include all the type-indexed value needed, and every value construction e i should be implemented as an instance declaration for the constructed type, assuming the component types are already instances of the type class.
Reference: [12] <author> Robert Harper and Greg Morrisett. </author> <title> Compiling poly-morphism using intensional type analysis. </title> <editor> In Peter Lee, editor, </editor> <booktitle> Proceedings of the Twenty-Second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <address> San Francisco, California, Jan-uary 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: On the other hand, it is also because of this possibility of run-time `type error' that dynamic typing disciplines give extra power, as shown in applications such as meta-programming and higher-level data/code transferring in distributed programming. 5.1.2 Intensional type analysis Intensional type analysis <ref> [12] </ref> directly supports type-indexed values in the language ML i in order to compile polymor-phism into efficient unboxed representations.
Reference: [13] <author> Fritz Henglein. </author> <title> Dynamic typing: syntax and proof theory. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 22(3) </volume> <pages> 197-230, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: More involved cases of embedding and projection functions between special types and universal tagged datatypes are studied in detail in <ref> [13] </ref>. 4.3.1 Examples Taking the family F int;list of types, we can encode the type constructors as: datatype typeExpL = tInt | tLst of typeExpL val Int = (fn x =&gt; INT x, fn (INT x) =&gt; x, tInt) fun List (T as (emb_T, proj_T, tE_T)) = (fn l =&gt; LST
Reference: [14] <author> J. Roger Hindley. </author> <title> The principal type-scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <year> 1969. </year>
Reference-contexts: 1 Introduction Over the last two decades, the Hindley-Milner type system <ref> [14, 20] </ref> has been widely used. For example, it underlies several major statically typed functional programming languages, such as ML [21] and Haskell [24]. Among other fl This research was partially supported by National Science Foundation grant CCR-9616993 and the Danish National Research Foundation.
Reference: [15] <author> Mark P. Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymorphism. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(1) </volume> <pages> 1-35, </pages> <month> January </month> <year> 1995. </year> <note> An earlier version appeared in FPCA '93. </note>
Reference-contexts: Substantial work has been done in this direction, such as allowing selective annotations of -bound variables with polymorphic types [23] or packaging of these variables using polymorphic datatype components [16]. Moreover, higher-order polymorphism <ref> [15] </ref> is needed to allow parameterizing over a type constructor, e.g., the type constructor obj.
Reference: [16] <author> Mark P. Jones. </author> <title> First-class polymorphism with type inference. </title> <booktitle> In Jones [17], </booktitle> <pages> pages 483-496. </pages>
Reference-contexts: Substantial work has been done in this direction, such as allowing selective annotations of -bound variables with polymorphic types [23] or packaging of these variables using polymorphic datatype components <ref> [16] </ref>. Moreover, higher-order polymorphism [15] is needed to allow parameterizing over a type constructor, e.g., the type constructor obj.
Reference: [17] <editor> Neil D. Jones, editor. </editor> <booktitle> Proceedings of the Twenty-Fourth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year> <note> ACM Press. </note>
Reference: [18] <author> Neil D. Jones, Carsten K. Gomard, and Peter Ses-toft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> Prentice Hall International, International Series in Computer Science, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: This approach is not as efficient as the ad hoc, value-dependent approach, due to the lengthy tagging and un-tagging operations and the introduction of extra intermediate data structures. This problem can be overcome using program transformation techniques such as partial evaluation <ref> [18] </ref>, by specializing the general functions with respect to certain type encodings at compile time, and removing all the tagging/untagging operations.
Reference: [19] <author> Andrew Kennedy. </author> <title> Relational parametricity and units of measure. </title> <booktitle> In Jones [17], </booktitle> <pages> pages 442-455. </pages>
Reference-contexts: "123123". val C = coerce [(tINT, tSTR, fn (INT x) =&gt; STR (Int.toString x))] (Str --&gt; Str) (Int --&gt; Str) Again, this approach can be combined with type-directed partial evaluation to obtain 2-level functions, as done by Danvy for coercion functions and by Vestergaard for "a la Kennedy" conversion functions <ref> [19, 32] </ref>. 5 Related work 5.1 Using more expressive type systems The problem of programming type-indexed values in a statically typed language like ML motivated several earlier works that introduce new features to the type systems.
Reference: [20] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: 1 Introduction Over the last two decades, the Hindley-Milner type system <ref> [14, 20] </ref> has been widely used. For example, it underlies several major statically typed functional programming languages, such as ML [21] and Haskell [24]. Among other fl This research was partially supported by National Science Foundation grant CCR-9616993 and the Danish National Research Foundation.
Reference: [21] <author> Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> The MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction Over the last two decades, the Hindley-Milner type system [14, 20] has been widely used. For example, it underlies several major statically typed functional programming languages, such as ML <ref> [21] </ref> and Haskell [24]. Among other fl This research was partially supported by National Science Foundation grant CCR-9616993 and the Danish National Research Foundation.
Reference: [22] <author> John C. Mitchell. </author> <title> Coercion and type inference. </title> <editor> In Ken Kennedy, editor, </editor> <booktitle> Proceedings of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 175-185, </pages> <address> Salt Lake City, Utah, </address> <month> January </month> <year> 1984. </year>
Reference-contexts: Here let us take the example of writing an ML function that performs subtype coercion <ref> [22] </ref>. Given a from-type, a to-type, a list of subtype coercions at base types, and a value of the from-type, this function coerces the value to the to-type and return it. Following the general pattern, we first write a function univ coerce, which performs the coercions on tagged values.
Reference: [23] <author> Martin Odersky and Konstantin Laufer. </author> <title> Putting type annotations to work. </title> <booktitle> In Steele [29], </booktitle> <pages> pages 54-67. </pages>
Reference-contexts: What we need here is first-class polymorphism, which allows nested quantified types, as used in the type of argument func v. Substantial work has been done in this direction, such as allowing selective annotations of -bound variables with polymorphic types <ref> [23] </ref> or packaging of these variables using polymorphic datatype components [16]. Moreover, higher-order polymorphism [15] is needed to allow parameterizing over a type constructor, e.g., the type constructor obj.
Reference: [24] <author> John Peterson, Kevin Hammond, et al. </author> <title> Report on the programming language Haskell, a non-strict purely-functional programming language, </title> <note> version 1.4. Available at the Haskell homepage: http://www.haskell.org, April 1997. </note>
Reference-contexts: 1 Introduction Over the last two decades, the Hindley-Milner type system [14, 20] has been widely used. For example, it underlies several major statically typed functional programming languages, such as ML [21] and Haskell <ref> [24] </ref>. Among other fl This research was partially supported by National Science Foundation grant CCR-9616993 and the Danish National Research Foundation.
Reference: [25] <author> John C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Programming Symposium, number 19 in Lecture Notes in Computer Science, </booktitle> <pages> pages 408-425, </pages> <address> Paris, France, April 1974. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In fact, such type encodings are similar to a Martin-Lof-style encoding of inductive types using the corresponding elimination rules in System F ! , which does support both first-class polymorphism and higher-order polymorphism in an explicit form <ref> [10, 25] </ref>. 4.2 Explicit first-class and higher-order polymor phism in SML/NJ The module system of Standard ML provides an explicit form of first-class polymorphism and higher-order polymor-phism.
Reference: [26] <author> Morten Rhiger. </author> <title> A study in higher-order programming languages. </title> <type> Master's thesis, DAIMI, </type> <institution> Department of Computer Science, University of Aarhus, Aarhus, Den-mark, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: The author answered the challenge in 1996, which, according to Danvy, is the first solution after Filinski's. The third person to have solved it is Morten Rhiger <ref> [26] </ref>. Since then, Kristoffer Rose has programmed it in Haskell, using type classes [27].
Reference: [27] <author> Kristoffer Rose. </author> <title> Type-directed partial evaluation in a pure functional language. </title> <note> In Danvy and Dybjer [8]. </note>
Reference-contexts: The author answered the challenge in 1996, which, according to Danvy, is the first solution after Filinski's. The third person to have solved it is Morten Rhiger [26]. Since then, Kristoffer Rose has programmed it in Haskell, using type classes <ref> [27] </ref>. An interesting common pattern shared by type-directed partial evaluation and the embedding/projection-based approach is the use of types as external tags (see section 4.3.2): loosely speaking, one external type tag in type-directed partial evaluation replaces pervasive binding-time annotations in the preprocessed program texts.
Reference: [28] <author> Mark Shields, Tim Sheard, and Simon Peyton Jones. </author> <title> Dynamic typing as staged type inference. </title> <editor> In Luca Cardelli, editor, </editor> <booktitle> Proceedings of the Twenty-Fifth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 289-302, </pages> <address> San Diego, California, Jan-uary 1998. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Processing dynamic values is however similar to processing tagged values of user-defined type| both require operations that wrap values and case analysis that removes the wrapping. A recent approach along the line of dynamic typing, staged type inference <ref> [28] </ref> proposes to defer the type inference of some expressions until run-time when all related information is available. In particular, this approach is naturally combined with the framework of staged computation [9, 30] to support type-safe code generation at run-time. <p> This is effectively equivalent to providing default exception handlers for run-time exceptions resulting from type inference. The approach is still a dynamic-typing approach, so that the benefit of static debugging offered by a static typing system is lost. For example, the formatting function in <ref> [28] </ref> will simply return an error when field specifiers do not match the function arguments.
Reference: [29] <editor> Guy L. Steele, editor. </editor> <booktitle> Proceedings of the Twenty-Third Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, Jan-uary 1996. </address> <publisher> ACM Press. </publisher>
Reference: [30] <author> Walid Taha and Tim Sheard. </author> <title> Multi-stage programming. </title> <editor> In Mads Tofte, editor, </editor> <booktitle> Proceedings of the 1997 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 321-321, </pages> <address> Amsterdam, The Netherlands, June 1997. </address> <publisher> ACM Press. </publisher>
Reference-contexts: A recent approach along the line of dynamic typing, staged type inference [28] proposes to defer the type inference of some expressions until run-time when all related information is available. In particular, this approach is naturally combined with the framework of staged computation <ref> [9, 30] </ref> to support type-safe code generation at run-time. Staged programming helped to solve some of the original problems of dynamic typing, especially those concerning usages.
Reference: [31] <author> Mads Tofte. </author> <title> Principal signatures for higher-order program modules. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(3) </volume> <pages> 285-335, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: To recast the higher-order functions in Figure 6 into functors, we also need to use higher-order functors which allows functors to have functor arguments or results. Such higher-order func-tors <ref> [31] </ref> are supported by Standard ML of New Jersey [3].
Reference: [32] <author> Rene Vestergaard. </author> <title> From proof normalization to compiler generation and type-directed change-of-representation. </title> <type> Master's thesis, DAIMI, </type> <institution> Department of Computer Science, University of Aarhus, Aarhus, Den-mark, </institution> <month> May </month> <year> 1997. </year>
Reference-contexts: "123123". val C = coerce [(tINT, tSTR, fn (INT x) =&gt; STR (Int.toString x))] (Str --&gt; Str) (Int --&gt; Str) Again, this approach can be combined with type-directed partial evaluation to obtain 2-level functions, as done by Danvy for coercion functions and by Vestergaard for "a la Kennedy" conversion functions <ref> [19, 32] </ref>. 5 Related work 5.1 Using more expressive type systems The problem of programming type-indexed values in a statically typed language like ML motivated several earlier works that introduce new features to the type systems.
References-found: 32

