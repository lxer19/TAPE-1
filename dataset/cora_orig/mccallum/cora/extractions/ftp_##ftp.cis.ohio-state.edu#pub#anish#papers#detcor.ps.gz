URL: ftp://ftp.cis.ohio-state.edu/pub/anish/papers/detcor.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~anish/pub.html
Root-URL: 
Title: Detectors and Correctors: A Theory of Fault-Tolerance Components  
Author: Anish Arora Sandeep S. Kulkarni 
Keyword: Composition, Fault environment, Tolerance components, Tolerance design  
Address: Columbus, Ohio 43210 USA  
Affiliation: Department of Computer and Information Science The Ohio State University  
Abstract: Two primitive components, namely detectors and correctors, provide a basis for achieving the different types of fault-tolerance properties required in computing systems. In this paper, we develop the theory of these primitive "tolerance components", characterizing precisely their role in achieving the different types of fault-tolerances. Also, we illustrate how they can be used to formulate extant design methods and argue that they sometimes offer the potential for better designs than those obtained from extant methods. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Arora and S. S. Kulkarni. </author> <title> Component based design of multitolerance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 24(1) </volume> <pages> 63-78, </pages> <month> January </month> <year> 1998. </year>
Reference-contexts: Correctors are necessary and sufficient for eventually satisfying both the safety and the "liveness" of a problem specification. A consequence of this result is that "nonmasking" tolerant fl Some of the results presented in this paper appear in preliminary form in <ref> [1] </ref>. Email: fanish,kulkarnig@cis.ohio-state.edu; Web: http://www.cis.ohio-state.edu/ ~ anish, ~ kulkarnig; Tel: +1-614-292-1836; Fax: +1-614-292-2911. Research supported in part by NSA Grant MDA904-96-1-0111, NSF Grant CCR-93-08640, and OSU Grant 221506. correctors are necessary and sufficient for nonmasking tolerant programs. <p> It is important to note that there may be multiple such state predicates T from which p meets the above three requirements. Each of these multiple T state predicates cap tures a (potentially different) type of fault-tolerance of p. We have exploited this multiplicity in <ref> [1] </ref> to design programs that tolerate multiple fault-classes. Types of fault-tolerances. We now classify three types of fault-tolerances that a program can exhibit, namely masking, nonmasking, and fail-safe tolerance, using the above definition of F -tolerance. <p> One technique is to prove that that d performs its detection by executing at most one action. Another technique is to prove that p executes only after d has completed its detection. Yet another technique is to show that p eventually terminates. These sufficient conditions are presented formally in <ref> [1] </ref>. Example : Triple modular redundancy. Consider a triple modular redundant system with three inputs, say x, y and z, and one output, say out. In the absence of faults, all inputs are identical. Faults may corrupt any one of the three inputs. <p> Another technique is to prove that that p executes only after c has completed its correction. Yet another is to show that p eventually terminates. Sufficient conditions for these techniques are presented in <ref> [1] </ref>. Example : Triple modular redundancy (contin ued). Program DR; IR deadlocks when the value of x gets corrupted. To achieve masking tolerance, we add corrector CR whose correction predicate and witness predicate are both out = uncor.
Reference: [2] <author> F. B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: are necessary and sufficient for masking tolerant programs. (Each of these terms is formally defined in the next section.) We then proceed to identify the relation between detectors/correctors and the components used in the extant component based methods for fault-tolerance. (Extant methods include replication based voting, Schneider's state machine approach <ref> [2] </ref>, Randell's recovery blocks [3], checkpointing and recovery, and exception handling.) Specifically, we show how replication based voting and Schneider's state machine approach can be formulated in terms of detectors and correctors. <p> In this section, we show how programs designed using Schneider's state machine approach can also be designed using detectors and correctors. Recall that Schneider's state machine approach <ref> [2] </ref> consists of two requirements, Agreement and Order.
Reference: [3] <author> B. Randell. </author> <title> System structure for software fault tolerance. </title> <journal> IEEE Transactions on Software Engineering., </journal> <pages> pages 220-232, </pages> <year> 1975. </year>
Reference-contexts: for masking tolerant programs. (Each of these terms is formally defined in the next section.) We then proceed to identify the relation between detectors/correctors and the components used in the extant component based methods for fault-tolerance. (Extant methods include replication based voting, Schneider's state machine approach [2], Randell's recovery blocks <ref> [3] </ref>, checkpointing and recovery, and exception handling.) Specifically, we show how replication based voting and Schneider's state machine approach can be formulated in terms of detectors and correctors.
Reference: [4] <author> B. Alpern and F. B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21 </volume> <pages> 181-185, </pages> <year> 1985. </year>
Reference-contexts: Finally, we make concluding remarks in Section 8. 2 Preliminaries In this section, we give formal definitions of programs, problem specifications, faults, and fault-tolerances. The formalization of programs is a standard one, that of specifications is adapted from Alpern and Schneider <ref> [4] </ref>, and that of faults and fault-tolerances is adapted from earlier work of the first author with Mohamed Gouda [5] (with the exception of the portion on fail-safe tolerance which is new). 2.1 Programs Definition. A program is a set of variables and a finite set of actions. <p> Note that the state sequences in a problem specification may be finite or infinite. Following Alpern and Schneider <ref> [4] </ref>, it can be shown that any problem specification is the intersection of some "safety" specification that is suffix closed and fusion closed and some "liveness" specification, defined next. Definition (Safety).
Reference: [5] <author> A. Arora and M. G. Gouda. </author> <title> Closure and convergence: A foundation of fault-tolerant computing. </title> <journal> IEEE Transactions on Software Engineering, </journal> 19(11) 1015-1027, 1993. 
Reference-contexts: The formalization of programs is a standard one, that of specifications is adapted from Alpern and Schneider [4], and that of faults and fault-tolerances is adapted from earlier work of the first author with Mohamed Gouda <ref> [5] </ref> (with the exception of the portion on fail-safe tolerance which is new). 2.1 Programs Definition. A program is a set of variables and a finite set of actions. Each variable has a predefined nonempty domain. <p> Finally, since c satisfies Stability from U and X is never falsified, it follows that Z is never falsified. Remark. If the witness predicate Z is identical to the correction predicate X, our definition of the corrects relation reduces to one given by Arora and Gouda <ref> [5] </ref>. We have considered this more general definition to accommodate the case |which occurs for instance in masking tolerance| where the witness predicate Z can be checked atomically but the correction predicate X cannot. (End of Remark.) Properties.
Reference: [6] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Assumption. When the safety property of the specification is to be preserved, as in fail-safe and masking tolerance, we make the standard assumption <ref> [6] </ref> that the execution of any fault action in F always maintains the problem specification, i.e., if a prefix maintains a problem specification and s is the extended prefix obtained by execution of a fault action in F (where s is a state and s is the concatenation of and s),
Reference: [7] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Remark. If the detection predicate X is closed in d, our definition of the detects relation reduces to one given by Chandy and Misra <ref> [7] </ref>. We have considered this more general definition to accommodate the case |which occurs for instance in nonmasking tolerance| where X denotes that "something bad has happened"; in this case, X is not supposed to be closed since it has to be subsequently corrected. (End of Remark.) Properties.
Reference: [8] <author> S. S. Kulkarni and A. Arora. </author> <title> Compositional design of mul-titolerant repetitive byzantine agreement. </title> <booktitle> Proceedings of the Seventeenth International Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <address> Kharagpur, India, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: We focus our attention on Agreement in the presence of Byzan-tine faults. (For reasons of space, we refer the interested reader to a companion paper for a discussion of how detectors and correctors achieve Order as well as Agreement in the presence of Byzantine faults <ref> [8] </ref>.) Byzantine agreement. <p> For ease of exposition, we will restrict our atten-tion to the case where the total number of processes (including g) is 4 and, hence, f is 1. (We discuss the general case where f is greater than one elsewhere <ref> [8] </ref>.) We show that a Byzantine agreement program can be designed by first designing a fault-intolerant program, IB, and then adding to it a detector, DB, followed by a corrector, CB. Fault-intolerant program IB.
Reference: [9] <author> T. Chandra and S. Toueg. </author> <title> Unreliable failure detectors for reliable distributed systems. </title> <journal> Journal of the ACM, </journal> <volume> 43(2), </volume> <year> 1996. </year>
Reference-contexts: In passing, we note that our notion of detectors also applies to the recent important work on failure detection of Chandra and Toueg <ref> [9] </ref>, although that work makes some distinctions among types of detectors that we do not need for our purposes. To apply the notions of detectors and correctors in practice, we are currently developing SIEFAST, a component-based design and verification environment that enables stepwise implementation and validation of fault-tolerant distributed programs.
References-found: 9

