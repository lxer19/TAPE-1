URL: http://www.cs.virginia.edu/~son/publications/lee.chap.ps
Refering-URL: http://www.cs.virginia.edu/~son/publications.html
Root-URL: http://www.cs.virginia.edu
Title: Performance of Concurrency Control Algorithms for Real-Time Database Systems  
Author: Juhnyoung Lee and Sang H. Son 
Date: April 6, 1994  
Address: Charlottesville, VA 22903 U.S.A.  
Affiliation: Department of Computer Science University of Virginia  
Abstract: In this paper, we investigate the key components of a reasonable model of real-time database systems (RTDBSs), including the policy for dealing with tardy transactions, the availability of resources in the system, and the use of pre-knowledge about transaction processing requirement. We employ a fairly complete model of an RTDBS for studying the relative performance of locking and optimistic concurrency control protocols under a variety of operating conditions. In addition, we examine the issues on the implementation of concurrency control algorithms, which may have a significant impact on performance. We show that under a soft deadline system, the results of the relative performance of locking and optimistic approaches depend heavily on resource availability in the system as in conventional database systems. In the context of firm deadline systems, it is shown that an optimistic protocol outperforms a locking-based protocol under a wide range of resource availability and system workload level. Based on these results, we reconfirm the results from previous performance studies on concurrency control for RTDBSs. 
Abstract-found: 1
Intro-found: 1
Reference: [Abbo88] <author> Abbott, R. and H. Garcia-Molina, </author> <title> "Scheduling Real-Time Transactions: A Performance Evaluation," </title> <booktitle> Proceedings of the 14th VLDB Conference, </booktitle> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: The problem of scheduling transactions in an RTDBS with the objective of minimizing the percentage of transactions missing its deadline was first addressed in <ref> [Abbo88, Abbo89] </ref>. The work proposed new policies for priority assignment and eligibility test in RTDBSs, and evaluated the performance of various scheduling policies through simulation. A group of concurrency control protocols for RTDBSs using two-phase locking as the underlying mechanism was also proposed and evaluated. <p> Read locks can be shared, while write locks are exclusive. For real-time database systems, two-phase locking needs to be augmented with a priority-based conflict resolution scheme to ensure that higher priority transactions are not delayed by lower priority transactions. In High Priority scheme <ref> [Abbo88] </ref>, all data conflicts are resolved in favor of the transaction with the higher priority. <p> In addition, a new read lock requester can join a group of read lock holders only if its priority is higher than that of all waiting write lock operations. This protocol is referred to as 2PL-HP <ref> [Abbo88] </ref>. It is important to note that 2PL-HP loses some of the basic 2PL algorithm's blocking factor due to the partially restart-based nature of the High Priority scheme. Note that High Priority scheme is similar to Wound-Wait scheme [Rose78], which is added to two-phase locking for deadlock prevention. <p> These characteristics of deadline in real-time transactions come directly from real-time application requirements, and are not an option for the system designer. An example of real-time database application having firm deadline is a financial market program for arbitrage trading described in <ref> [Abbo88] </ref>. The detection and exploitation of arbitrage opportunities are constrained to time.
Reference: [Abbo89] <author> Abbott, R. and H. Garcia-Molina, </author> <title> "Scheduling Real-Time Transactions with Disk Resident Data," </title> <booktitle> Proceedings of the 15th VLDB Conference, </booktitle> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: The problem of scheduling transactions in an RTDBS with the objective of minimizing the percentage of transactions missing its deadline was first addressed in <ref> [Abbo88, Abbo89] </ref>. The work proposed new policies for priority assignment and eligibility test in RTDBSs, and evaluated the performance of various scheduling policies through simulation. A group of concurrency control protocols for RTDBSs using two-phase locking as the underlying mechanism was also proposed and evaluated. <p> The work proposed new policies for priority assignment and eligibility test in RTDBSs, and evaluated the performance of various scheduling policies through simulation. A group of concurrency control protocols for RTDBSs using two-phase locking as the underlying mechanism was also proposed and evaluated. Studies in <ref> [Abbo89, Huan91b, Sha88, Sha91] </ref> addressed the problem of priority inversion in the context of RTDBSs where locking and priority-driven preemptive scheduling for CPU scheduling are integrated together. A priority inversion occurs when a higher priority transaction must wait for the execution of lower priority transaction (s). <p> Also, note that 2PL-HP is free from priority inversion problem, because a higher priority transaction never waits for a lower priority transaction, but restarts it. 2.1.2 2PL-WP 2PL-WP (Wait Promote) <ref> [Abbo89] </ref> retains the blocking policy and hence resource-conservation feature of the basic 2PL, employing priority inheritance mechanism [Sha87] for conflict resolution. Priority Inheritance was devised to solve the problem of priority inversion. <p> Under this situation, the behavior of the RTDBS would effectively reduce to that of a conventional database system. Experimental performance evaluation of real-time concurrency control algorithms in <ref> [Abbo89, Huan91b] </ref> confirmed that the performance of 2PL-WP degrades rapidly under high data contention situations. In [Huan91b], a protocol that combines High Priority and Wait Promote schemes for conflict resolution is studied and reported to have superior performance.
Reference: [Agra87] <author> Agrawal, R., M. J. Carey, and M. Livny, </author> <title> "Concurrency Control Performance Modeling: Alternatives and Implications," </title> <journal> ACM Trans. on Database Systems, </journal> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: With respect to the impact of conflict resolution methods, the effect of blocking and restart should be considered in the context of the amount of available system resources. Generally, blocking-based conflict resolution policy conserves resources, while restart-based policy wastes more resources. Previous performance studies on conventional database systems in <ref> [Agra87, Care84] </ref> showed that locking algorithm that resolves data conflicts by blocking transactions outperforms restart-oriented algorithm in an environment where physical resources are limited. <p> While 2PL-HP employs both blocking and restart for conflict resolution, OCC-FV depends solely on restarts. In conventional database systems, abundant resources are usually not to be expected and a reasonable model of system resources is crucial ingredient for performance studies <ref> [Agra87] </ref>. However, it is worth noting that in the application domain of RTDBSs, functionality, rather than cost, is often the driving consideration. <p> The amounts of CPU and I/O time per logical service are specified as model parameters. The physical queueing model is depicted in Figure 3 (b), and the associated model parameters are described in the next section. The physical queueing model is similar to the one used in <ref> [Agra87, Care84] </ref>. CPUs share a single queue and the service discipline used for the queue is priority scheduling without preemption. Each disk has its own queue and is also scheduled with priority scheduling. <p> The results of this experiment conclude that 2PL-HP outperforms OCC-FV when available resources are limited and all the transactions are required to complete as in conventional database systems. This conclusion is similar to that in conventional database systems. In <ref> [Agra87, Care84] </ref>, it was concluded that two-phase locking was found to outperform optimistic algorithm in an environment where physical resources are limited. The result of better performance of 2PL-HP than OCC-FV also agrees with that of the 22 experimental study in [Huan91]. <p> For the reasons explained in Section 2.4, the optimistic protocol shows shorter blocking time than 2PL-HP. Based on the results of this experiment, we conclude that OCC-FV outperforms 2PL-HP under an infinite resource situation. Similar conclusion was obtained in the study of conventional database systems <ref> [Agra87] </ref>. If resource utilizations are low enough so that a large amount of wasted resources can be tolerated, and in addition there are a large number of transactions available to execute, then an optimistic algorithm that allows a higher degree of concurrent execution is a better choice. <p> In varying the number of CPUs and disks, we decided to use one CPU and two disks as one resource unit as in <ref> [Agra87] </ref>, and we vary the number of resource units rather than the number of CPUs and the number of disks individually.
Reference: [Bern87] <author> Bernstein, P. A., V. Hadzilacos, and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: The database itself is modeled as a collection of data pages in disks, and the data pages are modeled as being uniformly distributed across all the disks. The logical model is shown in Figure 3 (a). This model was developed based on the conventional database system model described in <ref> [Bern87] </ref>. It consists of three main components: a Transaction Manager (TM), a Data Operation Scheduler (DOS), and a Data Manager (DM). <p> We assume that a write operation is always preceded by a read for the same page, that is, the write set of a transaction is always a subset of its read set <ref> [Bern87] </ref>. If a data access request leads to a decision to abort the transaction, it has to restart. The system checks the eligibility of a transaction whenever it restarts, and whenever it is put into and comes out of a queue, to see if it has already missed its deadline.
Reference: [Care84] <author> Carey, M. J., and M. R. Stonebraker, </author> <title> "The Performance of Concurrency Control Algorithms for Database management Systems," </title> <booktitle> Proceedings of the 10th VLDB Conference, </booktitle> <address> Singapore, </address> <month> August, </month> <year> 1984. </year>
Reference-contexts: With respect to the impact of conflict resolution methods, the effect of blocking and restart should be considered in the context of the amount of available system resources. Generally, blocking-based conflict resolution policy conserves resources, while restart-based policy wastes more resources. Previous performance studies on conventional database systems in <ref> [Agra87, Care84] </ref> showed that locking algorithm that resolves data conflicts by blocking transactions outperforms restart-oriented algorithm in an environment where physical resources are limited. <p> The amounts of CPU and I/O time per logical service are specified as model parameters. The physical queueing model is depicted in Figure 3 (b), and the associated model parameters are described in the next section. The physical queueing model is similar to the one used in <ref> [Agra87, Care84] </ref>. CPUs share a single queue and the service discipline used for the queue is priority scheduling without preemption. Each disk has its own queue and is also scheduled with priority scheduling. <p> The results of this experiment conclude that 2PL-HP outperforms OCC-FV when available resources are limited and all the transactions are required to complete as in conventional database systems. This conclusion is similar to that in conventional database systems. In <ref> [Agra87, Care84] </ref>, it was concluded that two-phase locking was found to outperform optimistic algorithm in an environment where physical resources are limited. The result of better performance of 2PL-HP than OCC-FV also agrees with that of the 22 experimental study in [Huan91].
Reference: [Eswa76] <author> Eswaran, K., J. Gray, R. Lorie, and I. Traiger, </author> <title> "The Notions of Consistency and Predicate Locks in a Database System," </title> <journal> Comm. of ACM, </journal> <month> Nov. </month> <year> 1976. </year>
Reference-contexts: Given these differences, considerable research has recently been devoted to designing concurrency control algorithms for RTDBSs and to evaluating their performance. Most of these studies use the serializability <ref> [Eswa76] </ref> for maintaining data consistency, because at present there is no general-purpose consistency criterion available that is less stringent than serializability, and yet as obviously correct and easily implementable as serializability. Most of the proposed algorithms are based on one of the two basic mechanisms: two-phase locking (2PL) [Eswa76] 2 and <p> the serializability <ref> [Eswa76] </ref> for maintaining data consistency, because at present there is no general-purpose consistency criterion available that is less stringent than serializability, and yet as obviously correct and easily implementable as serializability. Most of the proposed algorithms are based on one of the two basic mechanisms: two-phase locking (2PL) [Eswa76] 2 and optimistic concurrency control (OCC) [Kung81], and use priority information in the resolution of data conflicts, that is, resolve data conflicts always in favor of the higher priority transaction. <p> In this section, in addition to 2PL-HP and OCC-FV, we review a few other concurrency control algorithms, in both locking and optimistic control sides, proposed for using in RTDBSs. 2.1 Locking-Based Algorithms 2.1.1 2PL-HP In classical two-phase locking protocol <ref> [Eswa76] </ref>, transactions set read locks on objects that they read, and these locks are later upgraded to write locks for the data objects that are updated. If a lock requested is denied, the requesting transaction is blocked until the lock is released.
Reference: [Haer84] <author> Haerder, T., </author> <title> "Observations on Optimistic Concurrency Control Schemes," </title> <journal> Information Systems, </journal> <volume> 9(2), </volume> <year> 1984. </year>
Reference-contexts: The key component among these is the validation phase where a transaction's destiny is decided. Validation comes in several flavors, but it can carried out basically in either of two ways: backward validation and forward validation <ref> [Haer84] </ref>. While in backward scheme, the validation process is done against committed transactions, in forward validation, validating of a transaction is carried out against currently running transactions. As explained above, in RTDBSs, data conflicts should be resolved in favor of higher 7 priority transactions.
Reference: [Hari90] <author> Haritsa, J. R., M. J. Carey, and M. Livny, </author> <title> "On Being Optimistic about Real-Time Constraints," </title> <booktitle> Proceedings of the 1990 ACM SIGACT-SIGART-SIGMOD Symposium on Principles of Database Systems (PODS), </booktitle> <year> 1990. </year>
Reference-contexts: Because higher priority is blocked by lower priority transaction (s), this problem operates against the purpose of priority assignment in real-time systems. Even worse, the blocking delay may be unbounded. The proposed solutions for this problem will be reviewed in the next section. The work in <ref> [Hari90, Hari90b] </ref> focused primarily on the behavior of concurrency control algorithms in a real-time database environment, evaluating the relative performance of locking and optimistic concurrency control through simulation. The problem of adding transaction timing information to optimistic concurrency control for conflict resolution was also addressed. <p> These performance studies on real-time concurrency control protocols are informative, but some of the results emerged, instead of being definitive, are contradictory. For example, the studies in <ref> [Hari90] </ref> suggest that optimistic approach outperforms locking in a real-time database environment, while the experimental results in [Huan91] indicate that optimistic protocols may not always outperform priority-cognizant two-phase locking schemes when the physical implementation of concurrency control algorithms is considered. <p> Also, it was reported in [Hari90b] that the use of priority-driven wait mechanism in conflict resolutions further improves the performance of optimistic approach, but the results in [Huan91] showed that the priority-driven wait strategy has no significant impact on performance. Regarding these apparent contradictions between the results from <ref> [Hari90, Hari90b] </ref> and 3 [Huan91], possible reasons were examined. In [Huan91], it was pointed out that the contra-dictions come from the fact that unlike theirs, the results from [Hari90, Hari90b] are based on simulation experiments, where optimistic concurrency control is carried out at the logical level and detailed implementation issues at <p> Regarding these apparent contradictions between the results from <ref> [Hari90, Hari90b] </ref> and 3 [Huan91], possible reasons were examined. In [Huan91], it was pointed out that the contra-dictions come from the fact that unlike theirs, the results from [Hari90, Hari90b] are based on simulation experiments, where optimistic concurrency control is carried out at the logical level and detailed implementation issues at the physical level are ignored 1 . <p> These algo 1 In particular, it was pointed in [Huang91] that the optimistic protocol used in <ref> [Hari90, Hari90b] </ref> employs a broadcast mechanism in its validation phase but no overhead involved in this mechanism is taken into account in the performance study. 4 rithms were chosen because they represent concurrency control protocols for RTDBSs based on locking and optimistic concurrency control, respectively, in the previous studies. <p> In addition, forward scheme generally detects and resolves data conflicts earlier than backward validation, and hence it wastes less resources and time. All the optimistic algorithms used in the previous studies of real-time concurrency control in <ref> [Hari90, Hari90b, Huan91] </ref> are based on the forward validation. The broadcast mechanism in the algorithm, OPT-BC used in [Hari90, Robi82] is an implementation variant of the forward validation. We refer to the optimistic algorithm using forward validation as OCC-FV. <p> All the optimistic algorithms used in the previous studies of real-time concurrency control in [Hari90, Hari90b, Huan91] are based on the forward validation. The broadcast mechanism in the algorithm, OPT-BC used in <ref> [Hari90, Robi82] </ref> is an implementation variant of the forward validation. We refer to the optimistic algorithm using forward validation as OCC-FV. A point to note is that unlike 2PL-HP, OCC-FV does not use any transaction priority information in resolving data conflicts. <p> On the other hand, the immediate conflict resolution policy of locking schemes may lead to useless restarts and blocking in RTDBSs due to its lack of information on conflicting transactions at the time of conflict resolution <ref> [Hari90] </ref>. 2.4 Implementation Issues In this section, we describe a physical implementation method for optimistic algorithms with forward validation. The implementation method and its corresponding overhead are 10 important factors for a correct performance comparison of concurrency control algorithms. <p> This method is impractical for actual database systems, since the complexity of the validation test is dependent on the number of active transactions. The other concern was the comparability of locking algorithms and optimistic schemes. In the previous studies of concurrency control for RTDBSs in <ref> [Hari90, Hari90b] </ref>, the validation test of optimistic algorithms were implemented using a broadcast mechanism by which the validating transaction notifies other currently running transactions with data conflicts. <p> A point to note here is that there is a trade-off between the two metrics, Miss Percentage and Average Tardy Time, in the sense that a decrease in one will usually result in an increase in the other. Thus, it is difficult to simultaneously improve both metrics <ref> [Hari90] </ref>. The behavioral difference between soft deadline system and firm deadline system has been shown analytically using simple queueing systems [Hari90]. The analysis was very loose and abstract, showing the immaturity of this field. Still, it clearly showed the difference between the two systems. <p> Thus, it is difficult to simultaneously improve both metrics <ref> [Hari90] </ref>. The behavioral difference between soft deadline system and firm deadline system has been shown analytically using simple queueing systems [Hari90]. The analysis was very loose and abstract, showing the immaturity of this field. Still, it clearly showed the difference between the two systems. A soft deadline system is modeled by a single M/M/1 queue. The computation of the Miss Percentage for this system can be done as follows. <p> This concept is quantified in the Miss Percentage graph in Figure 18. For this graph, we set the write probability to 0.5, fixed the arrival rate at 20 transactions/second, and varied the amount of available resources using the resource unit defined earlier. The work in <ref> [Hari90] </ref> presented a quantitative study of the relative performance of locking and optimistic concurrency control techniques in the context of a real-time database system. <p> Optimistic approach can avoid such wasted restarts because of its policy of delayed conflict resolution. A more general result of this study is that we have reconfirmed results from previous performance studies on concurrency control in RTDBS including <ref> [Hari90, Hari92, Huan91] </ref>. We have shown that seemingly contradictory performance results, some of which favored locking-based protocol and others of which favored optimistic scheme, are not contradictory at all.
Reference: [Hari90b] <author> Haritsa, J. R., M. J. Carey, and M. Livny, </author> <title> "Dynamic Real-Time Optimistic Concurrency Control," </title> <booktitle> Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <address> Orlando, Florida, </address> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Because higher priority is blocked by lower priority transaction (s), this problem operates against the purpose of priority assignment in real-time systems. Even worse, the blocking delay may be unbounded. The proposed solutions for this problem will be reviewed in the next section. The work in <ref> [Hari90, Hari90b] </ref> focused primarily on the behavior of concurrency control algorithms in a real-time database environment, evaluating the relative performance of locking and optimistic concurrency control through simulation. The problem of adding transaction timing information to optimistic concurrency control for conflict resolution was also addressed. <p> Also, it was reported in <ref> [Hari90b] </ref> that the use of priority-driven wait mechanism in conflict resolutions further improves the performance of optimistic approach, but the results in [Huan91] showed that the priority-driven wait strategy has no significant impact on performance. <p> Also, it was reported in [Hari90b] that the use of priority-driven wait mechanism in conflict resolutions further improves the performance of optimistic approach, but the results in [Huan91] showed that the priority-driven wait strategy has no significant impact on performance. Regarding these apparent contradictions between the results from <ref> [Hari90, Hari90b] </ref> and 3 [Huan91], possible reasons were examined. In [Huan91], it was pointed out that the contra-dictions come from the fact that unlike theirs, the results from [Hari90, Hari90b] are based on simulation experiments, where optimistic concurrency control is carried out at the logical level and detailed implementation issues at <p> Regarding these apparent contradictions between the results from <ref> [Hari90, Hari90b] </ref> and 3 [Huan91], possible reasons were examined. In [Huan91], it was pointed out that the contra-dictions come from the fact that unlike theirs, the results from [Hari90, Hari90b] are based on simulation experiments, where optimistic concurrency control is carried out at the logical level and detailed implementation issues at the physical level are ignored 1 . <p> These algo 1 In particular, it was pointed in [Huang91] that the optimistic protocol used in <ref> [Hari90, Hari90b] </ref> employs a broadcast mechanism in its validation phase but no overhead involved in this mechanism is taken into account in the performance study. 4 rithms were chosen because they represent concurrency control protocols for RTDBSs based on locking and optimistic concurrency control, respectively, in the previous studies. <p> In addition, forward scheme generally detects and resolves data conflicts earlier than backward validation, and hence it wastes less resources and time. All the optimistic algorithms used in the previous studies of real-time concurrency control in <ref> [Hari90, Hari90b, Huan91] </ref> are based on the forward validation. The broadcast mechanism in the algorithm, OPT-BC used in [Hari90, Robi82] is an implementation variant of the forward validation. We refer to the optimistic algorithm using forward validation as OCC-FV. <p> Thus, under OCC-FV, a transaction with a higher priority may need to restart due to a committing transaction with a lower priority. Several methods to incorporate priority information into OCC-FV were proposed and studied in <ref> [Hari90b, Huan91] </ref>, using priority-driven wait or abort mechanism. <p> We have chosen OCC-FV because it shows the representative performance among optimistic algorithms studied in the context of real-time database systems. 2.2.2 OPT-SACRIFICE OPT-SACRIFICE <ref> [Hari90b] </ref> is an optimistic protocol which uses a priority-driven abort for conflict resolution. In this protocol, when a transaction reaches its validation phase, it is aborted if one or more conflicting transactions have higher priority than the validating one; otherwise it commits and all the conflicting transactions restart immediately. <p> This protocol behaves similarly to OCC-FV most of the time, because the condition for the restart of validating transaction is restrictive. 2.2.3 OPT-WAIT In OPT-WAIT scheme <ref> [Hari90b] </ref>, when a transaction reaches its validation phase, if its priority is not the highest among the conflicting transactions, it waits for the conflicting transactions with higher priority to complete. This scheme gives the higher priority transactions a chance to meet their deadlines first. <p> This problem becomes worse with the possibility of chained blocking, which may cause cascaded aborts. Moreover, while a validating transaction waits, new conflicts can occur, and hence the number of conflicting transactions and the chance of abort are increased. In WAIT-50 scheme <ref> [Hari90b] </ref>, a validating transaction is made to wait as long as more than half the transactions that conflict with it have higher priorities; otherwise it commits and all the conflicting transactions are restarted immediately as in OCC-FV scheme. <p> This method is impractical for actual database systems, since the complexity of the validation test is dependent on the number of active transactions. The other concern was the comparability of locking algorithms and optimistic schemes. In the previous studies of concurrency control for RTDBSs in <ref> [Hari90, Hari90b] </ref>, the validation test of optimistic algorithms were implemented using a broadcast mechanism by which the validating transaction notifies other currently running transactions with data conflicts.
Reference: [Hari92] <author> Haritsa, J. R., M. J. Carey, and M. Livny, </author> <title> "Data Access Scheduling in Firm Real-Time Database Systems," </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 4, </volume> <year> 1992. </year>
Reference-contexts: They argued that in practice, the implementation schemes and the corresponding overheads may affect the protocol performance, so that they should be carefully analyzed and included in performance study. On the other hand, in <ref> [Hari92] </ref>, a performance crossover point between two-phase locking and optimistic algorithms was shown when their database system was operated over a wide range of workload. They argued that the contradictions are primarily due to basic differences in system workload rather than differences in experimental systems or protocol implementation schemes. <p> However, it is worth noting that in the application domain of RTDBSs, functionality, rather than cost, is often the driving consideration. Because many real-time systems are involved in mission-critical applications and hence sized to handle transient heavy loading, it may be common to provide sufficient resources in RTDBS environment <ref> [Hari92] </ref>. 3.3 Other Issues In this study, we assume that the real-time database system has no pre-knowledge about transaction processing requirements, as such knowledge is difficult to obtain in a general database transaction context where database queries and updates are embedded in application programs. <p> Optimistic approach can avoid such wasted restarts because of its policy of delayed conflict resolution. A more general result of this study is that we have reconfirmed results from previous performance studies on concurrency control in RTDBS including <ref> [Hari90, Hari92, Huan91] </ref>. We have shown that seemingly contradictory performance results, some of which favored locking-based protocol and others of which favored optimistic scheme, are not contradictory at all.
Reference: [Huan89] <author> Huang, J., J. A. Stankovic, D. Towsley and K. Ramamritham, </author> <title> "Experimental Evaluation of Real-Time Transaction Processing," </title> <booktitle> Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <month> Dec. </month> <year> 1989. </year>
Reference: [Huan91] <author> Huang, J., J. A. Stankovic, K. Ramamritham, and D. Towsley, </author> <title> "Experimental Evaluation of Real-Time Optimistic Concurrency Control Schemes," </title> <booktitle> Proceedings of the 17th VLDB Conference, </booktitle> <month> Sep. </month> <year> 1991. </year>
Reference-contexts: The problem of adding transaction timing information to optimistic concurrency control for conflict resolution was also addressed. The work in <ref> [Huan91, Huan91b] </ref> also investigated the performance of various concurrency control protocols. Their work used a real-time database testbed instead of a simulation system for experiments, and focused on the impact of the overhead involved in implementing concurrency control algorithms. <p> These performance studies on real-time concurrency control protocols are informative, but some of the results emerged, instead of being definitive, are contradictory. For example, the studies in [Hari90] suggest that optimistic approach outperforms locking in a real-time database environment, while the experimental results in <ref> [Huan91] </ref> indicate that optimistic protocols may not always outperform priority-cognizant two-phase locking schemes when the physical implementation of concurrency control algorithms is considered. Also, it was reported in [Hari90b] that the use of priority-driven wait mechanism in conflict resolutions further improves the performance of optimistic approach, but the results in [Huan91] <p> <ref> [Huan91] </ref> indicate that optimistic protocols may not always outperform priority-cognizant two-phase locking schemes when the physical implementation of concurrency control algorithms is considered. Also, it was reported in [Hari90b] that the use of priority-driven wait mechanism in conflict resolutions further improves the performance of optimistic approach, but the results in [Huan91] showed that the priority-driven wait strategy has no significant impact on performance. Regarding these apparent contradictions between the results from [Hari90, Hari90b] and 3 [Huan91], possible reasons were examined. In [Huan91], it was pointed out that the contra-dictions come from the fact that unlike theirs, the results from [Hari90, Hari90b] <p> was reported in [Hari90b] that the use of priority-driven wait mechanism in conflict resolutions further improves the performance of optimistic approach, but the results in <ref> [Huan91] </ref> showed that the priority-driven wait strategy has no significant impact on performance. Regarding these apparent contradictions between the results from [Hari90, Hari90b] and 3 [Huan91], possible reasons were examined. In [Huan91], it was pointed out that the contra-dictions come from the fact that unlike theirs, the results from [Hari90, Hari90b] are based on simulation experiments, where optimistic concurrency control is carried out at the logical level and detailed implementation issues at the physical level are <p> use of priority-driven wait mechanism in conflict resolutions further improves the performance of optimistic approach, but the results in <ref> [Huan91] </ref> showed that the priority-driven wait strategy has no significant impact on performance. Regarding these apparent contradictions between the results from [Hari90, Hari90b] and 3 [Huan91], possible reasons were examined. In [Huan91], it was pointed out that the contra-dictions come from the fact that unlike theirs, the results from [Hari90, Hari90b] are based on simulation experiments, where optimistic concurrency control is carried out at the logical level and detailed implementation issues at the physical level are ignored 1 . <p> In addition, forward scheme generally detects and resolves data conflicts earlier than backward validation, and hence it wastes less resources and time. All the optimistic algorithms used in the previous studies of real-time concurrency control in <ref> [Hari90, Hari90b, Huan91] </ref> are based on the forward validation. The broadcast mechanism in the algorithm, OPT-BC used in [Hari90, Robi82] is an implementation variant of the forward validation. We refer to the optimistic algorithm using forward validation as OCC-FV. <p> Thus, under OCC-FV, a transaction with a higher priority may need to restart due to a committing transaction with a lower priority. Several methods to incorporate priority information into OCC-FV were proposed and studied in <ref> [Hari90b, Huan91] </ref>, using priority-driven wait or abort mechanism. <p> This difficulty also applies to performance study using actual systems or a testbed, because the implementation costs often vary from one system to another. Considering these issues, we decided to use a locking mechanism for the implementation of optimistic protocols. The mechanism is based on the one proposed in <ref> [Huan91] </ref>. In this mechanism, the system maintains a system-wide lock table, LT, for recording data accesses by all concurrently executing transactions. There are two lock modes: read-phase lock (R-lock) and validation-phase lock (V-lock). An R-lock is further classified by the type of the data operation, i.e., read and write operation. <p> This locking-based implementation of validation test is efficient because its complexity is independent of the number of active transactions. In addition, it determines fair implementation costs for the two algorithms due to their common ground on lock table management. It was shown in <ref> [Huan91] </ref> that the physical operations on the lock table of this implementation of optimistic protocols are almost the same as those of locking protocols. Those operations include setting of R-locks, upgrading of R-locks to V-locks, and releasing of R-locks and V-locks. <p> In [Agra87, Care84], it was concluded that two-phase locking was found to outperform optimistic algorithm in an environment where physical resources are limited. The result of better performance of 2PL-HP than OCC-FV also agrees with that of the 22 experimental study in <ref> [Huan91] </ref>. This result is reasonable because the experimental environ-ment used in [Huan91] is characterized as a soft deadline system with limited resources. In their system, all transactions are required to complete eventually regardless of whether they meet deadlines or not. <p> The result of better performance of 2PL-HP than OCC-FV also agrees with that of the 22 experimental study in <ref> [Huan91] </ref>. This result is reasonable because the experimental environ-ment used in [Huan91] is characterized as a soft deadline system with limited resources. In their system, all transactions are required to complete eventually regardless of whether they meet deadlines or not. <p> As other actual testbed systems for performance evaluation study, their system is limited by the amount of physical resources. A point to note is that while our simulation model is based on an open model, the work in <ref> [Huan91] </ref> used a closed queueing model where the number of active transactions in the system, i.e., the multiprogramming level, is limited at any time. Thus in the study in [Huan91], the system was not driven beyond the point where the system is saturated. 5.2 Experiment 2: Soft Deadline and Infinite Resources <p> A point to note is that while our simulation model is based on an open model, the work in <ref> [Huan91] </ref> used a closed queueing model where the number of active transactions in the system, i.e., the multiprogramming level, is limited at any time. Thus in the study in [Huan91], the system was not driven beyond the point where the system is saturated. 5.2 Experiment 2: Soft Deadline and Infinite Resources In this experiment, we study the comparative performance of the two concurrency control algorithms when the amount of available resources is infinite. <p> Optimistic approach can avoid such wasted restarts because of its policy of delayed conflict resolution. A more general result of this study is that we have reconfirmed results from previous performance studies on concurrency control in RTDBS including <ref> [Hari90, Hari92, Huan91] </ref>. We have shown that seemingly contradictory performance results, some of which favored locking-based protocol and others of which favored optimistic scheme, are not contradictory at all.
Reference: [Huan91b] <author> Huang, J., J. A. Stankovic, K. Ramamritham, and D. Towsley, </author> <title> "On Using Priority Inheritance in Real-Time Databases," </title> <booktitle> Proceedings of the IEEE Real-Time System Symposium, </booktitle> <month> Dec. </month> <year> 1991. </year> <month> 28 </month>
Reference-contexts: The work proposed new policies for priority assignment and eligibility test in RTDBSs, and evaluated the performance of various scheduling policies through simulation. A group of concurrency control protocols for RTDBSs using two-phase locking as the underlying mechanism was also proposed and evaluated. Studies in <ref> [Abbo89, Huan91b, Sha88, Sha91] </ref> addressed the problem of priority inversion in the context of RTDBSs where locking and priority-driven preemptive scheduling for CPU scheduling are integrated together. A priority inversion occurs when a higher priority transaction must wait for the execution of lower priority transaction (s). <p> The problem of adding transaction timing information to optimistic concurrency control for conflict resolution was also addressed. The work in <ref> [Huan91, Huan91b] </ref> also investigated the performance of various concurrency control protocols. Their work used a real-time database testbed instead of a simulation system for experiments, and focused on the impact of the overhead involved in implementing concurrency control algorithms. <p> Under this situation, the behavior of the RTDBS would effectively reduce to that of a conventional database system. Experimental performance evaluation of real-time concurrency control algorithms in <ref> [Abbo89, Huan91b] </ref> confirmed that the performance of 2PL-WP degrades rapidly under high data contention situations. In [Huan91b], a protocol that combines High Priority and Wait Promote schemes for conflict resolution is studied and reported to have superior performance. <p> Under this situation, the behavior of the RTDBS would effectively reduce to that of a conventional database system. Experimental performance evaluation of real-time concurrency control algorithms in [Abbo89, Huan91b] confirmed that the performance of 2PL-WP degrades rapidly under high data contention situations. In <ref> [Huan91b] </ref>, a protocol that combines High Priority and Wait Promote schemes for conflict resolution is studied and reported to have superior performance. <p> Another problem of this scheme is wasted sacrifice. A wasted sacrifice occurs when a transaction is sacrificed on behalf of another transaction that is later discarded. 8 In <ref> [Huan91b] </ref>, a similar optimistic scheduler was described. In this protocol, when a transaction reaches its validation phase, it is aborted if its priority is less than that of all the conflicting transactions; otherwise, it commits and all the conflicting transactions restart immediately as in OCC-FV.
Reference: [Jens85] <author> Jensen, E. D., C. D. Locke, and H. Tokuda, </author> <title> "A Time-Driven Scheduling Model for Real-Time Operating Systems," </title> <booktitle> Proceedings of the IEEE Real-Time System Symposium, </booktitle> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: viewed using the 2 Database systems for efficiently supporting hard deadline applications, where all transaction deadlines have to be met, appear infeasible due to the large variance between the average case and worst case execution times of a typical database transaction [Rama92, Stan88]. 12 value function model for real-time scheduling <ref> [Jens85] </ref>. The key idea of the value function model is that the completion of a transaction has a value to the application that can be expressed as a function of the completion time. Figure 1 shows simple value functions of soft-deadline and firm-deadline.
Reference: [Klei75] <author> Kleinrock, L., </author> <title> Queueing Systems, Vol. I, </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: Then the probability that it misses its deadline is equal to the probability that it must wait in the server queue more than s time units. Given an M/M/1 system with mean inter-arrival time 1= and mean service time 1.0, the waiting time distribution W (s) is given by <ref> [Klei75] </ref>: W (s) = P r [time spent in queue s] = 1 e (1)s : Thus the probability that the transaction waits more than s time units and misses its deadline is 1W (s). To compute the expected probability of missed deadline, we need the distribution 14 of s. <p> Given an M=M=1=N system with mean inter-arrival time 1= and mean service time 1.0, the blocking probability, i.e., M P F D is given by <ref> [Klei75] </ref>: M P F D = ((1 )=(1 N+1 )) N : A sample graph of M P F D versus for N = 10 is shown in Figure 2 (b).
Reference: [Kung81] <author> Kung H.T., and J. T. Robinson, </author> <title> "On Optimistic Methods for Concurrency Control," </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(2): </volume> <pages> 213-226, </pages> <month> June </month> <year> 1981. </year>
Reference-contexts: Most of the proposed algorithms are based on one of the two basic mechanisms: two-phase locking (2PL) [Eswa76] 2 and optimistic concurrency control (OCC) <ref> [Kung81] </ref>, and use priority information in the resolution of data conflicts, that is, resolve data conflicts always in favor of the higher priority transaction. The problem of scheduling transactions in an RTDBS with the objective of minimizing the percentage of transactions missing its deadline was first addressed in [Abbo88, Abbo89]. <p> Thus, the execution of a transaction consists of three phases: read, validation, and write <ref> [Kung81] </ref>. The key component among these is the validation phase where a transaction's destiny is decided. Validation comes in several flavors, but it can carried out basically in either of two ways: backward validation and forward validation [Haer84].
Reference: [Kuo92] <author> Kuo, T.-W., and A. K. Mok, </author> <title> "Application Semantics and Concurrency Control of Real-Time Data-Intensive Applications," </title> <booktitle> Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <month> Dec </month> <year> 1992. </year>
Reference-contexts: We also assume that data consistency is enforced in our real-time database system. Most work on real-time concurrency control uses the notion of serializability as the correctness criterion. While some work considers relaxation of consistency requirements using such correctness criteria as epsilon-serializability [Pu92] and similarity <ref> [Kuo92] </ref> based on the argument that it is desirable to trade-off data consistency temporarily to some degree for 16 timeliness, currently no general method is available to implement such ideas. 4 Experimental Environment This section outlines the structure and details of our simulation model and experimental environment which were used to
Reference: [Lamp78] <author> Lamport, L., </author> <title> "Time, Clocks, and Ordering of Events in a Distributed System," </title> <journal> Comm. of ACM, </journal> <month> July </month> <year> 1978. </year>
Reference-contexts: A point to note here is that although another extensively studied concurrency control mechanism in conventional database systems, timestamp ordering <ref> [Lamp78] </ref> could have been used as a basic concurrency control for RTDBSs, very little work has been done in that direction.
Reference: [Lin90] <author> Lin, Y., and S. H. Son, </author> <title> "Concurrency Control in Real-Time Database Systems by Dynamic Adjustment of Serialization Order," </title> <booktitle> Proceedings of the 11th IEEE Real-Time Systems Symposium, </booktitle> <address> Orlando, Florida, </address> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: This condition appears unapplicable to many database applications, since in many cases, transaction execution is data dependent. Moreover, the scheme becomes extremely conservative, with respect to the degree of concurrency, if transactions can access any data objects in the database. 2.1.4 RTL In <ref> [Lin90] </ref>, a protocol called Real-Time Locking (RTL) that uses locking and dynamic adjustment of serialization order for priority conflict resolution was proposed.
Reference: [Liu73] <author> Liu, C. L., and J. Layland, </author> <title> "Scheduling Algorithms for Multiprogramming in a Hard Real-Time Environment," </title> <journal> J.ACM, </journal> <volume> 10(1), </volume> <year> 1973. </year>
Reference-contexts: This value is used only for the above deadline-assignment formula, but not used for any other purpose including conflict resolution decisions in concurrency control. In this system, the priorities of transactions are assigned by the Earliest Deadline First policy <ref> [Liu73] </ref>, which uses only deadline information to decide transaction priority, but not any other information on transaction execution time. Finally, the base values for parameters shown in Tables 1 and 2 are not meant to model a specific real-time application.
Reference: [Pedg90] <author> Pegden, C. D., R. Shannon, and R. Sadowski, </author> <title> Introduction to Simulation Using SIMAN, </title> <publisher> McGraw-Hill, Inc., </publisher> <address> NJ, </address> <year> 1990. </year>
Reference-contexts: The average data blocking time and average resource queueing time are normalized on a per-blocking basis. 5 Experiments and Results The simulation program was written in SIMAN, a discrete-event simulation language <ref> [Pedg90] </ref>. The data collection in the experiments is based on the method of replication. For each experiment, we ran the simulation with the same parameter values for at least 10 different random number seeds. Each run continued until 1,000 transactions were executed.
Reference: [Pu92] <author> Pu, C., and Krithi Ramamritham, </author> <title> "A Formal Characterization of Epsilon Seri-alizability," </title> <type> Technical Report, </type> <institution> Department of Computer Science, University of Massachusetts at Amherst,1992. </institution>
Reference-contexts: We also assume that data consistency is enforced in our real-time database system. Most work on real-time concurrency control uses the notion of serializability as the correctness criterion. While some work considers relaxation of consistency requirements using such correctness criteria as epsilon-serializability <ref> [Pu92] </ref> and similarity [Kuo92] based on the argument that it is desirable to trade-off data consistency temporarily to some degree for 16 timeliness, currently no general method is available to implement such ideas. 4 Experimental Environment This section outlines the structure and details of our simulation model and experimental environment which
Reference: [Rama92] <author> Ramamritham, K., </author> <title> "Real-Time Databases," </title> <journal> International Journal of Distributed and Parallel Databases, </journal> <volume> Vol. 1, No. 1, </volume> <year> 1992. </year>
Reference-contexts: In RTDBSs, the primary performance criterion is timeliness level and not average response time or throughput, and scheduling of transactions is driven by priority considerations rather than fairness considerations <ref> [Rama92] </ref>. Given these differences, considerable research has recently been devoted to designing concurrency control algorithms for RTDBSs and to evaluating their performance. <p> The categorization of soft-deadline and firm-deadline transactions can be viewed using the 2 Database systems for efficiently supporting hard deadline applications, where all transaction deadlines have to be met, appear infeasible due to the large variance between the average case and worst case execution times of a typical database transaction <ref> [Rama92, Stan88] </ref>. 12 value function model for real-time scheduling [Jens85]. The key idea of the value function model is that the completion of a transaction has a value to the application that can be expressed as a function of the completion time.
Reference: [Robi82] <author> Robinson, J. T., </author> <title> "Design of Concurrency Controls for Transaction Processing Systems," </title> <type> Ph.D. Thesis, Technical Report CMU-CS-82-114, </type> <institution> Carnegie-Mellon University, </institution> <year> 1982. </year>
Reference-contexts: All the optimistic algorithms used in the previous studies of real-time concurrency control in [Hari90, Hari90b, Huan91] are based on the forward validation. The broadcast mechanism in the algorithm, OPT-BC used in <ref> [Hari90, Robi82] </ref> is an implementation variant of the forward validation. We refer to the optimistic algorithm using forward validation as OCC-FV. A point to note is that unlike 2PL-HP, OCC-FV does not use any transaction priority information in resolving data conflicts.
Reference: [Rose78] <author> Rosenkrantz, D. J., R. E. Stern, and P. M. Lewis, </author> <title> "II System Level Concurrency Control for Distributed Database Systems," </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 3(2), </volume> <pages> pp 178-198, </pages> <month> June </month> <year> 1978. </year>
Reference-contexts: This protocol is referred to as 2PL-HP [Abbo88]. It is important to note that 2PL-HP loses some of the basic 2PL algorithm's blocking factor due to the partially restart-based nature of the High Priority scheme. Note that High Priority scheme is similar to Wound-Wait scheme <ref> [Rose78] </ref>, which is added to two-phase locking for deadlock prevention. The only difference is that High Priority scheme uses priority order decided by transaction timing constraints for conflict resolution decisions, while Wound-Wait employs timestamp order usually decided by transaction arrival 5 time.
Reference: [Sha87] <author> Sha, L., R. Rajkumar, and J. P. Lehoczky, </author> <title> "Priority Inheritance Protocol: An Approach to Real-Time Synchronization," </title> <type> Technical Report, </type> <institution> Computer Science Department, Carnegie-Mellon University, </institution> <year> 1987. </year>
Reference-contexts: Also, note that 2PL-HP is free from priority inversion problem, because a higher priority transaction never waits for a lower priority transaction, but restarts it. 2.1.2 2PL-WP 2PL-WP (Wait Promote) [Abbo89] retains the blocking policy and hence resource-conservation feature of the basic 2PL, employing priority inheritance mechanism <ref> [Sha87] </ref> for conflict resolution. Priority Inheritance was devised to solve the problem of priority inversion. Under this policy, when a priority inversion occurs, the lower priority transaction holding the lock will execute at the highest priority among the transactions waiting for the lock, until it releases the lock.
Reference: [Sha88] <author> Sha, L., R. Rajkumar, and J. P. Lehoczky, </author> <title> "Concurrency Control for Distributed Real-Time Databases," </title> <booktitle> ACM SIGMOD Record, </booktitle> <month> March </month> <year> 1988. </year> <month> 29 </month>
Reference-contexts: The work proposed new policies for priority assignment and eligibility test in RTDBSs, and evaluated the performance of various scheduling policies through simulation. A group of concurrency control protocols for RTDBSs using two-phase locking as the underlying mechanism was also proposed and evaluated. Studies in <ref> [Abbo89, Huan91b, Sha88, Sha91] </ref> addressed the problem of priority inversion in the context of RTDBSs where locking and priority-driven preemptive scheduling for CPU scheduling are integrated together. A priority inversion occurs when a higher priority transaction must wait for the execution of lower priority transaction (s). <p> Integrating the priority ceiling policy with locking for RTDBSs results in 2PL-PC protocol <ref> [Sha88] </ref>. This scheme appears to be promising for hard real-time environment since it 6 prevents deadlock formation and strictly bounds transaction blocking duration caused by priority inversion problem. However, this scheme requires a priori knowledge about data objects to be accessed by each transaction.
Reference: [Sha91] <author> Sha, L., R. Rajkumar, S. H. Son, and C. Chang, </author> <title> "A Real-Time Locking Proto--col," </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 40, No. 7, </volume> <month> July </month> <year> 1991, </year> <pages> pp. 793-800. </pages>
Reference-contexts: The work proposed new policies for priority assignment and eligibility test in RTDBSs, and evaluated the performance of various scheduling policies through simulation. A group of concurrency control protocols for RTDBSs using two-phase locking as the underlying mechanism was also proposed and evaluated. Studies in <ref> [Abbo89, Huan91b, Sha88, Sha91] </ref> addressed the problem of priority inversion in the context of RTDBSs where locking and priority-driven preemptive scheduling for CPU scheduling are integrated together. A priority inversion occurs when a higher priority transaction must wait for the execution of lower priority transaction (s).
Reference: [Son90] <author> S. H. Son, </author> <title> "Real-Time Database Systems: A New Challenge," </title> <journal> IEEE Data Engineering, </journal> <volume> 13(4), </volume> <booktitle> Special Issue on Directions for Future Database Research and Development, </booktitle> <month> December </month> <year> 1990, </year> <pages> pp 39-43. </pages>
Reference-contexts: 1 Introduction Real-Time Database Systems (RTDBSs) are vital to a wide range of operations. As computers have been faster and more powerful, and their use more widespread, real-time database systems have grown larger and become more critical <ref> [Son90] </ref>. For example, they are used in program stock trading, telephone switching systems, virtual environment systems, network management, automated factory management, and command and control systems.
Reference: [Son92] <author> Son, S. H., S. Park, and Y. Lin, </author> <title> "An Integrated Real-Time Locking Protocol," </title> <booktitle> IEEE Conference on Data Engineering, </booktitle> <month> February </month> <year> 1992, </year> <journal> pp. </journal> <volume> 527-534. 30 31 32 33 34 35 36 37 38 </volume>
References-found: 30

