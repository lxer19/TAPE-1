URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr93/tr93-005.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr93-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: A Prioritized Multiprocessor Spin Lock  
Author: Theodore Johnson Krishna Harathi 
Keyword: mutual exclusion, parallel processing, real time system, spin-lock, priority queue.  
Affiliation: Dept. of Computer and Information Science University of Florida  
Abstract: In this paper, we present the PR-lock, a prioritized spin-lock mutual exclusion algorithm for real time systems. The PR-lock is a contention-free spin lock, in which blocked processes spin on locally stored or cached variables. In contrast to previous work on prioritized spin locks, our algorithm maintains a pointer to the lock holder. As a result, our spin lock can support priority inheritance protocols. In addition, all work to maintain a priority queue is done while a process acquires a lock, when it is blocked anyway. Releasing a lock is a constant time operation. We present simulation results that demonstrate the prioritized acquisition of locks, and compare the performance of the PR-lock against that of an alternative prioritized spin lock. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. E. Anderson. </author> <title> The performance of spin lock alternatives for shared memory multiprocessors. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 6-16, </pages> <year> 1990. </year>
Reference-contexts: Busy waiting is effective when the critical section is small and the processor resources are not needed by other processes in the interim. However, a spin-lock is usually not fair, and a naive implementation can severely limit performance due to network and memory contention <ref> [1, 11] </ref>. A careful design can avoid contention by requiring processes to spin on locally stored or cached variables [19]. In real time systems, each process has timing constraints and is associated with a priority indicating the urgency of that process [26]. <p> The MCS-lock grants lock requests in FIFO order, and blocked processes spin on locally accessible flag variables only, avoiding the contention usually associated with busy-waiting in multiprocessors <ref> [1, 11] </ref>. Each process has a record that represents its place in the lock queue. The MCS-lock algorithm maintains a pointer to the tail of the lock queue. A process adds itself to the queue by swapping the current contents of the tail pointer for the address of its record.
Reference: [2] <author> G.R. Andrews. </author> <booktitle> Concurrent Programming Principles and Practice. </booktitle> <address> Benjamin/Cummings, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Mutual exclusion is a fundamental synchronization primitive for exclusive access to critical sections or shared resources on multiprocessors [17]. The spin-lock is one of the mechanisms that can be used to provide mutual exclusion on shared memory multiprocessors <ref> [2] </ref>. A spin-lock usually is implemented using atomic read-modify-write instructions such as Test&Set or Compare&Swap, which are available on most shared-memory multiprocessors [16]. Busy waiting is effective when the critical section is small and the processor resources are not needed by other processes in the interim.
Reference: [3] <author> Inc. </author> <title> BBN Advanced Computers. Tc2000 programming handbook. </title> <type> 23 </type>
Reference-contexts: The underlying multiprocessor architecture supports an atomic Compare&Swap instruction. We note that many parallel architectures support this instruction, or a related instruction <ref> [13, 21, 3, 28] </ref>. 2. The multiprocessor has shared memory with coherent caches, or has locally-stored but globally accessible shared memory. 3. Each processor has a record to place in the queue for each lock. In a NUMA architecture, this record is allocated in the local, but globally accessible, memory.
Reference: [4] <author> E.A. Brewer, Chrysanthos, and N. Dellarocas. </author> <title> PROTEUS user documentation. </title> <type> Technical report, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1991. </year>
Reference-contexts: The process can't distinguish between these possibilities, so it must re-search the lock queue. 5 Simulation Results We simulated the execution of the PR-lock algorithm in PROTEUS, which is a configurable multiprocessor simulator <ref> [4] </ref>. We also implemented the MCS-lock and Markatos' lock to demonstrate the difference in the acquisition and release time characteristics. In the simulation, we use a multiprocessor model with eight processors and a global shared memory. Each processor has a local cache memory of 2048 bytes size.
Reference: [5] <author> J.E. Burns. </author> <title> Mutual exclusion with linear waiting using binary shared variables. </title> <journal> SIGACT News, </journal> <volume> 10(2), </volume> <year> 1978. </year>
Reference-contexts: If no successor exists, the lock holder sets the tail pointer to nil using a Compare&Swap instruction. 2 Molesky, Shen, and Zlokapa [20] describe a prioritized spin lock that uses the test-and-set instruction. Their algorithm is based on Burn's fair test-and-set mutual exclusion algorithm <ref> [5] </ref>. However, this lock is not contention-free. Markatos and LeBlanc [18] presents a prioritized spin-lock algorithm based on the MCS-lock algorithm. Their acquire lock algorithm is almost the same as the MCS acquire lock algorithm, with the exception that Markatos' algorithm maintains a doubly linked list.
Reference: [6] <author> K.M. Chandy and L. Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <year> 1985. </year>
Reference-contexts: Similarly, when a process executes the decisive instruction for a release lock operation, Q changes state to dequeue (Q). We show that when we observe L, we find a structure that is equivalent to Q. To observe L, we take a consistent snapshot <ref> [6] </ref> of the current state of the system memory. Next, we start at the lock pointer L and observe the records following the linked list. If the head record has its Dq bit set and its process has exited the acquire lock operation, then we discard it from our observation.
Reference: [7] <author> M.I. Chen and K.J. Lin. </author> <title> Dynamic priority ceiling: A concurrency control protocol for real-time systems. </title> <journal> Real-Time Systems Journal, </journal> <volume> 2(4) </volume> <pages> 325-346, </pages> <year> 1990. </year>
Reference-contexts: For example, the Priority Ceiling protocol [24] guarantees that a high priority process is blocked by a lower priority process for the duration of at most one critical section. The Priority Ceiling protocol has been extended to handle dynamic-priority schedulers <ref> [7] </ref> and multiprocessors [23, 8]. Our contribution over previous work in developing prioritized contention-free spin locks ([18] and [10]) is to more directly implement the desired priority queue. Our algorithm maintains a pointer to the head of the lock queue, which is the record of the lock holder.
Reference: [8] <author> M.I. Chen and K.J. Lin. </author> <title> A priority ceiling protocol for multiple-instance resources. </title> <booktitle> In Real Time Systems Symposium, </booktitle> <pages> pages 140-149, </pages> <year> 1990. </year>
Reference-contexts: For example, the Priority Ceiling protocol [24] guarantees that a high priority process is blocked by a lower priority process for the duration of at most one critical section. The Priority Ceiling protocol has been extended to handle dynamic-priority schedulers [7] and multiprocessors <ref> [23, 8] </ref>. Our contribution over previous work in developing prioritized contention-free spin locks ([18] and [10]) is to more directly implement the desired priority queue. Our algorithm maintains a pointer to the head of the lock queue, which is the record of the lock holder.
Reference: [9] <author> C.L.Liu and W.J. Leyland. </author> <title> Scheduling algorithms for multiprogramming in a hard real-time environment. </title> <journal> JACM, </journal> <volume> 20(1) </volume> <pages> 46-63, </pages> <year> 1973. </year>
Reference-contexts: The holder of the token enters the critical section. The utility of prioritized locks is demonstrated by rate monotonic scheduling theory <ref> [9, 24] </ref>. Suppose there are N periodic processes T 1 ; T 2 ; T 3 ; : : : ; T N on a uniprocessor. Let E i and C i represent the execution time and the cycle time (periodicity) of the process T i . <p> Let E i and C i represent the execution time and the cycle time (periodicity) of the process T i . We assume that C 1 C 2 ::: C N . Under the assumption that there is no blocking, <ref> [9] </ref> show that if for each j j X E i =C i j 2 1=j 1 Then all processes can meet their deadlines. Suppose that B j is the worst case blocking time that process T j will incur.
Reference: [10] <author> T.S. Craig. </author> <title> Queuing spin lock alternatives to support timing predictability. </title> <type> Technical report, </type> <institution> University of Washington, </institution> <year> 1993. </year>
Reference-contexts: In addition, the work of maintaining the priority queue is performed when a lock is released. This choice makes the time to release a lock unpredictable, and significantly increases the time to acquire or release a lock (as is shown in section 5). Craig <ref> [10] </ref> proposes a modification to the MCS lock and to Markatos' lock that substitutes an atomic Swap for the Compare&Swap instruction, and permits nested locks using only one lock record per process. Goscinski [12] develops two algorithms for mutual exclusion for real time distributed systems. <p> The Priority Ceiling protocol has been extended to handle dynamic-priority schedulers [7] and multiprocessors [23, 8]. Our contribution over previous work in developing prioritized contention-free spin locks ([18] and <ref> [10] </ref>) is to more directly implement the desired priority queue. Our algorithm maintains a pointer to the head of the lock queue, which is the record of the lock holder. As a result, the PR-lock can be used to implement priority inheritance [24, 23]. <p> The acquire lock and release lock algorithms carry through by modifying the test for being or not being in queue i appropriately. We note that if a process sets nested locks, a new lock record must be used for each level of nesting. Craig <ref> [10] </ref> presents a method for reusing the same record for nested locks. 4.2 Backing Out If a process does not obain the lock after a certain deadline, it might wish to stop waiting and continue processing. The process must first remove its record from the lock queue.
Reference: [11] <author> R.R. Glenn, D.V. Pryor, J.M. Conroy, and T. Johnson. </author> <title> Characterizing memory hotspots in a shared memory mimd machine. In Supercomputing '91. </title> <journal> IEEE and ACM SIGARCH, </journal> <year> 1991. </year>
Reference-contexts: Busy waiting is effective when the critical section is small and the processor resources are not needed by other processes in the interim. However, a spin-lock is usually not fair, and a naive implementation can severely limit performance due to network and memory contention <ref> [1, 11] </ref>. A careful design can avoid contention by requiring processes to spin on locally stored or cached variables [19]. In real time systems, each process has timing constraints and is associated with a priority indicating the urgency of that process [26]. <p> The MCS-lock grants lock requests in FIFO order, and blocked processes spin on locally accessible flag variables only, avoiding the contention usually associated with busy-waiting in multiprocessors <ref> [1, 11] </ref>. Each process has a record that represents its place in the lock queue. The MCS-lock algorithm maintains a pointer to the tail of the lock queue. A process adds itself to the queue by swapping the current contents of the tail pointer for the address of its record.
Reference: [12] <author> A. Goscinski. </author> <title> Two algorithms for mutual exclusion in real-time distributed computer systems. </title> <journal> The Journal of Parallel and Distributed Computing, </journal> <volume> 9 </volume> <pages> 77-82, </pages> <year> 1990. </year>
Reference-contexts: Craig [10] proposes a modification to the MCS lock and to Markatos' lock that substitutes an atomic Swap for the Compare&Swap instruction, and permits nested locks using only one lock record per process. Goscinski <ref> [12] </ref> develops two algorithms for mutual exclusion for real time distributed systems. The algorithms are based on token passing. A process requests the critical section by broadcasting its intention to all other processes in the system.
Reference: [13] <author> M. Herlihy. </author> <title> A methodology for implementing highly concurrent data objects. </title> <type> Technical Report CRL 91/10, </type> <institution> DEC Cambridge Research Lab, </institution> <year> 1991. </year>
Reference-contexts: The underlying multiprocessor architecture supports an atomic Compare&Swap instruction. We note that many parallel architectures support this instruction, or a related instruction <ref> [13, 21, 3, 28] </ref>. 2. The multiprocessor has shared memory with coherent caches, or has locally-stored but globally accessible shared memory. 3. Each processor has a record to place in the queue for each lock. In a NUMA architecture, this record is allocated in the local, but globally accessible, memory.
Reference: [14] <author> M. Herlihy and J. Wing. </author> <title> Linearizability: A correctness condition for concurrent objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <year> 1990. </year>
Reference-contexts: Thus, the equivalent priority queue of a PR-lock is in a single state at any instant, simplifying the correctness proof (a concurrent data structure that is linearizable but not decisive-instruction serializable might be in several states simultaneously <ref> [14] </ref>). We use the following notation in our discussion. PR-lock L has lock pointer L, which points to the first record in the lock queue (and the record of the process that holds the lock).
Reference: [15] <author> J. Hong, X. Tan, and D. Towsley. </author> <title> A performance analysis of minimum laxity and earliest deadline in a real-time system. </title> <journal> IEEE Trans. on Computers, </journal> <volume> 38(12) </volume> <pages> 1736-1744, </pages> <year> 1989. </year>
Reference-contexts: The PR-lock algorithm is suitable for use in systems which either use static-priority schedulers, or use dynamic-priority schedulers in which the relative priorities of existing tasks do not change while blocked (such as Earliest Deadline First [26] or Minimum Laxity <ref> [15] </ref>). The PR-lock is a contention-free lock [19], so its use will not create excessive network or memory contention. The PR-lock maintains a queue of records, with one record for each process that has requested but not yet released the lock.
Reference: [16] <author> C. P. Kruskal, L. Rudolph, and M. Snir. </author> <title> Efficient synchronization on multiprocessors with shared memory. </title> <booktitle> In Proc. 5th ACM Symp on Principles of Distributed Computing, </booktitle> <pages> pages 218-228, </pages> <year> 1986. </year> <month> 24 </month>
Reference-contexts: The spin-lock is one of the mechanisms that can be used to provide mutual exclusion on shared memory multiprocessors [2]. A spin-lock usually is implemented using atomic read-modify-write instructions such as Test&Set or Compare&Swap, which are available on most shared-memory multiprocessors <ref> [16] </ref>. Busy waiting is effective when the critical section is small and the processor resources are not needed by other processes in the interim. However, a spin-lock is usually not fair, and a naive implementation can severely limit performance due to network and memory contention [1, 11].
Reference: [17] <author> Maekawa, Oldehoeft, and Oldehoeft. </author> <title> Operating Systems: </title> <booktitle> Advanced Concepts. </booktitle> <address> Benjamin/Cummings, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction Mutual exclusion is a fundamental synchronization primitive for exclusive access to critical sections or shared resources on multiprocessors <ref> [17] </ref>. The spin-lock is one of the mechanisms that can be used to provide mutual exclusion on shared memory multiprocessors [2]. A spin-lock usually is implemented using atomic read-modify-write instructions such as Test&Set or Compare&Swap, which are available on most shared-memory multiprocessors [16].
Reference: [18] <author> E.P. Markatos and T.J. LeBlanc. </author> <title> Multiprocessor synchronization primitives with priorities. </title> <type> Technical report, </type> <institution> University of Rochester, </institution> <year> 1991. </year>
Reference-contexts: Their algorithm is based on Burn's fair test-and-set mutual exclusion algorithm [5]. However, this lock is not contention-free. Markatos and LeBlanc <ref> [18] </ref> presents a prioritized spin-lock algorithm based on the MCS-lock algorithm. Their acquire lock algorithm is almost the same as the MCS acquire lock algorithm, with the exception that Markatos' algorithm maintains a doubly linked list.
Reference: [19] <author> J.M. Mellor-Crummey and M.L. Scott. </author> <title> Algorithms for scalable synchronization on shared-memory multiprocessors. </title> <journal> ACM Trans. Computer Systems, </journal> <volume> 9(1) </volume> <pages> 21-65, </pages> <year> 1991. </year>
Reference-contexts: However, a spin-lock is usually not fair, and a naive implementation can severely limit performance due to network and memory contention [1, 11]. A careful design can avoid contention by requiring processes to spin on locally stored or cached variables <ref> [19] </ref>. In real time systems, each process has timing constraints and is associated with a priority indicating the urgency of that process [26]. This priority is used by the operating system to order the rendering of services among competing processes. <p> The PR-lock algorithm is suitable for use in systems which either use static-priority schedulers, or use dynamic-priority schedulers in which the relative priorities of existing tasks do not change while blocked (such as Earliest Deadline First [26] or Minimum Laxity [15]). The PR-lock is a contention-free lock <ref> [19] </ref>, so its use will not create excessive network or memory contention. The PR-lock maintains a queue of records, with one record for each process that has requested but not yet released the lock. <p> In Section 6 we conclude this paper by suggesting some applications and future extensions to the PR-lock algorithm. 1.1 Previous Work Our PR-lock algorithm is based on the MCS-lock algorithm, which is a spin-lock mutual exclusion algorithm for shared-memory multiprocessors <ref> [19] </ref>. The MCS-lock grants lock requests in FIFO order, and blocked processes spin on locally accessible flag variables only, avoiding the contention usually associated with busy-waiting in multiprocessors [1, 11]. Each process has a record that represents its place in the lock queue.
Reference: [20] <author> L.D. Molesky, C. Shen, and G. Zlokapa. </author> <title> Predictable synchronization mechanisms for real-time systems. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 2(3) </volume> <pages> 163-180, </pages> <year> 1990. </year>
Reference-contexts: The head of the queue is the record of the lock holder. The lock holder releases the lock by reseting the flag of its successor record. If no successor exists, the lock holder sets the tail pointer to nil using a Compare&Swap instruction. 2 Molesky, Shen, and Zlokapa <ref> [20] </ref> describe a prioritized spin lock that uses the test-and-set instruction. Their algorithm is based on Burn's fair test-and-set mutual exclusion algorithm [5]. However, this lock is not contention-free. Markatos and LeBlanc [18] presents a prioritized spin-lock algorithm based on the MCS-lock algorithm.
Reference: [21] <author> Motorola. </author> <title> M68000 family programmer's reference manual. </title>
Reference-contexts: The underlying multiprocessor architecture supports an atomic Compare&Swap instruction. We note that many parallel architectures support this instruction, or a related instruction <ref> [13, 21, 3, 28] </ref>. 2. The multiprocessor has shared memory with coherent caches, or has locally-stored but globally accessible shared memory. 3. Each processor has a record to place in the queue for each lock. In a NUMA architecture, this record is allocated in the local, but globally accessible, memory. <p> This sequence of events cannot be detected by the Compare&Swap and is known as the A-B-A problem. Following the work of Prakash et al. [22] and Turek et al. [27], we make use of a double-word Compare&Swap instruction <ref> [21] </ref> to avoid this problem. A counter is appended to Current which is treated as a part of Current. Thus Current consists of two parts: the value part of Current and the counter part of Current. This counter is incremented every time a modification is made to *Current.
Reference: [22] <author> S. Prakash, Y.H. Lee, and T. Johnson. </author> <title> A non-blocking algorithm for shared queues using compare-and-swap. </title> <booktitle> In Proc. Int'l Conf. on Parallel Processing, </booktitle> <pages> pages II68-II75, </pages> <year> 1991. </year>
Reference-contexts: This will occur if *Old is removed from the data structure, then re-inserted as Current with a new object. This sequence of events cannot be detected by the Compare&Swap and is known as the A-B-A problem. Following the work of Prakash et al. <ref> [22] </ref> and Turek et al. [27], we make use of a double-word Compare&Swap instruction [21] to avoid this problem. A counter is appended to Current which is treated as a part of Current. Thus Current consists of two parts: the value part of Current and the counter part of Current. <p> The rest of 6 the bits are used as the actual counter. This technique is similar to the one used by Prakash et al. <ref> [22] </ref> and Turek et al. [27]. Their counter refers to the record referenced by the pointer. In our algorithm, the counter refers to the record that contains the pointer, not the record that is pointed to.
Reference: [23] <author> R. Rajkumar, L. Sha, and J.P. Lehoczky. </author> <title> Real-time synchronization protocols for multiprocessors. </title> <booktitle> In Real Time Systems Symposium, </booktitle> <year> 1988. </year>
Reference-contexts: Normally, the higher the priority of a process, the faster it's request for services gets honored. When the synchronization primitives disregard the priorities, lower priority processes may block the execution of a process with a higher priority and a stricter timing constraint <ref> [24, 23] </ref>. This priority inversion may cause the higher priority process to miss its deadline, leading to a failure of the real time system. Most of the work done in synchronization is not based on priorities, and thus is not suitable for real time systems. <p> The lock keeps a pointer to the record of the lock holder, which aids in the implementation of priority inheritance protocols <ref> [24, 23] </ref>. A task's lock request and release are performed at well-defined points in time, which makes the lock predictable. We present a correctness proof, and simulation results which demonstrate the prioritized lock access, the locality of the references, and the improvement over a previously proposed prioritized spin lock. <p> For example, the Priority Ceiling protocol [24] guarantees that a high priority process is blocked by a lower priority process for the duration of at most one critical section. The Priority Ceiling protocol has been extended to handle dynamic-priority schedulers [7] and multiprocessors <ref> [23, 8] </ref>. Our contribution over previous work in developing prioritized contention-free spin locks ([18] and [10]) is to more directly implement the desired priority queue. Our algorithm maintains a pointer to the head of the lock queue, which is the record of the lock holder. <p> Our algorithm maintains a pointer to the head of the lock queue, which is the record of the lock holder. As a result, the PR-lock can be used to implement priority inheritance <ref> [24, 23] </ref>. The work of maintaining priority ordering is performed in the acquire lock operation, when a task is blocked anyway. The time required to release a lock is small and predictable, which reduces the length and the variance of the time spent in the critical section.
Reference: [24] <author> R. Rajkumar, L. Sha, and J.P. Lehoczky. </author> <title> Priority inheritance protocols: An approach to real-time synchronization. </title> <journal> IEEE Trans. on Computers, </journal> <volume> 39(9) </volume> <pages> 1175-1185, </pages> <year> 1990. </year>
Reference-contexts: Normally, the higher the priority of a process, the faster it's request for services gets honored. When the synchronization primitives disregard the priorities, lower priority processes may block the execution of a process with a higher priority and a stricter timing constraint <ref> [24, 23] </ref>. This priority inversion may cause the higher priority process to miss its deadline, leading to a failure of the real time system. Most of the work done in synchronization is not based on priorities, and thus is not suitable for real time systems. <p> The lock keeps a pointer to the record of the lock holder, which aids in the implementation of priority inheritance protocols <ref> [24, 23] </ref>. A task's lock request and release are performed at well-defined points in time, which makes the lock predictable. We present a correctness proof, and simulation results which demonstrate the prioritized lock access, the locality of the references, and the improvement over a previously proposed prioritized spin lock. <p> The holder of the token enters the critical section. The utility of prioritized locks is demonstrated by rate monotonic scheduling theory <ref> [9, 24] </ref>. Suppose there are N periodic processes T 1 ; T 2 ; T 3 ; : : : ; T N on a uniprocessor. Let E i and C i represent the execution time and the cycle time (periodicity) of the process T i . <p> Under the assumption that there is no blocking, [9] show that if for each j j X E i =C i j 2 1=j 1 Then all processes can meet their deadlines. Suppose that B j is the worst case blocking time that process T j will incur. Then <ref> [24] </ref> show that all tasks can meet their deadlines if j X E i =C i + B j =C j j 2 1=j 1 Thus, the blocking of a high priority process by a lower priority process has a significant impact on the ability of tasks to meet their deadlines. <p> Much work has been done to bound the blocking due to lower priority 3 processes. For example, the Priority Ceiling protocol <ref> [24] </ref> guarantees that a high priority process is blocked by a lower priority process for the duration of at most one critical section. The Priority Ceiling protocol has been extended to handle dynamic-priority schedulers [7] and multiprocessors [23, 8]. <p> Our algorithm maintains a pointer to the head of the lock queue, which is the record of the lock holder. As a result, the PR-lock can be used to implement priority inheritance <ref> [24, 23] </ref>. The work of maintaining priority ordering is performed in the acquire lock operation, when a task is blocked anyway. The time required to release a lock is small and predictable, which reduces the length and the variance of the time spent in the critical section.
Reference: [25] <author> D. Shasha and N. Goodman. </author> <title> Concurrent search structure algorithms. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 53-90, </pages> <year> 1988. </year>
Reference-contexts: The PR-lock is decisive-instruction serializable <ref> [25] </ref>. Both operations of the PR-lock algorithm have a single decisive instruction. The decisive instruction for the acquire lock operation is the successful Compare&Swap and the decisive instruction for the release lock operation is setting the Dq bit.
Reference: [26] <author> J.A. Stankovic and K. Ramamritham. </author> <title> Tutorial Hard Real-Time Systems. </title> <publisher> EEE Computer Society Press, </publisher> <year> 1986. </year>
Reference-contexts: A careful design can avoid contention by requiring processes to spin on locally stored or cached variables [19]. In real time systems, each process has timing constraints and is associated with a priority indicating the urgency of that process <ref> [26] </ref>. This priority is used by the operating system to order the rendering of services among competing processes. Normally, the higher the priority of a process, the faster it's request for services gets honored. <p> In this paper, we present a prioritized spin-lock algorithm, the PR-lock. The PR-lock algorithm is suitable for use in systems which either use static-priority schedulers, or use dynamic-priority schedulers in which the relative priorities of existing tasks do not change while blocked (such as Earliest Deadline First <ref> [26] </ref> or Minimum Laxity [15]). The PR-lock is a contention-free lock [19], so its use will not create excessive network or memory contention. The PR-lock maintains a queue of records, with one record for each process that has requested but not yet released the lock.
Reference: [27] <author> J. Turek, D. Shasha, and S. Prakash. </author> <title> Locking without blocking: Making lock based concurrent data structure algorithms nonblocking. </title> <booktitle> In ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 212-222, </pages> <year> 1992. </year>
Reference-contexts: This will occur if *Old is removed from the data structure, then re-inserted as Current with a new object. This sequence of events cannot be detected by the Compare&Swap and is known as the A-B-A problem. Following the work of Prakash et al. [22] and Turek et al. <ref> [27] </ref>, we make use of a double-word Compare&Swap instruction [21] to avoid this problem. A counter is appended to Current which is treated as a part of Current. Thus Current consists of two parts: the value part of Current and the counter part of Current. <p> The rest of 6 the bits are used as the actual counter. This technique is similar to the one used by Prakash et al. [22] and Turek et al. <ref> [27] </ref>. Their counter refers to the record referenced by the pointer. In our algorithm, the counter refers to the record that contains the pointer, not the record that is pointed to.
Reference: [28] <author> C.-Q Zhu and P.-C. Yew. </author> <title> A synchronization scheme and its applications for large multiprocessor systems. </title> <booktitle> In Proceedings of the 4th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 486-493, </pages> <year> 1984. </year>
Reference-contexts: The underlying multiprocessor architecture supports an atomic Compare&Swap instruction. We note that many parallel architectures support this instruction, or a related instruction <ref> [13, 21, 3, 28] </ref>. 2. The multiprocessor has shared memory with coherent caches, or has locally-stored but globally accessible shared memory. 3. Each processor has a record to place in the queue for each lock. In a NUMA architecture, this record is allocated in the local, but globally accessible, memory.
References-found: 28

