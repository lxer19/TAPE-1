URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr95/tr95-027.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr95-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: Optimized Rule Condition Testing in Ariel using Gator Networks  
Author: Eric N. Hanson, Sreenath Bodagala, Mohammed Hasan, Goutam Kulkarni and Jayashree Rangarajan 
Address: 301 CSE, P.O. Box 116120  Gainesville, FL 32611-6120  
Affiliation: Rm.  CISE Department University of Florida  
Pubnum: TR-95-027  
Email: hanson@cis.ufl.edu  
Web: http://www.cis.ufl.edu/~hanson/  
Date: 23 October 1995  
Abstract: This paper presents a new active database discrimination network algorithm called Gator, and its implementation in a modified version of the Ariel active DBMS. Gator is a generalization of the widely known Rete and TREAT algorithms, and is designed as a target for a discrimination network optimizer. Ariel now has an optimizer that can choose an efficient Gator discrimination network for testing the conditions of a set of rules, given information about the rules, database size and attribute cardinality, and update frequency distribution. The optimizer uses a randomized strategy similar to one which has been successfully used previously to optimize large join queries. Use of Gator gives large speedups (3 times for one realistic rule tested potentially much more) compared with the unoptimized TREAT strategy formerly used in Ariel.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David A. Brant and Daniel P. Miranker. </author> <title> Index support for rule activation. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 42-48, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: For a number of years, the Rete [3] and TREAT [15] discrimination network algorithms have been used in production system implementations. Variations of TREAT have also been used in the Ariel [4, 6] and DATEX <ref> [1] </ref> active database projects. The difficulty with the standard Rete and TREAT algorithms is that they do not provide a way to optimize Rule condition testing based on database size, predicate selectivity, and update patterns.
Reference: [2] <author> L. Brownston, R. Farrell, E. Kant, and N. Martin. </author> <title> Programming Expert Systems in OPS5: an Introduction to Rule-Based Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1985. </year>
Reference-contexts: 1 Introduction A crucial component of an active database system is the mechanism it uses to test rule conditions as the database changes. Tools for artificial intelligence programming known as production systems, such as OPS5 <ref> [2] </ref>, use structures called discrimination networks for rule condition testing. For a number of years, the Rete [3] and TREAT [15] discrimination network algorithms have been used in production system implementations. Variations of TREAT have also been used in the Ariel [4, 6] and DATEX [1] active database projects.
Reference: [3] <author> C. L. Forgy. </author> <title> Rete: A fast algorithm for the many pattern/many object pattern match problem. </title> <journal> Artificial Intelligence, </journal> <volume> 19 </volume> <pages> 17-37, </pages> <year> 1982. </year>
Reference-contexts: Tools for artificial intelligence programming known as production systems, such as OPS5 [2], use structures called discrimination networks for rule condition testing. For a number of years, the Rete <ref> [3] </ref> and TREAT [15] discrimination network algorithms have been used in production system implementations. Variations of TREAT have also been used in the Ariel [4, 6] and DATEX [1] active database projects.
Reference: [4] <author> Eric N. Hanson. </author> <title> Rule condition testing and action execution in Ariel. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 49-58, </pages> <month> June </month> <year> 1992. </year> <month> 22 </month>
Reference-contexts: For a number of years, the Rete [3] and TREAT [15] discrimination network algorithms have been used in production system implementations. Variations of TREAT have also been used in the Ariel <ref> [4, 6] </ref> and DATEX [1] active database projects. The difficulty with the standard Rete and TREAT algorithms is that they do not provide a way to optimize Rule condition testing based on database size, predicate selectivity, and update patterns. <p> be "If a customer of salesperson Iris is interested in a house in a neighborhood that Iris represents, and there is a house available in the customer's desired price range in that neighborhood, make this information known to Iris." This could be expressed as follows in the Ariel rule language <ref> [4] </ref>: define rule IrisRule if salesperson.name = "Iris" and customer.spno = salesperson.spno and customer.cno = desired_nh.cno and salesperson.spno = covers_nh.spno and desired_nh.nno = covers_nh.nno and house.nno = desired_nh.nno and house.price &gt;= customer.minprice and house.price &lt;= customer.maxprice then 2 raise event CustomerHouseMatch ("Iris",customer.cno,house.hno) The raise event command in the rule action is <p> There were seven different types of ff nodes with slightly different behavior (see <ref> [4] </ref> for details). These were implemented as a hierarchy of classes in the E language [17], a form of persistent C++.
Reference: [5] <author> Eric N. Hanson. Gator: </author> <title> A discrimination network suitable for optimizing production rule matching. </title> <type> Technical Report TR-007-93, </type> <institution> University of Florida CIS Dept., </institution> <month> February </month> <year> 1993. </year> <note> http://www.cis.ufl.edu/cis/tech-reports/. </note>
Reference-contexts: This example gives the flavor of how active database rule condition matching is performed by propagating information through a Gator network. A detailed description of how Gator does pattern matching by propagating tokens is not given here due to lack of space, but is presented elsewhere <ref> [5] </ref>. 3 Cost Functions So the optimizer can choose between different Gator networks, a cost estimation function is needed to evaluate the expected cost of a network.
Reference: [6] <author> Eric N. Hanson. </author> <title> The design and implementation of the Ariel active database rule system. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <note> 1995. (to appear). </note>
Reference-contexts: For a number of years, the Rete [3] and TREAT [15] discrimination network algorithms have been used in production system implementations. Variations of TREAT have also been used in the Ariel <ref> [4, 6] </ref> and DATEX [1] active database projects. The difficulty with the standard Rete and TREAT algorithms is that they do not provide a way to optimize Rule condition testing based on database size, predicate selectivity, and update patterns.
Reference: [7] <author> Eric N. Hanson, I-Cheng Chen, Roxana Dastur, Kurt Engel, Vijay Ramaswamy, and Chun Xu. </author> <title> Flexible and recoverable interaction between applications and active databases. </title> <type> Technical Report 94-033, </type> <institution> University of Florida CIS Department, </institution> <month> September </month> <year> 1994. </year> <note> http://www.cis.ufl.edu/cis/tech-reports/. </note>
Reference-contexts: and customer.cno = desired_nh.cno and salesperson.spno = covers_nh.spno and desired_nh.nno = covers_nh.nno and house.nno = desired_nh.nno and house.price &gt;= customer.minprice and house.price &lt;= customer.maxprice then 2 raise event CustomerHouseMatch ("Iris",customer.cno,house.hno) The raise event command in the rule action is used to signal an application program, which would take appropriate action <ref> [7] </ref>. Internally, Ariel represents the condition of a rule as a rule condition graph, similar to a connection graph for a query [20]. The structure of the rule condition graph for IrisRule is shown in figure 1. A Rete network for this rule is shown in figure 2.
Reference: [8] <author> Mohammed Hasan. </author> <title> Optimization of discrimination networks for active databases. </title> <type> Master's thesis, </type> <institution> University of Florida, CIS Department, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: We were motivated to use a randomized approach to Gator network optimization since it has been used successfully for optimizing large join queries [9], a problem with a similarly large search space. We conducted experiments <ref> [8, 16] </ref> which demonstrated that a randomized approach is superior to a dynamic programming approach like that used in traditional query optimizers [18]. <p> Sometimes, the SA phase "pops up" to a higher cost state and then does not find its way back down to the apparent minimum cost state. This is the source of the jagged nature of the curve in figure 10. In extensive prior simulation results <ref> [8, 16] </ref> we noticed that in some cases the SA phase did improve the performance, i.e. 2PO produced better output than II. <p> Iterative improvement has been shown to be a satisfactory optimization strategy for Gator networks. Further work is needed to see whether it is worthwhile to use the more complex two-phase optimization scheme. Randomized optimization of Gator networks is crucial. Our previous simulation results <ref> [8, 16] </ref> illustrate that a traditional dynamic programming approach to Gator network optimization takes too long to optimize rules with more than seven tuple variables. Moreover, a randomized optimizer produces better results (lower-cost Gator networks) even for rules with fewer than seven tuple variables.
Reference: [9] <author> Yiannis Ioannidis and Younkyung Cha Kang. </author> <title> Randomized algorithms for optimizing large join queries. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 312-321, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The optimizer uses the statistics such as update frequencies, sizes etc., maintained in the catalogs for the optimization process. We were motivated to use a randomized approach to Gator network optimization since it has been used successfully for optimizing large join queries <ref> [9] </ref>, a problem with a similarly large search space. We conducted experiments [8, 16] which demonstrated that a randomized approach is superior to a dynamic programming approach like that used in traditional query optimizers [18]. <p> It is interesting to observe that this approach is capable of extricating itself out of the local minimums. However, the low initial temperature makes climbing very high hills virtually impossible. It has been observed that 2PO performs better than both II and SA approaches for optimizing large join queries <ref> [9] </ref>. These generic algorithms require the specification of three problem-specific parameters, namely state space, neighbors function and cost function [11, 9, 10]. For the optimization of the Gator network we defined these parameters as below: 1. <p> It has been observed that 2PO performs better than both II and SA approaches for optimizing large join queries [9]. These generic algorithms require the specification of three problem-specific parameters, namely state space, neighbors function and cost function <ref> [11, 9, 10] </ref>. For the optimization of the Gator network we defined these parameters as below: 1. State Space: The state space of the Gator network optimization problem for a given rule is defined as the set of all possible shapes of the complete Gator network for that rule.
Reference: [10] <author> Yiannis Ioannidis and Younkyung Cha Kang. </author> <title> Left-deep vs. bushy trees: An analysis of strategy spaces and its implications for query optimization. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 168-177, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: It has been observed that 2PO performs better than both II and SA approaches for optimizing large join queries [9]. These generic algorithms require the specification of three problem-specific parameters, namely state space, neighbors function and cost function <ref> [11, 9, 10] </ref>. For the optimization of the Gator network we defined these parameters as below: 1. State Space: The state space of the Gator network optimization problem for a given rule is defined as the set of all possible shapes of the complete Gator network for that rule.
Reference: [11] <author> Yiannis Ioannidis and Eugene Wong. </author> <title> Query optimization by simulated annealing. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1987. </year>
Reference-contexts: The probability with which uphill moves are accepted is controlled by a parameter called temperature. The higher the value of temperature, the higher the probability of an uphill move. However, as the temperature is decreasing with time, the chances of an uphill move tend to zero. See <ref> [13, 11] </ref> for more details on SA. 4.3 Two Phase Optimization As the name `Two Phase Optimization' (2PO) suggests, this approach runs in two phases. In the first phase it runs II for a small period of time, performing a few local optimizations. <p> It has been observed that 2PO performs better than both II and SA approaches for optimizing large join queries [9]. These generic algorithms require the specification of three problem-specific parameters, namely state space, neighbors function and cost function <ref> [11, 9, 10] </ref>. For the optimization of the Gator network we defined these parameters as below: 1. State Space: The state space of the Gator network optimization problem for a given rule is defined as the set of all possible shapes of the complete Gator network for that rule.
Reference: [12] <author> Toru Ishida. </author> <title> An optimization algorithm for production systems. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 6(4) </volume> <pages> 549-558, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: It has been shown that Rete networks can be optimized, giving speedups of a factor of three or more in real OPS5 programs <ref> [12] </ref>. But even optimized Rete networks still have a fixed number of fi nodes, which take time to maintain and use up space. With Gator, it is possible to get additional advantages from optimization, since fi nodes are only materialized when they are beneficial.
Reference: [13] <author> S. Kirkpatrick, C. C. Gelatt, and M. P. Vecchi. </author> <title> Optimization by simulated annealing. </title> <journal> Science, </journal> <volume> 220 </volume> <pages> 671-680, </pages> <year> 1983. </year>
Reference-contexts: This constructor was used to produce random start states for II. 4.2 Simulated Annealing Simulated Annealing (SA) is a Monte Carlo optimization technique proposed by Kirkpatrick et al. <ref> [13] </ref> for problems with many degrees freedom. This is a probabilistic hill-climbing approach where both uphill and downhill moves are accepted. A downhill move (i.e. a move to a lower-cost state) is always accepted. The probability with which uphill moves are accepted is controlled by a parameter called temperature. <p> The probability with which uphill moves are accepted is controlled by a parameter called temperature. The higher the value of temperature, the higher the probability of an uphill move. However, as the temperature is decreasing with time, the chances of an uphill move tend to zero. See <ref> [13, 11] </ref> for more details on SA. 4.3 Two Phase Optimization As the name `Two Phase Optimization' (2PO) suggests, this approach runs in two phases. In the first phase it runs II for a small period of time, performing a few local optimizations.
Reference: [14] <author> Goutam Kulkarni. </author> <title> Extending the Ariel active DBMS with Gator, an optimized discrimination network for rule condition testing. </title> <type> Technical Report TR95-006, </type> <institution> University of Florida, CIS Dept., </institution> <month> February </month> <year> 1995. </year> <type> MS thesis, </type> <note> http://www.cis.ufl.edu/cis/tech-reports/. </note>
Reference-contexts: This paper describes the Gator algorithm, outlines a cost model for Gator networks, and presents how the Gator optimizer and rule condition matching algorithm have been implemented in a modified version of Ariel <ref> [14] </ref>. <p> The final result is the local minimum with the lowest cost. In Ariel, we implemented a random Gator network constructor that builds a complete feasible Gator network for a rule by making random choices about the Gator network structure, avoiding formation of fi nodes that are cross-products <ref> [14] </ref>. This constructor was used to produce random start states for II. 4.2 Simulated Annealing Simulated Annealing (SA) is a Monte Carlo optimization technique proposed by Kirkpatrick et al. [13] for problems with many degrees freedom. This is a probabilistic hill-climbing approach where both uphill and downhill moves are accepted.
Reference: [15] <author> Daniel P. Miranker. </author> <title> TREAT: A better match algorithm for AI production systems. </title> <booktitle> In Proc. AAAI National Conference on Artificial Intelligence, </booktitle> <pages> pages 42-47, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Tools for artificial intelligence programming known as production systems, such as OPS5 [2], use structures called discrimination networks for rule condition testing. For a number of years, the Rete [3] and TREAT <ref> [15] </ref> discrimination network algorithms have been used in production system implementations. Variations of TREAT have also been used in the Ariel [4, 6] and DATEX [1] active database projects.
Reference: [16] <author> Jayashree Rangarajan. </author> <title> A randomized optimizer for rule condition testing in active databases. </title> <type> Master's thesis, </type> <institution> University of Florida, CIS Department, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: We were motivated to use a randomized approach to Gator network optimization since it has been used successfully for optimizing large join queries [9], a problem with a similarly large search space. We conducted experiments <ref> [8, 16] </ref> which demonstrated that a randomized approach is superior to a dynamic programming approach like that used in traditional query optimizers [18]. <p> Sometimes, the SA phase "pops up" to a higher cost state and then does not find its way back down to the apparent minimum cost state. This is the source of the jagged nature of the curve in figure 10. In extensive prior simulation results <ref> [8, 16] </ref> we noticed that in some cases the SA phase did improve the performance, i.e. 2PO produced better output than II. <p> Iterative improvement has been shown to be a satisfactory optimization strategy for Gator networks. Further work is needed to see whether it is worthwhile to use the more complex two-phase optimization scheme. Randomized optimization of Gator networks is crucial. Our previous simulation results <ref> [8, 16] </ref> illustrate that a traditional dynamic programming approach to Gator network optimization takes too long to optimize rules with more than seven tuple variables. Moreover, a randomized optimizer produces better results (lower-cost Gator networks) even for rules with fewer than seven tuple variables.
Reference: [17] <author> Joel E. Richardson, Michael J. Carey, and Daniel T. Schuh. </author> <title> The design of the E programming language. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(3), </volume> <year> 1993. </year>
Reference-contexts: There were seven different types of ff nodes with slightly different behavior (see [4] for details). These were implemented as a hierarchy of classes in the E language <ref> [17] </ref>, a form of persistent C++. Memory nodes in Ariel can be either static, in which case their contents are persistent and are stored between transactions, or dynamic, in which case they are flushed after each transaction.
Reference: [18] <author> P. Selinger et al. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1979. </year> <note> (reprinted in [19]). </note>
Reference-contexts: These selectivity factors are derived from the statistics maintained by the system using techniques similar to the ones used in query optimizers <ref> [18] </ref>. In fact, the same selectivity estimators used by the Ariel query optimizer are used by the Gator network optimizer. 4 Randomized Optimization Strategy For a given rule there could many possible Gator networks. The efficiency of the rule condition testing mechanism depends on the shape of the Gator network. <p> We conducted experiments [8, 16] which demonstrated that a randomized approach is superior to a dynamic programming approach like that used in traditional query optimizers <ref> [18] </ref>. A general description of II, SA and 2PO is given below, followed by a description of how we apply them to Gator optimization. 4.1 Iterative Improvement The Iterative Improvement (II) technique performs a sequence of local optimizations initiated at multiple random starting states. <p> An important objective is to choose a join plan with the minimum cost. However, since choosing token join plans must be done very frequently (hundreds or thousands of times) while finding an optimized Gator network for one rule, it is too expensive to use traditional query optimization <ref> [18] </ref> to find the join order plan. Instead, the following heuristic is used: during each of the two-way joins, the current result should be joined with that sibling that would give the join result with smallest estimated size.
Reference: [19] <author> Michael Stonebraker, </author> <title> editor. </title> <booktitle> Readings in Database Systems. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference: [20] <author> Jeffrey D. Ullman. </author> <title> Principles of Database Systems. </title> <publisher> Computer Science Press, </publisher> <year> 1982. </year> <month> 23 </month>
Reference-contexts: Internally, Ariel represents the condition of a rule as a rule condition graph, similar to a connection graph for a query <ref> [20] </ref>. The structure of the rule condition graph for IrisRule is shown in figure 1. A Rete network for this rule is shown in figure 2. A sample TREAT network for the rule IrisRule is shown in figure 3.
Reference: [21] <author> Yu-wang Wang and Eric N. Hanson. </author> <title> A performance comparison of the Rete and TREAT algorithms for testing database rule conditions. </title> <booktitle> In Proc. IEEE Data Eng. Conf., </booktitle> <pages> pages 88-97, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: In contrast, there is only a single TREAT network for a given rule, and Rete networks are limited to binary-tree structures. It has been observed in a simulation study that TREAT normally outperforms Rete, but the "right" Rete network can vastly outperform TREAT in some situations <ref> [21] </ref>. The reason that TREAT is usually better than Rete is that the cost of maintaining fi nodes usually is greater than their benefit in Rete.
Reference: [22] <author> S. B. Yao. </author> <title> Approximating block accesses in database organizations. </title> <journal> Communications of the ACM, </journal> <volume> 20(4), </volume> <year> 1977. </year> <month> 24 </month>
Reference-contexts: We plan to implement memory node indexes in a future version. For evaluating the update cost we use the Yao approximation for the number of pages that would be touched when k tuples are randomly searched within relations that occupy m pages <ref> [22] </ref>. Insertion of a total of size number of tuples involves bringing in the required pages and writing them back after updating them. If the incoming tuples occupy more than a page, that many new pages have to be fetched, modified and written back to the disk.
References-found: 22

