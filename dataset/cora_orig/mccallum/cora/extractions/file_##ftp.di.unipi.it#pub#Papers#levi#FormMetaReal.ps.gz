URL: file://ftp.di.unipi.it/pub/Papers/levi/FormMetaReal.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: levi@di.unipi.it  
Title: A formalization of metaprogramming for real  
Author: Giorgio Levi Davide Ramundo 
Address: Corso Italia 40, 56125 Pisa, Italy  
Affiliation: Dipartimento di Informatica Universita di Pisa  
Abstract: The paper formally shows that the S-semantics is adequate for reasoning about the soundness and completeness of real Prolog metainterpreters, based on the non-ground representation of object-level variables. The paper extends some recent results by De Schreye and Martens, by proving the "equivalence" between the object program and its version metainterpreted by vanilla for any positive logic program. The same construction is applied to obtain a soundness and completeness result for an enhanced metainterpreter defining various inheritance mechanisms on structured logic programs. We then consider the specialization of metainterpreters by means of partial deduction techniques, both in the case of vanilla and of the inheritance metain-terpreter. We prove that success derivations have exactly the same length in the specialized program and in the "corresponding" object-level program. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt, E. Marchiori, and C. Palamidessi. </author> <title> A theory of first-order built-in's of PROLOG. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Algebraic and Logic Programming, Proceedings of the Third International Conference, volume 632 of Lecture Notes in Computer Science, </booktitle> <pages> pages 69-83. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference: [2] <author> R. Barbuti, M. Codish, R. Giacobazzi, and M. Maher. </author> <title> Oracle Semantics for PROLOG. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Algebraic and Logic Programming, Proceedings of the Third International Conference, volume 632 of Lecture Notes in Computer Science, </booktitle> <pages> pages 100-114. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference: [3] <author> K. Benkerimi and J. W. Lloyd. </author> <title> A Partial Evaluation Procedure for Logic Programs. </title> <editor> In S. K. Debray and M. Hermenegildo, editors, </editor> <booktitle> Proc. of 1990 North American Logic Programming Conference, </booktitle> <pages> pages 343-358. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference: [4] <author> A. Bossi, M. Bugliesi, and M. Fabris. </author> <title> Fixpoint semantics for PROLOG. </title> <editor> In D. S. Warren, editor, </editor> <booktitle> Proc. Tenth Int'l Conf. on Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference: [5] <author> A. Bossi, M. Bugliesi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Differential logic programming. </title> <booktitle> In Proc. Twentieth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 359-370. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: The same approach can be applied to enhanced metainterpreters, provided that we have a "corresponding" pure object-level solution. We show an example using a metainterpreter defining various inheritance mechanisms on hierarchically structured programs, for which there exists an equivalent "flat" object-level program <ref> [5] </ref>. The second problem related to real-life metaprogramming is performance. The practice suggests that the specialization of metaprograms by means of partial deduction techniques should get rid of the overhead caused by the interpretation layer. This has to be formally justified. <p> In the sequel we consider an enhanced metain-terpreter which implements a recently proposed extension of logic programs <ref> [5] </ref> which captures the semantics of static and dynamic extension and overriding. <p> Our metainterpreter implements the inheritance semantics. The results of soundness and completeness are of course related to the "object-level" program dp 2 / dp 1 . This paper cannot provide an adequate description of the semantics of the inheritance mechanism. The interested reader should consult <ref> [5] </ref>. 2.2.1 Differential logic programs A differential logic program is a program dp annotated by three sets of exported predicate symbols, (statically inherited or -predicates), (dynamically inherited or -predicates), fi (extensible or fi-predicates). <p> The operational semantics of isa-hierarchies of differential programs has an alternative and equivalent characterization in terms of a generalized syntactic composition operator / <ref> [5] </ref>. / is right associative and thus a composition dp n / dp n1 /. . . / dp 1 is interpreted as dp n /( dp n1 /. . . / dp 1 ). <p> In the sequel, for any goal G, P red (G) stands for the set of predicate symbols of the atoms occurring in G. The following theorem holds. Theorem 2.14 <ref> [5] </ref> Let HP be an isa-hierarchy and HP / be the correspond ing h; ; fii- differential program. Then for any goal G such that P red (G) ( [ [ fi), HP ` G iff G has an SLD-refutation in HP / with c.a.s. , where GG. <p> Example 2.15 <ref> [5] </ref> The object level differential programs are dp 1 = q (X) h (X) h (a) dp 2 = s (X) r (X) h (X) t (X) dp 3 = s (X) q (X) q (a) Assume the hierarchy is dp 3 isa dp 2 isa dp 1 and the annotations
Reference: [6] <author> K. A. Bowen and R. A. Kowalski. </author> <title> Amalgamating language and metalanguage in logic programming. </title> <editor> In K. L. Clark and S. A. Tarnlund, editors, </editor> <booktitle> Logic Programming, </booktitle> <pages> pages 153-172. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: 1 & . . . &G k )g iff is a correct answer substitution for HP / [ f G 1 ; . . . ; G k g. 2.3 Amalgamation The semantic results obtained so far can be extended to the amalgamation of the object level and the metalevel <ref> [6] </ref>. The textual combination of the object-level program P and its vanilla metainterpreted version V P results in a program P + V P which preserves the properties of equivalence of the S-semantics.
Reference: [7] <author> P. Bruscoli, F. Levi, G. Levi, and M. C. Meo. </author> <title> Compilative constructive negation in CLP. </title> <type> Technical report, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <month> November </month> <year> 1992. </year>
Reference: [8] <author> K. L. Clark. </author> <title> Predicate logic as a computational formalism. Res. </title> <type> Report DOC 79/59, </type> <institution> Imperial College, Dept. of Computing, </institution> <address> London, </address> <year> 1979. </year>
Reference: [9] <author> P. Coscia, P. Franceschi, G. Levi, G. Sardu, and L. Torre. </author> <title> Inference engine definition and compilation in the Epsilon logic programming environment. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 359-373. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference: [10] <author> S. Costantini and G. A. Lanzarone. </author> <title> A metalogic programming language. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proc. Sixth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 218-233. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference: [11] <author> G. Delzanno and M. Martelli. </author> <title> A bottom-up characterization of finite success. </title> <type> Technical report, </type> <institution> Universita di Genova, DISI, </institution> <year> 1992. </year>
Reference: [12] <author> D. De Schreye and B. Martens. </author> <title> A Sensible Least Herbrand Semantics for Untyped Vanilla Meta-Programming and its Extension to a Limited Form of Amalgamation. </title> <editor> In A. Pettorossi, editor, </editor> <booktitle> Proceedings of the third Workshop on Meta-programming in Logic, volume 649 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Thus, when building the least Herbrand model of V P , the variable in the clause definition can be instantiated to values like true, p (a), q (a), etc. The current proposed solutions are the following. * [18] suggests to consider typed programs and metaprograms. * <ref> [12] </ref> characterizes a class of programs (language independent programs) for which the problem does not arise. * [20] establishes the correspondence by considering a suitable subset of the least Herbrand model of V P . <p> As already mentioned, our solution is to move from the least Herbrand model to the S-semantics. As we will show, the language independence property defined by <ref> [12] </ref> holds for any (positive) logic program, when based on the S-semantics. We will then start by considering the results obtained in [12]. Language-independent programs [12] extend the domain independence defined for logic databases in [34]. Definition 2.1 [12] A definite program P with underlying language L P is language independent <p> As already mentioned, our solution is to move from the least Herbrand model to the S-semantics. As we will show, the language independence property defined by <ref> [12] </ref> holds for any (positive) logic program, when based on the S-semantics. We will then start by considering the results obtained in [12]. Language-independent programs [12] extend the domain independence defined for logic databases in [34]. Definition 2.1 [12] A definite program P with underlying language L P is language independent iff, for any extension L P 0 of L P , its least L P 0 -Herbrand model is equal to its <p> As we will show, the language independence property defined by <ref> [12] </ref> holds for any (positive) logic program, when based on the S-semantics. We will then start by considering the results obtained in [12]. Language-independent programs [12] extend the domain independence defined for logic databases in [34]. Definition 2.1 [12] A definite program P with underlying language L P is language independent iff, for any extension L P 0 of L P , its least L P 0 -Herbrand model is equal to its least L P <p> As we will show, the language independence property defined by <ref> [12] </ref> holds for any (positive) logic program, when based on the S-semantics. We will then start by considering the results obtained in [12]. Language-independent programs [12] extend the domain independence defined for logic databases in [34]. Definition 2.1 [12] A definite program P with underlying language L P is language independent iff, for any extension L P 0 of L P , its least L P 0 -Herbrand model is equal to its least L P -Herbrand model. Language independence generalizes range restrictedness, as shown by theorem 2.3. <p> Definition 2.2 A clause in a definite program P is range restricted iff any variable that appears in its head appears also in its body. A definite program is called range restricted iff all its clauses are range restricted. Theorem 2.3 <ref> [12] </ref> A range-restricted definite program is language independent. For language-independent object programs there is a natural correspondence between the least Herbrand models as shown by the following theorem. Theorem 2.4 [12] Let P be a definite language-independent program and V P be its vanilla metainterpreted version. <p> A definite program is called range restricted iff all its clauses are range restricted. Theorem 2.3 <ref> [12] </ref> A range-restricted definite program is language independent. For language-independent object programs there is a natural correspondence between the least Herbrand models as shown by the following theorem. Theorem 2.4 [12] Let P be a definite language-independent program and V P be its vanilla metainterpreted version. Let M P and M V P be the least Herbrand models of P and V P respectively. <p> Corollary 2.8 Every definite program is S-independent from the language. The following theorem gives a semantic characterization of language independent programs as defined in <ref> [12] </ref>. They are exactly those programs for which the S-semantics and the least Herbrand model semantics do coincide. Theorem 2.9 Let P be a definite program and M S P be its least S-model.
Reference: [13] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A new Declarative Semantics for Logic Languages. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 993-1005. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: corresponding operational semantics is: OS P = fp (t 1 ; . . . ; t n ) 2 BS P j X 1 ; . . . ; X n are distinct variables; p (X 1 ; . . . ; X n ) ! fl 2; Theorem 2.5 <ref> [13] </ref> [strong soundness and completeness] Let P be a definite program, G be the goal A 1 ,. . . ,A n .
Reference: [14] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference: [15] <author> G. Ferrand. </author> <title> Error Diagnosis in Logic Programming, an Adaptation of E.Y. Shapiro's Method. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 177-198, </pages> <year> 1987. </year>
Reference: [16] <author> M. Gabbrielli, G. Levi, and D. Turi. </author> <title> A Two Steps Semantics for Logic Programs with Negation. </title> <editor> In A. Voronkov, editor, </editor> <booktitle> Proceedings of the Int'l Conf. on Logic Programming and Automated Reasoning, volume 624 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 297-308. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference: [17] <author> J. Gallagher. </author> <title> Transforming logic programs by specializing interpreters. </title> <booktitle> In ECAI-86 7th European Conference on Artificial Intelligence, </booktitle> <pages> pages 109-122, </pages> <year> 1986. </year>
Reference: [18] <author> P. M. Hill and J. W. Lloyd. </author> <title> Analysis of meta-programs. </title> <editor> In H. Abramson and M.H. Rogers, editors, </editor> <booktitle> Meta-programming in Logic Programming, </booktitle> <pages> pages 23-51. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: Thus, when building the least Herbrand model of V P , the variable in the clause definition can be instantiated to values like true, p (a), q (a), etc. The current proposed solutions are the following. * <ref> [18] </ref> suggests to consider typed programs and metaprograms. * [12] characterizes a class of programs (language independent programs) for which the problem does not arise. * [20] establishes the correspondence by considering a suitable subset of the least Herbrand model of V P .
Reference: [19] <author> P. M. Hill and J. W. Lloyd. </author> <title> The Godel report. </title> <type> Technical Report TR-91-02, </type> <institution> Computer Science Department, University of Bristol, </institution> <year> 1991. </year>
Reference: [20] <author> M. Kalsbeek. </author> <title> The Vanilla meta-interpreter for definite logic programs and ambivalent syntax. </title> <type> Technical Report CT-93-01, </type> <institution> University of Amsterdam, Institute for Logic, Language and Computation, </institution> <year> 1993. </year>
Reference-contexts: The current proposed solutions are the following. * [18] suggests to consider typed programs and metaprograms. * [12] characterizes a class of programs (language independent programs) for which the problem does not arise. * <ref> [20] </ref> establishes the correspondence by considering a suitable subset of the least Herbrand model of V P . As already mentioned, our solution is to move from the least Herbrand model to the S-semantics.
Reference: [21] <author> H. J. Komorowski. </author> <title> Partial evaluation as a means for inferencing data structures in an applicative language: A theory and implementation in the case of PROLOG. </title> <booktitle> In Ninth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 255-267. </pages> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: Our result is a kind of folk theorem which is however a useful step in the derivation of the corresponding result in the case of the inheritance enhanced metainterpreter. The theory of partial deduction in the case of logic programs was started in <ref> [21] </ref> and then fully developed in [25]. We extend that theory by making it parametric wrt a suspension function which is needed in order to control the partial deduction procedure. The problem of how to control the unfolding in the case of specialization of interpreters was considered in [22].
Reference: [22] <author> A. Lakhotia and L. Sterling. </author> <title> How to control unfolding when specializing interpreters. </title> <journal> New Generation Computing, </journal> <volume> 8 </volume> <pages> 61-70, </pages> <year> 1990. </year>
Reference-contexts: We extend that theory by making it parametric wrt a suspension function which is needed in order to control the partial deduction procedure. The problem of how to control the unfolding in the case of specialization of interpreters was considered in <ref> [22] </ref>. Our suspension functions are clearly inspired by the results in [22]. We will first report here some basic notions from [25]. Let A be a finite set of atoms. <p> The problem of how to control the unfolding in the case of specialization of interpreters was considered in <ref> [22] </ref>. Our suspension functions are clearly inspired by the results in [22]. We will first report here some basic notions from [25]. Let A be a finite set of atoms. A set S of atoms is A-closed if every atom of S which contains a predicate symbol occurring in A is an instance of an atom in A. <p> The resulting number of inferences has then to be augmented by n-1. We will now consider the partial deduction of metainterpreted programs, by considering a simple suspension function inspired by <ref> [22] </ref>, which allows us to specialize the metainterpreter without further optimizing the "compiled code".
Reference: [23] <author> G. Levi and D. Ramundo. </author> <title> A formalization of metaprogramming for real. </title> <type> Technical report, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: All the proofs of the new theorems reported in the paper can be found in <ref> [23] </ref>. 2 The semantics 2.1 The vanilla metainterpreter Let V denote the vanilla metainterpreter, i.e. the Horn clause representation of the proof procedure of definite logic programs, using the non-ground representation for object-level variables. 1: demo (true) 2: demo (X&Y ) demo (X); demo (Y ) 3: demo (X) clause (X;
Reference: [24] <author> G. Levi and G. Sardu. </author> <title> Partial Evaluation of metaprograms in a multiple worlds logic language. </title> <journal> New Generation Computing, </journal> <volume> 6 </volume> <pages> 227-247, </pages> <year> 1988. </year>
Reference: [25] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial Evaluation in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 217-242, </pages> <year> 1991. </year>
Reference-contexts: The practice suggests that the specialization of metaprograms by means of partial deduction techniques should get rid of the overhead caused by the interpretation layer. This has to be formally justified. To this aim, we first consider the partial deduction theory developed in <ref> [25] </ref> and we make it parametric wrt a suspension function, to be specified for each metainterpreter. We first formalize the application of this theory to the vanilla metainter-preter. <p> Our result is a kind of folk theorem which is however a useful step in the derivation of the corresponding result in the case of the inheritance enhanced metainterpreter. The theory of partial deduction in the case of logic programs was started in [21] and then fully developed in <ref> [25] </ref>. We extend that theory by making it parametric wrt a suspension function which is needed in order to control the partial deduction procedure. The problem of how to control the unfolding in the case of specialization of interpreters was considered in [22]. <p> The problem of how to control the unfolding in the case of specialization of interpreters was considered in [22]. Our suspension functions are clearly inspired by the results in [22]. We will first report here some basic notions from <ref> [25] </ref>. Let A be a finite set of atoms. A set S of atoms is A-closed if every atom of S which contains a predicate symbol occurring in A is an instance of an atom in A. <p> HIS is the set of histories, where each history is a sequence of goals together with the selected atoms, a sequence of input clauses, a sequence of mgu's and a sequence of suspended goals. Moreover f P (;; A) = no: We can now reformulate the main result in <ref> [25] </ref>, by considering a suspension function whose definition roughly corresponds to the choice of a selection rule.
Reference: [26] <author> B. Martens and D. De Schreye. </author> <title> A Perfect Herbrand Semantics for Untyped Vanilla Meta-Programming. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int'l Conf. and Symposium on Logic Programming, </booktitle> <pages> pages 511-525. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: We have also shown that specialization by means of partial deduction does indeed make metaprogramming feasible, since the specialized program and the corresponding object-level program have equivalent successful derivations. We are currently investigating the extensions of our results to the case of normal programs (considered in <ref> [26] </ref> still in the case of language independent programs) and to the case of approximations of real Prolog, featuring some non-logical primitives.
Reference: [27] <author> B. Martens and D. De Schreye. </author> <title> Why Untyped Meta-Programming is not (much of) a problem. </title> <type> Technical Report CW159, </type> <institution> Katholieke Universiteit Leuven, Department of Computer Science, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: Then demo (A 1 & . . . &A k ) 2 M S V P iff A 1 ; . . . ; A k 2 M S P . The correspondence of the S-models has been independently proved also in <ref> [27] </ref>. 2.1.3 Procedural and declarative equivalences We have shown that there exists a correspondence between the atoms of the S-semantics of a program P and of its metainterpreted version V P . The S-semantics correctly models the computed and correct answer substitutions.
Reference: [28] <author> A. Messora and M. Martelli. </author> <title> Declarative semantics of meta-logic predicates in logic programming. </title> <type> Technical report, </type> <institution> Universita di Genova, DISI, </institution> <year> 1992. </year>
Reference: [29] <author> B. Richards. </author> <title> A point of reference. </title> <journal> Synthese, </journal> <volume> 28 </volume> <pages> 361-454, </pages> <year> 1974. </year>
Reference-contexts: Even if the PROLOG non-ground representation can be understood in terms of the ideas discussed by Richards <ref> [29] </ref>, whose language handles formulas as non-ground terms, we are still left with a problem related to the semantics.
Reference: [30] <author> S. Safra and E. Shapiro. </author> <title> Meta interpreters for real. </title> <editor> In H. J. Kugler, editor, </editor> <booktitle> Information Processing 86, </booktitle> <pages> pages 271-278. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1986. </year>
Reference: [31] <author> L. Sterling and R. D. Beer. </author> <title> Incremental Flavor-Mixing of Meta-interpreters for Expert System Construction. </title> <booktitle> In Proc. Third Logic Programming Symposium, </booktitle> <pages> pages 20-27, </pages> <year> 1986. </year>
Reference: [32] <author> L. Sterling and E. Y. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: According to the theory [6,18], object level formulas (clauses) should be represented as metalevel data (ground terms). This choice, taken also in the design of new logic languages oriented towards metaprogramming [10,19], affects the granularity <ref> [32] </ref> of metainterpreters, leading to metaprograms which are both more complex (unification has to be redefined!) and less efficient.
Reference: [33] <author> A. Takeuchi and K. Furukawa. </author> <title> Partial evaluation of Prolog programs and its application to meta programming. </title> <editor> In H. J. Kugler, editor, </editor> <booktitle> Information Processing 86, </booktitle> <pages> pages 415-420. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1986. </year>
Reference: [34] <author> R. W. Topor and E. A. Sonenberg. </author> <title> On Domain Independent Databases. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 217-240. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1987. </year>
Reference-contexts: As we will show, the language independence property defined by [12] holds for any (positive) logic program, when based on the S-semantics. We will then start by considering the results obtained in [12]. Language-independent programs [12] extend the domain independence defined for logic databases in <ref> [34] </ref>. Definition 2.1 [12] A definite program P with underlying language L P is language independent iff, for any extension L P 0 of L P , its least L P 0 -Herbrand model is equal to its least L P -Herbrand model.
Reference: [35] <author> D. Turi. </author> <title> Extending S-Models to Logic Programs with Negation. </title> <editor> In K. Fu-rukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 397-411. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference: [36] <author> R. Venken. </author> <title> A PROLOG meta-interpreter for partial evaluation and its application to source-to-source transformation and query optimization. </title> <editor> In T. O'Shea, editor, ECAI-84: </editor> <booktitle> Advances in Artificial Intelligence, </booktitle> <pages> pages 91-100. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
References-found: 36

