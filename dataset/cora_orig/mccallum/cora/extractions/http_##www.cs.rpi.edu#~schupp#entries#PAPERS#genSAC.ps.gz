URL: http://www.cs.rpi.edu/~schupp/entries/PAPERS/genSAC.ps.gz
Refering-URL: http://www.cs.rpi.edu/~schupp/entries/research.html
Root-URL: http://www.cs.rpi.edu
Email: email: schupp@informatik.uni-tuebingen.de email: loos@informatik.uni-tuebingen.de  
Phone: Phone: 0049 7071 292899 Fax 0049 7071 295958  
Title: Considerations for a Generic SAC Library  
Author: Sibylle Schupp and Rudiger Loos 
Address: Sand 13 D-72076 Tubingen GERMANY  
Affiliation: Fakultat fur Informatik Arbeitsbereich Computeralgebra  
Pubnum: WSI-95-25  
Abstract-found: 0
Intro-found: 1
Reference: [Bro78] <author> W. S. Brown, </author> <title> The Subresultant PRS Algorithm, </title> <journal> ACM Transactions on Mathematical Software, Vol.4, </journal> <volume> No. 3, </volume> <month> September </month> <year> 1978, </year> <pages> Pages 237-249. </pages>
Reference: [BC93] <author> Bruno Buchberger, George E. Collins, Mark J, Encarnacion, Hoon Hong, Jeremy R. Johnson, Werner Krandick, Rudiger Loos, Ana M. Mandache, Andreas Neubacher, Herbert Vielhaber, </author> <title> SACLIB User's Guide, </title> <address> March 12, </address> <year> 1993, </year> <institution> Kurt Godel Institute, University of Linz, Austria. For downloading, </institution> <note> send email to saclib@risc.uni-linz.ac.at. At the time you read this, version 1.2 will be available. </note>
Reference-contexts: 1 Introduction The SACLIB <ref> [BC93] </ref> of Buchberger, Collins and others uses C as programming language. It grew out from SAC-2 written in Aldes [LC92], which uses C as implementation language.
Reference: [DGT91] <author> J. H. Davenport, P. Gianni, and B. M. Trager, </author> <title> Scratchpad's View of Algebra II: A Categorial View of Factorization, </title> <booktitle> Proceedings of the 1991 International Symposium on Symbolic and Algebraic Computation, ISAAC'91, St. M. Watt editor. </booktitle>
Reference-contexts: Nevertheless, as in the case of inheritance, generic algebraic programming does simply extend the STL-approach. As it turns out, generic algebraic programming poses, in addition, problems in algebra not all of which have found answers in the literature so far. It is this aspect, again 3 not new <ref> [DGT91] </ref>, a reader not interested in C ++ may find fascinating on its own. <p> Musser programmed the algorithm sqf generically, or as an abstract algorithm, as he dubbed it 25 years ago. It can easily be extended to the case of prime characteristic. The next let-declaration states that amplifi cation is functorial in the sense of <ref> [DGT91] </ref>. Algorithm: L := sqf (A) [square-free factorization.] Let I be an UFD, char I=0, and as associate relation. Let I [X] be f A | A 2 I [X], lc (A)2 I g. Input: A 2 I [X] , primitive, non-constant.
Reference: [DGL95] <author> Mark Day, Robert Gruber, Barbara Liskov, Andrew C. Myers, </author> <title> Subtypes vs. Where Clauses: Constraining Parametric Polymorphism, </title> <booktitle> OOPSLA Conference Proceedings (Austin Texas 1995). ACM SIGPLAN 32, 11(Nov). ACM, </booktitle> <address> New York, p. </address> <pages> 156-168. </pages>
Reference-contexts: Recently, a number of object oriented languages have been developed which allow for constrained parametric polymorphism. In languages without constrained parameters like C ++ or Modula-3 [Ne91] the compiler replaces the type parameter in the body of the parametric class or function and type-checks the result. In <ref> [DGL95] </ref> it is argued that this approach does not support separate compilation because the instantiated body must be available to the compiler, in addition it violates modularity and abstraction. <p> Also, for the other algorithm names 5 like axioms in AXIOM 6 "Such that" is also a keyword in Emerald, another new object oriented language with type matching (for a reference see <ref> [DGL95] </ref>). Our naming coresponds to where-clauses in Theta and reflects the importance of algebraic specifications. 7 we use lower case letters as customary in mathematics. <p> Consider now the function subst. It reads from a data sheet. To access the data sheet, it uses functions like value, parameter-name. Its return value is unique. 9 we face here the possibility of an infinite descent, however, we believe as <ref> [DGL95] </ref> that this is not a problem in practice 16 Consider next the function switch. It estab-lishes syntactically a new context. So, it provides more than one return value if and only if an identifier is overloaded. Overloading occurs rather often in mathematical notation.
Reference: [Ed92] <author> Danial R. Edelson, </author> <booktitle> A Mark-and-Sweep Collector for C ++ , Proceedings of the Ninetheenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, </address> <month> January </month> <year> 1992, </year> <pages> p. 51-58. </pages>
Reference-contexts: In order to hide those details, a prepro cessing from Such That even to the STL library is highly desirable. The SACLIB currently uses a conservative garbage collector which is not type-safe (for these concepts see <ref> [Ed92] </ref>).
Reference: [FZZ95] <author> Arne Frick, Walter Zimmer and Wolf Zimmermann, </author> <title> Uber die Konstruktion robuster objektorientierter Klassenbibliotheken, </title> <institution> Fachtagung "Software-Technik '95" der Gesellschaft fur Informatik, Braunschweig, </institution> <month> November </month> <year> 1995, </year> <pages> p. 35-46. </pages>
Reference-contexts: And from that in turn it depends, whether and which functions are defined. Different additional relations between types in object oriented languages have been studied more recently. Liskov and Wing [LW94] give examples where subtypes extend and others where they specialize given types. Frick, Zimmer and Zimmer-mann <ref> [FZZ95] </ref> study four type relations. Both resarch groups argue to separate sub-typing from inheritance. Subtypes and templates support generic programming. The concept and realization of genericity in C ++ seems to us a promising recent achievement to allow the systematic construction of a new SACLIB.
Reference: [G95] <author> Gerhard Goos, Sather-K, </author> <title> the language, </title> <type> Report 8/1995, </type> <institution> Fakultat fur Informatik, Universitat Karlsruhe. </institution>
Reference-contexts: In [DGL95] it is argued that this approach does not support separate compilation because the instantiated body must be available to the compiler, in addition it violates modularity and abstraction. The languages Rapide [KLM94] and Sather-K <ref> [G95] </ref> use auxiliary classes to express constraints, Liskov's new language Theta [LCD94] uses where-clauses for this purpose. 2.2 Application to C ++ Named types in C ++ are either build in or they are user defined classes. Classes can be parametrized by type variables, introduced by templates.
Reference: [KLM94] <author> D. Katiyar, D. Luckham, J. Mitchell, and S. Melda, </author> <title> Polymorphism and subtyping in interfaces, </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 29(9): </volume> <pages> 22-34, </pages> <month> August </month> <year> 1994. </year> <month> 20 </month>
Reference-contexts: In [DGL95] it is argued that this approach does not support separate compilation because the instantiated body must be available to the compiler, in addition it violates modularity and abstraction. The languages Rapide <ref> [KLM94] </ref> and Sather-K [G95] use auxiliary classes to express constraints, Liskov's new language Theta [LCD94] uses where-clauses for this purpose. 2.2 Application to C ++ Named types in C ++ are either build in or they are user defined classes. Classes can be parametrized by type variables, introduced by templates.
Reference: [KMS82] <author> Deepak Kapur, David R. Musser, and Alexander A. Stepanov, Tecton, </author> <title> a language for manipulating generic objects, </title> <booktitle> Proc. of Program Specification Workshop, </booktitle> <institution> University of Aarhus, Denmark, </institution> <month> August </month> <year> 1981, </year> <booktitle> Lecture Notes in Computer Science Vol. </booktitle> <volume> 134, </volume> <publisher> Springer Verlag, </publisher> <year> 1982. </year>
Reference-contexts: C ++ has a sound type system and is compiler based, hence a strongly typed language. Many existing compilers accept templates only in some restricted form. 3 A strongly typed SAC library According to Musser, an author and co-author of several generic libraries [Mus95], [MSt94], <ref> [KMS82] </ref>, in developing generic algorithms one should start from non-generic algorithms of known efficiency.
Reference: [KTh89] <author> Herbert Klaeren and Peter Thiemann, </author> <title> A Clean Modula-2 Interface to Abstract Data Types, </title> <booktitle> First Modula-2 Conference, </booktitle> <address> Bled, </address> <year> 1989. </year>
Reference-contexts: These conventions bypass even the modest type checking facilities of the C language. The program looks very similar to a Modula-2 program using exclusively the (non-portable) system module <ref> [KTh89] </ref>. /*====================================================================== L &lt;- IPSF (r,A) Integral polynomial squarefree factorization. Inputs r : a BETA-digit, r &gt; 0. A : in Z [X1,...,Xr], A positive, primitive and of positive degree.
Reference: [LW94] <author> Barabara H. Liskov and Jeannette M. Wing, </author> <title> A Behavioral Notion of Subtyping, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 16, No. 6, </volume> <month> November </month> <year> 1994, </year> <pages> Page 1811-1814. </pages>
Reference-contexts: And from that in turn it depends, whether and which functions are defined. Different additional relations between types in object oriented languages have been studied more recently. Liskov and Wing <ref> [LW94] </ref> give examples where subtypes extend and others where they specialize given types. Frick, Zimmer and Zimmer-mann [FZZ95] study four type relations. Both resarch groups argue to separate sub-typing from inheritance. Subtypes and templates support generic programming. <p> He called overloaded functions generic, but we follow the use of that term in the programming community. 2 By this definition, if a computer algebra system is said to be strongly typed, this implies, that it is compiler based and has a sound type system. 4 the subtype property <ref> [LW94] </ref> holds: If S &lt; T , then every property OE (x) provable for objects x of type T should imply that OE (y) is provable for objects y of type S.
Reference: [LCD94] <author> Barbara Liskov, Dorothy Curtis, Mark Day, Sanjay Ghemawhat, Robert Gruber, Paul Johnson, and Andrew C. Myers, </author> <title> Theta Reference Manual, Programming Methodology Group Memo 88, </title> <institution> MIT Laboratory for Computer Science, </institution> <address> Cam-bridge, MA, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: In [DGL95] it is argued that this approach does not support separate compilation because the instantiated body must be available to the compiler, in addition it violates modularity and abstraction. The languages Rapide [KLM94] and Sather-K [G95] use auxiliary classes to express constraints, Liskov's new language Theta <ref> [LCD94] </ref> uses where-clauses for this purpose. 2.2 Application to C ++ Named types in C ++ are either build in or they are user defined classes. Classes can be parametrized by type variables, introduced by templates. Type expressions include classes (even multiply) inheriting other classes.
Reference: [LC92] <author> Rudiger G. K. Loos, George E. </author> <title> Collins Algorithm Description Language Aldes, </title> <institution> Interner Bericht, WSI-92-14, Fakultat fur Informatik, Universitat Tubingen, Sand 13, D-76072 Tubingen. </institution>
Reference-contexts: 1 Introduction The SACLIB [BC93] of Buchberger, Collins and others uses C as programming language. It grew out from SAC-2 written in Aldes <ref> [LC92] </ref>, which uses C as implementation language. The widespread availability of C ++ in the meantime invites us to consider a move from C to C ++ and its effect on an algebraic library like SACLIB.
Reference: [Mas79] <author> John Myron Masley, </author> <title> Where Are Number Fields With Small Class Number?, </title> <booktitle> Springer Lecture Notes in Mathematics 751, Number Theory, Carbondale 1979, Proceedings, </booktitle> <editor> Ed. Melvyn B. Nathanson, p. </editor> <month> 221-242. </month>
Reference-contexts: Theorem 6.1 Z [i n ] is a UFD exactly for the following 30 values of n (6j 2 (4)): n = 1,3,4,5,7,8,9,11,12,13,15,16,17,19,20,21, Proof: For n prime, the theorem is known as a theorem of Uchida and Montgomery (1971), the general case is proven by Masley (1972). <ref> [Mas79] </ref>. ffi The following theorem holds for a principal ideal domain (PID): Theorem 6.2 Let A be the ring of integers in an algebraic number field. Then A PID , A UFD. This equivalence is of course not true in the general case.
Reference: [MSt89] <author> David R. Musser, Alexander A. Stepanov, </author> <title> The ADA Generic Library: Linear List Processing Packages, </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: He and Stepanov call this approach algorithm oriented as opposed to object oriented <ref> [MSt89] </ref>. 3.1 Types in the SACLIB Let us look to a typical SACLIB algorithm as it was derived from the SAC-2 version in Aldes. We take the integral polynomial squarefree factorization algorithm 3 .
Reference: [MSt94] <author> David R. Musser, Alexander A. Stepanov, </author> <title> Algorithm-oriented Generic Libraries. </title> <journal> Software-Practice and Experience, </journal> <volume> vol. 24(7), </volume> <month> 623-642(July </month> <year> 1994). </year>
Reference-contexts: C ++ has a sound type system and is compiler based, hence a strongly typed language. Many existing compilers accept templates only in some restricted form. 3 A strongly typed SAC library According to Musser, an author and co-author of several generic libraries [Mus95], <ref> [MSt94] </ref>, [KMS82], in developing generic algorithms one should start from non-generic algorithms of known efficiency.
Reference: [Mus71] <author> David Musser, </author> <title> Polynomial Factorization Algorithms, </title> <address> PhD-Thesis, Madison 1971. </address>
Reference-contexts: For the first algorithm we have a preamble declaring the algebraic type variable I. It is constrained to be a unique factorization domain (UFD) of characteristic-0 having a multiplicative ample set with respect to associates. This notion was introduced by Musser <ref> [Mus71] </ref> for gcd-domains 7 .
Reference: [Mus95] <author> David Musser, </author> <title> The Standard Template Library, </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Therefore, in this paper we concentrate on questions of generic algorithms. This concept, although quite old, was recently promoted to practical use in the Standard Template Library for C ++ <ref> [StL94, Mus95] </ref>. Nevertheless, as in the case of inheritance, generic algebraic programming does simply extend the STL-approach. As it turns out, generic algebraic programming poses, in addition, problems in algebra not all of which have found answers in the literature so far. <p> C ++ has a sound type system and is compiler based, hence a strongly typed language. Many existing compilers accept templates only in some restricted form. 3 A strongly typed SAC library According to Musser, an author and co-author of several generic libraries <ref> [Mus95] </ref>, [MSt94], [KMS82], in developing generic algorithms one should start from non-generic algorithms of known efficiency.
Reference: [Ne91] <author> Greg Nelson, </author> <title> editor, System Programming with Modula-3, </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: There are few occasions where any parametrization makes sense. Recently, a number of object oriented languages have been developed which allow for constrained parametric polymorphism. In languages without constrained parameters like C ++ or Modula-3 <ref> [Ne91] </ref> the compiler replaces the type parameter in the body of the parametric class or function and type-checks the result. In [DGL95] it is argued that this approach does not support separate compilation because the instantiated body must be available to the compiler, in addition it violates modularity and abstraction.
Reference: [Rey85] <author> J. C. Reynolds, </author> <title> Three approaches to type structure, </title> <booktitle> Mathematical Foundations of Software Development, Springer Lecture Notes on Computer Science 185, p. </booktitle> <pages> 97-138. </pages>
Reference-contexts: Algorithms for objects of type T are applicable to objects whose type S is a subtype of T , written S &lt; T , provided 1 Strachey, according to Reynolds <ref> [Rey85] </ref>, coined the term polymorphic.
Reference: [SS96] <author> Sibylle Schupp, </author> <title> Such That, a Language for Programming with Algebra, PhD-Thesis, </title> <type> forthcoming, </type> <institution> Fakultat fur Informatik, Universitat Tubingen, Sand 13, D-76072 Tubingen. </institution>
Reference-contexts: Since we do not see how this may happen in C we use a new notation for algebraic specifications, switch in the algorithm body back to an extended Aldes and call the resulting language Such That <ref> [SS96] </ref>. 6 How does IPSF then look like? Algorithm: L := sqf (A) [square-free factorization.] Input: A2 Z [x 1 ,...,x r ], r&gt;0, A positive, primitive, and of positive degree.
Reference: [StL94] <author> Alexander A. Stepanov and Meng Lee, </author> <title> The Standard Template Library, </title> <type> Technical Report, </type> <institution> Hewlett-Packard Laboratories, </institution> <month> September 20, </month> <year> 1994, </year> <note> revised February 7, 1995, available by anonymous ftp from ftp.cd.rpi.edu as pub/stl.doc.ps.Z 21 </note>
Reference-contexts: Therefore, in this paper we concentrate on questions of generic algorithms. This concept, although quite old, was recently promoted to practical use in the Standard Template Library for C ++ <ref> [StL94, Mus95] </ref>. Nevertheless, as in the case of inheritance, generic algebraic programming does simply extend the STL-approach. As it turns out, generic algebraic programming poses, in addition, problems in algebra not all of which have found answers in the literature so far.
References-found: 22

