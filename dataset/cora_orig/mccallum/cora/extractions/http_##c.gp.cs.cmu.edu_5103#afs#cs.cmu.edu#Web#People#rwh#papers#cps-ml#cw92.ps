URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/Web/People/rwh/papers/cps-ml/cw92.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/Web/People/rwh/papers.html
Root-URL: http://www.cs.cmu.edu
Title: Polymorphic Type Assignment and CPS Conversion  
Author: Robert Harper Mark Lillibridge 
Address: Pittsburgh, PA 15213  
Affiliation: Carnegie Mellon University  
Date: June 1992)  April 10, 1992  
Note: (To appear: ACM SIGPLAN Workshop on Continuations, San Francisco,  
Abstract: Meyer and Wand established that the type of a term in the simply typed -calculus may be related in a straightforward manner to the type of its call-by-value CPS transform. This typing property may be extended to Scheme-like continuation-passing primitives, from which the soundness of these extensions follows. We study the extension of these results to the Damas-Milner polymorphic type assignment system under both the call-by-value and call-by-name interpretations. We obtain CPS transforms for the call-by-value interpretation, provided that the polymorphic let is restricted to values, and for the call-by-name interpretation with no restrictions. We prove that there is no call-by-value CPS transform for the full Damas-Milner language that validates the Meyer-Wand typing property and is equivalent to the standard call-by-value transform up to fi-conversion.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> William Clinger, Daniel P. Friedman, and Mitchell Wand. </author> <title> A scheme for higher-level semantic algebra. </title> <editor> In Maurice Nivat and John C. Reynolds, editors, </editor> <booktitle> Algebraic Methods in Semantics, </booktitle> <pages> pages 237-250. </pages> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1985. </year>
Reference-contexts: This result may be extended to the calculus that results from extending ! with Scheme-like continuation-passing primitives callcc and throw ( ! + cont) <ref> [1, 3] </ref>. Since ! under a call-by-value operational semantics is "type safe" in the sense of Milner [9, 2], and since the call-by-value CPS transform faithfully mimics the call-by-value semantics [12], it follows that ! + cont under a call-by-value operational semantics is also type safe. <p> We include the let construct as a primitive because it is needed in the discussion of polymorphic type assignment. callcc and throw are continuation-passing primitives whose definitions are derived from analogous constructs in Scheme <ref> [1] </ref> and Standard ML of New Jersey [3]. We consider two CPS transforms for untyped terms, corresponding to the call-by-value and call-by-name operational semantics [12]. Each CPS transform consists of a transformation jj for untyped terms and a transformation jjjj for untyped values.
Reference: [2] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <year> 1982. </year>
Reference-contexts: This result may be extended to the calculus that results from extending ! with Scheme-like continuation-passing primitives callcc and throw ( ! + cont) [1, 3]. Since ! under a call-by-value operational semantics is "type safe" in the sense of Milner <ref> [9, 2] </ref>, and since the call-by-value CPS transform faithfully mimics the call-by-value semantics [12], it follows that ! + cont under a call-by-value operational semantics is also type safe. In a subsequent study Duba, Harper, and MacQueen studied the addition of callcc and throw to Standard ML [10]. <p> In this paper we undertake a systematic study of the interaction between continuations and polymorphism by considering the typing properties of the CPS transform for both the call-by-value and call-by-name variants of the Damas-Milner language <ref> [2] </ref> and its extension with continuation-passing primitives. We obtain suitable extensions of the Meyer-Wand theorem for the call-by-value CPS transform, provided that the polymorphic let is restricted to values, and for the call-by-name transform, under no restrictions. <p> Our main positive results are the extension of the 8 Meyer-Wand theorem to the call-by-value interpretation of a restricted form of polymorphism, and to the call-by-name interpretation of the unrestricted language. These results have as a consequence the soundness (in the sense of Damas and Milner <ref> [2] </ref>) of these programming languages. We have also argued that there is no "natural" call-by-value CPS transform for the unrestricted language, but this leaves open the possibility of finding a transformation that is radically different in character from the usual one.
Reference: [3] <author> Bruce Duba, Robert Harper, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1991. </year>
Reference-contexts: This result may be extended to the calculus that results from extending ! with Scheme-like continuation-passing primitives callcc and throw ( ! + cont) <ref> [1, 3] </ref>. Since ! under a call-by-value operational semantics is "type safe" in the sense of Milner [9, 2], and since the call-by-value CPS transform faithfully mimics the call-by-value semantics [12], it follows that ! + cont under a call-by-value operational semantics is also type safe. <p> We include the let construct as a primitive because it is needed in the discussion of polymorphic type assignment. callcc and throw are continuation-passing primitives whose definitions are derived from analogous constructs in Scheme [1] and Standard ML of New Jersey <ref> [3] </ref>. We consider two CPS transforms for untyped terms, corresponding to the call-by-value and call-by-name operational semantics [12]. Each CPS transform consists of a transformation jj for untyped terms and a transformation jjjj for untyped values. Exactly what is considered a value depends on which operational semantics is being used. <p> The call-by-value type transform is extended to ! + cont by defining jjt contjj cbv = jjt jj cbv ! ff. It is straightforward to verify that Theorem 3.4 extends to ! + cont in this way <ref> [3] </ref>. <p> Meyer and Wand exploited this relationship in their proof of the equivalence of the direct and continuation semantics of ! [8]. A minor extension of this result may be used to establish the soundness of typing for ! + cont, the extension of ! with continuation-passing primitives <ref> [3] </ref>, under call-by-value. In this paper we have presented a systematic study of the extension of the Meyer-Wand theorem to the Damas-Milner system of polymorphic type assignment.
Reference: [4] <author> Matthias Felleisen, Daniel Friedman, Eugene Kohlbecker, and Bruce Duba. </author> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Computer Science, </journal> <volume> 52(3) </volume> <pages> 205-237, </pages> <year> 1987. </year>
Reference-contexts: The correctness of these transforms may either be established by relating them to an independently-defined operational semantics (as in <ref> [12, 4] </ref>), or else taken as the definition of call-by-value and call-by-name semantics. 3 Simple Type Assignment In this section we review Meyer and Wand's typing theorem for the call-by-value CPS transform for the simply-typed -calculus ( ! ), and present an analogous result for the call-by-name CPS transform.
Reference: [5] <author> Timothy Griffin. </author> <title> Private communication., </title> <month> January </month> <year> 1992. </year>
Reference-contexts: The typing rules of the Damas-Milner system extend those of ! as follows: 2 The term "call-by-name type transform" is something of a misnomer since there exists a by-value CPS transform that validates the by-name typing property <ref> [5] </ref>.
Reference: [6] <author> Robert Harper, Bruce Duba, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <note> Revised and expanded version of [3], in preparation. </note>
Reference-contexts: The source of this discrepancy may be traced to the interaction between the polymorphic let construct and the typing rules for callcc. Several ad hoc methods for restricting the language to recover soundness have been proposed <ref> [6, 14] </ref>. In this paper we undertake a systematic study of the interaction between continuations and polymorphism by considering the typing properties of the CPS transform for both the call-by-value and call-by-name variants of the Damas-Milner language [2] and its extension with continuation-passing primitives.
Reference: [7] <author> Robert Harper and Mark Lillibridge. </author> <title> Announcement on the types electronic forum., </title> <month> July </month> <year> 1991. </year>
Reference-contexts: The extension of the Meyer-Wand transform to ! + cont establishes the soundness of the monomorphic fragment of the language, but the soundness of the polymorphic language with continuation-passing primitives was left open. It was subsequently proved by the authors <ref> [7] </ref> that the full polymorphic language is unsound when extended with callcc and throw. The source of this discrepancy may be traced to the interaction between the polymorphic let construct and the typing rules for callcc.
Reference: [8] <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs, volume 224 of Lecture Notes in Computer Science, </booktitle> <pages> pages 219-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: their study of the relationship between direct and continuation semantics for the simply typed -calculus ( ! ), Meyer and Wand note that the type of a term in ! may be related in a simple and natural way to the type of its call-by-value continuation passing style (CPS) transform <ref> [8] </ref>. This result may be extended to the calculus that results from extending ! with Scheme-like continuation-passing primitives callcc and throw ( ! + cont) [1, 3]. <p> Meyer and Wand exploited this relationship in their proof of the equivalence of the direct and continuation semantics of ! <ref> [8] </ref>. A minor extension of this result may be used to establish the soundness of typing for ! + cont, the extension of ! with continuation-passing primitives [3], under call-by-value.
Reference: [9] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming languages. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: This result may be extended to the calculus that results from extending ! with Scheme-like continuation-passing primitives callcc and throw ( ! + cont) [1, 3]. Since ! under a call-by-value operational semantics is "type safe" in the sense of Milner <ref> [9, 2] </ref>, and since the call-by-value CPS transform faithfully mimics the call-by-value semantics [12], it follows that ! + cont under a call-by-value operational semantics is also type safe. In a subsequent study Duba, Harper, and MacQueen studied the addition of callcc and throw to Standard ML [10].
Reference: [10] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In a subsequent study Duba, Harper, and MacQueen studied the addition of callcc and throw to Standard ML <ref> [10] </ref>. The extension of the Meyer-Wand transform to ! + cont establishes the soundness of the monomorphic fragment of the language, but the soundness of the polymorphic language with continuation-passing primitives was left open.
Reference: [11] <author> John C. Mitchell. </author> <title> A type-inference approach to reduction properties and semantics of polymorphic expressions. </title> <booktitle> In 1986 Symposium on LISP and Functional Programming, </booktitle> <pages> pages 308-319, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: But this takes us beyond the limits of the Damas-Milner type system since jjjj cbv is, in general, a polytype. We therefore consider as target language the extension, DM + , of DM, in which the distinction between monotypes and polytypes is dropped, leading to full polymorphic type assignment <ref> [11] </ref>. The decidability of type checking for DM + is unknown, but this is not important for our purposes. We shall rely, however, on the fact that the subject reduction property holds for fi-reduction in DM + [11]. <p> distinction between monotypes and polytypes is dropped, leading to full polymorphic type assignment <ref> [11] </ref>. The decidability of type checking for DM + is unknown, but this is not important for our purposes. We shall rely, however, on the fact that the subject reduction property holds for fi-reduction in DM + [11]. With these changes to the type transformation and the associated enrichment of the target type system, the induction step for general let's works. However, polymorphic generalization becomes problematic. <p> Constants of non-base type must be handled on a case-by-case basis. 7 form is 0. Therefore, we have that e 1 x:x is fi-reducible to 0. But this is a violation of the subject reduction property of DM + <ref> [11] </ref> since e 1 x:x has type bool! The conditions of Theorem 4.9 leave open the possibility of either finding a variant call-by-value transform that is not convertible to the standard one, or else varying the type transform in such a way that a Meyer-Wand-like typing property can be proved, or
Reference: [12] <author> Gordon Plotkin. </author> <title> Call-by-name, call-by-value, and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: Since ! under a call-by-value operational semantics is "type safe" in the sense of Milner [9, 2], and since the call-by-value CPS transform faithfully mimics the call-by-value semantics <ref> [12] </ref>, it follows that ! + cont under a call-by-value operational semantics is also type safe. In a subsequent study Duba, Harper, and MacQueen studied the addition of callcc and throw to Standard ML [10]. <p> We consider two CPS transforms for untyped terms, corresponding to the call-by-value and call-by-name operational semantics <ref> [12] </ref>. Each CPS transform consists of a transformation jj for untyped terms and a transformation jjjj for untyped values. Exactly what is considered a value depends on which operational semantics is being used. Under call-by-value, variables, -abstractions, and constants 1 are considered values. <p> The correctness of these transforms may either be established by relating them to an independently-defined operational semantics (as in <ref> [12, 4] </ref>), or else taken as the definition of call-by-value and call-by-name semantics. 3 Simple Type Assignment In this section we review Meyer and Wand's typing theorem for the call-by-value CPS transform for the simply-typed -calculus ( ! ), and present an analogous result for the call-by-name CPS transform.
Reference: [13] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Conference Record of the 25th National ACM Conference, </booktitle> <pages> pages 717-740, </pages> <address> Boston, </address> <month> August </month> <year> 1972. </year> <journal> ACM. </journal> <volume> 9 </volume>
Reference-contexts: In the terminology of Reynolds <ref> [13] </ref>, polymorphic instantiation is given a "trivial" interpretation in that no interesting computation can occur as a result of the specialization of a value of polymorphic type. The definition of j8t:j cbv reflects the fact that in DM there is no need of continuations whose domain is a polymorphic type. <p> This transform is defined by taking jj8t:jj = 8t:jj, and jj = (jjjj ! ff) ! ff. The intuition behind this choice is to regard polymorphic instantiation as a "serious" computation (in roughly the sense of Reynolds <ref> [13] </ref>). This interpretation is arguably at variance with the usual semantics of ML polymorphism since it admits primitives that have non-trivial computational effects when polymorphically instantiated.
Reference: [14] <author> Andrew K. Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report TR91-160, </type> <institution> Department of Computer Science, Rice University, </institution> <month> July </month> <year> 1991. </year> <month> 10 </month>
Reference-contexts: The source of this discrepancy may be traced to the interaction between the polymorphic let construct and the typing rules for callcc. Several ad hoc methods for restricting the language to recover soundness have been proposed <ref> [6, 14] </ref>. In this paper we undertake a systematic study of the interaction between continuations and polymorphism by considering the typing properties of the CPS transform for both the call-by-value and call-by-name variants of the Damas-Milner language [2] and its extension with continuation-passing primitives.
References-found: 14

