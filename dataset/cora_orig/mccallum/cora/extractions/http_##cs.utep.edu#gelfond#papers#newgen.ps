URL: http://cs.utep.edu/gelfond/papers/newgen.ps
Refering-URL: http://cs.utep.edu/gelfond/gelfond.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Classical Negation in Logic Programs and Disjunctive Databases  
Author: Michael Gelfond Vladimir Lifschitz 
Address: El Paso, Texas 79968  Austin, Texas 78712  
Affiliation: University of Texas at El Paso  University of Texas at Austin  
Abstract: An important limitation of traditional logic programming as a knowledge representation tool, in comparison with classical logic, is that logic programming does not allow us to deal directly with incomplete information. In order to overcome this limitation, we extend the class of general logic programs by including classical negation, in addition to negation-as-failure. The semantics of such extended programs is based on the method of stable models. The concept of a disjunctive database can be extended in a similar way. We show that some facts of commonsense knowledge can be represented by logic programs and disjunctive databases more easily when classical negation is available. Computationally, classical negation can be eliminated from extended programs by a simple preprocessor. Extended programs are identical to a special case of default theories in the sense of Reiter. 
Abstract-found: 1
Intro-found: 1
Reference: [Bidoit and Froidevaux1987] <author> Nicole Bidoit and Christine Froidevaux. </author> <title> Minimalism subsumes default logic and circumscription. </title> <booktitle> In Proc. of LICS-87, </booktitle> <pages> pages 89-97, </pages> <year> 1987. </year>
Reference-contexts: Our extension of general logic programs hardly brings any new computational difficulties. 2 The class of extended programs is of interest in connection with the problem of relation between logic programming and nonmonotonic formalisms (see [Przymusinski1988] for an overview). As shown in <ref> [Bidoit and Froidevaux1987] </ref>, general logic programs can be viewed as default theories in the sense of Reiter [rei80]. A similar reduction is applicable to extended programs, and they turn out to be a notational variant of a natural, easily identifiable subset of default logic. <p> A reduction to autoepistemic logic is given in [Gelfond1987], and the equivalence of the stable model approach to this semantics is established in [Gelfond and Lifschitz1988] (Theorem 3). A reduction to default logic is described in <ref> [Bidoit and Froidevaux1987] </ref> (see also [Lin and Shoham1989]) and shown to be equivalent to stable models in [Bidoit and Froidevaux1988]. Introspective circumscription is defined in [Lifschitz1989], and its relation to stable models is discussed in Sections 5.1 and 5.2 of that paper. 6.
Reference: [Bidoit and Froidevaux1988] <author> Nicole Bidoit and Christine Froidevaux. </author> <title> Negation by default and nonstratifiable logic programs. </title> <type> Technical Report 437, </type> <institution> Universite Paris XI, </institution> <year> 1988. </year>
Reference-contexts: A reduction to default logic is described in [Bidoit and Froidevaux1987] (see also [Lin and Shoham1989]) and shown to be equivalent to stable models in <ref> [Bidoit and Froidevaux1988] </ref>. Introspective circumscription is defined in [Lifschitz1989], and its relation to stable models is discussed in Sections 5.1 and 5.2 of that paper. 6. The use of autoepistemic logic for this purpose leads to some complications.
Reference: [Blair and Subrahmanian1989] <author> Howard Blair and V.S. Subrahmanian. </author> <title> Paraconsistent logic programming. </title> <journal> Theoretical Computer Science, </journal> <volume> 68 </volume> <pages> 135-154, </pages> <year> 1989. </year>
Reference-contexts: It is clear that a general logic program cannot be contradictory. Proposition 1. Every contradictory program has exactly one answer set|the set of all literals, Lit. This proposition shows that our approach to negation is different from the "paraconsistent" approach of <ref> [Blair and Subrahmanian1989] </ref>. Proof. It is clear from the definition of answer sets that any answer set containing a pair of complementary literals coincides with Lit. The fact that a contradictory program cannot have any other answer set is a consequence of the following lemma: Lemma 1.
Reference: [Fitting1985] <author> Melvin Fitting. </author> <title> A kripke-kleene semantics for logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(4) </volume> <pages> 295-312, </pages> <year> 1985. </year>
Reference-contexts: We will return to this point in the next section, and then again in Section 6. 5 We think of answer sets as incomplete theories (rather than "three--valued models," used, for instance, in <ref> [Fitting1985] </ref>, [Przymusinski1989] and [Van Gelder et al.1990]). When a program has several answer sets, it is incomplete also in another sense|it has several different interpretations, and the answer to a query may depend on the interpretation.
Reference: [Gelfond and Lifschitz1988] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <editor> In Robert Kowalski and Kenneth Bowen, editors, </editor> <booktitle> Logic Programming: Proc. of the Fifth Int'l Conf. and Symp., </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year> <month> 22 </month>
Reference-contexts: The semantics of extended programs described below is an extension of the stable model semantics for general logic programs proposed in <ref> [Gelfond and Lifschitz1988] </ref>. The stable model semantics defines when a set S of ground atoms is a "stable model" of a given program. <p> Consequently, an answer set of a general logic program|a program without classical negation|is a set of atoms. The definition of an answer set coincides in this case with the definition of stable model given in <ref> [Gelfond and Lifschitz1988] </ref>. (Notice that the sign : stands there for negation-as-failure and thus corresponds to not in the notation of this paper.) We conclude that the answer sets of a general logic program are identical to its stable models. <p> Historically, two of these reductions were proposed earlier than the definition of stable models. A reduction to autoepistemic logic is given in [Gelfond1987], and the equivalence of the stable model approach to this semantics is established in <ref> [Gelfond and Lifschitz1988] </ref> (Theorem 3). A reduction to default logic is described in [Bidoit and Froidevaux1987] (see also [Lin and Shoham1989]) and shown to be equivalent to stable models in [Bidoit and Froidevaux1988].
Reference: [Gelfond and Lifschitz1989] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Compiling circumscriptive theories into logic programs. </title> <editor> In Michael Reinfrank, Johan de Kleer, Matthew Ginsberg, and Erik Sandewall, editors, </editor> <booktitle> Non-Monotonic Reasoning: 2nd International Workshop (Lecture Notes in Artificial Intelligence 346), </booktitle> <pages> pages 74-99. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: This mapping is related to the methods for translating inheritance hierarchies into logic programs proposed in <ref> [Gelfond and Lifschitz1989] </ref> and [Gelfond and Lifschitz1990]. These methods require that new predicates be introduced for the purpose of representing negative conditions.
Reference: [Gelfond and Lifschitz1990] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Logic programs with classical negation. </title> <editor> In David Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 579-597, </pages> <year> 1990. </year>
Reference-contexts: Notes 1. The idea of providing for the incompleteness of information in logic-based query answering systems, and permitting answers other than simply yes or no for ground queries, is discussed in [Gelfond1989] and <ref> [Gelfond and Lifschitz1990] </ref>. Our use of two kinds of negation appears to be somewhat similar to the distinction between "strong" and "weak" negation in [Wagner1989]. 2. Notice for comparison that when Poole and Goebel [poo86] add classical negation to Prolog, they immediately get full first order logic and full resolution. <p> This mapping is related to the methods for translating inheritance hierarchies into logic programs proposed in [Gelfond and Lifschitz1989] and <ref> [Gelfond and Lifschitz1990] </ref>. These methods require that new predicates be introduced for the purpose of representing negative conditions.
Reference: [Gelfond1987] <author> Michael Gelfond. </author> <title> On stratified autoepistemic theories. </title> <booktitle> In Proc. AAAI-87, </booktitle> <pages> pages 207-211, </pages> <year> 1987. </year>
Reference-contexts: Historically, two of these reductions were proposed earlier than the definition of stable models. A reduction to autoepistemic logic is given in <ref> [Gelfond1987] </ref>, and the equivalence of the stable model approach to this semantics is established in [Gelfond and Lifschitz1988] (Theorem 3). A reduction to default logic is described in [Bidoit and Froidevaux1987] (see also [Lin and Shoham1989]) and shown to be equivalent to stable models in [Bidoit and Froidevaux1988]. <p> Consequently, even in programs without not, we can't interpret as implication. To fix this problem, we can try to modify the translation from <ref> [Gelfond1987] </ref> and insert the autoepistemic operator L in front of each literal in the body of a rule, even if it doesn't follow not. Then the rules P :Q and Q :P are translated by two different autoepistemic formulas, L:Q P and L:P Q.
Reference: [Gelfond1989] <author> Michael Gelfond. </author> <title> Autoepistemic logic and formalization of commonsense reasoning. </title> <editor> In Michael Reinfrank, Johan de Kleer, Matthew Ginsberg, and Erik Sandewall, editors, </editor> <booktitle> Non-Monotonic Reasoning: 2nd International Workshop (Lecture Notes in Artificial Intelligence 346), </booktitle> <pages> pages 176-186. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: This research was supported in part by NSF grants IRI-8906516 and IRI-8904611 and by DARPA under Contract N00039-84-C-0211. Notes 1. The idea of providing for the incompleteness of information in logic-based query answering systems, and permitting answers other than simply yes or no for ground queries, is discussed in <ref> [Gelfond1989] </ref> and [Gelfond and Lifschitz1990]. Our use of two kinds of negation appears to be somewhat similar to the distinction between "strong" and "weak" negation in [Wagner1989]. 2.
Reference: [Kowalski and Sadri1990] <author> Robert Kowalski and Fariba Sadri. </author> <title> Logic programs with exceptions. </title> <editor> In David Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 598-613, </pages> <year> 1990. </year>
Reference-contexts: In this sense, the language of extended programs is symmetric, like default logic [Reiter1980], autoepistemic logic [Moore1985] and formula circumscription [McCarthy1986]. 8 On the contrary, the modification of our approach proposed in <ref> [Kowalski and Sadri1990] </ref> is not symmetric. In Section 6 we say more on the use of the closed world assumption in extended programs. Here is one more example in which both kinds of negation are used. College X uses the following rules for awarding scholarships to its students: 1. <p> Notice for comparison that when Poole and Goebel [poo86] add classical negation to Prolog, they immediately get full first order logic and full resolution. This is because they interpret as classical implication. 3. According to [Kowalski1989] and <ref> [Kowalski and Sadri1990] </ref>, many provisions in legislation have a negative form ("A declaration: : : 20 shall not be registered unless: : :"). In a preliminary version of [Kowalski and Sadri1990], such statements were treated as integrity constraints with one of the conditions identified as "retractable." The use of rules with <p> This is because they interpret as classical implication. 3. According to [Kowalski1989] and <ref> [Kowalski and Sadri1990] </ref>, many provisions in legislation have a negative form ("A declaration: : : 20 shall not be registered unless: : :"). In a preliminary version of [Kowalski and Sadri1990], such statements were treated as integrity constraints with one of the conditions identified as "retractable." The use of rules with negative heads seems more natural. 4.
Reference: [Kowalski1989] <author> Robert Kowalski. </author> <title> The treatment of negation in logic programs for representing legislation. </title> <booktitle> In Proc. of the Second Int'l Conf. on Artificial Intelligence and Law, </booktitle> <pages> pages 11-15, </pages> <year> 1989. </year>
Reference-contexts: If the available employment information is complete for Stanford, but not for SRI, a more restricted rule should be used instead: :Employed (x; Stanford) not; Employed (x; Stanford): The following example of the use of negation in the 1981 British Nationality Act is quoted in <ref> [Kowalski1989] </ref>: "After commencement no person shall have the status of a Commonwealth citizen or the status of a British subject otherwise than under this Act." This statement, in essense, postulates the closed world assumption for some predicates. <p> Notice for comparison that when Poole and Goebel [poo86] add classical negation to Prolog, they immediately get full first order logic and full resolution. This is because they interpret as classical implication. 3. According to <ref> [Kowalski1989] </ref> and [Kowalski and Sadri1990], many provisions in legislation have a negative form ("A declaration: : : 20 shall not be registered unless: : :").
Reference: [Lifschitz1989] <author> Vladimir Lifschitz. </author> <title> Between circumscription and autoepistemic logic. </title> <editor> In Ronald Brachman, Hector Levesque, and Raymond Reiter, editors, </editor> <booktitle> Proc. of the First Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 235-244, </pages> <year> 1989. </year>
Reference-contexts: A reduction to default logic is described in [Bidoit and Froidevaux1987] (see also [Lin and Shoham1989]) and shown to be equivalent to stable models in [Bidoit and Froidevaux1988]. Introspective circumscription is defined in <ref> [Lifschitz1989] </ref>, and its relation to stable models is discussed in Sections 5.1 and 5.2 of that paper. 6. The use of autoepistemic logic for this purpose leads to some complications.
Reference: [Lin and Shoham1989] <author> Fangzhen Lin and Yoav Shoham. </author> <title> Argument systems: a uniform basis for nonmonotonic reasoning. </title> <editor> In Ronald Brachman, Hector Levesque, and Raymond Reiter, editors, </editor> <booktitle> Proc. of the First Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 245-255, </pages> <year> 1989. </year>
Reference-contexts: A reduction to autoepistemic logic is given in [Gelfond1987], and the equivalence of the stable model approach to this semantics is established in [Gelfond and Lifschitz1988] (Theorem 3). A reduction to default logic is described in [Bidoit and Froidevaux1987] (see also <ref> [Lin and Shoham1989] </ref>) and shown to be equivalent to stable models in [Bidoit and Froidevaux1988]. Introspective circumscription is defined in [Lifschitz1989], and its relation to stable models is discussed in Sections 5.1 and 5.2 of that paper. 6. The use of autoepistemic logic for this purpose leads to some complications.
Reference: [Lloyd1984] <author> John Lloyd. </author> <title> Foundations of logic programming. </title> <publisher> Springer, </publisher> <year> 1984. </year>
Reference-contexts: In the language of extended programs, we can distinguish between a query which fails in the sense that it does not succeed and a query which fails in the stronger sense that its negation succeeds. 1 A general logic program <ref> [Lloyd1984] </ref> can be defined as a set of rules of the form A 0 A 1 ; : : : ; A m ; not A m+1 ; : : : ; not A n ; where n m 0, and each A i is an atom.
Reference: [Marek and Truszczynski1989a] <author> Wiktor Marek and Miroslaw Truszczynski. </author> <title> Autoepistemic logic, defaults and truth maintenance. </title> <type> Manuscript, </type> <year> 1989. </year>
Reference-contexts: Unfortunately, this translation reduces some "well-behaved" programs to autoepistemic theories with several extensions. For instance, the 21 autoepistemic theory LP P , corresponding to the trivial program P P , has two extensions. The "unintended" extensions can be eliminated by using the ideas of <ref> [Marek and Truszczynski1989a] </ref> and [Marek and Truszczynski1989b]. 7. This restriction allows us to disregard the process of Skolemization, involved in defining extensions in the general case ([Reiter1980], Section 7.1). 8.
Reference: [Marek and Truszczynski1989b] <author> Wiktor Marek and Miroslaw Truszczynski. </author> <title> Relating autoepistemic and default logic. </title> <editor> In Ronald Brachman, Hector Levesque, and Raymond Reiter, editors, </editor> <booktitle> Proc. of the First Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 276-288, </pages> <year> 1989. </year>
Reference-contexts: Unfortunately, this translation reduces some "well-behaved" programs to autoepistemic theories with several extensions. For instance, the 21 autoepistemic theory LP P , corresponding to the trivial program P P , has two extensions. The "unintended" extensions can be eliminated by using the ideas of [Marek and Truszczynski1989a] and <ref> [Marek and Truszczynski1989b] </ref>. 7. This restriction allows us to disregard the process of Skolemization, involved in defining extensions in the general case ([Reiter1980], Section 7.1). 8.
Reference: [McCarthy1986] <author> John McCarthy. </author> <title> Applications of circumscription to formalizing common sense knowledge. </title> <journal> Artificial Intelligence, </journal> <volume> 26(3) </volume> <pages> 89-116, </pages> <year> 1986. </year>
Reference-contexts: In this sense, the language of extended programs is symmetric, like default logic [Reiter1980], autoepistemic logic [Moore1985] and formula circumscription <ref> [McCarthy1986] </ref>. 8 On the contrary, the modification of our approach proposed in [Kowalski and Sadri1990] is not symmetric. In Section 6 we say more on the use of the closed world assumption in extended programs. Here is one more example in which both kinds of negation are used.
Reference: [Minker1982] <author> Jack Minker. </author> <title> On indefinite data bases and the closed world assumption. </title> <booktitle> In Proc. of CADE-82, </booktitle> <pages> pages 292-308, </pages> <year> 1982. </year>
Reference-contexts: However, this doesn't give any additional generality, because an axiom F can be identified with the default true : =F . 9. For databases without classical negation, this definition is equivalent to the definition of a minimal model from <ref> [Minker1982] </ref>. 10. This definition is roughly equivalent to the construction described in Section 6 of [Przymusinski1990], applied to the stable model semantics. (Contradictory programs are treated by Przymusinski somewhat differently.)
Reference: [Moore1985] <author> Robert Moore. </author> <title> Semantical considerations on nonmono-tonic logic. </title> <journal> Artificial Intelligence, </journal> <volume> 25(1) </volume> <pages> 75-94, </pages> <year> 1985. </year>
Reference-contexts: In this sense, the language of extended programs is symmetric, like default logic [Reiter1980], autoepistemic logic <ref> [Moore1985] </ref> and formula circumscription [McCarthy1986]. 8 On the contrary, the modification of our approach proposed in [Kowalski and Sadri1990] is not symmetric. In Section 6 we say more on the use of the closed world assumption in extended programs.
Reference: [Poole and Goebel1986] <author> David Poole and Randy Goebel. </author> <title> Gracefully adding negation and disjunction to prolog. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proc. of the Third Int'l Conf. on Logic Programming, </booktitle> <pages> pages 635-641, </pages> <year> 1986. </year>
Reference: [Przymusinski1988] <author> Teodor Przymusinski. </author> <title> On the relationship between logic programming and non-monotonic reasoning. </title> <booktitle> In Proc. AAAI-88, </booktitle> <pages> pages 444-448, </pages> <year> 1988. </year>
Reference-contexts: Our extension of general logic programs hardly brings any new computational difficulties. 2 The class of extended programs is of interest in connection with the problem of relation between logic programming and nonmonotonic formalisms (see <ref> [Przymusinski1988] </ref> for an overview). As shown in [Bidoit and Froidevaux1987], general logic programs can be viewed as default theories in the sense of Reiter [rei80].
Reference: [Przymusinski1989] <author> Teodor Przymusinski. </author> <title> Three-valued formalizations of non-monotonic reasoning and logic programming. </title> <editor> In Ronald Brachman, Hector Levesque, and Raymond Reiter, editors, </editor> <booktitle> Proc. of the First Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 341-348, </pages> <year> 1989. </year>
Reference-contexts: We will return to this point in the next section, and then again in Section 6. 5 We think of answer sets as incomplete theories (rather than "three--valued models," used, for instance, in [Fitting1985], <ref> [Przymusinski1989] </ref> and [Van Gelder et al.1990]). When a program has several answer sets, it is incomplete also in another sense|it has several different interpretations, and the answer to a query may depend on the interpretation.
Reference: [Przymusinski1990] <author> Teodor Przymusinski. </author> <title> Extended stable semantics for normal and disjunctive programs. </title> <editor> In David Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 459-477, </pages> <year> 1990. </year>
Reference-contexts: Many attempts have been made to define a declarative 17 semantics for "disjunctive logic programs," or "disjunctive databases"; references can be found in <ref> [Przymusinski1990] </ref>. Consider a simple example. Jack is employed by Stanford University or by SRI International; any employed individual has an adequate income. It follows that Jack has an adequate income. <p> For databases without classical negation, this definition is equivalent to the definition of a minimal model from [Minker1982]. 10. This definition is roughly equivalent to the construction described in Section 6 of <ref> [Przymusinski1990] </ref>, applied to the stable model semantics. (Contradictory programs are treated by Przymusinski somewhat differently.)
Reference: [Reiter1978] <author> Raymond Reiter. </author> <title> On closed world data bases. </title> <editor> In Herve Gallaire and Jack Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 119-140. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: :Train: Then Cross will not belong to the answer set unless the negative fact :Train is included. 3 The difference between not P and :P in a logic program is essential whenever we cannot assume that the available positive information about P is complete, i.e., when the "closed world assumption" <ref> [Reiter1978] </ref> is not applicable to P .
Reference: [Reiter1980] <author> Raymond Reiter. </author> <title> A logic for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1,2):81-132, </volume> <year> 1980. </year> <month> 24 </month>
Reference-contexts: We do not commit ourselves to any particular use of the closed world assumption by deciding which of two opposite predicates will be represented by a predicate constant, and which one will be considered negative. In this sense, the language of extended programs is symmetric, like default logic <ref> [Reiter1980] </ref>, autoepistemic logic [Moore1985] and formula circumscription [McCarthy1986]. 8 On the contrary, the modification of our approach proposed in [Kowalski and Sadri1990] is not symmetric. In Section 6 we say more on the use of the closed world assumption in extended programs. <p> The "unintended" extensions can be eliminated by using the ideas of [Marek and Truszczynski1989a] and [Marek and Truszczynski1989b]. 7. This restriction allows us to disregard the process of Skolemization, involved in defining extensions in the general case (<ref> [Reiter1980] </ref>, Section 7.1). 8. In the notation of [Reiter1980], (7) would be written as G : MH 1 ; : : : ; MH k ; or G : MH 1 ; : : : ; MH k =F .
Reference: [Van Gelder et al.1990] <author> Allen Van Gelder, Kenneth Ross, and John Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of ACM, </journal> <note> 1990. To appear. </note>
Reference-contexts: We will return to this point in the next section, and then again in Section 6. 5 We think of answer sets as incomplete theories (rather than "three--valued models," used, for instance, in [Fitting1985], [Przymusinski1989] and <ref> [Van Gelder et al.1990] </ref>). When a program has several answer sets, it is incomplete also in another sense|it has several different interpretations, and the answer to a query may depend on the interpretation.
Reference: [Wagner1989] <author> Gerd Wagner. </author> <title> The two sources of nonmonotonicity in vivid logic: weak falsity and inconsistency handling. </title> <editor> In G. Brewka and H. Freitag, editors, </editor> <booktitle> Proc. of the Workshop on Nonmonotonic Reasoning, </booktitle> <year> 1989. </year> <month> 25 </month>
Reference-contexts: Our use of two kinds of negation appears to be somewhat similar to the distinction between "strong" and "weak" negation in <ref> [Wagner1989] </ref>. 2. Notice for comparison that when Poole and Goebel [poo86] add classical negation to Prolog, they immediately get full first order logic and full resolution. This is because they interpret as classical implication. 3.
References-found: 27

