URL: http://www.cs.utah.edu/~machiraj/res/thesis/proposal.ps
Refering-URL: http://www.cs.utah.edu/~machiraj/res/thesis/main.html
Root-URL: 
Title: OBJECT MIGRATION FOR DISTRIBUTED GRAPHICS APPLICATIONS  
Author: by Vijay Machiraju 
Degree: A proposal submitted to the faculty of The University of Utah in partial fulfillment of the requirements for the degree of Master of Science  
Date: November 1996  
Affiliation: Department of Computer Science The University of Utah  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Barghouti, N. S., and Kaiser, G. E. </author> <title> Concurrency control in advanced database applications. </title> <journal> ACM Computing Surveys 23, </journal> <month> 3 (Sep </month> <year> 1991), </year> <pages> 269-317. </pages>
Reference-contexts: When objects or parts of an object graph are shared or replicated on multiple nodes, there should be some concurrency control mechanisms to maintain the single view for the graph. There are several concurrency control strategies that can be implemented <ref> [1] </ref>. On the strong side, we can have locking algorithms to achieve serializability of concurrent applications.
Reference: [2] <author> Caughey, S. J., Parrington, G. D., and Shrivastava, S. K. </author> <title> Shadows a flexible support for objects in distributed systems. </title> <note> In IWOOOS'93 (Dec 1993). </note>
Reference-contexts: An object identifier encapsulates the location of the node on which it was created, which makes an object's location efficient if it is not migrated. Once an object is migrated it leaves a fowarder at the source which keeps track of the current location of the object. Shadows <ref> [2] </ref> is another system which allows mobility of only quiescent objects. Objects move between object managers which manage a collection of objects. Location transparency is achieved by a similar forwarding mechanism. None of the above migration mechanisms consider defining graphs of objects and the issues involved in migrating these graphs.
Reference: [3] <author> Chevalier, P.-Y., D.Hagimont, J.Mossiere, and de Pine, X. </author> <title> Object migration in the guide system. </title> <type> Tech. Rep. 101, Broadcast, </type> <year> 1995. </year>
Reference-contexts: The main drawback with Emerald is that it is designed for homogeneous environments and local area networks, and is not scalable to large distributed systems. Only immutable objects can be replicated in Emerald, and the system does not support sharing of stateful objects. 32 The Guide system <ref> [3] </ref> allows objects to be migrated at administration time, ie., when there are no methods that are active on the objects. It does not support migration of non-quiescent and active objects.
Reference: [4] <author> Chin, R. S., and Chanson, S. T. </author> <title> Distributed object-based programming systems. </title> <journal> ACM Computing Surveys 23, </journal> <month> 1 (Mar </month> <year> 1991), </year> <pages> 91-124. </pages>
Reference-contexts: A graphics application, typically consists of a few ( &lt; 100 ) large-grain objects and a large ( &gt; 10; 000 ) 39 number of fine-grain objects. There are two standard object models that are widely popular in the existing systems <ref> [4] </ref> the active object model and the passive object model. In the active object model (fig. 3.3), several server processes are created for and assigned to each object to handle its invocation requests. These processes are terminated when the object dies.
Reference: [5] <institution> International Business Machines Corpopration and SunSoft, Inc. Object Externalization Service. </institution> <type> Tech. rep., </type> <institution> Object Management Group, </institution> <year> 1994. </year>
Reference-contexts: The Externalization Service is a standard CORBA service which defines standards for externalizing the state of objects. As we describe in chapter 4, this service helps in providing an implementation strategy for objects to perform lifecycle operations. The operations provided by externalization service are described in <ref> [5] </ref>. Relationship Service: Objects do not exist independently in a distributed en 36 vironment. They will be related to other objects. For example, objects can contain references to other objects, or they can contain other objects. Containment and reference are two standard relations.
Reference: [6] <author> Joint Object Services Submission. </author> <title> Relationship Service Specification. OMG Document 94-5-5, </title> <booktitle> Object Management Group, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Relationship Service defines a standard for defining these kind of relationships between objects. These relationships can be used at a higher level, to define operations for migrating object graphs. Relationship Service is explained fully in <ref> [6] </ref>. Compound LifeCycle Service: The Compound LifeCycle Service builds on the services described above to define lifecycle operations on graphs of objects. The graphs are constructed by defining the relationships between objects using the Relationship Service.
Reference: [7] <author> Jul, E., Levy, H., Hutchinson, N., and Black, A. </author> <title> Fine-grained mobility in the emerald system. </title> <journal> ACM Transactions on Computer Systems 6, </journal> <month> 1 (Feb </month> <year> 1988), </year> <pages> 109-133. </pages>
Reference-contexts: Our efforts in this thesis, are motivated by a wider set of considerations (which arise from graphics applications) than just fault-tolerance. 2.3 Related Work There were many attempts to provide transparent operating system support for object migration. Emerald, Guide, and Shadows are some of examples of these systems. Emerald <ref> [7] </ref> supports migration of fine-grain objects. Each object in Emerald has a unique network-wide name, which is used in identifying objects when they are moved between nodes. Objects in Emerald can also have references to other objects. <p> A process can execute in several objects during its lifetime. When a process makes an invocation on another object, its execution in the object in which it is currently executing is temporarily suspended. It continues its execution in the new object. Emerald <ref> [7] </ref> and Clouds [11] use the passive object model. The active object model is suited when the system supports large-grain objects, whereas the passive object model is appropriate when the system supports fine-grain objects.
Reference: [8] <author> Linton, M., and Price, C. </author> <title> Building distributed user interfaces with fresco. </title> <booktitle> In Proc. Seventh X Technical Conference (Boston, </booktitle> <address> Masachusetts, </address> <month> Jan </month> <year> 1993), </year> <pages> pp. 77-87. </pages>
Reference-contexts: Another aspect that should be considered in designing good user interfaces is that they should be able to put together components from different parts of the system into a single window. Fresco <ref> [8] </ref> is an example of such interface development tool, which would help in distributing components of the interface across a collection of machines.
Reference: [9] <author> Object Management Group. </author> <title> Common Object Services Specification, Volume I. </title> <type> Tech. rep., </type> <institution> Object Management Group, </institution> <year> 1994. </year>
Reference-contexts: Objects are bound to names within contexts. Contexts are normal objects which act as containers for name bindings. Since contexts are objects, context objects can also be bound to names. This results in a naming graph or a naming hierarchy. The CORBA standard for Naming Service is described in <ref> [9] </ref>, and is explained in greater detail in chapter 4. Chapter 4 also describes our implementation of the naming service, and how the naming service is used in this model to obtain the initial references to factory objects, which are described in the next section. <p> In addition to the standard lifecycle operations defined in the LifeCycle Service, we add another operation (replicate ()) to replicate objects. Any object that supports these operations inherits from the cosLifeCycle object and provide an implementation for these methods. The complete standard for lifecycle operations is described in <ref> [9] </ref>. 35 It should be noted that factories are large-grain objects since they are defined in IDL (using interface). The notion of factories, as defined by the LifeCycle Service in CORBA, applies only to the creation of other large-grain objects.
Reference: [10] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification (CORBA), </title> <month> July </month> <year> 1995. </year>
Reference-contexts: Application Objects are objects that are 24 part of a specific distributed application. OMG defines standards for the ORB, the Object Services, and the Common Facilities. The Common Object Request Broker Architecture (CORBA) <ref> [10] </ref> is an OMG defined standard for ORB in the OMA reference model. CORBA defines all the interfaces that are available through or by the ORB to the objects. It addresses the problem of making distributed application development no more difficult than developing a centralized application.
Reference: [11] <author> P.Dasgupta, R.LeBlanc, and W.Appelbe. </author> <title> The clouds distributed operating system functional description, implementation details, and related work. </title> <booktitle> In IEEE 8th International Conference on Distributed Computing Systems (San Jose, </booktitle> <year> 1989). </year>
Reference-contexts: A process can execute in several objects during its lifetime. When a process makes an invocation on another object, its execution in the object in which it is currently executing is temporarily suspended. It continues its execution in the new object. Emerald [7] and Clouds <ref> [11] </ref> use the passive object model. The active object model is suited when the system supports large-grain objects, whereas the passive object model is appropriate when the system supports fine-grain objects. In a system that should support objects of all granularities, we need a 40 hybrid object model (fig. 3.5).
Reference: [12] <author> Rahn, N. Borg: </author> <title> A system for assimilating legacy systems into distributed objects. </title> <type> Master's thesis, </type> <institution> Univ. of Utah, </institution> <year> 1996. </year>
Reference-contexts: The original Alpha 1 system is composed of many other independent programs, such as render, which interact with 38 each other only through saving their output to files where other programs can access it. Nicholas Rahn has converted some of this functionality into distributed objects by his BORG system <ref> [12] </ref>. All the large-grain objects were defined using IDL interfaces, and wrapper objects were provided to convert the existing legacy code into distributed object implementations. Clients can now access these applications using CORBA calling styles. <p> For instance, this will involve designing implicit concurrency control mechanisms, and setting default settings for migration control on graphs of objects. Alpha 1 Applications and Object Monitor: We build on the foundation laid by Nicholas Rahn's implementation of distributed objects for Alpha 1 <ref> [12] </ref>. Rahn has converted all the large-grain objects of Alpha 1 into CORBA objects. All the fine-grain objects were handled using the stream operations of Alpha 1.
Reference: [13] <author> R.J.Fowler. </author> <title> Decentralized Object Finding Using Forwarding Addresses. </title> <type> PhD 45 thesis, </type> <institution> Univ. of Washington, </institution> <address> Seattle, </address> <month> Dec </month> <year> 1985. </year>
Reference-contexts: The template is used in locating the pointers in the state information, which are then replaced with the new addresses. Finally, the processes are resumed on the destination. Emerald uses a forwarding address <ref> [13] </ref> concept to locate objects transparently. The main drawback with Emerald is that it is designed for homogeneous environments and local area networks, and is not scalable to large distributed systems.
Reference: [14] <author> Rozier, M., and Martins, J. </author> <title> Distributed Operating Systems, Thoery and Practice. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, </address> <year> 1987, </year> <title> ch. </title> <booktitle> The CHORUS Distributed Operating System; Some Design Issues, </booktitle> <pages> pp. 262-287. </pages>
Reference-contexts: The number of server processes that are assigned to each object may be either fixed (static variant of active object model), or may be dynamically changed when requests arrive at the object (dynamic variant of the active object model). Systems such as Amoeba [16] and CHORUS <ref> [14] </ref> support the active object model. In the passive object model (fig. 3.4), the processes and objects are separate entities. A process can execute in several objects during its lifetime.
Reference: [15] <author> Soley, R. M., and Stone, C. M. </author> <title> The Object Management Architecture Guide, third ed. </title> <publisher> John Wiley & Sons, Inc., </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: This can be used in certain decisions regarding the destinations for migrating objects. 2.2 CORBA Object Management Group (OMG), which is a consortium of several companies such as Sun, HP, DEC, and IBM, attempts to define the various facilities that are necessary for distributed object-oriented computing <ref> [15] </ref>. This definition, which is popularly known as the the Object Management Architecture (OMA) Reference Model, is shown in Figure 2.2. The central component of this model is the Object Request Broker (ORB), which is responsible for transparent communication between objects.
Reference: [16] <author> Tanenbaum, A., and van Renesse, R. </author> <title> Distributed operating systems. </title> <journal> ACM Computing Surveys 17, </journal> <month> 4 (Dec </month> <year> 1985), </year> <pages> 419-470. </pages>
Reference-contexts: The number of server processes that are assigned to each object may be either fixed (static variant of active object model), or may be dynamically changed when requests arrive at the object (dynamic variant of the active object model). Systems such as Amoeba <ref> [16] </ref> and CHORUS [14] support the active object model. In the passive object model (fig. 3.4), the processes and objects are separate entities. A process can execute in several objects during its lifetime.
Reference: [17] <author> Tanenbaum, A. S. </author> <title> Distributed Operating Systems. </title> <publisher> Prentice Hall, </publisher> <address> Upper Saddle River, New Jersey 07458, </address> <year> 1995. </year>
Reference-contexts: This chapter describes some of the issues involved in developing distributed applications, and explains how object-oriented programming has helped in reducing the complexity involved in designing and developing a distributed application. 1.1 Distributed Object-Oriented Applications Tanenbaum defines a distributed system <ref> [17] </ref> as ... a collection of independent computers that appears to the users of the system as a single computer. This definition has two aspects. The first one deals with hardware: the machines are autonomous.
References-found: 17

