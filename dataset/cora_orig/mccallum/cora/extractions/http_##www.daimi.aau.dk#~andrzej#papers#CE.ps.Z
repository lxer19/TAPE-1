URL: http://www.daimi.aau.dk/~andrzej/papers/CE.ps.Z
Refering-URL: http://www.daimi.aau.dk/~andrzej/papers/
Root-URL: http://www.daimi.aau.dk
Title: Controlling Effects  
Author: Andrzej Filinski John Reynolds, Co-Chair Stephen Brookes Gordon Plotkin, 
Degree: Submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy. Thesis Committee: Robert Harper, Co-Chair  
Note: Copyright c fl1996 Andrzej Filinski This research was sponsored in part by the Defense Advanced Research Projects Agency, CSTO, under the title "The Fox Project: Advanced Development of Systems Software", under Contract F19628-95-C-0050. The research was also partially sponsored by the National Science Foundation under Grant No. CCR-94-09997.  
Address: Pittsburgh, PA 15213  Edinburgh  
Affiliation: School of Computer Science Carnegie Mellon University  University of  
Date: May 1996  
Abstract: The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of the Defense Advanced Research Projects Agency, the National Science Foundation, or the U.S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: [AM91] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <booktitle> In Third International Symposium on Programming Language Implementation and Logic Programming, number 528 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-13, </pages> <address> Passau, Germany, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: ML IMPLEMENTATION AND EXAMPLES 103 4.5 ML implementation and examples In this section we illustrate how the abstract construction presented so far can be transcribed into runnable code. To emphasize the typing issues involved, we use the New Jersey dialect of Standard ML <ref> [AM91] </ref> as our concrete language, but the operational content should translate straightforwardly into Scheme as well (though instantiation to different monads may be less convenient without a "parameterized module" facility).
Reference: [App92] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Since we may want to perform the continuation-passing translation anyway, e.g., for cps-based code generation <ref> [App92] </ref>, we seem to be on the right track. On closer inspection, however, the translation does not quite produce "proper" continuation-passing terms: there is still a little bit of explicit sequencing left in the output. Recall the equations for [[ ]] K from Definition 4.8. <p> To ensure good performance of the reflection and reification operators as well, we do need to assume a reasonably efficient implementation of call=cc in the host language. In cps-based compilers, providing a cheap first-class continuation facility is generally straightforward <ref> [App92] </ref>. And even in stack-based implementations, good techniques exist for keeping at least the amortized cost per call=cc acceptably low [HDB90]. Still, if a particular effect is heavily used, it may be preferable to rewrite the program in the corresponding monadic style.
Reference: [CM93] <author> Pietro Cenciarelli and Eugenio Moggi. </author> <title> A syntactic approach to modularity in de-notational semantics. </title> <booktitle> In Proceedings of the Conference on Category Theory and Computer Science, </booktitle> <address> Amsterdam, </address> <month> September </month> <year> 1993. </year> <type> CWI Tech. Report. </type>
Reference-contexts: handlers, where an exception is implicitly re-raised if it does not match any of the clauses in a handler; we want to ensure that such a handler has no effect on the result of the program. 2.4 Related work There has already been much work on combining monadic effects, e.g., <ref> [Mog90, KW93, CM93, Ste94, LHJ95, Esp95] </ref>, of varying degrees of generality and formality. None of these approaches, however, were particularly concerned about nonstandard implementations of 44 CHAPTER 2.
Reference: [CR91] <author> William Clinger and Jonathan Rees. </author> <title> Revised 4 report on the algorithmic language Scheme. </title> <journal> Lisp Pointers, </journal> <volume> 4(3) </volume> <pages> 1-55, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: And this sequencing can serve as a robust skeleton for organizing general computational effects. Although this idea can be traced back to early Lisp [M + 62], perhaps the prototypical functional language based on such an approach is Scheme <ref> [CR91] </ref>. The three key semantic differences distinguishing Scheme from a "purely functional" language are its call-by-value evaluation strategy, the presence of explicitly mutable state, and a feature known as first-class continuations. These three characteristics make Scheme a very versatile language, but potentially significantly complicate reasoning about programs. <p> This could be said to validate the informal claim in the Scheme Rationale for call=cc that most useful control abstractions can be implemented explicitly, without changing or extending the language itself <ref> [CR91] </ref>. With this correspondence, we have effectively bridged the gap between the denota-tional and the operational view of effects: we can reason safely in terms of the former, but work in a practical, familiar programming language in terms of the latter. <p> This again introduces a reflexivity in the types, and it is well known that one can define a fixed-point operator using higher-order state (as actually done for letrec in Scheme <ref> [CR91] </ref>). As usual, we give a definitional translation of the new language: Definition 4.24 Let be a computation-type of L 1 -type.
Reference: [DF90] <author> Olivier Danvy and Andrzej Filinski. </author> <title> Abstracting control. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 151-160, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: extend to recursively-defined types without too many obstacles. (The initial version in [Fil94] was based on the Meyer-Wand approach, but it is not clear how well that would scale to ambient effects and especially recursion.) A possible correspondence between monads and continuation-passing style (CPS) was conjectured by Danvy and Filinski <ref> [DF90] </ref>, and more concretely presented by Wadler [Wad92b]. (The general idea of using a monad morphism to simulate one monadic effect with another is also due to Wadler [Wad90].) However, this work was largely informal. <p> Early work <ref> [JD88, FWFD88, DF90] </ref> presumed explicit support from the compiler or runtime system for the actual implementation, such as the ability to mark or splice together delimited stack segments. However, an encoding in standard Scheme of one variant was devised by Sitaram and Felleisen [SF90]. <p> The more restrictive usage of the term, where the metacontinuation actually arises from a standard continuation-passing transform of an "almost-cps" term, is due to Danvy and Filinski <ref> [DF90] </ref>. The further observation that the metacontinuation can be represented by a storage cell was first exploited in a preliminary version of the present work [Fil94].
Reference: [DF92] <author> Olivier Danvy and Andrzej Filinski. </author> <title> Representing control: A study of the CPS transformation. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 361-391, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: k r 1 in r 2 ) in (s x)) =6 Note also that we could define A M = S (k 0!! : M ) Although probably not as well known as call=cc, control operators like S, A, and # have already seen a fair amount of study, e.g., <ref> [Fel88, SF90, DF92, Wad94, Fil94, GRR95] </ref>; we will briefly compare the various approaches in Section 4.6.
Reference: [Esp95] <author> David A. Espinosa. </author> <title> Semantic Lego. </title> <type> PhD thesis, </type> <institution> Graduate School of Arts and Sciences, Columbia University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: handlers, where an exception is implicitly re-raised if it does not match any of the clauses in a handler; we want to ensure that such a handler has no effect on the result of the program. 2.4 Related work There has already been much work on combining monadic effects, e.g., <ref> [Mog90, KW93, CM93, Ste94, LHJ95, Esp95] </ref>, of varying degrees of generality and formality. None of these approaches, however, were particularly concerned about nonstandard implementations of 44 CHAPTER 2.
Reference: [Fel88] <author> Matthias Felleisen. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 180-190, </pages> <address> San Diego, California, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: k r 1 in r 2 ) in (s x)) =6 Note also that we could define A M = S (k 0!! : M ) Although probably not as well known as call=cc, control operators like S, A, and # have already seen a fair amount of study, e.g., <ref> [Fel88, SF90, DF92, Wad94, Fil94, GRR95] </ref>; we will briefly compare the various approaches in Section 4.6.
Reference: [FH92] <author> Matthias Felleisen and Robert Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 103(2) </volume> <pages> 235-271, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: In fact, we do not need to explicitly translate at all; direct-style equational theories such as the computational -calculus are only slightly more complicated than fij-conversion [Mog89]. (The situation is complicated somewhat by dynamic creation of mutable cells, but those too can be dealt with <ref> [FH92] </ref>.) It would thus seem that ease of reasoning about impure functional programs should be "within a constant factor" of that about pure programs.
Reference: [Fil94] <author> Andrzej Filinski. </author> <title> Representing monads. </title> <booktitle> In Proceedings of the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 446-457, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: The present work, while formulated in a simply-typed setting, and using mostly axiomatic reasoning, is nevertheless closer conceptually to the domain-theoretic results. In particular, it explicitly handles general recursion in computations by fixed-point induction, and should extend to recursively-defined types without too many obstacles. (The initial version in <ref> [Fil94] </ref> was based on the Meyer-Wand approach, but it is not clear how well that would scale to ambient effects and especially recursion.) A possible correspondence between monads and continuation-passing style (CPS) was conjectured by Danvy and Filinski [DF90], and more concretely presented by Wadler [Wad92b]. (The general idea of using <p> k r 1 in r 2 ) in (s x)) =6 Note also that we could define A M = S (k 0!! : M ) Although probably not as well known as call=cc, control operators like S, A, and # have already seen a fair amount of study, e.g., <ref> [Fel88, SF90, DF92, Wad94, Fil94, GRR95] </ref>; we will briefly compare the various approaches in Section 4.6. <p> The further observation that the metacontinuation can be represented by a storage cell was first exploited in a preliminary version of the present work <ref> [Fil94] </ref>. An application of this technique for continuation-based partial evaluation was reported by Lawall and Danvy, who found that a call=cc-based implementation of composable continuations uniformly outperformed the equivalent explicit continuation-passing translation, especially with respect to heap usage [LD94]. <p> This distinction gives us a very simple correspondence between composable continuations and monadic reflection for the continuation monad, further motivating composable continuations as the canonical control effect. (The change was also partially necessitated by the introduction of ambient effects; in <ref> [Fil94] </ref>, the target language of the definitional translation was assumed to be effect-free in the present terminology.) Chapter 5 Conclusions 5.1 Summary We have analyzed a new approach to incorporating computational effects in a functional language.
Reference: [Fis72] <author> Michael J. Fischer. </author> <title> Lambda calculus schemata. </title> <booktitle> In Proceedings of the ACM Conference on Proving Assertions about Programs, </booktitle> <pages> pages 104-109. </pages> <booktitle> SIGPLAN Notices, </booktitle> <volume> Vol. 7, No 1 and SIGACT News, No 14, </volume> <month> January </month> <year> 1972. </year> <note> Revised version in Lisp and Symbolic Computation, 6(3/4), 1993. 134 BIBLIOGRAPHY 135 </note>
Reference-contexts: And, perhaps best-known, continuation-passing style (CPS) passes to every function an explicit representation of the remainder of the computation, to be invoked on the result of that function <ref> [Rey72, Fis72, Plo75] </ref>. While these techniques for modeling computational effects all share a similar feel, they do differ substantially in the details.
Reference: [FWFD88] <author> Matthias Felleisen, Mitchell Wand, Daniel P. Friedman, and Bruce F. Duba. </author> <title> Abstract continuations: A mathematical semantics for handling full functional jumps. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 52-62, </pages> <address> Snowbird, Utah, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: Early work <ref> [JD88, FWFD88, DF90] </ref> presumed explicit support from the compiler or runtime system for the actual implementation, such as the ability to mark or splice together delimited stack segments. However, an encoding in standard Scheme of one variant was devised by Sitaram and Felleisen [SF90].
Reference: [Gir72] <author> Jean-Yves Girard. </author> <title> Interpretation Fonctionelle et Elimination des Coupures de l'Arithmetique d'Ordre Superieur. </title> <institution> These d'etat, Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: However, the fact that the continuation-based representation is in a sense parametric in the choice of fl cannot be captured equationally in our setting. (It might be possible in a language with F 2 -polymorphism <ref> [Gir72, Rey74b] </ref>.) For the formal proof in Section 3.3, we will therefore need a stronger, relational characterization of i to accurately express this property. 3.1.2 The variant translation In this section, we show how to actually exploit the existence of a monad morphism (with some further properties) to simulate one kind
Reference: [GRR95] <author> Carl A. Gunter, Didier Remy, and Jon G. Riecke. </author> <title> A generalization of exceptions and control in ML-like languages. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <year> 1995. </year>
Reference-contexts: k r 1 in r 2 ) in (s x)) =6 Note also that we could define A M = S (k 0!! : M ) Although probably not as well known as call=cc, control operators like S, A, and # have already seen a fair amount of study, e.g., <ref> [Fel88, SF90, DF92, Wad94, Fil94, GRR95] </ref>; we will briefly compare the various approaches in Section 4.6. <p> Another explicitly Scheme-implementable notion of partial continuations was pro posed by Queinnec and Serpette [QS91]; the code required is perhaps even more intric ate. And more recently, an implementation of a related construct in Standard ML of New Jersey was presented by Gunter, Remy and Riecke <ref> [GRR95] </ref>. 4.6. RELATED WORK 113 At least initially, most of these operators appear more general than monadic reflection for continuations, but it is not clear if the additional expressive power is sufficiently useful in practice to justify their fairly complex implementations.
Reference: [Hay87] <author> Christopher T. Haynes. </author> <title> Logic continuations. </title> <journal> The Journal of Logic Programming, </journal> <volume> 4(2) </volume> <pages> 157-176, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: But a proof that such an implementation actually agrees with the explicit exception-passing used in the formal definition of SML [MTH90] is by no means a trivial task. Similar considerations apply to analyzing control-based implementations of backtracking <ref> [Hay87, HDM93] </ref> or concurrency [Wan80]: while the code may be short, elegant, and intuitively plausible, formally relating it to a more abstract denotational specification, such as success lists [Wad85] or resumptions [Sch86, Mog90], is often a serious undertaking.
Reference: [HDB90] <author> Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 66-77, </pages> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: In cps-based compilers, providing a cheap first-class continuation facility is generally straightforward [App92]. And even in stack-based implementations, good techniques exist for keeping at least the amortized cost per call=cc acceptably low <ref> [HDB90] </ref>. Still, if a particular effect is heavily used, it may be preferable to rewrite the program in the corresponding monadic style. For example, if the parameter provided by an environment monad changes very frequently, we should make it an explicit argument to all functions using it.
Reference: [HDM93] <author> Robert Harper, Bruce F. Duba, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(4) </volume> <pages> 465-484, </pages> <month> October </month> <year> 1993. </year> <note> (A preliminary version appeared in Proceedings of the 1991 Symposium on Principles of Programming Languages). </note>
Reference-contexts: But a proof that such an implementation actually agrees with the explicit exception-passing used in the formal definition of SML [MTH90] is by no means a trivial task. Similar considerations apply to analyzing control-based implementations of backtracking <ref> [Hay87, HDM93] </ref> or concurrency [Wan80]: while the code may be short, elegant, and intuitively plausible, formally relating it to a more abstract denotational specification, such as success lists [Wad85] or resumptions [Sch86, Mog90], is often a serious undertaking. <p> 3 + escape (fnfnfn k =&gt; k (6 + coerce (k 1))) endendend; (* val it = 4 : int *) (The use of void and coerce instead of an unconstrained type variable in Escape permits continuations to be stored in ref -cells while staying within the ML type system <ref> [HDM93] </ref>.) Now we can define a composable-continuations facility, parameterized by the type of final answers (using Definition 4.25 and Lemma 4.4): signaturesignaturesignature CONTROL = sigsigsig typetypetype ans valvalval reset : (unit -&gt; ans) -&gt; ans valvalval shift : (('1a -&gt; ans) -&gt; ans) -&gt; '1a endendend; functorfunctorfunctor Control (typetypetype ans) :
Reference: [HM93] <author> Robert Harper and John C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: The reflection-based approach to effects, on the other hand, also seems well suited for Church-style type reconstruction (where type information is considered an inherent part of the program, only elided for conciseness), as already advocated for ML in <ref> [HM93] </ref>. 5.3 Closing remarks Perhaps the most concise way of stating the main conclusion of this work is that a functional program can and should distinguish between specification and implementation of computational effects as it already would for any other abstract data type.
Reference: [JD88] <author> Gregory F. Johnson and Dominic Duggan. </author> <title> Stores and partial continuations as first-class objects in a language and its environment. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 158-168, </pages> <address> San Diego, California, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: To express general reflection/reification in the store case, we need access to a "first-class store" mechanism. This can actually be implemented reasonably efficiently using version trees, without requiring the whole store to be copied <ref> [JD88, Mor93] </ref>, but it does impose some overhead. The latter example illustrates that it may not always be feasible or desirable to export the full reflection/reification pair for a monad in a real programming language. <p> Early work <ref> [JD88, FWFD88, DF90] </ref> presumed explicit support from the compiler or runtime system for the actual implementation, such as the ability to mark or splice together delimited stack segments. However, an encoding in standard Scheme of one variant was devised by Sitaram and Felleisen [SF90].
Reference: [JG89] <author> Pierre Jouvelot and David K. Gifford. </author> <title> Reasoning about continuations with control effects. </title> <booktitle> In Proceedings of the ACM SIGPLAN'89 Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 218-226, </pages> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: We would want a concise and unobtrusive way of representing that same information in direct style. Existing work in this area tends to consider mainly low-level notions of effects (jumps and state manipulation) <ref> [JG89, KJLS87] </ref>, rather than application-specific, higher-level concepts. But given the often complex relationship between a monadic specification and its imperative implementation, it seems highly unlikely that an automated analysis based on the latter would be able to detect a higher-level pattern such as an exception-handling system.
Reference: [KJLS87] <author> David K.Gifford, Pierre Jouvelot, John M. Lucassen, and Mark A. Sheldon. </author> <title> FX-87 reference manual (edition 1.0). </title> <type> Technical Report MIT/LCS/TR-407, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: We would want a concise and unobtrusive way of representing that same information in direct style. Existing work in this area tends to consider mainly low-level notions of effects (jumps and state manipulation) <ref> [JG89, KJLS87] </ref>, rather than application-specific, higher-level concepts. But given the often complex relationship between a monadic specification and its imperative implementation, it seems highly unlikely that an automated analysis based on the latter would be able to detect a higher-level pattern such as an exception-handling system.
Reference: [KW93] <author> David J. King and Philip Wadler. </author> <title> Combining monads. </title> <editor> In J. Launchbury and P. M. Sansom, editors, </editor> <booktitle> Functional Programming, Glasgow 1992, </booktitle> <pages> pages 134-143, </pages> <address> Ayr, Scotland, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The second, and more fundamental, reason is that certain very useful notions of computation do not actually form monads in the presence of arbitrary ambient effects. Perhaps the best known such example <ref> [KW93] </ref> is the list monad T ff = (ff list), used to model nondeterminism. <p> handlers, where an exception is implicitly re-raised if it does not match any of the clauses in a handler; we want to ensure that such a handler has no effect on the result of the program. 2.4 Related work There has already been much work on combining monadic effects, e.g., <ref> [Mog90, KW93, CM93, Ste94, LHJ95, Esp95] </ref>, of varying degrees of generality and formality. None of these approaches, however, were particularly concerned about nonstandard implementations of 44 CHAPTER 2.
Reference: [LD94] <author> Julia L. Lawall and Olivier Danvy. </author> <title> Continuation-based partial evaluation. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 227-238, </pages> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: An application of this technique for continuation-based partial evaluation was reported by Lawall and Danvy, who found that a call=cc-based implementation of composable continuations uniformly outperformed the equivalent explicit continuation-passing translation, especially with respect to heap usage <ref> [LD94] </ref>. The main difference between the variant of composable continuations considered in this chapter and the previous formulations is that we start with an even more abstract specification of the original operators, distinguishing in the type system between computations with and without control effects.
Reference: [LHJ95] <author> Sheng Liang, Paul Hudak, and Mark Jones. </author> <title> Monad transformers and modular interpreters. </title> <booktitle> In Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 333-343, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year> <note> 136 BIBLIOGRAPHY </note>
Reference-contexts: handlers, where an exception is implicitly re-raised if it does not match any of the clauses in a handler; we want to ensure that such a handler has no effect on the result of the program. 2.4 Related work There has already been much work on combining monadic effects, e.g., <ref> [Mog90, KW93, CM93, Ste94, LHJ95, Esp95] </ref>, of varying degrees of generality and formality. None of these approaches, however, were particularly concerned about nonstandard implementations of 44 CHAPTER 2.
Reference: [LPJ95] <author> John Launchbury and Simon L. Peyton Jones. </author> <title> State in Haskell. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 293-341, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: INTRODUCTION implementation itself, still providing a purely functional interface to the relevant operations, but implementing them more efficiently than what could be expressed explicitly in the language. In particular, several proposals have been made for direct implementations of state in languages like Haskell <ref> [PW93, LPJ95] </ref>. Unfortunately, such a "black-box" approach negates one of the main advantages of the denotational approach: the ability to represent effect meanings explicitly as ordinary, functional constructs that can be reasoned about directly within the language.
Reference: [M + 62] <editor> John McCarthy et al. </editor> <title> LISP 1.5 Programmer's Manual. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1962. </year>
Reference-contexts: And this sequencing can serve as a robust skeleton for organizing general computational effects. Although this idea can be traced back to early Lisp <ref> [M + 62] </ref>, perhaps the prototypical functional language based on such an approach is Scheme [CR91]. The three key semantic differences distinguishing Scheme from a "purely functional" language are its call-by-value evaluation strategy, the presence of explicitly mutable state, and a feature known as first-class continuations.
Reference: [Mit96] <author> John C. Mitchell. </author> <title> Foundations for Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: Its syntax and semantics are very similar to PCF [Plo77] (even more so to PCF with lifted types <ref> [Mit96] </ref>, except that the effect structure is made more explicit. We call it Effect-PCF. We present the syntax and informal operational interpretation in this section, with a precise denotational semantics in the next.
Reference: [ML71] <author> Saunders Mac Lane. </author> <title> Categories for the Working Mathematician, volume 5 of Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1971. </year>
Reference-contexts: must further satisfy the three monad laws: f fl ffi j ff = f j fl Remark 1.2 In category theory, the a monad is conventionally defined in terms of a functor T and natural transformations j : Id ! T and : T 2 ! T satisfying certain equalities <ref> [ML71, VI.1] </ref>. (In the context of functional programming, the corresponding operations are usually referred to as map, unit, and join [Wad92a].) It is easy to see, however, that the two formulations are equivalent: every Kleisli triple (T; j; fl ) determines a monad (T; j; ) by T f = (j <p> ` i fi (x) = x : fi m:(fi) ` i fi (letx ( m in x) = i fi (letx ( m in (i fi x)) : fi (In category-theoretic terms, this says that i fi is the structure map of an algebra (fi; i) for the monad underlying <ref> [ML71, VI.2] </ref>.) Specifically, given such a function, we can define a generalized-let operator by let fi x ( M 1 in M 2 = i fi (letx ( M 1 in M 2 ) However, the generalized-let formulation is more convenient to work with, its equational properties being a natural generalization
Reference: [Mog89] <author> Eugenio Moggi. </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 14-23, </pages> <address> Pacific Grove, California, </address> <month> June </month> <year> 1989. </year> <note> IEEE. </note>
Reference-contexts: It was therefore a remarkable observation by Moggi that they could each be seen as a particular instance of a generic schema, parameterized by a monad, a simple concept from category theory <ref> [Mog89] </ref>. This meant that much of the theory of computational effects could be derived abstractly, without reference to any specific notion of effect. Again, it did not take long for this idea to migrate from mathematical semantics to mainstream functional programming. <p> In fact, we do not need to explicitly translate at all; direct-style equational theories such as the computational -calculus are only slightly more complicated than fij-conversion <ref> [Mog89] </ref>. (The situation is complicated somewhat by dynamic creation of mutable cells, but those too can be dealt with [FH92].) It would thus seem that ease of reasoning about impure functional programs should be "within a constant factor" of that about pure programs. <p> This "continuation last" notation is usually preferable for writing 10 CHAPTER 1. INTRODUCTION actual functional programs in monadic style, but the formulation in the definition is more convenient for our purposes. It should also be mentioned that our monads are properly called strong monads in category theory <ref> [Mog89] </ref>, essentially because the f being extended need not be closed. (The monad laws must then also hold for open terms; the formal definition in the next chapter will reflect this.) We will use the "functional programming" rather than the "categorical" terminology throughout this document. <p> Monads provide a uniform framework for reasoning about computational effects (such as state, exceptions, or I/O) in applicative programming languages <ref> [Mog89, Mog91] </ref>. Informally, j a represents a "pure" (i.e., effect-free) computation yielding a, while f fl t represents the computation consisting of t's effects followed by an application of f to the result (if any) computed by t. <p> And finally, the generalized let must satisfy (not necessarily directly by definition) the equations in Definition 2.4. For example, in any cll, for every type ff, there exists a (computation-)type ff ! ff ! ff fiff. Note that this is a slightly stronger requirement than Moggi's T -exponentials <ref> [Mog89] </ref>, which only guaranteed existence of all function spaces of the form ff 1 !ff 2 . A weaker notion would be to take the computation types to be exactly the set of types of the formff. <p> RELATED WORK 79 in a simulation of general monads by continuation-passing requires a more flexible type system. Finally, another glimmer of the connection between monads and continuations can be seen in Sabry and Felleisen's result that fij-equivalence of CPS terms coincides with direct-style equivalence in Moggi's computational -calculus <ref> [SF93, Mog89] </ref>; the latter captures exactly the equivalences holding in the presence of arbitrary monadic effects. While this does not by itself imply that any monadic effect can be simulated by a continuation monad, it does indicate that continuations form a maximally (but not necessarily most) general notion of effect.
Reference: [Mog90] <author> Eugenio Moggi. </author> <title> An abstract view of programming languages. </title> <type> Technical Report ECS-LFCS-90-113, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Similar considerations apply to analyzing control-based implementations of backtracking [Hay87, HDM93] or concurrency [Wan80]: while the code may be short, elegant, and intuitively plausible, formally relating it to a more abstract denotational specification, such as success lists [Wad85] or resumptions <ref> [Sch86, Mog90] </ref>, is often a serious undertaking. One could thus say that it is in this sense that "purely functional" programs offer 6 CHAPTER 1. INTRODUCTION a pragmatic reasoning advantage over "impure" ones: by penalizing all effects equally, they do not discourage the use of precise, custom-tailored effect representations. <p> handlers, where an exception is implicitly re-raised if it does not match any of the clauses in a handler; we want to ensure that such a handler has no effect on the result of the program. 2.4 Related work There has already been much work on combining monadic effects, e.g., <ref> [Mog90, KW93, CM93, Ste94, LHJ95, Esp95] </ref>, of varying degrees of generality and formality. None of these approaches, however, were particularly concerned about nonstandard implementations of 44 CHAPTER 2.
Reference: [Mog91] <author> Eugenio Moggi. </author> <title> Notions of computation and monads. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 55-92, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Monads provide a uniform framework for reasoning about computational effects (such as state, exceptions, or I/O) in applicative programming languages <ref> [Mog89, Mog91] </ref>. Informally, j a represents a "pure" (i.e., effect-free) computation yielding a, while f fl t represents the computation consisting of t's effects followed by an application of f to the result (if any) computed by t.
Reference: [Mor93] <author> J. Gregory Morrisett. </author> <title> Generalizing first-class stores. </title> <booktitle> In ACM SIGPLAN Workshop on State in Programming Languages, </booktitle> <pages> pages 73-87, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year> <type> (Technical report YALEU/DCS/RR-968, </type> <institution> Department of Computer Science, Yale University). </institution>
Reference-contexts: To express general reflection/reification in the store case, we need access to a "first-class store" mechanism. This can actually be implemented reasonably efficiently using version trees, without requiring the whole store to be copied <ref> [JD88, Mor93] </ref>, but it does impose some overhead. The latter example illustrates that it may not always be feasible or desirable to export the full reflection/reification pair for a monad in a real programming language.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: For example, in Scheme we can encode (the control aspects of) an ML-like exception facility in a few lines of code using call=cc and a "current handler" cell. But a proof that such an implementation actually agrees with the explicit exception-passing used in the formal definition of SML <ref> [MTH90] </ref> is by no means a trivial task.
Reference: [MW85] <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda-calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs Proceedings, number 193 in Lecture Notes in Computer Science, </booktitle> <pages> pages 219-224, </pages> <address> Brooklyn, </address> <month> June </month> <year> 1985. </year>
Reference-contexts: In the presence of higher-order functions, however, proving correctness of a continuation-based simulation is decidedly non-trivial <ref> [Rey74a, Sto81, MW85] </ref>, even for a "purely functional" language with partiality as the only notion of computational effect. In this chapter, we will consider the relationship between a direct and a continuation semantics for arbitrary monadic effects. <p> Early investigations [Rey74a, ST80, Sto81] were set in a domain-theoretic framework where the main difficulties concerned reflexive domains; as a result, these methods and results were closely tied to specific semantic models. On the other hand, Meyer and Wand's more abstract approach <ref> [MW85] </ref> applied to all models of simply-typed -calculi, but did not encompass computational effects not even nontermination. The present work, while formulated in a simply-typed setting, and using mostly axiomatic reasoning, is nevertheless closer conceptually to the domain-theoretic results.
Reference: [Pit99] <author> Andrew M. Pitts. </author> <title> Relational properties of domains. </title> <journal> Information and Computation, </journal> <note> 199? Revised version of Cambridge Computer Laboratory Technical Report Number 321. To appear. </note>
Reference-contexts: PROPERTIES OF THE PREDOMAIN MODEL One can show that the standard inverse-limit construction for solving recursive domain equation actually yields minimal invariants: Theorem A.7 Every locally continuous mixed functor in Cpo ? has a minimal invariant. Proof. See <ref> [Pit99] </ref>. <p> Let there be given a relational correspondence between predomain interpretations L of L and L 0 of L 0 (Definition 3.16). Most notably, admissibility is then preserved by formation of inverse images and intersections (e.g., <ref> [Pit99] </ref>): A.2. ADMISSIBLE RELATIONS 123 Lemma A.9 Recall that a (computation-)admissibile relations between closed types ff and ff 0 is a (pointed) chain-complete relation between cpos L [[ff]] and L 0 [[ff 0 ]]. We then have: 1. <p> The following presents only the specific results we need for the proofs in Chapter 4; for a general treatment of the subject, see <ref> [Pit99] </ref>. Throughout this section, let us assume a fixed relational correspondence between predomain interpretations L of L and L 0 of L 0 , with a computation-extension of relations. In keeping with the general convention in this appendix, we also write ? R for relation-lifting. <p> Proof. (The proof technique is due to Pitts and can essentially be found in <ref> [Pit99] </ref>. However, since we are working with binary relations instead of unary ones, and a few details are slightly more involved for predomains than for domains, it seems worth spelling out the construction.) As usual, we abbreviate roll as OE and unroll as .
Reference: [Plo75] <author> Gordon D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1(2) </volume> <pages> 125-159, </pages> <month> December </month> <year> 1975. </year>
Reference-contexts: And, perhaps best-known, continuation-passing style (CPS) passes to every function an explicit representation of the remainder of the computation, to be invoked on the result of that function <ref> [Rey72, Fis72, Plo75] </ref>. While these techniques for modeling computational effects all share a similar feel, they do differ substantially in the details.
Reference: [Plo77] <author> Gordon D. Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5(3) </volume> <pages> 223-255, </pages> <month> December </month> <year> 1977. </year>
Reference-contexts: Its syntax and semantics are very similar to PCF <ref> [Plo77] </ref> (even more so to PCF with lifted types [Mit96], except that the effect structure is made more explicit. We call it Effect-PCF. We present the syntax and informal operational interpretation in this section, with a precise denotational semantics in the next.
Reference: [PW93] <editor> Simon L. Peyton Jones and Philip Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In Proceedings of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 71-84, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: This meant that much of the theory of computational effects could be derived abstractly, without reference to any specific notion of effect. Again, it did not take long for this idea to migrate from mathematical semantics to mainstream functional programming. Work by Wadler and others <ref> [Wad90, Wad92b, PW93] </ref> established monadic style as a practical technique for structuring purely functional programs in a way that could reasonably conveniently express both program-internal effects (exceptions, state, etc.) and external ones (foreign function interfaces and monadic I/O). <p> INTRODUCTION implementation itself, still providing a purely functional interface to the relevant operations, but implementing them more efficiently than what could be expressed explicitly in the language. In particular, several proposals have been made for direct implementations of state in languages like Haskell <ref> [PW93, LPJ95] </ref>. Unfortunately, such a "black-box" approach negates one of the main advantages of the denotational approach: the ability to represent effect meanings explicitly as ordinary, functional constructs that can be reasoned about directly within the language. <p> It is easy to check that these definitions do in fact satisfy the equations in Definition 2.15. The use of monads for structuring purely functional programs as opposed to language semantics is by now quite commonplace <ref> [Wad92b, PW93] </ref>. <p> Most notably, the problems with reification (needed, e.g., to express handle for continuation-based exceptions) in a typed setting were not addressed at all. Peyton Jones and Wadler <ref> [PW93] </ref> probe the relationship between monads and CPS further, and Wadler [Wad94] analyzes composable continuations from a monadic perspective, but in both cases the restriction to Hindley-Milner typable translations obscures the general correspondence; properly expressing the answer-type parametricity 3.4.
Reference: [QS91] <author> Christian Queinnec and Bernard Serpette. </author> <title> A dynamic extent control operator for partial continuations. </title> <booktitle> In Proceedings of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-184, </pages> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year> <note> BIBLIOGRAPHY 137 </note>
Reference-contexts: However, an encoding in standard Scheme of one variant was devised by Sitaram and Felleisen [SF90]. Still, this embedding was quite complex, relying on dynamically-allocated, mutable data structures, eq?-tests, and the dynamic typing of Scheme. Another explicitly Scheme-implementable notion of partial continuations was pro posed by Queinnec and Serpette <ref> [QS91] </ref>; the code required is perhaps even more intric ate. And more recently, an implementation of a related construct in Standard ML of New Jersey was presented by Gunter, Remy and Riecke [GRR95]. 4.6.
Reference: [Rey72] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proceedings of 25th ACM National Conference, </booktitle> <pages> pages 717-740, </pages> <address> Boston, </address> <month> August </month> <year> 1972. </year>
Reference-contexts: There is a close similarity between the metalanguage of denotational semantics (a concise notation for specifying continuous functions between domains) and actual functional programming languages. This has the fortunate consequence that often an appropriately expressed denotational definition can be directly executed to get an interpreter for the defined language <ref> [Rey72] </ref>. And in fact, many of the techniques pioneered in denotational semantics were quickly adopted for functional programs that were not in any reasonable sense language processors. Specifically, the denotational representation of almost every computational effect leads to a characteristic pattern or style in functional programs using that effect. <p> And, perhaps best-known, continuation-passing style (CPS) passes to every function an explicit representation of the remainder of the computation, to be invoked on the result of that function <ref> [Rey72, Fis72, Plo75] </ref>. While these techniques for modeling computational effects all share a similar feel, they do differ substantially in the details.
Reference: [Rey74a] <author> John C. Reynolds. </author> <title> On the relation between direct and continuation semantics. </title> <editor> In Jacques Loeckx, editor, </editor> <booktitle> 2nd Colloquium on Automata, Languages and Programming, number 14 in Lecture Notes in Computer Science, </booktitle> <pages> pages 141-156, </pages> <address> Saarbrucken, West Germany, </address> <month> July </month> <year> 1974. </year>
Reference-contexts: In the presence of higher-order functions, however, proving correctness of a continuation-based simulation is decidedly non-trivial <ref> [Rey74a, Sto81, MW85] </ref>, even for a "purely functional" language with partiality as the only notion of computational effect. In this chapter, we will consider the relationship between a direct and a continuation semantics for arbitrary monadic effects. <p> Early investigations <ref> [Rey74a, ST80, Sto81] </ref> were set in a domain-theoretic framework where the main difficulties concerned reflexive domains; as a result, these methods and results were closely tied to specific semantic models.
Reference: [Rey74b] <author> John C. Reynolds. </author> <title> Towards a theory of type structure. </title> <editor> In B. Robinet, editor, </editor> <booktitle> Programming Symposium, number 19 in Lecture Notes in Computer Science, </booktitle> <pages> pages 408-425, </pages> <address> Paris, France, </address> <month> April </month> <year> 1974. </year>
Reference-contexts: However, the fact that the continuation-based representation is in a sense parametric in the choice of fl cannot be captured equationally in our setting. (It might be possible in a language with F 2 -polymorphism <ref> [Gir72, Rey74b] </ref>.) For the formal proof in Section 3.3, we will therefore need a stronger, relational characterization of i to accurately express this property. 3.1.2 The variant translation In this section, we show how to actually exploit the existence of a monad morphism (with some further properties) to simulate one kind
Reference: [Rey93] <author> John C. Reynolds. </author> <title> The discoveries of continuations. </title> <journal> Lisp and Symbolic Computation, </journal> 6(3/4):233-247, November 1993. 
Reference-contexts: Perhaps the most striking example of this was the use of continuation functions for modeling unstructured control constructs (gotos) <ref> [SW74, Rey93] </ref>; simpler techniques sufficed for concepts such as state or exceptions. There is a close similarity between the metalanguage of denotational semantics (a concise notation for specifying continuous functions between domains) and actual functional programming languages.
Reference: [Sch86] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <year> 1986. </year>
Reference-contexts: Similar considerations apply to analyzing control-based implementations of backtracking [Hay87, HDM93] or concurrency [Wan80]: while the code may be short, elegant, and intuitively plausible, formally relating it to a more abstract denotational specification, such as success lists [Wad85] or resumptions <ref> [Sch86, Mog90] </ref>, is often a serious undertaking. One could thus say that it is in this sense that "purely functional" programs offer 6 CHAPTER 1. INTRODUCTION a pragmatic reasoning advantage over "impure" ones: by penalizing all effects equally, they do not discourage the use of precise, custom-tailored effect representations.
Reference: [SF90] <author> Dorai Sitaram and Matthias Felleisen. </author> <title> Control delimiters and their hierarchies. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(1) </volume> <pages> 67-99, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: k r 1 in r 2 ) in (s x)) =6 Note also that we could define A M = S (k 0!! : M ) Although probably not as well known as call=cc, control operators like S, A, and # have already seen a fair amount of study, e.g., <ref> [Fel88, SF90, DF92, Wad94, Fil94, GRR95] </ref>; we will briefly compare the various approaches in Section 4.6. <p> Early work [JD88, FWFD88, DF90] presumed explicit support from the compiler or runtime system for the actual implementation, such as the ability to mark or splice together delimited stack segments. However, an encoding in standard Scheme of one variant was devised by Sitaram and Felleisen <ref> [SF90] </ref>. Still, this embedding was quite complex, relying on dynamically-allocated, mutable data structures, eq?-tests, and the dynamic typing of Scheme. Another explicitly Scheme-implementable notion of partial continuations was pro posed by Queinnec and Serpette [QS91]; the code required is perhaps even more intric ate.
Reference: [SF93] <author> Amr Sabry and Matthias Felleisen. </author> <title> Reasoning about programs in continuation-passing style. </title> <journal> Lisp and Symbolic Computation, </journal> 6(3/4):289-360, November 1993. (An earlier version appeared in Proceedings of the 1992 ACM Conference on Lisp and Functional Programming). 
Reference-contexts: RELATED WORK 79 in a simulation of general monads by continuation-passing requires a more flexible type system. Finally, another glimmer of the connection between monads and continuations can be seen in Sabry and Felleisen's result that fij-equivalence of CPS terms coincides with direct-style equivalence in Moggi's computational -calculus <ref> [SF93, Mog89] </ref>; the latter captures exactly the equivalences holding in the presence of arbitrary monadic effects. While this does not by itself imply that any monadic effect can be simulated by a continuation monad, it does indicate that continuations form a maximally (but not necessarily most) general notion of effect.
Reference: [Smi82] <author> Brian C. Smith. </author> <title> Reflection and Semantics in a Procedural Language. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, Cambridge, Massachusetts, </institution> <month> January </month> <year> 1982. </year> <month> MIT-LCS-TR-272. </month>
Reference-contexts: As also noted by Moggi, this abstract correspondence principle can be embodied into a concrete language construct which we will call monadic reflection (by analogy to the more general notion of computational reflection <ref> [Smi82, WF88] </ref>). Specifically, we take: Definition 1.4 (preliminary) A reflection of a monad T in a language is given by two operators ` V : T ff and ` [E] : T ff 1.2.
Reference: [ST80] <author> Ravi Sethi and Adrian Tang. </author> <title> Constructing call-by-value continuation semantics. </title> <journal> Journal of the ACM, </journal> <volume> 27(3) </volume> <pages> 580-597, </pages> <month> July </month> <year> 1980. </year>
Reference-contexts: Early investigations <ref> [Rey74a, ST80, Sto81] </ref> were set in a domain-theoretic framework where the main difficulties concerned reflexive domains; as a result, these methods and results were closely tied to specific semantic models.
Reference: [Ste94] <author> Guy L. Steele, Jr. </author> <title> Building interpreters by composing monads. </title> <booktitle> In Proceedings of the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 472-492, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: handlers, where an exception is implicitly re-raised if it does not match any of the clauses in a handler; we want to ensure that such a handler has no effect on the result of the program. 2.4 Related work There has already been much work on combining monadic effects, e.g., <ref> [Mog90, KW93, CM93, Ste94, LHJ95, Esp95] </ref>, of varying degrees of generality and formality. None of these approaches, however, were particularly concerned about nonstandard implementations of 44 CHAPTER 2.
Reference: [Sto81] <author> Joseph E. Stoy. </author> <title> The congruence of two programming language definitions. </title> <journal> Theoretical Computer Science, </journal> <volume> 13(2) </volume> <pages> 151-174, </pages> <month> February </month> <year> 1981. </year>
Reference-contexts: In the presence of higher-order functions, however, proving correctness of a continuation-based simulation is decidedly non-trivial <ref> [Rey74a, Sto81, MW85] </ref>, even for a "purely functional" language with partiality as the only notion of computational effect. In this chapter, we will consider the relationship between a direct and a continuation semantics for arbitrary monadic effects. <p> Early investigations <ref> [Rey74a, ST80, Sto81] </ref> were set in a domain-theoretic framework where the main difficulties concerned reflexive domains; as a result, these methods and results were closely tied to specific semantic models.
Reference: [SW74] <author> Christopher Strachey and Christopher P. Wadsworth. </author> <title> Continuations: A mathematical semantics for handling full jumps. </title> <type> Technical Monograph PRG-11, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, Oxford, Eng-land, </institution> <year> 1974. </year>
Reference-contexts: Perhaps the most striking example of this was the use of continuation functions for modeling unstructured control constructs (gotos) <ref> [SW74, Rey93] </ref>; simpler techniques sufficed for concepts such as state or exceptions. There is a close similarity between the metalanguage of denotational semantics (a concise notation for specifying continuous functions between domains) and actual functional programming languages.
Reference: [Wad85] <author> Philip Wadler. </author> <title> How to replace failure by a list of successes. </title> <booktitle> In Functional Programming Languages and Computer Architecture, number 201 in Lecture Notes in Computer Science, </booktitle> <address> Nancy, France, </address> <month> September </month> <year> 1985. </year>
Reference-contexts: Similar considerations apply to analyzing control-based implementations of backtracking [Hay87, HDM93] or concurrency [Wan80]: while the code may be short, elegant, and intuitively plausible, formally relating it to a more abstract denotational specification, such as success lists <ref> [Wad85] </ref> or resumptions [Sch86, Mog90], is often a serious undertaking. One could thus say that it is in this sense that "purely functional" programs offer 6 CHAPTER 1.
Reference: [Wad90] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 61-78, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year> <note> 138 BIBLIOGRAPHY </note>
Reference-contexts: This meant that much of the theory of computational effects could be derived abstractly, without reference to any specific notion of effect. Again, it did not take long for this idea to migrate from mathematical semantics to mainstream functional programming. Work by Wadler and others <ref> [Wad90, Wad92b, PW93] </ref> established monadic style as a practical technique for structuring purely functional programs in a way that could reasonably conveniently express both program-internal effects (exceptions, state, etc.) and external ones (foreign function interfaces and monadic I/O). <p> scale to ambient effects and especially recursion.) A possible correspondence between monads and continuation-passing style (CPS) was conjectured by Danvy and Filinski [DF90], and more concretely presented by Wadler [Wad92b]. (The general idea of using a monad morphism to simulate one monadic effect with another is also due to Wadler <ref> [Wad90] </ref>.) However, this work was largely informal. Most notably, the problems with reification (needed, e.g., to express handle for continuation-based exceptions) in a typed setting were not addressed at all.
Reference: [Wad92a] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 461-493, </pages> <month> December </month> <year> 1992. </year> <note> (An earlier version appeared in Proceedings of the 1990 ACM Conference on Lisp and Functional Programming). </note>
Reference-contexts: theory, the a monad is conventionally defined in terms of a functor T and natural transformations j : Id ! T and : T 2 ! T satisfying certain equalities [ML71, VI.1]. (In the context of functional programming, the corresponding operations are usually referred to as map, unit, and join <ref> [Wad92a] </ref>.) It is easy to see, however, that the two formulations are equivalent: every Kleisli triple (T; j; fl ) determines a monad (T; j; ) by T f = (j ffi f ) fl and ff = id fl Conversely, every monad determines a Kleisli triple by f fl = <p> As observed by Wadler, however, list comprehensions can be generalized to arbitrary monads <ref> [Wad92a] </ref>; similarly we get general monad comprehensions in ML simply by supplying the appropriate [ ] and ( ) operations. 110 CHAPTER 4. <p> Ease of reasoning. Despite its apparent "imperative" nature, monadic reflection can equally well be viewed as a technique for writing "purely functional" programs in a more concise notation, much like monad comprehensions <ref> [Wad92a] </ref>. In fact, any imperative program fragment is extensionally equivalent to its monadic-style counterpart, in the sense that there exist language-definable isomorphisms between the two representations. 114 5.1.
Reference: [Wad92b] <author> Philip Wadler. </author> <title> The essence of functional programming (invited talk). </title> <booktitle> In Proceedings of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: This meant that much of the theory of computational effects could be derived abstractly, without reference to any specific notion of effect. Again, it did not take long for this idea to migrate from mathematical semantics to mainstream functional programming. Work by Wadler and others <ref> [Wad90, Wad92b, PW93] </ref> established monadic style as a practical technique for structuring purely functional programs in a way that could reasonably conveniently express both program-internal effects (exceptions, state, etc.) and external ones (foreign function interfaces and monadic I/O). <p> In the following, we will therefore use the terms "Kleisli triple" and "monad" synonymously. A simple syntactic variation on Kleisli triples, popularized by Wadler <ref> [Wad92b] </ref>, uses a binary infix operator to denote application of an extended function, writing t `bind` f or t ? f for our f fl t. This "continuation last" notation is usually preferable for writing 10 CHAPTER 1. <p> It is easy to check that these definitions do in fact satisfy the equations in Definition 2.15. The use of monads for structuring purely functional programs as opposed to language semantics is by now quite commonplace <ref> [Wad92b, PW93] </ref>. <p> obstacles. (The initial version in [Fil94] was based on the Meyer-Wand approach, but it is not clear how well that would scale to ambient effects and especially recursion.) A possible correspondence between monads and continuation-passing style (CPS) was conjectured by Danvy and Filinski [DF90], and more concretely presented by Wadler <ref> [Wad92b] </ref>. (The general idea of using a monad morphism to simulate one monadic effect with another is also due to Wadler [Wad90].) However, this work was largely informal. <p> We also give several examples; the reader may want to compare these with Wadler's presentation <ref> [Wad92b] </ref>. 4.5.1 Composable continuations In SML/NJ, first-class continuations have a type distinct from the type of general procedures.
Reference: [Wad94] <author> Philip Wadler. </author> <title> Monads and composable continuations. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 7(1) </volume> <pages> 39-56, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Most notably, the problems with reification (needed, e.g., to express handle for continuation-based exceptions) in a typed setting were not addressed at all. Peyton Jones and Wadler [PW93] probe the relationship between monads and CPS further, and Wadler <ref> [Wad94] </ref> analyzes composable continuations from a monadic perspective, but in both cases the restriction to Hindley-Milner typable translations obscures the general correspondence; properly expressing the answer-type parametricity 3.4. RELATED WORK 79 in a simulation of general monads by continuation-passing requires a more flexible type system. <p> k r 1 in r 2 ) in (s x)) =6 Note also that we could define A M = S (k 0!! : M ) Although probably not as well known as call=cc, control operators like S, A, and # have already seen a fair amount of study, e.g., <ref> [Fel88, SF90, DF92, Wad94, Fil94, GRR95] </ref>; we will briefly compare the various approaches in Section 4.6.
Reference: [Wan80] <author> Mitchell Wand. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Conference Record of the 1980 LISP Conference, </booktitle> <pages> pages 19-28, </pages> <address> Stanford, California, </address> <month> August </month> <year> 1980. </year>
Reference-contexts: But a proof that such an implementation actually agrees with the explicit exception-passing used in the formal definition of SML [MTH90] is by no means a trivial task. Similar considerations apply to analyzing control-based implementations of backtracking [Hay87, HDM93] or concurrency <ref> [Wan80] </ref>: while the code may be short, elegant, and intuitively plausible, formally relating it to a more abstract denotational specification, such as success lists [Wad85] or resumptions [Sch86, Mog90], is often a serious undertaking.
Reference: [WF88] <author> Mitchell Wand and Daniel P. Friedman. </author> <title> The mystery of the tower revealed: A non-reflective description of the reflective tower. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 1(1), </volume> <month> May </month> <year> 1988. </year>
Reference-contexts: As also noted by Moggi, this abstract correspondence principle can be embodied into a concrete language construct which we will call monadic reflection (by analogy to the more general notion of computational reflection <ref> [Smi82, WF88] </ref>). Specifically, we take: Definition 1.4 (preliminary) A reflection of a monad T in a language is given by two operators ` V : T ff and ` [E] : T ff 1.2. <p> The term metacontinuation, with a fairly broad meaning, was first used in giving a formal semantics to a notion of computational reflection by Wand and Friedman <ref> [WF88] </ref>. The more restrictive usage of the term, where the metacontinuation actually arises from a standard continuation-passing transform of an "almost-cps" term, is due to Danvy and Filinski [DF90].
References-found: 58

