URL: http://www.cs.wisc.edu/wpis/papers/popl96.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Title: Solving Shape-Analysis Problems in Languages with Destructive Updating  
Author: Mooly Sagiv and Thomas Reps Reinhard Wilhelm 
Affiliation: University of Wisconsin  Universitat des Saarlandes  
Abstract: This paper concerns the static analysis of programs that perform destructive updating on heap-allocated storage. We give an algorithm that conservatively solves this problem by using a finite shape-graph to approximate the possible "shapes" that heap-allocated structures in a program can take on. In contrast with previous work, our method is even accurate for certain programs that update cyclic data structures. For example, our method can determine that when the input to a program that searches a list and splices in a new element is a possibly circular list, the output is a possibly circular list. 
Abstract-found: 1
Intro-found: 1
Reference: [AW93] <author> U. Assmann and M. Weinhardt. </author> <title> Interprocedural Heap Analysis For Parallelizing Imperative Programs. </title> <editor> In W. K. Giloi, S. Jahnichen, and B. D. Shriver, editors, </editor> <booktitle> Programming Models For Massively Parallel Computers, </booktitle> <pages> pages 74-82. </pages> <publisher> IEEE Press, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: Jones and Muchnick [JM82], Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed earlier, both from a theoretical perspective [CWZ90] and from an implementation perspective <ref> [AW93] </ref>.
Reference: [CBC93] <author> J.-D. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side-effects. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <year> 1993. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program.
Reference: [CWZ90] <author> D.R. Chase, M. Wegman, and F. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <year> 1990. </year>
Reference-contexts: Furthermore, our method can determine that the list-insert program also preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, JM82, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> such qualitatively better results on the above-mentioned programs than previous methods? A detailed examination of the differences between our algorithm and previous algorithms is deferred to Section 6; however, a brief characterization of some of the differences is as follows: * Previous methods have used allocation sites to name shape-nodes <ref> [JM82, CWZ90, PCK93] </ref>. Allocation-site information imposes a fixed partition on the memory. In contrast, our approach deliberately drops information about the concrete locations. There is only an indirect connection to the run-time locations: Shape-graph nodes are named using a (possibly empty) set of variables. <p> Chase, Wegman, and Zadeck observed that their analysis method cannot handle programs such as the list-reversal program be cause it lacks a way to materialize ("un-summarize") sum-mary nodes at certain key points of the analysis <ref> [CWZ90, pp. 309] </ref>. <p> Previous methods either never remove these edges [Str92] or have some heuristics to remove such edges under certain conditions <ref> [JM81, LH88, CWZ90, PCK93] </ref>. (This unusual characteristic of our method is enabled by both the node-naming scheme and the materialization technique.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> The limited form of sharing information used in <ref> [JM81, CWZ90] </ref> does not allow these methods to determine this fact. * The shape-node names also provide information that some times permits our method to determine that a shared-node becomes unshared (e.g., this occurs in the program that performs an insertion into a list). <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck <ref> [CWZ90] </ref>, and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> The use of a single shape-graph is possibly less accurate than a method based on sets of graphs, but it leads to more compact representations, and thus is more likely to lead to a practical shape-analysis algorithm. Jones and Muchnick [JM82], Chase, Wegman, and Zadeck <ref> [CWZ90] </ref>, and Stransky [Str92] present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed earlier, both from a theoretical perspective [CWZ90] and from an implementation perspective [AW93]. <p> Jones and Muchnick [JM82], Chase, Wegman, and Zadeck <ref> [CWZ90] </ref>, and Stransky [Str92] present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed earlier, both from a theoretical perspective [CWZ90] and from an implementation perspective [AW93]. <p> The Chase-Wegman-Zadeck algorithm lacks a node-materialization operation (although they did recognize that the lack of one was a stumbling block to the ac curacy of their method <ref> [CWZ90, pp. 309] </ref>). Chase, Wegman, and Zadeck use reference-count values 0, 1, and 1, whereas we use a Boolean-valued is shared value.
Reference: [Deu92] <author> A. Deutsch. </author> <title> A storeless model for aliasing and its ab-stractions using finite representations of right-regular equivalence relations. </title> <booktitle> In IEEE International Conference on Computer Languages, </booktitle> <pages> pages 2-13, </pages> <year> 1992. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program.
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program. <p> There are also several algorithms for finding may aliases that are not based on shape-graphs. The most sophisticated ones are those of Landi and Ryder [LR91] and Deutsch <ref> [Deu94] </ref>. Deutsch's algorithm is particularly interesting because, for certain programs that manipulate lists, it offers a way of representing the exact (infinite set of) may aliases in a compact way.
Reference: [Hen90] <author> L. Hendren. </author> <title> Parallelizing Programs with Recursive Data Structures. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> Jan </month> <year> 1990. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program. <p> With the Chase-Wegman-Zadeck method, once a node is shared it remains shared forever thereafter. For programs that operate on lists and trees, the non-graph-based method of Hendren <ref> [Hen90] </ref> is sometimes able to determine that a shared-node becomes unshared. However, this method does not handle data structures that contain cycles. An experimental implementation of the analysis method has been created; the examples presented in the paper have been prepared with the aid of this implementation. <p> We do not mean to imply that our method dominates the Landi-Ryder and Deutsch algorithms; there exist programs in which the Deutsch algorithm is more accurate than our algorithm. A different approach was taken by Hendren, who designed an algorithm that handles only acyclic data structures <ref> [HN90, Hen90] </ref>. Because of the choice to work with programs that only manipulate acyclic structures, the algorithm does not have to have a way of representing cycles conservatively. For this alias-analysis problem, she has given an efficient algorithm that manipulates matrices that record access paths that are aliased.
Reference: [HG92] <author> L. Hendren and G.R. Gao. </author> <title> Designing programming languages for analyzability: A fresh look at pointer data structures. </title> <booktitle> In Proceedings of the International Conference on Computer Languages, </booktitle> <pages> pages 242-251, </pages> <year> 1992. </year>
Reference-contexts: This kind of conservative approximation is appropriate for use, for example, in parallelizing compilers <ref> [HNH92, HG92] </ref>. (An extension of our basic technique allows definitely circular structures to be identified. See Section 5.4.) 2 4.3 The Abstract Interpretation The abstract meaning function [[ ]] SSG : SSG ! SSG for the pointer-manipulation statements is given in Figure 6.
Reference: [HN90] <author> L. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program. <p> We do not mean to imply that our method dominates the Landi-Ryder and Deutsch algorithms; there exist programs in which the Deutsch algorithm is more accurate than our algorithm. A different approach was taken by Hendren, who designed an algorithm that handles only acyclic data structures <ref> [HN90, Hen90] </ref>. Because of the choice to work with programs that only manipulate acyclic structures, the algorithm does not have to have a way of representing cycles conservatively. For this alias-analysis problem, she has given an efficient algorithm that manipulates matrices that record access paths that are aliased.
Reference: [HNH92] <author> L. Hendren, A. Nicolau, and J. Hummel. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and the transformation of imperative programs. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 249-260, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This kind of conservative approximation is appropriate for use, for example, in parallelizing compilers <ref> [HNH92, HG92] </ref>. (An extension of our basic technique allows definitely circular structures to be identified. See Section 5.4.) 2 4.3 The Abstract Interpretation The abstract meaning function [[ ]] SSG : SSG ! SSG for the pointer-manipulation statements is given in Figure 6.
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <year> 1989. </year>
Reference-contexts: In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., <ref> [HPR89] </ref>). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph.
Reference: [JM81] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> Flow analysis and optimization of Lisp-like structures. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 4, </volume> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Furthermore, our method can determine that the list-insert program also preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, JM82, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> Previous methods either never remove these edges [Str92] or have some heuristics to remove such edges under certain conditions <ref> [JM81, LH88, CWZ90, PCK93] </ref>. (This unusual characteristic of our method is enabled by both the node-naming scheme and the materialization technique.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> The limited form of sharing information used in <ref> [JM81, CWZ90] </ref> does not allow these methods to determine this fact. * The shape-node names also provide information that some times permits our method to determine that a shared-node becomes unshared (e.g., this occurs in the program that performs an insertion into a list). <p> this means, we can guarantee that a fixed point of Equation (1) of Section 4.3 can be found in polynomial time; the widening operator simply has to be applied whenever necessary to limit the cardinality of shape-node name sets to some chosen constant. (This is similar in spirit to k-limiting <ref> [JM81] </ref>, but is likely to produce more accurate results because limiting the cardinality of name sets still preserves most of the structural information about the graph.) Details can be found in [SRW95]. 12 x - r - x - r z - n fz;yg r - r ?? n feg (a) <p> A similar shape-analysis problem, but for an imperative language supporting non-destructive manipulation of heap-allocated objects, was formulated independently by Jones and Muchnick, who treated the problem as one of solving (i.e., finding the least fixed-point of) a collection of equations using regular tree grammars <ref> [JM81] </ref>. In that same paper, Jones and Muchnick also began the study of shape analysis for languages with destructive updating. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in <ref> [JM81] </ref>), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> location, the sel 0 5 In this section, we use the term "shape-graph" in the generic sense, meaning any finite graph structure used to approximate the shapes of run-time data structures. 6 The idea of augmenting shape-graphs with sharing information also appears in the earlier work of Jones and Muchnick <ref> [JM81] </ref>. selector-edges emanating from the shape-node that x points to are overwritten (a so-called "strong update"). The Chase-Wegman-Zadeck algorithm is able to identify list-preservation properties in some cases; for instance, it can determine that a program that appends a list to a list preserves "list-ness".
Reference: [JM82] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <year> 1982. </year>
Reference-contexts: Furthermore, our method can determine that the list-insert program also preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, JM82, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> such qualitatively better results on the above-mentioned programs than previous methods? A detailed examination of the differences between our algorithm and previous algorithms is deferred to Section 6; however, a brief characterization of some of the differences is as follows: * Previous methods have used allocation sites to name shape-nodes <ref> [JM82, CWZ90, PCK93] </ref>. Allocation-site information imposes a fixed partition on the memory. In contrast, our approach deliberately drops information about the concrete locations. There is only an indirect connection to the run-time locations: Shape-graph nodes are named using a (possibly empty) set of variables. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick <ref> [JM82] </ref>, Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> The use of a single shape-graph is possibly less accurate than a method based on sets of graphs, but it leads to more compact representations, and thus is more likely to lead to a practical shape-analysis algorithm. Jones and Muchnick <ref> [JM82] </ref>, Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed earlier, both from a theoretical perspective [CWZ90] and from an implementation perspective [AW93].
Reference: [Lan92] <author> W. Landi. </author> <title> Undecidability of static analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(4), </volume> <year> 1992. </year>
Reference-contexts: However, Myers's work does not handle heap-allocated storage and destructive updating. Therefore, his algorithm is significantly simpler and he is even able to show that it is precise. In contrast, it is undecidable to give a precise solution to our problem, even in the absence of procedure calls <ref> [Lan92, Ram94] </ref>. Acknowledgments We are grateful for the helpful comments of Alain Deutsch, Christian Fecht, and Neil Jones. Laurie Hendren provided us with extensive and very helpful information about the capabilities of her analysis technique.
Reference: [Lar89] <author> J.R. Larus. </author> <title> Restructuring Symbolic Programs for Concurrent Execution on Multiprocessors. </title> <type> PhD thesis, </type> <institution> University of California, </institution> <year> 1989. </year>
Reference-contexts: In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger <ref> [LH88, Lar89] </ref>, Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> Larus and Hilfinger <ref> [LH88, Lar89] </ref> devised a shape-analysis algorithm that is based on somewhat different principles from the aforementioned work. As with our algorithm, shape-nodes are labeled with some auxiliary information.
Reference: [LH88] <author> J.R. Larus and P.N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <year> 1988. </year>
Reference-contexts: Furthermore, our method can determine that the list-insert program also preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, JM82, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> Previous methods either never remove these edges [Str92] or have some heuristics to remove such edges under certain conditions <ref> [JM81, LH88, CWZ90, PCK93] </ref>. (This unusual characteristic of our method is enabled by both the node-naming scheme and the materialization technique.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger <ref> [LH88, Lar89] </ref>, Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> Larus and Hilfinger <ref> [LH88, Lar89] </ref> devised a shape-analysis algorithm that is based on somewhat different principles from the aforementioned work. As with our algorithm, shape-nodes are labeled with some auxiliary information.
Reference: [LR91] <author> W. Landi and B.G. Ryder. </author> <title> Pointer induced aliasing: A problem classification. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <year> 1991. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program. <p> There are also several algorithms for finding may aliases that are not based on shape-graphs. The most sophisticated ones are those of Landi and Ryder <ref> [LR91] </ref> and Deutsch [Deu94]. Deutsch's algorithm is particularly interesting because, for certain programs that manipulate lists, it offers a way of representing the exact (infinite set of) may aliases in a compact way.
Reference: [Mye81] <author> E.W. Myers. </author> <title> A precise inter-procedural data flow algorithm. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <year> 1981. </year>
Reference-contexts: However, by design, Hendren's algorithm cannot determine such structure-preservation properties for programs that handle cyclic lists. Myers presented an algorithm for interprocedural bit-vector problems that accounts for aliasing <ref> [Mye81] </ref>. Like our shape-analysis algorithm, his algorithm also keeps track of sets of aliased variables. He conjectured that in practice the sizes of the alias sets remain small. However, Myers's work does not handle heap-allocated storage and destructive updating.
Reference: [PCK93] <author> J. Plevyak, A.A. Chien, and V. Karamcheti. </author> <title> Analysis of dynamic structures for efficient parallel execution. </title> <editor> In U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing, volume 768 of Lecture Notes in Computer Science, </booktitle> <pages> pages 37-57, </pages> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: Furthermore, our method can determine that the list-insert program also preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, JM82, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> such qualitatively better results on the above-mentioned programs than previous methods? A detailed examination of the differences between our algorithm and previous algorithms is deferred to Section 6; however, a brief characterization of some of the differences is as follows: * Previous methods have used allocation sites to name shape-nodes <ref> [JM82, CWZ90, PCK93] </ref>. Allocation-site information imposes a fixed partition on the memory. In contrast, our approach deliberately drops information about the concrete locations. There is only an indirect connection to the run-time locations: Shape-graph nodes are named using a (possibly empty) set of variables. <p> Previous methods either never remove these edges [Str92] or have some heuristics to remove such edges under certain conditions <ref> [JM81, LH88, CWZ90, PCK93] </ref>. (This unusual characteristic of our method is enabled by both the node-naming scheme and the materialization technique.) * We use sharing information to increase the accuracy of the primitive operations used by our method.
Reference: [Ram94] <author> G. Ramalingam. </author> <title> The undecidability of aliasing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1467-1471, </pages> <year> 1994. </year>
Reference-contexts: However, Myers's work does not handle heap-allocated storage and destructive updating. Therefore, his algorithm is significantly simpler and he is even able to show that it is precise. In contrast, it is undecidable to give a precise solution to our problem, even in the absence of procedure calls <ref> [Lan92, Ram94] </ref>. Acknowledgments We are grateful for the helpful comments of Alain Deutsch, Christian Fecht, and Neil Jones. Laurie Hendren provided us with extensive and very helpful information about the capabilities of her analysis technique.
Reference: [Rey68] <author> J.C. Reynolds. </author> <title> Automatic computation of data set definitions. </title> <booktitle> In Information Processing 68: Proceedings of the IFIP Congress, </booktitle> <pages> pages 456-461, </pages> <address> New York, NY, 1968. </address> <publisher> North-Holland. </publisher>
Reference-contexts: to n atom in the two shape-nodes); Figure 5 (e) represents a definitely cyclic list of length 1; and Figure 5 (f) represents a possibly cyclic list of length 1. 13 6 Related Work The shape-analysis problem was originally investigated by Reynolds for a Lisp-like language with no destructive updating <ref> [Rey68] </ref>. Reynolds treated the problem as one of simplifying a collection of set equations.
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interpro-cedural data flow analysis. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 7, </volume> <pages> pages 189-234. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Like n , they can represent multiple runtime locations from a single DSG. Using these ideas, we have extended the abstract semantics to handle procedure calls and returns. The second problem can be resolved using one of the known interprocedural techniques of Sharir and Pnueli <ref> [SP81] </ref>. For example, a simple conservative solution is to consider a procedure call as a goto to the called procedure and a return from a procedure P as a goto to all the statements that follow an invocation of P .
Reference: [SRW95] <author> M. Sagiv, T. Reps, and R. Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <type> Technical Report TR-1276, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI, </institution> <month> July </month> <year> 1995. </year> <note> Available on the WWW from URL http://www.cs.wisc.edu/trs.html. </note>
Reference-contexts: Section 6 discusses related work. Due to space constraints, we have omitted discussions of (i) other elaborations and extensions of our basic approach, (ii) a proof that our abstract semantics of static shape-graphs is safe with respect to the concrete semantics. This material can be found in <ref> [SRW95] </ref>. 2 Terminology and Notation 2.1 The Language We assume we are working with an imperative language that meets the following general description: A program consists of assignment statements, conditional statements, loops (while, for, repeat), read statements, write statements, and goto statements. 1 The language provides atomic data (e.g., 1 The <p> Also, dereferences of nil pointers are ignored. They are handled in <ref> [SRW95] </ref>. We now turn to the collecting semantics. For a control flow-graph vertex v 2 V , let pathsTo (v) be the set of paths in the control-flow graph from start to predecessors of v. <p> The operations presented in Figure 6 manipulate variable-edges, selector-edges, and sharing information, as well as the alias information that is maintained in the shape-node names of SSGs. It has been shown that these SSG transformers are conservative with respect to the concrete semantics defined in Figure 2 (see <ref> [SRW95] </ref>). The key property of the abstract semantics is that each abstract assignment operation creates an SSG that conservatively covers all the possible new configurations of variable sets whose members all point to the same run-time location (i.e., DSG shape-node). <p> Consequently, variables x and t must point to acyclic lists that do not share any storage in common. 2 Given how complicated the semantic equations in Figure 6 are, the following theorem, whose proof can be found in <ref> [SRW95] </ref>, is reassuring: Theorem 4.9 (Correctness Theorem) For every control-flow-graph vertex v, ff (cs (v)) v SG v . 2 4.4 What the Analysis Algorithm Achieves and Why The abstract interpretation defined in Section 4.3 yields a new shape-analysis algorithm for finding out information about the possible "shapes" that heap-allocated structures <p> More precisely, if at the beginning of the insert program x is a possibly cyclic list of length 1 (see Figure 5 (e)), then at the end of the program, x is a possibly cyclic list of length 2 (see Figure 5 (d)). (For details, see <ref> [SRW95, Appendix B] </ref>.) It is instructive to consider the main reasons why the shape-analysis algorithm is able to produce accurate information about the list-reversal program. <p> to limit the cardinality of shape-node name sets to some chosen constant. (This is similar in spirit to k-limiting [JM81], but is likely to produce more accurate results because limiting the cardinality of name sets still preserves most of the structural information about the graph.) Details can be found in <ref> [SRW95] </ref>. 12 x - r - x - r z - n fz;yg r - r ?? n feg (a) The shape-graph for vertex v 11 . <p> We can also use this approach to determine if there is possible sharing between components of two heap-allocated data structures, which is precisely the kind of information needed to be able to compile programs to take advantage of coarse-grained parallelism. (See <ref> [SRW95] </ref>.) 5.3 Interprocedural Analysis Our method can also be extended to handle procedure calls in a conservative way.
Reference: [Str92] <author> J. Stransky. </author> <title> A lattice for abstract interpretation of dynamic (Lisp-like) structures. </title> <journal> Information and Computation, </journal> <volume> 101(1) </volume> <pages> 70-102, </pages> <month> November </month> <year> 1992. </year> <month> 16 </month>
Reference-contexts: Furthermore, our method can determine that the list-insert program also preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, JM82, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> Previous methods either never remove these edges <ref> [Str92] </ref> or have some heuristics to remove such edges under certain conditions [JM81, LH88, CWZ90, PCK93]. (This unusual characteristic of our method is enabled by both the node-naming scheme and the materialization technique.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck [CWZ90], and Stransky <ref> [Str92] </ref> who developed shape-analysis methods that associate each program point with a single shape-graph. <p> The use of a single shape-graph is possibly less accurate than a method based on sets of graphs, but it leads to more compact representations, and thus is more likely to lead to a practical shape-analysis algorithm. Jones and Muchnick [JM82], Chase, Wegman, and Zadeck [CWZ90], and Stransky <ref> [Str92] </ref> present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed earlier, both from a theoretical perspective [CWZ90] and from an implementation perspective [AW93].
References-found: 23

