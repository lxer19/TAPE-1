URL: http://www.ece.cmu.edu/~ganger/papers/sigmetrics93.ps
Refering-URL: http://www.ece.cmu.edu/~ganger/disksim/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: ganger@eecs.umich.edu  
Title: The Process-Flow Model: Examining I/O Performance from the System's Point of View  
Author: Gregory R. Ganger, Yale N. Patt 
Address: Ann Arbor 48109-2122  
Affiliation: Department of Electrical Engineering and Computer Science University of Michigan,  
Note: Appeared in the Proceedings of the ACM Sigmetrics Conference,May, 1993, pp. 86-97.  
Abstract: Input/output subsystem performance is currently receiving considerable research attention. Significant effort has been focused on reducing average I/O response times and increasing throughput for a given workload. This work has resulted in tremendous advances in I/O subsystem performance. It is unclear, however, how these improvements will be reflected in overall system performance. The central problem lies in the fact that the current method of study tends to treat all I/O requests as equally important. We introduce a three class taxonomy of I/O requests based on their effects on system performance. We denote the three classes time-critical, time-limited, and time-noncritical. A system-level, trace-driven simulation model has been developed for the purpose of studying disk scheduling algorithms. By incorporating knowledge of I/O classes, algorithms tuned for system performance rather than I/O subsystem performance may be developed. Traditional I/O subsystem simulators would rate such algorithms unfavorably because they produce suboptimal subsystem performance. By studying the I/O subsystem via global, system-level simulation, one can more easily identify changes that will improve overall system performance. 
Abstract-found: 1
Intro-found: 1
Reference: [Baker91] <author> M. Baker, J. Hartman, M. Kupfer, K. Shirriff, J. Ousterhout, </author> <title> "Measurements of a Distributed File System", </title> <booktitle> SOSP Proceedings, </booktitle> <year> 1991, </year> <pages> pp. 198-212. </pages>
Reference-contexts: As discussed in Section 3, the timed-out time-noncritical requests are not time-limited in our taxonomy. The timeouts are simply a design restriction for the I/O subsystem. In many environments, unlike our experimental environment, system activity is quite bursty in nature [McNu86] [Zhou88] <ref> [Baker91] </ref> [Ruem93]. We believe that periods of low activity will allow time-noncritical requests to be serviced in the background (i.e., without interfering with the completion of time-critical and time-limited requests). 7 Conclusions We have introduced a taxonomy of I/O requests, dividing them into three sets | time-critical, time-limited, and time-noncritical. <p> The use of timeouts can limit this starvation, but only at the cost of reducing the performance gains. Fortunately, in many environments the system activity is very bursty [McNu86] [Zhou88] <ref> [Baker91] </ref> [Ruem93]. Periods of relative inactivity should allow for completion of time-noncritical requests. Our experimentation also suggests that changing disk scheduling algorithms to incorporate class information may require re-examining current process scheduling algorithms.
Reference: [Cars92] <author> S. Carson, S. Setia, </author> <title> "Analysis of the Periodic Update Write Policy for Disk Cache", </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> January, </month> <year> 1992. </year>
Reference-contexts: They found that 50-75% of disk requests are synchronous, partially due to the write-through meta-data cache on the systems traced. It has also been noted that bursts of delayed (time-noncritical) writes caused by periodic update policies can seriously degrade performance. <ref> [Cars92] </ref> and [Cars92a] argue that disk cache performance should be measured in terms of its effect on read performance. They study different update policies with analytical models using read performance as their metric. They suggest that a disk scheduling algorithm which gives preference to reads may provide significant improvements. <p> It checks the blocks in one-sixtieth of the cache, marks all dirty blocks and initiates write requests for them. This algorithm represents a significant reduction in write burstiness (as studied in <ref> [Cars92] </ref>), but does not completely alleviate this phenomenon. With the exception of one time-critical write caused by each file creation, all of the writes are time-noncritical. 5.3 Simulator Validation As mentioned above, the tracing mechanism gathers enough information to allow for both execution and validation of the process-flow model.
Reference: [Cars92a] <author> S. Carson, S. Setia, </author> <title> "Optimal Write Batch Size in Log-Structured File Systems", </title> <booktitle> Proceedings of USENIX File Systems Workshop, </booktitle> <year> 1992, </year> <pages> pp. 79-91. </pages>
Reference-contexts: They found that 50-75% of disk requests are synchronous, partially due to the write-through meta-data cache on the systems traced. It has also been noted that bursts of delayed (time-noncritical) writes caused by periodic update policies can seriously degrade performance. [Cars92] and <ref> [Cars92a] </ref> argue that disk cache performance should be measured in terms of its effect on read performance. They study different update policies with analytical models using read performance as their metric. They suggest that a disk scheduling algorithm which gives preference to reads may provide significant improvements.
Reference: [Chiu78] <author> W. Chiu, W. Chow, </author> <title> "A Performance Model of MVS", </title> <journal> IBM System Journal, </journal> <volume> Vol. 17, No. 4, </volume> <year> 1978, </year> <pages> pp. 444-463. </pages>
Reference-contexts: Section 7 presents our conclusions and some areas for future work. 2 Previous Work As with many other topics in computer design, one finds discussions of system-level modeling in the archives of IBM. [Seam69] and <ref> [Chiu78] </ref>, for example, describe such modeling efforts used mainly for examining various system configurations and evaluating proposed changes. Our process-flow model revisits this methodology and extends it. [Haig90] describes a system performance measurement technique which is very similar to our tra-cing methodology.
Reference: [DDI90] <author> Device Driver Interface/Driver-Kernel Interface (DDI/DKI) Reference Manual, </author> <title> UNIX System V/386 Release 4, </title> <journal> AT&T, </journal> <year> 1990. </year>
Reference-contexts: Some changes to the system code which makes calls to the device driver may be required. We assume that the interface between these two components is clean, as with the DDI/DKI <ref> [DDI90] </ref> in UNIX T M . The key then is to get the class information past the interface. The various pieces of system code which call the device driver to initiate the requests can generally infer the proper I/O classification based on their higher-level function.
Reference: [Geis87] <author> R. Geist, S. Daniel, </author> <title> "A Continuum of Disk Scheduling Algorithms", </title> <journal> ACM Transactions on Computer Systems, </journal> <month> February </month> <year> 1987, </year> <pages> pp. 77-92. </pages>
Reference-contexts: They match the observed values of the system from which the traces were gathered. There have been many studies of alternative disk scheduling algorithms [Teor72] <ref> [Geis87] </ref> [Selt90] [Jaco91]. Most of them use request sorting to reduce seek times while incorporating some type of fairness algorithm. Some of the more recent work has added rotational position to the equation, targeting a reduction in total access time [Selt90] [Jaco91].
Reference: [Geis87a] <author> R. Geist, R. Reynolds, E. Pittard, </author> <title> "Disk Scheduling in System V", Performance Evaluation Review, </title> <month> May </month> <year> 1987, </year> <pages> pp. 59-68. </pages>
Reference: [Haig90] <author> P. Haigh, </author> <title> "An Event Tracing Method for UNIX Performance Measurement", </title> <booktitle> CMG Proceedings, </booktitle> <year> 1990, </year> <pages> pp. 603-609. </pages>
Reference-contexts: Our process-flow model revisits this methodology and extends it. <ref> [Haig90] </ref> describes a system performance measurement technique which is very similar to our tra-cing methodology.
Reference: [Jaco91] <author> D. Jacobson, J. Wilkes, </author> <title> "Disk Scheduling Algorithms Based on Rotational Position", </title> <type> Hewlett-Packard Technical Report, </type> <institution> HPL-CSP-91-7, </institution> <month> Feb. 26, </month> <year> 1991. </year>
Reference-contexts: They match the observed values of the system from which the traces were gathered. There have been many studies of alternative disk scheduling algorithms [Teor72] [Geis87] [Selt90] <ref> [Jaco91] </ref>. Most of them use request sorting to reduce seek times while incorporating some type of fairness algorithm. Some of the more recent work has added rotational position to the equation, targeting a reduction in total access time [Selt90] [Jaco91]. <p> been many studies of alternative disk scheduling algorithms [Teor72] [Geis87] [Selt90] <ref> [Jaco91] </ref>. Most of them use request sorting to reduce seek times while incorporating some type of fairness algorithm. Some of the more recent work has added rotational position to the equation, targeting a reduction in total access time [Selt90] [Jaco91]. In all these cases, however, the work is limited by the fact that all requests are treated equally. As described in section 3, we have separated I/O requests into three distinct classes. From a short-term viewpoint, time-critical I/O requests are clearly more important to system performance than time-noncritical requests. <p> More workloads must be examined before drawing final conclusions about scheduling algorithms. Second, more disk scheduling algorithms must be considered. It has been noted that sorting based on both seek time and rotation time is often superior to sorting on seek time alone [Selt90] <ref> [Jaco91] </ref>. Also, we have not yet exploited the difference between time-critical requests and time-limited requests. Third, many state-of-the-art disk drives are equipped with request queues.
Reference: [Kim86] <author> M. Kim, </author> <title> "Synchronized Disk Interleaving", </title> <journal> IEEE Transactions on Computers, </journal> <month> November </month> <year> 1986, </year> <pages> pp. 978-988. </pages>
Reference: [McKu84] <author> M. McKusick, W. Joy, S. Le*er, R. Fabry, </author> <title> "A Fast File System for UNIX", </title> <journal> ACM Transactions on Computer Systems, </journal> <month> August </month> <year> 1984, </year> <pages> pp. 181-197. </pages>
Reference-contexts: The compression processes sequentially read a large file and sequentially write out a large file. The first read request is time-critical because the block is not in the cache. The file system, which is based on the Berkeley Fast File System <ref> [McKu84] </ref>, also generates a time-limited read-ahead request. Each time the previous read-ahead block is accessed, a time-limited read request is generated for the next block. So, essentially all of the reads are time-limited.
Reference: [McNu86] <author> B. McNutt, </author> <title> "An Empirical Study of Variations in DASD Volume Activity", </title> <booktitle> CMG Proceedings, </booktitle> <year> 1986, </year> <pages> pp. 274-283. </pages>
Reference-contexts: As discussed in Section 3, the timed-out time-noncritical requests are not time-limited in our taxonomy. The timeouts are simply a design restriction for the I/O subsystem. In many environments, unlike our experimental environment, system activity is quite bursty in nature <ref> [McNu86] </ref> [Zhou88] [Baker91] [Ruem93]. <p> The use of timeouts can limit this starvation, but only at the cost of reducing the performance gains. Fortunately, in many environments the system activity is very bursty <ref> [McNu86] </ref> [Zhou88] [Baker91] [Ruem93]. Periods of relative inactivity should allow for completion of time-noncritical requests. Our experimentation also suggests that changing disk scheduling algorithms to incorporate class information may require re-examining current process scheduling algorithms.
Reference: [McVo91] <author> L. McVoy, S. Kleiman, </author> <title> "Extent-like Performance from a UNIX File System", </title> <booktitle> Winter USENIX Proceedings, </booktitle> <year> 1991, </year> <pages> pp. 1-11. </pages>
Reference-contexts: Although we have found no previous work which specifically attempts to classify I/O requests as is done in this paper, previous researchers have noted differences between various I/O requests. Many have recognized that synchronous (time-critical) file system writes are undesirable [Oust90] <ref> [McVo91] </ref>. [Ruem93] recognizes the difference between synchronous (time-critical) and asynchronous (time-limited and time-noncritical) disk requests. They captured this information (as flagged by the file system) in their extensive traces of disk behavior.
Reference: [Mill91] <author> E. Miller, R. Katz, </author> <booktitle> "Input/Output Behavior of Supercomputing Applications", Proceedings of Supercomputing, </booktitle> <year> 1991, </year> <pages> pp. 567-576. </pages>
Reference-contexts: The enormous simulation times and instruction trace storage requirements, as well as the need for instruction level traces of operating system functionality, make this approach both time- and cost-prohibitive. Finally, <ref> [Mill91] </ref> makes use of a simple system-level model to study the effects of read-ahead and write buffering on supercomputer applications. Although we have found no previous work which specifically attempts to classify I/O requests as is done in this paper, previous researchers have noted differences between various I/O requests.
Reference: [Oust90] <author> J. Ousterhout, </author> <title> "Why Aren't Operating Systems Getting Faster As Fast as Hardware?", </title> <booktitle> Summer USENIX Proceedings, </booktitle> <year> 1990, </year> <month> pp.247-256. </month>
Reference-contexts: Although we have found no previous work which specifically attempts to classify I/O requests as is done in this paper, previous researchers have noted differences between various I/O requests. Many have recognized that synchronous (time-critical) file system writes are undesirable <ref> [Oust90] </ref> [McVo91]. [Ruem93] recognizes the difference between synchronous (time-critical) and asynchronous (time-limited and time-noncritical) disk requests. They captured this information (as flagged by the file system) in their extensive traces of disk behavior.
Reference: [Rich92] <author> K. Richardson, M. Flynn, </author> <title> "TIME: Tools for Input/Output and Memory Evaluation", </title> <booktitle> Proceedings of the Hawaii International Conference on Systems Sciences, </booktitle> <year> 1992, </year> <pages> pp. 58-66. </pages>
Reference-contexts: However, the end purpose for this technique is to measure system performance under various workloads rather than as input to a simulator to study various system design options. <ref> [Rich92] </ref> describes a set of tools under development which are intended to allow for studying I/O performance in much the same fashion as ours. The major difference is that they are basing their tools on instruction-level traces.
Reference: [Ruem93] <author> C. Ruemmler, J. Wilkes, </author> <title> "UNIX Disk Access Patterns", </title> <booktitle> Winter USENIX Proceedings, </booktitle> <year> 1993. </year>
Reference-contexts: Although we have found no previous work which specifically attempts to classify I/O requests as is done in this paper, previous researchers have noted differences between various I/O requests. Many have recognized that synchronous (time-critical) file system writes are undesirable [Oust90] [McVo91]. <ref> [Ruem93] </ref> recognizes the difference between synchronous (time-critical) and asynchronous (time-limited and time-noncritical) disk requests. They captured this information (as flagged by the file system) in their extensive traces of disk behavior. <p> As discussed in Section 3, the timed-out time-noncritical requests are not time-limited in our taxonomy. The timeouts are simply a design restriction for the I/O subsystem. In many environments, unlike our experimental environment, system activity is quite bursty in nature [McNu86] [Zhou88] [Baker91] <ref> [Ruem93] </ref>. We believe that periods of low activity will allow time-noncritical requests to be serviced in the background (i.e., without interfering with the completion of time-critical and time-limited requests). 7 Conclusions We have introduced a taxonomy of I/O requests, dividing them into three sets | time-critical, time-limited, and time-noncritical. <p> The use of timeouts can limit this starvation, but only at the cost of reducing the performance gains. Fortunately, in many environments the system activity is very bursty [McNu86] [Zhou88] [Baker91] <ref> [Ruem93] </ref>. Periods of relative inactivity should allow for completion of time-noncritical requests. Our experimentation also suggests that changing disk scheduling algorithms to incorporate class information may require re-examining current process scheduling algorithms.
Reference: [Seam69] <author> P. Seaman, R. Soucy, </author> <title> "Simulating Operating Systems", </title> <journal> IBM System Journal, </journal> <volume> No. 4, </volume> <year> 1969, </year> <pages> pp. 264-279. </pages>
Reference-contexts: Section 7 presents our conclusions and some areas for future work. 2 Previous Work As with many other topics in computer design, one finds discussions of system-level modeling in the archives of IBM. <ref> [Seam69] </ref> and [Chiu78], for example, describe such modeling efforts used mainly for examining various system configurations and evaluating proposed changes. Our process-flow model revisits this methodology and extends it. [Haig90] describes a system performance measurement technique which is very similar to our tra-cing methodology.
Reference: [Selt90] <author> M. Seltzer, P. Chen, J. Ousterhout, </author> <title> "Disk Scheduling Revisited", </title> <booktitle> Winter USENIX Proceedings, </booktitle> <year> 1990, </year> <pages> pp. 313-324. </pages>
Reference-contexts: They match the observed values of the system from which the traces were gathered. There have been many studies of alternative disk scheduling algorithms [Teor72] [Geis87] <ref> [Selt90] </ref> [Jaco91]. Most of them use request sorting to reduce seek times while incorporating some type of fairness algorithm. Some of the more recent work has added rotational position to the equation, targeting a reduction in total access time [Selt90] [Jaco91]. <p> have been many studies of alternative disk scheduling algorithms [Teor72] [Geis87] <ref> [Selt90] </ref> [Jaco91]. Most of them use request sorting to reduce seek times while incorporating some type of fairness algorithm. Some of the more recent work has added rotational position to the equation, targeting a reduction in total access time [Selt90] [Jaco91]. In all these cases, however, the work is limited by the fact that all requests are treated equally. As described in section 3, we have separated I/O requests into three distinct classes. <p> More workloads must be examined before drawing final conclusions about scheduling algorithms. Second, more disk scheduling algorithms must be considered. It has been noted that sorting based on both seek time and rotation time is often superior to sorting on seek time alone <ref> [Selt90] </ref> [Jaco91]. Also, we have not yet exploited the difference between time-critical requests and time-limited requests. Third, many state-of-the-art disk drives are equipped with request queues.
Reference: [Teor72] <author> T. Teorey, T. Pinkerton, </author> <title> "A Comparative Analysis of Disk Scheduling Policies", </title> <journal> Communications of the ACM, </journal> <month> March </month> <year> 1972, </year> <pages> pp. 177-184. </pages>
Reference-contexts: They match the observed values of the system from which the traces were gathered. There have been many studies of alternative disk scheduling algorithms <ref> [Teor72] </ref> [Geis87] [Selt90] [Jaco91]. Most of them use request sorting to reduce seek times while incorporating some type of fairness algorithm. Some of the more recent work has added rotational position to the equation, targeting a reduction in total access time [Selt90] [Jaco91].
Reference: [Zhou88] <author> S. Zhou, </author> <title> "A Trace-Driven Simulation Study of Dynamic Load Balancing", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Volume 14, No. 9, </volume> <month> September </month> <year> 1988, </year> <pages> pp. 1327-1341. </pages>
Reference-contexts: As discussed in Section 3, the timed-out time-noncritical requests are not time-limited in our taxonomy. The timeouts are simply a design restriction for the I/O subsystem. In many environments, unlike our experimental environment, system activity is quite bursty in nature [McNu86] <ref> [Zhou88] </ref> [Baker91] [Ruem93]. <p> The use of timeouts can limit this starvation, but only at the cost of reducing the performance gains. Fortunately, in many environments the system activity is very bursty [McNu86] <ref> [Zhou88] </ref> [Baker91] [Ruem93]. Periods of relative inactivity should allow for completion of time-noncritical requests. Our experimentation also suggests that changing disk scheduling algorithms to incorporate class information may require re-examining current process scheduling algorithms.
References-found: 21

