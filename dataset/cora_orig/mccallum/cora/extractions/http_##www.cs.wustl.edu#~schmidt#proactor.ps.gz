URL: http://www.cs.wustl.edu/~schmidt/proactor.ps.gz
Refering-URL: http://www.cs.wustl.edu/~irfan/resume/publications.html
Root-URL: 
Email: schmidtg@cs.wustl.edu ace@programmer.net 1  
Phone: (314) 935-7538 (414) 673-9813  
Title: Proactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handlers for Asynchronous Events systems provide
Author: Irfan Pyarali, Tim Harrison, and Douglas C. Schmidt Thomas D. Jordan firfan, harrison, 
Note: Modern operating  
Address: St. Louis 2 Hartford, WI 53027 St. Louis, MO 63130,  
Affiliation: Dept. of Computer Science SoftElegance Washington University,  
Abstract: This paper will appear at the 4 th annual Pattern Languages of Programming conference held in Allerton Park, Illinois, September, 1997. Permission is granted to make copies of this paper for the PLoP '97 conference proceedings. Abstract The Proactor pattern presented in this paper describes how to structure applications and systems that effectively utilize asynchronous mechanisms supported by operating systems. When an application invokes an asynchronous operation, the OS performs the operation on behalf of the application. This allows the application to have multiple operations running simultaneously without requiring the application to have a corresponding number of threads. Therefore, the Proactor pattern simplifies concurrent programming and improves performance by requiring fewer threads and leveraging OS support for asynchronous operations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Hu, I. Pyarali, and D. C. Schmidt, </author> <title> Measuring the Impact of Event Dispatching and Concurrency Models on Web Server Performance Over High-speed Networks, </title> <booktitle> in Proceedings of the 2 nd Global Internet Conference, IEEE, </booktitle> <month> November </month> <year> 1997. </year>
Reference-contexts: To illustrate this, consider networking applications that need to perform multiple operations concurrently. For example, a high-performance Web server must concurrently process HTTP requests sent from multiple clients <ref> [1] </ref>. Figure 1 shows a typical interaction between Web browsers and a Web server. When a user instructs a browser to open a URL, the browser sends an HTTP GET request to the Web server. <p> Completion Handlers can be written as if they existed in a conventional single-threaded environment. For instance, a Web server's HTTP GET Handler can access the disk through an Async Read operation (such as the Windows NT TransmitFile function <ref> [1] </ref>). 6.2 Drawbacks The Proactor pattern has the following drawbacks: Hard to debug: Applications written with the Proactor pattern can be hard to debug since the inverted flow of control oscillates between the framework infrastructure and the method callbacks on application-specific handlers.
Reference: [2] <author> J. C. </author> <title> Mogul, </title> <booktitle> The Case for Persistent-connection HTTP, in Proceedings of ACM SIGCOMM '95 Conference in Computer Communication Review, </booktitle> <address> (Boston, MA, USA), </address> <pages> pp. 299314, </pages> <publisher> ACM Press, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: must perform multiple client requests simultaneously; * Efficiency: The server must minimize latency, maximize throughput, and avoid utilizing the CPU (s) unnecessarily. * Programming simplicity: The design of the server should simplify the use of efficient concurrency strategies; * Adaptability: Integrating new or improved transport protocols (such as HTTP 1.1 <ref> [2] </ref>) should incur minimal maintenance costs. A Web server can be implemented using several concur-rency strategies, including multiple synchronous threads, reactive synchronous event dispatching, and proactive asynchronous event dispatching.
Reference: [3] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: * Increased synchronization complexity: Threading can increase the complexity of synchronization mechanisms necessary to serialize access to a server's shared resources (such as cached files and logging of Web page hits); 2 * Increased performance overhead: Threading can perform poorly due to context switching, synchronization, and data movement among CPUs <ref> [3] </ref>; * Non-portability: Threading may not be available on all OS platforms. Moreover, OS platforms differ widely in terms of their support for pre-emptive and non-preemptive threads. Consequently, it is hard to build multi-threaded servers that behave uniformly across OS platforms. <p> For instance, all Completion Handlers are required to act as Proactive Initiators instead of executing synchronous operations. 8 Sample Code This section shows how to use the Proactor pattern to develop a Web server. The example is based on the Proactor pattern implementation in the ACE framework <ref> [3] </ref>. When a client connects to the Web server, the HTTP Handler's open method is called. <p> The operating system is the Asynchronous Operation Processor. Results of the operations are queued up at the I/O completion port (which plays the role of the Completion Dispatcher). ACE Proactor: The Adaptive Communications Environ ment (ACE) <ref> [3] </ref> implements a Proactor component that en capsulates I/O Completion Ports on Windows NT. The ACE Proactor abstraction provides an OO interface to the stan dard C APIs supported by Windows NT. The source code for this implementation can be acquired from the ACE website at www.cs.wustl.edu/~schmidt/ACE.html.
Reference: [4] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The Reactor pattern <ref> [4] </ref> describes how applications can register Event Handlers with an Initiation Dispatcher. The Initiation Dispatcher notifies the Event Handler when it is possible to initiate an operation without blocking. <p> Dispatcher techniques described above, consider the possible combinations of OS environments and physical hardware shown in Table 1. 9 Threading model System Type Single-processor Multi-processor Single-threaded A B Multi-threaded C D Table 1: Completion Dispatcher Concurrency Strategies If your OS only supports synchronous I/O, then refer to the Reactor pattern <ref> [4] </ref>. However, most modern operating systems support some form of asynchronous I/O. In combination A and B from Table 1, the Post-reactive approach to asynchronous I/O is probably the best, assuming you are not waiting on any semaphores or mutexes. If you are, a Call-through implementation may be more responsive. <p> In general, the Proactor pattern is used to asynchronously demultiplex multiple sources of input to their associated event handlers, whereas an Observer is usually associated with only a single source of events. The Proactor pattern can be considered an asynchronous variant of the synchronous Reactor pattern <ref> [4] </ref>. The Reactor pattern is responsible for demultiplexing and dispatching of multiple event handlers that are triggered when it is possible to initiate an operation synchronously without blocking. In contrast, the Proactor supports the demultiplexing and dispatching of multiple event handlers that are triggered by the completion of asynchronous events.
Reference: [5] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: A single-threaded concurrent Web server can use a reactive event dispatching model that waits in an event loop for a Reactor to notify it to initiate appropriate operations. An example of a reactive operation in the Web server is the registration of an Acceptor <ref> [5] </ref> with the Initiation Dispatcher. When data arrives on the network connection, the dispatcher calls back the Acceptor. The Acceptor accepts the network connection and creates an HTTP Handler.
Reference: [6] <author> M. K. McKusick, K. Bostic, M. J. Karels, and J. S. Quarter-man, </author> <title> The Design and Implementation of the 4.4BSD Operating System. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: following drawbacks: * Complex programming: As seen from the list above, programmers must write complicated logic to make sure that the server does not block while servicing a particular client. * Lack of OS support for multi-threading: Most operating systems implement the reactive dispatching model through the select system call <ref> [6] </ref>. However, select does not allow more than one thread to wait in the event loop on the same descriptor set.
Reference: [7] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Asynchronous Completion Token: an Object Behavioral Pattern for Efficient Asynchronous Event Handling, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: Moreover, the Proactor pattern can be difficult to debug since asynchronous operations are often nondeterministic. Section 7 describes how to apply other patterns (such as the Asynchronous Completion Token <ref> [7] </ref>) to simplify the asynchronous application programming model. 3 Applicability Use the Proactor pattern when one or more of the following conditions hold: * An application needs to perform one or more asynchronous operations without blocking the calling thread; * The application must be notified when asynchronous operations complete; * The <p> There is no implicit limitation that prevents Proactive Initiators from assigning multiple Asynchronous Operation requests to a single Completion Handler. As a result, the Completion Handler must tie request-specific state information throughout the chain of completion notifications. To do this, Completion Handlers can utilize the Asynchronous Completion Token pattern <ref> [7] </ref>. 7.3.2 Resource Management As with any multi-threaded environment, the Proactor pattern does not alleviate Completion Handlers from ensuring that access to shared resources is thread-safe. However, a Completion Handler must not hold onto a shared resource across multiple completion notifications. <p> Natural instantiations of the Proactor pattern exists in most systems that employ asynchronous interaction across their system boundaries. In many of these systems, the system's actors are Proactive Initiators and the system's use-case scenarios are Asynchronous Operations. 10 Related Patterns The Asynchronous Completion Token (ACT) pattern <ref> [7] </ref> is generally used in conjunction with the Proactor pattern. When Asynchronous Operations complete, applications may need more information than simply the notification itself to properly handle the event. The Asynchronous Completion Token pattern allows applications to efficiently associate state with the completion of Asynchronous Operations.
Reference: [8] <institution> Information Technology Portable Operating System Interface (POSIX) Part 1: System Application: Program Interface (API) [C Lanaguage], </institution> <year> 1995. </year>
Reference-contexts: These system calls detect and report the events that may occur simultaneously on multiple event sources. Event sources may include I/O ports, timers, synchronization objects, signals, etc. On real-time POSIX platforms, the asynchronous I/O functions are provided by the aio family of APIs <ref> [8] </ref>. In Windows NT, I/O completion ports and overlapped I/O are used to implement asynchronous I/O [9]. <p> The source code for this implementation can be acquired from the ACE website at www.cs.wustl.edu/~schmidt/ACE.html. The UNIX AIO Family of Asynchronous I/O Operations: On some real-time POSIX platforms, the Proactor pattern is implemented by the aio family of APIs <ref> [8] </ref>. These OS features are very similar to the ones described above for Windows NT. One difference is that UNIX signals can be used to implement an truly asynchronous Completion Dispatcher (the Windows NT API is not truly asyn chronous).
Reference: [9] <institution> Microsoft Developers Studio, Version 4.2 Software Development Kit, </institution> <year> 1996. </year>
Reference-contexts: Event sources may include I/O ports, timers, synchronization objects, signals, etc. On real-time POSIX platforms, the asynchronous I/O functions are provided by the aio family of APIs [8]. In Windows NT, I/O completion ports and overlapped I/O are used to implement asynchronous I/O <ref> [9] </ref>. The Completion Dispatcher encapsulates the con-currency mechanism: A benefit of decoupling the Completion Dispatcher from the Asynchronous Operation Processor is that applications can configure Completion Dispatchers with various concur-rency strategies without affecting other participants.
Reference: [10] <author> E. W. Dijkstra, </author> <title> Hierarchical Ordering of Sequential Processes, </title> <journal> Acta Informatica, </journal> <volume> vol. 1, no. 2, </volume> <pages> pp. 115138, </pages> <year> 1971. </year>
Reference-contexts: However, a Completion Handler must not hold onto a shared resource across multiple completion notifications. If it does, it risks invoking the dining philosopher's problem <ref> [10] </ref>. This problem is the deadlock that results when a logical thread of control waits forever for a semaphore to become signaled. This is illustrated by imagining a dinner party attended by a group of philosophers.
Reference: [11] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: When Asynchronous Operations complete, applications may need more information than simply the notification itself to properly handle the event. The Asynchronous Completion Token pattern allows applications to efficiently associate state with the completion of Asynchronous Operations. The Proactor pattern is related to the Observer pattern <ref> [11] </ref> (where dependents are updated automatically when a single subject changes). In the Proactor pattern, handlers are informed automatically when events from multiple sources occur. <p> That is, both patterns can be used to implement Asynchronous Operations. The Proactor pattern is often used in place of the Active Object pattern to decouple the systems concurrency policy from the threading model. A Proactor may be implemented as a Singleton <ref> [11] </ref>. This is useful for centralizing event demultiplexing and completion dispatching into a single location within an asynchronous application. The Chain of Responsibility (COR) pattern [11] decouples event handlers from event sources. The Proactor pattern is similar in its segregation of Proactive Initiators and Completion Handlers. <p> A Proactor may be implemented as a Singleton <ref> [11] </ref>. This is useful for centralizing event demultiplexing and completion dispatching into a single location within an asynchronous application. The Chain of Responsibility (COR) pattern [11] decouples event handlers from event sources. The Proactor pattern is similar in its segregation of Proactive Initiators and Completion Handlers. However, in COR, the event source has no prior knowledge of which handler will be executed, if any. In Proactor, Proactive Initiators have full disclosure of the target handler.
Reference: [12] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, </title> <booktitle> in Proceed ings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 17, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: In contrast, the Proactor supports the demultiplexing and dispatching of multiple event handlers that are triggered by the completion of asynchronous events. The Active Object pattern <ref> [12] </ref> decouples method execution from method invocation. The Proactor pattern is similar because Asynchronous Operation Processors perform operations on behalf of application Proactive Initiators. That is, both patterns can be used to implement Asynchronous Operations.
References-found: 12

