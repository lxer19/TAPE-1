URL: http://www.arlut.utexas.edu/~lanceo/cikm97.ps
Refering-URL: 
Root-URL: 
Email: lanceo@arlut.utexas.edu  miranker@cs.utexas.edu  
Title: Evaluating Triggers Using Decision Trees  
Author: Lance Obermeyer Daniel P. Miranker 
Address: Austin  Austin  
Affiliation: Applied Research Laboratories The University of Texas at  Department of Computer Sciences The University of Texas at  
Abstract: This paper presents an algorithm for implementing rule filtering in active and trigger enabled databases. The algorithm generates one or more decision trees that determine what rules or triggers might be enabled by an individual database element, reducing the number of rules or triggers that must be evaluated. The algorithm operates by symbolically representing the space of database elements and subdividing the space based on rule predicates. Regions of the state space represent particular combinations of enabled rules. Decision trees are then generated based on the subdivided state space. The trees have the important property that no individual test is repeated. The ordered binary decision diagram (BDD) data structure is used to represent and manipulate the state space.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. Blakeley, N. Coburn, and P.-A. Larson, </author> <title> "Updating derived relations: detecting irrelevant and autonomously computable updates," </title> <journal> ACM Transactions on Database Systems, </journal> <volume> vol. 14, no. 3, </volume> <month> September, </month> <pages> pp. 369-400, </pages> <year> 1989. </year>
Reference-contexts: Their methodology is discussed in section 2.2. Blakeley, Coburn, and Larson report on the somewhat related problem of detecting updates to base relations that are irrelevant to materialized views <ref> [1] </ref>. Their work is based on determining the relationship between many elements and one rule (view definition), whereas the trigger filtering problem determines the relationship between one element and many rules. In the degenerate case of one element and one rule, the two are essentially the same.
Reference: 2. <author> D. Brant, T. Grose, B. Lofaso, and D. P. Miranker, </author> <title> "Effects of database size on rule system performance: Five case studies," </title> <booktitle> in Proceedings of the 17th International Conference on Very Large Data Bases. </booktitle> <address> Barcelona, Spain, </address> <month> September, </month> <year> 1991, </year> <pages> pp. 287-296. </pages>
Reference-contexts: Two reasonable values were chosen for each parameter, for a total of eight separate trials. The actual workload consisted of classifications from four expert system programs from the Texas Benchmark Suite, a suite of rule programs from the expert system community <ref> [2] </ref>. 4.1 Test count The total number of tests in a tree is a size measure. The desired result is a test count that approaches that of naive. Decision trees were generated using the nave and decision tree approaches for different compositions of rules.
Reference: 3. <author> R. E. Bryant, </author> <title> "Symbolic boolean manipulation with ordered binary-decision diagrams," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 24, no. 3, </volume> <month> September, </month> <pages> pp. 293-318, </pages> <year> 1992. </year>
Reference-contexts: Section 2 presents three methods for solving the trigger filtering problem. The third method is using decision trees, which is the focus of this paper. Section 3 presents an algorithm to generate decision trees using an algorithm based on binary decision diagrams (BDDs) <ref> [3] </ref>. Section 4 presents an empirical evaluation of the decision Many active databases, especially those adopting a C based rule syntax, allow calling functions in the condition portion of a rule. These functions must be side effect free, and be strict functions on the input tuple. <p> f.cf If c1.cf is satisfiable Insert c1 into C If c2.cf is satisfiable Insert c2 into C Set t to t c1.cf Insert [f.id, f.cf t] into C Return classification list C The above algorithm can be implemented quite easily by employing the Ordered Binary Decision Diagram (BDD) data structure <ref> [3] </ref>. BDDs are useful for representing functions over binary variables. For this application, filtering predicates are viewed as atomic variables, and filtering expressions are BDD functions over the variables. <p> It must be noted that for certain classes of functions BDDs behave very badly, with a worst case exponential size bound with respect to the number of variables <ref> [3] </ref>. While we have not experienced any BDD blowup in practice, further work is required to accurately determine the likelihood of BDD blowup.
Reference: 4. <author> A. Buchmann, J. Zimmermann, J. Blakeley, and D. Wells, </author> <title> "Building an integrated active OODBMS: Requirements, architecture, and design decisions," </title> <booktitle> in Proceedings of the 11th International Conference on Data Engineering. </booktitle> <address> Taipeh, Taiwan, </address> <month> March, </month> <year> 1995, </year> <pages> pp. 117-128. </pages>
Reference-contexts: These functions must be side effect free, and be strict functions on the input tuple. Example systems include VenusDB [15], SAMOS [10], and Reach <ref> [4] </ref>. tree technique. Section 5 lists three areas of future work. Section 6 provides concluding remarks. The remainder of the paper uses relational terminology. However, the technique presented is applicable to filtering insert, update and remove events in object oriented databases as well.
Reference: 5. <author> O. P. Buneman and E. K. Clemons, </author> <title> "Efficiently monitoring relational databases," </title> <journal> ACM Transactions on Database Systems, </journal> <volume> vol. 4, no. 3, </volume> <month> September, </month> <pages> pp. 368-382, 199. </pages>
Reference-contexts: Their technique first removes readily ignorable updates, then, for remaining updates, evaluates complete trigger expressions over restricted size data sets. Join predicates are evaluated, but relative to small size relations <ref> [5] </ref>. Cohen [8] describes a method of compiling trigger conditions into a match network similar to RETE [9]. This work is focuses on evaluating the complete trigger expression, not filtering out unsatisfiable triggers.
Reference: 6. <author> Buneman. O. P. and E. K. clemons, </author> <title> "Efficiently monitoring relational databases," </title> <journal> ACM Transactions on Database Systems, </journal> <volume> vol. 4, no. 3, </volume> <month> September, </month> <pages> pp. 368-382, </pages> <year> 1979. </year>
Reference-contexts: If a rule is not sensitive to events on the updated relation, then evaluation of the condition of the rule can be skipped. An update that can be ignored based on purely schematic information has been termed a readily ignorable update <ref> [6] </ref>. The second level is data dependent, and consists of comparing the triggering tuple to the constant test predicates in the rules condition. For example, figure 1 shows a schema and three rules in SQL3 style syntax from a hypothetical finance application.
Reference: 7. <author> E. Cerny and M. A. Marin, </author> <title> "An approach to unified methodology of combinational switching circuits," </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. 8, </volume> <month> August, </month> <pages> pp. 45-756, </pages> <year> 1977. </year>
Reference-contexts: Thus L defines a possibly empty set of filtering expressions. a characteristic function for a label L, denoted cf (L), is a Boolean valued function on a state s S such that cf (L)(s) = true "f L [f (s) = true] <ref> [7] </ref>. Intuitively, cf (L) defines a subset of the state space S where every element s satisfies all of the filtering expressions in L. a classification is a [label, characteristic function] pair. Rather than enumerating the individual states for a label, we instead provide the characteristic function.
Reference: 8. <author> D. Cohen, </author> <title> "Compiling complex database transition triggers," </title> <booktitle> in Proceedings of the 1989 ACM SIGMOD International Conference on the Management of Data. </booktitle> <address> Portland, OR, </address> <month> May, </month> <year> 1989, </year> <pages> pp. 225-234. </pages>
Reference-contexts: Their technique first removes readily ignorable updates, then, for remaining updates, evaluates complete trigger expressions over restricted size data sets. Join predicates are evaluated, but relative to small size relations [5]. Cohen <ref> [8] </ref> describes a method of compiling trigger conditions into a match network similar to RETE [9]. This work is focuses on evaluating the complete trigger expression, not filtering out unsatisfiable triggers.
Reference: 9. <author> C. Forgy, </author> <title> "RETE: A fast match algorithm for the many pattern/many object pattern match problem," </title> <journal> Artificial Intelligence, </journal> <volume> vol. 19, </volume> <pages> pp. 17-37, </pages> <year> 1982. </year>
Reference-contexts: We term the process of comparing a triggering tuple to the constant test predicates of a rule condition for the purpose of eliminating some rules from consideration trigger filtering. Researchers in the expert system community have long used trigger filtering to speed up system execution. For example, the RETE <ref> [9] </ref> and TREAT [14] match algorithms use trigger filtering techniques to generate the elements in alpha memories (a form of specialized predicate index). Formally, we define a program as consisting of a set of rules. <p> Their technique first removes readily ignorable updates, then, for remaining updates, evaluates complete trigger expressions over restricted size data sets. Join predicates are evaluated, but relative to small size relations [5]. Cohen [8] describes a method of compiling trigger conditions into a match network similar to RETE <ref> [9] </ref>. This work is focuses on evaluating the complete trigger expression, not filtering out unsatisfiable triggers. Similarly, the large bodies of work on production system match algorithms and database integrity constraints primarily focus on improving join performance.
Reference: 10. <author> A. Geppert, S. Gatziu, K. R. Dittrich, H. Fritschi, and A. Vaduva, </author> <title> Architecture and implementation of the active object-oriented database management system SAMOS, </title> <type> TR 95.29. </type> <institution> Institut fur Informatik, Universitat Zurich, Switzerland, </institution> <year> 1995. </year>
Reference-contexts: These functions must be side effect free, and be strict functions on the input tuple. Example systems include VenusDB [15], SAMOS <ref> [10] </ref>, and Reach [4]. tree technique. Section 5 lists three areas of future work. Section 6 provides concluding remarks. The remainder of the paper uses relational terminology. However, the technique presented is applicable to filtering insert, update and remove events in object oriented databases as well.
Reference: 11. <author> E. Hanson and T. Johnson, </author> <title> "Selection predicate indexing for active databases using inteval skip lists," </title> <journal> Information Systems, </journal> <volume> vol. 21, no. 3, </volume> <pages> pp. 269-298, </pages> <year> 1996. </year>
Reference-contexts: The only published work known to the authors on the trigger filtering problem is by Hanson and Johnson, who report on a technique for solving the trigger filtering problem <ref> [11] </ref>. Their methodology is discussed in section 2.2. Blakeley, Coburn, and Larson report on the somewhat related problem of detecting updates to base relations that are irrelevant to materialized views [1]. <p> The minimum number of tests is the number of filtering expressions. 2.2 Interval Skip List An alternative method is proposed by Hanson and Johnson <ref> [11] </ref>. They propose a technique relying on intervals. For each filtering expression, an interval over an attribute is selected. Intervals can be bounded (0 &lt; n.value &lt; 1) or unbounded (n.value &lt; 1). An equality test is treated as an interval of width 0.
Reference: 12. <author> L. Hyafil and R. L. Rivest, </author> <title> "Constructing optimal binary decision trees is NP-complete," </title> <journal> Information Processing Letters, </journal> <volume> vol. 5, no. 1, </volume> <year> 1976. </year>
Reference-contexts: In this tree, the maximum number of tests is five, two tests less than the amount in figure 3. Similarly, the minimum number of tests is two (FP0 FP3), whereas the minimum in figure 3 is three. Generating optimal decision trees is a known NP-complete problem <ref> [12] </ref>. Therefore, a heuristic method must be used to generate the tree. This method is presented in the next section. 3. Algorithm Assume the set of filtering expressions is E, with each element e containing some subset of the set P of filtering predicates. <p> Given that optimal binary tree generation is a known NP-complete problem <ref> [12] </ref>, the method will necessarily be heuristic. This phase is modeled after decision tree generation in ID3, a machine learning algorithm for classifying items based on features [18]. Like ID3, this algorithm depends upon a heuristic to select the feature to test at each level.
Reference: 13. <author> D. R. McCarthy and U. Dayal, </author> <title> "The architecture of an active database management system," </title> <booktitle> in Proceedings of the 1989 ACM SIGMOD International Conference on the Management of Data. </booktitle> <address> Portland, OR, </address> <month> May, </month> <year> 1989, </year> <pages> pp. 215-224. </pages>
Reference-contexts: 1. Introduction Modern database systems increasingly support active behavior through rules. This support ranges from simple database triggers to complete active database functionality. Rules typically follow the event condition action (ECA) model originally proposed in Hipac <ref> [13] </ref>. This rule model specifies the particular event or set of events a rule will respond to, the condition that must be true for the rule to proceed, and the action to execute if the condition is satisfied. <p> Active database rarely restrict the number of rules per table. This provides developers with the freedom to create multiple rules per table if they wish. The cost of this added freedom is in execution time. Depending upon the coupling mode <ref> [13] </ref> of the rule, rule evaluation happens within the critical path of either the triggering DML command or the enclosing transaction commit. It is therefore imperative that rule processing be as efficient as possible. One obvious technique for speeding up rule processing is to avoid evaluating rules that cannot execute.
Reference: 14. <author> D. P. Miranker, </author> <title> TREAT: A new and efficient match algorithm for AI production systems. </title> <address> Los Altos, CA: </address> <publisher> Pittman/Morgan-Kaufman Publishers, </publisher> <year> 1989. </year>
Reference-contexts: Researchers in the expert system community have long used trigger filtering to speed up system execution. For example, the RETE [9] and TREAT <ref> [14] </ref> match algorithms use trigger filtering techniques to generate the elements in alpha memories (a form of specialized predicate index). Formally, we define a program as consisting of a set of rules.
Reference: 15. <author> D. P. Miranker and L. Obermeyer, </author> <title> "An overview of the VenusDB active multidatabase system," </title> <booktitle> International Symposium on Cooperative Database Systems for Advanced Applications. </booktitle> <address> Kyoto, Japan, </address> <month> December, </month> <year> 1996. </year>
Reference-contexts: Section 4 presents an empirical evaluation of the decision Many active databases, especially those adopting a C based rule syntax, allow calling functions in the condition portion of a rule. These functions must be side effect free, and be strict functions on the input tuple. Example systems include VenusDB <ref> [15] </ref>, SAMOS [10], and Reach [4]. tree technique. Section 5 lists three areas of future work. Section 6 provides concluding remarks. The remainder of the paper uses relational terminology. However, the technique presented is applicable to filtering insert, update and remove events in object oriented databases as well.
Reference: 16. <author> S. Nishiyama, </author> <title> "Optimizing compilation of select phase of production systems," </title> <type> Master's thesis. </type> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <year> 1991. </year>
Reference-contexts: Acknowledgements The idea of subdividing the state space into classifications is due to an unpublished paper by Satoshi Nishiyama, Keith Goolsbey, and Daniel P. Miranker. A partial implementation is describe in <ref> [16] </ref>.
Reference: 17. <author> Oracle Corporation, </author> <note> Oracle 7 users guide1992. </note>
Reference-contexts: For example, Oracle version 7 allows one trigger per table per event (insert, delete, update) per situation (before row, before statement, after row, after statement) for a total of 12 triggers per table <ref> [17] </ref>. However, no more than one trigger is active at any one time. One area where active databases have an advantage over simple trigger systems is in supporting multiple rules per table. Active database rarely restrict the number of rules per table.
Reference: 18. <author> J. R. Quinlan, </author> <title> "Induction of decision trees," </title> <journal> Machine Learning, </journal> <volume> vol. 1, </volume> <pages> pp. 81-106. </pages>
Reference-contexts: Given that optimal binary tree generation is a known NP-complete problem [12], the method will necessarily be heuristic. This phase is modeled after decision tree generation in ID3, a machine learning algorithm for classifying items based on features <ref> [18] </ref>. Like ID3, this algorithm depends upon a heuristic to select the feature to test at each level. The heuristic used here is similar to the ID3 information gain heuristic. <p> Note that this all occurs at compile time, not runtime. A heuristic is involved with choosing the filtering predicate to test at a point. The heuristic is modeled after the ID3 information gain heuristic <ref> [18] </ref>. If a particular filtering predicate is required by every characteristic function in a set of classifications, then that predicate is chosen. If no required predicate exists, then the predicate that splits the fewest number of classifications is chosen.
References-found: 18

