URL: http://www.cs.toronto.edu/~ftp/pub/reports/na/SciTools.98.ps.Z
Refering-URL: http://www.cs.toronto.edu/NA/reports.html
Root-URL: http://www.cs.toronto.edu
Title: Software Issues in Validated ODE Solving key application of interval methods is to compute rigorous
Author: N. S. Nedialkov K. R. Jackson 
Note: This is page 1 Printer: Opaque this  1.1 Introduction A  
Abstract: Validated methods for initial value problems (IVPs) for ordinary differential equations (ODEs) produce bounds that are guaranteed to contain the true solution of a problem. In this chapter, we briefly survey validated methods for IVPs for ODEs, discuss software issues related to the implementation of a validated ODE solver, and describe the structure of a package for computing rigorous bounds on the solution of an IVP for an ODE. Standard numerical methods usually compute numerical approximations that satisfy a user-specified tolerance. These methods are robust and reliable for most applications, but it is possible to find examples for which they return very inaccurate results. However, there are situations when guaranteed bounds on the mathematically correct result are desired or needed. For example, such bounds can be used to prove a theorem [SA93]. Also, some calculations may be critical to the safety or reliability of a system. Therefore, it may be necessary to ensure that the true result is within computed bounds. Furthermore, methods that produce guaranteed bounds may be used to check a sample calculation to be performed by a standard floating-point scheme, to give the user an indication of the accuracy and reliability of the floating-point scheme. Validated (also called interval) methods produce bounds that are guaranteed to contain a mathematically correct result. These methods use interval arithmetic [Moo66] to enclose rounding errors, truncation errors, and possibly even uncertainties in the model, assuming these can be quantified. 
Abstract-found: 1
Intro-found: 1
Reference: [AH83] <author> G. Alefeld and J. Herzberger. </author> <title> Introduction to Interval Computations. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: One reason for obtaining different values for f ([a]) is that the distributive law does not hold in general in interval arithmetic <ref> [AH83, pp. 3-5] </ref>. However, for any three intervals [a], [b], and [c], the subdistributive law [a] ([b] + [c]) [a] [b] + [a] [c] ; does hold. This implies that if we rearrange an interval expression, we may obtain tighter bounds.
Reference: [Ber97] <author> Martin Berz. </author> <title> COSY INFINITY version 8 reference manual. </title> <type> Technical Report MSUCL-1088, </type> <institution> National Superconduct-ing Cyclotron Lab., Michigan State University, East Lansing, Mich., </institution> <year> 1997. </year> <note> COSY INFINITY is available at http://www.beamtheory.nscl.msu.edu/cosy/. </note>
Reference-contexts: Currently, there are three available packages for computing guaranteed bounds on the solution of an IVP for an ODE: AWA [Loh88], ADIODES [Sta97] and COSY INFINITY <ref> [Ber97] </ref>. We briefly summarize each in turn. 1. Software Issues in Validated ODE Solving 13 AWA is an implementation of Lohner's method (x1.4.4) and the constant enclosure method (x1.4.3) for validating existence and uniqueness of the solution.
Reference: [BGMS97] <author> S. Balay, W. D. Gropp, L. C. McInnes, and B. F. Smith. </author> <title> Parallelism in object-oriented numerical software libraries. In Erlend Arge, Are Magnus Bruaset, </title> <editor> and Hans Petter Lang-tangen, editors, </editor> <booktitle> Modern Software Tools in Scientific Computing, </booktitle> <pages> pages 163-202. </pages> <publisher> Birkhauser, </publisher> <address> Boston, </address> <year> 1997. </year> <note> See also http://www.mcs.anl.gov/petsc/. </note>
Reference-contexts: Procedural languages like C or Fortran 77 can be used to implement an object-oriented design <ref> [BGMS97] </ref>. However, using a language that supports object-oriented programming usually reduces the effort for implementing object-oriented software.
Reference: [BM98] <author> M. Berz and K. Makino. </author> <title> Verified integration of ODEs and flows using differential algebraic methods on high-order Taylor models. </title> <booktitle> Reliable Computing, </booktitle> <volume> 4 </volume> <pages> 361-369, </pages> <year> 1998. </year>
Reference-contexts: (t j ; t 0 ; [y 0 ]) [y j ] ; for j = 1; 2; : : : ; m: 1.4 An Overview of Validated Methods for IVPs for ODEs Most validated methods for IVPs for ODEs are based on Taylor series [Moo66], [Kru69], [Eij81], [Loh88], [Rih94], <ref> [BM98] </ref>. The Taylor series approach has been popular because of the simple form of the error term, which can be readily bounded using interval arithmetic. <p> COSY INFINITY is a Fortran-based code to study and to design beam physics systems. The method for verified integration of ODEs uses high-order Taylor polynomials with respect to time and the initial conditions. The wrapping effect is reduced by establishing functional dependency between initial and final conditions (see <ref> [BM98] </ref>). For that purpose, the computations are carried out with Taylor polynomials with real floating-point coefficients and a guaranteed error bound for the remainder term. Thus, the arithmetic operations and standard functions are executed with such Tay-lor polynomials as operands. Although the approach described in [BM98] reduces the wrapping effect substantially, <p> initial and final conditions (see <ref> [BM98] </ref>). For that purpose, the computations are carried out with Taylor polynomials with real floating-point coefficients and a guaranteed error bound for the remainder term. Thus, the arithmetic operations and standard functions are executed with such Tay-lor polynomials as operands. Although the approach described in [BM98] reduces the wrapping effect substantially, working with polynomials is significantly more expensive than working with intervals. 1.7 Object-Oriented Concepts We have chosen an object-oriented approach in designing VNODE and C++ [ES90] to implement it. This is not the first object-oriented design of an ODE solver.
Reference: [Boo94] <author> Grady Booch. </author> <title> Object-Oriented Analysis and Design. </title> <publisher> The Ben-jamin/Cummings Publishing Company Inc., Rational, </publisher> <address> Santa Clara, California, 2nd edition, </address> <year> 1994. </year>
Reference-contexts: We use them in the discussion of the choice of programming language (x1.8) and in the description of VNODE (x1.9). A reader familiar with object-oriented terms can skip this section (x1.7). A good discussion of object-oriented concepts, analysis, and design can be found in <ref> [Boo94] </ref>. An excellent book on advanced C++ styles and idioms is [Cop92]. A study of nonprocedural paradigms for numerical analysis, including object-oriented ones, is presented in [SZ95].
Reference: [BS96] <author> Claus Bendsten and Ole Stauning. FADBAD, </author> <title> a flexible C++ package for automatic differentiation using the forward and backward methods. </title> <type> Technical Report 1996-x5-94, </type> <institution> Department of Mathematical Modelling, Technical University of Denmark, DK-2800, Lyngby, Denmark, </institution> <month> August </month> <year> 1996. </year> <note> FADBAD is available at http://www.imm.dtu.dk/fadbad.html. 1. Software Issues in Validated ODE Solving 27 </note>
Reference-contexts: j f [i] (^y j ) + [z j+1 ] + [S j ]([y j ] ^y j ): (1.18) The ith Jacobian (i = 1; : : : ; k1) in (1.17) can be computed by generating the Taylor coefficient f [i] ([y j ]) and then differentiating it <ref> [BS96] </ref>, [BS97]. Alternatively, these Jacobians can be computed by generating Taylor coefficients for the associated variational equation [Loh88]. If we compute enclosures with (1.18), the widths of the computed intervals may decrease. <p> These are the FADBAD/TADIFF <ref> [BS96] </ref>, [BS97] and IADOL-C [Iwa97] packages. They are written in C++ and implement AD through operator overloading. TADIFF and FADBAD are two different packages. TADIFF can generate Taylor coefficients with respect to time.
Reference: [BS97] <author> Claus Bendsten and Ole Stauning. TADIFF, </author> <title> a flexible C++ package for automatic differentiation using Taylor series. </title> <type> Technical Report 1997-x5-94, </type> <institution> Department of Mathematical Mod-elling, Technical University of Denmark, DK-2800, Lyngby, Denmark, </institution> <month> April </month> <year> 1997. </year> <note> TADIFF is available at http://www.imm.dtu.dk/fadbad.html. </note>
Reference-contexts: f [i] (^y j ) + [z j+1 ] + [S j ]([y j ] ^y j ): (1.18) The ith Jacobian (i = 1; : : : ; k1) in (1.17) can be computed by generating the Taylor coefficient f [i] ([y j ]) and then differentiating it [BS96], <ref> [BS97] </ref>. Alternatively, these Jacobians can be computed by generating Taylor coefficients for the associated variational equation [Loh88]. If we compute enclosures with (1.18), the widths of the computed intervals may decrease. <p> These are the FADBAD/TADIFF [BS96], <ref> [BS97] </ref> and IADOL-C [Iwa97] packages. They are written in C++ and implement AD through operator overloading. TADIFF and FADBAD are two different packages. TADIFF can generate Taylor coefficients with respect to time.
Reference: [Cop92] <author> James O. Coplien. </author> <title> Advanced C++ Programming Styles and Idioms. </title> <type> Addison-Wesley, </type> <institution> AT&T Bell Laboratories, </institution> <year> 1992. </year>
Reference-contexts: A reader familiar with object-oriented terms can skip this section (x1.7). A good discussion of object-oriented concepts, analysis, and design can be found in [Boo94]. An excellent book on advanced C++ styles and idioms is <ref> [Cop92] </ref>. A study of nonprocedural paradigms for numerical analysis, including object-oriented ones, is presented in [SZ95]. Data Abstraction In the object model, a software system can be viewed as a collection of objects that interact with each other to achieve a desired functionality.
Reference: [CR87] <author> George F. Corliss and Louis B. Rall. </author> <title> Adaptive, self-validating quadrature. </title> <journal> SIAM J. Sci. Stat. Comput., </journal> <volume> 8(5) </volume> <pages> 831-847, </pages> <year> 1987. </year>
Reference-contexts: For example, as explained below, we can enclose the truncation error of a Taylor series expansion by generating Taylor coefficients in interval arithmetic. Such enclosures can be used to compute guaranteed bounds either for an integral <ref> [CR87] </ref> or for an initial value problem (IVP) for an ordinary differential equation (ODE) (see [NJC99] for a survey). An extensive summary of applications of and resources for interval computations can be found in [Kea96a]. Interval methods have not been popular in the past for several reasons.
Reference: [CR96] <author> G. F. Corliss and R. Rihm. </author> <title> Validating an a priori enclosure using high-order Taylor series. </title> <editor> In G. Alefeld and A. From-mer, editors, </editor> <booktitle> Scientific Computing, Computer Arithmetic, and Validated Numerics, </booktitle> <pages> pages 228-238. </pages> <publisher> Akademie Verlag, </publisher> <address> Berlin, </address> <year> 1996. </year>
Reference-contexts: Usually, Algorithm II allows larger stepsizes, but they are nearly always limited by Algorithm I. One can obtain methods that enable larger stepsizes by using polynomial enclosures [Loh95] or more Taylor series terms in the sum in (1.13), thus obtaining a Taylor series enclosure method [Moo66, pp. 100-103], <ref> [CR96] </ref>, [Ned99]. 8 N. S. Nedialkov, K. R.
Reference: [DNS97] <author> Viktor K. Decyk, Charles D. Norton, and Boleslaw K. Szyman-ski. </author> <title> Expressing object-oriented concepts in Fortran 90. </title> <journal> ACM Fortran Forum, </journal> <volume> 16(1) </volume> <pages> 13-18, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: The features of C++ (e.g., data abstraction, operator overloading, inheritance, and polymorphism) allow the goals in x1.5 to be achieved in a relatively simple way. Inheritance and polymorphism can be simulated in Fortran 90 <ref> [DNS97] </ref>, but this is cumbersome. 1.8.4 Efficiency Compared to Fortran, C++ has been criticized for its poor performance for scientific computing. Here, we discuss an important performance problem: 1.
Reference: [Eij81] <author> P. Eijgenraam. </author> <title> The Solution of Initial Value Problems Using Interval Arithmetic. </title> <publisher> Mathematical Centre Tracts No. 144. Stichting Mathematisch Centrum, </publisher> <address> Amsterdam, </address> <year> 1981. </year>
Reference-contexts: That is, y (t j ; t 0 ; [y 0 ]) [y j ] ; for j = 1; 2; : : : ; m: 1.4 An Overview of Validated Methods for IVPs for ODEs Most validated methods for IVPs for ODEs are based on Taylor series [Moo66], [Kru69], <ref> [Eij81] </ref>, [Loh88], [Rih94], [BM98]. The Taylor series approach has been popular because of the simple form of the error term, which can be readily bounded using interval arithmetic. <p> (t j ) = y j has a unique solution y (t; t j ; y j ) that satisfies y (t; t j ; y j ) 2 [~y j ] for all t 2 [t j ; t j+1 ] and all y j 2 [y j ], <ref> [Eij81, pp. 59-67] </ref>. We refer to a method based on (1.13) as a constant enclosure method. Such a method can be easily implemented, but a serious disadvantage of this approach is that the stepsize is restricted to Euler steps. <p> This formula is the basis of the interval Taylor series (ITS) methods of Moore [Moo66], Eijgenraam <ref> [Eij81] </ref>, Lohner [Loh88], and Rihm [Rih94] (see also [NJC99]). 2 An equality is possible only in the trivial cases h j = 0 or w (f [i] ([y j ])) = 0, i = 1; : : : k 1, and w (f [k] ([~y j ])) = 0. 1.
Reference: [ES90] <author> Margaret A. Ellis and B. Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Although the approach described in [BM98] reduces the wrapping effect substantially, working with polynomials is significantly more expensive than working with intervals. 1.7 Object-Oriented Concepts We have chosen an object-oriented approach in designing VNODE and C++ <ref> [ES90] </ref> to implement it. This is not the first object-oriented design of an ODE solver. The Godess project [Ols95] offers a generic ODE solver that implements traditional methods for IVPs for ODEs. Another successful package is Diffpack [Lan96], which is devised for solving partial differential equations.
Reference: [GJU96] <author> Andreas Griewank, David Juedes, and Jean Utke. ADOL-C, </author> <title> a package for the automatic differentiation of algorithms written in C/C++. </title> <journal> ACM Trans. Math. Software, </journal> <volume> 22(2) </volume> <pages> 131-167, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: FADBAD and TADIFF are not optimized to handle large and sparse systems. Also, they perform all the work in the main memory. The IADOL-C package is an extension of ADOL-C <ref> [GJU96] </ref> that allows generic data types. ADOL-C can compute Taylor coefficients by using the forward mode and their Jacobians by applying the reverse mode [Spe80] to these coefficients. The basic data type of ADOL-C is double.
Reference: [Han92] <author> Eldon R. Hansen. </author> <title> Global Optimization Using Interval Analysis. </title> <publisher> Marcel Dekker, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: For example, interval methods can be faster than standard floating-point schemes for finding all solutions or global optima of a nonlinear equation <ref> [Han92] </ref> (see [Kea96a] for references). The bounds produced by many early interval methods were not tight. For example, one way to bound the solution of a linear system is to apply Gaussian elimination with floating-point numbers replaced by intervals. This, though, often produces large overestimations of the error. A 1.
Reference: [Iwa97] <author> Ronald Van Iwaarden. IADOL-C, </author> <type> personal communications, </type> <year> 1997. </year> <note> IADOL-C is available through the author. E-mail vaniwaar@metsci.com. </note>
Reference-contexts: These are the FADBAD/TADIFF [BS96], [BS97] and IADOL-C <ref> [Iwa97] </ref> packages. They are written in C++ and implement AD through operator overloading. TADIFF and FADBAD are two different packages. TADIFF can generate Taylor coefficients with respect to time. <p> Since IADOL-C replaces only the double data type of ADOL-C, IADOL-C inherits all the functionality of ADOL-C. However, this overloading in IADOL-C causes it to run about three times slower than ADOL-C. This appears to be due largely to the C++ compilers rather than the AD package <ref> [Iwa97] </ref>. The ADOL-C package records the computation graph on a so-called tape. This tape is stored in the main memory, but, when necessary, is paged to disk. When generating Jacobians of Taylor coefficients, ADOL-C can exploit the sparsity structure of the Jacobian of the function for computing the right side.
Reference: [Jue91] <author> David Juedes. </author> <title> A taxonomy of automatic differentiation tools. </title> <editor> In Andreas Griewank and George F. Corliss, editors, </editor> <title> Automatic Differentiation of Algorithms: Theory, </title> <booktitle> Implementation, and Application, </booktitle> <pages> pages 315-329. </pages> <publisher> SIAM, </publisher> <address> Philadelphia, Penn., </address> <year> 1991. </year> <title> 28 N. </title> <editor> S. Nedialkov, K. R. </editor> <publisher> Jackson </publisher>
Reference-contexts: In this section, we address each of these considerations in turn. 1.8.1 Software for Automatic Generation of Interval Taylor Coefficients Although packages for automatic differentiation (AD) are available (see for example <ref> [Jue91] </ref> and [YC96]), to date, only two free packages for automatic generation of interval Taylor coefficients for the solution of an ODE and the Jacobians of these coefficients are known to the authors. These are the FADBAD/TADIFF [BS96], [BS97] and IADOL-C [Iwa97] packages.
Reference: [KDDH95] <author> R. B. Kearfott, M. Dawande, K. Du, and C. Hu. </author> <title> Algorithm 737: INTLIB: A portable Fortran 77 interval standard function library. </title> <journal> ACM Trans. Math. Softw., </journal> <volume> 20(4) </volume> <pages> 447-459, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: VNODE with these AD packages is based on the 16 N. S. Nedialkov, K. R. Jackson INTERVAL data type from the PROFIL/BIAS package, which we discuss in x1.8.2 and x1.8.4. 1.8.2 Interval Arithmetic Packages The most popular and free interval-arithmetic packages are PROFIL/BIAS [Knu94], written in C++, and INTLIB <ref> [KDDH95] </ref>, written in Fortran 77 and available with a Fortran 90 interface [Kea96b]. The Fortran 90 version of INTLIB uses operator overloading. For references and comments on other available packages, see for example [Kea96b] or [Knu94].
Reference: [Kea95] <author> R. B. Kearfott. </author> <title> Fortran 90 environment for research and pro-totyping of enclosure algorithms for constrained and unconstrained nonlinear equations. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 21(1) </volume> <pages> 63-78, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: One of the most successful applications of interval computations is in global optimization where bounds on the range of a function are used to reject regions that cannot contain global optima <ref> [Kea95] </ref>. We can also obtain tight bounds on the true solution of a linear system of equations [KU93]. Interval techniques can also be used to bound the error of a numerical approximation.
Reference: [Kea96a] <author> R. B. Kearfott. </author> <title> Interval computations: Introduction, uses, and resources. </title> <journal> Euromath Bulletin, </journal> <volume> 2(1) </volume> <pages> 95-112, </pages> <year> 1996. </year>
Reference-contexts: Such enclosures can be used to compute guaranteed bounds either for an integral [CR87] or for an initial value problem (IVP) for an ordinary differential equation (ODE) (see [NJC99] for a survey). An extensive summary of applications of and resources for interval computations can be found in <ref> [Kea96a] </ref>. Interval methods have not been popular in the past for several reasons. <p> For example, interval methods can be faster than standard floating-point schemes for finding all solutions or global optima of a nonlinear equation [Han92] (see <ref> [Kea96a] </ref> for references). The bounds produced by many early interval methods were not tight. For example, one way to bound the solution of a linear system is to apply Gaussian elimination with floating-point numbers replaced by intervals. This, though, often produces large overestimations of the error. A 1.
Reference: [Kea96b] <author> R. B. Kearfott. </author> <title> INTERVAL ARITHMETIC: A Fortran 90 module for an interval data type. </title> <journal> ACM Trans. Math. Software, </journal> <volume> 22(4) </volume> <pages> 385-392, </pages> <year> 1996. </year>
Reference-contexts: Without it, programming interval-arithmetic expressions is cumbersome, because we have to code interval-arithmetic operations by using function calls. Both C++ and Fortran 90 provide operator overloading. This feature is used to build interval-arithmetic libraries like PROFIL/BIAS [Knu94] (C++) and INTLIB (Fortran 90) <ref> [Kea96b] </ref>, as discussed in x1.8.2. 1.8 Choice of Language: C++ versus Fortran 90 We considered C++ and Fortran 90 [MR90] as candidates to implement VNODE, but we preferred C++. Procedural languages like C or Fortran 77 can be used to implement an object-oriented design [BGMS97]. <p> Nedialkov, K. R. Jackson INTERVAL data type from the PROFIL/BIAS package, which we discuss in x1.8.2 and x1.8.4. 1.8.2 Interval Arithmetic Packages The most popular and free interval-arithmetic packages are PROFIL/BIAS [Knu94], written in C++, and INTLIB [KDDH95], written in Fortran 77 and available with a Fortran 90 interface <ref> [Kea96b] </ref>. The Fortran 90 version of INTLIB uses operator overloading. For references and comments on other available packages, see for example [Kea96b] or [Knu94]. Recently, an extension of the Gnu Fortran compiler which supports intervals as an intrinsic data type was reported [SaAAB98]. <p> Arithmetic Packages The most popular and free interval-arithmetic packages are PROFIL/BIAS [Knu94], written in C++, and INTLIB [KDDH95], written in Fortran 77 and available with a Fortran 90 interface <ref> [Kea96b] </ref>. The Fortran 90 version of INTLIB uses operator overloading. For references and comments on other available packages, see for example [Kea96b] or [Knu94]. Recently, an extension of the Gnu Fortran compiler which supports intervals as an intrinsic data type was reported [SaAAB98]. PROFIL/BIAS seems to be the fastest interval package. In comparison with other such packages, including INTLIB, PROFIL/BIAS is about one order of magnitude faster [Knu94].
Reference: [KKN + 92] <author> Rudi Klatte, Ulrich Kulisch, Michael Neaga, Dietmar Ratz, and Christian Ullrich. Pascal-XSC: </author> <title> Language Reference with Examples. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: We briefly summarize each in turn. 1. Software Issues in Validated ODE Solving 13 AWA is an implementation of Lohner's method (x1.4.4) and the constant enclosure method (x1.4.3) for validating existence and uniqueness of the solution. This package is written in Pascal-XSC <ref> [KKN + 92] </ref>, an extension of Pascal for scientific computing. ADIODES is a C++ implementation of a solver using the constant enclosure method in Algorithm I and Lohner's method in Algorithm II. The stepsize in both ADIODES and AWA is restricted to Euler step by Algorithm I.
Reference: [Knu94] <author> O. Knuppel. </author> <title> PROFIL/BIAS a fast interval library. </title> <booktitle> Computing, </booktitle> <address> 53(3-4):277-287, </address> <year> 1994. </year> <note> PROFIL/BIAS is available at http://www.ti3.tu-harburg.de/Software/PROFILEnglisch. html. </note>
Reference-contexts: Without it, programming interval-arithmetic expressions is cumbersome, because we have to code interval-arithmetic operations by using function calls. Both C++ and Fortran 90 provide operator overloading. This feature is used to build interval-arithmetic libraries like PROFIL/BIAS <ref> [Knu94] </ref> (C++) and INTLIB (Fortran 90) [Kea96b], as discussed in x1.8.2. 1.8 Choice of Language: C++ versus Fortran 90 We considered C++ and Fortran 90 [MR90] as candidates to implement VNODE, but we preferred C++. <p> VNODE with these AD packages is based on the 16 N. S. Nedialkov, K. R. Jackson INTERVAL data type from the PROFIL/BIAS package, which we discuss in x1.8.2 and x1.8.4. 1.8.2 Interval Arithmetic Packages The most popular and free interval-arithmetic packages are PROFIL/BIAS <ref> [Knu94] </ref>, written in C++, and INTLIB [KDDH95], written in Fortran 77 and available with a Fortran 90 interface [Kea96b]. The Fortran 90 version of INTLIB uses operator overloading. For references and comments on other available packages, see for example [Kea96b] or [Knu94]. <p> The most popular and free interval-arithmetic packages are PROFIL/BIAS <ref> [Knu94] </ref>, written in C++, and INTLIB [KDDH95], written in Fortran 77 and available with a Fortran 90 interface [Kea96b]. The Fortran 90 version of INTLIB uses operator overloading. For references and comments on other available packages, see for example [Kea96b] or [Knu94]. Recently, an extension of the Gnu Fortran compiler which supports intervals as an intrinsic data type was reported [SaAAB98]. PROFIL/BIAS seems to be the fastest interval package. In comparison with other such packages, including INTLIB, PROFIL/BIAS is about one order of magnitude faster [Knu94]. <p> packages, see for example [Kea96b] or <ref> [Knu94] </ref>. Recently, an extension of the Gnu Fortran compiler which supports intervals as an intrinsic data type was reported [SaAAB98]. PROFIL/BIAS seems to be the fastest interval package. In comparison with other such packages, including INTLIB, PROFIL/BIAS is about one order of magnitude faster [Knu94]. For efficiency, it uses directional rounding facilities of the processor on the machines on which it is installed. Portability is provided by isolating the machine dependent code in small assembler files, which are distributed with the package. <p> Another reason for the efficiency of PROFIL/BIAS is that the number of rounding mode switches and sign tests are minimized in vector and matrix operations. In modern RISC architectures, sign tests and rounding mode switches cost nearly as much or even more than floating-point operations <ref> [Knu94] </ref>, [SaAAB98]. In addition, PROFIL/BIAS is easy to use, and provides matrix and vector operations and essential routines, such as, guaranteed linear equation solvers and optimization methods. INTLIB is intended to be a totally portable Fortran 77 package.
Reference: [Kru69] <author> F. Kruckeberg. </author> <title> Ordinary differential equations. In Eldon Hansen, editor, </title> <booktitle> Topics in Interval Analysis, </booktitle> <pages> pages 91-97. </pages> <publisher> Clarendon Press, Oxford, </publisher> <year> 1969. </year>
Reference-contexts: That is, y (t j ; t 0 ; [y 0 ]) [y j ] ; for j = 1; 2; : : : ; m: 1.4 An Overview of Validated Methods for IVPs for ODEs Most validated methods for IVPs for ODEs are based on Taylor series [Moo66], <ref> [Kru69] </ref>, [Eij81], [Loh88], [Rih94], [BM98]. The Taylor series approach has been popular because of the simple form of the error term, which can be readily bounded using interval arithmetic.
Reference: [KU93] <author> F. Korn and Ch. Ullrich. </author> <title> Verified solution of linear systems based on common software libraries. Interval Computations, </title> <booktitle> 3 </booktitle> <pages> 116-132, </pages> <year> 1993. </year>
Reference-contexts: One of the most successful applications of interval computations is in global optimization where bounds on the range of a function are used to reject regions that cannot contain global optima [Kea95]. We can also obtain tight bounds on the true solution of a linear system of equations <ref> [KU93] </ref>. Interval techniques can also be used to bound the error of a numerical approximation. For example, as explained below, we can enclose the truncation error of a Taylor series expansion by generating Taylor coefficients in interval arithmetic.
Reference: [Lan96] <author> Hans Petter Langtangen. Diffpack. </author> <type> Technical report, </type> <institution> SINTEF, Oslo, Norway, </institution> <month> June </month> <year> 1996. </year> <note> See also http://www.oslo.sintef.no/diffpack/reports/. </note>
Reference-contexts: This is not the first object-oriented design of an ODE solver. The Godess project [Ols95] offers a generic ODE solver that implements traditional methods for IVPs for ODEs. Another successful package is Diffpack <ref> [Lan96] </ref>, which is devised for solving partial differential equations. In [Lan96], there is also an example of how to construct an object-oriented ODE solver. In this section, we briefly review some object-oriented concepts supported in C++. <p> This is not the first object-oriented design of an ODE solver. The Godess project [Ols95] offers a generic ODE solver that implements traditional methods for IVPs for ODEs. Another successful package is Diffpack <ref> [Lan96] </ref>, which is devised for solving partial differential equations. In [Lan96], there is also an example of how to construct an object-oriented ODE solver. In this section, we briefly review some object-oriented concepts supported in C++. We use them in the discussion of the choice of programming language (x1.8) and in the description of VNODE (x1.9).
Reference: [Loh87] <author> Rudolph J. Lohner. </author> <title> Enclosing the solutions of ordinary initial and boundary value problems. </title> <editor> In Edgar W. Kaucher, Ulrich W. Kulisch, and Christian Ullrich, editors, </editor> <booktitle> Computer Arithmetic: Scientific Computation and Programming Languages, </booktitle> <pages> pages 255-286. </pages> <booktitle> Wiley-Teubner Series in Computer Science, </booktitle> <address> Stuttgart, </address> <year> 1987. </year>
Reference-contexts: A detailed explanation of the reasons for this and other choices for A j+1 can be found in <ref> [Loh87] </ref> and [NJC99]. An Interval-Hermite Obreschkoff Method For more than 30 years, Taylor series has been the only effective approach for computing rigorous bounds on the solution of an IVP for an ODE. Recently, we developed a new scheme, an interval Hermite-Obreschkoff (IHO) method [NJ98], [Ned99].
Reference: [Loh88] <author> Rudolf J. Lohner. </author> <title> Einschlieung der Losung gewohnlicher Anfangs- und Randwertaufgaben und Anwendungen. </title> <type> PhD thesis, </type> <institution> Universitat Karlsruhe, </institution> <year> 1988. </year> <note> AWA is available at ftp://iamk4515.mathematik.uni-karlsruhe.de/pub/awa/. </note> <month> 1. </month> <title> Software Issues in Validated ODE Solving 29 </title>
Reference-contexts: is, y (t j ; t 0 ; [y 0 ]) [y j ] ; for j = 1; 2; : : : ; m: 1.4 An Overview of Validated Methods for IVPs for ODEs Most validated methods for IVPs for ODEs are based on Taylor series [Moo66], [Kru69], [Eij81], <ref> [Loh88] </ref>, [Rih94], [BM98]. The Taylor series approach has been popular because of the simple form of the error term, which can be readily bounded using interval arithmetic. <p> This formula is the basis of the interval Taylor series (ITS) methods of Moore [Moo66], Eijgenraam [Eij81], Lohner <ref> [Loh88] </ref>, and Rihm [Rih94] (see also [NJC99]). 2 An equality is possible only in the trivial cases h j = 0 or w (f [i] ([y j ])) = 0, i = 1; : : : k 1, and w (f [k] ([~y j ])) = 0. 1. <p> Alternatively, these Jacobians can be computed by generating Taylor coefficients for the associated variational equation <ref> [Loh88] </ref>. If we compute enclosures with (1.18), the widths of the computed intervals may decrease. <p> In addition to an interval-arithmetic package, a major component of a validated solver is the module for automatic generation of interval Taylor coefficients (see x1.8.1). Currently, there are three available packages for computing guaranteed bounds on the solution of an IVP for an ODE: AWA <ref> [Loh88] </ref>, ADIODES [Sta97] and COSY INFINITY [Ber97]. We briefly summarize each in turn. 1. Software Issues in Validated ODE Solving 13 AWA is an implementation of Lohner's method (x1.4.4) and the constant enclosure method (x1.4.3) for validating existence and uniqueness of the solution.
Reference: [Loh95] <author> Rudolf J. Lohner. </author> <title> Step size and order control in the verified solution of IVP with ODE's, </title> <booktitle> 1995. SciCADE'95 International Conference on Scientific Computation and Differential Equations, </booktitle> <address> Stanford, Calif., March 28 - April 1, </address> <year> 1995. </year>
Reference-contexts: Usually, Algorithm II allows larger stepsizes, but they are nearly always limited by Algorithm I. One can obtain methods that enable larger stepsizes by using polynomial enclosures <ref> [Loh95] </ref> or more Taylor series terms in the sum in (1.13), thus obtaining a Taylor series enclosure method [Moo66, pp. 100-103], [CR96], [Ned99]. 8 N. S. Nedialkov, K. R.
Reference: [Moo66] <author> Ramon E. Moore. </author> <title> Interval Analysis. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1966. </year>
Reference-contexts: Validated (also called interval) methods produce bounds that are guaranteed to contain a mathematically correct result. These methods use interval arithmetic <ref> [Moo66] </ref> to enclose rounding errors, truncation errors, and possibly even uncertainties in the model, assuming these can be quantified. A key application of interval methods is to compute rigorous enclosures for the range of a function. <p> S. Nedialkov, K. R. Jackson If [a] and [b] are intervals and ffi 2 f+; ; fl; =g, then the interval-arithmetic operations are defined by [a] ffi [b] = x ffi y j x 2 [a] ; y 2 [b] ; 0 =2 [b] when ffi = = (1.1) <ref> [Moo66] </ref>. <p> Thus, f (y) 2 f M ([a]; b) = f (b) + f 0 ([a])([a] b) (1.7) <ref> [Moo66, p. 47] </ref>. The mean-value form, f M ([a]; b), is popular in interval methods since it often gives better enclosures for the range of f than the straightforward interval-arithmetic evaluation of f itself. <p> That is, y (t j ; t 0 ; [y 0 ]) [y j ] ; for j = 1; 2; : : : ; m: 1.4 An Overview of Validated Methods for IVPs for ODEs Most validated methods for IVPs for ODEs are based on Taylor series <ref> [Moo66] </ref>, [Kru69], [Eij81], [Loh88], [Rih94], [BM98]. The Taylor series approach has been popular because of the simple form of the error term, which can be readily bounded using interval arithmetic. <p> Validated ODE Solving 7 If we know the Taylor coefficients u (i) =i! and v (i) =i! for i = 0; : : : ; p for two functions u and v, then we can compute the pth Taylor coefficient of u v, uv, and u=v by standard Calculus formulas <ref> [Moo66, pp. 107-130] </ref>. <p> Using (1.12) and formulas for the Taylor coefficients of sums, products, quotients, and the standard functions, we can recursively evaluate (y j ) i , for i 1. It can be shown that to generate k coefficients, we need at most O (k 2 ) operations <ref> [Moo66, pp. 111-112] </ref>. Note that this is far more efficient than the standard symbolic generation of Taylor coefficients. <p> Usually, Algorithm II allows larger stepsizes, but they are nearly always limited by Algorithm I. One can obtain methods that enable larger stepsizes by using polynomial enclosures [Loh95] or more Taylor series terms in the sum in (1.13), thus obtaining a Taylor series enclosure method <ref> [Moo66, pp. 100-103] </ref>, [CR96], [Ned99]. 8 N. S. Nedialkov, K. R. <p> This formula is the basis of the interval Taylor series (ITS) methods of Moore <ref> [Moo66] </ref>, Eijgenraam [Eij81], Lohner [Loh88], and Rihm [Rih94] (see also [NJC99]). 2 An equality is possible only in the trivial cases h j = 0 or w (f [i] ([y j ])) = 0, i = 1; : : : k 1, and w (f [k] ([~y j ])) = 0. <p> This is called the wrapping effect. The Wrapping Effect The wrapping effect is clearly illustrated by Moore's example <ref> [Moo66] </ref>, y 0 y 0 y (0) 2 [y 0 ]: The interval vector [y 0 ] can be viewed as a rectangle in the (y 1 ; y 2 ) plane. <p> Thus, at each step, the enclosing rectangles become larger and larger, but the solution set remains a rectangle of the same size. Moore showed that at t = 2, the interval inclusion is inflated by a factor of e 2 535 as the stepsize approaches zero <ref> [Moo66, p. 134] </ref>. Lohner's Method Denote by m ([a]) = (a + a )=2 the midpoint of an interval [a]; the midpoint of an interval vector or interval matrix is defined componentwise.
Reference: [MR90] <author> M. Metcalf and J. Reid. </author> <title> Fortran 90 Explained. </title> <publisher> Oxford University Press, Oxford, </publisher> <address> England, </address> <year> 1990. </year>
Reference-contexts: Both C++ and Fortran 90 provide operator overloading. This feature is used to build interval-arithmetic libraries like PROFIL/BIAS [Knu94] (C++) and INTLIB (Fortran 90) [Kea96b], as discussed in x1.8.2. 1.8 Choice of Language: C++ versus Fortran 90 We considered C++ and Fortran 90 <ref> [MR90] </ref> as candidates to implement VNODE, but we preferred C++. Procedural languages like C or Fortran 77 can be used to implement an object-oriented design [BGMS97]. However, using a language that supports object-oriented programming usually reduces the effort for implementing object-oriented software.
Reference: [Ned99] <author> Nedialko Stoyanov Nedialkov. </author> <title> Computing Rigorous Bounds on the Solution of an Initial Value Problem for an Ordinary Differential Equation. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Toronto, Toronto, Canada, M5S 3G4, </institution> <month> February </month> <year> 1999. </year> <note> Available at http://www.cs.toronto.edu/NA/reports.html. </note>
Reference-contexts: Usually, Algorithm II allows larger stepsizes, but they are nearly always limited by Algorithm I. One can obtain methods that enable larger stepsizes by using polynomial enclosures [Loh95] or more Taylor series terms in the sum in (1.13), thus obtaining a Taylor series enclosure method [Moo66, pp. 100-103], [CR96], <ref> [Ned99] </ref>. 8 N. S. Nedialkov, K. R. <p> An Interval-Hermite Obreschkoff Method For more than 30 years, Taylor series has been the only effective approach for computing rigorous bounds on the solution of an IVP for an ODE. Recently, we developed a new scheme, an interval Hermite-Obreschkoff (IHO) method [NJ98], <ref> [Ned99] </ref>. Here, we outline the method and its potential. Let q;p q! (q + p i)! 1. <p> It can be shown that q X (1) i c i h i p X c i h i + (1) q q!p! h j f [k] (y; t j ; t j+1 ) (1.24) [Wan77], <ref> [Ned99] </ref>. This formula is the basis of our IHO method. The method we propose in [Ned99] consists of two phases, which can be considered as a predictor and a corrector. <p> can be shown that q X (1) i c i h i p X c i h i + (1) q q!p! h j f [k] (y; t j ; t j+1 ) (1.24) [Wan77], <ref> [Ned99] </ref>. This formula is the basis of our IHO method. The method we propose in [Ned99] consists of two phases, which can be considered as a predictor and a corrector. The predictor computes an enclosure [y (0) of the solution at t j+1 , and using this enclosure, the corrector computes a tighter enclosure [y j+1 ] [y (0) j+1 ] at t j+1 . <p> Since q &gt; 0, (1.24) is an implicit scheme. The corrector applies a Newton-like step to tighten [y (0) We have shown in [NJ98] and <ref> [Ned99] </ref> that for the same order and step size, our IHO method has smaller local error, better stability, and requires fewer Jacobians than an ITS method. <p> Currently, VNODE does not implement variable-order methods. For selecting a stepsize, CONST STEP returns a constant stepsize on each step, and VAR STEP CONTROL implements a stepsize selection scheme based on controlling the width of the remainder term <ref> [Ned99] </ref>. There are two methods for validating existence and uniqueness of the solution in VNODE: a constant enclosure method (CONST INIT ENCL) and 4 How to specify and interpret relative error tolerance will be discussed in the documentation of VNODE. 1. <p> When validating existence and uniqueness of the solution, we normally guess a priori bounds for the solution. Then, we verify if these bounds satisfy some condition (as in (1.4.3); see also <ref> [Ned99] </ref>). It may happen that we have guessed bounds that are too wide and contain zero. If there is a 1.
Reference: [Neu90] <author> Arnold Neumaier. </author> <title> Interval Methods for Systems of Equations. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: Email: fned,krjg@cs.toronto.edu 2 N. S. Nedialkov, K. R. Jackson a solution to a nonlinear system of equations and to compute interval vectors that are guaranteed to contain the true solution of the system <ref> [Neu90] </ref>. One of the most successful applications of interval computations is in global optimization where bounds on the range of a function are used to reject regions that cannot contain global optima [Kea95]. We can also obtain tight bounds on the true solution of a linear system of equations [KU93]. <p> This, though, often produces large overestimations of the error. A 1. Software Issues in Validated ODE Solving 3 good interval version of Gaussian elimination is significantly different from the corresponding floating-point algorithm <ref> [Neu90] </ref>. Similarly, early interval methods for ODEs suffered from the wrapping effect. As a result, they often produced very poor bounds. However, as described below, more sophisticated modern methods cope quite effectively with this difficulty and produce tight bounds for a wide range of problems. <p> This implies that if we rearrange an interval expression, we may obtain tighter bounds. An important case when the distributive law does hold is when [a] is a degenerate interval (a Addition of interval matrices is associative, but multiplication of interval matrices is not associative in general <ref> [Neu90, pp. 80-81] </ref>. Also, the distributive law does not hold in general for interval matrices [Neu90, p. 79]. <p> An important case when the distributive law does hold is when [a] is a degenerate interval (a Addition of interval matrices is associative, but multiplication of interval matrices is not associative in general [Neu90, pp. 80-81]. Also, the distributive law does not hold in general for interval matrices <ref> [Neu90, p. 79] </ref>. If f : R n ! R is continuously differentiable on D R n and [a] D, then, for any y and b 2 [a], f (y) = f (b) + f 0 (j)(y b) for some j 2 [a] by the mean-value theorem.
Reference: [NJ98] <author> N. S. Nedialkov and K. R. Jackson. </author> <title> An interval Hermite-Obreschkoff method for computing rigorous bounds on the solution of an initial value problem for an ordinary differential equation. Reliable Computing, </title> <note> Submitted, October 1998. Available at http://www.cs.toronto.edu/NA/reports.html. </note>
Reference-contexts: An Interval-Hermite Obreschkoff Method For more than 30 years, Taylor series has been the only effective approach for computing rigorous bounds on the solution of an IVP for an ODE. Recently, we developed a new scheme, an interval Hermite-Obreschkoff (IHO) method <ref> [NJ98] </ref>, [Ned99]. Here, we outline the method and its potential. Let q;p q! (q + p i)! 1. <p> Since q &gt; 0, (1.24) is an implicit scheme. The corrector applies a Newton-like step to tighten [y (0) We have shown in <ref> [NJ98] </ref> and [Ned99] that for the same order and step size, our IHO method has smaller local error, better stability, and requires fewer Jacobians than an ITS method.
Reference: [NJC99] <author> N. S. Nedialkov, K. R. Jackson, and G. F. Corliss. </author> <title> Validated solutions of initial value problems for ordinary differential equations. </title> <journal> Appl. Math. Comp., </journal> <note> To appear, 1999. Available at http://www.cs.toronto.edu/NA/reports.html. </note>
Reference-contexts: Such enclosures can be used to compute guaranteed bounds either for an integral [CR87] or for an initial value problem (IVP) for an ordinary differential equation (ODE) (see <ref> [NJC99] </ref> for a survey). An extensive summary of applications of and resources for interval computations can be found in [Kea96a]. Interval methods have not been popular in the past for several reasons. <p> method can be changed easily by adding or deleting Taylor series terms, and the stepsize can be changed without doing extra work to recompute Taylor series coefficients. 1.4.1 One Step of a Validated Method The (j + 1)st step (j 0) in most Taylor series methods consists of two phases <ref> [NJC99] </ref>: Algorithm I: Compute a stepsize h j and an a priori enclosure [~y j ] of the solution such that y (t; t j ; y j ) is guaranteed to exist for all t 2 [t j ; t j+1 ] and all y j 2 [y j ], <p> Algorithm II: Compute a tighter enclosure [y j+1 ] for y (t j+1 ; t 0 ; [y 0 ]). In this section, we briefly review methods for implementing these two algorithms. A detailed survey of Taylor series methods can be found in <ref> [NJC99] </ref>. 1.4.2 Automatic Generation of Taylor Coefficients Since the interval methods for IVPs for ODEs considered here use Taylor series, we outline the recursive generation of Taylor coefficients. 1. <p> This formula is the basis of the interval Taylor series (ITS) methods of Moore [Moo66], Eijgenraam [Eij81], Lohner [Loh88], and Rihm [Rih94] (see also <ref> [NJC99] </ref>). 2 An equality is possible only in the trivial cases h j = 0 or w (f [i] ([y j ])) = 0, i = 1; : : : k 1, and w (f [k] ([~y j ])) = 0. 1. <p> A detailed explanation of the reasons for this and other choices for A j+1 can be found in [Loh87] and <ref> [NJC99] </ref>. An Interval-Hermite Obreschkoff Method For more than 30 years, Taylor series has been the only effective approach for computing rigorous bounds on the solution of an IVP for an ODE. Recently, we developed a new scheme, an interval Hermite-Obreschkoff (IHO) method [NJ98], [Ned99]. <p> Since VNODE is to be used for comparing and assessing methods, it should contain the most promising ones. Moreover, VNODE should support rapid prototyping. 1.6 Background The area of computing validated solutions of IVPs for ODEs is not as developed as the area of computing approximate solutions <ref> [NJC99] </ref>. For example, we still do not have well-studied stepsize and order control strategies nor methods suitable for stiff problems. Also, reducing the wrapping effect in Algorithm II and taking larger stepsizes in Algorithm I are still problems in validated ODE solving.
Reference: [Ols95] <author> Hans Olson. </author> <title> Documentation of the structure of Godess. </title> <type> Technical report, </type> <institution> Computer Science, Lund Institute of Technology, S-221 00 Lund, Sweden, </institution> <month> November </month> <year> 1995. </year>
Reference-contexts: This is not the first object-oriented design of an ODE solver. The Godess project <ref> [Ols95] </ref> offers a generic ODE solver that implements traditional methods for IVPs for ODEs. Another successful package is Diffpack [Lan96], which is devised for solving partial differential equations. In [Lan96], there is also an example of how to construct an object-oriented ODE solver.
Reference: [Ral81] <author> Louis B. Rall. </author> <title> Automatic Differentiation: Techniques and Applications, </title> <booktitle> volume 120 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: They are written in C++ and implement AD through operator overloading. TADIFF and FADBAD are two different packages. TADIFF can generate Taylor coefficients with respect to time. Then, FADBAD can be used to compute Jacobians of Taylor coefficients by applying the forward mode of AD <ref> [Ral81] </ref> to these coefficients. FADBAD and TADIFF are not optimized to handle large and sparse systems. Also, they perform all the work in the main memory. The IADOL-C package is an extension of ADOL-C [GJU96] that allows generic data types.
Reference: [RBP + 91] <author> James Rumbaugh, Michael Blaha, William Premerlani, Fred-erick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: It is realized either by a complete containment of an object Y within another object X or by a pointer from X to Y. The notation in these figures is similar to that suggested in <ref> [RBP + 91] </ref>. In the next two subsections, we list the problem and method classes and provide brief explanations. Here, we do not discuss the classes for generating Taylor coefficients in VNODE. A description of VNODE will be given in the documentation of the code at http://www.cs.toronto.edu/NA.
Reference: [Rih94] <author> Robert Rihm. </author> <title> On a class of enclosure methods for initial value problems. </title> <journal> Computing, </journal> <volume> 53 </volume> <pages> 369-377, </pages> <year> 1994. </year>
Reference-contexts: y (t j ; t 0 ; [y 0 ]) [y j ] ; for j = 1; 2; : : : ; m: 1.4 An Overview of Validated Methods for IVPs for ODEs Most validated methods for IVPs for ODEs are based on Taylor series [Moo66], [Kru69], [Eij81], [Loh88], <ref> [Rih94] </ref>, [BM98]. The Taylor series approach has been popular because of the simple form of the error term, which can be readily bounded using interval arithmetic. <p> This formula is the basis of the interval Taylor series (ITS) methods of Moore [Moo66], Eijgenraam [Eij81], Lohner [Loh88], and Rihm <ref> [Rih94] </ref> (see also [NJC99]). 2 An equality is possible only in the trivial cases h j = 0 or w (f [i] ([y j ])) = 0, i = 1; : : : k 1, and w (f [k] ([~y j ])) = 0. 1.
Reference: [Rob96] <author> Arch D. Robinson. </author> <title> C++ gets faster for scientific computing. </title> <journal> Computers in Physics, </journal> <volume> 10(5) </volume> <pages> 458-462, </pages> <month> Sep/Oct </month> <year> 1996. </year> <title> 30 N. </title> <editor> S. Nedialkov, K. R. </editor> <publisher> Jackson </publisher>
Reference-contexts: Here, we discuss an important performance problem: 1. Software Issues in Validated ODE Solving 17 the pairwise evaluation of arithmetic expression with arguments of array types (e.g., matrices and vectors). More detailed treatment of this and other problems can be found in <ref> [Rob96] </ref>, [Vel97], and [VJ97]. In C++, executing overloaded arithmetic operations with array data types creates temporaries, which can introduce a significant overhead, particularly for small objects.
Reference: [SA93] <author> H. Spreuer and E. Adams. </author> <title> On the existence and the verified determination of homoclinic and heteroclinic orbits of the origin for the Lorenz system. </title> <journal> Computing Suppl., </journal> <volume> 9 </volume> <pages> 233-246, </pages> <year> 1993. </year>
Reference-contexts: However, there are situations when guaranteed bounds on the mathematically correct result are desired or needed. For example, such bounds can be used to prove a theorem <ref> [SA93] </ref>. Also, some calculations may be critical to the safety or reliability of a system. Therefore, it may be necessary to ensure that the true result is within computed bounds.
Reference: [SaAAB98] <author> Michael J. Schulte, Vitaly Zelov and Ahmet Akkas, and James Craig Burley. </author> <title> The interval-enhanced GNU Fortran compiler. Reliable Computing, </title> <note> Submitted, </note> <month> October </month> <year> 1998. </year>
Reference-contexts: As a result, we can implement an interval data type and write interval arithmetic operations without explicit function calls. An important step towards wider use of interval computations is the development of a Fortran compiler that supports intervals as an intrinsic data type <ref> [SaAAB98] </ref>. This chapter focuses on interval methods for IVPs for ODEs: we give a brief overview of these methods, discuss software issues related to the implementation of a validated ODE solver, and describe the structure of the VNODE (Validated Numerical ODE) package that we are developing. <p> The Fortran 90 version of INTLIB uses operator overloading. For references and comments on other available packages, see for example [Kea96b] or [Knu94]. Recently, an extension of the Gnu Fortran compiler which supports intervals as an intrinsic data type was reported <ref> [SaAAB98] </ref>. PROFIL/BIAS seems to be the fastest interval package. In comparison with other such packages, including INTLIB, PROFIL/BIAS is about one order of magnitude faster [Knu94]. For efficiency, it uses directional rounding facilities of the processor on the machines on which it is installed. <p> Another reason for the efficiency of PROFIL/BIAS is that the number of rounding mode switches and sign tests are minimized in vector and matrix operations. In modern RISC architectures, sign tests and rounding mode switches cost nearly as much or even more than floating-point operations [Knu94], <ref> [SaAAB98] </ref>. In addition, PROFIL/BIAS is easy to use, and provides matrix and vector operations and essential routines, such as, guaranteed linear equation solvers and optimization methods. INTLIB is intended to be a totally portable Fortran 77 package.
Reference: [Spe80] <author> B. Speelpenning. </author> <title> Compiling Fast Partial Derivatives of Functions Given by Algorithms. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana-Champaign, Ill., </institution> <month> January </month> <year> 1980. </year>
Reference-contexts: Also, they perform all the work in the main memory. The IADOL-C package is an extension of ADOL-C [GJU96] that allows generic data types. ADOL-C can compute Taylor coefficients by using the forward mode and their Jacobians by applying the reverse mode <ref> [Spe80] </ref> to these coefficients. The basic data type of ADOL-C is double. To use a new data type in IADOL-C, the user has to overload the arithmetic and comparison operations and the standard functions for that data type. Then, using IADOL-C is essentially the same as using ADOL-C.
Reference: [Sta97] <author> Ole Stauning. </author> <title> Automatic validation of numerical solutions. </title> <type> Technical Report IMM-PHD-1997-36, </type> <institution> IMM, Lyngby, Den-mark, </institution> <month> October </month> <year> 1997. </year> <note> ADIODES is available at http://www.imm.dtu.dk/~os/ADIODES.tar.gz. </note>
Reference-contexts: In addition to an interval-arithmetic package, a major component of a validated solver is the module for automatic generation of interval Taylor coefficients (see x1.8.1). Currently, there are three available packages for computing guaranteed bounds on the solution of an IVP for an ODE: AWA [Loh88], ADIODES <ref> [Sta97] </ref> and COSY INFINITY [Ber97]. We briefly summarize each in turn. 1. Software Issues in Validated ODE Solving 13 AWA is an implementation of Lohner's method (x1.4.4) and the constant enclosure method (x1.4.3) for validating existence and uniqueness of the solution.
Reference: [SZ95] <author> Stephen J. Sullivan and Benjamon G. Zorn. </author> <title> Numerical analysis using nonprocedural paradigms. </title> <journal> ACM TOMS, </journal> <volume> 21(3) </volume> <pages> 267-298, </pages> <month> Sept </month> <year> 1995. </year>
Reference-contexts: A good discussion of object-oriented concepts, analysis, and design can be found in [Boo94]. An excellent book on advanced C++ styles and idioms is [Cop92]. A study of nonprocedural paradigms for numerical analysis, including object-oriented ones, is presented in <ref> [SZ95] </ref>. Data Abstraction In the object model, a software system can be viewed as a collection of objects that interact with each other to achieve a desired functionality. An object is an instance of a class, which defines the structure and behavior 14 N. S. Nedialkov, K. R.
Reference: [Vel95] <author> T. Veldhuizen. </author> <title> Expression templates. C++ Report, </title> <booktitle> 7(5) </booktitle> <pages> 26-31, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Furthermore, this execution introduces three loops. Clearly, it would be better to compute this sum in one loop without temporaries. In Fortran 90, mathematical arrays are represented as elementary types and optimization is possible at the compiler level. Because of better optimizing compilers and template techniques <ref> [Vel95] </ref>, [VJ97], C++ is becoming more competitive for scientific computing. A good technique for reducing the overhead in the pairwise evaluation of expressions involving arrays is to use expression templates [Vel95]. The expression template technique is based on performing compile-time transformation of the code using templates. <p> Because of better optimizing compilers and template techniques <ref> [Vel95] </ref>, [VJ97], C++ is becoming more competitive for scientific computing. A good technique for reducing the overhead in the pairwise evaluation of expressions involving arrays is to use expression templates [Vel95]. The expression template technique is based on performing compile-time transformation of the code using templates. With this technique, expressions containing vectors and matrices can be computed in a single pass without allocating temporaries. For example, with expression templates, it is possible to achieve a loop fusion [Vel95], allowing the above <p> use expression templates <ref> [Vel95] </ref>. The expression template technique is based on performing compile-time transformation of the code using templates. With this technique, expressions containing vectors and matrices can be computed in a single pass without allocating temporaries. For example, with expression templates, it is possible to achieve a loop fusion [Vel95], allowing the above sum to be evaluated in a single loop: for ( int i = 1; i &lt;= N; i++ ) However, executing this loop in interval arithmetic may not be the best solution for the following reason.
Reference: [Vel97] <author> T. Veldhuizen. </author> <title> Scientific computing: C++ versus Fortran. </title> <journal> Dr. Dobb's Journal, </journal> <volume> 34, </volume> <month> November </month> <year> 1997. </year>
Reference-contexts: Here, we discuss an important performance problem: 1. Software Issues in Validated ODE Solving 17 the pairwise evaluation of arithmetic expression with arguments of array types (e.g., matrices and vectors). More detailed treatment of this and other problems can be found in [Rob96], <ref> [Vel97] </ref>, and [VJ97]. In C++, executing overloaded arithmetic operations with array data types creates temporaries, which can introduce a significant overhead, particularly for small objects.
Reference: [VJ97] <author> T. L. Veldhuizen and M. E. Jernigan. </author> <title> Will C++ be faster than Fortran? In Proceedings of the 1st International Scientific Computing in Object-Oriented Parallel Environments (ISCOPE'97), </title> <booktitle> Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Here, we discuss an important performance problem: 1. Software Issues in Validated ODE Solving 17 the pairwise evaluation of arithmetic expression with arguments of array types (e.g., matrices and vectors). More detailed treatment of this and other problems can be found in [Rob96], [Vel97], and <ref> [VJ97] </ref>. In C++, executing overloaded arithmetic operations with array data types creates temporaries, which can introduce a significant overhead, particularly for small objects. <p> Furthermore, this execution introduces three loops. Clearly, it would be better to compute this sum in one loop without temporaries. In Fortran 90, mathematical arrays are represented as elementary types and optimization is possible at the compiler level. Because of better optimizing compilers and template techniques [Vel95], <ref> [VJ97] </ref>, C++ is becoming more competitive for scientific computing. A good technique for reducing the overhead in the pairwise evaluation of expressions involving arrays is to use expression templates [Vel95]. The expression template technique is based on performing compile-time transformation of the code using templates.
Reference: [Wan77] <author> G. Wanner. </author> <title> On the integration of stiff differential equations. In Proceedings of the Colloquium on Numerical Analysis, </title> <journal> volume 37 of Internat. Ser. Numer. Math., </journal> <pages> pages 209-226, </pages> <address> Basel, 1977. </address> <publisher> Birkhauser. </publisher>
Reference-contexts: It can be shown that q X (1) i c i h i p X c i h i + (1) q q!p! h j f [k] (y; t j ; t j+1 ) (1.24) <ref> [Wan77] </ref>, [Ned99]. This formula is the basis of our IHO method. The method we propose in [Ned99] consists of two phases, which can be considered as a predictor and a corrector.
Reference: [YC96] <author> Wenhong Yang and George Corliss. </author> <title> Bibliography of computational differentiation. </title> <editor> In Martin Berz, Christian H. Bischof, George F. Corliss, and Andreas Griewank, editors, </editor> <title> Computational Differentiation: Techniques, </title> <booktitle> Applications, and Tools, </booktitle> <pages> pages 393-418. </pages> <publisher> SIAM, </publisher> <address> Philadelphia, Penn., </address> <year> 1996. </year>
Reference-contexts: In this section, we address each of these considerations in turn. 1.8.1 Software for Automatic Generation of Interval Taylor Coefficients Although packages for automatic differentiation (AD) are available (see for example [Jue91] and <ref> [YC96] </ref>), to date, only two free packages for automatic generation of interval Taylor coefficients for the solution of an ODE and the Jacobians of these coefficients are known to the authors. These are the FADBAD/TADIFF [BS96], [BS97] and IADOL-C [Iwa97] packages.
References-found: 50

