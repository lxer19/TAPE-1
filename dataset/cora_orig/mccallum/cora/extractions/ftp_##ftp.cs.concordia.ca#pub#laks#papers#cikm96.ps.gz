URL: ftp://ftp.cs.concordia.ca/pub/laks/papers/cikm96.ps.gz
Refering-URL: http://www.cs.concordia.ca/~faculty/laks/papers.html
Root-URL: http://www.cs.concordia.ca
Email: alanoly@cs.concordia.ca  laks@cs.concordia.ca  shiri@cs.concordia.ca  subbu@cs.concordia.ca  
Title: On Implementing SchemaLog A Database Programming Language  
Author: Alanoly J. Andrews Laks V.S. Lakshmanan Nematollaah Shiri Iyer N. Subramanian 
Address: Montreal, Canada  Montreal, Canada  Montreal, Canada  Montreal, Canada  
Affiliation: Concordia University,  Concordia University,  Concordia University,  Concordia University,  
Abstract: Efficient implementation of advanced database programming languages call for investigating novel architectures and algorithms. In this paper, we discuss our implementation of SchemaLog, a logic-based database programming language, capable of offering a powerful platform for a variety of database applications involving data/meta-data querying and restructuring. Our architecture for the implementation is based on compiling SchemaLog constructs into an extended version of relational algebra called SchemaLog. Based on this algebra, we develop a top-down algorithm for evaluating SchemaLog programs. We discuss three alternative storage structures for the implementation and study their effect on the efficiency of implementation. For each storage structure, we propose strategies for implementing our algebraic operators. We have implemented all these strategies on top of Microsoft Access DBMS running on Windows 3.1, and have run an extensive set of experiments for evaluating the efficiency of alternative strategies under a varied mix of querying and restructuring operations. We discuss the results of our experiments and conclude with a discussion of a graphic user interface for SchemaLog program development, that has also been implemented. 
Abstract-found: 1
Intro-found: 1
Reference: [AG87] <author> Abiteboul, S. and Grumbach, S. Col: </author> <title> A logic-based language for complex objects. </title> <booktitle> In Proc. of Workshop on Database Programming Languages </booktitle>
Reference-contexts: SchemaLog has a higher-order syntax, but unlike some of the previous languages like COL <ref> [AG87] </ref>, LDL [Chi89], etc, and like HiLog [CKW93] and (a fragment of) F-logic [KLW95], SchemaLog has a first-order semantics. Indeed, it has a sound and complete proof theory [LSS96].
Reference: [ALSS96] <author> Andrews, Alanoly J., Lakshmanan, Laks V.S., Shiri, Nematollaah, and Subramanian, Iyer N. </author> <title> On implementing advanced database programming languages. </title> <type> Technical Report TR-DB-96-04, </type> <institution> Con-cordia University, </institution> <address> Montreal, Quebec, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: Conclusions and a comparison with some related implementations are given in Section 7. For lack of space, details of some of our algorithms as well as many additional examples illustrating features of SchemaLog and the extended algebra are not included in this paper. Readers may refer to <ref> [ALSS96] </ref> for the details. 2 Algebra Our approach to the implementation of SchemaLog is based on compiling constructs in SchemaLog into corresponding operations in an extended version of relational algebra, called Schema Algebra, or SA for short. <p> An important consequence of the fact that SchemaLog unification is performed on atoms is that we need to `atomize' a SchemaLog program (which in general might contain molecules) before applying the top-down algorithm.We refer the reader to <ref> [ALSS96] </ref> for the details of the algorithm for atomization. The major strength of SchemaLog lies in its ability to express novel querying as well as powerful restructuring operations. Our adaptation of the classical RGT evaluation algorithm accounts for these unique features of SchemaLog . <p> Our adaptation of the classical RGT evaluation algorithm accounts for these unique features of SchemaLog . In the following, we sketch the major issues that arise in the development of such an algorithm. In <ref> [ALSS96] </ref>, we present a comprehensive algorithm for the RGT evaluation of a SchemaLog program and establish its correctness. <p> In this section, we outline three alternative storage structures at the level of physical schemas. We also discuss the implementation of SA operators corresponding to each of them. For lack of space, we discuss only some of the implementation algorithms. The rest can be found in <ref> [ALSS96] </ref>. Before we present the alternative storage structures, we remark that for existing (i.e. base) database relations, it is unrealistic to suppose that they can be converted into any form other than their existing form. For one thing, such a conversion would incur a massive overhead. <p> For lack of space we do not include here all the charts illustrating the results of our experiments. Figures 3 and 4 may be considered as representatives. A more comprehensive set of charts is included in <ref> [ALSS96] </ref>. 5.1 Experimental Results: Individual Operations In this experiment, we studied the cost of implementing each of the SA operations.
Reference: [CCS95] <author> Codd, E.F., Codd, </author> <title> S.B., and Salley C.T. Providing olap (on-line analytical processing) to user-analysts, </title> <note> 1995. White paper URL: http://www.arborsoft.com/papers/coddTOC.html. </note>
Reference: [Chi89] <editor> Chimenti, D. et al. </editor> <title> The ldl system prototype. </title> <journal> IEEE TKDE, </journal> <volume> 2(1) </volume> <pages> 76-90, </pages> <year> 1989. </year>
Reference-contexts: SchemaLog has a higher-order syntax, but unlike some of the previous languages like COL [AG87], LDL <ref> [Chi89] </ref>, etc, and like HiLog [CKW93] and (a fragment of) F-logic [KLW95], SchemaLog has a first-order semantics. Indeed, it has a sound and complete proof theory [LSS96].
Reference: [CKW89] <author> Chen, W., Kifer, M., and Warren, </author> <title> D.S. Hilog as a platform for database language. </title> <booktitle> In 2nd Intl. Workshop on Database Programming Languages, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: be used in a real database context. (ii) implementation of Gulog, an object-oriented logic developed at Griffith University, Australia [Dob95]; [Lef93]'s implementation bootstraps on the implementation of the F-logic interpreter above and inherits its limitations. (iii) implementation of HiLog, a higher-order database logic programming language developed at SUNY, Stony Brook <ref> [CKW89] </ref>. [SW95] describes an efficient implementation of HiLog within the WAM (Warren Abstract Machine) and is based on using a first-order translation of HiLog. For a comparison of the languages themselves, interested readers are referred to [LSS96].
Reference: [CKW93] <author> Chen, W., Kifer, M., and Warren, </author> <title> D.S. Hilog: A foundation for higher-order logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 15(3), </volume> <year> 1993. </year>
Reference-contexts: SchemaLog has a higher-order syntax, but unlike some of the previous languages like COL [AG87], LDL [Chi89], etc, and like HiLog <ref> [CKW93] </ref> and (a fragment of) F-logic [KLW95], SchemaLog has a first-order semantics. Indeed, it has a sound and complete proof theory [LSS96].
Reference: [Dob95] <author> Dobbie, Gillian. </author> <title> Foundations of deductive object-oriented database systems. </title> <type> Phd dissertation, </type> <institution> Univ. of Melbourne, </institution> <address> Parkville, Australia, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: F-logic [KLW95], one of the most comprehensive logical accounts for the object-oriented model; [Law93]'s implementation is useful for running small F-logic programs, but it is not clear how this can 323 be used in a real database context. (ii) implementation of Gulog, an object-oriented logic developed at Griffith University, Australia <ref> [Dob95] </ref>; [Lef93]'s implementation bootstraps on the implementation of the F-logic interpreter above and inherits its limitations. (iii) implementation of HiLog, a higher-order database logic programming language developed at SUNY, Stony Brook [CKW89]. [SW95] describes an efficient implementation of HiLog within the WAM (Warren Abstract Machine) and is based on using a
Reference: [GBLP96] <author> Gray, J., Bosworth, A., Layman, A., and Pira-hesh H. </author> <title> Data cube: A relational aggregation operator generalizing group-by, </title> <booktitle> cross-tab, and sub-totals. In Proceedings of the 12th ICDE,1996. </booktitle>
Reference: [KLW95] <author> Kifer, M., Lausen, G, and Wu, J. </author> <title> Logical foundations for object-oriented and frame-based languages. </title> <journal> Journal of ACM, </journal> <month> May </month> <year> 1995. </year>
Reference-contexts: SchemaLog has a higher-order syntax, but unlike some of the previous languages like COL [AG87], LDL [Chi89], etc, and like HiLog [CKW93] and (a fragment of) F-logic <ref> [KLW95] </ref>, SchemaLog has a first-order semantics. Indeed, it has a sound and complete proof theory [LSS96]. <p> We specifically consider three such implementations: (i) implementation of F-logic <ref> [KLW95] </ref>, one of the most comprehensive logical accounts for the object-oriented model; [Law93]'s implementation is useful for running small F-logic programs, but it is not clear how this can 323 be used in a real database context. (ii) implementation of Gulog, an object-oriented logic developed at Griffith University, Australia [Dob95]; [Lef93]'s
Reference: [Law93] <author> Lawley, M. J. </author> <title> A prolog interpreter for F-logic. </title> <type> Technical report, </type> <institution> Griffith University, </institution> <year> 1993. </year>
Reference: [Lef93] <author> Lefebvre, Alexandre. </author> <title> Implementing an object-oriented database system using a deductive database system. </title> <type> Technical report, </type> <institution> Griffith University, </institution> <month> April </month> <year> 1993. </year>
Reference: [LSPS95] <author> Lakshmanan, L.V.S., Subramanian, I. N., Pa-poulis, Despina, and Shiri, Nematollaah. </author> <title> A declarative system for multi-database interoperability. </title> <booktitle> In Proc. of the 4th Intl. Conf. on Algebraic Methodology and Software Technology (AMAST), </booktitle> <address> Montreal, </address> <month> July </month> <year> 1995. </year> <note> Springer-Verlag. Tools Demo. </note>
Reference-contexts: A prototype fl This research was supported in part by grants from the Natural Sciences and Engineering Research Council of Canada and the Fonds Pour Formation De Chercheurs Et L'Aide A La Recherche of Quebec. platform for interoperability among a number of INGRES databases was completed recently <ref> [LSPS95] </ref>, based on a fragment of SchemaLog. The theoretical basis for the use of SchemaLog as a powerful database programming language even in the context of a single database was established in our earlier papers. <p> Our discussion is based on a system we have developed in the context of a prototype platform for interoperability based on a fragment of SchemaLog <ref> [LSPS95] </ref>. We have designed and implemented the UI using the UIM/X interface development toolkit [Vis93]. <p> From practical considerations and from the experiments, a viable approach seems to be to use conventional storage for existing database relations and reduced storage for derived database relations. An implementation of SchemaLog for multi-database interoperability among several INGRES databases is described in <ref> [LSPS95] </ref> and a standalone implementation of SchemaLog is in progress.
Reference: [LSS93] <author> Lakshmanan, L.V.S., Sadri, F., and Subramanian, I. N. </author> <title> On the logical foundations of schema integration and evolution in heterogeneous database systems. </title> <booktitle> In Proc. 3rd International Conference on Deductive and Object-Oriented Databases (DOOD '93). </booktitle> <publisher> Springer-Verlag, </publisher> <address> LNCS-760, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: 1 Introduction This paper reports on our implementation of SchemaLog, a powerful language for advanced database logic programming proposed by Lakshmanan et al. <ref> [LSS93, LSS96] </ref>. It was established there that SchemaLog can offer a powerful platform in a variety of settings including multi-database interoperability, database programming with schema browsing, cooperative query answering, computing forms of aggregate queries which are beyond the scope of conventional database query languages, and database restructuring.
Reference: [LSS96] <author> Lakshmanan, L.V.S., Sadri, F., and Subramanian, I. N. </author> <title> Logic and algebraic languages for interoperability in multidatabase systems. </title> <type> Technical report, </type> <institution> Concordia University, Montreal, </institution> <month> Feb </month> <year> 1996. </year> <note> Accepted to the Journal of Logic Programming. </note>
Reference-contexts: 1 Introduction This paper reports on our implementation of SchemaLog, a powerful language for advanced database logic programming proposed by Lakshmanan et al. <ref> [LSS93, LSS96] </ref>. It was established there that SchemaLog can offer a powerful platform in a variety of settings including multi-database interoperability, database programming with schema browsing, cooperative query answering, computing forms of aggregate queries which are beyond the scope of conventional database query languages, and database restructuring. <p> SchemaLog has a higher-order syntax, but unlike some of the previous languages like COL [AG87], LDL [Chi89], etc, and like HiLog [CKW93] and (a fragment of) F-logic [KLW95], SchemaLog has a first-order semantics. Indeed, it has a sound and complete proof theory <ref> [LSS96] </ref>. <p> In the following, we introduce the syntax of SchemaLog and illustrate the semantics informally via examples. The syntax we will use is an adaptation of the full SchemaLog given in <ref> [LSS96] </ref> to a single database context. For a formal account, the reader is referred to [LSS96]. SchemaLog features three 1 kinds of basic expressions, called atoms. <p> In the following, we introduce the syntax of SchemaLog and illustrate the semantics informally via examples. The syntax we will use is an adaptation of the full SchemaLog given in <ref> [LSS96] </ref> to a single database context. For a formal account, the reader is referred to [LSS96]. SchemaLog features three 1 kinds of basic expressions, called atoms. <p> The term database relations refers to relations corresponding to database predicates, while programming relations refer to relations corresponding to programming predicates. When no confusion arises, we refer to database relations, simply as relations. <ref> [LSS96] </ref> provides a number of examples to illustrate the semantics of SchemaLog programs, and the various terminologies and conventions introduced above. For lack of space, we provide just one example in this section. <p> Operators of type (2) and (3) are new and are unique to our algebra. In principle, our algebra can well be defined in the context of a federation of databases. Indeed, operations of type 1 and 2 were defined in such a context in <ref> [LSS96] </ref> and it was proved that they have an expressive power equivalent to that of SchemaLog programs containing only programming predicates in rule heads. <p> Notice that no output corresponding to hp is produced since hp does not correspond to any relation name in the database. Before presenting the definition of our next operator, we need the notion of a pattern, introduced in <ref> [LSS96] </ref> in a different context. A pattern is of one of the following forms: `a!v 0 ; `a! 0 ; `!v 0 , or `! 0 . <p> At the guts of the algorithm we discuss here, lie the SA operators defined in the previous section. The notion of unification plays an important role in the construction of RGTs. Unification in SchemaLog is different from its classical counterpart. <ref> [LSS96] </ref> discusses this issue at depth and presents an algorithm for computing the most general unifier (mgu) of two SchemaLog atoms. Based on the SchemaLog notion of unification, the conventional algorithm for constructing the RGT of a program can be easily adapted to our setting. <p> For one thing, such a conversion would incur a massive overhead. For another, this would disrupt applications running on the existing database. <ref> [LSS96] </ref> discusses these issues in detail and argues that from a practical perspective, the base relations should be preserved in their existing form. Thus, we are really considering alternative storage structures for database relations which are created or derived by SchemaLog programs. 1. <p> By contrast, conventional storage is not particularly suited for meta-data querying and restructuring. Thus, we expect the new strategies proposed (see below) to perform better for such operations. 2. Reduced Storage: The term reduced refers to the fact that SchemaLog admits a faithful first-order reduction, as established in <ref> [LSS96] </ref>. <p> For a comparison of the languages themselves, interested readers are referred to <ref> [LSS96] </ref>. In contrast with all the above implementations, our implementation of SchemaLog has the following unique features. (1) It is not based on translation into any other language like Prolog. Rather, our implementation is a direct one. (2) Schema Algebra is at the core of our implementation.
Reference: [RSS92] <author> Ramakrishnan, R., Srivastava, D., and Sudarshan, S. </author> <title> Coral: Control, relations, </title> <booktitle> and logic. In Proc. Int. Conf. on Very Large Databases, </booktitle> <year> 1992. </year>
Reference-contexts: Interestingly, the schema browsing capability in the UI is realized using an underlying SchemaLog program. (2) Ad hoc querying: The implementation of the SchemaLog system uses CORAL <ref> [RSS92] </ref> as a back-end. Our UI exploits the ad hoc querying features of CORAL by providing querying window widgets in the interface. The use of CORAL, however, is hidden from the user.
Reference: [SW95] <author> Sagonas, Konstantinos and Warren, David S. </author> <title> Efficient execution of hilog in wam-based prolog implementations. </title> <type> Technical report, </type> <institution> Depertment of Comp. Sc., SUNY, Stony Brook, </institution> <address> NY 11794-4400, </address> <year> 1995. </year>
Reference-contexts: used in a real database context. (ii) implementation of Gulog, an object-oriented logic developed at Griffith University, Australia [Dob95]; [Lef93]'s implementation bootstraps on the implementation of the F-logic interpreter above and inherits its limitations. (iii) implementation of HiLog, a higher-order database logic programming language developed at SUNY, Stony Brook [CKW89]. <ref> [SW95] </ref> describes an efficient implementation of HiLog within the WAM (Warren Abstract Machine) and is based on using a first-order translation of HiLog. For a comparison of the languages themselves, interested readers are referred to [LSS96].
Reference: [Ull89] <author> Ullman, J.D. </author> <title> Principles of Database and Knowledge-Base Systems, volume II. </title> <publisher> Computer Science Press, </publisher> <address> Maryland, </address> <year> 1989. </year>
Reference-contexts: Note that oe $1=`r 0 denotes classical selection <ref> [Ull89] </ref>. E.g., let s = f (close; date); (close; ibm), (close; msf t); (close; xon); (volume; date); (volume; ibm); (volume, msf t); (volume; xon)g. Then & 1;2 (r) will create two relations close and volume both with the schema fdate; ibm; msof t; xong, and with no data. <p> In particular, we investigate how the set oriented Rule/Goal Tree (RGT) evaluation method <ref> [Ull89] </ref> proposed for classical logic can be extended to the SchemaLog setting. Our choice of this methodology is due to the fact that set-oriented query processing techniques are more suitable for database applications as opposed to the tuple-at-a-time paradigm of Prolog. <p> For datalog, this switching between argument and variable viewpoints is accomplished by means of procedures called a2v () and v2a () <ref> [Ull89] </ref>. As SchemaLog atoms are syntactically different from their classical counterpart, the a2v () and v2a () procedures are somewhat different for our setting.
Reference: [Vis93] <institution> Visual Edge Software Ltd., St-Laurent, Quebec, Canada. </institution> <note> The UIM/X Developer's Guide, 1993. 324 </note>
Reference-contexts: Our discussion is based on a system we have developed in the context of a prototype platform for interoperability based on a fragment of SchemaLog [LSPS95]. We have designed and implemented the UI using the UIM/X interface development toolkit <ref> [Vis93] </ref>. Aside from the usual text editor, file selection box, and related facilities for preparing SchemaLog programs, the other features of the UI are as follows. (1) Schema browsing: Our system provides a natural navigation of the schema hierarchy.
References-found: 18

