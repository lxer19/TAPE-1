URL: http://http.cs.berkeley.edu/~twagner/glr.ps
Refering-URL: http://http.cs.berkeley.edu/~twagner/index.html
Root-URL: http://www.cs.berkeley.edu
Title: Incremental Analysis of Real Programming Languages  
Author: Tim A. Wagner and Susan L. Graham 
Address: Berkeley  
Affiliation: University of California,  
Abstract: A major research goal for compilers and environments is the automatic derivation of tools from formal specifications. However, the formal model of the language is often inadequate; in particular, LR(k) grammars are unable to describe the natural syntax of many languages, such as C ++ and Fortran, which are inherently non-deterministic. Designers of batch compilers work around such limitations by combining generated components with ad hoc techniques (for instance, performing partial type and scope analysis in tandem with parsing). Unfortunately, the complexity of incremental systems precludes the use of batch solutions. The inability to generate incremental tools for important languages inhibits the widespread use of language-rich interactive environments. We address this problem by extending the language model itself, introducing a program representation based on parse dags that is suitable for both batch and incremental analysis. Ambiguities unresolved by one stage are retained in this representation until further stages can complete the analysis, even if the resolution depends on further actions by the user. Representing ambiguity explicitly increases the number and variety of languages that can be analyzed incrementally using existing methods. To create this representation, we have developed an efficient incremental parser for general context-free grammars. Our algorithm combines Tomita's generalized LR parser with reuse of entire subtrees via state-matching. Disambiguation can occur statically, during or after parsing, or during semantic analysis (using existing incremental techniques); program errors that preclude disambiguation retain multiple interpretations indefinitely. Our representation and analyses gain efficiency by exploiting the local nature of ambiguities: for the SPEC95 C programs, the explicit representation of ambiguity requires only 0.5% additional space and less than 1% additional time during reconstruction. fl This research has been sponsored in part by the Defense Advanced Research Projects Agency (DARPA) under Grant MDA972-92-J-1028. The content of this paper does not necessarily reflect the position or policy of the U. S. Government. Authors' addresses: Tim A. Wagner, 573 Soda Hall and Susan L. Graham, 771 Soda Hall; Department of EECS, Computer Science Division, University of California, Berkeley, CA 94720-1776. email: twagner@cs.berkeley.edu, graham@cs.berkeley.edu URL: http://http.cs.berkeley.edu/ twagner, http://http.cs.berkeley.edu/ graham.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, S. C. Johnson, and J. D. Ullman. </author> <title> Deterministic parsing of ambiguous grammars. </title> <journal> Commun. ACM, </journal> <volume> 18(8) </volume> <pages> 441-452, </pages> <month> Aug. </month> <year> 1975. </year>
Reference-contexts: We describe mechanisms for applying both types of resolution using existing formal techniques, such as attribute grammars, while also permitting ad hoc resolution. Pre-compiled filters such as precedence and associativity declarations in yacc <ref> [1] </ref> are supported in a uniform fashion. In the presence of missing or malformed program text, multiple interpretations may be retained indefinitely as a direct expression of the possibilities. We have developed a novel algorithm for incremental, non-deterministic parsing to (re)construct this IR. <p> Examples include the operator precedence and associativity specifications in yacc and bison <ref> [1] </ref> as well as techniques associated with a particular parse table construction algorithm, such as prefer shifting. Such methods can be applied at language specification time by selectively removing conflicts from the parse table, and therefore do not result in non-deterministic parsing or multiple representations.
Reference: [2] <author> J. Earley. </author> <title> An efficient context-free parsing algorithm. </title> <journal> Com-mun. ACM, </journal> <volume> 13(2) </volume> <pages> 94-102, </pages> <month> Feb. </month> <year> 1970. </year>
Reference-contexts: of each syntactically ambiguous con 3 Even with GLR parsing, some erasing of concrete elements unnecessary for the abstract structure, such as parentheses, is often done. 4 This property was indirectly measured by Tomita [22] and Rekers [20], who compared the speed of a batch GLR parser to Earley's algorithm <ref> [2] </ref> on natural and programming language grammars, respectively. Both authors concluded that grammars are `close' to LR (1) in practice, and therefore GLR parsing exhibits linear behavior despite its exponential worst-case asymptotic result. histogram groups the source files of gcc according to the amount of syntactic ambiguity they possess.
Reference: [3] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C ++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year> <institution> Sect. 6.8, 8.1.1. </institution>
Reference-contexts: int j; a (b); ambiguouscould be c (d); decls or stmts. i = 1; - case, type information is necessary for disambiguation: the middle two lines can be either declarations or function calls, depending on how a and c have been declared previously in enclosing scopes. guity in C ++ <ref> [3] </ref> and the `off-side' rule in Haskell [7]. We describe mechanisms for applying both types of resolution using existing formal techniques, such as attribute grammars, while also permitting ad hoc resolution. Pre-compiled filters such as precedence and associativity declarations in yacc [1] are supported in a uniform fashion. <p> For example, the syntactic ambiguity in C ++ expressed as prefer a declaration to an expression requires a dynamic filter, since competing reductions cannot be delayed until sufficient looka-head has been accumulated <ref> [3] </ref>.
Reference: [4] <author> M. V. Ferro and B. A. Dion. </author> <title> Efficient incremental parsing for context-free languages. </title> <booktitle> In Proc. 1994 IEEE Intl. Conf. Comp. Lang., </booktitle> <pages> pages 241-252. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: minimizes the work of subsequent analysis passes. (Together they also ensure the preservation of user context and program annotations.) Lookahead information is dynamically tracked and encoded in parsing states stored in the nodes, eliminating the space overhead of previous approaches that require persistent maintenance of the entire graph-structured parse stack <ref> [4] </ref>. As an example of an inherent context-free syntax ambiguity addressed by this representation, consider the syntax of C. <p> The correctness of incremental GLR parsing can then be established by an induction over the input stream. Our approach differs significantly from the nondeterministic PDA simulator of Ferro and Dion <ref> [4] </ref>, which uses the GSS itself as the persistent representation of the program. <p> Unlike Ferro and Dion <ref> [4] </ref>, we do not retain interpretations eliminated by syntactic filters. In general, disambiguation specifications [6, 11] can be compiled into a combination of static and dynamic filters.
Reference: [5] <author> Robert Giegerich. </author> <title> Considerate code selection. </title> <editor> In Robert Giegerich and Susan L. Graham, editors, </editor> <title> Code Generation Concepts, Tools, Techniques., </title> <booktitle> Workshops in Computing, </booktitle> <pages> pages 51-65, </pages> <address> Berlin, May 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Visser [24] makes this integration explicit for a batch system by using a single GLR parser for both lexical and context-free analysis. This approach can be made incremental using the techniques we describe. Code generation also benefits from retaining multiple representations until additional information has been gathered. Giegerich <ref> [5] </ref> applies context-sharing in this domain to intersperse code selection and register allocation. We have measured the space costs of our representation and the time overhead to rebuild it incrementally using a benchmark suite that includes both C ++ programs and the C programs in SPEC95.
Reference: [6] <author> J. Heering, P. R. H. Hendriks, P. Klint, and J. Rekers. </author> <title> The syntax definition formalism SDF Reference Manual, </title> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: Unlike Ferro and Dion [4], we do not retain interpretations eliminated by syntactic filters. In general, disambiguation specifications <ref> [6, 11] </ref> can be compiled into a combination of static and dynamic filters.
Reference: [7] <editor> Paul Hudak et al. </editor> <title> Haskell report. SIGPLAN Not., </title> <address> 27(5):R, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: (d); decls or stmts. i = 1; - case, type information is necessary for disambiguation: the middle two lines can be either declarations or function calls, depending on how a and c have been declared previously in enclosing scopes. guity in C ++ [3] and the `off-side' rule in Haskell <ref> [7] </ref>. We describe mechanisms for applying both types of resolution using existing formal techniques, such as attribute grammars, while also permitting ad hoc resolution. Pre-compiled filters such as precedence and associativity declarations in yacc [1] are supported in a uniform fashion.
Reference: [8] <author> Fahimeh Jalili and Jean H. Gallier. </author> <title> Building friendly parsers. </title> <booktitle> In 9th ACM Symp. Principles of Prog. Lang., </booktitle> <pages> pages 196-206, </pages> <address> New York, 1982. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The parser accepts all context-free grammars: generalized LR parsing [20, 22] is used to support non-determinism and ambiguity, eliminating restrictions on the parsing grammar and the attendant need for abstraction services. Shifting of entire subtrees via state-matching <ref> [8] </ref> provides efficient incremental behavior, and explicit node retention [25] minimizes the work of subsequent analysis passes. (Together they also ensure the preservation of user context and program annotations.) Lookahead information is dynamically tracked and encoded in parsing states stored in the nodes, eliminating the space overhead of previous approaches that <p> However, sentential-form parsing cannot be used as the basis for a non-deterministic incremental parser with conventional table construction: the stronger test of state-matching is needed to expose the possibility of non-deterministic splitting when shifting an otherwise valid subtree. In a state-matching implementation <ref> [8, 14] </ref>, each node representing a nonterminal symbol contains a record of the configuration of the pushdown automaton (the `parse state' ) when the node was shifted onto the stack.
Reference: [9] <author> Mark Johnson. </author> <title> The computational complexity of GLR parsing. </title> <editor> In Masaru Tomita, editor, </editor> <booktitle> Generalized LR Parsing, </booktitle> <pages> pages 35-42. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: single, shared list of reused nodes; maintaining separate lists when multiple parsers are active imposes a performance and complexity cost for minimal gain in the number of reused nodes.) 3.4 Asymptotic Analysis The IGLR parsing algorithm works for any context-free grammar and, like GLR parsing, is exponential in the worst-case <ref> [9] </ref> but linear on actual programming language grammars. To ensure incremental performance that improves on batch parsing, we need to impose some additional restrictions on both the grammar and the representation of the abstract parse dag.
Reference: [10] <author> Neil D. Jones and Michael Madsen. </author> <title> Attribute-influenced LR parsing. </title> <editor> In U. D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, number 94 in LNCS, </booktitle> <pages> pages 393-407, </pages> <address> Berlin, 1980. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Attribute-influenced parsing <ref> [10, 21] </ref> is a combination of LR parsing and a restricted class of attribute grammars that addresses the same problem in a formal way.
Reference: [11] <author> Paul Klint and Eelco Visser. </author> <title> Using filters for the disambiguation of context-free grammars. </title> <booktitle> In Proc. ASMICS Workshop on Parsing Theory, </booktitle> <address> Milan, Italy, </address> <year> 1994. </year>
Reference-contexts: The familiar pass-oriented compiler organization is supported, even in incremental settings, by allowing ambiguities to be resolved at different stages of the analysis. Semantic filters address the `feedback' problem (syntactic structure dependent upon semantic information) arising in C and Fortran. Parsing filters <ref> [11] </ref> address such problems as the declaration/expression ambi int foo () - int j; a (b); ambiguouscould be c (d); decls or stmts. i = 1; - case, type information is necessary for disambiguation: the middle two lines can be either declarations or function calls, depending on how a and c <p> Unlike Ferro and Dion [4], we do not retain interpretations eliminated by syntactic filters. In general, disambiguation specifications <ref> [6, 11] </ref> can be compiled into a combination of static and dynamic filters.
Reference: [12] <author> Wilf R. LaLonde. </author> <title> Regular right part grammars and their parsers. </title> <journal> Commun. ACM, </journal> 20(10) 731-740, 1977. 
Reference-contexts: To address this problem, we represent associative operators in the abstract parse dag as balanced binary trees. An obvious way to indicate the freedom to choose a balanced representation for associative sequences is to describe the syntax of the language using an extended context-free (regular right part) grammar <ref> [12] </ref>. We thus use the grammar both to specify the syntax of the language and to describe declaratively the representation of the resulting abstract parse dag.
Reference: [13] <author> Marc Lankhorst. </author> <title> An empirical comparison of generalized LR tables. </title> <editor> In R. Heemels, A. Nijholt, and K. Sikkel, editors, </editor> <title> Tomita's Algorithm: Extensions and Applications (TWLT1), </title> <booktitle> number 91-68 of Memoranda Informatica in Twente Workshops on Language Technology, </booktitle> <pages> pages 87-93. </pages> <address> Universeit Twente, </address> <year> 1991. </year>
Reference-contexts: LALR (1) tables are used to drive the parser: not only are they significantly smaller than LR (1) tables, but they also yield faster parsing speeds in non-deterministic regions <ref> [13] </ref> and improved incremental reuse in deterministic regions (due to the merging of states with like cores). 5 Left context checks involve the same integer comparison used by a deterministic state-matching incremental parser.
Reference: [14] <author> J. M. Larcheveque. </author> <title> Optimal incremental parsing. </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <volume> 17(1) </volume> <pages> 1-15, </pages> <year> 1995. </year>
Reference-contexts: However, sentential-form parsing cannot be used as the basis for a non-deterministic incremental parser with conventional table construction: the stronger test of state-matching is needed to expose the possibility of non-deterministic splitting when shifting an otherwise valid subtree. In a state-matching implementation <ref> [8, 14] </ref>, each node representing a nonterminal symbol contains a record of the configuration of the pushdown automaton (the `parse state' ) when the node was shifted onto the stack. <p> As with deterministic parsing, IGLR parsing can be extended to retain existing program structure through node reuse <ref> [14, 19, 25] </ref>.
Reference: [15] <author> Maryellen C. MacDonald, Marcel Adam Just, and Patricia A. Carpenter. </author> <title> Working memory constraints on the processing of syntactic ambiguity. Cog. </title> <journal> Psych., </journal> <volume> 24(1) </volume> <pages> 56-98, </pages> <year> 1992. </year>
Reference-contexts: We return to issues of sharing in Section 3.5 after explaining incremental GLR parsing. 2.1 Space Overhead for Ambiguity Cognitive studies suggest that localization of ambiguity is an inherent property of natural languages, a constraint imposed by limitations on short-term memory <ref> [15, 17] </ref>.
Reference: [16] <author> William Maddox. </author> <title> Incremental Static Semantic Analysis. </title> <type> Ph.D. dissertation, </type> <institution> University of California, Berkeley, </institution> <year> 1997. </year>
Reference-contexts: In the incremental case, each stage inspects or updates only those portions of the program that have changed or could possibly be affected by preceding changes <ref> [16] </ref>. An interesting case occurs when a typedef declaration is removed: Binding information stored in semantic attributes allows the former uses of the declaration to be efficiently located.
Reference: [17] <author> Akira Miyake, Marcel Adam Just, and Patricia A. Carpenter. </author> <title> Working memory constraints on the resolution of lexical ambiguity: Maintaining multiple interpretations in neutral contexts. </title> <journal> J. Memory and Lang., </journal> <volume> 33(2) </volume> <pages> 175-202, </pages> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: We return to issues of sharing in Section 3.5 after explaining incremental GLR parsing. 2.1 Space Overhead for Ambiguity Cognitive studies suggest that localization of ambiguity is an inherent property of natural languages, a constraint imposed by limitations on short-term memory <ref> [15, 17] </ref>.
Reference: [18] <author> R. Nozohoor-Farshi. </author> <title> GLR parsing for *-grammars. </title> <editor> In Masaru Tomita, editor, </editor> <booktitle> Generalized LR Parsing, </booktitle> <pages> pages 61-75. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: We introduce a performance model to analyze the asymptotic behavior of the parser, and conclude the section by proving that sharing in the abstract parse dag is both optimal and correct. The algorithm itself appears in Appendix A. 3.1 Generalized LR Parsing Batch GLR parsing <ref> [18, 20, 22] </ref> is a technique for parsing arbitrary context-free grammars that utilizes conventional LR table construction methods. Unlike deterministic parsers, however, a GLR parser permits these tables to contain conflicts: when a state transition is multiply-defined, the GLR parser simply forks multiple parsers to follow each possibility. <p> In most cases, non-determinism for dynamic lookahead results in deterministic (and unshared) structure in the parse tree, since unsuccessful parses eventually terminate. In the GSS, however, sharing needed to handle certain types of grammars with *-productions results in sharing in the parse tree even for unambiguous grammars <ref> [18] </ref>.
Reference: [19] <author> Luigi Petrone. </author> <title> Reusing batch parsers as incremental parsers. </title> <booktitle> In Proc. 15th Conf. Foundations Softw. Tech. and Theor. Comput. Sci., number 1026 in LNCS, </booktitle> <pages> pages 111-123, </pages> <address> Berlin, Dec. 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: As with deterministic parsing, IGLR parsing can be extended to retain existing program structure through node reuse <ref> [14, 19, 25] </ref>.
Reference: [20] <author> Jan Rekers. </author> <title> Parser Generation for Interactive Environments. </title> <type> Ph.D. dissertation, </type> <institution> University of Amsterdam, </institution> <year> 1992. </year>
Reference-contexts: In the presence of missing or malformed program text, multiple interpretations may be retained indefinitely as a direct expression of the possibilities. We have developed a novel algorithm for incremental, non-deterministic parsing to (re)construct this IR. The parser accepts all context-free grammars: generalized LR parsing <ref> [20, 22] </ref> is used to support non-determinism and ambiguity, eliminating restrictions on the parsing grammar and the attendant need for abstraction services. <p> 1, we measured the increased space consumption required to represent the multiple interpretations of each syntactically ambiguous con 3 Even with GLR parsing, some erasing of concrete elements unnecessary for the abstract structure, such as parentheses, is often done. 4 This property was indirectly measured by Tomita [22] and Rekers <ref> [20] </ref>, who compared the speed of a batch GLR parser to Earley's algorithm [2] on natural and programming language grammars, respectively. <p> We introduce a performance model to analyze the asymptotic behavior of the parser, and conclude the section by proving that sharing in the abstract parse dag is both optimal and correct. The algorithm itself appears in Appendix A. 3.1 Generalized LR Parsing Batch GLR parsing <ref> [18, 20, 22] </ref> is a technique for parsing arbitrary context-free grammars that utilizes conventional LR table construction methods. Unlike deterministic parsers, however, a GLR parser permits these tables to contain conflicts: when a state transition is multiply-defined, the GLR parser simply forks multiple parsers to follow each possibility. <p> different parsers) due to left or right contextual restrictions. 6 Rekers corrects 6 This is the same effect that causes incremental deterministic parsers based on state-matching to fail to reuse subtrees as aggressively as sentential-form parsers [25]. under-sharing in his batch GLR parser by merging nodes that have identical yields <ref> [20] </ref>. Merging is performed separately for both symbol and `rule' (production) nodes. The same approach can be applied in our algorithm, since non-deterministic regions are reconstructed atomically. A different problem exhibited by GLR algorithms is over-sharing. <p> Encoding as much filtering as possible at language specification time decreases both the size of the representation and the analysis time. (This contrasts with existing batch GLR environments, which perform all syntactic filtering dynamically <ref> [20, 22] </ref>, and thus require quadratic space for each expression, in contrast to the negligible increases we report in Section 2.1.) 4.2 Semantic Disambiguation Filters for which the selection criteria are not context-free are referred to as `semantic' filters.
Reference: [21] <author> Masataka Sassa, Harushi Ishizuka, and Ikuo Nakata. </author> <title> Rie, a compiler generator based on a one-pass-type attribute grammar. </title> <journal> SoftwarePractice & Experience, </journal> <volume> 25(3) </volume> <pages> 229-250, </pages> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: Attribute-influenced parsing <ref> [10, 21] </ref> is a combination of LR parsing and a restricted class of attribute grammars that addresses the same problem in a formal way.
Reference: [22] <author> Masaru Tomita. </author> <title> Efficient Parsing for Natural Languages. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1985. </year>
Reference-contexts: In the presence of missing or malformed program text, multiple interpretations may be retained indefinitely as a direct expression of the possibilities. We have developed a novel algorithm for incremental, non-deterministic parsing to (re)construct this IR. The parser accepts all context-free grammars: generalized LR parsing <ref> [20, 22] </ref> is used to support non-determinism and ambiguity, eliminating restrictions on the parsing grammar and the attendant need for abstraction services. <p> programs in Table 1, we measured the increased space consumption required to represent the multiple interpretations of each syntactically ambiguous con 3 Even with GLR parsing, some erasing of concrete elements unnecessary for the abstract structure, such as parentheses, is often done. 4 This property was indirectly measured by Tomita <ref> [22] </ref> and Rekers [20], who compared the speed of a batch GLR parser to Earley's algorithm [2] on natural and programming language grammars, respectively. <p> We introduce a performance model to analyze the asymptotic behavior of the parser, and conclude the section by proving that sharing in the abstract parse dag is both optimal and correct. The algorithm itself appears in Appendix A. 3.1 Generalized LR Parsing Batch GLR parsing <ref> [18, 20, 22] </ref> is a technique for parsing arbitrary context-free grammars that utilizes conventional LR table construction methods. Unlike deterministic parsers, however, a GLR parser permits these tables to contain conflicts: when a state transition is multiply-defined, the GLR parser simply forks multiple parsers to follow each possibility. <p> The parse forest produced by GLR parsing results in both over- and under-sharing, complicating (in some cases precluding) the application of existing methods for semantic attribution and similar tools. GLR parsing as originally defined <ref> [22] </ref> results in under-sharing in the shared parse forest when isomorphic subtrees with the same yield are created in different states (i.e., by different parsers) due to left or right contextual restrictions. 6 Rekers corrects 6 This is the same effect that causes incremental deterministic parsers based on state-matching to fail <p> Encoding as much filtering as possible at language specification time decreases both the size of the representation and the analysis time. (This contrasts with existing batch GLR environments, which perform all syntactic filtering dynamically <ref> [20, 22] </ref>, and thus require quadratic space for each expression, in contrast to the negligible increases we report in Section 2.1.) 4.2 Semantic Disambiguation Filters for which the selection criteria are not context-free are referred to as `semantic' filters.
Reference: [23] <author> Eelco Visser. </author> <title> A case study in optimizing parsing schemata by disambiguation filters. </title> <type> Technical Report P9507, </type> <institution> Programming Research Group, University of Amsterdam, </institution> <month> Jul. </month> <year> 1995. </year>
Reference-contexts: Visser uses priorities and tree patterns to produce static filters <ref> [23] </ref>, but further work is needed. An integrated model of semantic attribution and dynamic (semantic) filters remains an open problem. It requires extending scheduling algorithms to dags, balancing the restrictions required for efficient static scheduling with sufficient expressive power to model disambiguation methods that arise in practice.
Reference: [24] <author> Eelco Visser. </author> <title> Scannerless generalized-LR parsing, </title> <note> 1997. In preparation. </note>
Reference-contexts: Encoding alternatives for later resolution is useful in a number of stages in the compilation pipeline. Lexical decisions are often deferred until parsing or semantic analysis by having the lexer recognize only equivalence classes of tokens. Visser <ref> [24] </ref> makes this integration explicit for a batch system by using a single GLR parser for both lexical and context-free analysis. This approach can be made incremental using the techniques we describe. Code generation also benefits from retaining multiple representations until additional information has been gathered.
Reference: [25] <author> Tim A. Wagner and Susan L. Graham. </author> <title> Efficient and flexible incremental parsing, </title> <note> 1996. Submitted to ACM Trans. </note> <institution> Program. Lang. Syst. </institution>
Reference-contexts: The parser accepts all context-free grammars: generalized LR parsing [20, 22] is used to support non-determinism and ambiguity, eliminating restrictions on the parsing grammar and the attendant need for abstraction services. Shifting of entire subtrees via state-matching [8] provides efficient incremental behavior, and explicit node retention <ref> [25] </ref> minimizes the work of subsequent analysis passes. (Together they also ensure the preservation of user context and program annotations.) Lookahead information is dynamically tracked and encoded in parsing states stored in the nodes, eliminating the space overhead of previous approaches that require persistent maintenance of the entire graph-structured parse stack <p> For LALR or LR grammars with all conflicts resolved at parse table construction time, sentential-form parsing is the better implementation method, since it requires less time and space than a state-matching algorithm <ref> [25] </ref>. However, sentential-form parsing cannot be used as the basis for a non-deterministic incremental parser with conventional table construction: the stronger test of state-matching is needed to expose the possibility of non-deterministic splitting when shifting an otherwise valid subtree. <p> As with deterministic parsing, IGLR parsing can be extended to retain existing program structure through node reuse <ref> [14, 19, 25] </ref>. <p> when isomorphic subtrees with the same yield are created in different states (i.e., by different parsers) due to left or right contextual restrictions. 6 Rekers corrects 6 This is the same effect that causes incremental deterministic parsers based on state-matching to fail to reuse subtrees as aggressively as sentential-form parsers <ref> [25] </ref>. under-sharing in his batch GLR parser by merging nodes that have identical yields [20]. Merging is performed separately for both symbol and `rule' (production) nodes. The same approach can be applied in our algorithm, since non-deterministic regions are reconstructed atomically. A different problem exhibited by GLR algorithms is over-sharing. <p> Since a unique maximal sharing of these subtrees does not necessarily exist, this is the only approach that is consistent, correct, and practical. Node reuse strategies can be used to prevent unnecessary recreation of these and other subtrees <ref> [25] </ref>. 4 Resolving Ambiguity The ultimate use of the abstract parse dag is to enable disambiguation once the needed information is available. This `filtering' of alternatives can be static (decided at language specification time) or dynamic (decided at program analysis time). Dynamic filtering can involve both syntactic and semantic information. <p> Existing language definitions include Java, Modula-2, Fortran, a subset of Lisp, and C (with limited preprocessor support). The IGLR parser has been implemented in this system as an alternative to the sentential-form parser used for deterministic grammars <ref> [25] </ref>. The IGLR implementation, which includes the parse table interface but not error recovery code, occupies less than 2000 lines of C ++ code, including all tracing and assertion checking. The actual implementation corresponds closely to the algorithm given in Appendix A.
Reference: [26] <author> Tim A. Wagner and Susan L. Graham. </author> <title> Efficient self-versioning documents. </title> <booktitle> In CompCon '97, </booktitle> <pages> pages 62-67. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> Feb. </month> <year> 1997. </year>
Reference-contexts: parser consists of both new material, in the form of tokens provided by an incremental lexer, and reused subtrees; the latter are conceptually on a stack, but are actually produced by a directed traversal over the version of the tree as it existed immediately prior to the start of reparsing <ref> [26] </ref>. An explicit stack is used to maintain the new version of the tree while it is being built. Figure 6 illustrates a common case, where a changed token has resulted in a split from the root to the changed terminal symbol. <p> The actual implementation corresponds closely to the algorithm given in Appendix A. Support for abstract parse dags required very little change to Ensemble's low-level representation, which is based on the self-versioning document model <ref> [26] </ref>. Parse table information is produced using a modified version of bison that explicitly records all conflicts in the grammar except for those arising from the expansion of the associative sequence notation.
Reference: [27] <author> Tim A. Wagner and Susan L. Graham. </author> <title> Isolating errorsa history-based approach, </title> <note> 1997. In preparation. </note>
Reference-contexts: Any modifications remaining are flagged as unincorporated material <ref> [27] </ref>. This approach is automated, language-independent, and incremental.
Reference: [28] <author> David A. Watt. </author> <title> Rule splitting and attribute-directed parsing. </title> <editor> In U. D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, number 94 in LNCS, </booktitle> <pages> pages 363-392, </pages> <address> Berlin, 1980. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This problem arises whenever the natural context-free syntax depends on non-local type information <ref> [28] </ref>. Ambiguity is discovered during analysis of the context-free syntax, leaving multiple alternatives encoded in the parse dag.
References-found: 28

