URL: ftp://ftp.cs.washington.edu/tr/1994/02/UW-CSE-94-02-03.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: On Scalable State-Based Specifications for Real-Time Systems  
Note: 1 Introduction This research was supported in part by the National Science Foundation under grant number CCR-9200858.  
Abstract: Alan C. Shaw Department of Computer Science and Engineering University of Washington Seattle, Washington 98195 shaw@cs.washington.edu Technical Report 94-02-03 Abstract Using our communicating real-time state machine (CRSM) language as a basis, we propose and develop a methodology for specifying requirements and designs for large real-time systems. CRSMs are distributed state machines with novel and general timing facilities and CSP-like synchronous communications. The paper first presents a particular controller-client (CC) architecture for composing CRSMs into larger components and then uses the CC organization to define a number of standard in-the-large paradigms for real-time and other software. The general goal is to provide a methodology for the specification of software requirements and designs for large real-time systems. Among other features, the approach and techniques should be executable, universal, formal, and scalable. The basis for our work is the communicating real-time state machine (CRSM) notation [Raju 93; Raju & Shaw 92; Shaw 92, 93]. CRSMs are universal state machines with guarded commands as transitions, synchronous IO communications over undirectional channels, and facilities for describing the execution times of transitions and for accessing real-time. CRSMs are distinguished from other state machine models mainly by their explicit timing features. CRSMs have been tested empirically on a large number of relatively small problems, through paper specifications, computer simulation, monitoring, and (to some extent) verification. Examples include a real-time bounded buffer, calendar timer, mouse clicker recognizer, gate controller for a train crossing, traffic light controller, real-time dining philosophers, and real-time spinning lock algorithms. However, it is evident that some additional methodology is needed to handle larger applications. This paper makes two contributions towards real-time specifications in-the-large. First, we present a CRSM architecture that permits the construction of larger systems from components. This organizational scheme, called a controller-client architecture, assumes a particular uniform IO channel interface for all CRSMs. Our second contribution is to define a number of standard in-the-large paradigms for real-time and other software. These include conventional control for large components, such as sequential, parallel, guarded selection, and looping; and scalable encapsulated data objects. Also presented are a variety of specific schemes and utilities commonly used mainly in real-time applications. Examples are alarm clock and multicasting utilities, scalable interrupt mechanisms, and organizations for periodic and sporadic activities. Our approach to scalability has been most influenced by statecharts [Harel 87], with their notions of superstates, interrupts, and series/parallel composition of machines, even though our 
Abstract-found: 1
Intro-found: 0
Reference: [Gabrielian & Franklin 91] <author> A. Gabrielian and M. Franklin, </author> <title> "Multilevel Specification of Real-Time Systems," </title> <journal> Comm. of ACM 34, </journal> <month> 5 (May </month> <year> 1991), </year> <pages> pp. 50-60. </pages>
Reference-contexts: The Requirements State Machine Language (RSML) [Leveson et al. 92], also heavily influenced by statecharts, permits both shared store and distributed interactions among machines, but has no timing features. The Hierarchial Multi-State Machines (HMS) <ref> [Gabrielian & Franklin 91] </ref> uses aspects of statecharts, Petri-nets, and temporal logic, but seems excessively complex for convenient specification.
Reference: [Harel 87] <author> D. Harel, "Statecharts: </author> <title> A Visual Formalism for Complex Systems," </title> <booktitle> Science of Computer Programming 8, </booktitle> <year> (1987), </year> <pages> pp. 231-274. </pages>
Reference-contexts: Also presented are a variety of specific schemes and utilities commonly used mainly in real-time applications. Examples are alarm clock and multicasting utilities, scalable interrupt mechanisms, and organizations for periodic and sporadic activities. Our approach to scalability has been most influenced by statecharts <ref> [Harel 87] </ref>, with their notions of superstates, interrupts, and series/parallel composition of machines, even though our * This research was supported in part by the National Science Foundation under grant number CCR-9200858. mechanisms and details are quite different.
Reference: [Hoare 85] <author> C. Hoare, </author> <title> Communicating Sequential Processes, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1985. </year>
Reference-contexts: A command can be either an IO command, or an internal one designating a computation or some physical activity. Enabled transitions are fired on an earliest-time-first basis. Communications between CRSMs is synchronous and occurs over undirectional named channels, in a manner similar to CSP <ref> [Hoare 85] </ref>.
Reference: [Jahanian & Mok 89] <author> F. Jahanian and A. Mok, "Modechart: </author> <title> A Specification Language For Real Time Systems," </title> <type> IBM Tech Report RC 15140, </type> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: These differences result from different models (shared memory versus distributed, broadcast communications versus synchronous one-to-one) and our timing facilities. The Modechart notation <ref> [Jahanian & Mok 89] </ref> is similar to statecharts, but more restricted; they compose nicely but machines are finite state and events that trigger transitions among components cannot have data associated with them.
Reference: [Kramer et al. 93] <author> B. Kramer, Luqi, and V. Berzins, </author> <title> "Compositional Semantics of a Real-Time Prototyping Language," </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> Vol. 19, No. 5, </volume> <month> May </month> <year> 1993, </year> <pages> pp. 453-477. </pages>
Reference-contexts: The Hierarchial Multi-State Machines (HMS) [Gabrielian & Franklin 91] uses aspects of statecharts, Petri-nets, and temporal logic, but seems excessively complex for convenient specification. Another interesting language that provides for hierarchical composition of components is the prototype system description language (PSDL) <ref> [Kramer et al. 93] </ref>, which combines state machine with data flow ideas and includes time; for convenience and simplicity, we prefer a pure state-based notation. Other (non-state-based) models that provide for scalability, for example, those based on programming languages or Petri-nets, are not discussed here.
Reference: [Leveson et al. 91] <author> N. Leveson, M. Heimdahl, H. Hildreth, and J. Reese, </author> <title> "Requirements Specification For Process-Control Systems," </title> <type> TR 92-106, </type> <institution> Computer Science Dept., UC Irvine, </institution> <year> 1992. </year> <title> [Raju 93] "An automatic verification technique for communicating real-time state machines," </title> <type> TR #93-04-08, </type> <institution> Dept. of Computer Science & Engineering, University of Washington, </institution> <address> Seattle, </address> <month> April, </month> <year> 1993. </year>
Reference: [Raju & Shaw 92] <author> S. Raju and A. Shaw, </author> <title> "A prototyping environment for specifying, executing and checking communicating real-time state machines," </title> <type> TR #92-10-03, </type> <institution> Dept. of Computer Science & Engineering, University of Washington, </institution> <address> Seattle, </address> <month> October, </month> <year> 1992. </year> <note> A revised version is in publication in the journal Software-Practice & Experience. </note>
Reference-contexts: 1 . Introduction The general goal is to provide a methodology for the specification of software requirements and designs for large real-time systems. Among other features, the approach and techniques should be executable, universal, formal, and scalable. The basis for our work is the communicating real-time state machine (CRSM) notation <ref> [Raju 93; Raju & Shaw 92; Shaw 92, 93] </ref>. CRSMs are universal state machines with guarded commands as transitions, synchronous IO communications over undirectional channels, and facilities for describing the execution times of transitions and for accessing real-time. <p> This is a variation of the example presented in <ref> [Raju & Shaw 92] </ref>. The environment consists of two pairs of traffic lights, one for the avenue and one for the street, and the ambulance. Outputs are commands to turn the lights to their correct colors. <p> Of these tasks, the most useful initially would be programs for building and executing specifications - an in-the-large version of the tools described in <ref> [Raju & Shaw 92; Raju 93] </ref>. With these tools, especially the latter, we will be in a position to do some convincing experiments on interesting real-time systems. This should also lead to a larger number of useful paradigms for real-time requirements and designs. 9 .
Reference: [Shaw 92] <author> A. Shaw, </author> <title> "Communicating real-time system machines," </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> Vol. 18, No. 9, </volume> <month> Sept. </month> <year> 1992, </year> <pages> pp. </pages> <month> 805-816. </month> <title> [Shaw 93] "A (more) formal definition of communicating real-time state machines," </title> <type> TR #93-08-01, </type> <institution> Dept. of Computer Science & Engineering, University of Washington, </institution> <address> Seattle, </address> <month> August, </month> <year> 1993. </year>
Reference-contexts: 1 . Introduction The general goal is to provide a methodology for the specification of software requirements and designs for large real-time systems. Among other features, the approach and techniques should be executable, universal, formal, and scalable. The basis for our work is the communicating real-time state machine (CRSM) notation <ref> [Raju 93; Raju & Shaw 92; Shaw 92, 93] </ref>. CRSMs are universal state machines with guarded commands as transitions, synchronous IO communications over undirectional channels, and facilities for describing the execution times of transitions and for accessing real-time. <p> Approach Leave Avenue Street Ambulance Street_lights Avenue_Lights Light_Mode_Control Light _On/Off_Control Amb_Mode Normal_Mode Avenue Environment Computer Control Light_Mode_Control Amb_ModeNormal_Mode Approach Street Leave Avenue Approach Street Leave Approach Leave 3 . Communicating Real-Time State Machines We present a brief introduction to CRSMs. More formal and detailed treatments appear in <ref> [Shaw 92, 93] </ref>. A CRSM is a state machine with one designated start state and guarded commands for state transitions. A command can be either an IO command, or an internal one designating a computation or some physical activity. Enabled transitions are fired on an earliest-time-first basis. <p> The transmit_time parameter might reflect the physics of turning power on and off, the complexity and nature of the components, and the system requirements. Our original paper on CRSMs <ref> [Shaw 92] </ref> indicates how some other common forms of communications may be implemented. This includes asynchronous communications with a non-blocking send and a blocking receive, and synchronous but undirected one-to-one message passing.
References-found: 8

