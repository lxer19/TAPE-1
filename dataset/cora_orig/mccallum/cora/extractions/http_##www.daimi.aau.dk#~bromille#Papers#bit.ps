URL: http://www.daimi.aau.dk/~bromille/Papers/bit.ps
Refering-URL: http://www.daimi.aau.dk/~bromille/Papers/index.html
Root-URL: http://www.daimi.aau.dk
Email: Email: pbmilter@cs.toronto.edu.  
Title: Lower bounds for static dictionaries on RAMs with bit operations but no multiplication  
Author: Peter Bro Miltersen 
Address: Toronto, King's College Road, Toronto Ontario M5S 1A4, Canada.  
Affiliation: Department of Computer Science, University of  
Abstract: We consider solving the static dictionary problem with n keys from the universe f0; : : : ; m1g on a RAM with direct and indirect addressing, conditional jump, addition, bitwise Boolean operations, and arbitrary shifts (a Practical RAM). For any * &gt; 0, tries yield constant query time using space m * , provided that n = m o(1) . We show that this is essentially optimal: Any scheme with constant query time requires space m * for some * &gt; 0, even if n (log m) 2 . 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Andersson. </author> <title> Sublogarithmic searching without multiplications. </title> <booktitle> In Proc. FOCS, </booktitle> <year> 1995. </year>
Reference-contexts: manipulation is essential, such as for example tries, van Emde Boas trees [11], Gabow and Tarjan's special case Union-Find algorithm [15], Chazelle's M-structure [7], Dietz' list indexing structure [8], the O (n log log n) sorting algorithm of Andersson et al [2], Andersson's O ( p log n) search structure <ref> [1] </ref>, and Thorup's O (log log n) priority queue [16]. For some of these latter applications it is essential that the shift operation is capable of shifting the word an arbitrary number of places. The hashing schemes above are examples of data structures using a stronger instruction set. <p> The hashing schemes above are examples of data structures using a stronger instruction set. An additional example is the fusion tree [14] which also uses multiplication in a non-trivial way. Andersson's structure <ref> [1] </ref> gives a multiplication-free alternative to fusion trees. In this paper we show that no such alternative exists for static dictionaries without sacrificing either constant query time or linear (or even polynomial) storage space. Our main theorem is the following. <p> Create k copies of x inside a single word by repeated shift and bitwise OR in time O (log k) = O (log log n) (see e.g. Andersson <ref> [1] </ref>). Call the result x 0 . Bits ib; : : : ; (i + 1)b 1 of x 0 contain a copy of x for i 2 f0; : : : k 1g. 2. Compute a = x 0 ^ A 0 . 3. Compute p = fold (a).
Reference: 2. <author> A. Andersson, T. Hagerup, S. Nilsson, and R. Raman. </author> <title> Sorting in linear time? In Proc. </title> <booktitle> 27th ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 427-436, </pages> <year> 1995. </year>
Reference-contexts: algorithms and data structures where indirect addressing and/or bit manipulation is essential, such as for example tries, van Emde Boas trees [11], Gabow and Tarjan's special case Union-Find algorithm [15], Chazelle's M-structure [7], Dietz' list indexing structure [8], the O (n log log n) sorting algorithm of Andersson et al <ref> [2] </ref>, Andersson's O ( p log n) search structure [1], and Thorup's O (log log n) priority queue [16]. For some of these latter applications it is essential that the shift operation is capable of shifting the word an arbitrary number of places.
Reference: 3. <author> A. Andersson, P.B. Miltersen, S. Riis, and M. </author> <title> Thorup. Static Dictionaries on AC 0 RAMs: Query time p log n= log log n is sufficient and necessary. </title> <type> Manuscript, </type> <year> 1996. </year>
Reference-contexts: This upper bound is described in Section 2. The matching lower bound still holds for this extended machine model. To get a better lower bound, we thus have to apply different techniques. Subsequent to the research reported here, this was done by Andersson et al <ref> [3] </ref>. They show a lower bound of ( p query time for linear space data structures on AC 0 RAMs, i.e. RAMs where all compuational instructions can be implemented in AC 0 . The Practical RAM is a special case. <p> Subsequent to this research and using different techniques, Andersson et al <ref> [3] </ref> improved the lower bound of (log log n) of this paper to ( p log n= log log n). A polynomial gap to the O (log n) upper bound remains. We conjecture that O (log n) is in fact optimal, i.e. that tables should be sorted on Practical RAMs.
Reference: 4. <author> A.M. Ben-Amram and Z. Galil. </author> <title> When can we sort in o(n log n) time? In Proc. </title> <booktitle> 34th IEEE Symposium on Foundations of Computer Science (FOCS), </booktitle> <pages> pages 538-546, </pages> <year> 1993. </year>
Reference-contexts: As far as we know, this paper is the first one proving instruction set dependent lower bounds for this instruction set (previous papers considering shift operations <ref> [5, 4] </ref> have been restricted to one-bit shifts). The Practical RAM is quite powerful. It is certainly sufficiently powerful to implement the classical comparison based data structures for representing sets, such as trees and heaps of all kinds.
Reference: 5. <author> N.H. Bshouty. </author> <title> Lower bounds for the complexity of functions in a realistic RAM model. </title> <booktitle> In Proc. Israel Symposium on the Theory of Computing and Systems, </booktitle> <pages> pages 12-23, </pages> <year> 1992. </year>
Reference-contexts: As far as we know, this paper is the first one proving instruction set dependent lower bounds for this instruction set (previous papers considering shift operations <ref> [5, 4] </ref> have been restricted to one-bit shifts). The Practical RAM is quite powerful. It is certainly sufficiently powerful to implement the classical comparison based data structures for representing sets, such as trees and heaps of all kinds.
Reference: 6. <author> J.L. Carter and M.N. Wegman. </author> <title> Universal classes of hash functions. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 18 </volume> <pages> 143-154, </pages> <year> 1979. </year>
Reference-contexts: We make use of the following result by Carter and Wegman <ref> [6] </ref>: The class of functions f A : f0; 1g n 1 ! f0; 1g n 2 given by f A (x) = Ax, where A is an n 2 fi n 1 0-1 matrix and the matrix product is over the field Z 2 , is a universal class of
Reference: 7. <author> B. Chazelle. </author> <title> A functional approach to data structures and its use in multidimensional searching. </title> <journal> SIAM J. Comput., </journal> <volume> 17 </volume> <pages> 427-462, </pages> <year> 1988. </year>
Reference-contexts: It is also sufficiently powerful to implement several fundamental algorithms and data structures where indirect addressing and/or bit manipulation is essential, such as for example tries, van Emde Boas trees [11], Gabow and Tarjan's special case Union-Find algorithm [15], Chazelle's M-structure <ref> [7] </ref>, Dietz' list indexing structure [8], the O (n log log n) sorting algorithm of Andersson et al [2], Andersson's O ( p log n) search structure [1], and Thorup's O (log log n) priority queue [16].
Reference: 8. <author> P.F. Dietz. </author> <title> Optimal algorithms for list indexing and subset rank. </title> <booktitle> In Proc. First Workshop on Algorithms and Data Structures (WADS), </booktitle> <pages> pages 39-46, </pages> <year> 1989. </year>
Reference-contexts: It is also sufficiently powerful to implement several fundamental algorithms and data structures where indirect addressing and/or bit manipulation is essential, such as for example tries, van Emde Boas trees [11], Gabow and Tarjan's special case Union-Find algorithm [15], Chazelle's M-structure [7], Dietz' list indexing structure <ref> [8] </ref>, the O (n log log n) sorting algorithm of Andersson et al [2], Andersson's O ( p log n) search structure [1], and Thorup's O (log log n) priority queue [16].
Reference: 9. <author> M. Dietzfelbinger, T. Hagerup, J. Katajainen, and M. Penttonen. </author> <title> A reliable randomized algorithm for the closest-pair problem. </title> <type> Technical Report 513, </type> <institution> Fachbereich Informatik, Universitat Dortmund, </institution> <year> 1993. </year>
Reference-contexts: Real instruction sets certainly allow such things and real programs take advantage of them. In fact, if multiplication, bitwise Boolean operations and shifts are allowed, a solution to the static dictionary problem with linear storage space and constant query time that avoids integer division is possible: In <ref> [9] </ref> it is shown that the family of hash functions h k (x) = (kx mod 2 b ) div 2 a , where a and b are suitably chosen integer constants, can replace the family used by Fredman, Komlos, and Szemeredi.
Reference: 10. <author> M. Dietzfelbinger, A. Karlin, K. Mehlhorn, F. Meyer Auf Der Heide, H. Rohnert, and R.E. Tarjan. </author> <title> Dynamic perfect hashing: Upper and lower bounds. </title> <journal> SIAM J. Comput., </journal> <volume> 23 </volume> <pages> 738-761, </pages> <year> 1994. </year>
Reference-contexts: Furthermore we use the observation by <ref> [10] </ref>, that if we have black boxes computing classes of universal hash functions f A : U ! f0; : : : ; 2 k 1g for various k O (log n), we can use them as building blocks in Fredman, Komlos and Szemeredi's two level hashing data structure.
Reference: 11. <author> P. van Emde Boas, R. Kaas, and E. Zijlstra. </author> <title> Design and implementation of an efficient priority queue. </title> <journal> Mathematical Systems Theory, </journal> <volume> 10 </volume> <pages> 99-127, </pages> <year> 1977. </year>
Reference-contexts: It is also sufficiently powerful to implement several fundamental algorithms and data structures where indirect addressing and/or bit manipulation is essential, such as for example tries, van Emde Boas trees <ref> [11] </ref>, Gabow and Tarjan's special case Union-Find algorithm [15], Chazelle's M-structure [7], Dietz' list indexing structure [8], the O (n log log n) sorting algorithm of Andersson et al [2], Andersson's O ( p log n) search structure [1], and Thorup's O (log log n) priority queue [16].
Reference: 12. <author> F. Fich and P.B. Miltersen. </author> <title> Tables should be sorted (on random access machines). </title> <booktitle> In Proc. 4th International Workshop on Algorithms and Data Structures (WADS), </booktitle> <pages> pages 482-493, </pages> <year> 1995. </year>
Reference-contexts: Their technique is based on the family of hash functions h k (x) = (kx mod p) mod s, i.e. multiplication and integer division is used. Since these instructions are usually considered expensive, it is interesting to know whether their use can be avoided. Fich and Miltersen <ref> [12] </ref> considered this problem and showed that for a RAM with the standard, "classical" instruction set, consisting of direct and indirect addressing, addition, subtraction, multiplication, and conditional jump, the logarithmic query time of the sorted table/binary search solution cannot be improved without using space at least m=n o (1) .
Reference: 13. <author> M.L. Fredman, J. Komlos, and E. Szemeredi. </author> <title> Storing a sparse table with O(1) worst case access time. </title> <journal> J. Ass. Comp. Mach., </journal> <volume> 31 </volume> <pages> 538-544, </pages> <year> 1984. </year>
Reference-contexts: Then queries can be answered using binary search in O (log n) time. Yao [17] first considered the possibility of improving this solution and provided an improvement for certain values of m and n. Fredman, Komlos and Szemeredi <ref> [13] </ref> showed that for all values of m and n, there is a storage scheme using n + o (n) memory cells, so that queries can be answered in constant time.
Reference: 14. <author> M.L. Fredman and D.E. Willard. </author> <title> Surpassing the information theoretic bound with fusion trees. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 47 </volume> <pages> 424-436, </pages> <year> 1993. </year>
Reference-contexts: For some of these latter applications it is essential that the shift operation is capable of shifting the word an arbitrary number of places. The hashing schemes above are examples of data structures using a stronger instruction set. An additional example is the fusion tree <ref> [14] </ref> which also uses multiplication in a non-trivial way. Andersson's structure [1] gives a multiplication-free alternative to fusion trees. In this paper we show that no such alternative exists for static dictionaries without sacrificing either constant query time or linear (or even polynomial) storage space.
Reference: 15. <author> H. N. Gabow and R. E. Tarjan. </author> <title> A linear-time algorithm for a special case of disjoint set union. </title> <journal> Journal of Computer and Systems Sciences, </journal> <volume> 30 </volume> <pages> 209-221, </pages> <year> 1985. </year>
Reference-contexts: It is also sufficiently powerful to implement several fundamental algorithms and data structures where indirect addressing and/or bit manipulation is essential, such as for example tries, van Emde Boas trees [11], Gabow and Tarjan's special case Union-Find algorithm <ref> [15] </ref>, Chazelle's M-structure [7], Dietz' list indexing structure [8], the O (n log log n) sorting algorithm of Andersson et al [2], Andersson's O ( p log n) search structure [1], and Thorup's O (log log n) priority queue [16].
Reference: 16. <author> M. </author> <title> Thorup. On RAM priority queues. </title> <booktitle> In Proceedings of the 7th ACM-SIAM Symposium on Discrete Algorithms (SODA), </booktitle> <pages> pages 59-67, </pages> <year> 1996. </year>
Reference-contexts: Emde Boas trees [11], Gabow and Tarjan's special case Union-Find algorithm [15], Chazelle's M-structure [7], Dietz' list indexing structure [8], the O (n log log n) sorting algorithm of Andersson et al [2], Andersson's O ( p log n) search structure [1], and Thorup's O (log log n) priority queue <ref> [16] </ref>. For some of these latter applications it is essential that the shift operation is capable of shifting the word an arbitrary number of places. The hashing schemes above are examples of data structures using a stronger instruction set.
Reference: 17. <author> A.C. Yao. </author> <title> Should tables be sorted? J. Ass. </title> <journal> Comp. Mach., </journal> <volume> 28 </volume> <pages> 615-628, </pages> <year> 1981. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: The set S can be stored as a sorted table using n memory registers. Then queries can be answered using binary search in O (log n) time. Yao <ref> [17] </ref> first considered the possibility of improving this solution and provided an improvement for certain values of m and n.
References-found: 17

