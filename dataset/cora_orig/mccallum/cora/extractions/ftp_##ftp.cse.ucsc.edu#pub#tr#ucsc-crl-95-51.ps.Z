URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-95-51.ps.Z
Refering-URL: http://www.cse.ucsc.edu/~brucem/
Root-URL: http://www.cse.ucsc.edu
Title: Synchronous/Reactive Programming of Concurrent System Software  
Author: Bruce R. Montague and Charles E. McDowell 
Keyword: reactive systems, synchronous language, concurrent programming, system software, operating systems, threading, real-time systems, soft-instructions.  
Date: November 28, 1995  
Address: Santa Cruz  Santa Cruz, CA 95064 USA  
Affiliation: Computer and Information Sciences University of California,  Baskin Center for Computer Engineering Information Sciences University of California, Santa Cruz  
Pubnum: UCSC-CRL-95-51  
Abstract: Synchronous languages are intended for programming reactive systems. Reactive systems, which include real-time systems and key operating system components, interact continually with their environment. This paper considers the applicability of imperative synchronous/reactive languages to the development of general system software, that is, to the implementation of operating system kernels, file systems, databases, networks, server architectures, device drivers, etc.. The languages Esterel and Reactive C (RC) receive special attention as Esterel is the oldest and most developed such language and RC is specifically designed for compatibility with C systems programming. An alternative soft-instruction software architecture is described which is well suited to real-world system programming. 
Abstract-found: 1
Intro-found: 1
Reference: [ACJ + 95] <author> Mark A. Ardis, John A. Chaves, Lalita Jategaonkar Jagadeesan, Peter Mataga, Carlos Puchol, Mark G. Staskauskas, and James Von Olnhausen. </author> <title> A framework for evaluating specification methods for reactive systems. </title> <booktitle> In Proceedings of the 17th International Conference on Software Engineering, </booktitle> <pages> pages 159-168, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: statements are useful when multiple routines have to monitor each others state, wait for initialization to be complete, etc.. 0.4.4 Evaluations A group at Bell Labs evaluated 6 different reactive specification and development systems with respect to a reactive coding problem originally implemented in C in the ATT 5ESS system <ref> [ACJ + 95] </ref>. Esterel was included but not RC. The evaluation considered real-world applicability, compatibility, and software engineering concerns such as language learning curves. This study concluded that Esterel required more expertise than the other approaches.
Reference: [ALBL91] <author> Thomas E. Anderson, Henry M. Levy, Brian N. Bershad, and Edward D. La-zowska. </author> <title> The interaction of architecture and operating system design. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 108-120, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: This is especially true for servers requiring a very high degree of competitive internal concur-rency, for instance, servers for transaction processing, databases, networks, and multimedia. Context switch overhead bounds the performance of conventional multithreading approaches based on heavyweight and lightweight concurrency [Ous89] [MB91] <ref> [ALBL91] </ref>. Context switch code paths through general purpose systems are lengthy and context switches destroy locality of reference assumptions upon which high performance systems rely. Featherweight context switch techniques that can provide a high degree of both competitive and cooperative internal concurrency are thus of interest.
Reference: [All81] <author> Steve T. Allworth. </author> <title> Introduction to Real-Time Software Design. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Besides not directly supporting concurrent programming, most existing threaded-code architectures implement a rather fixed set of low-level primitives, with the bulk of the program occuring at the control table level. 26 Allworth provides a short description of real-time threaded-code soft-instruction architectures with only a single high-level program counter <ref> [All81] </ref>. He notes the flexibility and space savings provided by what is now called token-threaded code and simply calls the dispatcher an `interpreter'. Token-threaded code compresses control tables by using indices smaller than the machine address size to access an intermediate table. <p> The instruction pointer indicates which code is to be interpreted next. On each cycle of the interpreter it is incremented to point to the next code in sequence. Non-sequential jumps within the interpreted code can be implemented by allowing action programs to manipulate the instruction pointer' <ref> [All81] </ref>. The view of non-concurrent programs as abstract layers of virtual instructions is an old one.
Reference: [And79] <author> S. Andler. </author> <title> Predicate path expressions. </title> <booktitle> In Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 226-236, </pages> <year> 1979. </year>
Reference-contexts: A reactive subset of C is used for programming-in-the-large. The reactive level is programmed in familiar sequential procedure-oriented fashion, rather than using a nonprocedural or nonsequential approach, such as results from using guarded commands or path expressions <ref> [And79] </ref> [AS83]. Programming-in-the-small uses a minor variant of C, an ordinary systems program ming language. * Single Locus Concurrency. Concurrency is explicitly visible when reading the source `from the top down'.
Reference: [AS83] <author> G. R. Andrews and F. B. Schneider. </author> <title> Concepts and notations for concurrent programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 15(1) </volume> <pages> 3-43, </pages> <month> March </month> <year> 1983. </year>
Reference-contexts: A reactive subset of C is used for programming-in-the-large. The reactive level is programmed in familiar sequential procedure-oriented fashion, rather than using a nonprocedural or nonsequential approach, such as results from using guarded commands or path expressions [And79] <ref> [AS83] </ref>. Programming-in-the-small uses a minor variant of C, an ordinary systems program ming language. * Single Locus Concurrency. Concurrency is explicitly visible when reading the source `from the top down'.
Reference: [Atw76] <author> J. William Atwood. </author> <title> Concurrency in operating systems. </title> <journal> IEEE Computer, </journal> <volume> 9(10) </volume> <pages> 18-26, </pages> <month> October </month> <year> 1976. </year>
Reference-contexts: Each component is generally capable of servicing multiple concurrent requests, some of which may be of long-duration, and some of which may have real-time constraints. Thus, operating system software constitutes a significant concurrent programming problem, and it is widely agreed that development of such software remains difficult <ref> [Atw76] </ref> [Sch86] [Wat90]. There are many ways to view concurrency. The remainder of this section describes concurrent programming considerations germane to the design and programming of concurrent system software, that is, concurrency from the viewpoint of the system programmer. <p> A software architecture provides an identifiable approach or framework often implicitly framed by the adopted tools, languages, and development environments [GTP95] [Gar95]. Good system software invariably adopts a well defined software architecture. The architectures used for system software are usually based on some form of explicitly coded critical sections <ref> [Atw76] </ref> [FP88] [Her91]. However, explicit critical sections introduce nondeterminism and are a root cause of many concurrent programming difficulties [Her90].
Reference: [BB91] <author> Albert Benveniste and Gerard Berry. </author> <title> The synchronous approach to reactive and real-time systems. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1270-1282, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: For instance, an event-driven program may calculate a simple transformation and terminate. The term reactive is more general than soft real-time and near real-time, because a reactive system does not address any real-time constraints but only correct causality ordering <ref> [BB91] </ref>. 4 Simple reactive systems are often programmed as explicit finite state machines, with external events driving the machine through state transitions. Explicitly coded state machines work well for problems with fewer than around 10 states. Above this size, explicitly programming a single state machine becomes difficult. <p> Under sustained near worst case conditions, however, nondeterministic systems that must expend run-time overhead scheduling their activities are less efficient than cyclic systems [Kop91]. 0.3 Synchronous Languages Recently, synchronous software architectures have been proposed specifically for reactive systems <ref> [BB91] </ref> [Hal93]. The resulting synchronous/reactive systems include data-flow and declarative approaches as well as more traditional imperative languages. None of these approaches have proven intrinsically more powerful than the others, and an effort is currently underway to provide a common `back-end' for a number of these systems. <p> 0.6 An Alternative Proposal Is there a software architecture for conventional systems programming which retains synchronous/reactive advantages but not the disadvantages identified in the previous section? The developers of Esterel have noted the similarity between the synchrony hypothesis and clocked digital circuits in which all `reactions' take one clock cycle <ref> [BB91] </ref>. Indeed, it is natural to consider, as an alternative to dataflow-flavored approaches, a software architecture based on a sequential instruction model similar to that found in conventional hardware. 0.6.1 The Soft-Instruction Architecture A conventional computer architecture advances a program counter each `instant', thereby executing instruction sequences.
Reference: [BC84] <author> Gerard Berry and Laurent Cosserat. </author> <title> The Esterel synchronous programming language and its mathematical semantics. </title> <editor> In G. Goos and J. Hartmanis, editors, </editor> <booktitle> Lecture Notes in Computer Science, 197, Seminar on Concurrency, </booktitle> <pages> pages 389-448. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1984. </year>
Reference-contexts: NPL uses a non-deterministic Least Recently Used (LRU) policy to select which ready action to execute first. Although typical of guarded command languages and designed explicitly for reactive environments, NPL does not assume the synchrony hypothesis. 0.4.2 Esterel Esterel is the oldest synchronous/reactive language and the best documented <ref> [BC84] </ref> [BdS91] [BG92] [Hal93] [Edw94]. The design of Esterel was motivated by an effort to develop a semantics of parallel and real-time programming following Robin Milner's theories of synchronous process algebras [Mil93]. A complete Esterel module is shown in Figure 0.4 and code fragments in Figures 0.3 and 0.5.
Reference: [BdS91] <author> Frederic Boussinot and Robert de Si-mone. </author> <booktitle> The Esterel language. Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1293-1304, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: 0.1. Introduction 1 0.1 Introduction The imperative synchronous languages Esterel and Reactive C (RC) were developed to address concurrent programming difficulties associated with the reactive systems commonly encountered in real-time and embedded programming <ref> [BdS91] </ref> [Bou91]. These languages have been called synchronous/reactive languages. This paper considers the applicability of such languages to the closely related problem of general system software development, and then describes an alternative software architecture intended specifically for system software development. <p> NPL uses a non-deterministic Least Recently Used (LRU) policy to select which ready action to execute first. Although typical of guarded command languages and designed explicitly for reactive environments, NPL does not assume the synchrony hypothesis. 0.4.2 Esterel Esterel is the oldest synchronous/reactive language and the best documented [BC84] <ref> [BdS91] </ref> [BG92] [Hal93] [Edw94]. The design of Esterel was motivated by an effort to develop a semantics of parallel and real-time programming following Robin Milner's theories of synchronous process algebras [Mil93]. A complete Esterel module is shown in Figure 0.4 and code fragments in Figures 0.3 and 0.5.
Reference: [Bel73] <author> James R. Bell. </author> <title> Threaded code. </title> <journal> Communications of the ACM, </journal> <volume> 16(6) </volume> <pages> 370-372, </pages> <month> June </month> <year> 1973. </year>
Reference-contexts: Well designed control tables can take considerably less space than the equivalent assembler code. Thus, compilers generating threaded-code were originally introduced to implement high-level languages, such as Fortran, on small address-space minicomputers where program size was critical <ref> [Bel73] </ref> [Bre78].
Reference: [BG92] <author> Gerard Berry and Georges Gonthier. </author> <title> The Esterel synchronous programming language: Design, semantics, </title> <booktitle> implementation. Science of Computer Programming, </booktitle> <volume> 19(2) </volume> <pages> 87-152, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Although typical of guarded command languages and designed explicitly for reactive environments, NPL does not assume the synchrony hypothesis. 0.4.2 Esterel Esterel is the oldest synchronous/reactive language and the best documented [BC84] [BdS91] <ref> [BG92] </ref> [Hal93] [Edw94]. The design of Esterel was motivated by an effort to develop a semantics of parallel and real-time programming following Robin Milner's theories of synchronous process algebras [Mil93]. A complete Esterel module is shown in Figure 0.4 and code fragments in Figures 0.3 and 0.5.
Reference: [BGJ91] <author> Albert Benveniste, Paul Le Guernic, and Christian Jacquemot. </author> <title> Synchronous programming with events and relations: the Signal language and its semantics. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 16 </volume> <pages> 103-149, </pages> <year> 1991. </year>
Reference-contexts: Synchronous languages essentially `compile away' all internal cooperative concurrency by producing a single deterministic state machine that manages all required activities. Nondeterministic external events are handled by the reaction dispatch or guard evaluation mechanism, and do not directly propagate into the body of the program <ref> [BGJ91] </ref>. Since the single state machine into which concurrent programs are compiled cannot deadlock, the need for multiple threads, critical sections, and nondeterminacy is eliminated. However, synchronous languages that compile to a single state machine must sacrifice recursion and dynamic data allocation to obtain determinism.
Reference: [BJ87] <author> K. Birman and T. Joseph. </author> <title> Exploiting virtual synchrony in distributed systems. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating System Principles, </booktitle> <pages> pages 123-138, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: adopted as a fundamental primitive in theories of concurrency [Lam94]. 0.4 Current Studies Selected efforts relating to synchronous/reactive programming are examined in this section, primarily with respect to their source code and potential applicability to system programming. 0.4.1 Meta/NPL The ISIS system is a reliable distributed system developed at Cornell <ref> [BJ87] </ref>. While attempting a 6 large distributed ISIS application, the need arose for a distributed reactive toolkit because ISIS lacked tools for distributed control [MW91]. This motivated the development of Meta, a toolkit for building non-real-time reactive systems. Meta provides a state machine language called NPL.
Reference: [BJK + 95] <author> Robert D. Blumofe, Christopher F. Jo-erg, Bradley C. Kuszmaul, Charles E. Leiserson, Keith H. Randall, and Yuli Zhou. Cilk: </author> <title> An efficient multithreaded runtime system. </title> <booktitle> In Proceedings of the Fifth ACM SIGPLAN Symposium on Priciples and Practice of Parallel Programming, </booktitle> <pages> pages 207-216, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: A large amount of work has been performed on multithreaded runtimes and parallel programming environments for massively parallel machines. A system of particular interest is Cilk, a multithread-ing parallel programming C run-time influenced by dataflow research <ref> [BJK + 95] </ref>. It is used to program parallel MIMD machines for a particular class of computationally intensive distributed computations. Cilk provides high-performance cooperative concur-rency in a distributed environment. As with soft-instruction architectures, individual Cilk routines are atomic units of computation which always run to completion. <p> Cilk is good at expressing and executing dynamic, synchronous, tree-like, MIMD computations, but it is not yet ideal for more traditional parallel applications that can be programmed effectively in, for example, a message-passing data-parallel, or single-threaded shared-memory style' <ref> [BJK + 95] </ref>. Cilk is of interest as its developers note and study the performance advantages resulting from various soft-instruction related techniques, for instance, the use of atomic routines, a single scheduler/dispatch loop, and featherweight context switch provided by a thread model based on a linguistic abstraction.
Reference: [Bou91] <author> Frederic Boussinot. </author> <title> Reactive C: An extension of C to program reactive systems. </title> <journal> Software Practice and Experience, </journal> <volume> 21(4) </volume> <pages> 401-428, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: 0.1. Introduction 1 0.1 Introduction The imperative synchronous languages Esterel and Reactive C (RC) were developed to address concurrent programming difficulties associated with the reactive systems commonly encountered in real-time and embedded programming [BdS91] <ref> [Bou91] </ref>. These languages have been called synchronous/reactive languages. This paper considers the applicability of such languages to the closely related problem of general system software development, and then describes an alternative software architecture intended specifically for system software development. <p> continues to execute its body the first instant that display toggle is true, signal frozen display remains true for the entire instant, becoming false in the next following instant. 0.4.3 Reactive C Reactive C (RC) is designed to provide extensions to C supporting synchronous/reactive programming based on the Esterel model <ref> [Bou91] </ref> [Bou92]. RC is implemented as a preprocessor generating C source code. RC does not compile to a finite state machine, but rather provides the C programmer additional statements for expressing Esterel-style reactive control flow. RC is more general than Esterel.
Reference: [Bou92] <author> Frederic Boussinot. </author> <title> RC reference manual. </title> <type> Technical Report CMA 92-16, </type> <institution> Ecole Nationale Superieure des Mines, </institution> <year> 1992. </year>
Reference-contexts: to execute its body the first instant that display toggle is true, signal frozen display remains true for the entire instant, becoming false in the next following instant. 0.4.3 Reactive C Reactive C (RC) is designed to provide extensions to C supporting synchronous/reactive programming based on the Esterel model [Bou91] <ref> [Bou92] </ref>. RC is implemented as a preprocessor generating C source code. RC does not compile to a finite state machine, but rather provides the C programmer additional statements for expressing Esterel-style reactive control flow. RC is more general than Esterel.
Reference: [Bra82] <author> James Brakefield. </author> <title> Just what is an op-code? or a universal computer design. </title> <journal> Computer Architecture News, </journal> <volume> 10(4) </volume> <pages> 31-34, </pages> <month> June </month> <year> 1982. </year> <month> 30 </month>
Reference-contexts: Many VIs can be constructed... ... In general, therefore, a VI is not entered in parallel and hence is non-reentrant' 0.9. Related Work 27 [PJ75]. Mixed hardware/software instruction stream interpretation, with custom user written routines extending the machine instruction set, is an old idea <ref> [Bra82] </ref>. Such approaches are often seen today on RISC architectures, for instance PALcode on the DEC Alphas provides a mechanism for operating system programmers to develop privileged `hardware' instructions specific to the support of their system.
Reference: [Bre78] <author> Ronald F. Brender. </author> <title> Turning cousins into sisters: An example of software smoothing of hardware differences. </title> <editor> In C. Gordon Bell, J. Craig Mudge, and John E. McNamara, editors, </editor> <booktitle> Computer Engineering: A DEC View of Hardware Systems Design, </booktitle> <pages> pages 365-378. </pages> <publisher> Digital Press, </publisher> <year> 1978. </year>
Reference-contexts: Well designed control tables can take considerably less space than the equivalent assembler code. Thus, compilers generating threaded-code were originally introduced to implement high-level languages, such as Fortran, on small address-space minicomputers where program size was critical [Bel73] <ref> [Bre78] </ref>. Besides not directly supporting concurrent programming, most existing threaded-code architectures implement a rather fixed set of low-level primitives, with the bulk of the program occuring at the control table level. 26 Allworth provides a short description of real-time threaded-code soft-instruction architectures with only a single high-level program counter [All81].
Reference: [BS86] <author> Theodore P. Baker and Gregory M. Scal-lon. </author> <title> An architecture for real-time software systems. </title> <journal> IEEE Software, </journal> <volume> 2(5) </volume> <pages> 50-58, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: Historically, such approaches have long been used in areas such as real-time avionics and high performance transaction processing. Example systems that have been described include Boeing's Rex and IBM's TPF <ref> [BS86] </ref> [Mar90]. <p> The advantages of `traditional' soft-instruction flavored cyclic executives, as used in real-time avionics, have previously been enumerated and contrasted with conventional multithreading techniques using preemptive scheduling of lightweight threads [Mac80] [Gla83] [Sha86b] <ref> [BS86] </ref>. MacLaren, in discussing one such system, notes that `the efficiency of a cyclic executive derives from its minimal scheduling property, and from the very small implementation cost' [Mac80]. <p> Current real-time and concurrent programming research tends to emphasize replacing, rather than modernizing, soft-instruction related approaches. Baker and Scallon describe a family of systems implemented at Boeing using a soft-instruction architecture <ref> [BS86] </ref>. They note that its lineage includes the executives of the 1965 Apollo Range Instrumentation Ship and the 1970 Safeguard ballistic missile defense effort. <p> A plan for the management of these procedures' executions to form a system is expressed in a separate system-specification language, and is separately translated into tables (agendas) used by the Rex virtual machine. These tables are in effect a high-level machine code interpreted by the executive' <ref> [BS86] </ref>. They claim the resulting system provides a virtual machine for the system specification, rather than simply a virtual machine on which the application program executes.
Reference: [Bud95] <author> Reinhard Budde. Esterel. </author> <title> In Formal Development of Reactive Systems: </title> <booktitle> Case Study Production Cell, </booktitle> <pages> pages 75-100, </pages> <year> 1995. </year>
Reference-contexts: Although believing the approach simplified the design of the controller, the group implementing the Esterel controller concluded that `the advantages are limited if either many kernels are loosely coupled or if the 12 data structures used are complex' <ref> [Bud95] </ref>. The resulting executable program was 46 Kilobytes, with 26 Kilobytes resulting directly from Esterel and the remainder primarily resulting from the low-level C routines. 0.5 System Programming Considerations High-performance concurrent reactive systems play a central role in the future of operating systems.
Reference: [DDH72] <author> O. J. Dahl, Edsger W. Dijkstra, and C. A. R. Hoare. </author> <title> Structured Programming. </title> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference-contexts: Finally, the `lower' machine may have a set of private variables, introduced for its own benefit and completely outside the scope of the upper machine... until finally we have a program that can be executed by our hardware' <ref> [DDH72] </ref>. Perhaps because Dijkstra is explaining layered architecture and step-wise design in a book on structured programming, he does not propose literally implementing such a multiple-level instruction interpreter, but rather is motivating an abstract model of structured programming languages.
Reference: [Dij75] <author> Edsger W. Dijkstra. </author> <title> Guarded commands, nondeterminacy and formal derivation of programs. </title> <journal> Communications of the ACM, </journal> <volume> 18(8) </volume> <pages> 453-457, </pages> <month> August </month> <year> 1975. </year>
Reference-contexts: This section examines whether the synchronous/reactive techniques considered in the previous section are appropriate for high performance generic system software. 0.5.1 General Observations As indicated by the `guard' balloons in the figures, all the languages described enable programming large state machines using parallel variations of Dijkstra's guarded commands <ref> [Dij75] </ref> [Hal77]. To understand the source code in these systems, one identifies the guard locations and determines the conditions under which a guard will activate. For instance, in reading Esterel or RC, a productive first step is to identify all emits and all corresponding guards.
Reference: [DK76] <author> Frank DeRemer and Hans H. Kron. </author> <title> Programming in the large versus programming in the small. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 2(2) </volume> <pages> 80-86, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: The control constructs can be more elaborate than those in hardware instruction sets and can resemble those of any high-level programming language. The reactive level provides for programming-in-the-large and exposes one view of the deep structure of the program <ref> [DK76] </ref>. A synchronous lower program level consists of soft-instruction implementations. Soft-instruction implementations perform the programming-in-the-small tasks required of the program. Soft-instructions are written in a traditional system programming language such as C. These routines are written in a stylized manner defined by each specific implementation of the soft-instruction architecture.
Reference: [Edw94] <author> Stephen Edwards. </author> <title> An Esterel compiler for a synchronous/reactive development system. </title> <type> Technical Report ERL 94-43, </type> <institution> University of California, Berkeley, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: Although typical of guarded command languages and designed explicitly for reactive environments, NPL does not assume the synchrony hypothesis. 0.4.2 Esterel Esterel is the oldest synchronous/reactive language and the best documented [BC84] [BdS91] [BG92] [Hal93] <ref> [Edw94] </ref>. The design of Esterel was motivated by an effort to develop a semantics of parallel and real-time programming following Robin Milner's theories of synchronous process algebras [Mil93]. A complete Esterel module is shown in Figure 0.4 and code fragments in Figures 0.3 and 0.5. <p> These orderings correspond to all possible input sequences. Observations such as these motivated the Esterel compiler of Edwards, which resembles a traditional compiler <ref> [Edw94] </ref>. Source code is translated to assembler, and the resulting routines dispatched by a run-time reaction dispatch work-loop. This compiler is reported to have roughly linear compile time, output size, and output execution time. Edwards attempted to compile a 1000 line Es-terel program using both compiler approaches.
Reference: [FP88] <author> Stuart R. Faulk and David L. Parnas. </author> <title> On synchronization in hard-real-time systems. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 274-287, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Good system software invariably adopts a well defined software architecture. The architectures used for system software are usually based on some form of explicitly coded critical sections [Atw76] <ref> [FP88] </ref> [Her91]. However, explicit critical sections introduce nondeterminism and are a root cause of many concurrent programming difficulties [Her90].
Reference: [Fur92] <author> Koichi Furukawa. </author> <title> Logic programming as the integrator of the fifth generation computer systems project. </title> <journal> Communications of the ACM, </journal> <volume> 35(3) </volume> <pages> 82-92, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Concurrent Prolog was expressly designed for systems programming and provided dataflow style synchronization via nondeterministic guarded-commands as its basic control mechanism [Sha86a] [Sha87]. Concurrent Prolog served as the basis for KL1, the Kernel Language used to write the operating system for the Japanese Fifth Generation project <ref> [Fur92] </ref>. Regarding efficiency of Concurrent Prolog implementation efforts, Shapiro reports: ` ... It was a deathblow to the imple-mentability of Concurrent Prolog, at least for the time being, since it showed that implementing Concurrent Prolog efficiently is as hard, and probably harder than, implementing OR-parallel Prolog.
Reference: [Gar95] <author> David Garlan. </author> <booktitle> First international workshop on architectures for software systems: Workshop summary. ACM Software Engineering Notes, </booktitle> <volume> 20(3) </volume> <pages> 84-89, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: A software architecture provides an identifiable approach or framework often implicitly framed by the adopted tools, languages, and development environments [GTP95] <ref> [Gar95] </ref>. Good system software invariably adopts a well defined software architecture. The architectures used for system software are usually based on some form of explicitly coded critical sections [Atw76] [FP88] [Her91]. However, explicit critical sections introduce nondeterminism and are a root cause of many concurrent programming difficulties [Her90].
Reference: [GL91] <author> Keith Brian Gallagher and James R. Lyle. </author> <title> Using program slicing in software maintenance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(8) </volume> <pages> 751-760, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: There have been efforts in the debugging community to analyze sequential programs and determine information similar to that needed to automatically generate soft-instructions [Wei82]. These program slicing algorithms are currently impractical for real programs <ref> [GL91] </ref> [Hu93]. In parallel and distributed programming research, coordination frameworks support subroutine-level parallelism [Pan93]. Examples of such systems are Parallel Virtual Machine (PVM), STRAND88, Program Composition Notation (PCN), and Express.
Reference: [Gla83] <author> Robert L. Glass. </author> <title> Real-Time Software. </title> <publisher> Prentice-Hall, </publisher> <year> 1983. </year>
Reference-contexts: The advantages of `traditional' soft-instruction flavored cyclic executives, as used in real-time avionics, have previously been enumerated and contrasted with conventional multithreading techniques using preemptive scheduling of lightweight threads [Mac80] <ref> [Gla83] </ref> [Sha86b] [BS86]. MacLaren, in discussing one such system, notes that `the efficiency of a cyclic executive derives from its minimal scheduling property, and from the very small implementation cost' [Mac80].
Reference: [GP95] <author> David Garlan and Dewayne E. Perry. </author> <title> Introduction to the special issue on software architecture. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 269-274, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: The kernel is often considered simply another component that has primary responsibility for CPU allocation and interrupt dispatching. 0.1.2 Software Architecture Software architecture has been defined as `The structure of the components of a program/system, their interrelationships, and principles and guidelines governing their design and evolution over time' <ref> [GP95] </ref>. A software architecture is distinguished by `a shared repertoire of methods, techniques, patterns and idioms for structuring complex software systems'. Software architectures provide an abstract conceptual approach to complex systems more specific than the models often inherent in a general purpose language but more general than a single design.
Reference: [GTP95] <author> David Garlan, Walter Tichy, and Frances Paulisch. </author> <booktitle> Summary of the Dagstuhl workshop on software architecture. ACM Software Engineering Notes, </booktitle> <volume> 20(3) </volume> <pages> 63-83, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Software architectures provide an abstract conceptual approach to complex systems more specific than the models often inherent in a general purpose language but more general than a single design. A software architecture provides an identifiable approach or framework often implicitly framed by the adopted tools, languages, and development environments <ref> [GTP95] </ref> [Gar95]. Good system software invariably adopts a well defined software architecture. The architectures used for system software are usually based on some form of explicitly coded critical sections [Atw76] [FP88] [Her91]. However, explicit critical sections introduce nondeterminism and are a root cause of many concurrent programming difficulties [Her90].
Reference: [Hal77] <author> Horst Halling. </author> <title> Steps towards the implementation of a parallel code executor. </title> <booktitle> In Proceedings of the IFAC/IFIP Workshop, </booktitle> <pages> pages 55-63, </pages> <month> June </month> <year> 1977. </year>
Reference-contexts: This section examines whether the synchronous/reactive techniques considered in the previous section are appropriate for high performance generic system software. 0.5.1 General Observations As indicated by the `guard' balloons in the figures, all the languages described enable programming large state machines using parallel variations of Dijkstra's guarded commands [Dij75] <ref> [Hal77] </ref>. To understand the source code in these systems, one identifies the guard locations and determines the conditions under which a guard will activate. For instance, in reading Esterel or RC, a productive first step is to identify all emits and all corresponding guards.
Reference: [Hal93] <author> Nicolas Halbwachs. </author> <title> Synchronous Programming of Reactive Systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Under sustained near worst case conditions, however, nondeterministic systems that must expend run-time overhead scheduling their activities are less efficient than cyclic systems [Kop91]. 0.3 Synchronous Languages Recently, synchronous software architectures have been proposed specifically for reactive systems [BB91] <ref> [Hal93] </ref>. The resulting synchronous/reactive systems include data-flow and declarative approaches as well as more traditional imperative languages. None of these approaches have proven intrinsically more powerful than the others, and an effort is currently underway to provide a common `back-end' for a number of these systems. <p> Although typical of guarded command languages and designed explicitly for reactive environments, NPL does not assume the synchrony hypothesis. 0.4.2 Esterel Esterel is the oldest synchronous/reactive language and the best documented [BC84] [BdS91] [BG92] <ref> [Hal93] </ref> [Edw94]. The design of Esterel was motivated by an effort to develop a semantics of parallel and real-time programming following Robin Milner's theories of synchronous process algebras [Mil93]. A complete Esterel module is shown in Figure 0.4 and code fragments in Figures 0.3 and 0.5. <p> A complete Esterel module is shown in Figure 0.4 and code fragments in Figures 0.3 and 0.5. Sethi, and Figures 0.4 and 0.5 follow an example by Halbwachs [MS90] <ref> [Hal93] </ref>. Esterel is not a complete programming language. It is a program generator used to describe the reactive kernel of reactive programs, that is, it provides a deterministic reactive control harness which calls routines written in a conventional programming language. Program execution forms a discrete sequence of instants. <p> The new global state is... lines 3, 16, and 24... line 3 is interrupted. ... comes back to ... line 3. ... control is stopped at lines 3, 16, 28, and 32' <ref> [Hal93] </ref>. It is thus difficult to program Esterel or RC without drawing timelines, mapping source statements to the timeline, and mentally executing code fragments.
Reference: [Her90] <author> Maurice Herlihy. </author> <title> A methodology for implementing highly concurrent data structures. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP), </booktitle> <month> March </month> <year> 1990. </year>
Reference-contexts: Good system software invariably adopts a well defined software architecture. The architectures used for system software are usually based on some form of explicitly coded critical sections [Atw76] [FP88] [Her91]. However, explicit critical sections introduce nondeterminism and are a root cause of many concurrent programming difficulties <ref> [Her90] </ref>. Since synchronous languages do not contain explicit critical sections, software architectures based on such languages may have advantages over traditional architectures. 0.2 Reactive Systems A reactive system is event-driven, maintains a permanent interaction with its environment, and executes at a rate determined by the environment [HP85]. <p> A concurrent system is non-blocking if some member is guaranteed to complete an operation in a finite number of system steps. A system is wait-free if it can be guaranteed that each member completes an operation in a finite number of system steps [Her91] <ref> [Her90] </ref>. Investigating alternatives to process-based concurrency is a current research area.
Reference: [Her91] <author> Maurice Herlihy. </author> <title> Wait-free synchronization. </title> <journal> Communications of the ACM, </journal> <volume> 11(1) </volume> <pages> 124-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Good system software invariably adopts a well defined software architecture. The architectures used for system software are usually based on some form of explicitly coded critical sections [Atw76] [FP88] <ref> [Her91] </ref>. However, explicit critical sections introduce nondeterminism and are a root cause of many concurrent programming difficulties [Her90]. <p> A concurrent system is non-blocking if some member is guaranteed to complete an operation in a finite number of system steps. A system is wait-free if it can be guaranteed that each member completes an operation in a finite number of system steps <ref> [Her91] </ref> [Her90]. Investigating alternatives to process-based concurrency is a current research area.
Reference: [HG91] <author> C. Huizing and R. Gerth. </author> <title> Semantics of reactive systems in abstract time. </title> <booktitle> In Real-Time: Theory in Practice, </booktitle> <pages> pages 291-314, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Programming RC's micro instants, which require explicit source code coordination, resembles conventional concurrent programming. Micro instants introduce `invisible gotos' and their attendant programming difficulties. Additionally, Huizing and Gerth note that the semantics of such micro instants `turned out to be too subtle and non-deterministic to be of practical use' <ref> [HG91] </ref>. The problem of distributed mental state is not solved by any of these languages. Understanding the interaction of cooperative code scattered throughout a program presents a serious cognitive challenge to program comprehension [LS86]. <p> In their semantics `global' time is more abstract than `local' time. This proposal is of special interest as it is intended to overcome problems in the semantics of Esterel <ref> [HG91] </ref>. Discrete-event simulations often use architectures similar to soft-instructions but without direct real-time application. These environments are usually not intended for development of large system programs. An example of such a programming environment is Reactive-C, not to be confused with the RC described earlier in this paper [Su90].
Reference: [HP85] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive systems. Logics and Models of Concurrent Systems, </title> <booktitle> NATO ASI Series, </booktitle> <volume> 13 </volume> <pages> 477-498, </pages> <year> 1985. </year> <note> 0.10. Conclusions 31 </note>
Reference-contexts: Since synchronous languages do not contain explicit critical sections, software architectures based on such languages may have advantages over traditional architectures. 0.2 Reactive Systems A reactive system is event-driven, maintains a permanent interaction with its environment, and executes at a rate determined by the environment <ref> [HP85] </ref>. Reactive systems are assumed to execute with performance sufficient to ensure they are never overdriven by their environment. Since under normal circumstances a reactive system never terminates, reactive systems cannot be characterized as a simple function from a single initial input state to a single final output state.
Reference: [Hu93] <author> Shibin Hu. </author> <title> Automatic Generation of Language-Based Program Slicer. </title> <type> PhD thesis, </type> <institution> Wayne State University, </institution> <year> 1993. </year>
Reference-contexts: There have been efforts in the debugging community to analyze sequential programs and determine information similar to that needed to automatically generate soft-instructions [Wei82]. These program slicing algorithms are currently impractical for real programs [GL91] <ref> [Hu93] </ref>. In parallel and distributed programming research, coordination frameworks support subroutine-level parallelism [Pan93]. Examples of such systems are Parallel Virtual Machine (PVM), STRAND88, Program Composition Notation (PCN), and Express.
Reference: [Joh70] <author> Frederick C. Johnson. </author> <title> Real-time data processing and orbit determination on the Apollo tracking ships, </title> <booktitle> NASA-CR-111576. In AGARD Conference Proceedings No. 68 on the Application of Digital Computers to Guidance and Control, AGARD-CP68-70, </booktitle> <pages> pages 22-32. </pages> <address> Harford House, </address> <month> June </month> <year> 1970. </year>
Reference-contexts: Baker and Scallon trace the origins of these systems at least back to the AgPrep system developed by DBA Systems for the Apollo range ship <ref> [Joh70] </ref>. This system apparently functioned as a special linker that processed tables of entry points and scheduling requirements called agendas. The soft-instruction approach has many similarities to the threaded-code architectures used by some Microsoft applications and languages such as Forth and UCSD Pascal [Kog82].
Reference: [JS89] <author> S. B. Jones and A. F. Sinclair. </author> <title> Functional programming and operating systems. </title> <journal> The Computer Journal, </journal> <volume> 32(2) </volume> <pages> 162-174, </pages> <year> 1989. </year>
Reference-contexts: Real-time systems are reactive systems with the addition of timing constraints. Operating systems are inherently reactive and provide the archetypical example of large reactive systems <ref> [JS89] </ref> [MK93]. The term reactive is more specific than the informal term event-driven, which is widely used and overloaded. For instance, an event-driven program may calculate a simple transformation and terminate. <p> For instance, in describing the design of a functional operating system based on streams, Jones and Sinclair note that `operating systems are inherently reactive', but that `it is not clear that operating systems can be written without modeling nondeterministic behavior' <ref> [JS89] </ref>. They discuss such efforts in the functional language community, including an effort to provide implicit time determinism, timestamps, and clock oracles, and note that `The effect of this proposal is to place non-determinism entirely outside the software..'. They remark: 0.5. <p> They remark: 0.5. System Programming Considerations 13 `In recent years, however, research activity on the functional operating systems front has been rather quiet, possibly because the experiments reported above showed that... it does not always lead to greater elegance and clarity in the detailed coding of programs' <ref> [JS89] </ref>. Logic programming approaches have fared little better. Concurrent Prolog was expressly designed for systems programming and provided dataflow style synchronization via nondeterministic guarded-commands as its basic control mechanism [Sha86a] [Sha87].
Reference: [KKW94] <author> Andrew J. Kozubal, Debora M. Ker-stiens, and Rozelle M. Wright. </author> <title> Experience with the State Notation Language and run-time sequencer. Nuclear Instruments and Methods in Physics Research A, </title> <address> 352(1,2):411-414, </address> <year> 1994. </year>
Reference-contexts: Programmers are often provided with special languages for integrating state machines into their program source. State Notation Language (SNL) is typical of these languages [Koz93] <ref> [KKW94] </ref>. SNL is used for I/O intensive control systems and is compatible with C system programming. An example SNL program fragment is shown in Figure 0.1. This code turns a light on when a voltage exceeds 5 volts and off when the voltage falls below 3 volts.
Reference: [Kog82] <author> Peter M. Kogge. </author> <title> An architectural trail to threaded-code systems. </title> <journal> IEEE Computer, </journal> <volume> 15(3) </volume> <pages> 22-32, </pages> <month> March </month> <year> 1982. </year>
Reference-contexts: In threaded-code terminology, such a loop is an inner interpreter or address interpreter. On some architectures such interpreters can be reduced to a single instruction, and as such they do not have the negative performance connotations of high-level outer interpreters <ref> [Kog82] </ref>. 0.6.4 Short-term and Long-term Stacks Each valid context structure provides an explicit context for an internally competitive concurrent soft-instruction stream. A single program run-time stack provides space for short-term variables with lives lasting the duration of the current soft-instruction execution. <p> This system apparently functioned as a special linker that processed tables of entry points and scheduling requirements called agendas. The soft-instruction approach has many similarities to the threaded-code architectures used by some Microsoft applications and languages such as Forth and UCSD Pascal <ref> [Kog82] </ref>. These systems are usually single threaded, that is, have a single context block, and thus concurrent programming is not integral to the basic threading system. Threaded-code is often used as an implementation technique in memory constrained environments.
Reference: [Kop91] <author> H. Kopetz. </author> <title> Event-triggered versus time-triggered real-time systems. </title> <editor> In A. Karshmer and J. Nehmer, editors, </editor> <booktitle> Operating Systems of the 90s and Beyond, </booktitle> <pages> pages 87-101. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: While effective, the overhead of such pessimistic systems can be high, as code executes on a rigid table-driven timeline even if not needed. Under sustained near worst case conditions, however, nondeterministic systems that must expend run-time overhead scheduling their activities are less efficient than cyclic systems <ref> [Kop91] </ref>. 0.3 Synchronous Languages Recently, synchronous software architectures have been proposed specifically for reactive systems [BB91] [Hal93]. The resulting synchronous/reactive systems include data-flow and declarative approaches as well as more traditional imperative languages.
Reference: [Koz93] <author> Andy Kozubal. </author> <title> State Notation Language and Run-time Sequencer Users Guide. </title> <institution> Los Alamos National Laboratory, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: Programmers are often provided with special languages for integrating state machines into their program source. State Notation Language (SNL) is typical of these languages <ref> [Koz93] </ref> [KKW94]. SNL is used for I/O intensive control systems and is compatible with C system programming. An example SNL program fragment is shown in Figure 0.1. This code turns a light on when a voltage exceeds 5 volts and off when the voltage falls below 3 volts.
Reference: [KVK91] <author> Ilkka Kuuluvainen, Mika Vanttinen, and Perttu Koskinen. </author> <title> The action-state diagram: A compact finite state machine representation for user interfaces and small embedded reactive systems. </title> <journal> IEEE Transactions on Consumer Electronics, </journal> <volume> 37(3) </volume> <pages> 651-658, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: SNL is considered easy to understand and use. For slightly larger applications, such as standalone industrial controllers, some means of providing hierarchical structuring of state machines is required. A typical industrial system, intended to support up to around 150 states, is the Action-State diagram <ref> [KVK91] </ref>. This approach resembles coupling decision tables and state transition diagrams. The decision tables are compiled into hierarchical tables of action-routine addresses. A work-loop then sequentially executes action routines in response to events and the current state.
Reference: [Lam94] <author> Leslie Lamport. </author> <title> Processes are in the eye of the beholder. </title> <type> Technical Report 132, </type> <institution> Digital Systems Research Center, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: Investigating alternatives to process-based concurrency is a current research area. For instance, Lamport notes that processes are an artifact and need not be adopted as a fundamental primitive in theories of concurrency <ref> [Lam94] </ref>. 0.4 Current Studies Selected efforts relating to synchronous/reactive programming are examined in this section, primarily with respect to their source code and potential applicability to system programming. 0.4.1 Meta/NPL The ISIS system is a reliable distributed system developed at Cornell [BJ87].
Reference: [Laz91] <author> Edward D. Lazowska. </author> <title> Operating system support for high-performance architectures. </title> <editor> In A. Karshmer and J. Nehmer, editors, </editor> <booktitle> Operating Systems of the 90s and Beyond, </booktitle> <pages> pages 40-43. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: Typically, one of these registers is the application stack pointer, so there is usually a stack associated with each thread defined by a set of non-privileged registers. A lightweight context switch is often an order of magnitude faster than a heavyweight context switch <ref> [Laz91] </ref>. High-performance systems occasionally are designed which switch only a subset of the non-privileged registers. This approach is used in some transaction systems, such as IBM's TPF, and is often used within the interrupt handling component of operating systems [Mar90].
Reference: [LL95] <author> Claus Lewerentz and Thomas Linder. </author> <title> Formal Development of Reactive Systems: Case Study Production Cell. </title> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: The group recommended that maintainability must be addressed before any of the evaluated methods would be suitable for large-scale industrial use. A German research effort evaluated 18 different reactive programming systems amenable to formal analysis by funding implementations of the same `toy' manufacturing cell controller in each system <ref> [LL95] </ref>. As with the ATT evaluation, Esterel was included but not RC. The resulting 400 line Esterel program provided a reactive control harness for conventional C routines.
Reference: [LS86] <author> Stanley Letovsky and Elliot Soloway. </author> <title> Delocalized plans and program comprehension. </title> <journal> IEEE Software, </journal> <volume> 3(3) </volume> <pages> 41-49, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: The problem of distributed mental state is not solved by any of these languages. Understanding the interaction of cooperative code scattered throughout a program presents a serious cognitive challenge to program comprehension <ref> [LS86] </ref>. Programs written in a guarded command dataflow style can require considerable study before overall program behavior is deduced. Since every routine potentially executes every instant, and since control can be located in the midst of each routine, the programmer potentially must keep the entire program state in mind.
Reference: [Mac80] <author> Lee MacLaren. </author> <title> Evolving toward ADA in real-time systems. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on the ADA Language, </booktitle> <address> Boston, </address> <month> December </month> <year> 1980. </year>
Reference-contexts: The advantages of `traditional' soft-instruction flavored cyclic executives, as used in real-time avionics, have previously been enumerated and contrasted with conventional multithreading techniques using preemptive scheduling of lightweight threads <ref> [Mac80] </ref> [Gla83] [Sha86b] [BS86]. MacLaren, in discussing one such system, notes that `the efficiency of a cyclic executive derives from its minimal scheduling property, and from the very small implementation cost' [Mac80]. <p> in real-time avionics, have previously been enumerated and contrasted with conventional multithreading techniques using preemptive scheduling of lightweight threads <ref> [Mac80] </ref> [Gla83] [Sha86b] [BS86]. MacLaren, in discussing one such system, notes that `the efficiency of a cyclic executive derives from its minimal scheduling property, and from the very small implementation cost' [Mac80]. Shaw classifies real-time software as either based on concurrent interacting processes, or based on table-driven soft-instruction style approaches, which he terms slice-based following that usage in BBN's Pluribus IMP Arpanet communication processor [OCK + 75] [Sha86b]. Shaw notes that soft-instruction equivalents have been called slices, chunks, and strips.
Reference: [Mar90] <author> R. Jordan Martin. </author> <title> Transaction Processing Facility: A Guide for Application Programmers. </title> <publisher> Yourdon Press, </publisher> <year> 1990. </year>
Reference-contexts: High-performance systems occasionally are designed which switch only a subset of the non-privileged registers. This approach is used in some transaction systems, such as IBM's TPF, and is often used within the interrupt handling component of operating systems <ref> [Mar90] </ref>. Context switching a subset of the non-privileged registers will be called featherweight in the remainder of this paper. In the extreme, featherweight context switching involves switching only a single register, which usually is the base register of a data context describing a transaction or service request. <p> Historically, such approaches have long been used in areas such as real-time avionics and high performance transaction processing. Example systems that have been described include Boeing's Rex and IBM's TPF [BS86] <ref> [Mar90] </ref>.
Reference: [MB91] <author> J.C. Mogul and A. Borg. </author> <title> The effect of context switches on cache performance. </title> <booktitle> In Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 75-84, </pages> <year> 1991. </year>
Reference-contexts: This is especially true for servers requiring a very high degree of competitive internal concur-rency, for instance, servers for transaction processing, databases, networks, and multimedia. Context switch overhead bounds the performance of conventional multithreading approaches based on heavyweight and lightweight concurrency [Ous89] <ref> [MB91] </ref> [ALBL91]. Context switch code paths through general purpose systems are lengthy and context switches destroy locality of reference assumptions upon which high performance systems rely. Featherweight context switch techniques that can provide a high degree of both competitive and cooperative internal concurrency are thus of interest.
Reference: [Mil93] <author> Robin Milner. </author> <title> Turing award lecture: Elements of interaction. </title> <journal> Communications of the ACM, </journal> <volume> 36(1) </volume> <pages> 78-89, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The design of Esterel was motivated by an effort to develop a semantics of parallel and real-time programming following Robin Milner's theories of synchronous process algebras <ref> [Mil93] </ref>. A complete Esterel module is shown in Figure 0.4 and code fragments in Figures 0.3 and 0.5. Sethi, and Figures 0.4 and 0.5 follow an example by Halbwachs [MS90] [Hal93]. Esterel is not a complete programming language.
Reference: [MK93] <author> K. R. Mayes and J. A. Keane. </author> <title> Levels of atomic action in the Flagship parallel system. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 5(3) </volume> <pages> 193-212, </pages> <year> 1993. </year>
Reference-contexts: Real-time systems are reactive systems with the addition of timing constraints. Operating systems are inherently reactive and provide the archetypical example of large reactive systems [JS89] <ref> [MK93] </ref>. The term reactive is more specific than the informal term event-driven, which is widely used and overloaded. For instance, an event-driven program may calculate a simple transformation and terminate.
Reference: [MS90] <author> Gary J. Murakami and Ravi Sethi. </author> <title> Terminal call processing in Esterel. </title> <journal> ATT, </journal> <month> January </month> <year> 1990. </year>
Reference-contexts: A complete Esterel module is shown in Figure 0.4 and code fragments in Figures 0.3 and 0.5. Sethi, and Figures 0.4 and 0.5 follow an example by Halbwachs <ref> [MS90] </ref> [Hal93]. Esterel is not a complete programming language. It is a program generator used to describe the reactive kernel of reactive programs, that is, it provides a deterministic reactive control harness which calls routines written in a conventional programming language. Program execution forms a discrete sequence of instants. <p> Many Esterel statements are effectively constructed as macros using the do and trap statements as primitives. Sethi, contains a code-block that assembles a string of input characters into a buffer, subject to a timeout <ref> [MS90] </ref>. If a BREAK occurs, the baud rate of the input line is re-determined and buffer assembly restarted. This is a typical small systems programming problem. The &lt;trap GET STRING&gt; in Figure 0.3 enables &lt;exit GET STRING&gt; to exit the code-block. Signal RESTART is declared with local name scope.
Reference: [MW91] <author> Keith Marzullo and Mark D. Wood. </author> <title> Tools for constructing distributed reactive systems. </title> <type> Technical Report TR 91-1193, </type> <institution> Cornell, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: While attempting a 6 large distributed ISIS application, the need arose for a distributed reactive toolkit because ISIS lacked tools for distributed control <ref> [MW91] </ref>. This motivated the development of Meta, a toolkit for building non-real-time reactive systems. Meta provides a state machine language called NPL. NPL is a guarded command language providing a globally consistent view of distributed state. Guarded commands are interpreted and have atomic action semantics.
Reference: [Neh91] <author> Jurgen Nehmer. </author> <title> The immortality of operating systems, or is research in operating systems still justified? In A. </title> <editor> Karsh-mer and J. Nehmer, editors, </editor> <booktitle> Operating 32 Systems of the 90s and Beyond, </booktitle> <pages> pages 77-83. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1991. </year>
Reference: [OCK + 75] <author> S.M. Ornstein, W.R. Crowther, M.F. Kraley, R.D. Bressler, A. Michel, and F.E. Hart. </author> <title> Pluribus a reliable multiprocessor. </title> <booktitle> In Procedings of the AFIPS 1975 Conference, </booktitle> <pages> pages 551-559, </pages> <year> 1975. </year>
Reference-contexts: Shaw classifies real-time software as either based on concurrent interacting processes, or based on table-driven soft-instruction style approaches, which he terms slice-based following that usage in BBN's Pluribus IMP Arpanet communication processor <ref> [OCK + 75] </ref> [Sha86b]. Shaw notes that soft-instruction equivalents have been called slices, chunks, and strips. He contrasts the two real-time software architectures, and calls for research in including time as a first class programming object.
Reference: [Ous89] <author> John Ousterhout. </author> <title> Why aren't operating systems getting faster as fast as hardware? Technical Report TN-11, </title> <institution> Digital Western Research Laboratory, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: This is especially true for servers requiring a very high degree of competitive internal concur-rency, for instance, servers for transaction processing, databases, networks, and multimedia. Context switch overhead bounds the performance of conventional multithreading approaches based on heavyweight and lightweight concurrency <ref> [Ous89] </ref> [MB91] [ALBL91]. Context switch code paths through general purpose systems are lengthy and context switches destroy locality of reference assumptions upon which high performance systems rely. Featherweight context switch techniques that can provide a high degree of both competitive and cooperative internal concurrency are thus of interest.
Reference: [Pan93] <author> Cherri M. Pancake. </author> <title> Multithreaded languages for scientific and technical computing. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 81(2) </volume> <pages> 288-304, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: There have been efforts in the debugging community to analyze sequential programs and determine information similar to that needed to automatically generate soft-instructions [Wei82]. These program slicing algorithms are currently impractical for real programs [GL91] [Hu93]. In parallel and distributed programming research, coordination frameworks support subroutine-level parallelism <ref> [Pan93] </ref>. Examples of such systems are Parallel Virtual Machine (PVM), STRAND88, Program Composition Notation (PCN), and Express. These systems have many soft-instruction characteristics: `The programmer codes subroutines in some standard programming language... the tool automatically generates a source code `wrapper' for each subroutine, as well as a driver... <p> The coordination language is not really `compiled'; rather, it is transformed into calls to runtime libraries in a preprocessing step before compilation' <ref> [Pan93] </ref>. These systems are intended for writing distributed applications on top of existing operating systems. The level of granularity of these systems is often not appropriate for systems programming. A large amount of work has been performed on multithreaded runtimes and parallel programming environments for massively parallel machines.
Reference: [PJ75] <author> W. F. C. Purser and D. M. Jennings. </author> <title> The design of a real-time operating system for a minicomputer. </title> <journal> Software Practice and Experience, </journal> <volume> 5:147167, </volume> <year> 1975. </year>
Reference-contexts: Many VIs can be constructed... ... In general, therefore, a VI is not entered in parallel and hence is non-reentrant' 0.9. Related Work 27 <ref> [PJ75] </ref>. Mixed hardware/software instruction stream interpretation, with custom user written routines extending the machine instruction set, is an old idea [Bra82].
Reference: [Rep95] <author> John H. Reppy. </author> <title> First-class synchronous operations. </title> <booktitle> In Proceedings of the First International Workshop on Theory and Practice of Parallel Programming, </booktitle> <pages> pages 235-252, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: In general, modern win-dowing systems have used approaches based on explicit application event dispatch work-loops and call-backs rather than thread-based concurrency. This concurrency style, convenient in highly interactive cooperative environments, is sometimes called faux concurrency <ref> [Rep95] </ref>. Concurrent service requests for file, network, database, and transaction systems often have a high degree of independence. Unlike message and window servers, two arbitrary service requests to this type of server are usually competitive.
Reference: [Sch86] <author> Fred B. Schneider. </author> <title> Concepts for concurrent programming. </title> <booktitle> In Current Trends in Concurrency, </booktitle> <pages> pages 669-236. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Each component is generally capable of servicing multiple concurrent requests, some of which may be of long-duration, and some of which may have real-time constraints. Thus, operating system software constitutes a significant concurrent programming problem, and it is widely agreed that development of such software remains difficult [Atw76] <ref> [Sch86] </ref> [Wat90]. There are many ways to view concurrency. The remainder of this section describes concurrent programming considerations germane to the design and programming of concurrent system software, that is, concurrency from the viewpoint of the system programmer.
Reference: [Sha86a] <author> Ehud Shapiro. </author> <title> Concurrent Prolog: A progress report. </title> <journal> IEEE Computer, </journal> <volume> 19(8) </volume> <pages> 44-58, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Logic programming approaches have fared little better. Concurrent Prolog was expressly designed for systems programming and provided dataflow style synchronization via nondeterministic guarded-commands as its basic control mechanism <ref> [Sha86a] </ref> [Sha87]. Concurrent Prolog served as the basis for KL1, the Kernel Language used to write the operating system for the Japanese Fifth Generation project [Fur92]. Regarding efficiency of Concurrent Prolog implementation efforts, Shapiro reports: ` ... <p> It was a deathblow to the imple-mentability of Concurrent Prolog, at least for the time being, since it showed that implementing Concurrent Prolog efficiently is as hard, and probably harder than, implementing OR-parallel Prolog. As we all know, no one knows how to implement OR-parallel Prolog efficiently, as yet' <ref> [Sha86a] </ref>. 0.5.2 Implementation Concerns It is not possible to ignore software engineering issues such as performance, size, and maintainability when evaluating system software. There are a number of means by which one can implement synchronous/reactive languages.
Reference: [Sha86b] <author> Alan C. Shaw. </author> <title> Software clocks, concurrent programming, and slice-based scheduling. </title> <booktitle> In Proceedings of the 1986 Real-Time Systems Symposium, </booktitle> <pages> pages 14-18, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: The advantages of `traditional' soft-instruction flavored cyclic executives, as used in real-time avionics, have previously been enumerated and contrasted with conventional multithreading techniques using preemptive scheduling of lightweight threads [Mac80] [Gla83] <ref> [Sha86b] </ref> [BS86]. MacLaren, in discussing one such system, notes that `the efficiency of a cyclic executive derives from its minimal scheduling property, and from the very small implementation cost' [Mac80]. <p> Shaw classifies real-time software as either based on concurrent interacting processes, or based on table-driven soft-instruction style approaches, which he terms slice-based following that usage in BBN's Pluribus IMP Arpanet communication processor [OCK + 75] <ref> [Sha86b] </ref>. Shaw notes that soft-instruction equivalents have been called slices, chunks, and strips. He contrasts the two real-time software architectures, and calls for research in including time as a first class programming object. Current real-time and concurrent programming research tends to emphasize replacing, rather than modernizing, soft-instruction related approaches.
Reference: [Sha87] <author> Ehud Shapiro. </author> <title> Systems programming in Concurrent Prolog. </title> <booktitle> In Concurrent Prolog, </booktitle> <volume> volume 2, </volume> <pages> pages 6-27, </pages> <year> 1987. </year>
Reference-contexts: Logic programming approaches have fared little better. Concurrent Prolog was expressly designed for systems programming and provided dataflow style synchronization via nondeterministic guarded-commands as its basic control mechanism [Sha86a] <ref> [Sha87] </ref>. Concurrent Prolog served as the basis for KL1, the Kernel Language used to write the operating system for the Japanese Fifth Generation project [Fur92]. Regarding efficiency of Concurrent Prolog implementation efforts, Shapiro reports: ` ...
Reference: [Su90] <author> Wen-King Su. </author> <title> Reactive-Process Programming and Distributed Discrete-Event Simulation. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: Discrete-event simulations often use architectures similar to soft-instructions but without direct real-time application. These environments are usually not intended for development of large system programs. An example of such a programming environment is Reactive-C, not to be confused with the RC described earlier in this paper <ref> [Su90] </ref>. There have been efforts in the debugging community to analyze sequential programs and determine information similar to that needed to automatically generate soft-instructions [Wei82]. These program slicing algorithms are currently impractical for real programs [GL91] [Hu93]. In parallel and distributed programming research, coordination frameworks support subroutine-level parallelism [Pan93].
Reference: [SW92] <author> Mary Shaw and William A. Wulf. </author> <title> Tyrannical languages still preempt system design. </title> <booktitle> In Proceedings 1992 International Conference on Computer Languages, </booktitle> <pages> pages 200-211. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> April </month> <year> 1992. </year>
Reference-contexts: Because the reactive dispatcher is small enough to be routinely customized, the architecture leaves the system programmer in control at all levels, unlike approaches which preempt the programmer's design prerogatives <ref> [SW92] </ref>. The synchronicity model adopted by soft-instructions is weaker than the strong synchronicity model assumed by synchronous/reactive languages such as Esterel, but it is intuitive to systems programmers familiar with hardware instruction sets.
Reference: [Wat90] <author> David A. Watt. </author> <title> Programming Language Concepts and Paradigms. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Each component is generally capable of servicing multiple concurrent requests, some of which may be of long-duration, and some of which may have real-time constraints. Thus, operating system software constitutes a significant concurrent programming problem, and it is widely agreed that development of such software remains difficult [Atw76] [Sch86] <ref> [Wat90] </ref>. There are many ways to view concurrency. The remainder of this section describes concurrent programming considerations germane to the design and programming of concurrent system software, that is, concurrency from the viewpoint of the system programmer.
Reference: [Wei82] <author> Mark Weiser. </author> <title> Programmers use slices when debugging. </title> <journal> Communications of the ACM, </journal> <pages> pages 446-452, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: An example of such a programming environment is Reactive-C, not to be confused with the RC described earlier in this paper [Su90]. There have been efforts in the debugging community to analyze sequential programs and determine information similar to that needed to automatically generate soft-instructions <ref> [Wei82] </ref>. These program slicing algorithms are currently impractical for real programs [GL91] [Hu93]. In parallel and distributed programming research, coordination frameworks support subroutine-level parallelism [Pan93]. Examples of such systems are Parallel Virtual Machine (PVM), STRAND88, Program Composition Notation (PCN), and Express.
References-found: 70

