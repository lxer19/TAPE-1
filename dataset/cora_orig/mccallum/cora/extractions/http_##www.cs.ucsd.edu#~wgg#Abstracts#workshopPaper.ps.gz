URL: http://www.cs.ucsd.edu/~wgg/Abstracts/workshopPaper.ps.gz
Refering-URL: http://www.cs.ucsd.edu/~wgg/papers.html
Root-URL: http://www.cs.ucsd.edu
Abstract-found: 0
Intro-found: 0
Reference: 1. <author> Fredrick P. Brooks Jr. </author> <title> No Silver Bullet: </title> <journal> essence and accidents of software engineering. IEEE Computer, </journal> <volume> 20(4) </volume> <pages> 10-19, </pages> <year> 1987. </year>
Reference-contexts: Finally, since the information in a program is often not projectable into two dimensions, a graphical representation of a program can degrade into a spider web of connecting arcs for larger programs <ref> [1] </ref>, a problem often encountered in program visualization. This problem can be mitigated by techniques such as those used in the Rigi program understanding system, which allows its user to remove extraneous information with elision and tool-assisted grouping of structural [11].
Reference: 2. <author> R. K. Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1987. </year>
Reference-contexts: The second task is to insert the modification into the restructured program. The meaning-preserving nature of the tool obviates the need to test the restructured program for added errors before proceeding with the modification. In the prototype tool, which restructures programs written in the imperative programming language Scheme <ref> [2] </ref>, the software engineer manipulates the structure of the program by selecting expressions in the source code as parameters to a restructuring operation (Fig. 1). The primary benefit of restructuring source code is that it is the most familiar and commonly available representation [17].
Reference: 3. <author> Peter Eades. </author> <title> A heuristic for graph drawing. </title> <journal> Congressum Numerantium, </journal> <volume> 42 </volume> <pages> 149-160, </pages> <year> 1984. </year>
Reference-contexts: Currently the tool uses a simple algorithm for initial layout, then allows the software engineer to interactively improve the layout. The engineer's adjustments then can be used in automatic layout decisions and saved for future restructuring sessions. More sophisticated layout techniques, such as force-directed heuristics <ref> [3] </ref> can reduce the need for user customization. 7 Related Work There are many systems that support working graphically with programs. We discuss a few that are most relevant to our work. The Rigi reverse engineering environment provides semi-automatic construction of system views that assist understanding [11].
Reference: 4. <author> William G. Griswold. </author> <title> Program Restructuring to Aid Software Maintenance. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <year> 1991. </year>
Reference-contexts: However, it is a complex, program-wide activity that is error-prone when performed manually [5]. Techniques have been described for automatically maintaining the program's consistency as the user manipulates the structure of a program, and a prototype tool for performing meaning-preserving restructuring has been implemented using the techniques <ref> [4] </ref> [6]. The tool improves the process of making maintenance changes by separating the process into two sequential, independent tasks. <p> the tool. 5 Example To demonstrate the nature of the design-level restructuring tool, we describe some of the operations that convert a functional decomposition of the KWIC (Key Word In Context) index production program into a data-encapsulated decomposition of the program [12]. (The transformations are described in greater detail in <ref> [4] </ref>). KWIC takes a text file as input and produces the list of words appearing in the document, with the context of each word (the rest of its enclosing line, circularly shifted to place the keyed word at the beginning of the line) appearing with it. Fig. 3.
Reference: 5. <author> William G. Griswold and David Notkin. </author> <title> Computer-aided vs. manual program restructuring. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 17(1), </volume> <year> 1992. </year>
Reference-contexts: Restructuring is the more attractive approach. However, it is a complex, program-wide activity that is error-prone when performed manually <ref> [5] </ref>. Techniques have been described for automatically maintaining the program's consistency as the user manipulates the structure of a program, and a prototype tool for performing meaning-preserving restructuring has been implemented using the techniques [4] [6].
Reference: 6. <author> William G. Griswold and David Notkin. </author> <title> Automated assistance for program restructuring. </title> <journal> Transactions on Software Engineering and Methodology, </journal> <volume> 2(3), </volume> <year> 1993. </year>
Reference-contexts: However, it is a complex, program-wide activity that is error-prone when performed manually [5]. Techniques have been described for automatically maintaining the program's consistency as the user manipulates the structure of a program, and a prototype tool for performing meaning-preserving restructuring has been implemented using the techniques [4] <ref> [6] </ref>. The tool improves the process of making maintenance changes by separating the process into two sequential, independent tasks. The first is to restructure the program, without changing its meaning, into a form that localizes the scope of the modification or otherwise improves the structure to prepare for the modification.
Reference: 7. <author> David Harel, Hagi Lachover, Amnon Naamad, Amir Pnueli, Michal Politi, Rivi Sherman, Aharon Shtull-Trauring, and Mark Trakhtenbrot. STATEMATE: </author> <title> a working environment for the development of complex reactive systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 403-414, </pages> <year> 1990. </year>
Reference-contexts: The Garden project [13] notes that programmers benefit from using many notations during design, each view suited to a design technique. The STATEM-ATE environment, for instance, supports this need by providing physical layout, dataflow, and state machine notations to describe and prototype reactive systems <ref> [7] </ref>. Garden permits the programmer to define custom textual and graphical notations and describe designs with these notations. Garden then keeps the multiple views of a design consistent with each other as manipulations are performed, and supports limited rule-based execution of the designs to permit testing certain properties.
Reference: 8. <author> M. M. Lehman and L. A. Belady. </author> <title> Program Evolution: processes of software change. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: As repeated modifications are made, the design and implementation become increasingly less understandable until maintenance becomes unacceptably ? This work was supported in part by NSF Grant CCR-9211002. expensive, and the only solutions are to reimplement the system or restructure it <ref> [8] </ref>. Restructuring is the more attractive approach. However, it is a complex, program-wide activity that is error-prone when performed manually [5].
Reference: 9. <author> B. Lientz and E. Swanson. </author> <title> Software Maintenance Management: A Study of the Maintenance of Computer Application Software in 487 Data Processing Organizations. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1980. </year>
Reference-contexts: 1 The Problem Software is perceived to be too expensive relative to its quality. Since maintenance is the dominant phase in the program life-cycle <ref> [9] </ref>, substantially reducing the cost of software requires lowering the cost of maintenance. As useful software ages, modifications to meet the needs and demands of users are layered upon the original implementation.
Reference: 10. <author> Mark Moriconi and Dwight F. Hare. </author> <title> Visualizing program designs through PegaSys. </title> <journal> IEEE Computer, </journal> <volume> 18(8) </volume> <pages> 72-85, </pages> <year> 1985. </year>
Reference-contexts: A representation that better represents structure and design information is needed. 2 Graphical Interfaces for Restructuring One possible solution is to use a graphical design notation to represent the program. Graphical representations of design are used in many existing tools <ref> [10] </ref> [13] because the pictorial representation of structure often can convey the needed information in a more readily assimilable manner. A graphical representation can convey program component relationships through direct linkage and grouping, allowing immediate comprehension. A graphical notation also allows the soft Fig. 1. <p> However, this should be possible for some real design notations, given that the appropriate links can be made between the design and the implementation to allow simultaneous restructuring of the two. The PegaSys system <ref> [10] </ref> (see Related Work) uses a simple technique for the user to establish links when they cannot be automatically derived. <p> For example, the notation we use can highlight data-encapsulated structure. Another quality of the design, such as layering, might benefit from a customized notation displaying layering properties. The PegaSys system is a program analysis system based on visual formalisms <ref> [10] </ref>. Although the formal verification of program properties is valuable, the work involved in dealing with textual formalisms and relating them to the program implementation is daunting. PegaSys adds a layer of visual formalisms on top of textual ones to speed constructing a description and facilitate understanding.
Reference: 11. <author> H. A. Muller, S. R. Tilley, M. A. Orgun, B. D. Corrie, and N. H. Madhavaji. </author> <title> A reverse engineering environment based on spacial and visual software interconnection models. </title> <booktitle> In Fifth ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 88-98, </pages> <year> 1992. </year>
Reference-contexts: This problem can be mitigated by techniques such as those used in the Rigi program understanding system, which allows its user to remove extraneous information with elision and tool-assisted grouping of structural <ref> [11] </ref>. Similarly, automatically generating readable layouts of structure charts is difficult for large programs. Currently the tool uses a simple algorithm for initial layout, then allows the software engineer to interactively improve the layout. <p> We discuss a few that are most relevant to our work. The Rigi reverse engineering environment provides semi-automatic construction of system views that assist understanding <ref> [11] </ref>. Views are initially constructed by the environment and then modified and augmented by the environment user. These additions by the user allow describing the system in abstractions not visible in the implementation.
Reference: 12. <author> D. L. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058, </pages> <year> 1972. </year>
Reference-contexts: As useful software ages, modifications to meet the needs and demands of users are layered upon the original implementation. Modifications unanticipated in the design sometimes are not easily integrated into the existing implementation, requiring changes to multiple modules in the system to complete a single change <ref> [12] </ref>. As repeated modifications are made, the design and implementation become increasingly less understandable until maintenance becomes unacceptably ? This work was supported in part by NSF Grant CCR-9211002. expensive, and the only solutions are to reimplement the system or restructure it [8]. Restructuring is the more attractive approach. <p> color screen image of the structure manipulation interface for the tool. 5 Example To demonstrate the nature of the design-level restructuring tool, we describe some of the operations that convert a functional decomposition of the KWIC (Key Word In Context) index production program into a data-encapsulated decomposition of the program <ref> [12] </ref>. (The transformations are described in greater detail in [4]).
Reference: 13. <author> Steven P. Reiss. </author> <title> Working in the Garden environment for conceptual programming. </title> <journal> IEEE Software, </journal> <volume> 4(6) </volume> <pages> 16-27, </pages> <year> 1987. </year>
Reference-contexts: A representation that better represents structure and design information is needed. 2 Graphical Interfaces for Restructuring One possible solution is to use a graphical design notation to represent the program. Graphical representations of design are used in many existing tools [10] <ref> [13] </ref> because the pictorial representation of structure often can convey the needed information in a more readily assimilable manner. A graphical representation can convey program component relationships through direct linkage and grouping, allowing immediate comprehension. A graphical notation also allows the soft Fig. 1. Text-oriented user interface for Restructuring Tool. <p> Rigi currently only analyzes the text to the extent required to derive the high-level design relationships. The Garden project <ref> [13] </ref> notes that programmers benefit from using many notations during design, each view suited to a design technique. The STATEM-ATE environment, for instance, supports this need by providing physical layout, dataflow, and state machine notations to describe and prototype reactive systems [7].
Reference: 14. <author> Lawrence A. Rowe, Joseph A. Konstan, Brian C. Smith, Steve Seitz, and Chung Liu. </author> <title> The PICASSO application framework. </title> <booktitle> In 14th ACM Symposium on User Interface Software and Technology, </booktitle> <pages> pages 95-106, </pages> <year> 1991. </year>
Reference-contexts: The restructuring tool is written in Allegro Common Lisp, and uses the Pi-casso Application Framework <ref> [14] </ref> to implement the graphical user interface portions of the code. The tool runs on a Sun Sparcstation 2 workstation. Currently under development are module-level transformations and data-driven inference of unspecified parameters.
Reference: 15. <author> Guy L. Steele Jr. </author> <title> Common Lisp the Language. </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: A variable reference is displayed in its containing procedure as a separate object, thus allowing the programmer to manipulate either the variable reference or the variable declaration. Modules are also included (in the sense of Common Lisp's packages <ref> [15] </ref>). Since Scheme's scoping rules allow functions and variables within other functions and modules, such objects are drawn in a nested manner. To assist the tool user in identifying where a variable is referenced, a variable reference is graphically connected with the variable declaration it references. Fig. 2.
Reference: 16. <author> W. P. Stevens, G. J. Myers, and L. L. Constantine. </author> <title> Structured design. </title> <journal> IBM Systems Journal, </journal> <volume> 13(2) </volume> <pages> 115-139, </pages> <year> 1974. </year>
Reference-contexts: The graphical notation we chose (see Figs. 2 and 4) is similar to the structure chart notation described in "Structured Design" <ref> [16] </ref>. We use the notation because it represents many of the objects we intend the user to manipulate, and presents relations necessary for understanding how to restructure a program. The original notation presents functions, call-graph information, and intra-function variable references. <p> To assist the tool user in identifying where a variable is referenced, a variable reference is graphically connected with the variable declaration it references. Fig. 2. Our notation for describing structure, derived from "Structured Design" <ref> [16] </ref>. The variable access symbols exist within functions, and represent variable accesses made by the function. Variable accesses are always graphically connected to the variable they represent.
Reference: 17. <author> Mark Weiser. </author> <title> Source code. </title> <journal> IEEE Computer, </journal> 20(11) 66-73, 1987. This article was processed using the L a T E X macro package with LLNCS style 
Reference-contexts: The primary benefit of restructuring source code is that it is the most familiar and commonly available representation <ref> [17] </ref>. Also, restructuring the source does not require changing representations between restructuring and modification. However, manipulating a program's structure through its implementation is inappropriate because manipulating structure is a design issue, not an implementation issue.
References-found: 17

