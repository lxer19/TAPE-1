URL: ftp://ftp.cs.rochester.edu/pub/papers/theory/96.tr638.Universally_serializable_computation.ps.gz
Refering-URL: http://www.cs.rochester.edu/trs/theory-trs.html
Root-URL: 
Title: Universally Serializable Computation  
Author: Lane A. Hemaspaandra Mitsunori Ogihara 
Abstract: Cai and Furst [CF91] proved that every PSPACE language can be solved via a large number of identical, simple tasks, each of which is provided with the original input, its own unique task number, and at most three bits of output from the previous task. In the Cai-Furst model, the tasks are required to be run in the order specified by the task numbers. To study the extent to which the Cai-Furst PSPACE result is due to this strict scheduling, we remove their ordering restriction, allowing tasks to execute in any serial order. That is, we study the extent to which complex tasks can be decomposed into large numbers of simple tasks that can be scheduled arbitrarily. We provide upper bounds on the complexity of the sets thus accepted. Our bounds suggest that Cai and Furst's surprising PSPACE result is due in large part to the fixed order of their task execution. In fact, our bounds suggest the possibility that even relatively low levels of the polynomial hierarchy cannot be accepted via large numbers of simple tasks that can be scheduled arbitrarily. However, adding randomization recaptures the polynomial hierarchy: the entire polynomial hierarchy can be accepted by large numbers of arbitrarily scheduled probabilistic tasks passing only a single bit of information between successive tasks (and using J. Simon's "exact counting" acceptance mechanism). In fact, we show that the class of languages so accepted is exactly NP PP . 
Abstract-found: 1
Intro-found: 1
Reference: [Bar89] <author> D. Barrington. </author> <title> Bounded-width polynomial-size branching programs recognize exactly those languages in NC 1 . Journal of Computer and System Sciences, </title> <booktitle> 38 </booktitle> <pages> 150-164, </pages> <year> 1989. </year>
Reference-contexts: The computation "accepts" if the final task outputs some particular value (e.g., "1"). Building on Barrington's <ref> [Bar89] </ref> seminal work on branching programs, Cai and Furst prove that every PSPACE language can be accepted in this way, even if the tasks run in logarithmic space rather than in polynomial time. <p> Ogihara ([Ogi94], see also [BS95]) has put upper and lower bounds on the complexity of SF 3 and SF 4 . Finally, as mentioned earlier, Cai and Furst [CF91], building on the work of Barrington <ref> [Bar89] </ref>, proved that PSPACE = SF 5 = SF 6 = , a result that, as described in Section 1, motivated this paper. The intuition behind Definition 2.5 is that, as discussed in Section 1, we wish to study how crucial the task scheduling is in the serializable computation. <p> Furthermore, it follows from Toda's Theorem [Tod91] that this class is relatively inclusive, as NP PP PH = NP PP . Of course, just as Cai and Furst drew on Barrington's <ref> [Bar89] </ref> work on branching problems, one might hope that here we can draw on work on probabilistic branching programs. Indeed, probabilistic branching programs have been studied by Kilian [Kil90]. However, we cannot obtain our desired results from this work for two reasons.
Reference: [BC93] <author> D. Bovet and P. Crescenzi. </author> <title> Introduction to the Theory of Complexity. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference: [Bei91] <author> R. Beigel. </author> <title> Relativized counting classes: Relations among thresholds, parity, </title> <journal> and mods. Journal of Computer and System Sciences, </journal> <volume> 42(1) </volume> <pages> 76-96, </pages> <year> 1991. </year>
Reference-contexts: This special "zero rejects" condition is somewhat reminiscent of the ModZP classes of Beigel <ref> [Bei91] </ref>, and thus our use of the letter "Z" in our notation. Boolean hierarchies for a variety of classes including NP [CGH + 88,CGH + 89], UP [HR], and R [BJY90] have been studied recently in complexity theory. <p> In fact, the second part of the theorem even implies that SF A 3 6 k SSF A k . The proof of Theorem 3.3 relies on Toran's [Tor88,Tor91] basic work, revisited and extended by Beigel <ref> [Bei91] </ref>, on the relativized relationship between nondeterministic computation and parity-like computation. The proof also relies on the fact that SF 2 = R p m (NNT), 2 SF 3 , and Theorem 3.1 all relativize. <p> will have no effect on the coNP machine's acceptance, and thus by diagonalizing against the P machine via Toran's procedure, we in this case also diagonalize against the language accepted by the intersection of the coNP machine and the P machine. (2) The proof is based on the construction in <ref> [Bei91] </ref> of an oracle A relative to which NP 6 coMod k P. Define L (A) = f0 n j (9x : jxj = n) (8y : jyj = n) [xy 2 A]g: Then L (A) 2 NP NP A .
Reference: [BGH90] <author> R. Beigel, J. Gill, and U. Hertrampf. </author> <title> Counting classes: Thresholds, parity, </title> <booktitle> mods, and fewness. In Proceedings of the 7th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 49-57. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #415, </note> <month> February </month> <year> 1990. </year>
Reference-contexts: It is known that MOD q h P = MOD q P for any prime q and h 1 <ref> [BGH90] </ref>. So whether P p i=1 E (i; j) freq 1 (ff i ) is a multiple of r j can be tested by conjunctive queries to at most e of the classes MOD q P with q being prime and no greater than k. <p> A predicate of the first type can be decomposed as a conjunction of predicates in various coMod q P for prime powers q k. Since Mod p t P = Mod p P for any prime p and Mod p P is closed under polynomial-time Turing reductions <ref> [BGH90] </ref>, the conjunction of the predicates of the first type is actually decomposed as a conjunction of predicates in various coMod q P for primes q k. Since coMod n P is closed under conjunctive truth-table reductions for any n [BGH90], this conjunction is combined into a single predicate in coMod <p> and Mod p P is closed under polynomial-time Turing reductions <ref> [BGH90] </ref>, the conjunction of the predicates of the first type is actually decomposed as a conjunction of predicates in various coMod q P for primes q k. Since coMod n P is closed under conjunctive truth-table reductions for any n [BGH90], this conjunction is combined into a single predicate in coMod n k P, where n k is the product of all primes less than or equal to k.
Reference: [BJY90] <author> D. Bruschi, D. Joseph, and P. Young. </author> <title> Strong separations for the boolean hierarchy over RP. </title> <journal> International Journal of Foundations of Computer Science, </journal> <volume> 1(3) </volume> <pages> 201-218, </pages> <year> 1990. </year>
Reference-contexts: This special "zero rejects" condition is somewhat reminiscent of the ModZP classes of Beigel [Bei91], and thus our use of the letter "Z" in our notation. Boolean hierarchies for a variety of classes including NP [CGH + 88,CGH + 89], UP [HR], and R <ref> [BJY90] </ref> have been studied recently in complexity theory. For our purposes, it suffices to consider the most standard Boolean hierarchy, namely, that built over NP. This hierarchy contains exactly those sets that can be accepted via a finite tree of Boolean operations on NP sets.
Reference: [BS95] <author> R. Beigel and H. Straubing. </author> <title> The power of local self-reductions. </title> <booktitle> In Proceedings of the 10th Structure in Complexity Theory Conference, </booktitle> <pages> pages 277-285. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: Immediately, one can apply to SF 2 the various results of Hemaspaandra and Hoene [HH91]. For example, though SF 2 = R p m (NNT), nonetheless SF 2 = NNT only if P = NP = PP PH . Ogihara ([Ogi94], see also <ref> [BS95] </ref>) has put upper and lower bounds on the complexity of SF 3 and SF 4 .
Reference: [CF87] <author> J. Cai and M. Furst. </author> <title> PSPACE survives three-bit bottlenecks. </title> <booktitle> In Proceedings of the 2nd Structure in Complexity Theory Conference, </booktitle> <pages> pages 94-102. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: that for each A, PSPACE A = SSF A 5 = SSF A Though these results raise the possibility that large numbers of flexibly schedulable tasks do not suffice even to accept sets from the second level of the polynomial hierarchy, we show that large 1 The notation used in <ref> [CF87] </ref> and [Ogi94] is off by one in the k subscript compared with the notation of [CF91]. We uniformly use the notation of the former two papers.
Reference: [CF91] <author> J. Cai and M. Furst. </author> <title> PSPACE survives constant-width bottlenecks. </title> <journal> International Journal of Foundations of Computer Science, </journal> <volume> 2(1) </volume> <pages> 67-76, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction A key theme in modern computer science is the decomposition of a complex task into a number of smaller, simpler, tasks. Though this is often studied in the context of parallel computation, Cai and Furst <ref> [CF91] </ref> investigate this issue in terms of serial computation. <p> It seems remarkable that any PSPACE language computation can be "strung out" in such a fashion. (One would not have expected that the rise and fall of the sun or other terrestrial bodies provided us with any [such] valuable computing resource as space.) <ref> [CF91] </ref> They are indeed correct in pointing out that the rising and setting of the sun, in this setting, provides a weak form of access to space. <p> raise the possibility that large numbers of flexibly schedulable tasks do not suffice even to accept sets from the second level of the polynomial hierarchy, we show that large 1 The notation used in [CF87] and [Ogi94] is off by one in the k subscript compared with the notation of <ref> [CF91] </ref>. We uniformly use the notation of the former two papers. That is, SF k and SSF k are about machines that pass k-ary outputs between tasks. 2 numbers of flexibly schedulable probabilistic tasks do suffice to accept all sets from the polynomial hierarchy. <p> It is known (see [HH91]) that this is equivalent to the class of languages accepted via a P machine given both the input and advice|depending on the input|from an OptP function. Fix k 1. Following Cai and Furst <ref> [CF91] </ref>, consider a "machine" specified by (a) a task-name-length polynomial t (), (b) a token set f0; 1; ; k 1g, and (c) a polynomial-time program f : fl fi N fi f0; 1; ; k 1g ! f0; 1; ; k 1g. <p> Again following Cai and Furst, for the special case k = 1 we alter the definition of output to define acceptance to mean that the program f (x; (2 t (jxj) ); h 2 t (jxj) 1 ) itself ends in some accepting state. Definition 2.4 <ref> [CF91] </ref> A language L is in SF k ("safe storage via k tokens") if there exists a machine of the form described above (with k as the k above) such that, for each x, it holds that x 2 L () output (x; I) = accept, where I is the identity <p> The following results are known about the SF k classes. SF 1 = P <ref> [CF91] </ref>. Ogihara has shown directly that SF 2 = OptP [Ogi94]. <p> Ogihara ([Ogi94], see also [BS95]) has put upper and lower bounds on the complexity of SF 3 and SF 4 . Finally, as mentioned earlier, Cai and Furst <ref> [CF91] </ref>, building on the work of Barrington [Bar89], proved that PSPACE = SF 5 = SF 6 = , a result that, as described in Section 1, motivated this paper. <p> Can one resolve the remaining issues regarding closure under complementation and other Boolean operations? For example, can one prove that SF 3 , SF 4 , and SSF k , k 3, are closed under Boolean operations? 4 Universally Serializable Probabilistic Computation As discussed earlier, Cai and Furst <ref> [CF91] </ref> showed that all languages in PSPACE can be accepted via many simple tasks scheduled in a particular way.
Reference: [CGH + 88] <author> J. Cai, T. Gundermann, J. Hartmanis, L. Hemachandra, V. Sewelson, K. Wagner, and G. Wechsung. </author> <title> The boolean hierarchy I: Structural properties. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(6) </volume> <pages> 1232-1252, </pages> <year> 1988. </year>
Reference-contexts: For our purposes, it suffices to consider the most standard Boolean hierarchy, namely, that built over NP. This hierarchy contains exactly those sets that can be accepted via a finite tree of Boolean operations on NP sets. Definition 2.7 <ref> [CGH + 88] </ref> 1. BH (0) = P: 2. For each k 1; BH (k) = NP BH (k 1): 3. <p> Proof: (1) Each set in BH (k) can be expressed as L 1 (L 2 ( (L k1 L k ) )), with L 1 L 2 L k1 L k <ref> [CGH + 88] </ref>. Our SSF machine keeps track of the largest k for which some witness has been seen certifying that the input is in L k . The zero token is used to mean that for no k has a certificate been seen.
Reference: [CGH + 89] <author> J. Cai, T. Gundermann, J. Hartmanis, L. Hemachandra, V. Sewelson, K. Wagner, and G. Wechsung. </author> <title> The boolean hierarchy II: </title> <journal> Applications. SIAM Journal on Computing, </journal> <volume> 18(1) </volume> <pages> 95-111, </pages> <year> 1989. </year>
Reference: [CH90] <author> J. Cai and L. Hemachandra. </author> <title> On the power of parity polynomial time. </title> <journal> Mathematical Systems Theory, </journal> <volume> 23(2) </volume> <pages> 95-106, </pages> <year> 1990. </year>
Reference-contexts: For any nondeterministic Turing machine M and any x 2 fl , we denote by acc M (x) the number of accepting computation paths of M on input x. Definition 2.1 <ref> [CH90] </ref> For each k 2, define: L 2 Mod k P if and only if there is a nondeterministic polynomial-time Turing machine M such that, for each x, it holds that x 2 L () acc M (x) 6 0 (modulo k).
Reference: [GNW90] <author> T. Gundermann, N. Nasser, and G. Wechsung. </author> <title> A survey on counting classes. </title> <booktitle> In Proceedings of the 5th Structure in Complexity Theory Conference, </booktitle> <pages> pages 140-153. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> July </month> <year> 1990. </year>
Reference-contexts: For any set S, we denote by jjSjj the cardinality of S. We assume that the integers have their standard binary encodings. Let C 1 and C 2 be any classes. Following the convention of Gundermann, Nasser, and Wech-sung <ref> [GNW90] </ref>, we use C 1 _ C 2 to denote fL j (9L 1 2 C 1 ) (9L 2 2 C 2 ) [L = L 1 S C 1 ^ C 2 to denote fL j (9L 1 2 C 1 ) (9L 2 2 C 2 ) [L
Reference: [GP86] <author> L. Goldschlager and I. Parberry. </author> <title> On the construction of parallel computers from various bases of boolean functions. </title> <journal> Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 43-58, </pages> <year> 1986. </year>
Reference-contexts: As is standard, P will be used to represent Mod 2 P, a class first studied by Papadimitriou and Zachos [PZ83], and Goldschlager and Parberry <ref> [GP86] </ref>. OptP [Kre88], informally stated, is the class of functions computing the maxima of multivalued NP functions. Definition 2.2 [Kre88] For a nondeterministic Turing transducer M , define S M (x) to be the set of all outputs of M on x.
Reference: [Hem93] <author> L. Hemachandra. </author> <title> Fault-tolerance and complexity. </title> <booktitle> In Proceedings of the 20th International Colloquium on Automata, Languages, and Programming, </booktitle> <pages> pages 189-202. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #700, </note> <month> July </month> <year> 1993. </year> <month> 21 </month>
Reference-contexts: For example, in a quite different context, invariance under some perturbation is also required in the theory of "robust computation" (see the survey <ref> [Hem93] </ref>).
Reference: [Hem94] <author> L. Hemaspaandra. </author> <title> The not-ready-for-prime-time conjectures. </title> <journal> SIGACT News, </journal> <volume> 25(2):5--10, </volume> <month> June </month> <year> 1994. </year>
Reference-contexts: In fact, though NP P trivially implies a few consequences (e.g., FewP NP S P NP P), it is a notorious open problem to prove from this assumption that the entire polynomial hierarchy falls within P, the seemingly helpful known fact that P P = P notwithstanding (see <ref> [Hem94] </ref>; the problem is that it is not at all clear that NP P ) NP NP P P ). Part 2 of Theorem 3.3 displayed a relativized world in which the second level of the polynomial hierarchy was not contained in the SSF hierarchy.
Reference: [HH91] <author> L. Hemachandra and A. Hoene. </author> <title> On sets with efficient implicit membership tests. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(6) </volume> <pages> 1148-1156, </pages> <year> 1991. </year>
Reference-contexts: A function f belongs to OptP if there exist a polynomial time-bounded nondeterministic Turing machine transducer M and a function 2 fmax; ming such that for every x, otherwise. Definition 2.3 <ref> [HH91] </ref> OptP [HH91] is the class of languages L such that for some P set L 0 and for some f 2 OptP, (8x 2 fl ) [x 2 L () f (x) 2 L 0 ]. It is known (see [HH91]) that this is equivalent to the class of languages <p> A function f belongs to OptP if there exist a polynomial time-bounded nondeterministic Turing machine transducer M and a function 2 fmax; ming such that for every x, otherwise. Definition 2.3 <ref> [HH91] </ref> OptP [HH91] is the class of languages L such that for some P set L 0 and for some f 2 OptP, (8x 2 fl ) [x 2 L () f (x) 2 L 0 ]. It is known (see [HH91]) that this is equivalent to the class of languages accepted via <p> Definition 2.3 <ref> [HH91] </ref> OptP [HH91] is the class of languages L such that for some P set L 0 and for some f 2 OptP, (8x 2 fl ) [x 2 L () f (x) 2 L 0 ]. It is known (see [HH91]) that this is equivalent to the class of languages accepted via a P machine given both the input and advice|depending on the input|from an OptP function. Fix k 1. <p> The following results are known about the SF k classes. SF 1 = P [CF91]. Ogihara has shown directly that SF 2 = OptP [Ogi94]. Let NNT denote the nearly near-testable sets <ref> [HH91] </ref>, the class of sets L having a polynomial-time computable function f that on each input x either states that x 2 L, or that x 62 L, or that exactly one of x and the lexicographical predecessor of x is in L, or that not exactly one of x and <p> So, SF 2 = R p m (NNT). Ogihara's SF 2 result and this observation about the close connection between SF 2 and NNT are in harmony, as it is known that OptP = R p m (NNT) <ref> [HH91] </ref>. Immediately, one can apply to SF 2 the various results of Hemaspaandra and Hoene [HH91]. For example, though SF 2 = R p m (NNT), nonetheless SF 2 = NNT only if P = NP = PP PH . <p> Ogihara's SF 2 result and this observation about the close connection between SF 2 and NNT are in harmony, as it is known that OptP = R p m (NNT) <ref> [HH91] </ref>. Immediately, one can apply to SF 2 the various results of Hemaspaandra and Hoene [HH91]. For example, though SF 2 = R p m (NNT), nonetheless SF 2 = NNT only if P = NP = PP PH . Ogihara ([Ogi94], see also [BS95]) has put upper and lower bounds on the complexity of SF 3 and SF 4 . <p> Since SSF 1 = SF 1 = P and SF k = PSPACE for all k 5, these classes are closed 15 under all Boolean operations. Since SF 2 = OptP and OptP is closed under all Boolean oper-ations <ref> [HH91] </ref>, so is SF 2 . Also, SF 3 and SF 4 are both close under complementation [Ogi94]|we have only to append a new task at the end, which moves a token at position 1 to position 0 and a token at position 6= 1 to 1.
Reference: [HR] <author> L. Hemaspaandra and J. </author> <title> Rothe. Unambiguous computation: Boolean hierarchies and sparse Turing-complete sets. </title> <journal> SIAM Journal on Computing. </journal> <note> To appear. </note>
Reference-contexts: This special "zero rejects" condition is somewhat reminiscent of the ModZP classes of Beigel [Bei91], and thus our use of the letter "Z" in our notation. Boolean hierarchies for a variety of classes including NP [CGH + 88,CGH + 89], UP <ref> [HR] </ref>, and R [BJY90] have been studied recently in complexity theory. For our purposes, it suffices to consider the most standard Boolean hierarchy, namely, that built over NP. This hierarchy contains exactly those sets that can be accepted via a finite tree of Boolean operations on NP sets.
Reference: [Jac74] <author> N. Jacobson. Basic Algebra I. W. H. Freeman, </author> <year> 1974. </year>
Reference-contexts: It is well-known that any finite Abelian group is a direct product of cyclic groups of prime power orders (and that these orders and their multiplicities are unique and determine the group up to isomorphism) <ref> [Jac74, Theorem 3.13] </ref>.
Reference: [Kil90] <author> J. Kilian. </author> <title> Uses of Randomness in Algorithms and Protocols. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Of course, just as Cai and Furst drew on Barrington's [Bar89] work on branching problems, one might hope that here we can draw on work on probabilistic branching programs. Indeed, probabilistic branching programs have been studied by Kilian <ref> [Kil90] </ref>. However, we cannot obtain our desired results from this work for two reasons. First, we require universal serializability, and his work is in the (analog of the) "fixed schedule" model.
Reference: [Kre88] <author> M. Krentel. </author> <title> The complexity of optimization problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 36 </volume> <pages> 490-509, </pages> <year> 1988. </year>
Reference-contexts: As is standard, P will be used to represent Mod 2 P, a class first studied by Papadimitriou and Zachos [PZ83], and Goldschlager and Parberry [GP86]. OptP <ref> [Kre88] </ref>, informally stated, is the class of functions computing the maxima of multivalued NP functions. Definition 2.2 [Kre88] For a nondeterministic Turing transducer M , define S M (x) to be the set of all outputs of M on x. <p> As is standard, P will be used to represent Mod 2 P, a class first studied by Papadimitriou and Zachos [PZ83], and Goldschlager and Parberry [GP86]. OptP <ref> [Kre88] </ref>, informally stated, is the class of functions computing the maxima of multivalued NP functions. Definition 2.2 [Kre88] For a nondeterministic Turing transducer M , define S M (x) to be the set of all outputs of M on x.
Reference: [KSTT92] <author> J. Kobler, U. Schoning, S. Toda, and J. Toran. </author> <title> Turing machines with few accepting computations and low sets for PP. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 44(2) </volume> <pages> 272-286, </pages> <year> 1992. </year>
Reference: [LLS75] <author> R. Ladner, N. Lynch, and A. Selman. </author> <title> A comparison of polynomial time reducibilities. </title> <journal> Theoretical Computer Science, </journal> <volume> 1(2) </volume> <pages> 103-124, </pages> <year> 1975. </year>
Reference-contexts: Let N = f1; 2; g. We adopt the standard polynomial-time reducibility notions of Ladner, Lynch, and Selman <ref> [LLS75] </ref>. Definitions of classes or notions not defined in this section (e.g., P, NP, and coNP) can be found in any standard complexity theory textbook [Pap94,BC93].
Reference: [Ogi94] <author> M. </author> <title> Ogihara. </title> <journal> On serializable languages. International Journal of Foundations of Computer Science, </journal> 5(3&4):303-318, 1994. 
Reference-contexts: each A, PSPACE A = SSF A 5 = SSF A Though these results raise the possibility that large numbers of flexibly schedulable tasks do not suffice even to accept sets from the second level of the polynomial hierarchy, we show that large 1 The notation used in [CF87] and <ref> [Ogi94] </ref> is off by one in the k subscript compared with the notation of [CF91]. We uniformly use the notation of the former two papers. <p> The following results are known about the SF k classes. SF 1 = P [CF91]. Ogihara has shown directly that SF 2 = OptP <ref> [Ogi94] </ref>.
Reference: [OL93] <author> M. Ogiwara and A. Lozano. </author> <title> On sparse hard sets for counting classes. </title> <journal> Theoretical Computer Science, </journal> <volume> 112(2) </volume> <pages> 255-275, </pages> <year> 1993. </year>
Reference: [Pap94] <author> C. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference: [PZ83] <author> C. Papadimitriou and S. Zachos. </author> <title> Two remarks on the power of counting. </title> <booktitle> In Proceedings 6th GI Conference on Theoretical Computer Science, </booktitle> <pages> pages 269-276. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #145, </note> <year> 1983. </year>
Reference-contexts: As is standard, P will be used to represent Mod 2 P, a class first studied by Papadimitriou and Zachos <ref> [PZ83] </ref>, and Goldschlager and Parberry [GP86]. OptP [Kre88], informally stated, is the class of functions computing the maxima of multivalued NP functions. Definition 2.2 [Kre88] For a nondeterministic Turing transducer M , define S M (x) to be the set of all outputs of M on x. <p> For example, can one prove: SSF 2 = SF 2 ) PH collapses?(14) Note, however, that (since NP P ) OptP = P = NP + _ z P, as OptP is in FP NP and P P = P <ref> [PZ83] </ref>): Proposition 3.4 NP P ) SF 2 = SSF 2 . But this says that even easier than establishing (14) would be establishing the following: NP P ) PH collapses.(15) However (15) itself is very open.
Reference: [Sim75] <author> J. Simon. </author> <title> On Some Central Problems in Computational Complexity. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <address> Ithaca, N.Y., </address> <month> January </month> <year> 1975. </year> <note> Available as Cornell Department of Computer Science Technical Report TR75-224. </note>
Reference-contexts: In such a setting, it is in fact the notion that has come to be known as the "exact counting" acceptance mechanism. This mechanism was introduced by J. Simon <ref> [Sim75, p. 94] </ref>, who proved that exact counting can be simulated by general probabilistic computation (in current terminology, C = P PP).
Reference: [TO92] <author> S. Toda and M. Ogiwara. </author> <title> Counting classes are at least as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21(2) </volume> <pages> 316-328, </pages> <year> 1992. </year>
Reference: [Tod91] <author> S. </author> <title> Toda. PP is as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(5) </volume> <pages> 865-877, </pages> <year> 1991. </year>
Reference-contexts: As always, we require that the tasks be universally serializable: some task ordering leads to acceptance if and only if every task ordering leads to acceptance. We prove that the class of languages thus accepted is exactly NP PP . Since Toda's Theorem <ref> [Tod91] </ref> implies that NP PP = NP PP PH , we see that the entire polynomial hierarchy (and more) can be accepted by flexibly scheduled probabilistic tasks passing only one bit of information between successive tasks. <p> Denote the class of languages so accepted by ProbabilisticSSF 2 . We will prove that ProbabilisticSSF 2 = NP PP . This class is relatively robust, as it is well-known that NP PP = NP C = P = NP #P [Tor91]. Furthermore, it follows from Toda's Theorem <ref> [Tod91] </ref> that this class is relatively inclusive, as NP PP PH = NP PP . Of course, just as Cai and Furst drew on Barrington's [Bar89] work on branching problems, one might hope that here we can draw on work on probabilistic branching programs.
Reference: [Tor88] <author> J. Toran. </author> <title> Structural Properties of the Counting Hierarchies. </title> <type> PhD thesis, </type> <institution> Universitat Politecnica de Catalunya, </institution> <address> Barcelona, Spain, </address> <year> 1988. </year>
Reference: [Tor91] <author> J. Toran. </author> <title> Complexity classes defined by counting quantifiers. </title> <journal> Journal of the ACM, </journal> <volume> 38 </volume> <pages> 753-774, </pages> <year> 1991. </year>
Reference-contexts: Proof: (1) We wish to show (9A) [NP A 6 coNP A ^ P A ], which is equivalent to Part 1 of the theorem. We merely sketch the appropriate modification of Toran's proof <ref> [Tor91, Theorem 5.9] </ref> that (9B) [NP B 6 P B ]. His proof is a stage construction. <p> Denote the class of languages so accepted by ProbabilisticSSF 2 . We will prove that ProbabilisticSSF 2 = NP PP . This class is relatively robust, as it is well-known that NP PP = NP C = P = NP #P <ref> [Tor91] </ref>. Furthermore, it follows from Toda's Theorem [Tod91] that this class is relatively inclusive, as NP PP PH = NP PP . <p> is one that would accept given the PP oracle answers implicit in the guesses then we accept if and only if a C = P check that all those guesses are correct says that they are correct) that NP PP = NP C = P = 9 C = P <ref> [Tor91] </ref>. So, let our arbitrary NP PP language, B, be specified via the polynomials r () and q () and the predicate R (; ) described above, with L 0 denoting the implied C = P language.
Reference: [Wag86] <author> K. Wagner. </author> <title> The complexity of combinatorial problems with succinct input representations. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 325-356, </pages> <year> 1986. </year> <month> 22 </month>
References-found: 32

