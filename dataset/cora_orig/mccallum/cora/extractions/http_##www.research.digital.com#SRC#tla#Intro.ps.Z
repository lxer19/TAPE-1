URL: http://www.research.digital.com/SRC/tla/Intro.ps.Z
Refering-URL: http://www.research.digital.com/SRC/tla/papers.html
Root-URL: http://www.research.digital.com
Title: Verifying Sequentially Consistent Memory Problem Definition  
Author: Rob Gerth 
Date: April 1993  
Affiliation: Eindhoven University of Technology  
Abstract-found: 0
Intro-found: 1
Reference: [ABM93] <author> Y. Afek, G. Brown, and M. Merritt. </author> <title> Lazy caching. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 182-206, </pages> <year> 1993. </year>
Reference-contexts: Hence, the memory serializes the reads and writes of the processors. The interface differs from the one used in <ref> [ABM93] </ref> as shall be discussed at the end of the introduction. <p> Then we have A memory M is sequentially consistent w.r.t. M serial , M s:c: M serial , iff 8 2 Beh (M) 9t 2 Beh (M serial ) 8i = 1 : : : n ji = t ji Computation model 3 The lazy caching protocol In <ref> [ABM93] </ref> a sequential correct memory that is not serial was proposed: the lazy caching protocol. We use a slightly adapted version of this protocol. The architecture of M distr is depicted in Figure 3; the transition system in Figure 4. The protocol is thus geared towards a bus based architecture. <p> Observe that for s 2 IBeh (M distr ), s ji denotes the subsequence of external read and write-events of P i in s. The interface of the serial memory and the caching protocol in <ref> [ABM93] </ref> differs from the one we use. There, a R i (d; a)-event in either protocol is split into an (input) event ReadRequest i (d; a), which is always enabled, and an (output) event ReadReturn i (d; a) that behaves as the R i (d; a)-event.
Reference: [BFKR92] <author> H. Burkhardt, S. Frank, B. Knobe, and J. Rothnie. </author> <title> Overview of the KSR1 computer system. </title> <type> Technical Report SR-TR-9202001, </type> <institution> Kendall Square Research, </institution> <address> Boston, </address> <year> 1992. </year>
Reference-contexts: If the multiprocessor architecture is also distributed then such `write and mark' operations cause unacceptable latencies. For instance, the DASH [LLG + 92] and KSR1 <ref> [BFKR92] </ref> architectures envisage up to 10000 workstations to be connected and to operate on a conceptually shared memory. Atomic write-and-marks produce massive network congestion because at any time there will be many writes in progress.
Reference: [Lam79] <author> L. Lamport. </author> <title> How to make a multiprocessor that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28:690-691, </volume> <year> 1979. </year>
Reference-contexts: The approach taken in such distributed shared memory architectures is to relax the constraints on the behavior of a standard shared memory. Most of these relaxations are patterned after Lamport's proposal of sequential consistency <ref> [Lam79] </ref>. In a standard memory the value that is read at a location must be the value that has last been written to fl Currently working in ESPRIT project 6021: "Building Correct Reactive Systems (REACT)" y Department of Computing Science, Eindhoven University of Technology, P.O.
Reference: [LLG + 92] <author> D. Lenoski, J. Laudon, K. Gharachorloo, W.-D. Weber, A. Gupta, J. Hen-nessy, M. Horowitz, and M. S. Lam. </author> <title> The Stanford Dash multiprocessor. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 63-79, </pages> <year> 1992. </year>
Reference-contexts: Clearly, changing a location and marking that location in other caches must be done as one atomic operation if memory is to behave as expected. If the multiprocessor architecture is also distributed then such `write and mark' operations cause unacceptable latencies. For instance, the DASH <ref> [LLG + 92] </ref> and KSR1 [BFKR92] architectures envisage up to 10000 workstations to be connected and to operate on a conceptually shared memory. Atomic write-and-marks produce massive network congestion because at any time there will be many writes in progress.
Reference: [Mos93] <author> D. Mosberger. </author> <title> Memory consistency models. </title> <journal> ACM SIGOP Operating Systems Review, </journal> <volume> 27(1) </volume> <pages> 18-27, </pages> <year> 1993. </year> <month> 7 </month>
Reference-contexts: In practice, however, different, still weaker memory models tend to be implemented as the synchronization overhead of SCM is still too large. For instance, the processor consistency model would allow the above behavior at the processors. See <ref> [Mos93] </ref> for an overview of distributed memory models. A formal definition Let ji denote the operation on behaviors of removing the events that do not originate from process P i or that are not external. Then we have A memory M is sequentially consistent w.r.t.
References-found: 5

