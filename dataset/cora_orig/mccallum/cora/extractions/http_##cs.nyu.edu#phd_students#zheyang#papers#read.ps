URL: http://cs.nyu.edu/phd_students/zheyang/papers/read.ps
Refering-URL: http://cs.nyu.edu/cs/faculty/paige/research.html
Root-URL: http://www.cs.nyu.edu
Email: fpaige,zheyangg@cs.nyu.edu  
Title: High Level Reading and Data Structure Compilation of creating low-level data structures manually, and builds
Author: Robert Paige Zhe Yang 
Note: This work alleviates the burden  
Address: New York University  
Affiliation: Department of Computer Science  
Abstract: In [Paige89], it was shown how to simulate a set machine in real-time on a RAM that provides cursor or even only pointer access to data. The underlying assumption was that the establishment of efficient data structures would be provided by some `client' program. In the current paper, we fill in the gap by presenting a linear-time high level reading method that translates external input in string form into data structures that facilitate such real-time simulation. The algorithm builds the data structures for a much richer type system than what appeared in [Paige94], and is powerful enough to support our reading algorithm itself in an efficient way. Consequently, it equips a high level set-theoretic language with I/O, without the loss of computational transparency. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. M. Ben-Amram. </author> <title> What is a "pointer machine"? SIGACT News, </title> <booktitle> 26(2) </booktitle> <pages> 88-95, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The lack of such generic routines also makes people doubt the effectiveness of many algorithms dealing with discrete structures (referred to as "pointer algorithms" by Ben-Amram <ref> [1] </ref>), which require the internal form of input. This paper is a first attempt to eliminate such preprocessing code by providing a high level built-in batch mode read operation.
Reference: [2] <author> J. Cai, P. Facon, F. Henglein, R. Paige, and E. Schonberg. </author> <title> Type transformation and data structure choice. </title> <editor> In B. Moeller, editor, </editor> <booktitle> Constructing Programs From Specifications, </booktitle> <pages> pages 126-124. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1991. </year>
Reference-contexts: The current paper depends on three main sources: * Algorithms for simulating a set machine on a pointer RAM without I/O were described in [8]. * A type and subtype methodology developed in <ref> [2] </ref> captures the algorithmic principles for the underlying data structures that support efficient associative access operations in worst case unit time on a RAM. <p> In <ref> [2] </ref> a constraint based approach was used to calculate base b for a simpler type system without alternation and recursive subtypes. In the current paper we define base b equivalently by operational and by constraint based characterizations for our more general type system. <p> If we regard a multiset in list representation as a string, and elements as characters, then weak sort rearranges characters in each string of a multiset of strings over an unordered alphabet that is linearly ordered arbitrarily at run-time. For example, a result of weak sort for the lists <ref> [2; 7; 5] </ref>, [3; 7; 2], [5; 3; 7] could be the lists [5; 7; 2], [7; 2; 3], [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], <ref> [3; 7; 2] </ref>, [5; 3; 7] could be the lists [5; 7; 2], [7; 2; 3], [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], [3; 7; 2], [5; 3; 7] could be the lists <ref> [5; 7; 2] </ref>, [7; 2; 3], [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], [3; 7; 2], [5; 3; 7] could be the lists [5; 7; 2], <ref> [7; 2; 3] </ref>, [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For smap nodes, we subsequently go through the image sets to check if all of them contains only one element. The unique interpretation of base b for base variables b was defined in <ref> [2] </ref> for subtype constraints defined without recursion and alternation. However, no algorithm for computing the bases was given.
Reference: [3] <author> J. Cai and R. Paige. </author> <title> Using multiset discrimination to solve language processing problems without hashing. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 145(1-2):189-228, </address> <month> July </month> <year> 1995. </year> <note> URL: http://cs.nyu.edu/cs/faculty/paige/papers/hash.ps. </note>
Reference-contexts: We solve the reading problem using an algorithm that runs in worst-case time and space linear in the length of the input string. Algorithmic tools that extend the techniques in <ref> [11, 3] </ref> for detecting and eliminating duplicate values in multisets are presented to translate abstract syntax trees of the input into space efficient non-hashed data structures in linear time. <p> Our tree-to-dag transformation is based on two algorithmic techniques for removing duplicates without hashing. The first technique is a generalization of multi-set discrimination, i.e. finding and removing duplicate elements in a multiset to make it a set, described in <ref> [11, 9, 3] </ref>. Our extension rests on a surprisingly simple idea. <p> For example, a result of weak sort for the lists [2; 7; 5], <ref> [3; 7; 2] </ref>, [5; 3; 7] could be the lists [5; 7; 2], [7; 2; 3], [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], [3; 7; 2], <ref> [5; 3; 7] </ref> could be the lists [5; 7; 2], [7; 2; 3], [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], [3; 7; 2], [5; 3; 7] could be the lists [5; 7; 2], <ref> [7; 2; 3] </ref>, [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], [3; 7; 2], [5; 3; 7] could be the lists [5; 7; 2], [7; 2; 3], <ref> [5; 7; 3] </ref>, where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> Multiset discrimination of tuples can be solved in much the same way that multiset discrimination of strings was solved in <ref> [3] </ref> (based on the earlier array-based method found in [11]) | by repeated application of basic mul tiset discrimination. <p> Based on more complete proofs found in <ref> [3, 11] </ref>, we have the following lemma: Lemma 2 The multiset discrimination algorithm of tuples will dagify the nodes in V according to tuple equality, if the children of these nodes are already dagified. Complexity analysis also follows from these sources.
Reference: [4] <author> J. Cai and R. Paige. </author> <title> Towards increased productivity of algorithm implementation. </title> <booktitle> In Proc. ACM SIGSOFT, </booktitle> <pages> pages 71-78, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Both papers fit into with our ongoing research involving a translator from typed SETL2 [17] to C, which aims to improve of software productivity based on experiments reported in <ref> [4] </ref>. Since the read routine can be fully written in the type system itself, it is possible to use the SETL2-to-C translator to compile the read routine into its faster C version equivalent.
Reference: [5] <author> C. Consel and O. Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> In 1993 ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 493-501, </pages> <year> 1993. </year>
Reference-contexts: We can also perform partial evaluation on the read routine with respect to type information to further increase efficiency <ref> [5] </ref>. 2 The Reading Problem Consider a batch mode read operation: read v 1 ; :::; v k that reads external data into variables v i , for i = 1; :::; k. <p> If we regard a multiset in list representation as a string, and elements as characters, then weak sort rearranges characters in each string of a multiset of strings over an unordered alphabet that is linearly ordered arbitrarily at run-time. For example, a result of weak sort for the lists <ref> [2; 7; 5] </ref>, [3; 7; 2], [5; 3; 7] could be the lists [5; 7; 2], [7; 2; 3], [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], [3; 7; 2], <ref> [5; 3; 7] </ref> could be the lists [5; 7; 2], [7; 2; 3], [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], [3; 7; 2], [5; 3; 7] could be the lists <ref> [5; 7; 2] </ref>, [7; 2; 3], [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], [3; 7; 2], [5; 3; 7] could be the lists [5; 7; 2], [7; 2; 3], <ref> [5; 7; 3] </ref>, where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> Furthermore, since the type signature is usually fixed in a program, specializing the read method w.r.t. a type signature can tailor the read method to a specific read routine that is more efficient <ref> [5] </ref>. 4 Conclusions and Related Work We have presented a formal semantics for the reading problem and an efficient worst-case linear time algorithm to solve it. As in [9], a type system is used to serve as the specification for both external input and internal data representation.
Reference: [6] <author> W. Dowling and J. Gallier. </author> <title> Linear-time algorithms for testing the satisfiability of propositional Horn formulae. </title> <journal> J. Logic Programming, </journal> <volume> 1(3) </volume> <pages> 267-284, </pages> <year> 1984. </year>
Reference-contexts: In accordance with the fast Horn clause satisfiability algorithm found in <ref> [6] </ref>, we separate out the axioms from the remaining clauses, and represent them in the following ex ternal form: fx 1 x 2 g Using the following type signature: variable &lt; external lhs &lt; set (variable) Axioms : set (variable-strong) formula : mmap (lhs-strong; variable) we obtain highly efficient data structures
Reference: [7] <author> D. Goyal and R. Paige. </author> <title> The formal reconstruction and improvement of the linear time fragment of Willard's relational calculus subset. </title> <booktitle> to appear in Proc. IFIP TC2 Working Conf. on Algorithmic Languages and Calculi, </booktitle> <year> 1997. </year> <note> URL: http://cs.nyu.edu/phd students/deepak/lrcs.ps. </note>
Reference-contexts: We extend those algorithms to be fully written in our new type system. Whereas our paper focuses on elaborating complex data structures from input in string from, a companion paper <ref> [7] </ref> shows how these data structures facilitate computation with respect to the type system. Both papers fit into with our ongoing research involving a translator from typed SETL2 [17] to C, which aims to improve of software productivity based on experiments reported in [4]. <p> Type inference rules for our SETL-like language, which includes asymptotic run-time complexities, may be found in <ref> [7] </ref>. Also included in that paper is an extended example of how the kernel of our type system supports the computational transparency of our language. <p> If we regard a multiset in list representation as a string, and elements as characters, then weak sort rearranges characters in each string of a multiset of strings over an unordered alphabet that is linearly ordered arbitrarily at run-time. For example, a result of weak sort for the lists <ref> [2; 7; 5] </ref>, [3; 7; 2], [5; 3; 7] could be the lists [5; 7; 2], [7; 2; 3], [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], <ref> [3; 7; 2] </ref>, [5; 3; 7] could be the lists [5; 7; 2], [7; 2; 3], [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], [3; 7; 2], <ref> [5; 3; 7] </ref> could be the lists [5; 7; 2], [7; 2; 3], [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], [3; 7; 2], [5; 3; 7] could be the lists <ref> [5; 7; 2] </ref>, [7; 2; 3], [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], [3; 7; 2], [5; 3; 7] could be the lists [5; 7; 2], <ref> [7; 2; 3] </ref>, [5; 7; 3], where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> For example, a result of weak sort for the lists [2; 7; 5], [3; 7; 2], [5; 3; 7] could be the lists [5; 7; 2], [7; 2; 3], <ref> [5; 7; 3] </ref>, where we use the arbitrary order 5 &lt; 7 &lt; 2 &lt; 3 to sort each list. <p> This paper considers a richer type system, that supports real-time simulation of a set machine on a sequential RAM. Thus, the read method presented here can support efficient implementations of a wide spectrum of algorithms, e.g. <ref> [7] </ref> shows how a database query language can be executed in linear time using a set machine, where the initial data structure can be established by our read routine.
Reference: [8] <author> R. Paige. </author> <title> Real-time simulation of a set machine on a RAM. </title> <editor> In N. Janicki and W. Koczkodaj, editors, </editor> <booktitle> Computing and Information, </booktitle> <volume> volume II, </volume> <pages> pages 69-73. </pages> <publisher> Canadian Scholars' Press, </publisher> <address> Toronto, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: The current paper depends on three main sources: * Algorithms for simulating a set machine on a pointer RAM without I/O were described in <ref> [8] </ref>. * A type and subtype methodology developed in [2] captures the algorithmic principles for the underlying data structures that support efficient associative access operations in worst case unit time on a RAM. <p> records R b , used to store a doubly linked list that connects the set of records in R b whose key fields store the elements in the set (see representation supports worst-case unit-time associative access operations for elements of strongly based sets and maps with strongly based domains (see <ref> [8] </ref> for a detailed description). Such strongly based types can only appear in a type assignment at the top level of the type expression. For instance, type assignment v : set (b-strong) is valid, while type assignment v : set (set (b-strong)) is invalid.
Reference: [9] <author> R. Paige. </author> <title> Efficient translation of external input in a dynamically typed language. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> Technology and Foundations Information Processing 94, volume 1 of IFIP Transactions A-51, </booktitle> <pages> pages 603-608. </pages> <publisher> North-Holland, </publisher> <address> Am-sterdam, </address> <month> Sept. </month> <year> 1994. </year> <booktitle> Conference Record of IFIP Congress 94. </booktitle>
Reference-contexts: We augment the type system in that paper with tagged alternation, recursive subtype, and user defined type. * The kernel of our algorithms is based on a previous paper on reading by Paige <ref> [9] </ref>, which focused on the multiple presentations of external inputs and duplication removal; efficient data structures for quick associative access are not supported there. We extend those algorithms to be fully written in our new type system. <p> The corresponding grammar is clearly LL (1). Furthermore, the language it generates includes all the legal inputs of the language. Thus, type external acts as a `dynamic' type. Reading a variable of type external performs the task of reading for dynam ically typed terms as in <ref> [9] </ref>. * (Propositional Horn Clause Satisfiability) The propo sitional Horn clause satisfiability problem is a special case of the general satisfiability problem SAT (Chapter 4, [12]) where each clause has at most one positive literal. <p> Our tree-to-dag transformation is based on two algorithmic techniques for removing duplicates without hashing. The first technique is a generalization of multi-set discrimination, i.e. finding and removing duplicate elements in a multiset to make it a set, described in <ref> [11, 9, 3] </ref>. Our extension rests on a surprisingly simple idea. <p> The multiset discrimination algorithms used for the kernel of our type system was described in <ref> [9] </ref>. Here, we extend those algorithms to a more general type system. We also show how those algorithms can be specified in the very type system that these algorithms help build efficient data structures for. We give multiset discrimination algorithms tailored to three different element types tuples, multisets, and sets. <p> As in <ref> [9] </ref>, a type system is used to serve as the specification for both external input and internal data representation. This paper considers a richer type system, that supports real-time simulation of a set machine on a sequential RAM.
Reference: [10] <author> R. Paige and F. Henglein. </author> <title> Mechanical translation of set theoretic problem specifications into efficient RAM code a case study. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 4(2) </volume> <pages> 207-232, </pages> <month> Aug. </month> <year> 1987. </year>
Reference-contexts: and represent them in the following ex ternal form: fx 1 x 2 g Using the following type signature: variable &lt; external lhs &lt; set (variable) Axioms : set (variable-strong) formula : mmap (lhs-strong; variable) we obtain highly efficient data structures that are used by the pointer algorithm given in <ref> [10] </ref> to compute attribute closure. When the attribute closure Axioms + is computed from Axioms and formula , the original formula is satisfiable iff F does not belong to Axioms + .
Reference: [11] <author> R. Paige and R. Tarjan. </author> <title> Three efficient algorithms based on partition refinement. </title> <journal> SIAM Journal of Computing, </journal> <volume> 16(6), </volume> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: We solve the reading problem using an algorithm that runs in worst-case time and space linear in the length of the input string. Algorithmic tools that extend the techniques in <ref> [11, 3] </ref> for detecting and eliminating duplicate values in multisets are presented to translate abstract syntax trees of the input into space efficient non-hashed data structures in linear time. <p> Our tree-to-dag transformation is based on two algorithmic techniques for removing duplicates without hashing. The first technique is a generalization of multi-set discrimination, i.e. finding and removing duplicate elements in a multiset to make it a set, described in <ref> [11, 9, 3] </ref>. Our extension rests on a surprisingly simple idea. <p> Multiset discrimination of tuples can be solved in much the same way that multiset discrimination of strings was solved in [3] (based on the earlier array-based method found in <ref> [11] </ref>) | by repeated application of basic mul tiset discrimination. <p> Based on more complete proofs found in <ref> [3, 11] </ref>, we have the following lemma: Lemma 2 The multiset discrimination algorithm of tuples will dagify the nodes in V according to tuple equality, if the children of these nodes are already dagified. Complexity analysis also follows from these sources.
Reference: [12] <author> C. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: Reading a variable of type external performs the task of reading for dynam ically typed terms as in [9]. * (Propositional Horn Clause Satisfiability) The propo sitional Horn clause satisfiability problem is a special case of the general satisfiability problem SAT (Chapter 4, <ref> [12] </ref>) where each clause has at most one positive literal.
Reference: [13] <author> J. Rintanen. </author> <title> Private Communication, </title> <year> 1994. </year>
Reference-contexts: This precisely answers Jussi Rin-tanen's question about whether cursor access is essential to linear time algorithms for solving the HORNSAT problem <ref> [13] </ref>. 3 Solving the Reading Program Semantic map fl [t 1 ;:::;t k ] ffifront end [t 1 ;:::;t k ] is imple mented in three stages: 1. Recognizing external input and building an ab stract syntax tree (AST). 2.
Reference: [14] <author> J. Schwartz. </author> <title> Automatic data structure choice in a language of very high level. </title> <journal> CACM, </journal> <volume> 18(12) </volume> <pages> 722-728, </pages> <month> Dec </month> <year> 1975. </year>
Reference-contexts: The subset of val (b) actually appearing in the input is denoted by base b after Schwartz's heuristic for SETL optimization <ref> [14, 15] </ref>. The key field of each record in R b stores a distinct value of type t . Values of base type b can be thought of as pointers to records in R b .
Reference: [15] <author> J. Schwartz. </author> <title> Optimization of very high level languages, parts i, ii. </title> <journal> J. of Computer Languages, </journal> <volume> 1(2, </volume> 3):161-218, 1975. 
Reference-contexts: The subset of val (b) actually appearing in the input is denoted by base b after Schwartz's heuristic for SETL optimization <ref> [14, 15] </ref>. The key field of each record in R b stores a distinct value of type t . Values of base type b can be thought of as pointers to records in R b .
Reference: [16] <author> R. Snodgrass. </author> <title> The Interface Description Language. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: This surprising conclusion corrects the contrary view, which prevailed in the SETL and our own RAPTS projects. The problem of high level input representation and the translation of these representations into datatypes has been studied before in the context of interface language such as IDL <ref> [16] </ref>. IDL uses high level ASCII external data representations to communicate between different system components in a machine and language independent way. However, it has two major deficiencies.
Reference: [17] <author> K. Snyder. </author> <title> The SETL2 programming language. </title> <type> Technical Report 490, </type> <institution> Courant Insititute, </institution> <address> New York University, </address> <year> 1990. </year>
Reference-contexts: Whereas our paper focuses on elaborating complex data structures from input in string from, a companion paper [7] shows how these data structures facilitate computation with respect to the type system. Both papers fit into with our ongoing research involving a translator from typed SETL2 <ref> [17] </ref> to C, which aims to improve of software productivity based on experiments reported in [4]. Since the read routine can be fully written in the type system itself, it is possible to use the SETL2-to-C translator to compile the read routine into its faster C version equivalent.
Reference: [18] <author> R. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <publisher> SIAM, </publisher> <year> 1984. </year>
Reference-contexts: The first technique is a generalization of multi-set discrimination, i.e. finding and removing duplicate elements in a multiset to make it a set, described in [11, 9, 3]. Our extension rests on a surprisingly simple idea. If U is an exogenous set <ref> [18] </ref>, (i.e. a set of pointers to arbitrary values), where each distinct pointer references a distinct value, then comparing pointers x and y in U decides the equality of the values they point to. The multiset discrimination algorithms used for the kernel of our type system was described in [9].
Reference: [19] <author> R. Wilhelm and D. Maurer. </author> <title> Compiler Design. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1995. </year> <month> 14 </month>
Reference-contexts: grammar G (t ) is *-free grammar, there must exist two productions in the grammar of the form: X t 0 ::= X t 1 such that the language X t 1 derives and the language X t 2 derives have a common intial character s, by theorem 8.3 of <ref> [19] </ref>. <p> 3.1 Input Recognition and Abstract Syntax Tree Generation For all well-formed types t , the grammar G (t ) is LL (1) by Theorem 1 in Section 2.2, and hence external input can be verified, and converted into an AST in time linear in the length of the input string <ref> [19] </ref>. The algorithm can be implemented on a pointer machine equipped with a primitive operation that converts external strings to tuples of pointers to master records for each distinct character.
References-found: 19

