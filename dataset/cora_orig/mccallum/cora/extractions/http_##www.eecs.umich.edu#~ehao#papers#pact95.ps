URL: http://www.eecs.umich.edu/~ehao/papers/pact95.ps
Refering-URL: http://www.eecs.umich.edu/~ehao/school.html
Root-URL: http://www.cs.umich.edu
Title: Using Predicated Execution to Improve the Performance of a Dynamically Scheduled Machine with Speculative Execution  
Author: Po-Yung Chang Eric Hao Yale N. Patt Pohua P. Chang 
Keyword: Predicated execution, speculative execution, branch prediction, wide-issue dynamically scheduled processors, instruction level parallelism  
Address: Ann Arbor, MI Santa Clara, CA  
Affiliation: The University of Michigan Intel Architecture Laboratory  
Abstract: Conditional branches incur a severe performance penalty in wide-issue, deeply pipelined processors. Speculative execution [14, 12] and predicated execution [7, 16, 5, 10, 15, 22, 9] are two mechanisms that have been proposed for reducing this penalty. Speculative execution can completely eliminate the penalty associated with a particular branch, but requires accurate branch prediction to be effective. Predicated execution does not require accurate branch prediction to eliminate the branch penalty, but is not applicable to all branches and can increase the latencies within the program. This paper examines the performance benefit of using both mechanisms to reduce the branch execution penalty. Predicated execution is used to handle the hard-to-predict branches and speculative execution is used to handle the remaining branches. The hard-to-predict branches within the program are determined by profiling. We show that this approach can significantly reduce the branch execution penalty suffered by wide-issue processors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. R. Allen, K. Kennedy, C. Porterfield, and J. Warren, </author> <title> "Conversion of control dependence to data dependence," </title> <booktitle> in 10th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 177-189, </pages> <year> 1983. </year>
Reference-contexts: The branches can be eliminated by replacing their control-dependent instructions with predicated instructions <ref> [1] </ref>. A predicated instruction contains an extra source operand known as the predicate operand. The predicated instruction is conditionally executed based on the value of this operand. If the predicate evaluates to true, the predicated instruction is executed like a normal instruction.
Reference: [2] <author> M. G. Butler, </author> <title> Aggressive Execution Engines for Surpassing Single Basic Block Execution, </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <year> 1993. </year>
Reference-contexts: Two-Level Branch Predictor. 3 Predicated Execution 3.1 Predication Model Our predication model assumes that each predicated instruction has three or four source operands: one or two source operands used for calculating the value generated by the instruction, one predicate operand, and one implicit source operand specified by the destination register <ref> [2, 15] </ref>. The predicate operand is an ordinary register. The predicated instruction can interpret its value by its least significant bit or by the complement of its least significant bit. Although predicate registers are usually set by compare instructions, they can be set by any instruction.
Reference: [3] <author> P.-Y. Chang, E. Hao, T.-Y. Yeh, and Y. N. Patt, </author> <title> "Branch classification: A new mechanism for improving branch predictor performance," </title> <booktitle> in Proceedings of the 27th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 22-31, </pages> <year> 1994. </year>
Reference-contexts: A mechanism other than predicated execution must be used to handle such branches. 1 This paper examines the performance benefit of using both speculative and predicated execution to reduce the branch execution penalty for wide-issue, dynamically scheduled machines that use the Two-Level Adaptive Branch Predictor <ref> [23, 24, 3] </ref>. To minimize the effect of each approach's disadvantages, speculative execution is used to handle the branches that are accurately predicted by the branch predictor and predicated execution is used to eliminate the remaining hard-to-predict branches. <p> The profiler modeled the processor's branch predictor and recorded the number of mispredictions for each static branch. Branches whose mispredic-tion counts exceeded a given threshold were considered hard to predict and marked for elimination. The branch predictor simulated by the profiler in our experiments was the Gshare/PAg predictor <ref> [11, 3] </ref>, an aggressive variation of the Two-Level Branch Predictor. This hybrid branch predictor combines the global history (Gshare [11]) and per-address history (PAg [23]) schemes of the Two-Level Branch Predictor into one predictor.
Reference: [4] <author> P. P. Chang, S. A. Mahlke, W. Y. Chen, N. J. Warter, and W. W. Hwu, </author> <title> "IMPACT: An architectural framework for multiple-instruction-issue processors," </title> <booktitle> in Proceedings of the 18th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 266-275, </pages> <year> 1991. </year>
Reference-contexts: Figure 2 gives an example of instruction promotion from the sc benchmark. When the promoted instruction can potentially cause an exception (e.g. a load instruction), a non-trapping version of the instruction is used <ref> [18, 4] </ref>. ;; Predicated assembly code ;; cmp_eq r5, r6, 0 add r2, r2, r8 if r5 ;; Predicated assembly code ;; with instuction promotion. ;; ld r8, r6, 0 ; Instruction promoted cmp_eq r5, r6, 0 4 Experimental Results 4.1 Generating the Predicated Object Files The code compilation process consists
Reference: [5] <author> J. C. Dehnert, P. Y. T. Hsu, and J. P. Bratt, </author> <title> "Overlapped loop support in the Cydra 5," </title> <booktitle> in Proceedings of the 16th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 26-38, </pages> <year> 1989. </year>
Reference-contexts: If the prediction is incorrect, the processor, after removing from its state the effects of the speculatively executed instructions, must return to the point of the branch prediction and begin executing instructions from the correct path. In this case, the full branch execution penalty is suffered. Predicated execution <ref> [7, 16, 5, 10, 15, 22, 9] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program.
Reference: [6] <author> T. Granlund and R. Kenner, </author> <title> "Eliminating branches using a superoptimizer and the GNU C compiler," </title> <booktitle> in Proceedings of the ACM SIGPLAN'92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 341-352, </pages> <year> 1992. </year>
Reference-contexts: Four different variations for each benchmark were simulated: * np baseline version of the benchmark in which none of the branches were eliminated. * sp software-based predication version in which branches were eliminated by the GCC compiler through the use of logical and bit-manipulation operations <ref> [6] </ref>. * hp - hardware-based predication version in which branches were eliminated by predicated instruc tions. * ip - hardware-based predication version in which branches were eliminated by predicated instructions and instruction promotion optimizations were applied.
Reference: [7] <author> P. Hsu and E. Davidson, </author> <title> "Highly concurrent scalar processing," </title> <booktitle> in Proceedings of the 13th Annual International Symposium on Computer Architecture, </booktitle> <year> 1986. </year>
Reference-contexts: If the prediction is incorrect, the processor, after removing from its state the effects of the speculatively executed instructions, must return to the point of the branch prediction and begin executing instructions from the correct path. In this case, the full branch execution penalty is suffered. Predicated execution <ref> [7, 16, 5, 10, 15, 22, 9] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program.
Reference: [8] <author> J. K. F. Lee and A. J. Smith, </author> <title> "Branch prediction strategies and branch target buffer design," </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 6-22, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: 1 Introduction Today's processors are being built with wider issue rates and deeper pipelines in order to exploit larger amounts of instruction-level parallelism. For such processors, the occurrence of branches in the instruction stream incurs a severe performance penalty <ref> [17, 8] </ref>. Two well-known mechanisms have been proposed to reduce this penalty, speculative execution in conjunction with branch prediction and predicated execution.
Reference: [9] <author> S. A. Mahlke, R. E. Hank, R. A. Bringmann, J. C. Gyllenhaal, D. M. Gallagher, and W. W. Hwu, </author> <title> "Characterizing the impact of predicated execution on branch prediction," </title> <booktitle> in Proceedings of the 27th Annual ACM/IEEE International Symposium on Microarchi-tecture, </booktitle> <pages> pp. 217-227, </pages> <year> 1994. </year>
Reference-contexts: If the prediction is incorrect, the processor, after removing from its state the effects of the speculatively executed instructions, must return to the point of the branch prediction and begin executing instructions from the correct path. In this case, the full branch execution penalty is suffered. Predicated execution <ref> [7, 16, 5, 10, 15, 22, 9] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program. <p> In addition to the metrics reported in [15], he approximated the reduction in the branch execution penalty due to predicated execution by calculating the penalty as a function of processor issue width and pipeline depth. Mahlke et al. <ref> [10, 9] </ref> studied the performance benefit of using predicated execution in conjunction with a static branch predictor or a simple dynamic branch predictor. <p> First, it examines the performance benefit of eliminating only the hard-to-predict branches for the Two-Level Branch Predictor. Because the Two-Level Branch Predictor achieves a much higher prediction accuracy than those examined in <ref> [10, 9] </ref>, the number of branches that must be eliminated is smaller. Second, it measures this performance benefit by simulating an actual dynamically scheduled machine and reporting the benefit both in terms of number of mispredictions eliminated and the number of cycles saved in total execution time. <p> Branches that cannot be eliminated include loop branches and branches that branch over procedure calls. To deal with these branches, a set of transformations was proposed in <ref> [10, 9] </ref> that transformed some of these branches into a form more amenable to elimination. Two of these transformations, loop peeling and loop branch coalescing, were used to help eliminate some of the hard-to-predict branches found in section 3.2.
Reference: [10] <author> S. A. Mahlke, D. C. Lin, W. Y. Chen, R. E. Hank, and R. A. Bringmann, </author> <title> "Effective compiler support for predicated execution using the hyperblock," </title> <booktitle> in Proceedings of the 25th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 45-54, </pages> <year> 1992. </year>
Reference-contexts: If the prediction is incorrect, the processor, after removing from its state the effects of the speculatively executed instructions, must return to the point of the branch prediction and begin executing instructions from the correct path. In this case, the full branch execution penalty is suffered. Predicated execution <ref> [7, 16, 5, 10, 15, 22, 9] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program. <p> Profiling is used to determine which branches are inaccurately predicted by the branch predictor. In addition, we examine the effectiveness of the instruction promotion compiler optimization <ref> [20, 10] </ref>, which removes the data dependencies created by the addition of predicated instructions. We show that for most of the SPECint92 benchmarks, profiling is an effective means for determining which branches are difficult to predict for the Two-Level Predictor. <p> In addition to the metrics reported in [15], he approximated the reduction in the branch execution penalty due to predicated execution by calculating the penalty as a function of processor issue width and pipeline depth. Mahlke et al. <ref> [10, 9] </ref> studied the performance benefit of using predicated execution in conjunction with a static branch predictor or a simple dynamic branch predictor. <p> First, it examines the performance benefit of eliminating only the hard-to-predict branches for the Two-Level Branch Predictor. Because the Two-Level Branch Predictor achieves a much higher prediction accuracy than those examined in <ref> [10, 9] </ref>, the number of branches that must be eliminated is smaller. Second, it measures this performance benefit by simulating an actual dynamically scheduled machine and reporting the benefit both in terms of number of mispredictions eliminated and the number of cycles saved in total execution time. <p> Branches that cannot be eliminated include loop branches and branches that branch over procedure calls. To deal with these branches, a set of transformations was proposed in <ref> [10, 9] </ref> that transformed some of these branches into a form more amenable to elimination. Two of these transformations, loop peeling and loop branch coalescing, were used to help eliminate some of the hard-to-predict branches found in section 3.2. <p> The instructions that were converted into predicated instructions are now data dependent on the instruction that generates the branch's condition. Instruction promotion <ref> [20, 10] </ref> can remove these dependencies by promoting the instruction above the branch so that it does not need to be predicated.
Reference: [11] <author> S. McFarling, </author> <title> "Combining branch predictors," </title> <type> Technical Report TN-36, </type> <institution> Digital Western Research Laboratory, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: The profiler modeled the processor's branch predictor and recorded the number of mispredictions for each static branch. Branches whose mispredic-tion counts exceeded a given threshold were considered hard to predict and marked for elimination. The branch predictor simulated by the profiler in our experiments was the Gshare/PAg predictor <ref> [11, 3] </ref>, an aggressive variation of the Two-Level Branch Predictor. This hybrid branch predictor combines the global history (Gshare [11]) and per-address history (PAg [23]) schemes of the Two-Level Branch Predictor into one predictor. <p> The branch predictor simulated by the profiler in our experiments was the Gshare/PAg predictor [11, 3], an aggressive variation of the Two-Level Branch Predictor. This hybrid branch predictor combines the global history (Gshare <ref> [11] </ref>) and per-address history (PAg [23]) schemes of the Two-Level Branch Predictor into one predictor. It bases its prediction on whichever scheme has been making the more accurate predictions for the branch to be predicted.
Reference: [12] <author> S. Melvin and Y. N. Patt, </author> <title> "Exploiting fine-grained parallelism through a combination of hardware and software techniques," </title> <booktitle> in Proceedings of the 18th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 287-297, </pages> <year> 1991. </year>
Reference-contexts: For such processors, the occurrence of branches in the instruction stream incurs a severe performance penalty [17, 8]. Two well-known mechanisms have been proposed to reduce this penalty, speculative execution in conjunction with branch prediction and predicated execution. Speculative execution <ref> [14, 12] </ref> is a microarchitec-tural mechanism that solves the branch problem by guessing the direction that a branch will take before 0 the branch condition is known. After making a prediction for a branch in the dynamic instruction stream, the processor speculatively executes the instructions along the predicted path.
Reference: [13] <author> Y. Patt, W. Hwu, and M. Shebanow, "HPS, </author> <title> a new microarchitecture: Rationale and introduction," </title> <booktitle> in Proceedings of the 18th Annual ACM/IEEE International Symposium on Microarchitecture, </booktitle> <pages> pp. 103-107, </pages> <year> 1985. </year>
Reference-contexts: If the predicate evaluates to false, the predicated instruction writes the old value of the destination register (the implicit operand) back into the destination register. This is done instead of suppressing the execution of the instruction because the machine simulated uses dynamic register renaming <ref> [21, 13] </ref>. For register renaming to function correctly, every issued instruction must eventually produce a value. <p> Before After . . . SPEC OP op1 if r0 beq r0, 0, L1 op2 if r0 The new instruction trace is then processed by our processor simulator to gather execution statistics. 4.3 Machine Model The underlying architectural model is the HPS mi-croarchitecture <ref> [13] </ref> [14]. Execution in HPS flows as follows: Each cycle, multiple instructions are issued, and using the information in the register files, the instructions are merged into node tables, much like the Tomasulo algorithm merges operations into the reservation stations of the IBM 360/91 [21].
Reference: [14] <author> Y. N. Patt, S. W. Melvin, W. Hwu, and M. C. She-banow, </author> <title> "Critical issues regarding HPS, a high performance microarchitecture," </title> <booktitle> in Proceedings of the 18th Annual ACM/IEEE International Symposium on Mi-croarchitecture, </booktitle> <pages> pp. 109-116, </pages> <year> 1985. </year>
Reference-contexts: For such processors, the occurrence of branches in the instruction stream incurs a severe performance penalty [17, 8]. Two well-known mechanisms have been proposed to reduce this penalty, speculative execution in conjunction with branch prediction and predicated execution. Speculative execution <ref> [14, 12] </ref> is a microarchitec-tural mechanism that solves the branch problem by guessing the direction that a branch will take before 0 the branch condition is known. After making a prediction for a branch in the dynamic instruction stream, the processor speculatively executes the instructions along the predicted path. <p> Before After . . . SPEC OP op1 if r0 beq r0, 0, L1 op2 if r0 The new instruction trace is then processed by our processor simulator to gather execution statistics. 4.3 Machine Model The underlying architectural model is the HPS mi-croarchitecture [13] <ref> [14] </ref>. Execution in HPS flows as follows: Each cycle, multiple instructions are issued, and using the information in the register files, the instructions are merged into node tables, much like the Tomasulo algorithm merges operations into the reservation stations of the IBM 360/91 [21].
Reference: [15] <author> D. N. Pnevmatikatos and G. S. Sohi, </author> <title> "Guarded execution and dynamic branch prediction in dynamic ILP processors," </title> <booktitle> in Proceedings of the 21st Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 120-129, </pages> <year> 1994. </year>
Reference-contexts: If the prediction is incorrect, the processor, after removing from its state the effects of the speculatively executed instructions, must return to the point of the branch prediction and begin executing instructions from the correct path. In this case, the full branch execution penalty is suffered. Predicated execution <ref> [7, 16, 5, 10, 15, 22, 9] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program. <p> Section 4 describes the simulation methodolgy used in our experiments and the results from those experiments. Section 5 provides some concluding remarks. 2 Previous Work Many researchers have studied the effectiveness of combining speculative and predicated execution. Pnev-matikatos and Sohi <ref> [15] </ref> studied the performance benefit of using predicated execution in conjunction with the Two-Level Adaptive Branch Predictor. <p> These issues are not addressed in this paper. of predicating all short forward branches. In addition to the metrics reported in <ref> [15] </ref>, he approximated the reduction in the branch execution penalty due to predicated execution by calculating the penalty as a function of processor issue width and pipeline depth. <p> Two-Level Branch Predictor. 3 Predicated Execution 3.1 Predication Model Our predication model assumes that each predicated instruction has three or four source operands: one or two source operands used for calculating the value generated by the instruction, one predicate operand, and one implicit source operand specified by the destination register <ref> [2, 15] </ref>. The predicate operand is an ordinary register. The predicated instruction can interpret its value by its least significant bit or by the complement of its least significant bit. Although predicate registers are usually set by compare instructions, they can be set by any instruction.
Reference: [16] <author> B. R. Rau, D. W. L. Yen, W. Yen, and R. A. Towle, </author> <title> "The Cydra 5 departmental supercomputer," </title> <journal> IEEE Computer, </journal> <volume> vol. 22, </volume> <pages> pp. 12-35, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: If the prediction is incorrect, the processor, after removing from its state the effects of the speculatively executed instructions, must return to the point of the branch prediction and begin executing instructions from the correct path. In this case, the full branch execution penalty is suffered. Predicated execution <ref> [7, 16, 5, 10, 15, 22, 9] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program.
Reference: [17] <author> E. M. Riseman and C. C. Foster, </author> <title> "The inhibition of potential parallelism by conditional jumps," </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-21, no. 12, </volume> <pages> pp. 1405-1411, </pages> <year> 1972. </year>
Reference-contexts: 1 Introduction Today's processors are being built with wider issue rates and deeper pipelines in order to exploit larger amounts of instruction-level parallelism. For such processors, the occurrence of branches in the instruction stream incurs a severe performance penalty <ref> [17, 8] </ref>. Two well-known mechanisms have been proposed to reduce this penalty, speculative execution in conjunction with branch prediction and predicated execution.
Reference: [18] <author> M. D. Smith, M. S. Lam, and M. A. Horowitz, </author> <title> "Boosting beyond static scheduling in a superscalar processor," </title> <booktitle> in Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 344-354, </pages> <year> 1990. </year>
Reference-contexts: Figure 2 gives an example of instruction promotion from the sc benchmark. When the promoted instruction can potentially cause an exception (e.g. a load instruction), a non-trapping version of the instruction is used <ref> [18, 4] </ref>. ;; Predicated assembly code ;; cmp_eq r5, r6, 0 add r2, r2, r8 if r5 ;; Predicated assembly code ;; with instuction promotion. ;; ld r8, r6, 0 ; Instruction promoted cmp_eq r5, r6, 0 4 Experimental Results 4.1 Generating the Predicated Object Files The code compilation process consists
Reference: [19] <author> E. Sprangle and Y. Patt, </author> <title> "Facilitating superscalar processing via a combined static/dynamic register renaming scheme," </title> <booktitle> in Proceedings of the 27th Annual ACM/IEEE International Symposium on Microarchi-tecture, </booktitle> <pages> pp. 143-147, </pages> <year> 1994. </year>
Reference-contexts: These functions invoke the branch predictor simulator which then generates the branch prediction and updates the state of the simulated prediction hardware. By comparing the actual branch direction with the simulated prediction, the performance of the branch 2 Sprangle and Patt <ref> [19] </ref> have proposed a static register tagging scheme that avoids this drawback by eliminating the need to execute predicated instructions when their predicates are false. Our simulations, however, do not take advantage of this scheme. predictor can be determined on a per-branch basis.
Reference: [20] <author> P. Tirumalai, M. Lee, and M. Schlanskar, </author> <title> "Paralleliza-tion of loops with exits on pipelined architectures," </title> <booktitle> in Proceedings of Supercomputing '90, </booktitle> <year> 1990. </year>
Reference-contexts: Profiling is used to determine which branches are inaccurately predicted by the branch predictor. In addition, we examine the effectiveness of the instruction promotion compiler optimization <ref> [20, 10] </ref>, which removes the data dependencies created by the addition of predicated instructions. We show that for most of the SPECint92 benchmarks, profiling is an effective means for determining which branches are difficult to predict for the Two-Level Predictor. <p> The instructions that were converted into predicated instructions are now data dependent on the instruction that generates the branch's condition. Instruction promotion <ref> [20, 10] </ref> can remove these dependencies by promoting the instruction above the branch so that it does not need to be predicated.
Reference: [21] <author> R. M. Tomasulo, </author> <title> "An efficient algorithm for exploiting multiple arithmetic units," </title> <journal> IBM Journal of Research and Development, </journal> <volume> vol. 11, </volume> <pages> pp. 25-33, </pages> <month> January </month> <year> 1967. </year>
Reference-contexts: If the predicate evaluates to false, the predicated instruction writes the old value of the destination register (the implicit operand) back into the destination register. This is done instead of suppressing the execution of the instruction because the machine simulated uses dynamic register renaming <ref> [21, 13] </ref>. For register renaming to function correctly, every issued instruction must eventually produce a value. <p> Execution in HPS flows as follows: Each cycle, multiple instructions are issued, and using the information in the register files, the instructions are merged into node tables, much like the Tomasulo algorithm merges operations into the reservation stations of the IBM 360/91 <ref> [21] </ref>. Associated with each instruction (node) are the source operands for that instruction (or identifiers for obtaining the operands), and destination information.
Reference: [22] <author> G. S. Tyson, </author> <title> "The effects of predication on branch prediction," </title> <booktitle> in Proceedings of the 27th Annual ACM/IEEE International Symposium on Microarchi-tecture, </booktitle> <pages> pp. 196-206, </pages> <year> 1994. </year>
Reference-contexts: If the prediction is incorrect, the processor, after removing from its state the effects of the speculatively executed instructions, must return to the point of the branch prediction and begin executing instructions from the correct path. In this case, the full branch execution penalty is suffered. Predicated execution <ref> [7, 16, 5, 10, 15, 22, 9] </ref> is an architectural mechanism that addresses the branch problem by providing the compiler with a set of predicated instructions that can be used to eliminate static branches in the program. <p> They eliminated as many branches as possible through predicated execution and reported its effect on the number of dynamic branches executed, basic block size, wasted issue bandwidth, and the dynamic window size (the number of instructions issued between branch mispre-dictions). Tyson <ref> [22] </ref> studied the performance benefit 1 Two other disadvantages to using predicated execution are that it requires the addition of a third operand to every instruction in the instruction set architecture and the addition of hardware to support its semantics.
Reference: [23] <author> T.-Y. Yeh and Y. N. Patt, </author> <title> "Two-level adaptive branch prediction," </title> <booktitle> in Proceedings of the 24th Annual ACM/IEEE International Symposium on Microarchi-tecture, </booktitle> <pages> pp. 51-61, </pages> <year> 1991. </year>
Reference-contexts: A mechanism other than predicated execution must be used to handle such branches. 1 This paper examines the performance benefit of using both speculative and predicated execution to reduce the branch execution penalty for wide-issue, dynamically scheduled machines that use the Two-Level Adaptive Branch Predictor <ref> [23, 24, 3] </ref>. To minimize the effect of each approach's disadvantages, speculative execution is used to handle the branches that are accurately predicted by the branch predictor and predicated execution is used to eliminate the remaining hard-to-predict branches. <p> The branch predictor simulated by the profiler in our experiments was the Gshare/PAg predictor [11, 3], an aggressive variation of the Two-Level Branch Predictor. This hybrid branch predictor combines the global history (Gshare [11]) and per-address history (PAg <ref> [23] </ref>) schemes of the Two-Level Branch Predictor into one predictor. It bases its prediction on whichever scheme has been making the more accurate predictions for the branch to be predicted. An array of 1K 2-bit updown counters is used to keep track the relative accuracies of the two schemes.
Reference: [24] <author> T.-Y. Yeh and Y. N. Patt, </author> <title> "Alternative implementations of two-level adaptive branch prediction," </title> <booktitle> in Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 124-134, </pages> <year> 1992. </year>
Reference-contexts: A mechanism other than predicated execution must be used to handle such branches. 1 This paper examines the performance benefit of using both speculative and predicated execution to reduce the branch execution penalty for wide-issue, dynamically scheduled machines that use the Two-Level Adaptive Branch Predictor <ref> [23, 24, 3] </ref>. To minimize the effect of each approach's disadvantages, speculative execution is used to handle the branches that are accurately predicted by the branch predictor and predicated execution is used to eliminate the remaining hard-to-predict branches.
References-found: 24

