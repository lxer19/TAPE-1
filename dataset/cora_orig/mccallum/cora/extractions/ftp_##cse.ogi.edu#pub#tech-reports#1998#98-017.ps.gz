URL: ftp://cse.ogi.edu/pub/tech-reports/1998/98-017.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Email: moggi@disi.unige.it  fwalidt,benaissa,sheardg@cse.ogi.edu  
Phone: 2  
Title: An Idealized MetaML: Simpler, and More Expressive (Includes Proofs)  
Author: Eugenio Moggi Walid Taha Zine El-Abidine Benaissa and Tim Sheard 
Address: Genova, Italy  Portland, OR, USA  
Affiliation: 1 DISI, Univ di Genova  Oregon Graduate Institute  
Abstract: MetaML is a multi-stage functional programming language featuring three constructs that can be viewed as statically-typed refinements of the back-quote, comma, and eval of Scheme. Thus it provides special support for writing code generators and serves as a semantically-sound basis for systems involving multiple interdependent computational stages. In previous work, we reported on an implementation of MetaML, and on a small-step semantics and type-system for MetaML. In this paper, we present An Idealized MetaML (AIM) that is the result of our study of a categorical model for MetaML. An important outstanding problem is finding a type system that provides the user with a means for manipulating both open and closed code. This problem has eluded efforts by us and other researchers for over three years. AIM solves the issue by providing two type constructors, one classifies closed code and the other open code, and exploiting the way they interact.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> U. Berger and H. Schwichtenberg. </author> <title> An inverse of the evaluation functional for typed -calculus. </title> <editor> In Rao Vemuri, editor, </editor> <booktitle> Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science. </booktitle> <publisher> IEEE Computer Society Press, Loss Alamitos, </publisher> <year> 1991. </year>
Reference-contexts: This development is crucial for a call-by-name semantics. Such a semantics seems to play an important role in the formal theory of Normalization by Evaluation <ref> [1] </ref> and Type Directed Partial Evaluation [2]; 3. The big-step semantics is defined in the style in which fl was defined [3], and does not make explicit use of a stateful renaming function; 4. Terms have no explicit level annotations.
Reference: 2. <author> Olivier Danvy. </author> <title> Type-directed partial evaluation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 242-257, </pages> <address> Florida, January 1996. New York: </address> <publisher> ACM. </publisher>
Reference-contexts: This development is crucial for a call-by-name semantics. Such a semantics seems to play an important role in the formal theory of Normalization by Evaluation [1] and Type Directed Partial Evaluation <ref> [2] </ref>; 3. The big-step semantics is defined in the style in which fl was defined [3], and does not make explicit use of a stateful renaming function; 4. Terms have no explicit level annotations.
Reference: 3. <author> Rowan Davies. </author> <title> A temporal-logic approach to binding-time analysis. </title> <booktitle> In Proceedings, 11 th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 184-195, </pages> <address> New Brunswick, New Jersey, July 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In a statically typed setting, open code and closed code have different properties, which we explain in the following section. Open and Closed Code A number of typed languages for manipulating code fragments have been proposed in the literature. Some have types for open code <ref> [9, 6, 3, 12] </ref>, and others have types for closed code [4, 13]. On one hand, languages with open code types play an important role in the study of partial evaluation. <p> AIM is strictly more ex pressive than any known typed multi-level language, and features: 1. An open code type hti, which corresponds to flt of fl <ref> [3] </ref> and hti of MetaML; 2. A closed code type [t], which corresponds to flt of fl [4]; 3. Cross-stage persistence of MetaML; 4. A Run-with construct, generalizing Run of MetaML. <p> A closed code type [t], which corresponds to flt of fl [4]; 3. Cross-stage persistence of MetaML; 4. A Run-with construct, generalizing Run of MetaML. This work is the first to achieve a semantically sound integration of Davies and Pfenning's fl [4] and Davies' fl <ref> [3] </ref>, and to identify useful interactions between them. Moreover, we present important simplifications over MetaML [11], which overcome the problems mentioned above: 1. The type system uses only one level annotation, like the fl type system [3]; 2. <p> achieve a semantically sound integration of Davies and Pfenning's fl [4] and Davies' fl <ref> [3] </ref>, and to identify useful interactions between them. Moreover, we present important simplifications over MetaML [11], which overcome the problems mentioned above: 1. The type system uses only one level annotation, like the fl type system [3]; 2. The level Promotion and level Demotion lemmas, and the Substitution lemma, are proven in full generality and not just for the cases restricted to values. This development is crucial for a call-by-name semantics. <p> This development is crucial for a call-by-name semantics. Such a semantics seems to play an important role in the formal theory of Normalization by Evaluation [1] and Type Directed Partial Evaluation [2]; 3. The big-step semantics is defined in the style in which fl was defined <ref> [3] </ref>, and does not make explicit use of a stateful renaming function; 4. Terms have no explicit level annotations. Finally, it is straight forward to extend AIM with new base types and constants, therefore it provides a general setting for investigating staging combinators. <p> Big-Step Semantics 3 Big-Step Semantics The big-step semantics for MetaML [12] reflects the existing implementation: it is complex, and hence not very suitable for formal reasoning. Figure 2 presents a concise big-step semantics for AIM, which is presented at the same level of abstraction as that for fl <ref> [3] </ref>. We avoid the explicit use of a gensym or newname for renaming bound variables: this is implicitly done by substitution. <p> In future work, we hope to improve the syntax based on experience using AIM. 4 Embedding Results This section shows that other languages for staging computations can be translated into AIM, and that the embedding respects the typing and evaluation. The languages we consider are fl <ref> [3] </ref>, MetaML [11], and fl [4]. 4.1 Embedding of fl The embedding of fl into AIM is straight forward. <p> Davies extends the Curry-Howard isomorphism to a relation between temporal logic and the type system for a multi-level language <ref> [3] </ref>. Intuitively, fl provides a good framework for formalizing the presence of back-quote and comma in a statically typed language. The semantics of our Bracket and Escape correspond closely to those of back-quote and comma, respectively.
Reference: 4. <author> Rowan Davies and Frank Pfenning. </author> <title> A modal analysis of staged computation. </title> <booktitle> In 23rd Annual ACM Symposium on Principles of Programming Languages (POPL'96), </booktitle> <address> St.Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Open and Closed Code A number of typed languages for manipulating code fragments have been proposed in the literature. Some have types for open code [9, 6, 3, 12], and others have types for closed code <ref> [4, 13] </ref>. On one hand, languages with open code types play an important role in the study of partial evaluation. Typically, they provide two constructs, one for building a code fragment with free variables, and one for combining such fragments. <p> AIM is strictly more ex pressive than any known typed multi-level language, and features: 1. An open code type hti, which corresponds to flt of fl [3] and hti of MetaML; 2. A closed code type [t], which corresponds to flt of fl <ref> [4] </ref>; 3. Cross-stage persistence of MetaML; 4. A Run-with construct, generalizing Run of MetaML. This work is the first to achieve a semantically sound integration of Davies and Pfenning's fl [4] and Davies' fl [3], and to identify useful interactions between them. <p> A closed code type [t], which corresponds to flt of fl <ref> [4] </ref>; 3. Cross-stage persistence of MetaML; 4. A Run-with construct, generalizing Run of MetaML. This work is the first to achieve a semantically sound integration of Davies and Pfenning's fl [4] and Davies' fl [3], and to identify useful interactions between them. Moreover, we present important simplifications over MetaML [11], which overcome the problems mentioned above: 1. The type system uses only one level annotation, like the fl type system [3]; 2. <p> Box-With and unbox are not in MetaML, but are motivated by fl of Davies and Pfenning <ref> [4] </ref>. <p> The languages we consider are fl [3], MetaML [11], and fl <ref> [4] </ref>. 4.1 Embedding of fl The embedding of fl into AIM is straight forward. <p> Davies and Pfenning show that a generalization of this language to a multi-level language called fl gives rise to a type system related to a modal logic, and that this type system is equivalent to the binding-time analysis of Nielson and Nielson <ref> [4] </ref>. Intuitively, fl provides a natural framework where Scheme's back-quote and eval can be present in a language. The semantics of our Box and Unbox correspond closely to those of back-quote and eval, respectively. Gomard and Jones [6] use a statically-typed two-level language for partial evaluation of the untyped -calculus.
Reference: 5. <author> Robert Gluck and Jesper Jtrgensen. </author> <title> An automatic program generator for multilevel specialization. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 10(2) </volume> <pages> 113-158, </pages> <year> 1997. </year>
Reference-contexts: This language is the basis for many binding-time analyses. Gluck and Jtrgensen study partial evaluation in the generalized context where inputs can arrive at an arbitrary number of times rather than just two (namely, specialization-time and run-time) <ref> [5] </ref>, and demonstrate that binding-time analysis in a multi-level setting can be done with efficiency comparable to that of two-level binding time analysis. Davies extends the Curry-Howard isomorphism to a relation between temporal logic and the type system for a multi-level language [3].
Reference: 6. <author> Carsten K. Gomard and Neil D. Jones. </author> <title> A partial evaluator for the untyped lambda calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(1) </volume> <pages> 21-69, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: In a statically typed setting, open code and closed code have different properties, which we explain in the following section. Open and Closed Code A number of typed languages for manipulating code fragments have been proposed in the literature. Some have types for open code <ref> [9, 6, 3, 12] </ref>, and others have types for closed code [4, 13]. On one hand, languages with open code types play an important role in the study of partial evaluation. <p> Intuitively, fl provides a natural framework where Scheme's back-quote and eval can be present in a language. The semantics of our Box and Unbox correspond closely to those of back-quote and eval, respectively. Gomard and Jones <ref> [6] </ref> use a statically-typed two-level language for partial evaluation of the untyped -calculus. This language is the basis for many binding-time analyses.
Reference: 7. <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the ACM, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference: 8. <author> Eugenio Moggi. </author> <title> A categorical account of two-level languages. </title> <booktitle> In MFPS 1997, </booktitle> <year> 1997. </year>
Reference-contexts: Intuitively, fl provides a good framework for formalizing the presence of back-quote and comma in a statically typed language. The semantics of our Bracket and Escape correspond closely to those of back-quote and comma, respectively. Moggi <ref> [8] </ref> advocates a categorical approach to two-level languages based on indexed categories, and stresses formal analogies with a categorical account of phase distinction and module languages.
Reference: 9. <author> Flemming Nielson and Hanne Rijs Nielson. </author> <title> Two-Level Functional Languages. </title> <booktitle> Number 34 in Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: In a statically typed setting, open code and closed code have different properties, which we explain in the following section. Open and Closed Code A number of typed languages for manipulating code fragments have been proposed in the literature. Some have types for open code <ref> [9, 6, 3, 12] </ref>, and others have types for closed code [4, 13]. On one hand, languages with open code types play an important role in the study of partial evaluation. <p> Nielson and Nielson present a seminal detailed study into a two-level functional programming language <ref> [9] </ref>. This language was developed for studying code generation.
Reference: 10. <author> Calton Pu, Andrew Black, Crispin Cowan, and Jonathan Walpole. </author> <title> Microlanguages for operating system specialization. </title> <booktitle> In Proceedings of the SIGPLAN Workshop on Domain-Specific Languages, </booktitle> <address> Paris, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: ,! fl v is derivable in fl , then there exists v 0 such that e fl; 0 ,! v 0 and v 0 fl v fl; . 5 Related Work Multi-stage programming techniques have been used in a wide variety of settings [12], including run-time specialization of C programs <ref> [10] </ref>. Nielson and Nielson present a seminal detailed study into a two-level functional programming language [9]. This language was developed for studying code generation.
Reference: 11. <author> Walid Taha, Zine-El-Abidine Benaissa, and Tim Sheard. </author> <title> Multi-stage programming: Axiomatization and type-safety. </title> <booktitle> In 25th International Colloquium on Automata, Languages, and Programming, </booktitle> <address> Aalborg, Denmark, </address> <month> 13-17July </month> <year> 1998. </year>
Reference-contexts: For many languages, such an implementation would be almost as simple as an interpreter implementation (especially if back-quote and comma are utilized), but would incur almost non of the overhead associated with an interpretive implementation. MetaML <ref> [12, 11] </ref> provides constructs for manipulating open code and executing it, but does not distinguish between open and closed code types. But open code cannot be executed because it may contain free variables that have not been bound yet. <p> Finally, the last declaration executes this code fragment. Unfortunately, there is a problem with the above example. In particular, the very last declaration is not typable with the basic type system of MetaML <ref> [11] </ref>. Intuitively, the type system for MetaML must keep track of free variables in a code fragment, so as to ensure that programs don't get stuck. <p> Contribution and Organization of this Paper In previous work [12], we reported on the implementation and applications of MetaML, and later <ref> [11] </ref> presented an axiomatic semantics and a type system for MetaML and proved type-safety. However, there were still a number of drawbacks: 1. As discussed above, there is a typing problem with executing a separately-declared code fragment. <p> Cross-stage persistence of MetaML; 4. A Run-with construct, generalizing Run of MetaML. This work is the first to achieve a semantically sound integration of Davies and Pfenning's fl [4] and Davies' fl [3], and to identify useful interactions between them. Moreover, we present important simplifications over MetaML <ref> [11] </ref>, which overcome the problems mentioned above: 1. The type system uses only one level annotation, like the fl type system [3]; 2. The level Promotion and level Demotion lemmas, and the Substitution lemma, are proven in full generality and not just for the cases restricted to values. <p> The first four constructs are the standard ones in a call-by-value -calculus with constants. Bracket and Escape are the same as in MetaML <ref> [12, 11] </ref>. Run-With generalizes Run of MetaML, in that allows the use of additional variables x i in the body of e if they satisfy certain typing requirements that are made explicit in the next section. <p> The Abstraction and Application rules are standard. The Bracket and Escape rules establish an isomorphism between t n+1 and hti n . Typing Run in MetaML <ref> [11] </ref> introduces an extra index-annotation on types for counting the number of Runs surrounding an expression (see Figure 3). We avoid this extra annotation by incrementing the level of all variables in . <p> Demotion on e at n, written e # n , lowers the level of e from level n + 1 down to level n, and is well-defined on all terms, unlike demotion for MetaML <ref> [11] </ref>. <p> In future work, we hope to improve the syntax based on experience using AIM. 4 Embedding Results This section shows that other languages for staging computations can be translated into AIM, and that the embedding respects the typing and evaluation. The languages we consider are fl [3], MetaML <ref> [11] </ref>, and fl [4]. 4.1 Embedding of fl The embedding of fl into AIM is straight forward. <p> Figure 3 recalls the MetaML <ref> [11] </ref>. Definition 3 (Acceptable Judgment). We say that a MetaML typing judgment fx i : (t i ; r i ) n i ji 2 mg ` e: (t; r) n is acceptable if and only if 8i 2 m: r i r. Remark 1.
Reference: 12. <author> Walid Taha and Tim Sheard. </author> <title> Multi-stage programming with explicit annotations. </title> <booktitle> In Proceedings of the ACM-SIGPLAN Symposium on Partial Evaluation and semantic based program manipulations PEPM'97, Amsterdam, </booktitle> <pages> pages 203-217. </pages> <publisher> ACM, </publisher> <year> 1997. </year>
Reference-contexts: In a statically typed setting, open code and closed code have different properties, which we explain in the following section. Open and Closed Code A number of typed languages for manipulating code fragments have been proposed in the literature. Some have types for open code <ref> [9, 6, 3, 12] </ref>, and others have types for closed code [4, 13]. On one hand, languages with open code types play an important role in the study of partial evaluation. <p> For many languages, such an implementation would be almost as simple as an interpreter implementation (especially if back-quote and comma are utilized), but would incur almost non of the overhead associated with an interpretive implementation. MetaML <ref> [12, 11] </ref> provides constructs for manipulating open code and executing it, but does not distinguish between open and closed code types. But open code cannot be executed because it may contain free variables that have not been bound yet. <p> But there is no way for the type system to know that program is closed, hence, a conservative approximation is made, and the term is rejected by the type system. Contribution and Organization of this Paper In previous work <ref> [12] </ref>, we reported on the implementation and applications of MetaML, and later [11] presented an axiomatic semantics and a type system for MetaML and proved type-safety. However, there were still a number of drawbacks: 1. As discussed above, there is a typing problem with executing a separately-declared code fragment. <p> The first four constructs are the standard ones in a call-by-value -calculus with constants. Bracket and Escape are the same as in MetaML <ref> [12, 11] </ref>. Run-With generalizes Run of MetaML, in that allows the use of additional variables x i in the body of e if they satisfy certain typing requirements that are made explicit in the next section. <p> Big-Step Semantics 3 Big-Step Semantics The big-step semantics for MetaML <ref> [12] </ref> reflects the existing implementation: it is complex, and hence not very suitable for formal reasoning. Figure 2 presents a concise big-step semantics for AIM, which is presented at the same level of abstraction as that for fl [3]. <p> AIM has no function of type t ! [t], thus we avoid the "collapse" of types in the recent work of Wickline, Lee, and Pfenning [13]. Such a function does not exist in MetaML. 2. up : t ! hti. This function corresponds to cross-stage persistence <ref> [12] </ref>, in fact it embeds any value into an open fragment, including values of functional type. Such a function does not exist in fl . <p> 2 E fl is closed and e ,! fl v is derivable in fl , then there exists v 0 such that e fl; 0 ,! v 0 and v 0 fl v fl; . 5 Related Work Multi-stage programming techniques have been used in a wide variety of settings <ref> [12] </ref>, including run-time specialization of C programs [10]. Nielson and Nielson present a seminal detailed study into a two-level functional programming language [9]. This language was developed for studying code generation.
Reference: 13. <author> Philip Wickline, Peter Lee, and Frank Pfenning. </author> <title> Run-time code generation and Modal-ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN'98 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 224-235, </pages> <address> Montreal, Canada, </address> <month> 17-19 June </month> <year> 1998. </year>
Reference-contexts: Open and Closed Code A number of typed languages for manipulating code fragments have been proposed in the literature. Some have types for open code [9, 6, 3, 12], and others have types for closed code <ref> [4, 13] </ref>. On one hand, languages with open code types play an important role in the study of partial evaluation. Typically, they provide two constructs, one for building a code fragment with free variables, and one for combining such fragments. <p> Only a call-by-value semantics could be defined for MetaML, because substitution was a partial function, only defined when variables are substituted with values. 3. The type judgment used two indices. Moreover, it has been criticized for not being based on a standard logical system <ref> [13] </ref>. This paper describes the type system and operational semantics of An Idealized MetaML (AIM), whose design is inspired by a categorical model for MetaML (such a model will be the subject of another paper). AIM is strictly more ex pressive than any known typed multi-level language, and features: 1. <p> This function executes closed code. AIM has no function of type t ! [t], thus we avoid the "collapse" of types in the recent work of Wickline, Lee, and Pfenning <ref> [13] </ref>. Such a function does not exist in MetaML. 2. up : t ! hti. This function corresponds to cross-stage persistence [12], in fact it embeds any value into an open fragment, including values of functional type. Such a function does not exist in fl .
References-found: 13

