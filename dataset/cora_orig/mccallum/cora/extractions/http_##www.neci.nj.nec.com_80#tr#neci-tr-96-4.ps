URL: http://www.neci.nj.nec.com:80/tr/neci-tr-96-4.ps
Refering-URL: http://www.neci.nj.nec.com:80/tr/
Root-URL: 
Email: cher@cemi.msk.su  avg@research.nj.nec.com  
Title: Heap-on-Top Priority Queues  
Author: Boris V. Cherkassky Andrew V. Goldberg 
Keyword: shortest path algorithm  
Note: [11], improving the previous bounds. This work was done while the author was visiting NEC Research Institute.  
Date: March 1996  
Address: Krasikova St. 32 117418, Moscow, Russia  4 Independence Way Princeton, NJ 08540  
Affiliation: Central Economics and Mathematics Institute  NEC Research Institute  
Abstract: We introduce the heap-on-top (hot) priority queue data structure that combines the multi-level bucket data structure of Denardo and Fox [9] and a heap. We use the new data structure to obtain an O(m + n(log C) 1 3 +* ) expected time implementation of Dijkstra's 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: We call a sequence of operations on a priority queue preemptive if the sequence starts and 2 ends with an empty queue. In particular, implementations of Dijkstra's shortest path algorithm produce preemptive operation sequences. In this paper we use the RAM model of computation <ref> [1] </ref>. The only non-obvious result about the model we use appears in [7], where it is attributed to B. Schieber.
Reference: [2] <author> R. K. Ahuja, K. Mehlhorn, J. B. Orlin, and R. E. Tarjan. </author> <title> Faster Algorithms for the Shortest Path Problem. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 37(2) </volume> <pages> 213-223, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in [4, 12, 15]. Alternative implementations of priority queues use buckets (e.g. <ref> [2, 6, 9, 10] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure. Heaps are more efficient when the number of elements on the heap is small. <p> The resulting implementation takes advantage of the best performance features of both data structures. We also give an alternative description of the multi-level bucket data structure which is more insightful. Hot queues are related to, but simpler and more flexible than, the radix heaps 1 of Ahuja et. al. <ref> [2] </ref>. One advantage of our queues is that they can use any implementation of a heap. In contrast, radix heaps require a heap with operation time that depends on the number of distinct keys on the heap. The most complicated part of [2] is a modification of the Fibonacci heap data <p> the radix heaps 1 of Ahuja et. al. <ref> [2] </ref>. One advantage of our queues is that they can use any implementation of a heap. In contrast, radix heaps require a heap with operation time that depends on the number of distinct keys on the heap. The most complicated part of [2] is a modification of the Fibonacci heap data structure [12] that meets this requirement. Hot queues can use Fibonacci heaps with no modifications while achieving the same bounds as radix heaps. Using the heap of Thorup [15], we obtain better bounds. <p> This improves the deterministic bound of O (m + n p log C) that uses radix heaps <ref> [2] </ref>. (The hot queue implementation based on Fibonacci heaps matches this deterministic bound.) 5 Concluding Remarks The hot queue data structure combines the best features of heaps and multi-level buckets in a natural way.
Reference: [3] <author> P. Van Emde Boas, R. Kaas, and Zijlstra. </author> <title> Design and Implementation of Efficient Priority Queue. </title> <journal> Math. Systems Theory, </journal> <volume> 10 </volume> <pages> 99-127, </pages> <year> 1977. </year>
Reference-contexts: The fastest implementations of heaps are described in [4, 12, 15]. Alternative implementations of priority queues use buckets (e.g. [2, 6, 9, 10]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See <ref> [3] </ref> for a related data structure. Heaps are more efficient when the number of elements on the heap is small. Bucket-based priority queues are more efficient when the maximum event duration C is small.
Reference: [4] <author> G. S. Brodal. </author> <title> Worst-Case Efficient Priority Queues. </title> <booktitle> In Proc. 7th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 52-58, </pages> <year> 1996. </year> <month> 10 </month>
Reference-contexts: In this paper we deal with monotone priority queues. Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in <ref> [4, 12, 15] </ref>. Alternative implementations of priority queues use buckets (e.g. [2, 6, 9, 10]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure.
Reference: [5] <author> R. Brown. </author> <title> Calandar Queues: A Fast O(1) Priority Queue Implementation for the Simulation Event Set Problem. </title> <journal> Comm. ACM, </journal> <volume> 31 </volume> <pages> 1220-1227, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction A priority queue is a data structure that maintains a set of elements and supports operations insert, decrease-key, and extract-min. Priority queues are fundamental data structures with many applications. Typical applications include graph algorithms (e.g. [12]) and event simulation (e.g. <ref> [5] </ref>). An important subclass of priority queues, used in applications such as event simulation and in Dijkstra's shortest path algorithm [11], are monotone priority queues.
Reference: [6] <author> B. V. Cherkassky, A. V. Goldberg, and T. Radzik. </author> <title> Shortest Paths Algorithms: Theory and Experimental Evaluation. </title> <booktitle> In Proc. 5th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 516-525, </pages> <year> 1994. </year> <note> To appear in Math. Prog. </note>
Reference-contexts: Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in [4, 12, 15]. Alternative implementations of priority queues use buckets (e.g. <ref> [2, 6, 9, 10] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure. Heaps are more efficient when the number of elements on the heap is small. <p> Since Thorup's bounds depend on the total number of elements on the heap, radix heaps cannot take immediate advantage of this data structure. Hot queues appear to be more practical than radix heaps. Our queues are simpler. Furthermore, experience with multi-level bucket implementations <ref> [6, 13] </ref> suggests that practical implementations of hot queues should have a small number of levels (e.g. 3). Such implementations have no similar radix heap variants. This paper is organized as follows. Section 2 introduces basic definitions. Our description of the multi-level bucket data structure appears in Section 3.
Reference: [7] <author> R. Cole and U. Vishkin. </author> <title> Deterministic Coin Tossing and Accelerating Cascades: Micro and Macro Techniques for Designing Parallel Algorithms. </title> <booktitle> In Proc. 18th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 206-219, </pages> <year> 1986. </year>
Reference-contexts: In particular, implementations of Dijkstra's shortest path algorithm produce preemptive operation sequences. In this paper we use the RAM model of computation [1]. The only non-obvious result about the model we use appears in <ref> [7] </ref>, where it is attributed to B. Schieber.
Reference: [8] <author> R. Cole and U. Vishkin. </author> <title> Deterministic Coin Tossing with Applications to Optimal Parallel List Ranking. </title> <journal> Information and Control, </journal> <volume> 70 </volume> <pages> 32-53, </pages> <year> 1986. </year>
Reference-contexts: It is straightforward to see that if we use appropriate masks and the fact that the index of the first bit in which two words differ can be computed in constant time <ref> [8] </ref>, we can compute the position in constant time. Iterating through the levels, we can find the lowest nonempty level in O (k) time. Using binary search, we can find the level in O (log k) time.
Reference: [9] <author> E. V. Denardo and B. L. Fox. </author> <title> Shortest-Route Methods: 1. Reaching, Pruning, </title> <journal> and Buckets. Oper. Res., </journal> <volume> 27 </volume> <pages> 161-186, </pages> <year> 1979. </year>
Reference-contexts: Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in [4, 12, 15]. Alternative implementations of priority queues use buckets (e.g. <ref> [2, 6, 9, 10] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure. Heaps are more efficient when the number of elements on the heap is small. <p> In this sense, heaps and buckets complement each other. We introduce heap-on-top priority queues (hot queues), which combine the multi-level bucket data structure of Denardo and Fox <ref> [9] </ref> and a heap. The resulting implementation takes advantage of the best performance features of both data structures. We also give an alternative description of the multi-level bucket data structure which is more insightful. <p> Schieber. The result is that given two machine words, we can find, in constant time, the index of the most significant bit in which the two words differ. 3 Multi-Level Buckets In this section we describe the k-level bucket data structure of Denardo and Fox <ref> [9] </ref>. We give a simpler description of this data structure by treating the element keys as base- numbers for a certain parameter . A k-level bucket structure B contains k levels of buckets. Except for the top level, a level contains an array of buckets. <p> This takes O () time. Lemma 3.4 We can find the first nonempty bucket at a level in O () time. Remark. One can do better <ref> [9] </ref>. Divide buckets at every level into groups of size dlog Ce, each group containing consecutive buckets. For each group, maintain a dlog Ce-bit number with bit j equal to 1 if and only if the j-th bucket in the group is not empty.
Reference: [10] <author> R. B. Dial. </author> <title> Algorithm 360: Shortest Path Forest with Topological Ordering. </title> <journal> Comm. ACM, </journal> <volume> 12 </volume> <pages> 632-633, </pages> <year> 1969. </year>
Reference-contexts: Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in [4, 12, 15]. Alternative implementations of priority queues use buckets (e.g. <ref> [2, 6, 9, 10] </ref>). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure. Heaps are more efficient when the number of elements on the heap is small.
Reference: [11] <author> E. W. Dijkstra. </author> <title> A Note on Two Problems in Connection with Graphs. </title> <journal> Numer. Math., </journal> <volume> 1 </volume> <pages> 269-271, </pages> <year> 1959. </year>
Reference-contexts: Priority queues are fundamental data structures with many applications. Typical applications include graph algorithms (e.g. [12]) and event simulation (e.g. [5]). An important subclass of priority queues, used in applications such as event simulation and in Dijkstra's shortest path algorithm <ref> [11] </ref>, are monotone priority queues. A priority queue is monotone if keys of elements on the queue are at least as big as the key of the latest element extracted from the queue. In this paper we deal with monotone priority queues.
Reference: [12] <author> M. L. Fredman and R. E. Tarjan. </author> <title> Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 34 </volume> <pages> 596-615, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction A priority queue is a data structure that maintains a set of elements and supports operations insert, decrease-key, and extract-min. Priority queues are fundamental data structures with many applications. Typical applications include graph algorithms (e.g. <ref> [12] </ref>) and event simulation (e.g. [5]). An important subclass of priority queues, used in applications such as event simulation and in Dijkstra's shortest path algorithm [11], are monotone priority queues. <p> In this paper we deal with monotone priority queues. Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in <ref> [4, 12, 15] </ref>. Alternative implementations of priority queues use buckets (e.g. [2, 6, 9, 10]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure. <p> In contrast, radix heaps require a heap with operation time that depends on the number of distinct keys on the heap. The most complicated part of [2] is a modification of the Fibonacci heap data structure <ref> [12] </ref> that meets this requirement. Hot queues can use Fibonacci heaps with no modifications while achieving the same bounds as radix heaps. Using the heap of Thorup [15], we obtain better bounds. <p> The first fact is that the number of elements on H never exceeds kt since each level accounts for at most t elements. The second fact is Lemma 4.1. Given the first fact and Theorem 3.5, the bounds are straightforward. For Fibonacci heaps <ref> [12] </ref>, the amortized time bounds are I (N ) = D (N ) = F (N ) = O (1), and X (N ) = O (log N ).
Reference: [13] <author> A. V. Goldberg and C. Silverstein. </author> <title> Implementations of Dijkstra's Algorithm Based on Multi-Level Buckets. </title> <type> Technical Report 95-187, </type> <institution> NEC Research Institute, Princeton, NJ, </institution> <year> 1995. </year>
Reference-contexts: Since Thorup's bounds depend on the total number of elements on the heap, radix heaps cannot take immediate advantage of this data structure. Hot queues appear to be more practical than radix heaps. Our queues are simpler. Furthermore, experience with multi-level bucket implementations <ref> [6, 13] </ref> suggests that practical implementations of hot queues should have a small number of levels (e.g. 3). Such implementations have no similar radix heap variants. This paper is organized as follows. Section 2 introduces basic definitions. Our description of the multi-level bucket data structure appears in Section 3.
Reference: [14] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA, </address> <year> 1983. </year>
Reference-contexts: The running time of Dijkstra's algorithm is dominated by a preemptive sequence of priority queue operations that includes O (n) insert and extract-min operations and O (m) decrease-key operations (see e.g. <ref> [14] </ref>). The maximum event duration for this sequence of operations is C. The bounds for the queue operations immediately imply the following result.
Reference: [15] <author> M. </author> <title> Thorup. On RAM Priority Queues. </title> <booktitle> In Proc. 7th ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 59-67, </pages> <year> 1996. </year> <month> 11 </month>
Reference-contexts: In this paper we deal with monotone priority queues. Unless mentioned otherwise, we refer to priority queues whose operation time bounds depend only on the number of elements on the queue as heaps. The fastest implementations of heaps are described in <ref> [4, 12, 15] </ref>. Alternative implementations of priority queues use buckets (e.g. [2, 6, 9, 10]). Operation times for bucket-based implementations depend on the maximum event duration C, defined in Section 2. See [3] for a related data structure. <p> The most complicated part of [2] is a modification of the Fibonacci heap data structure [12] that meets this requirement. Hot queues can use Fibonacci heaps with no modifications while achieving the same bounds as radix heaps. Using the heap of Thorup <ref> [15] </ref>, we obtain better bounds. As a side-effect, we obtain an O (m+ 1 Radix heaps use both buckets and heaps, and their operation time bounds depend on C. 1 n (log C) 3 +* ) expected time implementation of Dijkstra's shortest path algorithm, improving the previous bounds. <p> Setting k = p O ( log C), O (1), and O ( log C) amortized bounds. Radix heaps achieve the same bounds but are more complicated. For Thorup's heaps <ref> [15] </ref>, the expected amortized time bounds are I (N ) = D (N ) = F (N ) = O (1), and X (N ) = O (log 2 +* N ).
References-found: 15

