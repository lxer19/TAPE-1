URL: http://www.cs.unc.edu/~anderson/diss/overton.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/
Root-URL: http://www.cs.unc.edu
Title: A Foray into Uniprocessor Real-Time Scheduling Algorithms and Intractibility  
Author: Ed Overton Drs. T. Brylawski and J. Anderson advisors 
Affiliation: 1 UNC-CH Department of Mathematics 2 UNC-CH Department of Computer Science  
Date: December 3, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [ARJ '97] <author> J. Anderson, S. Ramamurthy, and K. Jeffay, </author> <title> Real-Time Computing with Lock-Free Shared Objects (Technical Report), </title> <note> scheduled to appear in ACM Transactions on Computer Systems, 15(2), </note> <year> 1997. </year>
Reference-contexts: If that fraction is greater than one, then there is more "work" than time available, and the task set has no valid schedule. We follow the work of <ref> [ARJ '97] </ref>. Theorem 3.1 ([ARJ '97]) If a task set is schedulable, its utilization must be at most 1. Proof: Assume that there is a valid schedule for some task set T . Then every deadline of the task set will be met.
Reference: [ABD '95] <author> Neil C. Audsley, Alan Burns, Robert I. Davis, Ken W. Tindell and Andy J. Wellings, </author> <title> Fixed Priority Pre-emptive Scheduling: An Historical Perspective, </title> <booktitle> Real-Time Systems, </booktitle> <volume> 8: </volume> <pages> 173-198, </pages> <year> 1995. </year>
Reference: [BHR '93] <author> Sanjoy K. Baruah, Rodney R. Howell, and Louis E. Rosier, </author> <title> Feasibility problems for recurring tasks on one processor, </title> <journal> Theoretical Computer Science, </journal> <volume> 118: </volume> <pages> 3-20, </pages> <year> 1993. </year>
Reference-contexts: We will consider four scheduling algorithms for task sets of periodic tasks without shared resources: rate monotonic [LL '73, LSD '89, La '74], and deadline monotonic [LW '82] use static priorities; earliest deadline first <ref> [LL '73, LM '80, BRH '90, BHR '93] </ref>, and modified least laxity first use dynamic priorities. The modified least laxity first scheduling algorithm was developed by the author to generalize two dynamic priority scheduling algorithms - earliest deadline first, and least laxity first [Mo '83]. <p> This is shown in [LW '82] by a reduction of the Simultaneous Congruences Problem (SCP) to the feasibility problem above. SCP has been shown to be NP -complete in the strong sense in <ref> [BHR '93] </ref>. <p> Since there is no idle time on [t 1 ; t 2 ) and all execution corresponds to releases on that interval, P n Thus, we have a contradiction to condition 2. Hence, there is no such missed deadline t 2 . 2 To prepare for the complexity analysis, <ref> [BHR '93] </ref> shows that i (t 1 ; t 2 ) can be efficiently computed. Lemma 6.3 ([BHR '93]) i (t 1 ; t 2 ) = max 0; t 2 r i d i % ( & p i + 1 Proof: By definition of i (t 1 ; t <p> We will follow the work of [LM '80] to reduce the Simultaneous Congruences Problem (SCP), which is shown to be NP -complete in the strong 76 sense in <ref> [BHR '93] </ref>, to determining if a task set is not feasible. Note that this reduction is very similar to the reduction found in Section 5.5.
Reference: [BRH '90] <author> Sanjoy K. Baruah, Louis E. Rosier, and Rodney R. Howell, </author> <title> Algorithms and Complexity Concerning the Preemptive Scheduling of Periodic, Real-Time Tasks on One Processor, </title> <booktitle> Real-Time Systems, </booktitle> <volume> 2: </volume> <pages> 301-324, </pages> <year> 1990. </year>
Reference-contexts: We will consider four scheduling algorithms for task sets of periodic tasks without shared resources: rate monotonic [LL '73, LSD '89, La '74], and deadline monotonic [LW '82] use static priorities; earliest deadline first <ref> [LL '73, LM '80, BRH '90, BHR '93] </ref>, and modified least laxity first use dynamic priorities. The modified least laxity first scheduling algorithm was developed by the author to generalize two dynamic priority scheduling algorithms - earliest deadline first, and least laxity first [Mo '83]. <p> Therefore, all deadlines at or after time r + 2P are met. By the lemma assumption, all deadlines in [0; r + 2P ] are met. Therefore, all deadlines of T in g are met, and g is valid. 2 <ref> [BRH '90] </ref> followed the work of [LM '80], and produced another feasibility test for EDF which does not require one to compute the entire schedule on the interval [0; r + 2P ].
Reference: [CL '90] <author> Min-ih Chen and Kwei-Jay Lin, </author> <title> Dynamic Priority Ceilings: A Concurrency Control Protocol for Real-Time Systems, </title> <booktitle> Real-Time Systems, </booktitle> <volume> 2: </volume> <pages> 325-346, </pages> <year> 1990. </year>
Reference: [Je '92] <author> Kevin Jeffay, </author> <title> Scheduling Sporadic Tasks with Shared Resources in Hard-Real-Time Systems, </title> <booktitle> IEEE Real-Time Systems Symposium, </booktitle> <address> ,1992. </address>
Reference: [La '74] <author> Jacques Labetoulle, </author> <title> Some Theorems on Real Time Scheduling, appearing in: </title> <editor> E. Gelenbe and R. Mahl, eds., </editor> <booktitle> Computer Architectures and Networks, </booktitle> <publisher> (North-Holland Publishing, </publisher> <address> Amsterdam) 285-293, </address> <year> 1974. </year>
Reference-contexts: In that regard, there are two subsets of scheduling algorithms: ones where priorities are fixed (static priorities), and ones where priorities may change over time (dynamic priorities). We will consider four scheduling algorithms for task sets of periodic tasks without shared resources: rate monotonic <ref> [LL '73, LSD '89, La '74] </ref>, and deadline monotonic [LW '82] use static priorities; earliest deadline first [LL '73, LM '80, BRH '90, BHR '93], and modified least laxity first use dynamic priorities. <p> However, since we are considering hard-real-time systems, time may be critical, and the time it takes to determine feasibility might defer the start of the schedule while feasibility is determined. In such a case, one would clearly want a "quick" feasibility test. Following the work of <ref> [LL '73, LSD '89, La '74] </ref>, we will determine that for the conditions where rate-monotonic scheduling is optimal, there is a linear time feasibility test for rate montonic scheduling that determines necessity, but not sufficiency.
Reference: [LSD '89] <author> John Lehoczky, Lui Sha, and Ye Ding, </author> <title> The Rate Monotonic Scheduling Algorithm: Exact Case Characterization And Average Case Behavior, </title> <booktitle> Proc. IEEE Real-Time Systems Symposium 166-171, </booktitle> <year> 1989. </year>
Reference-contexts: In that regard, there are two subsets of scheduling algorithms: ones where priorities are fixed (static priorities), and ones where priorities may change over time (dynamic priorities). We will consider four scheduling algorithms for task sets of periodic tasks without shared resources: rate monotonic <ref> [LL '73, LSD '89, La '74] </ref>, and deadline monotonic [LW '82] use static priorities; earliest deadline first [LL '73, LM '80, BRH '90, BHR '93], and modified least laxity first use dynamic priorities. <p> However, since we are considering hard-real-time systems, time may be critical, and the time it takes to determine feasibility might defer the start of the schedule while feasibility is determined. In such a case, one would clearly want a "quick" feasibility test. Following the work of <ref> [LL '73, LSD '89, La '74] </ref>, we will determine that for the conditions where rate-monotonic scheduling is optimal, there is a linear time feasibility test for rate montonic scheduling that determines necessity, but not sufficiency. <p> This development hinges on the determination of a "worst case" task set one that minimizes utilization while fully utilizing the processor. In this section, we will re-develop some of [LL '73]'s results based upon several lemmas that we create from the works of [LL '73] and <ref> [LSD '89] </ref>. We now proceed to develop mathematical tests for schedulability and full utilization. With these lemmas in hand, we will be able to answer the "worst case" task set question, and define the task sets that minimize utilization while fully utilizing the processor. <p> Such an algorithm is pseudo-polynomial, however, since the algorithm must compute the schedule until time maxfp i g. The prioritization phase is computable in O (n log 2 n) time, since one must sort the n priorities. In <ref> [LSD '89] </ref>, another pseudo-polynomial time algorithm is developed that does not require computation of the full schedule from time 0 to time maxfp i g, as discussed 54 above. [LSD '89]'s method is based on Lemma 4.4: max 8 &gt; &gt; : t2 kp j jji;k2f1;:::; p i k o &lt; <p> The prioritization phase is computable in O (n log 2 n) time, since one must sort the n priorities. In <ref> [LSD '89] </ref>, another pseudo-polynomial time algorithm is developed that does not require computation of the full schedule from time 0 to time maxfp i g, as discussed 54 above. [LSD '89]'s method is based on Lemma 4.4: max 8 &gt; &gt; : t2 kp j jji;k2f1;:::; p i k o &lt; 1 i X & p j e j = 9 &gt; &gt; ; The given computation indicates that the RM feasibility question is in NP : Given a task <p> Each such computation is clearly in O (n), and there are n such computations. Hence, the nondeterministic choices yield a computation time in O (n 2 ). To deterministically decide if a task set is schedulable, one would use Lemma 4.4 as well. It is noted in <ref> [LSD '89] </ref> that the maximum is only necessary for a subset of the given tasks. The idea is that one can use the utilization test defined in Theorem 4.4 to test subsets of the entire task set.
Reference: [LW '82] <author> Joseph Y.-T. Leung and Jennifer Whitehead, </author> <title> On the Complexity of Fixed-Priority Scheduling of Periodic, Real-Time Tasks, Performance Evaluation, </title> <booktitle> 2: </booktitle> <pages> 237-250, </pages> <year> 1982. </year>
Reference-contexts: We will consider four scheduling algorithms for task sets of periodic tasks without shared resources: rate monotonic [LL '73, LSD '89, La '74], and deadline monotonic <ref> [LW '82] </ref> use static priorities; earliest deadline first [LL '73, LM '80, BRH '90, BHR '93], and modified least laxity first use dynamic priorities. <p> We will show that there exists a pseudo-polynomial time necessary and sufficient test that indicates the feasibility question for rate monontonic scheduling is in NP. We will then follow <ref> [LW '82] </ref> to show it is a generalization of rate-monotonic scheduling, and to determine the conditions under which deadline-monotonic scheduling is optimal. <p> Hence, it should be the first one to complete (so that it will be ready for its next release). In [LL '73], RM is considered in the case where each task's deadline is concurrent with the task's next release (thus, d i = p i ). <ref> [LW '82] </ref> later showed that RM is not optimal when this case does not hold, and developed deadline monotonic scheduling (DM). We will consider DM in Section 5. <p> The graph below shows both the "failed" prioritization and the valid schedule. According to <ref> [LW '82] </ref>, no static-priority scheduling algorithm has been discovered which is optimal for an arbitrary asynchronous system and produces task prioritizations in polynomial time we were unable to find either a more recent confirmation of this claim or a development of such an algorithm. <p> However, simply computing all possible prioritizations requires a factorial (of the number of tasks) amount of time, which doesn't even consider the amount of time it takes to compute feasibility. Results from <ref> [LW '82] </ref> show that DM is also optimal for asynchronous task sets under either of two specific conditions. First, if the task sets under consideration contain only two tasks, and d i = p i for i 2 f1; 2g. <p> We do not duplicate those results here. <ref> [LW '82] </ref> then provides a valuable tool, an algorithm to determine schedulability of discrete static priority scheduling algorithms for asynchronous task sets with integer valued param 58 eters. <p> Thus, we do not know of a pseudo-polynomial time algorithm for feasibility in the asynchronous case. In fact, given some task set T , determining if there is a valid static-priority schedule of T is co-NP -complete in the strong sense. This is shown in <ref> [LW '82] </ref> by a reduction of the Simultaneous Congruences Problem (SCP) to the feasibility problem above. SCP has been shown to be NP -complete in the strong sense in [BHR '93].
Reference: [LM '80] <author> Joseph Y.-T. Leung and M.L. Merrill, </author> <title> A Note on Preemptive Scheduling of Periodic, Real-Time Tasks, </title> <journal> Information Processing Letters, </journal> <volume> 11(3): </volume> <pages> 115-118, </pages> <year> 1980. </year>
Reference-contexts: We will consider four scheduling algorithms for task sets of periodic tasks without shared resources: rate monotonic [LL '73, LSD '89, La '74], and deadline monotonic [LW '82] use static priorities; earliest deadline first <ref> [LL '73, LM '80, BRH '90, BHR '93] </ref>, and modified least laxity first use dynamic priorities. The modified least laxity first scheduling algorithm was developed by the author to generalize two dynamic priority scheduling algorithms - earliest deadline first, and least laxity first [Mo '83]. <p> Thus, if EDF cannot schedule the task set, neither can any other scheduling algorithm. 2 6.4 A feasibility test Note that much of this work parallels work in Section 5.4, and we are able to use the lemmas there to greatly simplify our efforts here. <ref> [LM '80] </ref> derives an algorithm to determine the feasibility of producing a valid schedule under EDF for asynchronous task sets with integer valued parameters. <p> Therefore, all deadlines at or after time r + 2P are met. By the lemma assumption, all deadlines in [0; r + 2P ] are met. Therefore, all deadlines of T in g are met, and g is valid. 2 [BRH '90] followed the work of <ref> [LM '80] </ref>, and produced another feasibility test for EDF which does not require one to compute the entire schedule on the interval [0; r + 2P ]. <p> Note that since EDF is optimal among scheduling algorithms for all tasks sets, this result then implies that the general question of schedulability of a given task set on a uniprocessor system is also co-NP -complete in the strong sense. We will follow the work of <ref> [LM '80] </ref> to reduce the Simultaneous Congruences Problem (SCP), which is shown to be NP -complete in the strong 76 sense in [BHR '93], to determining if a task set is not feasible. Note that this reduction is very similar to the reduction found in Section 5.5.
Reference: [LL '73] <author> C.L. Liu and James W. Layland, </author> <title> Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment, </title> <journal> JACM, </journal> <volume> 20(1): </volume> <pages> 174-189, </pages> <year> 1973. </year> <month> 96 </month>
Reference-contexts: In that regard, there are two subsets of scheduling algorithms: ones where priorities are fixed (static priorities), and ones where priorities may change over time (dynamic priorities). We will consider four scheduling algorithms for task sets of periodic tasks without shared resources: rate monotonic <ref> [LL '73, LSD '89, La '74] </ref>, and deadline monotonic [LW '82] use static priorities; earliest deadline first [LL '73, LM '80, BRH '90, BHR '93], and modified least laxity first use dynamic priorities. <p> We will consider four scheduling algorithms for task sets of periodic tasks without shared resources: rate monotonic [LL '73, LSD '89, La '74], and deadline monotonic [LW '82] use static priorities; earliest deadline first <ref> [LL '73, LM '80, BRH '90, BHR '93] </ref>, and modified least laxity first use dynamic priorities. The modified least laxity first scheduling algorithm was developed by the author to generalize two dynamic priority scheduling algorithms - earliest deadline first, and least laxity first [Mo '83]. <p> However, since we are considering hard-real-time systems, time may be critical, and the time it takes to determine feasibility might defer the start of the schedule while feasibility is determined. In such a case, one would clearly want a "quick" feasibility test. Following the work of <ref> [LL '73, LSD '89, La '74] </ref>, we will determine that for the conditions where rate-monotonic scheduling is optimal, there is a linear time feasibility test for rate montonic scheduling that determines necessity, but not sufficiency. <p> 1 0 , i.e., i=1 p i Thus, if there is a valid schedule for the given task set, then the task set's utilization is at most 1. 2 4 Rate Monotonic Scheduling Rate monotonic scheduling (RM) was the focus of one of the seminal papers in hard-real-time scheduling theory, <ref> [LL '73] </ref>. The paper laid most of the ground work for much of the development of static-priority scheduling. RM is easy to understand and simple to implement, yet it yields several significant results. Additionally, RM is an optimal scheduling algorithm for static-priority scheduling algorithms under certain circumstances. <p> Intuitively, this prioritization makes sense, since the task that has the shortest period will be the first one to be re-released. Hence, it should be the first one to complete (so that it will be ready for its next release). In <ref> [LL '73] </ref>, RM is considered in the case where each task's deadline is concurrent with the task's next release (thus, d i = p i ). [LW '82] later showed that RM is not optimal when this case does not hold, and developed deadline monotonic scheduling (DM). <p> Theorem 4.1 (<ref> [LL '73] </ref>) Any static-priority scheduling algorithm where priorities are ordered identically with the task's deadline spans is an optimal scheduling policy among static-priority scheduling algorithms for synchronous task sets. Proof: This optimality is shown in [LL '73] via a priority swapping argument. Let T be a task set of n tasks, and since we are considering a static-priority scheduling algorithm, we 11 know that P 1 &lt; P 2 &lt; : : : &lt; P n . <p> This corollary follows directly from Theorem 4.1 since under RM, priorities are ordered by period lengths. Since we are assuming period lengths are equal to deadline spans, then the theorem holds for RM under the given restrictions. 4.4 Utilization Results One of the more powerful results of <ref> [LL '73] </ref> is the derivation of a sufficient test of schedu-lability under RM related to the utilization of the given task set. This development hinges on the determination of a "worst case" task set one that minimizes utilization while fully utilizing the processor. <p> This development hinges on the determination of a "worst case" task set one that minimizes utilization while fully utilizing the processor. In this section, we will re-develop some of <ref> [LL '73] </ref>'s results based upon several lemmas that we create from the works of [LL '73] and [LSD '89]. We now proceed to develop mathematical tests for schedulability and full utilization. <p> This development hinges on the determination of a "worst case" task set one that minimizes utilization while fully utilizing the processor. In this section, we will re-develop some of <ref> [LL '73] </ref>'s results based upon several lemmas that we create from the works of [LL '73] and [LSD '89]. We now proceed to develop mathematical tests for schedulability and full utilization. With these lemmas in hand, we will be able to answer the "worst case" task set question, and define the task sets that minimize utilization while fully utilizing the processor. <p> Thus, j p j 2 with equality if and only if 2p j = p i . The remainder of the proof should be clear. 2 <ref> [LL '73] </ref> states the following result, but their proof is faulty (as will be shown below). The theorem lays the groundwork for providing a necessary condition for schedulability under RM. <p> Thus, if those three conditions hold, T has the same utilization of the task set T 0 (which has less than n tasks) that fully utilizes the processor. It is in <ref> [LL '73] </ref>'s case 2 that the proof is faulty. There, case 2 is when there exists some t i such that e i &lt; p i+1 p i , and for all j &lt; i, e j = p j+1 p j . <p> 1 16 20 j t 2 The modified task set then becomes ( = 1) t 0 t 0 t 0 and the processor executes as follows T ime j T ask 1 2 3 1 2 18 20 j idle (!) Thus, the transformation in case 2 described in <ref> [LL '73] </ref> does not necessarily produce a task set that fully utilizes the processor. Hence, the induction used in that proof does not hold. Now we expand our consideration to all task sets, and show that the minimum acheived in Theorem 4.2 is a miminum over all task sets. <p> Note that we are not assuming that r i = 0 for all i, as is assumed in <ref> [LL '73] </ref>. Proof: Assume that for some task set T , the schedule produced by EDF is not feasible. Then there must exist some time t 2 when overflow occurs. Let us assume that task t j overflows at t 2 .
Reference: [Mo '83] <author> Aloysius K. Mok, </author> <title> Fundamental Design Problems of Distributed Systems for the Hard-Real-Time Environment, </title> <type> PhD. Thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: The modified least laxity first scheduling algorithm was developed by the author to generalize two dynamic priority scheduling algorithms - earliest deadline first, and least laxity first <ref> [Mo '83] </ref>. We will define each scheduling algorithm, and determine in which situations the algorithm is optimal. We will also derive feasibility tests in order to determine if a given task set will have a valid schedule under a given scheduling algorithm. <p> Thus, the feasibility question is in co-NP and is co-NP -hard in the strong sense. Hence, it is co-NP -complete in the strong sense. 77 7 Modified Least Laxity First In covering EDF and a scheduling algorithm known as Least Laxity First (LLF) found in <ref> [Mo '83] </ref>, we noticed that both shared a common structure in determining task priorities. Both used the next deadline of a given task and the current time in computing priorities. LLF also used the remaining amount of execution for the current release of the task. <p> Thus equation (42) holds for time t, and therefore ml 2 (t) &lt; ml 1 (t). Thus, t 1 is not scheduled at any time on the interval [0; n + 1], and it therefore misses its deadline at n + 2. 2 It is interesting to note that <ref> [Mo '83] </ref> remarks that, "There are in fact an infinite number of totally on-line optimal schedulers, e.g., any combination of the earliest deadline first and the least slack algorithm may conceivably be used in a run-time scheduler to minimize process switching overheads." In essence, MLLF with a variable laxity factor extends <p> fact an infinite number of totally on-line optimal schedulers, e.g., any combination of the earliest deadline first and the least slack algorithm may conceivably be used in a run-time scheduler to minimize process switching overheads." In essence, MLLF with a variable laxity factor extends that remark since the remark in <ref> [Mo '83] </ref> is merely a restriction of the above function z (to the range f0; 1g). In fact, our result is strictly more general in the types of allowable schedules (that is to say, EDF and LLF swapping cannot produce all schedules that variable laxity factors can produce). <p> Perhaps this unification will provide new light in which to consider dynamic priority scheduling, and may lead to discerning new classes of task sets that have polynomial time feasibility tests. However, MLLF was shown to be optimal when considering discrete schedules this is also how LLF (see <ref> [Mo '83] </ref>) is considered but was not developed for schedules over continuous time. Overall, we have tried to provide clarity to some of the major scheduling algorithms in the field, and to show their relationships.
Reference: [Ru '66] <author> Rudin, Walter, </author> <title> Real and Complex Analysis, </title> <publisher> McGraw-Hill, </publisher> <year> 1996. </year>
Reference-contexts: Q n n Y x i = p n i=1 p i 2p 1 p 1 p 3 p n1 p n = Q n Q n = 2 Since the geometric mean of a set of positive real numbers is less than or equal to the arithmetic mean (see <ref> [Ru '66] </ref>, page 61, for a proof of this claim), n Y x i n 1 n X x i 1 n X x i 1 n X x i n Then by equation (31) n (2 n 1) U Thus, the minimum possible utilization for a task set that fully
Reference: [SRL '90] <author> Lui Sha, Ragunathan Rajkumar, and John P. Lehoczky, </author> <title> Priority Inheritance Protocols: An Approach to Real-Time Synchronization, </title> <journal> IEEE Transactions on Computers 39(9): </journal> <pages> 1175-1185, </pages> <year> 1990. </year>
Reference: [SSN '95] <author> John A. Stankovic, Marco Spuri, Marco Di Natale, and Giorgio C. Buttazzo, </author> <title> Implications of Classical Scheduling Results for Real-Time Systems, </title> <booktitle> Computer, </booktitle> <pages> 16-25, </pages> <year> 1995. </year> <month> 97 </month>
References-found: 15

