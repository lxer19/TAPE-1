URL: http://www.cs.washington.edu/homes/eric/linked_lists/Stoc_submitted.ps
Refering-URL: http://www.cs.washington.edu/homes/eric/linked_lists/outline.html
Root-URL: http://www.cs.washington.edu
Title: On List Update and Work Function Algorithms  
Author: Eric J. Anderson Kris Hildrum Anna R. Karlin April Rasala Michael Saks 
Abstract: The list accessing or list update problem is one of the most well-studied problems in the area of dynamic data structures. The list update problem can be described as a metrical task system, an abstract formulation of online problems. A generic algorithm for metrical task systems, known as the work function algorithm, has previously been devised, and researchers have analyzed its application to a number of important online problems. In this paper, we analyze the performance of work function algorithms on the list update problem. The difficulty is in characterizing the optimal o*ine cost, or work function values. We present a construction relating the work function value of a state to the depth of the most recently referenced element. On the basis of this construction, we prove that a large class of work function algorithms achieve constant competitive ratio for the list update problem. We also present a new formulation of the well-known "list factoring" technique in terms of a partial order on the elements of the list. This approach leads to a simple and elegant proof that a large class of algorithms including Move-To-Front is (2 1=k)-competitive. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Albers. </author> <title> Private Communication. </title>
Reference-contexts: (b; a) (b in front of a), and the distance between these 6 This partial order has apparently been considered by Albers, von Stengel and Werchner in the context of randomized list update, and was used as a basis for an optimal randomized online algorithm for lists of length 4. <ref> [1] </ref> 6 OE AE a - i b O o a b i b O o a OE b i state a b corresponds to the case ! t ((a; b)) = ! t ((b; a)), and the state a OE b corresponds to the case ! t ((a; b)) 1 <p> If at the beginning x 1 is swapped behind x 2 and then behind x 3 , then the cost of 8 is achievable.) Unfortunately, this conjecture is false (a fact apparently known to people working in the area <ref> [1] </ref>). The simplest example we have found is given in the following.
Reference: [2] <author> S. Albers. </author> <title> Improved randomized on-line algorithms for the list update problem. </title> <journal> SIAM Journal on Computing, </journal> <volume> 27: </volume> <pages> 682-693, </pages> <year> 1998. </year>
Reference-contexts: 1 Introduction 1.1 Motivation The list accessing or list update problem is one of the most well-studied problems in competitive analysis <ref> [5, 16, 7, 2, 11] </ref>. The problem consists of maintaining a set S of items in an unsorted linked list, as a data structure for implementation of a dictionary. <p> the k-server problem WFA' and WFA are precisely the same.) 3 A Different View on List Factoring A technique which has been used in the past to analyze list update algorithms is the list factoring technique, which reduces the competitive analysis of list accessing algorithms to lists of size two <ref> [7, 12, 18, 2, 4] </ref>. For example, this technique, in conjunction with phase partitioning, was used to prove that an algorithm called TimeStamp is 2-competitive [2, 4]. <p> For example, this technique, in conjunction with phase partitioning, was used to prove that an algorithm called TimeStamp is 2-competitive <ref> [2, 4] </ref>. <p> By lemma 1 and the fact that OP T (oe) kn, we can conclude that A (oe) n + 2 t 2 The TimeStamp algorithm (originally called TimeStamp (0)) due to Albers <ref> [2] </ref> is defined as follows: On a request for an item x, insert x in front of the first (from the front of the list) item y that precedes x on the list and was requested at most once since the last request for x.
Reference: [3] <author> S. Albers and M. Mitzenmacher. </author> <title> Average case analyses of list update algorihtms, with applications to data compression. </title> <journal> Algorithmica, </journal> <year> 1998. </year>
Reference: [4] <author> S. Albers, B. von Stengel and R. Werchner. </author> <title> A combined BIT and TIMESTAMP algorithm for the list update problem. </title> <journal> Information Processing Letters; 56: </journal> <volume> 135- 139, </volume> <year> 1995. </year>
Reference-contexts: the k-server problem WFA' and WFA are precisely the same.) 3 A Different View on List Factoring A technique which has been used in the past to analyze list update algorithms is the list factoring technique, which reduces the competitive analysis of list accessing algorithms to lists of size two <ref> [7, 12, 18, 2, 4] </ref>. For example, this technique, in conjunction with phase partitioning, was used to prove that an algorithm called TimeStamp is 2-competitive [2, 4]. <p> For example, this technique, in conjunction with phase partitioning, was used to prove that an algorithm called TimeStamp is 2-competitive <ref> [2, 4] </ref>.
Reference: [5] <author> S. Albers and J. Westbrook. </author> <title> Self-organizing data structures. In "Online Algorithms, The state of the art", LNCS State-of-the Art Survey. </title> <publisher> Fiat-Woeginger, Springer, </publisher> <year> 1998. </year>
Reference-contexts: 1 Introduction 1.1 Motivation The list accessing or list update problem is one of the most well-studied problems in competitive analysis <ref> [5, 16, 7, 2, 11] </ref>. The problem consists of maintaining a set S of items in an unsorted linked list, as a data structure for implementation of a dictionary. <p> The second, and perhaps more exciting reason for studying work functions as they relate to list update is the tantalizing possibility that insight gained from that study could be helpful in the study of dynamic optimality for self-adjusting binary search trees <ref> [5, 17] </ref>. It is a longstanding open question whether or not there is a strongly competitive algorithm for dynamically rearranging a binary search tree using rotations, in response to a sequence of accesses.
Reference: [6] <author> R. Bachrach and R. </author> <title> El-Yaniv Online list accessing algorihtms and their applications: Recent empirical evidence. </title> <booktitle> In Proceedings of ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1997. </year>
Reference: [7] <author> J.L. Bentley and C. McGeoch. </author> <title> Amortized analysis of self-organizing sequential search heuristics. </title> <journal> Communications of the ACM, </journal> <volume> 28(4) </volume> <pages> 404-411, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction 1.1 Motivation The list accessing or list update problem is one of the most well-studied problems in competitive analysis <ref> [5, 16, 7, 2, 11] </ref>. The problem consists of maintaining a set S of items in an unsorted linked list, as a data structure for implementation of a dictionary. <p> the k-server problem WFA' and WFA are precisely the same.) 3 A Different View on List Factoring A technique which has been used in the past to analyze list update algorithms is the list factoring technique, which reduces the competitive analysis of list accessing algorithms to lists of size two <ref> [7, 12, 18, 2, 4] </ref>. For example, this technique, in conjunction with phase partitioning, was used to prove that an algorithm called TimeStamp is 2-competitive [2, 4].
Reference: [8] <author> A. Borodin, N. Linial, and M. Saks. </author> <title> An optimal online algorithm for metrical task systems. </title> <journal> Journal of the ACM, </journal> <volume> 52 </volume> <pages> 46-52, </pages> <year> 1985. </year>
Reference-contexts: The static list update problem (where the list starts out with k elements in it, and all requests are accesses) can also be considered within the metrical task system framework introduced by Borodin, Linial and Saks <ref> [8] </ref>. 1 Metrical task systems (MTS) are an abstract model for online computation that captures a wide variety of online problems (paging, list update and the k-server problem, to name a few) as special cases. <p> two states or permutations is just the number of inversions between the permutations. 2 One of the original results about metrical task systems was that the work function algorithm (WFA) has competitive ratio 2n 1 for all MTS's, where n is the number of states in the metrical task system <ref> [8] </ref>. It was also shown that this is best possible, in the sense that there exist metrical task systems for which no online algorithm can achieve a competitive ratio lower than 2n 1. <p> We define the work function ! t (s) for any state s and index t to be the lowest cost of satisfying the first t requests of oe and ending up in state s <ref> [10, 8] </ref>. Suppose that oe t+1 , the (t + 1)st request in oe, is the task o . <p> for all states s and s 0 : (1) ! t+1 (s) ! t (s); (2) ! t+1 (s) ! t (s) + oe t+1 (s); (3) ! t (s) ! t (s 0 ) + d (s; s 0 ): 2.2 Work Function Algorithms The Work Function Algorithm (WFA), <ref> [10, 8] </ref>, defined on an arbitrary metrical task system is the following: when in state s t , given a request oe t+1 = o , service o in the state s t+1 such that s t+1 = argmin s (! t+1 (s) + d (s t ; s)) where the <p> In addition, it is easy to show that prior results which hold for WFA also hold for WFA'. For example, WFA' is 2n 1 competitive for any metrical task system with n states, matching the result of <ref> [8] </ref> for metrical task systems.
Reference: [9] <author> W. Burley and S. Irani. </author> <title> On algorithm design for metrical task systems. </title> <booktitle> In Proceedings of ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1995. </year>
Reference-contexts: Indeed, one of the most intriguing open questions in this area is the question: For what metrical task systems is the work function algorithm strongly competitive? 3 Burley and Irani have shown that the work function algorithm is not strongly competitive for all metrical task systems <ref> [9] </ref>. However, these "bad" metrical task systems seem to be rather contrived, and it is widely believed that the work function algorithm is in fact strongly competitive for large classes of natural metrical task systems.
Reference: [10] <author> M. Chrobak, L. Larmore. </author> <title> The server problem and on-line games. In On-Line Algorithms, </title> <booktitle> Proceedings of a DIMACS Workshop, Vol 7 of DIMACS Series in Discrete Mathematics and Computer Science, </booktitle> <pages> pp. 11 - 64, </pages> <year> 1991. </year>
Reference-contexts: We define the work function ! t (s) for any state s and index t to be the lowest cost of satisfying the first t requests of oe and ending up in state s <ref> [10, 8] </ref>. Suppose that oe t+1 , the (t + 1)st request in oe, is the task o . <p> for all states s and s 0 : (1) ! t+1 (s) ! t (s); (2) ! t+1 (s) ! t (s) + oe t+1 (s); (3) ! t (s) ! t (s 0 ) + d (s; s 0 ): 2.2 Work Function Algorithms The Work Function Algorithm (WFA), <ref> [10, 8] </ref>, defined on an arbitrary metrical task system is the following: when in state s t , given a request oe t+1 = o , service o in the state s t+1 such that s t+1 = argmin s (! t+1 (s) + d (s t ; s)) where the
Reference: [11] <author> R. El-Yaniv. </author> <title> There are Infinitely Many Competitive-Optimal Online List Accessing Algorithms. Discussion paper from The Center for Rationality and Interactive Decision Making. </title> <institution> Hebrew University. </institution>
Reference-contexts: 1 Introduction 1.1 Motivation The list accessing or list update problem is one of the most well-studied problems in competitive analysis <ref> [5, 16, 7, 2, 11] </ref>. The problem consists of maintaining a set S of items in an unsorted linked list, as a data structure for implementation of a dictionary. <p> P P This leads to a new, very simple proof that a collection of algorithms already known to be competitive, including Move-To-Front and TimeStamp, and many others, are all 2 1=k competitive. 8 8 Ran El-Yaniv has recently presented an different family of algorithms, all of which are 21=k competitive <ref> [11] </ref>.
Reference: [12] <author> S. Irani. </author> <title> Two results on the list update problem. </title> <journal> Information Processing Letters, </journal> <volume> 38(6) </volume> <pages> 301-306, </pages> <year> 1991. </year>
Reference-contexts: Of these, perhaps the most well-known is the Move-To-Front algorithm: after accessing an item, move it to the front of the list, without changing the relative order of the other items. Move-To-Front is known to be 2 2 k+1 competitive, and this is best possible <ref> [16, 12] </ref>. Other well-known algorithms such as Transpose (after accessing an item, transpose it with the immediately preceding item) and Frequency-Count (maintain the elements in nonincreasing order of the frequency with which they have been requested) are not competitive with any constant competitive ratio. <p> the k-server problem WFA' and WFA are precisely the same.) 3 A Different View on List Factoring A technique which has been used in the past to analyze list update algorithms is the list factoring technique, which reduces the competitive analysis of list accessing algorithms to lists of size two <ref> [7, 12, 18, 2, 4] </ref>. For example, this technique, in conjunction with phase partitioning, was used to prove that an algorithm called TimeStamp is 2-competitive [2, 4].
Reference: [13] <author> E. Koutsoupias and C. Papadimitriou. </author> <title> On the k-server conjecture. </title> <journal> Journal of the ACM, </journal> <volume> 42(5): </volume> <pages> 971-983, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: For this problem, the metrical task system has n = k states, but a recent celebrated result of Koutsoupias and Papadimitriou shows that in fact the very same work function algorithm is 2k 1 competitive for this problem <ref> [13] </ref>, nearly 1 As with much of the work on list accessing, we focus in this paper on the static case, where there are no insertions and deletions. <p> For example, WFA' is 2n 1 competitive for any metrical task system with n states, matching the result of [8] for metrical task systems. Also, WFA' is 2k 1 competitive for the k-server problem, matching the result of <ref> [13] </ref> for the k-server problem. (This is trivial, since for the k-server problem WFA' and WFA are precisely the same.) 3 A Different View on List Factoring A technique which has been used in the past to analyze list update algorithms is the list factoring technique, which reduces the competitive analysis
Reference: [14] <author> M. Manasse, L. McGeoch and D.D. Sleator. </author> <title> Competitive algorithms for server problems. </title> <journal> Journal of Algorithms, </journal> <volume> 11 </volume> <pages> 208-230, </pages> <year> 1990. </year>
Reference-contexts: We continue to use the term "paid exchanges" to describe specifically those exchanges not involving the next-referenced element. 3 matching the known lower bound of k on the competitive ratio <ref> [14] </ref>. Unfortunately, our community understands very little at this point about how to design competitive algorithms that achieve close to the best possible competitive ratio for broad classes of metrical task systems.
Reference: [15] <author> N. Reingold and J. Westbrook. </author> <title> Optimum off-line algorihtms for the list update problem. </title> <type> Technical Report YALEU/DCS/TR-805, </type> <institution> Yale University, </institution> <year> 1990. </year>
Reference-contexts: The fastest optimal off-line algorithm currently known runs in time O (2 k k!m), where k is the size of the list and m is the length of the request sequence <ref> [15] </ref>. 3 We say an algorithm is strongly competitive if its competitive ratio is within a constant factor of the best possible competitive ratio achievable. 4 We hasten to add that we have made no tangible progress in this direction. 5 The proof does not achieve the best possible competitive ratio
Reference: [16] <author> D.D. Sleator and R.E. Tarjan. </author> <title> Amortized efficiency of list update and paging rules. </title> <journal> Communications of the ACM, </journal> <volume> 28 </volume> <pages> 202-208, </pages> <year> 1985. </year> <month> 13 </month>
Reference-contexts: 1 Introduction 1.1 Motivation The list accessing or list update problem is one of the most well-studied problems in competitive analysis <ref> [5, 16, 7, 2, 11] </ref>. The problem consists of maintaining a set S of items in an unsorted linked list, as a data structure for implementation of a dictionary. <p> Of these, perhaps the most well-known is the Move-To-Front algorithm: after accessing an item, move it to the front of the list, without changing the relative order of the other items. Move-To-Front is known to be 2 2 k+1 competitive, and this is best possible <ref> [16, 12] </ref>. Other well-known algorithms such as Transpose (after accessing an item, transpose it with the immediately preceding item) and Frequency-Count (maintain the elements in nonincreasing order of the frequency with which they have been requested) are not competitive with any constant competitive ratio.
Reference: [17] <author> D.D. Sleator and R.E. Tarjan. </author> <title> Self-adjusting binary search trees. </title> <journal> Journal of the ACM, </journal> <volume> 32: </volume> <pages> 652-686, </pages> <year> 1985. </year>
Reference-contexts: The second, and perhaps more exciting reason for studying work functions as they relate to list update is the tantalizing possibility that insight gained from that study could be helpful in the study of dynamic optimality for self-adjusting binary search trees <ref> [5, 17] </ref>. It is a longstanding open question whether or not there is a strongly competitive algorithm for dynamically rearranging a binary search tree using rotations, in response to a sequence of accesses. <p> The similarity between Move-To-Front as an algorithm for dynamically rearranging linked lists, and the splay tree algorithm of Sleator and Tarjan <ref> [17] </ref> for dynamically rearranging binary search trees, long conjectured to be strongly competitive, is obvious.
Reference: [18] <author> B. Teia. </author> <title> A lower bound for randomized list update algorithms. </title> <journal> Information Processing Letters, </journal> <volume> 47 </volume> <pages> 5-9, </pages> <year> 1993. </year>
Reference-contexts: the k-server problem WFA' and WFA are precisely the same.) 3 A Different View on List Factoring A technique which has been used in the past to analyze list update algorithms is the list factoring technique, which reduces the competitive analysis of list accessing algorithms to lists of size two <ref> [7, 12, 18, 2, 4] </ref>. For example, this technique, in conjunction with phase partitioning, was used to prove that an algorithm called TimeStamp is 2-competitive [2, 4].
References-found: 18

