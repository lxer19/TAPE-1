URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/94-21.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Email: avnaik@cs.buffalo.edu  regan@cs.buffalo.edu  sivak-d@cs.buffalo.edu  
Title: Quasilinear Time Complexity Theory  
Author: Ashish V. Naik Kenneth W. Regan D. Sivakumar 
Note: 1 Supported in part by NSF grant CCR-9002292. 2 Supported in part by NSF grant CCR-9011248.  
Address: Buffalo  Buffalo  Buffalo  
Affiliation: SUNY  SUNY  SUNY  
Abstract-found: 0
Intro-found: 1
Reference: [ABG90] <author> A. Amir, R. Beigel, and W. Gasarch. </author> <title> Some connections between bounded query classes and nonuniform complexity. </title> <booktitle> In Proc. 5th Annual IEEE Conference on Structure in Complexity Theory, </booktitle> <pages> pages 232-243, </pages> <year> 1990. </year>
Reference-contexts: Section 5 shows how our notion of counting the number of query bits used by oracle machines relates to previous work on counting queries <ref> [Bei87b, AG88, BGH89, ABG90, Bei91, BGGO93, HN93, BKS93] </ref> and on "helping" [Sch85, Ko87, Bal90]. We observe that the known equivalence between having search reduce to decision and one-sided helping in polynomial time carries over to any reasonable time bound t (n). <p> Since A ql m SAT , M can be replaced by a robust OTM M 0 that makes SAT 1-help itself in quasilinear time. The conclusion now follows via Theorem 5.2. Next we consider the subject of bounded-query classes studied in <ref> [Bei87b, Bei87a, AG88, BGH89, ABG90, Bei91, BGGO93] </ref>. <p> The conclusion now follows via Theorem 5.2. Next we consider the subject of bounded-query classes studied in [Bei87b, Bei87a, AG88, BGH89, ABG90, Bei91, BGGO93]. In particular, a language L is defined to be P-superterse <ref> [Bei87a, ABG90] </ref> if for all k and all oracles B, the function mapping a k-tuple of strings x 1 ; : : : ; x k to the k-tuple of answers L (x 1 ); : : : ; L (x k ) cannot be computed in polynomial time while making
Reference: [ABN + 92] <author> N. Alon, J. Bruck, J. Naor, M. Naor, and R. Roth. </author> <title> Construction of asymptotically good low-rate error-correcting codes through pseudo-random graphs. </title> <journal> IEEE Trans. Info. Thy., </journal> <volume> 38(2) </volume> <pages> 509-512, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Naor and Naor also mention error-correcting codes for similar purposes in-passing, ascribing the idea to Bruck with a reference to <ref> [ABN + 92] </ref>. However, using the codes in [ABN + 92] appears to require computing exponentiation in finite fields GF (2 m ) where the size m of field elements is polynomial in n. <p> Naor and Naor also mention error-correcting codes for similar purposes in-passing, ascribing the idea to Bruck with a reference to <ref> [ABN + 92] </ref>. However, using the codes in [ABN + 92] appears to require computing exponentiation in finite fields GF (2 m ) where the size m of field elements is polynomial in n. <p> The main point of our construction is that by scaling down the size of the field, and using multi-variable polynomials, one can achieve quasilinear runtime. Our code is similar to those used in recent improvements of "holographic proof systems" [BFLS91, Sud92], and is only inferior to that of <ref> [ABN + 92] </ref> in using 2q o (q) rather than q + O (1) random bits. 3.1 Error-correcting codes Let be an alphabet of size 2 l . <p> Families of codes are known for which R (as well as ffi) stays bounded below by a constant; such (families of) codes are called good . Good codes require only q + O (1) random bits in the above construction. The codes in <ref> [ABN + 92, JLJH92, She93] </ref> are good, but appear not to give quasilinear runtime here. 10 4 Search Versus Decision in Quasilinear Time The classical method of computing partial, multivalued functions using sets as oracles is the prefix-set method (cf. [Sel88] ).
Reference: [AG88] <author> A. Amir and W. Gasarch. </author> <title> Polynomial terse sets. </title> <journal> Info. Control, </journal> <volume> 77 </volume> <pages> 37-56, </pages> <year> 1988. </year> <month> 20 </month>
Reference-contexts: Section 5 shows how our notion of counting the number of query bits used by oracle machines relates to previous work on counting queries <ref> [Bei87b, AG88, BGH89, ABG90, Bei91, BGGO93, HN93, BKS93] </ref> and on "helping" [Sch85, Ko87, Bal90]. We observe that the known equivalence between having search reduce to decision and one-sided helping in polynomial time carries over to any reasonable time bound t (n). <p> Since A ql m SAT , M can be replaced by a robust OTM M 0 that makes SAT 1-help itself in quasilinear time. The conclusion now follows via Theorem 5.2. Next we consider the subject of bounded-query classes studied in <ref> [Bei87b, Bei87a, AG88, BGH89, ABG90, Bei91, BGGO93] </ref>.
Reference: [AHU74] <author> A. Aho, J. Hopcroft, and J. Ullman. </author> <title> The Design and Analysis of Computer Algo--rithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1974. </year>
Reference-contexts: For step 10, we first note that to multiply two polynomials of degree k 1 over GF (2) and reduce them modulo ff in the field GF (2 k ) takes time t 1 = O (k log k loglog k) on standard Turing machine models (see <ref> [AHU74] </ref> and [Rab80]). The time to compute a i in GF (2 k ) where i q is t 2 = O (log q 2k log k loglog k) via repeated squaring, which is O (log (n) log + n).
Reference: [Bal90] <author> J. Balcazar. </author> <title> Self-reducibility structures and solutions of NP problems. </title> <journal> Rivesta Matematica, </journal> <volume> 4(4) </volume> <pages> 175-184, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Section 5 shows how our notion of counting the number of query bits used by oracle machines relates to previous work on counting queries [Bei87b, AG88, BGH89, ABG90, Bei91, BGGO93, HN93, BKS93] and on "helping" <ref> [Sch85, Ko87, Bal90] </ref>. We observe that the known equivalence between having search reduce to decision and one-sided helping in polynomial time carries over to any reasonable time bound t (n). This yields other forms of our main results in Section 4. <p> We write O (t (n)) rather than just t (n) because linear speed-up does not hold for oracle machines. For polynomial time bounds, both Definition 4.1 and the notion of self-1-helping entail A 2 NP, and we restrict attention to NP below. Balcazar <ref> [Bal90] </ref> proved that a language A is a self-1-helper (in polynomial time) if and only if search reduces to decision for A (in polynomial time). We observe first that Balcazar's proof carries over to any reasonable time bound t (n). Proposition 5.1 Let A 2 NP.
Reference: [Bar92] <author> D. </author> <title> Mix Barrington. Quasipolynomial size circuit classes. </title> <booktitle> In Proc. 7th Annual IEEE Conference on Structure in Complexity Theory, </booktitle> <pages> pages 86-93, </pages> <year> 1992. </year>
Reference-contexts: Let polylog n abbreviate (log n) O (1) as before. Then DTIME [2 polylogn ] is often referred to as quasi-polynomial time (cf. <ref> [Bar92] </ref>). Theorem 4.2 Let L 2 NP. If search reduces to decision for L in quasilinear time, then L 2 DTIME [2 polylogn ]. Proof.
Reference: [BBFG91] <author> R. Beigel, M. Bellare, J. Feigenbaum, and S. Goldwasser. </author> <title> Languages that are easier than their proofs. </title> <booktitle> In Proc. 32nd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 19-28, </pages> <year> 1991. </year>
Reference-contexts: The following is a straightforward extension of the standard notion of search reducing to decision in polynomial time <ref> [BD76, BBFG91, NOS93] </ref> to other time bounds t (n). Definition 4.1. Let L 2 NP and a time bound t (n) be given. <p> However, we now show that the converse is unlikely to be true. Let EE stand for DTIME [2 2 O (n) ], and NEE for its nondeterministic counterpart. The classes EE and NEE were considered by Beigel, Bellare, Feigenbaum, and Goldwasser <ref> [BBFG91] </ref>, and there are reasons for believing it unlikely that NEE = EE. Theorem 4.6 Suppose NEE 6= EE. <p> Theorem 4.6 Suppose NEE 6= EE. Then for all k &gt; 0 there is a tally language in NP whose power index is at most 1=k, but for which search does not reduce to decision in polynomial time. 13 Proof. Let T be the tally set constructed in <ref> [BBFG91] </ref> such that search does not reduce to decision for T in polynomial time, unless NEE = EE. Suppose p is a polynomial such that for all n, all witnesses of the string 0 n are of length p (n).
Reference: [BD76] <author> A. Borodin and A. Demers. </author> <title> Some comments on functional self-reducibility and the NP hierarchy. </title> <type> Technical Report TR 76-284, </type> <institution> Cornell Univ. Comp. Sci. Dept., </institution> <year> 1976. </year>
Reference-contexts: The following is a straightforward extension of the standard notion of search reducing to decision in polynomial time <ref> [BD76, BBFG91, NOS93] </ref> to other time bounds t (n). Definition 4.1. Let L 2 NP and a time bound t (n) be given.
Reference: [BDG88] <author> J. Balcazar, J. Daz, and J. Gabarro. </author> <title> Structural Complexity Theory. </title> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: We use the same terms in the context of NQL and DQL. We note the following provision about oracle Turing machines M made standard in both [WW86] and <ref> [BDG88] </ref> (see also [LL76, Wra77, Wra78]): Whenever M enters its query state q ? with the query string z on its query tape, z is erased when the oracle gives its answer.
Reference: [Bei87a] <author> R. Beigel. </author> <title> Query-limited reducibilities. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1987. </year>
Reference-contexts: Since A ql m SAT , M can be replaced by a robust OTM M 0 that makes SAT 1-help itself in quasilinear time. The conclusion now follows via Theorem 5.2. Next we consider the subject of bounded-query classes studied in <ref> [Bei87b, Bei87a, AG88, BGH89, ABG90, Bei91, BGGO93] </ref>. <p> The conclusion now follows via Theorem 5.2. Next we consider the subject of bounded-query classes studied in [Bei87b, Bei87a, AG88, BGH89, ABG90, Bei91, BGGO93]. In particular, a language L is defined to be P-superterse <ref> [Bei87a, ABG90] </ref> if for all k and all oracles B, the function mapping a k-tuple of strings x 1 ; : : : ; x k to the k-tuple of answers L (x 1 ); : : : ; L (x k ) cannot be computed in polynomial time while making <p> Our hypothesis is the last on the following list: (a) SAT has power index 1 [SH86]. (b) SAT is P-superterse <ref> [Bei87a] </ref>. (c) The search function for SAT does not belong to PF NP [o (n)] [Kre88]. (d) NP does not have p-measure zero in exponential time [Lut93] (e) The search function for SAT requires (n 2 ) query bits to compute in polynomial time, with any oracle set (or at least
Reference: [Bei87b] <author> R. Beigel. </author> <title> A structural theorem that depends quantitatively on the complexity of SAT. </title> <booktitle> In Proc. 2nd Annual IEEE Conference on Structure in Complexity Theory, </booktitle> <pages> pages 28-32, </pages> <year> 1987. </year>
Reference-contexts: Section 5 shows how our notion of counting the number of query bits used by oracle machines relates to previous work on counting queries <ref> [Bei87b, AG88, BGH89, ABG90, Bei91, BGGO93, HN93, BKS93] </ref> and on "helping" [Sch85, Ko87, Bal90]. We observe that the known equivalence between having search reduce to decision and one-sided helping in polynomial time carries over to any reasonable time bound t (n). <p> Since A ql m SAT , M can be replaced by a robust OTM M 0 that makes SAT 1-help itself in quasilinear time. The conclusion now follows via Theorem 5.2. Next we consider the subject of bounded-query classes studied in <ref> [Bei87b, Bei87a, AG88, BGH89, ABG90, Bei91, BGGO93] </ref>.
Reference: [Bei91] <author> R. Beigel. </author> <title> Bounded queries to SAT and the Boolean hierarchy. </title> <journal> Theor. Comp. Sci., </journal> <volume> 83 </volume> <pages> 199-223, </pages> <year> 1991. </year>
Reference-contexts: Section 5 shows how our notion of counting the number of query bits used by oracle machines relates to previous work on counting queries <ref> [Bei87b, AG88, BGH89, ABG90, Bei91, BGGO93, HN93, BKS93] </ref> and on "helping" [Sch85, Ko87, Bal90]. We observe that the known equivalence between having search reduce to decision and one-sided helping in polynomial time carries over to any reasonable time bound t (n). <p> Since A ql m SAT , M can be replaced by a robust OTM M 0 that makes SAT 1-help itself in quasilinear time. The conclusion now follows via Theorem 5.2. Next we consider the subject of bounded-query classes studied in <ref> [Bei87b, Bei87a, AG88, BGH89, ABG90, Bei91, BGGO93] </ref>.
Reference: [BFLS91] <author> L. Babai, L. Fortnow, L. Levin, and M. Szegedy. </author> <title> Checking computations in polylog-arithmic time. </title> <booktitle> In Proc. 23rd Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 21-31, </pages> <year> 1991. </year>
Reference-contexts: The main point of our construction is that by scaling down the size of the field, and using multi-variable polynomials, one can achieve quasilinear runtime. Our code is similar to those used in recent improvements of "holographic proof systems" <ref> [BFLS91, Sud92] </ref>, and is only inferior to that of [ABN + 92] in using 2q o (q) rather than q + O (1) random bits. 3.1 Error-correcting codes Let be an alphabet of size 2 l . <p> Since d 2 k 1 these monomials are all distinct, and they are all linearly independent, so the dimension is K = ( m+d d ). The well-known property on which these codes are based (cf. <ref> [BFLS91, Sud92] </ref>) is that for every two distinct polynomials f and g over F of total degree at most d, and for every I F , jf ~a 2 I m : f (~a ) = g (~a ) gj djIj m1 : (1) With I = F , it follows
Reference: [BG93] <author> J. Buss and J. Goldsmith. </author> <title> Nondeterminism within P. </title> <journal> SIAM J. Comput., </journal> <volume> 22 </volume> <pages> 560-572, </pages> <year> 1993. </year>
Reference-contexts: DQL question takes on much the same shape as NP vs. P. Related classes within P are studied by Buss and Goldsmith <ref> [BG93] </ref>. One theoretical difficulty with the concept of quasilinear time is that it appears not to share the degree of independence on particular machine models that makes polynomial time such a robust concept. <p> Parts (b) and (c) follow from (a) by standard means. The case k = 1 of (d) is the main theorem of Schnorr [Sch78] that SAT is complete for NQL under ql m . It is worth sketching Schnorr's construction here (see also <ref> [BG93] </ref>) for reference below: Take a time-t (n) DTM M that decides a witness predicate R (x; y) for the given language A 2 NQL.
Reference: [BGGO93] <author> R. Beigel, W. Gasarch, J. Gill, and C. Owings. Terse, superterse, </author> <title> and verbose sets. </title> <journal> Info. Control, </journal> <volume> 103 </volume> <pages> 68-85, </pages> <year> 1993. </year>
Reference-contexts: Section 5 shows how our notion of counting the number of query bits used by oracle machines relates to previous work on counting queries <ref> [Bei87b, AG88, BGH89, ABG90, Bei91, BGGO93, HN93, BKS93] </ref> and on "helping" [Sch85, Ko87, Bal90]. We observe that the known equivalence between having search reduce to decision and one-sided helping in polynomial time carries over to any reasonable time bound t (n). <p> Since A ql m SAT , M can be replaced by a robust OTM M 0 that makes SAT 1-help itself in quasilinear time. The conclusion now follows via Theorem 5.2. Next we consider the subject of bounded-query classes studied in <ref> [Bei87b, Bei87a, AG88, BGH89, ABG90, Bei91, BGGO93] </ref>.
Reference: [BGH89] <author> R. Beigel, W. Gasarch, and L. Hay. </author> <title> Bounded query classes and the difference hierarchy. </title> <journal> Archive for Mathematical Logic, </journal> <volume> 29 </volume> <pages> 69-84, </pages> <year> 1989. </year>
Reference-contexts: Section 5 shows how our notion of counting the number of query bits used by oracle machines relates to previous work on counting queries <ref> [Bei87b, AG88, BGH89, ABG90, Bei91, BGGO93, HN93, BKS93] </ref> and on "helping" [Sch85, Ko87, Bal90]. We observe that the known equivalence between having search reduce to decision and one-sided helping in polynomial time carries over to any reasonable time bound t (n). <p> Since A ql m SAT , M can be replaced by a robust OTM M 0 that makes SAT 1-help itself in quasilinear time. The conclusion now follows via Theorem 5.2. Next we consider the subject of bounded-query classes studied in <ref> [Bei87b, Bei87a, AG88, BGH89, ABG90, Bei91, BGGO93] </ref>.
Reference: [BKS93] <author> R. Beigel, M. Kummer, and F. Stephan. </author> <title> Approximable sets. </title> <type> manuscript, </type> <year> 1993. </year>
Reference-contexts: Section 5 shows how our notion of counting the number of query bits used by oracle machines relates to previous work on counting queries <ref> [Bei87b, AG88, BGH89, ABG90, Bei91, BGGO93, HN93, BKS93] </ref> and on "helping" [Sch85, Ko87, Bal90]. We observe that the known equivalence between having search reduce to decision and one-sided helping in polynomial time carries over to any reasonable time bound t (n). <p> We construct an oracle A relative to which search reduces to decision for SAT in quasilinear time (in fact, O (n log 2 n) time), but still NP A 6= P A , so that SAT relative to A is still "P A -superterse" (see <ref> [BKS93] </ref>). This also gives evidence that our quasipolynomial simulation of NP in Theorem 4.2 is close to optimal. A concluding Section 6 summarizes the significance of this work and suggests some problems for further research. 2 Notation and Basic Results Let := f 0; 1 g. <p> Beigel, Kummer, and Stephan <ref> [BKS93] </ref> proved that SAT is P-superterse iff P 6= NP.
Reference: [CR73] <author> S. Cook and R. Reckhow. </author> <title> Time bounded random access machines. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 7 </volume> <pages> 354-375, </pages> <year> 1973. </year> <month> 21 </month>
Reference-contexts: Gurevich and Shelah [GS89] showed that a wide variety of models related to the RAM under log-cost criterion <ref> [CR73] </ref> accept the same class of languages in quasilinear time|we call this class DNLT. They also showed that nondeterministic qlin time for these machines, namely NNLT, equals NQL.
Reference: [CRS93] <author> S. Chari, P. Rohatgi, and A. Srinivasan. </author> <title> Randomness-optimal unique element iso-lation, with applications to perfect matching and related problems. </title> <booktitle> In Proc. 25th Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 458-467, </pages> <year> 1993. </year>
Reference-contexts: Section 3 shows that the randomized reduction from NP to parity given by Valiant and Vazirani [VV86] and used by Toda [Tod91], which was previously proved by constructions that run in quadratic time (see <ref> [VV86, Tod91, CRS93, Gup93] </ref>), can be made to run in quasilinear time. Our construction also markedly improves both the number of random bits needed and the success probability, and uses error-correcting codes in an interesting manner first noted in [NN90]. <p> The construction of <ref> [CRS93] </ref> achieves the same effect, still with quadratic runtime when q (n) = n. Gupta [Gup93] gives a randomized reduction to parity which achieves constant success probability 3/16 with only -(n) = q (n) nondeterministic moves, but still using q 2 -many random bits and quadratic time.
Reference: [CW79] <author> J. Carter and M. Wegman. </author> <title> Universal classes of hash functions. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 18 </volume> <pages> 143-154, </pages> <year> 1979. </year>
Reference-contexts: It was well known that by using small families H = f H k g of universal 2 hash functions <ref> [CW79] </ref> h k : f 0; 1 g q ! f 0; 1 g k (1 k q + 1) cuts the number r (n) of random bits used to 2q (n). The construction of [CRS93] achieves the same effect, still with quadratic runtime when q (n) = n.
Reference: [For66] <author> G. Forney. </author> <title> Concatenated Codes. </title> <publisher> MIT Press, </publisher> <year> 1966. </year>
Reference-contexts: But then we can only assert that the density of R 0 is at least =k, because two distinct elements a 1 ; a 2 2 GF (2 k ) might differ in only one out of k places as binary strings. The key idea, called concatenation of codes <ref> [For66] </ref>, is to apply a second level of coding to these elements. In this case we take the so-called inner code to be the Hadamard code H k .
Reference: [GS89] <author> Y. Gurevich and S. Shelah. </author> <title> Nearly-linear time. </title> <booktitle> In Proceedings, Logic at Botik '89, volume 363 of Lect. Notes in Comp. Sci., </booktitle> <pages> pages 108-118. </pages> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: P. Related classes within P are studied by Buss and Goldsmith [BG93]. One theoretical difficulty with the concept of quasilinear time is that it appears not to share the degree of independence on particular machine models that makes polynomial time such a robust concept. Gurevich and Shelah <ref> [GS89] </ref> showed that a wide variety of models related to the RAM under log-cost criterion [CR73] accept the same class of languages in quasilinear time|we call this class DNLT. They also showed that nondeterministic qlin time for these machines, namely NNLT, equals NQL. <p> The quasilinear time hierarchy is defined by: P ql Q ql ql and for k 1, k = NQL [ k1 ]; k = co k ; ql P ql Also QLH := [ 1 k=0 k , and QLSPACE := DSPACE [qlin ]. By the results of <ref> [GS89] </ref>, all these classes from NQL upward are the same for Turing machines and log-cost RAMs. Next we observe the following concavity property of quasilinear functions. Part (a) is an instance of Jensen's inequality.
Reference: [Gup93] <author> S. Gupta. </author> <title> On isolating an odd number of elements and its applications to complexity theory. </title> <type> Technical Report OSU-CISRC-6/93-TR24, </type> <institution> Dept. of Comp. Sci., Ohio State University, </institution> <year> 1993. </year>
Reference-contexts: Section 3 shows that the randomized reduction from NP to parity given by Valiant and Vazirani [VV86] and used by Toda [Tod91], which was previously proved by constructions that run in quadratic time (see <ref> [VV86, Tod91, CRS93, Gup93] </ref>), can be made to run in quasilinear time. Our construction also markedly improves both the number of random bits needed and the success probability, and uses error-correcting codes in an interesting manner first noted in [NN90]. <p> The construction of [CRS93] achieves the same effect, still with quadratic runtime when q (n) = n. Gupta <ref> [Gup93] </ref> gives a randomized reduction to parity which achieves constant success probability 3/16 with only -(n) = q (n) nondeterministic moves, but still using q 2 -many random bits and quadratic time.
Reference: [HN93] <author> A. Hoene and A. Nickelsen. </author> <title> Counting, selecting, and sorting by query-bounded machines. </title> <booktitle> In Proc. 10th Annual Symposium on Theoretical Aspects of Computer Science, volume 665 of Lect. Notes in Comp. Sci., </booktitle> <pages> pages 196-205. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Section 5 shows how our notion of counting the number of query bits used by oracle machines relates to previous work on counting queries <ref> [Bei87b, AG88, BGH89, ABG90, Bei91, BGGO93, HN93, BKS93] </ref> and on "helping" [Sch85, Ko87, Bal90]. We observe that the known equivalence between having search reduce to decision and one-sided helping in polynomial time carries over to any reasonable time bound t (n).
Reference: [HS90] <author> H. Hunt III and R. Stearns. </author> <title> The complexity of very simple Boolean formulas, with applications. </title> <journal> SIAM J. Comput., </journal> <volume> 19 </volume> <pages> 44-70, </pages> <year> 1990. </year>
Reference: [HU79] <author> J. Hopcroft and J. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: Part (e) follows because the language QBF = [ k B k of quantified Boolean formulas belongs to quasilinear (in fact, linear) space. Interestingly enough, we do not know whether QBF is complete for quasilinear space under quasilinear-time reductions. The standard reduction in <ref> [HU79] </ref>, when applied to a given set A in DSPACE [O (n)], has a quadratic blowup in size. This seems related to the issue of whether Savitch's simulation of nondeterministic space s (n) = (log n) by deterministic space O (s (n) 2 ) must have quadratic blowup.
Reference: [HW89] <author> S. Homer and J. Wang. </author> <title> Absolute results concerning one-way functions and their applications. </title> <journal> Math. Sys. Thy., </journal> <volume> 22 </volume> <pages> 21-35, </pages> <year> 1989. </year>
Reference-contexts: We believe there should be deeper connections. Another important question concerns the existence of "QL one-way" functions. Do there exist length-preserving 1-1 functions f which are computable in qlin time but not invertible in qlin time? Homer and Wang <ref> [HW89] </ref> construct, for any k 1, functions computable in quadratic time which are not invertible in time O (n k ), but their methods seem not to apply for qlin time or length-preserving functions.
Reference: [JL93] <author> D. Juedes and J. Lutz. </author> <title> The complexity and distribution of hard problems. </title> <booktitle> In Proc. 34th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 177-185, </pages> <year> 1993. </year> <note> To appear in SIAM J. Comput. </note>
Reference-contexts: The closest impact of (e) may be in relation to (d). By results of Juedes and Lutz <ref> [JL93] </ref>, (d) implies that there exists * &gt; 0 such that SAT does not have power index *, hence that search does not reduce to decision for SAT in time O (n 1+* ). We believe there should be deeper connections.
Reference: [JLJH92] <author> J. Justesen, K. Larsen, H.E. Jensen, and T. Hoholdt. </author> <title> Fast decoding of codes from algebraic plane curves. </title> <journal> IEEE Trans. Info. Thy., </journal> <volume> 38(1) </volume> <pages> 111-119, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Families of codes are known for which R (as well as ffi) stays bounded below by a constant; such (families of) codes are called good . Good codes require only q + O (1) random bits in the above construction. The codes in <ref> [ABN + 92, JLJH92, She93] </ref> are good, but appear not to give quasilinear runtime here. 10 4 Search Versus Decision in Quasilinear Time The classical method of computing partial, multivalued functions using sets as oracles is the prefix-set method (cf. [Sel88] ).
Reference: [JY90] <author> D. Joseph and P. Young. </author> <title> Self-reducibility: the effects of internal structure on computational complexity. </title> <editor> In A. Selman, editor, </editor> <booktitle> Complexity Theory Retrospective, </booktitle> <pages> pages 82-107. </pages> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: In contrast, we show that there exist functions that cannot be computed in quasilinear time using any set as an oracle whatsoever. Many natural problems in NP have associated search functions that reduce to the decision problems in polynomial time|in most cases, quadratic time (cf. <ref> [Sel88, JY90] </ref>). Theorem 4.2 shows that for 1 SAT , search does not reduce to decision in quasilinear time, unless all of NP is contained in quasi-polynomial time, viz. DTIME [2 polylog n ].
Reference: [Ko82] <author> K. Ko. </author> <title> Some observations on the probabilistic algorithms and NP-hard problems. </title> <journal> Inf. Proc. Lett., </journal> <volume> 14 </volume> <pages> 39-43, </pages> <year> 1982. </year>
Reference-contexts: The result of [PZ83] that P P = P also carries over because of the quasilinear bound on the total length of all queries in an oracle computation: QL QL = QL. However, it is unclear whether the theorem BPP BPP = BPP <ref> [Ko82] </ref> carries over, because the amplification of success probability to 1 2 polylog obtainable for BQL seems insufficient.
Reference: [Ko87] <author> K. Ko. </author> <title> On helping by robust oracle machines. </title> <journal> Theor. Comp. Sci., </journal> <volume> 52 </volume> <pages> 15-36, </pages> <year> 1987. </year> <month> 22 </month>
Reference-contexts: Section 5 shows how our notion of counting the number of query bits used by oracle machines relates to previous work on counting queries [Bei87b, AG88, BGH89, ABG90, Bei91, BGGO93, HN93, BKS93] and on "helping" <ref> [Sch85, Ko87, Bal90] </ref>. We observe that the known equivalence between having search reduce to decision and one-sided helping in polynomial time carries over to any reasonable time bound t (n). This yields other forms of our main results in Section 4. <p> The desire to find a property of decision problems alone that facilitates search led to several notions of helping proposed by Schoning [Sch85] and Ko <ref> [Ko87] </ref>. We extend their definitions from polynomial time to arbitrary time bounds t (n) under our oracle convention. An oracle TM M is robust if for every oracle B, M with oracle B halts for all inputs, and L (M B ) = L (M ; ). <p> Ko proved that for any nontrivial complexity class C, NP = P 1-help (C) <ref> [Ko87] </ref>. In the quasilinear case, however, we observe that only one direction of Ko's result is likely to carry over. Theorem 5.3 (a) For all complexity classes C, DQL 1-help (C) NQL. (b) If NQL DQL 1-help (NQL) then NP DTIME [2 polylogn ].
Reference: [Kre88] <author> M. Krentel. </author> <title> The complexity of optimization problems. </title> <journal> J. Comp. Sys. Sci., </journal> <volume> 36:490--509, </volume> <year> 1988. </year>
Reference-contexts: Our hypothesis is the last on the following list: (a) SAT has power index 1 [SH86]. (b) SAT is P-superterse [Bei87a]. (c) The search function for SAT does not belong to PF NP [o (n)] <ref> [Kre88] </ref>. (d) NP does not have p-measure zero in exponential time [Lut93] (e) The search function for SAT requires (n 2 ) query bits to compute in polynomial time, with any oracle set (or at least any oracle set in NQL). 19 It would be interesting to seek closer relationships among
Reference: [LL76] <author> R. Ladner and N. Lynch. </author> <title> Relativization of questions about log-space computability. </title> <journal> Math. Sys. Thy., </journal> <volume> 10 </volume> <pages> 19-32, </pages> <year> 1976. </year>
Reference-contexts: We use the same terms in the context of NQL and DQL. We note the following provision about oracle Turing machines M made standard in both [WW86] and [BDG88] (see also <ref> [LL76, Wra77, Wra78] </ref>): Whenever M enters its query state q ? with the query string z on its query tape, z is erased when the oracle gives its answer.
Reference: [Lut93] <author> J. Lutz. </author> <title> The quantitative structure of exponential time. </title> <booktitle> In Proc. 8th Annual IEEE Conference on Structure in Complexity Theory, </booktitle> <pages> pages 158-175, </pages> <year> 1993. </year>
Reference-contexts: Our hypothesis is the last on the following list: (a) SAT has power index 1 [SH86]. (b) SAT is P-superterse [Bei87a]. (c) The search function for SAT does not belong to PF NP [o (n)] [Kre88]. (d) NP does not have p-measure zero in exponential time <ref> [Lut93] </ref> (e) The search function for SAT requires (n 2 ) query bits to compute in polynomial time, with any oracle set (or at least any oracle set in NQL). 19 It would be interesting to seek closer relationships among these hypotheses.
Reference: [LV90] <author> M. Li and P. Vitanyi. </author> <title> Applications of Kolmogorov complexity in the theory of computation. </title> <editor> In A. Selman, editor, </editor> <booktitle> Complexity Theory Retrospective, </booktitle> <pages> pages 147-203. </pages> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Then the following is a description of f on f 0; 1 g n : * The finite control of M, plus finite descriptions of the function g (n) and "this discussion" (see <ref> [LV90] </ref>).
Reference: [MS77] <author> F. MacWilliams and N. Sloane. </author> <title> The Theory of Error-Correcting Codes. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1977. </year>
Reference-contexts: In one level of coding over GF (2), approaching 1/2 from below is best possible, because by well-known results concerning the Plotkin bound in coding theory (see <ref> [MS77] </ref>), any binary code of density 1=2 or more has too few elements to support the above application.
Reference: [NN90] <author> J. Naor and M. Naor. </author> <title> Small-bias probability spaces. </title> <booktitle> In Proc. 22nd Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 213-223, </pages> <year> 1990. </year>
Reference-contexts: Our construction also markedly improves both the number of random bits needed and the success probability, and uses error-correcting codes in an interesting manner first noted in <ref> [NN90] </ref>. Section 4 studies what may be the major difference between polynomial and quasi-linear time: the equivalence between functions and sets seems no longer to hold. It has long been known that every function can be computed in polynomial time using some set as an oracle. <p> The only previous construction which ours does not improve by an order of magnitude in these measures is by Naor and Naor <ref> [NN90, NN93] </ref>, which in this setting boils down to the following: Using 2q + 2 coin flips, their N determines, for each k q (n), a hash function h k 2 H k .
Reference: [NN93] <author> J. Naor and M. Naor. </author> <title> Small-bias probability spaces: efficient constructions and applications. </title> <journal> SIAM J. Comput., </journal> <volume> 22 </volume> <pages> 838-856, </pages> <year> 1993. </year>
Reference-contexts: The only previous construction which ours does not improve by an order of magnitude in these measures is by Naor and Naor <ref> [NN90, NN93] </ref>, which in this setting boils down to the following: Using 2q + 2 coin flips, their N determines, for each k q (n), a hash function h k 2 H k .
Reference: [NOS93] <author> A. Naik, M. Ogiwara, and A. Selman. </author> <title> P-selective sets, and reducing search to decision vs. self-reducibility. </title> <booktitle> In Proc. 8th Annual IEEE Conference on Structure in Complexity Theory, </booktitle> <pages> pages 52-64, </pages> <year> 1993. </year>
Reference-contexts: The following is a straightforward extension of the standard notion of search reducing to decision in polynomial time <ref> [BD76, BBFG91, NOS93] </ref> to other time bounds t (n). Definition 4.1. Let L 2 NP and a time bound t (n) be given.
Reference: [PZ83] <author> C. H. Papadimitriou and S. Zachos. </author> <title> Two remarks on the power of counting. </title> <booktitle> In The 6th GI Conference on Theoretical Computer Science, Lecture Notes in Computer Science No. </booktitle> <volume> 145, </volume> <pages> pages 269-276. </pages> <publisher> Springer Verlag, </publisher> <year> 1983. </year>
Reference-contexts: Statement (b) holds by essentially the same standard construction which, given any polynomial p, produces an oracle B such that NP B 6 DTIME [2 p (n) ]. The result of <ref> [PZ83] </ref> that P P = P also carries over because of the quasilinear bound on the total length of all queries in an oracle computation: QL QL = QL.
Reference: [Rab80] <author> M. Rabin. </author> <title> Probabilistic algorithms in finite fields. </title> <journal> SIAM J. Comput., </journal> <pages> pages 273-280, </pages> <year> 1980. </year>
Reference-contexts: For step 10, we first note that to multiply two polynomials of degree k 1 over GF (2) and reduce them modulo ff in the field GF (2 k ) takes time t 1 = O (k log k loglog k) on standard Turing machine models (see [AHU74] and <ref> [Rab80] </ref>). The time to compute a i in GF (2 k ) where i q is t 2 = O (log q 2k log k loglog k) via repeated squaring, which is O (log (n) log + n).
Reference: [Sch76] <author> C. Schnorr. </author> <title> The network complexity and the Turing machine complexity of finite functions. </title> <journal> Acta Informatica, </journal> <volume> 7 </volume> <pages> 95-107, </pages> <year> 1976. </year>
Reference-contexts: Quasi-linear time, namely time qlin := n (log n) O (1) , reduces the problem of the exponent of n. Let DQL and NQL stand for time qlin on deterministic and nondeterministic Turing machines. Schnorr <ref> [Sch76, Sch78] </ref> showed that SAT is complete for NQL under DQL many-one reductions ( ql m ). Together with Stearns and Hunt [SH86, SH90], it was shown that many known NP-complete problems also belong to NQL and are complete for NQL under ql m , so that the NQL vs. <p> It is worth sketching Schnorr's construction here (see also [BG93]) for reference below: Take a time-t (n) DTM M that decides a witness predicate R (x; y) for the given language A 2 NQL. Then as shown in <ref> [Sch76] </ref>, M can be converted into a uniform family of O (t (n) log t (n))-sized circuits C n of fan-in 2 in variables x 1 ; : : : ; x n and y 1 ; : : : ; y q such that for all x, x 2 A
Reference: [Sch78] <author> C. Schnorr. </author> <title> Satisfiability is quasilinear complete in NQL. </title> <journal> J. ACM, </journal> <volume> 25 </volume> <pages> 136-145, </pages> <year> 1978. </year>
Reference-contexts: Quasi-linear time, namely time qlin := n (log n) O (1) , reduces the problem of the exponent of n. Let DQL and NQL stand for time qlin on deterministic and nondeterministic Turing machines. Schnorr <ref> [Sch76, Sch78] </ref> showed that SAT is complete for NQL under DQL many-one reductions ( ql m ). Together with Stearns and Hunt [SH86, SH90], it was shown that many known NP-complete problems also belong to NQL and are complete for NQL under ql m , so that the NQL vs. <p> Since Matrix (x; ~c; ~v; ~w) is decidable in quasilinear time, this is a ql 2 definition of L. Parts (b) and (c) follow from (a) by standard means. The case k = 1 of (d) is the main theorem of Schnorr <ref> [Sch78] </ref> that SAT is complete for NQL under ql m . It is worth sketching Schnorr's construction here (see also [BG93]) for reference below: Take a time-t (n) DTM M that decides a witness predicate R (x; y) for the given language A 2 NQL.
Reference: [Sch85] <author> U. Schoning. </author> <title> Robust algorithms: a different approach to oracles. </title> <journal> Theor. Comp. Sci., </journal> <volume> 40 </volume> <pages> 57-66, </pages> <year> 1985. </year>
Reference-contexts: Section 5 shows how our notion of counting the number of query bits used by oracle machines relates to previous work on counting queries [Bei87b, AG88, BGH89, ABG90, Bei91, BGGO93, HN93, BKS93] and on "helping" <ref> [Sch85, Ko87, Bal90] </ref>. We observe that the known equivalence between having search reduce to decision and one-sided helping in polynomial time carries over to any reasonable time bound t (n). This yields other forms of our main results in Section 4. <p> The desire to find a property of decision problems alone that facilitates search led to several notions of helping proposed by Schoning <ref> [Sch85] </ref> and Ko [Ko87]. We extend their definitions from polynomial time to arbitrary time bounds t (n) under our oracle convention. An oracle TM M is robust if for every oracle B, M with oracle B halts for all inputs, and L (M B ) = L (M ; ).
Reference: [Sel79] <author> A. Selman. </author> <title> P-selective sets, tally languages, and the behavior of polynomial time reducibilities on NP. </title> <journal> Math. Sys. Thy., </journal> <volume> 13 </volume> <pages> 55-65, </pages> <year> 1979. </year>
Reference-contexts: This also gives a sense in which the quasi-polynomial upper bound for NP in Theorem 4.2 appears to be optimal. First we observe that a lemma of Selman <ref> [Sel79] </ref> carries over for quasilinear time reductions. Lemma 5.5 If L 1 and L 2 are such that L 1 ql m L 2 and search reduces to decision in quasilinear time for L 1 , then search reduces to decision in quasilinear time for L 2 . Proof.
Reference: [Sel88] <author> A. Selman. </author> <title> Natural self-reducible sets. </title> <journal> SIAM J. Comput., </journal> <volume> 17 </volume> <pages> 989-996, </pages> <year> 1988. </year> <month> 23 </month>
Reference-contexts: In contrast, we show that there exist functions that cannot be computed in quasilinear time using any set as an oracle whatsoever. Many natural problems in NP have associated search functions that reduce to the decision problems in polynomial time|in most cases, quadratic time (cf. <ref> [Sel88, JY90] </ref>). Theorem 4.2 shows that for 1 SAT , search does not reduce to decision in quasilinear time, unless all of NP is contained in quasi-polynomial time, viz. DTIME [2 polylog n ]. <p> The codes in [ABN + 92, JLJH92, She93] are good, but appear not to give quasilinear runtime here. 10 4 Search Versus Decision in Quasilinear Time The classical method of computing partial, multivalued functions using sets as oracles is the prefix-set method (cf. <ref> [Sel88] </ref> ). To illustrate, let f be an arbitrary length-preserving, partial function from fl to fl . Define: L f = fx#w j w is a prefix of some value of f (x)g: Clearly f is computable in quadratic time using L f as an oracle.
Reference: [SH86] <author> R. Stearns and H. Hunt III. </author> <title> On the complexity of the satisfiability problem and the structure of NP. </title> <type> Technical Report 86-21, </type> <institution> Dept. of Comp. Sci., SUNY at Albany, </institution> <year> 1986. </year>
Reference-contexts: Let DQL and NQL stand for time qlin on deterministic and nondeterministic Turing machines. Schnorr [Sch76, Sch78] showed that SAT is complete for NQL under DQL many-one reductions ( ql m ). Together with Stearns and Hunt <ref> [SH86, SH90] </ref>, it was shown that many known NP-complete problems also belong to NQL and are complete for NQL under ql m , so that the NQL vs. DQL question takes on much the same shape as NP vs. P. <p> Our hypothesis is the last on the following list: (a) SAT has power index 1 <ref> [SH86] </ref>. (b) SAT is P-superterse [Bei87a]. (c) The search function for SAT does not belong to PF NP [o (n)] [Kre88]. (d) NP does not have p-measure zero in exponential time [Lut93] (e) The search function for SAT requires (n 2 ) query bits to compute in polynomial time, with any
Reference: [SH90] <author> R. Stearns and H. Hunt III. </author> <title> Power indices and easier hard problems. </title> <journal> Math. Sys. Thy., </journal> <volume> 23 </volume> <pages> 209-225, </pages> <year> 1990. </year>
Reference-contexts: Let DQL and NQL stand for time qlin on deterministic and nondeterministic Turing machines. Schnorr [Sch76, Sch78] showed that SAT is complete for NQL under DQL many-one reductions ( ql m ). Together with Stearns and Hunt <ref> [SH86, SH90] </ref>, it was shown that many known NP-complete problems also belong to NQL and are complete for NQL under ql m , so that the NQL vs. DQL question takes on much the same shape as NP vs. P. <p> DTIME [2 polylog n ]. We also show that the quadratic upper bound is tight unless the power index of SAT is less than 1, which would be contrary to a conjecture of Stearns and Hunt <ref> [SH90] </ref>. Section 5 shows how our notion of counting the number of query bits used by oracle machines relates to previous work on counting queries [Bei87b, AG88, BGH89, ABG90, Bei91, BGGO93, HN93, BKS93] and on "helping" [Sch85, Ko87, Bal90]. <p> If A 2 NTIME [n k ] then all we get from the above is a running time of 2 n kffi , and the upper exponent is not bounded in k. Stearns and Hunt <ref> [SH90] </ref> define a language L 2 NP to have power index * if * is the infimum of all ffi such that L 2 DTIME [2 n ffi ]. They classify familiar NP-complete problems according to known bounds on their power indices, and conjecture that SAT has power index 1.
Reference: [She93] <author> B.-Z. Shen. </author> <title> A Justesen construction of binary concatenated codes than asymptotically meet the Zyablov bound for low rate. </title> <journal> IEEE Trans. Info. Thy., </journal> <volume> 39(1) </volume> <pages> 239-242, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Families of codes are known for which R (as well as ffi) stays bounded below by a constant; such (families of) codes are called good . Good codes require only q + O (1) random bits in the above construction. The codes in <ref> [ABN + 92, JLJH92, She93] </ref> are good, but appear not to give quasilinear runtime here. 10 4 Search Versus Decision in Quasilinear Time The classical method of computing partial, multivalued functions using sets as oracles is the prefix-set method (cf. [Sel88] ).
Reference: [Sho88] <author> V. Shoup. </author> <title> New algorithms for finding irreducible polynomials over finite fields. </title> <booktitle> In Proc. 29th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 283-290, </pages> <year> 1988. </year>
Reference-contexts: Compute G (y; j) := u v /*Hadamard code applied here*/ 12. Accept iff R (x; y) ^ G (y; j) = 1. Steps 1-5 take linear time. It is now possible to do Step 6 deterministically in time that is polynomial in k (see <ref> [Sho88] </ref>, and since k is approximately log q + log n + log (1=*), which is O (log n) when * is fixed, the time for step 6 is negligible.
Reference: [Sto77] <author> L. Stockmeyer. </author> <title> The polynomial time hierarchy. </title> <journal> Theor. Comp. Sci., </journal> <volume> 3 </volume> <pages> 1-22, </pages> <year> 1977. </year>
Reference-contexts: With this in hand it is straightforward to show that the most fundamental properties of the polynomial hierarchy (from <ref> [Sto77, Wra77] </ref>) carry over to QLH. <p> This reduces A to SAT and is computable in time O (n log n). The cases k &gt; 1 follow by inserting this construction into the corresponding parts of the proofs for polynomial-time reductions in <ref> [Sto77, Wra77] </ref>, similar to what we do in Proposition 2.4 (a) below. Part (e) follows because the language QBF = [ k B k of quantified Boolean formulas belongs to quasilinear (in fact, linear) space.
Reference: [Sud92] <author> M. Sudan. </author> <title> Efficient checking of polynomials and proofs and the hardness of approximation problems. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1992. </year>
Reference-contexts: The main point of our construction is that by scaling down the size of the field, and using multi-variable polynomials, one can achieve quasilinear runtime. Our code is similar to those used in recent improvements of "holographic proof systems" <ref> [BFLS91, Sud92] </ref>, and is only inferior to that of [ABN + 92] in using 2q o (q) rather than q + O (1) random bits. 3.1 Error-correcting codes Let be an alphabet of size 2 l . <p> Since d 2 k 1 these monomials are all distinct, and they are all linearly independent, so the dimension is K = ( m+d d ). The well-known property on which these codes are based (cf. <ref> [BFLS91, Sud92] </ref>) is that for every two distinct polynomials f and g over F of total degree at most d, and for every I F , jf ~a 2 I m : f (~a ) = g (~a ) gj djIj m1 : (1) With I = F , it follows
Reference: [Tod91] <author> S. </author> <title> Toda. PP is as hard as the polynomial-time hierarchy. </title> <journal> SIAM J. Comput., </journal> <volume> 20 </volume> <pages> 865-877, </pages> <year> 1991. </year>
Reference-contexts: Section 3 shows that the randomized reduction from NP to parity given by Valiant and Vazirani [VV86] and used by Toda <ref> [Tod91] </ref>, which was previously proved by constructions that run in quadratic time (see [VV86, Tod91, CRS93, Gup93]), can be made to run in quasilinear time. <p> Section 3 shows that the randomized reduction from NP to parity given by Valiant and Vazirani [VV86] and used by Toda [Tod91], which was previously proved by constructions that run in quadratic time (see <ref> [VV86, Tod91, CRS93, Gup93] </ref>), can be made to run in quasilinear time. Our construction also markedly improves both the number of random bits needed and the success probability, and uses error-correcting codes in an interesting manner first noted in [NN90]. <p> However we are able to show, in the next section, that the well-known NP BP [ P] lemma from [VV86] and <ref> [Tod91] </ref> does carry over by a new construction, where all previous known constructions were quadratic or worse. 3 Quasilinear-Time Reduction to Parity Let A 2 NP with witness predicate R (x; y) and length bound q = q (n), and for any x let S x := f y 2 f <p> In symbols, this says that NP RP [ P] (cf. <ref> [Tod91] </ref>). However, in the case A = SAT addressed by [VV86], with q (n) = n, N 0 runs in quadratic time|in fact, N 0 flips quadratically many coins and makes quadratically many nondeterministic moves.
Reference: [TV91] <author> M. Tsfasman and S. Vladut. </author> <title> Algebraic-Geometric Codes, volume 58 of Mathematics and Its Applications (Soviet Series). </title> <publisher> Kluwer Academic, </publisher> <address> Dordrecht, </address> <year> 1991. </year>
Reference-contexts: Guess a row i, 1 i 2 q , identified with a possible witness string y i 2 f 0; 1 g q . 3. Accept iff R (x; y i ) ^ G (i; j) = 1. 1 The standard notation is R q (r; m) as in <ref> [TV91] </ref>, where q is a prime power and r &lt; m (q 1). Below, d = d 0 m. Suppose S = S x is nonempty. Then to S there corresponds the unique non-zero codeword w S := y2S G (y; ), where the sum is over GF (2).
Reference: [VV86] <author> L. Valiant and V. Vazirani. </author> <title> NP is as easy as detecting unique solutions. </title> <journal> Theor. Comp. Sci., </journal> <volume> 47 </volume> <pages> 85-93, </pages> <year> 1986. </year>
Reference-contexts: Section 3 shows that the randomized reduction from NP to parity given by Valiant and Vazirani <ref> [VV86] </ref> and used by Toda [Tod91], which was previously proved by constructions that run in quadratic time (see [VV86, Tod91, CRS93, Gup93]), can be made to run in quasilinear time. <p> Section 3 shows that the randomized reduction from NP to parity given by Valiant and Vazirani [VV86] and used by Toda [Tod91], which was previously proved by constructions that run in quadratic time (see <ref> [VV86, Tod91, CRS93, Gup93] </ref>), can be made to run in quasilinear time. Our construction also markedly improves both the number of random bits needed and the success probability, and uses error-correcting codes in an interesting manner first noted in [NN90]. <p> However, it is unclear whether the theorem BPP BPP = BPP [Ko82] carries over, because the amplification of success probability to 1 2 polylog obtainable for BQL seems insufficient. However we are able to show, in the next section, that the well-known NP BP [ P] lemma from <ref> [VV86] </ref> and [Tod91] does carry over by a new construction, where all previous known constructions were quadratic or worse. 3 Quasilinear-Time Reduction to Parity Let A 2 NP with witness predicate R (x; y) and length bound q = q (n), and for any x let S x := f y <p> Valiant and Vazirani <ref> [VV86] </ref> constructed a probabilistic NTM N that on any input x of length n first flips q 2 -many coins to form q-many vectors w 1 ; : : : ; w q each of length q. N also flips coins to form a number j, 0 j q. <p> Clearly whenever x =2 A, for all w and i, the number #acc (N w;j ; x) of accepting computations of N w;j on input x is zero. The basic lemma of <ref> [VV86] </ref> states that whenever x 2 A, Pr w [(9j)#acc (N w;j ; x) = 1] 1=4. In particular, Pr w;j [#acc (N w;j ; x) is odd] 1=4 (q + 1). <p> In symbols, this says that NP RP [ P] (cf. [Tod91]). However, in the case A = SAT addressed by <ref> [VV86] </ref>, with q (n) = n, N 0 runs in quadratic time|in fact, N 0 flips quadratically many coins and makes quadratically many nondeterministic moves.
Reference: [vzG91] <author> J. von zur Gathen. </author> <title> Efficient exponentiation in finite fields. </title> <booktitle> In Proc. 32nd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 384-391, </pages> <year> 1991. </year>
Reference-contexts: This is not known to be possible in quasilinear time, even by randomized algorithms, and the sequential method of von zur Gathen <ref> [vzG91] </ref> takes quadratic time on TMs. The main point of our construction is that by scaling down the size of the field, and using multi-variable polynomials, one can achieve quasilinear runtime.
Reference: [Wra77] <author> C. Wrathall. </author> <title> Complete sets and the polynomial-time hierarchy. </title> <journal> Theor. Comp. Sci., </journal> <volume> 3 </volume> <pages> 23-33, </pages> <year> 1977. </year>
Reference-contexts: We use the same terms in the context of NQL and DQL. We note the following provision about oracle Turing machines M made standard in both [WW86] and [BDG88] (see also <ref> [LL76, Wra77, Wra78] </ref>): Whenever M enters its query state q ? with the query string z on its query tape, z is erased when the oracle gives its answer. <p> With this in hand it is straightforward to show that the most fundamental properties of the polynomial hierarchy (from <ref> [Sto77, Wra77] </ref>) carry over to QLH. <p> This reduces A to SAT and is computable in time O (n log n). The cases k &gt; 1 follow by inserting this construction into the corresponding parts of the proofs for polynomial-time reductions in <ref> [Sto77, Wra77] </ref>, similar to what we do in Proposition 2.4 (a) below. Part (e) follows because the language QBF = [ k B k of quantified Boolean formulas belongs to quasilinear (in fact, linear) space.
Reference: [Wra78] <author> C. Wrathall. </author> <title> Rudimentary predicates and relative computation. </title> <journal> SIAM J. Comput., </journal> <volume> 7 </volume> <pages> 194-209, </pages> <year> 1978. </year>
Reference-contexts: We use the same terms in the context of NQL and DQL. We note the following provision about oracle Turing machines M made standard in both [WW86] and [BDG88] (see also <ref> [LL76, Wra77, Wra78] </ref>): Whenever M enters its query state q ? with the query string z on its query tape, z is erased when the oracle gives its answer.
Reference: [WW86] <author> K. Wagner and G. Wechsung. </author> <title> Computational Complexity. </title> <address> D. </address> <publisher> Reidel, </publisher> <year> 1986. </year> <month> 24 </month>
Reference-contexts: However, currently it appears that DNLT is larger than DQL, and that for all d &gt; 1, Turing machines with d-dimensional tapes accept more languages in time qlin than do TMs with (d 1)-dimensional tapes (cf. <ref> [WW86] </ref>). Our constructions all work for DQL as well as DNLT. <p> We use the same terms in the context of NQL and DQL. We note the following provision about oracle Turing machines M made standard in both <ref> [WW86] </ref> and [BDG88] (see also [LL76, Wra77, Wra78]): Whenever M enters its query state q ? with the query string z on its query tape, z is erased when the oracle gives its answer.
References-found: 60

