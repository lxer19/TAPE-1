URL: http://www.csl.sri.com/shankar/tpcd94.ps.gz
Refering-URL: http://www.csl.sri.com/shankar/shankar-papers.html
Root-URL: 
Email: srivasg@csl.sri.com  
Phone: 1  2  3  
Title: Effective Theorem Proving for Hardware Verification  
Author: D. Cyrluk, S. Rajan, N. Shankar, and M.K. Srivas fcyrluk, sree, shankar, 
Address: Stanford CA 94305 and  Menlo Park, CA 94025  Menlo Park, CA 94025  Menlo Park CA 94025 USA  
Affiliation: Dept. of Computer Science, Stanford University,  Computer Science Laboratory, SRI International,  Integrated Systems Design Laboratory, Department of Computer Science, University of British Columbia, Vancouver, Canada and Computer Science Laboratory, SRI International,  Computer Science Laboratory, SRI International,  
Abstract: The attractiveness of using theorem provers for system design verification lies in their generality. The major practical challenge confronting theorem proving technology is in combining this generality with an acceptable degree of automation. We describe an approach for enhancing the effectiveness of theorem provers for hardware verification through the use of efficient automatic procedures for rewriting, arithmetic and equality reasoning, and an off-the-shelf BDD-based propositional simplifier. These automatic procedures can be combined into general-purpose proof strategies that can efficiently automate a number of proofs including those of hardware correctness. The inference procedures and proof strategies have been implemented in the PVS verification system. They are applied to several examples including an N-bit adder, the Saxe pipelined processor, and the benchmark Tamarack microprocessor design. These examples illustrate the basic design philosophy underlying PVS where powerful and efficient low-level inferences are employed within high-level user-defined proof strategies. This approach is contrasted with approaches based on tactics or batch-oriented theorem proving. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Mark D. Aagard, Miriam E. Leeser, and Phillip J. Windley. </author> <title> Toward a super duper hardware tactic. </title> <booktitle> In Proceedings of the HOL User's Group Workshop, </booktitle> <pages> pages 401-414, </pages> <year> 1993. </year>
Reference-contexts: This is an important consideration: the inference procedures of PVS do need to be scrutinized and tested with great care and rigor, but once this is done, they do not need to be justified down to basic inference steps with each application. The "super-duper" tactic developed in <ref> [1] </ref> for hardware proofs is similar to the core strategy described in this paper. The similarity lies in the fact that both combine rewriting, case-splitting and simplifications in a loop for automating hardware proofs. <p> This interaction allows rewriting to be more effective, i.e., successful in simplifying more often, and efficient. We have found that the efficiency and effectiveness of rewriting are very crucial in the core strategy being applicable for large examples. The tactic in <ref> [1] </ref> is also designed to process predicative style of hardware specifications, whereas ours is suited for functional style.
Reference: 2. <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <booktitle> In Third Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 165-175. </pages> <publisher> IEEE, Computer Society Press, </publisher> <month> July </month> <year> 1988. </year>
Reference-contexts: The details of this approach are beyond the scope of this paper (see <ref> [2, 11, 24, 27, 29] </ref> 7 ). In this approach, the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state.
Reference: 3. <author> R. J. Boulton. </author> <title> The HOL arith library. </title> <type> Technical report, </type> <institution> University of Cambridge Computer Laboratory, </institution> <year> 1992. </year>
Reference-contexts: The more powerful primitive inference mechanisms of PVS can, in principle, be developed as tactics in HOL. For example, Boulton <ref> [3] </ref> has implemented a decision procedure for Presburger arithmetic as a tactic in HOL. However, this procedure does not 16 handle equality over uninterpreted function symbols and, unlike in PVS, is not tightly integrated with the simplification and rewriting procedures.
Reference: 4. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: We had to provide manual instantiations for the other two examples. The Boyer-Moore theorem prover, Nqthm, is the best known of the batch-oriented theorem proving systems used in hardware verification <ref> [4] </ref>. Many of its deductive components are quite similar to those in PVS. The system uses a fast propositional simplifier, and also includes a rewriter and a linear arithmetic package. The latest release of the system has been heavily optimized for efficiency.
Reference: 5. <author> K. S. Brace, R. L. Rudell, and R. E. Bryant. </author> <title> Efficient implementation of a BDD package. </title> <booktitle> In Proc. of the 27th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 40-45, </pages> <year> 1990. </year>
Reference-contexts: The restriction operation is used to simplify one BDD representation assuming another containing the contextual assumptions. The BDD simplifier we use is an efficient implementation from EUT [17]. The simplifier uses Reduced Ordered BDD (ROBDD), a canonical representation of boolean expressions, with an associated set of algorithms <ref> [5] </ref>. The BDD simplifier is invoked in a PVS proof with the command bddsimp. 3 The Nature of Hardware Proofs, and Our Thesis We have described some of the built-in deductive capabilities of PVS.
Reference: 6. <author> J. R. Burch and D. L. Dill. </author> <title> Automated verification of pipelined microprocessor control. </title> <editor> In David Dill, editor, </editor> <booktitle> Computer-Aided Verification '94, </booktitle> <pages> pages 68-80. </pages> <booktitle> Volume 818 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Burch and Dill <ref> [6] </ref> report on an automatic stand-alone strategy for microprocessor verification. Although they have not attempted the two examples reported here they report impressive timings for the automatic verification of a small version of the DLX processor [15].
Reference: 7. <author> F. J. Cantu. </author> <title> Verifying an n-bit arithmetic logic unit. Blue book note 935, </title> <institution> Univer sity of Edinburgh, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: The resulting nested boolean expression is propositionally simplified into a finite number of subgoals. The last step consists of applying arithmetic and equality decision procedures on each of the subgoals resulting from the propositional simplification. We have applied this strategy to an n-bit ALU <ref> [7] </ref> that executes 12 microoperations. The completely automatic verification took 90 seconds on a SPARC 10.
Reference: 8. <author> E. M. Clarke and O. Grumberg. </author> <title> Research on automatic verification of finite-state concurrent systems. </title> <editor> In Joseph F. Traub, Barbara J. Grosz, Butler W. Lampson, and Nils J. Nilsson, editors, </editor> <booktitle> Annual Review of Computer Science, </booktitle> <volume> Volume 2, </volume> <pages> pages 269-290. </pages> <publisher> Annual Reviews, Inc., </publisher> <address> Palo Alto, CA, </address> <year> 1987. </year>
Reference-contexts: Though these approaches were quite general, the verification process required a significant human input. More recently, there has been a large body of work devoted to the use of model-checking, language-containment, and reachability analysis to finite-state machine models of hardware <ref> [8] </ref>. The latter class of systems work automatically but they do not yet scale up efficiently to realistic hardware designs. The challenge then is to combine the generality of theorem proving with an acceptable and efficient level of automation.
Reference: 9. <institution> User Guide for the Ehdm Specification Language and Verification System, </institution> <note> Version 6.1. </note> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year> <title> Three volumes. </title>
Reference-contexts: In this case, we can use a congruence closure data structure to rapidly propagate equality information. Congruence closure [12] plays a central role in several other systems including the Stanford Pascal Verifier [21] and Ehdm <ref> [9] </ref>. This basic procedure can be extended in several ways. One basic extension is to the case of ground linear inequalities over the real numbers.
Reference: 10. <author> D. Cyrluk and P. Narendran. </author> <title> Ground temporal logic|a logic for hardware ver ification. </title> <editor> In David Dill, editor, </editor> <booktitle> Computer-Aided Verification '94, </booktitle> <pages> pages 247-259. </pages> <booktitle> Volume 818 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <month> 19 </month>
Reference-contexts: See [11,24] for details. If the abstraction mapping is given this way, then once the proof is split according to the definition of num cycles, the resulting statement of correctness is usually an instance of a decidable fragment of the theory Ground Temporal Logic (GTL2) <ref> [10] </ref>. The problem is to come up with an effective procedure for deciding this theory.
Reference: 11. <author> David Cyrluk. </author> <title> Microprocessor verification in PVS: A methodology and simple example. </title> <type> Technical Report SRI-CSL-93-12, </type> <institution> SRI Computer Science Laboratory, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: The details of this approach are beyond the scope of this paper (see <ref> [2, 11, 24, 27, 29] </ref> 7 ). In this approach, the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state. <p> The above strategy consists of first skolemizing, then instructing PVS to use the axioms and definitions of the processor as rewrite rules (auto-rewrite-all-theories), then invoking the type predicate of the implementation state-type ((typepred-impl-state)). This is necessary in case there is a pipeline invariant associated with the machine state <ref> [11, 27] </ref>. The proof goal is then split (cycle-split) according to the num cycles function. The current case is recorded in the ground decision procedures and assert is called which invokes automatic rewriting.
Reference: 12. <author> P. J. Downey, R. Sethi, and R. E. Tarjan. </author> <title> Variations on the common subexpres sions problem. </title> <journal> Journal of the ACM, </journal> <volume> 27(4) </volume> <pages> 758-771, </pages> <month> October </month> <year> 1980. </year>
Reference-contexts: To refute the negation we can assert the information in each literal into a data structure until a contradiction is found. In this case, we can use a congruence closure data structure to rapidly propagate equality information. Congruence closure <ref> [12] </ref> plays a central role in several other systems including the Stanford Pascal Verifier [21] and Ehdm [9]. This basic procedure can be extended in several ways. One basic extension is to the case of ground linear inequalities over the real numbers.
Reference: 13. <author> M. J. C. Gordon and T. F. Melham, </author> <title> editors. Introduction to HOL: A Theorem Proving Environment for Higher-Order Logic. </title> <publisher> Cambridge University Press, </publisher> <address> Cam-bridge, UK, </address> <year> 1993. </year>
Reference-contexts: Note that hashing was much more important in the microprocessor examples. These examples typically use more rewriting. In the ongoing verification of a simplified version of the MIPS R3000 we find that we get exponential savings due to hashing. 6 Related Work The HOL system <ref> [13] </ref> is prototypical of the proof checkers that are based on very simple primitive inference rules combined using tactics. The more powerful primitive inference mechanisms of PVS can, in principle, be developed as tactics in HOL.
Reference: 14. <author> Mike Gordon. </author> <title> Proving a computer correct. </title> <type> Technical Report TR 42, </type> <institution> University of Cambridge, Computer Laboratory, </institution> <year> 1983. </year>
Reference-contexts: CCR-930044, the Semiconductor Research Corporation contract 92-DJ-295 (to the University of British Columbia), and the Philips Research Laboratories, Eindhoven, The Netherlands. ?? This paper was presented at the Second International Conference on Theorem Provers in Circuit Design, Theory, Practice, and Experience, Bad Herrenalb, Germany, September 26-28, 1994. of hardware designs <ref> [14, 16] </ref>. Though these approaches were quite general, the verification process required a significant human input. More recently, there has been a large body of work devoted to the use of model-checking, language-containment, and reachability analysis to finite-state machine models of hardware [8].
Reference: 15. <author> J. L. Hennessy and D. A. Patterson. </author> <title> Computer Architecture: A Quantitative Ap proach. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: Burch and Dill [6] report on an automatic stand-alone strategy for microprocessor verification. Although they have not attempted the two examples reported here they report impressive timings for the automatic verification of a small version of the DLX processor <ref> [15] </ref>. They also describe a method for automating the generation of the abstraction mapping. 7 Conclusions Automated theorem proving technology clearly has a great deal to contribute to hardware verification since hardware proofs tend to fall into certain systematic patterns.
Reference: 16. <author> Warren A. Hunt, Jr. </author> <title> Microprocessor design verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 429-460, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: CCR-930044, the Semiconductor Research Corporation contract 92-DJ-295 (to the University of British Columbia), and the Philips Research Laboratories, Eindhoven, The Netherlands. ?? This paper was presented at the Second International Conference on Theorem Provers in Circuit Design, Theory, Practice, and Experience, Bad Herrenalb, Germany, September 26-28, 1994. of hardware designs <ref> [14, 16] </ref>. Though these approaches were quite general, the verification process required a significant human input. More recently, there has been a large body of work devoted to the use of model-checking, language-containment, and reachability analysis to finite-state machine models of hardware [8].
Reference: 17. <author> G. </author> <type> Janssen. </type> <institution> ROBDD Software. Department of Electrical Engineering, Eindhoven University of Technology, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: The restriction operation is used to simplify one BDD representation assuming another containing the contextual assumptions. The BDD simplifier we use is an efficient implementation from EUT <ref> [17] </ref>. The simplifier uses Reduced Ordered BDD (ROBDD), a canonical representation of boolean expressions, with an associated set of algorithms [5].
Reference: 18. <author> J. Joyce, G. Birtwistle, and M. Gordon. </author> <title> Proving a computer correct in higher order logic. </title> <type> Technical Report 100, </type> <institution> Computer Lab., University of Cambridge, </institution> <year> 1986. </year>
Reference-contexts: We present the proof strategy and demonstrate its utility on a number of examples including an N-bit ripple carry adder circuit, Saxe's pipelined microprocessor [24] and the Tamarack processor <ref> [18] </ref>. The point of these examples is to illustrate efficiency and generality that can be derived from the inference capabilities present in PVS. <p> Note that this strategy, while not identical to the basic hardware strategy described earlier, has the same core strategy, namely the (do-rewrite, lift-if, bddsimp, assert) cycle. We have also applied the same strategy to the Tamarack microprocessor first verified by Joyce <ref> [18] </ref>. This microprocessor is microcoded but not pipelined. Only the first restricted form of rewriting is necessary to finish the Tamarack's proof of correctness.
Reference: 19. <author> R. Kumar, K. Schneider, and T. Kropf. </author> <title> Structuring and automating hardware proofs in a higher-order therem proving environment. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 2(2) </volume> <pages> 165-223, </pages> <year> 1993. </year>
Reference-contexts: The tactic in [1] is also designed to process predicative style of hardware specifications, whereas ours is suited for functional style. Kumar, Schneider, and Kropf have developed a system MEPHISTO and a sequent calculus prover FAUST <ref> [19] </ref> which jointly can automatically verify a class of bit-level hardware circuits specified in a relational style popularized by Michael Gordon. Their system cannot automate proofs of complex circuits, such as microprocessors, that use data types since they do not have rewriting and arithmetic capability.
Reference: 20. <author> Patrick Lincoln, Sam Owre, John Rushby, N. Shankar, and Friedrich von Henke. </author> <title> Eight papers on formal verification. </title> <type> Technical Report SRI-CSL-93-4, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: A high bandwidth of interaction is useful at the exploratory level whereas more automated high-level proof strategies are desirable at an advanced stage of proof development. PVS has been used to verify several complex fault-tolerant algorithms, real-time and distributed protocols, and several other applications <ref> [20] </ref>. 2.1 The Specification Language The PVS specification language builds on a classical typed higher-order logic. The base types consist of booleans, real numbers, rationals, integers, natural numbers, lists, and so forth.
Reference: 21. <author> D. C. Luckham, S. M. German, F. W. von Henke, R. A. Karp, P. W. Milne, D. C. Oppen, W. Polak, and W. L. Scherlis. </author> <title> Stanford Pascal Verifier user manual. </title> <type> CSD Report STAN-CS-79-731, </type> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <month> March </month> <year> 1979. </year>
Reference-contexts: In this case, we can use a congruence closure data structure to rapidly propagate equality information. Congruence closure [12] plays a central role in several other systems including the Stanford Pascal Verifier <ref> [21] </ref> and Ehdm [9]. This basic procedure can be extended in several ways. One basic extension is to the case of ground linear inequalities over the real numbers.
Reference: 22. <author> S. Owre, J. M. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <editor> In Deepak Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction (CADE), </booktitle> <pages> pages 748-752, </pages> <address> Saratoga, NY, </address> <month> June </month> <year> 1992. </year> <booktitle> Volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: It is difficult to reconcile efficiency with generality in a fully automated theorem prover since a single proof strategy is being applied to all theorems. The above design philosophy has formed the guiding principle for the implementation of the Prototype Verification System (PVS) <ref> [22, 23] </ref> developed at SRI. PVS is designed to automate the tedious and obvious low-level inferences while allowing the user to control the proof construction at a meaningful level.
Reference: 23. <author> S. Owre, N. Shankar, and J. M. Rushby. </author> <title> User Guide for the PVS Specification and Verification System, Language, and Proof Checker (Beta Release). </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year> <title> Three volumes. </title>
Reference-contexts: It is difficult to reconcile efficiency with generality in a fully automated theorem prover since a single proof strategy is being applied to all theorems. The above design philosophy has formed the guiding principle for the implementation of the Prototype Verification System (PVS) <ref> [22, 23] </ref> developed at SRI. PVS is designed to automate the tedious and obvious low-level inferences while allowing the user to control the proof construction at a meaningful level. <p> Section 4 describes the use of the PVS inference procedures in the development of verification strategies for microprocessor designs. We present our conclusions in the last section. 2 An Overview of PVS PVS is an environment for writing specifications and developing proofs <ref> [23] </ref>. It serves as a prototype for exploring new approaches to mechanized formal methods. The primary goal of PVS is to combine an expressive specification language with a productive, interactive proof checker that has a reasonable amount of theorem proving power.
Reference: 24. <author> James B. Saxe, Stephen J. Garland, John V. Guttag, and James J. Horning. </author> <title> Us ing transformations and verification in circuit design. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 4(1) </volume> <pages> 181-210, </pages> <year> 1994. </year>
Reference-contexts: We present the proof strategy and demonstrate its utility on a number of examples including an N-bit ripple carry adder circuit, Saxe's pipelined microprocessor <ref> [24] </ref> and the Tamarack processor [18]. The point of these examples is to illustrate efficiency and generality that can be derived from the inference capabilities present in PVS. <p> The details of this approach are beyond the scope of this paper (see <ref> [2, 11, 24, 27, 29] </ref> 7 ). In this approach, the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state. <p> The implementation machine may run at a different rate than the specification machine [11,27]. For example, in the case of the Saxe pipeline example <ref> [24] </ref>, the specification machine takes one state transition to execute each instruction, but the implementation machine might take five cycles to execute branch instructions, but only one cycle for non-branch instructions. In the following we assume that the specification machine always takes one cycle to execute an instruction. <p> In the Saxe pipeline more case analysis is needed to deal with the register bypass logic. Note that prior to adding hashing and bddsimp to PVS we had verified the correctness of the Saxe pipeline, but only with manual assistance. The verification originally done by Saxe et al <ref> [24] </ref> also required user assistance. 5 Experimental Results The following table summarizes the performance of PVS's automatic strategy with and without the improvements to PVS's automatic inference procedures. The timings were made on a SPARC 10. Processor Hashing and BDDs No Hashing Neither Adder 127 sec. 160 sec. unfin.
Reference: 25. <author> N. Shankar. </author> <title> Abstract datatypes in PVS. </title> <type> Technical Report SRI-CSL-93-9, </type> <institution> Com puter Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: We have applied this strategy to an n-bit ALU [7] that executes 12 microoperations. The completely automatic verification took 90 seconds on a SPARC 10. The same strategy is also effective on several non-hardware examples <ref> [25] </ref>. 4 Microprocessor Verification The automatic inference procedures used in the PVS proof checker have also allowed us to highly automate the task of microprocessor verification. PVS is a relatively new system that has been evolving over the course of our processor verification effort.
Reference: 26. <author> Robert E. Shostak. </author> <title> Deciding combinations of theories. </title> <journal> Journal of the ACM, </journal> <volume> 31(1) </volume> <pages> 1-12, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: The PVS decision procedures combine congruence closure over interpreted and uninterpreted functions and relations with refutation procedures for ground linear inequalities over the real numbers and arrays <ref> [26] </ref>. This procedure is also extended to integer inequalities in an incomplete though effective manner.
Reference: 27. <author> Mandayam Srivas and Mark Bickford. </author> <title> Formal verification of a pipelined micropro cessor. </title> <journal> IEEE Software, </journal> <volume> 7(5) </volume> <pages> 52-64, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The details of this approach are beyond the scope of this paper (see <ref> [2, 11, 24, 27, 29] </ref> 7 ). In this approach, the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state. <p> The above strategy consists of first skolemizing, then instructing PVS to use the axioms and definitions of the processor as rewrite rules (auto-rewrite-all-theories), then invoking the type predicate of the implementation state-type ((typepred-impl-state)). This is necessary in case there is a pipeline invariant associated with the machine state <ref> [11, 27] </ref>. The proof goal is then split (cycle-split) according to the num cycles function. The current case is recorded in the ground decision procedures and assert is called which invokes automatic rewriting.
Reference: 28. <author> Mandayam Srivas and Steve Miller. </author> <title> Formal verification of the AAMP5 micropro cessor: A case study in the industrial use of formal methods. </title> <type> Technical report. </type> <institution> A Forthcoming NASA Contractor Report. </institution>
Reference-contexts: AAMP5 is a microcoded pipelined processor built at the Collins Avionics Division of Rockwell International for Avionics applications. It is a complex 18 CISC processor containing more than half a million transistors and is designed to execute a stack-oriented machine. One of the main purposes in undertaking this project <ref> [28] </ref>, which is sponsored by NASA Langley Research Center and Rockwell International, was to see how well techniques developed and tested on small examples would scale to a commercial processor of significant complexity.
Reference: 29. <author> P. Windley and M. </author> <title> Coe. A correctness model for pipelined microprocessors. </title> <booktitle> In Proceedings of Theorem Provers in Circuit Design, </booktitle> <year> 1994. </year> <month> 20 </month>
Reference-contexts: The details of this approach are beyond the scope of this paper (see <ref> [2, 11, 24, 27, 29] </ref> 7 ). In this approach, the proof of correctness makes use of an abstraction function that maps an implementation state into a corresponding specification state.
References-found: 29

