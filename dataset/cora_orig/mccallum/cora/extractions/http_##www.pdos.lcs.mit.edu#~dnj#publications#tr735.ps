URL: http://www.pdos.lcs.mit.edu/~dnj/publications/tr735.ps
Refering-URL: http://www.pdos.lcs.mit.edu/~dnj/publications.htm
Root-URL: 
Title: Boolean Compilation of Relational Specifications  
Author: Daniel Jackson 
Note: MIT-LCS-TR-735  
Date: December 19, 1997  
Affiliation: MIT Lab for Computer Science  
Abstract: A new method for analyzing relational specifications is described. A property to be checked is cast as a relational formula, which, if the property holds, has no finite models. The relational formula is translated into a boolean formula that has a model for every model of the relational formula within some finite scope. Errors in specifications can usually be demonstrated with small counterexamples, so a small scope often suffices. The boolean formula is solved by an off-the-shelf satisfier. The satisfier requires that the boolean formula be in conjunctive normal form (CNF). A nave translation to CNF fails (by exhausting memory) for realistic specifications. This paper presents a preliminary design of a compiler that overcomes this problem, by exploiting typical features of the relational formulae that arise in practice. Initial experiments suggest that this method scales more readily than existing approaches and will be able to find more errors, in larger specifications. 
Abstract-found: 1
Intro-found: 1
Reference: [BC+92] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> Vol. 98, No. 2, pp.142170, </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: In this case, however, we will reach convergence in log n steps. This technique is known in model checking <ref> [BC+92] </ref> as iterative squaring. One way to encode closure is to apply the translation rules for composition and union on the fly, translating the approximations p i .
Reference: [C+95] <author> Edmund M. Clarke, Orna Grumberg, Hiromi Hiraishi, Somesh Jha, David E. Long, Kenneth L. McMillan, Linda A. Ness. </author> <title> Verification of the Futurebus+ cache coherence protocol. Formal Methods in System Design, </title> <type> 6, 217232, </type> <year> 1995. </year>
Reference-contexts: Fortunately, however, it seems that only small configurations are required to find errors. The celebrated analysis of the Futurebus+ cache protocol <ref> [C+95] </ref>, which perhaps marked the turning point in model checkings industrial reputation, was performed for up to 8 processors and 3 buses.
Reference: [DJ96] <author> C. Damon and D. Jackson. </author> <title> Efficient Search as a Means of Exe cuting Specifications. </title> <booktitle> Proc. Tools for Construction and Analysis of Software, </booktitle> <address> Passau, Germany, </address> <month> March </month> <year> 1996, </year> <pages> pp. 7086. </pages>
Reference-contexts: 3: Effect of symmetry breaking 18 Related Work Our previous method worked by explicit enumeration of relation values, with two principal mechanisms to prune the search: short circuiting, in which a partial assignment could be rejected by determining that any extension to a full assignment would not yield a model <ref> [DJ96] </ref>, and isomorph elimination, which exploited symmetries in the search space to avoid the generation of a high proportion of the relation values [JDJ96, JJD97]. On most of our examples, the new boolean method performs better.
Reference: [DJJ96] <author> Craig A. Damon, Daniel Jackson and Somesh Jha. </author> <title> Checking Relational Specifications with Binary Decision Diagrams. </title> <booktitle> Proc. 37 4th ACM SIGSOFT Conf. on Foundations of Software Engineer ing, </booktitle> <address> San Francisco, CA, </address> <month> October </month> <year> 1996, </year> <month> pp.7080. </month>
Reference-contexts: Fortunately, the DNF clauses derived from practical problems tend to involve few negated formulae (rarely more than one). We explained above (Section 10) how typing constraints are translated into elementary relational formulae, and subsequently have no special treatment. In our previous work <ref> [DJJ96] </ref>, in which we used binary decision diagrams to solve the satisfaction problem, we took a different approach, in which the encoding of a variable exploits its type constraints. Consider representing a total function to a set of 4 elements. <p> It remains to be seen how it will perform in comparison to the boolean checker. We have experimented before with a boolean checker, representing boolean formulae not in CNF but with ordered binary decision diagrams (BDDs) <ref> [DJJ96] </ref>. Although that method performed very well on some small examples, it did not appear to scale. Unlike CNF, a BDD is canonical, so translation cannot be separated from solving; if the formula has no models, it must be the formula false.
Reference: [DP60] <author> Martin Davis and Hilary Putnam. </author> <title> A computing procedure for quantification theory. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 7, </volume> <pages> pp. </pages> <address> 202215, </address> <year> 1960. </year>
Reference-contexts: Using tries naturally eliminates some redundancy since literals in clauses are lexically ordered, and prefixes are shared, it is easy to ensure that a clause never appears with one of its prefixes. The trie also supports a simple and efficient implementation of the Davis-Putnam satisfi-ability algorithm <ref> [DP60] </ref>. A huge performance gain is obtained by negation caching. A direct implementation of the translation rules will sometimes cause the negation of a formula to be negated. Consider, for example, translating Wfl flSflflT where p and q are relational variables. <p> Problematic elementary formulae that cannot be handled by symmetry breaking (because all types have been consumed) might be handled in this way. 29 16 Solving the Boolean Formula We have experimented with two solvers. We wrote a Davis-Putnam solver <ref> [DP60] </ref> using Zhang and Stickels trie-based representation of formulae [ZS94] in Java as part of the prototype. We also wrote code to generate input files for Selman and Kautzs WalkSAT solver [SKC94], a descendant of GSAT [SLM92]. The two solvers are very different.
Reference: [EMW97] <author> Michael D. Ernst, Todd D. Millstein and Daniel S. Weld. </author> <title> Automatic SAT-Compilation of Planning Problems. </title> <booktitle> Proc. 15 th International Joint Conference on Artificial Intelligence (IJCAI 97), </booktitle> <address> Nagoya, Aichi, Japan, </address> <month> August </month> <year> 1997, </year> <pages> pp. 11691176. </pages>
Reference-contexts: The closest application to ours is in planning, where the problem of finding a plan that satisfies a set of constraints is reduced to finding a model of a boolean formula <ref> [KS96, EMW97] </ref>. The planning problem is technically closer to the model checking problem than to our problem: namely finding a sequence of transitions in a state machine that leads to a state satisfying a given property (in planning, the goal, and in model checking, the negation of the invariant).
Reference: [G+95] <author> Erich Gamma, Richard Helm, Ralph Johnson and John Vlis sides. </author> <title> Design Patterns: Elements of Reusable ObjectOriented Soft ware. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: This disparity is particularly remarkable given the centrality of object configurations. The event view is sometimes dominant (for example, in the design of protocols and process control systems), but usually plays a subsidiary role. Take a glance at an influential book on design patterns <ref> [G+95] </ref>, and note the proportion of diagrams that describe object configurations. Nitpick is an attempt to redress this imbalance. Given a constraint describing a set of object configurations, Nitpick can generate instances satisfying the constraint. <p> The solver itself might be encapsulated within the abstract type, as an operation of type %RROHDQ)RUPXODflfifl%RROHDQ$VVLJQPHQW To change the representation of formulae, or to choose a different solver, we would then need only to replace this abstract type. Using subclassing, and perhaps the Factory design pattern <ref> [G+95] </ref>, we could even support these selections at runtime. Were this scheme viable, our paper would be very short. Unfortunately, however, it turns out that the choice of solver is not a concern that can be easily separated from the rest of the design.
Reference: [Giv88] <author> Steven Givant. </author> <title> Tarskis development of logic and mathematics based on the calculus of relations. Colloquia Mathematica Janos Bolyai 54, Algebraic Logic, </title> <address> Budapest, Hungary, </address> <year> 1988. </year>
Reference-contexts: These, along with the equality operator for obtaining formulae from terms, together constitute a basic relational language equivalent to Tarskis relational calculus <ref> [Giv88, Tar41] </ref>. This language is as expressive as first-order predicate logic (so long as we permit definition of projection functions so that tuples can be constructed), and is thus undecidable [Sch79]. The language includes, additionally, the transitive closure operator, which extends its expressiveness, and is indispensable in practice.
Reference: [IBM97] <institution> Object Constraint Language. </institution> <note> www.software.ibm.com/ad/ocl. </note>
Reference-contexts: These are extremely weak, and allow only the most elementary constraints between relations (such as that one is a subset of another) to be expressed. Various textual annotation languages have been designed, most recently UMLs Object Constraint Language (OCL) <ref> [IBM97] </ref>, which originated in the constraints of Syntropy. OCL is very similar to NP, although it does not have a formal semantics and does not appear to be able to express transitive closure.
Reference: [JD95] <author> Semi-executable Specifications. Daniel Jackson and Craig A. Da mon, </author> <month> CMU-CS-95-216, </month> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> November </month> <year> 1995. </year>
Reference: [JD96a] <author> Elements of Style: </author> <title> Analyzing a Software Design Feature with a Counterexample Detector. </title> <editor> Daniel Jackson and Craig A. </editor> <title> Damon. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 22, No. 7, </volume> <month> July </month> <year> 1996, </year> <pages> pp. 484495. </pages>
Reference-contexts: The first two examples are toy benchmarks; Phone is the specification of Figure 1 (but for a different claim, invB_preserved) and Finder is a specification of the directory structure of the Macintosh Finder. Style is a specification of the paragraph style hierarchy of Microsoft Word, described in detail in <ref> [JD96a] </ref>. Allocate is a simplified fragment of a railway interlocking specification written in Z by Praxis UK PLC. The performance figures are for the claim Al-locSafe2.
Reference: [JD96b] <author> Daniel Jackson and Craig A. Damon. </author> <title> Nitpick Reference Manual. </title> <institution> CMU-CS-96-109. School of Computer Science, Carnegie Mel lon University, </institution> <address> Pittsburgh, PA, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Section 17 gives some performance results that compare the new method to our previous explicit method. Section 18 and 19 discuss related work and future plans. 2 Relational Notation: NP Our notation, NP, is roughly a subset of Z [Spi92]. A reference manual <ref> [JD96b] </ref> describes the notation in detail.
Reference: [JDJ96] <author> Daniel Jackson, Craig A. Damon and Somesh Jha. </author> <title> Faster Checking of Software Specifications. </title> <booktitle> Proc. ACM Conf. on Prin ciples of Programming Languages, </booktitle> <address> St. Petersburg Beach, FL, Janu ary 1996, </address> <pages> pp. 7990. </pages>
Reference-contexts: This gives a formula like RSflflSflflS where op is the specification of the operation. A similar situation arises for a claim that an operation preserves an invariant that one relation is a subset of another. To address this problem, we apply some ideas from our previous work on symmetry <ref> [JDJ96, JJD97] </ref>. As we have shown, the models of relational formulae are permutation invariant: given a model of a formula, the assignment that results from permuting the atoms of the underlying universe will also be a model. <p> prune the search: short circuiting, in which a partial assignment could be rejected by determining that any extension to a full assignment would not yield a model [DJ96], and isomorph elimination, which exploited symmetries in the search space to avoid the generation of a high proportion of the relation values <ref> [JDJ96, JJD97] </ref>. On most of our examples, the new boolean method performs better.
Reference: [JJD97] <author> Daniel Jackson, Somesh Jha and Craig A. Damon. </author> <title> Isomorph-free Model Enumeration: A New Method for Checking Rela tional Specifications. </title> <note> To appear, ACM Transactions on Pro gramming Languages and Systems. </note>
Reference-contexts: HPSW"flUHODWLRQflFRQVWDQW _flH [SUflflH [SU XQLRQ _flH [SUflflH [SU LQWHUVHFWLRQ _flH [SUfl?flH [SU GLIIHUHQFH _flH [SUflflH [SU UHODWLRQDOflFRPSRVLWLRQ _flH [SUfla WUDQVSRVH _flH [SUflffi WUDQVLWLYHflFORVXUH _flH [SUflflH [SU GRPDLQflUHVWULFWLRQ _flGRPflH [SU GRPDLQ 18 A more elegant treatment of sets [SS93], which we have used to justify re ductions in our explicit checker <ref> [JJD97] </ref>, represents the set s as the relation ,Gflfl7flfl7 8Qflfl6flfl7 flfl6flfl7 Sfl6flfl7*flTfl6flfl7 SflflTflfl6flfl7 Sfl6flfl7*flTfl6flfl7 SflflTflfl6flfl7 Sfl6flfl7*flTfl6flfl7 Sfl?flTflfl6flfl7 Sfl6flfl7*flTfl7flfl9 SflflTflfl6flfl9 Sfl6flfl7 Saflfl7flfl6 Sfl7flfl7 Sffiflfl7flfl7 Sfl6flfl8QLW*flTfl6flfl7 SflflTflfl6flfl7 Sfl6flfl7 GRPflSflfl6flfl8QLW 19 corresponding to the cross product of s and the universal set. <p> This gives a formula like RSflflSflflS where op is the specification of the operation. A similar situation arises for a claim that an operation preserves an invariant that one relation is a subset of another. To address this problem, we apply some ideas from our previous work on symmetry <ref> [JDJ96, JJD97] </ref>. As we have shown, the models of relational formulae are permutation invariant: given a model of a formula, the assignment that results from permuting the atoms of the underlying universe will also be a model. <p> Both methods have a desirable performance property. When there is a solution, it tends to be found very quickly; when there isnt, the solver can run for a very long time. The engine underlying our previous implementation of Nitpick <ref> [JJD97] </ref> did not have this property: in many cases, successful and unsuccessful searches took roughly the same amount of time (within a factor of 2 to 10). <p> prune the search: short circuiting, in which a partial assignment could be rejected by determining that any extension to a full assignment would not yield a model [DJ96], and isomorph elimination, which exploited symmetries in the search space to avoid the generation of a high proportion of the relation values <ref> [JDJ96, JJD97] </ref>. On most of our examples, the new boolean method performs better.
Reference: [JNW97] <author> Daniel Jackson, Yuchung Ng and Jeannette Wing. </author> <note> A Nitpick Analysis of IPv6. Submitted to Formal Aspects of Computing. </note>
Reference-contexts: Using a variety of mechanisms to prune the search tree, it can analyze enormous configuration spaces. The tool has been used successfully to find flaws in a number of small designs, including a published draft of a mobile internet routing protocol <ref> [Ng97, JNW97] </ref>. Even small designs, however, tend to have huge configuration spaces. Indeed, this is perhaps why analysis of object configurations has not attracted the same attention as the analysis of state machines. <p> Allocate is a simplified fragment of a railway interlocking specification written in Z by Praxis UK PLC. The performance figures are for the claim Al-locSafe2. Mobile IP is a specification of a draft version of a mobile internet protocol for IPv6, written by an undergraduate at Carnegie Mellon <ref> [JNW97, Ng97] </ref>. The performance figures are for the claim loc_update_OK, which exposed a flaw in the protocol. 30 Table 1 is to be interpreted as follows.
Reference: [KS96] <author> Henry Kautz and Bart Selman. </author> <title> Pushing the envelope: planning, propositional logic, and stochastic search. </title> <booktitle> Proc. 5 th National Conference on Artificial Intelligence, </booktitle> <year> 1996, </year> <pages> pp. 11941201. </pages>
Reference-contexts: The closest application to ours is in planning, where the problem of finding a plan that satisfies a set of constraints is reduced to finding a model of a boolean formula <ref> [KS96, EMW97] </ref>. The planning problem is technically closer to the model checking problem than to our problem: namely finding a sequence of transitions in a state machine that leads to a state satisfying a given property (in planning, the goal, and in model checking, the negation of the invariant).
Reference: [Ng97] <author> Yu-Chung Ng. </author> <title> A Nitpick Specification of IPv6. </title> <type> Senior Honors Thesis, </type> <institution> Computer Science Department, Carnegie Mellon Uni versity, </institution> <month> May </month> <year> 1997. </year> <month> 38 </month>
Reference-contexts: Using a variety of mechanisms to prune the search tree, it can analyze enormous configuration spaces. The tool has been used successfully to find flaws in a number of small designs, including a published draft of a mobile internet routing protocol <ref> [Ng97, JNW97] </ref>. Even small designs, however, tend to have huge configuration spaces. Indeed, this is perhaps why analysis of object configurations has not attracted the same attention as the analysis of state machines. <p> Allocate is a simplified fragment of a railway interlocking specification written in Z by Praxis UK PLC. The performance figures are for the claim Al-locSafe2. Mobile IP is a specification of a draft version of a mobile internet protocol for IPv6, written by an undergraduate at Carnegie Mellon <ref> [JNW97, Ng97] </ref>. The performance figures are for the claim loc_update_OK, which exposed a flaw in the protocol. 30 Table 1 is to be interpreted as follows.
Reference: [Sch79] <author> Wolfgang Schoenfeld. </author> <title> An undecidability result for relational algebras. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 44(1), </volume> <month> March </month> <year> 1979. </year>
Reference-contexts: This language is as expressive as first-order predicate logic (so long as we permit definition of projection functions so that tuples can be constructed), and is thus undecidable <ref> [Sch79] </ref>. The language includes, additionally, the transitive closure operator, which extends its expressiveness, and is indispensable in practice. We also add two 17 operators that add nothing in a formal sense, but which allow more efficient generation of boolean formulae.
Reference: [SKC94] <author> Bart Selman, Henry Kautz and Bram Cohen. </author> <title> Noise strategies for improving local search. </title> <booktitle> Proc. AAAI-94, </booktitle> <pages> pp. 337343, </pages> <year> 1994. </year>
Reference-contexts: We wrote a Davis-Putnam solver [DP60] using Zhang and Stickels trie-based representation of formulae [ZS94] in Java as part of the prototype. We also wrote code to generate input files for Selman and Kautzs WalkSAT solver <ref> [SKC94] </ref>, a descendant of GSAT [SLM92]. The two solvers are very different. WalkSAT, unlike Davis-Putnam, is incomplete: it may fail to find a satisfying assignment even though one exists.
Reference: [SLM92] <author> Bart Selman, Hector Levesque and David Mitchell. </author> <title> A new method for solving hard satisfiability problems. </title> <booktitle> Proc. 10 th tional Conference on Artificial Intelligence. </booktitle>
Reference-contexts: We wrote a Davis-Putnam solver [DP60] using Zhang and Stickels trie-based representation of formulae [ZS94] in Java as part of the prototype. We also wrote code to generate input files for Selman and Kautzs WalkSAT solver [SKC94], a descendant of GSAT <ref> [SLM92] </ref>. The two solvers are very different. WalkSAT, unlike Davis-Putnam, is incomplete: it may fail to find a satisfying assignment even though one exists. <p> The canonicity of BDDs is essential in the context of model checking, because it allows detection of fixed points. But for our problem, canonicity is unnecessary and its cost is not warranted. The remarkable success of the stochastic solver GSAT <ref> [SLM92] </ref> and its descendants has made boolean translation attractive in other domains too. The closest application to ours is in planning, where the problem of finding a plan that satisfies a set of constraints is reduced to finding a model of a boolean formula [KS96, EMW97].
Reference: [Spi92] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. Second ed, </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Section 17 gives some performance results that compare the new method to our previous explicit method. Section 18 and 19 discuss related work and future plans. 2 Relational Notation: NP Our notation, NP, is roughly a subset of Z <ref> [Spi92] </ref>. A reference manual [JD96b] describes the notation in detail.
Reference: [SS93] <author> Gunther Schmidt and Thomas Stroehlein. </author> <title> Relations and Graphs. </title> <booktitle> EATCS Monographs in Theoretical Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: [SU HTXDOLW" _flflH [SUflflH [SU VXEVHW H [SUfl flflfl,G LGHQWLW"flUHODWLRQflFRQVWDQW _fl8Q XQLYHUVDOflUHODWLRQflFRQVWDQW _fl HPSW"flUHODWLRQflFRQVWDQW _flH [SUflflH [SU XQLRQ _flH [SUflflH [SU LQWHUVHFWLRQ _flH [SUfl?flH [SU GLIIHUHQFH _flH [SUflflH [SU UHODWLRQDOflFRPSRVLWLRQ _flH [SUfla WUDQVSRVH _flH [SUflffi WUDQVLWLYHflFORVXUH _flH [SUflflH [SU GRPDLQflUHVWULFWLRQ _flGRPflH [SU GRPDLQ 18 A more elegant treatment of sets <ref> [SS93] </ref>, which we have used to justify re ductions in our explicit checker [JJD97], represents the set s as the relation ,Gflfl7flfl7 8Qflfl6flfl7 flfl6flfl7 Sfl6flfl7*flTfl6flfl7 SflflTflfl6flfl7 Sfl6flfl7*flTfl6flfl7 SflflTflfl6flfl7 Sfl6flfl7*flTfl6flfl7 Sfl?flTflfl6flfl7 Sfl6flfl7*flTfl7flfl9 SflflTflfl6flfl9 Sfl6flfl7 Saflfl7flfl6 Sfl7flfl7 Sffiflfl7flfl7 Sfl6flfl8QLW*flTfl6flfl7 SflflTflfl6flfl7 Sfl6flfl7 GRPflSflfl6flfl8QLW 19 corresponding to the cross product of s and the universal
Reference: [Tar41] <author> Alfred Tarski. </author> <title> On the calculus of relations. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 6(1941), </volume> <pages> pp. 7389. </pages>
Reference-contexts: These, along with the equality operator for obtaining formulae from terms, together constitute a basic relational language equivalent to Tarskis relational calculus <ref> [Giv88, Tar41] </ref>. This language is as expressive as first-order predicate logic (so long as we permit definition of projection functions so that tuples can be constructed), and is thus undecidable [Sch79]. The language includes, additionally, the transitive closure operator, which extends its expressiveness, and is indispensable in practice.
Reference: [ZS94] <author> Hantao Zhang and Mark E. Stickel. </author> <title> Implementing the Davis Putnam Algorithm b yTries. </title> <type> Technical Report 94-12, </type> <institution> Artificial Intelligence Center, SRI International, </institution> <address> Menlo Park, CA. De cember 1994. </address> <month> 39 </month>
Reference-contexts: Eliminating redundant clauses early on can have an enormous effect on the size of intermediate formulae. Our prototype uses a trie-based representation developed by Zhang and Stickel <ref> [ZS94] </ref>. Using tries naturally eliminates some redundancy since literals in clauses are lexically ordered, and prefixes are shared, it is easy to ensure that a clause never appears with one of its prefixes. The trie also supports a simple and efficient implementation of the Davis-Putnam satisfi-ability algorithm [DP60]. <p> Problematic elementary formulae that cannot be handled by symmetry breaking (because all types have been consumed) might be handled in this way. 29 16 Solving the Boolean Formula We have experimented with two solvers. We wrote a Davis-Putnam solver [DP60] using Zhang and Stickels trie-based representation of formulae <ref> [ZS94] </ref> in Java as part of the prototype. We also wrote code to generate input files for Selman and Kautzs WalkSAT solver [SKC94], a descendant of GSAT [SLM92]. The two solvers are very different.
References-found: 24

