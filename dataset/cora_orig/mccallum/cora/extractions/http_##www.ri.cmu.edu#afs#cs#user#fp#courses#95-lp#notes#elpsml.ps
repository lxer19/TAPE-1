URL: http://www.ri.cmu.edu/afs/cs/user/fp/courses/95-lp/notes/elpsml.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/fp/courses/95-lp/notes/
Root-URL: 
Title: A Semi-Functional Implementation of a Higher-Order Logic Programming Language  
Author: Conal Elliott Frank Pfenning 
Date: February 1990  
Note: Draft of  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Anthony J. Bonner, L. Thorne McCarty, and Kumar Vadaparty. </author> <title> Expressing database queries with intuitionistic logic. </title> <editor> In Ewing Lusk and Ross Overbeek, editors, </editor> <booktitle> Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 831-850, </pages> <address> Cambridge, Massachusetts, 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: We then move on to first-order Horn logic, which is very much in the tradition of Prolog. In Section 4 we generalize this to include embedded 1 implication and universal quantification (see <ref> [1, 11, 21] </ref> for the motivation for these constructs) which complicates primarily unification. In Section 5 we introduce side-effects and assignment in a controlled way to increase the efficiency of unification. <p> This means that a goal can be an implication (called embedded implication) or a universally quantified formula (embedded universal quantification). For some general motivation for these constructs refer to <ref> [1, 12, 11, 21, 25] </ref>.
Reference: [2] <author> Mats Carlsson. </author> <title> On implementing Prolog in functional programming. </title> <journal> New Generation Computing, </journal> <volume> 2(4) </volume> <pages> 347-359, </pages> <year> 1984. </year>
Reference-contexts: One might also miss a discussion of compilation, which is not very well understood in this context and is the subject of current research [24]. We begin with an interpreter for propositional Horn logic, which introduces the central technique of the success continuation, due to Carlsson <ref> [2] </ref>. We then move on to first-order Horn logic, which is very much in the tradition of Prolog. In Section 4 we generalize this to include embedded 1 implication and universal quantification (see [1, 11, 21] for the motivation for these constructs) which complicates primarily unification. <p> The fundamental idea of the formulation as a functional program is that of a success continuation due to Carlsson <ref> [2] </ref>. The obvious arguments to solve are the current goal and program. The non-obvious argument is the success-continuation sc. sc is a function (of no arguments) that is to be called when the current goal succeeds.
Reference: [3] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: By higher-order programming we mean the ability of programs to construct other programs (to be assumed) and other goals (to be invoked). In Prolog some semblance of such a facility is provided through the call primitive. Here we have a higher-order term language, and, following Church <ref> [3] </ref>, we introduce a distinguished type of propositions (o) and constants representing the logical quantifiers and connectives.
Reference: [4] <author> Thierry Coquand and Gerard Huet. </author> <title> The Calculus of Constructions. </title> <journal> Information and Computation, </journal> 76(2/3):95-120, February/March 1988. 
Reference-contexts: This basic approach, though different in various details, is taken in the Calculus of Constructions <ref> [4] </ref>. The representation of terms is perhaps more direct, but less efficient than deBruijn indices [5] which are used in eLP and almost all other modern implementations of -calculi which require access to the internal structure of -terms.
Reference: [5] <author> N. G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: This basic approach, though different in various details, is taken in the Calculus of Constructions [4]. The representation of terms is perhaps more direct, but less efficient than deBruijn indices <ref> [5] </ref> which are used in eLP and almost all other modern implementations of -calculi which require access to the internal structure of -terms.
Reference: [6] <author> Conal Elliott. </author> <title> Extensions and Applications of Higher-order Unification. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1990. </year> <note> Available as Technical Report CMU-CS-90-134, </note> <institution> Carnegie Mel-lon University, Pittsburgh. </institution>
Reference-contexts: The type of a constant is accessible in a signature which maps names of constants to their types, implemented, for example, as a list of pairs of strings and types. The unification procedure we use is based on the one in <ref> [6, 7] </ref> for higher-order unification with dependent types, which itself is an extension of Huet's procedure for (higher-order) unification in 24 the simply typed -calculus [18]. <p> At least in the LF sub-calculus, these disagreement sets are always unifiable when they arise <ref> [6] </ref>. The "MATCH" phase examines a flexible-rigid disagreement pair, instantiates the logic variable at the head of the flexible term, and calls the success continuation on an augmented disagreement set. Upon backtracking, further instantiations may be tried. Once all possibilities are exhausted MATCH returns. The interested reader can consult [6] for <p> arise <ref> [6] </ref>. The "MATCH" phase examines a flexible-rigid disagreement pair, instantiates the logic variable at the head of the flexible term, and calls the success continuation on an augmented disagreement set. Upon backtracking, further instantiations may be tried. Once all possibilities are exhausted MATCH returns. The interested reader can consult [6] for an explanation and justification of these instantiations, as well as completeness proofs. Actually, completeness can in general only be guaranteed for a subcalculus where logic variables do not occur at the head of types.
Reference: [7] <author> Conal Elliott. </author> <title> Higher-order unification with dependent types. </title> <booktitle> In Rewriting Techniques and Applications, </booktitle> <pages> pages 121-136. </pages> <publisher> Springer-Verlag LNCS 355, </publisher> <month> April </month> <year> 1989. </year> <note> 13 Please send mail to the second author at fp@cs.cmu.edu for more information. 32 </note>
Reference-contexts: The type of a constant is accessible in a signature which maps names of constants to their types, implemented, for example, as a list of pairs of strings and types. The unification procedure we use is based on the one in <ref> [6, 7] </ref> for higher-order unification with dependent types, which itself is an extension of Huet's procedure for (higher-order) unification in 24 the simply typed -calculus [18].
Reference: [8] <author> Conal Elliott and Frank Pfenning. eLP: </author> <title> A Common Lisp implementation of Prolog in the Ergo Support System. Available via ftp over the Internet, </title> <month> October </month> <year> 1989. </year> <title> Send mail to elp-request@cs.cmu.edu on the Internet for further information. </title>
Reference-contexts: The logic programming language is closely related to Prolog [25], though the type system supported by our implementation is more general, for example by allowing explicit abstraction over types. The implementation is closely modeled after eLP, an implementation of Prolog in the Ergo Support System <ref> [8, 20] </ref> and may be considered as a rational reconstruction and explanation of the eLP implementation. <p> The eLP implementation <ref> [8] </ref> plays even more tricks with the initial success continuation: it presents the first solution, but then works ahead without waiting for instructions as to whether additional solutions are required. If an externally visible side-effect is just about to be executed, it suspends. <p> of Dflex (M') =&gt; raise error ("clausify: Program " ^ term_makestring (M') ^ " with variable head predicate.") | d =&gt; clausify d body vars rest) 31 10 Conclusion The interpreter we have developed is relatively close to eLP, our Common Lisp implementation of Prolog in the Ergo Support System <ref> [8, 20] </ref>. Most of the differences have already been mentioned: clauses are indexed and stored in a global hashtable, bound variables are represented by deBruijn indices and parameters and logic variables are time-stamped for comparison and unification of terms that have not been Skolemized.
Reference: [9] <author> Matthias Felleisen. </author> <title> Transliterating Prolog into Scheme. </title> <type> Technical Report 182, </type> <institution> Indiana University, Bloomington, Indiana, </institution> <month> October </month> <year> 1985. </year>
Reference-contexts: Our approach is to write a true interpreter, and not to embed Prolog in ML the way Prolog is embedded in Scheme in <ref> [9] </ref> and [17]. The primary difference is that we separate carefully the name space of predicates of the logic programming language from the name space of functions in ML.
Reference: [10] <author> Amy Felty. </author> <title> Specifying and Implementing Theorem Provers in a Higher-Order Logic Programming Language. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: This is sufficient for many application programs (see, for example, <ref> [10] </ref>), but there are instances where it is very elegant and natural to allow true higher-order programming. By higher-order programming we mean the ability of programs to construct other programs (to be assumed) and other goals (to be invoked).
Reference: [11] <author> D. M. Gabbay. N-prolog: </author> <title> an extension of Prolog with hypothetical implications II. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(4) </volume> <pages> 251-283, </pages> <year> 1985. </year>
Reference-contexts: We then move on to first-order Horn logic, which is very much in the tradition of Prolog. In Section 4 we generalize this to include embedded 1 implication and universal quantification (see <ref> [1, 11, 21] </ref> for the motivation for these constructs) which complicates primarily unification. In Section 5 we introduce side-effects and assignment in a controlled way to increase the efficiency of unification. <p> This means that a goal can be an implication (called embedded implication) or a universally quantified formula (embedded universal quantification). For some general motivation for these constructs refer to <ref> [1, 12, 11, 21, 25] </ref>.
Reference: [12] <author> D. M. Gabbay and U. Reyle. N-prolog: </author> <title> an extension of Prolog with hypothetical implications I. </title> <journal> Journal of Logic Programming, </journal> <volume> 1(4) </volume> <pages> 319-355, </pages> <year> 1985. </year>
Reference-contexts: This means that a goal can be an implication (called embedded implication) or a universally quantified formula (embedded universal quantification). For some general motivation for these constructs refer to <ref> [1, 12, 11, 21, 25] </ref>.
Reference: [13] <author> Michael J. Gordon, Robin Milner, and Christopher P. </author> <title> Wadsworth. </title> <publisher> Edinburgh LCF. Springer-Verlag LNCS 78, </publisher> <year> 1979. </year>
Reference-contexts: give a warning in such a case, if desired. 8.3 Rewriting Because we are using transformations as a fundamental structuring device in the implementation of unification, we adopted a very elegant technique from Paulson's higher-order implementation of rewriting [27], which itself was patterned after the tactics and tacticals in LCF <ref> [13] </ref>. Because we are not worried about having our implementation prove the correctness of applications of its transformations, we can use a somewhat simpler implementation than in [27].
Reference: [14] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <note> Submitted. A preliminary version appeared in Symposium on Logic in Computer Science, pages 194-204, </note> <month> June </month> <year> 1987, </year> <month> January </month> <year> 1989. </year>
Reference-contexts: If we were only interested in implementing a logic programming language over the simply typed -calculus without polymorphism this would be unnecessarily complicated, but we are interested in including dependent types (in the form of LF <ref> [14] </ref>) and polymorphism, at which point it is convenient to have to write only one function each for substitution and unification, rather than two (one for unifying terms and one for unifying types, for example).
Reference: [15] <author> Robert Harper, Robin Milner, Kevin Mitchell, Nick Rothwell, and Don Sannella. </author> <title> Functional programming in Standard ML. </title> <note> Notes to a five day course given at the University of Edinburgh, </note> <month> April </month> <year> 1988. </year>
Reference-contexts: Prior knowledge of ML is assumed, but not at a very deep or sophisticated level (see <ref> [15] </ref> for an SML tutorial). We try to emphasize programming techniques as well as the gradual development of the interpreter in its full generality from a very simple starting point.
Reference: [16] <author> Robert Harper and Robert Pollack. </author> <title> Type checking, universe polymorphism, and typical ambiguity in the Calculus of Constructions. </title> <booktitle> In TAPSOFT '89, Proceedings of the International Joint Conference on Theory and Practice in Software Development, Barcelona, Spain, </booktitle> <pages> pages 241-256. </pages> <publisher> Springer-Verlag LNCS 352, </publisher> <month> March </month> <year> 1989. </year>
Reference-contexts: And, yes, type is a type, though this could be avoided by introducing universes (see <ref> [16] </ref>) without any changes to the code of the unifier. As is customary, we use A ! B as an abbreviation for x : A: B if x does not occur free in B.
Reference: [17] <author> Christopher T. Haynes. </author> <title> Logic continuations. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(2) </volume> <pages> 157-176, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Our approach is to write a true interpreter, and not to embed Prolog in ML the way Prolog is embedded in Scheme in [9] and <ref> [17] </ref>. The primary difference is that we separate carefully the name space of predicates of the logic programming language from the name space of functions in ML.
Reference: [18] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: The unification procedure we use is based on the one in [6, 7] for higher-order unification with dependent types, which itself is an extension of Huet's procedure for (higher-order) unification in 24 the simply typed -calculus <ref> [18] </ref>. This procedure is most easily understood in terms of a collection of "transformations," some on terms, some on pairs of terms being unified, and some on sets of such pairs.
Reference: [19] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the Fourteenth Annual ACM Symposium on Principles of Programming Languages, Munich, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1987. </year>
Reference-contexts: Though somewhat 22 more general through our use of types, implication, and explicit quantification, our language now becomes a constraint logic programming language in the sense of Jaffar and Lassez <ref> [19] </ref>.
Reference: [20] <author> Peter Lee, Frank Pfenning, Gene Rollins, and William Scherlis. </author> <title> The Ergo Support System: An integrated set of tools for prototyping integrated environments. </title> <editor> In Peter Henderson, editor, </editor> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 25-34. </pages> <publisher> ACM Press, </publisher> <month> November </month> <year> 1988. </year> <note> Also available as Ergo Report 88-054, </note> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh. </institution> <month> 33 </month>
Reference-contexts: The logic programming language is closely related to Prolog [25], though the type system supported by our implementation is more general, for example by allowing explicit abstraction over types. The implementation is closely modeled after eLP, an implementation of Prolog in the Ergo Support System <ref> [8, 20] </ref> and may be considered as a rational reconstruction and explanation of the eLP implementation. <p> of Dflex (M') =&gt; raise error ("clausify: Program " ^ term_makestring (M') ^ " with variable head predicate.") | d =&gt; clausify d body vars rest) 31 10 Conclusion The interpreter we have developed is relatively close to eLP, our Common Lisp implementation of Prolog in the Ergo Support System <ref> [8, 20] </ref>. Most of the differences have already been mentioned: clauses are indexed and stored in a global hashtable, bound variables are represented by deBruijn indices and parameters and logic variables are time-stamped for comparison and unification of terms that have not been Skolemized.
Reference: [21] <author> Dale Miller. </author> <title> A logical analysis of modules in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 6(1-2):57-77, </volume> <month> January </month> <year> 1989. </year>
Reference-contexts: We then move on to first-order Horn logic, which is very much in the tradition of Prolog. In Section 4 we generalize this to include embedded 1 implication and universal quantification (see <ref> [1, 11, 21] </ref> for the motivation for these constructs) which complicates primarily unification. In Section 5 we introduce side-effects and assignment in a controlled way to increase the efficiency of unification. <p> This means that a goal can be an implication (called embedded implication) or a universally quantified formula (embedded universal quantification). For some general motivation for these constructs refer to <ref> [1, 12, 11, 21, 25] </ref>.
Reference: [22] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Journal of Pure and Applied Logic, </journal> <note> 1988. To appear. Available as Ergo Report 88-055, </note> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh. </institution>
Reference-contexts: Note that the argument G will be passed as a term, but has to be converted to a goal before it can be invoked. If we implemented strictly higher-order hereditary Harrop formulas (see <ref> [22] </ref>), some of the work below would not be necessary, but in practice it is important not to restrict statically to D-formulas and G-formulas whose predicate symbol is fixed and known at the time where terms are translated into propositions.
Reference: [23] <author> Dale A. Miller. </author> <title> Unification under mixed prefixes. </title> <type> Unpublished manuscript, </type> <year> 1987. </year>
Reference-contexts: Unification also differs: the one given here supports a much richer -calculus, but does not implement a number of important optimizations (see <ref> [23] </ref>) used in eLP. Finally, there are a number of design mistakes which are still part of the current eLP implementation which we chose not to expose here.
Reference: [24] <author> Gopalan Nadathur and Bharat Jayaraman. </author> <title> Towards a WAM model for lambda Prolog. </title> <booktitle> In Proceedings of the 1989 North American Conference on Logic Programming, </booktitle> <pages> pages 1180-1198. </pages> <publisher> MIT Press, </publisher> <month> October </month> <year> 1989. </year>
Reference-contexts: One might also miss a discussion of compilation, which is not very well understood in this context and is the subject of current research <ref> [24] </ref>. We begin with an interpreter for propositional Horn logic, which introduces the central technique of the success continuation, due to Carlsson [2]. We then move on to first-order Horn logic, which is very much in the tradition of Prolog. <p> We expect that the next set of significant improvements in the implementation techniques for Prolog and related languages will come from a more economical representation of -terms [26] and the development of compilation technology <ref> [24] </ref>. We conclude with the remark that the complete Standard ML code for all versions of the interpreter discussed here including a modest front end are available via ftp over the Internet. 13
Reference: [25] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <volume> Volume 1, </volume> <pages> pages 810-827, </pages> <address> Cambridge, Massachusetts, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: 1 Introduction In this chapter we develop an interpreter of a higher-order constraint logic programming language in Standard ML (SML). The logic programming language is closely related to Prolog <ref> [25] </ref>, though the type system supported by our implementation is more general, for example by allowing explicit abstraction over types. <p> This means that a goal can be an implication (called embedded implication) or a universally quantified formula (embedded universal quantification). For some general motivation for these constructs refer to <ref> [1, 12, 11, 21, 25] </ref>.
Reference: [26] <author> Gopalan Nadathur and Debra Sue Wilson. </author> <title> A representation of lambda terms suitable for operations on their intensions. </title> <booktitle> In Proceedings of the 1990 Conference on Lisp and Functional Programming. </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1990. </year> <note> To appear. </note>
Reference-contexts: We expect that the next set of significant improvements in the implementation techniques for Prolog and related languages will come from a more economical representation of -terms <ref> [26] </ref> and the development of compilation technology [24]. We conclude with the remark that the complete Standard ML code for all versions of the interpreter discussed here including a modest front end are available via ftp over the Internet. 13
Reference: [27] <author> Lawrence Paulson. </author> <title> A higher-order implementation of rewriting. </title> <booktitle> Science of Computer Programing, </booktitle> <volume> 3 </volume> <pages> 119-149, </pages> <year> 1983. </year> <month> 34 </month>
Reference-contexts: there is a possibility for incompleteness on a particular execution and can give a warning in such a case, if desired. 8.3 Rewriting Because we are using transformations as a fundamental structuring device in the implementation of unification, we adopted a very elegant technique from Paulson's higher-order implementation of rewriting <ref> [27] </ref>, which itself was patterned after the tactics and tacticals in LCF [13]. Because we are not worried about having our implementation prove the correctness of applications of its transformations, we can use a somewhat simpler implementation than in [27]. <p> adopted a very elegant technique from Paulson's higher-order implementation of rewriting <ref> [27] </ref>, which itself was patterned after the tactics and tacticals in LCF [13]. Because we are not worried about having our implementation prove the correctness of applications of its transformations, we can use a somewhat simpler implementation than in [27]. The basic kind of object we deal with we call a rewriter, which is simply a partial function from some type to itself| "partial" because it may fail to apply (which is communicated by a raised exception) as well as fail to terminate.
References-found: 27

