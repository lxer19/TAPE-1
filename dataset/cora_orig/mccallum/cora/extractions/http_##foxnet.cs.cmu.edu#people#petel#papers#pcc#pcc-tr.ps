URL: http://foxnet.cs.cmu.edu/people/petel/papers/pcc/pcc-tr.ps
Refering-URL: http://foxnet.cs.cmu.edu/people/petel/papers/pcc/pcc.html
Root-URL: 
Title: Proof-Carrying Code  
Author: George C. Necula Peter Lee 
Note: This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software," ARPA Order No. C533, issued by ESC/ENS under Contract No. F19628-95-C-0050. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Advanced Research Projects Agency or the U.S. Government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: September 1996  
Pubnum: CMU-CS-96-165  
Abstract: This report describes Proof-Carrying Code, a software mechanism that allows a host system to determine with certainty that it is safe to execute a program supplied by an untrusted source. For this to be possible, the untrusted code supplier must provide with the code a safety proof that attests to the code's safety properties. The code consumer can easily and quickly validate the proof without using cryptography and without consulting any external agents. In order to gain preliminary experience with proof-carrying code, we have performed a series of case studies. In one case study, we write safe assembly-language network packet filters. These filters can be executed with no run-time overhead, beyond a one-time cost of 1 to 3 milliseconds for validating the attached proofs. The net result is that our packet filters are formally guaranteed to be safe and are faster than packet filters created using Berkeley Packet Filters, Software Fault Isolation, or safe languages such as Modula-3. In another case study we show how proof-carrying code can be used to develop safe assembly-language extensions of the a simplified version of the TIL run-time system for Standard ML. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bershad, B., Savage, S., Pardyak, P., Sirer, E. G., Becker, D., Fiuczynski, M., Chambers, C., and Eggers, S. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Symposium on Operating System Principles (Dec. </booktitle> <year> 1995), </year> <pages> pp. 267-284. </pages>
Reference-contexts: Proof sizes and validation times are very similar to those for plain PCC packets. Another approach to safe code is to use a type-safe programming language. This approach is taken by the SPIN extensible operating system <ref> [1] </ref>, and the language used is Modula-3 [17] extended with pointer-safe casting (VIEW). SPIN allows applications to install extensions in the kernel but only if they are written in the safe subset of Modula-3.
Reference: [2] <author> Boyer, R. S., and Yu, Y. </author> <title> Automated proofs of object code for a widely used microprocessor. </title> <journal> J. ACM 43, </journal> <month> 1 (Jan. </month> <year> 1996), </year> <pages> 166-192. </pages>
Reference-contexts: We have also shown a way to use standard verification techniques to check type safety at the assembly-language level. This is important for certifying extensions to safe programming languages and as a main building block in constructing certifying compilers. Similar techniques have been applied to assembly language before <ref> [2, 3] </ref> but neither as a basis for creating safety proofs nor for checking type safety. We show an encoding of safety proofs as first-order logic derivations in LF.
Reference: [3] <author> Clutterbuck, D., and Carr e, B. </author> <title> The verification of low-level code. </title> <journal> IEEE Software Engineering Journal 3, </journal> <month> 3 (May </month> <year> 1988), </year> <pages> 97-111. </pages>
Reference-contexts: We have also shown a way to use standard verification techniques to check type safety at the assembly-language level. This is important for certifying extensions to safe programming languages and as a main building block in constructing certifying compilers. Similar techniques have been applied to assembly language before <ref> [2, 3] </ref> but neither as a basis for creating safety proofs nor for checking type safety. We show an encoding of safety proofs as first-order logic derivations in LF.
Reference: [4] <author> Constable, R. L., Allen, S. F., Bromley, H. M., Cleaveland, W. R., Cremer, J. F., Harper, R. W., Howe, D. J., Knoblock, T. B., Mendler, N. P., Panangaden, P., Sasaki, J. T., and Smith, S. F. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: 0 ; r 7 ; r 0 in r 16 and its length in r 17 . 53 8 Practical Difficulties Although we have worked out many of the theoretical underpinnings for PCC (and indeed, most of the theory is based on old and well-known principles from logic, type theory <ref> [4, 11] </ref>, and formal verification [5, 6, 8]), there are many difficult problems that remain to be solved. In this section we discuss some of the problematic issues that were brought to light by our experiment.
Reference: [5] <author> Dijkstra, E. W. </author> <title> Guarded commands, nondeterminancy and formal derivation of programs. </title> <booktitle> Communications of the ACM 18 (1975), </booktitle> <pages> 453-457. </pages>
Reference-contexts: r 0 in r 16 and its length in r 17 . 53 8 Practical Difficulties Although we have worked out many of the theoretical underpinnings for PCC (and indeed, most of the theory is based on old and well-known principles from logic, type theory [4, 11], and formal verification <ref> [5, 6, 8] </ref>), there are many difficult problems that remain to be solved. In this section we discuss some of the problematic issues that were brought to light by our experiment.
Reference: [6] <author> Floyd, R. W. </author> <title> Assigning meanings to programs. </title> <booktitle> In Mathematical Aspects of Computer Science, </booktitle> <editor> J. T. Schwartz, Ed. </editor> <publisher> American Mathematical Society, </publisher> <year> 1967, </year> <pages> pp. 19-32. </pages>
Reference-contexts: r 0 in r 16 and its length in r 17 . 53 8 Practical Difficulties Although we have worked out many of the theoretical underpinnings for PCC (and indeed, most of the theory is based on old and well-known principles from logic, type theory [4, 11], and formal verification <ref> [5, 6, 8] </ref>), there are many difficult problems that remain to be solved. In this section we discuss some of the problematic issues that were brought to light by our experiment.
Reference: [7] <author> Harper, R., Honsell, F., and Plotkin, G. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery 40, </journal> <month> 1 (Jan. </month> <year> 1993), </year> <pages> 143-184. </pages>
Reference-contexts: For this fragment, called LF 0 , we show the typing rules and the adequacy of the encoding of predicates and derivations. 3.2 LF 0 Type Checking In this section we introduce LF 0 , a fragment of full LF defined in <ref> [7] </ref>. The benefits of using LF 0 instead of full LF for proof representation and validation is that LF 0 admits a simpler type-checking algorithm that is still complete for our purposes. The results that we are deriving in this section for LF 0 mirror similar results for full LF [7]. <p> <ref> [7] </ref>. The benefits of using LF 0 instead of full LF for proof representation and validation is that LF 0 admits a simpler type-checking algorithm that is still complete for our purposes. The results that we are deriving in this section for LF 0 mirror similar results for full LF [7]. The first observation is that LF 0 has the same syntactical elements as full LF. As a consequence the signature and LF representation function presented in the previous subsection are inherited to LF 0 . <p> This means that the type of all constants involved are at most second-order and in all abstractions the type of the argument is first-order. This is enough for representing a wide array of first-order and higher-order logics <ref> [7] </ref>. The benefit gained is that the normalization judgment is syntax directed and admits simple and efficient implementations. Intuitively, functions can only be applied to atomic arguments, which when substituted in the body of the function cannot generate new redices. <p> Finally, by examination of the LF encoding functions we notice that only LF objects in canonical form are produced. This is in fact a crucial technical detail in the proofs of adequacy in <ref> [7] </ref>. In LF 0 we define typing judgments only for objects in canonical form, thus simplifying the typing rules and the adequacy proofs. An object is in canonical form if it is in fi-long-normal-form. We start by defining canonical forms for objects and types. <p> At the same time, by typechecking the representation of a proof we can check the identity of the proved predicate. This property is called in the literature <ref> [7] </ref> the adequacy of the proof representation. We state below the adequacy theorems for expression, predicate and proof representation as defined by the signature . The proofs for the adequacy theorems follow closely the model of similar adequacy theorems for full LF in [7]. <p> This property is called in the literature <ref> [7] </ref> the adequacy of the proof representation. We state below the adequacy theorems for expression, predicate and proof representation as defined by the signature . The proofs for the adequacy theorems follow closely the model of similar adequacy theorems for full LF in [7]. Technically, the proofs are somewhat simpler for LF 0 because of the syntax-directed form of the typing judgments and canonical forms. If we extend the signature of first-order predicate logic with first-order proof constants, the adequacy still holds because typically problems only arise for hypothetical and parametric judgements.
Reference: [8] <author> Hoare, C. A. R. </author> <title> An axiomatic basis for computer programming. </title> <booktitle> Communications of the ACM 12 (1969), </booktitle> <pages> 567-580. </pages>
Reference-contexts: r 0 in r 16 and its length in r 17 . 53 8 Practical Difficulties Although we have worked out many of the theoretical underpinnings for PCC (and indeed, most of the theory is based on old and well-known principles from logic, type theory [4, 11], and formal verification <ref> [5, 6, 8] </ref>), there are many difficult problems that remain to be solved. In this section we discuss some of the problematic issues that were brought to light by our experiment.
Reference: [9] <author> Hsieh, W. C., Fiuczynski, M. E., Garrett, C., Savage, S., Becker, D., and Ber-shad, B. N. </author> <title> Language support for extensible operating systems. </title> <booktitle> In The Inaugural Workshop on Compiler Support for Systems Software (Feb. </booktitle> <year> 1996), </year> <pages> pp. 127-133. </pages>
Reference-contexts: In our experiments with Modula-3 packet filters we use the VIEW extension <ref> [9] </ref> for pointer-safe casting. The result of the measurements are shown in Figure 26. From a per-packet latency point of view, the PCC packet filters outperform filters developed using any other considered approach. However, the PCC method has a startup cost significantly larger than the other approaches.
Reference: [10] <author> Lee, P., and Leone, M. </author> <title> Optimizing ML with run-time code generation. </title> <booktitle> In PLDI'96 Conference on Programming Language Design and Implementation (May 1996), </booktitle> <pages> pp. 137-148. </pages>
Reference-contexts: It is possible, of course, to eliminate the need for interpretation. For example, we could replace the packet-filter interpreter with a compiler. This approach is taken by several researchers <ref> [10, 25] </ref>. The problem here is the startup cost and complexity of compilation, especially if serious optimizations are performed. 41 Another approach to safe code execution is Software Fault Isolation (SFI) [24]. SFI is an inexpensive method for parsing binaries and inserting run-time checks on memory operations.
Reference: [11] <author> Martin-L of, P. </author> <title> A theory of types. </title> <type> Technical Report 71-3, </type> <institution> Department of Mathematics, University of Stockholm, </institution> <year> 1971. </year>
Reference-contexts: 0 ; r 7 ; r 0 in r 16 and its length in r 17 . 53 8 Practical Difficulties Although we have worked out many of the theoretical underpinnings for PCC (and indeed, most of the theory is based on old and well-known principles from logic, type theory <ref> [4, 11] </ref>, and formal verification [5, 6, 8]), there are many difficult problems that remain to be solved. In this section we discuss some of the problematic issues that were brought to light by our experiment.
Reference: [12] <author> McCanne, S. </author> <title> The Berkeley Packet Filter man page. </title> <note> BPF distribution available at ftp://ftp.ee.lbl.gov, </note> <month> May </month> <year> 1991. </year> <month> 59 </month>
Reference: [13] <author> McCanne, S., and Jacobson, V. </author> <title> The BSD packet filter: A new architecture for user-level packet capture. </title> <booktitle> In The Winter 1993 USENIX Conference (Jan. 1993), USENIX Association, </booktitle> <pages> pp. 259-269. </pages>
Reference-contexts: The standard way to ensure safe execution of packet filters is to interpret the filter and perform extensive run-time checks. This approach is best exemplified by the BSD Packet Filter architecture <ref> [13] </ref>, commonly referred to as BPF. In the BPF approach the filter is encoded in a restricted accumulator-based language. According to the BPF semantics, a filter that attempts to read outside the packet or the scratch memory, or to write outside the scratch memory, is terminated and the packet rejected.
Reference: [14] <author> Miller, D., Nadathur, G., Pfenning, F., and Scedrov, A. </author> <title> Uniform proofs as a foundation for logic programming. </title> <booktitle> Annals of Pure and Applied Logic 51 (1991), </booktitle> <pages> 125-157. </pages>
Reference-contexts: are a few optimizations that we incorporated in our packet filters: * The number of memory operations is minimized by using the DEC Alpha 64-bit load followed by byte extraction. * The TCP port number can be found at packet offset (<ref> [14] </ref> 8 & 15) fl 4 + 16, where [14] 8 denotes the byte at offset 14. If loading 64 bits at a time on a little-endian machine, the formula becomes ((([8] 64 48) & 255) & 15) fl 4 + 16. <p> These fragments of first-order logic admit a complete sequent-style proof system where the declarative meaning of logical connectors coincides with their search-related reading <ref> [14] </ref>. The resulting proofs are called uniform. The LF representation of an uniform proof system for our logic can then be used as a logic program to perform proof search. We represent in LF the uniform derivation rules for our logic in a manner similar to the natural deduction representation.
Reference: [15] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: To make the presentation more concrete we show in detail how we use PCC to develop safe DEC Alpha assembly-language [21] extensions to the run-time system of the TIL [23] compiler for Standard ML <ref> [15] </ref>. We consider here only a very small example with several simplifying assumptions. For example, we only consider leaf procedures that do not allocate memory. Scaling the technique to the entire Standard ML language is subject of current research. Consider the Standard ML program fragment shown in Figure 29.
Reference: [16] <author> Mogul, J. C., Rashid, R. F., and Accetta, M. J. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In ACM Symposium on Operating Systems Principles (Nov. 1987), </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 39-51. </pages> <note> An updated version is available as DEC WRL Research Report 87/2. </note>
Reference-contexts: A packet filter is an application-provided subroutine that scans each incoming network packet and decides whether the user application is interested in receiving it or not. Packet filters are supported by most of today's workstation operating systems. Since their first introduction in <ref> [16] </ref>, packet filters have been used successfully in network monitoring and diagnosis. 5.1 The Safety Policy In our approach a packet filter is a PCC binary whose native code component is invoked by the kernel on each incoming network packet. Kernel safety is ensured by validating the safety proof.
Reference: [17] <author> Nelson, G. </author> <title> Systems Programming with MODULA-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Proof sizes and validation times are very similar to those for plain PCC packets. Another approach to safe code is to use a type-safe programming language. This approach is taken by the SPIN extensible operating system [1], and the language used is Modula-3 <ref> [17] </ref> extended with pointer-safe casting (VIEW). SPIN allows applications to install extensions in the kernel but only if they are written in the safe subset of Modula-3.
Reference: [18] <author> Pfenning, F. </author> <title> Elf: A language for logic definition and verified meta-programming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science (Pacific Grove, </booktitle> <address> California, June 1989), </address> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 313-322. </pages>
Reference-contexts: This also means that the native code must be accompanied by a loop invariant for every loop. We currently produce the proofs using a very simple theorem prover that outputs a witness for every successful proof. For our experiments we use the programming language Elf <ref> [18] </ref> to prove VC predicates and produce LF representation of their proofs. Elf is a logic programming language based on LF. A program in Elf is an LF signature and execution in Elf is search for canonical LF objects inhabiting an LF type in the context of a signature.
Reference: [19] <author> Rouaix, F. </author> <title> A Web navigator with applets in Caml. </title> <booktitle> Proceedings of the 5th International World Wide Web Conference, in Computer Networks and Telecommunications Networking 28, </booktitle> <month> 7-11 (May </month> <year> 1996), </year> <pages> 1365-1371. </pages>
Reference: [20] <author> Sirer, E. G., Savage, S., Pardyak, P., DeFouw, G. P., and Bershad, B. N. </author> <title> Writing an operating system with Modula-3. </title> <booktitle> In The Inaugural Workshop on Compiler Support for Systems Software (Feb. </booktitle> <year> 1996), </year> <pages> pp. 134-140. </pages>
Reference-contexts: We measured a 20% improvement in the Modula-3 packet filter performance when using VIEW. Similar performance improvements over the DEC SRC Modula-3 compiler have been reported <ref> [20] </ref> for the more recent Vortex compiler. However, since we have not conducted any experiments with the Vortex compiler on our packet filters, it is not clear what kind of improvements we would realize in practice.
Reference: [21] <author> Sites, R. L. </author> <title> Alpha Architecture Reference Manual. </title> <publisher> Digital Press, </publisher> <year> 1992. </year>
Reference-contexts: Then, the user produces and attaches to the foreign code a safety proof attesting to the preservation of the invariants. To make the presentation more concrete we show in detail how we use PCC to develop safe DEC Alpha assembly-language <ref> [21] </ref> extensions to the run-time system of the TIL [23] compiler for Standard ML [15]. We consider here only a very small example with several simplifying assumptions. For example, we only consider leaf procedures that do not allocate memory.
Reference: [22] <author> Sun Microsystems. </author> <title> The Java Virtual Machine specification. </title> <note> Available as ftp://ftp.javasoft.com/docs/vmspec.ps.zip, </note> <year> 1995. </year>
Reference-contexts: Also, the cost of managing and transmitting encryption keys is not incurred by PCC. We should mention here one more approach to safe code execution, although we do not have an actual quantitative comparison. The Java Virtual Machine <ref> [22] </ref> is a proposed solution to safe interaction of distributed, untrusted agents. Mobile code is encoded in the Java Virtual Machine Language (also referred to as Java Bytecode), which is basically a safe low-level imperative language. Safety is achieved through a combination of static typechecking and run-time checking.
Reference: [23] <author> Tarditi, D., Morrisett, J. G., Cheng, P., Stone, C., Harper, R., and Lee, P. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In PLDI'96 Conference on Programming Language Design and Implementation (May 1996), </booktitle> <pages> pp. 181-192. </pages>
Reference-contexts: Then, the user produces and attaches to the foreign code a safety proof attesting to the preservation of the invariants. To make the presentation more concrete we show in detail how we use PCC to develop safe DEC Alpha assembly-language [21] extensions to the run-time system of the TIL <ref> [23] </ref> compiler for Standard ML [15]. We consider here only a very small example with several simplifying assumptions. For example, we only consider leaf procedures that do not allocate memory. Scaling the technique to the entire Standard ML language is subject of current research.
Reference: [24] <author> Wahbe, R., Lucco, S., Anderson, T. E., and Graham, S. L. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In 14th ACM Symposium on Operating Systems Principles (Dec. 1993), ACM, </booktitle> <pages> pp. 203-216. </pages>
Reference-contexts: For example, we could replace the packet-filter interpreter with a compiler. This approach is taken by several researchers [10, 25]. The problem here is the startup cost and complexity of compilation, especially if serious optimizations are performed. 41 Another approach to safe code execution is Software Fault Isolation (SFI) <ref> [24] </ref>. SFI is an inexpensive method for parsing binaries and inserting run-time checks on memory operations. There are many flavors of SFI depending on the desired level of memory safety. <p> If, on the other hand, the untrusted code interacts frequently with the code consumer or other untrusted components residing in different protection domains and the read operations must be checked also, the overhead of the run-time checks can amount to 20% <ref> [24] </ref>. A more serious disadvantage of SFI is that it can only ensure memory safety. <p> In this case, the code consumer performs a load-time checking that SFI was done correctly. The load-time SFI validator is reportedly simple if it must deal only with binaries for which run-time checks have been inserted on every potentially dangerous memory operation <ref> [24] </ref>. On the other hand, in the case where the validator must accept binaries for which the number of run-time checks has been optimized through program analysis, the validator itself has to redo the analysis that led to the optimization. <p> In general, however, this problem is similar to program verification and is not completely automatable. Actually, the problem is somewhat easier than verification because we have the option of inserting extra run-time checks (as is done in Software Fault Isolation <ref> [24] </ref>), which would have the effect of simplifying the proving process at the cost of reducing the performance of the foreign code.
Reference: [25] <author> Wallach, D. A., Engler, D., and Kaashoek, M. F. </author> <title> ASHs : Application-specific handlers for high-performance messaging. </title> <booktitle> In ACM SIGCOMM'96 (Oct. 1996), </booktitle> <volume> vol. 26, </volume> <booktitle> ACM. </booktitle> <pages> 60 </pages>
Reference-contexts: It is possible, of course, to eliminate the need for interpretation. For example, we could replace the packet-filter interpreter with a compiler. This approach is taken by several researchers <ref> [10, 25] </ref>. The problem here is the startup cost and complexity of compilation, especially if serious optimizations are performed. 41 Another approach to safe code execution is Software Fault Isolation (SFI) [24]. SFI is an inexpensive method for parsing binaries and inserting run-time checks on memory operations. <p> We wrote the four packet filters in the safe subset of Modula-3 and compiled them with the version 3.5 of the DEC SRC compiler extended with the VIEW operation <ref> [25] </ref>. VIEW is used to safely cast the packet filter to an array of aligned 64-bit words allowing fewer memory operation for accessing packet fields.
References-found: 25

