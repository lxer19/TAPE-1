URL: http://acuity.cis.ohio-state.edu/techref/framework.ps
Refering-URL: http://acuity.cis.ohio-state.edu/techref/techref.html
Root-URL: 
Email: fsinha,bowers,mamrakg@cis.ohio-state.edu  
Title: A Framework Design for Graphical User Interfaces: A Case Study  
Author: Saurabh Sinha, Sandra A. Mamrak, and S. Kirk Bowers 
Note: 1 This work was supported in part by Grant No. 5 U01 CA50910-08 from the National Cancer Institute.  
Date: May 4, 1998  
Address: 2015 Neil Avenue Mall  Columbus, OH 43210  
Affiliation: Department of Computer and Information Science  The Ohio State University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Ivar Jacobson, Martin Griss, and Patrik Jonsson. </author> <title> Making the reuse business work. </title> <booktitle> Computer, </booktitle> <pages> pages 36-42, </pages> <month> October </month> <year> 1997. </year> <month> 18 </month>
Reference-contexts: 1 Introduction Software reuse has a significant potential for reducing both development and debugging time for new applications, sometimes by as much as an order of magnitude <ref> [1] </ref>. These reductions, in turn, lower the cost of product development and increase the quality of the new applications. Many technical and nontechnical factors must coalesce in a software development project to realize the potential that reuse provides.
Reference: [2] <author> Robert G. Fichman and Chris F. Kemerer. </author> <title> Object technology and reuse: Lessons from early adopters. </title> <booktitle> Computer, </booktitle> <pages> pages 47-58, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: Considerably more advantage can be realized if the patterns of interaction among the components are similar or identical across different applications in the project. Many nontechnical factors can mitigate against success. An emerging consensus in the reuse community <ref> [2] </ref> is that the primary nontechnical reuse barriers stem from the organization and management of the software development team and include: * A poor investment in organizational learning. * A lack of attention or effort to develop a complete software architecture, including not only tangible products (languages, databases, class libraries, etc.),
Reference: [3] <author> Sandra A. Mamrak, John Boyd, and Ivan Ordo nez. </author> <title> Building an information system for collaborative researchers. </title> <journal> Software Practice and Experience, </journal> <volume> 27(3) </volume> <pages> 253-263, </pages> <month> March </month> <year> 1997. </year>
Reference-contexts: a reduction of effort of an order of magnitude when implementing new applications in the project. 2 Background We have been serving the data storage and retrieval needs of a national group of brain-tumor researchers for many years by way of an information system designed for this group of collaborators <ref> [3, 4] </ref>. The Neuro-Oncology Information System (NOIS) follows a client-server architecture.
Reference: [4] <institution> Department of Computer and Information Science, The Ohio State University, Columbus, Ohio. </institution> <note> Neuro-Oncology Information System Technical Reference, June 1996. Also found at http://www.acuity.cis.ohio-state.edu. </note>
Reference-contexts: a reduction of effort of an order of magnitude when implementing new applications in the project. 2 Background We have been serving the data storage and retrieval needs of a national group of brain-tumor researchers for many years by way of an information system designed for this group of collaborators <ref> [3, 4] </ref>. The Neuro-Oncology Information System (NOIS) follows a client-server architecture.
Reference: [5] <author> Oracle Corporation, </author> <title> Redwood City, CA. ORACLE7 Server Application Developer's Guide, </title> <month> December </month> <year> 1992. </year> <note> PN 6695-70-1292. </note>
Reference-contexts: these two subsystems are entered independently and in no prescribed order so that explicit linking between the subsystems is required to connect clinical and tissue-inventory data for a single surgery. 2.3 Migration from a Procedural to an Object-Oriented Implementation The NOIS database server is implemented using Oracle relational database software <ref> [5] </ref>. The user interfaces for input were initially implemented using the Oracle Forms Designer [6, 7]. This tool provides a layout editor for building user interface screens by creating canvases of interface objects such as text item, button, checkbox, list of values, etc.
Reference: [6] <author> Oracle Corporation, </author> <title> Redwood City, CA. Oracle Forms Reference Manual Volume 1, </title> <month> July </month> <year> 1993. </year> <note> (Version 4.0) PN A11988-1. </note>
Reference-contexts: The user interfaces for input were initially implemented using the Oracle Forms Designer <ref> [6, 7] </ref>. This tool provides a layout editor for building user interface screens by creating canvases of interface objects such as text item, button, checkbox, list of values, etc.
Reference: [7] <author> Oracle Corporation, </author> <title> Redwood City, CA. Oracle Forms Reference Manual Volume 2, </title> <month> July </month> <year> 1993. </year> <note> (Version 4.0) PN A11989-1. </note>
Reference-contexts: The user interfaces for input were initially implemented using the Oracle Forms Designer <ref> [6, 7] </ref>. This tool provides a layout editor for building user interface screens by creating canvases of interface objects such as text item, button, checkbox, list of values, etc.
Reference: [8] <institution> Oracle Corporation, </institution> <address> Redwood City, CA. </address> <note> SQL*Net Administrator's Guide, July 1993. (Version 2.0) PN A11325-1. </note>
Reference-contexts: The Oracle Forms Runtime has to be installed on each client machine that wishes to access the database through the user interfaces. The connection between the Forms interface and the database is handled transparently through Oracle's proprietary communication protocol called SQL*Net <ref> [8] </ref>. Versions 1 and 2 of the NOIS Input Forms were implemented in this manner.
Reference: [9] <author> David H. Friedel Jr. and Anthony Potts. </author> <title> Java Programming Language Handbook. </title> <publisher> Coriolis Group Books, </publisher> <year> 1996. </year>
Reference-contexts: The Java paradigm <ref> [9, 10] </ref> presented to us a truly compelling, revolutionary solution, having all of the desired characteristics for which we were looking. Java is object-oriented, and therefore, could help us manage complexity both in terms of high-level design methods and its reuse capability.
Reference: [10] <author> Jamie Jaworski. </author> <title> Java Developer's Guide. Sams Net, </title> <year> 1996. </year>
Reference-contexts: The Java paradigm <ref> [9, 10] </ref> presented to us a truly compelling, revolutionary solution, having all of the desired characteristics for which we were looking. Java is object-oriented, and therefore, could help us manage complexity both in terms of high-level design methods and its reuse capability.
Reference: [11] <author> Mohamed E. Fayad and Douglas C. Schmidt. </author> <title> Object-oriented application frameworks. </title> <journal> Communications of the ACM, </journal> <volume> 40(10) </volume> <pages> 32-38, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: Common Patterns. At this point in the project we advanced from using a simple object-oriented approach to one in which our goal was to create an object-oriented framework <ref> [11, 12] </ref>. Software developers have a variety of definitions and conceptualizations of frameworks. The description that is closest to our use of the term is that a framework is a reusable, not fully-specified application that can be specialized to produce custom applications. <p> They also discovered a need for one new listener. Such periodic maintenance of frameworks is to be expected because of their generic nature: frameworks can only be tested and debugged in the context of specific applications <ref> [11] </ref>. Therefore, a new application might suggest a modification or an adaptation of the framework that was not apparent before. The periodic maintenance of frameworks has been cited as one of its weaknesses [11]. However, such modifications have been minimal for us. <p> of their generic nature: frameworks can only be tested and debugged in the context of specific applications <ref> [11] </ref>. Therefore, a new application might suggest a modification or an adaptation of the framework that was not apparent before. The periodic maintenance of frameworks has been cited as one of its weaknesses [11]. However, such modifications have been minimal for us. Another commonly cited problem with frameworks is the lack of suitable documentation for new users of the framework [12].
Reference: [12] <author> Ralph E. Johnson. </author> <title> Frameworks = (components + patterns). </title> <journal> Communications of the ACM, </journal> <volume> 40(10) </volume> <pages> 39-42, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: Common Patterns. At this point in the project we advanced from using a simple object-oriented approach to one in which our goal was to create an object-oriented framework <ref> [11, 12] </ref>. Software developers have a variety of definitions and conceptualizations of frameworks. The description that is closest to our use of the term is that a framework is a reusable, not fully-specified application that can be specialized to produce custom applications. <p> The periodic maintenance of frameworks has been cited as one of its weaknesses [11]. However, such modifications have been minimal for us. Another commonly cited problem with frameworks is the lack of suitable documentation for new users of the framework <ref> [12] </ref>.
Reference: [13] <author> Shishir Gundavaram. </author> <title> CGI Programming on the World Wide Web. </title> <publisher> O'Reilly & Associates, Inc, </publisher> <year> 1996. </year>
Reference-contexts: Each applet is comprised of a `front-end' component and a `back-end' component: the `front-end' manages the interface with which users interact; the `back-end' handles all database accesses. The `back-end' connects to Oracle WebServer with appropriate parameters. The server in turn invokes a CGI <ref> [13] </ref> program that posts a user request to the database. The results from the database are interpreted by the `back-end' and passed on to the `front-end.' The `front-end' includes a graphical user interface for the Input Forms, through which users interact with the system.
Reference: [14] <author> Saurabh Sinha, S. Kirk Bowers, and Sandra A. Mamrak. </author> <title> Accessing a medical database using WWW-based user interfaces. </title> <type> Technical Report OSU-CISRC-3/98-TR10, </type> <institution> The Ohio State University, Department of Computer and Information Science, </institution> <month> March </month> <year> 1998. </year>
Reference-contexts: For brevity, we present here only the highest-level view of the forms and their database-related classes; a complete description of all classes can be found in <ref> [14] </ref>. 9 The design process for the forms involved identifying the required classes and their relationships. The decomposition of classes is in terms of domains of responsibility. Each class is made responsible for managing its internal state and for providing certain services. <p> Methods in DatabaseView generate strings for the SQL select command. DatabaseView is further extended to provide specializations for lookup views and updatable views, to account for their functional differences. DatabaseLookupView defines a vector to implement the cache; the dynamic behavior of the cache is discussed in <ref> [14] </ref>. The subclasses of DatabaseLookupView are individual lookup tables from the database. Methods in DatabaseLookupView manage its cache. DatabaseUpdatableView is subclassed for each subsystem view in the database. Each of these subclasses encapsulates the objects for database tables that are updated by that subclass. <p> However, such modifications have been minimal for us. Another commonly cited problem with frameworks is the lack of suitable documentation for new users of the framework [12]. While the documentation of the framework code is available by way of this document, a more detailed technical report <ref> [14] </ref>, and online, we have also documented the process of using the framework to generate a new Input Form. 3 In addition to the use of the framework by its own developers, we also had an opportunity to ask students who had not been involved in the development of the framework
Reference: [15] <author> Grady Booch. </author> <title> Object-Oriented Analysis and Design. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <year> 1994. </year>
Reference-contexts: We use class diagrams, like the one shown in Figure 6, to illustrate our design. Each class diagram shows the inheritance and containment relationships among classes. A containment relationship is qualified as either containment-by-value, or containment-by-reference, as suggested by Booch <ref> [15] </ref>. The cardinality of a containment-by-value relationship is shown next to the arrow. In most cases, a number shows the exact count of objects that are instantiated; an N indicates a value that is at least one, but the value can vary across the subclasses.
Reference: [16] <author> E. F. Codd. </author> <title> A relational model for large shared data banks. </title> <journal> Communications of the ACM, </journal> <volume> 13(6) </volume> <pages> 377-387, </pages> <month> June </month> <year> 1970. </year>
Reference-contexts: These methods perform simple actions, such as clearing all Screens and DatabaseViews. 4.2 Database Classes The database-related classes provide a useful abstraction for NOIS database objects like tables and views, that are referenced by the Input Forms. The NOIS database schema follows the relational data model <ref> [16, 17] </ref>. It contains a number of relations or base tables that hold records of data. The users of NOIS can update data in most of these tables. A few of them, however, serve as lookup tables that list valid values for a field in another table.
Reference: [17] <author> Peter Pin-Shan Chen. </author> <title> The Entity-Relationship Model | Toward a Unified View of Data. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(1) </volume> <pages> 9-36, </pages> <month> March </month> <year> 1976. </year>
Reference-contexts: These methods perform simple actions, such as clearing all Screens and DatabaseViews. 4.2 Database Classes The database-related classes provide a useful abstraction for NOIS database objects like tables and views, that are referenced by the Input Forms. The NOIS database schema follows the relational data model <ref> [16, 17] </ref>. It contains a number of relations or base tables that hold records of data. The users of NOIS can update data in most of these tables. A few of them, however, serve as lookup tables that list valid values for a field in another table.
Reference: [18] <author> Fernando Brita e Abreu and Rogerio Carapuca. </author> <title> Candidate metrics for object-oriented software within a taxonomy framework. </title> <journal> Journal of Systems Software, </journal> <volume> 26 </volume> <pages> 87-96, </pages> <year> 1994. </year>
Reference-contexts: We surveyed the literature for appropriate object-oriented metrics that would allow us to quantify our reuse experience and to relate it to others using standardized, or at least widely accepted, measures. 6.1.1 Metrics for Reuse For reuse, we found two suggestions for possible system reuse measures <ref> [18] </ref>: 1. Percentage of reused `as is' classes verbatim reuse in the system. 3 See http://acuity.cis.ohio-state.edu:8888/using framework.html 14 2. Percentage of reused classes with adaptation in the system.
Reference: [19] <author> Shyam R. Chidamber and Chris F. Kemerer. </author> <title> A metrics suite for object oriented design. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6) </volume> <pages> 476-493, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Some of the metrics proposed for evaluating object-oriented design include <ref> [19] </ref>: * Weighted methods per class. * Depth of inheritance tree. * Number of children. * Coupling between object classes (typically interpreted as an object in one class calling methods defined in an object in another class). * Response for a class (set of methods that can potentially be executed in
Reference: [20] <author> Victor R. Basili, Lionel C. Briand, and Walcelio L. Melo. </author> <title> A validation of object-oriented design metrics as quality indicators. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(10) </volume> <pages> 751-761, </pages> <month> October </month> <year> 1996. </year> <month> 19 </month>
Reference-contexts: Basili, Briand and Melo investigated these metrics as quality indicators by generating a set of hypotheses relating these metrics with fault-proneness <ref> [20] </ref>. In general, they hypothesize that the simpler the design, the less fault-prone the resulting application is, and so the higher the quality.
References-found: 20

