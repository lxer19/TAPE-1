URL: http://www.cs.wisc.edu/wpis/papers/tr1323.ps
Refering-URL: http://www.cs.wisc.edu/wpis/papers/
Root-URL: 
Title: Solving Shape-Analysis Problems in Languages with Destructive Updating  
Author: Mooly Sagiv Thomas Reps Reinhard Wilhelm 
Date: August 20, 1996  
Affiliation: University of Chicago  University of Wisconsin  Universitat des Saarlandes  
Abstract: This paper concerns the static analysis of programs that perform destructive updating on heap-allocated storage. We give an algorithm that uses finite shape-graphs to approximate conservatively the possible "shapes" that heap-allocated structures in a program can take on. For certain programs, our technique is able to determine such properties as: (i) when the input to the program is a list, the output is also a list, and (ii) when the input to the program is a tree, the output is also a tree. For example, the method can determine that "list-ness" is preserved by (i) a program that performs list reversal via destructive updating of the input list, and (ii) a program that searches a list and splices a new element into the list. None of the previously known methods that use graphs to model the program's store are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity). In contrast with previous work, our shape-analysis algorithm is even accurate for certain programs that update cyclic data structures, and is able to show that when the input to the program is a circular list, the output is also a circular list. For example, the shape-analysis algorithm can determine that the list-insert program preserves "circular list-ness".
Abstract-found: 1
Intro-found: 1
Reference: [AW93] <author> U. Assmann and M. Weinhardt. </author> <title> Interprocedural heap analysis for parallelizing imperative programs. </title> <editor> In W. K. Giloi, S. Jahnichen, and B. D. Shriver, editors, </editor> <booktitle> Programming Models For Massively Parallel Computers, </booktitle> <pages> pages 74-82. </pages> <publisher> IEEE Press, </publisher> <month> September </month> <year> 1993. </year>
Reference-contexts: Jones and Muchnick [JM82], Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed earlier, both from a theoretical perspective [CWZ90] and from an implementation perspective <ref> [AW93] </ref>.
Reference: [CBC93] <author> J.-D. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side-effects. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <year> 1993. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94, GH96] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction of approximation of fixed points. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: Appendix A presents the proof of a key lemma needed in Appendix B. 2 An Overview of the Method The shape-analysis algorithm is presented and proven correct using the framework of abstract interpretation <ref> [CC77] </ref>. Because pointers, heap-allocated storage, and destructive updating are all mechanisms that introduce aliasing, the formal treatment of shape analysis is notationally somewhat formidable. However, many aspects of the shape-analysis algorithm can be understood at an intuitive level. <p> Consequently, the x-list (respectively, t-list) is an acyclic list. 2 Termination and safety of the shape-analysis algorithm are argued in the standard manner <ref> [CC77] </ref>. For a given program P , we work with the domain of SSGs in which PVar consists of the program variables in P . This domain is finite and hence of finite height. <p> every SG 2 DSG, fi ([[st]](SG)) v [[st]] ] (fi (SG)): Proof: See Appendix B. 2 Finally, we have Theorem 5.14 (Global Safety Theorem) For every control-flow-graph vertex v, ff (cs (v)) v SG ] Proof: Immediate from Proposition 5.12 (Monotonicity) and Theorem 5.13 (Local Safety), using Theorem T2 of <ref> [CC77, pp. 252] </ref>. 2 5.4 Strong Nullification The key property of the abstract semantics is that each abstract assignment operation creates an SSG that conservatively covers all the possible new configurations of variable sets whose members all point to the same cons-cell.
Reference: [CWZ90] <author> D.R. Chase, M. Wegman, and F. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <year> 1990. </year>
Reference-contexts: For example, the shape-analysis algorithm can determine that the list-insert program preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> qualitatively better results on the abovementioned programs than previous methods? A detailed examination of the differences between our algorithm and previous algorithms is deferred to Section 8; however, a brief characterization of some of the differences is as follows: * Several previous methods have used allocation sites to name shape-nodes <ref> [JM82, CWZ90, PCK93] </ref>. Allocation-site information imposes a fixed partition on the memory. In contrast, our approach deliberately drops information about the concrete locations. There is only an indirect connection to the run-time locations: Shape-graph nodes are named using a (possibly empty) set of variables. <p> Chase, Wegman, and Zadeck observed that their shape-analysis method cannot handle programs such as the list-reversal program because it lacks a way to materialize ("un-summarize") summary nodes at certain key points of the analysis <ref> [CWZ90, pp. 309] </ref>. <p> Previous methods either never remove these edges [Str92] or use some heuristics to remove such edges under limited conditions <ref> [JM81, LH88, CWZ90, PCK93] </ref>. (This unusual characteristic of our method is also a by-product of the node-naming scheme.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> an entire list, tree, or graph. 2 program reverse (x; y) begin /* x points to an unshared, acyclic, singly linked list */ y := nil while x 6= nil do t := y x := x:cdr od end limited way in which sharing information is utilized in [JM81] and <ref> [CWZ90] </ref> prevents the methods described in those papers from determining this fact. * The shape-node names also provide information that sometimes permits the method to determine that a shared-node becomes unshared (e.g., this occurs in the program that performs an insertion into a list). <p> (to l 3 ), as well as a DSG that contains a cons-cell pointed to by z alone with an outgoing cdr -edge (to l 4 ). 2 Other shape-analysis algorithms do not perform strong nullification for a statement of the form "x:sel := nil", except under very limited circumstances <ref> [JM81, LH88, Lar89, CWZ90, PCK93] </ref>. The reason for this is that, after the conditional statement in Example 5.15, they perform actions that (in our terminology) are equivalent to merging n fyg and n fx;yg into one shape-node. <p> There are several simple ways to improve the accuracy of shape analysis by introducing more summary nodes, including: * Using allocation-sites to identify shape-nodes <ref> [JM82, CWZ90] </ref>. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck <ref> [CWZ90] </ref>, and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> However, for reasons mentioned in Section 5.2, the use of a single graph seems necessary for the pragmatic reason that it is more likely to lead to a practical shape-analysis algorithm. Jones and Muchnick [JM82], Chase, Wegman, and Zadeck <ref> [CWZ90] </ref>, and Stransky [Str92] present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed earlier, both from a theoretical perspective [CWZ90] and from an implementation perspective [AW93]. <p> Jones and Muchnick [JM82], Chase, Wegman, and Zadeck <ref> [CWZ90] </ref>, and Stransky [Str92] present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed earlier, both from a theoretical perspective [CWZ90] and from an implementation perspective [AW93]. <p> The Chase-Wegman-Zadeck algorithm lacks a node-materialization operation (although they did recognize that the lack of one was a stumbling block to the accuracy of their method <ref> [CWZ90, pp. 309] </ref>). Chase, Wegman, and Zadeck use reference-count values 0, 1, and 1, whereas we use a Boolean-valued function is ] .
Reference: [Deu92] <author> A. Deutsch. </author> <title> A storeless model for aliasing and its abstractions using finite representations of right-regular equivalence relations. </title> <booktitle> In IEEE International Conference on Computer Languages, </booktitle> <pages> pages 2-13, </pages> <year> 1992. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94, GH96] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program.
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <year> 1994. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94, GH96] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program. <p> There are also several algorithms that are not based on shape-graphs for finding may-alias information for pointer variables. The most sophisticated ones are those of Landi and Ryder [LR91] and Deutsch <ref> [Deu94] </ref>. Deutsch's algorithm is particularly interesting because, for certain programs 35 that manipulate lists, it offers a way of representing the exact (infinite set of) may aliases in a com-pact way.
Reference: [GH96] <author> R. Ghiya and L.J. Hendren. </author> <title> Is it a tree, a dag, or a cyclic graph? A shape analysis for heap-directed pointers in C. </title> <booktitle> In ACM Symposium on Principles of Programming Languages. ACM, </booktitle> <address> New York, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94, GH96] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program.
Reference: [Hei92] <author> N. Heintze. </author> <title> Set-based program analysis. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Follow-on work on this kind of shape-analysis problem includes <ref> [Mog88, Mog89, Hei92, Rep95] </ref>. In [JM81], Jones and Muchnick also began the study of shape analysis for languages with destructive updating.
Reference: [Hen90] <author> L. Hendren. </author> <title> Parallelizing Programs with Recursive Data Structures. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> Jan </month> <year> 1990. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94, GH96] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program. <p> With the Chase-Wegman-Zadeck method, once a node is shared it remains shared forever thereafter. For programs that operate on lists and trees, the non-graph-based method of Hendren <ref> [Hen90] </ref> is sometimes able to determine that a shared-node becomes unshared. However, Hendren's method does not handle data structures that contain cycles. An experimental implementation of the shape-analysis method has been created. The examples presented in the paper have been prepared with the aid of this implementation. <p> A more accurate solution can be determined by tabulating a "shape-graph-transformation" function for each procedure. An alternative is to use Hendren's tabulation method for interprocedural analysis <ref> [Hen90] </ref>. 7 Applications The algorithm developed in Section 5 produces an SSG SG ] v for every program point v. This SSG provides an approximation to the set of stores (DSGs) that can possibly occur in any execution of the program that ends at v. <p> and (c)). (We do not mean to imply that our method always dominates the Landi-Ryder and Deutsch algorithms; there exist programs for which Deutsch's algorithm is more accurate than our algorithm.) A different approach was taken by Hendren and Nicolau, who designed an algorithm that handles only acyclic data structures <ref> [HN90, Hen90] </ref>. Because of the decision to work with programs that only manipulate acyclic structures, the algorithm does not have to have a way of representing cycles, even conservatively. For this alias-analysis problem, they have given an efficient algorithm that manipulates matrices that record access paths that are aliases.
Reference: [HG92] <author> L. Hendren and G.R. Gao. </author> <title> Designing programming languages for analyzability: A fresh look at pointer data structures. </title> <booktitle> In Proceedings of the International Conference on Computer Languages, </booktitle> <pages> pages 242-251, </pages> <year> 1992. </year>
Reference-contexts: This kind of conservative approximation is appropriate for use, for example, in parallelizing compilers <ref> [HHN92, HG92] </ref>. (An extension of our basic technique allows SSGs to characterize some kinds of definitely circular data types, including definitely circular lists. See Section 6.3.) 2 Remark.
Reference: [HHN92] <author> L. Hendren, J. Hummel, and A. Nicolau. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and the transformation of imperative programs. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 249-260, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This kind of conservative approximation is appropriate for use, for example, in parallelizing compilers <ref> [HHN92, HG92] </ref>. (An extension of our basic technique allows SSGs to characterize some kinds of definitely circular data types, including definitely circular lists. See Section 6.3.) 2 Remark.
Reference: [HN90] <author> L. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94, GH96] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program. <p> and (c)). (We do not mean to imply that our method always dominates the Landi-Ryder and Deutsch algorithms; there exist programs for which Deutsch's algorithm is more accurate than our algorithm.) A different approach was taken by Hendren and Nicolau, who designed an algorithm that handles only acyclic data structures <ref> [HN90, Hen90] </ref>. Because of the decision to work with programs that only manipulate acyclic structures, the algorithm does not have to have a way of representing cycles, even conservatively. For this alias-analysis problem, they have given an efficient algorithm that manipulates matrices that record access paths that are aliases.
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <year> 1989. </year>
Reference-contexts: In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., <ref> [HPR89] </ref>). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph.
Reference: [JM81] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> Flow analysis and optimization of Lisp-like structures. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 4, </volume> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: For example, the shape-analysis algorithm can determine that the list-insert program preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> Previous methods either never remove these edges [Str92] or use some heuristics to remove such edges under limited conditions <ref> [JM81, LH88, CWZ90, PCK93] </ref>. (This unusual characteristic of our method is also a by-product of the node-naming scheme.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> and not an entire list, tree, or graph. 2 program reverse (x; y) begin /* x points to an unshared, acyclic, singly linked list */ y := nil while x 6= nil do t := y x := x:cdr od end limited way in which sharing information is utilized in <ref> [JM81] </ref> and [CWZ90] prevents the methods described in those papers from determining this fact. * The shape-node names also provide information that sometimes permits the method to determine that a shared-node becomes unshared (e.g., this occurs in the program that performs an insertion into a list). <p> (to l 3 ), as well as a DSG that contains a cons-cell pointed to by z alone with an outgoing cdr -edge (to l 4 ). 2 Other shape-analysis algorithms do not perform strong nullification for a statement of the form "x:sel := nil", except under very limited circumstances <ref> [JM81, LH88, Lar89, CWZ90, PCK93] </ref>. The reason for this is that, after the conditional statement in Example 5.15, they perform actions that (in our terminology) are equivalent to merging n fyg and n fx;yg into one shape-node. <p> It simply has to be applied whenever necessary to limit the cardinality of shape-node name sets to some chosen constant. (This is similar in spirit to k-limiting <ref> [JM81] </ref>, but it is likely to produce much better results because limiting the cardinality of name sets still preserves most of the structural information about the graph.) Example 6.5 In the SSG shown in the v 2 box of Figure 10, we can eliminate t 1 from the name sets to <p> A similar shape-analysis problem, but for an imperative language supporting non-destructive manipulation of heap-allocated objects, was formulated independently by Jones and Muchnick, who treated the problem as one of solving (i.e., finding the least fixed point of) a collection of equations using regular tree grammars <ref> [JM81] </ref>. Follow-on work on this kind of shape-analysis problem includes [Mog88, Mog89, Hei92, Rep95]. In [JM81], Jones and Muchnick also began the study of shape analysis for languages with destructive updating. <p> non-destructive manipulation of heap-allocated objects, was formulated independently by Jones and Muchnick, who treated the problem as one of solving (i.e., finding the least fixed point of) a collection of equations using regular tree grammars <ref> [JM81] </ref>. Follow-on work on this kind of shape-analysis problem includes [Mog88, Mog89, Hei92, Rep95]. In [JM81], Jones and Muchnick also began the study of shape analysis for languages with destructive updating. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in <ref> [JM81] </ref>), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> When our algorithm processes the first of these statements, it (always) removes 6 The idea of augmenting shape-graphs with sharing information also appears in the earlier work of Jones and Muchnick <ref> [JM81] </ref>. 34 the sel edges emanating from the shape-nodes that x points to. We have called this operation "strong nullification", by analogy with "strong update". When the algorithm processes the second statement, it introduces sel edges that emanate from the shape-nodes that x points to.
Reference: [JM82] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <year> 1982. </year> <month> 43 </month>
Reference-contexts: qualitatively better results on the abovementioned programs than previous methods? A detailed examination of the differences between our algorithm and previous algorithms is deferred to Section 8; however, a brief characterization of some of the differences is as follows: * Several previous methods have used allocation sites to name shape-nodes <ref> [JM82, CWZ90, PCK93] </ref>. Allocation-site information imposes a fixed partition on the memory. In contrast, our approach deliberately drops information about the concrete locations. There is only an indirect connection to the run-time locations: Shape-graph nodes are named using a (possibly empty) set of variables. <p> There are several simple ways to improve the accuracy of shape analysis by introducing more summary nodes, including: * Using allocation-sites to identify shape-nodes <ref> [JM82, CWZ90] </ref>. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick <ref> [JM82] </ref>, Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> However, for reasons mentioned in Section 5.2, the use of a single graph seems necessary for the pragmatic reason that it is more likely to lead to a practical shape-analysis algorithm. Jones and Muchnick <ref> [JM82] </ref>, Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed earlier, both from a theoretical perspective [CWZ90] and from an implementation perspective [AW93].
Reference: [Knu73] <author> D. E. Knuth. </author> <title> The Art of Computer Programming, Volume I: Fundamental Algorithms, 2nd. </title> <editor> Ed. </editor> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1973. </year>
Reference-contexts: However, for other programs we are not so fortunate. For example, in Lindstrom scanning of a tree [Lin73] (also known as the Deutsch-Schorr-Waite algorithm for traversing a tree without a stack <ref> [Knu73, pp. 417] </ref>) this kind of inaccuracy prevents us from finding that, after traversing a tree, we still have a tree.
Reference: [Lan92] <author> W. Landi. </author> <title> Undecidability of static analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(4), </volume> <year> 1992. </year>
Reference-contexts: However, Myers's work does not handle heap-allocated storage and destructive updating. Therefore, his algorithm is significantly simpler and he is even able to show that it is precise. In contrast, it is undecidable to give a precise solution to our problem, even in the absence of procedure calls <ref> [Lan92, Ram94] </ref>. Acknowledgments We are grateful for the helpful comments of Martin Alt, Alain Deutsch, Christian Fecht, John Field, Neil Jones, Florian Martin, Mike O'Donnell, and G. Ramalingam. Laurie Hendren provided us with extensive and very helpful information about the capabilities of her shape-analysis technique.
Reference: [Lar89] <author> J.R. Larus. </author> <title> Restructuring Symbolic Programs for Concurrent Execution on Multiprocessors. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <address> CA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: (to l 3 ), as well as a DSG that contains a cons-cell pointed to by z alone with an outgoing cdr -edge (to l 4 ). 2 Other shape-analysis algorithms do not perform strong nullification for a statement of the form "x:sel := nil", except under very limited circumstances <ref> [JM81, LH88, Lar89, CWZ90, PCK93] </ref>. The reason for this is that, after the conditional statement in Example 5.15, they perform actions that (in our terminology) are equivalent to merging n fyg and n fx;yg into one shape-node. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger <ref> [LH88, Lar89] </ref>, Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> Plevyak, Chien, and Karamcheti describe a shape-analysis algorithm that is similar to the Chase-Wegman-Zadeck method [PCK93]. Their algorithm inherits most of the drawbacks of the original Chase-Wegman-Zadeck algorithm. Larus and Hilfinger <ref> [LH88, Lar89] </ref> devised a shape-analysis algorithm that is based on somewhat different principles from the aforementioned work. As with our algorithm, shape-nodes are labeled with some auxiliary information.
Reference: [LH88] <author> J.R. Larus and P.N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <year> 1988. </year>
Reference-contexts: For example, the shape-analysis algorithm can determine that the list-insert program preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> Previous methods either never remove these edges [Str92] or use some heuristics to remove such edges under limited conditions <ref> [JM81, LH88, CWZ90, PCK93] </ref>. (This unusual characteristic of our method is also a by-product of the node-naming scheme.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> (to l 3 ), as well as a DSG that contains a cons-cell pointed to by z alone with an outgoing cdr -edge (to l 4 ). 2 Other shape-analysis algorithms do not perform strong nullification for a statement of the form "x:sel := nil", except under very limited circumstances <ref> [JM81, LH88, Lar89, CWZ90, PCK93] </ref>. The reason for this is that, after the conditional statement in Example 5.15, they perform actions that (in our terminology) are equivalent to merging n fyg and n fx;yg into one shape-node. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger <ref> [LH88, Lar89] </ref>, Chase, Wegman, and Zadeck [CWZ90], and Stransky [Str92] who developed shape-analysis methods that associate each program point with a single shape-graph. <p> Plevyak, Chien, and Karamcheti describe a shape-analysis algorithm that is similar to the Chase-Wegman-Zadeck method [PCK93]. Their algorithm inherits most of the drawbacks of the original Chase-Wegman-Zadeck algorithm. Larus and Hilfinger <ref> [LH88, Lar89] </ref> devised a shape-analysis algorithm that is based on somewhat different principles from the aforementioned work. As with our algorithm, shape-nodes are labeled with some auxiliary information.
Reference: [Lin73] <author> G. Lindstrom. </author> <title> Scanning list structures without stacks or tag bits. </title> <journal> Information Processing Letters, </journal> <volume> 2(2) </volume> <pages> 47-51, </pages> <month> June </month> <year> 1973. </year>
Reference-contexts: However, for other programs we are not so fortunate. For example, in Lindstrom scanning of a tree <ref> [Lin73] </ref> (also known as the Deutsch-Schorr-Waite algorithm for traversing a tree without a stack [Knu73, pp. 417]) this kind of inaccuracy prevents us from finding that, after traversing a tree, we still have a tree.
Reference: [LR91] <author> W. Landi and B.G. Ryder. </author> <title> Pointer induced aliasing: A problem classification. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <year> 1991. </year>
Reference-contexts: Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method (whether based on graphs or other principles <ref> [HN90, Hen90, LR91, Deu92, CBC93, Deu94, GH96] </ref>) has the ability to determine that "circular list-ness" is preserved by the list-insert program. <p> There are also several algorithms that are not based on shape-graphs for finding may-alias information for pointer variables. The most sophisticated ones are those of Landi and Ryder <ref> [LR91] </ref> and Deutsch [Deu94]. Deutsch's algorithm is particularly interesting because, for certain programs 35 that manipulate lists, it offers a way of representing the exact (infinite set of) may aliases in a com-pact way.
Reference: [Mog88] <author> T. Mogensen. </author> <title> Partially static structures in a self-applicable partial evaluator. In Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation Gammel Avernaes, </booktitle> <address> Denmark, </address> <month> October 18-24, </month> <year> 1987, </year> <pages> pages 325-347, </pages> <address> New York, NY, 1988. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Follow-on work on this kind of shape-analysis problem includes <ref> [Mog88, Mog89, Hei92, Rep95] </ref>. In [JM81], Jones and Muchnick also began the study of shape analysis for languages with destructive updating.
Reference: [Mog89] <author> T. Mogensen. </author> <title> Separating binding times in language specifications. </title> <booktitle> In Fourth International Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 12-25, </pages> <address> New York, NY, </address> <month> September </month> <year> 1989. </year> <note> ACM Press. </note>
Reference-contexts: Follow-on work on this kind of shape-analysis problem includes <ref> [Mog88, Mog89, Hei92, Rep95] </ref>. In [JM81], Jones and Muchnick also began the study of shape analysis for languages with destructive updating.
Reference: [Mye81] <author> E.W. Myers. </author> <title> A precise inter-procedural data flow algorithm. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <year> 1981. </year>
Reference-contexts: for program-point p represents the cons-cells that are simultaneously pointed to by all (and only) the variables in X when control reaches p. (The sets of variable names that represent alias configurations are reminiscent of the alias-configurations tracked by Myers in his algorithm for determining aliasing among (scalar) program variables <ref> [Mye81] </ref>.) 2.2 An Explicit Representation of Sharing An examination of the iteration-0 row of Figure 2 may lead the reader to think that acyclic structures are abstracted to cyclic structures (and hence that the abstraction cannot distinguish between cyclic and acyclic structures). <p> However, by design, their algorithm cannot determine such structure-preservation properties for programs that handle cyclic lists. Myers presented an algorithm for interprocedural bit-vector problems that accounts for aliasing <ref> [Mye81] </ref>. Like our shape-analysis algorithm, his algorithm also keeps track of sets of aliased variables. He conjectured that in practice the sizes of the alias sets remain small. However, Myers's work does not handle heap-allocated storage and destructive updating.
Reference: [PCK93] <author> J. Plevyak, A.A. Chien, and V. Karamcheti. </author> <title> Analysis of dynamic structures for efficient parallel execution. </title> <editor> In U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing, volume 768 of Lecture Notes in Computer Science, </booktitle> <pages> pages 37-57, </pages> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: For example, the shape-analysis algorithm can determine that the list-insert program preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> qualitatively better results on the abovementioned programs than previous methods? A detailed examination of the differences between our algorithm and previous algorithms is deferred to Section 8; however, a brief characterization of some of the differences is as follows: * Several previous methods have used allocation sites to name shape-nodes <ref> [JM82, CWZ90, PCK93] </ref>. Allocation-site information imposes a fixed partition on the memory. In contrast, our approach deliberately drops information about the concrete locations. There is only an indirect connection to the run-time locations: Shape-graph nodes are named using a (possibly empty) set of variables. <p> Previous methods either never remove these edges [Str92] or use some heuristics to remove such edges under limited conditions <ref> [JM81, LH88, CWZ90, PCK93] </ref>. (This unusual characteristic of our method is also a by-product of the node-naming scheme.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> (to l 3 ), as well as a DSG that contains a cons-cell pointed to by z alone with an outgoing cdr -edge (to l 4 ). 2 Other shape-analysis algorithms do not perform strong nullification for a statement of the form "x:sel := nil", except under very limited circumstances <ref> [JM81, LH88, Lar89, CWZ90, PCK93] </ref>. The reason for this is that, after the conditional statement in Example 5.15, they perform actions that (in our terminology) are equivalent to merging n fyg and n fx;yg into one shape-node. <p> Plevyak, Chien, and Karamcheti describe a shape-analysis algorithm that is similar to the Chase-Wegman-Zadeck method <ref> [PCK93] </ref>. Their algorithm inherits most of the drawbacks of the original Chase-Wegman-Zadeck algorithm. Larus and Hilfinger [LH88, Lar89] devised a shape-analysis algorithm that is based on somewhat different principles from the aforementioned work. As with our algorithm, shape-nodes are labeled with some auxiliary information.
Reference: [Ram94] <author> G. Ramalingam. </author> <title> The undecidability of aliasing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1467-1471, </pages> <year> 1994. </year>
Reference-contexts: However, Myers's work does not handle heap-allocated storage and destructive updating. Therefore, his algorithm is significantly simpler and he is even able to show that it is precise. In contrast, it is undecidable to give a precise solution to our problem, even in the absence of procedure calls <ref> [Lan92, Ram94] </ref>. Acknowledgments We are grateful for the helpful comments of Martin Alt, Alain Deutsch, Christian Fecht, John Field, Neil Jones, Florian Martin, Mike O'Donnell, and G. Ramalingam. Laurie Hendren provided us with extensive and very helpful information about the capabilities of her shape-analysis technique.
Reference: [Rep95] <author> T. Reps. </author> <title> Shape analysis as a generalized path problem. </title> <booktitle> In Proc. of ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation, PEPM'95, </booktitle> <pages> pages 1-11, </pages> <address> New York, NY, June 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Follow-on work on this kind of shape-analysis problem includes <ref> [Mog88, Mog89, Hei92, Rep95] </ref>. In [JM81], Jones and Muchnick also began the study of shape analysis for languages with destructive updating.
Reference: [Rey68] <author> J.C. Reynolds. </author> <title> Automatic computation of data set definitions. </title> <booktitle> In Information Processing 68: Proceedings of the IFIP Congress, </booktitle> <pages> pages 456-461, </pages> <address> New York, NY, 1968. </address> <publisher> North-Holland. </publisher>
Reference-contexts: y have the value is ] (n) = false, there cannot possibly be any sharing between the data structures pointed to by x and y. 8 Related Work The shape-analysis problem was first investigated by Reynolds, who studied it in the context of a Lisp-like language with no destructive updating <ref> [Rey68] </ref>. Reynolds treated the problem as one of simplifying a collection of set equations.
Reference: [RSSS93] <author> R. Ramakrishnan, P. Seshadri, D. Srivastava, and S. Sudarshan. </author> <title> Implementation of the CORAL deductive database system. </title> <booktitle> In Proceedings of the ACM SIGMOD 93 Conference, </booktitle> <pages> pages 167-176, </pages> <year> 1993. </year>
Reference-contexts: Ramalingam. Laurie Hendren provided us with extensive and very helpful information about the capabilities of her shape-analysis technique. We used two logic-programming systems | Coral <ref> [RSSS93] </ref> and XSB [War92] | to experiment with implementations of the shape-analysis algorithm. We are indebted to Raghu Ramakrishnan and Praveen Seshadri for help with Coral and to C.R. Ramakrishnan for porting the Coral implementation to XSB.
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 7, </volume> <pages> pages 189-234. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Like n , they can represent multiple cons-cells of a single concrete store. Using these ideas, we have extended the abstract semantics to handle procedure calls and returns. The second problem can be resolved using one of the known interprocedural techniques of Sharir and Pnueli <ref> [SP81] </ref>. For example, a simple conservative solution is to consider a procedure call as a goto to the called procedure and a return from a procedure P as a goto to all the statements that follow an invocation of P .
Reference: [SRW95] <author> M. Sagiv, T. Reps, and R. Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <type> Technical Report TR-1276, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI, </institution> <month> July </month> <year> 1995. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/trs.html). </note>
Reference-contexts: v 2 V : CS v = fh; ig if v = start f [[st (u)]](SG) j hu; vi 2 A; SG 2 CS u g otherwise (1) 3 An alternative semantics that returns a special value ? if a nil pointer or uninitialized pointer is dereferenced was used in <ref> [SRW95] </ref>. The present formulation has the advantage of being simpler. 12 5 The Abstract Semantics In this section, we present a shape-analysis technique that uses a restricted subset of shape-graphs, called static shape-graphs, or SSGs for short, to characterize the possible shapes that heap-allocated storage can take on. <p> More precisely, if at the beginning of the list-insert program x is a possibly cyclic list of length 1 (see Figure 7 (e)), then at the end of the program, x is a possibly cyclic list of length 2 (see Figure 7 (d)). (For details, see Appendix B of <ref> [SRW95] </ref>.) The list-insert program also illustrates an interesting capability of the shape-analysis algorithm that does not arise with the list-reversal program: In certain circumstances, information in shape-node names can be used to reset a shape-node's sharing information from true to false. <p> For certain programs, this may lead to loss of accuracy. This can be overcome by working with concrete and abstract semantics that incorporate garbage-collection operations (see <ref> [SRW95] </ref>). * In the way shape graphs were defined in Section 3.2, there are no shape-graph elements that represent uninitialized fields of cons-cells or fields whose value is either an atom or nil. One consequence of this is that the shape-analysis algorithm is only able determine rather weak data-type properties.
Reference: [Str92] <author> J. Stransky. </author> <title> A lattice for abstract interpretation of dynamic (Lisp-like) structures. </title> <journal> Information and Computation, </journal> <volume> 101(1) </volume> <pages> 70-102, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: For example, the shape-analysis algorithm can determine that the list-insert program preserves "circular list-ness". These are rather surprising capabilities. None of the previously developed methods that use graphs to solve shape-analysis problems are capable of determining that "list-ness" is preserved on these examples (or examples of similar complexity) <ref> [JM81, LH88, CWZ90, Str92, PCK93] </ref>. Previous to this paper, it was an open question whether such precision could ever be obtained by any method that uses graphs to model storage usage. <p> Previous methods either never remove these edges <ref> [Str92] </ref> or use some heuristics to remove such edges under limited conditions [JM81, LH88, CWZ90, PCK93]. (This unusual characteristic of our method is also a by-product of the node-naming scheme.) * We use sharing information to increase the accuracy of the primitive operations used by our method. <p> In addition to Jones and Muchnick's work, k-limiting has also been used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs (in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, and Zadeck [CWZ90], and Stransky <ref> [Str92] </ref> who developed shape-analysis methods that associate each program point with a single shape-graph. <p> However, for reasons mentioned in Section 5.2, the use of a single graph seems necessary for the pragmatic reason that it is more likely to lead to a practical shape-analysis algorithm. Jones and Muchnick [JM82], Chase, Wegman, and Zadeck [CWZ90], and Stransky <ref> [Str92] </ref> present similar methods in which the shape-nodes correspond to a program's allocation sites. These methods are more efficient than the methods discussed earlier, both from a theoretical perspective [CWZ90] and from an implementation perspective [AW93].
Reference: [War92] <author> D.S. Warren. </author> <title> Memoing for logic programs. </title> <journal> Communications of the ACM, </journal> <volume> 35(3) </volume> <pages> 93-111, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Ramalingam. Laurie Hendren provided us with extensive and very helpful information about the capabilities of her shape-analysis technique. We used two logic-programming systems | Coral [RSSS93] and XSB <ref> [War92] </ref> | to experiment with implementations of the shape-analysis algorithm. We are indebted to Raghu Ramakrishnan and Praveen Seshadri for help with Coral and to C.R. Ramakrishnan for porting the Coral implementation to XSB.
References-found: 33

