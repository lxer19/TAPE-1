URL: http://www-psrg.lcs.mit.edu/~james/drafts/osdi-aegis.ps
Refering-URL: http://www.cs.washington.edu/homes/romer/590lobo/index.html
Root-URL: 
Title: Aegis: A Secure Programmable Exokernel  
Author: Dawson R. Engler M. Frans Kaashoek James W. O'Toole Jr. 
Date: June 27 1994  
Address: Cambridge, MA 02139, USA  
Affiliation: MIT Laboratory for Computer Science  
Abstract: To provide high performance and a high degree of modularity, operating systems should provide only minimal embedded kernel functionality. The Exokernel is a new operating system structure that achieves this minimalist goal by letting applications manage the underlying hardware resources directly instead of hiding the hardware functionality in layers of operating system software. Applications can customize the operating system by extending exokernel interfaces. Exokernels can use code inspection, inlined cross-domain procedure calls, and secure languages to allow the safe execution of user code in the kernel. By having direct access to the physical hardware applications can implement policies that incorporate application-specific knowledge. To test and evaluate exokernels and their customization techniques a prototype exokernel system, Aegis, is being developed.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: a new kernel foundation for UNIX development. </title> <booktitle> Proc. Summer 1986 USENIX Conference, </booktitle> <pages> pages 93-112, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32]. Modern revisitations of microkernels have also argued for kernel extensibility <ref> [1, 10, 11, 39, 41, 43] </ref>. Anderson and Kiczales et al. also recently argued for minimalism and customizability [2, 26].
Reference: [2] <author> T.E. Anderson. </author> <title> The case for application-specific operating systems. </title> <booktitle> In Third Workshop on Workstation Operating Systems, </booktitle> <pages> pages 92-94, </pages> <year> 1992. </year>
Reference-contexts: However, no single policy is best for all applications. For example, file system and relational database applications often have different storage access patterns, and therefore benefit from different buffer and disk management policies. Similar policy conflicts arise in almost every area of 1 resource management <ref> [2, 13, 19, 42] </ref>. While microkernels have pushed some policy decisions out of the kernel into user-level processes, the supervisor mode still defines a fixed interface among the kernel, user-level services, and applications. Applications then suffer from a large number of protection domain crossings. <p> Modern revisitations of microkernels have also argued for kernel extensibility [1, 10, 11, 39, 41, 43]. Anderson and Kiczales et al. also recently argued for minimalism and customizability <ref> [2, 26] </ref>.
Reference: [3] <author> T.E. Anderson, H.M. Levy, B.N. Bershad, and E.D. Lazowska. </author> <title> The interaction of architecture and operating system design. </title> <booktitle> In Proc. of the Fourth Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <year> 1991. </year>
Reference-contexts: Applications then suffer from a large number of protection domain crossings. These crossings are typically expensive, as they involve entering the supervisor mode, saving and restoring registers, scheduling a thread of control, and manipulating address spaces <ref> [3, 9, 38] </ref>. For example, many applications run slower on the microkernel implementation of Mach than on the monolithic implementation [3]. The disadvantages of fixed operating system policies are made worse by the growing diversity in hardware platforms and rapid advances of technology. <p> These crossings are typically expensive, as they involve entering the supervisor mode, saving and restoring registers, scheduling a thread of control, and manipulating address spaces [3, 9, 38]. For example, many applications run slower on the microkernel implementation of Mach than on the monolithic implementation <ref> [3] </ref>. The disadvantages of fixed operating system policies are made worse by the growing diversity in hardware platforms and rapid advances of technology. For example, in a mobile computer it is of crucial importance to save power by carefully managing the spin-down policy of the disk.
Reference: [4] <author> A.W. Appel and K. Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Proc. Fourth International Conference on ASPLOS, </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: For example, the interaction of application and the virtual memory system is crucial to the performance of applications. Closer integration with virtual memory management can enable distributed shared memory systems and garbage collectors to run an order of magnitude faster <ref> [4] </ref>. * Improve performance by reducing the overhead of interrupts, translation look-aside buffer (TLB) faults, traps, context switches, and cache misses, which are the primary sources of overhead in today's operating systems.
Reference: [5] <author> K. Bala, M.F. Kaashoek, and W.E. Weihl. </author> <title> Software prefetching and caching for translation lookaside buffers. </title> <note> In OSDI (submitted), </note> <month> June </month> <year> 1994. </year>
Reference-contexts: In addition, applications have more control over TLB management, which allows applications to prefetch their own TLB entries, resulting in better overall performance <ref> [5] </ref>. The synthetic applications we are currently running all use a very simple page table layout.
Reference: [6] <author> B.N. Bershad, C. Chambers, S. Eggers, C. Maeda, D. McNamee, P. Pardyak, S. Savage, and E. Sirer. </author> <title> SPIN an extensible microkernel for application-specific operating system services. </title> <type> Technical Report TR94-03-03, </type> <institution> University of Washington, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Furthermore, the Aegis system will use runtime code generation to efficiently execute application kernel extensions. Concurrently with our work the SPIN project also investigates adaptable kernels that allow applications to make policy decisions efficiently <ref> [6] </ref>. The SPIN system encapsulates policies in spindles that can be dynamically loaded into the kernel. To ensure safety, spindles will be written in a type-secure language and will be translated by a trusted compiler.
Reference: [7] <author> B.N. Bershad, D.D. Redell, and J.R. Ellis. </author> <title> Fast mutual exclusion for uniprocessors. </title> <booktitle> Proc. of the Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 223-237, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The prologue and epilogue code allows applications to save and restore registers under their own control, and allows them to customize context switches. For example, this allows an application to implement Bershad's fast uniprocessor synchronization <ref> [7] </ref> by moving the program counter out of a critical section and releasing locks on a forced context switch.
Reference: [8] <author> M.A. Blumrich, K. Li, R. Alpert, C. Dubnicki, E.W. Felten, and J. Sandberg. </author> <title> Virtual memory mapped network interface for the SHRIMP multicomputer. </title> <booktitle> The 21st Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 142-153, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Using application-specific knowledge, spin-down policies can be much more effective than predictive policies or static ones [13, 33]. New architectures are arriving that support protected user-level communication, requiring little involvement of the operating system <ref> [8, 27] </ref>. By fixing policies, operating system software prevents applications from evolving with the hardware. In this paper we propose a new operating system organization, the exokernel, that delivers hardware performance and hardware functionality directly to applications.
Reference: [9] <author> J. Bradley Chen and Brian N. Bershad. </author> <title> The impact of operating system structure on memory system performance. </title> <booktitle> Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <year> 1993. </year>
Reference-contexts: Applications then suffer from a large number of protection domain crossings. These crossings are typically expensive, as they involve entering the supervisor mode, saving and restoring registers, scheduling a thread of control, and manipulating address spaces <ref> [3, 9, 38] </ref>. For example, many applications run slower on the microkernel implementation of Mach than on the monolithic implementation [3]. The disadvantages of fixed operating system policies are made worse by the growing diversity in hardware platforms and rapid advances of technology.
Reference: [10] <author> D.R. Cheriton. </author> <title> The V distributed system. </title> <journal> Commun. ACM, </journal> <volume> 31(3) </volume> <pages> 314-333, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32]. Modern revisitations of microkernels have also argued for kernel extensibility <ref> [1, 10, 11, 39, 41, 43] </ref>. Anderson and Kiczales et al. also recently argued for minimalism and customizability [2, 26].
Reference: [11] <author> H. Custer. </author> <title> Inside Windows/NT. </title> <publisher> Microsoft Press, </publisher> <address> Redmond, WA, </address> <year> 1993. </year>
Reference-contexts: Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32]. Modern revisitations of microkernels have also argued for kernel extensibility <ref> [1, 10, 11, 39, 41, 43] </ref>. Anderson and Kiczales et al. also recently argued for minimalism and customizability [2, 26]. <p> handlers for device I/O [20]; Chorus servers are loaded into the kernel [41]; Mach 3.0 has migrated some of the AFS cache manager back into the kernel [38]; the Amoeba file server is usually configured to run in the kernel [43]; Windows/NT runs only non-critical services outside of the kernel <ref> [11] </ref>; Lepreau et. al. has provided a tool to reintroduce servers into Mach 3.0 [31]. Draves has argued for selecting among several implementations of a specific kernel abstraction to allow customization [14]. However, none of these customizations guarantee the safety of the code once introduced.
Reference: [12] <author> P. Deutsch and C.A. Grant. </author> <title> A flexible measurement tool for software systems. </title> <booktitle> Information Processing 71, </booktitle> <year> 1971. </year>
Reference-contexts: These techniques ensure that safe application code will not execute privileged instructions or access protected data in uncontrolled ways: 1. Code Inspection. Code introduced into the secure programmable machine must be free of privileged instructions. As shown by Deutsch <ref> [12] </ref>, machine code can be inspected to guard against wild loads, stores, and jumps. Execution time can also be controlled by bounding loop iteration counts. <p> Techniques for certifying the safety of code include inspection and sandboxing. Deutsch showed how to safely introduce user-written instrumentation code into a running kernel by bounding loads, stores, jumps and runtime <ref> [12] </ref>. Making existing binaries safe has been explored by Wahbe [45]. Although this technique will be useful for controlling entry points, we expect that loads and stores can be constrained more efficiently by changing the address context quickly within supervisor mode.
Reference: [13] <author> F. Douglis, P. Krishnan, and B. Marsh. </author> <title> Thwarting the power hungry disk. </title> <booktitle> In Proceedings of 1994 Winter Usenix conference, </booktitle> <pages> pages 293-306, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: However, no single policy is best for all applications. For example, file system and relational database applications often have different storage access patterns, and therefore benefit from different buffer and disk management policies. Similar policy conflicts arise in almost every area of 1 resource management <ref> [2, 13, 19, 42] </ref>. While microkernels have pushed some policy decisions out of the kernel into user-level processes, the supervisor mode still defines a fixed interface among the kernel, user-level services, and applications. Applications then suffer from a large number of protection domain crossings. <p> For example, in a mobile computer it is of crucial importance to save power by carefully managing the spin-down policy of the disk. Using application-specific knowledge, spin-down policies can be much more effective than predictive policies or static ones <ref> [13, 33] </ref>. New architectures are arriving that support protected user-level communication, requiring little involvement of the operating system [8, 27]. By fixing policies, operating system software prevents applications from evolving with the hardware.
Reference: [14] <author> R. Draves. </author> <title> The case for run-time replaceable kernel modules. </title> <booktitle> In Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pages 160-165, </pages> <month> October </month> <year> 1993. </year> <month> 9 </month>
Reference-contexts: Draves has argued for selecting among several implementations of a specific kernel abstraction to allow customization <ref> [14] </ref>. However, none of these customizations guarantee the safety of the code once introduced. Synthesis is an innovative operating system that has inspired some of our work [34]; for example, the use of runtime code generation.
Reference: [15] <author> Dawson R. Engler, M. Frans Kaashoek, and James O'Toole. </author> <title> The operating system kernel as a secure programmable machine. </title> <booktitle> Proceedings of the Sixth SIGOPS European Workshop, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: In our view, the operating system should defer policy decisions to applications and provide a secure programmable machine interface, so that applications have direct access to the hardware and are able to set their own policies <ref> [15] </ref>. We are designing and implementing Aegis, a prototype system that will test the feasibility of this approach. A monolithic operating system typically provides a single fixed policy for resource management. However, no single policy is best for all applications.
Reference: [16] <author> Dawson R. Engler and Todd A. Proebsting. </author> <title> DCG: An efficient, retargetable dynamic code generation system. </title> <month> October </month> <year> 1994. </year>
Reference-contexts: This scheme will work on any architecture that decouples addressing contexts from the ability to execute privileged instructions. We also have experimented with two language-based approaches to safe customization. Using portable runtime code generation <ref> [16] </ref> we implemented Mogul's safe packet-filter language and compared its performance to an efficient byte-code interpreter of the packet filter. We measured a factor of 10 performance improvement. <p> However, none of these customizations guarantee the safety of the code once introduced. Synthesis is an innovative operating system that has inspired some of our work [34]; for example, the use of runtime code generation. The Aegis system, however, uses a portable runtime code generation system <ref> [16] </ref>, while the synthesis kernel is written in assembly, and uses ad-hoc runtime code generation macros to specialize system calls. Furthermore, the Aegis system will use runtime code generation to efficiently execute application kernel extensions.
Reference: [17] <author> Per Brinch Hansen. </author> <title> The nucleus of a multiprogramming system. </title> <journal> Communications of the ACM, </journal> <volume> 13(4) </volume> <pages> 238-241, </pages> <month> April </month> <year> 1970. </year>
Reference-contexts: Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper <ref> [17] </ref> are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32]. Modern revisitations of microkernels have also argued for kernel extensibility [1, 10, 11, 39, 41, 43].
Reference: [18] <author> M.C. Harrison and J.T. Schwartz. SHARER, </author> <title> a time sharing system for the CDC 6600. </title> <journal> Communications of the ACM, </journal> <volume> 10(10) </volume> <pages> 659-665, </pages> <month> October </month> <year> 1967. </year>
Reference-contexts: We have no results yet on the scheme48 interpreter, but we will report on them in the full paper. 5 Related Work Many early operating systems papers discussed the need for extensible kernels <ref> [18, 23, 29, 30, 46, 47] </ref>. Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32].
Reference: [19] <author> Kieran Harty and David R. Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> Proc. of the Fifth Conf. on Architectural Support for Programming languages and Operating Systems, </booktitle> <pages> pages 187-199, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: However, no single policy is best for all applications. For example, file system and relational database applications often have different storage access patterns, and therefore benefit from different buffer and disk management policies. Similar policy conflicts arise in almost every area of 1 resource management <ref> [2, 13, 19, 42] </ref>. While microkernels have pushed some policy decisions out of the kernel into user-level processes, the supervisor mode still defines a fixed interface among the kernel, user-level services, and applications. Applications then suffer from a large number of protection domain crossings.
Reference: [20] <author> D. Hildebrand. </author> <title> An architectural overview of QNX. </title> <booktitle> Proc. Usenix Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: To combat this performance penalty, current microkernels allow reintroduction of code into the 7 kernel: the QNX operating system allows user-level handlers for device I/O <ref> [20] </ref>; Chorus servers are loaded into the kernel [41]; Mach 3.0 has migrated some of the AFS cache manager back into the kernel [38]; the Amoeba file server is usually configured to run in the kernel [43]; Windows/NT runs only non-critical services outside of the kernel [11]; Lepreau et. al. has
Reference: [21] <author> W.C. Hsieh, M.F. Kaashoek, and W.E. Weihl. </author> <title> The persistent relevance of IPC performance: New techniques for reducing the IPC penalty. </title> <booktitle> In Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pages 186-190, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: For example, it does not save and restore registers. Aegis can pass control from one environment to another environment in only 20 MIPS assembly instructions. A very efficient RPC from client to server can be built if the client trusts the server to save and restore registers it uses <ref> [21] </ref>; traditionally RPC systems save and restore at least all general purpose registers. On the R2000 on which Aegis runs, this costs approximately 64 load and store instructions; as memory speeds are not scaling with processor performance and processor is increasing, this overhead will become increasingly expensive.
Reference: [22] <author> N.C. Hutchinson and L.L. Peterson. </author> <title> The x-kernel: an architecture for implementing network protocols. </title> <journal> IEEE Trans. on Soft. Eng., </journal> <volume> 17(1), </volume> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: Like exokernels the Scout project intends to use modern compiler and language technology to improve operating systems. Scout mainly intends to use this technology to optimize critical paths in a communication kernel that is based on their high-performance x-kernel architecture <ref> [22] </ref>. Exokernels are employ compiler technology both for improving performance and controlling the execution of user code in the kernel. Techniques for certifying the safety of code include inspection and sandboxing.
Reference: [23] <author> D.H.R. </author> <title> Huxtable and M.T. Warwick. Dynamic supervisors | their design and construction. </title> <booktitle> Proceedings of the First ACM Symposium on Operating Systems Principles, </booktitle> <year> 1967. </year>
Reference-contexts: We have no results yet on the scheme48 interpreter, but we will report on them in the full paper. 5 Related Work Many early operating systems papers discussed the need for extensible kernels <ref> [18, 23, 29, 30, 46, 47] </ref>. Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32].
Reference: [24] <author> Gerry Kane and Joe Heinrich. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: The R2000/R3000 can be programmed in such way that user programs can execute privileged instructions by writing and reading coprocessor 0 <ref> [24] </ref>. Using this feature, applications can run controlled privileged instructions in user space while maintaining fault isolation among different environments. This scheme will work on any architecture that decouples addressing contexts from the ability to execute privileged instructions. We also have experimented with two language-based approaches to safe customization.
Reference: [25] <author> Richard A. Kelsey and Jonathan A. Rees. </author> <title> Tractable Scheme Implementation. </title> <publisher> Kluwer. </publisher>
Reference-contexts: Using portable runtime code generation [16] we implemented Mogul's safe packet-filter language and compared its performance to an efficient byte-code interpreter of the packet filter. We measured a factor of 10 performance improvement. In addition, we have configured a small Scheme48 <ref> [25] </ref> byte-code interpreter so that it can run inside the Aegis exokernel, allowing us to experiment with executing safely arbitrary user code in the kernel.
Reference: [26] <author> G. Kiczales, J. Lamping, C. Maeda, D. Keppel, and D. McNamee. </author> <title> The need for customizable operating systems. </title> <booktitle> In Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pages 165-170, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Modern revisitations of microkernels have also argued for kernel extensibility [1, 10, 11, 39, 41, 43]. Anderson and Kiczales et al. also recently argued for minimalism and customizability <ref> [2, 26] </ref>.
Reference: [27] <author> J. Kuskin et al. </author> <title> The Stanford FLASH multiprocessor. </title> <booktitle> The 21st Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 302-313, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Using application-specific knowledge, spin-down policies can be much more effective than predictive policies or static ones [13, 33]. New architectures are arriving that support protected user-level communication, requiring little involvement of the operating system <ref> [8, 27] </ref>. By fixing policies, operating system software prevents applications from evolving with the hardware. In this paper we propose a new operating system organization, the exokernel, that delivers hardware performance and hardware functionality directly to applications.
Reference: [28] <author> B.W. Lampson. </author> <title> On reliable and extendable operating systems. State of the Art Report, </title> <type> 1, </type> <year> 1971. </year>
Reference-contexts: We have no results yet on the scheme48 interpreter, but we will report on them in the full paper. 5 Related Work Many early operating systems papers discussed the need for extensible kernels [18, 23, 29, 30, 46, 47]. Lampson's description of the CAL-TSS <ref> [28] </ref> and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32]. Modern revisitations of microkernels have also argued for kernel extensibility [1, 10, 11, 39, 41, 43].
Reference: [29] <author> B.W. Lampson and R.F. Sproull. </author> <title> An open operating system for a single-user machine. </title> <booktitle> Proceedings of the Seventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 98-105, </pages> <year> 1979. </year>
Reference-contexts: We have no results yet on the scheme48 interpreter, but we will report on them in the full paper. 5 Related Work Many early operating systems papers discussed the need for extensible kernels <ref> [18, 23, 29, 30, 46, 47] </ref>. Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32].
Reference: [30] <author> B.W. Lampson and H.E. Sturgis. </author> <title> Reflections on an operating system design. </title> <journal> Communications of the ACM, </journal> <volume> 19(5) </volume> <pages> 251-265, </pages> <month> May </month> <year> 1976. </year>
Reference-contexts: We have no results yet on the scheme48 interpreter, but we will report on them in the full paper. 5 Related Work Many early operating systems papers discussed the need for extensible kernels <ref> [18, 23, 29, 30, 46, 47] </ref>. Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32].
Reference: [31] <author> Jay Lepreau, Mike Hibler, Bryan Ford, and Jeff Law. </author> <title> In-kernel servers in Mach 3.0: implementation and performance. </title> <booktitle> Proc. of the Third Usenix Mach Symposium, </booktitle> <year> 1993. </year>
Reference-contexts: 3.0 has migrated some of the AFS cache manager back into the kernel [38]; the Amoeba file server is usually configured to run in the kernel [43]; Windows/NT runs only non-critical services outside of the kernel [11]; Lepreau et. al. has provided a tool to reintroduce servers into Mach 3.0 <ref> [31] </ref>. Draves has argued for selecting among several implementations of a specific kernel abstraction to allow customization [14]. However, none of these customizations guarantee the safety of the code once introduced.
Reference: [32] <author> R. Levin, E. Cohen, W. Corwin, F. Pollack, and W. Wulf. </author> <booktitle> Policy/mechanism seperation in HYDRA. Proceedings of the Fifth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 132-140, </pages> <year> 1975. </year>
Reference-contexts: Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets <ref> [47, 32] </ref>. Modern revisitations of microkernels have also argued for kernel extensibility [1, 10, 11, 39, 41, 43]. Anderson and Kiczales et al. also recently argued for minimalism and customizability [2, 26].
Reference: [33] <author> Kester Li, Roger Kumpf, Paul Horton, and Thomas Anderson. </author> <title> A quantative analysis of disk drive power management in portable computers. </title> <booktitle> In Proceedings of 1994 Winter Usenix conference, </booktitle> <pages> pages 279-291, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: For example, in a mobile computer it is of crucial importance to save power by carefully managing the spin-down policy of the disk. Using application-specific knowledge, spin-down policies can be much more effective than predictive policies or static ones <ref> [13, 33] </ref>. New architectures are arriving that support protected user-level communication, requiring little involvement of the operating system [8, 27]. By fixing policies, operating system software prevents applications from evolving with the hardware.
Reference: [34] <author> H. Massalin. </author> <title> Synthesis: an efficient implementation of fundamental operating system services. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: Draves has argued for selecting among several implementations of a specific kernel abstraction to allow customization [14]. However, none of these customizations guarantee the safety of the code once introduced. Synthesis is an innovative operating system that has inspired some of our work <ref> [34] </ref>; for example, the use of runtime code generation. The Aegis system, however, uses a portable runtime code generation system [16], while the synthesis kernel is written in assembly, and uses ad-hoc runtime code generation macros to specialize system calls.
Reference: [35] <author> J.C. Mogul, R.F. Rashid, and M.J. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proc. of the Eleventh ACM Symposium on Operating System Principles, </booktitle> <pages> pages 39-51, </pages> <month> Nov. </month> <year> 1987. </year> <month> 10 </month>
Reference-contexts: Fourth, we show how portable dynamic runtime code generation can be used in order to improve the performance of safe user code that is imported into the kernel; we implemented Mogul's packet-filter language <ref> [35] </ref>, compared its performance to an efficient byte-code interpreter, and measured a factor of 10 performance improvement. All four of our contributions are preliminary, as we do not yet have fully integrated system that supports all of them in a single system.
Reference: [36] <author> S.J. Mullender, G. van Rossum, A.S. Tanenbaum, R. van Renesse, and H. van Staveren. </author> <title> Amoeba: a distributed operating system for the 1990s. </title> <journal> IEEE Computer, </journal> <volume> 23(5) </volume> <pages> 44-53, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: For example, the Aegis kernel does not include page-table management, a file-system, remote procedure call, nor device drivers. To allow efficient checking we have chosen a capability-based approach for our prototype. As in Amoeba, Aegis capabilities are large random numbers <ref> [36] </ref>. In a capability-based system specific resources can be awarded to individual applications. Capabilities enable individual applications to efficiently manipulate the resources they own. The use of probabilistic capabilities also enables efficient revocation of resource access.
Reference: [37] <author> A.C. Myers. </author> <title> Resolving the integrity/performance conflict. </title> <booktitle> In Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pages 156-160, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: The use of a type-safe language to allow user applications to augment the operating system has been explored in a personal workstation environment [40]. Myers argued for using a type safe language to load application code into the object manager in a persistent object system <ref> [37] </ref>. In summary, the Aegis system builds on a rich tradition of operating system and language technology.
Reference: [38] <author> David Nagle, Richard Uhlig, Tim Stanley, Stuart Sechrest, Trevor Mudge, and Richard Brown. </author> <title> Design tradeoffs for software-managed TLBs. </title> <booktitle> 20th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 27-38, </pages> <year> 1993. </year>
Reference-contexts: Applications then suffer from a large number of protection domain crossings. These crossings are typically expensive, as they involve entering the supervisor mode, saving and restoring registers, scheduling a thread of control, and manipulating address spaces <ref> [3, 9, 38] </ref>. For example, many applications run slower on the microkernel implementation of Mach than on the monolithic implementation [3]. The disadvantages of fixed operating system policies are made worse by the growing diversity in hardware platforms and rapid advances of technology. <p> To combat this performance penalty, current microkernels allow reintroduction of code into the 7 kernel: the QNX operating system allows user-level handlers for device I/O [20]; Chorus servers are loaded into the kernel [41]; Mach 3.0 has migrated some of the AFS cache manager back into the kernel <ref> [38] </ref>; the Amoeba file server is usually configured to run in the kernel [43]; Windows/NT runs only non-critical services outside of the kernel [11]; Lepreau et. al. has provided a tool to reintroduce servers into Mach 3.0 [31].
Reference: [39] <author> R.F. Rashid and G. Robertson. </author> <title> Accent: A communication oriented network operating system kernel. </title> <booktitle> Proceedings of the Eighth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 64-75, </pages> <month> December </month> <year> 1981. </year>
Reference-contexts: Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32]. Modern revisitations of microkernels have also argued for kernel extensibility <ref> [1, 10, 11, 39, 41, 43] </ref>. Anderson and Kiczales et al. also recently argued for minimalism and customizability [2, 26].
Reference: [40] <author> D.D. Redell, Y.K. Dalal, T.R. Horsley, H.C. Lauer, W.C. Lynch, P.R. McJones, H.G. Murray, </author> <title> and S.C. Purcell. Pilot: An operating system for a personal computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: The use of a type-safe language to allow user applications to augment the operating system has been explored in a personal workstation environment <ref> [40] </ref>. Myers argued for using a type safe language to load application code into the object manager in a persistent object system [37]. In summary, the Aegis system builds on a rich tradition of operating system and language technology.
Reference: [41] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> Chorus distributed operating system. </title> <journal> Computing Systems, </journal> <volume> 1(4) </volume> <pages> 305-370, </pages> <year> 1988. </year>
Reference-contexts: Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32]. Modern revisitations of microkernels have also argued for kernel extensibility <ref> [1, 10, 11, 39, 41, 43] </ref>. Anderson and Kiczales et al. also recently argued for minimalism and customizability [2, 26]. <p> To combat this performance penalty, current microkernels allow reintroduction of code into the 7 kernel: the QNX operating system allows user-level handlers for device I/O [20]; Chorus servers are loaded into the kernel <ref> [41] </ref>; Mach 3.0 has migrated some of the AFS cache manager back into the kernel [38]; the Amoeba file server is usually configured to run in the kernel [43]; Windows/NT runs only non-critical services outside of the kernel [11]; Lepreau et. al. has provided a tool to reintroduce servers into Mach
Reference: [42] <author> M. Stonebraker. </author> <title> Operating system support for database management. </title> <journal> CACM, </journal> <volume> 24(7) </volume> <pages> 412-418, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: However, no single policy is best for all applications. For example, file system and relational database applications often have different storage access patterns, and therefore benefit from different buffer and disk management policies. Similar policy conflicts arise in almost every area of 1 resource management <ref> [2, 13, 19, 42] </ref>. While microkernels have pushed some policy decisions out of the kernel into user-level processes, the supervisor mode still defines a fixed interface among the kernel, user-level services, and applications. Applications then suffer from a large number of protection domain crossings.
Reference: [43] <author> A.S. Tanenbaum, R. van Renesse, H. van Staveren, G. Sharp, S.J. Mullender, A. Jansen, and G. van Rossum. </author> <title> Experiences with the Amoeba distributed operating system. </title> <journal> Communications of the ACM, </journal> <volume> 33(12) </volume> <pages> 46-63, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32]. Modern revisitations of microkernels have also argued for kernel extensibility <ref> [1, 10, 11, 39, 41, 43] </ref>. Anderson and Kiczales et al. also recently argued for minimalism and customizability [2, 26]. <p> into the 7 kernel: the QNX operating system allows user-level handlers for device I/O [20]; Chorus servers are loaded into the kernel [41]; Mach 3.0 has migrated some of the AFS cache manager back into the kernel [38]; the Amoeba file server is usually configured to run in the kernel <ref> [43] </ref>; Windows/NT runs only non-critical services outside of the kernel [11]; Lepreau et. al. has provided a tool to reintroduce servers into Mach 3.0 [31]. Draves has argued for selecting among several implementations of a specific kernel abstraction to allow customization [14].
Reference: [44] <author> Chandramohan A. Thekkath and Henry M. Levy. </author> <title> Hardware and software support for efficient exception handling. </title> <booktitle> In Proceedings of the 6th International Conference on Architectural Support for Programming Languages and Operating Systems (to appear), </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: For example, garbage collectors and distributed shared memory systems can effectively be integrated with the virtual memory systems, 6 which is also under application control. Thekkath has also recently advocated and exploited the usage of such inexpensive user-level traps <ref> [44] </ref>. Aegis can support efficient emulation of multiple operating system APIs (e.g., BSD4.3, Win32) by tailoring the usage of physical resources to a specific system and by taking advantage of inexpensive user-level traps.
Reference: [45] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <year> 1993. </year>
Reference-contexts: Third, we introduce an efficient variant of sandboxing <ref> [45] </ref> in which only unrestricted jumps and privileged instructions have to be controlled instead of all indirect stores and loads. <p> Inlined cross-domain calls. Code inspection that prohibits indirect loads and stores will be too restrictive for many application purposes. Wahbe <ref> [45] </ref> shows that sandboxing can be 4 by containing operating system (OS) code. A small exokernel immediately reflects interrupts, exceptions, and traps back to the application. <p> We are investigating multiple ways of safe customization: one using code inspection and inlined cross-domain calls, and two language-based approaches. We have experimented with an efficient code inspection scheme that only needs to control jumps and privileged instructions (instead of jumps and indirect load and stores as in sandboxing <ref> [45] </ref>) that takes advantage of the architecture of the MIPS R2000/R3000. The R2000/R3000 can be programmed in such way that user programs can execute privileged instructions by writing and reading coprocessor 0 [24]. <p> Techniques for certifying the safety of code include inspection and sandboxing. Deutsch showed how to safely introduce user-written instrumentation code into a running kernel by bounding loads, stores, jumps and runtime [12]. Making existing binaries safe has been explored by Wahbe <ref> [45] </ref>. Although this technique will be useful for controlling entry points, we expect that loads and stores can be constrained more efficiently by changing the address context quickly within supervisor mode.
Reference: [46] <author> B.A. Wichmann. </author> <title> A modular operating system. </title> <booktitle> Proc. IFIP Cong. </booktitle> <year> 1968, 1968. </year>
Reference-contexts: We have no results yet on the scheme48 interpreter, but we will report on them in the full paper. 5 Related Work Many early operating systems papers discussed the need for extensible kernels <ref> [18, 23, 29, 30, 46, 47] </ref>. Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32].
Reference: [47] <author> W. Wulf, E. Cohen, W. Corwin, A. Jones, R. Levin, C. Pierson, and F. Pollack. HYDRA: </author> <title> The kernel of a multiprocessing operating system. </title> <journal> Communications of the ACM, </journal> <volume> 17(6) </volume> <pages> 337-345, </pages> <month> July </month> <year> 1974. </year> <month> 11 </month>
Reference-contexts: We have no results yet on the scheme48 interpreter, but we will report on them in the full paper. 5 Related Work Many early operating systems papers discussed the need for extensible kernels <ref> [18, 23, 29, 30, 46, 47] </ref>. Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets [47, 32]. <p> Lampson's description of the CAL-TSS [28] and Brinch Hansen's microkernel paper [17] are two classic rationales. Hydra was the most ambitious system that had the separation of kernel policy and mechanism as one of its central tenets <ref> [47, 32] </ref>. Modern revisitations of microkernels have also argued for kernel extensibility [1, 10, 11, 39, 41, 43]. Anderson and Kiczales et al. also recently argued for minimalism and customizability [2, 26].
References-found: 47

