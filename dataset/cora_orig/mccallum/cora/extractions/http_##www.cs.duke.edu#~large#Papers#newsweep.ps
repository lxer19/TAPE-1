URL: http://www.cs.duke.edu/~large/Papers/newsweep.ps
Refering-URL: http://www.cs.duke.edu/~large/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: large@daimi.aau.dk  
Title: The Buffer Tree: A New Technique for Optimal I/O-Algorithms (Extended Abstract)  
Author: Lars Arge 
Address: Aarhus, Denmark  
Affiliation: Department of Computer Science, University of  
Note: BRICS  
Abstract: In this paper we develop a technique for transforming an internal memory tree data structure into an external storage structure. We show how the technique can be used to develop a search-tree-like structure, a priority-queue, a (one-dimensional) range-tree and a segment-tree, and give examples of how these structures can be used to develop efficient I/O-algorithms. All our algorithms are either extremely simple or straightforward generalizations of known internal memory algorithms | given the developed external data structures.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aggarwal, J.S. Vitter: </author> <title> The I/O Complexity of Sorting and Related Problems. </title> <booktitle> In Proc. of 14th ICALP (1987), </booktitle> <volume> LNCS 267, </volume> <pages> 467-478, </pages> <editor> and: </editor> <title> The Input/Output Complexity of Sorting and Related Problems. </title> <journal> Communications of the ACM, </journal> <volume> Vol 31 (9) (1988), </volume> <pages> 1116-1127. </pages>
Reference: 2. <author> L. Arge: </author> <title> External-Storage Data Structures for Plane-Sweep Algorithms. </title> <type> BRICS Report Series RS-94-16, </type> <institution> University of Aarhus, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: The buffer tree. The buffer tree is an (a; b)-tree [9] (with a = m=4 and b = m), extended with a buffer of m blocks in each node. The buffer tree is pictured in figure 1 (See <ref> [2] </ref> for a precise definition). <p> We will not go into details about the balancing algorithm, that is, what happens when an update-element reaches a leaf. Basically the I/O-balancing algorithm works like the internal memory algorithm. Details are contained in <ref> [2] </ref>. Using a result due to Huddleston and Mehlhorn [9] we can prove an amortized rebalancing cost of O (1=B) for each update operation. <p> However, the report-algorithm presented in the last section has to be modified when we have rangesearch-elements in the tree. As the modification is technically complicated we will not go into the details in this abstract but just refer to <ref> [2] </ref>. The main problem is that one should remember to report "matches" between insert- and rangesearch-elements in the buffers of the tree that is emptied. This is also the reason why just doing buffer-emptying processes on all the nodes will not work.
Reference: 3. <author> L. Arge, M. Knudsen, K. Larsen: </author> <title> A General Lower Bound on the I/O-Complexity of Comparison-based Algorithms. </title> <booktitle> In Proc. of 3rd WADS (1993), </booktitle> <volume> LNCS 709, </volume> <pages> 83-94. </pages>
Reference-contexts: Segments such as CD that completely span one or more slabs are then called long segments. A copy of each long segment is stored in a list associated with the largest multi-slab it spans. Thus, CD is stored in the list associated with the multi-slab <ref> [ 1 ; 3 ] </ref>. All segments that are not long are called short segments and are not stored in any multi-slab list. Instead, they are passed down to lower levels of the tree where they may span recursively defined slabs and be stored.
Reference: 4. <author> L. Arge, D.E. Vengroff, J.S. Vitter: </author> <title> External-Memory Algorithms for Processing Line Segments in Geographic Information Systems. </title> <type> Manuscript. </type>
Reference-contexts: The multi-slabs for the root super-node are then defined as contiguous ranges of slabs, such as for example <ref> [ 1 ; 4 ] </ref>. There are O (m) multi-slabs and the O (m) lists associated with a super-node is a list for each of the multi-slabs. Segments such as CD that completely span one or more slabs are then called long segments.
Reference: 5. <author> J.L. Bentley, D. Wood: </author> <title> An Optimal Worst Case Algorithm for Reporting Intersections of Rectangles. </title> <journal> IEEE Transactions on Computers 29 (1980), </journal> <pages> 571-577. </pages>
Reference-contexts: An external segment tree based on a set of N segments, three of which, AB, EF and EF , are shown. where a list of segments is associated with each internal node. Each segment is stored in O (log N ) such lists. See e.g. <ref> [5, 17] </ref> for a definition of the segment tree and the operations on it.
Reference: 6. <author> Y-J. Chiang: </author> <title> Experiments on the Practical I/O Efficiency of Geometric Algorithms: Distribution Sweep vs. Plane Sweep. </title> <booktitle> These Proceedings. </booktitle>
Reference: 7. <author> Y-J. Chiang, M.T. Goodrich, E.F. Grove, R. Tamassia, D.E. Vengroff, J.S. Vitter: </author> <title> External-Memory Graph Algorithms. </title> <booktitle> In Proc. of 6th ACM-SIAM SODA (1995), </booktitle> <pages> 139-149. </pages>
Reference: 8. <author> M.T. Goodrich, J. Tsay, D.E. Vengroff, J.S. Vitter: </author> <title> External-Memory Computational Geometry. </title> <booktitle> In Proc. of 34th IEEE FOCS (1993), </booktitle> <pages> 714-723. </pages>
Reference: 9. <author> S. Huddleston, K. Mehlhorn: </author> <title> A New Data Structure for Representing Sorted Lists. </title> <journal> Acta Informatica 17 (1982), </journal> <pages> 157-184. </pages>
Reference-contexts: In later sections we will then extend this basic structure in order to obtain an external priority-queue and an external (one-dimensional) range tree. m blocks B Fig. 1. The buffer tree. The buffer tree is an (a; b)-tree <ref> [9] </ref> (with a = m=4 and b = m), extended with a buffer of m blocks in each node. The buffer tree is pictured in figure 1 (See [2] for a precise definition). <p> We will not go into details about the balancing algorithm, that is, what happens when an update-element reaches a leaf. Basically the I/O-balancing algorithm works like the internal memory algorithm. Details are contained in [2]. Using a result due to Huddleston and Mehlhorn <ref> [9] </ref> we can prove an amortized rebalancing cost of O (1=B) for each update operation. In [9] it is proven that using a particular balancing algorithm, the number of rebalance-operations in an (a; b)-tree is linear in the number of update-operations divided by the hysteresis (b + 1 2a) of the <p> Basically the I/O-balancing algorithm works like the internal memory algorithm. Details are contained in [2]. Using a result due to Huddleston and Mehlhorn <ref> [9] </ref> we can prove an amortized rebalancing cost of O (1=B) for each update operation. In [9] it is proven that using a particular balancing algorithm, the number of rebalance-operations in an (a; b)-tree is linear in the number of update-operations divided by the hysteresis (b + 1 2a) of the tree.
Reference: 10. <author> Ch. Icking, R. Klein, Th. Ottmann: </author> <title> Priority Search Trees in Secondary Memory. </title> <booktitle> In Proc. of 1987 Graph-Theoretic Concepts in Computer Science, </booktitle> <volume> LNCS 314, </volume> <pages> 84-93. </pages>
Reference: 11. <author> P.C. Kanellakis, S. Ramaswamy, D.E. Vengroff, J.S. Vitter: </author> <title> Indexing for Data Models with Constraints and Classes. </title> <booktitle> In Proc. 12th ACM PODS (1993), </booktitle> <pages> 233-243. </pages>
Reference: 12. <author> D.E. Knuth: </author> <title> The Art of Computer Programming, Vol 3: Sorting and Searching, </title> <publisher> Addison-Wesley (1973). </publisher>
Reference: 13. <author> M.H. Nodine, J.S. Vitter: </author> <title> Deterministic Distribution Sort in Shared and Distributed Memory Multiprocessors. </title> <booktitle> In Proc. of 5th ACM SPAA (1993). </booktitle>
Reference: 14. <author> S. Ramaswamy, S. Subramanian: </author> <title> Path Caching: A Technique for Optimal External Searching. </title> <booktitle> In Proc. 13th ACM PODS (1994), </booktitle> <pages> 25-35. </pages>
Reference: 15. <author> S. Subramanian, S. Ramaswamy: </author> <title> The P-range Tree: A New Data Structure for Range Searching in Secondary Memory. </title> <booktitle> In Proc. 6th ACM-SIAM SODA (1995), </booktitle> <pages> 378-387. </pages>
Reference: 16. <author> N.P. Yale: </author> <title> The I/O Subsystem A Candidate for Improvement. </title> <booktitle> Guest Editor's Introduction in IEEE Computer 27 (3) (1994), </booktitle> <pages> 15-16. </pages>
Reference: 17. <author> F. Preparata, M. Shamos: </author> <title> Computational Geometry, An Introduction. </title> <booktitle> Text and Monographs in Computer Science, </booktitle> <publisher> Springer-Verlag 1985. </publisher>
Reference-contexts: An external segment tree based on a set of N segments, three of which, AB, EF and EF , are shown. where a list of segments is associated with each internal node. Each segment is stored in O (log N ) such lists. See e.g. <ref> [5, 17] </ref> for a definition of the segment tree and the operations on it.
Reference: 18. <author> C. Ruemmler, J. Wilkes: </author> <title> An Introduction to Disk Drive Modeling. </title> <booktitle> IEEE Computer 27 (3) (1994). </booktitle>
Reference: 19. <author> M. Smid: </author> <title> Dynamic Data Structures on Multiple Storage Media. </title> <booktitle> Ph.D thesis University of Amsterdam 1989. </booktitle>
Reference: 20. <author> D.E. Vengroff: </author> <title> A Transparent Parallel I/O Environment. </title> <booktitle> In Proc. of 1994 DAGS Symposium on Parallel Computation. </booktitle>
Reference: 21. <author> J.S. Vitter: </author> <title> Efficient Memory Access in Large-Scale Computation (invited paper). </title> <booktitle> In Proc. of 8th STACS (1991), </booktitle> <volume> LNCS 480, </volume> <pages> 26-41. </pages>
Reference: 22. <author> J.S. Vitter, E.A.M. Shriver: </author> <title> Algorithms for Parallel Memory I: Two-Level Memories. </title> <journal> Algorithmica, </journal> <month> 12 (2) </month> <year> (1994). </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
References-found: 22

