URL: http://www.cs.man.ac.uk/~kung-kiu/pub/lopstr93.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kung-kiu@cs.man.ac.uk  ornaghi@imiucca.csi.unimi.it  
Title: A Formal View of Specification, Deductive Synthesis and Transformation of Logic Programs  
Author: Kung-Kiu Lau Mario Ornaghi 
Address: Oxford Road, Manchester M13 9PL, United Kingdom  Via Comelico 39/41, Milano, Italy  
Affiliation: Department of Computer Science, University of Manchester  Dipartimento di Scienze dell'Informazione Universita' degli studi di Milano  
Abstract: We view logic programs as (first-order) axiomatisations, and deductive synthesis and transformation as operations on mathematical systems composed of axioms and "logical" systems such as SLD and SLDNF. In this framework, we distinguish between specification, deductive synthesis and transformation and discuss their inter-relationships. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Deville. </author> <title> Logic Programming: Systematic Program Development. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: list [ D prefix ; Ans (fprefix (M; n) j n is groundg); CLi (1) where S list is a (sufficiently rich) theory of lists, for instance containing identity axioms, axioms for list operations, induction schema on lists, etc; D prefix is the definition axiom (called a logic description in <ref> [1] </ref>): prefix (L; M ) $ 8i length (L): L [i] = M [i] ; Ans is the function associating with every goal prefix (M; n) the set of formulas of the form prefix (o; n) (o being any term). <p> Not every possible answer is a 2 By G and Ans we can specify things like directionality <ref> [1] </ref>, pre- and post-conditions, and other possible requirements. valid answer. <p> We will call it specification synthesis to distinguish it from program synthesis. Our specification synthesis corresponds to the construction of logic descriptions of <ref> [1] </ref>. We now give a simple example of specification synthesis. Example 6.1 Consider the problem of finding all the prefixes of a list L. The first step of formalising the problem is to state a logic language for lists and its intended interpretation. Suppose we choose the following language. <p> This definition is very close to the notion of correctness in <ref> [1] </ref> and allows us to use negation in an appropriate way. In general, parametric specifications cannot be used to completely define relations. For example, if in S list the sort Els is a parameter, we have no ground terms for this sort.
Reference: [2] <author> A. Eriksson, A.-L. Johansson and S.- A.Tarnlund. </author> <title> Towards a Derivation Editor. </title> <editor> In M. van Caneghem and D.H.D. Warren, editors, </editor> <booktitle> Logic Program ming and its Applications, </booktitle> <pages> pages 117-126. </pages> <publisher> Ablex Publ. Co., </publisher> <year> 1986. </year> <title> 35 In [2], program synthesis and transformation are respectively classified as (i) a derivation from a definition D d of data structures and a definition D r about relations or functions; and (ii) a derivation from a program and the definitions D d and D r . Such a distinction is really very similar to ours in spirit. </title> <year> 1990. </year>
Reference: [3] <author> J.A. Goguen and J. Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In B. Shriver and P. Weg-ner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417-477. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year> <month> 283, </month>
Reference-contexts: On the other hand, ordering is related to properties of the elements, and hence characterises particular kinds of lists, corresponding to subclasses. Examples 9.1 and 9.2 show how abstract data types, classes and inheritance (as introduced in <ref> [3] </ref> for example) can be managed in logic program synthesis. Moreover, synthesis methods can be used both in program and in specification synthesis, so that we have a framework where synthesis and specification can be mixed in very natural way, without confusing one with the other.
Reference: [4] <author> A. Hansson and S.- A. </author> <title> Tarnlund. A natural programming calculus. </title> <booktitle> In Proc. </booktitle> <pages> IJCAI-79 , pages 348-355, </pages> <year> 1979. </year>
Reference-contexts: approach, the specification is given in the form of a set of axioms, and the synthesis process systematically derives a set of clauses which are logical consequences of these axioms. 1 Examples of deductive synthesis 1 Note that Manna and Waldinger [10] use deductive synthesis to mean proofs-as-programs. methods include <ref> [4, 5, 6] </ref>. In Section 2 we give an informal overview of our terminology and our proposed distinction. In Section 3 we summarise the formal terminology for our formal framework described in Section 4.
Reference: [5] <author> C.J. </author> <title> Hogger. Derivation of logic programs. </title> <journal> Journal of the ACM , 28, </journal> <pages> 372-392, </pages> <year> 1981. </year>
Reference-contexts: approach, the specification is given in the form of a set of axioms, and the synthesis process systematically derives a set of clauses which are logical consequences of these axioms. 1 Examples of deductive synthesis 1 Note that Manna and Waldinger [10] use deductive synthesis to mean proofs-as-programs. methods include <ref> [4, 5, 6] </ref>. In Section 2 we give an informal overview of our terminology and our proposed distinction. In Section 3 we summarise the formal terminology for our formal framework described in Section 4.
Reference: [6] <author> K.K. Lau and S.D. Prestwich. </author> <title> Top-down synthesis of recursive logic procedures from first-order logic specifications. </title> <editor> In D.H.D. Warren and P. Sz-eredi, editors, </editor> <booktitle> Proc. 7 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 667-684. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: approach, the specification is given in the form of a set of axioms, and the synthesis process systematically derives a set of clauses which are logical consequences of these axioms. 1 Examples of deductive synthesis 1 Note that Manna and Waldinger [10] use deductive synthesis to mean proofs-as-programs. methods include <ref> [4, 5, 6] </ref>. In Section 2 we give an informal overview of our terminology and our proposed distinction. In Section 3 we summarise the formal terminology for our formal framework described in Section 4.
Reference: [7] <author> K.K. Lau and M. Ornaghi. </author> <title> Towards a formal framework for deductive synthesis of logic programs. </title> <type> Technical Report UMCS-92-11-2, </type> <institution> Department of Computer Science, University of Manchester, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: However, it was not clear whether the distinction is mainly based on pragmatic considerations or on more fundamental reasons. In this paper, we will propose and formalise a distinction between specification, synthesis, and transformation. This distinction is based on a formal framework described in <ref> [7] </ref> and [8]. In this framework, we view logic programs as (first-order) axiomatisations. Specification, synthesis and transformation are operations on mathematical systems which are composed of axioms and logical systems such as Classical Logic (CL), SLD and SLDNF . <p> For such systems, the definitions of v and i are as before. 4 A Formal Framework for Deductive Synthesis In this section, we summarise our framework for deductive synthesis of logic programs in <ref> [7, 8] </ref>. For logic programming notation, we shall follow [9] closely. <p> P 1 P n are logic programs, and S [ D k [ Ax (P k ) ` CL Ax (P k+1 ); for 1 k &lt; n : (5) By insisting on (5) (and using (2) and (3)) we can prove the partial correctness of every P h (see <ref> [7, 8] </ref> for details), but not total correctness.
Reference: [8] <author> K.K. Lau and M. Ornaghi. </author> <title> An incompleteness result for deductive synthesis of logic programs. </title> <editor> In D.S. Warren, editor, </editor> <booktitle> Proc. 10 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 456-477, </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: However, it was not clear whether the distinction is mainly based on pragmatic considerations or on more fundamental reasons. In this paper, we will propose and formalise a distinction between specification, synthesis, and transformation. This distinction is based on a formal framework described in [7] and <ref> [8] </ref>. In this framework, we view logic programs as (first-order) axiomatisations. Specification, synthesis and transformation are operations on mathematical systems which are composed of axioms and logical systems such as Classical Logic (CL), SLD and SLDNF . <p> That is, S `properly contains' Ax (P ) in an informal sense. In general, specification frameworks are infinite first order axiomatisations; then every synthesised program is necessarily a smaller subsystem. This fact and the stronger incompleteness result of <ref> [8] </ref> show that specifications and programs are different 3 and that synthesis is a process of specialisation. 2.3 Transformation Transformation is defined as getting a program P 2 from a given program P 1 , such that P 1 and P 2 are equivalent programs. <p> For such systems, the definitions of v and i are as before. 4 A Formal Framework for Deductive Synthesis In this section, we summarise our framework for deductive synthesis of logic programs in <ref> [7, 8] </ref>. For logic programming notation, we shall follow [9] closely. <p> P 1 P n are logic programs, and S [ D k [ Ax (P k ) ` CL Ax (P k+1 ); for 1 k &lt; n : (5) By insisting on (5) (and using (2) and (3)) we can prove the partial correctness of every P h (see <ref> [7, 8] </ref> for details), but not total correctness.
Reference: [9] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: ) [ D; CLi i hAx (P 2 ) [ D; CLi where D is a set of definition axioms, linking the predicate symbols of the two programs. 3 Note that if S is finite, then there exists a logic program P whose completion is equivalent to S (see, e.g. <ref> [9, 11] </ref>) and this difference disappears. <p> For such systems, the definitions of v and i are as before. 4 A Formal Framework for Deductive Synthesis In this section, we summarise our framework for deductive synthesis of logic programs in [7, 8]. For logic programming notation, we shall follow <ref> [9] </ref> closely. <p> N ) ) 0 G N 0 where P D is a definite program, G D a definite goal, and is a SLD - refutation of G D with program P D and computed answer ; P N is a normal 11 See the equality theory on p. 79 in <ref> [9] </ref>. 12 That is, first-order closed formulas of some first-order language. 13 We do not need to consider any precise representation of SLD- or SLDNF -refutations. program, G N a normal goal, and 0 is a SLDNF -refutation of G N with pro-gram P N and computed answer 0 . <p> In the second definition, instead of (7), we require hS [ D; CLi i hComp fl (P ); CLi : In this case every finite axiomatisation represents a program. Indeed, S can be transformed into an equivalent Comp fl (P ) according to <ref> [9] </ref>. Thus deriving a program P from S does not extract a small part of S (as in the case of deductive program synthesis), but an equivalent axiomatisation.
Reference: [10] <author> Z. Manna and R. Waldinger. </author> <title> A deductive approach to program synthesis. </title> <journal> ACM TOPLAS , 2(1) </journal> <pages> 90-121, </pages> <month> Jan </month> <year> 1980. </year>
Reference-contexts: In this approach, the specification is given in the form of a set of axioms, and the synthesis process systematically derives a set of clauses which are logical consequences of these axioms. 1 Examples of deductive synthesis 1 Note that Manna and Waldinger <ref> [10] </ref> use deductive synthesis to mean proofs-as-programs. methods include [4, 5, 6]. In Section 2 we give an informal overview of our terminology and our proposed distinction. In Section 3 we summarise the formal terminology for our formal framework described in Section 4.
Reference: [11] <author> J.C. Shepherdson. </author> <title> Negation in Logic Programming. </title> <editor> in J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: ) [ D; CLi i hAx (P 2 ) [ D; CLi where D is a set of definition axioms, linking the predicate symbols of the two programs. 3 Note that if S is finite, then there exists a logic program P whose completion is equivalent to S (see, e.g. <ref> [9, 11] </ref>) and this difference disappears.
References-found: 11

