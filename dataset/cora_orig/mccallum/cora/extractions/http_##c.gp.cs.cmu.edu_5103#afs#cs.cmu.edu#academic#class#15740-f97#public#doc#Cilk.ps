URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/academic/class/15740-f97/public/doc/Cilk.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/academic/class/15740-f97/public/doc/
Root-URL: http://www.cs.cmu.edu
Title: Cilk-5.1 (Beta 1) Reference Manual  
Note: 1 Cilk is a trademark of the Massachusetts Institute of Technology. The Cilk project is supported in part by DARPA Grant N00014-94-1-0985. This manual is Copyright c  
Date: September 10, 1997  1997  
Web: http://theory.lcs.mit.edu/~cilk  
Affiliation: Supercomputing Technologies Group MIT Laboratory for Computer Science  Massachusetts Institute of Technology.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Selim G. Akl and Nicola Santoro. </author> <title> Optimal parallel merging and sorting without memory conflicts. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(11), </volume> <month> November </month> <year> 1987. </year>
Reference-contexts: To better understand this guarantee, this section surveys the major characteristics of Cilk's algorithmic model. 6 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int (int - (n&lt;2) return (n); else-int y; = (n-1); = (n-2); return (x+y); -int main (int argc, char *argv []) - n, result; n atoi (argv <ref> [1] </ref>); result = (n); printf ("Result: %d"n", result); return 0; (a) #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;cilk.h&gt; cilk int (int - (n&lt;2) return n; else-int y; = spawn fib y spawn fib sync;return (x+y); -cilk int main (int argc, char *argv []) - n, result; n atoi (argv [1]); result = <p> atoi (argv <ref> [1] </ref>); result = (n); printf ("Result: %d"n", result); return 0; (a) #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;cilk.h&gt; cilk int (int - (n&lt;2) return n; else-int y; = spawn fib y spawn fib sync;return (x+y); -cilk int main (int argc, char *argv []) - n, result; n atoi (argv [1]); result = spawn fib (n); sync;printf ("Result: %d"n", result); return 0; (b) Figure 2.1: A serial C program to compute the th onacci n b (b) parallel Cilk program to compute the th onacci n b 7 rounded rectangle, is broken into sequences of threads, shown as circles. <p> new_config [ i] j; catch (spawn nqueens (ne w_c ig, i+1)); (done != NULL) break; sync;return done; -cilk int main (int argc, char *argv []) - n, char *config; char *result; if (argc &lt; - printf ("% s: number of queens required"n" , argv [0]); return 1; = atoi (argv <ref> [1] </ref> config = Cilk_alloc a (n sizeof (char )); printf ("run ni queens %d"n", result = spawn nqueens (co nf n, sync;if (result != NULL) - printf ("S olu n: for i&lt;n; printf ("%2d ", result [i]) ; printf ("" n") else printf ("N o solutions! "n return 0; Figure 2.9: <p> See the Cilk web page. 3.3 Sort The file is called cilksort.cilk. Algorithm Description The file cilksort.cilk provides an implementation of a fast parallel sorting algorithm, donned "Multisort," which is a variant of ordinary mergesort. Multisort is inspired by <ref> [1] </ref>. Multisort begins by dividing an array of elements in half and sorting each half. It then merges the two sorted halves back together, but in a divide-and-conquer approach rather than the usual serial merge.
Reference: [2] <author> Robert D. Blumofe. </author> <title> Managing storage for multithreaded computations. </title> <type> Master's thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachu-setts Institute of Technology, </institution> <month> September </month> <year> 1992. </year> <note> Also available as MIT Laboratory for Computer Science Technical Report MIT/LCS/TR-552. </note>
Reference: [3] <author> Robert D. Blumofe. </author> <title> Executing Multithreaded Programs Efficiently. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: These results led to the development of a performance model that accurately predicts the efficiency of a Cilk program using two simple parameters: work and critical-path length <ref> [6, 8, 3] </ref>. More recent research has included page faults as a measure of locality [4, 5, 19]. <p> With the addition of a provably good scheduler and the incorporation of many other parallel programming features, the system was rechristened "Cilk-1." Among the platforms that supported Cilk-1, notable was an adaptively parallel and fault-tolerant network-of-workstations implementation, called Cilk-NOW <ref> [3, 9] </ref>. The next release, Cilk-2, featured full typechecking, supported all of ANSI C in its C-language subset, and offered call-return semantics for writing multithreaded procedures. The runtime system was made more portable, and the base release included support for several architectures other than the CM-5. <p> The two MIT Ph.D. theses <ref> [3, 19] </ref> contain more detailed descriptions of the foundation and history of early Cilk versions. 1.3 About this manual This manual is primarily intended for users who wish to write Cilk application programs. <p> Its name really is k-n-ary. It can be used to generate arbitrary sizes of serial and parallel work. For more on Knary and its relation to the dag it generates, see Bobby Blumofe's thesis <ref> [3] </ref> (available from the Cilk homepage). Running the Program The command line is knary -nproc &lt;p&gt; &lt;serial&gt; &lt;parallel&gt; &lt;work&gt; &lt;depth&gt;. Playing around with different numbers for the four arguments can be instructive, since it gives insight in how scheduling is influenced by the relative sizes of the blocks of work.
Reference: [4] <author> Robert D. Blumofe, Matteo Frigo, Chrisopher F. Joerg, Charles E. Leiserson, and Keith H. Randall. </author> <title> An analysis of dag-consistent distributed shared-memory algorithms. </title> <booktitle> In Proceedings of the Eighth Annual ACM Symposium on Parallel Algorithms and Architectures (SPAA), </booktitle> <address> Padua, Italy, </address> <month> June </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: These results led to the development of a performance model that accurately predicts the efficiency of a Cilk program using two simple parameters: work and critical-path length [6, 8, 3]. More recent research has included page faults as a measure of locality <ref> [4, 5, 19] </ref>. <p> Cilk's scheduler guarantees that for a P -processor execution, we have S P S 1 P , which is to say one runtime stack per processor. In fact, much less space may be required for many algorithms (see <ref> [4] </ref>), but the bound S P S 1 P serves as a reasonable limit. If a computation uses moderate amounts of memory when on one processor, you can be assured that it will use no more space per processor when run in parallel. <p> In some circumstances you may find you need to cope with the intricacies of sharing. At a minimum, any implementation of Cilk supports a relaxed consistency model called dag consistency <ref> [4, 5] </ref>. In addition, a Cilk implementation on a particular machine architecture generally allows you to assume (at your own risk) the stronger shared-memory semantics of that machine. Cilk's dag-consistent shared memory provides you with a relaxed consistency model. <p> As an example, on an SMP, you can use the locking and unlocking 6 This definition is for intuition only, since it is not well defined for certain nondeterministic programs. See <ref> [4] </ref> for a proper definition of dag consistency. 15 primitives described in Section 6.12.3 to update regions of memory atomically. Of course, you should be aware of the problems of deadlock that may occur, and your code will not be portable to machines that do not support the same model. <p> The differences lie in the way storage for temporary submatrices is handled. The files are called blockedmul.cilk, notempmul.cilk, and spacemul.cilk. Algorithm Description The program blockedmul is an fi (n 3 )-work, fi (lg 2 n)-critical-path, square matrix multiplication algorithm <ref> [4] </ref>. It uses divide-and-conquer to solve one n fi n multiplication problem by splitting it into 8 n=2 fi n=2 multiplication subproblems and combining the results with one n fi n addition. A temporary matrix of size n fi n is allocated at each divide step. <p> The work of LU is fi (n 3 ), and the critical path is fi (n lg n) <ref> [4] </ref>. Note that usually LU decomposition is expressed as a triply nested for-loop. Cilk is more suited for a divide and conquer strategy (giving the added benefit of locality), hence our choice of the divide and conquer version of LU. <p> Matrices must be square, and dimensions must be a power of 2. This version does not do pivoting, and therefore, it should only be used on matrices for which numerical stability is not an issue. An analysis of this algorithm can be found in <ref> [4] </ref> (available from the Cilk web pages). This program only factors the matrix.
Reference: [5] <author> Robert D. Blumofe, Matteo Frigo, Christopher F. Joerg, Charles E. Leiserson, and Keith H. Randall. </author> <title> Dag-consistent distributed shared memory. </title> <booktitle> In Tenth International Parallel Processing Symposium (IPPS), </booktitle> <pages> pages 132-141, </pages> <address> Honolulu, Hawaii, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: Divide-and-conquer algorithms and tree search are examples of computations that are particularly well suited to Cilk. (For example, our group has developed three world-class chess programs, ?Tech [20], ?Socrates [18], and Cilkchess.) Besides search, we have experimented with numerical algorithms such as matrix factorization <ref> [5] </ref> and N -body simulations, and we are working on other types of applications. <p> These results led to the development of a performance model that accurately predicts the efficiency of a Cilk program using two simple parameters: work and critical-path length [6, 8, 3]. More recent research has included page faults as a measure of locality <ref> [4, 5, 19] </ref>. <p> The runtime system was made more portable, and the base release included support for several architectures other than the CM-5. Cilk-3 featured an implementation of dag-consistent distributed shared memory <ref> [5, 19] </ref>. With this addition of shared memory, Cilk could be applied to solve a much wider class of applications. Dag-consistency is a weak but nonetheless useful consistency model, and its relaxed semantics allows for an efficient, low overhead, software implementation. <p> In some circumstances you may find you need to cope with the intricacies of sharing. At a minimum, any implementation of Cilk supports a relaxed consistency model called dag consistency <ref> [4, 5] </ref>. In addition, a Cilk implementation on a particular machine architecture generally allows you to assume (at your own risk) the stronger shared-memory semantics of that machine. Cilk's dag-consistent shared memory provides you with a relaxed consistency model.
Reference: [6] <author> Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson, Keith H. Randall, and Yuli Zhou. Cilk: </author> <title> An efficient multithreaded runtime system. </title> <booktitle> In Proceedings of the Fifth ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP), </booktitle> <pages> pages 207-216, </pages> <address> Santa Barbara, California, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: Unlike many other multithreaded programming systems, Cilk is algorithmic, in that the runtime system employs a scheduler that allows the performance of programs to be estimated accurately <ref> [6] </ref> based on abstract complexity measures. 1.1 What is included in Cilk-5.1? This base release, which is available from http://theory.lcs.mit.edu/~cilk, includes the Cilk runtime system, the cilk2c compiler, a collection of example programs, and this manual. The full release includes the base release and the Nonde-terminator debugging tool. <p> These results led to the development of a performance model that accurately predicts the efficiency of a Cilk program using two simple parameters: work and critical-path length <ref> [6, 8, 3] </ref>. More recent research has included page faults as a measure of locality [4, 5, 19]. <p> Cilk's work-stealing scheduler executes a Cilk computation on P processors in time T P T 1 =P + O (T 1 ), which is asymptotically optimal. Empirically, the constant factor hidden by the big O is often close to 1 or 2 <ref> [6] </ref>, and the formula T P T 1 =P + T 1 (2.1) is a good approximation of runtime. (This model assumes that the parallel computer has adequate bandwidth in its communication network.) This performance model can be interpreted using the notion of average parallelism , which is given by the <p> execution in terms of its serial space. (We assume here that space is stack allocated and not heap allocated as is provided by the C library function malloc.) Denote by S P the space required 2 This abstract model of execution time ignores memory-hierarchy effects, but is nonetheless quite accurate <ref> [6] </ref>. 9 compiler, a type-checking preprocessor which generates C output. This output is then compiled with gcc and linked with the Cilk runtime library. for a P -processor execution. Then, S 1 is the space required for an execution on one processor.
Reference: [7] <author> Robert D. Blumofe and Charles E. Leiserson. </author> <title> Space-efficient scheduling of mul-tithreaded computations. </title> <booktitle> In Proceedings of the Twenty Fifth Annual ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 362-371, </pages> <address> San Diego, California, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: It can be shown that for general multithreaded dags, no good scheduling policy exists. That is, a dag can be constructed for which any schedule that provides linear speedup also requires vastly more than linear expansion of space <ref> [7] </ref>. Fortunately, every Cilk program generates a well-structured dag that can be scheduled efficiently [8]. The Cilk runtime system implements a provably efficiently scheduling policy based 1 Technically, procedure instances. 8 on randomized work-stealing .
Reference: [8] <author> Robert D. Blumofe and Charles E. Leiserson. </author> <title> Scheduling multithreaded computations by work stealing. </title> <booktitle> In Proceedings of the 35th Annual Symposium on Foundations of Computer Science (FOCS), </booktitle> <pages> pages 356-368, </pages> <address> Santa Fe, New Mex-ico, </address> <month> November </month> <year> 1994. </year> <month> 95 </month>
Reference-contexts: These results led to the development of a performance model that accurately predicts the efficiency of a Cilk program using two simple parameters: work and critical-path length <ref> [6, 8, 3] </ref>. More recent research has included page faults as a measure of locality [4, 5, 19]. <p> That is, a dag can be constructed for which any schedule that provides linear speedup also requires vastly more than linear expansion of space [7]. Fortunately, every Cilk program generates a well-structured dag that can be scheduled efficiently <ref> [8] </ref>. The Cilk runtime system implements a provably efficiently scheduling policy based 1 Technically, procedure instances. 8 on randomized work-stealing . During the execution of a Cilk program, when a processor runs out of work, it asks another processor chosen at random for work to do.
Reference: [9] <author> Robert D. Blumofe and David S. Park. </author> <title> Scheduling large-scale parallel compu-tations on networks of workstations. </title> <booktitle> In Proceedings of the Third International Symposium on High Performance Distributed Computing (HPDC), </booktitle> <pages> pages 96-105, </pages> <address> San Francisco, California, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: With the addition of a provably good scheduler and the incorporation of many other parallel programming features, the system was rechristened "Cilk-1." Among the platforms that supported Cilk-1, notable was an adaptively parallel and fault-tolerant network-of-workstations implementation, called Cilk-NOW <ref> [3, 9] </ref>. The next release, Cilk-2, featured full typechecking, supported all of ANSI C in its C-language subset, and offered call-return semantics for writing multithreaded procedures. The runtime system was made more portable, and the base release included support for several architectures other than the CM-5.
Reference: [10] <author> James W. Cooley and John W. Tukey. </author> <title> An algorithm for the machine calculation of complex Fourier series. </title> <journal> Mathematics of computation, </journal> 19(90) 297-301, April 1965. 
Reference-contexts: compiled with optimization -O2, and times are measured with crit ical path measurement on (which hardly impacts the run times for this application). 3.12 Fast Fourier Transform The file is called fft.cilk. 44 Algorithm Description This program is a highly optimized version of the classical Cooley-Tukey Fast Fourier Transform algorithm <ref> [10] </ref>. Some documentation can be found in the source code. Running the Program Type fft -nproc 8 -c for testing for correctness, and fft -nproc 8 -s for testing for speed. Remarks The default data size is 1024. Change the #define SIZE statement in the source code for different sizes.
Reference: [11] <author> David E. Culler, Anurag Sah, Klaus Erik Schauser, Thorsten von Eicken, and John Wawrzynek. </author> <title> Fine-grain parallelism with minimal hardware support: A compiler-controlled threaded abstract machine. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 164-175, </pages> <address> Santa Clara, California, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Cilk provides an inlet feature for this purpose. Inlets are inspired in part by the inlet feature of TAM <ref> [11] </ref>. An inlet is essentially a C function internal to a Cilk procedure. Normally in Cilk, the spawning of a procedure must occur as a separate statement and not in an expression. An exception is made to this rule if the spawn is performed as an argument to an inlet.
Reference: [12] <author> Iain Duff, Roger G. Grimes, and John G. Lewis. </author> <title> Users' guide for the Harwell-Boeing sparse matrix collection (Release I). </title> <type> Technical Report TR/PA/92/86, </type> <institution> CERFACS, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: For these codes, the setup time to read in the input was sufficiently long compared to 34 the runtime that only the core algorithm was measured. For cholesky, numbers for two sparse matrices from the Harwell-Boeing test set <ref> [12] </ref> are reported. The matrix BCSSTK29 has dimension 13992, with 619488 nonzeros, or 0.3 percent of the matrix entries. The BCSSTK32 matrix has dimension 44609, with 1029655 nonzeros, or 0.05 percent of the entries.
Reference: [13] <author> Mingdong Feng and Charles E. Leiserson. </author> <title> Efficient detection of determi-nacy races in Cilk programs. </title> <note> Submitted for publication. Available at URL "ftp://theory.lcs.mit.edu/pub/cilk/spbags.ps.gz", </note> <month> January </month> <year> 1997. </year>
Reference-contexts: Cilk-5 can use operating system threads as well as processes as the scheduling abstraction. Using operating system threads solves some of the I/O naming problems that are present in the process version. Also included in this release is a debugging tool, called the Nondeterminator <ref> [13] </ref>, which helps Cilk programmers to localize determinacy-race bugs in their code. To date, prototype applications developed in Cilk include graphics rendering, pro 3 tein folding [25], backtracking search, N -body simulation, and dense and sparse ma-trix computations. Our largest application effort is a series of chess programs. <p> Segregating the nondeterministic from the deterministic part of your program, however, should greatly narrow your debugging focus. 2.8.2 Using the Nondeterminator The Nondeterminator is a debugging tool to help users detect and locate deter-minacy races <ref> [13, 24] </ref> in their Cilk programs. A determinacy race is a cause of nondeterminism, and it arises when two parallel threads access (read or write) the same shared-memory location, and at least one of the accesses modifies the contents of the location. <p> For example, with cilk-compat.h included, malloc is an alias for Cilk malloc. See Section 6.13.1 for a complete list of aliased functions. 82 Chapter 9 The Nondeterminator The Nondeterminator is a debugging tool to help users detect and locate determinacy-race bugs in their Cilk programs <ref> [13] </ref>. Assuming that the serial execution of the program is deterministic, the Nondeterminator either determines which locations in the program are subject to potential determinacy races when the program is run on the data set, or else certifies that the program is race free when run on the data set.
Reference: [14] <author> Leonardo Pisano (Fibonacci). Liber abbaci, </author> <month> 1202. </month>
Reference-contexts: The next few sections give a short description of each example program. 3.1 Fibonacci The program is called fib.cilk. Algorithm Description This program contains probably the least efficient way to compute Fibonacci numbers <ref> [14] </ref>. It does, however, allow a parallelization in Cilk that is as close to ordinary C as you can possibly get. All it takes is plugging in the spawn and sync keywords in the logical places. Running the Program Try fib -nproc 8 24.
Reference: [15] <author> Michael Halbherr, Yuli Zhou, and Chris F. Joerg. </author> <title> MIMD-style parallel programming with continuation-passing threads. </title> <booktitle> In Proceedings of the 2nd International Workshop on Massive Parallelism: Hardware, Software, and Applications, </booktitle> <address> Capri, Italy, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: The first implementation of Cilk was a direct descendent of PCM/Threaded-C, a C-based package which provided continuation-passing-style threads on Thinking Machines Corporation's Connection Machine Model CM-5 Supercomputer [21] and which used work-stealing as a general scheduling policy to improve the load balance and locality of the computation <ref> [15] </ref>. With the addition of a provably good scheduler and the incorporation of many other parallel programming features, the system was rechristened "Cilk-1." Among the platforms that supported Cilk-1, notable was an adaptively parallel and fault-tolerant network-of-workstations implementation, called Cilk-NOW [3, 9].
Reference: [16] <author> Samuel P. Harbison and Guy L. Steele Jr. </author> <title> C, A Reference Manual. Tartan, </title> <publisher> Inc., </publisher> <year> 1995. </year>
Reference-contexts: The grammar rules are given as additions to the standard ISO C grammar (see <ref> [16, Appendix B] </ref>). As compatibility of the C library with Cilk is a major problem, Section 6.13 discusses some of the issues associated with using the C library in Cilk programs. The typographic conventions used in this chapter are the same as [16]. <p> As compatibility of the C library with Cilk is a major problem, Section 6.13 discusses some of the issues associated with using the C library in Cilk programs. The typographic conventions used in this chapter are the same as <ref> [16] </ref>.
Reference: [17] <author> John L. Hennessy and David A. Patterson. </author> <title> Computer Architecture: a Quantitative Approach. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <note> second edition, </note> <year> 1996. </year>
Reference-contexts: Both functions take a single argument which is a pointer to an object of type Cilk lockvar. Acquiring and releasing a Cilk lock has the memory consistency semantics of release consistency <ref> [17, p. 716] </ref>. The lock object must be initialized using Cilk lock init (). Here is an example: Cilk_lockvar mylock; : - Cilk_lock_init (&mylock); : Cilk_lock (&mylock); : Cilk_unlock (&mylock); - A simple example of code that uses locks is the bucket sort example in Section 3.15.
Reference: [18] <author> Chris Joerg and Bradley C. Kuszmaul. </author> <title> Massively parallel chess. </title> <booktitle> In Proceedings of the Third DIMACS Parallel Implementation Challenge, </booktitle> <institution> Rutgers University, </institution> <address> New Jersey, </address> <month> October </month> <year> 1994. </year> <note> Available as ftp://theory.lcs.mit.edu/ pub/cilk/dimacs94.ps.Z. </note>
Reference-contexts: Divide-and-conquer algorithms and tree search are examples of computations that are particularly well suited to Cilk. (For example, our group has developed three world-class chess programs, ?Tech [20], ?Socrates <ref> [18] </ref>, and Cilkchess.) Besides search, we have experimented with numerical algorithms such as matrix factorization [5] and N -body simulations, and we are working on other types of applications. <p> To date, prototype applications developed in Cilk include graphics rendering, pro 3 tein folding [25], backtracking search, N -body simulation, and dense and sparse ma-trix computations. Our largest application effort is a series of chess programs. The previous program, ?Socrates <ref> [18] </ref>, finished second place (before Deep Thought) in the 1995 ICCA World Computer Chess Championship in Hong Kong running on the 1824-node Intel Paragon at Sandia National Laboratories in New Mexico.
Reference: [19] <author> Christopher F. Joerg. </author> <title> The Cilk System for Parallel Multithreaded Computing. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Mass-achusetts Institute of Technology, </institution> <month> January </month> <year> 1996. </year> <month> 96 </month>
Reference-contexts: These results led to the development of a performance model that accurately predicts the efficiency of a Cilk program using two simple parameters: work and critical-path length [6, 8, 3]. More recent research has included page faults as a measure of locality <ref> [4, 5, 19] </ref>. <p> The runtime system was made more portable, and the base release included support for several architectures other than the CM-5. Cilk-3 featured an implementation of dag-consistent distributed shared memory <ref> [5, 19] </ref>. With this addition of shared memory, Cilk could be applied to solve a much wider class of applications. Dag-consistency is a weak but nonetheless useful consistency model, and its relaxed semantics allows for an efficient, low overhead, software implementation. <p> The two MIT Ph.D. theses <ref> [3, 19] </ref> contain more detailed descriptions of the foundation and history of early Cilk versions. 1.3 About this manual This manual is primarily intended for users who wish to write Cilk application programs.
Reference: [20] <author> Bradley C. Kuszmaul. </author> <title> Synchronized MIMD Computing. </title> <type> PhD thesis, </type> <institution> Depart--ment of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <month> May </month> <year> 1994. </year> <note> Available as MIT Laboratory for Computer Science Technical Report MIT/LCS/TR-645 or ftp://theory.lcs.mit.edu/pub/bradley/ phd.ps.Z. </note>
Reference-contexts: Cilk is designed for computations with dynamic, highly asynchronous parallelism, which can be difficult to write in data-parallel or message-passing style. Divide-and-conquer algorithms and tree search are examples of computations that are particularly well suited to Cilk. (For example, our group has developed three world-class chess programs, ?Tech <ref> [20] </ref>, ?Socrates [18], and Cilkchess.) Besides search, we have experimented with numerical algorithms such as matrix factorization [5] and N -body simulations, and we are working on other types of applications.
Reference: [21] <author> Charles E. Leiserson, Zahi S. Abuhamdeh, David C. Douglas, Carl R. Feynman, Mahesh N. Ganmukhi, Jeffrey V. Hill, W. Daniel Hillis, Bradley C. Kuszmaul, Margaret A. St. Pierre, David S. Wells, Monica C. Wong, Shaw-Wen Yang, and Robert Zak. </author> <title> The network architecture of the Connection Machine CM-5. </title> <booktitle> In Proceedings of the Fourth Annual ACM Symposium on Parallel Algorithms and Architectures (SPAA), </booktitle> <pages> pages 272-285, </pages> <address> San Diego, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: More recent research has included page faults as a measure of locality [4, 5, 19]. The first implementation of Cilk was a direct descendent of PCM/Threaded-C, a C-based package which provided continuation-passing-style threads on Thinking Machines Corporation's Connection Machine Model CM-5 Supercomputer <ref> [21] </ref> and which used work-stealing as a general scheduling policy to improve the load balance and locality of the computation [15].
Reference: [22] <author> Robert C. Miller. </author> <title> A type-checking preprocessor for Cilk 2, a multithreaded C language. </title> <type> Master's thesis, </type> <institution> Department of Electrical Engineering and Computer Science, Massachusetts Institute of Technology, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: By checking the variable SYNCHED, the procedure detects this situation, and the space is reused. Otherwise, it allocates new space for bar. The variable SYNCHED is actually more like a macro than an honest-to-goodness variable. The Cilk type-checking preprocessor <ref> [22] </ref> actually produces two "clones" of each Cilk procedure: a "fast" clone that executes common-case serial code, and a "slow" clone that worries about parallel communication. In the slow clone, which is rarely executed, SYNCHED inspects Cilk's internal state to determine if any children are outstanding. <p> A full list of these bugs can be found in the Cilk distribution's cilk2c directory, in the file BUGS. Our compiler is currently the most buggy of our system's components, a situation which we are actively attempting to remedy. Internals See <ref> [22] </ref> for a description of how cilk2c is constructed.
Reference: [23] <author> Joel Moses. </author> <title> The function of FUNCTION in LISP or why the FUNARG problem should be called the environment problem. </title> <type> Technical Report memo AI-199, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <month> June </month> <year> 1970. </year>
Reference-contexts: In the remainder of this section, we shall assume that the compatibility library header file is included and so that Cilk's version of these functions is used. 2.6.1 Stack memory Cilk uses a cactus stack <ref> [23] </ref> for stack-allocated storage, such as is needed for procedure-local variables. As is shown shown in Figure 2.6, from the point of view of a single Cilk procedure, a cactus stack behaves much like an ordinary stack. The procedure can allocate and free memory by pushing and popping the stack. <p> The stack becomes a cactus stack when multiple procedures execute in parallel, each with its own view of the stack that corresponds to its call history, as shown in Figure 2.6. Cactus stacks in Cilk have essentially the same limitations as ordinary C stacks <ref> [23] </ref>. For instance, a child procedure cannot return to its parent a pointer to an object that it has allocated, since the object will be deallocated automatically when the child returns. Similarly, sibling procedures cannot reference each other's local variables.
Reference: [24] <author> Robert H. B. Netzer and Barton P. Miller. </author> <title> What are race conditions? ACM Letters on Programming Languages and Systems, </title> <booktitle> 1(1) </booktitle> <pages> 74-88, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Segregating the nondeterministic from the deterministic part of your program, however, should greatly narrow your debugging focus. 2.8.2 Using the Nondeterminator The Nondeterminator is a debugging tool to help users detect and locate deter-minacy races <ref> [13, 24] </ref> in their Cilk programs. A determinacy race is a cause of nondeterminism, and it arises when two parallel threads access (read or write) the same shared-memory location, and at least one of the accesses modifies the contents of the location.
Reference: [25] <author> Vijay S. Pande, Christopher F. Joerg, Alexander Yu Grosberg, and Toyoichi Tanaka. </author> <title> Enumerations of the hamiltonian walks on a cubic sublattice. </title> <journal> Journal of Physics A, </journal> <volume> 27, </volume> <year> 1994. </year>
Reference-contexts: Also included in this release is a debugging tool, called the Nondeterminator [13], which helps Cilk programmers to localize determinacy-race bugs in their code. To date, prototype applications developed in Cilk include graphics rendering, pro 3 tein folding <ref> [25] </ref>, backtracking search, N -body simulation, and dense and sparse ma-trix computations. Our largest application effort is a series of chess programs.
Reference: [26] <author> Robert Sedgewick. </author> <title> Implementing quicksort programs. </title> <journal> Comm. ACM, </journal> <volume> 21(10), </volume> <month> October </month> <year> 1978. </year>
Reference-contexts: Remarks The implementation uses the above described algorithm for large arrays but falls back on a serial quicksort and mergesort for small arrays. The code includes an ordinary serial quicksort with some well-known optimizations <ref> [26] </ref>. The quicksort implementation on its own takes 0.95 seconds to sort 1,000,000 32 bit numbers on a single UltraSparc processor.

References-found: 26

