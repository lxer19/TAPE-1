URL: ftp://seldi.uniba.it/pub/papers/csm93.ps
Refering-URL: http://www.cs.umd.edu/~lanubile/public.html
Root-URL: 
Email: email: giuvis@vm.csata.it  
Phone: fax: +39-80-243196  
Title: Function Recovery based on Program Slicing  
Author: F.Lanubile, and G.Visaggio 
Note: 1: Introduction  
Address: Italy  
Affiliation: Dipartimento di Informatica University of Bari,  
Abstract: 1 To make an existing program easier to understand and modify, we propose an expectation-driven model for reverse engineering which identifies and extracts two main kinds of components: environment-dependent operations and domain-dependent functionalities. A reference information model gives expectations of components and their interface data. We apply program slicing, firstly proposed by Weiser, to this function recovery problem by modifying the notion of program slice to a direct slice and transform slice . The former, direct slice, is an executable subset of the original program containing all the statements which directly contribute either to the writing on an external sink or to the reading from an external source. The latter, transform slice, is also an executable subset including all the instructions which directly or indirectly contribute to transform an external input into an external output. This paper proposes a method to locate two basic types of components into a business application system. The former, environment-dependent components, depend on the technological environment which holds a system and usually consist of basic operations on the database, report production, displaying of interface maps, or user-machine dialogue. On the other hand, domain-dependent components characterize a class of problems in the same application domain and typically consist of computational formulas or business rules. The ability of correctly discerning these two classes of components is advantageous when dealing with adaptive maintenance or platform migration which regard only those parts of a program affected by the technological progress. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F.Abbattista, F.Lanubile, and G.Visaggio, </author> <title> "Recovering conceptual data models is human-intensive", </title> <booktitle> to appear in Fifth International Conference on Software Engineering and Knowledge Engineering , San Francisco, </booktitle> <address> California, </address> <year> 1993. </year>
Reference-contexts: Environment and domain-dependent modules are characterized differently as regards their data flow boundaries, and coherently slicing techniques differ too. The techniques are viewed as part of a process model for the reverse engineering of data-oriented applications. In <ref> [1] </ref> a method to recover the conceptual data model and trace entity attributes with data fields in the source code is shown. <p> On the contrary, when the extracted slice is empty or trivial, we can suppose that the expected function has been implemented in another program. In any case, to come to an end, the cognitive capabilities of the reverse engineer are required. This bear out the thesis, explained in <ref> [1] </ref>, that reverse engineering is a human-intensive activity. The following points require improvement and further investigation. Experimentation on large programs: the performances of the function recovery process should be empirically assessed using a significative sample of expected functions with different programs and different subjects.
Reference: [2] <author> F.Cutillo, F.Lanubile, and G.Visaggio, </author> <title> "Extracting application domain functions from old code: a real experience", </title> <booktitle> to appear in 2nd Workshop on Program Comprehension , Capri, </booktitle> <address> Italy, </address> <year> 1993. </year>
Reference-contexts: DIVIDE PR-ACTL-CON BY PR-TRGT-CON 000123 GIVING WS-DEFICIENCY-FRACTION. 000124 MULTIPLY WS-DEFICIENCY-FRACTION BY 100 000125 GIVING WS-DEF-PERCENT. 000126 MOVE WS-DEF-PERCENT TO DL-DEF-PERCENT. - - - - - - - - - - - - - - - - - - - 13 LINES NOT DISPLAYED ****************** BOTTOM OF DATA ******************* "Compute_Deficiency_Percent" In <ref> [2] </ref> a criteria for extracting transform module has been proposed, which takes into account all the statements of the output slice S (EXTOUT) which are not in the input slice, S (EXTINP). The input and output slices considered are independent from the instruction number, as defined in [4]. <p> Lessons learned from the experimentation have concerned both the proposed algorithms and the efficacy of the tool. In fact, the analysis of the results obtained with the difference of slices <ref> [2] </ref> has inducted the formulation of the current algorithm for transform slicing. As regards the tool, although the availability of a commercial tool makes it possible to analyze large Cobol programs, the process of function recovery is still partially automated because our slicing algorithms are not fully supported.
Reference: [3] <author> F.Cutillo, P.Fiore, and G.Visaggio, </author> <title> "Identification and extraction of domain independent components in large programs", </title> <note> to appear in Working Conference on Reverse Engineering , Baltimora, </note> <year> 1993. </year>
Reference-contexts: Our slicing techniques exploit the knowledge of the input/output data coming from the reverse engineering of data. This paper, starting from the lessons learned from experimenting the component extraction ([2], <ref> [3] </ref>), overcomes some previous limitation and specifies the segmentation techniques in a formal way. 2: A reverse engineering process for data oriented application A business system is typically data-oriented because most of its tasks are related to manipulating, retrieving and reporting data from a database.
Reference: [4] <author> K.B.Gallagher and J.R.Lyle, </author> <title> "Using program slicing in software maintenance", </title> <journal> IEEE Transactions on Software Engineering , vol.17, </journal> <volume> no.8, </volume> <month> August </month> <year> 1991. </year>
Reference-contexts: Initially proposed for program debugging and parallel processing [11], later on program slicing has been applied to other activities such as module integration [5], cohesion evaluation [7], testing <ref> [4] </ref> and modification [4]. Our goal is to apply program slicing to reverse engineering but some modification is needed to include only those statements which characterize source, sink and transform modules. <p> Initially proposed for program debugging and parallel processing [11], later on program slicing has been applied to other activities such as module integration [5], cohesion evaluation [7], testing <ref> [4] </ref> and modification [4]. Our goal is to apply program slicing to reverse engineering but some modification is needed to include only those statements which characterize source, sink and transform modules. <p> The input and output slices considered are independent from the instruction number, as defined in <ref> [4] </ref>. The accuracy of this technique is lower with respect to the transform slice algorithm presented in this paper. In fact, variable overloading and conditional instructions may cause the addition of extraneous statements or the deletion of necessary instructions as regards the transform module.
Reference: [5] <author> S.Horwitz, T.Reps, and D.Binkley, </author> <title> "Interprocedural slicing using dependence graphs", </title> <booktitle> in Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation , 1988, </booktitle> <address> pp.35-46. </address>
Reference-contexts: Program slicing finds those portions of source code which might directly or indirectly affect the values of variables at the given instruction . Initially proposed for program debugging and parallel processing [11], later on program slicing has been applied to other activities such as module integration <ref> [5] </ref>, cohesion evaluation [7], testing [4] and modification [4]. Our goal is to apply program slicing to reverse engineering but some modification is needed to include only those statements which characterize source, sink and transform modules.
Reference: [6] <author> J.Jiang, X.Zhou, and D.J.Robson, </author> <title> "Program slicing for C - the problems in implementation", </title> <booktitle> Proceedings of IEEE Conference on Software Maintenance , Sorrento, </booktitle> <address> Italy, </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Starting from zero, the superscripts represent the level of recursion. Some definitions appear different in style as respect to [11], because we have used a more compact notation already appeared in <ref> [6] </ref>. Definition 6 : R c - REF (n) | DEF (n) R c - R c S c 0 (IMS (n)) - 0 (n) represents the relevant variables with potential effects on V when program execution is at instruction n. Search starts from instruction i.
Reference: [7] <author> L.Ott, and J.Thuss, </author> <title> "The relationship between slices and module cohesion", </title> <booktitle> in Proceedings of the 11th International Conference on Software Engineering , 1989, </booktitle> <address> pp.198-204. </address>
Reference-contexts: Program slicing finds those portions of source code which might directly or indirectly affect the values of variables at the given instruction . Initially proposed for program debugging and parallel processing [11], later on program slicing has been applied to other activities such as module integration [5], cohesion evaluation <ref> [7] </ref>, testing [4] and modification [4]. Our goal is to apply program slicing to reverse engineering but some modification is needed to include only those statements which characterize source, sink and transform modules.
Reference: [8] <author> H.van Zuylen, </author> <title> editor, The REDO Compendium of Reverse Engineering for Software Maintenance , John Wiley and Sons Ltd., </title> <address> UK, </address> <year> 1992. </year>
Reference-contexts: 000125 GIVING WS-DEF-PERCENT. 000126 MOVE WS-DEF-PERCENT TO DL-DEF-PERCENT. - - - - - - - - - - - - - - - - - - - 13 LINES NOT DISPLAYED ****************** BOTTOM OF DATA ******************* "Compute_Deficiency_Percent" 4: Related work Among the methods based on static analysis, the REDO project <ref> [8] </ref> also uses program slicing when reverse engineering Cobol programs. The program slicing is used as a technique for a first segmentation of the program into smaller chunks.
Reference: [9] <author> M.Weiser, </author> <title> "Program slicing", </title> <booktitle> in Proceedings of the Fifth International Conference on Software Engineering , 1981, </booktitle> <address> pp.439-449. </address>
Reference-contexts: In this case, the decomposition starts from the component until all the expected subfunctions are obtained. 3: Extraction criteria In order to extract our components we need a decomposition method which uses both data flow and control flow analysis. Program slicing, introduced by Weiser in <ref> [9] </ref>, is based on the observation that we are often interested to only a portion of the program behavior, as in the debugging and modification tasks. In [10] an experiment was conducted whose results confirm the hypothesis that programmers implicitly use slices when debugging unknown programs.
Reference: [10] <author> M.Weiser, </author> <title> "Programmers uses slices when debugging", </title> <journal> Communications of ACM, vol.25, </journal> <volume> no.27, </volume> <month> July </month> <year> 1982, </year> <month> pp.446-452. </month>
Reference-contexts: Program slicing, introduced by Weiser in [9], is based on the observation that we are often interested to only a portion of the program behavior, as in the debugging and modification tasks. In <ref> [10] </ref> an experiment was conducted whose results confirm the hypothesis that programmers implicitly use slices when debugging unknown programs. Program understanding is difficult because slices are often scattered through the entire program, making difficult locating bugs into programs.
Reference: [11] <author> M.Weiser, </author> <title> "Program slicing", </title> <journal> IEEE Transactions on Software Engineering , vol.SE-10, </journal> <volume> no.4, </volume> <month> July </month> <year> 1984, </year> <month> pp.352-357. </month>
Reference-contexts: Moreover, the flexibility of a system is increased if those components which are influenced by the characteristics of the application domain can be easily isolated. We use a modified version of program slicing <ref> [11] </ref> to segment an unknown program in meaningful functionalities. Environment and domain-dependent modules are characterized differently as regards their data flow boundaries, and coherently slicing techniques differ too. The techniques are viewed as part of a process model for the reverse engineering of data-oriented applications. <p> Program slicing finds those portions of source code which might directly or indirectly affect the values of variables at the given instruction . Initially proposed for program debugging and parallel processing <ref> [11] </ref>, later on program slicing has been applied to other activities such as module integration [5], cohesion evaluation [7], testing [4] and modification [4]. <p> The building of S c is defined recursively on the set of variables and statements which have either direct or indirect influence on V. Starting from zero, the superscripts represent the level of recursion. Some definitions appear different in style as respect to <ref> [11] </ref>, because we have used a more compact notation already appeared in [6].
Reference: [12] <author> T.Welburn, and W.Price, </author> <title> Structured Cobol 74/85: Fundamentals and Style , 3rd edition, </title> <publisher> McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: The example is a little Cobol program, taken from <ref> [12] </ref>, which prints a tabular report from an external file after having done some arithmetic calculation. sequential file PATRON-FILE, whose record PATRON-RECORD contains the patron name, target contribution, actual contribution and the contribution date.
Reference: [13] <author> N.Wilde, J.A.Gomez, T.Gust, and D.Strasburg, </author> <title> "Locating user functionality in old code", </title> <booktitle> Proceedings of IEEE Conference on Software Maintenance , Orlando, </booktitle> <address> Florida, </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1992. </year>
Reference-contexts: Reuse of recovered functions: sliced components might be documented and classified to be included in a reuse library of the domain application or a reuse library of the programming environment. Comparison with dynamic analyzers: dynamic methods for design recovery, like that in <ref> [13] </ref> based on test cases, are not necessarily alternative to static analysis methods. Limitations of both methods could be stressed, so that to use static and dynamic methods in a complementary way.
Reference: [14] <author> E.Yourdon, and L.L.Constantine, </author> <title> Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design , NY: </title> <publisher> Yourdon Press, </publisher> <year> 1979. </year>
Reference-contexts: On the other hand, transform modules are typically domain-dependent, because functional requirements are usually modelled in terms of inputs, outputs, and description of the mapping rule. When deriving initial structural designs from the requirements specification, using transform analysis of Structured Design <ref> [14] </ref>, transform modules correspond to the processes in the data flow diagrams. The data recovery phase provides knowledge about the external data. So what we know about a functionality is its external input (EXTINP), its external output (EXTOUT), or both.
References-found: 14

