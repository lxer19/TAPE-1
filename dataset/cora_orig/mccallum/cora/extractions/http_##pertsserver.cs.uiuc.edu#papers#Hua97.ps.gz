URL: http://pertsserver.cs.uiuc.edu/papers/Hua97.ps.gz
Refering-URL: http://pertsserver.cs.uiuc.edu/papers/
Root-URL: http://www.cs.uiuc.edu
Note: c Copyright by Tai-Yi Huang, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffery D. Ullman. </author> <title> Compiler Principles, Techniques, and Tools. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: Kim and Min and Ha [12] developed two techniques to bound data cache performance. The first technique uses a global data-flow analysis <ref> [1] </ref> to distinguish the load/store instructions that reference single memory location from those that reference multiple memory locations. The second technique uses a data dependence analysis [3] to tightly bound the WCET of the load/store instructions that reference multiple memory locations. <p> In the following, we briefly describe the process to construct the linear constraints on x i 's. 3.2.1 Structural Constraints Structural constraints are defined as the linear constraints that can be extracted from the control-flow graph (CFG) <ref> [1] </ref> without any additional information. Figure 3.2 shows a segment of code and its CFG. Li and Malik [21] labeled edges with variables d i 's and basic blocks with variables x i 's in the CFG. <p> Output: the table W [k; z; ff], for k = 1 to K and z = 0 to Z. Procedure: * set W <ref> [1; z; ff] </ref> to e 1 (z) for z = 0 to Z. for z = 0 to Z do f 2. for g = 0 to z do | set W [k; z; ff] to W [k 1; z g; ff] + e k (g) To compute W [K; Z;
Reference: [2] <author> Rukmin Prasanna Amerasinghe. </author> <title> A comprehensive compiler based timing analysis tool for real time software. </title> <type> Master's thesis, </type> <institution> The University of Texas at Austin, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: We also make this assumption. 6 There are several approaches that use loop bound information only. Mok and his students <ref> [2, 4, 29] </ref> analyzed the execution times of assembly language programs generated from the compilation of annotated C programs. They used a graph method to find the worst-case execution path of a program. The WCET of the program is the execution time of this path. <p> For example, to compute W [4; 6; ff], the function first computes W [3; z; ff] for z = 0; 1; : : : ; 6. In turn, both W [3; 6; ff] and W [3; 5; ff] compute W <ref> [2; 5; ff] </ref>. Thus, the direct implementation computes W [2; 5; ff] twice. 72 Name Description # of instructions Tbub selection-sort for 12 elements 1,186 Tcor correlate a 3-dim point to 15 tracks 814 Tmtx multiply two 3x3 matrices 1,170 Tmt2 like Tmtx but unrolls innermost loop 884 Table 8.2: The <p> For example, to compute W [4; 6; ff], the function first computes W [3; z; ff] for z = 0; 1; : : : ; 6. In turn, both W [3; 6; ff] and W [3; 5; ff] compute W <ref> [2; 5; ff] </ref>. Thus, the direct implementation computes W [2; 5; ff] twice. 72 Name Description # of instructions Tbub selection-sort for 12 elements 1,186 Tcor correlate a 3-dim point to 15 tracks 814 Tmtx multiply two 3x3 matrices 1,170 Tmt2 like Tmtx but unrolls innermost loop 884 Table 8.2: The tested CPU tasks To avoid redundant computation, we implement
Reference: [3] <author> U. Banerjee. </author> <title> Loop Transformations for Restructuring Compilers: The Foundations. </title> <publisher> Kluwer Academic Publishers, Norwell, </publisher> <address> Massachusetts, </address> <year> 1993. </year>
Reference-contexts: Kim and Min and Ha [12] developed two techniques to bound data cache performance. The first technique uses a global data-flow analysis [1] to distinguish the load/store instructions that reference single memory location from those that reference multiple memory locations. The second technique uses a data dependence analysis <ref> [3] </ref> to tightly bound the WCET of the load/store instructions that reference multiple memory locations. <p> We increase f <ref> [k; 3] </ref> to 22 if 22 is larger than the value of f [k; 3]. We also increase p [k; 3] to 22 if 22 &gt; p [k; 3]. 2 Example 2 When z = 4 and j = 3; the procedure finds that the subsequence &lt; I 3 ; I <p> We increase f <ref> [k; 3] </ref> to 22 if 22 is larger than the value of f [k; 3]. We also increase p [k; 3] to 22 if 22 &gt; p [k; 3]. 2 Example 2 When z = 4 and j = 3; the procedure finds that the subsequence &lt; I 3 ; I 4 , I 5 &gt; belongs to fi k;4 because 3 = i=3 <p> We increase f <ref> [k; 3] </ref> to 22 if 22 is larger than the value of f [k; 3]. We also increase p [k; 3] to 22 if 22 &gt; p [k; 3]. 2 Example 2 When z = 4 and j = 3; the procedure finds that the subsequence &lt; I 3 ; I 4 , I 5 &gt; belongs to fi k;4 because 3 = i=3 5 X M (I i ) <p> We increase f <ref> [k; 3] </ref> to 22 if 22 is larger than the value of f [k; 3]. We also increase p [k; 3] to 22 if 22 &gt; p [k; 3]. 2 Example 2 When z = 4 and j = 3; the procedure finds that the subsequence &lt; I 3 ; I 4 , I 5 &gt; belongs to fi k;4 because 3 = i=3 5 X M (I i ) = 5 Therefore, we increase p [k; 4] <p> The problem with the direct evaluation of the formula is that it computes the same W [k; z; ff] repeatedly. For example, to compute W [4; 6; ff], the function first computes W <ref> [3; z; ff] </ref> for z = 0; 1; : : : ; 6. In turn, both W [3; 6; ff] and W [3; 5; ff] compute W [2; 5; ff]. <p> For example, to compute W [4; 6; ff], the function first computes W [3; z; ff] for z = 0; 1; : : : ; 6. In turn, both W <ref> [3; 6; ff] </ref> and W [3; 5; ff] compute W [2; 5; ff]. <p> For example, to compute W [4; 6; ff], the function first computes W [3; z; ff] for z = 0; 1; : : : ; 6. In turn, both W [3; 6; ff] and W <ref> [3; 5; ff] </ref> compute W [2; 5; ff].
Reference: [4] <author> Moyer Chen. </author> <title> The dataflow real-time system: A case study. </title> <type> Master's thesis, </type> <institution> The University of Texas at Austin, </institution> <month> December </month> <year> 1987. </year>
Reference-contexts: We also make this assumption. 6 There are several approaches that use loop bound information only. Mok and his students <ref> [2, 4, 29] </ref> analyzed the execution times of assembly language programs generated from the compilation of annotated C programs. They used a graph method to find the worst-case execution path of a program. The WCET of the program is the execution time of this path. <p> p [k; 3]. 2 Example 2 When z = 4 and j = 3; the procedure finds that the subsequence &lt; I 3 ; I 4 , I 5 &gt; belongs to fi k;4 because 3 = i=3 5 X M (I i ) = 5 Therefore, we increase p <ref> [k; 4] </ref> to 36 if the WCET of the subsequence, which is equal to 36, is larger than the current value of p [k; 4]. Because there is no subsequence which begins with I 3 and satisfies P M (I i ) = 4, we leave f [k; 4] unchanged. 2 <p> ; I 4 , I 5 &gt; belongs to fi k;4 because 3 = i=3 5 X M (I i ) = 5 Therefore, we increase p <ref> [k; 4] </ref> to 36 if the WCET of the subsequence, which is equal to 36, is larger than the current value of p [k; 4]. Because there is no subsequence which begins with I 3 and satisfies P M (I i ) = 4, we leave f [k; 4] unchanged. 2 The time complexity of the procedure in Figure 8.1 is O (ZU k ), where U k is the number of instructions in <p> we increase p <ref> [k; 4] </ref> to 36 if the WCET of the subsequence, which is equal to 36, is larger than the current value of p [k; 4]. Because there is no subsequence which begins with I 3 and satisfies P M (I i ) = 4, we leave f [k; 4] unchanged. 2 The time complexity of the procedure in Figure 8.1 is O (ZU k ), where U k is the number of instructions in task A k . <p> The problem with the direct evaluation of the formula is that it computes the same W [k; z; ff] repeatedly. For example, to compute W <ref> [4; 6; ff] </ref>, the function first computes W [3; z; ff] for z = 0; 1; : : : ; 6. In turn, both W [3; 6; ff] and W [3; 5; ff] compute W [2; 5; ff].
Reference: [5] <author> R. Ernst, J. Henkel, and T. Benner. </author> <title> Hardware-software co-synthesis for microcontrollers. </title> <booktitle> IEEE Design and Test of Computers, </booktitle> <pages> pages 64-75, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: This knowledge enables the designers to analyze the schedulability of each task of the system [20, 25, 26]. Similarly, in an embedded system, some functionality may be implemented in hardware to achieve requisite timing performance. The WCET of the system is required to determine this software/hardware partition <ref> [5, 6, 19] </ref>. Consequently, the problem of bounding the WCET of a program has received a great deal of attention in recent years. When a program contains conditional and loop programming structures, the instruction sequence that is actually executed may be different each time the program runs. <p> For example, to compute W [4; 6; ff], the function first computes W [3; z; ff] for z = 0; 1; : : : ; 6. In turn, both W [3; 6; ff] and W <ref> [3; 5; ff] </ref> compute W [2; 5; ff]. <p> For example, to compute W [4; 6; ff], the function first computes W [3; z; ff] for z = 0; 1; : : : ; 6. In turn, both W [3; 6; ff] and W [3; 5; ff] compute W <ref> [2; 5; ff] </ref>. Thus, the direct implementation computes W [2; 5; ff] twice. 72 Name Description # of instructions Tbub selection-sort for 12 elements 1,186 Tcor correlate a 3-dim point to 15 tracks 814 Tmtx multiply two 3x3 matrices 1,170 Tmt2 like Tmtx but unrolls innermost loop 884 Table 8.2: The <p> For example, to compute W [4; 6; ff], the function first computes W [3; z; ff] for z = 0; 1; : : : ; 6. In turn, both W [3; 6; ff] and W [3; 5; ff] compute W <ref> [2; 5; ff] </ref>. Thus, the direct implementation computes W [2; 5; ff] twice. 72 Name Description # of instructions Tbub selection-sort for 12 elements 1,186 Tcor correlate a 3-dim point to 15 tracks 814 Tmtx multiply two 3x3 matrices 1,170 Tmt2 like Tmtx but unrolls innermost loop 884 Table 8.2: The tested CPU tasks To avoid redundant computation, we implement
Reference: [6] <author> Rajesh Kumar Gupta. </author> <title> Co-Synthesis of Hardware and Software for Digital Embedded Systems. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: This knowledge enables the designers to analyze the schedulability of each task of the system [20, 25, 26]. Similarly, in an embedded system, some functionality may be implemented in hardware to achieve requisite timing performance. The WCET of the system is required to determine this software/hardware partition <ref> [5, 6, 19] </ref>. Consequently, the problem of bounding the WCET of a program has received a great deal of attention in recent years. When a program contains conditional and loop programming structures, the instruction sequence that is actually executed may be different each time the program runs. <p> The problem with the direct evaluation of the formula is that it computes the same W [k; z; ff] repeatedly. For example, to compute W <ref> [4; 6; ff] </ref>, the function first computes W [3; z; ff] for z = 0; 1; : : : ; 6. In turn, both W [3; 6; ff] and W [3; 5; ff] compute W [2; 5; ff]. <p> For example, to compute W [4; 6; ff], the function first computes W [3; z; ff] for z = 0; 1; : : : ; 6. In turn, both W <ref> [3; 6; ff] </ref> and W [3; 5; ff] compute W [2; 5; ff].
Reference: [7] <author> Rajiv Gupta and Prabha Gopinath. </author> <title> Correlation analysis techniques for refining execution time estimates of real-time applications. </title> <booktitle> In Proceedings of the IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 54-58, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Puschner and Koza [38, 39, 40] introduced several new language constructs with which programmers can describe the timing behavior of their programs. Their experiments showed that, with this valuable information, the gap between the estimated WCET bound and the real WCET can be reduced significantly. Gupta and Gopinath <ref> [7] </ref> introduced techniques that identify correlation among the execution counts of statements within a program. They used this information to eliminate infeasible paths during the remainder of the program as its execution progresses. Park [34, 35] used regular expressions to describe the execution paths of a program.
Reference: [8] <author> Marion G. Harmon, T. P. Baker, and David B. Whalley. </author> <title> A retargetable technique for predict 84 ing execution time. </title> <booktitle> In Proceedings of the 13th Real-Time Systems Symposium, </booktitle> <pages> pages 68-77, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: The second technique uses a data dependence analysis [3] to tightly bound the WCET of the load/store instructions that reference multiple memory locations. To estimate the WCET of a program that executes on a processor with an instruction pipeline, 8 Harmon and Baker and Whalley <ref> [8, 9] </ref> conducted timing analysis at the micro instruction level and analyzed the effect of pipelined execution through the pattern matching scheme.
Reference: [9] <author> Marion G. Harmon, T. P. Baker, and David B. Whalley. </author> <title> A retargetable technique for predicting execution time of code segments. </title> <journal> Journal of Real-Time Systems, </journal> <pages> pages 159-182, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: The second technique uses a data dependence analysis [3] to tightly bound the WCET of the load/store instructions that reference multiple memory locations. To estimate the WCET of a program that executes on a processor with an instruction pipeline, 8 Harmon and Baker and Whalley <ref> [8, 9] </ref> conducted timing analysis at the micro instruction level and analyzed the effect of pipelined execution through the pattern matching scheme.
Reference: [10] <author> Christopher A Healy, David B. Whalley, and Marion G. Harmon. </author> <title> Integrating the timing analysis of pipelining and instruction caching. </title> <booktitle> In Proceedings of the 16th Real-Time Systems Symposium, </booktitle> <pages> pages 288-297, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Each timing schema provides the information on what may affect the execution time of a succeeding construct. It also stores the information needed to determine the execution time of the construct itself once the execution time of a preceding construct is available. Healy and Whalley and Harmon <ref> [10] </ref> added the timing analysis of instruction pipelining into the method developed by Mueller [30].
Reference: [11] <author> Yerang Hur, Young Hyun Bae, Sung-Soo Lim, Sung-Kwan Kim, Byung-Do Rhee, Sang Lyul Min, Chang Yun Park, Heonshik Shin, and Chong Sang Kim. </author> <title> Worst case timing analysis of RISC processors: R3000/R3010 case study. </title> <booktitle> In Proceedings of the 16th Real-Time Systems Symposium, </booktitle> <pages> pages 308-319, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: The analyzer accounts for the effect of pipelining on the RISC processor when predicting the WCET. Several approaches integrate the timing analysis of instruction caching and pipelining. Lim et al. [24] and Hur et al. <ref> [11] </ref> extended the method developed by Park and Shaw [36] to analyze the effect of instruction caching and pipelining. This method associates each source-level programming language construct with a timing schema. Each timing schema provides the information on what may affect the execution time of a succeeding construct.
Reference: [12] <author> Sung-Kwan Kim, Sang Lyul Min, and Rhan Ha. </author> <title> Efficient worst case timing analysis of data caching. </title> <booktitle> In Proceedings of the 2nd Real-Time Technology and Applications, </booktitle> <pages> pages 230-240, </pages> <address> Brookline, Massachusetts, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: They classify all instructions into always hit, always miss, first hit, and first miss categories and use this instruction categorization information to estimate the worst-case cache performance in a nonpreemptive environment. Kim and Min and Ha <ref> [12] </ref> developed two techniques to bound data cache performance. The first technique uses a global data-flow analysis [1] to distinguish the load/store instructions that reference single memory location from those that reference multiple memory locations.
Reference: [13] <author> David B. Kirk. </author> <title> Smart cache design. </title> <booktitle> In Proceedings of the 10th Real-Time Systems Symposium, </booktitle> <pages> pages 229-237, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Liu and Lee [27] argued that a sufficient condition for determining the tightest WCET of a cached program is to search through all feasible paths exhaustively. They proposed a method that trades off between the tightness of the WCET bound and its computing time. Kirk and Strosnider <ref> [13, 14, 15] </ref> proposed a cache partitioning scheme to provide guaranteed instruction cache hits. According to this scheme an instruction cache is partitioned into a number of dedicated partitions, each of which can be accessed by only a dedicated task.
Reference: [14] <author> David B. Kirk. </author> <title> Predictable Cache Design for Real-Time Systems. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: Liu and Lee [27] argued that a sufficient condition for determining the tightest WCET of a cached program is to search through all feasible paths exhaustively. They proposed a method that trades off between the tightness of the WCET bound and its computing time. Kirk and Strosnider <ref> [13, 14, 15] </ref> proposed a cache partitioning scheme to provide guaranteed instruction cache hits. According to this scheme an instruction cache is partitioned into a number of dedicated partitions, each of which can be accessed by only a dedicated task.
Reference: [15] <author> David B. Kirk and Jay K. Strosnider. </author> <title> Smart cache design using the MIPS R3000. </title> <booktitle> In Proceedings of the 11th Real-Time Systems Symposium, </booktitle> <pages> pages 322-330, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Liu and Lee [27] argued that a sufficient condition for determining the tightest WCET of a cached program is to search through all feasible paths exhaustively. They proposed a method that trades off between the tightness of the WCET bound and its computing time. Kirk and Strosnider <ref> [13, 14, 15] </ref> proposed a cache partitioning scheme to provide guaranteed instruction cache hits. According to this scheme an instruction cache is partitioned into a number of dedicated partitions, each of which can be accessed by only a dedicated task.
Reference: [16] <author> Mark H. Klein and Thomas Ralya. </author> <title> An analysis of input/output paradigms for real-time 85 systems. </title> <type> Technical Report CMU/SEI-90-TR-19, </type> <institution> CMU Software Engineering Institute, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Traditionally, I/O tasks are not allowed in time-critical applications or are restricted to be released at predefined instants such as the beginning and end of a task to make the computation of their WCETs easier <ref> [16, 44] </ref>. Because our method can accurately bound the WCET of cycle-stealing DMA I/O tasks which have an arbitrary release time, this restriction can now be removed. 3 1.2 Dissertation Overview Chapter 2 introduces related work. There have been many methods for bounding the WCET of a program.
Reference: [17] <author> Eugene Klingerman and Alexander D. Stoyenko. </author> <title> Real-time Euclid: A language for reliable real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(9):941-949, </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: The number of the execution paths of a program cannot be bounded unless the iteration count of each loop structure is bounded. All previous studies on bounding WCETs of programs assume that the iteration count of each loop structure in the program being analyzed is bounded <ref> [17, 21, 29, 36, 39, 42] </ref>. We also make this assumption. 6 There are several approaches that use loop bound information only. Mok and his students [2, 4, 29] analyzed the execution times of assembly language programs generated from the compilation of annotated C programs.
Reference: [18] <author> P. M. Kogge. </author> <title> The Architecture of Pipelined Computers. </title> <publisher> Hemisphere Publishing Corp., </publisher> <year> 1981. </year>
Reference-contexts: We call them the cache-hit reservation table and the cache-miss reservation table of the l-block, respectively. A reservation table describes the activities within a pipeline <ref> [18] </ref>. In a reservation table, the rows represent the stages in the pipeline and the columns represent time. For example, Figure 6.1 shows an l-bock and its cache 39 hit reservation table. The instruction pipeline is composed of 4 stages.
Reference: [19] <author> D. Ku and G. D. </author> <title> Micheli. High-Level Synthesis of ASICs under Timing and Synchronization Constraints. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: This knowledge enables the designers to analyze the schedulability of each task of the system [20, 25, 26]. Similarly, in an embedded system, some functionality may be implemented in hardware to achieve requisite timing performance. The WCET of the system is required to determine this software/hardware partition <ref> [5, 6, 19] </ref>. Consequently, the problem of bounding the WCET of a program has received a great deal of attention in recent years. When a program contains conditional and loop programming structures, the instruction sequence that is actually executed may be different each time the program runs.
Reference: [20] <author> John Lehoczky, Lui Sha, and Ye Ding. </author> <title> The rate monotonic scheduling algorithm: Exact characterization and average case behavior. </title> <booktitle> In Proceedings of the 10th Real-Time Systems Symposium, </booktitle> <pages> pages 166-171, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: In such a system, it is essential for the worse-case execution time (WCET) of each program to be known in advance. This knowledge enables the designers to analyze the schedulability of each task of the system <ref> [20, 25, 26] </ref>. Similarly, in an embedded system, some functionality may be implemented in hardware to achieve requisite timing performance. The WCET of the system is required to determine this software/hardware partition [5, 6, 19].
Reference: [21] <author> Yau-Tsun Steven Li and Sharad Malik. </author> <title> Performance analysis of embedded software using implicit path enumeration. </title> <booktitle> In Proceedings of the 32nd ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 456-461, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Most of them assume that the program executes without any interference of cycle-stealing DMA I/O. Chapter 3 presents the machine model that is the basis of this dissertation. It also briefly describes the implicit path-enumeration method developed by Li and Malik <ref> [21] </ref> and its extension [22, 23] which bound the WCET of a program when it executes alone. This dissertation extends the integer linear programming formulation used by these methods to account for the effect of concurrently executing cycle-stealing DMA I/O on the WCET of a program. <p> The number of the execution paths of a program cannot be bounded unless the iteration count of each loop structure is bounded. All previous studies on bounding WCETs of programs assume that the iteration count of each loop structure in the program being analyzed is bounded <ref> [17, 21, 29, 36, 39, 42] </ref>. We also make this assumption. 6 There are several approaches that use loop bound information only. Mok and his students [2, 4, 29] analyzed the execution times of assembly language programs generated from the compilation of annotated C programs. <p> As a result, the maximum execution time of all feasible paths tightly bounds the WCET of the program. As stated in Chapter 1, the methods described in this dissertation starts with the integer 7 linear programming formulation developed by Li and Malik <ref> [21] </ref>. We will return to describe this formulation and their methods for dealing with infeasible paths in the next chapter. 2.2 Execution Time on Contemporary Architectures The assumption that the execution time of each instruction is fixed does not hold on contemporary machines. <p> It next briefly describes the implicit path-enumeration method <ref> [21] </ref> and its extension [22]. The methods described in the following chapters extend the integer linear programming formulation used in these two methods to account for the effect of concurrently executing cycle-stealing DMA I/O. 3.1 Machine Model We adopt here the commonly used machine model shown in Figure 3.1. <p> The CPU does not gain the bus immediately after it requests for the bus if the DMAC is currently transferring data. Therefore, the execution in the CPU may suffer delay, and its completion time is postponed accordingly. 3.2 Implicit Path Enumeration Li and Malik <ref> [21] </ref> developed an implicit path-enumeration method to bound the WCET of a program on a simple architecture. A program to be analyzed executes without any interference of DMA I/O. <p> Figure 3.2 shows a segment of code and its CFG. Li and Malik <ref> [21] </ref> labeled edges with variables d i 's and basic blocks with variables x i 's in the CFG. These variables represent the number of times the control flow passes through these edges and basic blocks. <p> = d 3 = d 4 + d 5 ; x 5 = d 5 = d 7 ; d 1 = 1: The last structural constraint says that the first basic block, labeled x 1 , is executed once. 14 3.2.2 Loop Constraints and Path Constraints Li and Malik <ref> [21] </ref> constructed loop constraints to bound each loop iteration count. <p> The programmer may input such a path constraint x i + x j = 1 to eliminate the infeasible paths which contain both B i and B j . 3.3 Instruction Cache Modeling Li and Malik and Wolfe [22] extended their implicit path-enumeration method <ref> [21] </ref> to bound the WCETs of programs on direct-mapped instruction-cache architectures. This method partitions 15 each basic block into l-blocks. An l-block is a sequence of contiguous instructions within the same basic block that are mapped to the same cache line. <p> We can obtain this information from the reference manual provided by the manufacturer of the processor. We can use this new instruction timing information for every instruction with the implicit path-enumeration method developed by Li and Malik <ref> [21] </ref> to bound the WCET of a program executing 21 concurrently with DMA I/O.
Reference: [22] <author> Yau-Tsun Steven Li, Sharad Malik, and Andrew Wolfe. </author> <title> Efficient microarchitecture modeling and path analysis for real-time software. </title> <booktitle> In Proceedings of the 16th Real-Time Systems Symposium, </booktitle> <pages> pages 298-307, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Most of them assume that the program executes without any interference of cycle-stealing DMA I/O. Chapter 3 presents the machine model that is the basis of this dissertation. It also briefly describes the implicit path-enumeration method developed by Li and Malik [21] and its extension <ref> [22, 23] </ref> which bound the WCET of a program when it executes alone. This dissertation extends the integer linear programming formulation used by these methods to account for the effect of concurrently executing cycle-stealing DMA I/O on the WCET of a program. <p> It next briefly describes the implicit path-enumeration method [21] and its extension <ref> [22] </ref>. The methods described in the following chapters extend the integer linear programming formulation used in these two methods to account for the effect of concurrently executing cycle-stealing DMA I/O. 3.1 Machine Model We adopt here the commonly used machine model shown in Figure 3.1. <p> The programmer may input such a path constraint x i + x j = 1 to eliminate the infeasible paths which contain both B i and B j . 3.3 Instruction Cache Modeling Li and Malik and Wolfe <ref> [22] </ref> extended their implicit path-enumeration method [21] to bound the WCETs of programs on direct-mapped instruction-cache architectures. This method partitions 15 each basic block into l-blocks. An l-block is a sequence of contiguous instructions within the same basic block that are mapped to the same cache line. <p> N X n i X (c h i;j + c m i;j ) (3.2) under a set of linear constraints on the x h i;j 's, x m i;j 's, and x i 's that relate these execution counts with each other. 3.3.1 Cache Constraints Li and Malik and Wolfe <ref> [22] </ref> constructed a set of cache constraints for each cache line. For example, if there is only one l-block B k;l mapping to a cache line, once B k;l is fetched into the mapped cache line it will stay in it until the execution of the program finishes. <p> There is the cache constraint x m h;g 1: Two l-blocks are called conflicting l-blocks if the execution of one l-block will displace the other one. For conflicting l-blocks, the behavior of the mapped cache line depends on the sequence these l-blocks are executed. Li and Malik and Wolfe <ref> [22] </ref> defined a cache conflict graph to model the control flow of the conflicting l-blocks. <p> In contrast, the cache-miss instruction cycle begins with a B-cycle to fetch the instruction, and the subsequent instructions in the l-block from the main memory. 23 5.2 A New Cost Function We extend the method developed by Li and Malik and Wolfe <ref> [22] </ref>, which we discussed in Section 3.3, to bound the WCET of a program executing concurrently with DMA I/O on an instruction-cache architecture. <p> Each x in the reservation table represents that the corresponding stage occurs at the indicated processor clock cycle. The rest of this section describes an extension of the method developed by Li and Malik and Wolfe <ref> [22] </ref> to bound the WCET of a program executing alone on an advanced architecture. We first define the execution time of an l-block. We next give a new cost function whose maximum value is an upper bound of the WCET of the program. <p> The timing tool contains about 15,000 lines of C++ code, part of which is obtained from a tool called Cinderella, which was developed by Li and Malik and Wolfe <ref> [22] </ref>. The code structure of our timing tool Dcind is described in Appendix A. Dcind takes as input a MC68030 assembly program. It requires the user to provide loop bound information. The user can also provide addition information in form of linear constraints to tighten the WCET prediction.
Reference: [23] <author> Yau-Tsun Steven Li, Sharad Malik, and Andrew Wolfe. </author> <title> Performance estimation of embedded software with instruction cache modeling. </title> <booktitle> In Proceedings of the IEEE/ACM International Conference on Computer-Aided Design, </booktitle> <pages> pages 380-387, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: Most of them assume that the program executes without any interference of cycle-stealing DMA I/O. Chapter 3 presents the machine model that is the basis of this dissertation. It also briefly describes the implicit path-enumeration method developed by Li and Malik [21] and its extension <ref> [22, 23] </ref> which bound the WCET of a program when it executes alone. This dissertation extends the integer linear programming formulation used by these methods to account for the effect of concurrently executing cycle-stealing DMA I/O on the WCET of a program.
Reference: [24] <author> Sung-Soo Lim, Young Hyun Bae, Gyu Tae Jang, Byung-Do Rhee, Sang Jyul Min, Chang Yun Park, Heonshik Shin, Kunsoo Park, and Chong Sang Kim. </author> <title> An accurate worst case timing anal-86 ysis technique for RISC processors. </title> <booktitle> In Proceedings of the 15th Real-Time Systems Symposium, </booktitle> <pages> pages 97-108, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: The analyzer accounts for the effect of pipelining on the RISC processor when predicting the WCET. Several approaches integrate the timing analysis of instruction caching and pipelining. Lim et al. <ref> [24] </ref> and Hur et al. [11] extended the method developed by Park and Shaw [36] to analyze the effect of instruction caching and pipelining. This method associates each source-level programming language construct with a timing schema.
Reference: [25] <author> C. L. Liu and J. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 10(1) </volume> <pages> 46-61, </pages> <year> 1973. </year>
Reference-contexts: In such a system, it is essential for the worse-case execution time (WCET) of each program to be known in advance. This knowledge enables the designers to analyze the schedulability of each task of the system <ref> [20, 25, 26] </ref>. Similarly, in an embedded system, some functionality may be implemented in hardware to achieve requisite timing performance. The WCET of the system is required to determine this software/hardware partition [5, 6, 19].
Reference: [26] <author> Jane W.-S. Liu, Juan Luis Redondo, Zhong Deng, Too-Seng Tia, Riccardo Bettati, Ami Silber-man, Matthew Storch, Rhan Ha, and Wei-Kuan Shih. PERTS: </author> <title> A prototyping environment for real-time systems. </title> <booktitle> In Proceedings of the 14th Real-Time Systems Symposium, </booktitle> <pages> pages 184-188, </pages> <address> Raleigh-Durham, North Carolina, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: In such a system, it is essential for the worse-case execution time (WCET) of each program to be known in advance. This knowledge enables the designers to analyze the schedulability of each task of the system <ref> [20, 25, 26] </ref>. Similarly, in an embedded system, some functionality may be implemented in hardware to achieve requisite timing performance. The WCET of the system is required to determine this software/hardware partition [5, 6, 19].
Reference: [27] <author> Jyh-Charn Liu and Hung-Ju Lee. </author> <title> Deterministic upperbounds of the worst-case execution times of cached programs. </title> <booktitle> In Proceedings of the 15th Real-Time Systems Symposium, </booktitle> <pages> pages 182-191, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: To bound the WCET of a program executed on such a machine, we must study the timing predictability of dynamic architectural features. Cache memory and instruction pipeline are two features on which much research has focused. Liu and Lee <ref> [27] </ref> argued that a sufficient condition for determining the tightest WCET of a cached program is to search through all feasible paths exhaustively. They proposed a method that trades off between the tightness of the WCET bound and its computing time.
Reference: [28] <institution> MC68030 Enhanced 32-bit Microprocessor: </institution> <note> User's Manual. </note> <institution> Motorola, </institution> <year> 1987. </year>
Reference-contexts: Dcind takes as input a MC68030 assembly program. It requires the user to provide loop bound information. The user can also provide addition information in form of linear constraints to tighten the WCET prediction. We obtained from the Motorola 68030 manual <ref> [28] </ref> the timing information of each instruction. We used the MC68030 in this experiment because it is a widely-used embedded microprocessor for which instruction timing information is available. The MC68030 microprocessor contains an on-chip 256 byte direct-mapped instruction cache which 50 is organized as 16 16-byte lines.
Reference: [29] <author> Aloysius K. Mok, Prasanna Amerasinghe, Moyer Chen, and Kamtorn Tantisirivat. </author> <title> Evaluating tight execution time bounds of programs by annotations. </title> <booktitle> In Proceedings of the 6th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pages 272-279, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: The number of the execution paths of a program cannot be bounded unless the iteration count of each loop structure is bounded. All previous studies on bounding WCETs of programs assume that the iteration count of each loop structure in the program being analyzed is bounded <ref> [17, 21, 29, 36, 39, 42] </ref>. We also make this assumption. 6 There are several approaches that use loop bound information only. Mok and his students [2, 4, 29] analyzed the execution times of assembly language programs generated from the compilation of annotated C programs. <p> We also make this assumption. 6 There are several approaches that use loop bound information only. Mok and his students <ref> [2, 4, 29] </ref> analyzed the execution times of assembly language programs generated from the compilation of annotated C programs. They used a graph method to find the worst-case execution path of a program. The WCET of the program is the execution time of this path.
Reference: [30] <author> Frank Mueller. </author> <title> Static Cache Simulation and its Applications. </title> <type> PhD thesis, </type> <institution> Florida State University, Tallahassee, Florida, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: Kirk and Strosnider [13, 14, 15] proposed a cache partitioning scheme to provide guaranteed instruction cache hits. According to this scheme an instruction cache is partitioned into a number of dedicated partitions, each of which can be accessed by only a dedicated task. Mueller and Whalley and Harmon <ref> [30, 31] </ref> use control-flow information to identify the potential cache conflicts in a direct-mapped instruction cache. They classify all instructions into always hit, always miss, first hit, and first miss categories and use this instruction categorization information to estimate the worst-case cache performance in a nonpreemptive environment. <p> It also stores the information needed to determine the execution time of the construct itself once the execution time of a preceding construct is available. Healy and Whalley and Harmon [10] added the timing analysis of instruction pipelining into the method developed by Mueller <ref> [30] </ref>.
Reference: [31] <author> Frank Mueller, David Whalley, and Marion Harmon. </author> <title> Predicting instruction cache behavior. </title> <booktitle> In ACM SIGPLAN Workshop on Languages, Compilers, and Tools for Real-Time Systems, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Kirk and Strosnider [13, 14, 15] proposed a cache partitioning scheme to provide guaranteed instruction cache hits. According to this scheme an instruction cache is partitioned into a number of dedicated partitions, each of which can be accessed by only a dedicated task. Mueller and Whalley and Harmon <ref> [30, 31] </ref> use control-flow information to identify the potential cache conflicts in a direct-mapped instruction cache. They classify all instructions into always hit, always miss, first hit, and first miss categories and use this instruction categorization information to estimate the worst-case cache performance in a nonpreemptive environment.
Reference: [32] <author> Kannan Narasimhan and Kelvin D. Nilsen. </author> <title> Portable execution time analysis for RISC pro 87 cessors. </title> <booktitle> In ACM SIGPLAN Workshop on Languages, Compilers and Tools for Real-Time Systems, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Zhang and Burns and Nicholson [45] developed a mathematical model of a two-stage pipelined processor and a method based on this model to calculate the WCET of a program that executes on this processor. Narasimhan and Nilsen <ref> [32] </ref> developed a tool that takes as input an architecture description file of a RISC processor and produces as output a timing analyzer. The analyzer accounts for the effect of pipelining on the RISC processor when predicting the WCET. Several approaches integrate the timing analysis of instruction caching and pipelining.
Reference: [33] <author> Douglas Niehaus. </author> <title> Program representation and translation for predictable real-time systems. </title> <booktitle> In Proceedings of the 12th Real-Time Systems Symposium, </booktitle> <pages> pages 53-63, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: The WCET of the program is the execution time of this path. Park and Shaw [36, 37] applied a similar method to source-level programs written in a subset of C. Their method is based on the notion of timing schema presented in Shaw [41]. Niehaus <ref> [33] </ref> developed a semantics-preserving transformation for concurrent programming language constructs such as critical sections and synchronous communication. He applied this transformation to bound the WCET of concurrent programs. A WCET bound obtained by a method using only loop bound information may be loose because of infeasible paths.
Reference: [34] <author> Chang Yun Park. </author> <title> Predicting Deterministic Execution Times of Real-Time Programs. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <address> Seattle, Washington, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Gupta and Gopinath [7] introduced techniques that identify correlation among the execution counts of statements within a program. They used this information to eliminate infeasible paths during the remainder of the program as its execution progresses. Park <ref> [34, 35] </ref> used regular expressions to describe the execution paths of a program. The intersection of these regular expressions represents all feasible paths. As a result, the maximum execution time of all feasible paths tightly bounds the WCET of the program.
Reference: [35] <author> Chang Yun Park. </author> <title> Predicting program execution times by analyzing static and dynamic program paths. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 5 </volume> <pages> 31-62, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Gupta and Gopinath [7] introduced techniques that identify correlation among the execution counts of statements within a program. They used this information to eliminate infeasible paths during the remainder of the program as its execution progresses. Park <ref> [34, 35] </ref> used regular expressions to describe the execution paths of a program. The intersection of these regular expressions represents all feasible paths. As a result, the maximum execution time of all feasible paths tightly bounds the WCET of the program.
Reference: [36] <author> Chang Yun Park and Alan C. Shaw. </author> <title> Experiments with a program timing tool based on source-level timing schema. </title> <booktitle> In Proceedings of the 11th Real-Time Systems Symposium, </booktitle> <address> Orlando, Florida, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: The number of the execution paths of a program cannot be bounded unless the iteration count of each loop structure is bounded. All previous studies on bounding WCETs of programs assume that the iteration count of each loop structure in the program being analyzed is bounded <ref> [17, 21, 29, 36, 39, 42] </ref>. We also make this assumption. 6 There are several approaches that use loop bound information only. Mok and his students [2, 4, 29] analyzed the execution times of assembly language programs generated from the compilation of annotated C programs. <p> They used a graph method to find the worst-case execution path of a program. The WCET of the program is the execution time of this path. Park and Shaw <ref> [36, 37] </ref> applied a similar method to source-level programs written in a subset of C. Their method is based on the notion of timing schema presented in Shaw [41]. Niehaus [33] developed a semantics-preserving transformation for concurrent programming language constructs such as critical sections and synchronous communication. <p> The analyzer accounts for the effect of pipelining on the RISC processor when predicting the WCET. Several approaches integrate the timing analysis of instruction caching and pipelining. Lim et al. [24] and Hur et al. [11] extended the method developed by Park and Shaw <ref> [36] </ref> to analyze the effect of instruction caching and pipelining. This method associates each source-level programming language construct with a timing schema. Each timing schema provides the information on what may affect the execution time of a succeeding construct.
Reference: [37] <author> Chang Yun Park and Alan C. Shaw. </author> <title> Experiments with a program timing tool based on source-level timing schema. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 48-57, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: They used a graph method to find the worst-case execution path of a program. The WCET of the program is the execution time of this path. Park and Shaw <ref> [36, 37] </ref> applied a similar method to source-level programs written in a subset of C. Their method is based on the notion of timing schema presented in Shaw [41]. Niehaus [33] developed a semantics-preserving transformation for concurrent programming language constructs such as critical sections and synchronous communication.
Reference: [38] <author> Gustav Pospischil, Peter Puschner, Alexander Vrchoticky, and Ralph Zainlinger. </author> <title> Developing real-time tasks with predictable timing. </title> <journal> IEEE Software, </journal> <pages> pages 35-44, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: An infeasible path is one that can be derived from the static program structure but can never be executed in practice. To obtain a tighter WCET bound, we must utilize additional information to eliminate infeasible paths. Many methods use additional information to tighten the WCET bound. Puschner and Koza <ref> [38, 39, 40] </ref> introduced several new language constructs with which programmers can describe the timing behavior of their programs. Their experiments showed that, with this valuable information, the gap between the estimated WCET bound and the real WCET can be reduced significantly.
Reference: [39] <author> P. Puschner and C. Koza. </author> <title> Calculating the maximum execution time of real-time programs. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 1 </volume> <pages> 159-176, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: The number of the execution paths of a program cannot be bounded unless the iteration count of each loop structure is bounded. All previous studies on bounding WCETs of programs assume that the iteration count of each loop structure in the program being analyzed is bounded <ref> [17, 21, 29, 36, 39, 42] </ref>. We also make this assumption. 6 There are several approaches that use loop bound information only. Mok and his students [2, 4, 29] analyzed the execution times of assembly language programs generated from the compilation of annotated C programs. <p> An infeasible path is one that can be derived from the static program structure but can never be executed in practice. To obtain a tighter WCET bound, we must utilize additional information to eliminate infeasible paths. Many methods use additional information to tighten the WCET bound. Puschner and Koza <ref> [38, 39, 40] </ref> introduced several new language constructs with which programmers can describe the timing behavior of their programs. Their experiments showed that, with this valuable information, the gap between the estimated WCET bound and the real WCET can be reduced significantly.
Reference: [40] <author> P. Puschner and A. Schedl. </author> <title> Computing maximum task execution times | a graph-based approach. </title> <journal> Journal of Real-Time Systems, </journal> <note> to appear. </note>
Reference-contexts: An infeasible path is one that can be derived from the static program structure but can never be executed in practice. To obtain a tighter WCET bound, we must utilize additional information to eliminate infeasible paths. Many methods use additional information to tighten the WCET bound. Puschner and Koza <ref> [38, 39, 40] </ref> introduced several new language constructs with which programmers can describe the timing behavior of their programs. Their experiments showed that, with this valuable information, the gap between the estimated WCET bound and the real WCET can be reduced significantly.
Reference: [41] <author> Alan C. Shaw. </author> <title> Reasoning about time in higher-level language software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(7) </volume> <pages> 875-889, </pages> <month> July </month> <year> 1989. </year> <month> 88 </month>
Reference-contexts: The WCET of the program is the execution time of this path. Park and Shaw [36, 37] applied a similar method to source-level programs written in a subset of C. Their method is based on the notion of timing schema presented in Shaw <ref> [41] </ref>. Niehaus [33] developed a semantics-preserving transformation for concurrent programming language constructs such as critical sections and synchronous communication. He applied this transformation to bound the WCET of concurrent programs. A WCET bound obtained by a method using only loop bound information may be loose because of infeasible paths.
Reference: [42] <author> Alexander D. Stoyenko. </author> <title> A Real-Time Language with A Schedulability Analyzer. </title> <type> PhD thesis, </type> <institution> Computer Systems Research Institute, University of Toronto, </institution> <month> December </month> <year> 1987. </year>
Reference-contexts: The number of the execution paths of a program cannot be bounded unless the iteration count of each loop structure is bounded. All previous studies on bounding WCETs of programs assume that the iteration count of each loop structure in the program being analyzed is bounded <ref> [17, 21, 29, 36, 39, 42] </ref>. We also make this assumption. 6 There are several approaches that use loop bound information only. Mok and his students [2, 4, 29] analyzed the execution times of assembly language programs generated from the compilation of annotated C programs.
Reference: [43] <institution> The VMEbus Specification. Motorola, </institution> <year> 1985. </year>
Reference-contexts: We assume that the CPU is synchronous: the beginning of each machine cycle is triggered by the processor clock. For the sake of concreteness, we assume that bus contention between the CPU and the DMAC is regulated according to the VMEbus <ref> [43] </ref> bus access protocol. This protocol is sufficiently general that our analysis may be easily applied to many other commonly-used bus protocols. To access the bus, a device (e.g., the DMAC) asserts the bus request line.
Reference: [44] <author> Alexander Vrchoticky and Peter Puschner. </author> <title> On the feasibility of response time predictions|an experimental evaluation. </title> <type> Technical Report 2/91, </type> <institution> Institute fur Technische Informatik Technis-che Universitat Wien, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Traditionally, I/O tasks are not allowed in time-critical applications or are restricted to be released at predefined instants such as the beginning and end of a task to make the computation of their WCETs easier <ref> [16, 44] </ref>. Because our method can accurately bound the WCET of cycle-stealing DMA I/O tasks which have an arbitrary release time, this restriction can now be removed. 3 1.2 Dissertation Overview Chapter 2 introduces related work. There have been many methods for bounding the WCET of a program.
Reference: [45] <author> N. Zhang, A. Burns, and M. Nicholson. </author> <title> Pipelined processors and worst case execution times. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 5 </volume> <pages> 319-343, </pages> <month> October </month> <year> 1993. </year> <month> 89 </month>
Reference-contexts: To estimate the WCET of a program that executes on a processor with an instruction pipeline, 8 Harmon and Baker and Whalley [8, 9] conducted timing analysis at the micro instruction level and analyzed the effect of pipelined execution through the pattern matching scheme. Zhang and Burns and Nicholson <ref> [45] </ref> developed a mathematical model of a two-stage pipelined processor and a method based on this model to calculate the WCET of a program that executes on this processor.
References-found: 45

