URL: http://www.cs.utah.edu/~cs686/Previous/a97/ml-critique.ps
Refering-URL: http://www.cs.utah.edu/~cs686/Previous/a97/
Root-URL: 
Title: A Critique of Standard ML nothing is perfect: Standard ML has a few shortcomings. In
Author: Andrew W. Appel 
Date: November 12, 1992  
Note: revised version of CS-TR-364-92  However,  Supported in part by NSF grant CCR-9002786.  
Affiliation: Princeton University  
Abstract: This is a critique of the language from two perspectives: the user's and the implementor's. The first part of this paper describes why ML is a pleasant language to use, and the second shows how some of these language features are interesting to compile. Then the third and fourth parts of the paper point out some of the annoyances ML programmers and implementors have to deal with. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Military standard: </author> <title> Ada programming language. </title> <type> Technical Report MIL-STD-1815, </type> <institution> Department of Defense, Naval Publications and Forms Center, </institution> <address> Philadelphia, PA, </address> <year> 1980. </year>
Reference-contexts: It is not controversial to say that modules with enforced interfaces and representation-hiding are an essential feature of a modern programming language. ML's module system is particularly nice, in that it allows one module to be parameterized by the interface of another. Ada <ref> [1] </ref> and Modula-3 [32] also support "generic" modules that are parameterized in this way. However, ML is unusual in that its parameterized modules|functors|can be compiled (with code generation) before any actual parameter is presented.
Reference: [2] <author> Thomas E. Anderson, Brian N. Bershad, Ed ward D. Lazowska, and Henry M. Levy. </author> <title> Scheduler activations: Effective kernel support for the user-level management of parallelism. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Thread scheduling is much more efficient when done in the client process, without requiring hardware- and operating-system context switches when synchronizing or interleaving thread executions. Recent operating-system research <ref> [2] </ref> has shown how to let the operating system schedule processors while the client programs manage processes to take advantage of the efficiency of user-mode schedulers. In ML extended with first-class continuations, the scheduler can be a source-language program that manipulates continuations directly.
Reference: [3] <author> Andrew W. Appel. </author> <title> Runtime tags aren't necessary. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2 </volume> <pages> 153-62, </pages> <year> 1989. </year>
Reference-contexts: The argument is often made that these tags are there to allow the garbage collector to traverse pointers and records. But it's possible to devise a garbage collector that relies on the static type information computed at compile time <ref> [3] </ref>, without any runtime tags on data. Furthermore, even a conventional garbage collector might use a BIBOP (Big Bag of Pages) scheme that groups many objects of similar type on the same page, so that one tag suffices for all of them.
Reference: [4] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: ML programs (run under some compilers) have used much more space than comparable C programs. This is a serious problem, but recent research <ref> [4, chapter 12] </ref> has hinted at solutions. At present, it appears that ML is efficient enough to use for a wide variety of applications. C programs are faster probably by no more than a factor of two, and often less than that.
Reference: [5] <author> Andrew W. Appel and David B. MacQueen. </author> <title> A Standard ML compiler. </title> <editor> In Gilles Kahn, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture (LNCS 274), </booktitle> <pages> pages 301-24, </pages> <address> New York, 1987. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In ML, worries about updates disappear for all but reference values, which are rare enough that conventional synchronization and message passing would be adequately efficient. The module system Run-time aspects of the module system turn out to be very simple <ref> [5] </ref>. A structure that exports n types and m values can be implemented as an ordinary m-tuple (types are needed only at compile time). Functors can be implemented as functions that take structures (tuples) as arguments and return structures as results.
Reference: [6] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Stan dard ML of New Jersey. </title> <editor> In Martin Wirsing, editor, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: It should be possible to get ML to run at least as efficiently as Scheme, since the languages are similar in many ways but ML doesn't require the run-time type checking that Scheme does. In any case, there is at least one reasonably efficient implementation of ML <ref> [6] </ref>. <p> Even if the implementor intends to parse using a different strategy (e.g., LL (1) or recursive descent), the LR (1) grammar is a useful starting point. The Standard ML of New Jersey implementation <ref> [6] </ref> uses such a grammar (with 68 terminals, 76 nonterminals, 231 productions, 452 LALR (1) states). Most languages have a shift/reduce conflict with else. <p> The Definition [31, page 10] states that "a more liberal scheme (which is under consideration)" would allow infix specs in signatures, and then an open declaration would re-install fixities of operators. Such a scheme has been implemented in Standard ML of New Jersey <ref> [6] </ref>, and is quite convenient to use. Separate compilation The ML language definition is purposely quite vague about the pragmatics of putting programs together.
Reference: [7] <author> Luca Cardelli. </author> <title> Compiling a functional language. </title> <booktitle> In 1984 Symp. on LISP and Functional Programming, </booktitle> <pages> pages 208-17, </pages> <address> New York, 1984. </address> <publisher> ACM Press. </publisher>
Reference-contexts: So the naive polymorphic type checker has proved inadequate to handle reference cells. A more appropriate type for f might be (8ff: ff ! ff)ref ), with the quantifier nested inside the ref constructor; but the ML type inference system cannot cope with "inner" quantifiers. Cardelli's ML compiler <ref> [7] </ref>, and the initial proposal for Standard ML [29], required that reference cells be completely monomorphic; that is, the compiler must be able to infer a type without type variables for any argument of the ref constructor. This is certainly safe, but insufficiently flexible. <p> Each element of the list, then, requires not one "cons cell" but two! Cardelli's ML compiler <ref> [7] </ref> avoided this extravagance by taking advantage of the fact that in the runtime representation of values, pointers could be distinguished from small integers.
Reference: [8] <author> Will Clinger and Lars Thomas Hansen. </author> <title> Is explicit deallocation really faster than garbage collection? unpublished manuscript, </title> <year> 1992. </year>
Reference-contexts: For many purposes, ML's advantages in safety, elegance, ease of storage management, and so on may outweigh this difference in performance. And programs that require complicated and expensive storage management in C may run faster in an ML implementation with a good garbage collector <ref> [8] </ref>.
Reference: [9] <author> Eric C. Cooper and J. Gregory Morrisett. </author> <title> Adding threads to Standard ML. </title> <type> Technical Report CMU-CS-90-186, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: In ML extended with first-class continuations, the scheduler can be a source-language program that manipulates continuations directly. This approach is very elegant and robust, and has proved successful in Concurrent ML [35] and ML-Threads <ref> [9] </ref>, two quite different concurrent programming environments for ML. 3 ML traps and pitfalls The syntactic and semantic pitfalls that an ML programmer encounters are much less severe and less numerous than those described in languages such as C [20], which is an egregious example.
Reference: [10] <author> Luis Damas. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Edinburgh, </institution> <year> 1985. </year>
Reference-contexts: Several languages in all three families have allowed programmers to define new overloaded identifiers, and to specify the implementation function to use for each argument type. Object-oriented languages, especially, have sophisticated support for user-defined overloading. Compile-time overloading resolution and ML-style polymorphic type inference do not work well together <ref> [10] </ref>. In processing a function definition such as fun double (x) = x+x it is impossible to know at compile-time whether + is to be implemented as integer or floating-point addition.
Reference: [11] <author> Bruce Duba, Robert Harper, and David Mac Queen. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Eighteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 163-73, </pages> <address> New York, Jan 1991. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Standard ML does not have such first-class continuations; but it turns out that they can easily be introduced, and they fit very nicely into the ML type system <ref> [11] </ref>. First-class continuations make it easy to implement coroutines, or their generalization, lightweight processes [45].
Reference: [12] <author> M. J. Gordon, A. J. Milner, and C. P. </author> <title> Wadsworth. </title> <publisher> Edinburgh LCF. Springer-Verlag, </publisher> <address> New York, </address> <year> 1979. </year>
Reference: [13] <author> C. A. R. </author> <title> Hoare. </title> <booktitle> Hints on Programming-Language Design, </booktitle> <pages> pages 193-216. </pages> <publisher> Prentice Hall, </publisher> <year> 1989. </year> <booktitle> keynote address to the ACM SIGPLAN conference in 1973. </booktitle>
Reference-contexts: This is a criterion to which I give the name security. C. A. R. Hoare, 1973. <ref> [13] </ref> One of the most pleasant things about ML is that it is safe: programs cannot corrupt the runtime system so that further execution of the program is not faithful to the language semantics. 1 Nelson [32] divides programming languages into three geneologi-cal categories: The BCPL family, including C and C++, <p> Theorists should note that, even though some of the criticisms are minor and not of much theoretical interest, they all affect the usability of the language. Those theorists who anticipate designing a language themselves someday might want to remember this critique, along with the classics of the genre <ref> [13, 46] </ref>. Acknowledgment I would like to thank Doug McIlroy and an anonymous referee for many valuable comments.
Reference: [14] <institution> Report on the programming language Haskell: Ver sion 1.1. </institution> <type> Technical Report Technical Report, </type> <institution> Yale University and Glasgow University, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: Such a technique is not possible in Lisp, since any object can in principle be updated (even though few objects are actually updated in practice). It is interesting to compare ML (which allows programmers to execute updating side effects) with lazy functional languages such as Haskell <ref> [14] </ref>, from the garbage collector's point of view. Since generational garbage collectors hate updates to existing objects, it would seem at first glance that a purely functional language with no assignment statement would be easier to garbage-collect. <p> These are both small things; they are cute but minimally useful, and programmers could easily work around their absence. Some variation of the Prolog approach would solve this problem without significantly altering the nature of Standard ML. The Haskell language <ref> [14] </ref> uses such an approach. Overloading Most languages support some kind of overloading of operators, also known as ad hoc polymorphism. <p> Perhaps the Definition "meant" to say that "operators of the same precedence but opposite associativity associate to the left." But an even better rule would be that left- and right-associative operators of the same precedence don't mix without parentheses; this is the rule in Haskell <ref> [14] </ref>. Infix vs. Modules Infix declarations are not exported from modules, and cannot be specified in signatures. This makes them significantly less useful.
Reference: [15] <author> Report on the programming language Haskell, </author> <title> a non-strict, purely functional language, version 1.2. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: One way to solve this problem is to allow run-time resolution of overloading, as in the language Haskell <ref> [44, 15] </ref> and in other extensions of typed lambda calculus [18]. In these languages, class operators are passed (at runtime) as implicit extra arguments to functions that take polymorphic overloaded types as arguments.
Reference: [16] <author> Kathleen Jensen and Niklaus Wirth. </author> <title> Pascal: User Manual and Report. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1974. </year>
Reference-contexts: Complete formal definition The programming language Pascal was an advance in language design, and became very popular, for several reasons. It supported clean and useful control structures and data structures. It is a small enough language, and was specified precisely enough (in informal prose) <ref> [16] </ref> that people could understand what Pascal programs should do. But Pascal still has "ambiguities and insecurities" [46].
Reference: [17] <author> Pierre Jouvelot and David K. Gifford. </author> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In Eighteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 303-310, </pages> <address> New York, Jan 1991. </address> <publisher> ACM Press. </publisher>
Reference-contexts: It is too bad that this purely internal data structure must be "mentioned" in the interface. Many researchers have recently been engaged in devising better type inference systems for polymorphic programs with references <ref> [25, 23, 17, 40, 48] </ref>, which indicates that the problem of type-checking references is not yet regarded as "solved;" some of these systems address the problem of internal, temporary references described above.
Reference: [18] <author> Stefan Kaes. </author> <title> Type inference in the presence of overloading, subtyping and recursive types. </title> <booktitle> In Proc. 1992 ACM Conf. on Lisp and Functional Programming, </booktitle> <pages> pages 193-204. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: One way to solve this problem is to allow run-time resolution of overloading, as in the language Haskell [44, 15] and in other extensions of typed lambda calculus <ref> [18] </ref>. In these languages, class operators are passed (at runtime) as implicit extra arguments to functions that take polymorphic overloaded types as arguments. But this mechanism makes dynamic semantics dependent on static semantics, which precludes certain kinds of separate compilation schemes.
Reference: [19] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1978. </year>
Reference-contexts: However, modern languages with module facilities (including C, Modula, Ada) usually specify quite clearly which parts of a program can be compiled separately from the rest of the program: in C, a .c file generally requires some .h files for compilation, but not other .c files <ref> [19] </ref>; the Modula-2 definition [47] is even more specific about the organization of compilation units. Since ML has a rather elaborate module system, it would seem that each module should be a separately compileable unit.
Reference: [20] <author> Andrew Koenig. </author> <title> C Traps and Pitfalls. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass, </address> <year> 1989. </year>
Reference-contexts: robust, and has proved successful in Concurrent ML [35] and ML-Threads [9], two quite different concurrent programming environments for ML. 3 ML traps and pitfalls The syntactic and semantic pitfalls that an ML programmer encounters are much less severe and less numerous than those described in languages such as C <ref> [20] </ref>, which is an egregious example. Misspelled constructors A well-known and most dangerous pitfall awaiting the ML programmer is the misspelling of a constant data constructor in a pattern.
Reference: [21] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 177-188, </pages> <address> New York, </address> <month> January </month> <year> 1992. </year> <note> ACM Press. </note>
Reference-contexts: But perhaps it is possible to pay for the abstraction only where abstraction is actually used. Xavier Leroy has recently pointed out that it is not necessary to represent every variable in one word, just polymorphic variables <ref> [21] </ref>. The type-checker can identify those places where non-polymorphic values are passed to polymorphic variables, and vice versa. Then the compiler can choose 9 specialized representations, just as languages of the Algol family do, for nonpolymorphic variables.
Reference: [22] <author> Xavier Leroy and Michel Mauny. </author> <title> Dynamics in ml. </title> <editor> In J. Hughes, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture: 5th ACM Conference (LNCS 523), </booktitle> <pages> pages 406-426. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: A more interesting use of dynamic types is for programs that wish to do type-safe, structured input/output, which is problematic in Standard ML. Within the ML community, the type dynamic has been proposed as a solution to this problem <ref> [22] </ref>: values of type dynamic would carry full ML-style types as part of their run-time representation, and could be coerced into ordinary statically-typed values with a runtime check. * Edinburgh ML 4.0, from the University of Edinburgh (lfcs@ed.ac.uk) * ANU ML, from the Australian National University (mcn@anucsd.anu.oz.au) * MicroML, from the
Reference: [23] <author> Xavier Leroy and Pierre Weis. </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In Eighteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 291-302, </pages> <address> New York, Jan 1991. </address> <publisher> ACM Press. </publisher>
Reference-contexts: It is too bad that this purely internal data structure must be "mentioned" in the interface. Many researchers have recently been engaged in devising better type inference systems for polymorphic programs with references <ref> [25, 23, 17, 40, 48] </ref>, which indicates that the problem of type-checking references is not yet regarded as "solved;" some of these systems address the problem of internal, temporary references described above.
Reference: [24] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-29, </pages> <year> 1983. </year>
Reference-contexts: It is very pleasant to exploit this freedom in writing an optimizing compiler. Mutable cells In ML the updateable parts of data structures (ref cells) are identified at compile time. This could be useful to a garbage collector. Generational garbage collectors <ref> [24, 42] </ref> segregate heap-allocated records by age. Because records are initialized (to point to already-existing records) when they are created, newer records usually point to older records.
Reference: [25] <author> John M. Lucassen and David K. Gifford. </author> <title> Poly morphic effect systems. </title> <booktitle> In Fifteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 47-57, </pages> <address> New York, Jan 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: It is too bad that this purely internal data structure must be "mentioned" in the interface. Many researchers have recently been engaged in devising better type inference systems for polymorphic programs with references <ref> [25, 23, 17, 40, 48] </ref>, which indicates that the problem of type-checking references is not yet regarded as "solved;" some of these systems address the problem of internal, temporary references described above.
Reference: [26] <author> David MacQueen. </author> <title> Modules for Standard ML. </title> <booktitle> In Proc. 1984 ACM Conf. on LISP and Functional Programming, </booktitle> <pages> pages 198-207, </pages> <address> New York, 1984. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In some cases the transparency of signatures is necessary and useful; but in many cases it would be useful to use the module system to implement abstract data types. MacQueen's original module proposal <ref> [26] </ref> provided for abstraction, a special kind of structure declaration in which all type representation and sharing information not specified in the signature constraint would be hidden. Giving programmers the choice between structure and abstraction would better support programming with abstract data types.
Reference: [27] <author> David B. MacQueen. weak-types. </author> <title> Distributed with Standard ML of New Jersey, </title> <year> 1988. </year>
Reference-contexts: In particular, it does not seem to work very naturally with higher-order functions; currying a function of imperative type can lead to a function that is rejected by Tofte's algorithm. MacQueen solved this problem by assigning numerical weakness indices to the type variables <ref> [27] </ref>. MacQueen's scheme is strictly more powerful than Tofte's, and has been implemented in Standard ML of New Jersey. However, MacQueen's weak types aren't very easy for programmers to understand.
Reference: [28] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-75, </pages> <year> 1978. </year>
Reference-contexts: "mathemati-cal" languages have garbage collectors; garbage collectors require some run-time type information to trace reachable objects; as long as the type information is in the run-time data there is a temptation to use it; or perhaps no one knew how to do good "mathematical" compile-time type-checking before ML's type system <ref> [28] </ref> was invented. Of course, run-time type checking can be slow; but the "mathemat-ical" languages have not had raw speed as a primary design concern. In ML, the absence of run-time checking does make for more efficient implementation; this will be discussed below.
Reference: [29] <author> Robin Milner. </author> <title> A proposal for Standard ML. </title> <booktitle> In ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 184-97, </pages> <address> New York, 1984. </address> <publisher> ACM Press. </publisher>
Reference-contexts: A more appropriate type for f might be (8ff: ff ! ff)ref ), with the quantifier nested inside the ref constructor; but the ML type inference system cannot cope with "inner" quantifiers. Cardelli's ML compiler [7], and the initial proposal for Standard ML <ref> [29] </ref>, required that reference cells be completely monomorphic; that is, the compiler must be able to infer a type without type variables for any argument of the ref constructor. This is certainly safe, but insufficiently flexible. <p> A reasonable compromise would be to allow a kind of statically overloaded equality function, of the kind found in earlier versions of Standard ML <ref> [29] </ref>. This equality operator worked on any nonfunctional monomorphic type.
Reference: [30] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1991. </year>
Reference-contexts: The Definition of Standard ML [31] is a complete operational semantics for the entire language. One can use the Definition to calculate exactly which programs should be accepted by a compiler, and what their result will be. Furthermore, the Definition (with accompanying commentary <ref> [30] </ref>) is readable|as formal semantic definitions go. This does not mean that the definition is suitable as a manual for the programmer; there is too much formal notation and not enough worked examples for that. <p> enough to prove, for example, that programs that type-check will execute "safely," that there can be no "dangling references" (invalid pointers), that the type inference algorithm always finds the most general type for an expression, and many other theorems that inspire confidence in the 5 semantics of the language 6 <ref> [30] </ref>. The proponents of formal specifications of programming languages have long claimed that semantics should be used as a tool for language design, not just for writing down the semantics of existing languages. <p> But it is particularly convenient to use abstract data types at the module level, where abstraction is more straightforward than abstype. And functors can be a clumsy mechanism for structuring programs. The Commentary to the definition shows that abstraction is not semantically problematical <ref> [30, page 85] </ref>, and even gives a useful generalization of MacQueen's proposal. It's a pity that this feature was omitted from the Definition. open in signatures It is customary, in writing modular software, to specify the interfaces between modules and to implement the modules to meet those interfaces. <p> Then the runtime "equality interpreter" faces a very complex task in understanding the structure of objects. As to the provision of implicit arguments to functions, this is workable but inelegant. As the Commentary on Standard ML states, "the static and dynamic semantics can be studied independently of one another." <ref> [30, preface] </ref> In structuring a compiler, it is very convenient that translation of expressions into machine language is independent of the types of the expressions. Requiring that some expressions must be treated specially depending on their types corrupts the interface between the components of the compiler.
Reference: [31] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA, </address> <year> 1989. </year>
Reference-contexts: ML is not only secure, it is also unambiguously defined. The Definition of Standard ML <ref> [31] </ref> is a complete operational semantics for the entire language. One can use the Definition to calculate exactly which programs should be accepted by a compiler, and what their result will be. Furthermore, the Definition (with accompanying commentary [30]) is readable|as formal semantic definitions go. <p> The semantics (i.e., type, value, etc.) of an operator can't be determined lexically because of the use of open; the programmer who can parse the operators but doesn't know what they do is almost as badly off as the one who isn't sure about operator precedence. The Definition <ref> [31, page 10] </ref> states that "a more liberal scheme (which is under consideration)" would allow infix specs in signatures, and then an open declaration would re-install fixities of operators. Such a scheme has been implemented in Standard ML of New Jersey [6], and is quite convenient to use. <p> implementation of this representation would be as a two-element record, with one field containing a small integer tag (stand-ing for the constructor) and the other containing the value (since ML has polymorphic types, every 14 Pages 4, 18, 19, 21, 22, 25, 26, 74, 75, 77, 79 of the Definition <ref> [31] </ref> would still mention equality; pages 13, 16, 33, 35, 36, 39, 40, 41, 43, 44, 57 would no longer need to. value must be the same size|one word in a typical implementation).
Reference: [32] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: C. A. R. Hoare, 1973. [13] One of the most pleasant things about ML is that it is safe: programs cannot corrupt the runtime system so that further execution of the program is not faithful to the language semantics. 1 Nelson <ref> [32] </ref> divides programming languages into three geneologi-cal categories: The BCPL family, including C and C++, which are not safe; the Algol family, including Pascal and Ada, which are almost safe; and the 1 Thanks to the Modula-3 manual [32] for this phrasing 1 "mathematically derived" family, including Lisp, ML, Smalltalk, and <p> of the program is not faithful to the language semantics. 1 Nelson <ref> [32] </ref> divides programming languages into three geneologi-cal categories: The BCPL family, including C and C++, which are not safe; the Algol family, including Pascal and Ada, which are almost safe; and the 1 Thanks to the Modula-3 manual [32] for this phrasing 1 "mathematically derived" family, including Lisp, ML, Smalltalk, and CLU, which are safe|except when Lisp programmers disable runtime type checking because it's too expensive. (There are, of course, languages such as FORTRAN and COBOL that do not fall into these categories.) In a safe language, all errors <p> It is not controversial to say that modules with enforced interfaces and representation-hiding are an essential feature of a modern programming language. ML's module system is particularly nice, in that it allows one module to be parameterized by the interface of another. Ada [1] and Modula-3 <ref> [32] </ref> also support "generic" modules that are parameterized in this way. However, ML is unusual in that its parameterized modules|functors|can be compiled (with code generation) before any actual parameter is presented.
Reference: [33] <author> Scott Nettles and James W. </author> <month> O'Toole. </month> <institution> Carnegie Mellon Univ., Pittsburgh, PA, </institution> <type> personal communication from Scott Nettles, </type> <year> 1990. </year>
Reference-contexts: A concurrent garbage collector might have trouble finding all these pointers quickly. In that case, it might be desireable to have two usable copies of the object|old and new| until all the pointers can be "forwarded" <ref> [33] </ref>. Distributed systems can copy objects without worrying about identity. Suppose we want to make the distributed nature of a system transparent to the programmer.
Reference: [34] <editor> J. Rees and W. Clinger. </editor> <title> Revised report on the algorithmic language Scheme. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(12) </volume> <pages> 37-79, </pages> <year> 1986. </year>
Reference-contexts: Since all inter-module linkage can be expressed this way, a conventional link-loader is not even necessary|which is particularly convenient in an interactive system that can load and execute programs and modules on the fly. First-class continuations A very interesting and powerful feature of Scheme <ref> [34] </ref> is the call-with-current-continuation mechanism, whereby the dynamic calling context of a function can be abstracted as another function. Standard ML does not have such first-class continuations; but it turns out that they can easily be introduced, and they fit very nicely into the ML type system [11].
Reference: [35] <author> John H. Reppy. </author> <title> Concurrent programming with events. </title> <type> Technical report, </type> <institution> Cornell University, Dept. of Computer Science, </institution> <address> Ithaca, NY, </address> <year> 1990. </year>
Reference-contexts: In ML extended with first-class continuations, the scheduler can be a source-language program that manipulates continuations directly. This approach is very elegant and robust, and has proved successful in Concurrent ML <ref> [35] </ref> and ML-Threads [9], two quite different concurrent programming environments for ML. 3 ML traps and pitfalls The syntactic and semantic pitfalls that an ML programmer encounters are much less severe and less numerous than those described in languages such as C [20], which is an egregious example.
Reference: [36] <author> John H. Reppy and Emden R. Gansner. </author> <title> The eXene library manual. </title> <institution> Cornell Univ. Dept. of Computer Science, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Efficiency An elegant language will have few applications if programs written in it always run too slowly. So 8 An interesting and useful windowing library has been implemented in ML by Gansner and Reppy <ref> [36] </ref> as a very elegant interface to an X server. The example here does not describe their system. it is important that ML can be compiled to run efficiently. There are many reasons to believe that it can.
Reference: [37] <author> Colin Runciman and David Wakeling. </author> <title> Heap profil ing of lazy functional programs. </title> <type> Technical Report 172, </type> <institution> University of York, Dept. of Computer Science, </institution> <address> Heslington, York Y01 5DD, United Kingdom, </address> <month> April </month> <year> 1992. </year>
Reference: [38] <author> Zhong Shao and Andrew W. Appel. </author> <title> Smartest recompilation. </title> <booktitle> In Proc. Twentieth Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, page to appear. </booktitle> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: Then, at link time the module can be type-checked, since the types of free identifiers then become known. Since code generation is much more expensive than type checking, we might gain significant benefit from this approach. The algorithms for in vacuo separate compilation have been worked out <ref> [38] </ref>, and are now being implemented. A more mundane advantage of the separation of static and dynamic semantics is that a simple, un-typed intermediate representation can be used; and the translation of ML into this intermediate representation need not pay attention to types. This somewhat simplifies a compiler.
Reference: [39] <author> Robert A. Shaw. </author> <title> Improving garbage collector per formance in virtual memory. </title> <type> Technical Report CSL-TR-87-323, </type> <institution> Stanford University, </institution> <address> Palo Alto, CA, </address> <year> 1987. </year>
Reference-contexts: It is more difficult in Algol-like languages where records are created uninitialized and are then stored into afterwards to initialize them. An alternate approach to updates is to use the virtual-memory hardware of the computer <ref> [39] </ref>. By making older generations read-only, an updating store will cause a page fault. This fault can be handled by making the page writeable, and marking all the objects on that page as possibly updated.
Reference: [40] <author> Jean-Pierre Talpin and Pierre Jouvelot. </author> <title> Polymor phic type, region, and effect inference. </title> <type> Technical Report EMP-CRI E/150, </type> <institution> Ecole des Mines de Paris, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: It is too bad that this purely internal data structure must be "mentioned" in the interface. Many researchers have recently been engaged in devising better type inference systems for polymorphic programs with references <ref> [25, 23, 17, 40, 48] </ref>, which indicates that the problem of type-checking references is not yet regarded as "solved;" some of these systems address the problem of internal, temporary references described above.
Reference: [41] <author> Mads Tofte. </author> <title> Type inference for polymorphic ref erences. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Cardelli's ML compiler [7], and the initial proposal for Standard ML [29], required that reference cells be completely monomorphic; that is, the compiler must be able to infer a type without type variables for any argument of the ref constructor. This is certainly safe, but insufficiently flexible. Tofte <ref> [41] </ref> generalized this idea, introducing "weakly polymorphic" references and "imperative types." These allow a function that creates references to be applied to more than one type, as long as each such type is itself monomorphic.
Reference: [42] <author> David M. Ungar. </author> <title> The Design and Evaluation of a High Performance Smalltalk System. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: It is very pleasant to exploit this freedom in writing an optimizing compiler. Mutable cells In ML the updateable parts of data structures (ref cells) are identified at compile time. This could be useful to a garbage collector. Generational garbage collectors <ref> [24, 42] </ref> segregate heap-allocated records by age. Because records are initialized (to point to already-existing records) when they are created, newer records usually point to older records. <p> There are many ways to keep track of updated cells. A software approach is to have the compiler generate code after each assignment statement to keep a list of all cells updated <ref> [42] </ref>. It's not necessary to put newly-allocated cells on this list, of course. So all the compiler needs to do is distinguish initializing store instructions from updating stores.
Reference: [43] <author> Philip Wadler. </author> <title> The essence of functional program ming (invited talk). </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 1-14, </pages> <address> New York, Jan 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Only an extremist would say that updateable cells are always too hard to use and understand. The extremists might yet be proved right: it is certainly true that any algorithm on objects can be simulated on values, and recent work has made such algorithms ever more readable and understandable <ref> [43] </ref>. But there are millions of programmers who have sufficiently comprehended the notion of assignment and updateable data structures to write successful programs. Of course, the same argument could be made for bringing back the goto and the 64-kilobyte address space.
Reference: [44] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad hoc. </title> <booktitle> In Sixteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 60-76, </pages> <address> New York, </address> <month> January </month> <year> 1989. </year> <note> ACM Press. </note>
Reference-contexts: One way to solve this problem is to allow run-time resolution of overloading, as in the language Haskell <ref> [44, 15] </ref> and in other extensions of typed lambda calculus [18]. In these languages, class operators are passed (at runtime) as implicit extra arguments to functions that take polymorphic overloaded types as arguments. <p> Then a function such as alleq could use these implicit parameters to perform equality testing. This is the solution adopted in Haskell <ref> [44] </ref>, which generalizes the notion of equality types to include other kinds of overloading. There are disadvantages to either solution. The first requires runtime tags which are otherwise not necessary for ordinary execution.
Reference: [45] <author> Mitchell Wand. </author> <title> Continuation-based multiprocess ing. </title> <booktitle> In Conf. Record of the 1980 Lisp Conf., </booktitle> <pages> pages 19-28, </pages> <address> New York, </address> <month> August </month> <year> 1980. </year> <note> ACM Press. </note>
Reference-contexts: Standard ML does not have such first-class continuations; but it turns out that they can easily be introduced, and they fit very nicely into the ML type system [11]. First-class continuations make it easy to implement coroutines, or their generalization, lightweight processes <ref> [45] </ref>. Low-level details that must ordinarily be confronted in such implementations|such as the allocation of new activation stacks, the garbage-collector interface, and the mechanisms for saving registers to invoke a new thread|are all neatly encapsulated in the continuation mechanism.
Reference: [46] <author> J. Welsh, W. J. Sneeringer, and C. A. R. Hoare. </author> <title> Ambiguities and insecurities in Pascal. </title> <journal> Software| Practice and Experience, </journal> <volume> 7(6) </volume> <pages> 685-96, </pages> <year> 1977. </year>
Reference-contexts: It supported clean and useful control structures and data structures. It is a small enough language, and was specified precisely enough (in informal prose) [16] that people could understand what Pascal programs should do. But Pascal still has "ambiguities and insecurities" <ref> [46] </ref>. That is, the language definition is ambiguous about the meaning of certain constructs (and different compilers give different results on the same program); and the language is insecure: it is not safe in the sense described by Hoare. ML is not only secure, it is also unambiguously defined. <p> Theorists should note that, even though some of the criticisms are minor and not of much theoretical interest, they all affect the usability of the language. Those theorists who anticipate designing a language themselves someday might want to remember this critique, along with the classics of the genre <ref> [13, 46] </ref>. Acknowledgment I would like to thank Doug McIlroy and an anonymous referee for many valuable comments.
Reference: [47] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1981. </year> <month> 23 </month>
Reference-contexts: However, modern languages with module facilities (including C, Modula, Ada) usually specify quite clearly which parts of a program can be compiled separately from the rest of the program: in C, a .c file generally requires some .h files for compilation, but not other .c files [19]; the Modula-2 definition <ref> [47] </ref> is even more specific about the organization of compilation units. Since ML has a rather elaborate module system, it would seem that each module should be a separately compileable unit.
Reference: [48] <author> Andrew K. Wright. </author> <title> Polymorphic references for mere mortals. </title> <booktitle> In Proceedings of the European Symposium on Programming, </booktitle> <year> 1992. </year> <month> 24 </month>
Reference-contexts: It is too bad that this purely internal data structure must be "mentioned" in the interface. Many researchers have recently been engaged in devising better type inference systems for polymorphic programs with references <ref> [25, 23, 17, 40, 48] </ref>, which indicates that the problem of type-checking references is not yet regarded as "solved;" some of these systems address the problem of internal, temporary references described above.
References-found: 48

