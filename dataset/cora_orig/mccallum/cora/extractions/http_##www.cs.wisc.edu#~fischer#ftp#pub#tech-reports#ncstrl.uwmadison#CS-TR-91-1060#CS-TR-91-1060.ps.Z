URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1060/CS-TR-91-1060.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1060/
Root-URL: http://www.cs.wisc.edu
Title: A TRANSFORMATION-BASED APPROACH TO OPTIMIZING LOOPS IN DATABASE PROGRAMMING LANGUAGES  
Author: Daniel F. Lieuwen David J. DeWitt 
Address: Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin  
Abstract: Database programming languages like O 2 , E, and O++ include the ability to iterate through a set. Nested iterators can be used to express joins. This paper describes compile-time optimizations similar to relational transformations like join reordering for such programming constructs. This paper also shows how to use a standard transformation-based optimizer to optimize these joins. An optimizer built using the EXODUS Optimizer Generator [GRAE87] was added to the Bell Labs O++ [AGRA89] compiler. We used the resulting optimizing compiler to experimentally validate the ideas in this paper. The experiments show that this technique can significantly improve the performance of database programming languages. 
Abstract-found: 1
Intro-found: 1
Reference: [ABU81] <author> Walid Abu-Sufah, David J. Kuck, and Duncan H. Lawrie. </author> <title> On the Performance Enhancement of Paging Systems Through Program Analysis and Transformations. </title> <journal> IEEE Trans. on Computers C-30,5 (May 1981), </journal> <pages> 341-355. </pages>
Reference-contexts: Thus the general idea is similar although the analysis used is different. Loop fission has been used to optimize FORTRAN programs. Loop fission breaks a single loop into several smaller loops to improve the locality of data reference. This can dramatically improve paging performance <ref> [ABU81] </ref>. Our transformations serve a similar functionbreaking a large loop into several small ones to enable database-style optimization. 3.
Reference: [AGRA89] <author> R. Agrawal and N. H. Gehani. </author> <title> Rationale for the Design of Persistence and Query Processing Facilities in the Database Programming Language O++. </title> <booktitle> Proc. 2nd Int. Workshop on Database Programming Languages, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: Third, some joins will be produced by calling a function from within a set iterationsince the function may also iterate through a set. This paper will concentrate on value-based joins. Since database programming languages such as PASCAL/R [SCHM77], O 2 [LECL89], E [RICH89], and O++ <ref> [AGRA89] </ref> provide constructs to iterate through a set in some unspecified order, it is possible to nest iterators in order to express value-based joins. <p> INTRODUCTION TO SELF-COMMUTATIVITY Before examining the different transformation strategies that we developed, we first examine when a simple group-by loop can be optimized like a relational join, since this is the base case of our optimization strategy. We introduce O++ <ref> [AGRA89] </ref> syntax for expressing a join 1 . <p> Given this assumption, the computation of a sequence of aggregates is a self-commutative statement. For example, in (7) for (D of Division) for (E of Employee) suchthat (E-&gt;division==D) - totpay += ChristmasBonus + (E-&gt;bpay*D->pftshare)/100; empcnt++; - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 The syntax presented here is different than that presented in <ref> [AGRA89] </ref>. It is the syntax of the present O++ compiler. the statement sequence that increments totpay and empcnt is self-commutative.
Reference: [AGRA91] <author> R. Agrawal, S. Dar, and N. H. Gehani. </author> <title> The O++ Database Programming Language: Implementation and Experience. </title> <institution> AT&T Bell Labs Technical Memorandum, </institution> <year> 1991. </year>
Reference-contexts: Since unanalyzed group-by loops must be evaluated with a tuple-at-a-time nested loops join algorithm (possibly with an index), and adding more facilities will improve the quality of optimized plans, these extensions should make the difference in performance between optimized and unoptimized plans even more impressive than in the hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 12 <ref> [AGRA91] </ref> describes the original O++ run-time system. It also contains examples of translating O++ code into C++ code. examples in the following section. 7. EXPERIMENTS In this section, we consider two queries, and compare the performance of the optimized and unoptimized forms of each.
Reference: [ATKI89] <author> Malcolm P. Atkinson, Francois Bancilhon, David DeWitt, Klaus Dittrich, David Maier, and Stanley Zdonik. </author> <title> The Object-Oriented Database System Manifesto, invited paper, </title> <booktitle> 1st Int'l Conf. on Deductive and Object-Oriented Databases, </booktitle> <address> Japan, </address> <month> December, </month> <year> 1989. </year>
Reference-contexts: 1. INTRODUCTION Many researchers believe that an object-oriented database system must be computationally completethat programmers and database administrators must have access to a programming language to write methods and application programs <ref> [ATKI89] </ref>. While the programming language for such a system must include the ability to iterate through a set, giving programmers this power allows them to write programs that are orders of magnitude slower than the desired computation should be.
Reference: [DAYA87] <author> Umeshwar Dayal. </author> <title> Of Nests and Trees: A Unified Approach to Process Queries That Contain Nested Subqueries, Aggregates, and Quantifiers. </title> <booktitle> Proceedings of 1987 Conf. Very Large Databases, </booktitle> <month> August </month> <year> 1987. </year>
Reference: [DEMO85] <author> G. Barbara Demo and Sukhamay Kundu. </author> <title> Analysis of the Context Dependency of CODASYL FIND-statements with Application to Database Program Conversion. </title> <booktitle> Proc. 1985 SIGMOD, </booktitle> <month> May </month> <year> 1985. </year>
Reference: [DEWI84] <author> David DeWitt, Randy Katz, Frank Olken, Leonard Shapiro, Michael Stonebraker, and David Wood. </author> <title> Implementation Techniques for Main Memory Database Systems. </title> <booktitle> Proc. 1984 SIGMOD, </booktitle> <month> June </month> <year> 1984. </year>
Reference: [GANS87] <author> Richard A. Ganski and Harry K. T. Wong. </author> <title> Optimization of Nested SQL Queries Revisited. </title> <booktitle> Proc. </booktitle> <year> 1987 </year> <month> SIG--MOD, May </month> <year> 1987. </year>
Reference: [GRAE87] <author> Goetz Graefe. </author> <type> Ph.D. Thesis. </type> <note> Rule-Base Query Optimization in Extensible Database Systems. </note> <institution> University of Wisconsin (1987). </institution>
Reference-contexts: This is not necessarypredicates involving such variables can be handled, but handling them requires complicating the representation and the exposition. The tree representation used here is different from a typical representation used to represent relational joins, the left deep query tree <ref> [GRAE87] </ref>. A tree's cost function cannot be evaluated bottom up unless each leaf node maintains information about how many times the set loop corresponding to the node is expected to be executed (For example, the value would be one for the X 1 node in (9). <p> This implicit set has no name, and there is no selection predicate on it. Note that the tree representation in Figure 3 would closely resemble a standard tree representation for relational joins, the left-deep query tree <ref> [GRAE87] </ref>, if the Supernode was removed from the tree. 10 ||g Y Var = Supernode First = Y.First Second = Y.Second StmtsDesc = Y.StmtsDesc Flow = Y.Flow SelectPred = TRUE ||g First = NULL Second = NULL Flow = noflow StmtsDesc = empty Tb || __ X SetName = NULL 5.1.
Reference: [KATZ82] <author> R. H. Katz and E. Wong. </author> <title> Decompiling CODASYL DML into Relational Queries. </title> <journal> ACM Trans. Database Syst. </journal> <month> 7,1 (March </month> <year> 1982), </year> <pages> 1-23. </pages>
Reference: [KIM82] <author> Won Kim. </author> <title> On Optimizing an SQL-like Nested Query. </title> <journal> ACM Trans. Database Syst. </journal> <month> 7,3 (September </month> <year> 1982), </year> <pages> 443-469. </pages>
Reference: [LECL89] <author> C. Lecluse and P. Richard. </author> <title> The O 2 Database Programming Language. </title> <booktitle> Proc. 1989 Conf. Very Large Databases, </booktitle> <month> August </month> <year> 1989. </year>
Reference-contexts: Third, some joins will be produced by calling a function from within a set iterationsince the function may also iterate through a set. This paper will concentrate on value-based joins. Since database programming languages such as PASCAL/R [SCHM77], O 2 <ref> [LECL89] </ref>, E [RICH89], and O++ [AGRA89] provide constructs to iterate through a set in some unspecified order, it is possible to nest iterators in order to express value-based joins.
Reference: [LIEU91a] <author> Daniel Lieuwen and David DeWitt, </author> <title> Optimizing Loops in Database Programming Languages. </title> <booktitle> Proceedings of 3rd Int'l Workshop on Database Programming Languages, </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: Some representative transformations are also described as tree rewrites. Section 6 describes the implementation of these ideas in an optimizing compiler. Section 7 presents the results of experiments that demonstrate that this optimization technique can be quite useful. Our conclusions are contained in Section 8. 2. RELATED WORK <ref> [LIEU91a] </ref> presents the transformations contained in this paper in source-to-source form and analytically evaluates the amount of I/O performed by the original and the transformed program assuming that all joins are computed using the hybrid hash join algorithm. This paper extends our earlier work in two ways. <p> Reductions are self-commutative. 3 Insertion into (or deletion from) a set other than those being iterated over is also self-commutative. A more complete description of the class of self-commutative statements is presented in <ref> [LIEU91a] </ref>. 4. INTRODUCTION TO THE REPRESENTATION The compiler's abstract syntax tree (AST) could be used as the query representation during the optimization of a group-by loop. The transformations contained in this paper in source-to-source form have straightforward analogues in AST-to-AST form. <p> However, there are only three classes of statements in <ref> [LIEU91a] </ref> where this is true. The first is a reduction operation on variable v where v is used in the predicate of a surrounding loop. Not only are we not covering this case in this paper, it also seems like a rare case.
Reference: [LIEU91b] <author> Daniel Lieuwen and David DeWitt, </author> <title> A Transformation-based Approach to Optimizing Loops in Database Programming Languages. </title> <type> Technical Report #1060, </type> <institution> Computer Sciences Department, University of Wisconsin, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Pred m,1 (X m ) && Pred m,2 (X 1 , ..., X m )) Insert &lt;Need (X 1 ),...,Need (X m )&gt; into Temp; Sort Temp on composite key (X 1 , X 2 , ..., X m-1 ); for (T of Temp) //in sorted order S'; hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 10 <ref> [LIEU91b] </ref>, the technical report version of this paper, contains an example of applying Supernoding twice to a loop over four sets. Also, its Appendix contains a detailed example of the steps the optimizer goes through to optimize a query.
Reference: [LOHM88] <author> Guy Lohman. </author> <title> Grammar-like Functional Rules for Representing Query Optimization Alternatives. </title> <booktitle> Proc. 1988 SIGMOD, </booktitle> <month> June </month> <year> 1988. </year>
Reference: [MURA89] <author> M. Muralikrishna. </author> <title> Optimization and Dataflow Algorithms for Nested Tree Queries. </title> <booktitle> Proceedings of 1989 Conf. Very Large Databases, </booktitle> <month> August </month> <year> 1989. </year>
Reference: [PADU86] <author> David A. Padua and Michael J. Wolfe. </author> <title> Advanced Compiler Optimizations for Supercomputers. </title> <journal> CACM 29,12 (December 1986), </journal> <pages> 1184-1201. </pages>
Reference-contexts: These subqueries can be simplified further by other transformations. We, too, break a complicated subquery into several parts. We then further transform the resulting subqueries just as they do. The idea of interchanging loops appears frequently in work on vectorizing FORTRAN <ref> [PADU86] </ref>. For instance, (2) do I = 1, N S = S + B (I,J) enddo enddo cannot be directly vectorized. However, if the I and J loops are interchanged, the definition of A (I,J+1) can be vec-torized.
Reference: [RIES83] <author> Daniel Ries, Arvola Chan, Umeshwar Dayal, Stephen Fox, Wen-Te Lin, and Laura Yedwab. </author> <title> Decompilation and Optimization for ADAPLEX: A Procedural Database Language. </title> <institution> Computer Corporation of America, </institution> <type> Technical Report CCA-82-04, </type> <address> Cambridge, Mass., </address> <month> September </month> <year> 1983. </year>
Reference-contexts: The resulting optimizing compiler is used to demonstrate empirically that using these transformations can significantly improve performance for many programs. [SHOP80] contains a slightly less-general version of the loop transformation called (T5) in this paper. <ref> [RIES83] </ref> uses an algebraic framework to optimize set loops in ADAPLEX. The algebra handles looping constructs more complicated than those covered in this paper. However, this algebra does not allow breaking a group-by loop into several loops, a key technique in this paper.
Reference: [RICH89] <author> Joel Richardson, Michael Carey, and Daniel Schuh. </author> <title> The Design of the E Programming Language. </title> <type> Technical Report #824, </type> <institution> Computer Sciences Department, University of Wisconsin, </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: Third, some joins will be produced by calling a function from within a set iterationsince the function may also iterate through a set. This paper will concentrate on value-based joins. Since database programming languages such as PASCAL/R [SCHM77], O 2 [LECL89], E <ref> [RICH89] </ref>, and O++ [AGRA89] provide constructs to iterate through a set in some unspecified order, it is possible to nest iterators in order to express value-based joins.
Reference: [SCHM77] <author> Joachim Schmidt. </author> <title> Some High Level Language Constructs for Data of Type Relation. </title> <journal> ACM Trans. Database Syst. </journal> <month> 2,3 (September </month> <year> 1977), </year> <pages> 247-261. </pages>
Reference-contexts: Third, some joins will be produced by calling a function from within a set iterationsince the function may also iterate through a set. This paper will concentrate on value-based joins. Since database programming languages such as PASCAL/R <ref> [SCHM77] </ref>, O 2 [LECL89], E [RICH89], and O++ [AGRA89] provide constructs to iterate through a set in some unspecified order, it is possible to nest iterators in order to express value-based joins.
Reference: [SELL88] <author> Timos Sellis. </author> <title> Multi-Query Optimization. </title> <journal> ACM Trans. Database Syst. </journal> <month> 13,1 (March </month> <year> 1988), </year> <pages> 23-52. </pages>
Reference-contexts: Future work includes finding new transformations, particularly transformations that combine several loops that appear sequentially in the program text into a single large loop (in some ways finding an inverse of transformations (T3) and (T4) closely related to multi-query optimization <ref> [SELL88] </ref>). Pointer-based join optimizations [SHEK90] will also be explored. We are very interested in techniques for optimizing more complicated set loopsparticularly loops that employ an O++ by clause or its equivalent. (The by clause allows a user to specify the iteration order for a set loop.
Reference: [SHEK90] <author> Eugene J. Shekita and Michael J. Carey. </author> <title> A Performance Evaluation of Pointer-Based Joins. </title> <booktitle> Proc. </booktitle> <year> 1990 </year> <month> SIG-MOD, May </month> <year> 1990. </year>
Reference-contexts: Thus, value-based joins will be needed, and they will sometimes be produced using nested iterators. Second, following pointers within a set iteration leads to an implicit join. If the system blindly follows pointers in the order specified by the user, the join execution may be unnecessarily slow <ref> [SHEK90] </ref>. Third, some joins will be produced by calling a function from within a set iterationsince the function may also iterate through a set. This paper will concentrate on value-based joins. <p> The rewritten query might well have no embedded sets. Then S might be self-commutative relative to the new list of sets even though it was not self-commutative relative to X 1 , X 2 , ..., and X m . We will ignore such rewrites in this paper; <ref> [SHEK90] </ref> employs this technique. 3 We are using FORTRAN optimization terminology. An APL/LISP reduction is not necessarily an order independent operation. To avoid these problems, we developed our own tree representation of set loops. We transform the AST into our new representation as the first step in the optimization process. <p> Future work includes finding new transformations, particularly transformations that combine several loops that appear sequentially in the program text into a single large loop (in some ways finding an inverse of transformations (T3) and (T4) closely related to multi-query optimization [SELL88]). Pointer-based join optimizations <ref> [SHEK90] </ref> will also be explored. We are very interested in techniques for optimizing more complicated set loopsparticularly loops that employ an O++ by clause or its equivalent. (The by clause allows a user to specify the iteration order for a set loop.
Reference: [SHOP80] <author> Jonathan Shopiro. </author> <title> Ph.D. Thesis. A Very High Level Language And Optimized Implementation Design For Relational Databases. </title> <institution> University of Rochester (1980). </institution>
Reference-contexts: Second, this paper describes our implementation of an optimizer that employs our transformations for the Bell Labs O++ compiler. The resulting optimizing compiler is used to demonstrate empirically that using these transformations can significantly improve performance for many programs. <ref> [SHOP80] </ref> contains a slightly less-general version of the loop transformation called (T5) in this paper. [RIES83] uses an algebraic framework to optimize set loops in ADAPLEX. The algebra handles looping constructs more complicated than those covered in this paper. <p> Dept D, Professor P where D.did=P.did group by D.name This SQL query can be expressed in O++ as: (17) for (D of Dept) - cnt = 0; //S 1,1 for (P of Professor) suchthat (D-&gt;did==P->did) cnt++; //S 2,1 printf ("%s %d ",D-&gt;name,cnt); //S 1,2 - We consider a transformation from <ref> [SHOP80] </ref> to rewrite queries involving aggregate functions such as (17).
References-found: 23

