URL: http://www.cs.man.ac.uk/~banach/some.pubs/Parallel.TGR.Conc.LP.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~banach/Recent.publications.html
Root-URL: http://www.cs.man.ac.uk
Title: PARALLEL TERM GRAPH REWRITING AND CONCURRENT LOGIC PROGRAMS  
Author: R. Banach a G. A. Papadopoulos b U. K. 
Address: East Anglia, Norwich, NR4 7TJ, U.K.  
Note: M13 9PL,  
Affiliation: a Computer Science Department, Manchester University, Manchester,  b School of Information Systems, University of  
Abstract: General term graph rewriting is a powerful computational model, suitable for implementing a wide variety of declarative language paradigms. Here, we address the problems involved in the implementation, on a loosely-coupled architecture, of an intermediate language based on term graph rewriting, DACTL. In general, such problems are severe, so a subset of this language called MONSTR is def ined, free from some of the inef ficiencies in the original model (such as an excessive necessity for locking). Superf icially, much of the expressiveness of the original model is compromised thereby, especially with regard to the implementation of concurrent logic languages. However , transformation techniques that are valid in the context of declarative language translations, and that map fairly general DACTL rule sets to equivalent MONSTR rule sets without endangering the semantics of the former can be defined. These techniques use shared graph nodes that reect states of computation, and are similar to the logical variable. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Banach R., MONSTR, </author> <note> (in preparation). </note>
Reference: [2] <author> Banach R., Sargeant J., Watson I., Watson P. and Woods V., </author> <title> The Flagship Project, </title> <booktitle> Proceedings of the Alvey Technical Conference, </booktitle> <address> Swansea, UK, </address> <month> July 4-7, </month> <year> 1988. </year>
Reference: [3] <author> Banach R. and Watson P., </author> <title> Dealing with State on FLAGSHIP: the MONSTR Computational Model, </title> <editor> in CONPAR-88, Jesshope and Reinhartz eds., </editor> <publisher> Cambridge University Press 1989, </publisher> <pages> pp. 595-604. </pages>
Reference: [4] <author> Barendregt H. P., Eekelen M. C. J. D., Glauert J. R. W., Kennaway J. R.,Plasmeijer M. J. and Sleep M. R., </author> <title> Term Graph Rewriting, </title> <editor> in PARLE-87, Odijk and Rem eds., </editor> <publisher> LNCS, Springer Verlag Vol 259, </publisher> <pages> pp. 141-158. </pages>
Reference: [5] <author> Glauert J. R. W., Kennaway J. R., Sleep M. R. and Somner G. W., </author> <title> Final Specification of DACTL, </title> <type> Internal Report SYS-C88-11, </type> <institution> University of East Anglia, Norwich, UK, </institution> <year> 1988. </year>
Reference: [6] <author> Glauert J. R. W. and Papadopoulos G. A., </author> <title> A Parallel Implementation of GHC, </title> <address> FGCS-88, Tokyo, Japan, </address> <month> Nov. 28 - Dec. </month> <title> 2, </title> <booktitle> 1988, </booktitle> <volume> Vol. 3, </volume> <pages> pp. 1051-1058. </pages>
Reference: [7] <author> Hammond K., </author> <title> Implementing Functional Languages for Parallel Machines, </title> <type> Ph.D. Thesis, </type> <institution> University of East Anglia, Norwich, UK, </institution> <year> 1988. </year>
Reference: [8] <author> Huet G. and Oppen D. C., </author> <title> Equations and Rewrite Rules: a Survey, in Formal Language Theory: Perspectives and Open Problems, </title> <publisher> Book ed., Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: 1 Introduction Rewriting theory is a powerful computational model for implementing declarative languages. Modern functional languages based on equations can be seen as specifying sets of rewrite rules (term rewriting systems <ref> [8] </ref>) that must be applied to reducible subexpressions (redexes) until a final form (the result) is reached. Where possible, common subexpressions can be shared thus saving unnecessary recomputations; this gives rise to graph rewriting systems ([12]).
Reference: [9] <author> Kennaway J. R., </author> <title> Implementing Term Rewrite Languages in DACTL, </title> <address> CAAP-88, Nancy, France, Mar.21-24, </address> <year> 1988, </year> <editor> Dauchet and Nivat eds., </editor> <publisher> LNCS, Springer Verlag Vol 299, </publisher> <pages> pp. 102-116. </pages>
Reference: [10] <author> Papadopoulos G. A., </author> <title> A Fine-Grain Parallel Implementation of PARLOG, </title> <address> TAPSOFT-89, Barcelona, Spain, </address> <month> Mar. </month> <pages> 13-17, </pages> <year> 1989, </year> <editor> Dias and Orejas eds., </editor> <publisher> LNCS, Springer Verlag Vol 351, </publisher> <pages> pp. 313-327. </pages>
Reference-contexts: Both the conjunction and unification (and the new merge too) will in time rewrite to either SUCCEED or FAIL. The fat arrow shows where this process starts. With this insight, and using the techniques described in <ref> [10] </ref>, the translation to DACTL of the above merge example is as follows: Merge [Cons [u x] y z] =&gt; #AND [^b1 ^b2], b1:*Unify [z Cons [u z1:Var]], b2:*Merge [x y z1]| Merge [x Cons [v y] z] =&gt; #AND [^b1 ^b2], b1:*Unify [z Cons [v z1:Var]], b2:*Merge [x y z1]| <p> AND also has unbalanced nodes to detect early failure and kill any remaining computation in the same conjunction; this is explained in detail in <ref> [10] </ref>. A simple definition of AND is shown below: AND [SUCCEED SUCCEED ... SUCCEED] =&gt; *SUCCEED; AND [p1:(Any - FAIL) p2:(Any - FAIL) ... pn:(Any - FAIL)] =&gt; #AND [^p1 ^p2 ... ^pn]; AND [Any Any ...
Reference: [11] <author> Papadopoulos G. A., </author> <title> Parallel Implementation of Concurrent Logic Languages Using Graph Rewriting Techniques, </title> <type> Ph.D. Thesis, </type> <institution> University of East Anglia, Norwich, UK, </institution> <year> 1989. </year>
Reference: [12] <editor> Peyton Jones S. L., </editor> <booktitle> The Implementation of Functional Programming Languages, </booktitle> <address> Prentice-Hall,1987. </address>
Reference: [13] <author> Shapiro E., </author> <title> The Family of Concurrent Logic Programming Languages, </title> <journal> Computing Surveys, 1989, </journal> <volume> Vol 21, </volume> <pages> pp. 412-510 </pages>
Reference: [14] <author> Watson P. and Watson I., </author> <title> Evaluating Functional Programs on the Flagship Machine, </title> <type> FPLCA, </type> <institution> Oregon, USA, </institution> <month> Sept. </month> <pages> 14-16, </pages> <year> 1987, </year> <editor> Khan ed., </editor> <publisher> LNCS, Springer Verlag Vol 274, </publisher> <pages> pp. 80-97. </pages>
Reference: [15] <author> Watson I., Woods V., Watson P., Banach R., Greenberg M. and Sargeant J., Flagship: </author> <title> A Parallel Architecture for Declarative Programming, </title> <booktitle> 15th International Symposium on Computer Architecture, IEEE, </booktitle> <address> Honolulu, Hawaii, </address> <month> May 30 - June 2, </month> <year> 1988, </year> <pages> pp. 124-130. </pages>
References-found: 15

