URL: http://www.csl.sri.com/~gong/papers/clock-risks.ps.gz
Refering-URL: http://www.csl.sri.com/~gong/papers/pubs92.html
Root-URL: 
Title: A Security Risk of Depending on Synchronized Clocks  
Author: Li Gong 
Date: September 24, 1991  
Affiliation: ORA Corporation and Cornell University  
Abstract: Many algorithms or protocols, in particular cryptographic protocols such as authentication protocols, use synchronized clocks and depend on them for correctness. This note describes a scenario where a clock synchronization failure renders a protocol vulnerable to an attack even after the faulty clock has been resynchronized. The attack exploits a postdated message by first suppressing it and replaying it later. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S.M. Bellovin and M. Merritt, </author> <title> "Limitations of the Kerberos Authentication System", </title> <journal> ACM Computer Communications Review, Vol.20, </journal> <volume> No.5, </volume> <month> October, </month> <year> 1990, </year> <month> pp.119-132. </month>
Reference-contexts: Bellovin and Merritt described a different attack scenario based on the observation that the duration of an authenticator is five minutes, so that an adversary may replay it, for example, when the client logs on, checks mail for one minute, and leaves <ref> [1] </ref>. A suppress-replay attack can be successful in their scenario too. Also, the duration of the authenticator is not important in the new scenario since it requires only that the authenticator is dated no later than the expiration time of the credentials.
Reference: [2] <author> D.E. Denning and G.M. Sacco, </author> <title> "Timestamps in Key Distribution Protocols", </title> <journal> Communications of the ACM, Vol.24, </journal> <volume> No.8, </volume> <month> August, </month> <year> 1981, </year> <month> pp.533-536. </month>
Reference-contexts: This note is particularly concerned with cryptographic protocols, such as some authentication protocols, which depend on synchronized clocks to timestamp messages so that the recipients can verify the timeliness of the messages and recognize and reject replays of messages communicated in the past <ref> [2, 4, 8] </ref>. Clocks can become unsynchronized due to sabotage on or faults in the clocks or the synchronization mechanism, such as overflows and the dependence on potentially unreliable clocks on remote sites (e.g. [12]) 1 . <p> For example, if a party in the Denning-Sacco authentication protocol uses a clock that is significantly behind other clocks, the party is vulnerable to a classic replay attack. The situation is corrected once the faulty clock is resynchronized. This scenario is well known <ref> [2] </ref>. In contrast, this note describes a new attack scenario where clock resynchronization does not correct the error caused by faulty clocks. When a party's clock is ahead of other clocks, its messages can get postdated. <p> For example, a connectionless protocol built on top of a reliable transport protocol may still be vulnerable. One major benefit of using timestamps is to eliminate the need for frequent handshakes <ref> [2, 7] </ref>. This note shows that the benefit is not without a cost. A handshake using nonces [11] is not vulnerable to suppress-replay attacks simply because the nonces the recipient will choose in the future are unpredictable to the sender 5 .
Reference: [3] <author> S. Kent and J. Linn, </author> <title> "Privacy Enhancement for Internet Electronic Mail: Part II Certificate-Based Key Management", IAB Network Working Group, </title> <type> RFC 1114, </type> <month> August, </month> <year> 1989. </year>
Reference-contexts: The whole discussion is not limited to short-lived data such as a message with a lifetime of five minutes; it also applies to long-lived data, such as a public-key certificate in the Internet electronic mail system <ref> [3] </ref>. Finally, it may be worth examining whether logical clocks [5], if used in a hostile environment, also suffer from suppress-replay attacks. The reason for suspicion is that logical clocks share many characteristics as physical clocks, e.g. future clocks readings are predictable thus postdating is possible.
Reference: [4] <author> J. Kohl and C. Neuman, </author> <title> "The Kerberos Network Authentication Service", </title> <type> Version 5 RFC, Draft No.4, </type> <institution> Network Working Group, MIT Project Athena, </institution> <month> December, </month> <year> 1990. </year>
Reference-contexts: This note is particularly concerned with cryptographic protocols, such as some authentication protocols, which depend on synchronized clocks to timestamp messages so that the recipients can verify the timeliness of the messages and recognize and reject replays of messages communicated in the past <ref> [2, 4, 8] </ref>. Clocks can become unsynchronized due to sabotage on or faults in the clocks or the synchronization mechanism, such as overflows and the dependence on potentially unreliable clocks on remote sites (e.g. [12]) 1 . <p> It is impractical to assume that performance failures (i.e. delays), omission failures, and denial of service can all be successfully masked in a typical system. In fact, it is not uncommon in system designs to assume that an adversary can suppress messages arbitrarily (e.g. <ref> [4] </ref>). Second, the message was originally suppressed, so techniques for recognizing duplicated messages (e.g. [9]) alone are not sufficient. Moreover, within the system, notifying the potential recipient to ignore the message is no easier than notifying a remote site to advance its clock. <p> Note that all emergency exchanges may need to depend on nonces [11] and not synchronized clocks to prove the timeliness of the messages. The remainder of this section uses the Kerberos authentication protocol <ref> [4] </ref> to show that suppress-replay attacks are real threats. It is worth emphasizing that the Kerberos protocol is not faulty in this sense because it assumes a network of synchronized clocks. <p> Obviously, if responding to a message (even more than once, e.g. caused by replays) could not cause harm, then the message is not vulnerable. For example, in Kerberos it is all right for the server to respond to a replayed initial request <ref> [4] </ref>. It is worth pointing out that the new scenario is not the well-known last-message-uncertainty phenomenon in disguise. For example, imagine a two-message protocol in which a client sends a request to a password server to change its password, and the server sends back an acknowledgment.
Reference: [5] <author> L. Lamport, </author> <title> "Time, Clocks, and the Ordering of Events in a Distributed System", </title> <journal> Communications of the ACM, Vol.21, </journal> <volume> No.7, </volume> <month> July, </month> <year> 1978, </year> <month> pp.558-565. </month>
Reference-contexts: The whole discussion is not limited to short-lived data such as a message with a lifetime of five minutes; it also applies to long-lived data, such as a public-key certificate in the Internet electronic mail system [3]. Finally, it may be worth examining whether logical clocks <ref> [5] </ref>, if used in a hostile environment, also suffer from suppress-replay attacks. The reason for suspicion is that logical clocks share many characteristics as physical clocks, e.g. future clocks readings are predictable thus postdating is possible.
Reference: [6] <author> L. Lamport and P.M. Melliar-Smith, </author> <title> "Synchronizing Clocks in the Presence of Faults", </title> <journal> Journal of the ACM, Vol.32, </journal> <volume> No.1, </volume> <month> January, </month> <year> 1985, </year> <month> pp.52-78. </month>
Reference-contexts: To guarantee clock synchronization systemwide at all times is at least very difficult and expensive, especially when many system components are under the threats of various malicious attacks and may have arbitrary (Byzantine) failures (e.g. <ref> [6, 10] </ref>). Erroneous behaviors are generally expected during clock failures ([2, 7]). For example, if a party in the Denning-Sacco authentication protocol uses a clock that is significantly behind other clocks, the party is vulnerable to a classic replay attack. The situation is corrected once the faulty clock is resynchronized.
Reference: [7] <author> B. Liskov, </author> <title> "Practical Uses of Synchronized Clocks in Distributed Systems", </title> <booktitle> in Proceedings of the 10th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, </address> <month> August, </month> <year> 1991, </year> <month> pp.1-9. </month>
Reference-contexts: 1 Introduction Synchronized clocks have become a reality in distributed systems. Many algorithms or protocols use them to improve performance; some depend on them for correctness <ref> [7] </ref>. This note is particularly concerned with cryptographic protocols, such as some authentication protocols, which depend on synchronized clocks to timestamp messages so that the recipients can verify the timeliness of the messages and recognize and reject replays of messages communicated in the past [2, 4, 8]. <p> For example, a connectionless protocol built on top of a reliable transport protocol may still be vulnerable. One major benefit of using timestamps is to eliminate the need for frequent handshakes <ref> [2, 7] </ref>. This note shows that the benefit is not without a cost. A handshake using nonces [11] is not vulnerable to suppress-replay attacks simply because the nonces the recipient will choose in the future are unpredictable to the sender 5 .
Reference: [8] <author> T.M.A. Lomas, L. Gong, J.H. Saltzer, and R.M. Needham, </author> <title> "Reducing Risks from Poorly Chosen Keys", </title> <booktitle> in Proceedings of the 12th ACM Symposium on Operating System Principles, </booktitle> <address> Litchfield Park, Arizona, </address> <month> December, </month> <year> 1989. </year> <note> Published as ACM Operating Systems Review, Vol.23, No.5, pp.14-18. </note>
Reference-contexts: This note is particularly concerned with cryptographic protocols, such as some authentication protocols, which depend on synchronized clocks to timestamp messages so that the recipients can verify the timeliness of the messages and recognize and reject replays of messages communicated in the past <ref> [2, 4, 8] </ref>. Clocks can become unsynchronized due to sabotage on or faults in the clocks or the synchronization mechanism, such as overflows and the dependence on potentially unreliable clocks on remote sites (e.g. [12]) 1 .
Reference: [9] <author> S.W. Luan and V.D Gligor, </author> <title> "On Replay Detection in Distributed Systems", </title> <booktitle> in Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <address> Paris, </address> <month> May, </month> <year> 1990, </year> <month> pp.188-195. </month>
Reference-contexts: In fact, it is not uncommon in system designs to assume that an adversary can suppress messages arbitrarily (e.g. [4]). Second, the message was originally suppressed, so techniques for recognizing duplicated messages (e.g. <ref> [9] </ref>) alone are not sufficient. Moreover, within the system, notifying the potential recipient to ignore the message is no easier than notifying a remote site to advance its clock. <p> This requires not only that errors be detected early enough but also that message delivery time be guaranteed to be sufficiently small, all in the face of malicious attacks. The recipient may also need a message duplication detection mechanism using non-volatile storage (e.g. <ref> [9] </ref>). Moreover, a carefully designed application, which avoids suppress-replay attacks, does not necessarily guarantee that a higher level application built on top of it can also avoid the attacks. For example, a connectionless protocol built on top of a reliable transport protocol may still be vulnerable.
Reference: [10] <author> D.L. Mills, </author> <title> "Network Time Protocol (Version 2) Specification and Implementation", IAB Network Working Group, </title> <type> RFC 1119, </type> <month> September, </month> <year> 1989. </year>
Reference-contexts: To guarantee clock synchronization systemwide at all times is at least very difficult and expensive, especially when many system components are under the threats of various malicious attacks and may have arbitrary (Byzantine) failures (e.g. <ref> [6, 10] </ref>). Erroneous behaviors are generally expected during clock failures ([2, 7]). For example, if a party in the Denning-Sacco authentication protocol uses a clock that is significantly behind other clocks, the party is vulnerable to a classic replay attack. The situation is corrected once the faulty clock is resynchronized.
Reference: [11] <author> R.M. Needham and M.D. Schroeder, </author> <title> "Using Encryption for Authentication in Large Networks of Computers", </title> <journal> Communications of the ACM, Vol.21, </journal> <volume> No.12, </volume> <month> December, </month> <year> 1978, </year> <month> pp.993-999. </month>
Reference-contexts: Moreover, within the system, notifying the potential recipient to ignore the message is no easier than notifying a remote site to advance its clock. Note that all emergency exchanges may need to depend on nonces <ref> [11] </ref> and not synchronized clocks to prove the timeliness of the messages. The remainder of this section uses the Kerberos authentication protocol [4] to show that suppress-replay attacks are real threats. <p> For example, a connectionless protocol built on top of a reliable transport protocol may still be vulnerable. One major benefit of using timestamps is to eliminate the need for frequent handshakes [2, 7]. This note shows that the benefit is not without a cost. A handshake using nonces <ref> [11] </ref> is not vulnerable to suppress-replay attacks simply because the nonces the recipient will choose in the future are unpredictable to the sender 5 .
Reference: [12] <author> P.G. Neumann, </author> <title> "Inside Risks", </title> <journal> Communications of the ACM, </journal> <note> Vol.34, No.1, January, 1991, p.170. [13] "Flawed computer chip sold for years", in RISKS-FORUM Digest, edited by P.G. Neumann, Vol.10, No.54 , October 18, </note> <year> 1990. </year>
Reference-contexts: Clocks can become unsynchronized due to sabotage on or faults in the clocks or the synchronization mechanism, such as overflows and the dependence on potentially unreliable clocks on remote sites (e.g. <ref> [12] </ref>) 1 . To guarantee clock synchronization systemwide at all times is at least very difficult and expensive, especially when many system components are under the threats of various malicious attacks and may have arbitrary (Byzantine) failures (e.g. [6, 10]). Erroneous behaviors are generally expected during clock failures ([2, 7]).
Reference: [14] <author> M. Satyanarayanan, </author> <title> "Integrating Security in a Large Distributed System", </title> <journal> ACM Transactions on Computer Systems, Vol.7, </journal> <volume> No.3, </volume> <month> August, </month> <year> 1989, </year> <month> pp.247-280. </month>
Reference-contexts: The adversary must know the timestamp included in the message and the clock reading at the recipient's site. The latter is trivial since a recipient typically tries to keep close to a 4 The Andrew Secure RPC is another example where such flexibility is allowed <ref> [14] </ref>. 5 If the nonces are pseudo-random numbers produced by a deterministic machine, they are predictable at least to the recipient itself. Thus there is in theory the chance of the recipient unintentionally releasing its future nonces and of the sender deducing the recipient's future nonces.
Reference: [15] <author> V.L. Voydock and S.T. Kent, </author> <title> "Security Mechanisms in High-Level Network Protocols", </title> <journal> ACM Computing Surveys, Vol.15, No.2, </journal> <month> June, </month> <year> 1983, </year> <note> pp.135-171. 5 </note>
Reference-contexts: For example, the adversary can introduce noise into network packets, block network traffic by causing packet collision, or physically cut off the communication line <ref> [15] </ref>. It is impractical to assume that performance failures (i.e. delays), omission failures, and denial of service can all be successfully masked in a typical system. In fact, it is not uncommon in system designs to assume that an adversary can suppress messages arbitrarily (e.g. [4]).
References-found: 14

