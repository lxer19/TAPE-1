URL: http://ei.cs.vt.edu/~cs6104/1996/projects/ben_project.ps
Refering-URL: http://ei.cs.vt.edu/~cs6104/1996/projects.html
Root-URL: http://www.cs.vt.edu
Email: keller@cs.vt.edu  
Title: Pattern Matching for Noncommutative Grobner Basis Computations  
Author: Benjamin J. Keller 
Date: June 28, 1996  
Address: 24061-0106 USA  
Affiliation: Department of Computer Science, Virginia Tech Blacksburg, Virginia  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. V. Aho and M. J. Corasick. </author> <title> Efficient string matching: an aid to bibliographic search. </title> <journal> Communications of the ACM, </journal> <volume> 18(6) </volume> <pages> 333-340, </pages> <year> 1975. </year>
Reference-contexts: Index automata are used for string rewriting to solve similar pattern matching problems, and could be used to solve the string completion problem. However, Sims suggests using the dictionary matching approach of Aho and Corasick <ref> [1] </ref> to implement index automata. Aho and Corasick use a static data structure to represent the automata, and so insertions and deletions to the dictionary cannot be performed without completely rebuilding the data structure. This makes the index automata unsuitable for use in implementations of completion algorithms. <p> In particular, they show how to use a suffix tree to implement the automata used for the subword search (essentially replacing the data structure used by Aho and Corasick <ref> [1] </ref>). We show how to also use the suffix tree structure for the superword and overlap searches.
Reference: [2] <author> A. Amir, M. Farach, Z. Galil, R. Giancarlo, and K. Park. </author> <title> Dynamic dictionary matching. </title> <journal> Journal of Computer and Systems Sciences, </journal> <volume> 49(2), </volume> <year> 1994. </year>
Reference-contexts: 1 Introduction We consider pattern matching for a problem from symbolic computation. In particular, we extend the dynamic dictionary matching approach of Amir et al. <ref> [2] </ref> to solve the pattern matching problems involved in the computation of Grobner bases in noncommutative algebras. The Grobner basis computation takes a set of polynomials and forms a new set by adding new polynomials. <p> The string completion problem is an extension of the dynamic dictionary problem considered by Amir et al. <ref> [2] </ref> which only includes the subword search. Like Amir et al., we use a suffix tree to store our dictionary structure, and so acheive insertion and deletion in time linear in the size of the word being added or deleted [2]. <p> of the dynamic dictionary problem considered by Amir et al. <ref> [2] </ref> which only includes the subword search. Like Amir et al., we use a suffix tree to store our dictionary structure, and so acheive insertion and deletion in time linear in the size of the word being added or deleted [2]. Using slight modifications to the suffix tree (that do not significantly affect insertion or deletion time), all searches take time linear in the sum of the sizes of the input and output. <p> If another insertion algorithm is used, then it may be better to have the search for self overlaps be a left-overlap search. 4 Pattern Matching Solution The dynamic dictionary matching approach of Amir et al. <ref> [2] </ref> provides linear time modifications to the dictionary, but only implements the subword search. In particular, they show how to use a suffix tree to implement the automata used for the subword search (essentially replacing the data structure used by Aho and Corasick [1]). <p> The algorithm checks each child and searches a subtree only if its root has a nonzero number of pattern leaves. The insertion algorithm alone takes O (jwj) time with each suffix insertion taking amortized constant time <ref> [2] </ref>. The addition of the subtree search does not affect this time for inserting each suffix.
Reference: [3] <author> T. Becker and V. Weispfenning. </author> <title> Grobner Basis: A Computational Approach to Commutative Algebra. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: Then Section 4 discusses the use of dynamic dictionary matching as a solution to these problems. Section 5 is a brief conclusion. 2 Computing Grobner Bases 2.1 Grobner Bases Grobner bases are a tool used in computations over polynomial algebras <ref> [3] </ref>. Here we consider the less typical case where the polynomials are noncommutative. Let B fl be a monoid over the alphabet , and let K be a field. <p> An admissible order on B is a well-order that is monotonic with respect to composition of words. An ideal in a polynomial ring is a set of polynomials that is both closed under addition and also closed under multiplication (on either side) by any element of the ring <ref> [3] </ref>. In noncommutative algebras, ideals have "sides" because the variables in the terms do not commute. Therefore, if p is an ideal element and q is any polynomial, then q p is not the same as p q.
Reference: [4] <author> R. V. Book and F. Otto. </author> <title> String-Rewriting Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> Submitted to soda 97 14 </note>
Reference-contexts: The frequency of additions to and deletions from D during the computation requires that these operations take time linear in the size of the input. A similar situation occurs in the closely related computation of Knuth-Bendix completion for string rewriting (see <ref> [4] </ref>). There the dictionary is the set of left-hand sides of rewrite rules, 1 Submitted to soda 97 2 but the pattern matching problems are identical. So, in general, we solve the (string) completion matching problem.
Reference: [5] <author> B. </author> <title> Buchberger. Grobner bases: an algorithmic method in polynomial ideal theory. </title> <editor> In N. K. Bose, editor, </editor> <booktitle> Multidimensional Systems Theory, Mathematics and its Applications, </booktitle> <pages> pages 184-232. </pages> <address> D. </address> <publisher> Reidel Publishing Company, Dordrecht, Holland, </publisher> <year> 1985. </year>
Reference-contexts: This fact is used in Buchberger's algorithm <ref> [5] </ref> for computing Grobner bases. We illustrate the noncommutative version of Buchberger's algorithm by an example. The algorithm takes as input a generating set F = fcab ac; cc b; baba bcg, and maintains a generating set G, and the set of overlaps of elements of G.
Reference: [6] <author> D. R. Farkas, C. D. Feustel, and E. L. Green. </author> <title> Synergy in the theories of Grobner bases and path algebras. </title> <journal> Canadian Journal of Mathematics, </journal> <volume> 45(4) </volume> <pages> 727-739, </pages> <year> 1993. </year>
Reference-contexts: The polynomial ring K ha; b; ci is the collection of all polynomials formed in this way. In general, B may be a semigroup, such as in the case of path algebras where B is the set of finite paths in a finite directed graph <ref> [6] </ref>. The leading term of a polynomial p, denoted tip (p), is determined by an admissible order on B. An admissible order on B is a well-order that is monotonic with respect to composition of words.
Reference: [7] <author> B. J. Keller. </author> <title> Alternatives in implementing noncommutative Grobner basis systems. </title> <booktitle> Submitted to the Proceedings of Conference on Symbolic Rewriting Systems, </booktitle> <address> Monte Verita, Ticino, Switzerland, </address> <month> May 1-5 </month> <year> 1995. </year>
Reference-contexts: The algorithm iterates the following steps: choose an overlap, form the overlap relation, reduce the overlap relation, and if the result is nonzero then add it to G and find the new overlaps. (The algorithm for noncommutative Grobner bases is presented by Keller <ref> [7] </ref> and Mora [10]). Denote the overlap c of cc with cab as c c ab. <p> The ability to make fast modifications is crucial to Grobner basis computations where the dictionary of patterns can change frequently. This data structure is a crucial advantage of our implementation of the noncommutative Grobner basis algorithm for path algebras, called Opal <ref> [7, 8] </ref>.
Reference: [8] <author> B. J. Keller. </author> <title> Algorithms and Orders for Finding Noncommutative Grobner Bases. </title> <type> PhD thesis, </type> <institution> Virginia Polytechnic Institute & State University, </institution> <note> (in progress). </note>
Reference-contexts: The ability to make fast modifications is crucial to Grobner basis computations where the dictionary of patterns can change frequently. This data structure is a crucial advantage of our implementation of the noncommutative Grobner basis algorithm for path algebras, called Opal <ref> [7, 8] </ref>.
Reference: [9] <author> E. M. McCreight. </author> <title> A space-economical suffix tree construction algorithm. </title> <journal> Journal of the ACM, </journal> <volume> 23(2) </volume> <pages> 262-272, </pages> <year> 1976. </year>
Reference-contexts: For each v, the label l (v) is a prefix of the suffixes represented by all leaves of the subtree rooted at v. Given a word s such that s = l (v) for some node v of a suffix tree, then v is called the locus of s <ref> [9] </ref>. Note that if there are k leaves of the suffix tree, the size of the tree is bounded by 2k 1. For dictionary matching, the suffix tree holds the suffixes for the individual dictionary words. <p> The tree is actually built by inserting each dictionary word in sequence. The insertion algorithm and data structure used for the suffix tree is based on that of McCreight <ref> [9] </ref>. McCreight's algorithm inserts the suffixes from the longest to the shortest, and uses suffix links in the tree so that insertion requires only linear time.
Reference: [10] <author> T. Mora. </author> <title> An introduction to commutative and non-commutative Grobner bases. </title> <journal> Theoretical Computer Science, </journal> <volume> 134 </volume> <pages> 131-173, </pages> <year> 1994. </year>
Reference-contexts: The algorithm iterates the following steps: choose an overlap, form the overlap relation, reduce the overlap relation, and if the result is nonzero then add it to G and find the new overlaps. (The algorithm for noncommutative Grobner bases is presented by Keller [7] and Mora <ref> [10] </ref>). Denote the overlap c of cc with cab as c c ab.
Reference: [11] <author> C. C. Sims. </author> <title> Computation with Finitely Presented Groups. </title> <publisher> Cambridge University Press, </publisher> <address> New York, </address> <year> 1994. </year>
Reference-contexts: To some extent, our solution could be considered a dynamic implementation of the index automata of Sims <ref> [11] </ref>. Index automata are used for string rewriting to solve similar pattern matching problems, and could be used to solve the string completion problem. However, Sims suggests using the dictionary matching approach of Aho and Corasick [1] to implement index automata.
References-found: 11

