URL: http://www.csl.sri.com/reports/postscript/icfem97.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Email: fCyrluk|Rushby|Srivasg@csl.sri.com  
Title: Systematic Formal Verification of Interpreters  
Author: David Cyrluk, John Rushby, Mandayam Srivas 
Address: Menlo Park CA 94025 USA  
Affiliation: Computer Science Laboratory SRI International  
Note: Presented at the first IEEE International Conference on Formal Engineering Methods (ICFEM '97), Hiroshima, Japan, November 1997, pp. 140-149.  
Abstract: Formal methods have gained acceptance in the hardware field through a pragmatic approach that has succeeded in providing systematic, scalable, highly automated, and cost-effective treatments for certain stereotypical problems of practical importance. By identifying stereotypical problems, the effort required to develop effective formal methods has been amortized over many applications. We suggest that formal methods can achieve similar industrial success in selected software applications by following the same principles. As illustration, we examine approaches to the stereotypical problem of interpreter correctness in the presence of timing differences between the specification and implementation interpreters. In hardware, this corresponds to the problem of verifying microprogrammed, pipelined, or superscalar processors, but it has wider applications to any system|hardware or software| that can be considered as an interpreter. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> R. Alur and T. A. Henzinger, editors. </editor> <booktitle> Computer-Aided Verification, CAV '96, volume 1102 of Lecture Notes in Computer Science, </booktitle> <address> New Brunswick, NJ, July/Aug. 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: the slow takeup of formal methods in the software industry, every major microprocessor and CAD company in the USA has established a formal methods program and is applying mechanized formal methods to some elements of hardware design, on at least an experimental basis (see, for example, papers in recent CAV <ref> [1, 12] </ref> and FMCAD proceedings [20] ). Some of the reasons for the greater acceptance of formal methods in hardware industry than in software were described recently by Dill and Rushby [11], and include the following. fl This work was supported by Arpa through USAF Rome Laboratory Contract No.
Reference: [2] <author> C. Barrett, D. Dill, and J. Levitt. </author> <title> Validity checking for combinations of theories with equality. </title> <booktitle> In Srivas and Camilleri [20], </booktitle> <pages> pages 187-201. </pages>
Reference-contexts: These theorem proving methods include decision procedures for propositional calculus, equality, linear arithmetic, and bitvectors, combined with rewriting, and induction <ref> [2, 8-10] </ref>. The focus is refutation rather than verification: Engineers are at least as interested in finding bugs early in the development process as in establishing their absence at its very end.
Reference: [3] <author> R. E. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary-decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: These tools perform highly automated formal calculations at various levels of the hardware design hierarchy. At the lowest level are tools that check Boolean equivalence of combinational circuits (this is useful for checking manual circuit optimizations). Techniques based on Ordered Binary Decision Diagrams (BDDs) <ref> [3] </ref> are able to check large circuits quite efficiently, and are now incorporated in industrial CAD tools.
Reference: [4] <author> J. R. Burch and D. L. Dill. </author> <title> Automatic verification of pipelined microprocessor control. </title> <editor> In D. Dill, editor, </editor> <booktitle> Computer-Aided Verification, CAV '94, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 68-80, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Verification of a simple superscalar machine is described in [7]. An alternative approach that seeks to provide greater automation was introduced by Burch and Dill <ref> [4] </ref>. Their method can be seen as a modification of the stuttering approach that avoids use of explicit time by modifying the commutes condition to take stuttering into account.
Reference: [5] <author> E. M. Clarke, O. Grumberg, H. Haraishi, S. Jha, D. E. Long, K. L. McMillan, and L. A. Ness. </author> <title> Verification of the Futurebus+ cache coherence protocol. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 6(2) </volume> <pages> 217-232, </pages> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: Applying formal methods to real problems is also crucial for building credibility. There is now a long string of success stories from academia and industry where finite-state verification techniques have been applied to hardware and protocols. A couple of documented examples include cache-coherence bugs in FutureBus+ <ref> [5] </ref> (found using symbolic model checking with a version of CMU's SMV system), and formal verification of the microarchitecture and selected microcode of the Collins AAMP5 [21] and AAMP-FV avionics processors (using theorem proving with SRI's PVS system [15]).
Reference: [6] <author> D. Cyrluk. </author> <title> Microprocessor verification in PVS: A methodology and simple example. </title> <type> Technical Report SRI-CSL-93-12, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: This example is due to Saxe, Garland, Guttag and Horning [18], who performed the original verification using the stuttering state and explicit time approach. The example, and its verification in PVS using both approaches, are described in detail in a technical report <ref> [6] </ref>. in the two figures are labeled SXX for specification register XX and IXX for the implementation register (or IXXn for n = 1, 2,. . . where the implementation has multiple registers). Two types of instructions are distinguished in this microprocessor: normal instructions and branch instructions.
Reference: [7] <author> D. Cyrluk. </author> <title> Inverting the abstraction mapping: A methodology for hardware verification. </title> <booktitle> In Srivas and Camilleri [20], </booktitle> <pages> pages 172-186. </pages>
Reference-contexts: The visible state approach does not allow num-abs-steps to return zero, instead it iterates the imple mentation next-state function enough times so that at least one specification step is taken. Verification of a simple superscalar machine is described in <ref> [7] </ref>. An alternative approach that seeks to provide greater automation was introduced by Burch and Dill [4]. Their method can be seen as a modification of the stuttering approach that avoids use of explicit time by modifying the commutes condition to take stuttering into account.
Reference: [8] <author> D. Cyrluk, P. Lincoln, and N. Shankar. </author> <title> On Shostak's decision procedure for combinations of theories. </title> <editor> In M. A. McRobbie and J. K. Slaney, editors, </editor> <booktitle> Automated Deduction|CADE-13, volume 1104 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 463-477, </pages> <address> New Brunswick, NJ, July/Aug. 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference: [9] <author> D. Cyrluk, S. Rajan, N. Shankar, and M. K. Srivas. </author> <title> Effective theorem proving for hardware verification. </title> <editor> In R. Kumar and T. Kropf, editors, </editor> <booktitle> Theorem Provers in Circuit Design (TPCD '94), volume 910 of Lecture Notes in Computer Science, </booktitle> <pages> pages 203-222, </pages> <address> Bad Her-renalb, Germany, Sept. 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference: [10] <author> D. Cyrluk, H. Rue, and O. Moller. </author> <title> An efficient decision procedure for the theory of fixed-sized bit-vectors. </title> <booktitle> In Grumberg [12], </booktitle> <pages> pages 60-71. </pages>
Reference: [11] <author> D. L. Dill and J. Rushby. </author> <title> Acceptance of formal methods: Lessons from hardware design. </title> <journal> IEEE Computer, </journal> <volume> 29(4) </volume> <pages> 23-24, </pages> <month> Apr. </month> <year> 1996. </year> <title> Part of [17]. </title>
Reference-contexts: Some of the reasons for the greater acceptance of formal methods in hardware industry than in software were described recently by Dill and Rushby <ref> [11] </ref>, and include the following. fl This work was supported by Arpa through USAF Rome Laboratory Contract No. F30602-96-C-0204, by NASA Langley Research Center under contract NAS1-20334, and by the National Science Foundation under contract CCR-9509931.
Reference: [12] <author> O. Grumberg, </author> <title> editor. Computer-Aided Verification, </title> <booktitle> CAV '97, volume 1254 of Lecture Notes in Computer Science, </booktitle> <address> Haifa, Israel, June 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: the slow takeup of formal methods in the software industry, every major microprocessor and CAD company in the USA has established a formal methods program and is applying mechanized formal methods to some elements of hardware design, on at least an experimental basis (see, for example, papers in recent CAV <ref> [1, 12] </ref> and FMCAD proceedings [20] ). Some of the reasons for the greater acceptance of formal methods in hardware industry than in software were described recently by Dill and Rushby [11], and include the following. fl This work was supported by Arpa through USAF Rome Laboratory Contract No.
Reference: [13] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1 </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: A Abst Abst The basic form of an interpreter correctness proof has been known for over 25 years <ref> [13] </ref>: both specification and implementation systems are specified as state machines, an abstraction function maps implementation states to corresponding specification states, and it is verified that each transition takes corresponding states to corresponding states (i.e., that the diagram of functions for the specification and implementation machines, respectively, and Abst is the
Reference: [14] <author> K. L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, MA, </address> <year> 1993. </year>
Reference-contexts: tools that represent the state space symbolically (using BDDs) can sometimes explore vast numbers of states (e.g., 10 100 ) in the same time, and can check richer properties (e.g., those that can be specified in a temporal logic, in which case the technique is called "temporal logic model checking") <ref> [14] </ref>. At the highest levels, or when very complex properties or very large (or infinite) state spaces are involved, highly automated theorem proving methods can be used to compare implementations with specifications.
Reference: [15] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: A couple of documented examples include cache-coherence bugs in FutureBus+ [5] (found using symbolic model checking with a version of CMU's SMV system), and formal verification of the microarchitecture and selected microcode of the Collins AAMP5 [21] and AAMP-FV avionics processors (using theorem proving with SRI's PVS system <ref> [15] </ref>). Many of these factors that have contributed to interest in formal methods among hardware engineers can also be applied to software. In this paper, we focus on just one factor|stereotypical applications|and use verification of interpreters as an example that illustrates some of the practical issues that must be addressed.
Reference: [16] <author> J. Rushby. </author> <title> Automated deduction and formal methods. </title> <booktitle> In Alur and Henzinger [1], </booktitle> <pages> pages 169-183. </pages>
Reference-contexts: The theorem provers in modern verification systems derive their power mainly from the integration of rewriting with decision procedures <ref> [16] </ref>. Specifications and proof strategies must therefore be constructed to maximize the extent to which these capabilities can be exploited. In the following section, we examine two approaches for dealing with timing differences between the imple mentation and specification machines. 3.
Reference: [17] <author> H. Saiedian (Ed.). </author> <title> An invitation to formal methods. </title> <journal> IEEE Computer, </journal> <volume> 29(4) </volume> <pages> 16-30, </pages> <month> Apr. </month> <year> 1996. </year> <title> A "roundtable" of short articles by several authors. </title>
Reference: [18] <author> J. B. Saxe, S. J. Garland, J. V. Guttag, and J. J. Horn-ing. </author> <title> Using transformations and verification in circuit design. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 4(1) </volume> <pages> 181-210, </pages> <year> 1994. </year>
Reference-contexts: An Example We now illustrate how the two different approaches can be applied to a small but nontrivial example: a simplified pipelined microprocessor. This example is due to Saxe, Garland, Guttag and Horning <ref> [18] </ref>, who performed the original verification using the stuttering state and explicit time approach. <p> By making explicit the representational choices that are implicit in treatments of pipeline correctness such as those of <ref> [18] </ref> and [19], and by casting them in a more abstract framework, we hope to have facilitated comparison between the approaches and to have made them available to a broader audience, including that concerned with verification of software artifacts.
Reference: [19] <author> M. Srivas and M. Bickford. </author> <title> Formal verification of a pipelined microprocessor. </title> <journal> IEEE Software, </journal> <volume> 7(5) </volume> <pages> 52-64, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: This is called the stuttering state approach. The two techniques are described in the following sections. 3.1. The Visible State Approach In this approach (which originated with Srivas and Bickford <ref> [19] </ref>) we distinguish two types of implementation states: those that are intended to correspond to a specification state are called visible states; the others are called non-visible states. This is illustrated in Figure 4, where non-visible states are shown dotted. <p> The need for a pipeline invariant was first recognized by Srivas and Bickford <ref> [19] </ref>; as well as being an independent proof obligation, it is needed in the proof of the commutes condition. Commutes Condition: This is the property corre sponding to Figure 1. A (Abst (vs)) = Abst (next-visible-state (vs)) Proof. <p> (As there were no external inputs in our example, it did not manifest this problem.) There are several ways to arrange this: one is to have the specification machine consume the same number of inputs in each step as all the corresponding implementation steps (this is the approach taken in <ref> [19] </ref>). However, this approach, and its alternatives, run into a problem previously encountered in the stuttering approach: the specification machine must refer to the state of the implementation machine. <p> By making explicit the representational choices that are implicit in treatments of pipeline correctness such as those of [18] and <ref> [19] </ref>, and by casting them in a more abstract framework, we hope to have facilitated comparison between the approaches and to have made them available to a broader audience, including that concerned with verification of software artifacts.
Reference: [20] <editor> M. Srivas and A. Camilleri, editors. </editor> <booktitle> Formal Methods in Computer-Aided Design (FMCAD '96), volume 1166 of Lecture Notes in Computer Science, </booktitle> <address> Palo Alto, CA, Nov. 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: methods in the software industry, every major microprocessor and CAD company in the USA has established a formal methods program and is applying mechanized formal methods to some elements of hardware design, on at least an experimental basis (see, for example, papers in recent CAV [1, 12] and FMCAD proceedings <ref> [20] </ref> ). Some of the reasons for the greater acceptance of formal methods in hardware industry than in software were described recently by Dill and Rushby [11], and include the following. fl This work was supported by Arpa through USAF Rome Laboratory Contract No.
Reference: [21] <author> M. K. Srivas and S. P. Miller. </author> <title> Formal verification of the AAMP5 microprocessor. </title> <editor> In M. G. Hinchey and J. P. Bowen, editors, </editor> <booktitle> Applications of Formal Methods, Prentice Hall International Series in Computer Science, chapter 7, </booktitle> <pages> pages 125-180. </pages> <publisher> Prentice Hall, </publisher> <address> Hemel Hempstead, UK, </address> <year> 1995. </year> <month> 10 </month>
Reference-contexts: A couple of documented examples include cache-coherence bugs in FutureBus+ [5] (found using symbolic model checking with a version of CMU's SMV system), and formal verification of the microarchitecture and selected microcode of the Collins AAMP5 <ref> [21] </ref> and AAMP-FV avionics processors (using theorem proving with SRI's PVS system [15]). Many of these factors that have contributed to interest in formal methods among hardware engineers can also be applied to software.
References-found: 21

