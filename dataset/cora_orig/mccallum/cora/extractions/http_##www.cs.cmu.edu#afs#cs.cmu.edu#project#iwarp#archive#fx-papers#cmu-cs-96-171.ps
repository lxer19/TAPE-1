URL: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/iwarp/archive/fx-papers/cmu-cs-96-171.ps
Refering-URL: http://www.cs.cmu.edu/~fx/papers.html
Root-URL: 
Title: Issues in Register Allocation by Graph Coloring  
Author: Guei-Yuan Lueh 
Note: This research was sponsored in part by the Advanced Research Projects Agency/ITO monitored by SPAWAR under contract N00039-93-C-0152. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of ARPA, SPAWAR, or the U.S. Government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: November 1996  
Pubnum: CMU-CS-96-171  
Abstract: This technical report addresses some issues in register allocation by graph coloring and presents three improvements, storage-class analysis, priority-based simplification and preference decision. The influence of the three improvements to graph coloring is discussed in this report. Comparisons of various register allocations are discussed as well. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Adl-Tabatabai, T. Gross, and G. Y. Lueh. </author> <title> Code reuse in an optimizing compiler. </title> <booktitle> In Proc. SIGPLAN Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 5168. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1996. </year>
Reference-contexts: Chaitin's algorithm provides a conceptually simple way to pack live ranges into registers. In this paper, we report on an empirical evaluation of Chaitin-style approaches to register allocation which are implemented in the cmcc optimizing C compiler <ref> [1] </ref>. <p> Shuffle code moves a data value between the different storage locations assigned to a split live range. The shuffle-code insertion phase is just a nop because both approaches do not split live ranges. This register-allocation structure also models other live-range splitting approaches <ref> [1] </ref>. There are two stacks that are used as the interface between the color-ordering and color-assignment phases: (1) the color stack (C), and (2) the spill stack (S).
Reference: [2] <author> D. Bernstein, D. Q. Goldin, M. C. Golumbic, H. Krawczyk, Y. Mansour, I. Nahshon, and R. Y. Pinter. </author> <title> Spill code minimization techniques for optimizing compilers. </title> <booktitle> In Proc. ACM SIGPLAN '89 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 258263. </pages> <publisher> ACM, </publisher> <month> July </month> <year> 1989. </year> <month> 21 </month>
Reference-contexts: Both approaches make sure to assign registers to the most important live ranges and spill the least important ones if necessary. * The register allocation algorithm used in the RS/6000 compiler <ref> [2] </ref> improves on Chaitin's basic algorithm in two ways. First, the interference graph is colored three times, each time using a variation of the spilling heuristic (i.e., a different cost function), and the coloring resulting in the least total spill cost is selected.
Reference: [3] <author> P. Briggs, K. D. Cooper, K. Kennedy, and L. Torczon. </author> <title> Coloring heuristics for register allocation. </title> <booktitle> In Proc. ACM SIGPLAN'89 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 275284. </pages> <publisher> ACM, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: The heuristic that chooses which live ranges to spill has a direct effect on the quality of the register allocation, so various heuristics have been investigated. * Simplification is a heuristic approach to coloring, and as such may miss legal coloring opportunities. Optimistic coloring <ref> [3] </ref> improves simplification by attempting to assign colors to live ranges that would have been spilled by the basic algorithm. Optimistic coloring delays spill decisions until the register assignment phase. <p> To assess the effect of the frequency information, we measured the SPEC programs using static and dynamic execution-frequency information. Static information uses the loop hierarchy (nesting levels) as an approximation of the execution frequency of a basic block <ref> [3, 7] </ref>. The execution frequency of a block B is defined as 10 depth (B) . The model treats every block within the same loop as having the same execution frequency. In practice, this 13 assumption is not always true. <p> If the static information gives us a good indication about the actual execution frequency, we see a similar improvement trend as using the dynamic information. alvinn, ear, eqntott, espresso, doduc, fpppp, matrix300, nasa7 and tomcatv fall into this category (Figure 24 in Appendix). 14 4.2 Optimistic versus non-optimistic Optimistic coloring <ref> [3] </ref> delays spill decision of live ranges until the live ranges actually fail to find legal colors. Optimistic coloring aggressively tries to find colors for those otherwise spilled live ranges.
Reference: [4] <author> P. Briggs, K. D. Cooper, and L. Torczon. </author> <title> Rematerialization. </title> <booktitle> In Proc. ACM SIGPLAN '92 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 311321. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: In effect, L is split into segments that span at most a basic block. * Rematerialization <ref> [4] </ref> spills live ranges that are cheaper to recompute than to store/load them back/from memory, e.g., loading constant values or computing addresses. 2.1.2 Live-range splitting Several approaches have tried to split live-ranges.
Reference: [5] <author> D. Callahan and B. Koblenz. </author> <title> Register allocation via hierarchical graph coloring. </title> <booktitle> In Proc. ACM SIGPLAN'91 Conf. on Prog. Language Design and Implementation, pages 192203, </booktitle> <address> Toronto, </address> <month> June </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: Splitting takes place during the coloring process. * Register allocation for the Tera compiler (as described in <ref> [5] </ref>) and probabilistic register allocation [13] perform register allocation hierarchically (from the innermost loops to the outermost loops). Loops are the natural splitting points of live ranges.
Reference: [6] <author> G. J. Chaitin, M. A. Auslander, A. K. Chandra, J. Cocke, M. E. Hopkins, and P. W. Markstein. </author> <title> Register allocation by coloring. </title> <type> Research Report 8395, </type> <institution> IBM Watson Research Center, </institution> <year> 1981. </year>
Reference-contexts: This graph captures the information about conflicts between live ranges; the register allocator attempts to find a legal N -coloring of the graph, with N the number of physical registers. Chaitin's graph-coloring algorithm forms the basis of many practical register allocators <ref> [6] </ref>. Chaitin's algorithm consists of two phases, simplification and register assignment.
Reference: [7] <author> F. C. Chow and J. L. Hennessy. </author> <title> A priority-based coloring approach to register allocation. </title> <journal> ACM Trans. on Prog. Lang. Syst., </journal> <volume> 12:501535, </volume> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: The call cost, however, is influenced by the compiler's calling convention. Many compilers divide the registers into two sets, callee-save and caller-save registers, respectively. The distinction between these registers provides the register allocator with more choices when minimizing the call overhead <ref> [7] </ref>. There is a distinct cost associated with each kind of register assigned to a live range. When a live range lr ends up in a caller-save register, we must pay the cost of saving and restoring lr's value at all function calls that are crossed by lr. <p> Optimistic coloring delays spill decisions until the register assignment phase. Spilling decisions are made during the register assignment phase: when no legal color exists for the next live range to be colored (instead of when the simplification blocks), this live range is spilled. * Priority-based coloring <ref> [7] </ref> and probabilistic register allocation [13] assign registers to live ranges based on priority functions. The priority-based approach uses a priority function that captures the savings in the number of memory accesses of a live range. <p> The benefit of splitting is that it reduces the degree of the interference graph. Furthermore, splitting 4 can take the structure of the program into account; it allows the spilling of only those live range segments that span program regions of high register pressure. * The priority-based coloring <ref> [7] </ref> splits a live range L when no legal color exists for L, i.e., when all N colors have been taken up by L's neighbors. <p> Selecting caller-save or callee-save registers for live ranges and optimizing placement of caller-save and callee-save code are two common approaches to reduce the call cost. * Priority-based register allocation <ref> [7] </ref> uses a priority function, which takes caller-save and callee-save cost into consideration. The register allocation assigns the kind of register to a live range which yields the maximum savings. 5 * The generic callee-save convention saves/restores the values of the registers at the exit/entry of the function. <p> That is, these two functions indicate the estimated number of load/store operations that are eliminated if a caller-save (or callee-save) register is assigned to lr. The two functions are similar to the priority function of priority-based approach <ref> [7] </ref>, except the benefits are not normalized by the size of live ranges. During the register assignment phase, the selection of the kind of register to use is based on these two functions. <p> For a live range that is not the first user of a callee-save register, the live range can use the callee-save register for free (since there in no need to spill the register). Priority-based coloring <ref> [7] </ref> uses the same approach to compute the priority function of a live range for callee-save registers. The second approach views callee-save costs as shared by all live ranges that share a callee-save register. <p> Now we can view the color stack as a priority-based color stack; the higher the position on the stack, the higher the priority with regard to picking registers. Hence register allocation based on this color stack is now similar to priority-based coloring <ref> [7] </ref>. <p> To assess the effect of the frequency information, we measured the SPEC programs using static and dynamic execution-frequency information. Static information uses the loop hierarchy (nesting levels) as an approximation of the execution frequency of a basic block <ref> [3, 7] </ref>. The execution frequency of a block B is defined as 10 depth (B) . The model treats every block within the same loop as having the same execution frequency. In practice, this 13 assumption is not always true. <p> As the number of registers increases, optimistic coloring has less influence and improved Chaitin-style coloring picks up, so we see the enhancement due to improved Chaitin-style coloring. 5 Priority-based vs. Chaitin At first sight, Chaitin-style coloring and priority-based coloring <ref> [7] </ref> appear to have very little in common. Priority-based coloring assigns registers to live ranges based on a priority function and splits a live range L that when no legal register exists for L. <p> The priority function is the same as the one used in <ref> [7] </ref>. The spilling heuristic of Chaitin-style coloring and optimistic coloring is spill cost (lr) degree (lr) . The heuristic tends to spill live ranges that have low spill cost and high degree. The priority function and the spilling heuristic are alike. <p> The remaining live ranges are pushed onto the color stack from the least priority to the highest priority. Chow uses the same approach in <ref> [7] </ref>. * sorting unconstrained Unconstrained live ranges are not pushed onto the color stack in a priority fashion in the removing-unconstrained approach, which means the kind of register that higher-priority live ranges covet for could possibly be taken away by lower-priority live ranges.
Reference: [8] <author> F.C. Chow. </author> <title> Minimizing register usage penalty at procedure calls. </title> <booktitle> In Proc. SIGPLAN Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 8594. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: The code to save and restore is executed inevitably every time the function is invoked, so there may be redundant saves and restores if the callee-save registers are never used during the execution of the function. Chow uses shrink-wrapping <ref> [8] </ref> to move the callee-save savings and restorings close to the places where the callee-save registers are used. Hence save and restore operations are performed only when it is absolutely necessary. * The Chez Scheme compiler optimizes the placement of caller-save code [14]. <p> is annotated so that the linker knows what instructions must be deleted and can perform reallocation once the register allocator assigns a register to a variable. * Chow extends the priority-based approach to an inter-procedural register allocation that constructs a call graph and compiles functions from leaves to the root <ref> [8] </ref>. The usage information of callee-save registers is propagated to the upper regions of the call graph. <p> Because LISP programs tend to spend most of time in the bottom of the call graph, register allocation is performed from the leaves to the root over the call graph, like Chow's approach <ref> [8] </ref>. Different registers (not used by the descendants of the current function in the call graph) are assigned to live ranges of the current function. * The HP compiler [15] performs inter-procedural register allocation using global-variable promotion and spill-code motion.
Reference: [9] <author> S. Freudenberger and J. Ruttenberg. </author> <title> Phase ordering of register allocation and instruction scheduling. </title> <editor> In R. Giegerich and S. L. Graham, editors, </editor> <title> Code Generation Concepts, </title> <booktitle> Tools, Techniques, </booktitle> <pages> pages 146170. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: This approach splits live ranges on region boundaries. A region is a collection of predicates and statements that are executed under the same control conditions. * The Multiflow compiler employs trace scheduling as a framework for both register allocation and schedul ing <ref> [9] </ref>. The trace scheduler picks a trace and then passes it to the code scheduler; the code scheduler then performs register allocation and scheduling together. Traces that are compiled first have more freedom in using registers, and shuffle code ends up on boundaries to traces that are compiled later. <p> The most important (frequently executed) regions have the maximum freedom in using registers, like in the Mulitflow compiler <ref> [9] </ref>. * Kurlander and Fischer [10] perform live range splitting after register allocation to free up registers that can be used to improve code scheduling. Empty delay slots in the final schedule are filled with shuffle code to split and spill live ranges.
Reference: [10] <author> S. M. Kurlander and C. N. Fischer. </author> <title> Zero-cost range splitting. </title> <booktitle> In Proc. ACM SIGPLAN '94 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 257265. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: The most important (frequently executed) regions have the maximum freedom in using registers, like in the Mulitflow compiler [9]. * Kurlander and Fischer <ref> [10] </ref> perform live range splitting after register allocation to free up registers that can be used to improve code scheduling. Empty delay slots in the final schedule are filled with shuffle code to split and spill live ranges.
Reference: [11] <author> W.G. Morris. Ccg: </author> <title> A prototype coagulating code generator. </title> <booktitle> In Proc. SIGPLAN Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 4558. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: As long as the trace picker presents the traces in an order that reflects the execution frequency, this scheme favors the most frequently executed parts of a program. * Coagulation code generation <ref> [11] </ref> integrates code generation and register allocation based on the ordering of prioritized control flow edges.
Reference: [12] <author> C. Norris and L. L. Pollock. </author> <title> Register allocation over the program dependence graph. </title> <booktitle> In Proc. ACM SIGPLAN '94 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 266277. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: Loops are the natural splitting points of live ranges. As coloring is done hierarchically, shuffle code tends to be outside of the innermost loops. * The RAP compiler <ref> [12] </ref> colors the region nodes in a function's Program Dependence Graph (PDG), proceeding in a hierarchical manner from the leaves to the root. Chaitin's algorithm is used at each region node. This approach splits live ranges on region boundaries.
Reference: [13] <author> T. A. Proebsting and C. N. Fischer. </author> <title> Probablistic register allocation. </title> <booktitle> In Proc. ACM SIGPLAN '92 Conf. on Prog. Language Design and Implementation, </booktitle> <pages> pages 300310. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Spilling decisions are made during the register assignment phase: when no legal color exists for the next live range to be colored (instead of when the simplification blocks), this live range is spilled. * Priority-based coloring [7] and probabilistic register allocation <ref> [13] </ref> assign registers to live ranges based on priority functions. The priority-based approach uses a priority function that captures the savings in the number of memory accesses of a live range. <p> Splitting takes place during the coloring process. * Register allocation for the Tera compiler (as described in [5]) and probabilistic register allocation <ref> [13] </ref> perform register allocation hierarchically (from the innermost loops to the outermost loops). Loops are the natural splitting points of live ranges.
Reference: [14] <author> O. Waddell R.G. Burger and R.K. Dybvig. </author> <title> Register allocation using lazy saves, eager restores, and greedy shuffling. </title> <booktitle> In Proc. SIGPLAN Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 130138. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: Chow uses shrink-wrapping [8] to move the callee-save savings and restorings close to the places where the callee-save registers are used. Hence save and restore operations are performed only when it is absolutely necessary. * The Chez Scheme compiler optimizes the placement of caller-save code <ref> [14] </ref>. Measurements show that over two thirds of procedural activations actually make no calls [14]. The compiler, hence, favors using caller-save registers along the paths that contain no calls; it uses callee-save registers along the paths where function calls are inevitable. <p> Hence save and restore operations are performed only when it is absolutely necessary. * The Chez Scheme compiler optimizes the placement of caller-save code <ref> [14] </ref>. Measurements show that over two thirds of procedural activations actually make no calls [14]. The compiler, hence, favors using caller-save registers along the paths that contain no calls; it uses callee-save registers along the paths where function calls are inevitable.
Reference: [15] <author> V. Santhanam and D. Odnert. </author> <title> Register allocation across procedure and module boundaries. </title> <booktitle> In Proc. SIGPLAN Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 2839. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Different registers (not used by the descendants of the current function in the call graph) are assigned to live ranges of the current function. * The HP compiler <ref> [15] </ref> performs inter-procedural register allocation using global-variable promotion and spill-code motion. Global-variable promotion transforms memory accesses to global variables into register references inside clusters of functions in the call graph.
Reference: [16] <author> P.A. Steenkiste and J.L. Hennessy. </author> <title> A simple interprocedural register allocation algorithm and its ef fectiveness for lisp. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1):132, </volume> <month> January </month> <year> 1989. </year>
Reference-contexts: A function tries to avoid using the same callee-save registers used by its lower regions on the call graph such that save/restore operations of the registers become redundant and can therefore be eliminated. * Steenkiste develops an inter-procedural register allocation in the context of a LISP compiler <ref> [16] </ref>. Because LISP programs tend to spend most of time in the bottom of the call graph, register allocation is performed from the leaves to the root over the call graph, like Chow's approach [8].
Reference: [17] <author> D. W. Wall. </author> <title> Global register allocation at link time. </title> <booktitle> In Proc. ACM SIGPLAN '86 Symp. on Compiler Construction, </booktitle> <pages> pages 264275, </pages> <address> Palo Alto, </address> <month> June </month> <year> 1986. </year> <journal> ACM. </journal> <volume> 22 </volume>
Reference-contexts: 2.2.2 Inter-procedural allocation Inter-procedural register allocation usually assigns registers in a hierarchical manner over the call graph such that the register allocation for a function f can take the register-usage information of functions g; h that are called by f into account. * Wall defers register allocation until link time <ref> [17] </ref>. Variables that are not simultaneously live (inter procedurally) are grouped together to use the same physical register.
References-found: 17

