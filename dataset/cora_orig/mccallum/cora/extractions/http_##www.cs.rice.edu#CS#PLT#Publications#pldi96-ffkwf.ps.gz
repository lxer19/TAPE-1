URL: http://www.cs.rice.edu/CS/PLT/Publications/pldi96-ffkwf.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/packages/mrspidey/
Root-URL: 
Email: cormac@cs.rice.edu  
Title: Catching Bugs in the Web of Program Invariants  
Author: Cormac Flanagan Matthew Flatt Shriram Krishnamurthi Stephanie Weirich Matthias Felleisen 
Address: Houston, Texas 77005-1892  
Affiliation: Department of Computer Science, Rice University,  
Abstract: MrSpidey is a user-friendly, interactive static debugger for Scheme. A static debugger supplements the standard debugger by analyzing the program and pinpointing those program operations that may cause run-time errors such as dereferencing the null pointer or applying non-functions. The program analysis of MrSpidey computes value set descriptions for each term in the program and constructs a value flow graph connecting the set descriptions. Using the set descriptions, MrSpidey can identify and highlight potentially erroneous program operations, whose cause the programmer can then explore by selectively exposing portions of the value flow graph. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aiken, A., Wimmers, E. L., and Lakshman, T. K. </author> <title> Soft typing with conditional types. </title> <booktitle> In Proceedings of the ACM Sigplan Conference on Principles of Programming Languages (1994), </booktitle> <pages> pp. 163-173. </pages>
Reference-contexts: MrSpidey also functions as an interactive optimization tool. Using MrSpidey, the programmer can tune a program so that its value set invariants accurately characterize its execution behavior, thus enabling numerous program optimizations that depend on these invariants, including variant check elimination <ref> [6, 15, 28, 1, 12] </ref>, synchronization optimization [7], partial evaluation [19], closure analysis [23], dead-code elimination and constant-folding. To investigate this potential, we implemented variant check elimination as part of Mr-Spidey. Preliminary results indicate that the resulting tool expedites the production of efficient programs. <p> This information is useful for eliminating array bounds checks and for array data dependence analysis. Other program analyses that produce information similar to set-based analysis but which provide alternative cost/accuracy tradeoffs could also be adapted for use in MrSpidey <ref> [14, 15, 12, 1] </ref>. Availability DrScheme, including MrSpidey, is available at http://www.cs.rice.edu/ scheme/packages/ drscheme. Acknowledgments We thank Corky Cartwright and Bruce Duba for discussions concerning the philosophy of soft typing and Nevin Heintze for hints on the implementation of set-based analysis.
Reference: [2] <author> Bourdoncle, F. </author> <title> Abstract debugging of higher-order imperative languages. </title> <booktitle> In Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation (June 1993), </booktitle> <pages> pp. 46-55. </pages>
Reference-contexts: Or, if the value set of a function variable only contains closures, the function application does not need to be checked, and will always succeed. Past research on static debuggers mainly focused on the synthesis of the invariants <ref> [2] </ref>. However, the presentation and, in particular, the explanation of these invariants were neglected. We believe that synthesizing invariants is not enough. Instead, a programmer must be able to inspect the invariants and browse their underlying proof. <p> Some address different concerns; none provide an explanation of the derived invariants. Syntox <ref> [2] </ref> is a static debugger for a subset of Pascal. Like MrSpidey, it associates run-time invariants, i.e., numeric ranges, with statements in the program.
Reference: [3] <editor> Clinger, W., and Rees, J. (Eds.). </editor> <title> The revised 4 report on the algorithmic language scheme. </title> <booktitle> ACM Lisp Pointers 4, </booktitle> <month> 3 (July </month> <year> 1991). </year>
Reference-contexts: As a result C programs are notoriously prone to inexplicable crashes [20]. In contrast, safe languages fl The authors are supported in part by NSF grants CCR 91-22518 and CDA-9414170. such as SML [21] and Scheme <ref> [3] </ref> equip all program operations with appropriate run-time checks. These checks guarantee that misapplications of program operations immediately raise an error signal, instead of returning random bit-patterns. Although this solution ensures that programs don't return random results, it is unsatisfactory because errors are not signaled until run-time.
Reference: [4] <author> Cooper, K. D., Hall, M. W., Hood, R., Kennedy, K., M c Kinley, K., Mellor-Crummey, J., Torczon, L., and Warren, S. </author> <title> The Parascope parallel programming environment. </title> <booktitle> Proceedings of the IEEE (February 1993), </booktitle> <pages> 244-263. </pages>
Reference-contexts: In addition, the existing system processes only a first-order language, though Bourdoncle explains how to extend the analysis [2:Section 5]. Several environments <ref> [16, 4, 13, 27, 24] </ref> have been built for parallel programming languages to expose dependencies, thus allowing the programmer to tune programs to minimize these dependencies. In particular, MrSpidey has many similarities to the ParaScope [16, 4] and D editors [13]. <p> Several environments [16, 4, 13, 27, 24] have been built for parallel programming languages to expose dependencies, thus allowing the programmer to tune programs to minimize these dependencies. In particular, MrSpidey has many similarities to the ParaScope <ref> [16, 4] </ref> and D editors [13]. Both MrSpidey and the editors provide information at varying levels of granularity; both retain source correlation through transformations; and both depict dependencies graphically.
Reference: [5] <author> Cousot, P., and Cousot, R. </author> <title> Abstract interpretation: A unified lattice model for static analyses of programs by construction or approximation of fixpoints. </title> <booktitle> In Proceedings of the ACM Sigplan Conference on Principles of Programming Languages (1977), </booktitle> <pages> pp. 238-252. </pages>
Reference-contexts: What is needed instead, is a static analysis tool that assists the programmer in verifying the preconditions of program operations. This kind of tool is a static debugger. Recent advances in proof technology have brought static debugging within reach. Methods like abstract interpretation <ref> [5] </ref>, control-flow analysis [25, 26, 14] or set-based analysis [11, 10] establish invariants about the sets of values that variables and expressions may assume.
Reference: [6] <author> Flanagan, C., and Felleisen, M. </author> <title> Set-based analysis for full Scheme and its use in soft-typing. </title> <institution> Rice University Computer Science TR95-253. </institution>
Reference-contexts: In this section, we outline the information produced by the analysis in terms of a simple functional subset of Scheme. For a full presentation of set-based analysis for a realistic language, we refer the interested reader to a related report <ref> [6] </ref>. 2.1 The Source Language The sample language is a simplified, -calculus-like language: see Figure 1. The language includes the primitives cons, car, and cdr for list manipulation, which will serve to illustrate the treatment of primitive operations, and a number of basic constants. <p> MrSpidey also functions as an interactive optimization tool. Using MrSpidey, the programmer can tune a program so that its value set invariants accurately characterize its execution behavior, thus enabling numerous program optimizations that depend on these invariants, including variant check elimination <ref> [6, 15, 28, 1, 12] </ref>, synchronization optimization [7], partial evaluation [19], closure analysis [23], dead-code elimination and constant-folding. To investigate this potential, we implemented variant check elimination as part of Mr-Spidey. Preliminary results indicate that the resulting tool expedites the production of efficient programs.
Reference: [7] <author> Flanagan, C., and Felleisen, M. </author> <title> The semantics of future and its use in program optimizations. </title> <booktitle> In Proceedings of the ACM Sigplan Conference on Principles of Programming Languages (1995), </booktitle> <pages> pp. 209-220. </pages>
Reference-contexts: MrSpidey also functions as an interactive optimization tool. Using MrSpidey, the programmer can tune a program so that its value set invariants accurately characterize its execution behavior, thus enabling numerous program optimizations that depend on these invariants, including variant check elimination [6, 15, 28, 1, 12], synchronization optimization <ref> [7] </ref>, partial evaluation [19], closure analysis [23], dead-code elimination and constant-folding. To investigate this potential, we implemented variant check elimination as part of Mr-Spidey. Preliminary results indicate that the resulting tool expedites the production of efficient programs. We intend to investigate this area in more depth.
Reference: [8] <author> Flatt, M. MrEd: </author> <title> An engine for portable graphical user interfaces. </title> <institution> Rice University Computer Science TR-96-258, Rice University. </institution>
Reference-contexts: Although the general question is PSPACE-complete [9], for our specific application it can be decided in time linear in the size of the argument's RTG, because the RTG of the expected arguments is deterministic and small. 5.4 Graphical Engine MrSpidey's graphical component is implemented using MrEd <ref> [8] </ref>, a Scheme-based engine for constructing graphical user interfaces. The core of the engine is am C++- like object system and a portable graphics library. This library defines high-level GUI elements, such as windows, buttons, and menus, which are embedded within Scheme as special primitive classes.
Reference: [9] <author> G ecseg, F., and Steinby, M. </author> <title> Tree Automata. </title> <publisher> Akademiai Kiado, </publisher> <address> Budapest, </address> <year> 1984. </year>
Reference-contexts: text. 5.2 Converting an Abstract Store to Set Description Expressions MrSpidey computes a set-description expression for each term M l from the abstract store representation as follows: First, it views the set environment as a regular-tree grammar with root non-terminal l, and uses a standard algorithm to simplify this grammar <ref> [9] </ref>. Second, it eliminates unnecessary non-terminals from this grammar, by replacing references to these non-terminals with the right-hand side of the appropriate production rules. If the resulting grammar contains only the single nonterminal l, it expresses the grammar as a non-recursive set-description expression. <p> Since the value set of each argument expression is also represented as an RTG, deciding whether a primitive is used correctly reduces to the inclusion question between two RTGs. Although the general question is PSPACE-complete <ref> [9] </ref>, for our specific application it can be decided in time linear in the size of the argument's RTG, because the RTG of the expected arguments is deterministic and small. 5.4 Graphical Engine MrSpidey's graphical component is implemented using MrEd [8], a Scheme-based engine for constructing graphical user interfaces.
Reference: [10] <author> Heintze, N. </author> <title> Set based analysis of arithmetic. </title> <type> Tech. Rep. </type> <institution> CMU-CS-93-221, Carnegie Mellon University, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: This kind of tool is a static debugger. Recent advances in proof technology have brought static debugging within reach. Methods like abstract interpretation [5], control-flow analysis [25, 26, 14] or set-based analysis <ref> [11, 10] </ref> establish invariants about the sets of values that variables and expressions may assume. Thus, if an array index expression does not assume values outside of the appropriate range, an array bound check is superfluous, and an indexing error will never be signaled for this expression. <p> Preliminary results indicate that the resulting tool expedites the production of efficient programs. We intend to investigate this area in more depth. We adapted set-based analysis for use as the underlying proof technology used in MrSpidey. Set-based analysis can be extended to produce accurate information on numeric ranges <ref> [10] </ref>. This information is useful for eliminating array bounds checks and for array data dependence analysis. Other program analyses that produce information similar to set-based analysis but which provide alternative cost/accuracy tradeoffs could also be adapted for use in MrSpidey [14, 15, 12, 1].
Reference: [11] <author> Heintze, N. </author> <title> Set-based analysis of ML programs. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1994), </booktitle> <pages> pp. 306-317. </pages>
Reference-contexts: This kind of tool is a static debugger. Recent advances in proof technology have brought static debugging within reach. Methods like abstract interpretation [5], control-flow analysis [25, 26, 14] or set-based analysis <ref> [11, 10] </ref> establish invariants about the sets of values that variables and expressions may assume. Thus, if an array index expression does not assume values outside of the appropriate range, an array bound check is superfluous, and an indexing error will never be signaled for this expression. <p> Constraints for the remaining classes of terms can be constructed in an analogous manner. Solving the derived constraints to produce a valid abstract store is straightforward <ref> [11] </ref>. 2.4 A Sample Analysis Consider the following toy program: (define sum ( tree: (if (number? tree) tree (+ (sum (car tree l 1 ) l 2 ) (sum (cdr tree)))))) (sum (cons (cons nil l 3 1 l 4 ) l 5 2 l 6 ) l 7 ) The
Reference: [12] <author> Henglein, F. </author> <title> Dynamic typing: syntax and proof theory. </title> <booktitle> Science of Computer Programming 22 (1994), </booktitle> <pages> pp. 197-230. </pages>
Reference-contexts: MrSpidey also functions as an interactive optimization tool. Using MrSpidey, the programmer can tune a program so that its value set invariants accurately characterize its execution behavior, thus enabling numerous program optimizations that depend on these invariants, including variant check elimination <ref> [6, 15, 28, 1, 12] </ref>, synchronization optimization [7], partial evaluation [19], closure analysis [23], dead-code elimination and constant-folding. To investigate this potential, we implemented variant check elimination as part of Mr-Spidey. Preliminary results indicate that the resulting tool expedites the production of efficient programs. <p> This information is useful for eliminating array bounds checks and for array data dependence analysis. Other program analyses that produce information similar to set-based analysis but which provide alternative cost/accuracy tradeoffs could also be adapted for use in MrSpidey <ref> [14, 15, 12, 1] </ref>. Availability DrScheme, including MrSpidey, is available at http://www.cs.rice.edu/ scheme/packages/ drscheme. Acknowledgments We thank Corky Cartwright and Bruce Duba for discussions concerning the philosophy of soft typing and Nevin Heintze for hints on the implementation of set-based analysis.
Reference: [13] <author> Hiranandani, S., Kennedy, K., Tseng, C.- W., and Warren, S. </author> <title> The D editor: A new interactive parallel programming tool. </title> <booktitle> In Proceedings of Supercomputing (1994). </booktitle>
Reference-contexts: In addition, the existing system processes only a first-order language, though Bourdoncle explains how to extend the analysis [2:Section 5]. Several environments <ref> [16, 4, 13, 27, 24] </ref> have been built for parallel programming languages to expose dependencies, thus allowing the programmer to tune programs to minimize these dependencies. In particular, MrSpidey has many similarities to the ParaScope [16, 4] and D editors [13]. <p> Several environments [16, 4, 13, 27, 24] have been built for parallel programming languages to expose dependencies, thus allowing the programmer to tune programs to minimize these dependencies. In particular, MrSpidey has many similarities to the ParaScope [16, 4] and D editors <ref> [13] </ref>. Both MrSpidey and the editors provide information at varying levels of granularity; both retain source correlation through transformations; and both depict dependencies graphically.
Reference: [14] <author> Jagannathan, S., and Weeks, S. </author> <title> A unified treatment of flow analysis in higher-order languages. </title> <booktitle> In 22nd ACM Symposium on Principles of Programming Languages (1995), </booktitle> <pages> pp. 393-407. </pages>
Reference-contexts: What is needed instead, is a static analysis tool that assists the programmer in verifying the preconditions of program operations. This kind of tool is a static debugger. Recent advances in proof technology have brought static debugging within reach. Methods like abstract interpretation [5], control-flow analysis <ref> [25, 26, 14] </ref> or set-based analysis [11, 10] establish invariants about the sets of values that variables and expressions may assume. <p> Future extensions are discussed below. 2.6 Value Flow Information While deriving an abstract store for the analyzed program, the set-based analysis algorithm also constructs a flow graph <ref> [14] </ref> from the subset relations. The flow graph models how values "flow" through a program during an execution, and provides an intuitive explanation for each value-set invariant produced by the analysis. Let us illustrate this idea by considering how the value nil flows through the program sum . <p> This information is useful for eliminating array bounds checks and for array data dependence analysis. Other program analyses that produce information similar to set-based analysis but which provide alternative cost/accuracy tradeoffs could also be adapted for use in MrSpidey <ref> [14, 15, 12, 1] </ref>. Availability DrScheme, including MrSpidey, is available at http://www.cs.rice.edu/ scheme/packages/ drscheme. Acknowledgments We thank Corky Cartwright and Bruce Duba for discussions concerning the philosophy of soft typing and Nevin Heintze for hints on the implementation of set-based analysis.
Reference: [15] <author> Jagannathan, S., and Wright, A. K. </author> <title> Effective flow analysis for avoiding run-time checks. </title> <booktitle> In Proc. 2nd International Static Analysis Symposium, LNCS 983 (September 1995), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 207-224. </pages> <note> Preliminary version appears as part of Technical Report DAIMI-PB 493, </note> <institution> -Aarhus University, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: MrSpidey also functions as an interactive optimization tool. Using MrSpidey, the programmer can tune a program so that its value set invariants accurately characterize its execution behavior, thus enabling numerous program optimizations that depend on these invariants, including variant check elimination <ref> [6, 15, 28, 1, 12] </ref>, synchronization optimization [7], partial evaluation [19], closure analysis [23], dead-code elimination and constant-folding. To investigate this potential, we implemented variant check elimination as part of Mr-Spidey. Preliminary results indicate that the resulting tool expedites the production of efficient programs. <p> This information is useful for eliminating array bounds checks and for array data dependence analysis. Other program analyses that produce information similar to set-based analysis but which provide alternative cost/accuracy tradeoffs could also be adapted for use in MrSpidey <ref> [14, 15, 12, 1] </ref>. Availability DrScheme, including MrSpidey, is available at http://www.cs.rice.edu/ scheme/packages/ drscheme. Acknowledgments We thank Corky Cartwright and Bruce Duba for discussions concerning the philosophy of soft typing and Nevin Heintze for hints on the implementation of set-based analysis.
Reference: [16] <author> Kennedy, K., M c Kinley, K., and Tseng, C.- W. </author> <title> Interactive parallel programming using the ParaScope Editor. </title> <journal> IEEE Transactions on Parallel and Distributed Systems 2, </journal> <month> 3 (July </month> <year> 1991). </year>
Reference-contexts: In addition, the existing system processes only a first-order language, though Bourdoncle explains how to extend the analysis [2:Section 5]. Several environments <ref> [16, 4, 13, 27, 24] </ref> have been built for parallel programming languages to expose dependencies, thus allowing the programmer to tune programs to minimize these dependencies. In particular, MrSpidey has many similarities to the ParaScope [16, 4] and D editors [13]. <p> Several environments [16, 4, 13, 27, 24] have been built for parallel programming languages to expose dependencies, thus allowing the programmer to tune programs to minimize these dependencies. In particular, MrSpidey has many similarities to the ParaScope <ref> [16, 4] </ref> and D editors [13]. Both MrSpidey and the editors provide information at varying levels of granularity; both retain source correlation through transformations; and both depict dependencies graphically.
Reference: [17] <author> Kernighan, B. W., and Ritchie, D. M. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: These problems are beyond the capabilities of standard type systems, and different languages deal with such run-time errors in different ways. Unsafe languages like C <ref> [17] </ref> ignore the problem and leave it to the programmer to insert checks where appropriate. As a result C programs are notoriously prone to inexplicable crashes [20].
Reference: [18] <author> Krishnamurthi, S. Zodiac: </author> <title> A programming environment builder. </title> <institution> Rice University Computer Science TR-96-259, Rice University. </institution>
Reference-contexts: Hence, the environment requires a front-end for processing source text that can correlate the internal representation of programs with their source location. For Scheme, this correlation task is complicated by the powerful macro systems of typical implementations because macros permit arbitrary rearrangements of syntax. MrSpidey exploits Zodiac <ref> [18] </ref> for its front-end. Zodiac is a tool-kit for generating language front-ends that are suitable for interactive environments. It includes a hygienic high-level macro system that relates each expression in the macro-expanded code to its source location.
Reference: [19] <author> Malmkjr, K., Heintze, N., and Danvy, O. </author> <title> ML partial evaluation using set-based analysis. </title> <type> Tech. Rep. </type> <institution> CMU-CS-94-129, Carnegie Mellon University, </institution> <year> 1994. </year>
Reference-contexts: Using MrSpidey, the programmer can tune a program so that its value set invariants accurately characterize its execution behavior, thus enabling numerous program optimizations that depend on these invariants, including variant check elimination [6, 15, 28, 1, 12], synchronization optimization [7], partial evaluation <ref> [19] </ref>, closure analysis [23], dead-code elimination and constant-folding. To investigate this potential, we implemented variant check elimination as part of Mr-Spidey. Preliminary results indicate that the resulting tool expedites the production of efficient programs. We intend to investigate this area in more depth.
Reference: [20] <author> Miller, B., Koski, D., Lee, C. P., Maganty, V., Murthy, P., Natarajan, A., and Steidl, J. </author> <title> Fuzz revisited: A re-examination of the reliability of unix utilities and services. </title> <institution> Computer Science Department, University of Wisconsin, </institution> <year> 1995. </year>
Reference-contexts: Unsafe languages like C [17] ignore the problem and leave it to the programmer to insert checks where appropriate. As a result C programs are notoriously prone to inexplicable crashes <ref> [20] </ref>. In contrast, safe languages fl The authors are supported in part by NSF grants CCR 91-22518 and CDA-9414170. such as SML [21] and Scheme [3] equip all program operations with appropriate run-time checks.
Reference: [21] <author> Milner, R., Tofte, M., and Harper, R. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Massachusetts and London, England, </address> <year> 1990. </year>
Reference-contexts: As a result C programs are notoriously prone to inexplicable crashes [20]. In contrast, safe languages fl The authors are supported in part by NSF grants CCR 91-22518 and CDA-9414170. such as SML <ref> [21] </ref> and Scheme [3] equip all program operations with appropriate run-time checks. These checks guarantee that misapplications of program operations immediately raise an error signal, instead of returning random bit-patterns. Although this solution ensures that programs don't return random results, it is unsatisfactory because errors are not signaled until run-time.
Reference: [22] <author> Plotkin, G. D. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theoretical Comput. Sci. </journal> <volume> 1 (1975), </volume> <pages> 125-159. </pages>
Reference-contexts: The language includes the primitives cons, car, and cdr for list manipulation, which will serve to illustrate the treatment of primitive operations, and a number of basic constants. The semantics of the source language can be formulated as a variant of Plotkins v -calculus <ref> [22] </ref>. Each term in the language is labeled, and we assume that all labels in a program are distinct.
Reference: [23] <author> Shao, Z., and Appel, A. </author> <title> Space-efficient closure representations. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming (1994), </booktitle> <pages> pp. 150-161. </pages>
Reference-contexts: Using MrSpidey, the programmer can tune a program so that its value set invariants accurately characterize its execution behavior, thus enabling numerous program optimizations that depend on these invariants, including variant check elimination [6, 15, 28, 1, 12], synchronization optimization [7], partial evaluation [19], closure analysis <ref> [23] </ref>, dead-code elimination and constant-folding. To investigate this potential, we implemented variant check elimination as part of Mr-Spidey. Preliminary results indicate that the resulting tool expedites the production of efficient programs. We intend to investigate this area in more depth.
Reference: [24] <author> Shei, B., and Gannon, D. Sigmacs: </author> <title> A programmable programming environment. </title> <booktitle> In Advances in Languages and Compilers for Parallel Computing. </booktitle> <publisher> The MIT Press, </publisher> <month> August </month> <year> 1990. </year>
Reference-contexts: In addition, the existing system processes only a first-order language, though Bourdoncle explains how to extend the analysis [2:Section 5]. Several environments <ref> [16, 4, 13, 27, 24] </ref> have been built for parallel programming languages to expose dependencies, thus allowing the programmer to tune programs to minimize these dependencies. In particular, MrSpidey has many similarities to the ParaScope [16, 4] and D editors [13].
Reference: [25] <author> Shivers, O. </author> <title> Control-flow Analysis of Higher-Order Languages, or Taming Lambda. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1991. </year>
Reference-contexts: What is needed instead, is a static analysis tool that assists the programmer in verifying the preconditions of program operations. This kind of tool is a static debugger. Recent advances in proof technology have brought static debugging within reach. Methods like abstract interpretation [5], control-flow analysis <ref> [25, 26, 14] </ref> or set-based analysis [11, 10] establish invariants about the sets of values that variables and expressions may assume.
Reference: [26] <author> Stefanescu, D., and Zhou, Y. </author> <title> An equational framework for the flow analysis of higher order functional programs. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1994), </booktitle> <pages> pp. 318-327. </pages>
Reference-contexts: What is needed instead, is a static analysis tool that assists the programmer in verifying the preconditions of program operations. This kind of tool is a static debugger. Recent advances in proof technology have brought static debugging within reach. Methods like abstract interpretation [5], control-flow analysis <ref> [25, 26, 14] </ref> or set-based analysis [11, 10] establish invariants about the sets of values that variables and expressions may assume.
Reference: [27] <author> Wolfe, M. J. </author> <title> The Tiny loop restructuring research tool. </title> <booktitle> In Proceedins of the 1991 International Conference on Parallel Processing (August 1991). </booktitle>
Reference-contexts: In addition, the existing system processes only a first-order language, though Bourdoncle explains how to extend the analysis [2:Section 5]. Several environments <ref> [16, 4, 13, 27, 24] </ref> have been built for parallel programming languages to expose dependencies, thus allowing the programmer to tune programs to minimize these dependencies. In particular, MrSpidey has many similarities to the ParaScope [16, 4] and D editors [13].
Reference: [28] <author> Wright, A., and Cartwright, R. </author> <title> A practical soft type system for scheme. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1994), </booktitle> <pages> pp. 250-262. </pages>
Reference-contexts: We constructed a text-based system, called MrSpidey/textual, that resembles an ML-style type-checker and Wright and Cartwright's soft typer <ref> [28] </ref>. MrSpidey/textual produces an annotated version of the source program, which identifies those program operations that require run-time checks. Using additional commands, a programmer may inquire about the value sets of global and local definitions, and the mismatch between the expected arguments and inferred value sets of program operations. <p> MrSpidey also functions as an interactive optimization tool. Using MrSpidey, the programmer can tune a program so that its value set invariants accurately characterize its execution behavior, thus enabling numerous program optimizations that depend on these invariants, including variant check elimination <ref> [6, 15, 28, 1, 12] </ref>, synchronization optimization [7], partial evaluation [19], closure analysis [23], dead-code elimination and constant-folding. To investigate this potential, we implemented variant check elimination as part of Mr-Spidey. Preliminary results indicate that the resulting tool expedites the production of efficient programs.
References-found: 28

