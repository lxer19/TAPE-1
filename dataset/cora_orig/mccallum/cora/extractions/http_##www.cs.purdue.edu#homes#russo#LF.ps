URL: http://www.cs.purdue.edu/homes/russo/LF.ps
Refering-URL: http://www.cs.purdue.edu/people/russo/
Root-URL: http://www.cs.purdue.edu
Email: fmuckel|russog@cs.purdue.edu  
Title: Lingua Franca: An IDL for Structural Subtyping Distributed Object Systems  
Author: Patrick A. Muckelbauer and Vincent F. Russo 
Address: West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences Purdue University  
Abstract: Recently the trend has been towards applying object-oriented techniques to address problems of building scalable and maintainable distributed systems. Object-oriented programming increases modularity and data abstraction by supporting encapsulation through narrow, rigidly defined and strongly enforced interfaces to objects. Unfortunately, object-oriented interfaces and mechanisms are usually only accessible and enforced through language mechanisms or strict programming conventions. This severely limits the degree to which disjoint, unrelated components can interact in a multilingual, loosely coupled distributed system. An accepted solution to the language dependence problem is the use of high-level interface description languages (IDLs). IDLs provide a description mechanism for an object's interface that is independent of any programming language. In this paper we describe an interface description language and runtime support system that uses structural subtyping rules rather than the traditional interface name equivalence rules for conformance checking. We argue that the choice of structural subtyping rather than interface name equivalence leads to a less coupled and more extensible distributed system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mike Accetta et al. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In Proceedings of the USENIX Conference, </booktitle> <pages> pages 93-111, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Kernel Application UNIX 1 2503s 2585s 4282s 3 2503s 2584s 4164s 5 2536s 2642s 4218s Server Object with 5 Methods 6 Related Work Clients in traditional distributed systems such as V [8, 7], Mach <ref> [1] </ref>, and Chorus [21] acquire system services from servers by explicitly sending messages to ports or processes. While the servers in such systems can be considered objects and message sending analogous to invoking methods, such systems do not provide a run-time representation for types and therefore cannot perform conformance checking.
Reference: [2] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Sub-typing Recursive Types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(4) </volume> <pages> 575-631, </pages> <year> 1993. </year>
Reference-contexts: The rules for conformance are recursive and when applied to recursive types equate to testing that the infinite expansions of the types structurally conform. Unfortunately, this implies the rules are not fini-tary. However, finitary algorithms exist that test the rules of structural conformance even in the presence of recursion <ref> [2] </ref>. To understand how this works, we first define the representation of a type to be a directed graph where the nodes of the graph represent types and edges are pointers to types used in the source node's construction. The nodes contain the necessary information to perform the conformance test. <p> This checking may make recursive calls to this algorithm but recursive calls with (F,T) as the argument will return immediately with TRUE. A detailed look at an equivalent algorithm is provided in <ref> [2] </ref>. The algorithm guarantees the conformance rules are never verified for a pair of types more than once. Since the number of nodes in a type graph is finite, the number of verifications of the conformance rules are finite, and the algorithm will terminate even in the presence of recursion.
Reference: [3] <author> John K. Bennett. </author> <title> The Design and Implementation of Distributed Smalltalk. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 318-330, </pages> <year> 1987. </year>
Reference-contexts: What separates our work from the others systems is the use of an IDL that uses structural subtyping rather than names of interfaces for conformance testing. Distributed object languages, such as Argus [14], Distributed Smalltalk <ref> [3] </ref>, and Emerald [20], and distributed object systems, such as Clouds [9] and Eden [13], not only provide a notion of objects and type conformance but also provide features such as concurrency and atomicity, replication, persistence, fault tolerance, and migration.
Reference: [4] <author> Edward V. Berard. </author> <booktitle> Essays on Object-Oriented Software Engineering, </booktitle> <volume> volume 1. </volume> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1993. </year>
Reference-contexts: In order to build a successful and scalable distributed system in such an environment we believe it is necessary to minimize the coupling between distributed components <ref> [4] </ref>. Coupling measures the interdependencies between interacting components. Low component coupling is a desirable feature of any system because it decreases the difficulty of separating, understanding, maintaining and reusing individual components [10]. Over time, it is inevitable that some components of a system will need to evolve. <p> Furthermore, these programmers are often unaware of many component inter-dependencies. Recent trends have been towards applying object-oriented techniques to address such problems in distributed and non-distributed systems. Object-oriented programming increases program modularity and data abstraction by supporting encapsulation through narrow, rigidly defined and strongly enforced interfaces to objects <ref> [4] </ref>. An object consist of an encapsulated state and a set of operations, or methods, to modify or access the state. The interface of an object is the collection of all its methods.
Reference: [5] <author> Andrew Birrell and Bruce Nelson. </author> <title> Implementing Remote Procedure Calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1), </volume> <month> February </month> <year> 1984. </year>
Reference-contexts: Object-based systems including OMG's CORBA [19], Microsoft's OLE2 [15], IBM's SOM/DSOM [12] and Sun's Spring system [11] all provide an IDL for describing objects and translators for mapping these descriptions into target languages. Likewise, remote procedure call <ref> [5] </ref> (RPC) based systems such as SUN RPC [24] provide an IDL for describing services but in terms of procedures not objects. Clients in RPC-based systems acquire services by invoking local functions that transparently access remote services.
Reference: [6] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, </title> <journal> and polymor-phism. ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Conformance checking in a distributed system has several advantages: it catches errors early, it guarantees a sense of correctness to the system by not allowing clients and servers to interact in an inconsistent manner, and it allows greater execution time efficiency of remote accesses to be achieved <ref> [6] </ref>. Client programs bind to server values dynamically at runtime.
Reference: [7] <author> David R. Cheriton. </author> <title> The V Kernel: A Software Base for Distributed Systems. </title> <journal> IEEE Software, </journal> <volume> 1(2) </volume> <pages> 19-42, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Argument/result conformance checking will add to the expense depending on the complexity of the types involved. Kernel Application UNIX 1 2503s 2585s 4282s 3 2503s 2584s 4164s 5 2536s 2642s 4218s Server Object with 5 Methods 6 Related Work Clients in traditional distributed systems such as V <ref> [8, 7] </ref>, Mach [1], and Chorus [21] acquire system services from servers by explicitly sending messages to ports or processes.
Reference: [8] <author> David R. Cheriton. </author> <title> The V Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 314-333, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Argument/result conformance checking will add to the expense depending on the complexity of the types involved. Kernel Application UNIX 1 2503s 2585s 4282s 3 2503s 2584s 4164s 5 2536s 2642s 4218s Server Object with 5 Methods 6 Related Work Clients in traditional distributed systems such as V <ref> [8, 7] </ref>, Mach [1], and Chorus [21] acquire system services from servers by explicitly sending messages to ports or processes.
Reference: [9] <author> Partha Dasgupta, Richard LeBlanc, and William Appelbe. </author> <title> The Clouds Distributed Operating System:Functional Description, Implementation Details, and Related Work. Technical Report GIT-ICS-87/42Functional Description, Implementation Details, and Related Work, </title> <type> Georgia Tech, 87. </type>
Reference-contexts: What separates our work from the others systems is the use of an IDL that uses structural subtyping rather than names of interfaces for conformance testing. Distributed object languages, such as Argus [14], Distributed Smalltalk [3], and Emerald [20], and distributed object systems, such as Clouds <ref> [9] </ref> and Eden [13], not only provide a notion of objects and type conformance but also provide features such as concurrency and atomicity, replication, persistence, fault tolerance, and migration.
Reference: [10] <author> Carlo Ghezze, Mehdi Jazayeri, and Dino Man-drioli. </author> <title> Fundamentals of Software Engineering. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: Coupling measures the interdependencies between interacting components. Low component coupling is a desirable feature of any system because it decreases the difficulty of separating, understanding, maintaining and reusing individual components <ref> [10] </ref>. Over time, it is inevitable that some components of a system will need to evolve. High component coupling increase the likelyhood that, in order to maintain inter-operability, changes to support this evolution will require modifications to other dependent components.
Reference: [11] <author> G. Hamilton, M. Powell, and J. Mitchell. Subcontract: </author> <title> A Flexible Base for Distributed Programming. </title> <booktitle> In Proceedings of the ACM Symposium on Operating System Principles, </booktitle> <month> Decem-ber </month> <year> 1993. </year>
Reference-contexts: Our approach is obviously related in overall philosophy to a number of other systems that use an interface description language. Object-based systems including OMG's CORBA [19], Microsoft's OLE2 [15], IBM's SOM/DSOM [12] and Sun's Spring system <ref> [11] </ref> all provide an IDL for describing objects and translators for mapping these descriptions into target languages. Likewise, remote procedure call [5] (RPC) based systems such as SUN RPC [24] provide an IDL for describing services but in terms of procedures not objects.
Reference: [12] <institution> IBM. </institution> <note> SOMobjects Developer Toolkit Users Guide Version 2.0, </note> <year> 1993. </year>
Reference-contexts: Also, in these systems the burden of data canonicalization and type checking is placed on the programmer. Our approach is obviously related in overall philosophy to a number of other systems that use an interface description language. Object-based systems including OMG's CORBA [19], Microsoft's OLE2 [15], IBM's SOM/DSOM <ref> [12] </ref> and Sun's Spring system [11] all provide an IDL for describing objects and translators for mapping these descriptions into target languages. Likewise, remote procedure call [5] (RPC) based systems such as SUN RPC [24] provide an IDL for describing services but in terms of procedures not objects.
Reference: [13] <author> E. Lazowska, H. Levy, G. Almes, M. Fischer, R. Fowler, and S. Vestal. </author> <title> The Architecture of the Eden System. </title> <booktitle> In Proceedings of the ACM Symposium on Operating System Principles, </booktitle> <pages> pages 148-159, </pages> <year> 1981. </year>
Reference-contexts: What separates our work from the others systems is the use of an IDL that uses structural subtyping rather than names of interfaces for conformance testing. Distributed object languages, such as Argus [14], Distributed Smalltalk [3], and Emerald [20], and distributed object systems, such as Clouds [9] and Eden <ref> [13] </ref>, not only provide a notion of objects and type conformance but also provide features such as concurrency and atomicity, replication, persistence, fault tolerance, and migration. Unfortunately, the requirements placed on these systems to support these features makes it difficult for them to scale and interoperate with one another.
Reference: [14] <author> Barbara Liskov. </author> <title> Distributed Programming in Argus. Technical Report Programming Methodology Group Memo 58, </title> <publisher> MIT, </publisher> <month> October </month> <year> 1987. </year>
Reference-contexts: What separates our work from the others systems is the use of an IDL that uses structural subtyping rather than names of interfaces for conformance testing. Distributed object languages, such as Argus <ref> [14] </ref>, Distributed Smalltalk [3], and Emerald [20], and distributed object systems, such as Clouds [9] and Eden [13], not only provide a notion of objects and type conformance but also provide features such as concurrency and atomicity, replication, persistence, fault tolerance, and migration.
Reference: [15] <author> Microsoft Corporation. </author> <title> OLE2 Programmer's Reference, volume 2. </title> <publisher> Microsoft Press, </publisher> <year> 1994. </year>
Reference-contexts: Also, in these systems the burden of data canonicalization and type checking is placed on the programmer. Our approach is obviously related in overall philosophy to a number of other systems that use an interface description language. Object-based systems including OMG's CORBA [19], Microsoft's OLE2 <ref> [15] </ref>, IBM's SOM/DSOM [12] and Sun's Spring system [11] all provide an IDL for describing objects and translators for mapping these descriptions into target languages.
Reference: [16] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Lingua Franca and the set of values they define. Records are built using the record of type constructor. Discriminated unions are built using the case of type constructor and are very similar in form to datatypes in ML <ref> [16] </ref>. A tag or discriminate field for a case type is not necessary as it is implicit in the declaration. Field names within the case of and record of type constructors must be unique. Monomorphic sequences are built using the sequence of type constructor.
Reference: [17] <author> Patrick A. Muckelbauer and Vincent F. Russo. </author> <title> Efficient Remote Method Invocation in a System Utilizing Structural Subtyping. </title> <type> Technical report, </type> <institution> Department of Computer Sciences, Pur-due University, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: The operating system's services (kernel, file system, network, devices, etc.) are all Renaissance domains. The transport mechanisms used to perform cross-domain messaging are implemented as part of the Renaissance runtime support libraries and are modular and based upon the domains of the client and server <ref> [17] </ref>. Communication protocols have been designed and built to support machine independent, cross domain method invocations using shared mem-ory and UDP/IP packet transport. <p> However, it is our opinion that the semantic information of an object and its interface are conceptually different and a clear distinction between them should be made. 5 Performance A complete analysis of the performance of our system is beyond the scope of this paper and is detailed elsewhere <ref> [17] </ref>. However, it is interesting to look at two facets of the system to put it in perspective with other work. 5.1 Performance Of Cross Domain Method Invocation a null method (no arguments/no results) for various combinations of Renaissance clients and servers.
Reference: [18] <author> Patrick A. Muckelbauer and Vincent F. Russo. </author> <title> Lingua Franca: an IDL for Structurally Sub-typing Distributed Systems. </title> <type> Technical report, </type> <institution> Department of Computer Sciences, Purdue University, </institution> <month> June </month> <year> 1995. </year> <note> This is and expanded form of the current paper. </note>
Reference-contexts: However, it can be shown that there are potentially an infinite number of distinct client interfaces that a server conforms to <ref> [18] </ref>. Two interfaces are distinct if they are not structurally equivalent. The general approach is to enumerate all possible structural supertypes (client requirements) of an interface and use multiple inheritance to build up the interface hierarchy.
Reference: [19] <author> OMG. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <year> 1991. </year>
Reference-contexts: We term an autonomous collection of objects a domain. The increased abstraction and encapsulation provided by the object-oriented model helps reduce component coupling across separately developed domains. Like other recent work <ref> [19] </ref>, we use a distributed object system model in which interaction between clients and servers are implemented as method invocations on objects in separate domains. I.e., clients access a server by invoking methods on remote references to objects in the server's domain. <p> Also, in these systems the burden of data canonicalization and type checking is placed on the programmer. Our approach is obviously related in overall philosophy to a number of other systems that use an interface description language. Object-based systems including OMG's CORBA <ref> [19] </ref>, Microsoft's OLE2 [15], IBM's SOM/DSOM [12] and Sun's Spring system [11] all provide an IDL for describing objects and translators for mapping these descriptions into target languages.
Reference: [20] <author> Rajendra K. Raj, Ewan Tempero, Henry M. Levy, Andrew P. Black, Norman C. Hutchison, and Eric Jul. </author> <title> Emerald: A General-Purpose Programming Language. </title> <journal> Software Practice and Experience, </journal> <volume> 2(1) </volume> <pages> 91-118, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: What separates our work from the others systems is the use of an IDL that uses structural subtyping rather than names of interfaces for conformance testing. Distributed object languages, such as Argus [14], Distributed Smalltalk [3], and Emerald <ref> [20] </ref>, and distributed object systems, such as Clouds [9] and Eden [13], not only provide a notion of objects and type conformance but also provide features such as concurrency and atomicity, replication, persistence, fault tolerance, and migration.
Reference: [21] <author> M. Rozier, V. Abrossimov, and W Neuhauser. </author> <title> CHORUS-V3 Kernel Specification and Interface, </title> <type> Draft. Technical Report CS/TN-87-25.10, </type> <institution> CHORUS Systems, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Kernel Application UNIX 1 2503s 2585s 4282s 3 2503s 2584s 4164s 5 2536s 2642s 4218s Server Object with 5 Methods 6 Related Work Clients in traditional distributed systems such as V [8, 7], Mach [1], and Chorus <ref> [21] </ref> acquire system services from servers by explicitly sending messages to ports or processes. While the servers in such systems can be considered objects and message sending analogous to invoking methods, such systems do not provide a run-time representation for types and therefore cannot perform conformance checking.
Reference: [22] <author> Marc Shapiro. </author> <title> Structure and Encapsulation in Distributed Systems: The Proxy Principle. </title> <booktitle> In Proceedings of the 6th. International Conference on Distributed Computer Systems, </booktitle> <month> May </month> <year> 1986. </year>
Reference-contexts: All objects have a globally unique identifier. These identifiers can be thought of as handles to the objects. Passing an object between domains amounts to passing the object's handle. Transparent use of these handles is achieved through the use of proxy objects <ref> [22] </ref>. As shown in Figure 4, a proxy is a local representation of a remote object and maps the language notion of procedure call or method invocation transparently into a remote method invocation.
Reference: [23] <author> Bjarne Stroustrup. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference: [24] <author> Sun Microsystems. </author> <title> Networking on the SUN Workstation, </title> <year> 1985. </year>
Reference-contexts: Object-based systems including OMG's CORBA [19], Microsoft's OLE2 [15], IBM's SOM/DSOM [12] and Sun's Spring system [11] all provide an IDL for describing objects and translators for mapping these descriptions into target languages. Likewise, remote procedure call [5] (RPC) based systems such as SUN RPC <ref> [24] </ref> provide an IDL for describing services but in terms of procedures not objects. Clients in RPC-based systems acquire services by invoking local functions that transparently access remote services.
Reference: [25] <author> Guido van Rossum. </author> <title> Python Reference Manual. </title> <institution> CWI (Centre for Mathematics and Computer Science), </institution> <address> Amsterdam, The Netherlands, </address> <year> 1994. </year>
Reference-contexts: The Renaissance system provides support for Lingua Franca derived programs running on UNIX systems or on a native object-oriented operating system kernel. Translators are currently supported to map Lingua Franca programs into C++[23] for compiled applications and Python <ref> [25] </ref> for interpreted applications. Additional translators of Lingua Franca to other programming languages are being investigated along with the corresponding runtime libraries. The Renaissance system and tools provide support for inter-domain object method invocations (transparently) using Lingua Franca object interface descriptions.
References-found: 25

