URL: http://www.cs.mu.oz.au/tr_db/mu_93_15.ps.gz
Refering-URL: http://www.cs.mu.oz.au/tr_db/TR.html
Root-URL: 
Title: Syntactically Recognizable Modularly Stratified Programs  
Author: David B. Kemp Kotagiri Ramamohanarao 
Note: Revised  
Date: July 1993  December 1993  
Abstract: Technical report 93/15 Department of Computer Science University of Melbourne Abstract We present an efficient evaluation technique for modularly stratified programs for which the local strata level mappings are known at compile time. We present an important subclass of these programs (called EMS-programs) in which one can easily express problems such as shortest distance, company ownership, bill of materials, preferential vote counting, and matrix diagonalization. Programs written in this style are easier to understand and can be efficiently computed. Another virtue of these programs is that their modular-stratification properties are independent of the extensional database. We also present compiler optimizations for EMS-programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> I. Balbin. </author> <title> Efficient bottom-up computation on recursively defined deductive databases. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <year> 1989. </year>
Reference-contexts: Proof: Follows from the previous lemma. Possible ways for extending the class of sips that can be used on declarative loop programs on EMS-programs include adapting the approaches of `predicate labelling' [2], `structured bottom-up' computation [3], or the `magic-set interpreter' <ref> [1] </ref>.
Reference: [2] <author> I. Balbin, Krishnamurthy Meenakshi, and Kotagiri Ramamohanarao. </author> <title> A query independent method for magic set computation on stratified databases. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 711-718, </pages> <year> 1988. </year>
Reference-contexts: Proof: Follows from the previous lemma. Possible ways for extending the class of sips that can be used on declarative loop programs on EMS-programs include adapting the approaches of `predicate labelling' <ref> [2] </ref>, `structured bottom-up' computation [3], or the `magic-set interpreter' [1].
Reference: [3] <author> I. Balbin, G.S. Port, K. Ramamohanarao, and K. Meenakshi. </author> <title> Efficient bottom-up computation of queries on stratified databases. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 295-345, </pages> <year> 1991. </year>
Reference-contexts: Proof: Follows from the previous lemma. Possible ways for extending the class of sips that can be used on declarative loop programs on EMS-programs include adapting the approaches of `predicate labelling' [2], `structured bottom-up' computation <ref> [3] </ref>, or the `magic-set interpreter' [1].
Reference: [4] <author> I. Balbin and K. Ramamohanarao. </author> <title> A generalization of the differential approach to recursive query evaluation. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(3) </volume> <pages> 259-262, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: As usual, we are treating any term of the form s i (0) as the integer i. Note that, for a given i and l, the computation of i;l " ! can use an obvious adaptation of the "differential" or "semi-naive" techniques presented in <ref> [4] </ref> and [5]. Example 4 Here we show how to use to evaluate the shortest distance program for predicates sd; esd, and psd in section 4. So as to simplify this presentation, we do not show the tuples generated for new1 and new2.
Reference: [5] <author> F. Bancilhon. </author> <title> Naive evaluation of recursively defined relations. </title> <editor> In M. Brodie and J. Mylopoulos, editors, </editor> <booktitle> On knowledge-base management systems integrating database and AI systems, </booktitle> <pages> pages 165-178. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986. </year> <note> Also appeared in the Proceedings of the Islamadora Conference on Databases and AI, </note> <year> 1985. </year>
Reference-contexts: As usual, we are treating any term of the form s i (0) as the integer i. Note that, for a given i and l, the computation of i;l " ! can use an obvious adaptation of the "differential" or "semi-naive" techniques presented in [4] and <ref> [5] </ref>. Example 4 Here we show how to use to evaluate the shortest distance program for predicates sd; esd, and psd in section 4. So as to simplify this presentation, we do not show the tuples generated for new1 and new2. The predicate new1 is a simple projection of sd.
Reference: [6] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J.D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the Fifth ACM PODS Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <year> 1986. </year>
Reference-contexts: To overcome this, various program transformations have been developed that can specialize a 19 program to particular classes of query. These transformations ensure that the well-founded model of the transformed program only consists of tuples that are in some sense `relevant to the query'. The magic set transformation (cf. <ref> [6, 7] </ref>) is one of the more well known and most generally applicable of these program transformations. In addition to the program itself, the magic set transformation requires modes and sips.
Reference: [7] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In Proceedings of the Sixth ACM PODS Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <year> 1987. </year>
Reference-contexts: To overcome this, various program transformations have been developed that can specialize a 19 program to particular classes of query. These transformations ensure that the well-founded model of the transformed program only consists of tuples that are in some sense `relevant to the query'. The magic set transformation (cf. <ref> [6, 7] </ref>) is one of the more well known and most generally applicable of these program transformations. In addition to the program itself, the magic set transformation requires modes and sips. <p> Given a head mode and a corresponding sips for a rule, we adorn that rule using a method similar to that given by Beeri and Ramakrishnan in <ref> [7] </ref>. The head is adorned with the head mode, and each IDB body literal L is adorned as follows. If the sips does not contain an arc feeding L, then each of its arguments are adorned free except for those that are fully ground terms | these are adorned bound.
Reference: [8] <author> S. Ceri, G. Gottlob, and L. Tanca. </author> <title> Logic programming and databases. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> Surveys in Computer Science. </note>
Reference-contexts: Indeed, evaluation of this program will still terminate, but the relation for bom will not contain tuples for those parts involved in a cycle. 29 A.3 Company Control In this section, we look at a problem presented in <ref> [8] </ref> and in [22]. It is further investigated in [26]. Say that the base relation direct (X,Y,V) is true when company X directly owns V shares in Y where V is expressed as a percentage of the total number of shares available for Y.
Reference: [9] <institution> Australian Electoral Commission. </institution> <note> Fact Sheet , 1993. Also obtained from the AEC: Commonwealth electoral procedures 1992, and Electoral pocket book 1991. </note>
Reference-contexts: First we give a brief | and slightly simplified | summary of Australia's system of government. More details can be obtained from the Australian Electoral Commission <ref> [9] </ref>. Australia is governed by two houses of parliament: a House of Representatives and a Senate. For the purposes of choosing members of the House of Representatives, Australia's physical area is divided into 147 non-overlapping electoral divisions | each with a roughly similar population size.
Reference: [10] <author> E. W. Dijkstra. </author> <title> A note on two problems in connection with graphs. </title> <journal> In Numerische Mathematik: </journal> <volume> 1, </volume> <pages> pages 269-271, </pages> <year> 1959. </year>
Reference-contexts: Furthermore, it is difficult to define a syntactic characterization of a reasonably useful class of programs that express closed semi-ring problems. Let us consider the shortest distance problem in more detail. In particular, let us consider Dijkstra's shortest path algorithm <ref> [10] </ref> for finding all shortest paths from a single point p.
Reference: [11] <author> Sumit Ganguly, Sergio Greco, and Carlo Zaniolo. </author> <title> Minimum and maximum predicates in logic programming. </title> <booktitle> In Proceedings of the Tenth ACM PODS Symposium on Principles of Database Systems, </booktitle> <pages> pages 154-163, </pages> <year> 1991. </year>
Reference-contexts: This was a generalization of the work by Ganguly et al. <ref> [11] </ref>, Mumick et at. [22], and Sudarshan and Ramakrishnan [28]. It appears that the techniques proposed in these papers should result in quite efficient evaluation. However, monotonicity, as it is defined in these papers, is not a syntactically recognizable property.
Reference: [12] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proceedings of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1071-1080, </pages> <year> 1988. </year>
Reference-contexts: This means that its well founded model is always two valued, and it may possibly be easier to understand. This last point is supported by the fact that, if the edge relation describes a cyclic graph, then the one line program may have more than one stable model <ref> [12] </ref>, and may even have no stable models. A.2 Bill of materials In this section we show how to express the `bill of materials' problem as an EMS-program.
Reference: [13] <author> David B. Kemp and Peter J. Stuckey. </author> <title> Semantics of logic programs with aggregates. </title> <booktitle> In Proceedings of the 1991 International Symposium on Logic Programming, </booktitle> <pages> pages 387-401, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The terminology and definitions used for aggregates are the same as those given in <ref> [13] </ref>, which was, in turn, based on work done by others on the semantics of negation (cf. [31]), and aggregates (cf. [22]). 2.1 Common notation and terminology We use the following Prolog-like notation. * Constants are represented by using strings of letters starting with lower case letters. <p> Now suppose we wish to know the shortest distance between any two nodes in the graph. This problem belongs to the class of generalized transitive closure problems called closed semi-ring problems (cf. Ullman [30]). Quite efficient algorithms have been developed for these problems. It is shown in <ref> [13] </ref> that the closed semi-ring problems can be expressed as three line programs. <p> The semantics tends to be unclear, or at best difficult to understand. Using the semantics given in <ref> [13] </ref>, the above program can have more than one stable model (see [13] for an example of this - it happens if the domain includes `1' even when the distances given are positive finite values). <p> The semantics tends to be unclear, or at best difficult to understand. Using the semantics given in <ref> [13] </ref>, the above program can have more than one stable model (see [13] for an example of this - it happens if the domain includes `1' even when the distances given are positive finite values). Furthermore, it is difficult to define a syntactic characterization of a reasonably useful class of programs that express closed semi-ring problems. <p> Indeed, if our base relations are: frequires (liz,1), requires (jane,1)g, and ffriend (liz,jane), friend (jane,liz)g, then one of the "stable models" (as defined in <ref> [13] </ref>), is fcoming (liz), coming (jane), kc (liz,jane), kc (jane,liz)g.
Reference: [14] <author> David B. Kemp, Peter J. Stuckey, and Divesh Srivastava. </author> <title> Magic sets and bottom-up evalu-ation of well-founded models. </title> <booktitle> In Proceedings of the 1991 International Symposium on Logic Programming, </booktitle> <pages> pages 336-351, </pages> <month> October </month> <year> 1991. </year> <title> An extended version, containing all proofs, </title> <note> is available as Melbourne University technical report 91/4. </note>
Reference-contexts: Firstly, it may be possible that the magic set transformed program does not agree with the query with respect to the well founded model of the program | these problems are discussed for programs containing negation in <ref> [14, 15] </ref>. Secondly, even if query equivalence were preserved by a magic set transformation, the resulting program may not be a modularly stratified program.
Reference: [15] <author> David B. Kemp, Peter J. Stuckey, and Divesh Srivastava. </author> <title> Query restricted bottom-up evaluation in normal form logic. </title> <booktitle> In Proceedings of the 1992 Joint International Conference and Symposium on Logic Programming., </booktitle> <pages> pages 288-302, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Assigning predicate level numbers can easily be done after performing a topological sort of the strongly connected components | a task that can also be performed in linear time. 8 Evaluation of EMS-programs Various techniques have been developed for general programs (cf. <ref> [15] </ref>) and for programs that are modularly stratified (cf. [25]). These techniques suffer from various problems. Some, such as those proposed in [15] only deal with programs containing negation, and they do not extend well to program containing aggregation. <p> the strongly connected components | a task that can also be performed in linear time. 8 Evaluation of EMS-programs Various techniques have been developed for general programs (cf. <ref> [15] </ref>) and for programs that are modularly stratified (cf. [25]). These techniques suffer from various problems. Some, such as those proposed in [15] only deal with programs containing negation, and they do not extend well to program containing aggregation. <p> Firstly, it may be possible that the magic set transformed program does not agree with the query with respect to the well founded model of the program | these problems are discussed for programs containing negation in <ref> [14, 15] </ref>. Secondly, even if query equivalence were preserved by a magic set transformation, the resulting program may not be a modularly stratified program.
Reference: [16] <author> Phokion G. Kolaitis and Christos H. Papadimitriou. </author> <booktitle> Why not negation by fixpoint ? In Proceedings of the Seventh ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 231-239, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: In the next appendix we present an even more difficult, although very practical problem for which our approach is well suited and for which it is difficult to find any other solution. A.1 The simple game program Consider the game playing program given in <ref> [16] </ref>. win (X) edge (X; Y ); :win (Y ) The intended meaning is that win (X) is true if X is a winning position.
Reference: [17] <author> Alexandre Lefebvre. </author> <title> Recursive aggregates in the EKS-V1 system. </title> <type> Technical report, </type> <institution> TR-KB 34, ECRC, European Computer-Industry Research Centre, Munchen, Germany, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: A top-down approach to evaluating modularly stratified programs based on QSQ is given in <ref> [17, 18] </ref>. However, just as with [22, 25], dependencies between atoms need to be maintained at runtime. In effect, these techniques determine the local strata levels of atoms at runtime, and this is an unnecessary overhead for the class of programs we investigate in this paper.
Reference: [18] <author> Alexandre Lefebvre. </author> <title> Towards an efficient evaluation of recursive aggregates in deductive databases, </title> <note> 1993. To appear in the New Generation of Computing Journal. An earlier version appeared in the proceedings of the FGCS'92 conference. </note>
Reference-contexts: A top-down approach to evaluating modularly stratified programs based on QSQ is given in <ref> [17, 18] </ref>. However, just as with [22, 25], dependencies between atoms need to be maintained at runtime. In effect, these techniques determine the local strata levels of atoms at runtime, and this is an unnecessary overhead for the class of programs we investigate in this paper.
Reference: [19] <author> J.W. Lloyd. </author> <booktitle> Foundations of logic programming. Springer Series in Symbolic Computation. </booktitle> <publisher> Springer Verlag, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1987. </year>
Reference-contexts: Furthermore, unlike the general class of modularly stratified programs, recognizing these programs is a solvable problem. 2 Terminology Where possible, we usually use the standard terminology and definitions for logic programs and deductive databases similar to those found in Lloyd <ref> [19] </ref> and in Ullman [29, 30].
Reference: [20] <author> J.W. Lloyd and R.W. Topor. </author> <title> Making prolog more expressive. </title> <journal> Journal of Logic Programming, </journal> <volume> 1(3) </volume> <pages> 225-240, </pages> <year> 1984. </year>
Reference-contexts: Furthermore, notice that we are applying the negation operation to more than just simple atoms. Much of the deductive database literature does not consider expressions such as `: 9 X a (X; Y )'. If necessary, a compiler could use the techniques described in <ref> [20] </ref> and replace expressions such as this with simple literals by using a new predicate and adding new rules to the program. <p> To determine if a program whose rule bodies are general well-formed formulas is EMS, it is probably much easier for the programmer to actually perform the transformation to normal form by hand using the techniques in <ref> [20] </ref>, and then apply the tests in Definition 13. If we can prove that EMS-programs are modularly stratified, and that there is a simple formula for determining the level of a ground atom, then we can use the operator given in the Section 5 for query evaluation.
Reference: [21] <author> Inderpal S. Mumick, Sheldon J. Finkelstein, Hamid Pirahesh, and Raghu Ramakrishnan. </author> <title> Magic conditions. </title> <booktitle> In Proceedings of the Ninth ACM PODS Symposium on the Principles of Database Systems, </booktitle> <pages> pages 314-330, </pages> <year> 1990. </year>
Reference-contexts: In addition to the program itself, the magic set transformation requires modes and sips. Here we describe the basic bf mode system; more precise systems of modes can be found in <ref> [21] </ref> and [27]. Definition 14 If p is an n-ary predicate, then a mode for p is a string ff of length n, each of whose elements is either f or b.
Reference: [22] <author> Inderpal Singh Mumick, Hamid Pirahesh, and Raghu Ramakrishnan. </author> <title> The magic of duplicates and aggregates. </title> <booktitle> In Proceedings of the Sixteenth Conference on Very Large Databases, </booktitle> <pages> pages 264-277, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: The terminology and definitions used for aggregates are the same as those given in [13], which was, in turn, based on work done by others on the semantics of negation (cf. [31]), and aggregates (cf. <ref> [22] </ref>). 2.1 Common notation and terminology We use the following Prolog-like notation. * Constants are represented by using strings of letters starting with lower case letters. Numbers are also constants. <p> These terms are defined for programs containing negation in [23] and [25] respectively, and extended to programs containing aggregates in <ref> [22] </ref>. We now try to make this extension more formal as we find some of these definitions useful when discussing our evaluation techniques. <p> This was a generalization of the work by Ganguly et al. [11], Mumick et at. <ref> [22] </ref>, and Sudarshan and Ramakrishnan [28]. It appears that the techniques proposed in these papers should result in quite efficient evaluation. However, monotonicity, as it is defined in these papers, is not a syntactically recognizable property. <p> Indeed, in the examples given, such as the shortest-path, company-control, and party attendance problems, the monotonicity property relies on the EDB relations having certain properties (no negative edges, for example). There have been some proposals for the bottom-up evaluation of modularly stratified programs <ref> [22, 25] </ref>, but these involve maintaining sets of dependencies between atoms at run-time, and the manipulation of non-ground tuples even when the program is `range restricted' | handling non-ground tuples usually requires expensive subsumption testing. <p> A top-down approach to evaluating modularly stratified programs based on QSQ is given in [17, 18]. However, just as with <ref> [22, 25] </ref>, dependencies between atoms need to be maintained at runtime. In effect, these techniques determine the local strata levels of atoms at runtime, and this is an unnecessary overhead for the class of programs we investigate in this paper. <p> Indeed, evaluation of this program will still terminate, but the relation for bom will not contain tuples for those parts involved in a cycle. 29 A.3 Company Control In this section, we look at a problem presented in [8] and in <ref> [22] </ref>. It is further investigated in [26]. Say that the base relation direct (X,Y,V) is true when company X directly owns V shares in Y where V is expressed as a percentage of the total number of shares available for Y.
Reference: [23] <author> Teodor C. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1988. </year>
Reference-contexts: Consequently, we also use agg (p ( ~ X)) to denote :p ( ~ X ). 2.3 The Herbrand base, stratification, and well-founded models Here we review the definition of local and modular stratification. These terms are defined for programs containing negation in <ref> [23] </ref> and [25] respectively, and extended to programs containing aggregates in [22]. We now try to make this extension more formal as we find some of these definitions useful when discussing our evaluation techniques.
Reference: [24] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Rule ordering in bottom-up fixpoint evaluation of logic programs. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 359-371, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: In this example, it is actually possible to give each predicate a different predicate level, and it would be more efficient to do this for reasons not unlike the reasons motivating the "psn" techniques presented in <ref> [24] </ref>. However, in this example we will only use the predicate level assignments given above. For N = 0, bom and hence new2 are empty, and bom5 (X; X; X; 1; N ) is true for all bicycle parts, including X = bicycle.
Reference: [25] <author> Ken A. Ross. </author> <title> Modular stratification and magic sets for DATALOG programs with negation. </title> <booktitle> In Proceedings of the Ninth ACM PODS Symposium on Principles of Database Systems, </booktitle> <pages> pages 161-171, </pages> <year> 1990. </year> <title> An extended version of this paper, containing new results, was obtained from the author. </title> <type> 45 </type>
Reference-contexts: Consequently, we also use agg (p ( ~ X)) to denote :p ( ~ X ). 2.3 The Herbrand base, stratification, and well-founded models Here we review the definition of local and modular stratification. These terms are defined for programs containing negation in [23] and <ref> [25] </ref> respectively, and extended to programs containing aggregates in [22]. We now try to make this extension more formal as we find some of these definitions useful when discussing our evaluation techniques. <p> Indeed, in the examples given, such as the shortest-path, company-control, and party attendance problems, the monotonicity property relies on the EDB relations having certain properties (no negative edges, for example). There have been some proposals for the bottom-up evaluation of modularly stratified programs <ref> [22, 25] </ref>, but these involve maintaining sets of dependencies between atoms at run-time, and the manipulation of non-ground tuples even when the program is `range restricted' | handling non-ground tuples usually requires expensive subsumption testing. <p> A top-down approach to evaluating modularly stratified programs based on QSQ is given in [17, 18]. However, just as with <ref> [22, 25] </ref>, dependencies between atoms need to be maintained at runtime. In effect, these techniques determine the local strata levels of atoms at runtime, and this is an unnecessary overhead for the class of programs we investigate in this paper. <p> predicate level numbers can easily be done after performing a topological sort of the strongly connected components | a task that can also be performed in linear time. 8 Evaluation of EMS-programs Various techniques have been developed for general programs (cf. [15]) and for programs that are modularly stratified (cf. <ref> [25] </ref>). These techniques suffer from various problems. Some, such as those proposed in [15] only deal with programs containing negation, and they do not extend well to program containing aggregation. Existing techniques that are specialized to modularly stratified programs, such as the techniques given in [25], build tables of dependencies between <p> that are modularly stratified (cf. <ref> [25] </ref>). These techniques suffer from various problems. Some, such as those proposed in [15] only deal with programs containing negation, and they do not extend well to program containing aggregation. Existing techniques that are specialized to modularly stratified programs, such as the techniques given in [25], build tables of dependencies between atoms | they effectively discover the local strata of atoms at runtime, and this is an unnecessary overhead for EMS-programs.
Reference: [26] <author> Ken A. Ross and Yehoshua Sagiv. </author> <title> Monotonic aggregation in deductive databases. </title> <booktitle> In Pro--ceedings of the Eleventh ACM PODS Symposium on the Principles of Database Systems, 1992. Also appeared in the proceedings of the Workshop on Deductive Databases at the International Symposium on Logic Programming, </booktitle> <pages> pages 53-61, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Hence, the reduced program is locally stratified, and so the original program is modularly stratified. 3 Existing evaluation proposals Bottom-up evaluation techniques for programs containing recursion through aggregation that have been proposed have been restricted to programs defined as monotonic by Ross and Sagiv in <ref> [26] </ref>. This was a generalization of the work by Ganguly et al. [11], Mumick et at. [22], and Sudarshan and Ramakrishnan [28]. It appears that the techniques proposed in these papers should result in quite efficient evaluation. <p> Indeed, evaluation of this program will still terminate, but the relation for bom will not contain tuples for those parts involved in a cycle. 29 A.3 Company Control In this section, we look at a problem presented in [8] and in [22]. It is further investigated in <ref> [26] </ref>. Say that the base relation direct (X,Y,V) is true when company X directly owns V shares in Y where V is expressed as a percentage of the total number of shares available for Y. <p> If the strata-level argument is omitted, then the rules are the same as those given in <ref> [26] </ref>. In our version however, the program is always modularly stratified, even when the share ownership relation is cyclic. The resultant computation is actually very similar to that suggested in [26]. A.4 Party invitations This is a problem presented in [26] Suppose that you have sent out party invitations, but that <p> If the strata-level argument is omitted, then the rules are the same as those given in <ref> [26] </ref>. In our version however, the program is always modularly stratified, even when the share ownership relation is cyclic. The resultant computation is actually very similar to that suggested in [26]. A.4 Party invitations This is a problem presented in [26] Suppose that you have sent out party invitations, but that there are some people who will not accept the invitation until some minimum number of their friends accept the invitation. <p> then the rules are the same as those given in <ref> [26] </ref>. In our version however, the program is always modularly stratified, even when the share ownership relation is cyclic. The resultant computation is actually very similar to that suggested in [26]. A.4 Party invitations This is a problem presented in [26] Suppose that you have sent out party invitations, but that there are some people who will not accept the invitation until some minimum number of their friends accept the invitation. We assume that there is bad communication between friends so that the obvious deadlock situations occur. <p> Suppose that the relation friend (X,Y) is true when person X is a friend of person Y, and that the relation requires (X,K) is true when person X requires that at least K of X's friends have accepted the invitation. The solution proposed in <ref> [26] </ref> looks something like: coming (X) :- requires (X, 0). coming (X) :- requires (X, K), kc (X, _), group_by (kc (X, _), [X], C = count), C &gt;= K. kc (X, Y) :- friend (X, Y), coming (Y). <p> The situation of both Liz and Jane waiting for each other to accept before accepting, results in this program not being modularly stratified. However, it is pointed out in <ref> [26] </ref> that this program has certain monotonic properties that that allow them to define and compute the intended model. 30 It can be argued that the above rules could also be expected to cover the situation where both Liz and Jane accept simultaneously. <p> Indeed, if our base relations are: frequires (liz,1), requires (jane,1)g, and ffriend (liz,jane), friend (jane,liz)g, then one of the "stable models" (as defined in [13]), is fcoming (liz), coming (jane), kc (liz,jane), kc (jane,liz)g. By adding strata-level arguments and a few other small changes to the solution given in <ref> [26] </ref>, we get the following EMS-program: coming (X, N) :- requires (X, 0). coming (X, N) :- requires (X, K), kc (X, _, N), group_by (kc (X, _, N), [X,N], C = count), C &gt;= K. kc (X, Y, s (N)) :- friend (X, Y), coming (Y, N).
Reference: [27] <author> Zoltan Somogyi, David Kemp, James Harland, and Kotagiri Ramamohanarao. </author> <title> Subsumption-free bottom-up evaluation of logic programs with partially instantiated data structures. </title> <type> Technical Report Technical Report 93/26, </type> <institution> Department of Computer Science, University of Mel-bourne, Australia, </institution> <year> 1993. </year> <booktitle> To appear in the proceedings of The Fourth International Conference on Extending Database Technology, </booktitle> <month> March, </month> <year> 1994. </year>
Reference-contexts: In addition to the program itself, the magic set transformation requires modes and sips. Here we describe the basic bf mode system; more precise systems of modes can be found in [21] and <ref> [27] </ref>. Definition 14 If p is an n-ary predicate, then a mode for p is a string ff of length n, each of whose elements is either f or b. If p is a predicate and ff is a mode for p, then p ff is an adorned predicate.
Reference: [28] <author> S. Sudarshan and R.. Ramakrishnan. </author> <title> Aggregation and relevance in deductive databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1991. </year>
Reference-contexts: This was a generalization of the work by Ganguly et al. [11], Mumick et at. [22], and Sudarshan and Ramakrishnan <ref> [28] </ref>. It appears that the techniques proposed in these papers should result in quite efficient evaluation. However, monotonicity, as it is defined in these papers, is not a syntactically recognizable property. Furthermore, no useful subclasses of the monotonic programs have been proposed that 5 could be recognized at compile time.
Reference: [29] <author> J.D. Ullman. </author> <title> Principles of database and knowledge-base systems, vol. I. </title> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Furthermore, unlike the general class of modularly stratified programs, recognizing these programs is a solvable problem. 2 Terminology Where possible, we usually use the standard terminology and definitions for logic programs and deductive databases similar to those found in Lloyd [19] and in Ullman <ref> [29, 30] </ref>.
Reference: [30] <author> J.D. Ullman. </author> <title> Principles of database and knowledge-base systems, vol. II: The new technologies. </title> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Furthermore, unlike the general class of modularly stratified programs, recognizing these programs is a solvable problem. 2 Terminology Where possible, we usually use the standard terminology and definitions for logic programs and deductive databases similar to those found in Lloyd [19] and in Ullman <ref> [29, 30] </ref>. <p> Now suppose we wish to know the shortest distance between any two nodes in the graph. This problem belongs to the class of generalized transitive closure problems called closed semi-ring problems (cf. Ullman <ref> [30] </ref>). Quite efficient algorithms have been developed for these problems. It is shown in [13] that the closed semi-ring problems can be expressed as three line programs.
Reference: [31] <author> A. van Gelder, K. A. Ross, and J. S. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year> <title> A preliminary version of this paper appeared as "Unfounded sets and well-founded semantics of general logic programs", </title> <booktitle> in Proceedings of the Seventh ACM PODS Symposium on Principles of Database Systems, </booktitle> <pages> pages 221-230, </pages> <year> 1988. </year> <month> 46 </month>
Reference-contexts: The terminology and definitions used for aggregates are the same as those given in [13], which was, in turn, based on work done by others on the semantics of negation (cf. <ref> [31] </ref>), and aggregates (cf. [22]). 2.1 Common notation and terminology We use the following Prolog-like notation. * Constants are represented by using strings of letters starting with lower case letters. Numbers are also constants. <p> The perfect models of these reduced predicate-SCCs combine to give the well-founded model of the program | a type of model originally defined in a different manner for a much larger class of programs in <ref> [31] </ref>. For a program P , the well-founded model of P is denoted using W fl P . / Often we will consider programs whose IDB's have only one predicate-SCC (although our techniques are not restricted to such programs).
References-found: 31

