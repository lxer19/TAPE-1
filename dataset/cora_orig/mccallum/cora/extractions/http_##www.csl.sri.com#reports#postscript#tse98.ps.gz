URL: http://www.csl.sri.com/reports/postscript/tse98.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Title: Subtypes for Specifications: Predicate Subtyping in PVS  
Author: John Rushby Sam Owre N. Shankar 
Keyword: Formal methods, specification languages, type systems, subtypes, typechecking, consistency, PVS  
Note: IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. XX, NO. Y, MONTH 199X 1  
Abstract: A specification language used in the context of an effective theorem prover can provide novel features that enhance precision and expressiveness. In particular, type-checking for the language can exploit the services of the theorem prover. We describe a feature called "predicate subtyping" that uses this capability and illustrate its utility as mechanized in PVS. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> Papers by SRI authors are generally available from http://www. csl.sri.com/fm.html. </institution>
Reference: [1] <author> Luca Cardelli, </author> <title> "Type systems," </title> <booktitle> in Handbook of Computer Science and Engineering, chapter 103, </booktitle> <pages> pp. 2208-2236. </pages> <publisher> CRC Press, </publisher> <year> 1997. </year> <note> Available at http://www.research.digital.com/SRC. </note>
Reference-contexts: Subtypes of a different, "structural," kind are sometimes used in type systems for programming languages to account for issues arising in object-oriented programs <ref> [1] </ref>. In particular, a record type A that contains fields in addition to those of a record type B is regarded as a subtype of B. The intuition behind this kind of subtyping is rather different than the "subtypes as subsets" intuition.
Reference: [2] <author> Bertrand Russell, </author> <title> "Mathematical logic as based on the theory of types," in From Frege to Godel, </title> <editor> Jean van Heijenoort, </editor> <publisher> Ed., </publisher> <pages> pp. 150-182. </pages> <publisher> Harvard University Press, </publisher> <address> Cambridge, MA, </address> <year> 1967, </year> <note> First published 1908. </note>
Reference: [3] <author> F. P. Ramsey, </author> <booktitle> "The foundations of mathematics," in Philosophical Papers of F. </booktitle> <editor> P. Ramsey, D. H. Mellor, Ed., </editor> <volume> chapter 8, </volume> <pages> pp. 164-224. </pages> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1990, </year> <booktitle> Originally published in Proceedings of the London Mathematical Society, </booktitle> <volume> 25, </volume> <pages> pp. 338-384, </pages> <year> 1925. </year>
Reference: [4] <author> A. Church, </author> <title> "A formulation of the simple theory of types," </title> <journal> Journal of Symbolic Logic, </journal> <volume> vol. 5, </volume> <pages> pp. 56-68, </pages> <year> 1940. </year>
Reference: [5] <author> Sam Owre, John Rushby, and N. Shankar, </author> <title> "Integration in PVS: Tables, types, and model checking," in Tools and Algorithms for the Construction and Analysis of Systems (TACAS '97), </title> <editor> Ed Brinksma, Ed., </editor> <address> Enschede, The Netherlands, </address> <month> Apr. </month> <year> 1997, </year> <title> vol. </title> <booktitle> 1217 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 366-383, </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Another is consistency checking for tabular specifications <ref> [5] </ref>. 2 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. XX, NO. Y, MONTH 199X the set interpreting the first is a subset of that interpreting the second.
Reference: [6] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke, </author> <title> "Formal verification for fault-tolerant architectures: Pro-legomena to the design of PVS," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 21, no. 2, </volume> <pages> pp. 107-125, </pages> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: Predicate subtypes are fully supported as part of a specification logic by the Nuprl [9], ABEL [10], Raise [11], Veritas [12], and PVS <ref> [6] </ref> verification systems. Predicate subtypes arose independently in these systems (in PVS, they came from its predecessor, Ehdm, whence they were introduced from the ANNA notation [13] by Friedrich von Henke, who was involved in the design of both), and there are differences in their uses and mechanization. <p> This function on integers is given by subp (i; j) = if i = j then 0 else subp (i; j + 1) + 1 endif and is undefined if i &lt; j (when i j; subp (i; j) = i j). As described in an earlier paper <ref> [6, Section III] </ref>, this challenge is easily handled in PVS using dependent predicate subtyping to require that the second argument is no greater than the first.
Reference: [7] <author> Piotr Rudnicki, </author> <title> "An overview of the MIZAR project," </title> <booktitle> in Proceedings of the 1992 Workshop on Types for Proofs and Programs, </booktitle> <address> B-astad, Sweden, </address> <month> June </month> <year> 1992, </year> <pages> pp. 311-330, </pages> <note> Available at http://web.cs.ualberta.ca/~piotr/Mizar/MizarOverview.ps. 12 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. XX, NO. Y, MONTH 199X </note>
Reference-contexts: 1 Another is consistency checking for tabular specifications [5]. 2 IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. XX, NO. Y, MONTH 199X the set interpreting the first is a subset of that interpreting the second. In this treatment (found, for example, in Mizar <ref> [7] </ref>) the natural numbers are a subtype of the integers, but the subtyping relation does not characterize those integers that are natural numbers. Predicate subtypes provide such a tightly bound characterization by associating a predicate or property with the subtype.
Reference: [8] <author> Cliff B. Jones, </author> <title> Systematic Software Development Using VDM, </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> Hemel Hempstead, UK, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: Similar ideas are also seen in formalized specification notations where, for example, the datatype invariants of VDM <ref> [8, Chapter 5] </ref> have much in common with predicate subtypes. However, datatype invariants are part of VDM's mechanisms for specifying operations in terms of pre- and post-conditions on a state, rather than part of the type system for its logic.
Reference: [9] <author> R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleave-land, J. F. Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P. Panangaden, J. T. Sasaki, and S. F. Smith, </author> <title> Implementing Mathematics with the Nuprl Proof Development System, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: However, datatype invariants are part of VDM's mechanisms for specifying operations in terms of pre- and post-conditions on a state, rather than part of the type system for its logic. Predicate subtypes are fully supported as part of a specification logic by the Nuprl <ref> [9] </ref>, ABEL [10], Raise [11], Veritas [12], and PVS [6] verification systems.
Reference: [10] <author> Ole-Johan Dahl and Olaf Owe, </author> <title> "On the use of subtypes in ABEL (revised version)," </title> <type> Tech. Rep. 206, </type> <institution> Department of Informatics, University of Oslo, </institution> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: However, datatype invariants are part of VDM's mechanisms for specifying operations in terms of pre- and post-conditions on a state, rather than part of the type system for its logic. Predicate subtypes are fully supported as part of a specification logic by the Nuprl [9], ABEL <ref> [10] </ref>, Raise [11], Veritas [12], and PVS [6] verification systems.
Reference: [11] <editor> The RAISE Language Group, </editor> <booktitle> The RAISE Specification Language, BCS Practioner Series. Prentice-Hall International, </booktitle> <address> Hemel Hempstead, UK, </address> <year> 1992. </year>
Reference-contexts: However, datatype invariants are part of VDM's mechanisms for specifying operations in terms of pre- and post-conditions on a state, rather than part of the type system for its logic. Predicate subtypes are fully supported as part of a specification logic by the Nuprl [9], ABEL [10], Raise <ref> [11] </ref>, Veritas [12], and PVS [6] verification systems.
Reference: [12] <author> F. Keith Hanna, Neil Daeche, and Mark Longley, </author> <title> "Specification and verification using dependent types," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 16, no. 9, </volume> <pages> pp. 949-964, </pages> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: Predicate subtypes are fully supported as part of a specification logic by the Nuprl [9], ABEL [10], Raise [11], Veritas <ref> [12] </ref>, and PVS [6] verification systems.
Reference: [13] <author> David C. Luckham, Friedrich W. von Henke, Bernd Krieg-Bruckner, and Olaf Owe, ANNA: </author> <title> A Language for Annotating Ada Programs, </title> <booktitle> vol. 260 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Predicate subtypes are fully supported as part of a specification logic by the Nuprl [9], ABEL [10], Raise [11], Veritas [12], and PVS [6] verification systems. Predicate subtypes arose independently in these systems (in PVS, they came from its predecessor, Ehdm, whence they were introduced from the ANNA notation <ref> [13] </ref> by Friedrich von Henke, who was involved in the design of both), and there are differences in their uses and mechanization.
Reference: [14] <author> S. Owre, S. Rajan, J.M. Rushby, N. Shankar, and M.K. Sri-vas, "PVS: </author> <title> Combining specification, proof checking, and model checking," </title> <booktitle> In Alur and Henzinger [31], </booktitle> <pages> pp. 411-414. </pages>
Reference-contexts: PVS system includes an interactive theorem prover that can be customized with user-written "strategies" (similar to tactics and tacticals in LCF-style provers), and that provides rather powerful automation in the form of decision procedures (e.g., for ground equality and linear arithmetic over both integers and reals) integrated with a rewriter <ref> [14, 15] </ref>. As noted, some constructions involving predicate sub-types generate TCCs (proof obligations); these are not decidable in general as there are no constraints on the predicates used to induce subtypes.
Reference: [15] <author> John Rushby, </author> <title> "Automated deduction and formal methods," </title> <booktitle> In Alur and Henzinger [31], </booktitle> <pages> pp. 169-183. </pages>
Reference-contexts: PVS system includes an interactive theorem prover that can be customized with user-written "strategies" (similar to tactics and tacticals in LCF-style provers), and that provides rather powerful automation in the form of decision procedures (e.g., for ground equality and linear arithmetic over both integers and reals) integrated with a rewriter <ref> [14, 15] </ref>. As noted, some constructions involving predicate sub-types generate TCCs (proof obligations); these are not decidable in general as there are no constraints on the predicates used to induce subtypes.
Reference: [16] <author> David Cyrluk, Patrick Lincoln, and N. Shankar, </author> <title> "On Shostak's decision procedure for combinations of theories," in Automated Deduction|CADE-13, </title> <editor> M. A. McRobbie and J. K. Slaney, Eds., </editor> <address> New Brunswick, NJ, July/Aug. </address> <year> 1996, </year> <title> vol. </title> <booktitle> 1104 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pp. 463-477, </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: There are strong advantages in theorem proving from adopting the first approach: it allows use of congruence closure as a decision procedure for equality over uninterpreted function symbols, which is essential for effective automation <ref> [16] </ref>. On the other hand, there are functions, such as division, that seem inherently partial and cause difficulty to this approach.
Reference: [17] <author> H. Barringer, J. H. Cheng, and C. B. Jones, </author> <title> "A logic covering undefinedness in program proofs," </title> <journal> Acta Informatica, </journal> <volume> vol. 21, </volume> <pages> pp. 251-269, </pages> <year> 1984. </year>
Reference-contexts: One way out of the difficulty is introduce some artificial value for undefined terms such as x=0, but this is clumsy and has to be done carefully to avoid inconsistencies. Another approach introduces "undefined" as a truth value <ref> [17] </ref>; more sophisticated approaches use "free logics" in which quantifiers range only over defined terms (e.g., Beeson's logic of partial terms [18]; Parnas [19] and Farmer [20] have introduced logics similar to Beeson's 10 ). Both approaches have the disadvantage of using nonstandard logics, with some attendant difficulties.
Reference: [18] <author> Michael J. Beeson, </author> <title> Foundations of Constructive Mathematics, Ergebnisse der Mathematik und ihrer Grenzgebiete; 3. Folge Band 6. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Another approach introduces "undefined" as a truth value [17]; more sophisticated approaches use "free logics" in which quantifiers range only over defined terms (e.g., Beeson's logic of partial terms <ref> [18] </ref>; Parnas [19] and Farmer [20] have introduced logics similar to Beeson's 10 ). Both approaches have the disadvantage of using nonstandard logics, with some attendant difficulties.
Reference: [19] <author> David Lorge Parnas, </author> <title> "Predicate logic for software engineering," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 19, no. 9, </volume> <pages> pp. 856-862, </pages> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: Another approach introduces "undefined" as a truth value [17]; more sophisticated approaches use "free logics" in which quantifiers range only over defined terms (e.g., Beeson's logic of partial terms [18]; Parnas <ref> [19] </ref> and Farmer [20] have introduced logics similar to Beeson's 10 ). Both approaches have the disadvantage of using nonstandard logics, with some attendant difficulties.
Reference: [20] <author> William M. Farmer, </author> <title> "A partial functions version of Church's simple theory of types," </title> <journal> Journal of Symbolic Logic, </journal> <volume> vol. 55, no. 3, </volume> <pages> pp. 1269-1291, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Another approach introduces "undefined" as a truth value [17]; more sophisticated approaches use "free logics" in which quantifiers range only over defined terms (e.g., Beeson's logic of partial terms [18]; Parnas [19] and Farmer <ref> [20] </ref> have introduced logics similar to Beeson's 10 ). Both approaches have the disadvantage of using nonstandard logics, with some attendant difficulties.
Reference: [21] <author> William M. Farmer, Joshua D. Guttman, and F. Javier Thayer, "IMPS: </author> <title> An interactive mathematical proof system," </title> <journal> Journal of Automated Reasoning, </journal> <volume> vol. 11, no. 2, </volume> <pages> pp. 213-248, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: true; if-then-else is treated as two implications, and the rules for disjunctions P _ Q and conjunctions P ^ Q are similar to that for implication, except that for disjunctions Q must be shown well-formed under the assumption that P is 10 Farmer's logic is used in the IMPS system <ref> [21] </ref>. IMPS generates proof obligations to ensure definedness during proofs that are similar to PVS's TCCs.
Reference: [22] <author> Leslie Lamport and Lawrence C. Paulson, </author> <title> "Should your specification language be typed?," </title> <note> SRC Research Report 147, </note> <institution> Digital Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1997. </year> <note> Available at http://www.research.digital.com/SRC. </note>
Reference-contexts: Both approaches have the disadvantage of using nonstandard logics, with some attendant difficulties. These problems have led some to argue that the discipline of types can be too onerous in a specification language, and that untyped set theory is a better choice <ref> [22] </ref>. Predicate subtypes offer another approach. Many partial functions become total if their domains are specified with sufficient precision; applying a function outside its domain then becomes a type error, rather than something that has to be dealt with in the logic.
Reference: [23] <author> J. H. Cheng and C. B. Jones, </author> <title> "On the usability of logics which handle partial functions," </title> <booktitle> in Proceedings of the Third Refinement Workshop, </booktitle> <editor> Carroll Morgan and J. C. P. Woodcock, Eds. </editor> <year> 1990, </year> <pages> pp. 51-69, </pages> <publisher> Springer-Verlag Workshops in Computing. </publisher>
Reference-contexts: left-to-right order (which is sound, but conservative) causes PVS to generate the unprovable TCC (y-x) 6= 0 for the following, logically equivalent, reformulation. 14 test: THEOREM 8 (x, y:real): (x-y)/(y-x) = -1 _ x = y Another example of a partial function is the subp "challenge" from Cheng and Jones <ref> [23] </ref>. This function on integers is given by subp (i; j) = if i = j then 0 else subp (i; j + 1) + 1 endif and is undefined if i &lt; j (when i j; subp (i; j) = i j).
Reference: [24] <author> Savi Maharaj and Juan Bicarregui, </author> <title> "On the verification of VDM specification and refinement with PVS," </title> <booktitle> in 12th IEEE International Conference on Automated Software Engineering: ASE '97, </booktitle> <address> Incline Village, NV, Nov. 1997, </address> <publisher> IEEE Computer Society, </publisher> <pages> pp. 280-289. </pages>
Reference-contexts: All three are discharged automatically by the PVS decision procedures. The PVS formulation of subp is adequate for most purposes, but the following formula (from Maharaj and Bicar-regui <ref> [24] </ref>) reveals a limitation. 15 subp_lemma:FORMULA 8 i, j: nat: subp (i,j)= i-j _ subp (j,i)= j-i This formula is true in some treatments of partial functions, but generates false TCCs and is unacceptable to PVS.
Reference: [25] <author> Mark Saaltink, </author> <title> "The Z/EVES system," </title> <booktitle> in ZUM '97: The Z Formal Specification Notation; 10th International Conference of Z Users, </booktitle> <address> Reading, UK, </address> <month> Apr. </month> <year> 1997, </year> <title> vol. </title> <booktitle> 1212 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 72-85, </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: As another illustration of the latter, the "domain checking" for Z specifications provided by the Z/EVES system <ref> [25] </ref> has reportedly found errors in every Z specification examined in this way [26]. (Domain checking is similar to the use of predicate subtypes described in this section, but lacks the more general benefits of predicate subtyping.) VII.
Reference: [26] <author> Mark Saaltink, </author> <title> "Domain checking Z specifications," </title> <booktitle> in LFM' 97: Fourth NASA Langley Formal Methods Workshop, </booktitle> <editor> C. Michael Holloway and Kelly J. Hayhurst, Eds., </editor> <address> Hampton, VA, </address> <month> Sept. </month> <year> 1997, </year> <institution> NASA Langley Research Center, </institution> <note> NASA Conference Publication 3356, pp. 185-192. Available at http://atb-www.larc.nasa. gov/Lfm97/proceedings/. </note>
Reference-contexts: As another illustration of the latter, the "domain checking" for Z specifications provided by the Z/EVES system [25] has reportedly found errors in every Z specification examined in this way <ref> [26] </ref>. (Domain checking is similar to the use of predicate subtypes described in this section, but lacks the more general benefits of predicate subtyping.) VII. Dependent Types and Higher-Order Subtypes Predicate subtypes are useful for defining very refined type dependencies through dependent typing.
Reference: [27] <author> Steven M. </author> <title> German, "Automating proofs of the absence of common runtime errors," </title> <booktitle> in Proceedings, 5th ACM Symposium on the Principles of Programming Languages, </booktitle> <address> Tucson, AZ, </address> <month> Jan. </month> <year> 1978, </year> <pages> pp. 105-118. </pages>
Reference-contexts: X. Comparison with Subtypes in Programming Languages We know of no programming language that provides predicate subtypes, although the annotations provided for "extended static checking" (proving the absence of runtime errors such as array bound violations) <ref> [27, 28] </ref> have some similarities. Bringing the benefits of predicate subtyping RUSHBY, OWRE, SHANKAR: SUBTYPES FOR SPECIFICATIONS 11 to programming languages seems a worthwhile research endeavor that might generalize the benefits of extended static checking, while also providing information that could be useful to an optimizing compiler.
Reference: [28] <author> David L. Detlefs, </author> <title> "An overview of the Extended Static Checking system," </title> <booktitle> in First Workshop on Formal Methods in Software Practice (FMSP '96), </booktitle> <address> San Diego, CA, </address> <month> Jan. </month> <year> 1996, </year> <journal> Association for Computing Machinery, </journal> <pages> pp. 1-9. </pages>
Reference-contexts: X. Comparison with Subtypes in Programming Languages We know of no programming language that provides predicate subtypes, although the annotations provided for "extended static checking" (proving the absence of runtime errors such as array bound violations) <ref> [27, 28] </ref> have some similarities. Bringing the benefits of predicate subtyping RUSHBY, OWRE, SHANKAR: SUBTYPES FOR SPECIFICATIONS 11 to programming languages seems a worthwhile research endeavor that might generalize the benefits of extended static checking, while also providing information that could be useful to an optimizing compiler.
Reference: [29] <author> Val Breazu-Tannen, Thierry Coquand, Carl A. Gunter, and An-dre Scedrov, </author> <title> "Inheritance as implicit coercion," </title> <journal> Information and Computation, </journal> <volume> vol. 93, no. 1, </volume> <pages> pp. 172-221, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: We consider predicate sub-typing to be a basic element of a specification language| whereas structural subtyping and subtyping on function domains are largely syntactic conveniences that we prefer to handle by mechanisms such as conversions (see also <ref> [29] </ref>), rather than incorporate them into the type system. Nonetheless, combining some structural subtyping (e.g., for records) with predicate subtyping is an interesting topic for research. XI.
Reference: [30] <author> John Rushby, </author> <title> PVS Bibliography, </title> <address> Menlo Park, CA, </address> <note> Constantly updated; available at http://www.csl.sri.com/pvs-bib.html. </note>
Reference-contexts: There are many other circumstances where predicate subtypes provide benefit, and they have been used to excellent effect by several users of PVS (see, for example, the PVS bibliography <ref> [30] </ref> and the links from its Web page). We hope the examples we have presented do convey the value of predicate subtyping in specification languages, and suggest their possible utility in programming languages. Acknowledgments Paul Jackson provided many suggestions that have improved the presentation.

References-found: 31

