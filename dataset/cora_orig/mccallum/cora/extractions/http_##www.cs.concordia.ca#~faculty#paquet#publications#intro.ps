URL: http://www.cs.concordia.ca/~faculty/paquet/publications/intro.ps
Refering-URL: http://www.cs.concordia.ca/~faculty/paquet/publications/publications.html
Root-URL: http://www.cs.concordia.ca
Email: E-mail: John.Plaice@ift.ulaval.ca  E-mail: Joey.Paquet@ift.ulaval.ca  
Title: INTRODUCTION TO INTENSIONAL PROGRAMMING  
Author: JOHN PLAICE and JOEY PAQUET 
Address: Ste-Foy (Quebec), Canada G1K 7P4  
Affiliation: Departement d'informatique, Universite Laval  
Abstract: Using the World Wide Web as illustration, the basic concepts of intensional programming, in which the meaning of an expression depends on the context in which it is being evaluated, are presented. A historical overview of the Lucid language, past, present and future, is given, thereby allowing an intensional understanding of dataflow programming, multidimensional programming, functional programming and object-oriented programming. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> E. A. Ashcroft, A. A. Faustini, R. Jagannathan, and W. W. Wadge. </author> <title> Multidimensional Declarative Programming. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Here is how the program is executed: call.f (0,fib) n o n o = (call.f (1,fib) + call.f (2.fib)) n o n o n o = (call.f (1.fib) + call.f (2.fib)) n o = fib f 7! <ref> [1; 1; 0] </ref> + fib f 7! [2; 1; 0] + 1 = 3 To understand what is really going on, one needs to understand how the values of n are computed: n f 7! [0] = 3 n o n o n f 7! [2; 0] = n f 7! <p> Here is how the program is executed: call.f (0,fib) n o n o = (call.f (1,fib) + call.f (2.fib)) n o n o n o = (call.f (1.fib) + call.f (2.fib)) n o = fib f 7! [1; 1; 0] + fib f 7! <ref> [2; 1; 0] </ref> + 1 = 3 To understand what is really going on, one needs to understand how the values of n are computed: n f 7! [0] = 3 n o n o n f 7! [2; 0] = n f 7! [0] - 2 = 1 n o <p> 3 To understand what is really going on, one needs to understand how the values of n are computed: n f 7! [0] = 3 n o n o n f 7! [2; 0] = n f 7! [0] - 2 = 1 n o n o n f 7! <ref> [2; 1; 0] </ref> = n f 7! [1; 0] - 2 = 0 A similar translation can be effected for higher-order programs. A program of order n can be translated, in n steps and using n dimensions, to a program with no function calls. <p> on, one needs to understand how the values of n are computed: n f 7! [0] = 3 n o n o n f 7! [2; 0] = n f 7! [0] - 2 = 1 n o n o n f 7! [2; 1; 0] = n f 7! <ref> [1; 0] </ref> - 2 = 0 A similar translation can be effected for higher-order programs. A program of order n can be translated, in n steps and using n dimensions, to a program with no function calls.
Reference: 2. <author> David R. Dowty, Robert E. Wall, and Stanley Peters. </author> <title> Introduction to Mon-tague Semantics. </title> <address> D. </address> <publisher> Reidel, </publisher> <year> 1981. </year>
Reference-contexts: Here is how the program is executed: call.f (0,fib) n o n o = (call.f (1,fib) + call.f (2.fib)) n o n o n o = (call.f (1.fib) + call.f (2.fib)) n o = fib f 7! [1; 1; 0] + fib f 7! <ref> [2; 1; 0] </ref> + 1 = 3 To understand what is really going on, one needs to understand how the values of n are computed: n f 7! [0] = 3 n o n o n f 7! [2; 0] = n f 7! [0] - 2 = 1 n o <p> o = fib f 7! [1; 1; 0] + fib f 7! [2; 1; 0] + 1 = 3 To understand what is really going on, one needs to understand how the values of n are computed: n f 7! [0] = 3 n o n o n f 7! <ref> [2; 0] </ref> = n f 7! [0] - 2 = 1 n o n o n f 7! [2; 1; 0] = n f 7! [1; 0] - 2 = 0 A similar translation can be effected for higher-order programs. <p> 3 To understand what is really going on, one needs to understand how the values of n are computed: n f 7! [0] = 3 n o n o n f 7! [2; 0] = n f 7! [0] - 2 = 1 n o n o n f 7! <ref> [2; 1; 0] </ref> = n f 7! [1; 0] - 2 = 0 A similar translation can be effected for higher-order programs. A program of order n can be translated, in n steps and using n dimensions, to a program with no function calls.
Reference: 3. <author> Saul Kripke. </author> <title> Naming and Necessity. </title> <publisher> Harvard University Press, </publisher> <year> 1980. </year>
Reference: 4. <author> P. J. Landin. </author> <title> The next 700 programming languages. </title> <journal> Communications of the ACM, </journal> <volume> 9(3) </volume> <pages> 157-166, </pages> <year> 1966. </year>
Reference: 5. <author> Joey Paquet and John Plaice. </author> <title> The intensional relation. </title> <booktitle> In Proc. of the Eighth International Symposium on Languages for Intensional Programming. World Scientific, </booktitle> <year> 1995. </year>
Reference: 6. <author> John Plaice. </author> <title> Particle simulation with Lucid. </title> <booktitle> In Proc. of the Eighth International Symposium on Languages for Intensional Programming. World Scientific, </booktitle> <year> 1995. </year>
Reference: 7. <author> P. Rondogiannis and William Wadge. </author> <title> Extending the intensionalization algorithm to a broader class of higher-order programs. </title> <booktitle> In Proc. of the Eighth International Symposium on Languages for Intensional Programming. World Scientific, </booktitle> <year> 1995. </year>
Reference: 8. <author> R. D. Tennent. </author> <title> Semantics of Programming Languages. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1991. </year>
Reference: 9. <author> William Wadge. </author> <title> Possible WOOrlds. </title> <booktitle> In Proc. of the Eighth International Sym--posium on Languages for Intensional Programming. World Scientific, </booktitle> <year> 1995. </year>
Reference: 10. <author> William W. Wadge and Edward A. Ashcroft. </author> <title> Lucid, the Dataflow Programming Language. </title> <publisher> Academic Press, </publisher> <year> 1985. </year>
References-found: 10

