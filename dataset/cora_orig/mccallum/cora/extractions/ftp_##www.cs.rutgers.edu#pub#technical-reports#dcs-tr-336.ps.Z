URL: ftp://www.cs.rutgers.edu/pub/technical-reports/dcs-tr-336.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: fwlandi,raltucherg@scr.siemens.com  fryder,pstocks,xxzhangg@cs.rutgers.edu  
Title: A Schema for Interprocedural Modification Side-Effect Analysis With Pointer Aliasing  
Author: William A. Landi Barbara G. Ryder Philip A. Stocks Sean Zhang Rita Altucher 
Date: May 27, 1998  
Address: 755 College Rd. East Princeton, NJ 08540  New Brunswick, NJ 08903  
Affiliation: Siemens Corporate Research Inc  Department of Computer Science Rutgers University Hill Center, Busch Campus  
Abstract: The first interprocedural modification side-effects analysis (MOD C ) for C that obtains better than worst-case precision on programs with general-purpose pointer usage is presented with empirical results. 1 The analysis consists of an algorithm schema corresponding to a family of MOD C algorithms with two independent phases: one for determining pointer-induced aliases and a subsequent one for propagating interprocedural side effects. These MOD C algorithms are parameterized by the aliasing method used. The empirical results compare the performance of two dissimilar MOD C algorithms: MOD C (FSAlias) uses a flow-sensitive, calling-context-sensitive interprocedural alias analysis [LR92]; MOD C (FIAlias) uses a flow-insensitive, calling-context-insensitive alias analysis which is much faster, but less accurate [ZRL96]. These two algorithms were profiled on 45 programs ranging in size from 250 to 30,000 lines of C code, and the results demonstrate dramatically the possible cost-precision tradeoffs. This first comparative implementation of MOD C analyses offers insight into the differences between flow-/context-sensitive and flow-/context-insensitive analyses. The analysis cost versus precision tradeoffs in side-effect information obtained is reported. The results show surprisingly that the precision of flow-sensitive side-effect analysis is not always prohibitive and that the imprecision of flow-insensitive analysis is substantially better than worst-case estimates and can be sufficient for certain applications. On average MOD C (FSAlias) for procedures and calls is in the range of 20% more precise than MOD C (FIAlias); however, the performance was found to be at least an order of magnitude slower than MOD C (FIAlias). 
Abstract-found: 1
Intro-found: 1
Reference: [AG96] <author> D. Atkinson and W. Griswold. </author> <title> The design of whole-program analysis tools. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <pages> pages 16-27, </pages> <year> 1996. </year>
Reference: [All74] <author> F. E. Allen. </author> <title> Interprocedural data flow analysis. </title> <booktitle> In Proceedings of 1974 IFIP Congress, </booktitle> <pages> pages 398-402, </pages> <address> Amsterdam, Holland, 1974. </address> <publisher> Institute of Electrical and Electronics Engineers, Inc., North Holland Publishing Company. </publisher>
Reference-contexts: Table 3 in Appendix C shows the raw data from which these figures are constructed. 5 Related Work Interprocedural Side-Effects Analysis. Interprocedural modification side effects were first handled by Allen for acyclic call multigraphs in Fortran programs <ref> [All74, Spi71] </ref>. Later, Barth explored the use of relations to capture side effects in recursive programs [Bar78].
Reference: [And94] <author> L. O. Andersen. </author> <title> Program analysis and specialization for the C programming language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <year> 1994. </year> <note> Also available as DIKU report 94/19. </note>
Reference-contexts: Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases <ref> [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96] </ref>. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction Accurate compile-time calculation of possible interprocedural side effects is crucial for aggressive compiler optimization <ref> [ASU86] </ref>, practical dependence analysis in programs with procedure calls fl The research reported here was supported, in part, by Siemens Corporate Research and NSF grants CISE-CCR-9208632, CCR-9501761, GER-9023628. 1 This is a presentation of the algorithm schema for MOD C and describes new and extensive empirical results with two of the <p> Many algorithms use intraprocedural propagation of aliases through pointer-assignment statements in a manner conceptually similar to the single-level pointer aliasing algorithm in Chapter 10 of <ref> [ASU86] </ref> with extensions to handle multiple-level pointers. Intraprocedural algorithms can make worst-case assumptions about the effects of call sites and determine a "first-cut" alias solution. Most aliasing algorithms now in use do some form of interprocedural analysis. <p> This intraprocedural propagation of aliases through pointer-assignment statements is described by transfer functions associated with each node in a standard extension of <ref> [ASU86] </ref>. Aliases are associated with calling contexts, and this information is propagated over the flow graph. Parameter/argument bindings can create aliases as well.
Reference: [Ban79] <author> J. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> In Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: The latter applications need an efficient method to report program-point-specific side-effect information in the presence of pointers in order to handle modern languages such as C, C ++ , Fortran90 and Java; 2 this requires practical interprocedural side-effect analysis with pointers, something that previous techniques for FORTRAN cannot supply <ref> [Ban79, Bur90, Coo85, CK88, CK87] </ref>. In the past, it has been suggested that one could do intraprocedural analyses of C codes, by using worst-case estimates of variables which could possibly experience a side effect at a call site. <p> Interprocedural modification side effects were first handled by Allen for acyclic call multigraphs in Fortran programs [All74, Spi71]. Later, Barth explored the use of relations to capture side effects in recursive programs [Bar78]. Banning <ref> [Ban79] </ref> first accomplished the decomposition of the MOD problem for FORTRAN (and other languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow-insensitive calculations on the call multigraph: one for side effects and a separate one for aliases. 25 25 The interprocedural side-effects problem for Fortran
Reference: [Ban88] <author> Utpal Banerjee. </author> <title> Dependence Analysis for Supercomputing. </title> <publisher> Kluwer Academic Publishers, Norwell, </publisher> <address> MA, </address> <year> 1988. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 <ref> [Ban88, Pol88, Wol89] </ref>, data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88], interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [Bar78] <author> J. M. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <year> 1978. </year>
Reference-contexts: Alias analysis, like nearly all data-flow analyses, is precise up to symbolic execution <ref> [Bar78] </ref> meaning assuming the executability of all program branches. In programming languages such as C, explicit addressing operators render alias analysis more difficult than in Fortran, where aliases are introduced only through call-by-reference parameter passing. <p> In other words, any fixed location that can be modified by some execution is guaranteed to be in the computed solution. The equations in Section 3.1 produce a safe solution. A reverse-safe solution is one that is point-wise a subset of the precise solution. In <ref> [Bar78] </ref>, Barth defines the concept precise up to symbolic execution to mean precise assuming that all program branches are executable. Using this definition of safe it is possible to define reverse-safe up to symbolic execution. This is done by comparing the approximate solution to the precise-up-to-symbolic-execution solution. <p> Interprocedural modification side effects were first handled by Allen for acyclic call multigraphs in Fortran programs [All74, Spi71]. Later, Barth explored the use of relations to capture side effects in recursive programs <ref> [Bar78] </ref>.
Reference: [BCCH94] <author> Michael Burke, Paul Carini, Jong-Doek Choi, and Michael Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <booktitle> In Proceedings of the 7th International Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 234-250. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1994. </year>
Reference-contexts: representation which stores all aliases as pairs consisting of a location and the single-level pointer expression which points to it (e.g., &lt; flp; x &gt; means the dereferenced value of p is x); this representation requires a transitive closure step to obtain all pairs of aliases at a program point <ref> [CBC93, MLR + 93, BCCH94] </ref>. F SAlias, the flow-sensitive, context-sensitive alias approximation algorithm [LR92] uses an explicit representation of aliases as pairs of names possibly containing dereferences (e.g., h flflp,flq i). <p> Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases <ref> [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96] </ref>. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [BH93] <author> S. Bates and S. Horwitz. </author> <title> Incremental program testing using dependence graphs. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 384-396, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing <ref> [HS91, BH93, Ost90, Wey94] </ref>, incremental semantic change analysis of software [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88], interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [BR90] <author> M. Burke and B. G. Ryder. </author> <title> A critical analysis of incremental iterative data flow analysis algorithms. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(7), </volume> <month> July </month> <year> 1990. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software <ref> [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88] </ref>, interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [Bur90] <author> M. Burke. </author> <title> An interval-based approach to exhaustive and incremental interprocedural data flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 341-395, </pages> <month> July </month> <year> 1990. </year> <month> 38 </month>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software <ref> [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88] </ref>, interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96]. <p> The latter applications need an efficient method to report program-point-specific side-effect information in the presence of pointers in order to handle modern languages such as C, C ++ , Fortran90 and Java; 2 this requires practical interprocedural side-effect analysis with pointers, something that previous techniques for FORTRAN cannot supply <ref> [Ban79, Bur90, Coo85, CK88, CK87] </ref>. In the past, it has been suggested that one could do intraprocedural analyses of C codes, by using worst-case estimates of variables which could possibly experience a side effect at a call site. <p> Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition <ref> [Bur90] </ref>. All of this work targeted the programming model of Fortran, Pascal, and related languages with restricted pointer usage.
Reference: [Car88] <author> M. D. Carroll. </author> <title> A new pointer-removing program transformation. </title> <type> Unpublished manuscript, </type> <year> 1988. </year>
Reference-contexts: Since semantically dereference (*) and address (&) are effectively inverse operations 20 (&*r 0 *&r 0 r 0 ), in the above case r 0 will be unchanged. This transformation is essentially the inverse of refizing as developed in <ref> [Car88] </ref>; for programs with single-level pointers it is equivalent to the transformation in [Lan92a] (p.50). 20 In C, there is an exception: &*(&x) &x but *&(&x) is illegal.
Reference: [CBC93] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Choi et al. use the immediate past call site as their encoding of the calling context in their flow-sensitive aliasing algorithm <ref> [CBC93, MLR + 93] </ref>. They also describe an algorithm variant that uses alias sets of unrestricted size at the call site, called source alias sets, as additional call site encoding information. <p> RA is used in the description of the MOD C schema to represent some approximation of calling context. Figures 1 and 2 show that the reaching alias encoding of calling context is incomparable to using the last call site (i.e.,1CFA) as in <ref> [CBC93, MLR + 93] </ref>. 13 In these examples aliases created independently of calling context are labelled with call site ? and spurious aliases are underlined. <p> representation which stores all aliases as pairs consisting of a location and the single-level pointer expression which points to it (e.g., &lt; flp; x &gt; means the dereferenced value of p is x); this representation requires a transitive closure step to obtain all pairs of aliases at a program point <ref> [CBC93, MLR + 93, BCCH94] </ref>. F SAlias, the flow-sensitive, context-sensitive alias approximation algorithm [LR92] uses an explicit representation of aliases as pairs of names possibly containing dereferences (e.g., h flflp,flq i). <p> All of this work targeted the programming model of Fortran, Pascal, and related languages with restricted pointer usage. Choi, Burke, and Carini mention an interprocedural modification side-effects algorithm for languages with pointers based on their flow-sensitive pointer-aliasing analysis technique <ref> [CBC93, MLR + 93] </ref>; it is difficult to compare their work to this work, because they give no description of their algorithm and offer no implementation results. <p> Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases <ref> [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90] </ref>. Still other work concentrated on aliases in higher order functional languages [Deu90, NPD87]. 6 OBSERVATIONS The obvious conclusion of the empirical results is that flow-sensitive analysis yields significantly more precise solutions at far greater computation cost.
Reference: [CK84] <author> K. Cooper and K. Kennedy. </author> <title> Efficient computation of flow insensitive interprocedural summary information. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 247-258, </pages> <month> June </month> <year> 1984. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 19, No 6. </volume>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software <ref> [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88] </ref>, interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [CK87] <author> K. Cooper and K. Kennedy. </author> <title> Complexity of interprocedural side-effect analysis. </title> <institution> Computer Science Department Technical Report TR87-61, Rice University, </institution> <month> October </month> <year> 1987. </year>
Reference-contexts: The latter applications need an efficient method to report program-point-specific side-effect information in the presence of pointers in order to handle modern languages such as C, C ++ , Fortran90 and Java; 2 this requires practical interprocedural side-effect analysis with pointers, something that previous techniques for FORTRAN cannot supply <ref> [Ban79, Bur90, Coo85, CK88, CK87] </ref>. In the past, it has been suggested that one could do intraprocedural analyses of C codes, by using worst-case estimates of variables which could possibly experience a side effect at a call site. <p> RA 0 represents the calling context induced by call Q during data-flow propagation in P under calling context RA of P. The function b call Q , specific to call Q , maps names from the called procedure (Q) to the calling procedure (P ) according to scoping rules <ref> [CK87] </ref> and only returns fixed locations. <p> problem for FORTRAN (and other languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow-insensitive calculations on the call multigraph: one for side effects and a separate one for aliases. 25 25 The interprocedural side-effects problem for Fortran is flow insensitive. 34 Cooper and Kennedy <ref> [Coo85, CK88, CK87] </ref> further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [Bur90].
Reference: [CK88] <author> K. Cooper and K. Kennedy. </author> <title> Interprocedural side-effect analysis in linear time. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 57-66, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: The latter applications need an efficient method to report program-point-specific side-effect information in the presence of pointers in order to handle modern languages such as C, C ++ , Fortran90 and Java; 2 this requires practical interprocedural side-effect analysis with pointers, something that previous techniques for FORTRAN cannot supply <ref> [Ban79, Bur90, Coo85, CK88, CK87] </ref>. In the past, it has been suggested that one could do intraprocedural analyses of C codes, by using worst-case estimates of variables which could possibly experience a side effect at a call site. <p> problem for FORTRAN (and other languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow-insensitive calculations on the call multigraph: one for side effects and a separate one for aliases. 25 25 The interprocedural side-effects problem for Fortran is flow insensitive. 34 Cooper and Kennedy <ref> [Coo85, CK88, CK87] </ref> further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [Bur90].
Reference: [Coo85] <author> K. Cooper. </author> <title> Analyzing aliases of reference formal parameters. </title> <booktitle> In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-290, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: The latter applications need an efficient method to report program-point-specific side-effect information in the presence of pointers in order to handle modern languages such as C, C ++ , Fortran90 and Java; 2 this requires practical interprocedural side-effect analysis with pointers, something that previous techniques for FORTRAN cannot supply <ref> [Ban79, Bur90, Coo85, CK88, CK87] </ref>. In the past, it has been suggested that one could do intraprocedural analyses of C codes, by using worst-case estimates of variables which could possibly experience a side effect at a call site. <p> problem for FORTRAN (and other languages where aliasing is imposed only by call-by-reference parameter passing); he separated out two flow-insensitive calculations on the call multigraph: one for side effects and a separate one for aliases. 25 25 The interprocedural side-effects problem for Fortran is flow insensitive. 34 Cooper and Kennedy <ref> [Coo85, CK88, CK87] </ref> further decomposed the problem into side effects on global variables and side effects accomplished through parameter passing. Burke showed that these two subproblems on globals and formals can be solved by a similar problem decomposition [Bur90].
Reference: [Coo89] <author> B. G. Cooper. </author> <title> Ambitious Data Flow Analysis of Procedural Programs. </title> <type> Master's thesis, </type> <institution> University of Minnesota, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases <ref> [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90] </ref>. Still other work concentrated on aliases in higher order functional languages [Deu90, NPD87]. 6 OBSERVATIONS The obvious conclusion of the empirical results is that flow-sensitive analysis yields significantly more precise solutions at far greater computation cost.
Reference: [Cou86] <author> D. S. Coutant. </author> <title> Retargetable high-level alias analysis. </title> <booktitle> In Conference Record of the Thirteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 110-118, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases <ref> [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96] </ref>. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [CWZ90] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 25, No 6. </volume>
Reference-contexts: Others have suggested less naive ways of restricting the name space while obtaining more accurate aliases of heap-stored variables <ref> [CWZ90, Deu94, HPR89, LH88, HN90, HHN92, SRW96] </ref>. The F SAlias algorithm uses Jones and Muchnick's original k-limiting definition for recursive data structures combined with a naming scheme that identifies a dynamically created fixed location by its creation site. <p> This paper discusses a schema for finding side effects in C codes that is parameterized by the type of pointer aliasing technique used. 26 Recently, there have been many investigations of pointer aliasing algorithms which vary in cost and precision. Several concentrate on aliases in heap storage <ref> [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96] </ref>. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [Deu90] <author> A. Deutsch. </author> <title> On determining lifetime and aliasing of dynamically allocated data in higher-order functional specifications. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 157-168, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90]. Still other work concentrated on aliases in higher order functional languages <ref> [Deu90, NPD87] </ref>. 6 OBSERVATIONS The obvious conclusion of the empirical results is that flow-sensitive analysis yields significantly more precise solutions at far greater computation cost.
Reference: [Deu94] <author> A. Deutsch. </author> <title> Interprocedural may alias for pointers: Beyond k-limiting. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Others have suggested less naive ways of restricting the name space while obtaining more accurate aliases of heap-stored variables <ref> [CWZ90, Deu94, HPR89, LH88, HN90, HHN92, SRW96] </ref>. The F SAlias algorithm uses Jones and Muchnick's original k-limiting definition for recursive data structures combined with a naming scheme that identifies a dynamically created fixed location by its creation site. <p> This paper discusses a schema for finding side effects in C codes that is parameterized by the type of pointer aliasing technique used. 26 Recently, there have been many investigations of pointer aliasing algorithms which vary in cost and precision. Several concentrate on aliases in heap storage <ref> [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96] </ref>. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [DGS95] <author> Evelyn Duesterwald, Rajiv Gupta, and Mary Lou Soffa. </author> <title> Demand-driven computation of interprocedural data flow. </title> <booktitle> In Conference Record of the Twenty-second Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: This is often used as an empirical test of the precision of the alias solution obtained. Related Analyses Related interprocedural analyses include compile-time interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96], interprocedural def-use associations [PLR94, HS94, GH98] and, and demand analyses <ref> [HRS95, DGS95] </ref>. Slicing determines the data and control dependent parts of a program which correspond to a particular computation. Def-use associations trace value flow on static paths in a program; they are useful for various machine-independent optimizations and data-flow testing methods.
Reference: [EGH94] <author> M. Emami, R. Ghiya, and L. J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-257, </pages> <month> June </month> <year> 1994. </year> <note> Published as SIGPLAN Notices, 29 (6). </note>
Reference-contexts: This is close to the approach used in the points-to algorithm developed at McGill University, where every procedure activation is analyzed separately <ref> [HN90, EGH94] </ref>; optimizations to reduce computation by reusing the results for similar calling contexts were suggested by Emami [Ema93], and have been subsequently developed by Wilson and Lam [WL95] for points-to analysis and Ghiya and Hendren for connection analysis [GH96]. 9 Jones and Muchnick [JM82b] describe the use of an abstraction <p> Some algorithms distinguish the independent fields of a structure (e.g., F SAlias, F I Alias, <ref> [EGH94, Ste96] </ref>) while others do not (e.g., [SH97b, Ste95]). An added complication is presented by non-visible variables. <p> The non-visibles are local variables of procedures live at the call site (or in an earlier invocation of the current procedure) which are accessible through an alias, although not visible directly in the current scope. Possible side effects to these variables must be accounted for <ref> [LR92, LRZ93, EGH94] </ref>. 2.3 Program Representation A program is represented by a common directed graph structure, an ICFG or interprocedural control flow graph. <p> Aliases are either represented explicitly as pairs of names or implicitly embedded in a points-to relation. 15 Hendren et al. represent aliases as a set of simultaneous points-to relations at a particular program point <ref> [HN90, EGH94] </ref> (e.g., &lt; x; y &gt; means x points to the variable y). <p> in terms of the resulting 14 The MOD C schema would be largely unchanged for these languages although the alias phase would probably be more efficient by being specialized to their simpler pointer usages. 15 Differences between points-to analysis notation and the explicit pointer alias representation were also discussed in <ref> [EGH94] </ref>. accuracy they exhibit as illustrated in Figure 3. For the example in Figure 3 (a), an algorithm using transitive reduction will result in the h flx,z i alias replacing incoming alias h flx,y i at statement S3; thus no aliases involving y will be reported at S4. <p> This paper discusses a schema for finding side effects in C codes that is parameterized by the type of pointer aliasing technique used. 26 Recently, there have been many investigations of pointer aliasing algorithms which vary in cost and precision. Several concentrate on aliases in heap storage <ref> [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96] </ref>. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90]. <p> Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases <ref> [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90] </ref>. Still other work concentrated on aliases in higher order functional languages [Deu90, NPD87]. 6 OBSERVATIONS The obvious conclusion of the empirical results is that flow-sensitive analysis yields significantly more precise solutions at far greater computation cost.
Reference: [Ema93] <author> Maryam Emami. </author> <title> A practical interprocedural alias analysis for an optimizing/parallelizing C compiler. </title> <type> Master's thesis, </type> <institution> McGill University, Montreal, Canada, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: This is close to the approach used in the points-to algorithm developed at McGill University, where every procedure activation is analyzed separately [HN90, EGH94]; optimizations to reduce computation by reusing the results for similar calling contexts were suggested by Emami <ref> [Ema93] </ref>, and have been subsequently developed by Wilson and Lam [WL95] for points-to analysis and Ghiya and Hendren for connection analysis [GH96]. 9 Jones and Muchnick [JM82b] describe the use of an abstraction of the calling context at a dynamic creation site for a variable; the precision of this abstraction plus
Reference: [GH96] <author> R. Ghiya and L. Hendren. </author> <title> Connection analysis: A practical interpreocdural heap analysis for c. </title> <journal> International Journal of Parallel Programming, </journal> <year> 1996. </year>
Reference-contexts: developed at McGill University, where every procedure activation is analyzed separately [HN90, EGH94]; optimizations to reduce computation by reusing the results for similar calling contexts were suggested by Emami [Ema93], and have been subsequently developed by Wilson and Lam [WL95] for points-to analysis and Ghiya and Hendren for connection analysis <ref> [GH96] </ref>. 9 Jones and Muchnick [JM82b] describe the use of an abstraction of the calling context at a dynamic creation site for a variable; the precision of this abstraction plus the approximation lattice for the data-flow problem in question determine the precision of the solution.
Reference: [GH98] <author> R. Ghiya and L. Hendren. </author> <title> Putting pointer analysis to work. </title> <booktitle> In Conference Record of the Twenty-fifth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 121-133, </pages> <year> 1998. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88], interprocedural def-use relations <ref> [PLR94, HS94, GH98] </ref> and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96]. Many of these key applications in parallel and sequential programming environments need interprocedural def-use information which can be approximated using side-effect information. <p> This is often used as an empirical test of the precision of the alias solution obtained. Related Analyses Related interprocedural analyses include compile-time interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96], interprocedural def-use associations <ref> [PLR94, HS94, GH98] </ref> and, and demand analyses [HRS95, DGS95]. Slicing determines the data and control dependent parts of a program which correspond to a particular computation. Def-use associations trace value flow on static paths in a program; they are useful for various machine-independent optimizations and data-flow testing methods.
Reference: [GL91] <author> K. Gallagher and J Lyle. </author> <title> Using program slices in software maintenance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(8) </volume> <pages> 751-761, </pages> <month> August </month> <year> 1991. </year>
Reference: [GS96] <author> R. Gupta and M. L. Soffa. </author> <title> Hybrid slicing: An approach for refining static slices using dynamic information. </title> <booktitle> In Proceedings of Third ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 29-40, </pages> <year> 1996. </year>
Reference: [Gua88] <author> C. A. Guarna. </author> <title> A technique for analyzing pointer and structure references in parallel restructuring compilers. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <pages> pages 212-220, </pages> <year> 1988. </year>
Reference-contexts: Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases <ref> [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96] </ref>. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [HA90] <author> W. L. Harrison III and Z. Ammarguellat. </author> <title> Parcel and Miprac: parallelizers for symbolic and numeric programs. </title> <booktitle> In Proceedings of International Workshop on Compilers for Parallel Computers, </booktitle> <pages> pages 329-346. </pages> <institution> Ecole des Mines de Paris - CAI, UPMC Laboratoire MASI, </institution> <month> December </month> <year> 1990. </year> <institution> Paris, France. </institution> <month> 39 </month>
Reference-contexts: Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases <ref> [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90] </ref>. Still other work concentrated on aliases in higher order functional languages [Deu90, NPD87]. 6 OBSERVATIONS The obvious conclusion of the empirical results is that flow-sensitive analysis yields significantly more precise solutions at far greater computation cost.
Reference: [HHN92] <author> L. Hendren, J. Hummel, and A. Nicolau. </author> <title> Abstractions for recursive pointer data structures: Improving analysis and transformations of imperative languages. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 249-260, </pages> <month> June </month> <year> 1992. </year> <journal> SIGPLAN Notices, </journal> <volume> volume 27, number 6. </volume>
Reference-contexts: Others have suggested less naive ways of restricting the name space while obtaining more accurate aliases of heap-stored variables <ref> [CWZ90, Deu94, HPR89, LH88, HN90, HHN92, SRW96] </ref>. The F SAlias algorithm uses Jones and Muchnick's original k-limiting definition for recursive data structures combined with a naming scheme that identifies a dynamically created fixed location by its creation site.
Reference: [HN90] <author> L. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <booktitle> IEEE Transaction on Parallel and Distributed Systems, </booktitle> <year> 1990. </year>
Reference-contexts: This is close to the approach used in the points-to algorithm developed at McGill University, where every procedure activation is analyzed separately <ref> [HN90, EGH94] </ref>; optimizations to reduce computation by reusing the results for similar calling contexts were suggested by Emami [Ema93], and have been subsequently developed by Wilson and Lam [WL95] for points-to analysis and Ghiya and Hendren for connection analysis [GH96]. 9 Jones and Muchnick [JM82b] describe the use of an abstraction <p> Others have suggested less naive ways of restricting the name space while obtaining more accurate aliases of heap-stored variables <ref> [CWZ90, Deu94, HPR89, LH88, HN90, HHN92, SRW96] </ref>. The F SAlias algorithm uses Jones and Muchnick's original k-limiting definition for recursive data structures combined with a naming scheme that identifies a dynamically created fixed location by its creation site. <p> Aliases are either represented explicitly as pairs of names or implicitly embedded in a points-to relation. 15 Hendren et al. represent aliases as a set of simultaneous points-to relations at a particular program point <ref> [HN90, EGH94] </ref> (e.g., &lt; x; y &gt; means x points to the variable y). <p> This paper discusses a schema for finding side effects in C codes that is parameterized by the type of pointer aliasing technique used. 26 Recently, there have been many investigations of pointer aliasing algorithms which vary in cost and precision. Several concentrate on aliases in heap storage <ref> [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96] </ref>. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 28-40, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Others have suggested less naive ways of restricting the name space while obtaining more accurate aliases of heap-stored variables <ref> [CWZ90, Deu94, HPR89, LH88, HN90, HHN92, SRW96] </ref>. The F SAlias algorithm uses Jones and Muchnick's original k-limiting definition for recursive data structures combined with a naming scheme that identifies a dynamically created fixed location by its creation site. <p> This paper discusses a schema for finding side effects in C codes that is parameterized by the type of pointer aliasing technique used. 26 Recently, there have been many investigations of pointer aliasing algorithms which vary in cost and precision. Several concentrate on aliases in heap storage <ref> [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96] </ref>. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [HRB90] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1), </volume> <month> January </month> <year> 1990. </year>
Reference: [HRS95] <author> S. Horwitz, T. Reps, and M. Sagiv. </author> <title> Demand interprocedural dataflow analysis. </title> <booktitle> In Proceedings of the Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 104-115, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: This is often used as an empirical test of the precision of the alias solution obtained. Related Analyses Related interprocedural analyses include compile-time interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96], interprocedural def-use associations [PLR94, HS94, GH98] and, and demand analyses <ref> [HRS95, DGS95] </ref>. Slicing determines the data and control dependent parts of a program which correspond to a particular computation. Def-use associations trace value flow on static paths in a program; they are useful for various machine-independent optimizations and data-flow testing methods.
Reference: [HS91] <author> M. J. Harrold and M. L. Soffa. </author> <title> Selecting and using data for integration testing. </title> <journal> IEEE Software, </journal> <volume> 8(2) </volume> <pages> 58-65, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing <ref> [HS91, BH93, Ost90, Wey94] </ref>, incremental semantic change analysis of software [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88], interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [HS94] <author> M. J. Harrold and M. L. Soffa. </author> <title> Efficient computation of interprocedural definition-use chains. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(2) </volume> <pages> 175-204, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88], interprocedural def-use relations <ref> [PLR94, HS94, GH98] </ref> and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96]. Many of these key applications in parallel and sequential programming environments need interprocedural def-use information which can be approximated using side-effect information. <p> This is often used as an empirical test of the precision of the alias solution obtained. Related Analyses Related interprocedural analyses include compile-time interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96], interprocedural def-use associations <ref> [PLR94, HS94, GH98] </ref> and, and demand analyses [HRS95, DGS95]. Slicing determines the data and control dependent parts of a program which correspond to a particular computation. Def-use associations trace value flow on static paths in a program; they are useful for various machine-independent optimizations and data-flow testing methods.
Reference: [JM82a] <author> N. D. Jones and S. Muchnick. </author> <title> Flow analysis and optimization of lisp-like structures. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice Hall, </publisher> <year> 1982. </year>
Reference-contexts: Therefore, while two fixed locations created at the same allocation site are not distinguishable, those created at different sites are. All data-flow algorithms must deal with the a priori unbounded nature of recursive data structures. Many follow the approach of Jones and Muchnick <ref> [JM82a] </ref> which limits the set of possible names obtainable by following links in a recursive data structure by truncating them to contain no more than k pointer dereferences, a process known as k-limiting. <p> This paper discusses a schema for finding side effects in C codes that is parameterized by the type of pointer aliasing technique used. 26 Recently, there have been many investigations of pointer aliasing algorithms which vary in cost and precision. Several concentrate on aliases in heap storage <ref> [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96] </ref>. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [JM82b] <author> N. D. Jones and S. S. Muchnick. </author> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: For interprocedural data-flow analysis, not all paths in the usual graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it <ref> [JM82b, LR92, RHS95, SP81] </ref>. <p> every procedure activation is analyzed separately [HN90, EGH94]; optimizations to reduce computation by reusing the results for similar calling contexts were suggested by Emami [Ema93], and have been subsequently developed by Wilson and Lam [WL95] for points-to analysis and Ghiya and Hendren for connection analysis [GH96]. 9 Jones and Muchnick <ref> [JM82b] </ref> describe the use of an abstraction of the calling context at a dynamic creation site for a variable; the precision of this abstraction plus the approximation lattice for the data-flow problem in question determine the precision of the solution.
Reference: [Lan92a] <author> W. Landi. </author> <title> Interprocedural Aliasing in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> January </month> <year> 1992. </year> <month> LCSR-TR-174. </month>
Reference-contexts: This transformation is essentially the inverse of refizing as developed in [Car88]; for programs with single-level pointers it is equivalent to the transformation in <ref> [Lan92a] </ref> (p.50). 20 In C, there is an exception: &*(&x) &x but *&(&x) is illegal.
Reference: [Lan92b] <author> W. Landi. </author> <title> Undecidability of static analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(4) </volume> <pages> 323-337, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: S3: p = &q; else S4: q = &y; S1: if () else S3: r = &s; S5: ***p = (a) Transitive reduction more precise (b) Explicit representation more precise (c) Both imprecise Since the basic problem of determining pointer-induced aliases is intractable for programs with multiple levels of indirection <ref> [Lan92b, Ram94] </ref>, practical pointer-aliasing algorithms are approximate. Many algorithms use intraprocedural propagation of aliases through pointer-assignment statements in a manner conceptually similar to the single-level pointer aliasing algorithm in Chapter 10 of [ASU86] with extensions to handle multiple-level pointers.
Reference: [LH88] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <month> July </month> <year> 1988. </year> <journal> SIGPLAN NOTICES, </journal> <volume> Vol. 23, No. </volume> <pages> 7. </pages>
Reference-contexts: Others have suggested less naive ways of restricting the name space while obtaining more accurate aliases of heap-stored variables <ref> [CWZ90, Deu94, HPR89, LH88, HN90, HHN92, SRW96] </ref>. The F SAlias algorithm uses Jones and Muchnick's original k-limiting definition for recursive data structures combined with a naming scheme that identifies a dynamically created fixed location by its creation site. <p> This paper discusses a schema for finding side effects in C codes that is parameterized by the type of pointer aliasing technique used. 26 Recently, there have been many investigations of pointer aliasing algorithms which vary in cost and precision. Several concentrate on aliases in heap storage <ref> [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96] </ref>. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [LH96] <author> L. Larsen and M. J. Harrold. </author> <title> Slicing object-oriented software. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <pages> pages 495-505, </pages> <month> March </month> <year> 1996. </year>
Reference: [LR91] <author> W. Landi and B. G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The calling context approximation used in the MOD C schema is the same as that of the F SAlias algorithm <ref> [LR91, LR92] </ref>. The data-flow fact that x and y are aliased at program point n is represented by an unordered pair h x,y i at n. <p> corresponds to a source alias set to which a namespace mapping is applied that includes the parameter bindings as well as scoping transformations. 12 For aliasing in programs restricted to one level of dereferencing, the RA sets are of cardinality one and can be used to obtain a precise solution <ref> [LR91] </ref>. 13 For comparison purposes, these examples have been coded using the Landi-Ryder representation of aliases. 5 reaching alias last call site void main () f int flflp, flq; int flx, y; p = &q; [; hflp; qi] [?; hflp; qi] [; hflp; qi]; [; hflflp; flxi]; [; hflq; flxi]; [; <p> These relations between incoming and outgoing information are then memoized to avoid re-analysis. The underlying ideas of this analysis are related to notions expressed in the conditional analysis for aliasing due to single-level pointers <ref> [LR91] </ref>. Several solutions to MOD C with different flow-insensitive, context-insensitive points-to approximation algorithms have been obtained by this method, since using program-wide aliases yields an approximate problem for MOD C that yields the same side effects regardless of calling context [SH97a].
Reference: [LR92] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximation algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The empirical experiments reported involve two MOD C methods with different component aliasing algorithms. MOD C (FSAlias) uses the flow-sensitive, calling-context-sensitive approximation algorithm for pointer-induced aliasing, F SAlias <ref> [LR92] </ref>; MOD C (FIAlias) uses a flow-insensitive, calling-context-insensitive approximation algorithm for pointer-induced aliasing, F I Alias, which is similar to the algorithm described in [ZRL96]. 3 The MOD C schema is independent of the aliasing algorithm chosen and can use any aliasing algorithm, given a suitable interface. <p> For interprocedural data-flow analysis, not all paths in the usual graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it <ref> [JM82b, LR92, RHS95, SP81] </ref>. <p> The calling context approximation used in the MOD C schema is the same as that of the F SAlias algorithm <ref> [LR91, LR92] </ref>. The data-flow fact that x and y are aliased at program point n is represented by an unordered pair h x,y i at n. <p> n when p is invoked from a particular 8 We do not allow setjump or longjump in C programs analyzed. 9 Empirical data seems to suggest that such optimizations can dramatically reduce the number of contexts actually analyzed. 10 Reaching aliases were referred to by the term assumed aliases in <ref> [LR92] </ref>. 4 call site. When an alias exists independently of calling context any reaching alias is an appropriate context to use, but for convenience the special reaching alias is used. <p> The non-visibles are local variables of procedures live at the call site (or in an earlier invocation of the current procedure) which are accessible through an alias, although not visible directly in the current scope. Possible side effects to these variables must be accounted for <ref> [LR92, LRZ93, EGH94] </ref>. 2.3 Program Representation A program is represented by a common directed graph structure, an ICFG or interprocedural control flow graph. <p> F SAlias, the flow-sensitive, context-sensitive alias approximation algorithm <ref> [LR92] </ref> uses an explicit representation of aliases as pairs of names possibly containing dereferences (e.g., h flflp,flq i). Redundant aliases obtained through dereferences applied to both elements of an alias pair are not stored explicitly but inferred (e.g., h flp,flq i implies h flflp,flflq i). <p> These techniques allow exploration of the precision/cost tradeoffs of side-effects analysis and the scalability of these approaches applied to real programs. The following brief alias algorithm descriptions are explained on an intuitive level; definitive algorithm descriptions appear in <ref> [LR92, ZRL96, Zha98] </ref>. In F SAlias, an alias is created (or destroyed) during a pass through a called procedure, given an approximate calling context (i.e., a reaching alias), which propagates information over static execution paths. <p> Aliases associated with reaching alias are valid at every call site. The actual algorithm includes details of namespace mappings between the calling and called procedures <ref> [LR92] </ref>. The main approximation which can occur with this scheme is that sometimes two incoming aliases at a pointer assignment are needed to create an alias as a side effect of that statement (as in Figure 3 (c)). The kind of approximation in Figure 3 (a) is less frequent. <p> Intuitively speaking, the names in a program are partitioned to show which pairs of names can become aliased during execution. This is accomplished conceptually, by starting with every name as its own partition element and then using an union-find algorithm to join elements as possible aliasing relations 16 In <ref> [LR92] </ref>, we used may-holds to represent conditional aliasing information. <p> Q factors out all local variables of Q (including formal parameters of Q), maps global fixed locations (global variables and dynamic storage locations) to themselves, and maps non visibles in Q to their corresponding fixed locations in P , which are either locals of P or non visibles in P <ref> [LR92] </ref>. 19 It is possible with the MOD C schema to derive side effects at specific interesting statements, namely calls and assignments. <p> Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases <ref> [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90] </ref>. Still other work concentrated on aliases in higher order functional languages [Deu90, NPD87]. 6 OBSERVATIONS The obvious conclusion of the empirical results is that flow-sensitive analysis yields significantly more precise solutions at far greater computation cost.
Reference: [LRZ93] <author> W. Landi, B. G. Ryder, and S. Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in <ref> [LRZ93] </ref>. 1 [Ban88, Pol88, Wol89], data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88], interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96]. <p> The non-visibles are local variables of procedures live at the call site (or in an earlier invocation of the current procedure) which are accessible through an alias, although not visible directly in the current scope. Possible side effects to these variables must be accounted for <ref> [LR92, LRZ93, EGH94] </ref>. 2.3 Program Representation A program is represented by a common directed graph structure, an ICFG or interprocedural control flow graph.
Reference: [MLR + 93] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. Choi, M. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: A clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Choi et al. use the immediate past call site as their encoding of the calling context in their flow-sensitive aliasing algorithm <ref> [CBC93, MLR + 93] </ref>. They also describe an algorithm variant that uses alias sets of unrestricted size at the call site, called source alias sets, as additional call site encoding information. <p> RA is used in the description of the MOD C schema to represent some approximation of calling context. Figures 1 and 2 show that the reaching alias encoding of calling context is incomparable to using the last call site (i.e.,1CFA) as in <ref> [CBC93, MLR + 93] </ref>. 13 In these examples aliases created independently of calling context are labelled with call site ? and spurious aliases are underlined. <p> representation which stores all aliases as pairs consisting of a location and the single-level pointer expression which points to it (e.g., &lt; flp; x &gt; means the dereferenced value of p is x); this representation requires a transitive closure step to obtain all pairs of aliases at a program point <ref> [CBC93, MLR + 93, BCCH94] </ref>. F SAlias, the flow-sensitive, context-sensitive alias approximation algorithm [LR92] uses an explicit representation of aliases as pairs of names possibly containing dereferences (e.g., h flflp,flq i). <p> All of this work targeted the programming model of Fortran, Pascal, and related languages with restricted pointer usage. Choi, Burke, and Carini mention an interprocedural modification side-effects algorithm for languages with pointers based on their flow-sensitive pointer-aliasing analysis technique <ref> [CBC93, MLR + 93] </ref>; it is difficult to compare their work to this work, because they give no description of their algorithm and offer no implementation results. <p> Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases <ref> [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90] </ref>. Still other work concentrated on aliases in higher order functional languages [Deu90, NPD87]. 6 OBSERVATIONS The obvious conclusion of the empirical results is that flow-sensitive analysis yields significantly more precise solutions at far greater computation cost.
Reference: [MR90a] <author> T. J. Marlowe and B. G. Ryder. </author> <title> An efficient hybrid algorithm for incremental data flow analysis. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 184-196, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software <ref> [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88] </ref>, interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [MR90b] <author> T. J. Marlowe and B. G. Ryder. </author> <title> Properties of data flow frameworks: A unified model. </title> <journal> Acta Informatica, </journal> <volume> 28 </volume> <pages> 121-163, </pages> <year> 1990. </year>
Reference-contexts: to obtain good approximations to the possible aliasing induced by pointer usage in the program. 2.1 Realizable Interprocedural Paths Iterative data-flow analysis is a fixed point calculation for recursive equations defined on a graph representing a program, that safely approximates the meet over all paths solution of a data-flow problem <ref> [MR90b] </ref>. For interprocedural data-flow analysis, not all paths in the usual graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it [JM82b, LR92, RHS95, SP81]. <p> unrealizable and can never happen in an actual execution. 8 A fundamental problem of interprocedural analysis is how to restrict the propagation of data-flow information to realizable paths, especially when the data-flow functions are monotone rather than distributive so that the fixed point solution need not be the meet-over-all-paths solution <ref> [MR90b] </ref>. There are many methods proposed for distinguishing calling contexts (i.e., the state of the call stack) in data-flow algorithms.
Reference: [NPD87] <author> A. Neirynck, P. Panangaden, and A. Demers. </author> <title> Computation of aliases and support sets. </title> <booktitle> In Conference Record of the Fourteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 274-283, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90]. Still other work concentrated on aliases in higher order functional languages <ref> [Deu90, NPD87] </ref>. 6 OBSERVATIONS The obvious conclusion of the empirical results is that flow-sensitive analysis yields significantly more precise solutions at far greater computation cost.
Reference: [OO84] <author> K. J. Ottenstein and L. M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference: [Ost90] <author> Thomas J. </author> <title> Ostrand. Data-flow testing with pointers and function calls. </title> <booktitle> In Proceedings of the Pacific Northwest Software Quality Conference, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing <ref> [HS91, BH93, Ost90, Wey94] </ref>, incremental semantic change analysis of software [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88], interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [PLR94] <author> H. D. Pande, W. Landi, and B. G. Ryder. </author> <title> Interprocedural def-use associations for C systems with single level pointers. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(5) </volume> <pages> 385-403, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88], interprocedural def-use relations <ref> [PLR94, HS94, GH98] </ref> and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96]. Many of these key applications in parallel and sequential programming environments need interprocedural def-use information which can be approximated using side-effect information. <p> This is often used as an empirical test of the precision of the alias solution obtained. Related Analyses Related interprocedural analyses include compile-time interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96], interprocedural def-use associations <ref> [PLR94, HS94, GH98] </ref> and, and demand analyses [HRS95, DGS95]. Slicing determines the data and control dependent parts of a program which correspond to a particular computation. Def-use associations trace value flow on static paths in a program; they are useful for various machine-independent optimizations and data-flow testing methods.
Reference: [Pol88] <author> C. D. Polychronopolous. </author> <title> Parallel Programming and Compilers. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1988. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 <ref> [Ban88, Pol88, Wol89] </ref>, data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88], interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [PS89] <author> L. Pollock and M. Soffa. </author> <title> An incremental version of iterative data flow analysis. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(12), </volume> <month> December </month> <year> 1989. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software <ref> [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88] </ref>, interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [Ram94] <author> G. Ramalingam. </author> <title> The undecidability of aliasing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1467-1471, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: S3: p = &q; else S4: q = &y; S1: if () else S3: r = &s; S5: ***p = (a) Transitive reduction more precise (b) Explicit representation more precise (c) Both imprecise Since the basic problem of determining pointer-induced aliases is intractable for programs with multiple levels of indirection <ref> [Lan92b, Ram94] </ref>, practical pointer-aliasing algorithms are approximate. Many algorithms use intraprocedural propagation of aliases through pointer-assignment statements in a manner conceptually similar to the single-level pointer aliasing algorithm in Chapter 10 of [ASU86] with extensions to handle multiple-level pointers.
Reference: [RHS95] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In Conference Record of the Twenty-second Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: For interprocedural data-flow analysis, not all paths in the usual graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it <ref> [JM82b, LR92, RHS95, SP81] </ref>. <p> Interprocedural distributive finite subset problems can be solved using a graph reachability technique on an "exploded" call graph of the program <ref> [RHS95] </ref>. Capture of calling context is not an issue here since the problems being solved are of a form such that reachability in each procedure can be analyzed once for each parameter, regardless of calling context.
Reference: [RM88] <author> C. Ruggieri and T. Murtagh. </author> <title> Lifetime analysis of dynamically allocated objects. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-293, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Fixed locations are either user-defined variables or heap storage creation site names/field accesses. For example in C syntax, x and x.f are fixed locations whereas flp and p-&gt;f are not. Each dynamically allocated fixed location is identified by the site that created it, a common approach first used in <ref> [RM88] </ref>. Therefore, while two fixed locations created at the same allocation site are not distinguishable, those created at different sites are. All data-flow algorithms must deal with the a priori unbounded nature of recursive data structures.
Reference: [RP88] <author> B. G. Ryder and M. C. Paull. </author> <title> Incremental data flow analysis algorithms. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(1) </volume> <pages> 1-50, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software <ref> [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88] </ref>, interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [RR95] <author> T. Reps and G. Rosay. </author> <title> Precise interprocedural chopping. </title> <booktitle> In Proceedings of the Third ACM SIGSOFT Symposium on Foundations of Software Engineeering, </booktitle> <pages> pages 41-52, </pages> <year> 1995. </year>
Reference: [Ruf95] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: However, there are no flow- and/or context-sensitive analyses performed and direct comparison with MOD C (FIAlias) is difficult, since only a flow- and context-insensitive M OD (P ) is defined with no per-statement side effects, and indirect side effects to structure fields and union members are not distinguished. Ruf <ref> [Ruf95] </ref> compared the effect of context sensitivity (or its lack) on a flow-sensitive points-to algorithm. Most of his reported data is with respect to the difference in precision of the points-to solution, with and without context information. <p> Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases <ref> [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90] </ref>. Still other work concentrated on aliases in higher order functional languages [Deu90, NPD87]. 6 OBSERVATIONS The obvious conclusion of the empirical results is that flow-sensitive analysis yields significantly more precise solutions at far greater computation cost.
Reference: [Ruf97] <author> E. Ruf. </author> <title> Partitioning data flow analysis using types. </title> <booktitle> In Conference Record of the Twenty-fourth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 15-26, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: Normalized differences at calls and for procedures are presented and discussed in Section 4. The empirical results show the utility of both analyses for specific applications and demonstrate the precision gains from sensitivity for certain data-flow information. Recent work in partitioning programs for analyses <ref> [ZRL98, ZRL96, Ruf97] </ref> yields hope that analyses of varying cost and precision can be applied to different parts of a program to obtain desired data-flow information at practical cost.
Reference: [Ryd83] <author> B. G. Ryder. </author> <title> Incremental data flow analysis. </title> <booktitle> In Conference Record of the Tenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 167-176, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software <ref> [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88] </ref>, interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [SFRW90] <author> S. Sagiv, N. Francez, M. Rodeh, and R. Wilhelm. </author> <title> A logic-based approach to data flow analysis. </title> <booktitle> In Proceedings of the Second International Workshop in Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 277-292, </pages> <month> August </month> <year> 1990. </year> <booktitle> Volume 456 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases <ref> [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90] </ref>. Still other work concentrated on aliases in higher order functional languages [Deu90, NPD87]. 6 OBSERVATIONS The obvious conclusion of the empirical results is that flow-sensitive analysis yields significantly more precise solutions at far greater computation cost.
Reference: [SH97a] <author> M. Shapiro and S. Horwitz. </author> <title> The effects of the precision of pointer analysis. </title> <booktitle> In Proceedings of the Fourth International Symposium on Static Analysis (SAS'97), </booktitle> <pages> pages 16-34, </pages> <month> September </month> <year> 1997. </year>
Reference-contexts: Another approach to side-effect analysis is to perform an interprocedural pointer aliasing algorithm and then identify all variables experiencing side effects at indirect stores through a pointer (i.e., at through-dereference statements) using the aliases found <ref> [SH97a, ZRL98, ZRL96] </ref>. This is often used as an empirical test of the precision of the alias solution obtained. <p> Several solutions to MOD C with different flow-insensitive, context-insensitive points-to approximation algorithms have been obtained by this method, since using program-wide aliases yields an approximate problem for MOD C that yields the same side effects regardless of calling context <ref> [SH97a] </ref>. This study shares the philosophy of the empirical results presented here, in that the effects of pointer aliasing on applications are reported.
Reference: [SH97b] <author> M. Shapiro and S. Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In Conference Record of the Twenty-fourth Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: Some algorithms distinguish the independent fields of a structure (e.g., F SAlias, F I Alias, [EGH94, Ste96]) while others do not (e.g., <ref> [SH97b, Ste95] </ref>). An added complication is presented by non-visible variables. The non-visibles are local variables of procedures live at the call site (or in an earlier invocation of the current procedure) which are accessible through an alias, although not visible directly in the current scope. <p> Casting and union types are handled similarly, by encoding the relationship between structure fields as offsets, as in [WL95, Ste96]. The F I Alias technique is similar to other independently-derived, flow- and context-insensitive algorithms <ref> [Ste95, SH97b] </ref>. 3 MOD C Schema The MOD C schema defines a family of algorithms which solve for modification side effects to fixed locations at program points, parameterized by the type of aliasing algorithm used. Side effects reported are differentiated by fixed-location type: global, local, dynamically-created, and non-visible. <p> Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases <ref> [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96] </ref>. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90]. <p> The intersection of the solutions generated by different, safe analyses for the same problem must also be safe, and may be closer to the precise solution. Recently, Shapiro and Horwitz used this idea with several flow- and context-insensitive points-to analysis algorithms <ref> [SH97b] </ref>. This approach needs more exploratory experimentation. The final topic is to discern more fully the kind of program construct and programming style that foils data-flow analysis. Perhaps the availability of precise, flow- and context-sensitive data-flow analysis would be sufficient motivation to change programming practice, language design and programmers' habits.
Reference: [Shi88] <author> O. Shivers. </author> <title> Control flow analysis in scheme. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 164-174, </pages> <month> Jun </month> <year> 1988. </year>
Reference-contexts: They also describe an algorithm variant that uses alias sets of unrestricted size at the call site, called source alias sets, as additional call site encoding information. Their use of the call site name is reminiscent of Shivers' control flow analyses (CFA) in higher order functional languages <ref> [Shi88] </ref> in which a suffix of the call stack contents is used to approximate calling context (e.g., 0CFA (no call sites distinguished), 1CFA (last call site), etc.). The calling context approximation used in the MOD C schema is the same as that of the F SAlias algorithm [LR91, LR92].
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189-234. </pages> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: For interprocedural data-flow analysis, not all paths in the usual graph representation correspond to real program executions. A realizable path is a path on which every procedure returns to the call site which invoked it <ref> [JM82b, LR92, RHS95, SP81] </ref>. <p> There are many methods proposed for distinguishing calling contexts (i.e., the state of the call stack) in data-flow algorithms. Sharir and Pnueli <ref> [SP81] </ref> advocate the use of a call-string list of open and not yet closed procedure activations to label data-flow information precisely with the calling context in which it was obtained.
Reference: [Spi71] <author> T. Spillman. </author> <title> Exposing side effects in a PL-I optimizing compiler. </title> <booktitle> In Proceedings of IFIPS Conference, </booktitle> <pages> pages TA-3-56:TA-3-62, </pages> <year> 1971. </year> <month> 41 </month>
Reference-contexts: Table 3 in Appendix C shows the raw data from which these figures are constructed. 5 Related Work Interprocedural Side-Effects Analysis. Interprocedural modification side effects were first handled by Allen for acyclic call multigraphs in Fortran programs <ref> [All74, Spi71] </ref>. Later, Barth explored the use of relations to capture side effects in recursive programs [Bar78].
Reference: [SRW96] <author> S. Sagiv, Thomas Reps, and Reinhard Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> In Conference Record of the Twenty-third Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 16-31, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Others have suggested less naive ways of restricting the name space while obtaining more accurate aliases of heap-stored variables <ref> [CWZ90, Deu94, HPR89, LH88, HN90, HHN92, SRW96] </ref>. The F SAlias algorithm uses Jones and Muchnick's original k-limiting definition for recursive data structures combined with a naming scheme that identifies a dynamically created fixed location by its creation site. <p> This paper discusses a schema for finding side effects in C codes that is parameterized by the type of pointer aliasing technique used. 26 Recently, there have been many investigations of pointer aliasing algorithms which vary in cost and precision. Several concentrate on aliases in heap storage <ref> [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96] </ref>. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [Ste95] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Conference Record of the Twenty-second Annual ACM SIGACT/SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <year> 1995. </year>
Reference-contexts: Some algorithms distinguish the independent fields of a structure (e.g., F SAlias, F I Alias, [EGH94, Ste96]) while others do not (e.g., <ref> [SH97b, Ste95] </ref>). An added complication is presented by non-visible variables. The non-visibles are local variables of procedures live at the call site (or in an earlier invocation of the current procedure) which are accessible through an alias, although not visible directly in the current scope. <p> Casting and union types are handled similarly, by encoding the relationship between structure fields as offsets, as in [WL95, Ste96]. The F I Alias technique is similar to other independently-derived, flow- and context-insensitive algorithms <ref> [Ste95, SH97b] </ref>. 3 MOD C Schema The MOD C schema defines a family of algorithms which solve for modification side effects to fixed locations at program points, parameterized by the type of aliasing algorithm used. Side effects reported are differentiated by fixed-location type: global, local, dynamically-created, and non-visible. <p> Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases <ref> [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96] </ref>. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [Ste96] <author> Bjarne Steensgaard. </author> <title> Points-to analysis by type inference of programs with structures and unions. </title> <booktitle> In Proceedings of the Sixth International Confernce on Compiler Construction, </booktitle> <pages> pages 136-150, </pages> <month> April </month> <year> 1996. </year> <note> Also available as LNCS 1060. </note>
Reference-contexts: Some algorithms distinguish the independent fields of a structure (e.g., F SAlias, F I Alias, <ref> [EGH94, Ste96] </ref>) while others do not (e.g., [SH97b, Ste95]). An added complication is presented by non-visible variables. <p> Casting and union types are handled similarly, by encoding the relationship between structure fields as offsets, as in <ref> [WL95, Ste96] </ref>.
Reference: [TAFM97] <author> P. Tonella, G. Antoniol, R. Fiutern, and E. Merlo. </author> <title> Flow-insensitive c ++ pointers and polymorphism analysis and its application to slicing. </title> <booktitle> In Proceedings of the 19th International Conference on Software Engineering (ICSE97), </booktitle> <pages> pages 433-443, </pages> <year> 1997. </year>
Reference: [TCFR96] <author> F. Tip, J-D Choi, J. Field, and G. Ramalingam. </author> <title> Slicing class hierarchies in c ++ . In Proceedings of OOPSLA'96: </title> <booktitle> Conference on Object-oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 179-197, </pages> <month> October </month> <year> 1996. </year>
Reference: [Tip96] <author> Frank Tip. </author> <title> A survey of program slicing technques. </title> <journal> Journal of Programming Languages, </journal> <volume> 3(3) </volume> <pages> 121-189, </pages> <year> 1996. </year>
Reference: [Ven91] <author> G. A. Venkatesh. </author> <title> The semantic approach to program slicing. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 107-119, </pages> <month> June </month> <year> 1991. </year>
Reference: [Wei80] <author> W. E. Weihl. </author> <title> Interprocedural Data Flow Analysis in the Presence of Pointers, Procedure Variables and Label Variables. </title> <type> Master's thesis, </type> <institution> M.I.T., </institution> <month> June </month> <year> 1980. </year>
Reference-contexts: Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases <ref> [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96] </ref>. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90].
Reference: [Wei84] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference: [Wey94] <author> E. Weyuker. </author> <title> More experience with data flow testing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(9) </volume> <pages> 912-919, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 [Ban88, Pol88, Wol89], data-flow based testing <ref> [HS91, BH93, Ost90, Wey94] </ref>, incremental semantic change analysis of software [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88], interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [WL95] <author> Robert Wilson and Monica Lam. </author> <title> Efficient context-sensitive pointer analysis for c programs. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> June </month> <year> 1995. </year> <note> also available as SIGPLAN Notices, 30(6). </note>
Reference-contexts: This is close to the approach used in the points-to algorithm developed at McGill University, where every procedure activation is analyzed separately [HN90, EGH94]; optimizations to reduce computation by reusing the results for similar calling contexts were suggested by Emami [Ema93], and have been subsequently developed by Wilson and Lam <ref> [WL95] </ref> for points-to analysis and Ghiya and Hendren for connection analysis [GH96]. 9 Jones and Muchnick [JM82b] describe the use of an abstraction of the calling context at a dynamic creation site for a variable; the precision of this abstraction plus the approximation lattice for the data-flow problem in question determine <p> Casting and union types are handled similarly, by encoding the relationship between structure fields as offsets, as in <ref> [WL95, Ste96] </ref>. <p> Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96]. There are flow-sensitive techniques as well which calculate program-point-specific aliases <ref> [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90] </ref>. Still other work concentrated on aliases in higher order functional languages [Deu90, NPD87]. 6 OBSERVATIONS The obvious conclusion of the empirical results is that flow-sensitive analysis yields significantly more precise solutions at far greater computation cost.
Reference: [Wol89] <author> Michael Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: The first MOD C algorithm in the schema was discussed in [LRZ93]. 1 <ref> [Ban88, Pol88, Wol89] </ref>, data-flow based testing [HS91, BH93, Ost90, Wey94], incremental semantic change analysis of software [Bur90, BR90, CK84, MR90a, PS89, Ryd83, RP88], interprocedural def-use relations [PLR94, HS94, GH98] and effective static interprocedural program slicing [GL91, HRB90, OO84, RR95, GS96, LH96, TCFR96, Tip96, Ven91, Wei84, TAFM97, AG96].
Reference: [Zha98] <author> Sean Zhang. </author> <title> Practical Pointer Aliasing Analyses for C. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> May </month> <year> 1998. </year>
Reference-contexts: more spurious side effects may be reported locally and propagated on the call-multigraph (in a context-insensitive manner). 2 Value-flow analysis for Java references is similar to pointer alias analysis. 3 The actual implemented algorithm handles unions and casting in C programs which the published version of the algorithm does not <ref> [ZRL96, Zha98] </ref>. 2 The empirical tests of these algorithms used 45 C programs, most of which are publicly available. 4 Measurements of average and maximum number of side effects found per assignment statement, per assignment through pointer dereference (i.e., a through-dereference assignment statement such as *p=), per procedure and per call <p> These techniques allow exploration of the precision/cost tradeoffs of side-effects analysis and the scalability of these approaches applied to real programs. The following brief alias algorithm descriptions are explained on an intuitive level; definitive algorithm descriptions appear in <ref> [LR92, ZRL96, Zha98] </ref>. In F SAlias, an alias is created (or destroyed) during a pass through a called procedure, given an approximate calling context (i.e., a reaching alias), which propagates information over static execution paths. <p> F SAlias has worst-case polynomial time complexity. F I Alias is a fast, coarse-grained alternative to F SAlias <ref> [ZRL96, Zha98] </ref>. Intuitively speaking, the names in a program are partitioned to show which pairs of names can become aliased during execution.
Reference: [ZRL96] <author> Sean Zhang, Barbara G. Ryder, and William Landi. </author> <title> Program decomposition for pointer aliasing: A step towards practical analyses. </title> <booktitle> In Proceedings of the 4th Annual ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 81-92, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: MOD C (FSAlias) uses the flow-sensitive, calling-context-sensitive approximation algorithm for pointer-induced aliasing, F SAlias [LR92]; MOD C (FIAlias) uses a flow-insensitive, calling-context-insensitive approximation algorithm for pointer-induced aliasing, F I Alias, which is similar to the algorithm described in <ref> [ZRL96] </ref>. 3 The MOD C schema is independent of the aliasing algorithm chosen and can use any aliasing algorithm, given a suitable interface. These are the first MOD C algorithms with extensive implementation results reported. <p> more spurious side effects may be reported locally and propagated on the call-multigraph (in a context-insensitive manner). 2 Value-flow analysis for Java references is similar to pointer alias analysis. 3 The actual implemented algorithm handles unions and casting in C programs which the published version of the algorithm does not <ref> [ZRL96, Zha98] </ref>. 2 The empirical tests of these algorithms used 45 C programs, most of which are publicly available. 4 Measurements of average and maximum number of side effects found per assignment statement, per assignment through pointer dereference (i.e., a through-dereference assignment statement such as *p=), per procedure and per call <p> Normalized differences at calls and for procedures are presented and discussed in Section 4. The empirical results show the utility of both analyses for specific applications and demonstrate the precision gains from sensitivity for certain data-flow information. Recent work in partitioning programs for analyses <ref> [ZRL98, ZRL96, Ruf97] </ref> yields hope that analyses of varying cost and precision can be applied to different parts of a program to obtain desired data-flow information at practical cost. <p> These techniques allow exploration of the precision/cost tradeoffs of side-effects analysis and the scalability of these approaches applied to real programs. The following brief alias algorithm descriptions are explained on an intuitive level; definitive algorithm descriptions appear in <ref> [LR92, ZRL96, Zha98] </ref>. In F SAlias, an alias is created (or destroyed) during a pass through a called procedure, given an approximate calling context (i.e., a reaching alias), which propagates information over static execution paths. <p> F SAlias has worst-case polynomial time complexity. F I Alias is a fast, coarse-grained alternative to F SAlias <ref> [ZRL96, Zha98] </ref>. Intuitively speaking, the names in a program are partitioned to show which pairs of names can become aliased during execution. <p> Another approach to side-effect analysis is to perform an interprocedural pointer aliasing algorithm and then identify all variables experiencing side effects at indirect stores through a pointer (i.e., at through-dereference statements) using the aliases found <ref> [SH97a, ZRL98, ZRL96] </ref>. This is often used as an empirical test of the precision of the alias solution obtained. <p> Several concentrate on aliases in heap storage [HPR89, CWZ90, Deu94, HN90, EGH94, JM82a, LH88, SRW96]. Others calculate program-wide (flow-insensitive) aliases <ref> [Cou86, Gua88, BCCH94, And94, SH97b, Ste95, Wei80, ZRL96] </ref>. There are flow-sensitive techniques as well which calculate program-point-specific aliases [Coo89, LR92, CBC93, MLR + 93, EGH94, WL95, Ruf95, HA90, SFRW90]. <p> The first is how to incorporate flow sensitivity into analysis of very large programs. Zhang et al. <ref> [ZRL98, ZRL96] </ref> report on a program decomposition strategy where the alias relation induces a partitioning of the assignment statements involving pointer variables.
Reference: [ZRL98] <author> Sean Zhang, Barbara G. Ryder, and William A. Landi. </author> <title> Experiments with combined analysis for pointer aliasing. </title> <booktitle> In Proceedings of ACM SIGPLAN Workshop on Program Analysis and Software Tools for Engineering, </booktitle> <month> June </month> <year> 1998. </year> <month> 42 </month>
Reference-contexts: Normalized differences at calls and for procedures are presented and discussed in Section 4. The empirical results show the utility of both analyses for specific applications and demonstrate the precision gains from sensitivity for certain data-flow information. Recent work in partitioning programs for analyses <ref> [ZRL98, ZRL96, Ruf97] </ref> yields hope that analyses of varying cost and precision can be applied to different parts of a program to obtain desired data-flow information at practical cost. <p> Another approach to side-effect analysis is to perform an interprocedural pointer aliasing algorithm and then identify all variables experiencing side effects at indirect stores through a pointer (i.e., at through-dereference statements) using the aliases found <ref> [SH97a, ZRL98, ZRL96] </ref>. This is often used as an empirical test of the precision of the alias solution obtained. <p> The first is how to incorporate flow sensitivity into analysis of very large programs. Zhang et al. <ref> [ZRL98, ZRL96] </ref> report on a program decomposition strategy where the alias relation induces a partitioning of the assignment statements involving pointer variables.
References-found: 85

