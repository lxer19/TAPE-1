URL: http://www.research.microsoft.com/~djk/papers/thesis/thesis.ps
Refering-URL: http://www.research.microsoft.com/users/djk/chimera/chimera.htm
Root-URL: http://www.research.microsoft.com
Title: Graphical Editing by Example  
Author: David Joshua Kurlander 
Degree: Submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy in the Graduate School of Arts and Sciences  
Date: July 1993  
Affiliation: COLUMBIA UNIVERSITY  Columbia University Computer Science Department  
Pubnum: Technical Report CUCS-023-93  
Abstract-found: 0
Intro-found: 1
Reference: [Adobe85] <author> Adobe Systems Inc. </author> <title> PostScript fi Language Tutorial and Cookbook. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address> <year> 1985. </year>
Reference-contexts: The fractal arrow in the figure results after repeating 10 generations of replacements, and then making the remaining grey rectangles black. The PostScript Language Tutorial and Cookbook describes how to create this shape through recursive PostScript programming <ref> [Adobe85] </ref>. The program is relatively simple, containing 21 lines of code, and is intended for instruc Search Replace Search Replace branches; (b) the production that added the leaves; (c) the maple tree. (a) (b) 75 tional purposes.
Reference: [Adobe90] <author> Adobe Systems Inc. </author> <title> Adobe Illustrator User Manual. Macintosh version 3. Part no. </title> <type> 0199-2045 rev. 1. </type> <address> 1585 Charleston Road, Mountain View, CA 94039. </address> <month> November </month> <year> 1990. </year>
Reference-contexts: The techniques described here have been developed for a 2D object-based illustration system, similar to such programs as MacDraw [Claris88] and Adobe Illustrator <ref> [Adobe90] </ref>, although some of these techniques apply to 3D editing and other domains as well. Graphical editors are an apt focus for this research, because they can be used for many different tasks, such as constructing technical illustrations, organizational charts, network diagrams, flow charts, and architectural drawings. <p> Changing a graphical property, such as line width or fill color, for all objects in a group is approximately as easy as changing the attribute for a single object. Most commercial graphical editors, such as MacDraw [Claris88] and Adobe Illustrator <ref> [Adobe90] </ref>, have a grouping facility. Instancing is really a special case of the object libraries mentioned in Section 2.1.2.2. Instead of copying an object from a library, a reference is inserted into the document pointing back to the original.
Reference: [Aldus90] <author> Aldus Corporation. </author> <note> Aldus PageMaker Reference Manual. version 4.0. ISBN 1-56026-021-1. 411 First Avenue South, </note> <institution> Seattle, </institution> <address> WA 98104. </address> <month> April </month> <year> 1990. </year>
Reference: [Arnon88] <author> Arnon, Dennis, Beach, Richard, McIsaac, Kevin, and Waldspurger, Carl. Cam-inoReal: </author> <title> An Interactive Mathematical Notebook. </title> <editor> In J. C. van Vliet, editor, </editor> <booktitle> Document Manipulation and Typography: Proceedings of the International Conference on Electronic Publishing, Document Manipulation, and Typography (EP88), </booktitle> <address> Nice, France. April 20-22, 1988, Cambridge, </address> <publisher> Cambridge University Press, INRIA. </publisher> <pages> 1-18. </pages> <note> Also available in Xerox PARC Technical Report EDL-89-1. </note>
Reference-contexts: Because equation formatting, like equations themselves, tends to be formulaic, interactive equation editing is an application that is wellsuited for templates. Equation editors, such as CaminoReals Meddle <ref> [Arnon88] </ref> and Expressionist [Bonadio88], provide templates for a large number of mathematical operations, such as integration, summation, and addition, and mathematical constructs, such as matrices. Templates can include style and formatting information, without supplying any accompanying media, such as text or graphics.
Reference: [Asente87] <author> Asente, Paul. </author> <title> Editing Graphical Objects Using Procedural Representations. </title> <note> DEC WRL Research Report 87/6. </note> <month> November </month> <year> 1987. </year> <note> Revised version of Stanford Computer Science Ph. </note> <author> D. </author> <type> thesis. </type>
Reference-contexts: object-input and document structure extensibil 35 ity domainsthey can add new objects and constraints to the scene, and nested procedures impose a procedural hierarchy on the scene description. 2.2.2 Tweedle The Tweedle system, built by Paul Asente, consists of two components: the Dee graphical editor and the Dum graphics language <ref> [Asente87] </ref>. Like Juno, Tweedle is a two-view system, and modifications made to one view automatically propagate to the other. Programs in the Dum language serve as the internal representation of objects in the graphical viewthe graphical editor contains no redundant data structures to be kept consistent with the program. <p> In his dissertation, Asente cites the traditional snowflake curve as one reason why programming subsystems are important for graphical editorsthat shapes like these are inherently difficult to construct through direct manipulation, since they require so much repetition and precision <ref> [Asente87] </ref>. Using MatchTool, people can construct such shapes without traditional programming. Also, it is far easier to construct these shapes using graphical search and replace than general programming, since search and replace very closely approximates the abstractions used to define graphical grammars. <p> To edit the demonstrated procedure, the user can either textually edit these steps or the resulting Lisp procedure. Tweedle, a graphical editor with both a WYSIWYG view and a textual code view, allows procedures to be generated in both views <ref> [Asente87] </ref>. However, to edit a procedure, the user must be able to understand the code view. In the MIKE UIMS, graphical macros can also be defined by demonstration [Olsen88].
Reference: [Beach85] <author> Beach, Richard J. </author> <title> Setting Tables and Illustrations with Style. </title> <note> Xerox PARC Technical Report CSL-85-3. </note> <month> May </month> <year> 1985. </year> <institution> Reprint of University of Waterloo Computer Science Ph. </institution> <address> D. </address> <note> thesis. </note>
Reference: [Bier86] <author> Bier, Eric A., and Stone, Maureen C. Snap-Dragging. </author> <booktitle> Proceedings of SIG-GRAPH 86 (Dallas, </booktitle> <address> Texas, </address> <month> August 18-22, </month> <year> 1986). </year> <booktitle> In Computer Graphics 20, </booktitle> <month> 4 (August </month> <year> 1986). </year> <pages> 233-240. 212 </pages>
Reference-contexts: Portions of Chimeras interface were inspired by GNU Emacs [Stallman87], and the Gargoyle Illustrator [Pier88]. From Emacs, Chimera borrows keymaps, a minibuffer for text-based commands, a Lisp-based extension language (Common Lisp though, instead of ELisp), the default text command bindings, and multiple editor modes. Chimeras graphics mode takes snap-dragging <ref> [Bier86] </ref> and many of its commands from Gargoyle. However, Chimeras implementation shares no code with either of these systems. 1.4 Graphical Editing by Example This section introduces five new example-based techniques to automate repetition in graphical editor interactions. <p> The grid itself can be edited in a special mode, and grid configurations can be saved and retrieved. Bier points out that graphical relationships involving multiple points are often difficult to specify with grids <ref> [Bier86] </ref>. The ability to create custom grids increases the relationships that can be expressed; however, two other techniques, snap-dragging [Bier86] and constraints [Nelson85] have greater expressive power. The former technique uses compass and ruler constructs, called alignment objects, to precisely specify geometric 28 positioning relationships. <p> Bier points out that graphical relationships involving multiple points are often difficult to specify with grids <ref> [Bier86] </ref>. The ability to create custom grids increases the relationships that can be expressed; however, two other techniques, snap-dragging [Bier86] and constraints [Nelson85] have greater expressive power. The former technique uses compass and ruler constructs, called alignment objects, to precisely specify geometric 28 positioning relationships. The latter allows the specification of high-level geometric relationships to be maintained as the illustration is modified. <p> The original MatchTool, hereby referred to as Match-Tool 1, was implemented during the summer of 1987 at Xerox PARCs Computer Sciences Laboratory. MatchTool 1 runs on Dorado workstations [Pier83] under the Cedar Environment [Swinehart86]. It works in conjunction with the Gargoyle graphical editor <ref> [Bier86] </ref> [Pier88]. A videotape of MatchTool 1 appears in [Bier89]. In some ways, Match-Tool 1s interface was patterned after Tiogas textual search and replace utility, the EditTool. It was hoped that people already familiar with the EditTool would find Match-Tool 1 easy to learn. <p> An example of this is included in <ref> [Bier86] </ref>. These constructions consist of a small number of tasks that are repeated many times, some of which are difficult to perform or require some geometric knowledge. <p> They are useful during object construction to position components relative to one another precisely, as well as during subsequent manipulation of the components. Several graphical techniques, such as grids, snap-dragging <ref> [Bier86] </ref> and automatic beautification [Pavlidis85] were developed to make the initial construction phase easier, since specifying constraints explicitly can be a complex task. However, when objects are to be manipulated frequently, permanent constraints have an advantage over these other techniques in that they need not be reapplied. <p> can be expressed through procedural constructions, but the relationships between objects in these constructions tend to be unidirectional, and procedures for every dependency need to be demonstrated. 106 The difficulty inherent in understanding interactions among multiple constraints and debugging large constraint networks has been addressed by the snap-dragging interaction technique <ref> [Bier86] </ref> [Bier88] and by an automatic illustration beautifier [Pavlidis85]. In snap-dragging, individual constraint solutions are isolated temporally from one another, so that their interaction cannot confuse the artist. <p> Note that scale in this diagram refers to isotropic scale, and the vector relationship is the combination of slope and distance constraints. Identity coordinates Translation vectors Scaling & Translation slopes Rotation & Translation distances angles, ratios of distances & Scaling Rotation, Translation, Affine Transformations parallelism Reprinted with permission from <ref> [Bier86] </ref>. 117 We next determine which constraints cannot hold within the transformational group. Again, this is easily done by examining the transformations that have been applied to the group. If a group has been translated, all of its fixed vertex location constraints are broken. <p> This allows us to define macros that perform geometric constructions, using the snap-dragging interaction technique developed by Bier <ref> [Bier86] </ref>. For example, we can use this technique to define macros in Chimera that bisect angles, construct the midpoint of lines, and align shapes. <p> The caret is gravity sensitive, and objects in the scene, as well as align 208 ment lines attract the caret. Translations, rotations, and scales are guided by the caret to specify these transformations precisely. This technique, called snap-dragging, was initially used in the Gargoyle editor, and is described in <ref> [Bier86] </ref>. Most drawing commands in Chimera use the caret. For example, when adding a line to the scene, the line rubberbands between the position of the caret at the start of the operation, and the current position of the caret, as it follows the hardware cursor.
Reference: [Bier88] <author> Bier, Eric A. Snap-Dragging: </author> <title> Interactive Geometric Design in Two and Three Dimensions. </title> <type> Ph.D. thesis. </type> <institution> U.C. Berkeley. EECS Department. </institution> <month> April </month> <year> 1988. </year>
Reference-contexts: be expressed through procedural constructions, but the relationships between objects in these constructions tend to be unidirectional, and procedures for every dependency need to be demonstrated. 106 The difficulty inherent in understanding interactions among multiple constraints and debugging large constraint networks has been addressed by the snap-dragging interaction technique [Bier86] <ref> [Bier88] </ref> and by an automatic illustration beautifier [Pavlidis85]. In snap-dragging, individual constraint solutions are isolated temporally from one another, so that their interaction cannot confuse the artist. <p> Alignment lines are a powerful and easy-to-use mechanism for specifying precise geometric relationships. Users of the Gargoyle editor, responding to a survey, indicated that they generally make use of alignment lines, and an analysis of interaction logs confirmed this <ref> [Bier88] </ref>. If people use this technique to establish precise geometric relationships during normal editing, then they would probably use it, without additional thought, while demonstrating a macro. In Metamouse, users construct tools in order to make positioning operations explicit [Maulsby93a].
Reference: [Bier89] <author> Bier, Eric A., and Kurlander, David. </author> <title> Interactive Graphical Search and Substitute. </title> <note> SIGGRAPH Video Review. Issue 48. </note> <year> 1989. </year>
Reference-contexts: MatchTool 1 runs on Dorado workstations [Pier83] under the Cedar Environment [Swinehart86]. It works in conjunction with the Gargoyle graphical editor [Bier86] [Pier88]. A videotape of MatchTool 1 appears in <ref> [Bier89] </ref>. In some ways, Match-Tool 1s interface was patterned after Tiogas textual search and replace utility, the EditTool. It was hoped that people already familiar with the EditTool would find Match-Tool 1 easy to learn. Later we built MatchTool 2 to experiment with extensions of graphical search and replace.
Reference: [Bloomenthal85] <author> Bloomenthal, Jules. </author> <title> Modeling the Mighty Maple. </title> <booktitle> Proceedings of SIG-GRAPH 85 (San Francisco, </booktitle> <address> CA, </address> <month> July 22-26, </month> <year> 1985). </year> <booktitle> In Computer Graphics 19, </booktitle> <month> 3 (July </month> <year> 1985). </year> <pages> 305-311. </pages>
Reference-contexts: Though graphical grammars were not used to build the maple tree of Figure 3.3, they could have been used for this purpose. Smith studied the use of grammars (or graftals) to generate plants [Smith84], and Bloomenthal developed an interesting approach to modeling 3D maple trees without grammars <ref> [Bloomenthal85] </ref>.
Reference: [Bonadio88] <author> Allan Bonadio Associates. </author> <title> Expressionist Version 2.0 Users Manual. </title> <address> 814 Castro Street, San Francisco, CA 94114. </address> <year> 1988. </year>
Reference-contexts: Because equation formatting, like equations themselves, tends to be formulaic, interactive equation editing is an application that is wellsuited for templates. Equation editors, such as CaminoReals Meddle [Arnon88] and Expressionist <ref> [Bonadio88] </ref>, provide templates for a large number of mathematical operations, such as integration, summation, and addition, and mathematical constructs, such as matrices. Templates can include style and formatting information, without supplying any accompanying media, such as text or graphics.
Reference: [Borenstein88] <author> Borenstein, Nathaniel S., and Gosling, James. </author> <title> Emacs: A Retrospective. </title> <booktitle> ACM SIGGRAPH Symposium on User Interface Software. </booktitle> <publisher> ACM Press. </publisher> <month> October </month> <year> 1988. </year>
Reference-contexts: The Emacs editors particularly have been extensively exploited in this way. UNIX Emacs, for example, has been used as an interface to an electronic mail system, bulletin boards, net news, spreadsheets, an animation program, a database system, a Basic interpreter, and an online help system <ref> [Borenstein88] </ref>. 2.1.2 Object Input Extensibility People spend more time inserting text, graphics, and other objects into documents than performing any other type of editor operation. This section deals primarily with mechanisms for extending the ease of adding objects to editor documents. <p> They write, This is probably the most important lesson to be learned from mlisp: extension languages are real languages, not toys <ref> [Borenstein88] </ref>. Extension languages also vary in whether they are compiled or interpreted. If execution speed is not critical, interpreters are generally superior to compiled languages for editor extensions. Interpreted languages allow a faster cycle time for testing and modifying extensions. <p> These have the speed of compiled programs (which they are), and 31 many of the conveniences of interpreted code. The Andrew EZ editor can dynamically load compiled C extensions, although some criticize the process as being too awkward for spur-of-the moment customizations <ref> [Borenstein88] </ref>. An editor in the Emacs family, called SINE, dynamically loads extensions in a compiled Lisp-like language [Stallman84]. VAXTPU, which has its own custom compiled extension language, can also load procedures dynamically.
Reference: [Borning79] <author> Borning, Alan. </author> <type> ThingLab: </type> <institution> A Constraint-Oriented Simulation Laboratory. </institution> <note> Xerox PARC Technical Report SSL-79-3. Revised version of Stanford Computer Science Ph. </note> <author> D. </author> <type> thesis. </type> <month> July </month> <year> 1979. </year>
Reference-contexts: This chapter describes a new technique for inferring constraints from multiple valid configurations of a scene. Geometric constraints are used extensively in computer graphics in the specification of relationships between graphical objects [Sutherland63a] <ref> [Borning79] </ref> [Myers88] [Olsen90]. They are useful during object construction to position components relative to one another precisely, as well as during subsequent manipulation of the components. <p> Lees problem domain and assumptions restricted the set of constraints such that there was never any ambiguity about which to select. In our domain the initial ambiguity is unavoidable, and we rely on multiple examples to converge to the desired constraint set. Systems like Sketchpad [Sutherland63a] [Sutherland63b] and ThingLab <ref> [Borning79] </ref> make it easier to add large numbers of constraints to a scene, by allowing users to define new classes of objects that include the constraints that operate on them as part of the definition. When users create instances of a new class, the system automatically generates the associated constraints.
Reference: [Borning86] <author> Borning, Alan. </author> <title> Graphically Defining New Building Blocks in ThingLab. </title> <booktitle> Human Computer Interaction 2, </booktitle> <volume> 4. </volume> <year> 1986. </year> <month> 269-295. </month> <title> Reprinted in Visual Programming Environments: Paradigms and Systems. </title> <editor> Ephraim Glinert, ed. </editor> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA. </address> <year> 1990. </year> <pages> 450-469. </pages>
Reference-contexts: The ability to create custom rules is particularly important, now that methods have been developed to allow the user to define new types of constraints with little or no programming. For example, Bornings ThingLab allows new constraint classes to be defined using graphical techniques <ref> [Borning86] </ref>, and several recent systems allow new constraints to be entered via spreadsheets [Lewis90] [Hudson90b] [Myers91a]. If the system designers cannot foresee every constraint that may be necessary, they clearly cannot provide for every transformation rule based on these constraints. <p> This is described in Appendix C. Because our technique is particularly useful in heavily constrained systems, we allow constraints in the browser to be filtered by type or object reference. One of Bornings ThingLab implementations allowed new types of constraints to be defined and viewed graphically <ref> [Borning86] </ref>. Several systems permit users to define new classes of constraints by filling in cell equations in a spreadsheet [Lewis90] [Hudson90b] [Myers91a]. The technique introduced here infers constraints from a fixed set of classes that have proven useful for graphical editing.
Reference: [Brooks88] <author> Brooks, Kenneth P. </author> <title> A Two-View Document Editor with User-Definable Document Structure. </title> <note> DEC SRC Research Report #33. </note> <month> November </month> <year> 1988. </year> <note> Revised version of Stanford Ph. </note> <author> D. </author> <type> thesis. </type>
Reference-contexts: Variants first execute their parent definition, followed by code that modifies subobjects defined by the parent, possibly adding, deleting, transforming, or changing the overlap order of these components. 2.2.3 Lilac In Kenneth Brooks two-view document editor, Lilac, logical document structures are also defined procedurally <ref> [Brooks88] </ref>. Corresponding to each use of a structure in the formatted page view is a procedure call in the algorithmic source view. An example from Brooks thesis appears in Figure 2.2, demonstrating how a simple dictionary entry structure might be defined and used.
Reference: [Burr79] <author> Burr, D. J. </author> <title> A Technique for Comparing Curves. </title> <booktitle> IEEE Conference on Pattern Recognition and Image Processing. </booktitle> <address> (Chicago, IL, </address> <month> August 6-8). </month> <note> IEEE. </note> <year> 1979. </year> <pages> 271-277. </pages>
Reference-contexts: A run of curves can be discretized into a one dimensional string, with characters representing directions. The similarity of two runs can be compared by calculating the cost of editing one string into the other. Burr used a similar approach for handdrawn character recognition <ref> [Burr79] </ref>. This appears to be much more intuitive than MatchTools current metric for inexact matches, but we have yet to extend the technique to matching multiple runs of curves. As mentioned in the last section, the number of widgets in the MatchTool window can be daunting.
Reference: [Chamberlin88] <author> Chamberlin, Donald D., Hasselmeier, Helmut F., Luniewski, Allen W., Paris, Dieter P., Wade, Bradford W., and Zolliker, Mitch L. </author> <title> Quill: An Extensible System for Editing Documents of Mixed Type. </title> <booktitle> Proceedings of the Twenty-First Annual Hawaii International Conference on System Sciences, </booktitle> <editor> Bruce Shriver, ed., </editor> <month> 317-326. </month>
Reference-contexts: In contrast, weakly integrated media editors each run in their own window as separate processes, with no single, uniform interface. The Diamond Editor [Crowley87], originally built for a multimedia message system [Thomas85], the EZ editor of the Andrew Toolkit [Palay88], and Quill <ref> [Chamberlin88] </ref> are all strongly integrated multimedia editors. In each of these, the editors framework determines which media elements interact with each other and the general editor services.
Reference: [Chang89] <author> Chang, Shi Kuo. </author> <title> Principles of Pictorial Information Systems Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1989. </year>
Reference-contexts: Searching a graphical scene is also related to making queries on a graphical database, and other researchers have examined this topic [Weller76] [Palermo80] <ref> [Chang89] </ref>. Graphical search and replace has a number of additional applications, aside from making mundane coherent changes. Graphical search and replace can serve as a tool for constructing repetitive, recursive shapes defined by graphical grammars. It can also help to make complex scenes out of simple ones, using graphical templates.
Reference: [Chen88] <author> Chen, Pehong. </author> <title> A Mutliple Representation Paradigm for Document Development. </title> <type> Ph.D. thesis, </type> <institution> U.C. Berkeley. EECS Department. </institution> <month> July </month> <year> 1988. </year>
Reference-contexts: Many Cedar keywords are defined as abbreviations, which expand into templates for the language constructs that they initiate. BibTeX, the bibliography database tool for LaTeX [Lamport86], has two BibTeX modes written for GNU Emacs to provide template support for its many reference types <ref> [Chen88] </ref> [Martensson88]. Because equation formatting, like equations themselves, tends to be formulaic, interactive equation editing is an application that is wellsuited for templates. <p> In Andrew, each parent media object determines which input events to pass on to its children, and which to interpret as media-specific commands. 34 More loosely integrated editors, not sharing the same address space, must rely on protocols for inter-editor communication. An example of this is Chens VorTeX system <ref> [Chen88] </ref>, which contains a source editor for editing TeX code directly, a formatter, and a target editor for viewing the formatted page. Additional media editors, executing as independent processes in separate windows, can be incorporated into the system by defining new protocols between them and the source and target editors.
Reference: [Christodoulakis88] <author> Christodoulakis, S., and Graham, S. </author> <title> Browsing within TimeDriven Multimedia Documents. </title> <booktitle> Proceedings of COIS 88, Conference on Office Information Systems. </booktitle> <address> Palo Alto, CA. March 23-25, </address> <year> 1988. </year> <pages> 219-227. 213 </pages>
Reference-contexts: By selecting one of the screen miniatures, the user can return to a previously visited page. Christodoulakis and Graham developed a system that adds icons to a scrolling window at points in a multimedia presentation that the author deems important <ref> [Christodoulakis88] </ref>. In Makkunis Chinese temple editor, architects share a design history represented as a sequence of icons. The system provides an additional record of the design process by showing component editors for the various steps, connected by threads relating their use [Makkuni87].
Reference: [Chyz85] <author> Chyz, George W. </author> <title> Constraint Management for Constructive Geometry. </title> <type> Masters thesis. </type> <institution> MIT. Mechanical Engineering. </institution> <month> June </month> <year> 1985. </year>
Reference-contexts: One approach to reducing redundant constraints might involve using algorithms similar to those Chyz developed for maintaining complete and consistent constraint systems <ref> [Chyz85] </ref>. When a new constraint is added to the network, his algorithms determine which constraint must be eliminated to avoid overconstraining the system. These methods may allow us to reduce the set of constraints passed to the solver.
Reference: [Claris88] <author> Claris Corporation. </author> <title> MacDraw II Reference. </title> <type> 440 Clyde Ave., </type> <institution> Mountain View, </institution> <address> CA 94043. </address> <year> 1988. </year>
Reference-contexts: The techniques described here have been developed for a 2D object-based illustration system, similar to such programs as MacDraw <ref> [Claris88] </ref> and Adobe Illustrator [Adobe90], although some of these techniques apply to 3D editing and other domains as well. <p> Changing a graphical property, such as line width or fill color, for all objects in a group is approximately as easy as changing the attribute for a single object. Most commercial graphical editors, such as MacDraw <ref> [Claris88] </ref> and Adobe Illustrator [Adobe90], have a grouping facility. Instancing is really a special case of the object libraries mentioned in Section 2.1.2.2. Instead of copying an object from a library, a reference is inserted into the document pointing back to the original.
Reference: [Cohen82] <author> Cohen, Paul R., and Feigenbaum, Edward A. </author> <booktitle> The Handbook of Artificial Intelligence. </booktitle> <volume> vol. 3. </volume> <publisher> Kaufmann, Inc., </publisher> <address> Los Altos, CA. </address> <year> 1982. </year>
Reference-contexts: The inference mechanism determines constants in the constraint equations, but it does not synthesize new classes of equations. Our technique is an application of learning from multiple examples, also known as empirical learning. Several empirical learning systems are discussed in <ref> [Cohen82] </ref>. In contrast, generalizing from a single example is called explanation-based learning and is surveyed in [Ellman89]. Explanation-based learning requires a potentially large amount of domain knowledge to determine why one explanation is particularly likely.
Reference: [Cohen92] <author> Cohen, Philip R. </author> <title> The Role of Natural Language in a Multimodal Interface. </title> <booktitle> In Proceedings of UIST 92 (Monterey, </booktitle> <address> CA, </address> <month> November 15-18). </month> <booktitle> ACM, </booktitle> <address> New York, </address> <year> 1992. </year> <pages> 143-149. </pages>
Reference-contexts: Spoken language can be used as a supplementary input mechanism for Mondrian. Alan Turransky developed a speech input mechanism for Mondrian, that allows users to verbalize their intent while performing inherently ambiguous direct manipulation commands [Turran-sky93]. Speech input and direct manipulation work well together because they are largely complementary <ref> [Cohen92] </ref>. By pointing with a mouse, people can easily select particular object instances, while speech better communicates abstractions. 2.2.9 Turvy Like Mondrian, David Maulsbys Turvy experiment uses speech and graphical interaction together to synthesize a procedure by demonstration [Maulsby93b].
Reference: [Crowley87] <author> Crowley, Terrence, Forsdick, Harry, Landau, Matt and Travers, Virginia. </author> <title> The Diamond Multimedia Editor. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <month> Summer </month> <year> 1987. </year> <month> June </month> <year> 1987. </year> <pages> 1-18. </pages>
Reference-contexts: Some screen editors with their roots in the days before workstation technology became popular, such as Emacs [Stallman84] and VAXTPU [Digital86b], rely on translation tables to associate key sequences with commands. These are called keymaps. Newer systems, such as 24 the Diamond Multimedia Editor <ref> [Crowley87] </ref>, designed from the outset to accept other forms of graphical input, also use this mechanism for dispatching on keyboard events. When editors are built using a User Interface Management System (UIMS), they often rely on the UIMS to translate events for them. <p> Editors with a framework that readily supports additions of this type exhibit media extensibility. Editors capable of producing multimedia documents typically consist of multiple component editors, one for each media type, integrated in either a strong or weak fashion. As discussed in <ref> [Crowley87] </ref>, strongly integrated editors allow different media objects to be viewed and edited in the same window, execute under a single process, present a uniform user interface where possible, and may even permit easy conversions among media types. <p> In contrast, weakly integrated media editors each run in their own window as separate processes, with no single, uniform interface. The Diamond Editor <ref> [Crowley87] </ref>, originally built for a multimedia message system [Thomas85], the EZ editor of the Andrew Toolkit [Palay88], and Quill [Chamberlin88] are all strongly integrated multimedia editors. In each of these, the editors framework determines which media elements interact with each other and the general editor services.
Reference: [Cypher91] <author> Cypher, Allen. EAGER: </author> <title> Programming Repetitive Tasks by Example. </title> <booktitle> CHI 91 Conference Proceedings (New Orleans, </booktitle> <address> LA, </address> <month> April 27- May 2, </month> <year> 1991). </year> <pages> 33-39. </pages> <note> Revised version appears in Watch What I Do: Programming by Demonstration. </note> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 205-217. </pages>
Reference-contexts: Users can also teach Peridot the dynamic behaviors of the interaction devices by demonstration. 2.3.5 Eager Allen Cyphers Eager system, a programming by example utility for Apples Hypercard application, has a novel method for communicating its generalizations to the user <ref> [Cypher91] </ref>. Many programming by example systems interrupt the demonstration process to verify that their generalization hypotheses are correct. <p> When users realize that a set of operations that they had performed are generally useful, they can always open up a history window and encapsulate the interesting operations into a macro. A programming by example system named EAGER also generates macros from a history <ref> [Cypher91] </ref>. It constantly monitors the command stream for repeated operation sequences. When a repetitive task is detected, the system presents feedback that indicates the tasks it anticipates, and when users are confident in EAGERs predictions, they can have it automatically generate a generalized procedure.
Reference: [Digital80] <institution> Digital Equipment Corporation. </institution> <note> PDP-11 TECO Users Guide. DEC Software Distribution Center, </note> <institution> Maynard, </institution> <address> MA 01754. </address> <publisher> Part no. </publisher> <address> DEC-11-UTECA-B-D. </address> <month> February </month> <year> 1980. </year>
Reference-contexts: Text-based interfaces and graphical user interfaces provide alternative mechanisms to support extensibility. 2.1.1.1 Command interpretation In some editors, users invoke commands by typing the command names directly to an interpreter. Many non-screen-oriented text editors, such as TECO <ref> [Digital80] </ref> and ed [Kernighan78b] exclusively use an interpreter for command input. These editors historically have been popular mainly with programmers, since the task of editing becomes akin to programming. <p> Richard Stall-man later wrote that Emacs is a misnomer because his editor was implemented as a set of functions in the TECO language [Stallman84], yet the TECO manual refers only to macros, never functions <ref> [Digital80] </ref>. 2.1.3.3 Command programming The only way to give an editor radically new functionality is through programming. All of the techniques for extensibility discussed in this chapter rely on existing mechanisms to provide their extensibility. Only programming itself can create entirely new mechanisms.
Reference: [Digital86a] <institution> Digital Equipment Corporation. </institution> <note> Guide to Text Processing on VAX/VMS. DEC, </note> <author> P. O. </author> <title> Box CS2008, </title> <journal> Nashua, </journal> <volume> NH 03061. Part no. AI-Y502B-TE. </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: The VAX EDT editor allows the default syntax for words, sentences, paragraphs and pages to be modified with commands that change the delimiters <ref> [Digital86a] </ref>. GNU Emacs stores syntax information such as word-constituent characters, opening and closing delim-iters (used for example in parenthesis and bracket matching), quote characters, whitespace, and comment delimiters in syntax tables [Stallman87].
Reference: [Digital86b] <author> Digital Equipment Corporation. </author> <title> Text Processing Utility Reference Manual. DEC, </title> <editor> P. O. Box CS2008, Nashua, </editor> <volume> NH 03061. Part no. AA-EC64C-TE. </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: In the days before menus and mice, the keyboard was the source of all input events. Some screen editors with their roots in the days before workstation technology became popular, such as Emacs [Stallman84] and VAXTPU <ref> [Digital86b] </ref>, rely on translation tables to associate key sequences with commands. These are called keymaps. Newer systems, such as 24 the Diamond Multimedia Editor [Crowley87], designed from the outset to accept other forms of graphical input, also use this mechanism for dispatching on keyboard events.
Reference: [Ellman89] <author> Ellman, Thomas. </author> <title> Explanation-Based Learning: A Survey of Programs and Perspectives. </title> <journal> ACM Computing Surveys 21, </journal> <volume> 2. </volume> <month> June </month> <year> 1989. </year> <pages> 163-221. </pages>
Reference-contexts: Our technique is an application of learning from multiple examples, also known as empirical learning. Several empirical learning systems are discussed in [Cohen82]. In contrast, generalizing from a single example is called explanation-based learning and is surveyed in <ref> [Ellman89] </ref>. Explanation-based learning requires a potentially large amount of domain knowledge to determine why one explanation is particularly likely.
Reference: [Feiner82] <author> Feiner, S., Nagy, S., and van Dam, A. </author> <title> An Experimental System for Creating and Presenting Interactive Graphical Documents. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 1, 1. </volume> <month> January </month> <year> 1982. </year> <pages> 59-77. </pages>
Reference-contexts: The IGD hypermedia system, built by Feiner, Nagy, and van Dam, constructs a timeline out of screen miniatures to represent its users navigation path through a document <ref> [Feiner82] </ref>. By selecting one of the screen miniatures, the user can return to a previously visited page. Christodoulakis and Graham developed a system that adds icons to a scrolling window at points in a multimedia presentation that the author deems important [Christodoulakis88].
Reference: [Feiner85] <author> Feiner, Steven. APEX: </author> <title> An Experiment in the Automated Creation of Pictorial Explanations. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 5, 11. </volume> <month> November </month> <year> 1985. </year> <pages> 29-37. </pages>
Reference-contexts: The use of tags for this purpose was used earlier in the APEX system for generating automated pictorial explanations <ref> [Feiner85] </ref>.
Reference: [Foley90] <author> Foley, James D., van Dam, Andries, Feiner, Steven K., and Hughes, John F. </author> <title> Computer Graphics: Principles and Practice. Second Edition. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address> <year> 1990. </year>
Reference-contexts: An earlier 1989-class history, corresponding to the last seven panels of this sequence, appears in <ref> [Foley90, Plate I.23] </ref>. That reproduction is in color, and better demonstrates the effect of lightening colors of contextual objects.
Reference: [Frame90] <author> Frame Technology Corporation. </author> <title> FrameMaker Reference. Part no. </title> <address> 41-00524-00. 1010 Rincon Circle, San Jose, CA 95131. </address> <month> September </month> <year> 1990. </year> <month> 214 </month>
Reference: [Furnas86] <author> Furnas, George. </author> <title> Generalized Fisheye Views. </title> <booktitle> CHI 86 Conference Proceedings (Boston, </booktitle> <address> MA, April 13-17). </address> <publisher> ACM, </publisher> <address> New York, </address> <year> 1986. </year> <pages> 16-23. </pages>
Reference-contexts: It would be interesting to try to automatically increase the granularity of panels farther in the history, creating a graphical fisheye view. Fisheye views distort space, allowing more detail for important parts of a presentation, and less for context <ref> [Furnas86] </ref>. 160 161 Chapter 7 A History-Based Macro By Example System 7.1 Introduction When applications are made extensible, the entire user community benefits. Individuals can customize their applications to the tasks that they often encounter, and experts can encapsulate their expertise in a form that less skilled users can exploit.
Reference: [Garey79] <author> Garey, M. R., and Johnson, D. S. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <address> San Francisco, CA. </address> <year> 1979. </year>
Reference-contexts: Therefore, matching the search pattern to the scene requires finding occurrences of one graph within another. This is known as the subgraph isomor-phism problem, and the bad news is that it is NP-complete for general graphs <ref> [Garey79] </ref>. The good news is that for a search pattern of fixed size the matching can be done in polynomial time, and for typical replacements the exponent is very small.
Reference: [Gips75] <author> Gips, James. </author> <title> Shape Grammars and Their Uses: Artificial Perception, Shape Generation, </title> <publisher> and Computer Aesthetics. Birkhauser, Verlag, </publisher> <address> Basel, Switzerland. </address> <year> 1975. </year>
Reference-contexts: Typically these graphical properties include shape. Shape grammars, a class of graphical grammars in which shapes form all the terminals and nonterminals, have been explored by others <ref> [Gips75] </ref> [Stiny75]. Graphical search and replace provides a convenient mechanism for generating pictures formed by graphical grammars. Examples of such illustrations are the snowflake curves presented in Figure 3.7.
Reference: [Goines82] <author> Goines, D. L. </author> <title> A Constructed Roman Alphabet. </title> <editor> David R. Godine, publisher. </editor> <address> 306 Dartmouth St., Boston, MA 02116. </address> <year> 1982. </year>
Reference-contexts: more sophisticated tasks that introduce other capabilities of the system. 4.6 Example 2: Making A Line Tangent to a Circle As the Gargoyle graphical editor was being developed at Xerox PARC, several people proved their drafting prowess by constructing letters from the Roman alphabet, following the instructions described by Goines <ref> [Goines82] </ref>. An example of this is included in [Bier86]. These constructions consist of a small number of tasks that are repeated many times, some of which are difficult to perform or require some geometric knowledge.
Reference: [Green85] <author> Green, Mark. </author> <title> The University of Albert User Interface Management System. </title> <booktitle> Proceedings of SIGGRAPH 85 (San Francisco, </booktitle> <address> CA, </address> <month> July 22-26, </month> <year> 1985). </year> <booktitle> In Computer Graphics 19, </booktitle> <month> 3 (July </month> <year> 1985). </year> <pages> 205-213. </pages>
Reference-contexts: In the Seeheim model of user interfaces, the presentation component converts low-level events into descriptive tokens, and the dialogue control component processes the token stream, generating calls to the third component, the application interface <ref> [Green85] </ref>. As part of its presentation component, the Cedar environment includes a Terminal Interface Package (TIP) that acts as a lexical analyzer, reading input events such as those directly generated by the keyboard and mouse, turning these events into higher-level tokens such as DELETE and DOREPLACE [Swinehart86].
Reference: [Halbert84] <author> Halbert, Daniel. C. </author> <title> Programming by Example. </title> <institution> Xerox Office Systems Division Technical Report OSD-T8402. </institution> <month> December </month> <year> 1984. </year> <institution> Reprint of Berkeley Computer Science Ph. </institution> <address> D. </address> <note> thesis. </note>
Reference-contexts: In contrast, using demonstrational techniques is much closer to using the native application. Demonstrational techniques are accessible to anyone already possessing the skills to use the applications interface. Halbert, for example, describes one demonstrational technique, programming by example, as programming an application through its own interface <ref> [Halbert84] </ref>. Conventional programming skills are either not necessary or fewer are needed. Demonstrational interfaces also have the advantage that abstractions are specified using concrete examples, so those people that have difficulty working with abstractions will probably find these interfaces easier to use. <p> A small prototype version of this interface had been built called SmallStar, and for his doctoral thesis, Daniel Halbert devised a mechanism for programming this system by example <ref> [Halbert84] </ref> [Halbert93]. To begin defining a program, the user either invokes a StartRecording command, or opens a program icon. As users perform operations, a text and icon-based description of these commands appears in the program window. <p> For example, in Figure 2.5, we see the property sheet for the Treaty argument, referred to in Figure 2.4. To modify this argument to be the first file in folder Reprinted from <ref> [Halbert84] </ref>. 45 Negotiations, the Choose using field is changed to POSITION, and the Position field must contain FIRST. After this data description is modified, the listing in the program window is updated accordingly, as in Figure 2.6. <p> In this system macros can be defined and edited largely in demonstration mode, but the visual representation of graphical commands is textual. A programming by example component of SmallStar, a subset of the Star user interface, adopts a mixed text and iconic representation for macros <ref> [Halbert84] </ref>. As shown in Figure 2.4, this system uses a predefined set of icons or pictographs to represent entities on the desktop. The domains for which our system is targeted are more graphical in nature, so prefabricated icons will not suffice. <p> Splitting macro definition into a demonstrational step and a generalization step was first done by Halbert in SmallStar <ref> [Halbert84] </ref>.
Reference: [Halbert93] <author> Halbert, Daniel C. SmallStar: </author> <title> Programming by Example in the Desktop Metaphor. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 103-123. </pages>
Reference-contexts: A small prototype version of this interface had been built called SmallStar, and for his doctoral thesis, Daniel Halbert devised a mechanism for programming this system by example [Halbert84] <ref> [Halbert93] </ref>. To begin defining a program, the user either invokes a StartRecording command, or opens a program icon. As users perform operations, a text and icon-based description of these commands appears in the program window.
Reference: [Hudson90a] <author> Hudson, Scott E., and Mohamed, Shamim P. </author> <title> Interactive Specification of Flexible User Interface Displays. </title> <journal> ACM Transactions on Information Systems 8, </journal> <month> 3 (July </month> <year> 1990). </year> <pages> 269-288. </pages>
Reference-contexts: Nelsons Juno, a two-view graphical editor, provided a program view of constraints [Nelson85]. Peridot communicated constraints as English language fragments during confirmation, and Metamouse used buttons for confirming and prioritizing constraints. The OPUS interface editor represented constraints between interface components as arrows connecting hierarchical frames or drafting lines <ref> [Hudson90a] </ref>. Our technique never requires that its users work with individual, low-level constraints. In both the specification and debugging stages, they can think entirely in terms of acceptable configurations of the illustration. The inferred constraints can be tested by manipulating scene objects, and the constraint set refined through additional snapshots.
Reference: [Hudson90b] <author> Hudson, Scott E. </author> <title> An Enhanced Spreadsheet Model for User Interface Specification. </title> <type> Report TR 90-33. </type> <institution> Univ. of Arizona. Computer Science. </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: For example, Bornings ThingLab allows new constraint classes to be defined using graphical techniques [Borning86], and several recent systems allow new constraints to be entered via spreadsheets [Lewis90] <ref> [Hudson90b] </ref> [Myers91a]. If the system designers cannot foresee every constraint that may be necessary, they clearly cannot provide for every transformation rule based on these constraints. Search and replace is also a particularly easy way to add constraints to similar sets of objects. <p> One of Bornings ThingLab implementations allowed new types of constraints to be defined and viewed graphically [Borning86]. Several systems permit users to define new classes of constraints by filling in cell equations in a spreadsheet [Lewis90] <ref> [Hudson90b] </ref> [Myers91a]. The technique introduced here infers constraints from a fixed set of classes that have proven useful for graphical editing. The inference mechanism determines constants in the constraint equations, but it does not synthesize new classes of equations.
Reference: [Hudson91] <author> Hudson, Scott E., and Yeatts, Andrey K. </author> <title> Smoothly Integrating Rule-Based Techniques into a Direct Manipulation Interface Builder. </title> <booktitle> In Proceedings of UIST 91 (Hil-ton Head, </booktitle> <address> SC, </address> <month> November 11-13). </month> <booktitle> ACM, </booktitle> <address> New York, </address> <year> 1991. </year> <pages> 145-153. </pages>
Reference-contexts: If MatchTool 2 cannot solve the system, it prints a message and the user can either undo the replacement or manually remove the unwanted constraints. Recent research has dealt with merging rule-based techniques into direct manipulation systems <ref> [Hudson91] </ref> [Karsenty92]. Constraint-based search and replace is a direct manipulation technique for defining rules that govern the geometry and placement of graphical objects.
Reference: [Jernigan88] <author> Jernigan, Ginger. </author> <title> QuickDraws Internal Picture Definition. </title> <type> Macintosh Technical Note #21. </type> <institution> Apple Computer. </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Again, a protocol must be agreed upon between the editors sending and receiving the media element; here that protocol is the PICT data format <ref> [Jernigan88] </ref>. Using Apples Publish and Subscribe protocol, multiple media editors can automatically notify one another of document changes [Meadow91].
Reference: [Johnson88] <author> Johnson, Jeff, and Beach, Richard J. </author> <title> Styles in Document Editing Systems. </title> <booktitle> In Computer 21, </booktitle> <month> 1 (January </month> <year> 1988). </year> <pages> 32-43. </pages>
Reference-contexts: Grouping is a technique for associating multiple objects together so they can be manipulated and modified together, which is also a motivating factor for styles. Johnson and Beach outline the history of style rules, and survey a set of design issues to be considered when building a style mechanism <ref> [Johnson88] </ref>. <p> Function definitions in Lilac replace style rules in more conventional editors. Modifying the formatting information in the body of a function reformats all of the corresponding structure elements in the page view. One of the design issues discussed in <ref> [Johnson88] </ref> is which structural elements should be associated with styles. In most editors with style rules, rules can be applied to only a few object elements, such as characters and structure element definition; (b) an invocation of this structure element; (c) The resulting formatted text. (a) (c) 37 paragraphs.
Reference: [Joy79] <author> Joy, William. </author> <title> An Introduction to the C Shell. In UNIX Programmers Manual, Seventh Edition, Third Berkeley UNIX Distribution. </title> <institution> Dept. of EE & CS, University of California, Berkeley, </institution> <year> 1979. </year>
Reference-contexts: Since users of these applications invoke commands by typing text at a keyboard, this text makes a natural record of the users interactions. Both the UNIX TM C Shell <ref> [Joy79] </ref>, and the Doskey facility of MS-DOS [Microsoft91a] support this history representation. With the advent of graphical user interfaces, application designers explored other means of representing command sequences.
Reference: [Joy80a] <author> Joy, William. </author> <title> Ex Reference Manual, </title> <note> version 3.5/2.13, </note> <month> September </month> <year> 1980. </year> <title> Revised by Mark Horton. In UNIX Users Manual Supplementary Documents, </title> <booktitle> published by USENIX Association. </booktitle> <month> December </month> <year> 1984 </year> <month> 215 </month>
Reference-contexts: The vi/ex editor has commands to advance the cursor to the next paragraph or section, as determined by a string search for particular troff macros <ref> [Joy80a] </ref>. Since troff is itself extensible, the editor has user options to declare which macros are relevant. 2.1.4.2 Grouping and instancing The two mechanisms discussed next appear most frequently in graphical editors, though they are relevant to others as well.
Reference: [Joy80b] <author> Joy, William. </author> <title> An Introduction to Display Editing with Vi. </title> <month> September </month> <year> 1980. </year> <title> Revised by Mark Horton. In UNIX Users Manual Supplementary Documents, </title> <booktitle> published by USENIX Association. </booktitle> <month> December </month> <year> 1984. </year>
Reference-contexts: Though this is especially true of TECO, which is a full programming language with loops and conditionals, users of ed also need to remember a command syntax, including command names, arguments, and separators. Other editors, such as sam [Pike87] and vi <ref> [Joy80b] </ref>, provide a command interpreter to supplement the screen editing capabilities of the editor.
Reference: [Karsenty92] <author> Karsenty, Solange, Landay, James A., and Weikart, Chris. </author> <title> Inferring Graphical Constraints with Rockit. </title> <booktitle> In HCI 92 Conference on People and Computers VII (Sep-tember 1992). </booktitle> <publisher> British Computer Society. Cambridge University Press, </publisher> <address> Cambridge, England. </address> <pages> 137-153. </pages>
Reference-contexts: If MatchTool 2 cannot solve the system, it prints a message and the user can either undo the replacement or manually remove the unwanted constraints. Recent research has dealt with merging rule-based techniques into direct manipulation systems [Hudson91] <ref> [Karsenty92] </ref>. Constraint-based search and replace is a direct manipulation technique for defining rules that govern the geometry and placement of graphical objects.
Reference: [Kernighan78] <author> Kernighan, Brian W. </author> <title> A Tutorial Introduction to the UNIX Text Editor. </title> <month> September </month> <year> 1978. </year> <title> Available in UNIX Users Manual Supplementary Documents, </title> <booktitle> published by USENIX Association. </booktitle> <month> December </month> <year> 1984. </year>
Reference: [Kosbie90] <author> Kosbie, David S., Vander Zanden, Brad, Myers, Brad A., and Giuse, Dario. </author> <title> Automatic Graphical Output Management. </title> <booktitle> In The Garnet Compendium: Collected Papers, </booktitle> <pages> 1989-1990. </pages> <editor> Brad A. Myers, </editor> <title> ed. </title> <type> Technical Report CMU-CS-90-154. CMU. </type> <institution> School of Computer Science. </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: All objects in Chimera belong to a scene, be they widgets in a control panel, or graphical shapes in an editor buffer. This is similar to Garnets retained object model <ref> [Kosbie90] </ref>. Chimera checks whether all objects in a panel belong to the same scene. If they do not, it allocates multiple subpanels, each of which receives objects from a 148 single scene.
Reference: [Kurlander88a] <author> Kurlander, David, and Bier, Eric. A. </author> <title> Graphical Search and Replace. </title> <booktitle> Proceedings of SIGGRAPH 88 (Atlanta, </booktitle> <address> Georgia, </address> <month> August 1-5, </month> <year> 1988). </year> <booktitle> In Computer Graphics 22, </booktitle> <month> 4 (August </month> <year> 1988). </year> <pages> 113-120. </pages>
Reference-contexts: Many of the ideas presented in Chapter 3 also appear in a SIGGRAPH paper <ref> [Kurlander88a] </ref>, though the text and many of the examples differ. Chapter 4 derives from a CHI paper [Kurlander92a]. The material in Chapter 5 will soon appear in ACM Transactions on Graphics [Kurlander93d]. Elements of editable graphical histories have been described in [Kurlander88b], [Kurlander90], [Kurlander91] and [Kurlander93b].
Reference: [Kurlander88b] <author> Kurlander, David, and Feiner, Steven. </author> <title> Editable Graphical Histories. </title> <booktitle> In 1988 IEEE Workshop on Visual Languages (Pittsburgh, </booktitle> <address> PA, </address> <month> October 10-12, </month> <title> 1988). </title> <publisher> IEEE Press. </publisher> <month> 127-134. </month> <title> Reprinted in Visual Programming Environments: Applications and Issues. </title> <editor> E.P. Glinert, ed. </editor> <publisher> IEEE Press, Los Alamitos, </publisher> <address> CA. </address> <year> 1990. </year> <pages> 416-423. </pages>
Reference-contexts: Chapter 4 derives from a CHI paper [Kurlander92a]. The material in Chapter 5 will soon appear in ACM Transactions on Graphics [Kurlander93d]. Elements of editable graphical histories have been described in <ref> [Kurlander88b] </ref>, [Kurlander90], [Kurlander91] and [Kurlander93b]. Some of the material from Chapter 7 appears in [Kurlander92b]. <p> / 2 Add Line - 1 / 4 Scale - 4 / 2 Copy - 0 / 1 Translate - 0 / 2 Copy - 1 / 1 Translate - 0 / 2 (a) 153 This history was generated in 1988, and it represents Chimeras initial implementation of graphical histories <ref> [Kurlander88b] </ref>. As in the current histories, related operations were coalesced into panels. For example, the first panel pair contains several Add-Line operations, as well as operations to move the cursor. Each label contains two numbers, indicating the number of operations represented in the prologue and epilogue. <p> Now changes can be made directly in the panels themselves, and users can execute a command to propagate these changes into the history stream. Though editable graphical histories were initially developed with the intention of using them as a visual representation for macros by example <ref> [Kurlander88b] </ref>, we postponed implementing this capability until the individual panels could be made editable. Having editable panels allows object and property arguments to be selected directly in the panels, and permits macros to be edited in place.
Reference: [Kurlander89] <author> Kurlander, David. </author> <title> Editor Extensibility: Domains and Mechanisms. </title> <type> Technical Report CUCS-516-89. </type> <institution> Columbia University, Computer Science. </institution> <month> May </month> <year> 1989. </year>
Reference: [Kurlander90] <author> Kurlander, David and Feiner, Steven. </author> <title> A Visual Language for Browsing, Undoing, and Redoing Graphical Interface Commands. In Visual Languages and Visual Programming, </title> <editor> Shi-Kuo Chang, ed. </editor> <publisher> Plenum Press, </publisher> <address> New York. </address> <year> 1990. </year> <pages> 257-275. </pages>
Reference-contexts: Chapter 4 derives from a CHI paper [Kurlander92a]. The material in Chapter 5 will soon appear in ACM Transactions on Graphics [Kurlander93d]. Elements of editable graphical histories have been described in [Kurlander88b], <ref> [Kurlander90] </ref>, [Kurlander91] and [Kurlander93b]. Some of the material from Chapter 7 appears in [Kurlander92b]. <p> These tags are examined by the renderer to determine what style should be used to draw the objects. This represents the state of the histories in 1989, and these histories are further discussed in <ref> [Kurlander90] </ref>. This technique was employed in producing the history panels of Figure 6.9 to make the important objects in each panel stand out.
Reference: [Kurlander91] <author> Kurlander, David and Feiner, Steven. </author> <title> Editable Graphical Histories: The Video. SIGGRAPH Video Review. </title> <booktitle> Issue 63. 1991. Abstracted in CHI 91 Conference Proceedings (New Orleans, </booktitle> <address> LA, </address> <month> April 27- May 2, </month> <year> 1991). </year> <pages> 451-452. </pages>
Reference-contexts: Chapter 4 derives from a CHI paper [Kurlander92a]. The material in Chapter 5 will soon appear in ACM Transactions on Graphics [Kurlander93d]. Elements of editable graphical histories have been described in [Kurlander88b], [Kurlander90], <ref> [Kurlander91] </ref> and [Kurlander93b]. Some of the material from Chapter 7 appears in [Kurlander92b].
Reference: [Kurlander92a] <author> Kurlander, David and Feiner, Steven. </author> <title> Interactive Constraint-Based Search and Replace. </title> <booktitle> In CHI 92 Conference Proceedings (Monterey, </booktitle> <address> CA, </address> <month> May 3-7, </month> <year> 1992). </year> <booktitle> ACM, </booktitle> <address> New York. </address> <pages> 609-618. </pages>
Reference-contexts: Many of the ideas presented in Chapter 3 also appear in a SIGGRAPH paper [Kurlander88a], though the text and many of the examples differ. Chapter 4 derives from a CHI paper <ref> [Kurlander92a] </ref>. The material in Chapter 5 will soon appear in ACM Transactions on Graphics [Kurlander93d]. Elements of editable graphical histories have been described in [Kurlander88b], [Kurlander90], [Kurlander91] and [Kurlander93b]. Some of the material from Chapter 7 appears in [Kurlander92b].
Reference: [Kurlander92b] <author> Kurlander, David, and Feiner, Steven. </author> <title> A History-Based Macro by Example System. </title> <booktitle> In Proceedings of UIST 92 (Monterey, </booktitle> <address> CA, </address> <month> November 15-18). </month> <booktitle> ACM, </booktitle> <address> New York, </address> <year> 1992. </year> <month> 99-106. </month> <title> Reprinted in Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 323-338. 216 </pages>
Reference-contexts: Chapter 4 derives from a CHI paper [Kurlander92a]. The material in Chapter 5 will soon appear in ACM Transactions on Graphics [Kurlander93d]. Elements of editable graphical histories have been described in [Kurlander88b], [Kurlander90], [Kurlander91] and [Kurlander93b]. Some of the material from Chapter 7 appears in <ref> [Kurlander92b] </ref>.
Reference: [Kurlander93a] <author> Kurlander, David. </author> <title> Chimera: Example-Based Graphical Editing. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 271-290. </pages>
Reference-contexts: The material in Chapter 5 will soon appear in ACM Transactions on Graphics [Kurlander93d]. Elements of editable graphical histories have been described in [Kurlander88b], [Kurlander90], [Kurlander91] and [Kurlander93b]. Some of the material from Chapter 7 appears in [Kurlander92b]. Even part of this introduction is included in <ref> [Kurlander93a] </ref>. 20 21 Chapter 2 Related Work Ignore the rennets swinging to and fro, grab a cup of mead, and consider the wisdom of the fields sages, many of whom, thanks to the relative newness of the subject, have only moderately long beards and mildly shriveled skin.
Reference: [Kurlander93b] <author> Kurlander, David, and Feiner, Steven. </author> <title> A History of Editable Graphical Histories. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 405-413. </pages>
Reference-contexts: Chapter 4 derives from a CHI paper [Kurlander92a]. The material in Chapter 5 will soon appear in ACM Transactions on Graphics [Kurlander93d]. Elements of editable graphical histories have been described in [Kurlander88b], [Kurlander90], [Kurlander91] and <ref> [Kurlander93b] </ref>. Some of the material from Chapter 7 appears in [Kurlander92b].
Reference: [Kurlander93c] <author> Kurlander, David. </author> <title> Graphical Editing by Example: A Demonstration. Videotape. SIGGRAPH Video Review. </title> <booktitle> Issue 89. 1993. Abstracted in INTERCHI 93 Conference Proceedings (Amsterdam, </booktitle> <address> The Netherlands, April 24 - 29, </address> <year> 1993). </year> <month> 529. </month>
Reference-contexts: All figures in this dissertation were generated by the PostScript output of Chimera, and each figure depicting a demonstration of a technique was generated by the system running on a real example. A videotape is also available, showing an interactive demonstration of these techniques in Chimera <ref> [Kurlander93c] </ref>. 1.4.1 Graphical Search and Replace Often shapes are repeated many times in a single illustration. Similarly, many illustrations contain the same graphical properties, such as particular fill colors or line styles, repeated multiple times.
Reference: [Kurlander93d] <author> Kurlander David, and Feiner, Steven. </author> <title> Inferring Constraints from Multiple Snapshots. </title> <journal> ACM Transactions on Graphics 12, </journal> <volume> 4. </volume> <month> (October </month> <year> 1993). </year> <note> Pages to be determined. </note>
Reference-contexts: Many of the ideas presented in Chapter 3 also appear in a SIGGRAPH paper [Kurlander88a], though the text and many of the examples differ. Chapter 4 derives from a CHI paper [Kurlander92a]. The material in Chapter 5 will soon appear in ACM Transactions on Graphics <ref> [Kurlander93d] </ref>. Elements of editable graphical histories have been described in [Kurlander88b], [Kurlander90], [Kurlander91] and [Kurlander93b]. Some of the material from Chapter 7 appears in [Kurlander92b].
Reference: [Lamport86] <author> Lamport, Leslie. </author> <title> LaTeX Users Guide and Reference Manual. </title> <address> Addison-Wes-ley, Reading, MA. </address> <year> 1986. </year>
Reference-contexts: During program composition, abbreviation expansion and templates work together in Tioga to accelerate the construction of Cedar programs. Many Cedar keywords are defined as abbreviations, which expand into templates for the language constructs that they initiate. BibTeX, the bibliography database tool for LaTeX <ref> [Lamport86] </ref>, has two BibTeX modes written for GNU Emacs to provide template support for its many reference types [Chen88] [Martensson88]. Because equation formatting, like equations themselves, tends to be formulaic, interactive equation editing is an application that is wellsuited for templates.
Reference: [Lee83] <author> Lee, Kunwoo. </author> <title> Shape Optimization of Assemblies Using Geometric Properties. </title> <type> Ph.D. Thesis. </type> <institution> MIT. Mechanical Engineering. </institution> <month> December </month> <year> 1983. </year>
Reference-contexts: Many approaches have been taken to solve these limitations. The first problem was addressed by Lee, who built a system to construct a set of constraint equations automatically for a database of geometric shapes <ref> [Lee83] </ref>. In doing so, he worked with a restricted class of mutually orthogonal constraints, and required that the geometric shapes be aligned with the coordinate axes. Lees problem domain and assumptions restricted the set of constraints such that there was never any ambiguity about which to select.
Reference: [Letraset87] <author> Letraset USA. </author> <title> Ready, Set, Go! 4.0 Users Guide. </title> <address> ISBN 0-944289-01-0. 40 Eisenhower Dr., Paramus NJ 07653. </address> <year> 1987. </year>
Reference-contexts: Also, abbreviation expansion usually suffices, which effectively includes a library plus an automatic instantiation facility. Some editors, such as Ready, Set, Go! <ref> [Letraset87] </ref>, have text libraries called glossaries which bind text to be inserted to command characters, thus accelerating the lookup process. ClickPaste, a product for the Macintosh, allows both text and graphics to be placed in hierarchical menus, which provide fast access to library objects [Mainstay91]. <p> In contrast, layout templates specify complete layouts, usually with auxiliary information, such as font styles and sizes to be used. Fewer electronic page layout editors offer grids than templates, perhaps because they require more effort and experience to use; although some systems, such as Ready, Set, Go! support them <ref> [Letraset87] </ref>. 2.1.2.5 Customizable style properties Many style properties, such as line pattern and fill color, have a vast range of potential values. <p> [ B e a ch 8 5] , Pa g e Ma k er [Al d u s9 0] , Fr a m e Ma ke r [Fr a m e 90 ] , Mi c r oso f t W o rd [Microsoft91b], EZ [Palay88], and Ready, Set, Go! <ref> [Letraset87] </ref>. 2.1.5 Media Extensibility Multimedia editing systems integrate such disparate objects as text, illustrations, scanned images, voice, and spreadsheets.
Reference: [Levine83] <author> Levine, Martin D. </author> <title> Vision in Man and Machine, Chapter 10, </title> <publisher> McGraw Hill, </publisher> <address> New York, New York. </address> <year> 1983. </year>
Reference-contexts: The curve matching techniques discussed in this section were developed particularly for this task, though existing curve matching research is relevant, and could perhaps accelerate some of our searches [Pavlidis78] <ref> [Levine83] </ref>. Searching a graphical scene is also related to making queries on a graphical database, and other researchers have examined this topic [Weller76] [Palermo80] [Chang89]. Graphical search and replace has a number of additional applications, aside from making mundane coherent changes.
Reference: [Lewis88] <author> Lewis, Bil. </author> <title> GNU Emacs Lisp Manual. </title> <type> 2nd Draft. </type> <month> September </month> <year> 1988. </year> <note> Final version to be distributed by the Free Software Foundation. </note>
Reference-contexts: Extensible command interpreters include a language construct enabling new commands to be defined. GNU Emacs, for example, provides a full Lisp interpreter whereby new commands can be defined and subsequently invoked as though they were primitives <ref> [Lewis88] </ref>. Though this interpreter can be employed by the end user to launch commands, it primarily serves as a language for programming editor extensions. Section 2.1.3.3 describes extension languages in greater detail.
Reference: [Lewis90] <author> Lewis, C. NoPumpG: </author> <title> Creating Interactive Graphics with Spreadsheet Machinery. In Visual Programming Environments: Paradigms and Systems. </title> <editor> E.P. Glinert, ed. </editor> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA. </address> <year> 1990. </year> <pages> 526-546. </pages>
Reference-contexts: For example, Bornings ThingLab allows new constraint classes to be defined using graphical techniques [Borning86], and several recent systems allow new constraints to be entered via spreadsheets <ref> [Lewis90] </ref> [Hudson90b] [Myers91a]. If the system designers cannot foresee every constraint that may be necessary, they clearly cannot provide for every transformation rule based on these constraints. Search and replace is also a particularly easy way to add constraints to similar sets of objects. <p> One of Bornings ThingLab implementations allowed new types of constraints to be defined and viewed graphically [Borning86]. Several systems permit users to define new classes of constraints by filling in cell equations in a spreadsheet <ref> [Lewis90] </ref> [Hudson90b] [Myers91a]. The technique introduced here infers constraints from a fixed set of classes that have proven useful for graphical editing. The inference mechanism determines constants in the constraint equations, but it does not synthesize new classes of equations.
Reference: [Lieberman84] <author> Lieberman, Henry. </author> <title> Seeing What Your Programs are Doing. </title> <journal> International Journal of Man-Machine Studies 21, </journal> <year> (1984). </year> <pages> 311-331. </pages>
Reference-contexts: His programming aid, called Tinker <ref> [Lieberman84] </ref> [Lieberman86] [Lieberman93a] allows people to develop Lisp code as they manipulate real data. Tinker is especially useful in developing graphics programs, since it displays the effects of graphics commands interactively. The Tinker workspace consists of five windows, as shown in Figure 2.3.
Reference: [Lieberman86] <author> Lieberman, Henry. </author> <title> An Example Based Environment for Beginning Programmers. </title> <booktitle> In Instructional Science 14, </booktitle> <year> (1986) </year> <month> 277-292. </month>
Reference-contexts: His programming aid, called Tinker [Lieberman84] <ref> [Lieberman86] </ref> [Lieberman93a] allows people to develop Lisp code as they manipulate real data. Tinker is especially useful in developing graphics programs, since it displays the effects of graphics commands interactively. The Tinker workspace consists of five windows, as shown in Figure 2.3. <p> Representing commands in text-based systems tends to be easier, since the textual commands themselves form a convenient representation. Tinker, a text-based programming by example facility, has a textual audit-trail of steps used in constructing procedures <ref> [Lieberman86] </ref>. To edit the demonstrated procedure, the user can either textually edit these steps or the resulting Lisp procedure. Tweedle, a graphical editor with both a WYSIWYG view and a textual code view, allows procedures to be generated in both views [Asente87].
Reference: [Lieberman93a] <author> Lieberman, Henry. Tinker: </author> <title> A Programming by Demonstration System for Beginning Programmers. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 49-64. </pages>
Reference-contexts: His programming aid, called Tinker [Lieberman84] [Lieberman86] <ref> [Lieberman93a] </ref> allows people to develop Lisp code as they manipulate real data. Tinker is especially useful in developing graphics programs, since it displays the effects of graphics commands interactively. The Tinker workspace consists of five windows, as shown in Figure 2.3.
Reference: [Lieberman93b] <author> Lieberman, Henry. Mondrian: </author> <title> A Teachable Graphical Editor. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 341-358. 217 </pages>
Reference-contexts: Metamouse works in the command extensibility domain, and the turtle can be taught to perform some surprisingly complex tasks, such as sorting rectangles by height. 2.2.8 Mondrian Henry Liebermans Mondrian is also a graphical editor with a programming by example component <ref> [Lieberman93b] </ref>. It was built concurrently with Chimeras macro by example facility, and uses a visual representation inspired in part by Chimeras editable graphical histories. Mondrian provides a storyboard of screen miniatures, showing the changing state of the display during editing. <p> The Mondrian graphical editor also dynamically builds panels to present a history, but Mondrians panels are uneditable screen miniatures, and do not yet participate in many phases of macro definition <ref> [Lieberman93b] </ref>. Most of the programming by example systems discussed thus far have special operations to start and stop recording events. In our system, operations are always being recorded by an undo/redo mechanism.
Reference: [Mainstay91] <author> Mainstay. ClickPaste: </author> <title> The One-Click-Per-Paste Intelligent Scrapbook. version 2.1. </title> <address> 5311B Derry Avenue, Agoura Hills, CA 91301. </address> <year> 1991. </year>
Reference-contexts: ClickPaste, a product for the Macintosh, allows both text and graphics to be placed in hierarchical menus, which provide fast access to library objects <ref> [Mainstay91] </ref>. The objects can be pasted into any editor. Several companies sell object libraries oriented toward particular domains. Such libraries for CAD systems include graphics for mechanical and electrical engineering, residential and commercial architecture, and other purposes. Libraries of illustrations, called clip art, are available for draw and paint programs.
Reference: [Makkuni87] <author> Makkuni, Ranjit. </author> <title> A Gestural Representation of the Process of Composing Chinese Temples. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 7, 12. </volume> <month> (December </month> <year> 1987). </year> <pages> 45-61. </pages>
Reference-contexts: In Makkunis Chinese temple editor, architects share a design history represented as a sequence of icons. The system provides an additional record of the design process by showing component editors for the various steps, connected by threads relating their use <ref> [Makkuni87] </ref>. This chapter describes editable graphical histories, a new representation for histories in a graphical user interface. Editable graphical histories are based on a comic strip metaphor, depicting important events in the history of the interface within a sequence of panels.
Reference: [Martensson88] <author> Martensson, Bengt. </author> <title> Simple BibTeX Mode for GNU Emacs. As modified by Marc Shapiro and Michael Elhadad. </title> <year> 1988. </year>
Reference-contexts: Many Cedar keywords are defined as abbreviations, which expand into templates for the language constructs that they initiate. BibTeX, the bibliography database tool for LaTeX [Lamport86], has two BibTeX modes written for GNU Emacs to provide template support for its many reference types [Chen88] <ref> [Martensson88] </ref>. Because equation formatting, like equations themselves, tends to be formulaic, interactive equation editing is an application that is wellsuited for templates.
Reference: [Maulsby89a] <author> Maulsby, David L., Witten, Ian H., and Kittlitz, Kenneth A. Metamouse: </author> <title> Specifying Graphical Procedures by Example. </title> <booktitle> Proceedings of SIGGRAPH 89 (Boston, </booktitle> <address> MA, July 31-August 4, </address> <year> 1989). </year> <booktitle> In Computer Graphics 23, </booktitle> <month> 4 (July </month> <year> 1989). </year> <pages> 127-136. </pages>
Reference-contexts: The system infers how each of the components should appear, including their ordering, the presentation of the author names, and their typesetting characteristics. The system then automatically creates formatted bibliography entries for other references in the database. 2.2.7 Metamouse David Maulsbys Metamouse system <ref> [Maulsby89a] </ref> [Maulsby89b] [Maulsby93a] provides a macro by example capability for graphical editors. Metamouse works in conjunction with A.sq, a simple graphical editor that manipulates lines and boxes. The editor has a special teaching mode in which an iconic turtle jumps to the cursor location between commands. <p> Constraint rules have been used by several researchers in human-computer interaction. Weitzmans Designer was supplied with a set of rules to enforce design goals [Weitz-man86]. Peridots rules, written in Interlisp, infer geometric constraints among objects in an interface editor. Maulsbys Metamouse graphical editor infers graphical procedures by demonstration <ref> [Maulsby89a] </ref>. Each program step is associated with a set of preconditions and postconditions to be met, which can include touch constraints. Vander Zanden developed a method of specifying graphical applications using constraint grammars to isolate the visual display from the data structures [Vander Zanden89]. <p> However, a single example often contains insufficient information to infer many desired constraints. This chapter describes another component of Chimera that uses multiple examples to support the constraint inferencing process. Maulsbys Metamouse <ref> [Maulsby89a] </ref> induces graphical procedures by example, and infers constraints to be solved at every program step. To make the task more tractable, he considers only touch constraints in the vicinity of an iconic turtle that the user teaches to perform the desired task.
Reference: [Maulsby89b] <author> Maulsby, David L. </author> <title> Inducing Procedures Interactively: Adventures with Metamouse. </title> <type> Masters Thesis. </type> <institution> University of Calgary. Department of Computer Science. </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: The system infers how each of the components should appear, including their ordering, the presentation of the author names, and their typesetting characteristics. The system then automatically creates formatted bibliography entries for other references in the database. 2.2.7 Metamouse David Maulsbys Metamouse system [Maulsby89a] <ref> [Maulsby89b] </ref> [Maulsby93a] provides a macro by example capability for graphical editors. Metamouse works in conjunction with A.sq, a simple graphical editor that manipulates lines and boxes. The editor has a special teaching mode in which an iconic turtle jumps to the cursor location between commands.
Reference: [Maulsby93a] <author> Maulsby, David L. and Witten, Ian H. Metamouse: </author> <title> An Instructible Agent for Programming by Demonstration. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 155-181. </pages>
Reference-contexts: The system infers how each of the components should appear, including their ordering, the presentation of the author names, and their typesetting characteristics. The system then automatically creates formatted bibliography entries for other references in the database. 2.2.7 Metamouse David Maulsbys Metamouse system [Maulsby89a] [Maulsby89b] <ref> [Maulsby93a] </ref> provides a macro by example capability for graphical editors. Metamouse works in conjunction with A.sq, a simple graphical editor that manipulates lines and boxes. The editor has a special teaching mode in which an iconic turtle jumps to the cursor location between commands. <p> If people use this technique to establish precise geometric relationships during normal editing, then they would probably use it, without additional thought, while demonstrating a macro. In Metamouse, users construct tools in order to make positioning operations explicit <ref> [Maulsby93a] </ref>. In Chimera, alignment lines act as tools, though users can also build tools by hand. Alignment lines appear to have several advantages over tools constructed out of ordinary scene objects: 1. Alignment lines have been shown to be useful in ordinary editing.
Reference: [Maulsby93b] <author> Maulsby, David. </author> <title> The Turvy Experience: Simulating an Instructible User Interface. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 239-269. </pages>
Reference-contexts: By pointing with a mouse, people can easily select particular object instances, while speech better communicates abstractions. 2.2.9 Turvy Like Mondrian, David Maulsbys Turvy experiment uses speech and graphical interaction together to synthesize a procedure by demonstration <ref> [Maulsby93b] </ref>. Turvy is actually a Wizard of Oz experiment, meaning that a human being plays the role of the computer during the tests, to gather human-interaction data without the cost of building an actual implementation.
Reference: [Meadow91] <author> Meadow, Tony. </author> <title> System 7 Revealed. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address> <year> 1991. </year>
Reference-contexts: Again, a protocol must be agreed upon between the editors sending and receiving the media element; here that protocol is the PICT data format [Jernigan88]. Using Apples Publish and Subscribe protocol, multiple media editors can automatically notify one another of document changes <ref> [Meadow91] </ref>.
Reference: [Microsoft91a] <author> Microsoft Corporation. </author> <title> Microsoft MS-DOS Users Guide and Reference. version 5.0. Part No. 070-00367 from Gateway 2000. </title> <type> 610 Gateway Dr., </type> <institution> North Sioux City, SD 57049. </institution> <year> 1991. </year>
Reference-contexts: Since users of these applications invoke commands by typing text at a keyboard, this text makes a natural record of the users interactions. Both the UNIX TM C Shell [Joy79], and the Doskey facility of MS-DOS <ref> [Microsoft91a] </ref> support this history representation. With the advent of graphical user interfaces, application designers explored other means of representing command sequences. In these interfaces, users can invoke commands through mouse operations and keyboard accelerators, and they may be unaware of the textual command names.
Reference: [Microsoft91b] <author> Microsoft Corporation. </author> <title> Microsoft Word for Windows Users Guide. version 2.0. Part No. 32756. One Microsoft Way, </title> <address> Redmond WA 98052. </address> <year> 1991. </year>
Reference-contexts: modern formatter/editors have style support, including Tioga [ B e a ch 8 5] , Pa g e Ma k er [Al d u s9 0] , Fr a m e Ma ke r [Fr a m e 90 ] , Mi c r oso f t W o rd <ref> [Microsoft91b] </ref>, EZ [Palay88], and Ready, Set, Go! [Letraset87]. 2.1.5 Media Extensibility Multimedia editing systems integrate such disparate objects as text, illustrations, scanned images, voice, and spreadsheets.
Reference: [Microsoft92] <author> Microsoft Corporation. </author> <title> Object Linking and Embedding: OLE 2 Design Specification. </title> <type> Draft. </type> <note> Version 2.00.09. </note> <month> September </month> <year> 1992. </year>
Reference-contexts: Using Apples Publish and Subscribe protocol, multiple media editors can automatically notify one another of document changes [Meadow91]. This capability is also present in Microsofts OLE 2.0 system, which permits multiple media classes to be embedded and edited within the same window <ref> [Microsoft92] </ref>. 2.2 Experimental Systems for Editing by Example This section describes nine research systems that use novel demonstrational techniques to facilitate editing of either textual or graphical documents. 2.2.1 Juno Greg Nelsons Juno graphical editor, like the systems described in the next two sections, is a two-view editor [Nelson85].
Reference: [Modugno93] <author> Modugno, Francesmary, and Myers, Brad. A. </author> <title> Graphical Representation and Feedback in a PBD System. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 415-422. </pages>
Reference-contexts: Lieberman would like to add support for conditionals and recursion in Mondrian, and extend the panel representation to include diverse flow of control. Francesmary Modugno at Carnegie Mellon University is building a programming by demonstration system for a graphical shell <ref> [Modugno93] </ref>. The visual representation for these programs resembles editable graphical histories, but it is more abstract and it displays generalizations within the panels themselves. Modugno also plans to incorporate flow of control within the visual representation.
Reference: [Mller-Brockmann81] <author> Mller-Brockmann, J. </author> <title> Grid Systems in Graphic Design. </title> <publisher> Verlag Arthur Niggli, </publisher> <address> Niederteufen, Switzerland, </address> <year> 1981. </year> <title> Translated by D. </title> <type> Stephenson. </type>
Reference: [Myers86] <author> Myers, Brad A., and Buxton, William. </author> <title> Creating Highly Interactive and Graphical User Interfaces by Demonstration. </title> <booktitle> Proceedings of SIGGRAPH 86 (Dallas, </booktitle> <address> Texas, </address> <month> August 18-22, </month> <year> 1986). </year> <booktitle> In Computer Graphics 20, </booktitle> <month> 4 (August </month> <year> 1986). </year> <pages> 249-268. 218 </pages>
Reference-contexts: the three main contributions of his work to be the use of data descriptions to specify intent, the conclusion that some operations are better added after a program has been demonstrated, and the evidence that programming by example has practical use in commercial systems. 2.3.4 Peridot Brad Myers Peridot system <ref> [Myers86] </ref> [Myers88] [Myers93] allows the construction of virtual interaction devices by demonstration. Such devices include menus, scroll bars, buttons, and other widgets often found in user interface toolkits. Interface designers work with Peridots graphical editor to create and position the components of the interaction devices, and demonstrate their interactive behavior. <p> However, people defining a new object class must still instantiate all the constraints to include in their class definition or prototype. Constraints from multiple snapshots can help with this task. One of the innovations of Myerss Peridot <ref> [Myers86] </ref> [Myers88] is a component that infers constraints automatically as objects are added to the scene. A rule base determines which relationships are sought, and when a match is found the user is asked to confirm or deny the constraint explicitly.
Reference: [Myers88] <author> Myers, Brad A. </author> <title> Creating User Interfaces by Demonstration. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: three main contributions of his work to be the use of data descriptions to specify intent, the conclusion that some operations are better added after a program has been demonstrated, and the evidence that programming by example has practical use in commercial systems. 2.3.4 Peridot Brad Myers Peridot system [Myers86] <ref> [Myers88] </ref> [Myers93] allows the construction of virtual interaction devices by demonstration. Such devices include menus, scroll bars, buttons, and other widgets often found in user interface toolkits. Interface designers work with Peridots graphical editor to create and position the components of the interaction devices, and demonstrate their interactive behavior. <p> Pavli-dis and Van Wyks illustration beautifier searches for certain relationships, such as nearly aligned lines or nearly coincident vertices, and enforces these relationships precisely [Pavlidis85]. Myers Peridot uses a rule set to find particular relationships between pairs of scene objects and establish new constraints among them <ref> [Myers88] </ref>. The system described here differs from these in that the constraint rules can be defined by the systems users, thereby providing a powerful new form of editor extensibility. Rules are defined by direct manipulation [Shneiderman83], using the same techniques that are used for editing ordinary scenes. <p> This chapter describes a new technique for inferring constraints from multiple valid configurations of a scene. Geometric constraints are used extensively in computer graphics in the specification of relationships between graphical objects [Sutherland63a] [Borning79] <ref> [Myers88] </ref> [Olsen90]. They are useful during object construction to position components relative to one another precisely, as well as during subsequent manipulation of the components. <p> However, people defining a new object class must still instantiate all the constraints to include in their class definition or prototype. Constraints from multiple snapshots can help with this task. One of the innovations of Myerss Peridot [Myers86] <ref> [Myers88] </ref> is a component that infers constraints automatically as objects are added to the scene. A rule base determines which relationships are sought, and when a match is found the user is asked to confirm or deny the constraint explicitly. <p> As shown in the value in this same text field, and pressing the Apply-Arguments button. Alternatively, we can adjust the slider, and the value of Argument 1 changes accordingly. Myers presents a similar example of parameterizing scrollbar behavior in <ref> [Myers88] </ref>. His method linearly interpolates between two different constrained configurations, which is a more powerful abstraction, particularly for defining the behavior of widgets. For example, in Peridot the slider height can be parameterized with respect to the bottom and top of the scrollbar. <p> Peridot <ref> [Myers88] </ref> and Metamouse [Mauls-by89a] provide highlighting or feedback for individual program steps, however they depict a single step at a time with no visual representations for the complete procedures that they infer. A more comprehensive graphical representation would allow the user to quickly examine and edit any step. <p> In the latter case, the inferencing mechanism can be weaker, but in the former, the command set can often be reduced. Peridot has a special facility for inferring the geometric relationships between two objects <ref> [Myers88] </ref>. Chimera could be extended to allow the system designer or end user to define constraint-based search and replace patterns that specify arbitrary interesting geometric relationships to which Chimeras macro inferencing component should be sensitive. <p> Chimera might also plausibly raise the abstraction level higher by including a command specifically to create an object centered about another. 177 However, it would be unrealistic to expect Chimera to provide prefabricated commands for all high-level intentsthats the whole motivation behind macros! Also, as Myers points out in <ref> [Myers88] </ref>, implementing commands for many geometric positioning intents would result in a proliferation of commands for the user to memorize.
Reference: [Myers91a] <author> Myers, Brad A. </author> <title> Graphical Techniques in a Spreadsheet for Specifying User Interfaces. </title> <booktitle> In CHI 91 Conference Proceedings (New Orleans, </booktitle> <address> LA, </address> <month> April 27- May 2, </month> <year> 1991). </year> <pages> 243-249. </pages>
Reference-contexts: For example, Bornings ThingLab allows new constraint classes to be defined using graphical techniques [Borning86], and several recent systems allow new constraints to be entered via spreadsheets [Lewis90] [Hudson90b] <ref> [Myers91a] </ref>. If the system designers cannot foresee every constraint that may be necessary, they clearly cannot provide for every transformation rule based on these constraints. Search and replace is also a particularly easy way to add constraints to similar sets of objects. <p> One of Bornings ThingLab implementations allowed new types of constraints to be defined and viewed graphically [Borning86]. Several systems permit users to define new classes of constraints by filling in cell equations in a spreadsheet [Lewis90] [Hudson90b] <ref> [Myers91a] </ref>. The technique introduced here infers constraints from a fixed set of classes that have proven useful for graphical editing. The inference mechanism determines constants in the constraint equations, but it does not synthesize new classes of equations.
Reference: [Myers91b] <author> Myers, Brad A. </author> <title> Text Formatting by Demonstration. </title> <booktitle> In CHI 91 Conference Proceedings (New Orleans, </booktitle> <address> LA, </address> <month> April 27- May 2, </month> <year> 1991). </year> <pages> 251-256. </pages>
Reference-contexts: TELS can make overgeneralization and overspecialization mistakes, both of which can be corrected by presenting additional examples. 2.2.6 Tourmaline Tourmaline differs from the U editor and TELS in using demonstrational techniques to facilitate text formatting, rather than textual transformations <ref> [Myers91b] </ref>. Brad Myers system uses three techniques to achieve consistent formatting in a document. The first technique defines composite styles, multiple style elements appearing together, by demonstration. For example, a chapter header might include the string Chapter, a decorative rule, a chapter number, and a name.
Reference: [Myers92] <author> Myers, B. A. </author> <title> Demonstrational Interfaces: A Step Beyond Direct Manipulation. </title> <journal> IEEE Computer 25, </journal> <volume> 8. </volume> <month> (August </month> <year> 1992). </year> <pages> 61-73. </pages>
Reference-contexts: Hence, these methods are all example-based or demonstrational techniques <ref> [Myers92] </ref>, in which the user presents to the application an 3 example of the desired task, and the application uses this specification to perform similar tasks on other examples. Alternatively, the user could write a program to perform the desired repetition, but this has several disadvantages.
Reference: [Myers93] <author> Myers, Brad. A. Peridot: </author> <title> Creating User Interfaces by Demonstration. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 125-153. </pages>
Reference-contexts: main contributions of his work to be the use of data descriptions to specify intent, the conclusion that some operations are better added after a program has been demonstrated, and the evidence that programming by example has practical use in commercial systems. 2.3.4 Peridot Brad Myers Peridot system [Myers86] [Myers88] <ref> [Myers93] </ref> allows the construction of virtual interaction devices by demonstration. Such devices include menus, scroll bars, buttons, and other widgets often found in user interface toolkits. Interface designers work with Peridots graphical editor to create and position the components of the interaction devices, and demonstrate their interactive behavior.
Reference: [Nelson85] <author> Nelson, Greg. Juno, </author> <title> A Constraint-Based Graphics System. </title> <booktitle> Proceedings of SIGGRAPH 85 (San Francisco, </booktitle> <address> CA, </address> <month> July 22-26, </month> <year> 1985). </year> <booktitle> In Computer Graphics 19, </booktitle> <month> 3 (July </month> <year> 1985). </year> <pages> 235-243. </pages>
Reference-contexts: Bier points out that graphical relationships involving multiple points are often difficult to specify with grids [Bier86]. The ability to create custom grids increases the relationships that can be expressed; however, two other techniques, snap-dragging [Bier86] and constraints <ref> [Nelson85] </ref> have greater expressive power. The former technique uses compass and ruler constructs, called alignment objects, to precisely specify geometric 28 positioning relationships. The latter allows the specification of high-level geometric relationships to be maintained as the illustration is modified. <p> same window [Microsoft92]. 2.2 Experimental Systems for Editing by Example This section describes nine research systems that use novel demonstrational techniques to facilitate editing of either textual or graphical documents. 2.2.1 Juno Greg Nelsons Juno graphical editor, like the systems described in the next two sections, is a two-view editor <ref> [Nelson85] </ref>. Juno provides a WYSIWYG graphical view of an illustration, and a source view that contains a procedural description. Users can define procedures demonstrationally by executing direct manipulation commands in the graphical view, which generates code in the procedural view. Changes made to either view propagate to the other. <p> Constraint-based search and replace has neither of these limitations. Nelsons Juno allows constraints to be added either in a WYSIWYG view or a program view, resulting in a procedure that can be parameterized and applied to other objects <ref> [Nelson85] </ref>. Constraint-based search and replace rules are implicit procedures that are specified through a direct manipulation interface. The procedures are parameterized through the search portion of the rule, which also specifies the criteria that an object must 85 match to be a valid argument. <p> A number of systems provide visual representations of constraints to facilitate debugging. Sutherlands Sketchpad connected constrained vertices together with lines accompanied by a symbol indicating the constraint. Nelsons Juno, a two-view graphical editor, provided a program view of constraints <ref> [Nelson85] </ref>. Peridot communicated constraints as English language fragments during confirmation, and Metamouse used buttons for confirming and prioritizing constraints. The OPUS interface editor represented constraints between interface components as arrows connecting hierarchical frames or drafting lines [Hudson90a]. Our technique never requires that its users work with individual, low-level constraints. <p> Each constraint in the scrolling list can be selected, and this activates its graphical representation in the editor scene. The Juno editor has graphical and textual representations of constraints as well, with the textual representations being procedures <ref> [Nelson85] </ref>. Since graphical constraint presentations quickly become cluttered as the displayed constraint set grows, it is important to allow constraints to be displayed selectively. The last section described how the ConstraintTool interface allowed us to convert a rectangle to a square, an inch on a side.
Reference: [Nix83] <author> Nix, Robert Peter. </author> <title> Editing by Example. </title> <type> Ph.D. Thesis. </type> <institution> Yale University. Department of Computer Science. </institution> <note> Research Report 280. </note> <month> August </month> <year> 1983. </year>
Reference-contexts: In both systems, function definitions specify structural elements, and invocations declare instances of those elements. 2.2.4 The U Editor Robert Nix built an editing by example component for the U text editor to automate repetitive textual transformations <ref> [Nix83] </ref>. His system takes examples of text sequences to be found, and examples of how they should be changed, and synthesizes a procedure to find similar text and make similar changes. <p> For example, the following is a gap program: ( -1 ) q -2- -3- . fi -1- -2- -3- . , where gaps are identified by -n- (n is an integer, and -1- is the first gap) and q represents the space character <ref> [Nix83] </ref>. This program finds all telephone numbers of the form (212) 3169369. and changes them to the form 2123169369..
Reference: [Olsen88] <author> Olsen, Dan. R. Jr., and Dance, J. R. </author> <title> Macros by Example in a Graphical UIMS. </title> <booktitle> Computer Graphics and Applications 8, </booktitle> <month> 1 (January </month> <year> 1988). </year> <pages> 68-78. </pages>
Reference-contexts: However, to edit a procedure, the user must be able to understand the code view. In the MIKE UIMS, graphical macros can also be defined by demonstration <ref> [Olsen88] </ref>. In this system macros can be defined and edited largely in demonstration mode, but the visual representation of graphical commands is textual. A programming by example component of SmallStar, a subset of the Star user interface, adopts a mixed text and iconic representation for macros [Halbert84].
Reference: [Olsen90] <author> Olsen, Dan R., Jr., and Allan, Kirk. </author> <title> Creating Interactive Techniques by Symbolically Solving Geometric Constraints. </title> <booktitle> In Proceedings of UIST 90 (Snowbird, </booktitle> <address> Utah, Octo-ber 3-5). </address> <publisher> ACM, </publisher> <address> New York, </address> <year> 1990. </year> <pages> 102-107. </pages>
Reference-contexts: This chapter describes a new technique for inferring constraints from multiple valid configurations of a scene. Geometric constraints are used extensively in computer graphics in the specification of relationships between graphical objects [Sutherland63a] [Borning79] [Myers88] <ref> [Olsen90] </ref>. They are useful during object construction to position components relative to one another precisely, as well as during subsequent manipulation of the components.
Reference: [Palay88] <author> Palay, Andrew J., Wilfred, Hansen J., Sherman, Mark, Wadlow, Maria G., Neu-endorffer, Thomas P., Stern, Zalman, Bader, Miles, and Peters, Thom. </author> <title> The Andrew Tool-kitAn Overview. </title> <booktitle> USENIX Winter 1988 Conference Proceedings, </booktitle> <month> February </month> <year> 1988. </year> <pages> 9-21. </pages>
Reference-contexts: have style support, including Tioga [ B e a ch 8 5] , Pa g e Ma k er [Al d u s9 0] , Fr a m e Ma ke r [Fr a m e 90 ] , Mi c r oso f t W o rd [Microsoft91b], EZ <ref> [Palay88] </ref>, and Ready, Set, Go! [Letraset87]. 2.1.5 Media Extensibility Multimedia editing systems integrate such disparate objects as text, illustrations, scanned images, voice, and spreadsheets. <p> In contrast, weakly integrated media editors each run in their own window as separate processes, with no single, uniform interface. The Diamond Editor [Crowley87], originally built for a multimedia message system [Thomas85], the EZ editor of the Andrew Toolkit <ref> [Palay88] </ref>, and Quill [Chamberlin88] are all strongly integrated multimedia editors. In each of these, the editors framework determines which media elements interact with each other and the general editor services.
Reference: [Palermo80] <author> Palermo, Frank, and Weller, Dan. </author> <title> Some Database Requirements for Pictorial Applications (Florence, </title> <address> Italy, </address> <month> June </month> <year> 1979). </year> <title> Edited by A. Blaser. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> 81. </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany. </address> <year> 1980. </year>
Reference-contexts: Searching a graphical scene is also related to making queries on a graphical database, and other researchers have examined this topic [Weller76] <ref> [Palermo80] </ref> [Chang89]. Graphical search and replace has a number of additional applications, aside from making mundane coherent changes. Graphical search and replace can serve as a tool for constructing repetitive, recursive shapes defined by graphical grammars.
Reference: [Pavlidis78] <author> Pavlidis, Theo. </author> <title> A Review of Algorithms for Shape Analysis. </title> <booktitle> Computer Graphics and Image Processing 7, </booktitle> <month> 2 (April </month> <year> 1978). </year> <pages> 243-258. </pages>
Reference-contexts: The curve matching techniques discussed in this section were developed particularly for this task, though existing curve matching research is relevant, and could perhaps accelerate some of our searches <ref> [Pavlidis78] </ref> [Levine83]. Searching a graphical scene is also related to making queries on a graphical database, and other researchers have examined this topic [Weller76] [Palermo80] [Chang89]. Graphical search and replace has a number of additional applications, aside from making mundane coherent changes.
Reference: [Pavlidis85] <author> Pavlidis, Theo and Van Wyk, Christopher J. </author> <title> An Automatic Beautifier for Drawings and Illustrations. </title> <booktitle> Proceedings of SIGGRAPH 85 (San Francisco, </booktitle> <address> CA, </address> <month> July 22-26, </month> <year> 1985). </year> <booktitle> In Computer Graphics 19, </booktitle> <month> 3 (July </month> <year> 1985). </year> <pages> 225-234. </pages>
Reference-contexts: Several other systems use automatic constraint generation for scene beautification. Pavli-dis and Van Wyks illustration beautifier searches for certain relationships, such as nearly aligned lines or nearly coincident vertices, and enforces these relationships precisely <ref> [Pavlidis85] </ref>. Myers Peridot uses a rule set to find particular relationships between pairs of scene objects and establish new constraints among them [Myers88]. <p> They are useful during object construction to position components relative to one another precisely, as well as during subsequent manipulation of the components. Several graphical techniques, such as grids, snap-dragging [Bier86] and automatic beautification <ref> [Pavlidis85] </ref> were developed to make the initial construction phase easier, since specifying constraints explicitly can be a complex task. However, when objects are to be manipulated frequently, permanent constraints have an advantage over these other techniques in that they need not be reapplied. <p> relationships between objects in these constructions tend to be unidirectional, and procedures for every dependency need to be demonstrated. 106 The difficulty inherent in understanding interactions among multiple constraints and debugging large constraint networks has been addressed by the snap-dragging interaction technique [Bier86] [Bier88] and by an automatic illustration beautifier <ref> [Pavlidis85] </ref>. In snap-dragging, individual constraint solutions are isolated temporally from one another, so that their interaction cannot confuse the artist. The automatic beautifier infers a set of constraints sufficient to neaten a drawing, but the constraints are solved once and discardedthey are isolated temporally from subsequent user-interaction.
Reference: [Paxton87] <author> Paxton, Bill. </author> <title> The Tioga Editor. </title> <note> Internal memo. Xerox PARC Computer Sciences Laboratory. 1984, updated in 1985 and 1987. 219 </note>
Reference-contexts: Expansions in Emacs and Tioga can retain the capitalization of the document text, and in Tioga, formatting information can be inherited either from the document text or specified in the expansion definition. Tiogas command-based macros can also be included in this definition, to be executed after finishing the expansion <ref> [Paxton87] </ref>. An additional GNU Emacs facility, called dynamic abbreviation expansion, uses the buffer contents in lieu of explicit abbreviation definitions to determine expansions. If the expansion is not appropriate, the user can cycle 26 through other words in the document which begin the same way, and select the appropriate one. <p> Xerox PARCs Bravo, the first WYSIWYG text editor, did not have this capability, but Bravos successor, Tioga, has a powerful search and replace utility called the EditTool, which can search on multiple properties <ref> [Paxton87] </ref>. However, graphical editors have traditionally had other mechanisms for making coherent changes easy. In systems that provide instancing, such as Sutherlands Sketchpad editor, all instantiations of a master or library object can be changed by manipulating the master.
Reference: [Pier83] <author> Pier, Kenneth A. </author> <title> A Retrospective on the Dorado, a High-Performance Personal Computer. </title> <booktitle> Proceedings of the 10th Symposium on Computer Architecture. SIGARCH/ IEEE, </booktitle> <address> (Stockholm, Sweden, </address> <month> June </month> <year> 1983). </year> <pages> 252-269. </pages>
Reference-contexts: In the process of studying graphical search and replace, we have built two implementations of a utility called MatchTool. The original MatchTool, hereby referred to as Match-Tool 1, was implemented during the summer of 1987 at Xerox PARCs Computer Sciences Laboratory. MatchTool 1 runs on Dorado workstations <ref> [Pier83] </ref> under the Cedar Environment [Swinehart86]. It works in conjunction with the Gargoyle graphical editor [Bier86] [Pier88]. A videotape of MatchTool 1 appears in [Bier89]. In some ways, Match-Tool 1s interface was patterned after Tiogas textual search and replace utility, the EditTool.
Reference: [Pier88] <author> Pier, Ken, Bier, Eric, and Stone, Maureen. </author> <title> An Introduction to Gargoyle: An Interactive Illustration Tool. Document Manipulation and Typography, </title> <editor> J. C. van Vliet (ed.), </editor> <publisher> Cambridge University Press, </publisher> <year> 1988. </year> <booktitle> Proceedings of the EP 88 International Conference on Electronic Publishing Document Manipulation and Typography, </booktitle> <address> Nice, France, </address> <month> April 20-22, </month> <year> 1988. </year> <pages> 223-238. </pages>
Reference-contexts: Most of the editor is written in Lisp, but C procedures handle some numerically intensive components and communicate with Chimeras PostScript procedures that process input events, manipulate windows and widgets, and perform graphics output. Portions of Chimeras interface were inspired by GNU Emacs [Stallman87], and the Gargoyle Illustrator <ref> [Pier88] </ref>. From Emacs, Chimera borrows keymaps, a minibuffer for text-based commands, a Lisp-based extension language (Common Lisp though, instead of ELisp), the default text command bindings, and multiple editor modes. Chimeras graphics mode takes snap-dragging [Bier86] and many of its commands from Gargoyle. <p> The original MatchTool, hereby referred to as Match-Tool 1, was implemented during the summer of 1987 at Xerox PARCs Computer Sciences Laboratory. MatchTool 1 runs on Dorado workstations [Pier83] under the Cedar Environment [Swinehart86]. It works in conjunction with the Gargoyle graphical editor [Bier86] <ref> [Pier88] </ref>. A videotape of MatchTool 1 appears in [Bier89]. In some ways, Match-Tool 1s interface was patterned after Tiogas textual search and replace utility, the EditTool. It was hoped that people already familiar with the EditTool would find Match-Tool 1 easy to learn.
Reference: [Pike87] <author> Pike, Rob. </author> <title> The text editor sam. </title> <journal> Software Practice and Experience 17, </journal> <month> 11 (November </month> <year> 1987). </year> <pages> 813-845. </pages>
Reference-contexts: Though this is especially true of TECO, which is a full programming language with loops and conditionals, users of ed also need to remember a command syntax, including command names, arguments, and separators. Other editors, such as sam <ref> [Pike87] </ref> and vi [Joy80b], provide a command interpreter to supplement the screen editing capabilities of the editor.
Reference: [Potter93a] <author> Potter, Richard. </author> <title> Triggers: Guiding Automation with Pixels to Achieve Data Access. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 361-380. </pages>
Reference-contexts: These tests also show that users are often able to learn to work with Eager with no instruction whatsoever. 2.3.6 Triggers Richard Potter built Triggers to investigate the possibility of adding programming by example to existing applications and environments not developed to work with such a facility <ref> [Potter93a] </ref>. One difficulty that he faced was that of accessing application data existing applications often provide no protocol for making their data available to programming by example systems. Furthermore those applications that can share their data provide varying interfaces for accessing this information, and have different data formats.
Reference: [Potter93b] <author> Potter, Richard, and Maulsby, David. </author> <title> A Test Suite for Programming by Demonstration. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 539-591. </pages>
Reference-contexts: Applied to the N of application of our rounding rule. (This figure has been reduced.) (a) (b) 96 4.10 Example 4: Wrapping Rounded Rectangles Around Text This section presents one approach to automating a task posed by Richard Potter and David Maulsby in their Programming by Demonstration Test Suite <ref> [Potter93b] </ref>. While using MacDraw II, a member of Richards lab found it a chore to wrap rounded rectangles around the many text fields in a graphical document. Each rectangle had to be centered around the text, a fixed amount larger than the string it enclosed.
Reference: [Press88] <author> Press, William H., Flannery, Brian P., Teukolsky, Saul A., and Vetterling, Will-iam T. </author> <title> Numerical Recipes in C: </title> <booktitle> The Art of Scientific Computing. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1988. </year>
Reference-contexts: This allows constraint-based replacements to add objects to the scene. 4.12 Implementation Chimera uses Levenberg-Marquadt iteration to solve systems of constraints <ref> [Press88] </ref>. This method uses gradient descent when far from a solution, but switches to the inverse Hessian method to converge quadratically when a solution is near. Levenberg-Marquadt is a least-squares method. <p> Part of the Levenberg-Marquadt method requires solving a system of equations to determine how the current solution estimate should change. If the error functions are not mutually independent (which is the case with redundant constraints), the system cannot be solved using Gaussian elimination. Instead, we use singular value decomposition <ref> [Press88] </ref> to find a solution at this step. In looking for absolute and relative relations in the scene, it is important to build tolerances into the matching process.
Reference: [Rubine91] <author> Rubine, Dean. </author> <title> Specifying Gestures by Example. </title> <booktitle> Proceedings of SIGGRAPH 91 (Las Vegas, </booktitle> <address> NV, July 28-August 2, </address> <year> 1991). </year> <booktitle> In Computer Graphics 25, </booktitle> <month> 4 (July </month> <year> 1991). </year> <pages> 329-337. </pages>
Reference-contexts: In a graphical editor it is typically harder to enter a precise shape that can be interpreted unambiguously as a particular abbreviation. Gestures in some interfaces provide elements of this function <ref> [Rubine91] </ref>. Abbreviation expansion is an elaborate form of search and replace, usually employing multiple replacement rules. When a more sophisticated abbreviation facility is not available, a sequence of search and replace operations can be used for abbreviation expansion.
Reference: [Sankoff83] <author> Sankoff, David, and Kruskal, Joseph B. </author> <title> Time Warps, String Edits, and Macromolecules: The Theory and Practice of Sequence Comparison. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA. </address> <year> 1983. </year>
Reference-contexts: MatchTool would benefit from an inexact shape matching metric that much more closely matches that of the human visual system. As an experiment in improving this component of MatchTool, we built a system for matching runs of curves using the minimal cost stringedit algorithm <ref> [Sankoff83] </ref>. A run of curves can be discretized into a one dimensional string, with characters representing directions. The similarity of two runs can be compared by calculating the cost of editing one string into the other. Burr used a similar approach for handdrawn character recognition [Burr79].
Reference: [Shneiderman83] <author> Shneiderman, Ben. </author> <title> Direct Manipulation: A Step Beyond Programming Languages. </title> <booktitle> IEEE Computer 16, </booktitle> <month> 8 (August </month> <year> 1983). </year> <pages> 57-69. </pages>
Reference-contexts: The system described here differs from these in that the constraint rules can be defined by the systems users, thereby providing a powerful new form of editor extensibility. Rules are defined by direct manipulation <ref> [Shneiderman83] </ref>, using the same techniques that are used for editing ordinary scenes. Furthermore, users can view the constraint rules graphically, in the same visual language as the rest of the editor interface. As will be described later in this paper, simple demonstrational techniques help in defining these rules.
Reference: [Smith77] <author> Smith, David Canfield. Pygmalion: </author> <title> A Computer Program to Model and Stimulate Creative Thought. </title> <publisher> Birkhauser, Verlag, </publisher> <address> Basel, Stuttgart. </address> <year> 1977. </year> <booktitle> Reprint of 1975 Stan-ford Computer Science Ph.D. thesis. </booktitle>
Reference-contexts: This section describes six systems that take an innovative approach to programming by example outside of the editing domain. 2.3.1 Pygmalion David C. Smiths Pygmalion is the granddaddy of all programming by example systems, and inspired much of the subsequent research in the field <ref> [Smith77] </ref> [Smith93]. Smith built Pygmalion as an alternative to traditional noninteractive, abstract programming languages. People using Pygmalion construct programs by drawing pictorial, analogic representations of the computation, using real sample data. In Pygmalion, programmers construct movies of their functions computations.
Reference: [Smith78] <author> Smith, Alvy Ray. </author> <month> Paint. </month> <institution> NYIT Computer Graphics Lab Technical Memo No. 7, Old Westbury, </institution> <address> NY, </address> <month> July 20, </month> <year> 1978. </year> <note> Also available in Beatty, </note> <editor> J. and Booth, K. (eds.), </editor> <booktitle> IEEE Tutorial: Computer Graphics, 2nd Edition. </booktitle> <address> Silver Spring, MD: </address> <publisher> IEEE Computer Society Press. </publisher> <year> 1982. </year> <pages> 501-515. </pages>
Reference-contexts: In these systems, the application can be scrolled forwards and/or backwards in time, and the user infers the history by examining the changing state of the application canvas. Alvy Ray Smiths PAINT program had this capability <ref> [Smith78] </ref>. Applications with undo and redo commands, like GNU Emacs [Stallman87], provide a type of temporal reexecution by 133 allowing the user to step through the history by hand, viewing the results of each command.
Reference: [Smith82] <author> Smith, David Canfield, Irby, Charles, Kimball, Ralph, Harslem, Eric. </author> <title> Designing the Star User Interface. </title> <journal> Byte 7, </journal> <volume> 4. </volume> <month> (April </month> <year> 1982). </year> <pages> 242-287. 220 </pages>
Reference-contexts: Examples of programs that Tinker has assisted in generating include an alphabeta search implementation and a pong video game. 2.3.3 SmallStar The Star user interface pioneered the desktop metaphor as a means of manipulating and interacting with files on a computer system <ref> [Smith82] </ref>. A small prototype version of this interface had been built called SmallStar, and for his doctoral thesis, Daniel Halbert devised a mechanism for programming this system by example [Halbert84] [Halbert93]. To begin defining a program, the user either invokes a StartRecording command, or opens a program icon.
Reference: [Smith84] <author> Smith, Alvy Ray. </author> <title> Plants, </title> <booktitle> Fractals, and Formal Languages. Proceedings of SIG-GRAPH 84 (Minneapolis, </booktitle> <address> Minnesota, </address> <month> July 23-27, </month> <year> 1984). </year> <booktitle> In Computer Graphics 18, </booktitle> <month> 3 (July </month> <year> 1984). </year> <pages> 1-10. </pages>
Reference-contexts: The result appears in Figure 3.18c. Though graphical grammars were not used to build the maple tree of Figure 3.3, they could have been used for this purpose. Smith studied the use of grammars (or graftals) to generate plants <ref> [Smith84] </ref>, and Bloomenthal developed an interesting approach to modeling 3D maple trees without grammars [Bloomenthal85].
Reference: [Smith93] <author> Smith, David Canfield. Pygmalion: </author> <title> An Executable Electronic Blackboard. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA. </address> <year> 1993. </year> <pages> 19-47. </pages>
Reference-contexts: This section describes six systems that take an innovative approach to programming by example outside of the editing domain. 2.3.1 Pygmalion David C. Smiths Pygmalion is the granddaddy of all programming by example systems, and inspired much of the subsequent research in the field [Smith77] <ref> [Smith93] </ref>. Smith built Pygmalion as an alternative to traditional noninteractive, abstract programming languages. People using Pygmalion construct programs by drawing pictorial, analogic representations of the computation, using real sample data. In Pygmalion, programmers construct movies of their functions computations. <p> Pygmalion uses temporal reexecution to animate visual programming steps applied to new data, though not to represent the actual programming history <ref> [Smith93] </ref>. A disadvantage of temporal reexecution is that only a single step in the history can be displayed at once.
Reference: [Stallman84] <author> Stallman, Richard M. </author> <title> EMACS: The Extensible, Customizable, Self-Documenting Display Editor. In Interactive Programming Environments, </title> <editor> David Barstow, Howard Shrobe, and Eric Sandewall, ed. </editor> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: In the days before menus and mice, the keyboard was the source of all input events. Some screen editors with their roots in the days before workstation technology became popular, such as Emacs <ref> [Stallman84] </ref> and VAXTPU [Digital86b], rely on translation tables to associate key sequences with commands. These are called keymaps. Newer systems, such as 24 the Diamond Multimedia Editor [Crowley87], designed from the outset to accept other forms of graphical input, also use this mechanism for dispatching on keyboard events. <p> Emacs is so named because it was intended to be a set of Editing MACroS for the TECO editor. Richard Stall-man later wrote that Emacs is a misnomer because his editor was implemented as a set of functions in the TECO language <ref> [Stallman84] </ref>, yet the TECO manual refers only to macros, never functions [Digital80]. 2.1.3.3 Command programming The only way to give an editor radically new functionality is through programming. All of the techniques for extensibility discussed in this chapter rely on existing mechanisms to provide their extensibility. <p> The Andrew EZ editor can dynamically load compiled C extensions, although some criticize the process as being too awkward for spur-of-the moment customizations [Borenstein88]. An editor in the Emacs family, called SINE, dynamically loads extensions in a compiled Lisp-like language <ref> [Stallman84] </ref>. VAXTPU, which has its own custom compiled extension language, can also load procedures dynamically. When designing an extensible editor, the system architect must also decide whether to choose an existing language for extensions.
Reference: [Stallman87] <author> Stallman, Richard. </author> <title> GNU Emacs Manual, Sixth Edition, Version 18. Free Software Foundation, </title> <address> Cambridge, MA. </address> <month> March </month> <year> 1987. </year>
Reference-contexts: Most of the editor is written in Lisp, but C procedures handle some numerically intensive components and communicate with Chimeras PostScript procedures that process input events, manipulate windows and widgets, and perform graphics output. Portions of Chimeras interface were inspired by GNU Emacs <ref> [Stallman87] </ref>, and the Gargoyle Illustrator [Pier88]. From Emacs, Chimera borrows keymaps, a minibuffer for text-based commands, a Lisp-based extension language (Common Lisp though, instead of ELisp), the default text command bindings, and multiple editor modes. Chimeras graphics mode takes snap-dragging [Bier86] and many of its commands from Gargoyle. <p> GNU Emacs stores syntax information such as word-constituent characters, opening and closing delim-iters (used for example in parenthesis and bracket matching), quote characters, whitespace, and comment delimiters in syntax tables <ref> [Stallman87] </ref>. The vi/ex editor has commands to advance the cursor to the next paragraph or section, as determined by a string search for particular troff macros [Joy80a]. <p> In these systems, the application can be scrolled forwards and/or backwards in time, and the user infers the history by examining the changing state of the application canvas. Alvy Ray Smiths PAINT program had this capability [Smith78]. Applications with undo and redo commands, like GNU Emacs <ref> [Stallman87] </ref>, provide a type of temporal reexecution by 133 allowing the user to step through the history by hand, viewing the results of each command. Pygmalion uses temporal reexecution to animate visual programming steps applied to new data, though not to represent the actual programming history [Smith93]. <p> Systems with a macro by example or programming by example component generate code automatically in response to tasks demonstrated by the user through the applications own interface. These systems make the benefits of extensibility accessible to the entire user community. Many applications, such as GNU Emacs <ref> [Stallman87] </ref>, have a macro by example facility, but lack a visual representation for the macros. Without a visual representation, it is diffi I respond to three questions, stated the augur.
Reference: [Stiny75] <author> Stiny, George. </author> <title> Pictorial and Formal Aspects of Shape and Shape Grammars. </title> <publisher> Birkhauser, Verlag, </publisher> <address> Basel, Switzerland. </address> <year> 1975. </year>
Reference-contexts: Typically these graphical properties include shape. Shape grammars, a class of graphical grammars in which shapes form all the terminals and nonterminals, have been explored by others [Gips75] <ref> [Stiny75] </ref>. Graphical search and replace provides a convenient mechanism for generating pictures formed by graphical grammars. Examples of such illustrations are the snowflake curves presented in Figure 3.7.
Reference: [Sutherland63a] <author> Sutherland, Ivan E. </author> <title> Sketchpad, A Man-Machine Graphical Communication System. </title> <type> Ph.D. Thesis. </type> <institution> MIT. Electrical Engineering. </institution> <month> January </month> <year> 1963. </year>
Reference-contexts: Thus multiple instances of an object may appear in a document, but changes to the original effectively propagate to each. Ivan Sutherlands Sketchpad system, the earliest interactive drawing system, included this mechanism <ref> [Sutherland63a] </ref>. 2.1.4.3 Styles In the publishing world, style specifications have long been used to promote consistency of form within and among documents. Styles used in document editing programs support this same goal, but also reduce the effort to change all appearances of a logical component. <p> This chapter describes a new technique for inferring constraints from multiple valid configurations of a scene. Geometric constraints are used extensively in computer graphics in the specification of relationships between graphical objects <ref> [Sutherland63a] </ref> [Borning79] [Myers88] [Olsen90]. They are useful during object construction to position components relative to one another precisely, as well as during subsequent manipulation of the components. <p> Lees problem domain and assumptions restricted the set of constraints such that there was never any ambiguity about which to select. In our domain the initial ambiguity is unavoidable, and we rely on multiple examples to converge to the desired constraint set. Systems like Sketchpad <ref> [Sutherland63a] </ref> [Sutherland63b] and ThingLab [Borning79] make it easier to add large numbers of constraints to a scene, by allowing users to define new classes of objects that include the constraints that operate on them as part of the definition.
Reference: [Sutherland63b] <author> Sutherland, Ivan E. </author> <title> Sketchpad: A Man-Machine Graphical Communication System. </title> <booktitle> AFIPS Conference Proceedings, Spring Joint Computer Conference. </booktitle> <year> 1963. </year> <pages> 329-346. </pages>
Reference-contexts: If the system designers cannot foresee every constraint that may be necessary, they clearly cannot provide for every transformation rule based on these constraints. Search and replace is also a particularly easy way to add constraints to similar sets of objects. Sutherlands Sketchpad <ref> [Sutherland63b] </ref> introduced instancing to facilitate the same task. Instancing, though an extremely useful technique with its own benefits, requires that the user know, prior to object instantiation, the types of constraints that will be used. <p> Lees problem domain and assumptions restricted the set of constraints such that there was never any ambiguity about which to select. In our domain the initial ambiguity is unavoidable, and we rely on multiple examples to converge to the desired constraint set. Systems like Sketchpad [Sutherland63a] <ref> [Sutherland63b] </ref> and ThingLab [Borning79] make it easier to add large numbers of constraints to a scene, by allowing users to define new classes of objects that include the constraints that operate on them as part of the definition.
Reference: [Swinehart86] <author> Swinehart, Daniel C., Zellweger, Polle Z., Beach, Richard J. and Hagmann, Robert B. </author> <title> A Structural View of the Cedar Programming Environment. </title> <type> Xerox PARC Technical Report CSL-86-1. </type> <address> 3333 Coyote Hill Rd., Palo Alto, CA 94304. </address> <month> June </month> <year> 1986. </year>
Reference-contexts: As part of its presentation component, the Cedar environment includes a Terminal Interface Package (TIP) that acts as a lexical analyzer, reading input events such as those directly generated by the keyboard and mouse, turning these events into higher-level tokens such as DELETE and DOREPLACE <ref> [Swinehart86] </ref>. These tokens pass in turn to a notifier that maps them to appropriate procedures. <p> The original MatchTool, hereby referred to as Match-Tool 1, was implemented during the summer of 1987 at Xerox PARCs Computer Sciences Laboratory. MatchTool 1 runs on Dorado workstations [Pier83] under the Cedar Environment <ref> [Swinehart86] </ref>. It works in conjunction with the Gargoyle graphical editor [Bier86] [Pier88]. A videotape of MatchTool 1 appears in [Bier89]. In some ways, Match-Tool 1s interface was patterned after Tiogas textual search and replace utility, the EditTool.
Reference: [Symbolics86] <author> Symbolics, Inc. </author> <title> Text Editing and Processing. Volume 3 of Genera 7.0 Documentation. </title> <type> 4 New England Tech. </type> <institution> Center, </institution> <address> 555 Virginia Rd., Concord, MA 01742. </address> <month> July </month> <year> 1986. </year>
Reference-contexts: Existing languages frequently have utilities such as source-level debuggers and profilers, and often an entire environment to support the programming process. When extension languages are custom written for an editor, these important tools are neglected more often than not. Environments such as that of the Lisp Machine <ref> [Symbolics86] </ref>, Smalltalk, and Cedar [Teitelman84], all allow extensions to be coded in their host language. Editors employing existing languages for extensions need only supply a programming interface. 2.1.4 Document Structure Extensibility Documents typically have several different types of structure.
Reference: [Teitelman84] <author> Teitelman, Warren. </author> <title> The Cedar Programming Environment: A Midterm Report and Examination. </title> <type> Xerox PARC Technical Report CSL-83-11. </type> <address> 3333 Coyote Hill Rd., Palo Alto, CA 94304. </address> <month> June </month> <year> 1984. </year>
Reference-contexts: When extension languages are custom written for an editor, these important tools are neglected more often than not. Environments such as that of the Lisp Machine [Symbolics86], Smalltalk, and Cedar <ref> [Teitelman84] </ref>, all allow extensions to be coded in their host language. Editors employing existing languages for extensions need only supply a programming interface. 2.1.4 Document Structure Extensibility Documents typically have several different types of structure.
Reference: [Thomas85] <author> Thomas, Robert H., Forsdick, Harry C., Crowley, Terrence R., Schaaf, Rich-ard W., Tomlinson, Raymond S., Travers, Virginia M. Diamond: </author> <title> A Multimedia Message System Built on a Distributed Architecture. </title> <journal> Computer, </journal> <volume> 18, </volume> <month> 12 (December </month> <year> 1985). </year> <pages> 65-78. </pages>
Reference-contexts: In contrast, weakly integrated media editors each run in their own window as separate processes, with no single, uniform interface. The Diamond Editor [Crowley87], originally built for a multimedia message system <ref> [Thomas85] </ref>, the EZ editor of the Andrew Toolkit [Palay88], and Quill [Chamberlin88] are all strongly integrated multimedia editors. In each of these, the editors framework determines which media elements interact with each other and the general editor services.
Reference: [Turransky93] <author> Turransky, Alan. </author> <title> Using Voice Input to Disambiguate Intent. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 457-464. </pages>
Reference: [Unilogic85] <author> Unilogic, Ltd. </author> <title> SCRIBE Document Production System User Manual. Fourth Edition. Suite 240, Commerce Court, 4 Station Square, </title> <address> Pittsburgh, PA 15219. </address> <month> June </month> <year> 1985. </year> <month> 221 </month>
Reference-contexts: The main program in Figure 2.2b contains a call to this function, and the result, as it appears in the formatted view, is given in Figure 2.2c. The idea of formatting a document with directives specifying logical structure rather than typesetting information was pioneered by Brian Reids Scribe system <ref> [Unilogic85] </ref>. Brooks contribution involves integrating this technique into a two-view editor, and providing interactive support for inserting structural instances into the page view. Lilac 36 permits either of the two views to be edited, and changes made to one automatically propagate to the other.
Reference: [Vander Zanden89] <author> Vander Zanden, B. T. </author> <title> Constraint GrammarsA New Model for Specifying Graphical Applications. </title> <booktitle> In CHI 89 Proceedings (Austin TX, </booktitle> <address> April 30-May 4, 1989). </address> <publisher> ACM, </publisher> <address> New York, </address> <year> 1989, </year> <pages> 325-330. </pages>
Reference-contexts: Each program step is associated with a set of preconditions and postconditions to be met, which can include touch constraints. Vander Zanden developed a method of specifying graphical applications using constraint grammars to isolate the visual display from the data structures <ref> [Vander Zanden89] </ref>. The second implementation of MatchTool, MatchTool 2, has a constraint-based search and replace feature that, like the other techniques described in these chapters, works in conjunction with the graphics and interface editing modes of the Chimera editor.
Reference: [Weitzman86] <author> Weitzman, L. </author> <title> DESIGNER: A Knowledge-Based Graphic Design Assistant. </title> <type> ICS Report 8609. </type> <institution> University of California, </institution> <address> San Diego. </address> <month> July </month> <year> 1986. </year>
Reference: [Weller76] <author> Weller, Dan, and Williams, Robin. </author> <title> Graphic and Relational Data Base Support for Problem Solving. </title> <booktitle> Proceedings of SIGGRAPH 76 (Philadelphia, </booktitle> <address> PA, </address> <month> July 14-16, </month> <year> 1976). </year> <booktitle> In Computer Graphics 10, 2 (Summer 1976). </booktitle> <pages> 183-189. </pages>
Reference-contexts: Searching a graphical scene is also related to making queries on a graphical database, and other researchers have examined this topic <ref> [Weller76] </ref> [Palermo80] [Chang89]. Graphical search and replace has a number of additional applications, aside from making mundane coherent changes. Graphical search and replace can serve as a tool for constructing repetitive, recursive shapes defined by graphical grammars.
Reference: [Witten93] <author> Witten, Ian H., and Mo, Dan H. TELS: </author> <title> Learning Text Editing Tasks From Examples. In Watch What I Do: Programming by Demonstration. </title> <editor> Allen Cypher, ed. </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address> <year> 1993. </year> <pages> 183-203. </pages>
Reference-contexts: synthesized by the system, and edit them directly if they have the expertise. 2.2.5 TELS Ian Witten and Dan Mo took a different approach in building a system for specifying textual transformations by demonstration, in that their editor, TELS, builds procedures from interaction traces rather than input and output pairs <ref> [Witten93] </ref>. Witten and Mo argue that synthesizing procedures from traces better allows exceptions in the transformation rules, and permits procedures to be learned from less regularly structured text.
References-found: 130

