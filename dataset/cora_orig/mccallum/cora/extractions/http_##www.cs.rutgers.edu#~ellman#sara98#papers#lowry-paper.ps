URL: http://www.cs.rutgers.edu/~ellman/sara98/papers/lowry-paper.ps
Refering-URL: http://www.cs.rutgers.edu/~ellman/sara98/papers/
Root-URL: http://www.cs.rutgers.edu
Phone: 269-2  
Title: Abstraction For Analytic Verification of Concurrent Software Systems  
Author: Michael Lowry and M. Subramaniam 
Address: Code IC, MS  Mofett Field, CA 94035  
Affiliation: 1 Computational Sciences Division,  NASA Ames Research Centre  
Abstract-found: 0
Intro-found: 0
Reference: 1. <author> R. E. Bryant, and Y.-A. Chen, </author> <title> "Verification of Arithmetic Circuits with Binary Moment Diagrams", </title> <booktitle> In 32nd ACM/IEEE Design Automation Conference (DAC) 1995. </booktitle>
Reference-contexts: Symbolic model checkers like SMV use canonical representations to represent the formulae denoting a state, a set of states, and the transition relation. These specialized representations include binary decision diagrams (BDD), and binary moment diagrams (BMD) <ref> [2, 1] </ref>. A BDD can be thought of as first a binary decision tree for a propositional formula where each horizontal level is a boolean variable and the left and right branches represent the true and false valuations of a boolean variable. <p> A lot of work has been done in combating the state explosion problem for hardware applications [4, 5, 6]. Several techniques such as symmetry reduction [18], partial-order red uction [9, 14] and symbolic encodings of states using representations such as BDDs, BMDs <ref> [17, 1, 2] </ref> have been considered. However, these techniques only work on finite models. They can not be applied in general to software systems, which typically use data types op erating on unbounded domains and hence have models which are not bounded in advance.
Reference: 2. <author> R. E. Bryant, </author> <title> "Graph-based algorithms for boolean function manipulation", </title> <journal> In IEEE Trans. on Computers, </journal> <volume> Vol. C-35, No. 8. </volume> <year> 1986. </year>
Reference-contexts: Symbolic model checkers like SMV use canonical representations to represent the formulae denoting a state, a set of states, and the transition relation. These specialized representations include binary decision diagrams (BDD), and binary moment diagrams (BMD) <ref> [2, 1] </ref>. A BDD can be thought of as first a binary decision tree for a propositional formula where each horizontal level is a boolean variable and the left and right branches represent the true and false valuations of a boolean variable. <p> A lot of work has been done in combating the state explosion problem for hardware applications [4, 5, 6]. Several techniques such as symmetry reduction [18], partial-order red uction [9, 14] and symbolic encodings of states using representations such as BDDs, BMDs <ref> [17, 1, 2] </ref> have been considered. However, these techniques only work on finite models. They can not be applied in general to software systems, which typically use data types op erating on unbounded domains and hence have models which are not bounded in advance.
Reference: 3. <author> J. J. Comuzzi and J. M. Hart, </author> <title> "Program Slicing using Weakest Preconditions", </title> <booktitle> in Proc. FME: Industrial Benefit and Advances in Formal Methods, 3rd Intl. Symposium , LNCS 1051, 1996. 4. 5th International Conference on Computer Aided Verification, </booktitle> <address> CAV-93, </address> <publisher> Springer Verlag LNCS 697. </publisher> <address> 5. </address> <booktitle> 6th International Conference on Computer Aided Verification, </booktitle> <address> CAV-94, </address> <publisher> Springer Verlag LNCS 818. </publisher> <address> 6. </address> <booktitle> 8th International Conference on Computer Aided Verification, </booktitle> <address> CAV-96, </address> <publisher> Springer Verlag LNCS 1102. </publisher>
Reference-contexts: We have shown how this approach can be extended to handle typical data concurrency and control abstrac-tions that frequently occur in software applications. The use of weakest preconditions for program slicing is also discussed in <ref> [3] </ref>. However, the approach described there is applicable only to sequential programs.
Reference: 7. <author> E.M.Clarke, O. Grumberg, D.E. </author> <title> Long , " Model Checking and Abstraction", </title> <booktitle> In Proc. of 19th ACM Symp. POPL 1992. </booktitle>
Reference-contexts: The mappings are then "lifted" to abstract program operations to generate an abstract model. The abstract model so constructed is conservative with respect to the branching temporal logic fragment ACTL (the universal fragment of computational tree logic) <ref> [7] </ref>. Furthermore, the abstract model is exact for all properties expressible in CTL*, if the domain mappings are a congruence with respect to program operations [7]. In the next section a brief overview of model checking is given. Section 4 discusses the proposed approach for model checking of software. <p> The abstract model so constructed is conservative with respect to the branching temporal logic fragment ACTL (the universal fragment of computational tree logic) <ref> [7] </ref>. Furthermore, the abstract model is exact for all properties expressible in CTL*, if the domain mappings are a congruence with respect to program operations [7]. In the next section a brief overview of model checking is given. Section 4 discusses the proposed approach for model checking of software. The use of weakest preconditions for performing control and data abstractions is described. <p> The second approach is based on generating a set of mappings over the domains of the variables of the program and automatically lifting the program operations to abstract program operations. This approach extends research by Clarke et. al on abstractions in <ref> [7] </ref>. The theory developed previously by [7] dealt only with homomor-phisms on the logical operators. Further, the domain mappings and the corresponding abstract logical operations are manually supplied that work. <p> The second approach is based on generating a set of mappings over the domains of the variables of the program and automatically lifting the program operations to abstract program operations. This approach extends research by Clarke et. al on abstractions in <ref> [7] </ref>. The theory developed previously by [7] dealt only with homomor-phisms on the logical operators. Further, the domain mappings and the corresponding abstract logical operations are manually supplied that work. <p> The second approach is more general and preserves truth values of the abstract model for more expressive class of properties including CTL and universally quantified fragment of CTL* <ref> [7] </ref>. 4.3 Generating Data Abstract Models Using Weakest Pre-Conditions The key idea in this approach is to identify a set of control predicates. The abstract model can then be regarded as recording the control predicate values as concrete transitions are executed. <p> The use of data abstraction in model checking to handle some limited types of infinite state systems are discussed in <ref> [19, 7, 10, 15] </ref>. In [19], Wolper uses the notion of data independence to transform certain temporal properties specified over infinite data values to equivalent properties specified over a finite domain. In [7], Clarke et. al, discuss how user defined abstractions can be used for model checking. <p> In [19], Wolper uses the notion of data independence to transform certain temporal properties specified over infinite data values to equivalent properties specified over a finite domain. In <ref> [7] </ref>, Clarke et. al, discuss how user defined abstractions can be used for model checking. However, no attempt is made there to automate the generation of abstractions. Two approaches that address aspects of automatic generation of abstractions are [15, 11].
Reference: 8. <author> A. Th. Eiriksson and K.L. Mcmillan, </author> <title> "Using formal verification/analyses methods on the critical path in system design : A case study," </title> <booktitle> In Proc. of Computer Aided Verification, </booktitle> <publisher> LNCS 939, Springer Verlag 1995. </publisher>
Reference-contexts: To use these tools in a runtime monitoring mode requires that they be made extremely computationally efficient. 3 Analytic Verification Approaches: Model Checking Model checking has proven very successful in debugging and verifying behavioral aspects of industrial-strength hardware applications and protocols <ref> [17, 8, 12] </ref>. This success can be largely attributed to the highly automated and algorithmic nature of model checking techniques that automate reasoning about error-prone concurrent applications.
Reference: 9. <author> P. Godfroid, </author> " <title> Using Partial Orders to improve automatic verification methods," </title> <booktitle> In Proc. of 2nd Workshop on Computer Aided Verification 1990. </booktitle>
Reference-contexts: A lot of work has been done in combating the state explosion problem for hardware applications [4, 5, 6]. Several techniques such as symmetry reduction [18], partial-order red uction <ref> [9, 14] </ref> and symbolic encodings of states using representations such as BDDs, BMDs [17, 1, 2] have been considered. However, these techniques only work on finite models.
Reference: 10. <author> S. Graf, </author> <title> "A tool for symbolic verification and abstraction," </title> <booktitle> in CAV93. </booktitle>
Reference-contexts: The use of data abstraction in model checking to handle some limited types of infinite state systems are discussed in <ref> [19, 7, 10, 15] </ref>. In [19], Wolper uses the notion of data independence to transform certain temporal properties specified over infinite data values to equivalent properties specified over a finite domain. In [7], Clarke et. al, discuss how user defined abstractions can be used for model checking.
Reference: 11. <author> S. Graf, H. Saidi, </author> " <title> Constructing Abstract Graphs Using PVS," </title> <booktitle> in CAV96. </booktitle>
Reference-contexts: The first one is based on the generation of an abstract model based on weakest preconditions and is an extension of the approach described in <ref> [11] </ref>. The second approach is based on generating a set of mappings over the domains of the variables of the program and automatically lifting the program operations to abstract program operations. This approach extends research by Clarke et. al on abstractions in [7]. <p> This approach extends research by Clarke et. al on abstractions in [7]. The theory developed previously by [7] dealt only with homomor-phisms on the logical operators. Further, the domain mappings and the corresponding abstract logical operations are manually supplied that work. The approach for performing data abstractions in <ref> [11] </ref> uses weakest preconditions to compute an abstract model from a program expressed in terms of a simple guarded command language. <p> Furthermore, the translation of applications from high level languages into such a formalism needs to carefully devised as naive translations may lead to state explosion. The main contribution of our work is first to extend the approach described in <ref> [11] </ref> to the richer control, data and concurrency constructs that occur in concurrent software applications. Second, we generate the abstract models compositionally in contrast to the approach in [11], where the application is always considered as a whole. This limits the ability of the approach in [11] to scale to large, <p> The main contribution of our work is first to extend the approach described in <ref> [11] </ref> to the richer control, data and concurrency constructs that occur in concurrent software applications. Second, we generate the abstract models compositionally in contrast to the approach in [11], where the application is always considered as a whole. This limits the ability of the approach in [11] to scale to large, complex applications. The extended approach is illustrated by generating an abstract model for the release property of the space controller resource manager verified in [12]. <p> the approach described in <ref> [11] </ref> to the richer control, data and concurrency constructs that occur in concurrent software applications. Second, we generate the abstract models compositionally in contrast to the approach in [11], where the application is always considered as a whole. This limits the ability of the approach in [11] to scale to large, complex applications. The extended approach is illustrated by generating an abstract model for the release property of the space controller resource manager verified in [12]. The basic assumptions underlying both these methods is the same. <p> In [7], Clarke et. al, discuss how user defined abstractions can be used for model checking. However, no attempt is made there to automate the generation of abstractions. Two approaches that address aspects of automatic generation of abstractions are <ref> [15, 11] </ref>. Jackson in [15] discusses how certain properties involving unbounded sets and predicates over such sets can be reduced to equivalent properties over bounded sets. In [11], the interactive theorem prover PVS is used to generate an abstract model. <p> Two approaches that address aspects of automatic generation of abstractions are [15, 11]. Jackson in [15] discusses how certain properties involving unbounded sets and predicates over such sets can be reduced to equivalent properties over bounded sets. In <ref> [11] </ref>, the interactive theorem prover PVS is used to generate an abstract model. However this approach is limited in terms of the data, control, and concurrency abstractions and in the size of the abstract model to be used for software applications.
Reference: 12. <author> K. Havelund, M. Lowry, and J. Penix, </author> " <title> Formal analysis of a space craft controller using Spin", </title> <institution> NASA Ames Research Center Technical Report, </institution> <year> 1997. </year>
Reference-contexts: The use of weakest preconditions for performing control and data abstractions is described. The effectiveness of these techniques are illustrated using examples that arose in the analytic verification of a space craft controller that is being developed at NASA <ref> [16, 12] </ref>. Section 5 outlines the data abstraction technique based on explicit domain mappings. A long-term spin-off of this technology is the development of light-weight, automated versions of these analytic V&V tools that continuously monitor a software system as it is executing. <p> To use these tools in a runtime monitoring mode requires that they be made extremely computationally efficient. 3 Analytic Verification Approaches: Model Checking Model checking has proven very successful in debugging and verifying behavioral aspects of industrial-strength hardware applications and protocols <ref> [17, 8, 12] </ref>. This success can be largely attributed to the highly automated and algorithmic nature of model checking techniques that automate reasoning about error-prone concurrent applications. <p> This limits the ability of the approach in [11] to scale to large, complex applications. The extended approach is illustrated by generating an abstract model for the release property of the space controller resource manager verified in <ref> [12] </ref>. The basic assumptions underlying both these methods is the same. The notions of concrete and abstract program models used by these two approaches are formalized below. <p> A non-trivial example : Remote Agent Executive of a Spacecraft Controller In this section we illustrate how the same technique can be applied to a nontrivial example of a resource manager of a space craft controller. The resource manager was verified using the SPIN model checker in <ref> [12] </ref> and several bugs were found. An invariant property that was found to be incorrect there concerned the release of locks by the task processes whose resource usage is monitored by the resource manager. <p> Subsequently, we illustrate how the proposed approach can be used to automatically generate an abstract model which can be analyzed by a model checker to generate a counterexample to the invariant property. For a complete description of the Remote agent executive the reader may refer to <ref> [12] </ref>. The remote agent executive monitors a set of onboard flight tasks that operate on a common set of shared resources. Each task needs specific resources and also requires certain properties of the resources to hold while it is executing.
Reference: 13. <author> K. Havelund, T. Pressburger, </author> " <title> Translating Java to Spin," </title> <type> Manuscript Under Preparation, </type> <institution> NASA Ames Research Center. </institution>
Reference-contexts: This paper is primarily concerned with the latter aspect of developing abstraction techniques to generate a finite-state tractable model. For details on the language translation aspects of abstract model generation, the reader may refer to <ref> [13] </ref>. Our key idea in automatic generation of an abstract model is to use the property that needs to be verified of the given program as the basis for abstraction. Informally, control abstractions discard irrelevant portions of the program that do not affect the property.
Reference: 14. <author> G. Holzmann, D. Peled, </author> " <title> The State of SPIN," </title> <booktitle> in CAV-96. </booktitle>
Reference-contexts: A lot of work has been done in combating the state explosion problem for hardware applications [4, 5, 6]. Several techniques such as symmetry reduction [18], partial-order red uction <ref> [9, 14] </ref> and symbolic encodings of states using representations such as BDDs, BMDs [17, 1, 2] have been considered. However, these techniques only work on finite models.
Reference: 15. <author> Jackson, D.E., </author> " <title> Abstract Model checking of infinite specifications," </title> <booktitle> In Proc. of Formal Methods in Europe 1994. </booktitle>
Reference-contexts: The use of data abstraction in model checking to handle some limited types of infinite state systems are discussed in <ref> [19, 7, 10, 15] </ref>. In [19], Wolper uses the notion of data independence to transform certain temporal properties specified over infinite data values to equivalent properties specified over a finite domain. In [7], Clarke et. al, discuss how user defined abstractions can be used for model checking. <p> In [7], Clarke et. al, discuss how user defined abstractions can be used for model checking. However, no attempt is made there to automate the generation of abstractions. Two approaches that address aspects of automatic generation of abstractions are <ref> [15, 11] </ref>. Jackson in [15] discusses how certain properties involving unbounded sets and predicates over such sets can be reduced to equivalent properties over bounded sets. In [11], the interactive theorem prover PVS is used to generate an abstract model. <p> In [7], Clarke et. al, discuss how user defined abstractions can be used for model checking. However, no attempt is made there to automate the generation of abstractions. Two approaches that address aspects of automatic generation of abstractions are [15, 11]. Jackson in <ref> [15] </ref> discusses how certain properties involving unbounded sets and predicates over such sets can be reduced to equivalent properties over bounded sets. In [11], the interactive theorem prover PVS is used to generate an abstract model.
Reference: 16. <author> M. Lowry, K. Havelund, and J. Penix, </author> " <title> Verification and validation of AI systems that control deep-space spacecraft.", </title> <booktitle> In Proc. of ISMIS 1997.. </booktitle>
Reference-contexts: The use of weakest preconditions for performing control and data abstractions is described. The effectiveness of these techniques are illustrated using examples that arose in the analytic verification of a space craft controller that is being developed at NASA <ref> [16, 12] </ref>. Section 5 outlines the data abstraction technique based on explicit domain mappings. A long-term spin-off of this technology is the development of light-weight, automated versions of these analytic V&V tools that continuously monitor a software system as it is executing. <p> A discussion of the application of these rules to task programs of a space controller executive are described in <ref> [16] </ref>. 4.2 Overview of Automating Data Abstractions Data abstractions play a crucial role in generating abstract models of software programs that are amenable for model checking. Typical software applications employ data types such as numbers, lists, trees, queues, stacks etc. that are often unbounded in advance.
Reference: 17. <author> K. McMillan, </author> " <title> Symbolic Model Checking", </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: To use these tools in a runtime monitoring mode requires that they be made extremely computationally efficient. 3 Analytic Verification Approaches: Model Checking Model checking has proven very successful in debugging and verifying behavioral aspects of industrial-strength hardware applications and protocols <ref> [17, 8, 12] </ref>. This success can be largely attributed to the highly automated and algorithmic nature of model checking techniques that automate reasoning about error-prone concurrent applications. <p> This has been called the state-explosion problem. We discuss two broad approaches that have been previously pursued for dealing with the state-explosion problem and the associated model checking tools below. Symbolic model checkers such as SMV <ref> [17] </ref> identify the state of the system with a predicate denoting the valuations of the variables of the system. The predicate encoding of a state can be naturally extended by expressing each transition as a relation between the current state variables and next state variables. <p> The set of states satisfying an existential property (liveness or eventuality property) can be similarly characterized by the least fixed point of a monotonic functional. The computation of these fixed points can be iteratively done by starting with true (false) for the safety (eventuality) property <ref> [17] </ref>. Explicit state model checkers such as SPIN and Murphi, in contrast to symbolic model checkers, do not employ predicate encodings for representing the states of the transition system. The states are represented directly as a tuple of assignments to the variables of the system. <p> A lot of work has been done in combating the state explosion problem for hardware applications [4, 5, 6]. Several techniques such as symmetry reduction [18], partial-order red uction [9, 14] and symbolic encodings of states using representations such as BDDs, BMDs <ref> [17, 1, 2] </ref> have been considered. However, these techniques only work on finite models. They can not be applied in general to software systems, which typically use data types op erating on unbounded domains and hence have models which are not bounded in advance.
Reference: 18. <author> C. Norris Ip, </author> " <title> State Reduction Methods for Automatic Formal Verification," </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <month> De-cember </month> <year> 1996. </year>
Reference-contexts: A lot of work has been done in combating the state explosion problem for hardware applications [4, 5, 6]. Several techniques such as symmetry reduction <ref> [18] </ref>, partial-order red uction [9, 14] and symbolic encodings of states using representations such as BDDs, BMDs [17, 1, 2] have been considered. However, these techniques only work on finite models.
Reference: 19. <author> Wolper, P., </author> " <title> Expressing Interesting Properties of Programs in propositional temporal logic" In Proc. 13th ACM POPL 1986. This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: The use of data abstraction in model checking to handle some limited types of infinite state systems are discussed in <ref> [19, 7, 10, 15] </ref>. In [19], Wolper uses the notion of data independence to transform certain temporal properties specified over infinite data values to equivalent properties specified over a finite domain. In [7], Clarke et. al, discuss how user defined abstractions can be used for model checking. <p> The use of data abstraction in model checking to handle some limited types of infinite state systems are discussed in [19, 7, 10, 15]. In <ref> [19] </ref>, Wolper uses the notion of data independence to transform certain temporal properties specified over infinite data values to equivalent properties specified over a finite domain. In [7], Clarke et. al, discuss how user defined abstractions can be used for model checking.
References-found: 16

