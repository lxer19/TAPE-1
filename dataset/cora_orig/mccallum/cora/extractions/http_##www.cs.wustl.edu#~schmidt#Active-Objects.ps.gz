URL: http://www.cs.wustl.edu/~schmidt/Active-Objects.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/TAO-status.html
Root-URL: 
Email: G.Lavender@isode.com schmidt@cs.wustl.edu  
Title: Active Object an Object Behavioral Pattern for Concurrent Programming  
Author: R. Greg Lavender Douglas C. Schmidt 
Address: Austin, TX Washington University, St. Louis  
Affiliation: ISODE Consortium Inc. Department of Computer Science  
Abstract: An earlier version of this paper appeared in a chapter in the book Pattern Languages of Program Design 2 ISBN 0-201-89527-7, edited by John Vlissides, Jim Coplien, and Norm Kerth published by Addison-Wesley, 1996. Abstract This paper describes the Active Object pattern, which decou-ples method execution from method invocation in order to simplify synchronized access to a shared resource by methods invoked in different threads of control. The Active Object pattern allows one or more independent threads of execution to interleave their access to data modeled as a single object. A broad class of producer/consumer and reader/writer problems are well-suited to this model of concurrency. This pattern is commonly used in distributed systems requiring multi-threaded servers. In addition, client applications (such as windowing systems and network browsers), are increasingly employing active objects to simplify concurrent, asynchronous network operations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: A Gateway decouples cooperating components in a distributed system and allows them to interact without having direct dependencies among each other <ref> [1] </ref>. For example, the Gateway shown in Figure 1 routes messages from one or more source processes to one or more destination processes in a distributed system [2]. Sources and destinations communicate with the Gateway using TCP connections. Internally, the Gateway contains a set of Input and Output Handler objects.
Reference: [2] <author> D. C. Schmidt, </author> <title> A Family of Design Patterns for Application-level Gateways, </title> <journal> The Theory and Practice of Object Systems (Special Issue on Patterns and Pattern Languages), </journal> <volume> vol. 2, no. 1, </volume> <year> 1996. </year>
Reference-contexts: A Gateway decouples cooperating components in a distributed system and allows them to interact without having direct dependencies among each other [1]. For example, the Gateway shown in Figure 1 routes messages from one or more source processes to one or more destination processes in a distributed system <ref> [2] </ref>. Sources and destinations communicate with the Gateway using TCP connections. Internally, the Gateway contains a set of Input and Output Handler objects. Input Handlers receive messages from sources and use address fields in a message to determine the appropriate Output Handlers associated with the destination. <p> Output Handler objects in Iridium Gateways are implemented as active objects to simplify concurrent programming and improve performance on multi-processors. The active object version of the Iridium Gateway uses the pre-emptive multi-tasking capabilities provided by Solaris threads [12]. An earlier version of the Iridium Gateway <ref> [2] </ref> used a reactive implementation described in Section 3. The reactive design relied on a cooperative event loop-driven dispatcher within a single thread. This design was more difficult to implement and did not perform as well as the active object version on multi-processor platforms.
Reference: [3] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: One way to ensure this is to design the Gateway as a single 1 threaded reactive state machine that uses asynchronous net-work I/O. This design typically combines the Reactor pattern <ref> [3] </ref>, non-blocking sockets, and a set of message queues (one per Output Handler). The Reactor pattern and the non-blocking sockets provide a single-threaded cooperative event loop model of programming. The Reactor demulti-plexes ok to send and ok to receive events to multiple Input and Output Handler objects. <p> The Half-Sync/Half-Async pattern [16] is an architectural pattern that decouples synchronous I/O from asynchronous I/O in a system to simplify concurrent programming effort without degrading execution efficiency. This pattern typically uses the Active Object pattern to implement the Synchronous task layer, the Reactor pattern <ref> [3] </ref> to implement the Asynchronous task layer, and a Producer/Consumer pattern to implement the Queueing layer.
Reference: [4] <author> D. C. Schmidt and T. Suda, </author> <title> Measuring the Performance of Parallel Message-based Process Architectures, </title> <booktitle> in Proceedings of the Conference on Computer Communications (INFO-COM), </booktitle> <address> (Boston, MA), </address> <pages> pp. 624-633, </pages> <publisher> IEEE, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: method invocation methods invoked asynchronously are executed based on a synchronization policy, not on the order of invocation. * The operations on a shared object are relatively coarse-grained in contrast, if operations are very fine-grained the synchronization, data movement, and context switching overhead of active objects may be too high <ref> [4] </ref>. 2 5 Structure and Participants The structure of the Active Object pattern is illustrated in the following Booch class diagram: The key participants in the Active Object pattern include the following classes shown below: * Client Interface (Output Handler Interface) The Client Interface is a Proxy that presents a method
Reference: [5] <author> R. H. Halstead, Jr., </author> <title> Multilisp: A Language for Concurrent Symbolic Computation, </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> vol. 7, </volume> <pages> pp. 501-538, </pages> <month> Oct. </month> <year> 1985. </year>
Reference-contexts: The Method Object is then bound to the current Representation and the method is allowed to access/update this Representation and create a Result. 3 3. Return result the final phase binds the Result value, if any, to a future <ref> [5, 6] </ref> object that passes return values back to the caller when the method finishes executing. A future is a synchronization object that enforces write-once, read-many synchronization. Subsequently, any readers that rendezvous with the future will evaluate the future and obtain the result value.
Reference: [6] <author> B. Liskov and L. Shrira, </author> <title> Promises: Linguistic Support for Efficient Asynchronous Procedure Calls in Distributed Systems, </title> <booktitle> in Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 260-267, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: The Method Object is then bound to the current Representation and the method is allowed to access/update this Representation and create a Result. 3 3. Return result the final phase binds the Result value, if any, to a future <ref> [5, 6] </ref> object that passes return values back to the caller when the method finishes executing. A future is a synchronization object that enforces write-once, read-many synchronization. Subsequently, any readers that rendezvous with the future will evaluate the future and obtain the result value.
Reference: [7] <author> P. </author> <title> America, Inheritance and Subtyping in a Parallel Object-Oriented Language, </title> <booktitle> in ECOOP'87 Conference Proceedings, </booktitle> <pages> pp. 234-242, </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: This tight coupling often inhibits the reuse of the resource implementation by derived classes that require specialized or different synchronization policies. This problem is commonly referred to as the inheritance anomaly <ref> [7, 8, 9, 10] </ref>. A more flexible implementation is to decouple the explicit synchronization policy code from the methods that access and update the shared resource. This decoupling requires that the Client Interface be defined separately.
Reference: [8] <author> D. G. Kafura and K. H. Lee, </author> <title> Inheritance in Actor-Based Concurrent Object-Oriented Languages, </title> <booktitle> in ECOOP'89 Conference Proceedings, </booktitle> <pages> pp. 131-145, </pages> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: This tight coupling often inhibits the reuse of the resource implementation by derived classes that require specialized or different synchronization policies. This problem is commonly referred to as the inheritance anomaly <ref> [7, 8, 9, 10] </ref>. A more flexible implementation is to decouple the explicit synchronization policy code from the methods that access and update the shared resource. This decoupling requires that the Client Interface be defined separately.
Reference: [9] <author> S. Matsuoka, K. Wakita, and A. Yonezawa, </author> <title> Analysis of Inheritance Anomaly in Concurrent Object-Oriented Languages, </title> <journal> OOPS Messenger, </journal> <year> 1991. </year>
Reference-contexts: This tight coupling often inhibits the reuse of the resource implementation by derived classes that require specialized or different synchronization policies. This problem is commonly referred to as the inheritance anomaly <ref> [7, 8, 9, 10] </ref>. A more flexible implementation is to decouple the explicit synchronization policy code from the methods that access and update the shared resource. This decoupling requires that the Client Interface be defined separately.
Reference: [10] <author> M. Papathomas, </author> <title> Concurrency Issues in Object-Oriented Languages, in Object Oriented Development (D. Tsichritzis, </title> <publisher> ed.), </publisher> <pages> pp. 207-245, </pages> <institution> Centre Universitaire D'Informatique, University of Geneva, </institution> <year> 1989. </year>
Reference-contexts: This tight coupling often inhibits the reuse of the resource implementation by derived classes that require specialized or different synchronization policies. This problem is commonly referred to as the inheritance anomaly <ref> [7, 8, 9, 10] </ref>. A more flexible implementation is to decouple the explicit synchronization policy code from the methods that access and update the shared resource. This decoupling requires that the Client Interface be defined separately.
Reference: [11] <author> R. G. Lavender and D. G. Kafura, </author> <title> A Polymorphic Future and First-Class Function Type for Concurrent Object-Oriented Programming in C++, in Forthcoming, </title> <note> 1995. http://www.cs.utexas.edu/users/lavender/papers/futures.ps. </note>
Reference-contexts: If the method produces a result value then some form of future mechanism must be used to provide synchronized access to the value (or the error status if the method fails). In the context of the Active Object pattern, a polymorphic future pattern may be required <ref> [11] </ref> for asynchronous invocations that return a value to the caller. A polymorphic future allows parameterization of the eventual result type represented by the future and enforces the necessary synchronization.
Reference: [12] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Output Handler objects in Iridium Gateways are implemented as active objects to simplify concurrent programming and improve performance on multi-processors. The active object version of the Iridium Gateway uses the pre-emptive multi-tasking capabilities provided by Solaris threads <ref> [12] </ref>. An earlier version of the Iridium Gateway [2] used a reactive implementation described in Section 3. The reactive design relied on a cooperative event loop-driven dispatcher within a single thread.
Reference: [13] <author> G. Agha, </author> <title> A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: The reactive design relied on a cooperative event loop-driven dispatcher within a single thread. This design was more difficult to implement and did not perform as well as the active object version on multi-processor platforms. The Active Object pattern has also been used to implement Actors <ref> [13] </ref>. An Actor contains a set of instance variables and behaviors that react to messages sent to an Actor by other Actors. Messages sent to an Actor are queued in the Actor's message queue. In the Actor model, messages are executed in order of arrival by the current behavior.
Reference: [14] <author> C. Tomlinson and V. Singh, </author> <title> Inheritance and Synchronization with Enabled-Sets, </title> <booktitle> in OOPSLA'89 Conference Proceedings, </booktitle> <pages> pp. 103-112, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Each behavior nominates a replacement behavior to execute the next message, possibly before the nominating behavior has completed execution. Variations on the basic Actor model allow messages in the message queue to be executed based on criteria other than arrival order <ref> [14] </ref>. When the Active Object pattern is used to implement Actors, the Scheduler corresponds to the Actor scheduling mechanism, Method Objects correspond to the behaviors defined for an Actor, and the Resource Representation is the set of instance variables that collectively represent the state of an Actor [15].
Reference: [15] <author> D. Kafura, M. Mukherji, and G. Lavender, </author> <title> ACT++: A Class Library for Concurrent Programming in C++ using Actors, </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pp. 47-56, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: When the Active Object pattern is used to implement Actors, the Scheduler corresponds to the Actor scheduling mechanism, Method Objects correspond to the behaviors defined for an Actor, and the Resource Representation is the set of instance variables that collectively represent the state of an Actor <ref> [15] </ref>.
Reference: [16] <author> D. C. Schmidt and C. D. Cranor, Half-Sync/Half-Async: </author> <title> an Architectural Pattern for Efficient and Well-structured Concurrent I/O, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-10, </pages> <month> September </month> <year> 1995. </year> <month> 8 </month>
Reference-contexts: Whether a caller blocks on a future depends on whether or not a result value has been computed. Hence, the future pattern is a hybrid pattern that is partly a reader-writer condition 7 synchronization pattern and partly a producer-consumer syn-chronization pattern. The Half-Sync/Half-Async pattern <ref> [16] </ref> is an architectural pattern that decouples synchronous I/O from asynchronous I/O in a system to simplify concurrent programming effort without degrading execution efficiency.
References-found: 16

