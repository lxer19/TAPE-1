URL: ftp://ftp.cs.toronto.edu/pub/cogrob/temporal.ps.Z
Refering-URL: 
Root-URL: 
Email: javier@ai.toronto.edu  reiter@ai.toronto.edu  
Title: Temporal Reasoning in Logic Programming: A Case for the Situation Calculus.  
Author: Javier Pinto Raymond Reiter 
Keyword: Temporal Reasoning, Knowledge Representation, Situation Calculus, Event Calculus.  
Address: Toronto, Canada M5S 1A4  Toronto, Canada M5S 1A4  
Affiliation: Dept. of Computer Science University of Toronto  Dept. of Computer Science University of Toronto  
Abstract: We propose, and axiomatize, an extended version of the situation calculus [10] for temporal reasoning in a logic programming framework. This extended language provides for a linear temporal structure, which may be viewed as a path of actual event occurrences within the tree of possible situations of the "classical" situation calculus. The extended language provides for events to occur and fluents to hold at specific points in time. As a result, it is possible to establish a close correspondence between this extended situation calculus and other linear time formalisms which have been proposed in opposition to the situation calculus. In particular, we argue that the functionality of the event calculus [6] is subsumed by the extended situation calculus. We present a logic program for temporal reasoning which is provably sound for our axiomatization, relative to the Clark completion semantics of the program. Our logic programming approach has the advantage of being grounded in a pure (without negation as failure) first order axiomatization suitable for reasoning about events and their occurrences. Moreover, efficient algorithms can be obtained for a suitable class of temporal reasoning problems, following the ideas of Kowalski [5]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Allen, J. F. </author> <title> Towards a general theory of action and time. </title> <booktitle> Artificial Intelligence 23 (1984), </booktitle> <pages> 123-154. </pages>
Reference-contexts: See Section 4 below for details. 3.3 Defining an Interval Based Ontology. The version of the situation calculus we have introduced has an ontology based on time points. On the other hand, the calculus of events, as well as other prominent temporal logics (e.g. Allen's <ref> [1] </ref>), have ontologies in which the primitive temporal objects are intervals of time. In this section we show how the expressiveness of the interval based language can be realized within the situation calculus.
Reference: [2] <author> Clark, K. </author> <title> Negation as Failure. Logic and Databases. </title> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference: [3] <author> Gelfond, M., and Lifschitz, V. </author> <title> Classical negation in logic programs and disjunctive databases. </title> <booktitle> New Generation Computing 9 (1991), </booktitle> <pages> 365-385. 14 </pages>
Reference-contexts: It is well known that logic programming is inappropriate for reasoning with non-categorical theories. In fact, the extension of the logic programming paradigm to work with such theories is a very active area of research <ref> [3] </ref>. Therefore, it should not be surprising that the examples of overcommitment mentioned above arise. <p> Our logic programming implementation can certainly be improved. In particular, the requirement of complete knowledge of events and effect of actions can be relaxed if we use a logic programming framework that allows for uncertainty (e.g. logic programming with both classical negation and negation as failure <ref> [3] </ref>). Furthermore, our version of the situation calculus has certain representational limitations. For example, it is not possible to describe continuously changing properties as fluents (e.g., the position of a falling object).
Reference: [4] <author> Gelfond, M., Lifschitz, V., and Rabinov, A. </author> <title> What are the Limitations of the Situation Calculus? In Working Notes, </title> <booktitle> AAAI Spring Symposium Series. Symposium:Logical Formalization of Commonsense Reasoning. </booktitle> <month> (Mar. </month> <year> 1991), </year> <pages> pp. 59-69. </pages>
Reference-contexts: The situation calculus has been criticized on the grounds that it is not general enough to deal with problems in the real world. However, a recent surge of interest in the situation calculus has shown that most of the criticisms are unjustified. For example, Gelfond, Lifschitz and Rabinov <ref> [4] </ref> show that by extending the language to deal with a generalized notion of action one can represent concurrency, non-instantaneous actions, conditional actions, etc. Lin and Shoham [7] show how to incorporate concurrent actions and discuss the notion of independence among actions. <p> Furthermore, our version of the situation calculus has certain representational limitations. For example, it is not possible to describe continuously changing properties as fluents (e.g., the position of a falling object). To extend our framework to deal with these limitations, ideas of Gelfond, Lifschitz and Rabinov <ref> [4] </ref> will prove valuable. A natural extension of this framework is the inclusion of axioms from which occurrences can be derived, as opposed to axioms in which occurrences are explicitly stated.
Reference: [5] <author> Kowalski, R. </author> <title> Database Updates in the Event Calculus. </title> <booktitle> The Journal of Logic Programming 12 (1992), </booktitle> <pages> 121-146. </pages>
Reference-contexts: Levesque, Lin and Reiter 1 propose an extension fl Fellow of the Canadian Institute for Advanced Research. 1 Forthcoming. 1 to the situation calculus in which complex actions can be built from primitive ones, providing Algol-like programming constructs as complex actions. In this paper we consider Kowalski's <ref> [5] </ref> criticisms of the situation calculus for temporal reasoning. Kowalski claims several disadvantages for the situation calculus for representing event occurrences, specifically: 1. High computational cost of the frame axioms. 2. Events need to be totally ordered. 3. Information must be assimilated in chronological order. <p> We conclude that Holds (after (E1,R)), which is clearly unintended (and contradictory). This problem stems from a poor choice of ontology, and seems to be caused by the Holds predicate, which states that time periods hold (?!). In <ref> [5, p. 142] </ref>, Kowalski suggests that for a very specific class of problems "time periods can be eliminated altogether." This is suggested for computational, rather than representational reasons. However, it seems that either time periods, or the Holds predicate should be eliminated from the ontology for their proposal to work. <p> It is also worth noting that the introduction of terminations and initiations (term, init and maximal) provides an efficient algorithm for dealing with the frame problem in the case that complete information is at hand. Following Kowalski's proposal <ref> [5, pp.138-142] </ref>, we can define an algorithm to answer queries of the form holds (F; S), in which S is a completely determined situation. <p> Whether or not this lower bound is realized by a given implemen-tation is dependent upon the algorithms or reasoning framework utilized. The algorithm proposed by Kowalski for the calculus of events <ref> [5, pp.138-142] </ref> can be used in conjunction with our logical specification to efficiently address the inefficiencies associated with our solution to the frame problem.
Reference: [6] <author> Kowalski, R., and Sergot, M. </author> <title> A logic-based calculus of events. </title> <booktitle> New Generation Computing 4 (1986), </booktitle> <pages> 67-95. </pages>
Reference-contexts: The rest of the paper is organized as follows: In section 2, we analyze the event calculus and show that some ontological choices made in <ref> [6] </ref> have unintended consequences, making it difficult to interpret the calculus as a declarative theory. In section 3, we and show how, with a simple extension to the original situation calculus language, it is possible to express event occurrences and time. <p> Finally, in section 5, we present our conclusions and discuss extensions of the present research. 2 The Event Calculus Revisited. The calculus of events was proposed as a general temporal logic framework. It was originally presented as a logic program <ref> [6] </ref>, in which negation as failure plays an essential role. We have found it very difficult to ascribe a semantics to the calculus of events. In this section we point out some of the difficulties we have encountered with this proposal as a formal theory of time. <p> Both are two-place functions that take an action and a fluent as arguments. According to Kowalski, a term of the form after (a; f) "names" a time period. Furthermore, according to Kowalski and Sergot <ref> [6, p.87] </ref>, the sentence: Holds (p) (1) "expresses that the relationship associated with p holds for the time period p." For example, we can write: Holds (after (paint (Green); colour (Green))) that can be taken to mean that paint (Green) is an event that starts a time period in which the <p> Among others, the time period after (E1,D) holds; this is the same as the time periods hT1 T3i and before (E3,D). Now, from rule G3 in Kowalski and Sergot's program <ref> [6, p.88] </ref> we know that: start (after (e; u); e): (2) Therefore, we may infer that the time period after (E1,R) is started by E1 at time T1. Now, we can easily provide axioms that make event E2 terminate only B and nothing else. <p> It is simple to imagine examples of the first case. The second possibility arises, for example, with case 3 in <ref> [6, p.90] </ref>, where two events e and e 0 are known, the first one initiates a fluent u and the second one terminates a fluent u 0 , with u and u 0 mutually exclusive. <p> ^ actual (s 2 ) s 1 &lt; s 2 _ s 2 &lt; s 1 _ s 1 = s 2 : We also introduce a notion of time, which will allow us to gain the same representational features as some linear temporal logics (e.g., the calculus of events <ref> [6] </ref>). Intuitively, each actual situation has a starting time. The time span of of an actual situation s extends from its starting point upto the starting point of its successor situation (i.e., the ending time of s) in the actual line. <p> For example, the definition of maximal (axiom (28)) and theorems (31)-(33) capture the intuitions behind the cases of start and end points of intervals as discussed in <ref> [6, pp. 90-93] </ref>. Without a precise axiomatization for the calculus of events a formal argument that our language subsumes that of the calculus of events cannot be made. <p> The assertion occurs T (E; T ) is an implicit assertion that, in addition, possible (E; S) is true, where S is the state which includes time T (see axiom (11). This perspective is problematic in the logic programming setting. (See Kowalski <ref> [6] </ref> for an example.) 2. The preconditions of the event E are known to be true at time T .
Reference: [7] <author> Lin, F., and Shoham, Y. </author> <title> Provably correct theories of action. </title> <type> Tech. rep., </type> <institution> University of Toronto, </institution> <year> 1992. </year>
Reference-contexts: For example, Gelfond, Lifschitz and Rabinov [4] show that by extending the language to deal with a generalized notion of action one can represent concurrency, non-instantaneous actions, conditional actions, etc. Lin and Shoham <ref> [7] </ref> show how to incorporate concurrent actions and discuss the notion of independence among actions.
Reference: [8] <author> McCarthy, J. </author> <title> Circumscription a form of non-monotonic reasoning. </title> <booktitle> Artificial Intelligence 13 (1980), </booktitle> <pages> 27-39. </pages>
Reference-contexts: one for each fluent, together with a set of unique names axioms for the action terms. 3.2.2 No Intervening Events Formalizing the assumption that no event occurs between states s 1 and s 2 , unless it must occur, reduces to a suitable form of occurrence minimization, namely, predicate circumscription <ref> [8] </ref> to 8 minimize the extension of the occurs predicate, leaving the remaining predicates fixed. Elsewhere 6 , we elaborate on this idea.
Reference: [9] <author> McCarthy, J., and Hayes, P. J. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <booktitle> In Machine Intelligence 4, </booktitle> <editor> B. Meltzer and D. Michie, Eds. </editor> <publisher> Edinburgh University Press, Edinburgh, </publisher> <address> Scotland, </address> <year> 1969, </year> <pages> pp. 463-502. </pages>
Reference-contexts: 1 Introduction and Motivation. The situation calculus was originally introduced by McCarthy and Hayes <ref> [9] </ref> as a first order language appropriate for reasoning about actions. The basic ontology of the situation calculus consists of situations, which correspond to snapshots of the universe at an instant of time, and actions or events, which change the world from one state to another.
Reference: [10] <author> Pinto, J., and Reiter, R. </author> <title> Adding a time line to the situation calculus. </title> <note> Submitted for publication, </note> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: With this specification in hand, we shall be in a position to derive a logic program which is sound with respect to it. 3 The Extended Situation Calculus. 3.1 The Basic Language and Axioms. In this subsection we summarize the axiomatization and some results from <ref> [10] </ref>. We have sorts A; S; F ; T ; D for action types, situations, propositional fluents, time, and other domain objects respectively. Variables are denoted by lower case letters (with or without subscripts), and constants are denoted by upper case letters (with or without subscripts).
Reference: [11] <author> Reiter, R. </author> <title> The Frame Problem in the Situation Calculus: A Simple Solution (sometimes) and a completeness result for goal regression. </title> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy. </booktitle> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1991, </year> <pages> pp. 359-380. </pages>
Reference-contexts: ) for some action a (see prop. 3.9), in which case successor state persistence will yield persistence of fluents from s 1 to s 2 . 3.2.1 Successor State Persistence To address this problem, we appeal to a monotonic solution to the frame problem which relies on successor state axioms <ref> [11] </ref>. In this approach a successor state axiom is provided for every fluent in the language. Each such axiom provides a complete characterization of a fluent's truth value in state do (a; s) in terms of what is true of the state s. <p> See <ref> [11] </ref> for a discussion. Reiter ([11]) shows how such axioms may be obtained from the effect, or "causal" axioms of the domain, and how it is that they solve the frame problem. In [12] Reiter shows how successor state axioms can be used to specify transactions in database update applications.
Reference: [12] <author> Reiter, R. </author> <title> On specifying database updates. </title> <type> Tech. Rep. </type> <institution> KRR-TR-92-3, University of Toronto, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: See [11] for a discussion. Reiter ([11]) shows how such axioms may be obtained from the effect, or "causal" axioms of the domain, and how it is that they solve the frame problem. In <ref> [12] </ref> Reiter shows how successor state axioms can be used to specify transactions in database update applications.
Reference: [13] <author> Reiter, R. </author> <title> Proving Properties of States in the Situation Calculus. </title> <note> Submitted for publication, </note> <month> Feb. </month> <year> 1992. </year> <month> 15 </month>
Reference-contexts: (8 s):'(s); (3) (8 a 1 ; a 2 ; s 1 ; s 2 ):do (a 1 ; s 1 ) = do (a 2 ; s 2 ) a 1 = a 2 (5) Axiom (3) is an induction axiom, necessary to prove properties true in all situations <ref> [13] </ref>. Notice that axiom (5) precludes concurrent actions. 2 We use the abbreviation s 1 s 2 to mean s 1 &lt; s 2 _ s 1 = s 2 .
References-found: 13

