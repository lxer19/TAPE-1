URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-96-14.ps.Z
Refering-URL: ftp://ftp.cs.caltech.edu/tr/INDEX.html
Root-URL: http://www.cs.caltech.edu
Title: An Algorithm for Distributed Location Management in Networks of Mobile Computers  
Author: Svetlana Kryukova Berna Massingill and Beverly Sanders 
Abstract: In a network supporting mobile communication devices, a mechanism to find the location of a device, wherever it may be, is needed. In this paper, we present a distributed algorithm for this purpose along with its formal specification and proof sketch. Inspired by our experiences with Wang's algorithm [9], one goal of this paper is to demonstrate that the process of formalization together with careful attention to abstraction and presentation can yield significant benefits in algorithm design. In this case, we obtained a more regular, general, and robust algorithm with a clearer description. An incidental contribution is a useful theorem for proving progress properties in distributed algorithms that use tokens.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: We do not specify exactly how this is done, since it is not relevant to our algorithms. The algorithms are developed and verified using a variation of the UNITY <ref> [1, 4, 5] </ref> programming method. We have attempted to give sufficient intuitive justification and informal explanations to allow readers unfamiliar with this formalism to understand the algorithms and follow the overall derivation. <p> This problem can be addressed independently of our algorithm, another example of "separation of concerns". Finally, we specified, developed, and verified our proposed algorithm using a systematic, well-founded method and described the algorithm using a well-defined notation <ref> [1, 4, 5] </ref> with clear assumptions. This makes clear what the algorithm is and what problems we have and haven't actually solved.
Reference: [2] <author> F. Cristian. </author> <title> Understanding fault-tolerant distributed systems. </title> <journal> Communications of the ACM, </journal> <volume> 34(2) </volume> <pages> 56-91, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Appendix A supplies necessary definitions, axioms, and theorems from UNITY. 2 A base station is a node of the physical network that also engages in wireless communication with portables, acting as the interface between portables and the physical network. 3 Several known techniques exist for providing fault tolerance using replication <ref> [2] </ref>. 2 2 Problem Description In terms of our model, the problem is to give algorithms that allow the current actual address of each portable in the system, or the fact that it is unreachable (due to being out of its service area or switched off), to be determined.
Reference: [3] <author> J. G. Markoulidakis and E. D. Sykas. </author> <title> Method for efficient location area planning in mobile telecommunications. </title> <journal> Electronics Letters, </journal> <volume> 29(25) </volume> <pages> 2165-2166, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: This simplifies the algorithm and is easily implemented. Also, individual base stations need not be the optimal granularity for location information for portables. For example, several base stations might be combined in a region, with connection established with individual portables by paging in the entire region. <ref> [3] </ref> discusses the tradeoff between paging and the granularity of location information that is maintained. Finally, our approach allows fault tolerance to be introduced using well-known techniques for replication. This problem can be addressed independently of our algorithm, another example of "separation of concerns".
Reference: [4] <author> J. Misra. </author> <title> A logic for concurrent programming: Progress. </title> <journal> Journal of Computer and Software Engineering, </journal> <volume> 3(2) </volume> <pages> 273-300, </pages> <year> 1995. </year>
Reference-contexts: We do not specify exactly how this is done, since it is not relevant to our algorithms. The algorithms are developed and verified using a variation of the UNITY <ref> [1, 4, 5] </ref> programming method. We have attempted to give sufficient intuitive justification and informal explanations to allow readers unfamiliar with this formalism to understand the algorithms and follow the overall derivation. <p> This problem can be addressed independently of our algorithm, another example of "separation of concerns". Finally, we specified, developed, and verified our proposed algorithm using a systematic, well-founded method and described the algorithm using a well-defined notation <ref> [1, 4, 5] </ref> with clear assumptions. This makes clear what the algorithm is and what problems we have and haven't actually solved.
Reference: [5] <author> J. Misra. </author> <title> A logic for concurrent programming: Safety. </title> <journal> Journal of Computer and Software Engineering, </journal> <volume> 3(2) </volume> <pages> 239-272, </pages> <year> 1995. </year>
Reference-contexts: We do not specify exactly how this is done, since it is not relevant to our algorithms. The algorithms are developed and verified using a variation of the UNITY <ref> [1, 4, 5] </ref> programming method. We have attempted to give sufficient intuitive justification and informal explanations to allow readers unfamiliar with this formalism to understand the algorithms and follow the overall derivation. <p> This problem can be addressed independently of our algorithm, another example of "separation of concerns". Finally, we specified, developed, and verified our proposed algorithm using a systematic, well-founded method and described the algorithm using a well-defined notation <ref> [1, 4, 5] </ref> with clear assumptions. This makes clear what the algorithm is and what problems we have and haven't actually solved.
Reference: [6] <author> S. Mohan and R. Jain. </author> <title> Two user location strategies for personal communications services. </title> <journal> IEEE Personal Communications, </journal> <pages> pages 42-50, </pages> <year> 1994. </year>
Reference-contexts: We will give one algorithm for database maintenance and one for database queries. The GSM and EIA/TIA standards for mobile communications (see <ref> [6] </ref> for an overview of location strategies in both) implement a two-level database of location information. For portables away from their home addresses, the home address node maintains the location of a "visitor location register" that stores the actual address of the portable.
Reference: [7] <author> E. D. Sykas and M. E. Theologou. </author> <title> Numbering and addressing in IBCN for mobile communications. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(2) </volume> <pages> 230-241, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: Typically, the IDs of nodes and of portables will contain geographic information similar to telephone numbers that can be exploited for routing and determining a node's home address. See <ref> [7, 9] </ref> for a discussion of numbering and addressing in mobile networks. We assume that routing in the fixed network is available, and that given a portable's ID there is some way to determine its home address.
Reference: [8] <author> A. S. Tanenbaum. </author> <title> Computer Networks. </title> <publisher> Prentice-Hall, 3rd edition, </publisher> <year> 1996. </year>
Reference-contexts: See, for example, <ref> [8] </ref>. 1 called the portable's location or actual address. The actual address of portable P is denoted AA:P . A message can be sent to the portable via its actual address node, which may change over time as the portable moves.
Reference: [9] <author> J. Z. Wang. </author> <title> A fully distributed location registration strategy for universal personal communication systems. </title> <journal> IEEE Journal on Selected Areas in Communication, </journal> <volume> 11(6) </volume> <pages> 850-860, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Typically, the IDs of nodes and of portables will contain geographic information similar to telephone numbers that can be exploited for routing and determining a node's home address. See <ref> [7, 9] </ref> for a discussion of numbering and addressing in mobile networks. We assume that routing in the fixed network is available, and that given a portable's ID there is some way to determine its home address. <p> This approach has the disadvantage that it doesn't scale well, and in cases where the portable is not close (in the network) to the home address node it can result in a significant amount of communication. A more distributed approach, described in <ref> [9] </ref>, imposes a hierarchical tree structure on the nodes in the fixed network. Wang calls this an "intelligent network". In Wang's algorithm, the length of the path from the root of the tree to each leaf node is constant, and each level in the tree represents a geographic area. <p> Figure 6 describes processing on receipt of a query token. 5 Wang <ref> [9] </ref> simply assumed that this would not happen, and did not give sufficient details to determine what would happen with his algorithm if it did. 16 Initial conditions are as specified in (25), plus the following (for all portables P ): :token (P; ; ; QUERY ; ) ^ (39) :token <p> The invariant follows from the invariants given for the database maintenance algorithm; the proof is omitted. 6 Discussion We have given an algorithm for location update in mobile networks. Our work was inspired by Wang's algorithm <ref> [9] </ref>. Although the hierarchical approach he presents has much potential for scaling up to large systems, we found his presentation difficult to understand. A major reason was that he included details that are indeed important, but orthogonal to the design of the location database itself and best considered separately.
References-found: 9

