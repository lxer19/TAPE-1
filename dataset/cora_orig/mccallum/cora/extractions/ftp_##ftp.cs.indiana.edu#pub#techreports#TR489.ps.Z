URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR489.ps.Z
Refering-URL: http://www.cs.indiana.edu/ftp/techreports/index.html
Root-URL: http://www.cs.indiana.edu
Note: Contents  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Although control and data flow analysis of more traditional intermediate representations (such as three-address code) are described extensively in the compiler literature (see e.g. <ref> [1, 3, 15, 35, 46, 47] </ref>), we briefly discuss the analysis specifically for bytecode. 1 Although the class file format provides a way to supply information about bytecode in so-called attributes [26, ch4], there is no pre-defined way yet to support bytecode optimization. <p> We can partition the bytecode for one method into basic-blocks by first finding the set of leaders (cf. <ref> [1, ch9] </ref>): * The first instruction of the method and each first instruction of every exception handler for the method are leaders. * Each statement that is the target of a conditional or unconditional branch (including jsr and jsr w) or one of the targets of a &lt;kind&gt;switch is a leader. <p> The other basic blocks are constructed similarly. 6 *** method 0x00 flow ()I 1-&gt;1 [4,23) -&gt; 26 java.lang.Exception [4,34) -&gt; 40 any [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore_1 [ 0] 2: iconst_0 [ 1] 3: istore_2 ---------- [ 0] 4: iinc 1 1 [ 0] 7: iload_2 [ 1] 8: aload_0 *[ 2] 9: getfield Flow.a [I ---------- [ 2] 12: iload_1 *[ 3] 13: iaload ---------- [ 2] 14: iadd [ 1] 15: istore_2 <p> The other basic blocks are constructed similarly. 6 *** method 0x00 flow ()I 1-&gt;1 [4,23) -&gt; 26 java.lang.Exception [4,34) -&gt; 40 any [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore_1 [ 0] 2: iconst_0 [ 1] 3: istore_2 ---------- [ 0] 4: iinc 1 1 [ 0] 7: iload_2 [ 1] 8: aload_0 *[ 2] 9: getfield Flow.a [I ---------- [ 2] 12: iload_1 *[ 3] 13: iaload ---------- [ 2] 14: iadd [ 1] 15: istore_2 [ 0] 16: iload_1 [ 1] 17: sipush <p> The other basic blocks are constructed similarly. 6 *** method 0x00 flow ()I 1-&gt;1 [4,23) -&gt; 26 java.lang.Exception [4,34) -&gt; 40 any [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore_1 [ 0] 2: iconst_0 [ 1] 3: istore_2 ---------- [ 0] 4: iinc 1 1 [ 0] 7: iload_2 [ 1] 8: aload_0 *[ 2] 9: getfield Flow.a [I ---------- [ 2] 12: iload_1 *[ 3] 13: iaload ---------- [ 2] 14: iadd [ 1] 15: istore_2 [ 0] 16: iload_1 [ 1] 17: sipush 500 [ 2] 20: if_icmplt 4 ---------- [ 0] 23: goto 34 ---------- [ 0] <p> 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore_1 [ 0] 2: iconst_0 [ 1] 3: istore_2 ---------- [ 0] 4: iinc 1 1 [ 0] 7: iload_2 [ 1] 8: aload_0 *[ 2] 9: getfield Flow.a [I ---------- [ 2] 12: iload_1 *[ 3] 13: iaload ---------- [ 2] 14: iadd [ 1] 15: istore_2 [ 0] 16: iload_1 [ 1] 17: sipush 500 [ 2] 20: if_icmplt 4 ---------- [ 0] 23: goto 34 ---------- [ 0] 27: iconst_0 [ 1] 28: istore_3 [ 0] 29: jsr 48 [ 0] 32: iload_3 [ 1] 33: ireturn ---------- ---------- [ 0] 37: <p> 0] 2: iconst_0 <ref> [ 1] </ref> 3: istore_2 ---------- [ 0] 4: iinc 1 1 [ 0] 7: iload_2 [ 1] 8: aload_0 *[ 2] 9: getfield Flow.a [I ---------- [ 2] 12: iload_1 *[ 3] 13: iaload ---------- [ 2] 14: iadd [ 1] 15: istore_2 [ 0] 16: iload_1 [ 1] 17: sipush 500 [ 2] 20: if_icmplt 4 ---------- [ 0] 23: goto 34 ---------- [ 0] 27: iconst_0 [ 1] 28: istore_3 [ 0] 29: jsr 48 [ 0] 32: iload_3 [ 1] 33: ireturn ---------- ---------- [ 0] 37: goto 57 ---------- [ 1] 40: astore 4 <p> aload_0 *[ 2] 9: getfield Flow.a [I ---------- [ 2] 12: iload_1 *[ 3] 13: iaload ---------- [ 2] 14: iadd <ref> [ 1] </ref> 15: istore_2 [ 0] 16: iload_1 [ 1] 17: sipush 500 [ 2] 20: if_icmplt 4 ---------- [ 0] 23: goto 34 ---------- [ 0] 27: iconst_0 [ 1] 28: istore_3 [ 0] 29: jsr 48 [ 0] 32: iload_3 [ 1] 33: ireturn ---------- ---------- [ 0] 37: goto 57 ---------- [ 1] 40: astore 4 [ 0] 42: jsr 48 [ 0] 45: aload 4 *[ 1] 47: athrow ---------- [ 1] 48: astore 5 [ <p> 3] 13: iaload ---------- [ 2] 14: iadd <ref> [ 1] </ref> 15: istore_2 [ 0] 16: iload_1 [ 1] 17: sipush 500 [ 2] 20: if_icmplt 4 ---------- [ 0] 23: goto 34 ---------- [ 0] 27: iconst_0 [ 1] 28: istore_3 [ 0] 29: jsr 48 [ 0] 32: iload_3 [ 1] 33: ireturn ---------- ---------- [ 0] 37: goto 57 ---------- [ 1] 40: astore 4 [ 0] 42: jsr 48 [ 0] 45: aload 4 *[ 1] 47: athrow ---------- [ 1] 48: astore 5 [ 0] 50: aload_0 [ 1] 51: aconst_null *[ 2] 52: putfield Flow.a [I <p> [ 0] 16: iload_1 <ref> [ 1] </ref> 17: sipush 500 [ 2] 20: if_icmplt 4 ---------- [ 0] 23: goto 34 ---------- [ 0] 27: iconst_0 [ 1] 28: istore_3 [ 0] 29: jsr 48 [ 0] 32: iload_3 [ 1] 33: ireturn ---------- ---------- [ 0] 37: goto 57 ---------- [ 1] 40: astore 4 [ 0] 42: jsr 48 [ 0] 45: aload 4 *[ 1] 47: athrow ---------- [ 1] 48: astore 5 [ 0] 50: aload_0 [ 1] 51: aconst_null *[ 2] 52: putfield Flow.a [I ---------- ---------- [ 0] 57: iload_2 [ 1] 58: ireturn ---------- Locals <p> ---------- [ 0] 27: iconst_0 <ref> [ 1] </ref> 28: istore_3 [ 0] 29: jsr 48 [ 0] 32: iload_3 [ 1] 33: ireturn ---------- ---------- [ 0] 37: goto 57 ---------- [ 1] 40: astore 4 [ 0] 42: jsr 48 [ 0] 45: aload 4 *[ 1] 47: athrow ---------- [ 1] 48: astore 5 [ 0] 50: aload_0 [ 1] 51: aconst_null *[ 2] 52: putfield Flow.a [I ---------- ---------- [ 0] 57: iload_2 [ 1] 58: ireturn ---------- Locals 0: this 1: i 3: 0 5: return 7 *** method 0x00 switcher (Z)D 2-&gt;2 ---------- [ 0] 0: iload_1 <p> [ 0] 29: jsr 48 [ 0] 32: iload_3 <ref> [ 1] </ref> 33: ireturn ---------- ---------- [ 0] 37: goto 57 ---------- [ 1] 40: astore 4 [ 0] 42: jsr 48 [ 0] 45: aload 4 *[ 1] 47: athrow ---------- [ 1] 48: astore 5 [ 0] 50: aload_0 [ 1] 51: aconst_null *[ 2] 52: putfield Flow.a [I ---------- ---------- [ 0] 57: iload_2 [ 1] 58: ireturn ---------- Locals 0: this 1: i 3: 0 5: return 7 *** method 0x00 switcher (Z)D 2-&gt;2 ---------- [ 0] 0: iload_1 [ 1] 1: ifeq 42 ---------- [ 0] 4: <p> 0] 37: goto 57 ---------- <ref> [ 1] </ref> 40: astore 4 [ 0] 42: jsr 48 [ 0] 45: aload 4 *[ 1] 47: athrow ---------- [ 1] 48: astore 5 [ 0] 50: aload_0 [ 1] 51: aconst_null *[ 2] 52: putfield Flow.a [I ---------- ---------- [ 0] 57: iload_2 [ 1] 58: ireturn ---------- Locals 0: this 1: i 3: 0 5: return 7 *** method 0x00 switcher (Z)D 2-&gt;2 ---------- [ 0] 0: iload_1 [ 1] 1: ifeq 42 ---------- [ 0] 4: aload_0 *[ 1] 5: getfield Switcher.s I ---------- [ 1] 8: lookupswitch 2 -10::36 default::42 ---------- <p> 1] 48: astore 5 [ 0] 50: aload_0 <ref> [ 1] </ref> 51: aconst_null *[ 2] 52: putfield Flow.a [I ---------- ---------- [ 0] 57: iload_2 [ 1] 58: ireturn ---------- Locals 0: this 1: i 3: 0 5: return 7 *** method 0x00 switcher (Z)D 2-&gt;2 ---------- [ 0] 0: iload_1 [ 1] 1: ifeq 42 ---------- [ 0] 4: aload_0 *[ 1] 5: getfield Switcher.s I ---------- [ 1] 8: lookupswitch 2 -10::36 default::42 ---------- [ 2] 39: dreturn ---------- [ 0] 40: dconst_1 [ 2] 41: dreturn ---------- [ 0] 42: dconst_0 [ 2] 43: dreturn ---------- Locals 0: this <p> [I ---------- ---------- [ 0] 57: iload_2 <ref> [ 1] </ref> 58: ireturn ---------- Locals 0: this 1: i 3: 0 5: return 7 *** method 0x00 switcher (Z)D 2-&gt;2 ---------- [ 0] 0: iload_1 [ 1] 1: ifeq 42 ---------- [ 0] 4: aload_0 *[ 1] 5: getfield Switcher.s I ---------- [ 1] 8: lookupswitch 2 -10::36 default::42 ---------- [ 2] 39: dreturn ---------- [ 0] 40: dconst_1 [ 2] 41: dreturn ---------- [ 0] 42: dconst_0 [ 2] 43: dreturn ---------- Locals 0: this 1: b Both the edges (v 3 ; v 1 ) and (v 3 ; v 4 <p> In Figure 3, where Pred (v) = fp 2 V j (p; v) 2 Eg, we give an iterative algorithm comp dominators () to compute the set of dominators Dom (v) V for every vertex v 2 V <ref> [1, p670-671] </ref>. An edge (g; h) 2 E where h 2 Dom (g) is called a back edge. Such a back edge defines a natural loop L V , consisting of all vertices that can reach vertex g without going through h. <p> Given a back edge (g; h) 2 E, the corresponding natural loop can be constructed by invoking the algorithm in Figure 3 as comp natloop (g) for an initial set L = fhg <ref> [1, p604] </ref>. Given a natural loop L V , an edge (v; e) 2 E where v 2 L and e =2 L is called a loop-exit. <p> For the latter loop, edge (v 4 ; v 5 ) 2 E forms a normal loop-exit, whereas, again, all edges representing abnormal completion of mat () form abnormal loop-exits. 9 *** method 0x08 mat ([[I [[I [[II)V 4-&gt;0 ---------- [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore 4 [ 0] 3: goto 49 ---------- [ 0] 6: iconst_0 [ 1] 7: istore 5 [ 0] 9: goto 40 ---------- [ 0] 12: aload_2 [ 1] 13: iload 4 *[ 2] 15: aaload ---------- ---------- [ 5] 34: iadd [ 4] 35: iadd *[ 3] <p> 5 ) 2 E forms a normal loop-exit, whereas, again, all edges representing abnormal completion of mat () form abnormal loop-exits. 9 *** method 0x08 mat ([[I [[I [[II)V 4-&gt;0 ---------- [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore 4 [ 0] 3: goto 49 ---------- [ 0] 6: iconst_0 [ 1] 7: istore 5 [ 0] 9: goto 40 ---------- [ 0] 12: aload_2 [ 1] 13: iload 4 *[ 2] 15: aaload ---------- ---------- [ 5] 34: iadd [ 4] 35: iadd *[ 3] 36: iastore ---------- [ 0] 37: iinc 5 1 ---------- [ 0] 40: iload 5 <p> of mat () form abnormal loop-exits. 9 *** method 0x08 mat ([[I [[I [[II)V 4-&gt;0 ---------- [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore 4 [ 0] 3: goto 49 ---------- [ 0] 6: iconst_0 [ 1] 7: istore 5 [ 0] 9: goto 40 ---------- [ 0] 12: aload_2 [ 1] 13: iload 4 *[ 2] 15: aaload ---------- ---------- [ 5] 34: iadd [ 4] 35: iadd *[ 3] 36: iastore ---------- [ 0] 37: iinc 5 1 ---------- [ 0] 40: iload 5 [ 1] 42: iload_3 [ 2] 43: if_icmplt 12 ---------- [ 0] 46: iinc 4 <p> 1] 7: istore 5 [ 0] 9: goto 40 ---------- [ 0] 12: aload_2 <ref> [ 1] </ref> 13: iload 4 *[ 2] 15: aaload ---------- ---------- [ 5] 34: iadd [ 4] 35: iadd *[ 3] 36: iastore ---------- [ 0] 37: iinc 5 1 ---------- [ 0] 40: iload 5 [ 1] 42: iload_3 [ 2] 43: if_icmplt 12 ---------- [ 0] 46: iinc 4 1 ---------- [ 0] 49: iload 4 [ 1] 51: iload_3 [ 2] 52: if_icmplt 6 ---------- [ 0] 55: return ---------- Locals 0: a 2: c 4: i 2.4 Reaching Definitions of Local Variables On <p> aaload ---------- ---------- [ 5] 34: iadd [ 4] 35: iadd *[ 3] 36: iastore ---------- [ 0] 37: iinc 5 1 ---------- [ 0] 40: iload 5 <ref> [ 1] </ref> 42: iload_3 [ 2] 43: if_icmplt 12 ---------- [ 0] 46: iinc 4 1 ---------- [ 0] 49: iload 4 [ 1] 51: iload_3 [ 2] 52: if_icmplt 6 ---------- [ 0] 55: return ---------- Locals 0: a 2: c 4: i 2.4 Reaching Definitions of Local Variables On a method invocation, a fixed-sized frame consisting of a fixed-sized operand stack and a set of local variables is allocated [26, ch3]. <p> O := rd_gen [v] [ (rd in [v] rd kill [v]); if (rd_out [v] 6= O) - busy := true; rd_out [v] := O; - while (busy); - for a method with control flow graph G = hV; E; v 0 i by solving a forward, any-path (may) data-flow problem <ref> [1, 3, 15, 35, 46, 47] </ref>. First, for each basic block v 2 V , the sets rd gen [v] and rd kill [v] are constructed. <p> defs () shown in Figure 5 is used to solve these data flow equations (statistics gathered in [21] reveal that visiting the vertices in the flow graph according to topological sorting of the dominance relation tends to reduce the number of passes required to solve forward data flow equations iteratively <ref> [1, 47] </ref>). Here, we assume that the entry vertex v 0 2 V has a dummy predecessor w, where rd out [w] consists of all definitions that are formed by invoking the current method. <p> The instructions lstore 1 at address 7 and 11 form two definitions of the locals 1 and 2, respectively: 11 *** method 0x08 retLong (ZJ)J 3-&gt;2 ---------- [ 0] 0: iload_0 <ref> [ 1] </ref> 1: ifeq 12 ---------- [ 2] 7: lstore_1 [ 0] 8: ldc2_w 30 [ 2] 11: lstore_1 ---------- [ 0] 12: lload_1 [ 2] 13: lreturn ---------- Locals 0: b 2: l-2 d 1 d 2 d 3 d 4 d 5 d 6 d 7 local 0 1 <p> 3 ; d 6 ; d 7 g fd 1 ; d 2 ; d 3 ; d 6 ; d 7 g Consider, as another small example, the following Java class method reach () in which a do-while-loop and three local variables i, j, and k are used (cf. <ref> [1, p619] </ref>): static int reach () - int i = 100, j = 200, k = 300; if (i &gt; 10) k = 4; else i = 0; while (j &gt; 5); return k; - The bytecode and corresponding flow graph G = hV; E; v 0 i, where V = <p> our definition, d 4 and d 5 belong to the rd kill [v 1 ], we could equally well omit these definitions from this set because d 4 and d 5 cannot reach any other basic block. 12 *** method 0x08 reach ()I 0-&gt;1 ---------- [ 0] 0: bipush 100 <ref> [ 1] </ref> 2: istore_0 [ 0] 3: sipush 200 [ 1] 6: istore_1 [ 0] 7: sipush 300 [ 1] 10: istore_2 ---------- [ 0] 11: iinc 0 1 [ 0] 14: iinc 1 -1 [ 0] 17: iload_0 [ 1] 18: bipush 10 [ 2] 20: if_icmple 28 ---------- [ <p> the rd kill [v 1 ], we could equally well omit these definitions from this set because d 4 and d 5 cannot reach any other basic block. 12 *** method 0x08 reach ()I 0-&gt;1 ---------- [ 0] 0: bipush 100 <ref> [ 1] </ref> 2: istore_0 [ 0] 3: sipush 200 [ 1] 6: istore_1 [ 0] 7: sipush 300 [ 1] 10: istore_2 ---------- [ 0] 11: iinc 0 1 [ 0] 14: iinc 1 -1 [ 0] 17: iload_0 [ 1] 18: bipush 10 [ 2] 20: if_icmple 28 ---------- [ 0] 23: iconst_4 [ 1] 24: istore_2 [ 0] <p> well omit these definitions from this set because d 4 and d 5 cannot reach any other basic block. 12 *** method 0x08 reach ()I 0-&gt;1 ---------- [ 0] 0: bipush 100 <ref> [ 1] </ref> 2: istore_0 [ 0] 3: sipush 200 [ 1] 6: istore_1 [ 0] 7: sipush 300 [ 1] 10: istore_2 ---------- [ 0] 11: iinc 0 1 [ 0] 14: iinc 1 -1 [ 0] 17: iload_0 [ 1] 18: bipush 10 [ 2] 20: if_icmple 28 ---------- [ 0] 23: iconst_4 [ 1] 24: istore_2 [ 0] 25: goto 30 ---------- [ 0] 28: iconst_0 [ <p> method 0x08 reach ()I 0-&gt;1 ---------- [ 0] 0: bipush 100 <ref> [ 1] </ref> 2: istore_0 [ 0] 3: sipush 200 [ 1] 6: istore_1 [ 0] 7: sipush 300 [ 1] 10: istore_2 ---------- [ 0] 11: iinc 0 1 [ 0] 14: iinc 1 -1 [ 0] 17: iload_0 [ 1] 18: bipush 10 [ 2] 20: if_icmple 28 ---------- [ 0] 23: iconst_4 [ 1] 24: istore_2 [ 0] 25: goto 30 ---------- [ 0] 28: iconst_0 [ 1] 29: istore_0 ---------- [ 0] 30: iload_1 [ 1] 31: iconst_5 [ 2] 32: if_icmpgt 11 ---------- [ 0] 35: <p> [ 0] 3: sipush 200 <ref> [ 1] </ref> 6: istore_1 [ 0] 7: sipush 300 [ 1] 10: istore_2 ---------- [ 0] 11: iinc 0 1 [ 0] 14: iinc 1 -1 [ 0] 17: iload_0 [ 1] 18: bipush 10 [ 2] 20: if_icmple 28 ---------- [ 0] 23: iconst_4 [ 1] 24: istore_2 [ 0] 25: goto 30 ---------- [ 0] 28: iconst_0 [ 1] 29: istore_0 ---------- [ 0] 30: iload_1 [ 1] 31: iconst_5 [ 2] 32: if_icmpgt 11 ---------- [ 0] 35: iload_2 [ 1] 36: ireturn ---------- Locals 0: i 2: k v rd gen [v] <p> <ref> [ 1] </ref> 10: istore_2 ---------- [ 0] 11: iinc 0 1 [ 0] 14: iinc 1 -1 [ 0] 17: iload_0 [ 1] 18: bipush 10 [ 2] 20: if_icmple 28 ---------- [ 0] 23: iconst_4 [ 1] 24: istore_2 [ 0] 25: goto 30 ---------- [ 0] 28: iconst_0 [ 1] 29: istore_0 ---------- [ 0] 30: iload_1 [ 1] 31: iconst_5 [ 2] 32: if_icmpgt 11 ---------- [ 0] 35: iload_2 [ 1] 36: ireturn ---------- Locals 0: i 2: k v rd gen [v] rd kill [v] rd in [v] rd out [v] v 0 fd 1 ; <p> 0 1 [ 0] 14: iinc 1 -1 [ 0] 17: iload_0 <ref> [ 1] </ref> 18: bipush 10 [ 2] 20: if_icmple 28 ---------- [ 0] 23: iconst_4 [ 1] 24: istore_2 [ 0] 25: goto 30 ---------- [ 0] 28: iconst_0 [ 1] 29: istore_0 ---------- [ 0] 30: iload_1 [ 1] 31: iconst_5 [ 2] 32: if_icmpgt 11 ---------- [ 0] 35: iload_2 [ 1] 36: ireturn ---------- Locals 0: i 2: k v rd gen [v] rd kill [v] rd in [v] rd out [v] v 0 fd 1 ; d 2 ; d 3 g fd 4 ; <p> 18: bipush 10 [ 2] 20: if_icmple 28 ---------- [ 0] 23: iconst_4 <ref> [ 1] </ref> 24: istore_2 [ 0] 25: goto 30 ---------- [ 0] 28: iconst_0 [ 1] 29: istore_0 ---------- [ 0] 30: iload_1 [ 1] 31: iconst_5 [ 2] 32: if_icmpgt 11 ---------- [ 0] 35: iload_2 [ 1] 36: ireturn ---------- Locals 0: i 2: k v rd gen [v] rd kill [v] rd in [v] rd out [v] v 0 fd 1 ; d 2 ; d 3 g fd 4 ; d 5 ; d 6 ; d 7 g ; fd 1 ; d <p> In a ud-chain (use/definition-chain), each use u has an associated set UD (u) consisting of all definitions that reach that use. Given the global reaching definitions information of the previous section, it is straightforward to construct local reaching definitions information (i.e. for each indi vidual instruction) and, hence, ud-chains <ref> [1, ch10] </ref>. Starting with the initial set rd in [v] of a basic block v 2 V , we step through the instructions of this basic block in order. At each instruction i, we first associate definitions in the current set with all corresponding uses formed by i. <p> Likewise, in a du-chain (definition/use-chain), each definition d has an associated set DU (d) consisting of all uses that are reached by this particular definition. Although the problem of finding du-chains can be formulated as another data flow problem (see e.g. <ref> [1, p632-633] </ref>), we can also use 13 the following obvious property to construct du-chains from ud-chains: u 2 DU (d) , d 2 UD (u) (2) If DU (d) = ;, then definition d does not reach any use, and the corresponding instruction in the bytecode can be eliminated as dead <p> we can also use 13 the following obvious property to construct du-chains from ud-chains: u 2 DU (d) , d 2 UD (u) (2) If DU (d) = ;, then definition d does not reach any use, and the corresponding instruction in the bytecode can be eliminated as dead code <ref> [1, ch9,10] </ref>. Likewise, if UD (u) = ;, an uninitialized variable is referenced, which indicates a programming error in the bytecode. <p> from the bytecode context for the instructions getfield, getstatic, and invoke&lt;kind&gt; (for invocations, sp post (i), in fact, yields the number of words that are pushed back onto the stack by the corresponding &lt;T&gt;return instruction in the callee). 15 *** method 0x08 iterativeFac (I)I 1-&gt;1 ---------- [ 0] 0: iconst_1 <ref> [ 1] </ref> 1: istore_1 [ 0] 2: goto 12 ---------- [ 0] 5: iload_1 [ 1] 6: iload_0 [ 2] 7: iinc 0 -1 [ 2] 10: imul [ 1] 11: istore_1 ---------- [ 0] 12: iload_0 [ 1] 13: iconst_1 [ 2] 14: if_icmpgt 5 ---------- [ 0] 17: iload_1 <p> post (i), in fact, yields the number of words that are pushed back onto the stack by the corresponding &lt;T&gt;return instruction in the callee). 15 *** method 0x08 iterativeFac (I)I 1-&gt;1 ---------- [ 0] 0: iconst_1 <ref> [ 1] </ref> 1: istore_1 [ 0] 2: goto 12 ---------- [ 0] 5: iload_1 [ 1] 6: iload_0 [ 2] 7: iinc 0 -1 [ 2] 10: imul [ 1] 11: istore_1 ---------- [ 0] 12: iload_0 [ 1] 13: iconst_1 [ 2] 14: if_icmpgt 5 ---------- [ 0] 17: iload_1 [ 1] 18: ireturn ---------- Locals 0: n For each instruction i in a <p> the stack by the corresponding &lt;T&gt;return instruction in the callee). 15 *** method 0x08 iterativeFac (I)I 1-&gt;1 ---------- [ 0] 0: iconst_1 <ref> [ 1] </ref> 1: istore_1 [ 0] 2: goto 12 ---------- [ 0] 5: iload_1 [ 1] 6: iload_0 [ 2] 7: iinc 0 -1 [ 2] 10: imul [ 1] 11: istore_1 ---------- [ 0] 12: iload_0 [ 1] 13: iconst_1 [ 2] 14: if_icmpgt 5 ---------- [ 0] 17: iload_1 [ 1] 18: ireturn ---------- Locals 0: n For each instruction i in a basic block, an associated attribute i.sp is used to store the operand stack size <p> callee). 15 *** method 0x08 iterativeFac (I)I 1-&gt;1 ---------- [ 0] 0: iconst_1 <ref> [ 1] </ref> 1: istore_1 [ 0] 2: goto 12 ---------- [ 0] 5: iload_1 [ 1] 6: iload_0 [ 2] 7: iinc 0 -1 [ 2] 10: imul [ 1] 11: istore_1 ---------- [ 0] 12: iload_0 [ 1] 13: iconst_1 [ 2] 14: if_icmpgt 5 ---------- [ 0] 17: iload_1 [ 1] 18: ireturn ---------- Locals 0: n For each instruction i in a basic block, an associated attribute i.sp is used to store the operand stack size in words prior to executing the instruction. <p> 1] 1: istore_1 [ 0] 2: goto 12 ---------- [ 0] 5: iload_1 <ref> [ 1] </ref> 6: iload_0 [ 2] 7: iinc 0 -1 [ 2] 10: imul [ 1] 11: istore_1 ---------- [ 0] 12: iload_0 [ 1] 13: iconst_1 [ 2] 14: if_icmpgt 5 ---------- [ 0] 17: iload_1 [ 1] 18: ireturn ---------- Locals 0: n For each instruction i in a basic block, an associated attribute i.sp is used to store the operand stack size in words prior to executing the instruction. <p> long parameter that appears in the following class Fac: class Fac - static long recLongFac (long n) - return (n &gt; 1) ? recLongFac (n-1) * n : 1; - 16 *** method 0x08 recLongFac (J)J 2-&gt;2 ---------- [ 0] 0: lload_0 [ 2] 1: lconst_1 [ 4] 2: lcmp <ref> [ 1] </ref> 3: ifle 15 ---------- [ 0] 6: lload_0 [ 2] 7: lconst_1 [ 4] 8: lsub ---------- *[ 2] 9: invokestatic Fac.recLongFac (J)J ---------- [ 2] 12: lload_0 [ 4] 13: lmul [ 2] 14: lreturn ---------- [ 0] 15: lconst_1 [ 2] 16: lreturn ---------- Locals 0: n <p> In the branch that implements a simple form of constant folding <ref> [1, ch10] </ref>, operator C i performs the appropriate operation on stack state in case the result of the operation can be expressed as a new stack state component. <p> ; &gt;i if Pred (v) = ; O := (s_mod [v];s_in [v]); busy := true; s_out [v] := O; - while (busy); - 2.8 Copy and Constant Propagation Local stack state information can frequently be made slightly more accurate by using the following bytecode variants of copy and constant propagation <ref> [1, 3, 15, 35, 46, 47] </ref> on stack states. Under the assumption that no local is used before defined [26, ch8], the following replacements can be applied repetitively to the stack states associated with all instructions of a bytecode method. <p> g for this use u (viz. rd in [v 3 ] = fd 1 ; d 2 ; d 3 ; d 4 g), we have s mod [v 3 ] = hvar (fd 4 g); &gt;i. 20 *** method 0x08 init ([F [ZI)V 3-&gt;0 ---------- [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore_3 [ 0] 2: goto 22 ---------- [ 0] 5: aload_0 [ 1] 6: iload_3 [ 2] 7: aload_1 [ 3] 8: iload_3 *[ 4] 9: baload ---------- [ 3] 10: ifeq 17 ---------- [ 2] 13: fconst_1 [ 3] 14: goto 18 ---------- [ 2] 17: fconst_2 <p> ; d 2 ; d 3 ; d 4 g), we have s mod [v 3 ] = hvar (fd 4 g); &gt;i. 20 *** method 0x08 init ([F [ZI)V 3-&gt;0 ---------- [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore_3 [ 0] 2: goto 22 ---------- [ 0] 5: aload_0 [ 1] 6: iload_3 [ 2] 7: aload_1 [ 3] 8: iload_3 *[ 4] 9: baload ---------- [ 3] 10: ifeq 17 ---------- [ 2] 13: fconst_1 [ 3] 14: goto 18 ---------- [ 2] 17: fconst_2 ---------- *[ 3] 18: fastore ---------- [ 0] 19: iinc 3 1 ---------- [ <p> [ 2] 7: aload_1 [ 3] 8: iload_3 *[ 4] 9: baload ---------- [ 3] 10: ifeq 17 ---------- [ 2] 13: fconst_1 [ 3] 14: goto 18 ---------- [ 2] 17: fconst_2 ---------- *[ 3] 18: fastore ---------- [ 0] 19: iinc 3 1 ---------- [ 0] 22: iload_3 <ref> [ 1] </ref> 23: iload_2 [ 2] 24: if_icmplt 5 ---------- [ 0] 27: return ---------- Locals 0: a 2: n All other stack state modifications tuples are computed in a similar way. <p> Moreover, the improved local stack state information after applying copy and constant propagation are shown: code original stack states improved stack states d1: *** method 0x08 copy (Z)I 1-&gt;1 ---------- [ 0] 0: iconst_1 h&gt;; &gt;i d2: <ref> [ 1] </ref> 1: istore_1 hcon (1); &gt;i [ 0] 2: iload_1 h?; &gt;i d3: [ 1] 3: istore_2 hvar (fd 2 g); &gt;i hcon (1); &gt;i [ 0] 4: iload_2 h?; &gt;i d4: [ 1] 5: istore_3 hvar (fd 3 g); &gt;i hcon (1); &gt;i [ 0] 6: iload_0 h?; &gt;i <p> the improved local stack state information after applying copy and constant propagation are shown: code original stack states improved stack states d1: *** method 0x08 copy (Z)I 1-&gt;1 ---------- [ 0] 0: iconst_1 h&gt;; &gt;i d2: <ref> [ 1] </ref> 1: istore_1 hcon (1); &gt;i [ 0] 2: iload_1 h?; &gt;i d3: [ 1] 3: istore_2 hvar (fd 2 g); &gt;i hcon (1); &gt;i [ 0] 4: iload_2 h?; &gt;i d4: [ 1] 5: istore_3 hvar (fd 3 g); &gt;i hcon (1); &gt;i [ 0] 6: iload_0 h?; &gt;i [ 1] 7: ifeq 14 hvar (fd 1 g); &gt;i ---------- [ 0] 10: <p> stack states d1: *** method 0x08 copy (Z)I 1-&gt;1 ---------- [ 0] 0: iconst_1 h&gt;; &gt;i d2: <ref> [ 1] </ref> 1: istore_1 hcon (1); &gt;i [ 0] 2: iload_1 h?; &gt;i d3: [ 1] 3: istore_2 hvar (fd 2 g); &gt;i hcon (1); &gt;i [ 0] 4: iload_2 h?; &gt;i d4: [ 1] 5: istore_3 hvar (fd 3 g); &gt;i hcon (1); &gt;i [ 0] 6: iload_0 h?; &gt;i [ 1] 7: ifeq 14 hvar (fd 1 g); &gt;i ---------- [ 0] 10: iload_2 h?; &gt;i [ 1] 11: goto 15 hvar (fd 3 g); &gt;i hcon (1); &gt;i ---------- [ 0] <p> 1] 1: istore_1 hcon (1); &gt;i [ 0] 2: iload_1 h?; &gt;i d3: <ref> [ 1] </ref> 3: istore_2 hvar (fd 2 g); &gt;i hcon (1); &gt;i [ 0] 4: iload_2 h?; &gt;i d4: [ 1] 5: istore_3 hvar (fd 3 g); &gt;i hcon (1); &gt;i [ 0] 6: iload_0 h?; &gt;i [ 1] 7: ifeq 14 hvar (fd 1 g); &gt;i ---------- [ 0] 10: iload_2 h?; &gt;i [ 1] 11: goto 15 hvar (fd 3 g); &gt;i hcon (1); &gt;i ---------- [ 0] 14: iload_3 h?; &gt;i --------- [ 1] 15: iconst_1 hvar (fd 3 ; d 4 g); &gt;i hcon <p> hvar (fd 2 g); &gt;i hcon (1); &gt;i [ 0] 4: iload_2 h?; &gt;i d4: <ref> [ 1] </ref> 5: istore_3 hvar (fd 3 g); &gt;i hcon (1); &gt;i [ 0] 6: iload_0 h?; &gt;i [ 1] 7: ifeq 14 hvar (fd 1 g); &gt;i ---------- [ 0] 10: iload_2 h?; &gt;i [ 1] 11: goto 15 hvar (fd 3 g); &gt;i hcon (1); &gt;i ---------- [ 0] 14: iload_3 h?; &gt;i --------- [ 1] 15: iconst_1 hvar (fd 3 ; d 4 g); &gt;i hcon (1); &gt;i [ 2] 16: iadd hvar (fd 3 ; d 4 g); con (1)i hcon (1); <p> 3 g); &gt;i hcon (1); &gt;i [ 0] 6: iload_0 h?; &gt;i <ref> [ 1] </ref> 7: ifeq 14 hvar (fd 1 g); &gt;i ---------- [ 0] 10: iload_2 h?; &gt;i [ 1] 11: goto 15 hvar (fd 3 g); &gt;i hcon (1); &gt;i ---------- [ 0] 14: iload_3 h?; &gt;i --------- [ 1] 15: iconst_1 hvar (fd 3 ; d 4 g); &gt;i hcon (1); &gt;i [ 2] 16: iadd hvar (fd 3 ; d 4 g); con (1)i hcon (1); con (1)i [ 1] 17: ireturn hexp (1; fd 3 ; d 4 g); ?i hcon (2); ?i 21 *** method <p> goto 15 hvar (fd 3 g); &gt;i hcon (1); &gt;i ---------- [ 0] 14: iload_3 h?; &gt;i --------- <ref> [ 1] </ref> 15: iconst_1 hvar (fd 3 ; d 4 g); &gt;i hcon (1); &gt;i [ 2] 16: iadd hvar (fd 3 ; d 4 g); con (1)i hcon (1); con (1)i [ 1] 17: ireturn hexp (1; fd 3 ; d 4 g); ?i hcon (2); ?i 21 *** method 0x08 copy (Z)I 1-&gt;1 ---------- [ 0] 0: iconst_1 [ 1] 1: istore_1 [ 0] 2: iload_1 [ 1] 3: istore_2 [ 0] 4: iload_2 [ 1] 5: istore_3 [ 0] 6: <p> g); &gt;i hcon (1); &gt;i [ 2] 16: iadd hvar (fd 3 ; d 4 g); con (1)i hcon (1); con (1)i <ref> [ 1] </ref> 17: ireturn hexp (1; fd 3 ; d 4 g); ?i hcon (2); ?i 21 *** method 0x08 copy (Z)I 1-&gt;1 ---------- [ 0] 0: iconst_1 [ 1] 1: istore_1 [ 0] 2: iload_1 [ 1] 3: istore_2 [ 0] 4: iload_2 [ 1] 5: istore_3 [ 0] 6: iload_0 [ 1] 7: ifeq 14 ---------- [ 0] 10: iload_2 [ 1] 11: goto 15 ---------- [ 0] 14: iload_3 ---------- [ 1] 15: iconst_1 [ 2] <p> iadd hvar (fd 3 ; d 4 g); con (1)i hcon (1); con (1)i <ref> [ 1] </ref> 17: ireturn hexp (1; fd 3 ; d 4 g); ?i hcon (2); ?i 21 *** method 0x08 copy (Z)I 1-&gt;1 ---------- [ 0] 0: iconst_1 [ 1] 1: istore_1 [ 0] 2: iload_1 [ 1] 3: istore_2 [ 0] 4: iload_2 [ 1] 5: istore_3 [ 0] 6: iload_0 [ 1] 7: ifeq 14 ---------- [ 0] 10: iload_2 [ 1] 11: goto 15 ---------- [ 0] 14: iload_3 ---------- [ 1] 15: iconst_1 [ 2] 16: iadd [ 1] 17: ireturn ---------- Locals <p> con (1)i hcon (1); con (1)i <ref> [ 1] </ref> 17: ireturn hexp (1; fd 3 ; d 4 g); ?i hcon (2); ?i 21 *** method 0x08 copy (Z)I 1-&gt;1 ---------- [ 0] 0: iconst_1 [ 1] 1: istore_1 [ 0] 2: iload_1 [ 1] 3: istore_2 [ 0] 4: iload_2 [ 1] 5: istore_3 [ 0] 6: iload_0 [ 1] 7: ifeq 14 ---------- [ 0] 10: iload_2 [ 1] 11: goto 15 ---------- [ 0] 14: iload_3 ---------- [ 1] 15: iconst_1 [ 2] 16: iadd [ 1] 17: ireturn ---------- Locals 0: b 2: j For example, let i <p> 17: ireturn hexp (1; fd 3 ; d 4 g); ?i hcon (2); ?i 21 *** method 0x08 copy (Z)I 1-&gt;1 ---------- [ 0] 0: iconst_1 <ref> [ 1] </ref> 1: istore_1 [ 0] 2: iload_1 [ 1] 3: istore_2 [ 0] 4: iload_2 [ 1] 5: istore_3 [ 0] 6: iload_0 [ 1] 7: ifeq 14 ---------- [ 0] 10: iload_2 [ 1] 11: goto 15 ---------- [ 0] 14: iload_3 ---------- [ 1] 15: iconst_1 [ 2] 16: iadd [ 1] 17: ireturn ---------- Locals 0: b 2: j For example, let i denote the instruction at address 5 with associated <p> ?i hcon (2); ?i 21 *** method 0x08 copy (Z)I 1-&gt;1 ---------- [ 0] 0: iconst_1 <ref> [ 1] </ref> 1: istore_1 [ 0] 2: iload_1 [ 1] 3: istore_2 [ 0] 4: iload_2 [ 1] 5: istore_3 [ 0] 6: iload_0 [ 1] 7: ifeq 14 ---------- [ 0] 10: iload_2 [ 1] 11: goto 15 ---------- [ 0] 14: iload_3 ---------- [ 1] 15: iconst_1 [ 2] 16: iadd [ 1] 17: ireturn ---------- Locals 0: b 2: j For example, let i denote the instruction at address 5 with associated stack state hvar (fd 3 g); &gt;i, where the only <p> ---------- [ 0] 0: iconst_1 <ref> [ 1] </ref> 1: istore_1 [ 0] 2: iload_1 [ 1] 3: istore_2 [ 0] 4: iload_2 [ 1] 5: istore_3 [ 0] 6: iload_0 [ 1] 7: ifeq 14 ---------- [ 0] 10: iload_2 [ 1] 11: goto 15 ---------- [ 0] 14: iload_3 ---------- [ 1] 15: iconst_1 [ 2] 16: iadd [ 1] 17: ireturn ---------- Locals 0: b 2: j For example, let i denote the instruction at address 5 with associated stack state hvar (fd 3 g); &gt;i, where the only definition d 3 is formed by instruction i 0 at address <p> istore_1 [ 0] 2: iload_1 <ref> [ 1] </ref> 3: istore_2 [ 0] 4: iload_2 [ 1] 5: istore_3 [ 0] 6: iload_0 [ 1] 7: ifeq 14 ---------- [ 0] 10: iload_2 [ 1] 11: goto 15 ---------- [ 0] 14: iload_3 ---------- [ 1] 15: iconst_1 [ 2] 16: iadd [ 1] 17: ireturn ---------- Locals 0: b 2: j For example, let i denote the instruction at address 5 with associated stack state hvar (fd 3 g); &gt;i, where the only definition d 3 is formed by instruction i 0 at address 3. <p> For an imul instruction, however, it would be useful to propagate the improved stack state locally, in order to apply a constant folding rule that was not formerly applicable: locally propagated code original stack states improved stack states constant folding ... <ref> [ 1] </ref> 15: iconst_1 hvar (fd 3 ; d 4 g); &gt;i hcon (1); &gt;i [ 2] 16: imul hvar (fd 3 ; d 4 g); con (1)i hcon (1); con (1)i [ 1] 17: ireturn h?; ?i h?; ?i hcon (1); ?i 2.9 Array Reference Chasing After partial stack states <p> rule that was not formerly applicable: locally propagated code original stack states improved stack states constant folding ... <ref> [ 1] </ref> 15: iconst_1 hvar (fd 3 ; d 4 g); &gt;i hcon (1); &gt;i [ 2] 16: imul hvar (fd 3 ; d 4 g); con (1)i hcon (1); con (1)i [ 1] 17: ireturn h?; ?i h?; ?i hcon (1); ?i 2.9 Array Reference Chasing After partial stack states have been computed for a method, and after copy and constant propagation have been accounted for, the compiler can use this information to partially trace the usage of arrays in a bytecode <p> Consider the following Java instance method decl () in a class `Decl' that is a subclass of the class `java.lang.Thread': class Decl extends Thread - Thread [] decl (Thread [][] t) - Thread [] nt = new Thread [2]; nt [0] = this; nt <ref> [1] </ref> = t [0][0]; return nt; - The bytecode, corresponding flow graph G = hV; E; v 0 i, and local variables usage are shown in this of type t 1 =`LDecl;' to the method (here we assume that the class declaration appears in the default package). <p> Likewise, each var (fd 2 g) component is replaced by apar (1; 2), indicating a reference to the two-dimensional array passed as parameter into local 1. The aaload 23 *** method 0x00 decl ([[Ljava/lang/Thread;) [Ljava/lang/Thread; 2-&gt;1 ---------- [ 0] 0: iconst_2 *<ref> [ 1] </ref> 1: anewarray java.lang.Thread ---------- [ 1] 4: astore_2 [ 0] 5: aload_2 [ 1] 6: iconst_0 [ 2] 7: aload_0 *[ 3] 8: aastore ---------- [ 0] 9: aload_2 [ 1] 10: iconst_1 [ 2] 11: aload_1 [ 3] 12: iconst_0 *[ 4] 13: aaload ---------- [ 3] 14: iconst_0 *[ 4] 15: aaload ---------- <p> The aaload 23 *** method 0x00 decl ([[Ljava/lang/Thread;) [Ljava/lang/Thread; 2-&gt;1 ---------- [ 0] 0: iconst_2 *<ref> [ 1] </ref> 1: anewarray java.lang.Thread ---------- [ 1] 4: astore_2 [ 0] 5: aload_2 [ 1] 6: iconst_0 [ 2] 7: aload_0 *[ 3] 8: aastore ---------- [ 0] 9: aload_2 [ 1] 10: iconst_1 [ 2] 11: aload_1 [ 3] 12: iconst_0 *[ 4] 13: aaload ---------- [ 3] 14: iconst_0 *[ 4] 15: aaload ---------- *[ 3] 16: aastore ---------- [ 0] 17: <p> The aaload 23 *** method 0x00 decl ([[Ljava/lang/Thread;) [Ljava/lang/Thread; 2-&gt;1 ---------- [ 0] 0: iconst_2 *<ref> [ 1] </ref> 1: anewarray java.lang.Thread ---------- [ 1] 4: astore_2 [ 0] 5: aload_2 [ 1] 6: iconst_0 [ 2] 7: aload_0 *[ 3] 8: aastore ---------- [ 0] 9: aload_2 [ 1] 10: iconst_1 [ 2] 11: aload_1 [ 3] 12: iconst_0 *[ 4] 13: aaload ---------- [ 3] 14: iconst_0 *[ 4] 15: aaload ---------- *[ 3] 16: aastore ---------- [ 0] 17: aload_2 [ 1] 18: areturn ---------- Locals 0: this 1: t instruction at address 13 effectively converts <p> 6: iconst_0 [ 2] 7: aload_0 *[ 3] 8: aastore ---------- [ 0] 9: aload_2 <ref> [ 1] </ref> 10: iconst_1 [ 2] 11: aload_1 [ 3] 12: iconst_0 *[ 4] 13: aaload ---------- [ 3] 14: iconst_0 *[ 4] 15: aaload ---------- *[ 3] 16: aastore ---------- [ 0] 17: aload_2 [ 1] 18: areturn ---------- Locals 0: this 1: t instruction at address 13 effectively converts this reference into apar (1; 1), i.e. a reference to the last dimension of this array. <p> aastore at address 16 becomes a `?' after it has been chased back to the aaload at 15: code initial stack states chased stack states d1,2:*** method 0x00 decl... ---------- [ 0] 0: iconst_2 h&gt;; &gt;; &gt;; &gt;i *<ref> [ 1] </ref> 1: anewarray ... hcon (2); &gt;; &gt;; &gt;i ---------- d3: [ 1] 4: astore_2 href (1); &gt;; &gt;; &gt;i hadecl (1; 1); &gt;; &gt;; &gt;i [ 0] 5: aload_2 h?; &gt;; &gt;; &gt;i [ 1] 6: iconst_0 href (1); &gt;; &gt;; &gt;i hadecl (1; 1); &gt;; &gt;; &gt;i [ 2] 7: aload_0 href (1); con (0); &gt;; &gt;i hadecl (1; 1); <p> stack states d1,2:*** method 0x00 decl... ---------- [ 0] 0: iconst_2 h&gt;; &gt;; &gt;; &gt;i *<ref> [ 1] </ref> 1: anewarray ... hcon (2); &gt;; &gt;; &gt;i ---------- d3: [ 1] 4: astore_2 href (1); &gt;; &gt;; &gt;i hadecl (1; 1); &gt;; &gt;; &gt;i [ 0] 5: aload_2 h?; &gt;; &gt;; &gt;i [ 1] 6: iconst_0 href (1); &gt;; &gt;; &gt;i hadecl (1; 1); &gt;; &gt;; &gt;i [ 2] 7: aload_0 href (1); con (0); &gt;; &gt;i hadecl (1; 1); con (0); &gt;; &gt;i *[ 3] 8: aastore href (1); con (0); var (fd 1 g); &gt;i hadecl (1; 1); con (0); var <p> &gt;i [ 2] 7: aload_0 href (1); con (0); &gt;; &gt;i hadecl (1; 1); con (0); &gt;; &gt;i *[ 3] 8: aastore href (1); con (0); var (fd 1 g); &gt;i hadecl (1; 1); con (0); var (fd 1 g); &gt;i ---------- [ 0] 9: aload_2 h?; ?; ?; &gt;i <ref> [ 1] </ref> 10: iconst_1 href (1); ?; ?; &gt;i hadecl (1; 1); ?; ?; &gt;i [ 2] 11: aload_1 href (1); con (1); ?; &gt;i hadecl (1; 1); con (1); ?; &gt;i [ 3] 12: iconst_0 href (1); con (1); var (fd 2 g); &gt;i hadecl (1; 1); con (1); apar <p> *[ 4] 15: aaload href (1); con (1); ref (13); con (0)i hadecl (1; 1); con (1); apar (1; 1); con (0)i ---------- *[ 3] 16: aastore href (1); con (1); ref (15); ?i hadecl (1; 1); con (1); ?; ?i ---------- [ 0] 17: aload_2 h?; ?; ?; ?i <ref> [ 1] </ref> 18: areturn href (1); ?; ?; ?i hadecl (1; 1); ?; ?; ?i 24 3 Bytecode Parallelization After the bytecode of a method has been analyzed, all natural loops are examined by the compiler to automatically detect and exploit implicit parallelism in these loops. <p> add_field (double [] a, int n) - for (int i = 0; i &lt; n; i++) - 4 In fact, this constraint can be slightly relaxed by allowing invocations of side-effect free static methods such as `java.lang.Math.cos ()'. 26 *** method 0x00 add_field ([DI)V 3-&gt;0 ---------- [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore_3 [ 0] 2: goto 18 ---------- [ 0] 5: aload_1 [ 1] 6: iload_3 [ 2] 7: dup2 *[ 4] 8: daload ---------- [ 4] 9: aload_0 *[ 5] 10: getfield Field.d D ---------- [ 6] 13: dadd *[ 4] 14: dastore ---------- [ 0] 15: iinc <p> n; i++) - 4 In fact, this constraint can be slightly relaxed by allowing invocations of side-effect free static methods such as `java.lang.Math.cos ()'. 26 *** method 0x00 add_field ([DI)V 3-&gt;0 ---------- [ 0] 0: iconst_0 <ref> [ 1] </ref> 1: istore_3 [ 0] 2: goto 18 ---------- [ 0] 5: aload_1 [ 1] 6: iload_3 [ 2] 7: dup2 *[ 4] 8: daload ---------- [ 4] 9: aload_0 *[ 5] 10: getfield Field.d D ---------- [ 6] 13: dadd *[ 4] 14: dastore ---------- [ 0] 15: iinc 3 1 ---------- [ 0] 18: iload_3 [ 1] 19: iload_2 [ 2] 20: <p> 18 ---------- [ 0] 5: aload_1 <ref> [ 1] </ref> 6: iload_3 [ 2] 7: dup2 *[ 4] 8: daload ---------- [ 4] 9: aload_0 *[ 5] 10: getfield Field.d D ---------- [ 6] 13: dadd *[ 4] 14: dastore ---------- [ 0] 15: iinc 3 1 ---------- [ 0] 18: iload_3 [ 1] 19: iload_2 [ 2] 20: if_icmplt 5 ---------- [ 0] 23: return ---------- Locals 0: this 1: a 3: i The bytecode, corresponding flow graph G = hV; E; v 0 i, and local variables usage are shown in d 1 d 2 d 3 d 4 d 5 <p> ? 1 15 par. type t [D I Local stack state information for instructions in the trivial loop L = fv 1 ; v 3 ; : : : ; v 6 g is shown below: code stack states ... [ 0] 5: aload_1 h?; ?; ?; ?; ?; ?i <ref> [ 1] </ref> 6: iload_3 hapar (1; 1); ?; ?; ?; ?; ?i [ 2] 7: dup2 hapar (1; 1); var (fd 4 ; d 5 g); ?; ?; ?; ?i *[ 4] 8: daload hapar (1; 1); var (fd 4 ; d 5 g); apar (1; 1); var (fd 4 ; <p> Loop-carried output and anti dependences caused by local scalars will be resolved in the parallel loop by letting each thread operate on a separate set of locals. Constraint (II) states that all local scalars defined in the loop must be dead <ref> [1, ch10] </ref> on exit of the loop. <p> Moreover, the same definition d 5 in v 5 2 L reaches the use u 8 in basic block v 2 =2 L (thereby causing a loop-exiting flow dependence). 28 *** method 0x08 scalardep ([Z [I)I 2-&gt;1 ---------- [ 0] 0: iconst_5 <ref> [ 1] </ref> 1: istore_3 [ 0] 2: iconst_0 [ 1] 3: istore_2 [ 0] 4: goto 22 ---------- [ 0] 7: aload_0 [ 1] 8: iload_2 *[ 2] 9: baload ---------- [ 1] 10: ifeq 15 ---------- [ 0] 13: iconst_2 [ 1] 14: istore_3 ---------- [ 0] 15: aload_1 [ <p> Moreover, the same definition d 5 in v 5 2 L reaches the use u 8 in basic block v 2 =2 L (thereby causing a loop-exiting flow dependence). 28 *** method 0x08 scalardep ([Z [I)I 2-&gt;1 ---------- [ 0] 0: iconst_5 <ref> [ 1] </ref> 1: istore_3 [ 0] 2: iconst_0 [ 1] 3: istore_2 [ 0] 4: goto 22 ---------- [ 0] 7: aload_0 [ 1] 8: iload_2 *[ 2] 9: baload ---------- [ 1] 10: ifeq 15 ---------- [ 0] 13: iconst_2 [ 1] 14: istore_3 ---------- [ 0] 15: aload_1 [ 1] 16: iload_2 [ 2] 17: iload_3 *[ <p> u 8 in basic block v 2 =2 L (thereby causing a loop-exiting flow dependence). 28 *** method 0x08 scalardep ([Z [I)I 2-&gt;1 ---------- [ 0] 0: iconst_5 <ref> [ 1] </ref> 1: istore_3 [ 0] 2: iconst_0 [ 1] 3: istore_2 [ 0] 4: goto 22 ---------- [ 0] 7: aload_0 [ 1] 8: iload_2 *[ 2] 9: baload ---------- [ 1] 10: ifeq 15 ---------- [ 0] 13: iconst_2 [ 1] 14: istore_3 ---------- [ 0] 15: aload_1 [ 1] 16: iload_2 [ 2] 17: iload_3 *[ 3] 18: iastore ---------- [ 0] 19: iinc 2 1 ---------- [ 0] 22: <p> (thereby causing a loop-exiting flow dependence). 28 *** method 0x08 scalardep ([Z [I)I 2-&gt;1 ---------- [ 0] 0: iconst_5 <ref> [ 1] </ref> 1: istore_3 [ 0] 2: iconst_0 [ 1] 3: istore_2 [ 0] 4: goto 22 ---------- [ 0] 7: aload_0 [ 1] 8: iload_2 *[ 2] 9: baload ---------- [ 1] 10: ifeq 15 ---------- [ 0] 13: iconst_2 [ 1] 14: istore_3 ---------- [ 0] 15: aload_1 [ 1] 16: iload_2 [ 2] 17: iload_3 *[ 3] 18: iastore ---------- [ 0] 19: iinc 2 1 ---------- [ 0] 22: iload_2 [ 1] 23: bipush 100 [ 2] 25: <p> scalardep ([Z [I)I 2-&gt;1 ---------- [ 0] 0: iconst_5 <ref> [ 1] </ref> 1: istore_3 [ 0] 2: iconst_0 [ 1] 3: istore_2 [ 0] 4: goto 22 ---------- [ 0] 7: aload_0 [ 1] 8: iload_2 *[ 2] 9: baload ---------- [ 1] 10: ifeq 15 ---------- [ 0] 13: iconst_2 [ 1] 14: istore_3 ---------- [ 0] 15: aload_1 [ 1] 16: iload_2 [ 2] 17: iload_3 *[ 3] 18: iastore ---------- [ 0] 19: iinc 2 1 ---------- [ 0] 22: iload_2 [ 1] 23: bipush 100 [ 2] 25: if_icmplt 7 ---------- [ 0] 28: iload_3 [ 1] 29: <p> <ref> [ 1] </ref> 1: istore_3 [ 0] 2: iconst_0 [ 1] 3: istore_2 [ 0] 4: goto 22 ---------- [ 0] 7: aload_0 [ 1] 8: iload_2 *[ 2] 9: baload ---------- [ 1] 10: ifeq 15 ---------- [ 0] 13: iconst_2 [ 1] 14: istore_3 ---------- [ 0] 15: aload_1 [ 1] 16: iload_2 [ 2] 17: iload_3 *[ 3] 18: iastore ---------- [ 0] 19: iinc 2 1 ---------- [ 0] 22: iload_2 [ 1] 23: bipush 100 [ 2] 25: if_icmplt 7 ---------- [ 0] 28: iload_3 [ 1] 29: ireturn ---------- Locals 0: b 2: i 3.2.3 Analysis <p> 8: iload_2 *[ 2] 9: baload ---------- <ref> [ 1] </ref> 10: ifeq 15 ---------- [ 0] 13: iconst_2 [ 1] 14: istore_3 ---------- [ 0] 15: aload_1 [ 1] 16: iload_2 [ 2] 17: iload_3 *[ 3] 18: iastore ---------- [ 0] 19: iinc 2 1 ---------- [ 0] 22: iload_2 [ 1] 23: bipush 100 [ 2] 25: if_icmplt 7 ---------- [ 0] 28: iload_3 [ 1] 29: ireturn ---------- Locals 0: b 2: i 3.2.3 Analysis of Arrays As a final step in the automatic detection of implicit parallelism, the compiler verifies if none of the array instructions &lt;t&gt;aload and <p> 13: iconst_2 <ref> [ 1] </ref> 14: istore_3 ---------- [ 0] 15: aload_1 [ 1] 16: iload_2 [ 2] 17: iload_3 *[ 3] 18: iastore ---------- [ 0] 19: iinc 2 1 ---------- [ 0] 22: iload_2 [ 1] 23: bipush 100 [ 2] 25: if_icmplt 7 ---------- [ 0] 28: iload_3 [ 1] 29: ireturn ---------- Locals 0: b 2: i 3.2.3 Analysis of Arrays As a final step in the automatic detection of implicit parallelism, the compiler verifies if none of the array instructions &lt;t&gt;aload and &lt;t&gt;astore in a candidate parallel loop give rise to loop-carried data dependences or a transfer <p> (viz. i 2 [1; 500); j 2 [4; 101); k 2 [5; 98)): static void bound (int a []) - for (int i = 1; i &lt; 500; i++) for (int k = j+1; k &lt; j-2; k++) - code stack states ... [ 0] 12: iload_2 h?; ?; ?i <ref> [ 1] </ref> 13: iconst_1 hvar (fd 3 ; d 6 g); ?; ?i d4: [ 2] 14: iadd hvar (fd 3 ; d 6 g); con (1); ?i [ 1] 15: istore_3 hexp (1; fd 3 ; d 6 g); ?; ?i [ 0] 16: goto 28 h?; ?; ?i ---------- <p> i++) for (int k = j+1; k &lt; j-2; k++) - code stack states ... [ 0] 12: iload_2 h?; ?; ?i <ref> [ 1] </ref> 13: iconst_1 hvar (fd 3 ; d 6 g); ?; ?i d4: [ 2] 14: iadd hvar (fd 3 ; d 6 g); con (1); ?i [ 1] 15: istore_3 hexp (1; fd 3 ; d 6 g); ?; ?i [ 0] 16: goto 28 h?; ?; ?i ---------- [ 0] 19: aload_0 h?; ?; ?i [ 1] 20: iload_3 hapar (0; 1); ?; ?i [ 2] 21: iconst_4 hapar (0; 1); var (fd 4 ; d <p> d 6 g); ?; ?i d4: [ 2] 14: iadd hvar (fd 3 ; d 6 g); con (1); ?i <ref> [ 1] </ref> 15: istore_3 hexp (1; fd 3 ; d 6 g); ?; ?i [ 0] 16: goto 28 h?; ?; ?i ---------- [ 0] 19: aload_0 h?; ?; ?i [ 1] 20: iload_3 hapar (0; 1); ?; ?i [ 2] 21: iconst_4 hapar (0; 1); var (fd 4 ; d 5 g); ?i [ 3] 22: iadd hapar (0; 1); var (fd 4 ; d 5 g); con (4)i [ 2] 23: iconst_1 hapar (0; 1); exp (4; fd 4 <p> 23: iconst_1 hapar (0; 1); exp (4; fd 4 ; d 5 g); ?i *[ 3] 24: iastore hapar (0; 1); exp (4; fd 4 ; d 5 g); con (1)i ---------- d5: [ 0] 25: iinc 3 1 h?; ?; ?i ---------- [ 0] 28: iload_3 h?; ?; ?i <ref> [ 1] </ref> 29: iload_2 hvar (fd 4 ; d 5 g); ?; ?i [ 2] 30: iconst_2 hvar (fd 4 ; d 5 g); var (fd 3 ; d 6 g); ?i [ 3] 31: isub hvar (fd 4 ; d 5 g); var (fd 3 ; d 6 g); con <p> For example, with respect to the trivial i-loop in the bytecode equivalent of the following Java fragment, access tuple h [0; 2]; ?i will eventually be associated with the array parameter a. Likewise, with respect to the j-loop, access tuple h?; <ref> [1; +1] </ref>i will eventually be associated with a. <p> our bytecode analysis eventually reveals that the method performs the operation `a [i][j] += 1;' for all elements of an mfin array, where m and n are parameters of the method: 32 code stack states *** method 0x08 par (II)[[I 2-&gt;1 ---------- [ 0] 0: iload_0 h&gt;; &gt;; &gt;; &gt;i <ref> [ 1] </ref> 1: iload_1 hvar (fd 1 g); &gt;; &gt;; &gt;i *[ 2] 2: multianewarray [[I hvar (fd 1 g); var (fd 2 g); &gt;; &gt;i ---------- [ 1] 6: astore_2 hadecl (2; 2); &gt;; &gt;; &gt;i ... [ 0] 40: aload 7 h?; ?; ?; ?i [ 1] 42: iload <p> parameters of the method: 32 code stack states *** method 0x08 par (II)[[I 2-&gt;1 ---------- [ 0] 0: iload_0 h&gt;; &gt;; &gt;; &gt;i <ref> [ 1] </ref> 1: iload_1 hvar (fd 1 g); &gt;; &gt;; &gt;i *[ 2] 2: multianewarray [[I hvar (fd 1 g); var (fd 2 g); &gt;; &gt;i ---------- [ 1] 6: astore_2 hadecl (2; 2); &gt;; &gt;; &gt;i ... [ 0] 40: aload 7 h?; ?; ?; ?i [ 1] 42: iload 9 hadecl (2; 1); ?; ?; ?i [ 2] 44: aload 8 hadecl (2; 1); var (fd 10 ; d 11 g); ?; ?i [ 3] 46: <p> &gt;; &gt;; &gt;i <ref> [ 1] </ref> 1: iload_1 hvar (fd 1 g); &gt;; &gt;; &gt;i *[ 2] 2: multianewarray [[I hvar (fd 1 g); var (fd 2 g); &gt;; &gt;i ---------- [ 1] 6: astore_2 hadecl (2; 2); &gt;; &gt;; &gt;i ... [ 0] 40: aload 7 h?; ?; ?; ?i [ 1] 42: iload 9 hadecl (2; 1); ?; ?; ?i [ 2] 44: aload 8 hadecl (2; 1); var (fd 10 ; d 11 g); ?; ?i [ 3] 46: iload 9 hadecl (2; 1); var (fd 10 ; d 11 g); adecl (2; 1); ?i *[ 4] 48: iaload <p> hadecl (2; 1); var (fd 10 ; d 11 g); ?; con (1)i *[ 3] 51: iastore hadecl (2; 1); var (fd 10 ; d 11 g); ?; ?i ---------- [ 0] 52: iinc 9 1 h?; ?; ?; ?i ---------- [ 0] 55: iload 9 h?; ?; ?; ?i <ref> [ 1] </ref> 57: iload 4 hvar (fd 10 ; d 11 g); ?; ?; ?i [ 2] 59: if_icmplt :40 hvar (fd 10 ; d 11 g); var (fd 2 g); ?; ?i ---------- In the flow graph, the two back edges (v 8 ; v 2 ) 2 E and <p> This indicates that references to this array do not cause any data dependences that are carried by the outer trivial loop, which implies that the i-loop can be executed in parallel. 33 *** method 0x08 par (II)[[I 2-&gt;1 [0,73) -&gt; 73 java.lang.Exception ---------- [ 0] 0: iload_0 <ref> [ 1] </ref> 1: iload_1 *[ 2] 2: multianewarray [[I ---------- [ 1] 6: astore_2 [ 0] 7: iload_0 [ 1] 8: istore_3 [ 0] 9: iload_1 [ 1] 10: istore 4 [ 0] 12: iconst_0 [ 1] 13: istore 5 [ 0] 15: goto 65 ---------- [ 0] 18: iload 5 <p> do not cause any data dependences that are carried by the outer trivial loop, which implies that the i-loop can be executed in parallel. 33 *** method 0x08 par (II)[[I 2-&gt;1 [0,73) -&gt; 73 java.lang.Exception ---------- [ 0] 0: iload_0 <ref> [ 1] </ref> 1: iload_1 *[ 2] 2: multianewarray [[I ---------- [ 1] 6: astore_2 [ 0] 7: iload_0 [ 1] 8: istore_3 [ 0] 9: iload_1 [ 1] 10: istore 4 [ 0] 12: iconst_0 [ 1] 13: istore 5 [ 0] 15: goto 65 ---------- [ 0] 18: iload 5 [ 1] 20: istore 6 [ 0] 22: aload_2 [ <p> carried by the outer trivial loop, which implies that the i-loop can be executed in parallel. 33 *** method 0x08 par (II)[[I 2-&gt;1 [0,73) -&gt; 73 java.lang.Exception ---------- [ 0] 0: iload_0 <ref> [ 1] </ref> 1: iload_1 *[ 2] 2: multianewarray [[I ---------- [ 1] 6: astore_2 [ 0] 7: iload_0 [ 1] 8: istore_3 [ 0] 9: iload_1 [ 1] 10: istore 4 [ 0] 12: iconst_0 [ 1] 13: istore 5 [ 0] 15: goto 65 ---------- [ 0] 18: iload 5 [ 1] 20: istore 6 [ 0] 22: aload_2 [ 1] 23: iload 5 *[ 2] 25: aaload <p> that the i-loop can be executed in parallel. 33 *** method 0x08 par (II)[[I 2-&gt;1 [0,73) -&gt; 73 java.lang.Exception ---------- [ 0] 0: iload_0 <ref> [ 1] </ref> 1: iload_1 *[ 2] 2: multianewarray [[I ---------- [ 1] 6: astore_2 [ 0] 7: iload_0 [ 1] 8: istore_3 [ 0] 9: iload_1 [ 1] 10: istore 4 [ 0] 12: iconst_0 [ 1] 13: istore 5 [ 0] 15: goto 65 ---------- [ 0] 18: iload 5 [ 1] 20: istore 6 [ 0] 22: aload_2 [ 1] 23: iload 5 *[ 2] 25: aaload ---------- [ 1] 26: astore 7 [ 0] <p> *** method 0x08 par (II)[[I 2-&gt;1 [0,73) -&gt; 73 java.lang.Exception ---------- [ 0] 0: iload_0 <ref> [ 1] </ref> 1: iload_1 *[ 2] 2: multianewarray [[I ---------- [ 1] 6: astore_2 [ 0] 7: iload_0 [ 1] 8: istore_3 [ 0] 9: iload_1 [ 1] 10: istore 4 [ 0] 12: iconst_0 [ 1] 13: istore 5 [ 0] 15: goto 65 ---------- [ 0] 18: iload 5 [ 1] 20: istore 6 [ 0] 22: aload_2 [ 1] 23: iload 5 *[ 2] 25: aaload ---------- [ 1] 26: astore 7 [ 0] 28: aload_2 [ 1] 29: iload 6 *[ 2] <p> 1] 1: iload_1 *[ 2] 2: multianewarray [[I ---------- <ref> [ 1] </ref> 6: astore_2 [ 0] 7: iload_0 [ 1] 8: istore_3 [ 0] 9: iload_1 [ 1] 10: istore 4 [ 0] 12: iconst_0 [ 1] 13: istore 5 [ 0] 15: goto 65 ---------- [ 0] 18: iload 5 [ 1] 20: istore 6 [ 0] 22: aload_2 [ 1] 23: iload 5 *[ 2] 25: aaload ---------- [ 1] 26: astore 7 [ 0] 28: aload_2 [ 1] 29: iload 6 *[ 2] 31: aaload ---------- [ 1] 32: astore 8 [ 0] 34: iconst_0 [ 1] 35: istore <p> <ref> [ 1] </ref> 6: astore_2 [ 0] 7: iload_0 [ 1] 8: istore_3 [ 0] 9: iload_1 [ 1] 10: istore 4 [ 0] 12: iconst_0 [ 1] 13: istore 5 [ 0] 15: goto 65 ---------- [ 0] 18: iload 5 [ 1] 20: istore 6 [ 0] 22: aload_2 [ 1] 23: iload 5 *[ 2] 25: aaload ---------- [ 1] 26: astore 7 [ 0] 28: aload_2 [ 1] 29: iload 6 *[ 2] 31: aaload ---------- [ 1] 32: astore 8 [ 0] 34: iconst_0 [ 1] 35: istore 9 [ 0] 37: goto 55 ---------- [ 0] <p> 8: istore_3 [ 0] 9: iload_1 <ref> [ 1] </ref> 10: istore 4 [ 0] 12: iconst_0 [ 1] 13: istore 5 [ 0] 15: goto 65 ---------- [ 0] 18: iload 5 [ 1] 20: istore 6 [ 0] 22: aload_2 [ 1] 23: iload 5 *[ 2] 25: aaload ---------- [ 1] 26: astore 7 [ 0] 28: aload_2 [ 1] 29: iload 6 *[ 2] 31: aaload ---------- [ 1] 32: astore 8 [ 0] 34: iconst_0 [ 1] 35: istore 9 [ 0] 37: goto 55 ---------- [ 0] 40: aload 7 [ 1] 42: iload 9 [ 2] <p> istore 4 [ 0] 12: iconst_0 <ref> [ 1] </ref> 13: istore 5 [ 0] 15: goto 65 ---------- [ 0] 18: iload 5 [ 1] 20: istore 6 [ 0] 22: aload_2 [ 1] 23: iload 5 *[ 2] 25: aaload ---------- [ 1] 26: astore 7 [ 0] 28: aload_2 [ 1] 29: iload 6 *[ 2] 31: aaload ---------- [ 1] 32: astore 8 [ 0] 34: iconst_0 [ 1] 35: istore 9 [ 0] 37: goto 55 ---------- [ 0] 40: aload 7 [ 1] 42: iload 9 [ 2] 44: aload 8 [ 3] 46: iload 9 *[ <p> 5 [ 0] 15: goto 65 ---------- [ 0] 18: iload 5 <ref> [ 1] </ref> 20: istore 6 [ 0] 22: aload_2 [ 1] 23: iload 5 *[ 2] 25: aaload ---------- [ 1] 26: astore 7 [ 0] 28: aload_2 [ 1] 29: iload 6 *[ 2] 31: aaload ---------- [ 1] 32: astore 8 [ 0] 34: iconst_0 [ 1] 35: istore 9 [ 0] 37: goto 55 ---------- [ 0] 40: aload 7 [ 1] 42: iload 9 [ 2] 44: aload 8 [ 3] 46: iload 9 *[ 4] 48: iaload ---------- [ 3] 49: iconst_1 [ 4] <p> 18: iload 5 <ref> [ 1] </ref> 20: istore 6 [ 0] 22: aload_2 [ 1] 23: iload 5 *[ 2] 25: aaload ---------- [ 1] 26: astore 7 [ 0] 28: aload_2 [ 1] 29: iload 6 *[ 2] 31: aaload ---------- [ 1] 32: astore 8 [ 0] 34: iconst_0 [ 1] 35: istore 9 [ 0] 37: goto 55 ---------- [ 0] 40: aload 7 [ 1] 42: iload 9 [ 2] 44: aload 8 [ 3] 46: iload 9 *[ 4] 48: iaload ---------- [ 3] 49: iconst_1 [ 4] 50: iadd *[ 3] 51: iastore ---------- [ 0] <p> 5 *[ 2] 25: aaload ---------- <ref> [ 1] </ref> 26: astore 7 [ 0] 28: aload_2 [ 1] 29: iload 6 *[ 2] 31: aaload ---------- [ 1] 32: astore 8 [ 0] 34: iconst_0 [ 1] 35: istore 9 [ 0] 37: goto 55 ---------- [ 0] 40: aload 7 [ 1] 42: iload 9 [ 2] 44: aload 8 [ 3] 46: iload 9 *[ 4] 48: iaload ---------- [ 3] 49: iconst_1 [ 4] 50: iadd *[ 3] 51: iastore ---------- [ 0] 52: iinc 9 1 ---------- [ 0] 55: iload 9 [ 1] 57: iload 4 [ <p> [ 0] 40: aload 7 <ref> [ 1] </ref> 42: iload 9 [ 2] 44: aload 8 [ 3] 46: iload 9 *[ 4] 48: iaload ---------- [ 3] 49: iconst_1 [ 4] 50: iadd *[ 3] 51: iastore ---------- [ 0] 52: iinc 9 1 ---------- [ 0] 55: iload 9 [ 1] 57: iload 4 [ 2] 59: if_icmplt 40 ---------- [ 0] 62: iinc 5 1 ---------- [ 0] 65: iload 5 [ 1] 67: iload_3 [ 2] 68: if_icmplt 18 ---------- [ 0] 71: aload_2 [ 1] 72: areturn ---------- [ 0] 74: aconst_null [ 1] 75: areturn ---------- <p> iaload ---------- [ 3] 49: iconst_1 [ 4] 50: iadd *[ 3] 51: iastore ---------- [ 0] 52: iinc 9 1 ---------- [ 0] 55: iload 9 <ref> [ 1] </ref> 57: iload 4 [ 2] 59: if_icmplt 40 ---------- [ 0] 62: iinc 5 1 ---------- [ 0] 65: iload 5 [ 1] 67: iload_3 [ 2] 68: if_icmplt 18 ---------- [ 0] 71: aload_2 [ 1] 72: areturn ---------- [ 0] 74: aconst_null [ 1] 75: areturn ---------- Locals 0: m 2: a 4: nc 6: k 8: q 34 3.3 Exploitation of Implicit Loop Parallelism If a trivial loop L <p> ---------- [ 0] 52: iinc 9 1 ---------- [ 0] 55: iload 9 <ref> [ 1] </ref> 57: iload 4 [ 2] 59: if_icmplt 40 ---------- [ 0] 62: iinc 5 1 ---------- [ 0] 65: iload 5 [ 1] 67: iload_3 [ 2] 68: if_icmplt 18 ---------- [ 0] 71: aload_2 [ 1] 72: areturn ---------- [ 0] 74: aconst_null [ 1] 75: areturn ---------- Locals 0: m 2: a 4: nc 6: k 8: q 34 3.3 Exploitation of Implicit Loop Parallelism If a trivial loop L V in a method with flow graph G = hV; E; v 0 i <p> 0] 55: iload 9 <ref> [ 1] </ref> 57: iload 4 [ 2] 59: if_icmplt 40 ---------- [ 0] 62: iinc 5 1 ---------- [ 0] 65: iload 5 [ 1] 67: iload_3 [ 2] 68: if_icmplt 18 ---------- [ 0] 71: aload_2 [ 1] 72: areturn ---------- [ 0] 74: aconst_null [ 1] 75: areturn ---------- Locals 0: m 2: a 4: nc 6: k 8: q 34 3.3 Exploitation of Implicit Loop Parallelism If a trivial loop L V in a method with flow graph G = hV; E; v 0 i satisfies all the constraints of the previous sections, implicit <p> For instance, the ldc2 w instruction at 27 refers to the CONSTANT Double entry 7 (making entry 8 invalid). Moreover, the method invocation instruction at 31 refers to the CONSTANT Methodref entry 5 and, hence, indirect to entries 1, 10, 11, 24, and 25: --&gt; constant_pool <ref> [ 1] </ref>: &lt;Class&gt; java/lang/Math constant_pool [ 2]: &lt;Class&gt; java/lang/Object constant_pool [ 3]: &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: <p> constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 <ref> [ 1] </ref> 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [ 1] 10: astore_2 [ 0] 11: iconst_0 [ 1] 12: istore_3 [ 0] 13: goto 50 ---------- [ 0] 16: iconst_0 [ 1] 17: istore 4 [ 0] 19: goto 39 ---------- [ 0] 22: aload_2 [ <p> [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 <ref> [ 1] </ref> 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [ 1] 10: astore_2 [ 0] 11: iconst_0 [ 1] 12: istore_3 [ 0] 13: goto 50 ---------- [ 0] 16: iconst_0 [ 1] 17: istore 4 [ 0] 19: goto 39 ---------- [ 0] 22: aload_2 [ 1] 23: iload_3 *[ 2] 24: aaload ---------- [ 1] 25: iload 4 <p> constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 <ref> [ 1] </ref> 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [ 1] 10: astore_2 [ 0] 11: iconst_0 [ 1] 12: istore_3 [ 0] 13: goto 50 ---------- [ 0] 16: iconst_0 [ 1] 17: istore 4 [ 0] 19: goto 39 ---------- [ 0] 22: aload_2 [ 1] 23: iload_3 *[ 2] 24: aaload ---------- [ 1] 25: iload 4 [ 2] 27: ldc2_w #7 &lt;Double&gt; 0x404535c28f5c28f6 [ <p> constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 <ref> [ 1] </ref> 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [ 1] 10: astore_2 [ 0] 11: iconst_0 [ 1] 12: istore_3 [ 0] 13: goto 50 ---------- [ 0] 16: iconst_0 [ 1] 17: istore 4 [ 0] 19: goto 39 ---------- [ 0] 22: aload_2 [ 1] 23: iload_3 *[ 2] 24: aaload ---------- [ 1] 25: iload 4 [ 2] 27: ldc2_w #7 &lt;Double&gt; 0x404535c28f5c28f6 [ 4] 30: dload_0 ---------- *[ 6] 31: invokestatic #5 &lt;Class&gt; java/lang/Math.sin (D)D ---------- [ <p> <ref> [ 1] </ref> 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [ 1] 10: astore_2 [ 0] 11: iconst_0 [ 1] 12: istore_3 [ 0] 13: goto 50 ---------- [ 0] 16: iconst_0 [ 1] 17: istore 4 [ 0] 19: goto 39 ---------- [ 0] 22: aload_2 [ 1] 23: iload_3 *[ 2] 24: aaload ---------- [ 1] 25: iload 4 [ 2] 27: ldc2_w #7 &lt;Double&gt; 0x404535c28f5c28f6 [ 4] 30: dload_0 ---------- *[ 6] 31: invokestatic #5 &lt;Class&gt; java/lang/Math.sin (D)D ---------- [ 6] 34: dmul *[ 4] 35: dastore ---------- [ 0] 36: iinc 4 1 ---------- <p> #3 &lt;Class&gt; [[D ---------- <ref> [ 1] </ref> 10: astore_2 [ 0] 11: iconst_0 [ 1] 12: istore_3 [ 0] 13: goto 50 ---------- [ 0] 16: iconst_0 [ 1] 17: istore 4 [ 0] 19: goto 39 ---------- [ 0] 22: aload_2 [ 1] 23: iload_3 *[ 2] 24: aaload ---------- [ 1] 25: iload 4 [ 2] 27: ldc2_w #7 &lt;Double&gt; 0x404535c28f5c28f6 [ 4] 30: dload_0 ---------- *[ 6] 31: invokestatic #5 &lt;Class&gt; java/lang/Math.sin (D)D ---------- [ 6] 34: dmul *[ 4] 35: dastore ---------- [ 0] 36: iinc 4 1 ---------- [ 0] 39: iload 4 [ 1] 41: sipush <p> 24: aaload ---------- <ref> [ 1] </ref> 25: iload 4 [ 2] 27: ldc2_w #7 &lt;Double&gt; 0x404535c28f5c28f6 [ 4] 30: dload_0 ---------- *[ 6] 31: invokestatic #5 &lt;Class&gt; java/lang/Math.sin (D)D ---------- [ 6] 34: dmul *[ 4] 35: dastore ---------- [ 0] 36: iinc 4 1 ---------- [ 0] 39: iload 4 [ 1] 41: sipush 1000 [ 2] 44: if_icmplt 22 ---------- [ 0] 47: iinc 3 1 ---------- [ 0] 50: iload_3 [ 1] 51: sipush 1000 [ 2] 54: if_icmplt 16 ---------- [ 0] 57: return ---------- If constant pool entries must be copied into the constant pool of the <p> 31: invokestatic #5 &lt;Class&gt; java/lang/Math.sin (D)D ---------- [ 6] 34: dmul *[ 4] 35: dastore ---------- [ 0] 36: iinc 4 1 ---------- [ 0] 39: iload 4 <ref> [ 1] </ref> 41: sipush 1000 [ 2] 44: if_icmplt 22 ---------- [ 0] 47: iinc 3 1 ---------- [ 0] 50: iload_3 [ 1] 51: sipush 1000 [ 2] 54: if_icmplt 16 ---------- [ 0] 57: return ---------- If constant pool entries must be copied into the constant pool of the auxiliary class, then currently javab copies the whole old constant pool into the new class file and simply obsoletes all entries that <p> In addition, the instruction at address 65 is replaced by goto 76, and an exception handler starting at 121 for code region [76,121) and exception `java.lang.InterruptedException' is added to the exception table of this method: ... <ref> [ 1] </ref> 73: pop [ 0] 74: aconst_null [ 1] 75: areturn ---------- *[ 0] 76: new Par_Worker_par_0 ---------- [ 2] 80: aload 2 [ 3] 82: iload 3 [ 4] 84: iload 4 [ 5] 86: iload 5 ---------- *[ 6] 88: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 1] 91: iinc <p> In addition, the instruction at address 65 is replaced by goto 76, and an exception handler starting at 121 for code region [76,121) and exception `java.lang.InterruptedException' is added to the exception table of this method: ... <ref> [ 1] </ref> 73: pop [ 0] 74: aconst_null [ 1] 75: areturn ---------- *[ 0] 76: new Par_Worker_par_0 ---------- [ 2] 80: aload 2 [ 3] 82: iload 3 [ 4] 84: iload 4 [ 5] 86: iload 5 ---------- *[ 6] 88: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 1] 91: iinc 5 1 *[ 1] 94: new Class Par_Worker_par_0 <p> this method: ... <ref> [ 1] </ref> 73: pop [ 0] 74: aconst_null [ 1] 75: areturn ---------- *[ 0] 76: new Par_Worker_par_0 ---------- [ 2] 80: aload 2 [ 3] 82: iload 3 [ 4] 84: iload 4 [ 5] 86: iload 5 ---------- *[ 6] 88: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 1] 91: iinc 5 1 *[ 1] 94: new Class Par_Worker_par_0 ---------- [ 3] 98: aload 2 [ 4]100: iload 3 [ 5]102: iload 4 [ 6]104: iload 5 ---------- *[ 7]106: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 2]109: iinc 5 1 ---------- *[ 2]112: invokevirtual java.lang.Thread.join ()V ---------- *[ 1]115: <p> The bytecode for the constructor and run ()-method of this class are shown below: 38 *** method 0x01 &lt;init&gt;([[IIII)V 5-&gt;0 ---------- [ 0] 0: aload_0 ---------- *<ref> [ 1] </ref> 1: invokespecial java.lang.Thread.&lt;init&gt; ()V ---------- [ 0] 4: aload_0 [ 1] 5: aload 1 *[ 2] 7: putfield Par_Worker_par.loc_2 [[I ---------- [ 0] 10: aload_0 [ 1] 11: iload 2 *[ 2] 13: putfield Par_Worker_par.loc_3 I ---------- [ 0] 16: aload_0 [ 1] 17: iload 3 *[ 2] 19: putfield Par_Worker_par.loc_4 I ---------- [ 0] 22: aload_0 [ 1] 23: <p> the constructor and run ()-method of this class are shown below: 38 *** method 0x01 &lt;init&gt;([[IIII)V 5-&gt;0 ---------- [ 0] 0: aload_0 ---------- *<ref> [ 1] </ref> 1: invokespecial java.lang.Thread.&lt;init&gt; ()V ---------- [ 0] 4: aload_0 [ 1] 5: aload 1 *[ 2] 7: putfield Par_Worker_par.loc_2 [[I ---------- [ 0] 10: aload_0 [ 1] 11: iload 2 *[ 2] 13: putfield Par_Worker_par.loc_3 I ---------- [ 0] 16: aload_0 [ 1] 17: iload 3 *[ 2] 19: putfield Par_Worker_par.loc_4 I ---------- [ 0] 22: aload_0 [ 1] 23: iload 4 *[ 2] 25: putfield Par_Worker_par.loc_5 I ---------- [ 0] 28: aload_0 ---------- *[ 1] <p> 5-&gt;0 ---------- [ 0] 0: aload_0 ---------- *<ref> [ 1] </ref> 1: invokespecial java.lang.Thread.&lt;init&gt; ()V ---------- [ 0] 4: aload_0 [ 1] 5: aload 1 *[ 2] 7: putfield Par_Worker_par.loc_2 [[I ---------- [ 0] 10: aload_0 [ 1] 11: iload 2 *[ 2] 13: putfield Par_Worker_par.loc_3 I ---------- [ 0] 16: aload_0 [ 1] 17: iload 3 *[ 2] 19: putfield Par_Worker_par.loc_4 I ---------- [ 0] 22: aload_0 [ 1] 23: iload 4 *[ 2] 25: putfield Par_Worker_par.loc_5 I ---------- [ 0] 28: aload_0 ---------- *[ 1] 29: invokevirtual java.lang.Thread.start ()V ---------- [ 0] 32: return ---------- *** method 0x01 run ()V 1-&gt;0 <p> 4: aload_0 <ref> [ 1] </ref> 5: aload 1 *[ 2] 7: putfield Par_Worker_par.loc_2 [[I ---------- [ 0] 10: aload_0 [ 1] 11: iload 2 *[ 2] 13: putfield Par_Worker_par.loc_3 I ---------- [ 0] 16: aload_0 [ 1] 17: iload 3 *[ 2] 19: putfield Par_Worker_par.loc_4 I ---------- [ 0] 22: aload_0 [ 1] 23: iload 4 *[ 2] 25: putfield Par_Worker_par.loc_5 I ---------- [ 0] 28: aload_0 ---------- *[ 1] 29: invokevirtual java.lang.Thread.start ()V ---------- [ 0] 32: return ---------- *** method 0x01 run ()V 1-&gt;0 ---------- [ 0] 0: aload_0 *[ 1] 1: getfield Par_Worker_par.loc_5 I ---------- [ 1] 4: istore <p> 0] 22: aload_0 <ref> [ 1] </ref> 23: iload 4 *[ 2] 25: putfield Par_Worker_par.loc_5 I ---------- [ 0] 28: aload_0 ---------- *[ 1] 29: invokevirtual java.lang.Thread.start ()V ---------- [ 0] 32: return ---------- *** method 0x01 run ()V 1-&gt;0 ---------- [ 0] 0: aload_0 *[ 1] 1: getfield Par_Worker_par.loc_5 I ---------- [ 1] 4: istore 5 [ 0] 6: aload_0 *[ 1] 7: getfield Par_Worker_par.loc_4 I ---------- [ 1] 10: istore 4 [ 0] 12: aload_0 *[ 1] 13: getfield Par_Worker_par.loc_3 I ---------- [ 1] 16: istore 3 [ 0] 18: aload_0 *[ 1] 19: getfield Par_Worker_par.loc_2 [[I ---------- [ 1] 22: <p> 0] 28: aload_0 ---------- *<ref> [ 1] </ref> 29: invokevirtual java.lang.Thread.start ()V ---------- [ 0] 32: return ---------- *** method 0x01 run ()V 1-&gt;0 ---------- [ 0] 0: aload_0 *[ 1] 1: getfield Par_Worker_par.loc_5 I ---------- [ 1] 4: istore 5 [ 0] 6: aload_0 *[ 1] 7: getfield Par_Worker_par.loc_4 I ---------- [ 1] 10: istore 4 [ 0] 12: aload_0 *[ 1] 13: getfield Par_Worker_par.loc_3 I ---------- [ 1] 16: istore 3 [ 0] 18: aload_0 *[ 1] 19: getfield Par_Worker_par.loc_2 [[I ---------- [ 1] 22: astore 2 [ 0] 24: goto 74 ; goto NewLoopEntry ---------- [ 0] 27: iload 5 <p> *** method 0x01 run ()V 1-&gt;0 ---------- [ 0] 0: aload_0 *<ref> [ 1] </ref> 1: getfield Par_Worker_par.loc_5 I ---------- [ 1] 4: istore 5 [ 0] 6: aload_0 *[ 1] 7: getfield Par_Worker_par.loc_4 I ---------- [ 1] 10: istore 4 [ 0] 12: aload_0 *[ 1] 13: getfield Par_Worker_par.loc_3 I ---------- [ 1] 16: istore 3 [ 0] 18: aload_0 *[ 1] 19: getfield Par_Worker_par.loc_2 [[I ---------- [ 1] 22: astore 2 [ 0] 24: goto 74 ; goto NewLoopEntry ---------- [ 0] 27: iload 5 [ 1] 29: istore 6 [ 0] 31: aload_2 [ 1] 32: iload 5 *[ 2] <p> I ---------- <ref> [ 1] </ref> 4: istore 5 [ 0] 6: aload_0 *[ 1] 7: getfield Par_Worker_par.loc_4 I ---------- [ 1] 10: istore 4 [ 0] 12: aload_0 *[ 1] 13: getfield Par_Worker_par.loc_3 I ---------- [ 1] 16: istore 3 [ 0] 18: aload_0 *[ 1] 19: getfield Par_Worker_par.loc_2 [[I ---------- [ 1] 22: astore 2 [ 0] 24: goto 74 ; goto NewLoopEntry ---------- [ 0] 27: iload 5 [ 1] 29: istore 6 [ 0] 31: aload_2 [ 1] 32: iload 5 *[ 2] 34: aaload ---------- [ 1] 35: astore 7 [ 0] 37: aload_2 [ 1] 38: iload <p> 1] 10: istore 4 [ 0] 12: aload_0 *<ref> [ 1] </ref> 13: getfield Par_Worker_par.loc_3 I ---------- [ 1] 16: istore 3 [ 0] 18: aload_0 *[ 1] 19: getfield Par_Worker_par.loc_2 [[I ---------- [ 1] 22: astore 2 [ 0] 24: goto 74 ; goto NewLoopEntry ---------- [ 0] 27: iload 5 [ 1] 29: istore 6 [ 0] 31: aload_2 [ 1] 32: iload 5 *[ 2] 34: aaload ---------- [ 1] 35: astore 7 [ 0] 37: aload_2 [ 1] 38: iload 6 *[ 2] 40: aaload ---------- [ 1] 41: astore 8 [ 0] 43: iconst_0 [ 1] 44: istore <p> 1] 13: getfield Par_Worker_par.loc_3 I ---------- <ref> [ 1] </ref> 16: istore 3 [ 0] 18: aload_0 *[ 1] 19: getfield Par_Worker_par.loc_2 [[I ---------- [ 1] 22: astore 2 [ 0] 24: goto 74 ; goto NewLoopEntry ---------- [ 0] 27: iload 5 [ 1] 29: istore 6 [ 0] 31: aload_2 [ 1] 32: iload 5 *[ 2] 34: aaload ---------- [ 1] 35: astore 7 [ 0] 37: aload_2 [ 1] 38: iload 6 *[ 2] 40: aaload ---------- [ 1] 41: astore 8 [ 0] 43: iconst_0 [ 1] 44: istore 9 [ 0] 46: goto 64 ---------- [ 0] <p> 3 [ 0] 18: aload_0 *<ref> [ 1] </ref> 19: getfield Par_Worker_par.loc_2 [[I ---------- [ 1] 22: astore 2 [ 0] 24: goto 74 ; goto NewLoopEntry ---------- [ 0] 27: iload 5 [ 1] 29: istore 6 [ 0] 31: aload_2 [ 1] 32: iload 5 *[ 2] 34: aaload ---------- [ 1] 35: astore 7 [ 0] 37: aload_2 [ 1] 38: iload 6 *[ 2] 40: aaload ---------- [ 1] 41: astore 8 [ 0] 43: iconst_0 [ 1] 44: istore 9 [ 0] 46: goto 64 ---------- [ 0] 49: aload 7 [ 1] 51: iload 9 [ 2] <p> Par_Worker_par.loc_2 [[I ---------- <ref> [ 1] </ref> 22: astore 2 [ 0] 24: goto 74 ; goto NewLoopEntry ---------- [ 0] 27: iload 5 [ 1] 29: istore 6 [ 0] 31: aload_2 [ 1] 32: iload 5 *[ 2] 34: aaload ---------- [ 1] 35: astore 7 [ 0] 37: aload_2 [ 1] 38: iload 6 *[ 2] 40: aaload ---------- [ 1] 41: astore 8 [ 0] 43: iconst_0 [ 1] 44: istore 9 [ 0] 46: goto 64 ---------- [ 0] 49: aload 7 [ 1] 51: iload 9 [ 2] 53: aload 8 [ 3] 55: iload 9 *[ <p> 24: goto 74 ; goto NewLoopEntry ---------- [ 0] 27: iload 5 <ref> [ 1] </ref> 29: istore 6 [ 0] 31: aload_2 [ 1] 32: iload 5 *[ 2] 34: aaload ---------- [ 1] 35: astore 7 [ 0] 37: aload_2 [ 1] 38: iload 6 *[ 2] 40: aaload ---------- [ 1] 41: astore 8 [ 0] 43: iconst_0 [ 1] 44: istore 9 [ 0] 46: goto 64 ---------- [ 0] 49: aload 7 [ 1] 51: iload 9 [ 2] 53: aload 8 [ 3] 55: iload 9 *[ 4] 57: iaload ---------- [ 3] 58: iconst_1 [ 4] <p> 27: iload 5 <ref> [ 1] </ref> 29: istore 6 [ 0] 31: aload_2 [ 1] 32: iload 5 *[ 2] 34: aaload ---------- [ 1] 35: astore 7 [ 0] 37: aload_2 [ 1] 38: iload 6 *[ 2] 40: aaload ---------- [ 1] 41: astore 8 [ 0] 43: iconst_0 [ 1] 44: istore 9 [ 0] 46: goto 64 ---------- [ 0] 49: aload 7 [ 1] 51: iload 9 [ 2] 53: aload 8 [ 3] 55: iload 9 *[ 4] 57: iaload ---------- [ 3] 58: iconst_1 [ 4] 59: iadd *[ 3] 60: iastore ---------- [ 0] <p> 5 *[ 2] 34: aaload ---------- <ref> [ 1] </ref> 35: astore 7 [ 0] 37: aload_2 [ 1] 38: iload 6 *[ 2] 40: aaload ---------- [ 1] 41: astore 8 [ 0] 43: iconst_0 [ 1] 44: istore 9 [ 0] 46: goto 64 ---------- [ 0] 49: aload 7 [ 1] 51: iload 9 [ 2] 53: aload 8 [ 3] 55: iload 9 *[ 4] 57: iaload ---------- [ 3] 58: iconst_1 [ 4] 59: iadd *[ 3] 60: iastore ---------- [ 0] 61: iinc 9 1 ---------- [ 0] 64: iload 9 [ 1] 66: iload 4 [ <p> [ 0] 49: aload 7 <ref> [ 1] </ref> 51: iload 9 [ 2] 53: aload 8 [ 3] 55: iload 9 *[ 4] 57: iaload ---------- [ 3] 58: iconst_1 [ 4] 59: iadd *[ 3] 60: iastore ---------- [ 0] 61: iinc 9 1 ---------- [ 0] 64: iload 9 [ 1] 66: iload 4 [ 2] 68: if_icmplt 49 ---------- [ 0] 71: iinc 5 2 ---------- [ 0] 74: iload 5 [ 1] 76: iload_3 [ 2] 77: if_icmplt 27 ; fall-through to return ---------- [ 0] 80: return ---------- 4 Initial Experiments The techniques presented in this paper <p> iaload ---------- [ 3] 58: iconst_1 [ 4] 59: iadd *[ 3] 60: iastore ---------- [ 0] 61: iinc 9 1 ---------- [ 0] 64: iload 9 <ref> [ 1] </ref> 66: iload 4 [ 2] 68: if_icmplt 49 ---------- [ 0] 71: iinc 5 2 ---------- [ 0] 74: iload 5 [ 1] 76: iload_3 [ 2] 77: if_icmplt 27 ; fall-through to return ---------- [ 0] 80: return ---------- 4 Initial Experiments The techniques presented in this paper have been actually implemented in a prototype bytecode parallelization tool javab which is made freely available (for details, see the end of this <p> One of these parallel trivial loops is illustrated below: code stack states *** method 0x08 &lt;clinit&gt;()V 0-&gt;0 ---------- [ 0] 0: sipush 256 h&gt;; &gt;; &gt;; &gt;; &gt;; &gt;i *<ref> [ 1] </ref> 3: newarray char hcon (256); &gt;; &gt;; &gt;; &gt;; &gt;i ---------- [ 1] 5: astore_0 hadecl (3; 1); &gt;; &gt;; &gt;; &gt;; &gt;i [ 0] 6: sipush 1 0 h?; &gt;; &gt;; &gt;; &gt;; &gt;i *[ 1] 9: newarray char hcon (256); &gt;; &gt;; &gt;; &gt;; &gt;i ---------- [ 1] 11: astore_1 hadecl (9; 1); &gt;; &gt;; &gt;; &gt;; &gt;i [ 0] <p> *<ref> [ 1] </ref> 3: newarray char hcon (256); &gt;; &gt;; &gt;; &gt;; &gt;i ---------- [ 1] 5: astore_0 hadecl (3; 1); &gt;; &gt;; &gt;; &gt;; &gt;i [ 0] 6: sipush 1 0 h?; &gt;; &gt;; &gt;; &gt;; &gt;i *[ 1] 9: newarray char hcon (256); &gt;; &gt;; &gt;; &gt;; &gt;i ---------- [ 1] 11: astore_1 hadecl (9; 1); &gt;; &gt;; &gt;; &gt;; &gt;i [ 0] 12: iconst_0 h?; &gt;; &gt;; &gt;; &gt;; &gt;i [ 1] 13: istore_2 hcon (0); &gt;; &gt;; &gt;; &gt;; &gt;i [ 0] 14: goto 29 h?; &gt;; &gt;; &gt;; &gt;; &gt;i ---------- [ 0] 17: aload_0 h?; ?; <p> &gt;; &gt;; &gt;i [ 0] 6: sipush 1 0 h?; &gt;; &gt;; &gt;; &gt;; &gt;i *<ref> [ 1] </ref> 9: newarray char hcon (256); &gt;; &gt;; &gt;; &gt;; &gt;i ---------- [ 1] 11: astore_1 hadecl (9; 1); &gt;; &gt;; &gt;; &gt;; &gt;i [ 0] 12: iconst_0 h?; &gt;; &gt;; &gt;; &gt;; &gt;i [ 1] 13: istore_2 hcon (0); &gt;; &gt;; &gt;; &gt;; &gt;i [ 0] 14: goto 29 h?; &gt;; &gt;; &gt;; &gt;; &gt;i ---------- [ 0] 17: aload_0 h?; ?; ?; ?; ?; ?i [ 1] 18: iload_2 hadecl (3; 1); ?; ?; ?; ?; ?i [ 2] 19: aload_1 hadecl (3; <p> (9; 1); &gt;; &gt;; &gt;; &gt;; &gt;i [ 0] 12: iconst_0 h?; &gt;; &gt;; &gt;; &gt;; &gt;i <ref> [ 1] </ref> 13: istore_2 hcon (0); &gt;; &gt;; &gt;; &gt;; &gt;i [ 0] 14: goto 29 h?; &gt;; &gt;; &gt;; &gt;; &gt;i ---------- [ 0] 17: aload_0 h?; ?; ?; ?; ?; ?i [ 1] 18: iload_2 hadecl (3; 1); ?; ?; ?; ?; ?i [ 2] 19: aload_1 hadecl (3; 1); var (fd 3 ; d 4 g); ?; ?; ?; ?i [ 3] 20: iload_2 hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); ?; ?; ?i [ <p> (fd 3 ; d 4 g); ?i ---------- *[ 3] 25: castore hadecl (3; 1); var (fd 3 ; d 4 g); ?; ?; ?; ?i ---------- [ 0] 26: iinc 2 1 h?; ?; ?; ?; ?; ?i ---------- [ 0] 29: iload_2 h?; ?; ?; ?; ?; ?i <ref> [ 1] </ref> 30: sipush 256 hvar (fd 3 ; d 4 g); ?; ?; ?; ?; ?i [ 2] 33: if_icmplt 17 hvar (fd 3 ; d 4 g); con (256); ?; ?; ?; ?i ---------- All three loops in Pendragon Software's CaffeineMark (tm) version 2.5 appear in the method fpmark
Reference: [2] <author> J.R. Allen and K. Kennedy. </author> <title> Automatic translation of FORTRAN programs to vector form. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9 </volume> <pages> 491-542, </pages> <year> 1987. </year>
Reference-contexts: 0x00 flow ()I 1-&gt;1 [4,23) -&gt; 26 java.lang.Exception [4,34) -&gt; 40 any [ 0] 0: iconst_0 [ 1] 1: istore_1 [ 0] 2: iconst_0 [ 1] 3: istore_2 ---------- [ 0] 4: iinc 1 1 [ 0] 7: iload_2 [ 1] 8: aload_0 *<ref> [ 2] </ref> 9: getfield Flow.a [I ---------- [ 2] 12: iload_1 *[ 3] 13: iaload ---------- [ 2] 14: iadd [ 1] 15: istore_2 [ 0] 16: iload_1 [ 1] 17: sipush 500 [ 2] 20: if_icmplt 4 ---------- [ 0] 23: goto 34 ---------- [ 0] 27: iconst_0 [ 1] 28: istore_3 [ 0] 29: jsr 48 <p> -&gt; 40 any [ 0] 0: iconst_0 [ 1] 1: istore_1 [ 0] 2: iconst_0 [ 1] 3: istore_2 ---------- [ 0] 4: iinc 1 1 [ 0] 7: iload_2 [ 1] 8: aload_0 *<ref> [ 2] </ref> 9: getfield Flow.a [I ---------- [ 2] 12: iload_1 *[ 3] 13: iaload ---------- [ 2] 14: iadd [ 1] 15: istore_2 [ 0] 16: iload_1 [ 1] 17: sipush 500 [ 2] 20: if_icmplt 4 ---------- [ 0] 23: goto 34 ---------- [ 0] 27: iconst_0 [ 1] 28: istore_3 [ 0] 29: jsr 48 [ 0] 32: iload_3 [ 1] 33: ireturn ---------- <p> 3: istore_2 ---------- [ 0] 4: iinc 1 1 [ 0] 7: iload_2 [ 1] 8: aload_0 *<ref> [ 2] </ref> 9: getfield Flow.a [I ---------- [ 2] 12: iload_1 *[ 3] 13: iaload ---------- [ 2] 14: iadd [ 1] 15: istore_2 [ 0] 16: iload_1 [ 1] 17: sipush 500 [ 2] 20: if_icmplt 4 ---------- [ 0] 23: goto 34 ---------- [ 0] 27: iconst_0 [ 1] 28: istore_3 [ 0] 29: jsr 48 [ 0] 32: iload_3 [ 1] 33: ireturn ---------- ---------- [ 0] 37: goto 57 ---------- [ 1] 40: astore 4 [ 0] 42: jsr 48 <p> 1] 58: ireturn ---------- Locals 0: this 1: i 3: 0 5: return 7 *** method 0x00 switcher (Z)D 2-&gt;2 ---------- [ 0] 0: iload_1 [ 1] 1: ifeq 42 ---------- [ 0] 4: aload_0 *[ 1] 5: getfield Switcher.s I ---------- [ 1] 8: lookupswitch 2 -10::36 default::42 ---------- <ref> [ 2] </ref> 39: dreturn ---------- [ 0] 40: dconst_1 [ 2] 41: dreturn ---------- [ 0] 42: dconst_0 [ 2] 43: dreturn ---------- Locals 0: this 1: b Both the edges (v 3 ; v 1 ) and (v 3 ; v 4 ) are added to E, because of the <p> 3: 0 5: return 7 *** method 0x00 switcher (Z)D 2-&gt;2 ---------- [ 0] 0: iload_1 [ 1] 1: ifeq 42 ---------- [ 0] 4: aload_0 *[ 1] 5: getfield Switcher.s I ---------- [ 1] 8: lookupswitch 2 -10::36 default::42 ---------- <ref> [ 2] </ref> 39: dreturn ---------- [ 0] 40: dconst_1 [ 2] 41: dreturn ---------- [ 0] 42: dconst_0 [ 2] 43: dreturn ---------- Locals 0: this 1: b Both the edges (v 3 ; v 1 ) and (v 3 ; v 4 ) are added to E, because of the conditional branch at ad dress 20. <p> (Z)D 2-&gt;2 ---------- [ 0] 0: iload_1 [ 1] 1: ifeq 42 ---------- [ 0] 4: aload_0 *[ 1] 5: getfield Switcher.s I ---------- [ 1] 8: lookupswitch 2 -10::36 default::42 ---------- <ref> [ 2] </ref> 39: dreturn ---------- [ 0] 40: dconst_1 [ 2] 41: dreturn ---------- [ 0] 42: dconst_0 [ 2] 43: dreturn ---------- Locals 0: this 1: b Both the edges (v 3 ; v 1 ) and (v 3 ; v 4 ) are added to E, because of the conditional branch at ad dress 20. <p> [ 0] 9: goto 40 ---------- [ 0] 12: aload_2 [ 1] 13: iload 4 *<ref> [ 2] </ref> 15: aaload ---------- ---------- [ 5] 34: iadd [ 4] 35: iadd *[ 3] 36: iastore ---------- [ 0] 37: iinc 5 1 ---------- [ 0] 40: iload 5 [ 1] 42: iload_3 [ 2] 43: if_icmplt 12 ---------- [ 0] 46: iinc 4 1 ---------- [ 0] 49: iload 4 [ 1] 51: iload_3 [ 2] 52: if_icmplt 6 ---------- [ 0] 55: return ---------- Locals 0: a 2: c 4: i 2.4 Reaching Definitions of Local Variables On a method invocation, a <p> 5] 34: iadd [ 4] 35: iadd *[ 3] 36: iastore ---------- [ 0] 37: iinc 5 1 ---------- [ 0] 40: iload 5 [ 1] 42: iload_3 <ref> [ 2] </ref> 43: if_icmplt 12 ---------- [ 0] 46: iinc 4 1 ---------- [ 0] 49: iload 4 [ 1] 51: iload_3 [ 2] 52: if_icmplt 6 ---------- [ 0] 55: return ---------- Locals 0: a 2: c 4: i 2.4 Reaching Definitions of Local Variables On a method invocation, a fixed-sized frame consisting of a fixed-sized operand stack and a set of local variables is allocated [26, ch3]. <p> The instructions lstore 1 at address 7 and 11 form two definitions of the locals 1 and 2, respectively: 11 *** method 0x08 retLong (ZJ)J 3-&gt;2 ---------- [ 0] 0: iload_0 [ 1] 1: ifeq 12 ---------- <ref> [ 2] </ref> 7: lstore_1 [ 0] 8: ldc2_w 30 [ 2] 11: lstore_1 ---------- [ 0] 12: lload_1 [ 2] 13: lreturn ---------- Locals 0: b 2: l-2 d 1 d 2 d 3 d 4 d 5 d 6 d 7 local 0 1 2 1 2 1 2 address <p> The instructions lstore 1 at address 7 and 11 form two definitions of the locals 1 and 2, respectively: 11 *** method 0x08 retLong (ZJ)J 3-&gt;2 ---------- [ 0] 0: iload_0 [ 1] 1: ifeq 12 ---------- <ref> [ 2] </ref> 7: lstore_1 [ 0] 8: ldc2_w 30 [ 2] 11: lstore_1 ---------- [ 0] 12: lload_1 [ 2] 13: lreturn ---------- Locals 0: b 2: l-2 d 1 d 2 d 3 d 4 d 5 d 6 d 7 local 0 1 2 1 2 1 2 address ? ? ? 7 7 11 11 par. type <p> address 7 and 11 form two definitions of the locals 1 and 2, respectively: 11 *** method 0x08 retLong (ZJ)J 3-&gt;2 ---------- [ 0] 0: iload_0 [ 1] 1: ifeq 12 ---------- <ref> [ 2] </ref> 7: lstore_1 [ 0] 8: ldc2_w 30 [ 2] 11: lstore_1 ---------- [ 0] 12: lload_1 [ 2] 13: lreturn ---------- Locals 0: b 2: l-2 d 1 d 2 d 3 d 4 d 5 d 6 d 7 local 0 1 2 1 2 1 2 address ? ? ? 7 7 11 11 par. type Z J - The rd gen [v] and rd <p> ---------- [ 0] 0: bipush 100 [ 1] 2: istore_0 [ 0] 3: sipush 200 [ 1] 6: istore_1 [ 0] 7: sipush 300 [ 1] 10: istore_2 ---------- [ 0] 11: iinc 0 1 [ 0] 14: iinc 1 -1 [ 0] 17: iload_0 [ 1] 18: bipush 10 <ref> [ 2] </ref> 20: if_icmple 28 ---------- [ 0] 23: iconst_4 [ 1] 24: istore_2 [ 0] 25: goto 30 ---------- [ 0] 28: iconst_0 [ 1] 29: istore_0 ---------- [ 0] 30: iload_1 [ 1] 31: iconst_5 [ 2] 32: if_icmpgt 11 ---------- [ 0] 35: iload_2 [ 1] 36: ireturn <p> 14: iinc 1 -1 [ 0] 17: iload_0 [ 1] 18: bipush 10 <ref> [ 2] </ref> 20: if_icmple 28 ---------- [ 0] 23: iconst_4 [ 1] 24: istore_2 [ 0] 25: goto 30 ---------- [ 0] 28: iconst_0 [ 1] 29: istore_0 ---------- [ 0] 30: iload_1 [ 1] 31: iconst_5 [ 2] 32: if_icmpgt 11 ---------- [ 0] 35: iload_2 [ 1] 36: ireturn ---------- Locals 0: i 2: k v rd gen [v] rd kill [v] rd in [v] rd out [v] v 0 fd 1 ; d 2 ; d 3 g fd 4 ; d 5 ; d <p> yields the number of words that are pushed back onto the stack by the corresponding &lt;T&gt;return instruction in the callee). 15 *** method 0x08 iterativeFac (I)I 1-&gt;1 ---------- [ 0] 0: iconst_1 [ 1] 1: istore_1 [ 0] 2: goto 12 ---------- [ 0] 5: iload_1 [ 1] 6: iload_0 <ref> [ 2] </ref> 7: iinc 0 -1 [ 2] 10: imul [ 1] 11: istore_1 ---------- [ 0] 12: iload_0 [ 1] 13: iconst_1 [ 2] 14: if_icmpgt 5 ---------- [ 0] 17: iload_1 [ 1] 18: ireturn ---------- Locals 0: n For each instruction i in a basic block, an associated <p> are pushed back onto the stack by the corresponding &lt;T&gt;return instruction in the callee). 15 *** method 0x08 iterativeFac (I)I 1-&gt;1 ---------- [ 0] 0: iconst_1 [ 1] 1: istore_1 [ 0] 2: goto 12 ---------- [ 0] 5: iload_1 [ 1] 6: iload_0 <ref> [ 2] </ref> 7: iinc 0 -1 [ 2] 10: imul [ 1] 11: istore_1 ---------- [ 0] 12: iload_0 [ 1] 13: iconst_1 [ 2] 14: if_icmpgt 5 ---------- [ 0] 17: iload_1 [ 1] 18: ireturn ---------- Locals 0: n For each instruction i in a basic block, an associated attribute i.sp is used to store <p> 0x08 iterativeFac (I)I 1-&gt;1 ---------- [ 0] 0: iconst_1 [ 1] 1: istore_1 [ 0] 2: goto 12 ---------- [ 0] 5: iload_1 [ 1] 6: iload_0 <ref> [ 2] </ref> 7: iinc 0 -1 [ 2] 10: imul [ 1] 11: istore_1 ---------- [ 0] 12: iload_0 [ 1] 13: iconst_1 [ 2] 14: if_icmpgt 5 ---------- [ 0] 17: iload_1 [ 1] 18: ireturn ---------- Locals 0: n For each instruction i in a basic block, an associated attribute i.sp is used to store the operand stack size in words prior to executing the instruction. <p> recLongFac () of the previous method with a long parameter that appears in the following class Fac: class Fac - static long recLongFac (long n) - return (n &gt; 1) ? recLongFac (n-1) * n : 1; - 16 *** method 0x08 recLongFac (J)J 2-&gt;2 ---------- [ 0] 0: lload_0 <ref> [ 2] </ref> 1: lconst_1 [ 4] 2: lcmp [ 1] 3: ifle 15 ---------- [ 0] 6: lload_0 [ 2] 7: lconst_1 [ 4] 8: lsub ---------- *[ 2] 9: invokestatic Fac.recLongFac (J)J ---------- [ 2] 12: lload_0 [ 4] 13: lmul [ 2] 14: lreturn ---------- [ 0] 15: lconst_1 <p> Fac - static long recLongFac (long n) - return (n &gt; 1) ? recLongFac (n-1) * n : 1; - 16 *** method 0x08 recLongFac (J)J 2-&gt;2 ---------- [ 0] 0: lload_0 <ref> [ 2] </ref> 1: lconst_1 [ 4] 2: lcmp [ 1] 3: ifle 15 ---------- [ 0] 6: lload_0 [ 2] 7: lconst_1 [ 4] 8: lsub ---------- *[ 2] 9: invokestatic Fac.recLongFac (J)J ---------- [ 2] 12: lload_0 [ 4] 13: lmul [ 2] 14: lreturn ---------- [ 0] 15: lconst_1 [ 2] 16: lreturn ---------- Locals 0: n Stack size information for the corresponding byte code is summarized <p> n : 1; - 16 *** method 0x08 recLongFac (J)J 2-&gt;2 ---------- [ 0] 0: lload_0 <ref> [ 2] </ref> 1: lconst_1 [ 4] 2: lcmp [ 1] 3: ifle 15 ---------- [ 0] 6: lload_0 [ 2] 7: lconst_1 [ 4] 8: lsub ---------- *[ 2] 9: invokestatic Fac.recLongFac (J)J ---------- [ 2] 12: lload_0 [ 4] 13: lmul [ 2] 14: lreturn ---------- [ 0] 15: lconst_1 [ 2] 16: lreturn ---------- Locals 0: n Stack size information for the corresponding byte code is summarized in Figure 10. <p> recLongFac (J)J 2-&gt;2 ---------- [ 0] 0: lload_0 <ref> [ 2] </ref> 1: lconst_1 [ 4] 2: lcmp [ 1] 3: ifle 15 ---------- [ 0] 6: lload_0 [ 2] 7: lconst_1 [ 4] 8: lsub ---------- *[ 2] 9: invokestatic Fac.recLongFac (J)J ---------- [ 2] 12: lload_0 [ 4] 13: lmul [ 2] 14: lreturn ---------- [ 0] 15: lconst_1 [ 2] 16: lreturn ---------- Locals 0: n Stack size information for the corresponding byte code is summarized in Figure 10. <p> 2] 1: lconst_1 [ 4] 2: lcmp [ 1] 3: ifle 15 ---------- [ 0] 6: lload_0 <ref> [ 2] </ref> 7: lconst_1 [ 4] 8: lsub ---------- *[ 2] 9: invokestatic Fac.recLongFac (J)J ---------- [ 2] 12: lload_0 [ 4] 13: lmul [ 2] 14: lreturn ---------- [ 0] 15: lconst_1 [ 2] 16: lreturn ---------- Locals 0: n Stack size information for the corresponding byte code is summarized in Figure 10. <p> d 3 ; d 4 g), we have s mod [v 3 ] = hvar (fd 4 g); &gt;i. 20 *** method 0x08 init ([F [ZI)V 3-&gt;0 ---------- [ 0] 0: iconst_0 [ 1] 1: istore_3 [ 0] 2: goto 22 ---------- [ 0] 5: aload_0 [ 1] 6: iload_3 <ref> [ 2] </ref> 7: aload_1 [ 3] 8: iload_3 *[ 4] 9: baload ---------- [ 3] 10: ifeq 17 ---------- [ 2] 13: fconst_1 [ 3] 14: goto 18 ---------- [ 2] 17: fconst_2 ---------- *[ 3] 18: fastore ---------- [ 0] 19: iinc 3 1 ---------- [ 0] 22: iload_3 [ <p> 20 *** method 0x08 init ([F [ZI)V 3-&gt;0 ---------- [ 0] 0: iconst_0 [ 1] 1: istore_3 [ 0] 2: goto 22 ---------- [ 0] 5: aload_0 [ 1] 6: iload_3 <ref> [ 2] </ref> 7: aload_1 [ 3] 8: iload_3 *[ 4] 9: baload ---------- [ 3] 10: ifeq 17 ---------- [ 2] 13: fconst_1 [ 3] 14: goto 18 ---------- [ 2] 17: fconst_2 ---------- *[ 3] 18: fastore ---------- [ 0] 19: iinc 3 1 ---------- [ 0] 22: iload_3 [ 1] 23: iload_2 [ 2] 24: if_icmplt 5 ---------- [ 0] 27: return ---------- Locals 0: a 2: n <p> 0] 0: iconst_0 [ 1] 1: istore_3 [ 0] 2: goto 22 ---------- [ 0] 5: aload_0 [ 1] 6: iload_3 <ref> [ 2] </ref> 7: aload_1 [ 3] 8: iload_3 *[ 4] 9: baload ---------- [ 3] 10: ifeq 17 ---------- [ 2] 13: fconst_1 [ 3] 14: goto 18 ---------- [ 2] 17: fconst_2 ---------- *[ 3] 18: fastore ---------- [ 0] 19: iinc 3 1 ---------- [ 0] 22: iload_3 [ 1] 23: iload_2 [ 2] 24: if_icmplt 5 ---------- [ 0] 27: return ---------- Locals 0: a 2: n All other stack state modifications tuples are computed in a <p> [ 3] 8: iload_3 *[ 4] 9: baload ---------- [ 3] 10: ifeq 17 ---------- <ref> [ 2] </ref> 13: fconst_1 [ 3] 14: goto 18 ---------- [ 2] 17: fconst_2 ---------- *[ 3] 18: fastore ---------- [ 0] 19: iinc 3 1 ---------- [ 0] 22: iload_3 [ 1] 23: iload_2 [ 2] 24: if_icmplt 5 ---------- [ 0] 27: return ---------- Locals 0: a 2: n All other stack state modifications tuples are computed in a similar way. <p> ifeq 14 hvar (fd 1 g); &gt;i ---------- [ 0] 10: iload_2 h?; &gt;i [ 1] 11: goto 15 hvar (fd 3 g); &gt;i hcon (1); &gt;i ---------- [ 0] 14: iload_3 h?; &gt;i --------- [ 1] 15: iconst_1 hvar (fd 3 ; d 4 g); &gt;i hcon (1); &gt;i <ref> [ 2] </ref> 16: iadd hvar (fd 3 ; d 4 g); con (1)i hcon (1); con (1)i [ 1] 17: ireturn hexp (1; fd 3 ; d 4 g); ?i hcon (2); ?i 21 *** method 0x08 copy (Z)I 1-&gt;1 ---------- [ 0] 0: iconst_1 [ 1] 1: istore_1 [ 0] <p> iconst_1 [ 1] 1: istore_1 [ 0] 2: iload_1 [ 1] 3: istore_2 [ 0] 4: iload_2 [ 1] 5: istore_3 [ 0] 6: iload_0 [ 1] 7: ifeq 14 ---------- [ 0] 10: iload_2 [ 1] 11: goto 15 ---------- [ 0] 14: iload_3 ---------- [ 1] 15: iconst_1 <ref> [ 2] </ref> 16: iadd [ 1] 17: ireturn ---------- Locals 0: b 2: j For example, let i denote the instruction at address 5 with associated stack state hvar (fd 3 g); &gt;i, where the only definition d 3 is formed by instruction i 0 at address 3. <p> would be useful to propagate the improved stack state locally, in order to apply a constant folding rule that was not formerly applicable: locally propagated code original stack states improved stack states constant folding ... [ 1] 15: iconst_1 hvar (fd 3 ; d 4 g); &gt;i hcon (1); &gt;i <ref> [ 2] </ref> 16: imul hvar (fd 3 ; d 4 g); con (1)i hcon (1); con (1)i [ 1] 17: ireturn h?; ?i h?; ?i hcon (1); ?i 2.9 Array Reference Chasing After partial stack states have been computed for a method, and after copy and constant propagation have been accounted <p> Consider the following Java instance method decl () in a class `Decl' that is a subclass of the class `java.lang.Thread': class Decl extends Thread - Thread [] decl (Thread [][] t) - Thread [] nt = new Thread <ref> [2] </ref>; nt [0] = this; nt [1] = t [0][0]; return nt; - The bytecode, corresponding flow graph G = hV; E; v 0 i, and local variables usage are shown in this of type t 1 =`LDecl;' to the method (here we assume that the class declaration appears in the <p> The aaload 23 *** method 0x00 decl ([[Ljava/lang/Thread;) [Ljava/lang/Thread; 2-&gt;1 ---------- [ 0] 0: iconst_2 *[ 1] 1: anewarray java.lang.Thread ---------- [ 1] 4: astore_2 [ 0] 5: aload_2 [ 1] 6: iconst_0 <ref> [ 2] </ref> 7: aload_0 *[ 3] 8: aastore ---------- [ 0] 9: aload_2 [ 1] 10: iconst_1 [ 2] 11: aload_1 [ 3] 12: iconst_0 *[ 4] 13: aaload ---------- [ 3] 14: iconst_0 *[ 4] 15: aaload ---------- *[ 3] 16: aastore ---------- [ 0] 17: aload_2 [ 1] 18: <p> The aaload 23 *** method 0x00 decl ([[Ljava/lang/Thread;) [Ljava/lang/Thread; 2-&gt;1 ---------- [ 0] 0: iconst_2 *[ 1] 1: anewarray java.lang.Thread ---------- [ 1] 4: astore_2 [ 0] 5: aload_2 [ 1] 6: iconst_0 <ref> [ 2] </ref> 7: aload_0 *[ 3] 8: aastore ---------- [ 0] 9: aload_2 [ 1] 10: iconst_1 [ 2] 11: aload_1 [ 3] 12: iconst_0 *[ 4] 13: aaload ---------- [ 3] 14: iconst_0 *[ 4] 15: aaload ---------- *[ 3] 16: aastore ---------- [ 0] 17: aload_2 [ 1] 18: areturn ---------- Locals 0: this 1: t instruction at address 13 effectively converts this reference into apar <p> *[ 1] 1: anewarray ... hcon (2); &gt;; &gt;; &gt;i ---------- d3: [ 1] 4: astore_2 href (1); &gt;; &gt;; &gt;i hadecl (1; 1); &gt;; &gt;; &gt;i [ 0] 5: aload_2 h?; &gt;; &gt;; &gt;i [ 1] 6: iconst_0 href (1); &gt;; &gt;; &gt;i hadecl (1; 1); &gt;; &gt;; &gt;i <ref> [ 2] </ref> 7: aload_0 href (1); con (0); &gt;; &gt;i hadecl (1; 1); con (0); &gt;; &gt;i *[ 3] 8: aastore href (1); con (0); var (fd 1 g); &gt;i hadecl (1; 1); con (0); var (fd 1 g); &gt;i ---------- [ 0] 9: aload_2 h?; ?; ?; &gt;i [ 1] <p> (0); &gt;; &gt;i *[ 3] 8: aastore href (1); con (0); var (fd 1 g); &gt;i hadecl (1; 1); con (0); var (fd 1 g); &gt;i ---------- [ 0] 9: aload_2 h?; ?; ?; &gt;i [ 1] 10: iconst_1 href (1); ?; ?; &gt;i hadecl (1; 1); ?; ?; &gt;i <ref> [ 2] </ref> 11: aload_1 href (1); con (1); ?; &gt;i hadecl (1; 1); con (1); ?; &gt;i [ 3] 12: iconst_0 href (1); con (1); var (fd 2 g); &gt;i hadecl (1; 1); con (1); apar (1; 2); &gt;i *[ 4] 13: aaload href (1); con (1); var (fd 2 g); <p> In fact, this constraint can be slightly relaxed by allowing invocations of side-effect free static methods such as `java.lang.Math.cos ()'. 26 *** method 0x00 add_field ([DI)V 3-&gt;0 ---------- [ 0] 0: iconst_0 [ 1] 1: istore_3 [ 0] 2: goto 18 ---------- [ 0] 5: aload_1 [ 1] 6: iload_3 <ref> [ 2] </ref> 7: dup2 *[ 4] 8: daload ---------- [ 4] 9: aload_0 *[ 5] 10: getfield Field.d D ---------- [ 6] 13: dadd *[ 4] 14: dastore ---------- [ 0] 15: iinc 3 1 ---------- [ 0] 18: iload_3 [ 1] 19: iload_2 [ 2] 20: if_icmplt 5 ---------- [ <p> 5: aload_1 [ 1] 6: iload_3 <ref> [ 2] </ref> 7: dup2 *[ 4] 8: daload ---------- [ 4] 9: aload_0 *[ 5] 10: getfield Field.d D ---------- [ 6] 13: dadd *[ 4] 14: dastore ---------- [ 0] 15: iinc 3 1 ---------- [ 0] 18: iload_3 [ 1] 19: iload_2 [ 2] 20: if_icmplt 5 ---------- [ 0] 23: return ---------- Locals 0: this 1: a 3: i The bytecode, corresponding flow graph G = hV; E; v 0 i, and local variables usage are shown in d 1 d 2 d 3 d 4 d 5 local 0 1 2 <p> for instructions in the trivial loop L = fv 1 ; v 3 ; : : : ; v 6 g is shown below: code stack states ... [ 0] 5: aload_1 h?; ?; ?; ?; ?; ?i [ 1] 6: iload_3 hapar (1; 1); ?; ?; ?; ?; ?i <ref> [ 2] </ref> 7: dup2 hapar (1; 1); var (fd 4 ; d 5 g); ?; ?; ?; ?i *[ 4] 8: daload hapar (1; 1); var (fd 4 ; d 5 g); apar (1; 1); var (fd 4 ; d 5 g); ?; ?i ---------- [ 4] 9: aload_0 hapar (1; <p> [ 0] 2: iconst_0 [ 1] 3: istore_2 [ 0] 4: goto 22 ---------- [ 0] 7: aload_0 [ 1] 8: iload_2 *<ref> [ 2] </ref> 9: baload ---------- [ 1] 10: ifeq 15 ---------- [ 0] 13: iconst_2 [ 1] 14: istore_3 ---------- [ 0] 15: aload_1 [ 1] 16: iload_2 [ 2] 17: iload_3 *[ 3] 18: iastore ---------- [ 0] 19: iinc 2 1 ---------- [ 0] 22: iload_2 [ 1] 23: bipush 100 [ 2] 25: if_icmplt 7 ---------- [ 0] 28: iload_3 [ 1] 29: ireturn ---------- Locals 0: b 2: i 3.2.3 Analysis of Arrays As a <p> baload ---------- [ 1] 10: ifeq 15 ---------- [ 0] 13: iconst_2 [ 1] 14: istore_3 ---------- [ 0] 15: aload_1 [ 1] 16: iload_2 <ref> [ 2] </ref> 17: iload_3 *[ 3] 18: iastore ---------- [ 0] 19: iinc 2 1 ---------- [ 0] 22: iload_2 [ 1] 23: bipush 100 [ 2] 25: if_icmplt 7 ---------- [ 0] 28: iload_3 [ 1] 29: ireturn ---------- Locals 0: b 2: i 3.2.3 Analysis of Arrays As a final step in the automatic detection of implicit parallelism, the compiler verifies if none of the array instructions &lt;t&gt;aload and &lt;t&gt;astore in a candidate parallel <p> void bound (int a []) - for (int i = 1; i &lt; 500; i++) for (int k = j+1; k &lt; j-2; k++) - code stack states ... [ 0] 12: iload_2 h?; ?; ?i [ 1] 13: iconst_1 hvar (fd 3 ; d 6 g); ?; ?i d4: <ref> [ 2] </ref> 14: iadd hvar (fd 3 ; d 6 g); con (1); ?i [ 1] 15: istore_3 hexp (1; fd 3 ; d 6 g); ?; ?i [ 0] 16: goto 28 h?; ?; ?i ---------- [ 0] 19: aload_0 h?; ?; ?i [ 1] 20: iload_3 hapar (0; 1); <p> iadd hvar (fd 3 ; d 6 g); con (1); ?i [ 1] 15: istore_3 hexp (1; fd 3 ; d 6 g); ?; ?i [ 0] 16: goto 28 h?; ?; ?i ---------- [ 0] 19: aload_0 h?; ?; ?i [ 1] 20: iload_3 hapar (0; 1); ?; ?i <ref> [ 2] </ref> 21: iconst_4 hapar (0; 1); var (fd 4 ; d 5 g); ?i [ 3] 22: iadd hapar (0; 1); var (fd 4 ; d 5 g); con (4)i [ 2] 23: iconst_1 hapar (0; 1); exp (4; fd 4 ; d 5 g); ?i *[ 3] 24: iastore <p> ?; ?i ---------- [ 0] 19: aload_0 h?; ?; ?i [ 1] 20: iload_3 hapar (0; 1); ?; ?i <ref> [ 2] </ref> 21: iconst_4 hapar (0; 1); var (fd 4 ; d 5 g); ?i [ 3] 22: iadd hapar (0; 1); var (fd 4 ; d 5 g); con (4)i [ 2] 23: iconst_1 hapar (0; 1); exp (4; fd 4 ; d 5 g); ?i *[ 3] 24: iastore hapar (0; 1); exp (4; fd 4 ; d 5 g); con (1)i ---------- d5: [ 0] 25: iinc 3 1 h?; ?; ?i ---------- [ 0] 28: iload_3 h?; ?; <p> ?i *[ 3] 24: iastore hapar (0; 1); exp (4; fd 4 ; d 5 g); con (1)i ---------- d5: [ 0] 25: iinc 3 1 h?; ?; ?i ---------- [ 0] 28: iload_3 h?; ?; ?i [ 1] 29: iload_2 hvar (fd 4 ; d 5 g); ?; ?i <ref> [ 2] </ref> 30: iconst_2 hvar (fd 4 ; d 5 g); var (fd 3 ; d 6 g); ?i [ 3] 31: isub hvar (fd 4 ; d 5 g); var (fd 3 ; d 6 g); con (2)i [ 2] 32: if_icmplt 19 hvar (fd 4 ; d 5 g); <p> 29: iload_2 hvar (fd 4 ; d 5 g); ?; ?i <ref> [ 2] </ref> 30: iconst_2 hvar (fd 4 ; d 5 g); var (fd 3 ; d 6 g); ?i [ 3] 31: isub hvar (fd 4 ; d 5 g); var (fd 3 ; d 6 g); con (2)i [ 2] 32: if_icmplt 19 hvar (fd 4 ; d 5 g); exp (2; fd 3 ; d 6 g); ?i ... <p> If such a component does not exists, loop-carried data dependences may hold, and parallelization of the loop is disabled. For example, with respect to the trivial i-loop in the bytecode equivalent of the following Java fragment, access tuple h <ref> [0; 2] </ref>; ?i will eventually be associated with the array parameter a. Likewise, with respect to the j-loop, access tuple h?; [1; +1]i will eventually be associated with a. <p> &gt;; &gt;; &gt;i *<ref> [ 2] </ref> 2: multianewarray [[I hvar (fd 1 g); var (fd 2 g); &gt;; &gt;i ---------- [ 1] 6: astore_2 hadecl (2; 2); &gt;; &gt;; &gt;i ... [ 0] 40: aload 7 h?; ?; ?; ?i [ 1] 42: iload 9 hadecl (2; 1); ?; ?; ?i [ 2] 44: aload 8 hadecl (2; 1); var (fd 10 ; d 11 g); ?; ?i [ 3] 46: iload 9 hadecl (2; 1); var (fd 10 ; d 11 g); adecl (2; 1); ?i *[ 4] 48: iaload hadecl (2; 1); var (fd 10 ; d 11 g); adecl <p> 51: iastore hadecl (2; 1); var (fd 10 ; d 11 g); ?; ?i ---------- [ 0] 52: iinc 9 1 h?; ?; ?; ?i ---------- [ 0] 55: iload 9 h?; ?; ?; ?i [ 1] 57: iload 4 hvar (fd 10 ; d 11 g); ?; ?; ?i <ref> [ 2] </ref> 59: if_icmplt :40 hvar (fd 10 ; d 11 g); var (fd 2 g); ?; ?i ---------- In the flow graph, the two back edges (v 8 ; v 2 ) 2 E and (v 11 ; v 7 ) 2 E define the natural loops L 1 = <p> ---------- [ 1] 26: astore 7 [ 0] 28: aload_2 [ 1] 29: iload 6 *<ref> [ 2] </ref> 31: aaload ---------- [ 1] 32: astore 8 [ 0] 34: iconst_0 [ 1] 35: istore 9 [ 0] 37: goto 55 ---------- [ 0] 40: aload 7 [ 1] 42: iload 9 [ 2] 44: aload 8 [ 3] 46: iload 9 *[ 4] 48: iaload ---------- [ 3] 49: iconst_1 [ 4] 50: iadd *[ 3] 51: iastore ---------- [ 0] 52: iinc 9 1 ---------- [ 0] 55: iload 9 [ 1] 57: iload 4 [ 2] 59: if_icmplt 40 ---------- <p> [ 1] 42: iload 9 <ref> [ 2] </ref> 44: aload 8 [ 3] 46: iload 9 *[ 4] 48: iaload ---------- [ 3] 49: iconst_1 [ 4] 50: iadd *[ 3] 51: iastore ---------- [ 0] 52: iinc 9 1 ---------- [ 0] 55: iload 9 [ 1] 57: iload 4 [ 2] 59: if_icmplt 40 ---------- [ 0] 62: iinc 5 1 ---------- [ 0] 65: iload 5 [ 1] 67: iload_3 [ 2] 68: if_icmplt 18 ---------- [ 0] 71: aload_2 [ 1] 72: areturn ---------- [ 0] 74: aconst_null [ 1] 75: areturn ---------- Locals 0: m 2: a <p> 49: iconst_1 [ 4] 50: iadd *[ 3] 51: iastore ---------- [ 0] 52: iinc 9 1 ---------- [ 0] 55: iload 9 [ 1] 57: iload 4 <ref> [ 2] </ref> 59: if_icmplt 40 ---------- [ 0] 62: iinc 5 1 ---------- [ 0] 65: iload 5 [ 1] 67: iload_3 [ 2] 68: if_icmplt 18 ---------- [ 0] 71: aload_2 [ 1] 72: areturn ---------- [ 0] 74: aconst_null [ 1] 75: areturn ---------- Locals 0: m 2: a 4: nc 6: k 8: q 34 3.3 Exploitation of Implicit Loop Parallelism If a trivial loop L V in a method <p> Moreover, the method invocation instruction at 31 refers to the CONSTANT Methodref entry 5 and, hence, indirect to entries 1, 10, 11, 24, and 25: --&gt; constant_pool [ 1]: &lt;Class&gt; java/lang/Math constant_pool <ref> [ 2] </ref>: &lt;Class&gt; java/lang/Object constant_pool [ 3]: &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool <p> 1] 10: astore_2 [ 0] 11: iconst_0 [ 1] 12: istore_3 [ 0] 13: goto 50 ---------- [ 0] 16: iconst_0 [ 1] 17: istore 4 [ 0] 19: goto 39 ---------- [ 0] 22: aload_2 [ 1] 23: iload_3 *<ref> [ 2] </ref> 24: aaload ---------- [ 1] 25: iload 4 [ 2] 27: ldc2_w #7 &lt;Double&gt; 0x404535c28f5c28f6 [ 4] 30: dload_0 ---------- *[ 6] 31: invokestatic #5 &lt;Class&gt; java/lang/Math.sin (D)D ---------- [ 6] 34: dmul *[ 4] 35: dastore ---------- [ 0] 36: iinc 4 1 ---------- [ 0] 39: iload 4 [ 1] 41: sipush 1000 [ 2] 44: if_icmplt <p> 25: iload 4 <ref> [ 2] </ref> 27: ldc2_w #7 &lt;Double&gt; 0x404535c28f5c28f6 [ 4] 30: dload_0 ---------- *[ 6] 31: invokestatic #5 &lt;Class&gt; java/lang/Math.sin (D)D ---------- [ 6] 34: dmul *[ 4] 35: dastore ---------- [ 0] 36: iinc 4 1 ---------- [ 0] 39: iload 4 [ 1] 41: sipush 1000 [ 2] 44: if_icmplt 22 ---------- [ 0] 47: iinc 3 1 ---------- [ 0] 50: iload_3 [ 1] 51: sipush 1000 [ 2] 54: if_icmplt 16 ---------- [ 0] 57: return ---------- If constant pool entries must be copied into the constant pool of the auxiliary class, then currently javab <p> (D)D ---------- [ 6] 34: dmul *[ 4] 35: dastore ---------- [ 0] 36: iinc 4 1 ---------- [ 0] 39: iload 4 [ 1] 41: sipush 1000 <ref> [ 2] </ref> 44: if_icmplt 22 ---------- [ 0] 47: iinc 3 1 ---------- [ 0] 50: iload_3 [ 1] 51: sipush 1000 [ 2] 54: if_icmplt 16 ---------- [ 0] 57: return ---------- If constant pool entries must be copied into the constant pool of the auxiliary class, then currently javab copies the whole old constant pool into the new class file and simply obsoletes all entries that are not required. <p> address 65 is replaced by goto 76, and an exception handler starting at 121 for code region [76,121) and exception `java.lang.InterruptedException' is added to the exception table of this method: ... [ 1] 73: pop [ 0] 74: aconst_null [ 1] 75: areturn ---------- *[ 0] 76: new Par_Worker_par_0 ---------- <ref> [ 2] </ref> 80: aload 2 [ 3] 82: iload 3 [ 4] 84: iload 4 [ 5] 86: iload 5 ---------- *[ 6] 88: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 1] 91: iinc 5 1 *[ 1] 94: new Class Par_Worker_par_0 ---------- [ 3] 98: aload 2 [ 4]100: iload 3 [ <p> [ 5] 86: iload 5 ---------- *[ 6] 88: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 1] 91: iinc 5 1 *[ 1] 94: new Class Par_Worker_par_0 ---------- [ 3] 98: aload 2 [ 4]100: iload 3 [ 5]102: iload 4 [ 6]104: iload 5 ---------- *[ 7]106: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- <ref> [ 2] </ref>109: iinc 5 1 ---------- *[ 2]112: invokevirtual java.lang.Thread.join ()V ---------- *[ 1]115: invokevirtual java.lang.Thread.join ()V ---------- [ 0]118: goto 71 ---------- [ 0]122: goto 71 ---------- Subsequently, the compiler constructs a new class file that defines the Par par worker class with fields local 2 (with field descriptor `[[I'), <p> ---------- [ 1] 35: astore 7 [ 0] 37: aload_2 [ 1] 38: iload 6 *<ref> [ 2] </ref> 40: aaload ---------- [ 1] 41: astore 8 [ 0] 43: iconst_0 [ 1] 44: istore 9 [ 0] 46: goto 64 ---------- [ 0] 49: aload 7 [ 1] 51: iload 9 [ 2] 53: aload 8 [ 3] 55: iload 9 *[ 4] 57: iaload ---------- [ 3] 58: iconst_1 [ 4] 59: iadd *[ 3] 60: iastore ---------- [ 0] 61: iinc 9 1 ---------- [ 0] 64: iload 9 [ 1] 66: iload 4 [ 2] 68: if_icmplt 49 ---------- <p> [ 1] 51: iload 9 <ref> [ 2] </ref> 53: aload 8 [ 3] 55: iload 9 *[ 4] 57: iaload ---------- [ 3] 58: iconst_1 [ 4] 59: iadd *[ 3] 60: iastore ---------- [ 0] 61: iinc 9 1 ---------- [ 0] 64: iload 9 [ 1] 66: iload 4 [ 2] 68: if_icmplt 49 ---------- [ 0] 71: iinc 5 2 ---------- [ 0] 74: iload 5 [ 1] 76: iload_3 [ 2] 77: if_icmplt 27 ; fall-through to return ---------- [ 0] 80: return ---------- 4 Initial Experiments The techniques presented in this paper have been actually implemented in <p> 58: iconst_1 [ 4] 59: iadd *[ 3] 60: iastore ---------- [ 0] 61: iinc 9 1 ---------- [ 0] 64: iload 9 [ 1] 66: iload 4 <ref> [ 2] </ref> 68: if_icmplt 49 ---------- [ 0] 71: iinc 5 2 ---------- [ 0] 74: iload 5 [ 1] 76: iload_3 [ 2] 77: if_icmplt 27 ; fall-through to return ---------- [ 0] 80: return ---------- 4 Initial Experiments The techniques presented in this paper have been actually implemented in a prototype bytecode parallelization tool javab which is made freely available (for details, see the end of this paper). <p> &gt;; &gt;; &gt;; &gt;; &gt;i [ 1] 13: istore_2 hcon (0); &gt;; &gt;; &gt;; &gt;; &gt;i [ 0] 14: goto 29 h?; &gt;; &gt;; &gt;; &gt;; &gt;i ---------- [ 0] 17: aload_0 h?; ?; ?; ?; ?; ?i [ 1] 18: iload_2 hadecl (3; 1); ?; ?; ?; ?; ?i <ref> [ 2] </ref> 19: aload_1 hadecl (3; 1); var (fd 3 ; d 4 g); ?; ?; ?; ?i [ 3] 20: iload_2 hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); ?; ?; ?i [ 4] 21: iload_2 hadecl (3; 1); var (fd 3 ; d 4 <p> 3 ; d 4 g); ?; ?; ?; ?i ---------- [ 0] 26: iinc 2 1 h?; ?; ?; ?; ?; ?i ---------- [ 0] 29: iload_2 h?; ?; ?; ?; ?; ?i [ 1] 30: sipush 256 hvar (fd 3 ; d 4 g); ?; ?; ?; ?; ?i <ref> [ 2] </ref> 33: if_icmplt 17 hvar (fd 3 ; d 4 g); con (256); ?; ?; ?; ?i ---------- All three loops in Pendragon Software's CaffeineMark (tm) version 2.5 appear in the method fpmark () that is used to test floating point performance.
Reference: [3] <author> Andrew W. Appel. </author> <title> Modern Compiler Implementation in C. </title> <publisher> Cambridge University Press, </publisher> <address> New York, </address> <year> 1997. </year>
Reference-contexts: Although control and data flow analysis of more traditional intermediate representations (such as three-address code) are described extensively in the compiler literature (see e.g. <ref> [1, 3, 15, 35, 46, 47] </ref>), we briefly discuss the analysis specifically for bytecode. 1 Although the class file format provides a way to supply information about bytecode in so-called attributes [26, ch4], there is no pre-defined way yet to support bytecode optimization. <p> O := rd_gen [v] [ (rd in [v] rd kill [v]); if (rd_out [v] 6= O) - busy := true; rd_out [v] := O; - while (busy); - for a method with control flow graph G = hV; E; v 0 i by solving a forward, any-path (may) data-flow problem <ref> [1, 3, 15, 35, 46, 47] </ref>. First, for each basic block v 2 V , the sets rd gen [v] and rd kill [v] are constructed. <p> ; &gt;i if Pred (v) = ; O := (s_mod [v];s_in [v]); busy := true; s_out [v] := O; - while (busy); - 2.8 Copy and Constant Propagation Local stack state information can frequently be made slightly more accurate by using the following bytecode variants of copy and constant propagation <ref> [1, 3, 15, 35, 46, 47] </ref> on stack states. Under the assumption that no local is used before defined [26, ch8], the following replacements can be applied repetitively to the stack states associated with all instructions of a bytecode method. <p> 4 g), we have s mod [v 3 ] = hvar (fd 4 g); &gt;i. 20 *** method 0x08 init ([F [ZI)V 3-&gt;0 ---------- [ 0] 0: iconst_0 [ 1] 1: istore_3 [ 0] 2: goto 22 ---------- [ 0] 5: aload_0 [ 1] 6: iload_3 [ 2] 7: aload_1 <ref> [ 3] </ref> 8: iload_3 *[ 4] 9: baload ---------- [ 3] 10: ifeq 17 ---------- [ 2] 13: fconst_1 [ 3] 14: goto 18 ---------- [ 2] 17: fconst_2 ---------- *[ 3] 18: fastore ---------- [ 0] 19: iinc 3 1 ---------- [ 0] 22: iload_3 [ 1] 23: iload_2 [ <p> = hvar (fd 4 g); &gt;i. 20 *** method 0x08 init ([F [ZI)V 3-&gt;0 ---------- [ 0] 0: iconst_0 [ 1] 1: istore_3 [ 0] 2: goto 22 ---------- [ 0] 5: aload_0 [ 1] 6: iload_3 [ 2] 7: aload_1 <ref> [ 3] </ref> 8: iload_3 *[ 4] 9: baload ---------- [ 3] 10: ifeq 17 ---------- [ 2] 13: fconst_1 [ 3] 14: goto 18 ---------- [ 2] 17: fconst_2 ---------- *[ 3] 18: fastore ---------- [ 0] 19: iinc 3 1 ---------- [ 0] 22: iload_3 [ 1] 23: iload_2 [ 2] 24: if_icmplt 5 ---------- [ 0] 27: return <p> init ([F [ZI)V 3-&gt;0 ---------- [ 0] 0: iconst_0 [ 1] 1: istore_3 [ 0] 2: goto 22 ---------- [ 0] 5: aload_0 [ 1] 6: iload_3 [ 2] 7: aload_1 <ref> [ 3] </ref> 8: iload_3 *[ 4] 9: baload ---------- [ 3] 10: ifeq 17 ---------- [ 2] 13: fconst_1 [ 3] 14: goto 18 ---------- [ 2] 17: fconst_2 ---------- *[ 3] 18: fastore ---------- [ 0] 19: iinc 3 1 ---------- [ 0] 22: iload_3 [ 1] 23: iload_2 [ 2] 24: if_icmplt 5 ---------- [ 0] 27: return ---------- Locals 0: a 2: n All other stack state <p> method 0x00 decl ([[Ljava/lang/Thread;) [Ljava/lang/Thread; 2-&gt;1 ---------- [ 0] 0: iconst_2 *[ 1] 1: anewarray java.lang.Thread ---------- [ 1] 4: astore_2 [ 0] 5: aload_2 [ 1] 6: iconst_0 [ 2] 7: aload_0 *<ref> [ 3] </ref> 8: aastore ---------- [ 0] 9: aload_2 [ 1] 10: iconst_1 [ 2] 11: aload_1 [ 3] 12: iconst_0 *[ 4] 13: aaload ---------- [ 3] 14: iconst_0 *[ 4] 15: aaload ---------- *[ 3] 16: aastore ---------- [ 0] 17: aload_2 [ 1] 18: areturn ---------- Locals 0: this 1: t instruction at address 13 effectively converts this reference into apar (1; 1), i.e. a <p> 0: iconst_2 *[ 1] 1: anewarray java.lang.Thread ---------- [ 1] 4: astore_2 [ 0] 5: aload_2 [ 1] 6: iconst_0 [ 2] 7: aload_0 *<ref> [ 3] </ref> 8: aastore ---------- [ 0] 9: aload_2 [ 1] 10: iconst_1 [ 2] 11: aload_1 [ 3] 12: iconst_0 *[ 4] 13: aaload ---------- [ 3] 14: iconst_0 *[ 4] 15: aaload ---------- *[ 3] 16: aastore ---------- [ 0] 17: aload_2 [ 1] 18: areturn ---------- Locals 0: this 1: t instruction at address 13 effectively converts this reference into apar (1; 1), i.e. a reference to the last dimension of this array. <p> (1; 1); con (0); var (fd 1 g); &gt;i ---------- [ 0] 9: aload_2 h?; ?; ?; &gt;i [ 1] 10: iconst_1 href (1); ?; ?; &gt;i hadecl (1; 1); ?; ?; &gt;i [ 2] 11: aload_1 href (1); con (1); ?; &gt;i hadecl (1; 1); con (1); ?; &gt;i <ref> [ 3] </ref> 12: iconst_0 href (1); con (1); var (fd 2 g); &gt;i hadecl (1; 1); con (1); apar (1; 2); &gt;i *[ 4] 13: aaload href (1); con (1); var (fd 2 g); con (0)i hadecl (1; 1); con (1); apar (1; 2); con (0)i ---------- [ 3] 14: iconst_0 <p> (1); ?; &gt;i <ref> [ 3] </ref> 12: iconst_0 href (1); con (1); var (fd 2 g); &gt;i hadecl (1; 1); con (1); apar (1; 2); &gt;i *[ 4] 13: aaload href (1); con (1); var (fd 2 g); con (0)i hadecl (1; 1); con (1); apar (1; 2); con (0)i ---------- [ 3] 14: iconst_0 href (1); con (1); ref (13); ?i hadecl (1; 1); con (1); apar (1; 1); ?i *[ 4] 15: aaload href (1); con (1); ref (13); con (0)i hadecl (1; 1); con (1); apar (1; 1); con (0)i ---------- *[ 3] 16: aastore href (1); con (1); <p> hexp (1; fd 3 ; d 6 g); ?; ?i [ 0] 16: goto 28 h?; ?; ?i ---------- [ 0] 19: aload_0 h?; ?; ?i [ 1] 20: iload_3 hapar (0; 1); ?; ?i [ 2] 21: iconst_4 hapar (0; 1); var (fd 4 ; d 5 g); ?i <ref> [ 3] </ref> 22: iadd hapar (0; 1); var (fd 4 ; d 5 g); con (4)i [ 2] 23: iconst_1 hapar (0; 1); exp (4; fd 4 ; d 5 g); ?i *[ 3] 24: iastore hapar (0; 1); exp (4; fd 4 ; d 5 g); con (1)i ---------- d5: <p> d5: [ 0] 25: iinc 3 1 h?; ?; ?i ---------- [ 0] 28: iload_3 h?; ?; ?i [ 1] 29: iload_2 hvar (fd 4 ; d 5 g); ?; ?i [ 2] 30: iconst_2 hvar (fd 4 ; d 5 g); var (fd 3 ; d 6 g); ?i <ref> [ 3] </ref> 31: isub hvar (fd 4 ; d 5 g); var (fd 3 ; d 6 g); con (2)i [ 2] 32: if_icmplt 19 hvar (fd 4 ; d 5 g); exp (2; fd 3 ; d 6 g); ?i ... <p> &gt;i ---------- [ 1] 6: astore_2 hadecl (2; 2); &gt;; &gt;; &gt;i ... [ 0] 40: aload 7 h?; ?; ?; ?i [ 1] 42: iload 9 hadecl (2; 1); ?; ?; ?i [ 2] 44: aload 8 hadecl (2; 1); var (fd 10 ; d 11 g); ?; ?i <ref> [ 3] </ref> 46: iload 9 hadecl (2; 1); var (fd 10 ; d 11 g); adecl (2; 1); ?i *[ 4] 48: iaload hadecl (2; 1); var (fd 10 ; d 11 g); adecl (2; 1); var (fd 10 ; d 11 g)i ---------- [ 3] 49: iconst_1 hadecl (2; 1); <p> ; d 11 g); ?; ?i <ref> [ 3] </ref> 46: iload 9 hadecl (2; 1); var (fd 10 ; d 11 g); adecl (2; 1); ?i *[ 4] 48: iaload hadecl (2; 1); var (fd 10 ; d 11 g); adecl (2; 1); var (fd 10 ; d 11 g)i ---------- [ 3] 49: iconst_1 hadecl (2; 1); var (fd 10 ; d 11 g); ?; ?i [ 4] 50: iadd hadecl (2; 1); var (fd 10 ; d 11 g); ?; con (1)i *[ 3] 51: iastore hadecl (2; 1); var (fd 10 ; d 11 g); ?; ?i ---------- [ <p> 7 [ 0] 28: aload_2 [ 1] 29: iload 6 *[ 2] 31: aaload ---------- [ 1] 32: astore 8 [ 0] 34: iconst_0 [ 1] 35: istore 9 [ 0] 37: goto 55 ---------- [ 0] 40: aload 7 [ 1] 42: iload 9 [ 2] 44: aload 8 <ref> [ 3] </ref> 46: iload 9 *[ 4] 48: iaload ---------- [ 3] 49: iconst_1 [ 4] 50: iadd *[ 3] 51: iastore ---------- [ 0] 52: iinc 9 1 ---------- [ 0] 55: iload 9 [ 1] 57: iload 4 [ 2] 59: if_icmplt 40 ---------- [ 0] 62: iinc 5 <p> *[ 2] 31: aaload ---------- [ 1] 32: astore 8 [ 0] 34: iconst_0 [ 1] 35: istore 9 [ 0] 37: goto 55 ---------- [ 0] 40: aload 7 [ 1] 42: iload 9 [ 2] 44: aload 8 <ref> [ 3] </ref> 46: iload 9 *[ 4] 48: iaload ---------- [ 3] 49: iconst_1 [ 4] 50: iadd *[ 3] 51: iastore ---------- [ 0] 52: iinc 9 1 ---------- [ 0] 55: iload 9 [ 1] 57: iload 4 [ 2] 59: if_icmplt 40 ---------- [ 0] 62: iinc 5 1 ---------- [ 0] 65: iload 5 [ 1] 67: <p> Moreover, the method invocation instruction at 31 refers to the CONSTANT Methodref entry 5 and, hence, indirect to entries 1, 10, 11, 24, and 25: --&gt; constant_pool [ 1]: &lt;Class&gt; java/lang/Math constant_pool [ 2]: &lt;Class&gt; java/lang/Object constant_pool <ref> [ 3] </ref>: &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions <p> goto 76, and an exception handler starting at 121 for code region [76,121) and exception `java.lang.InterruptedException' is added to the exception table of this method: ... [ 1] 73: pop [ 0] 74: aconst_null [ 1] 75: areturn ---------- *[ 0] 76: new Par_Worker_par_0 ---------- [ 2] 80: aload 2 <ref> [ 3] </ref> 82: iload 3 [ 4] 84: iload 4 [ 5] 86: iload 5 ---------- *[ 6] 88: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 1] 91: iinc 5 1 *[ 1] 94: new Class Par_Worker_par_0 ---------- [ 3] 98: aload 2 [ 4]100: iload 3 [ 5]102: iload 4 [ 6]104: <p> 75: areturn ---------- *[ 0] 76: new Par_Worker_par_0 ---------- [ 2] 80: aload 2 <ref> [ 3] </ref> 82: iload 3 [ 4] 84: iload 4 [ 5] 86: iload 5 ---------- *[ 6] 88: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 1] 91: iinc 5 1 *[ 1] 94: new Class Par_Worker_par_0 ---------- [ 3] 98: aload 2 [ 4]100: iload 3 [ 5]102: iload 4 [ 6]104: iload 5 ---------- *[ 7]106: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 2]109: iinc 5 1 ---------- *[ 2]112: invokevirtual java.lang.Thread.join ()V ---------- *[ 1]115: invokevirtual java.lang.Thread.join ()V ---------- [ 0]118: goto 71 ---------- [ 0]122: goto 71 <p> 7 [ 0] 37: aload_2 [ 1] 38: iload 6 *[ 2] 40: aaload ---------- [ 1] 41: astore 8 [ 0] 43: iconst_0 [ 1] 44: istore 9 [ 0] 46: goto 64 ---------- [ 0] 49: aload 7 [ 1] 51: iload 9 [ 2] 53: aload 8 <ref> [ 3] </ref> 55: iload 9 *[ 4] 57: iaload ---------- [ 3] 58: iconst_1 [ 4] 59: iadd *[ 3] 60: iastore ---------- [ 0] 61: iinc 9 1 ---------- [ 0] 64: iload 9 [ 1] 66: iload 4 [ 2] 68: if_icmplt 49 ---------- [ 0] 71: iinc 5 <p> *[ 2] 40: aaload ---------- [ 1] 41: astore 8 [ 0] 43: iconst_0 [ 1] 44: istore 9 [ 0] 46: goto 64 ---------- [ 0] 49: aload 7 [ 1] 51: iload 9 [ 2] 53: aload 8 <ref> [ 3] </ref> 55: iload 9 *[ 4] 57: iaload ---------- [ 3] 58: iconst_1 [ 4] 59: iadd *[ 3] 60: iastore ---------- [ 0] 61: iinc 9 1 ---------- [ 0] 64: iload 9 [ 1] 66: iload 4 [ 2] 68: if_icmplt 49 ---------- [ 0] 71: iinc 5 2 ---------- [ 0] 74: iload 5 [ 1] 76: <p> 14: goto 29 h?; &gt;; &gt;; &gt;; &gt;; &gt;i ---------- [ 0] 17: aload_0 h?; ?; ?; ?; ?; ?i [ 1] 18: iload_2 hadecl (3; 1); ?; ?; ?; ?; ?i [ 2] 19: aload_1 hadecl (3; 1); var (fd 3 ; d 4 g); ?; ?; ?; ?i <ref> [ 3] </ref> 20: iload_2 hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); ?; ?; ?i [ 4] 21: iload_2 hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); var (fd 3 ; d 4 g); ?; ?i [ 5] 22: i2c hadecl
Reference: [4] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1996. </year>
Reference-contexts: ---------- [ 0] 0: iconst_0 [ 1] 1: istore 4 [ 0] 3: goto 49 ---------- [ 0] 6: iconst_0 [ 1] 7: istore 5 [ 0] 9: goto 40 ---------- [ 0] 12: aload_2 [ 1] 13: iload 4 *[ 2] 15: aaload ---------- ---------- [ 5] 34: iadd <ref> [ 4] </ref> 35: iadd *[ 3] 36: iastore ---------- [ 0] 37: iinc 5 1 ---------- [ 0] 40: iload 5 [ 1] 42: iload_3 [ 2] 43: if_icmplt 12 ---------- [ 0] 46: iinc 4 1 ---------- [ 0] 49: iload 4 [ 1] 51: iload_3 [ 2] 52: if_icmplt <p> previous method with a long parameter that appears in the following class Fac: class Fac - static long recLongFac (long n) - return (n &gt; 1) ? recLongFac (n-1) * n : 1; - 16 *** method 0x08 recLongFac (J)J 2-&gt;2 ---------- [ 0] 0: lload_0 [ 2] 1: lconst_1 <ref> [ 4] </ref> 2: lcmp [ 1] 3: ifle 15 ---------- [ 0] 6: lload_0 [ 2] 7: lconst_1 [ 4] 8: lsub ---------- *[ 2] 9: invokestatic Fac.recLongFac (J)J ---------- [ 2] 12: lload_0 [ 4] 13: lmul [ 2] 14: lreturn ---------- [ 0] 15: lconst_1 [ 2] 16: lreturn <p> recLongFac (long n) - return (n &gt; 1) ? recLongFac (n-1) * n : 1; - 16 *** method 0x08 recLongFac (J)J 2-&gt;2 ---------- [ 0] 0: lload_0 [ 2] 1: lconst_1 <ref> [ 4] </ref> 2: lcmp [ 1] 3: ifle 15 ---------- [ 0] 6: lload_0 [ 2] 7: lconst_1 [ 4] 8: lsub ---------- *[ 2] 9: invokestatic Fac.recLongFac (J)J ---------- [ 2] 12: lload_0 [ 4] 13: lmul [ 2] 14: lreturn ---------- [ 0] 15: lconst_1 [ 2] 16: lreturn ---------- Locals 0: n Stack size information for the corresponding byte code is summarized in Figure 10. <p> 16 *** method 0x08 recLongFac (J)J 2-&gt;2 ---------- [ 0] 0: lload_0 [ 2] 1: lconst_1 <ref> [ 4] </ref> 2: lcmp [ 1] 3: ifle 15 ---------- [ 0] 6: lload_0 [ 2] 7: lconst_1 [ 4] 8: lsub ---------- *[ 2] 9: invokestatic Fac.recLongFac (J)J ---------- [ 2] 12: lload_0 [ 4] 13: lmul [ 2] 14: lreturn ---------- [ 0] 15: lconst_1 [ 2] 16: lreturn ---------- Locals 0: n Stack size information for the corresponding byte code is summarized in Figure 10. <p> allowing invocations of side-effect free static methods such as `java.lang.Math.cos ()'. 26 *** method 0x00 add_field ([DI)V 3-&gt;0 ---------- [ 0] 0: iconst_0 [ 1] 1: istore_3 [ 0] 2: goto 18 ---------- [ 0] 5: aload_1 [ 1] 6: iload_3 [ 2] 7: dup2 *<ref> [ 4] </ref> 8: daload ---------- [ 4] 9: aload_0 *[ 5] 10: getfield Field.d D ---------- [ 6] 13: dadd *[ 4] 14: dastore ---------- [ 0] 15: iinc 3 1 ---------- [ 0] 18: iload_3 [ 1] 19: iload_2 [ 2] 20: if_icmplt 5 ---------- [ 0] 23: return ---------- Locals 0: this 1: a <p> ?; ?; ?; ?; ?i [ 2] 7: dup2 hapar (1; 1); var (fd 4 ; d 5 g); ?; ?; ?; ?i *<ref> [ 4] </ref> 8: daload hapar (1; 1); var (fd 4 ; d 5 g); apar (1; 1); var (fd 4 ; d 5 g); ?; ?i ---------- [ 4] 9: aload_0 hapar (1; 1); var (fd 4 ; d 5 g); ?; ?; ?; ?i *[ 5] 10: getfield d hapar (1; 1); var (fd 4 ; d 5 g); ?; ?; var (fd 1 g); ?i ---------- [ 6] 13: dadd hapar (1; 1); var (fd 4 <p> 10 ; d 11 g); adecl (2; 1); ?i *<ref> [ 4] </ref> 48: iaload hadecl (2; 1); var (fd 10 ; d 11 g); adecl (2; 1); var (fd 10 ; d 11 g)i ---------- [ 3] 49: iconst_1 hadecl (2; 1); var (fd 10 ; d 11 g); ?; ?i [ 4] 50: iadd hadecl (2; 1); var (fd 10 ; d 11 g); ?; con (1)i *[ 3] 51: iastore hadecl (2; 1); var (fd 10 ; d 11 g); ?; ?i ---------- [ 0] 52: iinc 9 1 h?; ?; ?; ?i ---------- [ 0] 55: iload 9 h?; <p> ---------- [ 1] 32: astore 8 [ 0] 34: iconst_0 [ 1] 35: istore 9 [ 0] 37: goto 55 ---------- [ 0] 40: aload 7 [ 1] 42: iload 9 [ 2] 44: aload 8 [ 3] 46: iload 9 *<ref> [ 4] </ref> 48: iaload ---------- [ 3] 49: iconst_1 [ 4] 50: iadd *[ 3] 51: iastore ---------- [ 0] 52: iinc 9 1 ---------- [ 0] 55: iload 9 [ 1] 57: iload 4 [ 2] 59: if_icmplt 40 ---------- [ 0] 62: iinc 5 1 ---------- [ 0] 65: iload 5 [ 1] 67: iload_3 [ 2] 68: <p> Moreover, the method invocation instruction at 31 refers to the CONSTANT Methodref entry 5 and, hence, indirect to entries 1, 10, 11, 24, and 25: --&gt; constant_pool [ 1]: &lt;Class&gt; java/lang/Math constant_pool [ 2]: &lt;Class&gt; java/lang/Object constant_pool [ 3]: &lt;Class&gt; [[D constant_pool <ref> [ 4] </ref>: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: <p> [ 1] 12: istore_3 [ 0] 13: goto 50 ---------- [ 0] 16: iconst_0 [ 1] 17: istore 4 [ 0] 19: goto 39 ---------- [ 0] 22: aload_2 [ 1] 23: iload_3 *[ 2] 24: aaload ---------- [ 1] 25: iload 4 [ 2] 27: ldc2_w #7 &lt;Double&gt; 0x404535c28f5c28f6 <ref> [ 4] </ref> 30: dload_0 ---------- *[ 6] 31: invokestatic #5 &lt;Class&gt; java/lang/Math.sin (D)D ---------- [ 6] 34: dmul *[ 4] 35: dastore ---------- [ 0] 36: iinc 4 1 ---------- [ 0] 39: iload 4 [ 1] 41: sipush 1000 [ 2] 44: if_icmplt 22 ---------- [ 0] 47: iinc 3 <p> handler starting at 121 for code region [76,121) and exception `java.lang.InterruptedException' is added to the exception table of this method: ... [ 1] 73: pop [ 0] 74: aconst_null [ 1] 75: areturn ---------- *[ 0] 76: new Par_Worker_par_0 ---------- [ 2] 80: aload 2 [ 3] 82: iload 3 <ref> [ 4] </ref> 84: iload 4 [ 5] 86: iload 5 ---------- *[ 6] 88: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 1] 91: iinc 5 1 *[ 1] 94: new Class Par_Worker_par_0 ---------- [ 3] 98: aload 2 [ 4]100: iload 3 [ 5]102: iload 4 [ 6]104: iload 5 ---------- *[ 7]106: <p> 76: new Par_Worker_par_0 ---------- [ 2] 80: aload 2 [ 3] 82: iload 3 <ref> [ 4] </ref> 84: iload 4 [ 5] 86: iload 5 ---------- *[ 6] 88: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 1] 91: iinc 5 1 *[ 1] 94: new Class Par_Worker_par_0 ---------- [ 3] 98: aload 2 [ 4]100: iload 3 [ 5]102: iload 4 [ 6]104: iload 5 ---------- *[ 7]106: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 2]109: iinc 5 1 ---------- *[ 2]112: invokevirtual java.lang.Thread.join ()V ---------- *[ 1]115: invokevirtual java.lang.Thread.join ()V ---------- [ 0]118: goto 71 ---------- [ 0]122: goto 71 ---------- Subsequently, the compiler constructs <p> ---------- [ 1] 41: astore 8 [ 0] 43: iconst_0 [ 1] 44: istore 9 [ 0] 46: goto 64 ---------- [ 0] 49: aload 7 [ 1] 51: iload 9 [ 2] 53: aload 8 [ 3] 55: iload 9 *<ref> [ 4] </ref> 57: iaload ---------- [ 3] 58: iconst_1 [ 4] 59: iadd *[ 3] 60: iastore ---------- [ 0] 61: iinc 9 1 ---------- [ 0] 64: iload 9 [ 1] 66: iload 4 [ 2] 68: if_icmplt 49 ---------- [ 0] 71: iinc 5 2 ---------- [ 0] 74: iload 5 [ 1] 76: iload_3 [ 2] 77: <p> [ 1] 18: iload_2 hadecl (3; 1); ?; ?; ?; ?; ?i [ 2] 19: aload_1 hadecl (3; 1); var (fd 3 ; d 4 g); ?; ?; ?; ?i [ 3] 20: iload_2 hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); ?; ?; ?i <ref> [ 4] </ref> 21: iload_2 hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); var (fd 3 ; d 4 g); ?; ?i [ 5] 22: i2c hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); var (fd 3 ; d 4 g); var
Reference: [5] <author> Utpal Banerjee. </author> <title> Dependence Analysis. </title> <publisher> Kluwer, </publisher> <address> Boston, </address> <year> 1997. </year> <title> A Book Series on Loop Transformations for Restructuring Compilers. </title>
Reference-contexts: ([[I [[I [[II)V 4-&gt;0 ---------- [ 0] 0: iconst_0 [ 1] 1: istore 4 [ 0] 3: goto 49 ---------- [ 0] 6: iconst_0 [ 1] 7: istore 5 [ 0] 9: goto 40 ---------- [ 0] 12: aload_2 [ 1] 13: iload 4 *[ 2] 15: aaload ---------- ---------- <ref> [ 5] </ref> 34: iadd [ 4] 35: iadd *[ 3] 36: iastore ---------- [ 0] 37: iinc 5 1 ---------- [ 0] 40: iload 5 [ 1] 42: iload_3 [ 2] 43: if_icmplt 12 ---------- [ 0] 46: iinc 4 1 ---------- [ 0] 49: iload 4 [ 1] 51: iload_3 <p> = exp (c 0 ; D 0 )) return (lp.strict) ? exp (c + c 0 1; D 0 ) : exp (c + c 0 ; D 0 ) - return ?; - in the interval [9; 102) (viz. i 2 [1; 500); j 2 [4; 101); k 2 <ref> [5; 98)): static void bound (int a [] </ref>) - for (int i = 1; i &lt; 500; i++) for (int k = j+1; k &lt; j-2; k++) - code stack states ... [ 0] 12: iload_2 h?; ?; ?i [ 1] 13: iconst_1 hvar (fd 3 ; d 6 g); ?; <p> Moreover, the method invocation instruction at 31 refers to the CONSTANT Methodref entry 5 and, hence, indirect to entries 1, 10, 11, 24, and 25: --&gt; constant_pool [ 1]: &lt;Class&gt; java/lang/Math constant_pool [ 2]: &lt;Class&gt; java/lang/Object constant_pool [ 3]: &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool <ref> [ 5] </ref>: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: <p> code region [76,121) and exception `java.lang.InterruptedException' is added to the exception table of this method: ... [ 1] 73: pop [ 0] 74: aconst_null [ 1] 75: areturn ---------- *[ 0] 76: new Par_Worker_par_0 ---------- [ 2] 80: aload 2 [ 3] 82: iload 3 [ 4] 84: iload 4 <ref> [ 5] </ref> 86: iload 5 ---------- *[ 6] 88: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 1] 91: iinc 5 1 *[ 1] 94: new Class Par_Worker_par_0 ---------- [ 3] 98: aload 2 [ 4]100: iload 3 [ 5]102: iload 4 [ 6]104: iload 5 ---------- *[ 7]106: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ <p> [ 2] 80: aload 2 [ 3] 82: iload 3 [ 4] 84: iload 4 <ref> [ 5] </ref> 86: iload 5 ---------- *[ 6] 88: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 1] 91: iinc 5 1 *[ 1] 94: new Class Par_Worker_par_0 ---------- [ 3] 98: aload 2 [ 4]100: iload 3 [ 5]102: iload 4 [ 6]104: iload 5 ---------- *[ 7]106: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 2]109: iinc 5 1 ---------- *[ 2]112: invokevirtual java.lang.Thread.join ()V ---------- *[ 1]115: invokevirtual java.lang.Thread.join ()V ---------- [ 0]118: goto 71 ---------- [ 0]122: goto 71 ---------- Subsequently, the compiler constructs a new class file <p> ?; ?; ?; ?i [ 3] 20: iload_2 hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); ?; ?; ?i [ 4] 21: iload_2 hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); var (fd 3 ; d 4 g); ?; ?i <ref> [ 5] </ref> 22: i2c hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); var (fd 3 ; d 4 g); var (fd 3 ; d 4 g); ?i [ 5] 23: dup_x2 hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); var (fd <p> (fd 3 ; d 4 g); adecl (9; 1); var (fd 3 ; d 4 g); ?; ?i <ref> [ 5] </ref> 22: i2c hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); var (fd 3 ; d 4 g); var (fd 3 ; d 4 g); ?i [ 5] 23: dup_x2 hadecl (3; 1); var (fd 3 ; d 4 g); adecl (9; 1); var (fd 3 ; d 4 g); ?; ?i *[ 6] 24: castore hadecl (3; 1); var (fd 3 ; d 4 g); ?; adecl (9; 1); var (fd 3 ; d 4 g);
Reference: [6] <author> Aart J.C. Bik and Dennis B. Gannon. </author> <title> Automatically exploiting implicit parallelism in Java. </title> <journal> Concurrency, Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 579-619, </pages> <year> 1997. </year>
Reference-contexts: The diagram above reveals some obvious ways to speedup Java programs. At source code level (viz. (i)), a source-to-source restructuring can be applied. In earlier work <ref> [6] </ref>, for example, we have shown how a restructuring compiler can make loop parallelism in a Java source program explicit using the multi-threading mechanism of the Java programming language [18, 24, 32]. <p> 26 *** method 0x00 add_field ([DI)V 3-&gt;0 ---------- [ 0] 0: iconst_0 [ 1] 1: istore_3 [ 0] 2: goto 18 ---------- [ 0] 5: aload_1 [ 1] 6: iload_3 [ 2] 7: dup2 *[ 4] 8: daload ---------- [ 4] 9: aload_0 *[ 5] 10: getfield Field.d D ---------- <ref> [ 6] </ref> 13: dadd *[ 4] 14: dastore ---------- [ 0] 15: iinc 3 1 ---------- [ 0] 18: iload_3 [ 1] 19: iload_2 [ 2] 20: if_icmplt 5 ---------- [ 0] 23: return ---------- Locals 0: this 1: a 3: i The bytecode, corresponding flow graph G = hV; E; <p> (fd 4 ; d 5 g); ?; ?i ---------- [ 4] 9: aload_0 hapar (1; 1); var (fd 4 ; d 5 g); ?; ?; ?; ?i *[ 5] 10: getfield d hapar (1; 1); var (fd 4 ; d 5 g); ?; ?; var (fd 1 g); ?i ---------- <ref> [ 6] </ref> 13: dadd hapar (1; 1); var (fd 4 ; d 5 g; ?; ?; ?; ?i *[ 4] 14: dastore hapar (1; 1); var (fd 4 ; d 5 g; ?; ?; ?; ?i ---------- [ 0] 15: iinc 3 1 h?; ?; ?; ?; ?; ?i ... <p> The actual parallelization resembles the Java source code transformations described in <ref> [6] </ref>, although now all transformations are directly applied at bytecode level. Because there is usually little advantage of having nested parallel loops, we disable the parallelization of candidate parallel loops within another candidate parallel loop. <p> instruction at 31 refers to the CONSTANT Methodref entry 5 and, hence, indirect to entries 1, 10, 11, 24, and 25: --&gt; constant_pool [ 1]: &lt;Class&gt; java/lang/Math constant_pool [ 2]: &lt;Class&gt; java/lang/Object constant_pool [ 3]: &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool <ref> [ 6] </ref>: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: <p> [ 1] 17: istore 4 [ 0] 19: goto 39 ---------- [ 0] 22: aload_2 [ 1] 23: iload_3 *[ 2] 24: aaload ---------- [ 1] 25: iload 4 [ 2] 27: ldc2_w #7 &lt;Double&gt; 0x404535c28f5c28f6 [ 4] 30: dload_0 ---------- *<ref> [ 6] </ref> 31: invokestatic #5 &lt;Class&gt; java/lang/Math.sin (D)D ---------- [ 6] 34: dmul *[ 4] 35: dastore ---------- [ 0] 36: iinc 4 1 ---------- [ 0] 39: iload 4 [ 1] 41: sipush 1000 [ 2] 44: if_icmplt 22 ---------- [ 0] 47: iinc 3 1 ---------- [ 0] 50: iload_3 [ 1] 51: sipush 1000 [ 2] 54: <p> 2 [ 3] 82: iload 3 [ 4] 84: iload 4 [ 5] 86: iload 5 ---------- *<ref> [ 6] </ref> 88: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 1] 91: iinc 5 1 *[ 1] 94: new Class Par_Worker_par_0 ---------- [ 3] 98: aload 2 [ 4]100: iload 3 [ 5]102: iload 4 [ 6]104: iload 5 ---------- *[ 7]106: invokespecial Par_Worker_par_0.&lt;init&gt; ([[IIII)V ---------- [ 2]109: iinc 5 1 ---------- *[ 2]112: invokevirtual java.lang.Thread.join ()V ---------- *[ 1]115: invokevirtual java.lang.Thread.join ()V ---------- [ 0]118: goto 71 ---------- [ 0]122: goto 71 ---------- Subsequently, the compiler constructs a new class file that defines the Par <p> This work extends our earlier work on Java source code restructuring <ref> [6] </ref> in two ways: first, all transformations are now directly applied at bytecode level and, second, loop parallelism is now also detected automatically (rather than relying on annotations in the Java source code). <p> Hereby, techniques that incrementally update inter-procedural information after changes of parts of a program [13] will be very useful. Obtaining Java Research Tools Documentation and the complete source of the prototype bytecode parallelization tool javab, together with a prototype Java restructuring compiler javar described in <ref> [6] </ref>, are made available for education, research, and non-profit purposes at: http://www.extreme.indiana.edu/hpjava/ 43
Reference: [7] <author> Zoran Budimlic and Ken Kennedy. </author> <title> Optimizing Java theory and practice. </title> <journal> Concurrency, Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 445-463, </pages> <year> 1997. </year>
Reference-contexts: Alternatively, optimizations can be applied at bytecode level, either at compile-time or run-time. Compile-time bytecode optimization (viz. (ii)) can be done by an integrated module of the Java compiler (cf. `javac -O') or by a stand-alone bytecode-to-bytecode optimizer <ref> [7, 12] </ref>. 3 The latter approach makes the optimizer independent of the actual Java compiler, which allows the optimization of bytecodes from alternative sources, such as bytecodes that have been downloaded over a network, bytecodes generated by bytecode producing compilers for other high level languages, or bytecodes produced by a JVM <p> Methodref entry 5 and, hence, indirect to entries 1, 10, 11, 24, and 25: --&gt; constant_pool [ 1]: &lt;Class&gt; java/lang/Math constant_pool [ 2]: &lt;Class&gt; java/lang/Object constant_pool [ 3]: &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool <ref> [ 7] </ref>: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool <p> Compile-time has been kept limited by letting the compiler rely on less accurate but generally also less expensive analysis. For example, operand stack states are only traced partially, rather than doing a more accurate conversion of stack usage into expressions trees, as is discussed in, for example, the paper <ref> [7] </ref>. Although this implies that currently only relatively simple loop bounds and subscripts can be dealt with, preliminary experiments indicate that this simple analysis already suffices to handle a reasonable number of loops in numerical programs.
Reference: [8] <author> David Callahan. </author> <title> A Global Approach to Detection of Parallelism. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Rice University, </institution> <year> 1987. </year>
Reference: [9] <author> Bryan Carpenter, Yuh-Jye Chang, Geoffrey Fox, Donald Leskiw, and Xiaoming Li. </author> <title> Experiments with `HP Java'. </title> <journal> Concurrency, Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 633-648, </pages> <year> 1997. </year>
Reference-contexts: Hence, although Java already has a potential to become a major language in scientific and engineering computing <ref> [9, 17] </ref>, clearly means to speedup execution have to be found before Java can be truly competitive with languages like FORTRAN and C. The diagram above reveals some obvious ways to speedup Java programs. At source code level (viz. (i)), a source-to-source restructuring can be applied. <p> indirect to entries 1, 10, 11, 24, and 25: --&gt; constant_pool [ 1]: &lt;Class&gt; java/lang/Math constant_pool [ 2]: &lt;Class&gt; java/lang/Object constant_pool [ 3]: &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool <ref> [ 9] </ref>: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool
Reference: [10] <author> Michal Cierniak and Wei Li. </author> <title> Just-in-time optimizations for high-performance Java programs. </title> <note> To Appear Concurrency, Practice and Experience, </note> <year> 1997. </year>
Reference-contexts: A more aggressive approach at this stage, however, is to abandon the interpretation of bytecode completely, and to perform a JIT (just-in-time) compilation into native machine code prior to execution (see e.g. <ref> [10, 20, 22] </ref>). Besides the obvious advantage that native code runs substantially faster than bytecode interpretation, the run-time approach usually also allows more optimizations. <p> 24, and 25: --&gt; constant_pool [ 1]: &lt;Class&gt; java/lang/Math constant_pool [ 2]: &lt;Class&gt; java/lang/Object constant_pool [ 3]: &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool <ref> [10] </ref>: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math
Reference: [11] <author> Michal Cierniak and Wei Li. </author> <title> Optimizing Java bytecodes. </title> <journal> Concurrency, Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 427-444, </pages> <year> 1997. </year>
Reference-contexts: Finally, bytecode optimizations can be performed at run-time (viz. (iii)). Again, a bytecode-to-bytecode transformation can be performed at this stage, which now has the advantage that specific properties of the target platform can be accounted for during the optimizations <ref> [11] </ref>. A more aggressive approach at this stage, however, is to abandon the interpretation of bytecode completely, and to perform a JIT (just-in-time) compilation into native machine code prior to execution (see e.g. [10, 20, 22]). <p> [ 1]: &lt;Class&gt; java/lang/Math constant_pool [ 2]: &lt;Class&gt; java/lang/Object constant_pool [ 3]: &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool <ref> [11] </ref>: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]:
Reference: [12] <author> Lars R. Clausen. </author> <title> A Java bytecode optimizer using side-effect analysis. </title> <note> To Appear in a Special Issue of Concurrency, Practice and Experience, </note> <year> 1997. </year>
Reference-contexts: Alternatively, optimizations can be applied at bytecode level, either at compile-time or run-time. Compile-time bytecode optimization (viz. (ii)) can be done by an integrated module of the Java compiler (cf. `javac -O') or by a stand-alone bytecode-to-bytecode optimizer <ref> [7, 12] </ref>. 3 The latter approach makes the optimizer independent of the actual Java compiler, which allows the optimization of bytecodes from alternative sources, such as bytecodes that have been downloaded over a network, bytecodes generated by bytecode producing compilers for other high level languages, or bytecodes produced by a JVM <p> java/lang/Math constant_pool [ 2]: &lt;Class&gt; java/lang/Object constant_pool [ 3]: &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool <ref> [12] </ref>: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method <p> Simple data dependence tests for arrays and scalars have been used, rather than advanced data dependence analysis, and parallelization of a loop in which field modifications occur is disabled, rather than using e.g. the side-effect analysis presented in <ref> [12] </ref>. However, although using more advanced analysis will increase the opportunities for loop parallelization, keeping compile-time limited may become more important if the techniques are used for some form of JIT parallelization, i.e. bytecode parallelization directly prior to execution or JIT compilation of the bytecode.
Reference: [13] <author> Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> The impact of interprocedural analysis and optimization in the R n programming environment. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8 </volume> <pages> 491-523, </pages> <year> 1986. </year>
Reference-contexts: 2]: &lt;Class&gt; java/lang/Object constant_pool [ 3]: &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool <ref> [13] </ref>: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V <p> Hereby, techniques that incrementally update inter-procedural information after changes of parts of a program <ref> [13] </ref> will be very useful. Obtaining Java Research Tools Documentation and the complete source of the prototype bytecode parallelization tool javab, together with a prototype Java restructuring compiler javar described in [6], are made available for education, research, and non-profit purposes at: http://www.extreme.indiana.edu/hpjava/ 43
Reference: [14] <institution> Pendragon Software Corporation. </institution> <note> Pendragon Software's CaffeineMark(tm) version 2.5 - Java Benchmark. This Java benchmark is made available at http://www.webfayre.com/cm.html. </note>
Reference-contexts: constant_pool [ 3]: &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool <ref> [14] </ref>: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ <p> particular loop and target platform when n exceeds 30, and an efficiency over 85% is obtained. 4.2 Statistics In the following table, we present the results of applying javab to the class files of a number of packages: (i) the complete Java 1.0.2API, (ii) Pendragon Software's CaffeineMark (tm) version 2.5 <ref> [14] </ref>, (iii) a wavelet transformation package written by David Wanqian Liu [27], and (iv) a Java implementation of some routines of BLAS and LINPACK [44] written by Steve Verrill.
Reference: [15] <author> C.N. Fischer and R.J. LeBlanc. </author> <title> Crafting a Compiler. </title> <address> Benjamin-Cummings, Menlo Park, California, </address> <year> 1988. </year>
Reference-contexts: Although control and data flow analysis of more traditional intermediate representations (such as three-address code) are described extensively in the compiler literature (see e.g. <ref> [1, 3, 15, 35, 46, 47] </ref>), we briefly discuss the analysis specifically for bytecode. 1 Although the class file format provides a way to supply information about bytecode in so-called attributes [26, ch4], there is no pre-defined way yet to support bytecode optimization. <p> O := rd_gen [v] [ (rd in [v] rd kill [v]); if (rd_out [v] 6= O) - busy := true; rd_out [v] := O; - while (busy); - for a method with control flow graph G = hV; E; v 0 i by solving a forward, any-path (may) data-flow problem <ref> [1, 3, 15, 35, 46, 47] </ref>. First, for each basic block v 2 V , the sets rd gen [v] and rd kill [v] are constructed. <p> ; &gt;i if Pred (v) = ; O := (s_mod [v];s_in [v]); busy := true; s_out [v] := O; - while (busy); - 2.8 Copy and Constant Propagation Local stack state information can frequently be made slightly more accurate by using the following bytecode variants of copy and constant propagation <ref> [1, 3, 15, 35, 46, 47] </ref> on stack states. Under the assumption that no local is used before defined [26, ch8], the following replacements can be applied repetitively to the stack states associated with all instructions of a bytecode method. <p> &lt;Class&gt; [[D constant_pool [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool <ref> [15] </ref>: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush
Reference: [16] <author> David Flanagan. </author> <title> Java in a Nutshell. </title> <publisher> O'Reilly & Associates, </publisher> <address> Sebastopol, CA, </address> <year> 1996. </year>
Reference-contexts: [ 4]: &lt;Class&gt; Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool <ref> [16] </ref>: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 [ 1]
Reference: [17] <author> Geoffrey C. Fox and Wojtek Furmanski. </author> <title> Java for parallel computing and as a general language for scientific and engineering simulation and modeling. </title> <journal> Concurrency, Practice and Experience, </journal> <volume> 9(6) </volume> <pages> 415-425, </pages> <year> 1997. </year>
Reference-contexts: Hence, although Java already has a potential to become a major language in scientific and engineering computing <ref> [9, 17] </ref>, clearly means to speedup execution have to be found before Java can be truly competitive with languages like FORTRAN and C. The diagram above reveals some obvious ways to speedup Java programs. At source code level (viz. (i)), a source-to-source restructuring can be applied. <p> Pool --&gt; constant_pool [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool <ref> [17] </ref>: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 [ 1] 3: sipush 1000
Reference: [18] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> Java Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Architectural neutrality of the Java programming language <ref> [18] </ref> is due to the compilation of Java source programs into bytecode, i.e. instructions of the JVM (Java Virtual Machine) [26], rather than the more traditional compilation of source programs into native machine code. Bytecode can run on any platform that provides an implementation of the JVM. <p> At source code level (viz. (i)), a source-to-source restructuring can be applied. In earlier work [6], for example, we have shown how a restructuring compiler can make loop parallelism in a Java source program explicit using the multi-threading mechanism of the Java programming language <ref> [18, 24, 32] </ref>. Eventually, speedup can be obtained on any platform that supports true parallel execution of JVM threads (like the AIX4.2 JDK on an IBM RS/6000 G30). <p> Also, for security reasons, JVM implementations will probably have to reject such optimization attributes from untrusted sources anyway. 4 2.1 The Java Virtual Machine The JVM is a stack-based virtual machine that has been designed to support the Java programming language <ref> [18, 26] </ref>. The input of the JVM consists of platform-independent class files. Each class file is a binary file that contains information about the fields and methods of one particular class, a constant pool (a kind of symbol-table), as well as the actual bytecode for each method. <p> [ 5]: &lt;Class&gt; java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool <ref> [18] </ref>: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 [ 1] 3: sipush 1000 *[ 2] 6: <p> More elaborate experiments are planned in a follow-up paper. Our prototype focuses on the parallelization of loops that operate on arrays, and this paralleliza-tion is done by means of an off-line bytecode to bytecode conversion. Because exceptions have to be dealt with precisely <ref> [18, 26] </ref>, the parallelization of loops is only applied to regions of code for which the compiler can prove that run-time exceptions cannot be thrown. A potential change in semantics with respect to JVM errors and (possibly) linking-exceptions is allowed, however.
Reference: [19] <author> Jonathan C. Hardwick and Jay Sipelstein. </author> <title> Java as an intermediate language. </title> <type> Technical Report CMU-CS-96-161, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1996. </year> <month> 44 </month>
Reference-contexts: java/lang/Math.sin (D)D constant_pool [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool <ref> [19] </ref>: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 [ 1] 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt;
Reference: [20] <author> Joe Hummel, Ana Azevedo, David Kolson, and Alex Nicolau. </author> <title> Annotating the Java bytecodes in support of optimization. </title> <note> To Appear in a Special Issue of Concurrency, Practice and Experience, </note> <year> 1997. </year>
Reference-contexts: A more aggressive approach at this stage, however, is to abandon the interpretation of bytecode completely, and to perform a JIT (just-in-time) compilation into native machine code prior to execution (see e.g. <ref> [10, 20, 22] </ref>). Besides the obvious advantage that native code runs substantially faster than bytecode interpretation, the run-time approach usually also allows more optimizations. <p> [ 6]: &lt;Class&gt; java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool <ref> [20] </ref>: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 [ 1] 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [
Reference: [21] <author> Donald E. Knuth. </author> <title> An Empirical Study of FORTRAN Programs. </title> <institution> US Department of Commerce, Stanford University, </institution> <year> 1971. </year>
Reference-contexts: v 2 V : 8 &gt; : S p2Pred (v) rd out [p] rd out [v] = rd gen [v] [ (rd in [v] rd kill [v]) (1) The iterative algorithm comp reaching defs () shown in Figure 5 is used to solve these data flow equations (statistics gathered in <ref> [21] </ref> reveal that visiting the vertices in the flow graph according to topological sorting of the dominance relation tends to reduce the number of passes required to solve forward data flow equations iteratively [1, 47]). <p> java/lang/Object.&lt;init&gt; ()V --&gt; constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool <ref> [21] </ref>: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 [ 1] 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [ 1] 10: astore_2
Reference: [22] <author> Andreas Krall and Reinhard Grafl. </author> <title> A Java just-in-time compiler that transcends Java-VM's 32 bit barrier. </title> <note> To Appear in a Special Issue of Concurrency, Practice and Experience, </note> <year> 1997. </year>
Reference-contexts: A more aggressive approach at this stage, however, is to abandon the interpretation of bytecode completely, and to perform a JIT (just-in-time) compilation into native machine code prior to execution (see e.g. <ref> [10, 20, 22] </ref>). Besides the obvious advantage that native code runs substantially faster than bytecode interpretation, the run-time approach usually also allows more optimizations. <p> constant_pool [ 7]: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool <ref> [22] </ref>: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 [ 1] 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [ 1] 10: astore_2 [ 0] 11:
Reference: [23] <author> David J. Kuck. </author> <title> The Structure of Computers and Computations. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <booktitle> 1978. </booktitle> <volume> Volume 1. </volume>
Reference-contexts: &lt;Double&gt; 42.42 constant_pool [ 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool <ref> [23] </ref>: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 [ 1] 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [ 1] 10: astore_2 [ 0] 11: iconst_0 [ 1]
Reference: [24] <author> Doug Lea. </author> <title> Concurrent Programming in Java. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: At source code level (viz. (i)), a source-to-source restructuring can be applied. In earlier work [6], for example, we have shown how a restructuring compiler can make loop parallelism in a Java source program explicit using the multi-threading mechanism of the Java programming language <ref> [18, 24, 32] </ref>. Eventually, speedup can be obtained on any platform that supports true parallel execution of JVM threads (like the AIX4.2 JDK on an IBM RS/6000 G30). <p> 9]: &lt;init&gt; ()V --&gt; constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool <ref> [24] </ref>: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 [ 1] 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [ 1] 10: astore_2 [ 0] 11: iconst_0 [ 1] 12: istore_3 [ 0]
Reference: [25] <author> Zhiyuan Li and Walid Abu-Sufah. </author> <title> On reducing data synchronization in multi-processed loops. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36:105-109, </volume> <year> 1987. </year>
Reference-contexts: constant_pool [10]: sin (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool <ref> [25] </ref>: java/lang/Math constant_pool [26]: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 [ 1] 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [ 1] 10: astore_2 [ 0] 11: iconst_0 [ 1] 12: istore_3 [ 0] 13: goto 50 ----------
Reference: [26] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Architectural neutrality of the Java programming language [18] is due to the compilation of Java source programs into bytecode, i.e. instructions of the JVM (Java Virtual Machine) <ref> [26] </ref>, rather than the more traditional compilation of source programs into native machine code. Bytecode can run on any platform that provides an implementation of the JVM. Below, a typical compiled-interpreted execution of a Java program is illustrated. <p> Run-time optimization, however, can generate native code (or, in the interpreted approach, a new form of quick pseudo-instruction could be used, cf. <ref> [26, ch9] </ref>) in which all superfluous checks are omitted. <p> analysis of more traditional intermediate representations (such as three-address code) are described extensively in the compiler literature (see e.g. [1, 3, 15, 35, 46, 47]), we briefly discuss the analysis specifically for bytecode. 1 Although the class file format provides a way to supply information about bytecode in so-called attributes <ref> [26, ch4] </ref>, there is no pre-defined way yet to support bytecode optimization. <p> Also, for security reasons, JVM implementations will probably have to reject such optimization attributes from untrusted sources anyway. 4 2.1 The Java Virtual Machine The JVM is a stack-based virtual machine that has been designed to support the Java programming language <ref> [18, 26] </ref>. The input of the JVM consists of platform-independent class files. Each class file is a binary file that contains information about the fields and methods of one particular class, a constant pool (a kind of symbol-table), as well as the actual bytecode for each method. <p> At run-time, the JVM fetches an opcode and corresponding operands, executes the corresponding action, and then continues with the next instruction. At the JVM-level, operations are performed on the abstract notion of words <ref> [26, ch3] </ref>: words have a platform-specific size, but two words can contain values of type long and double, whereas one word can contain values of all other types. <p> Situation (1) can occur during execution of any instruction, because the JVM specification does not mandate precisely when JVM errors can be reported <ref> [26, ch6] </ref>. In contrast, the compiler can easily determine when situation (2) or (3) may occur, because the JVM specification [26] precisely documents which instructions may explicitly or implicitly throw linking exceptions or run-time exceptions. <p> Situation (1) can occur during execution of any instruction, because the JVM specification does not mandate precisely when JVM errors can be reported [26, ch6]. In contrast, the compiler can easily determine when situation (2) or (3) may occur, because the JVM specification <ref> [26] </ref> precisely documents which instructions may explicitly or implicitly throw linking exceptions or run-time exceptions. <p> Finally, we add an edge from the basic block of each instruction that may throw an exception to the entry basic block of every exception handler that covers the region of bytecode in which the instruction appear, and to a dummy basic block that represents abnormal completion of the method <ref> [26, ch3] </ref>, i.e. the situation where a thrown exception is not caught by any handler of the method (in the prototype, the types of exceptions are not accounted for during flow graph construction, so that some redundant edges may arise). <p> are shown in Figure 1. class Flow - int a []; int flow () - int i = 0, j = 0; do i++; while (i &lt; 500); - catch (Exception e) return 0; - finally a= null; - return j; - First, the access flags, name, and method descriptor <ref> [26, ch4] </ref> of the method are shown (`0x000 flow ()I'). <p> 4 [ 1] 51: iload_3 [ 2] 52: if_icmplt 6 ---------- [ 0] 55: return ---------- Locals 0: a 2: c 4: i 2.4 Reaching Definitions of Local Variables On a method invocation, a fixed-sized frame consisting of a fixed-sized operand stack and a set of local variables is allocated <ref> [26, ch3] </ref>. Effectively, this latter set consists of an array of words in which locals are addressed as word offsets from the array base. A bytecode instruction that assigns a value to a local variable in this frame forms a definition of that local. <p> The types of these parameters can be easily determined from the bytecode context. For an instance method, the first parameter is a reference this to an instance of the class in which the method is defined. Types of all other arguments are defined by the corresponding method descriptor <ref> [26, ch4] </ref>. At implementation level, each definition of a local in a particular method can be represented by two words: the address of the defining instruction (set to ? for definitions arising from parameter passing), and the offset of the local. <p> Using this stack, however, slightly differs from using stacks in more traditional stack-based architectures: the JVM specification requires that for each bytecode instruction, the operand stack contains the same number of words prior to the execution of this instruction, regardless of the execution path taken to reach the instruction <ref> [26, ch4] </ref>. Consider, for example, the following Java method: static int myMethod (int n) - int i, acc = 0; return acc; - The left fragment shown below presents an assembler representation of the bytecode that is generated by the Java compiler for this method. <p> For most instructions, this number is fixed, whereas for putfield, putstatic, invoke&lt;kind&gt;, and multianewarray, this number can be determined from the bytecode context (i.e. a field or method descriptor in the constant pool, or an operand of the opcode <ref> [26] </ref>). Likewise, sp post (i) yields the number of words that are pushed back on the operand stack by i. <p> stack is uninitialized, contains an addition of a constant c and a local defined by a definition d 2 D, an array reference generated by an instruction at address a, or an unknown or `irrelevant' value, respectively. 3 In particular, under the assumption that no local is used before defined <ref> [26, ch8] </ref>, we let exp (c; D) represent a single constant for D = ;, which will be denoted as con (c), or a single local defined by a d 2 D for c = 0, which will be denoted as var (D). <p> Under the assumption that no local is used before defined <ref> [26, ch8] </ref>, the following replacements can be applied repetitively to the stack states associated with all instructions of a bytecode method. <p> (fdg) component, where the single definition d is formed by an m-dimensional array parameter in local l, is replaced by a new component apar (l; m) (the number of leading `[' characters in an individual parameter descriptor in a method descriptor defines the number of dimensions for each array parameter <ref> [26, ch4] </ref>). Subsequently, the compiler attempts to chase each ref (a) component in the local stack state information back to the corresponding parameters or declarations using algorithm chase array refs () of Figure 15. <p> Note that the looping construct of the left fragment is typically generated by the javac compiler to reduce the number of overhead instructions around the loop <ref> [26, ch7] </ref>. 25 3.2 Detection of Implicit Loop Parallelism A trivial loop L V in a method with flow graph G = hV; E; v 0 i is a candidate for parallelization if (i) the operand stack is empty on entry and exit of the loop, (ii) the loop-body does not <p> All other inner-loop bytecode instructions are replaced by nop (these instructions are unreachable in the resulting code), and attributes that are nested within the Code attribute <ref> [26, ch4] </ref> are stripped from the resulting class file, because the meaning of these attributes may have become obsoleted. 3.3.2 Construction of a new Loop Worker Class In the next step, the compiler generates a class file for the auxiliary class `MyClass Worker x' that corresponds to the following Java definition <p> have become obsoleted. 3.3.2 Construction of a new Loop Worker Class In the next step, the compiler generates a class file for the auxiliary class `MyClass Worker x' that corresponds to the following Java definition (but keep in mind that this class is directly generated in the class file format <ref> [26] </ref>): class MyClas_Worker_x extends java.lang.Thread - private t 1 loc_1; ... private t p loc_p; public MyClass_Worker_x (t 1 loc_1, ..., t p loc_p) - this.loc_1 = loc_1; ... this.loc_p = loc_p; start (); - public void run () - ... - In the constructor, the values of the p locals <p> ..., t p loc_p) - this.loc_1 = loc_1; ... this.loc_p = loc_p; start (); - public void run () - ... - In the constructor, the values of the p locals that are passed as parameter are temporarily stored in p fields of appropriate type, as described by field descriptors <ref> [26, ch4] </ref> in the class file. Moreover, a new thread is started by calling start (). The run ()-method in this class has the form shown below. <p> In a future implementation, however, more advanced scheduling policies (see e.g. [36, ch4][45, p73-74][46, p387-392] [41, 42][47, 296-298]) with better load balancing or data locality properties could be incorporated. If an instruction within the loop (indirectly) refers to entries in the constant pool of the original class file <ref> [26] </ref>, these entries must be copied into the constant pool of the new auxiliary class. <p> (D)D --&gt; constant_pool [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool <ref> [26] </ref>: (D)V constant_pool [27]: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 [ 1] 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [ 1] 10: astore_2 [ 0] 11: iconst_0 [ 1] 12: istore_3 [ 0] 13: goto 50 ---------- [ 0] 16: <p> More elaborate experiments are planned in a follow-up paper. Our prototype focuses on the parallelization of loops that operate on arrays, and this paralleliza-tion is done by means of an off-line bytecode to bytecode conversion. Because exceptions have to be dealt with precisely <ref> [18, 26] </ref>, the parallelization of loops is only applied to regions of code for which the compiler can prove that run-time exceptions cannot be thrown. A potential change in semantics with respect to JVM errors and (possibly) linking-exceptions is allowed, however.
Reference: [27] <author> David Wanqian Liu. </author> <title> Wavelet Transformation Package. </title> <note> This package is made available at http://reality.sgi.com/davidliu/. </note>
Reference-contexts: [11]: (D)D constant_pool [12]: pool constant_pool [13]: ConstantValue constant_pool [14]: Exceptions constant_pool [15]: Pool.java constant_pool [16]: LineNumberTable constant_pool [17]: SourceFile constant_pool [18]: LocalVariables constant_pool [19]: Code constant_pool [20]: java/lang/Object constant_pool [21]: [[D constant_pool [22]: Pool constant_pool [23]: &lt;init&gt; --&gt; constant_pool [24]: sin --&gt; constant_pool [25]: java/lang/Math constant_pool [26]: (D)V constant_pool <ref> [27] </ref>: ()V *** method 0x08 pool (D)V 2-&gt;0 ---------- [ 0] 0: sipush 1000 [ 1] 3: sipush 1000 *[ 2] 6: multianewarray #3 &lt;Class&gt; [[D ---------- [ 1] 10: astore_2 [ 0] 11: iconst_0 [ 1] 12: istore_3 [ 0] 13: goto 50 ---------- [ 0] 16: iconst_0 [ 1] <p> efficiency over 85% is obtained. 4.2 Statistics In the following table, we present the results of applying javab to the class files of a number of packages: (i) the complete Java 1.0.2API, (ii) Pendragon Software's CaffeineMark (tm) version 2.5 [14], (iii) a wavelet transformation package written by David Wanqian Liu <ref> [27] </ref>, and (iv) a Java implementation of some routines of BLAS and LINPACK [44] written by Steve Verrill.
Reference: [28] <author> Jon Meyer. Jasmin: </author> <title> a Java Assembler Interface. </title> <note> This JVM bytecode assembler is made available at http://www.cat.nyu.edu/meyer/jasmin/. </note>
Reference-contexts: latter approach makes the optimizer independent of the actual Java compiler, which allows the optimization of bytecodes from alternative sources, such as bytecodes that have been downloaded over a network, bytecodes generated by bytecode producing compilers for other high level languages, or bytecodes produced by a JVM assembler like Jasmin <ref> [28, 29] </ref>. The former approach has the advantage, however, that high level information about the program does not have to be recovered prior to the actual optimizations. Finally, bytecode optimizations can be performed at run-time (viz. (iii)).
Reference: [29] <author> Jon Meyer and Troy Downing. </author> <title> Java Virtual Machine. </title> <publisher> O'Reilly & Associates, </publisher> <address> Sebastopol, CA, </address> <year> 1997. </year>
Reference-contexts: latter approach makes the optimizer independent of the actual Java compiler, which allows the optimization of bytecodes from alternative sources, such as bytecodes that have been downloaded over a network, bytecodes generated by bytecode producing compilers for other high level languages, or bytecodes produced by a JVM assembler like Jasmin <ref> [28, 29] </ref>. The former approach has the advantage, however, that high level information about the program does not have to be recovered prior to the actual optimizations. Finally, bytecode optimizations can be performed at run-time (viz. (iii)).
Reference: [30] <author> Samuel P. Midkiff. </author> <title> The Dependence Analysis and Synchronization of Parallel Programs. </title> <type> PhD thesis, </type> <institution> C.S.R.D., </institution> <year> 1993. </year>
Reference: [31] <author> Samuel P. Midkiff and David A. Padua. </author> <title> Compiler algorithms for synchronization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36:1485-1495, </volume> <year> 1987. </year>
Reference: [32] <author> Scott Oaks and Henry Wong. </author> <title> Java Threads. </title> <publisher> O'Reilly & Associates, </publisher> <address> Sebastopol, CA, </address> <year> 1997. </year>
Reference-contexts: At source code level (viz. (i)), a source-to-source restructuring can be applied. In earlier work [6], for example, we have shown how a restructuring compiler can make loop parallelism in a Java source program explicit using the multi-threading mechanism of the Java programming language <ref> [18, 24, 32] </ref>. Eventually, speedup can be obtained on any platform that supports true parallel execution of JVM threads (like the AIX4.2 JDK on an IBM RS/6000 G30).
Reference: [33] <author> David A. Padua, David J. Kuck, and Duncan H. Lawrie. </author> <title> High speed multiprocessors and compilation techniques. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-29:763-776, </volume> <year> 1980. </year>
Reference: [34] <author> David A. Padua and Michael J. Wolfe. </author> <title> Advanced compiler optimizations for supercomputers. </title> <journal> Communications of the ACM, </journal> <volume> 29 </volume> <pages> 1184-1201, </pages> <year> 1986. </year>
Reference: [35] <author> Thomas W. Parsons. </author> <title> Introduction to Compiler Construction. </title> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Although control and data flow analysis of more traditional intermediate representations (such as three-address code) are described extensively in the compiler literature (see e.g. <ref> [1, 3, 15, 35, 46, 47] </ref>), we briefly discuss the analysis specifically for bytecode. 1 Although the class file format provides a way to supply information about bytecode in so-called attributes [26, ch4], there is no pre-defined way yet to support bytecode optimization. <p> O := rd_gen [v] [ (rd in [v] rd kill [v]); if (rd_out [v] 6= O) - busy := true; rd_out [v] := O; - while (busy); - for a method with control flow graph G = hV; E; v 0 i by solving a forward, any-path (may) data-flow problem <ref> [1, 3, 15, 35, 46, 47] </ref>. First, for each basic block v 2 V , the sets rd gen [v] and rd kill [v] are constructed. <p> ; &gt;i if Pred (v) = ; O := (s_mod [v];s_in [v]); busy := true; s_out [v] := O; - while (busy); - 2.8 Copy and Constant Propagation Local stack state information can frequently be made slightly more accurate by using the following bytecode variants of copy and constant propagation <ref> [1, 3, 15, 35, 46, 47] </ref> on stack states. Under the assumption that no local is used before defined [26, ch8], the following replacements can be applied repetitively to the stack states associated with all instructions of a bytecode method.
Reference: [36] <author> Constantine D. Polychronopoulos. </author> <title> Parallel Programming and Compilers. </title> <publisher> Kluwer, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: As stated earlier, this effectively implements a cyclic scheduling policy. In a future implementation, however, more advanced scheduling policies (see e.g. <ref> [36, ch4] </ref>[45, p73-74][46, p387-392] [41, 42][47, 296-298]) with better load balancing or data locality properties could be incorporated.
Reference: [37] <author> Constantine D. Polychronopoulos, David J. Kuck, and David A. Padua. </author> <title> Execution of parallel loops on parallel processor systems. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <pages> pages 519-527, </pages> <year> 1986. </year>
Reference: [38] <author> William Pugh. </author> <title> The Omega test: a fast and practical integer programming algorithm for dependence analysis. </title> <journal> Communications of the ACM, </journal> <year> 1992. </year>
Reference: [39] <author> William Pugh and David Wonnacott. </author> <title> An evaluation of exact methods for analysis of value-based array data dependences. </title> <booktitle> In Proceedings of the Sixth Annual Workshop on Languages and Compilers for Parallel Computing, </booktitle> <year> 1993. </year> <month> 45 </month>
Reference: [40] <author> Barbara G. Ryder. </author> <title> Constructing the call graph of a program. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5:216-226, </volume> <year> 1979. </year>
Reference-contexts: In addition, analysis that deals with a program as a whole is called inter-procedural analysis (where a call-graph <ref> [40] </ref> is used to represent possible transfer of control between methods).
Reference: [41] <author> Rizos Sakellarious and John R. Gurd. </author> <title> Compile-time minimisation of load imbalance in loop nests. </title> <booktitle> In Proceedings of the International Conference on Supercomputing, </booktitle> <address> Vienna, </address> <year> 1997. </year>
Reference-contexts: As stated earlier, this effectively implements a cyclic scheduling policy. In a future implementation, however, more advanced scheduling policies (see e.g. [36, ch4][45, p73-74][46, p387-392] <ref> [41, 42] </ref>[47, 296-298]) with better load balancing or data locality properties could be incorporated. If an instruction within the loop (indirectly) refers to entries in the constant pool of the original class file [26], these entries must be copied into the constant pool of the new auxiliary class.
Reference: [42] <author> Rizos Sakellarious and John R. Gurd. </author> <title> Compile-time schemes for mapping loop parallelism. </title> <editor> In A. Bakkers, editor, </editor> <booktitle> Parallel Programming and Java, </booktitle> <pages> pages 252-260. </pages> <publisher> IOS Press, </publisher> <year> 1997. </year> <month> (WoTUG-20). </month>
Reference-contexts: As stated earlier, this effectively implements a cyclic scheduling policy. In a future implementation, however, more advanced scheduling policies (see e.g. [36, ch4][45, p73-74][46, p387-392] <ref> [41, 42] </ref>[47, 296-298]) with better load balancing or data locality properties could be incorporated. If an instruction within the loop (indirectly) refers to entries in the constant pool of the original class file [26], these entries must be copied into the constant pool of the new auxiliary class.
Reference: [43] <author> Shawn Silverman. D-Java: </author> <title> a Class File Disassembler. </title> <note> This JVM bytecode disassembler is made available at http://home.cc.umanitoba.ca/~umsilve1/djava/. </note>
Reference: [44] <author> Steve Verrill. </author> <title> Linear Algebra for Statistics Java Package. </title> <note> This numerical package is made available at http://www1.fpl.fs.fed.us/linear_algebra.html. </note>
Reference-contexts: the results of applying javab to the class files of a number of packages: (i) the complete Java 1.0.2API, (ii) Pendragon Software's CaffeineMark (tm) version 2.5 [14], (iii) a wavelet transformation package written by David Wanqian Liu [27], and (iv) a Java implementation of some routines of BLAS and LINPACK <ref> [44] </ref> written by Steve Verrill.
Reference: [45] <author> Michael J. Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <publisher> Pitman, </publisher> <address> London, </address> <year> 1989. </year>
Reference: [46] <author> Michael J. Wolfe. </author> <title> High Performance Compilers for Parallel Computers. </title> <publisher> Addison-Wesley, </publisher> <address> Redwood City, California, </address> <year> 1996. </year>
Reference-contexts: Although control and data flow analysis of more traditional intermediate representations (such as three-address code) are described extensively in the compiler literature (see e.g. <ref> [1, 3, 15, 35, 46, 47] </ref>), we briefly discuss the analysis specifically for bytecode. 1 Although the class file format provides a way to supply information about bytecode in so-called attributes [26, ch4], there is no pre-defined way yet to support bytecode optimization. <p> O := rd_gen [v] [ (rd in [v] rd kill [v]); if (rd_out [v] 6= O) - busy := true; rd_out [v] := O; - while (busy); - for a method with control flow graph G = hV; E; v 0 i by solving a forward, any-path (may) data-flow problem <ref> [1, 3, 15, 35, 46, 47] </ref>. First, for each basic block v 2 V , the sets rd gen [v] and rd kill [v] are constructed. <p> ; &gt;i if Pred (v) = ; O := (s_mod [v];s_in [v]); busy := true; s_out [v] := O; - while (busy); - 2.8 Copy and Constant Propagation Local stack state information can frequently be made slightly more accurate by using the following bytecode variants of copy and constant propagation <ref> [1, 3, 15, 35, 46, 47] </ref> on stack states. Under the assumption that no local is used before defined [26, ch8], the following replacements can be applied repetitively to the stack states associated with all instructions of a bytecode method.
Reference: [47] <author> H. Zima and B. Chapman. </author> <title> Supercompilers for Parallel and Vector Computers. </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1990. </year> <month> 46 </month>
Reference-contexts: Although control and data flow analysis of more traditional intermediate representations (such as three-address code) are described extensively in the compiler literature (see e.g. <ref> [1, 3, 15, 35, 46, 47] </ref>), we briefly discuss the analysis specifically for bytecode. 1 Although the class file format provides a way to supply information about bytecode in so-called attributes [26, ch4], there is no pre-defined way yet to support bytecode optimization. <p> O := rd_gen [v] [ (rd in [v] rd kill [v]); if (rd_out [v] 6= O) - busy := true; rd_out [v] := O; - while (busy); - for a method with control flow graph G = hV; E; v 0 i by solving a forward, any-path (may) data-flow problem <ref> [1, 3, 15, 35, 46, 47] </ref>. First, for each basic block v 2 V , the sets rd gen [v] and rd kill [v] are constructed. <p> defs () shown in Figure 5 is used to solve these data flow equations (statistics gathered in [21] reveal that visiting the vertices in the flow graph according to topological sorting of the dominance relation tends to reduce the number of passes required to solve forward data flow equations iteratively <ref> [1, 47] </ref>). Here, we assume that the entry vertex v 0 2 V has a dummy predecessor w, where rd out [w] consists of all definitions that are formed by invoking the current method. <p> ; &gt;i if Pred (v) = ; O := (s_mod [v];s_in [v]); busy := true; s_out [v] := O; - while (busy); - 2.8 Copy and Constant Propagation Local stack state information can frequently be made slightly more accurate by using the following bytecode variants of copy and constant propagation <ref> [1, 3, 15, 35, 46, 47] </ref> on stack states. Under the assumption that no local is used before defined [26, ch8], the following replacements can be applied repetitively to the stack states associated with all instructions of a bytecode method. <p> If the loop-body is not executed for the upper bound, then this upper bound is called strict. Otherwise, the upper bound is called non-strict. Conventional loop transformations, such as loop-normalization <ref> [47, p174-177] </ref>, either at bytecode level, or already at source code level, could be used to increase the number of trivial loops in a program.
References-found: 47

