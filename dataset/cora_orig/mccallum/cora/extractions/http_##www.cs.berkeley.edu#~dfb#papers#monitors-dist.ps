URL: http://www.cs.berkeley.edu/~dfb/papers/monitors-dist.ps
Refering-URL: http://www.cs.berkeley.edu/~dfb/publist.html
Root-URL: 
Title: Thin Locks: Featherweight Synchronization for Java  
Author: David F. Bacon Ravi Konuru Chet Murthy Mauricio Serrano 
Affiliation: IBM T.J. Watson Research Center  
Abstract: Language-supported synchronization is a source of serious performance problems in many Java programs. Even single-threaded applications may spend up to half their time performing useless synchronization due to the thread-safe nature of the Java libraries. We solve this performance problem with a new algorithm that allows lock and unlock operations to be performed with only a few machine instructions in the most common cases. Our locks only require a partial word per object, and were implemented without increasing object size. We present measurements from our implementation in the JDK 1.1.2 for AIX, demonstrating speedups of up to a factor of 5 in micro-benchmarks and up to a factor of 1.7 in real programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anderson, T. E. </author> <title> The performance of spin lock alternatives for shared memory multiprocessors. </title> <journal> IEEE Transactions on Parallel and Distributed Systems 1, </journal> <month> 1 (Jan. </month> <year> 1990), </year> <pages> 6-16. </pages>
Reference-contexts: In general, this works well. The only pathological case occurs when an object is locked by one thread and not released for a long time, during which time other threads are spinning on the object. Standard back-off techniques <ref> [1] </ref> for reducing the cost of spin-locking can be applied to solve this problem. 3 Measurements In this section we evaluate our implementation of thin locks in the JDK 1.1.2 for IBM's AIX operating system on the PowerPC. <p> He is implicitly assuming that mutual exclusion is only being used in the operating system, or that the overhead of an operating system trap is acceptable on every lock and unlock operation from user-level code. Both Anderson <ref> [1] </ref> and Mellor-Crummey and Scott [12] 10 provide thorough discussions of synchronization algorithms for multiprocessors and include comparative performance measurements. 5 Conclusions We have presented thin locks, a method for implementing monitors in the Java programming language using a partial word of storage per object.
Reference: [2] <author> Dijkstra, E. W. </author> <title> Solution of a problem in concurrent programming and control. </title> <journal> Commun. ACM 8, </journal> <month> 9 (Sept. </month> <year> 1965), </year> <month> 569. </month>
Reference-contexts: There is a significant body of work on how to achieve mutual exclusion with only atomic read and write operations <ref> [2, 9, 10, 13, 14] </ref>. These solutions were rendered obsolete by the introduction of instructions that performed compound atomic operations such as exchange, test-and-set, and compare-and-swap [6].
Reference: [3] <author> Gosling, J., Joy, B., and Steele, G. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mas-sachussetts, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Monitors [5] are a language-level construct for providing mutually exclusive access to shared data structures in a multi-threaded environment. However, the overhead required by the necessary locking has generally restricted their use to relatively "heavy-weight" objects. Recently, their incorporation in Java <ref> [3] </ref> has led to renewed interest in monitors, because of both their prevalence and their associated performance problems. Java uses monitor semantics derived from Mesa [11].
Reference: [4] <author> Gottlieb, A., Lubachevsky, B. D., and Rudolph, L. </author> <title> Basic techniques for the efficient coordination of very large numbers of cooperating sequential processors. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 5, </volume> <month> 2 (Apr. </month> <year> 1983), </year> <pages> 164-189. </pages>
Reference-contexts: Such operations were later generalized to the Fetch-and- primitive for multiprocessors [8], and were particularly popular on machines with butterfly-type interconnects because concurrent Fetch-and operations to the same location could be combined in the network <ref> [4] </ref>. Many microprocessors have not had compound atomic operations until relatively recently because mutual exclusion was generally considered to be the province of operating systems and parallel processors.
Reference: [5] <author> Hoare, C. A. R. </author> <title> Monitors: An operating system structuring concept. </title> <journal> Commun. ACM 17, </journal> <month> 10 (Oct. </month> <year> 1974), </year> <pages> 549-557. </pages>
Reference-contexts: 1 Introduction Monitors <ref> [5] </ref> are a language-level construct for providing mutually exclusive access to shared data structures in a multi-threaded environment. However, the overhead required by the necessary locking has generally restricted their use to relatively "heavy-weight" objects.
Reference: [6] <institution> IBM Corporation. IBM 370 Principles of Operation. </institution>
Reference-contexts: There is a significant body of work on how to achieve mutual exclusion with only atomic read and write operations [2, 9, 10, 13, 14]. These solutions were rendered obsolete by the introduction of instructions that performed compound atomic operations such as exchange, test-and-set, and compare-and-swap <ref> [6] </ref>. Such operations were later generalized to the Fetch-and- primitive for multiprocessors [8], and were particularly popular on machines with butterfly-type interconnects because concurrent Fetch-and operations to the same location could be combined in the network [4].
Reference: [7] <author> Krall, A., and Probst, M. </author> <title> Monitors and exceptions: How to implement Java efficiently. </title> <booktitle> In ACM Workshop on Java for High-Performance Network Computing (1998). </booktitle>
Reference-contexts: As seen in the "UnlkC&S" case, the cost of the additional atomic operation is significant. 8 9 4 Related Work Krall and Probst <ref> [7] </ref> implemented monitors for the CACAO Java JIT compiler. They argue that because object size is at a premium, monitors should be kept externally in a hash table. However, our 24-bit thin locks have been used in a Java implementation with only two words of overhead per object.
Reference: [8] <author> Kruskal, C. P., Rudolph, L., and Snir, M. </author> <title> Efficient synchronization on multiprocessors with shared memory. </title> <booktitle> In Proceedings of the Fifth Annual ACM Symposium on Principles of Distributed Computing (1986), </booktitle> <pages> pp. 218-228. </pages>
Reference-contexts: These solutions were rendered obsolete by the introduction of instructions that performed compound atomic operations such as exchange, test-and-set, and compare-and-swap [6]. Such operations were later generalized to the Fetch-and- primitive for multiprocessors <ref> [8] </ref>, and were particularly popular on machines with butterfly-type interconnects because concurrent Fetch-and operations to the same location could be combined in the network [4].
Reference: [9] <author> Lamport, L. </author> <title> The mutual exclusion problem. </title> <journal> J. ACM 33, </journal> <month> 2 (Apr. </month> <year> 1986), </year> <pages> 313-348. </pages>
Reference-contexts: There is a significant body of work on how to achieve mutual exclusion with only atomic read and write operations <ref> [2, 9, 10, 13, 14] </ref>. These solutions were rendered obsolete by the introduction of instructions that performed compound atomic operations such as exchange, test-and-set, and compare-and-swap [6].
Reference: [10] <author> Lamport, L. </author> <title> A fast mutual exclusion algorithm. </title> <journal> ACM Trans. Comput. Syst. </journal> <volume> 5, </volume> <month> 1 (Feb. </month> <year> 1987), </year> <pages> 1-11. </pages>
Reference-contexts: There is a significant body of work on how to achieve mutual exclusion with only atomic read and write operations <ref> [2, 9, 10, 13, 14] </ref>. These solutions were rendered obsolete by the introduction of instructions that performed compound atomic operations such as exchange, test-and-set, and compare-and-swap [6]. <p> In 1987, Lamport stated that "if the concurrent processes are being time-shared on a single processor, then mutual exclusion is easily achieved by inhibiting hardware interrupts at crucial times" <ref> [10] </ref>. He is implicitly assuming that mutual exclusion is only being used in the operating system, or that the overhead of an operating system trap is acceptable on every lock and unlock operation from user-level code.
Reference: [11] <author> Lampson, B. W., and Redell, D. D. </author> <title> Experience with processes and monitors in Mesa. </title> <journal> Commun. ACM 23, </journal> <volume> 2 (1980), </volume> <pages> 105-117. </pages>
Reference-contexts: However, the overhead required by the necessary locking has generally restricted their use to relatively "heavy-weight" objects. Recently, their incorporation in Java [3] has led to renewed interest in monitors, because of both their prevalence and their associated performance problems. Java uses monitor semantics derived from Mesa <ref> [11] </ref>. In Java, the methods of an object may be declared synchronized meaning that the object must be locked for the duration of the method's execution. Since Java is an explicitly multi-threaded language, designers of general-purpose class libraries must make their classes thread-safe.
Reference: [12] <author> Mellor-Crummey, J. M., and Scott, M. L. </author> <title> Algorithms for scalable synchronization on shared-memory multiprocessors. </title> <journal> ACM Trans. Comput. Syst. </journal> <volume> 9, </volume> <month> 1 (Feb. </month> <year> 1991), </year> <pages> 1-20. </pages>
Reference-contexts: This approach is similar to that used by the IBM112 "hot locks" implementation; as our measurements showed, some applications have a sufficiently large "working set" of locks that they will thrash such a cache, and will pay a substantial performance penalty. 4.1 General Locking Research The MCS locks of <ref> [12] </ref> are similar to thin locks in that they only require a single atomic operation to lock an object in the most common case. However, MCS locks also require an atomic operation to release a lock, whereas we can release a lock with a much less expensive load-store sequence. <p> He is implicitly assuming that mutual exclusion is only being used in the operating system, or that the overhead of an operating system trap is acceptable on every lock and unlock operation from user-level code. Both Anderson [1] and Mellor-Crummey and Scott <ref> [12] </ref> 10 provide thorough discussions of synchronization algorithms for multiprocessors and include comparative performance measurements. 5 Conclusions We have presented thin locks, a method for implementing monitors in the Java programming language using a partial word of storage per object.
Reference: [13] <author> Peterson, G. L. </author> <title> A new solution to Lamport's concurrent programming problem using small shared variables. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 5, </volume> <month> 1 (Jan. </month> <year> 1983), </year> <pages> 56-65. </pages>
Reference-contexts: There is a significant body of work on how to achieve mutual exclusion with only atomic read and write operations <ref> [2, 9, 10, 13, 14] </ref>. These solutions were rendered obsolete by the introduction of instructions that performed compound atomic operations such as exchange, test-and-set, and compare-and-swap [6].
Reference: [14] <author> Raynal, M. </author> <title> Algorithms for Mutual Exclusion. </title> <publisher> MIT Press Series in Scientific Computation. MIT Press, </publisher> <address> Cambridge, Massachussetts, </address> <year> 1986. </year> <title> Translated from the French by D. </title> <journal> Beeson. </journal> <volume> 11 </volume>
Reference-contexts: There is a significant body of work on how to achieve mutual exclusion with only atomic read and write operations <ref> [2, 9, 10, 13, 14] </ref>. These solutions were rendered obsolete by the introduction of instructions that performed compound atomic operations such as exchange, test-and-set, and compare-and-swap [6].
References-found: 14

