URL: http://wwwcsif.cs.ucdavis.edu/~pandey/wlcpc94.ps
Refering-URL: http://www.cs.ucdavis.edu/~pandey/cyes.html
Root-URL: http://www.cs.ucdavis.edu
Email: fraju, browneg@cs.utexas.edu  
Title: Event-based Composition of Concurrent Programs  
Author: Raju Pandey James C. Browne 
Address: Austin, TX 78712  
Affiliation: Department of Computer Sciences University of Texas at Austin  
Abstract: This paper presents a model for concurrent programming, where programs (concurrent program structures) are represented as composition expressions over component programs with suitably defined operators. In this model of programming, called Composition bY Event Specification (C-YES), a composition of programs specifies that all events (individual occurrences of named operations, called actions) of component programs can execute in parallel, except for a set of events that interact with each other. Interactions among such events can be specified by establishing execution orderings among them. This paper presents a mechanism, where such interactions are specified by constructing algebraic expressions from a set of primitive interaction expressions and interaction operators. The primitive expressions model interactions at the fundamental level of computations, namely, events. The interaction operators model nondeterministic interactions and interaction over sets of events. A mechanism for the representation of concurrent programs, called interacting blocks, is also given. The interface of an interacting block contains, in addition to the conventional parameters, references to events that may interact with events of other interacting blocks. The implementation of an interacting block contains definitions of its computations and mappings between internal events, and references to these events. Examples illustrating the properties of the C-YES model are presented in the pa per.
Abstract-found: 1
Intro-found: 1
Reference: [AHV85] <author> F. Andre, D. Herman, and J. P. Verjus. </author> <title> Synchronization of Parallel Programs. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: Any accesses or modifications to the data structures of M must be made through the interfaces. Examples of structured approaches are Monitor [Hoa74], abstract data types with Path Expressions [CH74, And79] or abstract expressions <ref> [AHV85] </ref>, 21 Mediators [GC86], rendezvous-based models [Geh84, GR86], remote-procedure call models [BN84], and concurrent object-oriented models [Ame87, YBS87, TS89, CK92, WKH92].
Reference: [Ame87] <author> Pierre America. POOL-T: </author> <title> A Parallel Object-Oriented Language. </title> <editor> In A. Yonezawa and M. Tokoro, editors, </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pages 199-220. </pages> <publisher> The MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Examples of structured approaches are Monitor [Hoa74], abstract data types with Path Expressions [CH74, And79] or abstract expressions [AHV85], 21 Mediators [GC86], rendezvous-based models [Geh84, GR86], remote-procedure call models [BN84], and concurrent object-oriented models <ref> [Ame87, YBS87, TS89, CK92, WKH92] </ref>. There are two possible sources of concurrency and interactions among programs in such models: i) External interaction and concurrency: these arise when a program C requests for a service through an interface I k .
Reference: [And79] <author> S. Andler. </author> <title> Predicate Path Expression. </title> <booktitle> In Proc. Sixth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 226-236, </pages> <year> 1979. </year>
Reference-contexts: Any accesses or modifications to the data structures of M must be made through the interfaces. Examples of structured approaches are Monitor [Hoa74], abstract data types with Path Expressions <ref> [CH74, And79] </ref> or abstract expressions [AHV85], 21 Mediators [GC86], rendezvous-based models [Geh84, GR86], remote-procedure call models [BN84], and concurrent object-oriented models [Ame87, YBS87, TS89, CK92, WKH92].
Reference: [And91] <author> Gregory R. Andrews. </author> <title> Concurrent Programming. </title> <publisher> The Benjamin/Cummings Publishing Company, </publisher> <address> Redwood City, CA, </address> <year> 1991. </year>
Reference-contexts: Such mechanisms, called interaction specification mechanisms, are very important aspects of a concurrent programming model. They influence how programs are designed, implemented, and reasoned with (during verification and debugging). Many models for concurrent programming have been proposed <ref> [And91] </ref>.
Reference: [Blo79] <author> Toby Bloom. </author> <title> Evaluating Synchronization Schemes. </title> <booktitle> In Proc 7th Symposium on Operating Systems Principles, </booktitle> <pages> pages 24-32. </pages> <publisher> ACM, </publisher> <year> 1979. </year>
Reference-contexts: The approach is constructive in that one first identifies the events that interact, and represents their interaction through a set of primitive ordering constraint expressions. An event ordering constraint expression is then constructed from the primitive expressions and the interaction operators. This facilitates modular <ref> [Blo79] </ref> construction of event ordering constraint expressions. For instance, in the two-buffer producer-consumer example, we derive separate event ordering constraint expressions for the two buffers and then use the fl^ operator to combine the two expressions.
Reference: [BN84] <author> Andrew Birrell and B. J. Nelson. </author> <title> Implementing Remote Procedure Calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <year> 1984. </year> <month> 23 </month>
Reference-contexts: Any accesses or modifications to the data structures of M must be made through the interfaces. Examples of structured approaches are Monitor [Hoa74], abstract data types with Path Expressions [CH74, And79] or abstract expressions [AHV85], 21 Mediators [GC86], rendezvous-based models [Geh84, GR86], remote-procedure call models <ref> [BN84] </ref>, and concurrent object-oriented models [Ame87, YBS87, TS89, CK92, WKH92]. There are two possible sources of concurrency and interactions among programs in such models: i) External interaction and concurrency: these arise when a program C requests for a service through an interface I k .
Reference: [CH74] <author> R. H. Campbell and A. N. Habermann. </author> <title> The Specification of Process Syn--chronization by Path Expressions. </title> <booktitle> In Lecture Notes on Computer Sciences, </booktitle> <volume> volume 16, </volume> <pages> pages 89-102. </pages> <publisher> Springer Verlag, </publisher> <year> 1974. </year>
Reference-contexts: Any accesses or modifications to the data structures of M must be made through the interfaces. Examples of structured approaches are Monitor [Hoa74], abstract data types with Path Expressions <ref> [CH74, And79] </ref> or abstract expressions [AHV85], 21 Mediators [GC86], rendezvous-based models [Geh84, GR86], remote-procedure call models [BN84], and concurrent object-oriented models [Ame87, YBS87, TS89, CK92, WKH92].
Reference: [CK89] <author> Gianna Cioni and Antoni Kreczmar. </author> <title> Modules in High Level Programming Languages. </title> <booktitle> In Advanced Programming Methodologies, </booktitle> <pages> pages 247-340. </pages> <publisher> Academic Press, Ltd., </publisher> <year> 1989. </year>
Reference-contexts: Since "events" form the basis for defining event ordering constraint expressions, we choose events to represent interaction points. We now present a representation for programs, which contains, in addition to its composition definition, definitions of interaction points. In sequential imperative programming languages, programs are represented by blocks <ref> [CK89] </ref>.
Reference: [CK92] <author> K. Mani Chandy and Carl Kesselman. </author> <title> Compositional C++: Compositional Parallel Programming. </title> <type> Technical Report Caltech-CS-TR-92-13, Cal Tech, </type> <year> 1992. </year>
Reference-contexts: Examples of structured approaches are Monitor [Hoa74], abstract data types with Path Expressions [CH74, And79] or abstract expressions [AHV85], 21 Mediators [GC86], rendezvous-based models [Geh84, GR86], remote-procedure call models [BN84], and concurrent object-oriented models <ref> [Ame87, YBS87, TS89, CK92, WKH92] </ref>. There are two possible sources of concurrency and interactions among programs in such models: i) External interaction and concurrency: these arise when a program C requests for a service through an interface I k .
Reference: [Dij65] <author> E. W. Dijkstra. </author> <title> Solution of a Problem in Concurrent Programming Control. </title> <journal> Communication of the ACM, </journal> <volume> 8(9):569, </volume> <year> 1965. </year>
Reference-contexts: The interaction between the synchronization primitives is defined at the "action" level. All interactions are constructed from suitable combinations of these primitives. Examples of unstructured synchronization primitives are semaphores <ref> [Dij65, Dij68] </ref>, message-passing primitives [Hoa78, Per87], and write-once shared variables [Sha89, FT89] of logic programming languages. Interactions among programs in these languages are realized indirectly through the executions of suitable synchronization primitives. The synchronization primitives are at a low level of abstraction, which makes it difficult to define concurrent programs.
Reference: [Dij68] <author> E. W. Dijkstra. </author> <title> The Structure of the THE Multiprogramming System. </title> <journal> Communication of the ACM, </journal> <volume> 11(5) </volume> <pages> 341-346, </pages> <year> 1968. </year>
Reference-contexts: The interaction between the synchronization primitives is defined at the "action" level. All interactions are constructed from suitable combinations of these primitives. Examples of unstructured synchronization primitives are semaphores <ref> [Dij65, Dij68] </ref>, message-passing primitives [Hoa78, Per87], and write-once shared variables [Sha89, FT89] of logic programming languages. Interactions among programs in these languages are realized indirectly through the executions of suitable synchronization primitives. The synchronization primitives are at a low level of abstraction, which makes it difficult to define concurrent programs.
Reference: [FT89] <author> Ian Foster and Stephen Taylor. Strand: </author> <title> New Concepts in Parallel Programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N. J., </address> <year> 1989. </year>
Reference-contexts: The interaction between the synchronization primitives is defined at the "action" level. All interactions are constructed from suitable combinations of these primitives. Examples of unstructured synchronization primitives are semaphores [Dij65, Dij68], message-passing primitives [Hoa78, Per87], and write-once shared variables <ref> [Sha89, FT89] </ref> of logic programming languages. Interactions among programs in these languages are realized indirectly through the executions of suitable synchronization primitives. The synchronization primitives are at a low level of abstraction, which makes it difficult to define concurrent programs.
Reference: [GC86] <author> J. E. Grass and R. H. Campbell. Mediators: </author> <title> A Synchronization Mechanism. </title> <booktitle> In Sixth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 468-477, </pages> <year> 1986. </year>
Reference-contexts: Any accesses or modifications to the data structures of M must be made through the interfaces. Examples of structured approaches are Monitor [Hoa74], abstract data types with Path Expressions [CH74, And79] or abstract expressions [AHV85], 21 Mediators <ref> [GC86] </ref>, rendezvous-based models [Geh84, GR86], remote-procedure call models [BN84], and concurrent object-oriented models [Ame87, YBS87, TS89, CK92, WKH92]. <p> There is no general mechanism for specifying arbitrary external interactions. 3. Many programming models such as Monitors [Hoa74] and ADA [Geh84] do not support internal concurrency. 4. Models such as Mediator <ref> [GC86] </ref> do allow concurrent executions within a module. However, they either support only non-interacting concurrent executions or use unstructured primitives to specify interactions.
Reference: [Geh84] <author> Narain H Gehani. </author> <title> Ada: Concurrent Programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1984. </year>
Reference-contexts: Any accesses or modifications to the data structures of M must be made through the interfaces. Examples of structured approaches are Monitor [Hoa74], abstract data types with Path Expressions [CH74, And79] or abstract expressions [AHV85], 21 Mediators [GC86], rendezvous-based models <ref> [Geh84, GR86] </ref>, remote-procedure call models [BN84], and concurrent object-oriented models [Ame87, YBS87, TS89, CK92, WKH92]. There are two possible sources of concurrency and interactions among programs in such models: i) External interaction and concurrency: these arise when a program C requests for a service through an interface I k . <p> However, support for concurrency and interaction in these models is weak. The reasons are the following: 1. The external interaction in most languages such as ADA <ref> [Geh84] </ref> and Monitors [Hoa74] is based on synchronous call-return semantics. This limits the possible concurrency between the calling and called computations. 2. Models that do allow for external concurrency among the calling and called computations employ ad-hoc mechanisms such as future [YBS87] for specifying external interaction between the two computations. <p> Models that do allow for external concurrency among the calling and called computations employ ad-hoc mechanisms such as future [YBS87] for specifying external interaction between the two computations. There is no general mechanism for specifying arbitrary external interactions. 3. Many programming models such as Monitors [Hoa74] and ADA <ref> [Geh84] </ref> do not support internal concurrency. 4. Models such as Mediator [GC86] do allow concurrent executions within a module. However, they either support only non-interacting concurrent executions or use unstructured primitives to specify interactions.
Reference: [GR86] <author> Narain H Gehani and W. D Roome. </author> <title> Concurrent C. </title> <journal> Software Practice and Experience, </journal> <volume> 16(9) </volume> <pages> 821-844, </pages> <year> 1986. </year>
Reference-contexts: Any accesses or modifications to the data structures of M must be made through the interfaces. Examples of structured approaches are Monitor [Hoa74], abstract data types with Path Expressions [CH74, And79] or abstract expressions [AHV85], 21 Mediators [GC86], rendezvous-based models <ref> [Geh84, GR86] </ref>, remote-procedure call models [BN84], and concurrent object-oriented models [Ame87, YBS87, TS89, CK92, WKH92]. There are two possible sources of concurrency and interactions among programs in such models: i) External interaction and concurrency: these arise when a program C requests for a service through an interface I k .
Reference: [Hoa74] <author> C. A. R. Hoare. </author> <title> Monitor: An Operating System Structuring Concept. </title> <journal> Communication of the ACM, </journal> <volume> 17(10) </volume> <pages> 549-557, </pages> <year> 1974. </year>
Reference-contexts: Any accesses or modifications to the data structures of M must be made through the interfaces. Examples of structured approaches are Monitor <ref> [Hoa74] </ref>, abstract data types with Path Expressions [CH74, And79] or abstract expressions [AHV85], 21 Mediators [GC86], rendezvous-based models [Geh84, GR86], remote-procedure call models [BN84], and concurrent object-oriented models [Ame87, YBS87, TS89, CK92, WKH92]. <p> However, support for concurrency and interaction in these models is weak. The reasons are the following: 1. The external interaction in most languages such as ADA [Geh84] and Monitors <ref> [Hoa74] </ref> is based on synchronous call-return semantics. This limits the possible concurrency between the calling and called computations. 2. Models that do allow for external concurrency among the calling and called computations employ ad-hoc mechanisms such as future [YBS87] for specifying external interaction between the two computations. <p> Models that do allow for external concurrency among the calling and called computations employ ad-hoc mechanisms such as future [YBS87] for specifying external interaction between the two computations. There is no general mechanism for specifying arbitrary external interactions. 3. Many programming models such as Monitors <ref> [Hoa74] </ref> and ADA [Geh84] do not support internal concurrency. 4. Models such as Mediator [GC86] do allow concurrent executions within a module. However, they either support only non-interacting concurrent executions or use unstructured primitives to specify interactions.
Reference: [Hoa78] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <journal> CACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: Concurrent programs aim to model applications where entities exist and perform independently. During an execution, an entity performs certain operations. Occasionally, it interacts with its environment at certain points. We call such execution points interaction points. Programming languages such as CSP <ref> [Hoa78] </ref> model such entities as processes and model their interactions with other entities by sending and receiving messages on channels of communications. Sends and receives, therefore, form the interaction points of processes. We observe that there are two elements of an interaction point: the first is its identification. <p> The interaction between the synchronization primitives is defined at the "action" level. All interactions are constructed from suitable combinations of these primitives. Examples of unstructured synchronization primitives are semaphores [Dij65, Dij68], message-passing primitives <ref> [Hoa78, Per87] </ref>, and write-once shared variables [Sha89, FT89] of logic programming languages. Interactions among programs in these languages are realized indirectly through the executions of suitable synchronization primitives. The synchronization primitives are at a low level of abstraction, which makes it difficult to define concurrent programs.
Reference: [KR78] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1978. </year>
Reference-contexts: The emphasis in the first example is on the composition and interaction specification mechanisms. In the second example, it is on the representation of concurrent programs by interacting blocks. The language that we use here contains features from C <ref> [KR78] </ref> and a few extensions in order to present our ideas. We explain these extensions where they are used. 11 3.4.1 Example 1: Producer/Consumer.
Reference: [Per87] <author> Brinch Hansen Per. </author> <title> Joyce A Programming Language for Distributed Systems. </title> <journal> Software Practice and Experience, </journal> <volume> 17(1) </volume> <pages> 29-50, </pages> <year> 1987. </year>
Reference-contexts: The interaction between the synchronization primitives is defined at the "action" level. All interactions are constructed from suitable combinations of these primitives. Examples of unstructured synchronization primitives are semaphores [Dij65, Dij68], message-passing primitives <ref> [Hoa78, Per87] </ref>, and write-once shared variables [Sha89, FT89] of logic programming languages. Interactions among programs in these languages are realized indirectly through the executions of suitable synchronization primitives. The synchronization primitives are at a low level of abstraction, which makes it difficult to define concurrent programs.
Reference: [Pra86] <author> Vaughan Pratt. </author> <title> Modeling Concurrency with Partial Order. </title> <journal> International Journal of Parallel Programming, </journal> <pages> pages 33-71, </pages> <year> 1986. </year>
Reference-contexts: Concurrency is modeled by the lack of any execution orderings. A concurrent computation is a set of events such that some of the events are not ordered with respect to each other, and hence, can be executed in parallel. We will use two mathematical entities, pomsets <ref> [Pra86] </ref> and event dependency graphs, to represent a concurrent computation. <p> Unlike existing programming models, where interaction and concurrency are represented indirectly through the executions of concurrent threads and synchronization constraints, our compositional model represents the two relationships directly. Our model is based on the Pomset model <ref> [Pra86] </ref> in that concurrency and interaction among operations are represented by specifying the presence or absence of execution orderings among the operations. Concurrency is specified by the lack of execution orderings, whereas interaction is represented by specifying the order in which interacting operations must be executed.
Reference: [Sha89] <author> Ehud Shapiro. </author> <title> The Family of Concurrent Logic Programming Languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 413-510, </pages> <year> 1989. </year>
Reference-contexts: The interaction between the synchronization primitives is defined at the "action" level. All interactions are constructed from suitable combinations of these primitives. Examples of unstructured synchronization primitives are semaphores [Dij65, Dij68], message-passing primitives [Hoa78, Per87], and write-once shared variables <ref> [Sha89, FT89] </ref> of logic programming languages. Interactions among programs in these languages are realized indirectly through the executions of suitable synchronization primitives. The synchronization primitives are at a low level of abstraction, which makes it difficult to define concurrent programs.
Reference: [Ste73] <author> G. W. Stewart. </author> <title> Introduction to Matrix Computations. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1973. </year>
Reference-contexts: We develop below a concurrent program for the Gaussian elimination algorithm. The purpose here is to highlight the important ideas inherent in the notion of interacting blocks, and to discuss their usefulness in the representation of concurrent programs. For a n fi n matrix A, the Gaussian elimination algorithm <ref> [Ste73] </ref> solves the linear equation Ax = b There are two distinct steps in the algorithm. The first step, called forward elimination, transforms A into an upper triangular matrix, whereas the second 13 Fig. 3.
Reference: [TS89] <author> Chris Tomlinson and Mark Scheevek. </author> <title> Concurrent Object Oriented Programming Languages. </title> <editor> In Won Kim and F. H. Lochovsky, editors, </editor> <booktitle> Object Oriented Concepts, Databases, and Applications, </booktitle> <pages> pages 79-124. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: Examples of structured approaches are Monitor [Hoa74], abstract data types with Path Expressions [CH74, And79] or abstract expressions [AHV85], 21 Mediators [GC86], rendezvous-based models [Geh84, GR86], remote-procedure call models [BN84], and concurrent object-oriented models <ref> [Ame87, YBS87, TS89, CK92, WKH92] </ref>. There are two possible sources of concurrency and interactions among programs in such models: i) External interaction and concurrency: these arise when a program C requests for a service through an interface I k .
Reference: [WKH92] <author> Barbara B. Wyatt, K. Kavi, and Steve Hufnagel. </author> <title> Parallelism in Object-Oriented Languages: a Survey. </title> <journal> IEEE Software, </journal> <volume> 9(6), </volume> <year> 1992. </year>
Reference-contexts: Examples of structured approaches are Monitor [Hoa74], abstract data types with Path Expressions [CH74, And79] or abstract expressions [AHV85], 21 Mediators [GC86], rendezvous-based models [Geh84, GR86], remote-procedure call models [BN84], and concurrent object-oriented models <ref> [Ame87, YBS87, TS89, CK92, WKH92] </ref>. There are two possible sources of concurrency and interactions among programs in such models: i) External interaction and concurrency: these arise when a program C requests for a service through an interface I k .
Reference: [YBS87] <author> A. Yonezawa, J. Briot, and E. Shibayama. </author> <title> Modeling and Programming in Object-Oriented Concurrent Language ABCL/1. </title> <editor> In A. Yonezawa and M. Tokoro, editors, </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pages 55-89. </pages> <publisher> The MIT Press, </publisher> <year> 1987. </year> <title> This article was processed using the L A T E X macro package with LLNCS style 24 </title>
Reference-contexts: Examples of structured approaches are Monitor [Hoa74], abstract data types with Path Expressions [CH74, And79] or abstract expressions [AHV85], 21 Mediators [GC86], rendezvous-based models [Geh84, GR86], remote-procedure call models [BN84], and concurrent object-oriented models <ref> [Ame87, YBS87, TS89, CK92, WKH92] </ref>. There are two possible sources of concurrency and interactions among programs in such models: i) External interaction and concurrency: these arise when a program C requests for a service through an interface I k . <p> This limits the possible concurrency between the calling and called computations. 2. Models that do allow for external concurrency among the calling and called computations employ ad-hoc mechanisms such as future <ref> [YBS87] </ref> for specifying external interaction between the two computations. There is no general mechanism for specifying arbitrary external interactions. 3. Many programming models such as Monitors [Hoa74] and ADA [Geh84] do not support internal concurrency. 4. Models such as Mediator [GC86] do allow concurrent executions within a module.
References-found: 25

