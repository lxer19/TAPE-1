URL: http://www.research.microsoft.com/~ymwang/papers/FTCS-1992.ps
Refering-URL: http://www.research.microsoft.com/~ymwang/papers/FTCS92CR.htm
Root-URL: http://www.research.microsoft.com
Title: Scheduling Message Processing for Reducing Rollback Propagation  
Author: Yi-Min Wang and W. Kent Fuchs 
Affiliation: Coordinated Science Laboratory University of Illinois at Urbana-Champaign  
Abstract: Traditional checkpointing and rollback recovery techniques for parallel systems have typically assumed the communication pattern is specified by program behavior. In this paper we exploit the property that the communication pattern can often be changed at run-time without affecting program correctness. A scheduling algorithm for message processing and its implementation for reducing rollback propagation are described. The algorithm incorporates a user-transparent prioritized scheme based upon the run-time communication and checkpointing history. Communication trace-driven simulation for several parallel programs written in the Chare Kernel language demonstrates that the probability of rollback propagation can be reduced at the cost of slight additional performance degradation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Randell, </author> <title> "System structure for software fault tolerance," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. SE-1, No. 2, </volume> <pages> pp. 220-232, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: 1 Introduction Numerous checkpointing and rollback recovery techniques have been proposed in the literature for parallel systems. Rollback propagation and the associated domino effect <ref> [1] </ref> have been the primary issue of concern in many of these techniques. Check-pointing for parallel and distributed systems can be classified into three primary categories. Coordinated checkpointing schemes synchronize computation with checkpointing by coordinating processors during a checkpointing session in order to maintain a consistent set of checkpoints [2-4].
Reference: [2] <author> K. M. Chandy and L. Lamport, </author> <title> "Distributed snapshots: Determining global states of distributed systems," </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> Vol. 3, No. 1, </volume> <pages> pp. 63-75, </pages> <month> Feb. </month> <year> 1985. </year>
Reference-contexts: Fig. 1 (b) illustrates the second situation. The message m becomes a lost message [6] according to the system state containing CP ik and CP jm . By defining the state of the channels to be the set of messages sent but not yet received, it has been proved <ref> [2, 5] </ref> that checkpoints like CP ik and CP jm can be considered consistent if the corresponding state of the channels is also recorded. Koo and Toueg [3] assumed such a state is recorded at the sender side by some end-to-end transmission protocol.
Reference: [3] <author> R. Koo and S. Toueg, </author> <title> "Checkpointing and rollback-recovery for distributed systems," </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. SE-13, No. 1, </volume> <pages> pp. 23-31, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: By defining the state of the channels to be the set of messages sent but not yet received, it has been proved [2, 5] that checkpoints like CP ik and CP jm can be considered consistent if the corresponding state of the channels is also recorded. Koo and Toueg <ref> [3] </ref> assumed such a state is recorded at the sender side by some end-to-end transmission protocol. Another way of recording the channel state is through message logging. Pessimistic logging protocol [17, 18] can ensure such a state is properly recorded at the receiving end 2 .
Reference: [4] <author> K. Li, J. F. Naughton, and J. S. Plank, </author> <title> "Check-pointing multicomputer applications," </title> <booktitle> in Proc. IEEE Symp. on Reliable Distr. Syst., </booktitle> <pages> pp. 2-11, </pages> <year> 1991. </year>
Reference: [5] <author> F. Cristian and F. Jahanian, </author> <title> "A timestamp-based checkpointing protocol for long-lived distributed computations," </title> <booktitle> in Proc. IEEE Symp. on Reliable Distr. Syst., </booktitle> <pages> pp. 12-20, </pages> <year> 1991. </year>
Reference-contexts: Department of the Navy and managed by the Office of the Chief of Naval Research under Contract N00014-91-J-1283, and in part by the National Aeronautics and Space Administration (NASA) under Grant NASA NAG 1-613, in cooperation with the Illinois Computer Laboratory for Aerospace Systems and Software (ICLASS). synchronized checkpointing schemes <ref> [5, 6] </ref> reduce the overhead for coordination by taking advantage of the loosely-synchronized checkpointing clocks and by bounding the message transmission delay. Independent checkpointing schemes replace the checkpoint synchronization by dependency tracking and possibly message logging [7-11] in order to preserve process autonomy. <p> Fig. 1 (b) illustrates the second situation. The message m becomes a lost message [6] according to the system state containing CP ik and CP jm . By defining the state of the channels to be the set of messages sent but not yet received, it has been proved <ref> [2, 5] </ref> that checkpoints like CP ik and CP jm can be considered consistent if the corresponding state of the channels is also recorded. Koo and Toueg [3] assumed such a state is recorded at the sender side by some end-to-end transmission protocol.
Reference: [6] <author> Z. Tong, R. Y. Kain, and W. T. Tsai, </author> <title> "Rollback recovery in distributed systems using loosely synchronized clocks," </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> Vol. 3, No. 2, </volume> <pages> pp. 246-251, </pages> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: Department of the Navy and managed by the Office of the Chief of Naval Research under Contract N00014-91-J-1283, and in part by the National Aeronautics and Space Administration (NASA) under Grant NASA NAG 1-613, in cooperation with the Illinois Computer Laboratory for Aerospace Systems and Software (ICLASS). synchronized checkpointing schemes <ref> [5, 6] </ref> reduce the overhead for coordination by taking advantage of the loosely-synchronized checkpointing clocks and by bounding the message transmission delay. Independent checkpointing schemes replace the checkpoint synchronization by dependency tracking and possibly message logging [7-11] in order to preserve process autonomy. <p> In Fig. 1 (a), if processors p i and p j restart from CP ik and CP jm respectively, message m is recorded as "received but not yet sent". In a general model without the assumption of deterministic execution [16], message m becomes an orphan message <ref> [6] </ref> and results in inconsistency between CP ik and CP jm . but not yet sent; (b) message sent but not yet received. Fig. 1 (b) illustrates the second situation. The message m becomes a lost message [6] according to the system state containing CP ik and CP jm . <p> without the assumption of deterministic execution [16], message m becomes an orphan message <ref> [6] </ref> and results in inconsistency between CP ik and CP jm . but not yet sent; (b) message sent but not yet received. Fig. 1 (b) illustrates the second situation. The message m becomes a lost message [6] according to the system state containing CP ik and CP jm .
Reference: [7] <author> K. Tsuruoka, A. Kaneko, and Y. Nishihara, </author> <title> "Dynamic recovery schemes for distributed processes," </title> <booktitle> in Proc. IEEE 2nd Symp. on Reliability in Distributed Software and Database, </booktitle> <pages> pp. 124-130, </pages> <year> 1981. </year>
Reference-contexts: Each surviving processor takes a virtual checkpoint upon receiving the rollback-initiating message so that the communication information during the most recent checkpoint interval is also collected. After receiving the responses, p i constructs the extended checkpoint graph <ref> [7] </ref> and executes the rollback propagation algorithm [15] to determine the local recovery line. A rollback-request message is sent to each processor which then rolls back and restarts according to the local recovery line. There are two important situations concerning the consistency between two checkpoints.
Reference: [8] <author> R. E. Strom and S. Yemini, </author> <title> "Optimistic recovery in distributed systems," </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> Vol. 3, No. 3, </volume> <pages> pp. 204-226, </pages> <month> Aug. </month> <year> 1985. </year>
Reference-contexts: Processes on the same processor share a single message queue and belong to the same fail-stop recovery unit <ref> [8, 13] </ref>. Processes can be dynamically generated and the request for the creation of a new process is sent out as a job message to some processor according to the load balancing strategy.
Reference: [9] <author> B. Bhargava and S. R. Lian, </author> <title> "Independent check-pointing and concurrent rollback for recovery An optimistic approach," </title> <booktitle> in Proc. IEEE Symp. on Reliable Distr. Syst., </booktitle> <pages> pp. 3-12, </pages> <year> 1988. </year>
Reference-contexts: Each message is tagged with the current checkpoint interval number and the processor number of the sender. Each processor takes its checkpoint independently and updates the communication information table, or input table <ref> [9] </ref>, as follows: if at least one message from the mth checkpoint interval of processor p j has been processed during the previous checkpoint interval, the pair (j; m) is added to the table. <p> A checkpoint space reclamation algorithm [15] can be periodically invoked by any processor to reduce the space overhead. When processor p i detects an error, it starts a two-phase centralized recovery procedure <ref> [9] </ref>. First, a rollback-initiating message is sent to every other processor to request the up-to-date communication information. Each surviving processor takes a virtual checkpoint upon receiving the rollback-initiating message so that the communication information during the most recent checkpoint interval is also collected.
Reference: [10] <author> D. B. Johnson and W. Zwaenepoel, </author> <title> "Recovery in distributed systems using optimistic message logging and checkpointing," </title> <journal> J. of Algorithms, </journal> <volume> Vol. 11, </volume> <pages> pp. 462-491, </pages> <year> 1990. </year>
Reference: [11] <author> Y. M. Wang and W. K. Fuchs, </author> <title> "Optimistic message logging for independent checkpointing in message-passing systems." </title> <booktitle> To appear in Proc. IEEE 11th Symp. on Reliable Distributed Systems, </booktitle> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Pessimistic logging protocol [17, 18] can ensure such a state is properly recorded at the receiving end 2 . As a result, we consider the situation in Fig. 1 (b) as consistent. 2 The recovery protocol described above can also be modified and applied to systems with optimistic logging <ref> [11] </ref>. 3 Scheduling Message Processing 3.1 Problem description In communication-induced checkpointing [19-22] a checkpoint is taken on the sender side whenever communication between two processors occurs. Because the rollback of a processor does not affect any other processor, rollback propagation is avoided. <p> Our implementation of periodic checkpointing utilizes the interrupt service routine for UNIX alarm (T ) system call as the checkpoint-ing routine. Each checkpointing action is simulated by inserting a constant delay (2 seconds). We assume a technique for detecting the messages which do not require logging <ref> [11] </ref> is employed so that the overhead for message logging is negligible. We define several rollback statistics associated with each communication pattern which encapsulate various costs for rollback recovery. They allow quantitative comparison between different scheduling algorithms. Table 1: Execution and checkpoint parameters of the Chare Kernel programs.
Reference: [12] <author> J. Fang and M. Lu, </author> <title> "A solution of cache ping-pong problem in RISC based parallel processing," </title> <booktitle> in Proc. Int. Conf. on Parallel Processing, </booktitle> <pages> pp. </pages> <address> I-238-I-245, </address> <year> 1991. </year>
Reference-contexts: This observation has been used by others to reduce cache thrashing by means of array subscript analysis in nested parallel loop constructs for dynamic thread scheduling <ref> [12] </ref>. In a message-passing system, since the order in which the messages arrive at a processor can not be assumed, changing the order of message processing will typically not affect program correctness.
Reference: [13] <author> R. D. Schlichting and F. B. Schneider, </author> <title> "Fail-stop processors: An approach to designing fault-tolerant computing systems," </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> Vol. 1, No. 3, </volume> <pages> pp. 222-238, </pages> <month> Aug. </month> <year> 1983. </year>
Reference-contexts: Processes on the same processor share a single message queue and belong to the same fail-stop recovery unit <ref> [8, 13] </ref>. Processes can be dynamically generated and the request for the creation of a new process is sent out as a job message to some processor according to the load balancing strategy.
Reference: [14] <author> W. Shu and L. V. Kale, </author> <title> "Chare kernel A runtime support system for parallel computations," </title> <journal> J. Parallel and Distributed Computing, </journal> <volume> Vol. 11, </volume> <pages> pp. 198-211, </pages> <year> 1991. </year>
Reference-contexts: Although this model is usually applied to distributed-memory multicomputers, recent work on parallel environments has shown that the message processing model can also be efficiently used on shared-memory multiprocessors <ref> [14] </ref>. During normal execution, the state of each processor is occasionally saved as a checkpoint on stable storage. Let CP ik denote the kth checkpoint of processor p i with k 0 and 0 i N 1, where N is the number of processors. <p> ] = i; if (i Last Processed CP Num [p s ]) add m to safe queue; else add m to unsafe sub-queue [p s ]; g 4 Experimental Evaluation Our message scheduling algorithm is implemented in the Chare Kernel which has been developed as a medium-grain, machine-independent parallel language <ref> [14] </ref>. A program written in the Chare Kernel language can run on both shared-memory and distributed-memory machines such as Encore Multi-max, Sequent Symmetry, and the Intel iPSC/2 hypercube. Our experiments are on an eight-processor Multimax 510. A Chare Kernel program is structurally similar to a C program.
Reference: [15] <author> Y. M. Wang, P. Y. Chung, I. J. Lin, and W. K. Fuchs, </author> <title> "Reducing space overhead for independent check-pointing," </title> <type> Tech. Rep. </type> <institution> CRHC-92-06, Coordinated Science Laboratory, University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: A checkpoint space reclamation algorithm <ref> [15] </ref> can be periodically invoked by any processor to reduce the space overhead. When processor p i detects an error, it starts a two-phase centralized recovery procedure [9]. First, a rollback-initiating message is sent to every other processor to request the up-to-date communication information. <p> Each surviving processor takes a virtual checkpoint upon receiving the rollback-initiating message so that the communication information during the most recent checkpoint interval is also collected. After receiving the responses, p i constructs the extended checkpoint graph [7] and executes the rollback propagation algorithm <ref> [15] </ref> to determine the local recovery line. A rollback-request message is sent to each processor which then rolls back and restarts according to the local recovery line. There are two important situations concerning the consistency between two checkpoints.
Reference: [16] <author> D. B. Johnson and W. Zwaenepoel, </author> <title> "Transparent optimistic rollback recovery," </title> <booktitle> Operating Systems Review, </booktitle> <pages> pp. 99-102, </pages> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: In Fig. 1 (a), if processors p i and p j restart from CP ik and CP jm respectively, message m is recorded as "received but not yet sent". In a general model without the assumption of deterministic execution <ref> [16] </ref>, message m becomes an orphan message [6] and results in inconsistency between CP ik and CP jm . but not yet sent; (b) message sent but not yet received. Fig. 1 (b) illustrates the second situation.
Reference: [17] <author> M. L. Powell and D. L. Presotto, </author> <title> "Publishing: A reliable broadcast communication mechanism," </title> <booktitle> in Proc. 9th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pp. 100-109, </pages> <year> 1983. </year>
Reference-contexts: Koo and Toueg [3] assumed such a state is recorded at the sender side by some end-to-end transmission protocol. Another way of recording the channel state is through message logging. Pessimistic logging protocol <ref> [17, 18] </ref> can ensure such a state is properly recorded at the receiving end 2 .
Reference: [18] <author> A. Borg, W. Blau, W. Graetsch, F. Herrmann, and W. Oberle, </author> <title> "Fault tolerance under UNIX," </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> Vol. 7, No. 1, </volume> <pages> pp. 1-24, </pages> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: Koo and Toueg [3] assumed such a state is recorded at the sender side by some end-to-end transmission protocol. Another way of recording the channel state is through message logging. Pessimistic logging protocol <ref> [17, 18] </ref> can ensure such a state is properly recorded at the receiving end 2 .
Reference: [19] <author> K. L. Wu, W. K. Fuchs, and J. H. Patel, </author> <title> "Error recovery in shared memory multiprocessors using private caches," </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> Vol. 1, No. 2, </volume> <pages> pp. 231-240, </pages> <month> Apr. </month> <year> 1990. </year>
Reference: [20] <author> K. L. Wu and W. K. Fuchs, </author> <title> "Recoverable distributed shared virtual memory," </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol. 39, No. 4, </volume> <pages> pp. 460-469, </pages> <month> Apr. </month> <year> 1990. </year>
Reference: [21] <author> R. E. Ahmed, R. C. Frazier, and P. N. Marinos, </author> <title> "Cache-aided rollback error recovery (carer) algorithms for shared-memory multiprocessor systems," </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 82-88, </pages> <year> 1990. </year>
Reference: [22] <author> B. Janssens and W. K. Fuchs, </author> <title> "Experimental evaluation of multiprocessor cache-based error recovery," </title> <booktitle> in Proc. Int. Conf. on Parallel Processing, </booktitle> <pages> pp. </pages> <address> I-505-I-508, </address> <year> 1991. </year>
Reference: [23] <author> K. H. Kim, J. H. You, and A. Abouelnaga, </author> <title> "A scheme for coordinated execution of independently designed recoverable distributed processes," </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 130-135, </pages> <year> 1986. </year>
Reference-contexts: Such a situation is sim ilar to the indirect potential recaller (IPR) rela tionship described by Kim, et. al <ref> [23, 24] </ref>. rollback propagation. 3.2 The scheduling algorithm Based on the above observations, we give the following definition: Definition: A message m in the queue of a processor p is safe if the immediate processing of m by p does not increase the probability of rollback propagation. two processors.
Reference: [24] <author> K. H. Kim and J. H. </author> <title> You, "A highly decentralized implementation model for the Programmer-Transparent Coordination (PTC) scheme for cooperative recovery," </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 282-289, </pages> <year> 1990. </year>
Reference-contexts: Such a situation is sim ilar to the indirect potential recaller (IPR) rela tionship described by Kim, et. al <ref> [23, 24] </ref>. rollback propagation. 3.2 The scheduling algorithm Based on the above observations, we give the following definition: Definition: A message m in the queue of a processor p is safe if the immediate processing of m by p does not increase the probability of rollback propagation. two processors.
References-found: 24

