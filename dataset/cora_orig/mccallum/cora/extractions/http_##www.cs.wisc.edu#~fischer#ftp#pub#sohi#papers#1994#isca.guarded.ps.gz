URL: http://www.cs.wisc.edu/~fischer/ftp/pub/sohi/papers/1994/isca.guarded.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/sohi/papers/1994/
Root-URL: http://www.cs.wisc.edu
Email: pnevmati@cs.wisc.edu sohi@cs.wisc.edu  
Title: Guarded Execution and Branch Prediction in Dynamic ILP Processors  
Author: Dionisios N. Pnevmatikatos Gurindar S. Sohi 
Address: Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract: We evaluate the effects of guarded (or conditional, or predicated) execution on the performance of an instruction level parallel processor employing dynamic branch prediction. First, we assess the utility of guarded execution, both qualitatively and quantitatively, using a variety of application programs. Our assessment shows that guarded execution significantly increases the opportunities, for both compiler and dynamic hardware, to extract and exploit parallelism. However, existing methods of specifying guarded execution have several drawbacks that limit its use. Second, we study the interaction of guarded execution and dynamic branch prediction and show that the use of guarded execution significantly increases the number of instructions between mispredicted branches. Third, we propose a new method of specifying guarded execution. The proposed method uses special GUARD instructions, which can be used to incorporate guarded execution into existing instruction sets. GUARD instructions realize the full power of guarded execution, without the drawbacks of existing methods of specifying guarded execution. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Allen, K. Kennedy, C. Porterfield, and J. Warren, </author> <title> ``Conversion of Control Dependence to Data Dependence,'' </title> <booktitle> Proc. 10th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 177-189, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Introducing guarded execution into scalar processors can be a very powerful concept; C-code for the inner loop of the Cmppt function of the SPEC92 benchmark Eqntott. Figure 1 (b) shows the corresponding MIPS-like assembly code. Figure 1 (c) shows the same code using guarded instructions (if-conversion <ref> [1] </ref> is used to transform the code). In Figure 1 (c), c_move is a conditional move, and c_li is a conditional load immediate. The last operand of a conditional instruction is the condition register.
Reference: [2] <author> P. P. Chang, S. A. Mahlke, W. Y. Chen, N. J. War-ter, and W. W. Hwu, </author> <title> ``IMPACT: An Architectural Framework for Multiple-Instruction-Issue Processors,'' </title> <booktitle> Proc. 18th Int'l Symposium on Computer Architecture, </booktitle> <pages> pp. 266-275, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The basic block expansion plus the basic block size gives the effective guarded block size, i.e. the number of useful instructions between branches after the if-conversion. The advantages of this metric are (i) it is highly correlated with parallelism that can be extracted <ref> [2, 6, 12] </ref> and (ii) it is dependent only on the program and the compiler and not on the underlying hardware implementation. Our second metric is the path expansion.
Reference: [3] <author> J. C. Dehnert, P. Y. T. Hsu, and J. P. Bratt, </author> <title> ``Overlapped loop support in the Cydra-5,'' </title> <booktitle> Proc. ASPLOS-III, </booktitle> <pages> pp. 26-38, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Vector processors have long benefited from guarded execution. Here, vector masks are used to express (multiple) guard conditions [14]. Using these vector masks, loops with if-statements can be vectorized. Recently proposed VLIW machines, for example the Cydra-5 <ref> [3, 13] </ref>, and the IBM VLIW machine [4], have also used guarded execution to facilitate the software pipelining of loops with conditional branch instructions. To incorporate guarded execution into a scalar instruction set, we need to be able to specify a guard condition for each (guarded) instruction.
Reference: [4] <author> K. Ebcioglu, </author> <title> ``Some Design Ideas for a VLIW Architecture for Sequential Natured Software,'' </title> <booktitle> in Parallel Processing (Proceedings of IFIP WG 10.3 Working Conference on Parallel Processing), </booktitle> <editor> ed., Cosnard et al. </editor> <publisher> North Holland, </publisher> <pages> pp. 3-21, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Vector processors have long benefited from guarded execution. Here, vector masks are used to express (multiple) guard conditions [14]. Using these vector masks, loops with if-statements can be vectorized. Recently proposed VLIW machines, for example the Cydra-5 [3, 13], and the IBM VLIW machine <ref> [4] </ref>, have also used guarded execution to facilitate the software pipelining of loops with conditional branch instructions. To incorporate guarded execution into a scalar instruction set, we need to be able to specify a guard condition for each (guarded) instruction.
Reference: [5] <author> J. A. Fisher and S. M. Freudenberger, </author> <title> ``Predicting Conditional Branch Directions from Previous Runs of a Program,'' </title> <booktitle> Proc. ASPLOS V, </booktitle> <pages> pp. 85-95, </pages> <month> Oc-tober </month> <year> 1992. </year>
Reference-contexts: Figure 4 presents the dynamic hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 3 It is interesting to compare these dynamic window sizes with the window sizes that can be established with trace scheduling, which uses static branch prediction <ref> [5] </ref>. window sizes without guarding (basic blocks), with res- tricted guarding, and with full guarding, for each of the benchmark programs using the above pattern-based pred ictor. The pattern-based predictor can establish a respect able window size (about 156 instructions, on average), even without guard instructions.
Reference: [6] <author> J. A. Fisher, </author> <title> ``Trace Scheduling: A Technique for Global Microcode Compaction,'' </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-30, </volume> <pages> pp. 478-490, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: The basic block expansion plus the basic block size gives the effective guarded block size, i.e. the number of useful instructions between branches after the if-conversion. The advantages of this metric are (i) it is highly correlated with parallelism that can be extracted <ref> [2, 6, 12] </ref> and (ii) it is dependent only on the program and the compiler and not on the underlying hardware implementation. Our second metric is the path expansion.
Reference: [7] <author> M. D. Hill and A. J. Smith, </author> <title> ``Evaluating Associativity in CPU Caches,'' </title> <journal> IEEE Transactions On Computer, </journal> <volume> vol. 38, </volume> <month> December </month> <year> 1989. </year>
Reference-contexts: Benchmarks For benchmark programs, we used the entire integer SPEC92 benchmark suite, namely the programs Compress, Eqntott, Espresso, Gcc, Sc and Xlisp. We also used three architecture simulators, Tycho, a cache simulator <ref> [7] </ref>, Supermips, a superscalar processor simulator based on the MIPS instruction set, and Thissim, a trace driven simulator similar to the one we used for this study. Finally, we used the TeX text formatter and the Yacc parser generator, as well as two object oriented database benchmarks, Sun-bench and Tektronix.
Reference: [8] <author> P. Y. T. Hsu and E. S. Davidson, </author> <title> ``Highly Concurrent Scalar Processing,'' </title> <booktitle> Proc. 13th Int'l Symposium on Computer Architecture, </booktitle> <pages> pp. 386-395, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: This technique requires a branch prediction mechanism (either static or dynamic), and the ability to undo the effects of instructions executed after an incorrectly predicted branch. The second option is the use of guarded execution <ref> [8] </ref> (also called conditional execution or predicated execution). By eliminating some branch instructions, the effective block size (the number of instructions between branches) is increased, thereby increasing the opportunities for parallelism extraction. Traditionally, guarded execution and speculative execution (especially speculative execution with dynamic branch prediction), have been treated mutually exclusively. <p> Guarded execution (or simply guarding), for scalar processors was proposed by Hsu and Davidson <ref> [8, 9] </ref> to allow better scheduling of decision trees. In the context of a decision tree, the conditional branches are essential because they steer the flow of control to the correct branch of the decision tree.
Reference: [9] <author> P. Y. T. Hsu, </author> <title> ``Highly Concurrent Scalar Processing,'' </title> <type> Ph.D. Thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> January </month> <year> 1986. </year>
Reference-contexts: Guarded execution (or simply guarding), for scalar processors was proposed by Hsu and Davidson <ref> [8, 9] </ref> to allow better scheduling of decision trees. In the context of a decision tree, the conditional branches are essential because they steer the flow of control to the correct branch of the decision tree.
Reference: [10] <author> W. W. Hwu and Y. N. Patt, </author> <title> ``Checkpoint Repair for High-Performance Out-of-Order Execution Machines,'' </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-36, </volume> <pages> pp. 1496-1514, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: In this approach, handling of traps (which cannot be deferred until the state of the processor becomes clean) requires that processor reverts to the last PC for which the state was clean, in a manner similar to the checkpoint repair of <ref> [10] </ref>. The exact number of GUARD instructions that need to be added to an instruction set and the nature of encoding of the mask field are something that need more study. In this paper, we evaluate the utility of two flavors of GUARD instructions.
Reference: [11] <institution> Advanced RISC Machines, </institution> <note> ``ARM 610 RISC Processor,'' Document No: ARM DDI 004C, </note> <month> January </month> <year> 1993. </year>
Reference: [12] <author> S. A. Mahlke, D. C. Lin, W. Y. Chen, R. E. Hank, and R. A. Bringmann, </author> <title> ``Effective Compiler Support for Predicated Execution Using the Hyperblock,'' </title> <booktitle> Proc. of the 25th Annual Workshop on Microprogramming and Microarchitecture, </booktitle> <pages> pp. 45-54, </pages> <month> De-cember </month> <year> 1992. </year>
Reference-contexts: The problem is exacerbated by the instruction scheduler which, by rearranging the instructions, can increase the register lifetime. A possible solution to this problem is to add a separate predicate register file <ref> [12, 13] </ref>, to relieve the pressure on the architectural registers. This solution, however, may result in extra instructions to transfer values between the two register files and clearly cannot be easily incorporated into existing architectures. Guarding also complicates the register renaming logic. <p> Because of these drawbacks, instruction set support for guarding is expected to be limited (unless one has the luxury of designing a new instruction set) and guarding can be profitably applied only in certain cases. Mahlke et al <ref> [12] </ref> addressed some of these issues for statically scheduled machines (such as VLIW), taking in account mainly the basic block size and the execution frequency. <p> The basic block expansion plus the basic block size gives the effective guarded block size, i.e. the number of useful instructions between branches after the if-conversion. The advantages of this metric are (i) it is highly correlated with parallelism that can be extracted <ref> [2, 6, 12] </ref> and (ii) it is dependent only on the program and the compiler and not on the underlying hardware implementation. Our second metric is the path expansion. <p> In our guarded block formation we do not perform any loop unrolling, or function inlining. Should loop unrolling and function inlining be performed, the potential of guarded execution would be enhanced. The guarded blocks constructed by our algorithm differ from the ones constructed in the Hyperblock formation of <ref> [12] </ref> in two ways. First, we require that all branches internal to the block (except the last one) be eliminated by the if-conversion; a Hyperblock is allowed to contain multiple branches and exit points. We treat what would be a Hyperblock as a sequence of basic blocks and guarded blocks. <p> smaller overhead than existing methods of specifying guarded execution. (It is possible to realize the full power of guarding with as few as three additional instructions: a GUARD_BOTH, and move instructions to save and restore the active_mask, as compared to tens of instructions to incorporate guarding using a traditional specification <ref> [12] </ref>). For our benchmark programs, two flavors of GUARD instructions allowed the full power of guarding to be realized (large effective block sizes and large dynamic windows), with an overhead of about 13.9% and 10%, respectively and 8.6% when they are combined.
Reference: [13] <author> B. R. Rau, D. W. L. Yen, W. Yen, and R. Towle, </author> <title> ``The Cydra 5 Departmental Supercomputer: Design Philosophies, Decisions, and Tradeoffs,'' </title> <journal> IEEE Computer, </journal> <volume> vol. 22, </volume> <pages> pp. 12-35, </pages> <month> January, </month> <year> 1989. </year>
Reference-contexts: Vector processors have long benefited from guarded execution. Here, vector masks are used to express (multiple) guard conditions [14]. Using these vector masks, loops with if-statements can be vectorized. Recently proposed VLIW machines, for example the Cydra-5 <ref> [3, 13] </ref>, and the IBM VLIW machine [4], have also used guarded execution to facilitate the software pipelining of loops with conditional branch instructions. To incorporate guarded execution into a scalar instruction set, we need to be able to specify a guard condition for each (guarded) instruction. <p> The problem is exacerbated by the instruction scheduler which, by rearranging the instructions, can increase the register lifetime. A possible solution to this problem is to add a separate predicate register file <ref> [12, 13] </ref>, to relieve the pressure on the architectural registers. This solution, however, may result in extra instructions to transfer values between the two register files and clearly cannot be easily incorporated into existing architectures. Guarding also complicates the register renaming logic.
Reference: [14] <author> R. M. Russel, </author> <title> ``The CRAY-1 Computer System,'' </title> <journal> CACM, </journal> <volume> vol. 21, </volume> <pages> pp. 63-72, </pages> <month> January </month> <year> 1978. </year>
Reference-contexts: Vector processors have long benefited from guarded execution. Here, vector masks are used to express (multiple) guard conditions <ref> [14] </ref>. Using these vector masks, loops with if-statements can be vectorized. Recently proposed VLIW machines, for example the Cydra-5 [3, 13], and the IBM VLIW machine [4], have also used guarded execution to facilitate the software pipelining of loops with conditional branch instructions.
Reference: [15] <author> N. J. Warter, S. A. Mahlke, W. W. Hwu, and B. R. Rau, </author> <title> ``Reverse If-Conversion,'' </title> <booktitle> Proc. of the SIG-PLAN 1993 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 290-299, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Branches that are not amenable to static prediction are eliminated using if-conversion. Finally, after the Hyperblock formation, the instructions are scheduled using conventional parallelism enhancing techniques. The problem of wasted computation resulting from if-conversion was addressed by Warter et al <ref> [15] </ref>. They propose the use of if-conversion before the instruction scheduling phase of the compiler, to eliminate the control dependencies and expose parallelism to the optimizer. After the optimization phase, a reverse if-conversion transformation is proposed, in which guarded computation is transformed back into normal instructions covered by conditional branches.
Reference: [16] <author> T. Yeh and Y. Patt, </author> <title> ``A Comparison of Dynamic Branch Predictors that use Two Levels of Branch History,'' </title> <booktitle> Proc. 20th Int'l Symposium on Computer Architecture, </booktitle> <pages> pp. 257-266, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Two, since the number of (static and dynamic) branches that need to be predicted is changed, the mechanics of the prediction mechanism could change completely. We use two different prediction mechanisms: a 2-bit counter-based mechanism, and a GAp (8) pattern-based mechanism <ref> [16] </ref>. In either case, the predictor has 4K entries (which corresponds to 8K bits of storage). The two configurations were chosen to be reasonable in hardware complexity while achieving respectable performance. We first address the issue of the branch prediction accuracy.
References-found: 16

