URL: http://www.cs.wustl.edu/~schmidt/europlop-97/papers/p3final.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/europlop-97/workshops.html
Root-URL: 
Email: email: ennio.grasso@cselt.it  
Phone: fax: +39-11-2286862  
Title: Synchronizer an Object Behavioral Pattern for Concurrent Programming The Synchronizer decouples method execution form method
Author: Ennio Grasso 
Note: Intent  
Address: Via Reiss Romoli 274 10148 Torino (Italy)  
Affiliation: CSELT  
Abstract: This paper describes the Synchronizer pattern, a specialization of the Active Object pattern described in [SCHM96a]. The intent of the Active Object pattern is the decoupling of method execution form method invocation to simplify synchronized access to shared objects by different threads. By assigning one thread to a shared object, the Active Object does not provide the maximum amount of concurrency that could be achieved. The Synchronizer specializes the Active Object by allowing many concurrent threads to access a shared object. 
Abstract-found: 1
Intro-found: 1
Reference: <author> [BUSC96], F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, M. Stal, </author> <title> A System of Patterns, </title> <publisher> John Wiley & Sons, </publisher> <year> 1996. </year>
Reference: [GAMM94] <author> E. Gamma, R. Helm, R. Johnson, J. Vlissides, </author> <title> Design Patterns, </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Introduction Concurrency is a paramount concern in a distributed system, where application servers may receive multiple requests in parallel with the problem of synchronizing those requests. A number of concurrency models have been proposed to tackle the synchronization problem, all based on the Command pattern <ref> [GAMM94] </ref> that encapsulates a request as a first class object. In a singlethreaded environment, the Reactor pattern [SCHM95b] provides a cooperative event loop model to manage and serve queues of requests. Although suited for singlethreaded systems, the Reactor is fairly complex and requires subtle programming to avoid deadlocks. <p> In particular, two concurrency patterns, called respectively thread-per-request and thread-per-object, are possible. In the remainder we will assume that thread management be performed by a separate filter object that use the Chain of Responsibility <ref> [GAMM94] </ref> pattern to decouple request demultiplexing from request dispatching. Thread-per-request In the thread-per-request model every incoming request to a server causes a new thread to be spawned to process the request. <p> () Client Interface Request Object Running Queue insert () remove () Waiting Queue insert () remove () S c h e d u l e r schedule () dispatch () assign_thread () opA () opC () Shared Object The participants in the Synchronizer pattern are: Client Interface is a Proxy <ref> [GAMM94] </ref> that presents an operation interface to client applications. The invocation of an operation in the Client Interface triggers the construction of a Request Object. Request Object is constructed for any invocation that needs synchronized access to a Shared Object managed by the Scheduler. <p> Since all object instances that support the same IDL interface bear the same conflict specification, only one ConflictTable instance is created using the Singleton pattern <ref> [GAMM94] </ref>.
Reference: [GRAS96a] <author> E. </author> <title> Grasso; "A Programmable Concurrency Control Service for Real-Time Object Request Broker"; in Proc. </title> <booktitle> 8 th Euromicro Workshop on Real Time Systems, </booktitle> <address> L'Aquila, </address> <year> 1996. </year>
Reference-contexts: Transactional Scheduler refines the assign_thread operation. Request Objects are now removed from the Running Queue only if they were not carried out on behalf of transactions. Sample usage in the PCCS We applied the Synchronizer and Transactional Synchronizer patterns in the implementation of the Programmable Concurrency Control Service (PCCS) <ref> [GRAS96a] </ref>, [GRAS96b] and the eXtended Transaction Service (XTS) [GRAS96c] for Orbix-MT [IONA95]. The PCCS defines a SynchronizedObject IDL interface with no operations but simply used as a marker to indicate that an object wants to be synchronized through the Synchronizer pattern.
Reference: [GRAS96b] <author> E. </author> <title> Grasso; "A Programmable Concurrency Control Service CORBA"; in Proc. </title> <booktitle> 3rd International Workshop on Services in Distributed Networked Environments, </booktitle> <address> Macau, </address> <year> 1996. </year>
Reference-contexts: Request Objects are now removed from the Running Queue only if they were not carried out on behalf of transactions. Sample usage in the PCCS We applied the Synchronizer and Transactional Synchronizer patterns in the implementation of the Programmable Concurrency Control Service (PCCS) [GRAS96a], <ref> [GRAS96b] </ref> and the eXtended Transaction Service (XTS) [GRAS96c] for Orbix-MT [IONA95]. The PCCS defines a SynchronizedObject IDL interface with no operations but simply used as a marker to indicate that an object wants to be synchronized through the Synchronizer pattern.
Reference: [GRAS96c] <author> E. </author> <title> Grasso; " An Extended Transaction Service for Telecom Object Request Brokers "; in Proc. </title> <booktitle> 2nd International Workshop on Distributed Object Oriented Computing, </booktitle> <address> Frankfurt, Germany, </address> <year> 1996. </year>
Reference-contexts: Sample usage in the PCCS We applied the Synchronizer and Transactional Synchronizer patterns in the implementation of the Programmable Concurrency Control Service (PCCS) [GRAS96a], [GRAS96b] and the eXtended Transaction Service (XTS) <ref> [GRAS96c] </ref> for Orbix-MT [IONA95]. The PCCS defines a SynchronizedObject IDL interface with no operations but simply used as a marker to indicate that an object wants to be synchronized through the Synchronizer pattern.
Reference: [GRAY93] <author> J. Gray, A. </author> <title> Reuter; "Transaction Processing: </title> <publisher> Concepts and Techniques"; Morgan Kaufmann Publishers, </publisher> <year> 1993. </year>
Reference-contexts: A number of concurrency control techniques may be used, each enforcing a particular synchronization policy: mutexes, semaphores, condition variables, guards, locks, to name a few. For example, the synchronization policy of the locking model is specified in terms of the conflict relationship between lock modes <ref> [GRAY93] </ref>. If a thread requests a lock mode that conflicts with any of the lock modes already granted to other concurrent threads, the first thread is suspended until its lock request can be fulfilled.
Reference: [IONA95] <institution> IONA Technologies Inc., </institution> <note> Orbix-MT 2 programming guide, </note> <year> 1995. </year> <title> [OMG91] "The Common Object Request Broker Architecture and Specification", OMG doc. </title> <editor> n. 91-12-1, </editor> <month> December </month> <year> 1991. </year> <title> [OMG95] " CORBAservices: Common Object Se rvices Specification", OMG doc. </title> <editor> n. 95-3-31, </editor> <month> March </month> <year> 1995. </year>
Reference-contexts: Sample usage in the PCCS We applied the Synchronizer and Transactional Synchronizer patterns in the implementation of the Programmable Concurrency Control Service (PCCS) [GRAS96a], [GRAS96b] and the eXtended Transaction Service (XTS) [GRAS96c] for Orbix-MT <ref> [IONA95] </ref>. The PCCS defines a SynchronizedObject IDL interface with no operations but simply used as a marker to indicate that an object wants to be synchronized through the Synchronizer pattern.
Reference: [SCHM95a] <author> R. G. Lavender, D. C. Schmidt, </author> <title> Active Object, </title> <booktitle> conf. Pattern Lnaguages of Programming, </booktitle> <address> Monticello, Illinois, </address> <month> September </month> <year> 1995. </year>
Reference: [SCHM95b] <author> D. C. Schmidt, </author> <title> Reactor, </title> <booktitle> in Pattern Languages of Programming Design, </booktitle> <publisher> Addison Wesley, </publisher> <year> 1995. </year>
Reference-contexts: A number of concurrency models have been proposed to tackle the synchronization problem, all based on the Command pattern [GAMM94] that encapsulates a request as a first class object. In a singlethreaded environment, the Reactor pattern <ref> [SCHM95b] </ref> provides a cooperative event loop model to manage and serve queues of requests. Although suited for singlethreaded systems, the Reactor is fairly complex and requires subtle programming to avoid deadlocks.
Reference: [SCHM95c] <author> D. C. Schmidt, </author> <title> Evaluating Concurrency Models for CORBA Servers, online tutorial: </title> <address> http://www.cs.wustl.edu/~schmidt/tutorials-corba.html </address>
References-found: 10

