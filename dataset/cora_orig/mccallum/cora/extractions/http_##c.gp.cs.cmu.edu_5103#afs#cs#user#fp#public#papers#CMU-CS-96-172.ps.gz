URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/papers/CMU-CS-96-172.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/papers/
Root-URL: http://www.cs.cmu.edu
Title: Primitive Recursion for Higher Order Abstract Syntax  
Author: Joelle Despeyroux, Frank Pfenning, Carsten Schurmann 
Note: This work was sponsored NSF Grant CCR-9303383. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of NSF or the U.S. Government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: August 30, 1996  
Pubnum: CMU-CS-96-172  
Abstract: Higher-order abstract syntax is a central representation technique in logical frameworks which maps variables of the object language into variables in the meta-language. It leads to concise encodings, but is incompatible with functions defined by primitive recursion or proofs by induction. In this paper we propose an extension of the simply-typed lambda-calculus with iteration and case constructs which preserves the adequacy of higher-order abstract syntax encodings. The well-known paradoxes are avoided through the use of a modal operator which obeys the laws of S4. In the resulting calculus many functions over higher-order representations can be expressed elegantly. Our central technical result, namely that our calculus is conservative over the simply-typed lambda-calculus, is proved by a rather complex argument using logical relations. We view our system as an important first step towards allowing the methodology of LF to be employed effectively in systems based on induction principles such as ALF, Coq, or Nuprl, leading to a synthesis of currently incompatible paradigms. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: [Chu40] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: The basic idea is to represent variables of the object language by variables in the meta-language. Consequently, object language constructs which bind variables must be represented by meta-language constructs which bind the corresponding variables. This deceptively simple idea, which goes back to Church <ref> [Chu40] </ref> and Martin-Lof's system of arities [NPS90], has far-reaching consequences for the methodology of logical frameworks.
Reference: [CNSvS94] <author> Thierry Coquand, Bengt Nordstrom, Jan M. Smith, and Bjorn von Sydow. </author> <title> Type theory and programming. </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 52 </volume> <pages> 203-228, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: For larger applications, writing programs by iteration becomes tedious and error-prone and a pattern-matching calculus such as employed in ALF <ref> [CNSvS94] </ref> or proposed by Jouannaud and Okada [JO91] seems more practical. Our informal notation in the examples provides some hints what concrete syntax one might envision for an implementation along these lines.
Reference: [DFH95] <author> Joelle Despeyroux, Amy Felty, and Andre Hirschowitz. </author> <title> Higher-order abstract syntax in Coq. </title> <editor> In M. Dezani-Ciancaglini and G. Plotkin, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <pages> pages 124-138, </pages> <address> Edinburgh, Scotland, April 1995. </address> <publisher> Springer-Verlag LNCS 902. </publisher>
Reference-contexts: On the other hand, higher-order representations are no longer inductive in the usual sense, which means that standard techniques for reasoning by induction do not apply. Various attempts have been made to preserve the advantages of higher-order abstract syntax in a setting with strong induction principles <ref> [DH94, DFH95] </ref>, but none of these is entirely satisfactory from a practical or theoretical point of view. In this paper we take a first step towards reconciling higher-order abstract syntax with induction by proposing a system of primitive recursive functionals that permits iteration over subjects of functional type. <p> We also plan 1 personal communication 61 62 10 CONCLUSION AND FUTURE WORK to reexamine applications in the realm of functional programming [Mil90, FS96] and related work on reasoning about higher-order abstract syntax with explicit induction <ref> [DH94, DFH95] </ref> or definitional reflection [MM96]. Acknowledgments. The work reported here took a long time to come to fruition, largely due to the complex nature of the technical development.
Reference: [DH94] <author> Joelle Despeyroux and Andre Hirschowitz. </author> <title> Higher-order abstract syntax with induction in Coq. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Proceedings of the 5th International Conference on Logic Programming and Automated Reasoning, </booktitle> <pages> pages 159-173, </pages> <address> Kiev, Ukraine, July 1994. </address> <publisher> Springer-Verlag LNAI 822. </publisher>
Reference-contexts: On the other hand, higher-order representations are no longer inductive in the usual sense, which means that standard techniques for reasoning by induction do not apply. Various attempts have been made to preserve the advantages of higher-order abstract syntax in a setting with strong induction principles <ref> [DH94, DFH95] </ref>, but none of these is entirely satisfactory from a practical or theoretical point of view. In this paper we take a first step towards reconciling higher-order abstract syntax with induction by proposing a system of primitive recursive functionals that permits iteration over subjects of functional type. <p> We also plan 1 personal communication 61 62 10 CONCLUSION AND FUTURE WORK to reexamine applications in the realm of functional programming [Mil90, FS96] and related work on reasoning about higher-order abstract syntax with explicit induction <ref> [DH94, DFH95] </ref> or definitional reflection [MM96]. Acknowledgments. The work reported here took a long time to come to fruition, largely due to the complex nature of the technical development.
Reference: [DP96] <author> Rowan Davies and Frank Pfenning. </author> <title> A modal analysis of staged computation. </title> <editor> In Jr. Guy Steele, editor, </editor> <booktitle> Proceedings of the 23rd Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 258-270, </pages> <address> St. Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: The system is non-trivial since we may also abstract over objects of type 2A, but fortunately it is well understood and corresponds (via an extension of the Curry-Howard isomorphism) to the intuitionistic variant of S 4 <ref> [DP96] </ref>. In Section 4 we introduce schemas for defining functions by iteration and case distinction which require the subject to be of type 2B. We can recover the ordinary scheme of primitive recursion for type nat if we also add pairs to the language. <p> Just as the modal type 2A, pairs are lazy and values of these types are not observable|ultimately we are only interested in canonical forms of pure type. The formulation of the modal -calculus below is copied from <ref> [DP96] </ref> and goes back to [PW95]. The language of types includes the pure types from the simply-typed -calculus in Section 2.
Reference: [FS96] <author> Leonidas Fegaras and Tim Sheard. </author> <title> Revisiting catamorphisms over datatypes with embedded functions (or, programs from outer space). </title> <booktitle> In Proceedings of 23rd Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 284-294, </pages> <address> St. Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: In our system we view iteration as replacing constructors of a canonical term by functions of appropriate type, which is also the idea behind catamorphisms <ref> [FS96] </ref>. In the case of natural numbers, we replace z : nat by a term M z : A and s : nat ! nat by a function M s : A ! A. Thus iteration over natural numbers replaces type nat by A. <p> The system of Meijer and Hutton [MH95] and its refinement by Fegaras and Sheard <ref> [FS96] </ref> are also related in that they extend primitive recursion to encompass functional objects. However, they treat functional objects extensionally, while our primitives are designed so we can analyze the internal structure of -abstractions directly. <p> However, they treat functional objects extensionally, while our primitives are designed so we can analyze the internal structure of -abstractions directly. Fegaras and Sheard also note the problem with adequacy and design more stringent type-checking rules in Section 3.4 of <ref> [FS96] </ref> to circumvent this problem. In contrast to our system, their proposal does not appear to have a logical interpretation. <p> This may be the critical insight required for a dependently typed version of our calculus. We also plan 1 personal communication 61 62 10 CONCLUSION AND FUTURE WORK to reexamine applications in the realm of functional programming <ref> [Mil90, FS96] </ref> and related work on reasoning about higher-order abstract syntax with explicit induction [DH94, DFH95] or definitional reflection [MM96]. Acknowledgments. The work reported here took a long time to come to fruition, largely due to the complex nature of the technical development.
Reference: [God90] <author> Kurt Godel. </author> <title> On an extension of finitary mathematics which has not yet been used. </title> <editor> In Solomon Feferman et al., editors, Kurt Godel, </editor> <booktitle> Collected Works, </booktitle> <volume> Volume II, </volume> <pages> pages 271-280. </pages> <publisher> Oxford University Press, </publisher> <year> 1990. </year>
Reference-contexts: The resulting system allows, for example, iteration over the structure of expressions from the untyped -calculus when represented using higher-order abstract syntax. It is general enough to permit iteration over objects of any simple type, constructed over any simply typed signature and thereby encompasses Godel's system T <ref> [God90] </ref>. Moreover, it is conservative over the simply-typed -calculus which means that the compositional adequacy of encodings in higher-order abstract syntax is preserved.
Reference: [HHP93] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Moreover, it is conservative over the simply-typed -calculus which means that the compositional adequacy of encodings in higher-order abstract syntax is preserved. We view our calculus as an important first step towards a system which allows the methodology of logical frameworks such as LF <ref> [HHP93] </ref> to be incorporated into systems such as Coq [PM93] or ALF [Mag95]. <p> For example, we can see that peq will never contain a fi-redex. Moreover, the argument to lam which has type exp ! exp will always be a -abstraction. Thus the image of the translation in this representation methodology is always a fi-normal and -long form. Following <ref> [HHP93] </ref>, we call these forms canonical as defined by the following two judgments.
Reference: [JO91] <author> Jean-Pierre Jouannaud and Mitsuhiro Okada. </author> <title> A computation model for executable higher-order algebraic specification languages. </title> <editor> In Gilles Kahn, editor, </editor> <booktitle> Proceedings of the 6th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 350-361, </pages> <address> Ams-terdam, The Netherlands, July 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: For larger applications, writing programs by iteration becomes tedious and error-prone and a pattern-matching calculus such as employed in ALF [CNSvS94] or proposed by Jouannaud and Okada <ref> [JO91] </ref> seems more practical. Our informal notation in the examples provides some hints what concrete syntax one might envision for an implementation along these lines.
Reference: [Mag95] <author> Lena Magnusson. </author> <title> The Implementation of ALF|A Proof Editor Based on Martin-Lof 's Monomorphic Type Theory with Explicit Substitution. </title> <type> PhD thesis, </type> <institution> Chalmers University of Technology and Goteborg University, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: We view our calculus as an important first step towards a system which allows the methodology of logical frameworks such as LF [HHP93] to be incorporated into systems such as Coq [PM93] or ALF <ref> [Mag95] </ref>. The remainder of this paper is organized as follows: Section 2 reviews the idea of higher order abstract syntax and introduces the simply typed -calculus ( ! ) which we extend to a modal -calculus in Section 3.
Reference: [MH95] <author> Erik Meijer and Graham Hutton. </author> <title> Bananas in space: Extending fold and unfold to exponential types. </title> <booktitle> In Proceedings of the 7th Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> La Jolla, California, </address> <month> June </month> <year> 1995. </year> <note> 120 REFERENCES 121 </note>
Reference-contexts: Due to the presence of unrestricted recursion and the absence of a modal operator, Miller's system is computationally adequate, but has a much weaker meta-theory which would not be sufficient for direct use in a logical framework. The system of Meijer and Hutton <ref> [MH95] </ref> and its refinement by Fegaras and Sheard [FS96] are also related in that they extend primitive recursion to encompass functional objects. However, they treat functional objects extensionally, while our primitives are designed so we can analyze the internal structure of -abstractions directly.
Reference: [Mil90] <author> Dale Miller. </author> <title> An extension to ML to handle bound variables in data structures: Preliminary report. </title> <booktitle> In Proceedings of the Logical Frameworks BRA Workshop, </booktitle> <address> Nice, France, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: To our knowledge, this is the first system in which it is possible to safely program functionally with higher-order abstract syntax representations. It thus complements and refines the logic programming approach to programming with such representations [Mil92, Pfe91]. Our work was inspired by Miller's system <ref> [Mil90] </ref>, which was presented in the context of ML. Due to the presence of unrestricted recursion and the absence of a modal operator, Miller's system is computationally adequate, but has a much weaker meta-theory which would not be sufficient for direct use in a logical framework. <p> This may be the critical insight required for a dependently typed version of our calculus. We also plan 1 personal communication 61 62 10 CONCLUSION AND FUTURE WORK to reexamine applications in the realm of functional programming <ref> [Mil90, FS96] </ref> and related work on reasoning about higher-order abstract syntax with explicit induction [DH94, DFH95] or definitional reflection [MM96]. Acknowledgments. The work reported here took a long time to come to fruition, largely due to the complex nature of the technical development.
Reference: [Mil91] <author> Dale Miller. </author> <title> Unification of simply typed lambda-terms as logic programming. </title> <editor> In Koichi Furukawa, editor, </editor> <booktitle> Eighth International Logic Programming Conference, </booktitle> <pages> pages 255-269, </pages> <address> Paris, France, June 1991. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Example 4.10 (Substitution in normal forms) Substitution is already directly definable by application, but one may also ask if there is a structural definition in the style of <ref> [Mil91] </ref>. Normal forms of the untyped -calculus are represented by the type nf with an auxiliary definition for atomic forms of type at.
Reference: [Mil92] <author> Dale Miller. </author> <title> Abstract syntax and logic programming. </title> <booktitle> In Proceedings of the First and Second Russian Conferences on Logic Programming, </booktitle> <pages> pages 322-337, </pages> <address> Irkutsk and St. Petersburg, Russia, 1992. </address> <publisher> Springer-Verlag LNAI 592. </publisher>
Reference-contexts: To our knowledge, this is the first system in which it is possible to safely program functionally with higher-order abstract syntax representations. It thus complements and refines the logic programming approach to programming with such representations <ref> [Mil92, Pfe91] </ref>. Our work was inspired by Miller's system [Mil90], which was presented in the context of ML.
Reference: [MM96] <author> Raymond McDowell and Dale Miller. </author> <title> A logic for reasoning about logic specifications. </title> <type> Draft manuscript, </type> <month> July </month> <year> 1996. </year>
Reference-contexts: We also plan 1 personal communication 61 62 10 CONCLUSION AND FUTURE WORK to reexamine applications in the realm of functional programming [Mil90, FS96] and related work on reasoning about higher-order abstract syntax with explicit induction [DH94, DFH95] or definitional reflection <ref> [MM96] </ref>. Acknowledgments. The work reported here took a long time to come to fruition, largely due to the complex nature of the technical development. During this time we have discussed various aspects of higher-order abstract syntax, iteration, and induction with too many people to acknowledge them individually.
Reference: [NPS90] <author> Bengt Nordstrom, Kent Petersson, and Jan M. Smith. </author> <title> Programming in Martin-Lof 's Type Theory: An Introduction, </title> <booktitle> volume 7 of International Series of Monographs on Computer Science. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1990. </year>
Reference-contexts: The basic idea is to represent variables of the object language by variables in the meta-language. Consequently, object language constructs which bind variables must be represented by meta-language constructs which bind the corresponding variables. This deceptively simple idea, which goes back to Church [Chu40] and Martin-Lof's system of arities <ref> [NPS90] </ref>, has far-reaching consequences for the methodology of logical frameworks.
Reference: [Pfe91] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: To our knowledge, this is the first system in which it is possible to safely program functionally with higher-order abstract syntax representations. It thus complements and refines the logic programming approach to programming with such representations <ref> [Mil92, Pfe91] </ref>. Our work was inspired by Miller's system [Mil90], which was presented in the context of ML.
Reference: [PM93] <author> Christine Paulin-Mohring. </author> <title> Inductive definitions in the system Coq: Rules and properties. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <pages> pages 328-345, </pages> <address> Utrecht, The Netherlands, March 1993. </address> <publisher> Springer-Verlag LNCS 664. </publisher>
Reference-contexts: We view our calculus as an important first step towards a system which allows the methodology of logical frameworks such as LF [HHP93] to be incorporated into systems such as Coq <ref> [PM93] </ref> or ALF [Mag95]. The remainder of this paper is organized as follows: Section 2 reviews the idea of higher order abstract syntax and introduces the simply typed -calculus ( ! ) which we extend to a modal -calculus in Section 3. <p> In fact, the subordination relation is defined with the purpose to extend the notion of inductive types. Note that static type subordination is built into calculi where inductive types are defined explicitly (such as the Calculus of Inductive Constructions <ref> [PM93] </ref>); here it must be recovered from the signature since we impose no ordering constraints except that a type must be declared before it is used.
Reference: [PW95] <author> Frank Pfenning and Hao-Chi Wong. </author> <title> On a modal -calculus for S4. </title> <editor> In S. Brookes and M. Main, editors, </editor> <booktitle> Proceedings of the Eleventh Conference on Mathematical Foundations of Programming Sematics, </booktitle> <address> New Orleans, Louisiana, </address> <month> March </month> <year> 1995. </year> <note> To appear in Electronic Notes in Theoretical Computer Science, Volume 1, Elsevier. 121 </note>
Reference-contexts: Just as the modal type 2A, pairs are lazy and values of these types are not observable|ultimately we are only interested in canonical forms of pure type. The formulation of the modal -calculus below is copied from [DP96] and goes back to <ref> [PW95] </ref>. The language of types includes the pure types from the simply-typed -calculus in Section 2.
References-found: 20

