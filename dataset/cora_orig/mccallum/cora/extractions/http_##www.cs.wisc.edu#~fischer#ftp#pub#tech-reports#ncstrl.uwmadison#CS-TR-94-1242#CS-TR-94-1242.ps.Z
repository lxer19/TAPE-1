URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-94-1242/CS-TR-94-1242.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-94-1242/
Root-URL: http://www.cs.wisc.edu
Abstract-found: 0
Intro-found: 1
Reference: [Atkin82] <author> M. Atkinson, K. Chisholm, and P. Cockshott, </author> <title> "PS-Algol: an Algol with a Persistent Heap," </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 17, </volume> <pages> pp. 24-31, </pages> <month> July </month> <year> 1982. </year>
Reference: [Atkin83] <author> M. Atkinson, K. Chisholm, and P. Cockshott, </author> <title> "Algorithms for a Persistent Heap," </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 13, No. 3, </volume> <pages> pp. 259-272, </pages> <month> March </month> <year> 1983. </year>
Reference-contexts: In the discussion that follows, we first cover related work on software-based pointer swizzling techniques; following this, work that has been done on hardware-based swizzling schemes is discussed. Some early work on software implementations of pointer swizzling was done as part of an implementation of PS-Algol <ref> [Atkin83, Cock84] </ref>.
Reference: [Ball92] <author> T. Ball, J. Larus, </author> <title> "Optimally Profiling and Tracing Programs", </title> <booktitle> POPL 1992, </booktitle> <pages> pp. 59-70, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: As one would expect, the performance of QS is generally better than E. It is somewhat surprising, however, that E is just 23% slower than QS during T1. To determine the reasons for this relatively small difference, we used qpt <ref> [Ball92] </ref> to profile the benchmark application. Table 5.7 presents the profiling results for T1. The T1 hot traversal time has been broken down in Table 5.7 based on the percentage of CPU time spent in several groups of functions.
Reference: [Butter91] <author> P. Butterworth, A. Otis, J. Stein, </author> <title> "The Gemstone Object Database Management System", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 34, No. 10, </volume> <month> October </month> <year> 1991 </year>
Reference-contexts: Since the 1980's object-oriented database technology has advanced significantly, and during the last five years, Object-Oriented Database Management Systems (OODBMSs), have gained a foothold in the commercial marketplace. For example, current commercial OODBMSs include ObjectStore [Lamb91], Objectivity [Objy92], Ontos [Ontos92], O 2 [Deux91], GemStone <ref> [Butter91] </ref>, and Versant [Versan92]. Despite their greater expressive power, however, whether OODBMSs continue to gain in popularity will ultimately depend upon their ability to meet the stringent performance demands of their potential market.
Reference: [Carey89] <author> M. Carey et al., </author> <title> "Storage Management for Objects in EXODUS," in Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. Lochovsky, eds., </editor> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The implementation of E uses an interpreter, the E Persistent Virtual Machine (EPVM), to coordinate access to persistent data [Schuh90] that is stored using the EXODUS Storage Manager <ref> [Carey89] </ref>. Under the approach taken by EPVM 1.0 (the original implementation of EPVM), memory resident persistent objects are accessed in-place in the buffer pool of the EXODUS Storage Manager (ESM). In addition, EPVM 1.0 provides support for a limited form of pointer swizzling. <p> Next, the interface function returns a data structure to the application, known as a user descriptor <ref> [Carey89] </ref>, that contains a pointer to the object. <p> CHAPTER 4 THE DESIGN OF QUICKSTORE This chapter describes the design of QuickStore, a memory-mapped storage system for persistent C++ that was built using the EXODUS Storage Manager (ESM) <ref> [Carey89] </ref>. QuickStore uses standard virtual memory hardware to trigger the transfer of persistent data from secondary storage into main memory [Wilso90].
Reference: [Carey93] <author> M. Carey, D. DeWitt, J. Naughton, </author> <title> "The OO7 Benchmark", </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Section 5.5 offers further details on the database systems (QuickStore and E) studied. Section 5.6 presents the performance results. Finally, Section 5.7 presents the conclusions reached in this chapter. 5.1. The OO7 Benchmark Database This section describes the structure of the OO7 benchmark database. The OO7 database <ref> [Carey93] </ref> is intended to be suggestive of many different CAD/CAM/CASE applications. There are two sizes of the OO7 database: small and medium. <p> This field is indexed, so T3 highlights the cost of updates of indexed fields. We also used three traversals that are not based on T1. T7 picks a random atomic part and traverses up to the root of the design hierarchy. T8 scans the manual object hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 <ref> [Carey93] </ref> specifies that the (x, y) attributes should be swapped. We increment them instead so that multiple updates of the same object change the object's value. <p> We included two different database sizes in the study, termed small and big. Table 6.1 shows the parameters used to construct the two databases. We note that the parameters used here do not correspond exactly to the "standard" OO7 database specification of <ref> [Carey93] </ref>. As indicated in Table 6.1, a module in the small database here is the same size as a module in the small database of [Carey93]; however, modules in the big database differ from the small database in that they con tain 2,000 composite parts instead of 500, and there are <p> We note that the parameters used here do not correspond exactly to the "standard" OO7 database specification of <ref> [Carey93] </ref>. As indicated in Table 6.1, a module in the small database here is the same size as a module in the small database of [Carey93]; however, modules in the big database differ from the small database in that they con tain 2,000 composite parts instead of 500, and there are 8 levels in the assembly hierarchy in the big database versus 7 in the small database.
Reference: [Carey94] <author> M. Carey, D. DeWitt, M. Franklin, N. Hall, M. McAuliffe, J. Naughton, D. Schuh, M. Solomon, C. Tan, O. Tsatalos, S. White, M. Zwilling, </author> <title> "Shoring Up Persistent Applications", </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: It simplifies the implementation of a storage manager by providing cache consistency between clients and the server [Frank93]. REDO is currently being used in the initial version of SHORE <ref> [Carey94] </ref>, a persistent object system being developed at Wisconsin. Since REDO only involves changes at the storage manager level, it can be used in combination with any of the recovery schemes mentioned previously that make use of the recovery services provided by EXODUS.
Reference: [Catte91] <author> R. Cattell, </author> <title> "An Engineering Database Benchmark," in The Benchmark Handbook For Database and Transaction Processing Systems, </title> <editor> Jim Gray ed., Morgan-Kaufman, </editor> <year> 1991. </year>
Reference-contexts: To evaluate the effectiveness of the design of EPVM 2.0, this chapter also presents the results of a number of performance experiments that were conducted using the OO1 benchmark <ref> [Catte91] </ref>. The experiments compare EPVM 2.0 with three alternative pointer swizzling architectures. The first architecture is represented by EPVM 1.0 which supports a more limited form of pointer swizzling than EPVM 2.0. The second architecture does not support pointer swizzling, and corresponds to using a conventional non-persistent programming language, i.e. <p> Note that all of the pointers between objects that have been visited by the program are swizzled, and that further traversals of the collection will dereference only swizzled pointers. 3.3. Performance Experiments The performance experiments were done using the traversal portion of the OO1 Benchmark <ref> [Catte91] </ref>. <p> Both approaches have important implications for systems that do redo/undo logging. The experiments also compare the different software versions using a small database that fits into main memory and a large database that represents a working set size that is bigger than main memory <ref> [Catte91] </ref>. 3.3.1. Software Versions The first architecture, which is shown in Figure 3.5, results when a conventional non-persistent programming language, i.e. C++, is used to call ESM directly. This approach accesses objects in the client buffer pool of ESM using a procedural interface. <p> We used 5 megabyte client and server buffer pools for all of the experiments. This architecture will be referred to as OS. 3.3.2. Benchmark Database For ESM, the small benchmark database <ref> [Catte91] </ref> consumed a total of 489 8 K-byte disk pages (3.8 Mb) and consisted of a collection of 20,000 part objects (each object is an average of 176 bytes in size). <p> The large database occupied 3,057 disk pages (23.8 Mb) and the index size was 1.9 megabytes when using ESM. For ObjectStore, the large database, including the index, required 2,559 pages (19.9 Mb). 125,000 objects were used for the large database instead of 200,000 as specified in <ref> [Catte91] </ref> due to limitations in the amount of available swap space. Using 125,000 objects eliminated this problem while still providing a database that would not fit into the real memory of the workstations that were used. 3.3.3. <p> Adding the costs for fetching pointers and in-line dereferences yields the total cost for dereferenc-ing pointers, which is 41.38% for EPVM 2.0. Finally, the dummy function cost of 14.36%, shown in Table 3.7, represents the overhead for preparing an argument to be passed to the "dummy" function <ref> [Catte91] </ref> that is called once during each object access. 3.5.2. Comparison of EPVM and ObjectStore Table 3.7 highlights the contribution of pointer dereferencing costs for EPVM 2.0, which are an important component (41.38%) of the total traversal cost.
Reference: [Cock84] <author> P. Cockshott et al., </author> <title> "Persistent Object Management System," </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 14, </volume> <pages> pp. 49-71, </pages> <year> 1984 </year>
Reference-contexts: In the discussion that follows, we first cover related work on software-based pointer swizzling techniques; following this, work that has been done on hardware-based swizzling schemes is discussed. Some early work on software implementations of pointer swizzling was done as part of an implementation of PS-Algol <ref> [Atkin83, Cock84] </ref>.
Reference: [Codd70] <author> E. F. Codd, </author> <title> "A Relational Model for Large Shared Data Banks", </title> <journal> Communications of the ACM, </journal> <volume> Volume 13, Number 6, </volume> <month> (June </month> <year> 1970), </year> <pages> pages 377-387. </pages>
Reference-contexts: The relational approach is inadequate for these application domains primarily because it offers a restricted type system (flat relations, tuples, and attributes) <ref> [Codd70] </ref> that lacks the modeling power and expressiveness required to represent and manipulate the complex structures that they generally require.
Reference: [DeWitt90] <author> D. DeWitt, P. Futtersack, D. Maier, F. Velez, </author> <title> "A Study of Three Alternative Workstation-Server Architectures for Object-Oriented Database Systems", </title> <booktitle> Proceedings of the 16th International Con-ferece on Very Large Data Bases, </booktitle> <address> Brisbane, Australia, </address> <month> August, </month> <year> 1990. </year> <pages> 112 113 </pages>
Reference-contexts: Finally, Section 4.7 compares the design of QuickStore with the design of other memory-mapped persistent stores. 4.1. Overview of the Memory-Mapped Architecture As mentioned above, QuickStore uses ESM to store persistent objects on disk. ESM features a page-shipping <ref> [DeWitt90] </ref> architecture, in which objects are transferred from the server to the client a page-at-a-time. <p> In addition, QuickStore, since it is implemented on top of the EXODUS Storage Manager (ESM), is a client-server, page-shipping system <ref> [DeWitt90] </ref>. This raises additional performance concerns that are not present in database systems based on more traditional designs, i.e. centralized DBMSs or systems based on a query-shipping architecture. The remainder of this chapter is organized as follows. <p> We begin by describing the implementation of recovery in ESM since several of the techniques are built on top of or involve modifications to the ESM recovery scheme. 6.2.1. Recovery in EXODUS The EXODUS Storage Manager is a client-server, page-shipping system <ref> [DeWitt90] </ref> in which both clients and servers manage their own local buffer pools. When a client needs to access an object on a page that is not currently cached in its local buffer pool, it sends a request to the appropriate server asking for the page.
Reference: [Deux91] <editor> O. Deux et al., </editor> <title> "The O2 System", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 34, No. 10, </volume> <month> October </month> <year> 1991 </year>
Reference-contexts: Since the 1980's object-oriented database technology has advanced significantly, and during the last five years, Object-Oriented Database Management Systems (OODBMSs), have gained a foothold in the commercial marketplace. For example, current commercial OODBMSs include ObjectStore [Lamb91], Objectivity [Objy92], Ontos [Ontos92], O 2 <ref> [Deux91] </ref>, GemStone [Butter91], and Versant [Versan92]. Despite their greater expressive power, however, whether OODBMSs continue to gain in popularity will ultimately depend upon their ability to meet the stringent performance demands of their potential market. <p> Figure 2.1 illustrates the different dimensions of pointer swizzling that are discussed. 2.1. Swizzling vs. No Swizzling One obvious approach is to do no pointer swizzling at all. We note that O 2 <ref> [Deux91] </ref> which is a commercial system, performs no pointer swizzling. Under this approach the unique object identifier (OID) [Khosh86] contained in a pointer is used to lookup the actual memory location of the object referenced by the pointer whenever the pointer is dereferenced. <p> Although several OODBMSs are commercially available, very little has been published concerning the recovery algorithms they use. The O 2 system <ref> [Deux91] </ref> also uses an ARIES-based approach to support recovery. O 2 differs from ESM and ARIES/CSA in that it uses shadowing to avoid undo. The most popular commercial OODBMS is ObjectStore [Lamb91] which like, QuickStore, uses a memory-mapping scheme to give application programs access to persistent data.
Reference: [Elhar84] <author> K. Elhardt, R. Bayer, </author> <title> "A Database Cache for High Performance and Fast Restart in Database Systems", </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(4) </volume> <pages> 503-525, </pages> <month> December </month> <year> 1984. </year> <title> [Exodu93] "Using the EXODUS Storage Manager V3.0", </title> <type> technical documentation, </type> <institution> Department of Computer Sciences, University of Wisconsin-Madison, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: This differs from the ARIES-based schemes mentioned above which only require that the log records generated by updates be written to disk at commit time. Finally, we note that the whole-page logging approach to recovery was first described in <ref> [Elhar84] </ref> which presents the design of the database cache. 109 6.6. Conclusions This chapter has presented an in-depth comparison of the performance of several different approaches to implementing recovery in QuickStore, a memory-mapped storage manager based on a client-server, page-shipping architecture.
Reference: [Frank92] <author> M. Franklin et al., </author> <title> "Crash Recovery in Client-Server EXODUS", </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <address> California, </address> <year> 1992. </year>
Reference-contexts: All of the systems included in the study are based on a client-server architecture and feature full support for transactions, concurrency control, and recovery. The client-server version of ESM <ref> [Frank92, Exodu93] </ref> was used to store persistent data for the experiments based on EPVM 2.0, EPVM 1.0, and C++. The remainder of the chapter is organized as follows. Section 3.2 presents a detailed description of the implementation of EPVM 2.0. Section 3.3 describes the benchmark experiments. <p> However, the client must communicate with the server to reacquire locks for cached pages that are accessed in succeeding transactions. Transaction commit involves shipping dirty data pages and log pages back to the server, writing log pages to disk, and releasing locks <ref> [Frank92] </ref>. No pointer swizzling is done in this architecture. A single software version based on this architecture was used (referred to as CESM). The size of the ESM client and server buffer pools was 5 megabytes. The second architecture represents the approach taken by EPVM 1.0 [Schuh90]. <p> The log records generated on behalf of a transaction must be written to the log by the server before the transaction commits, but the dirty pages themselves are not forced to disk. See <ref> [Frank92] </ref> for a more detailed description of the ESM recovery scheme. 6.2.2. The Page Diffing Approach The ESM recovery mechanism handles the generation of log records for updates. <p> Related Work This section discusses related work that has been done on the design and implementation of recovery algorithms for client-server database systems. We also compare the study presented here with other studies that have dealt with the issue of recovery performance. <ref> [Frank92] </ref> describes the design and implementation of crash recovery in the EXODUS Storage Manager (ESM). In addition, [Frank92] discusses the issues that must be addressed when implementing recovery in a client-server environment. The recovery algorithm described in [Frank92] is based on ARIES [Mohan92], and supports write-ahead-logging and a STEAL/NO FORCE buffer <p> We also compare the study presented here with other studies that have dealt with the issue of recovery performance. <ref> [Frank92] </ref> describes the design and implementation of crash recovery in the EXODUS Storage Manager (ESM). In addition, [Frank92] discusses the issues that must be addressed when implementing recovery in a client-server environment. The recovery algorithm described in [Frank92] is based on ARIES [Mohan92], and supports write-ahead-logging and a STEAL/NO FORCE buffer management policy at the server. <p> here with other studies that have dealt with the issue of recovery performance. <ref> [Frank92] </ref> describes the design and implementation of crash recovery in the EXODUS Storage Manager (ESM). In addition, [Frank92] discusses the issues that must be addressed when implementing recovery in a client-server environment. The recovery algorithm described in [Frank92] is based on ARIES [Mohan92], and supports write-ahead-logging and a STEAL/NO FORCE buffer management policy at the server. However, the ESM currently requires that all dirty pages be shipped from a client to the server before a transaction commits. This could be termed a force-to-server-at-commit policy.
Reference: [Frank93] <author> M. Franklin, </author> <title> "Caching and Memory Management in Client-Server Database Systems", </title> <type> Ph.D. thesis, </type> <institution> University of Wisconsin-Madison, </institution> <type> technical report #1168, </type> <month> July </month> <year> 1993. </year>
Reference-contexts: A final consideration arises from the fact that QuickStore is based on a client-server architecture in which updates are performed at client workstations. This raises the issue of cache consistency between clients and the server <ref> [Frank93] </ref> since both the client and the server buffer pools can contain cached copies of a page that has been updated. <p> In addition to the obvious advantage of not having to ship dirty pages from clients to the server, REDO is also appealing from an implementation standpoint. It simplifies the implementation of a storage manager by providing cache consistency between clients and the server <ref> [Frank93] </ref>. REDO is currently being used in the initial version of SHORE [Carey94], a persistent object system being developed at Wisconsin.
Reference: [Gray78] <author> J. N. Gray, </author> <title> "Notes on Data Base Operating Systems", in Operating Systems: An Advanced Course, </title> <editor> R. Bayer, R. M. Graham, G. Seegmuller (Editors), </editor> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <pages> pages 393-481, </pages> <year> 1978. </year>
Reference-contexts: The performance results presented in the thesis give an accurate and comprehensive picture of the differences in performance between software and hardware-based swizzling techniques. An issue that is closely related to pointer swizzling, and which appears several times in the thesis, is that of providing recovery services <ref> [Gray78] </ref> in an OODBMS. Implementing recovery in an OODBMS poses new challenges due to the tight integration between the application programming language used to access the database and the database system itself.
Reference: [Haerd83] <author> T. Haerder, A. Reuter, </author> <title> "Principles of Transaction Oriented Database Recovery A Taxonomy", </title> <journal> Computing Surveys, </journal> <volume> Vol. 6, No. 1, </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: Thus, the server never has a page cached in its buffer pool for which it doesn't also have the log records describing the updates present on the page. The server manages a circular, append-only log on secondary storage and uses a STEAL/NO-FORCE buffer management policy <ref> [Haerd83] </ref>. Clients can cache pages in their local buffer pools across transaction boundaries. However, inter-transaction caching of locks at clients is not supported.
Reference: [Hoski93a] <author> A. Hosking, J. E. B. Moss, </author> <title> "Object Fault Handling for Persistent Programming Languages: A Performance Evaluation", </title> <booktitle> Proceedings of the ACM Conference on Object-Oriented Programming Systems and Languages (OOPSLA), </booktitle> <pages> pp. 288-303, </pages> <year> 1993. </year> <booktitle> Proceedings of the 16th International Conferece on Very Large Data Bases </booktitle>
Reference: [Hoski93b] <author> A. Hosking, E. Brown, J. Moss, </author> <title> "Update Logging in Persistent Programming Languages: A Comparative Performance Evaluation", </title> <booktitle> Proceedings of the 19th International Conferece on Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <year> 1993. </year>
Reference: [Jagad94] <author> H. Jagadish, D. Lieuwen, R. Rastogi, A. Silberschatz, </author> <title> "Dali: A High Performance Main Memory Storage Manager", </title> <booktitle> to appear in Proceedings of the 20th International Conferece on Very Large Data Bases, </booktitle> <address> Santiago, Chile, </address> <month> September 12-15, </month> <year> 1994. </year>
Reference-contexts: This limitation could conceivably be overcome by using some form of garbage collection to reclaim memory space, but this would add additional overhead and complexity to the system. The hardware approach has been used in several commercial and research systems, including ObjectStore [Lamb91], Texas [Singh92], Cricket [Shek90], Dali <ref> [Jagad94] </ref>, and QuickStore (see Chapter 4). partial lazy indirect copy software swizzling uncaching full eager direct in-place hardware no-swizzling no uncaching 2.3. In-place vs. Copy Swizzling Copy and in-place strategies differ primarily in where they cache persistent objects in main memory. <p> Cricket, on the other hand, uses the Mach external pager facility to map persistent data into an application's address space (see [Shek90] for details). A very recent related system is Dali <ref> [Jagad94] </ref> which is designed to be a main memory storage manager. Dali uses memory mapping techniques, but since it is specifically designed to handle main memory databases, it differs substantially from QuickStore. For example, Dali itself performs no pointer swizzling.
Reference: [Khosh86] <author> S. N. Khoshafian, G. P. Copeland, </author> <title> "Object Identity", </title> <booktitle> Proceedings of the ACM Conference on Object-Oriented Programming Systems and Languages (OOPSLA), </booktitle> <pages> pages 408-416, </pages> <month> November </month> <year> 1986. </year> <month> 114 </month>
Reference-contexts: Swizzling vs. No Swizzling One obvious approach is to do no pointer swizzling at all. We note that O 2 [Deux91] which is a commercial system, performs no pointer swizzling. Under this approach the unique object identifier (OID) <ref> [Khosh86] </ref> contained in a pointer is used to lookup the actual memory location of the object referenced by the pointer whenever the pointer is dereferenced. The lookup process generally involves a relatively expensive search in an in-memory table.
Reference: [Kemper93] <author> A. Kemper, D. Kossmann, </author> <title> "Adaptable Pointer Swizzling Strategies in Object Bases", </title> <booktitle> Proceedings of the International Conference on Data Engineering, </booktitle> <pages> pages 155-162, </pages> <address> Vienna, Austria, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: Lazy swizzling techniques that swizzle individual pointers can be further categorized by the set of basic pointer operations (dereference, compare, fetch, and store) used to trigger swizzling [McAul94]. We note here that the term eager swizzling has a slightly different meaning in <ref> [Kemper93] </ref> and [McAul94] than in [Moss92]. [Moss92] defines an eager technique as one that eliminates the need for pointer checks by doing aggressive swizzling, while [Kemper93] and [McAul94] consider any swizzling technique that swizzles all of the pointers in an object (or page) together to be an eager technique. 7 2.6. <p> We note here that the term eager swizzling has a slightly different meaning in <ref> [Kemper93] </ref> and [McAul94] than in [Moss92]. [Moss92] defines an eager technique as one that eliminates the need for pointer checks by doing aggressive swizzling, while [Kemper93] and [McAul94] consider any swizzling technique that swizzles all of the pointers in an object (or page) together to be an eager technique. 7 2.6. Direct vs. <p> A restricted form of software swizzling is supported by EPVM 1.0 [Schuh90]. The major difference between the approach discussed in [Schuh90] and those presented in [Moss92], is that [Schuh90] allows objects to be replaced in memory during a transaction. <ref> [Kemper93] </ref> examines the performance of several software swizzling schemes which, like the approach of [Schuh90], also allow objects to be replaced during a transaction. [Kemper93] explores the issues of both direct versus indirect swizzling and eager versus lazy swizzling. The results of the study in [Kemper93] were inconclusive, however, in finding <p> major difference between the approach discussed in [Schuh90] and those presented in [Moss92], is that [Schuh90] allows objects to be replaced in memory during a transaction. <ref> [Kemper93] </ref> examines the performance of several software swizzling schemes which, like the approach of [Schuh90], also allow objects to be replaced during a transaction. [Kemper93] explores the issues of both direct versus indirect swizzling and eager versus lazy swizzling. The results of the study in [Kemper93] were inconclusive, however, in finding a swizzling technique that was clearly superior to the others, so [Kemper93] advocates an approach termed adaptable pointer swizzling that attempts to combine several <p> in memory during a transaction. <ref> [Kemper93] </ref> examines the performance of several software swizzling schemes which, like the approach of [Schuh90], also allow objects to be replaced during a transaction. [Kemper93] explores the issues of both direct versus indirect swizzling and eager versus lazy swizzling. The results of the study in [Kemper93] were inconclusive, however, in finding a swizzling technique that was clearly superior to the others, so [Kemper93] advocates an approach termed adaptable pointer swizzling that attempts to combine several swizzling schemes into a single hybrid approach. [McAul94] contains a similar study to the one presented in [Kemper93], comparing swizzling performance <p> approach of [Schuh90], also allow objects to be replaced during a transaction. <ref> [Kemper93] </ref> explores the issues of both direct versus indirect swizzling and eager versus lazy swizzling. The results of the study in [Kemper93] were inconclusive, however, in finding a swizzling technique that was clearly superior to the others, so [Kemper93] advocates an approach termed adaptable pointer swizzling that attempts to combine several swizzling schemes into a single hybrid approach. [McAul94] contains a similar study to the one presented in [Kemper93], comparing swizzling performance using several different workloads. The results in [McAul94] differ from those found in [Kemper93], and indicate that <p> the study in <ref> [Kemper93] </ref> were inconclusive, however, in finding a swizzling technique that was clearly superior to the others, so [Kemper93] advocates an approach termed adaptable pointer swizzling that attempts to combine several swizzling schemes into a single hybrid approach. [McAul94] contains a similar study to the one presented in [Kemper93], comparing swizzling performance using several different workloads. The results in [McAul94] differ from those found in [Kemper93], and indicate that indirect swizzling performs best. <p> the others, so <ref> [Kemper93] </ref> advocates an approach termed adaptable pointer swizzling that attempts to combine several swizzling schemes into a single hybrid approach. [McAul94] contains a similar study to the one presented in [Kemper93], comparing swizzling performance using several different workloads. The results in [McAul94] differ from those found in [Kemper93], and indicate that indirect swizzling performs best.
Reference: [Lamb91] <author> C. Lamb, G. Landis, J. Orenstein, D. Weinreb, </author> <title> "The ObjectStore Database System", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 34, No. 10, </volume> <month> October </month> <year> 1991 </year>
Reference-contexts: Since the 1980's object-oriented database technology has advanced significantly, and during the last five years, Object-Oriented Database Management Systems (OODBMSs), have gained a foothold in the commercial marketplace. For example, current commercial OODBMSs include ObjectStore <ref> [Lamb91] </ref>, Objectivity [Objy92], Ontos [Ontos92], O 2 [Deux91], GemStone [Butter91], and Versant [Versan92]. Despite their greater expressive power, however, whether OODBMSs continue to gain in popularity will ultimately depend upon their ability to meet the stringent performance demands of their potential market. <p> In the simple case, the swizzled pointer can then be used to directly access the object that it references. 2.2. Hardware vs. Software-based Swizzling Pointer swizzling schemes have traditionally used software checks to determine if a pointer has been swizzled. More recently, hardware-based swizzling schemes <ref> [Wilso90, Lamb91] </ref> that use virtual memory access protection violations to detect accesses of non-resident objects have been proposed. <p> This limitation could conceivably be overcome by using some form of garbage collection to reclaim memory space, but this would add additional overhead and complexity to the system. The hardware approach has been used in several commercial and research systems, including ObjectStore <ref> [Lamb91] </ref>, Texas [Singh92], Cricket [Shek90], Dali [Jagad94], and QuickStore (see Chapter 4). partial lazy indirect copy software swizzling uncaching full eager direct in-place hardware no-swizzling no uncaching 2.3. In-place vs. Copy Swizzling Copy and in-place strategies differ primarily in where they cache persistent objects in main memory. <p> The technique described in [Wilso90] allows programs to access persistent objects by dereferencing standard virtual memory pointers, eliminating the need for software residency checks. 9 The basic ideas presented in [Wilso90] were, at the same time, independently developed by the designers of ObjectStore <ref> [Objec90, Lamb91] </ref>, a commercial OODBMS product from Object Design, Inc. However, the implementation of ObjectStore, outlined briefly in [Objec90], differs in some interesting ways from the scheme described in [Wilso90]. <p> Again, a 5 megabyte server buffer pool was used for all of the experiments. The version referred to as PC1M does pointer swizzling, while the version labeled PC1M-NO does not. The final architecture examined was that of ObjectStore V1.2 <ref> [Lamb91] </ref>. Like ESM, ObjectStore uses a client/server architecture in which both the client and server processes buffer recently accessed pages of objects. All interaction between the client and server in ObjectStore was configured to take place at the granularity of individual pages, just as in ESM. <p> ObjectStore features basically the same transaction facilities as ESM, i.e. recovery for updates in the event of client or server failure, page level locking, and transaction rollback. ObjectStore also supports inter-transaction caching of persistent data in the client's main memory <ref> [Lamb91] </ref>. Callback messages are sent by the server to clients in order to maintain the coherence of cached data. This allows the ObjectStore client to cache locks between transactions as well as data pages. <p> If it has, then the mapping object for the page is updated to reflect the new set of referenced pages. 4.7. Comparison With Other Systems This section discusses previous work that has been done on memory-mapped stores and compares the design of QuickStore to other memory-mapped systems. <ref> [Lamb91] </ref> describes the design of ObjectStore, a commercially available OODBMS that is based on a memory-mapped architecture. The design of QuickStore was heavily influenced by the design of ObjectStore, so QuickStore and ObjectStore are similar in several respects. <p> We note that the approach used in E requires special compiler support to insert function calls for updates into the application code at compile time. Commercial OODBMSs that support automatic index maintenance, such as ObjectStore <ref> [Lamb91] </ref>, typically include a similar mechanism to trap updates so that index maintenance can be 83 84 performed whenever a relevant update occurs. However, like QuickStore, ObjectStore allows unindexed attributes to be updated by dereferencing normal virtual memory pointers. <p> This algorithm is termed whole-page logging (WPL) since entire modified pages are written to the log instead of log records for updated regions of objects. As was mentioned in Chapter 3, this is the basic approach used in ObjectStore <ref> [Lamb91] </ref>. The advantages of WPL are that it avoids the client CPU cost that is incurred by the two diffing schemes for copying and diffing. WPL also avoids the memory overhead at clients for storing the original values of pages/blocks. <p> The O 2 system [Deux91] also uses an ARIES-based approach to support recovery. O 2 differs from ESM and ARIES/CSA in that it uses shadowing to avoid undo. The most popular commercial OODBMS is ObjectStore <ref> [Lamb91] </ref> which like, QuickStore, uses a memory-mapping scheme to give application programs access to persistent data. As was mentioned in Chapter 3, ObjectStore uses a technique which we term whole-page logging to support recovery.
Reference: [McAul94] <author> M. McAuliffe, M. Solomon, </author> <title> "A Trace-Based Simulation of Pointer Swizzling Techniques", </title> <booktitle> to appear in Proceedings of the International Conference on Data Engineering, </booktitle> <address> Taipei, Taiwan, March 6-10, </address> <year> 1995. </year>
Reference-contexts: Lazy swizzling techniques that swizzle individual pointers can be further categorized by the set of basic pointer operations (dereference, compare, fetch, and store) used to trigger swizzling <ref> [McAul94] </ref>. We note here that the term eager swizzling has a slightly different meaning in [Kemper93] and [McAul94] than in [Moss92]. [Moss92] defines an eager technique as one that eliminates the need for pointer checks by doing aggressive swizzling, while [Kemper93] and [McAul94] consider any swizzling technique that swizzles all of <p> Lazy swizzling techniques that swizzle individual pointers can be further categorized by the set of basic pointer operations (dereference, compare, fetch, and store) used to trigger swizzling <ref> [McAul94] </ref>. We note here that the term eager swizzling has a slightly different meaning in [Kemper93] and [McAul94] than in [Moss92]. [Moss92] defines an eager technique as one that eliminates the need for pointer checks by doing aggressive swizzling, while [Kemper93] and [McAul94] consider any swizzling technique that swizzles all of the pointers in an object (or page) together to be an eager technique. 7 2.6. <p> compare, fetch, and store) used to trigger swizzling <ref> [McAul94] </ref>. We note here that the term eager swizzling has a slightly different meaning in [Kemper93] and [McAul94] than in [Moss92]. [Moss92] defines an eager technique as one that eliminates the need for pointer checks by doing aggressive swizzling, while [Kemper93] and [McAul94] consider any swizzling technique that swizzles all of the pointers in an object (or page) together to be an eager technique. 7 2.6. Direct vs. <p> The results of the study in [Kemper93] were inconclusive, however, in finding a swizzling technique that was clearly superior to the others, so [Kemper93] advocates an approach termed adaptable pointer swizzling that attempts to combine several swizzling schemes into a single hybrid approach. <ref> [McAul94] </ref> contains a similar study to the one presented in [Kemper93], comparing swizzling performance using several different workloads. The results in [McAul94] differ from those found in [Kemper93], and indicate that indirect swizzling performs best. The study in [McAul94] differs from the work presented here in that it only examines the <p> technique that was clearly superior to the others, so [Kemper93] advocates an approach termed adaptable pointer swizzling that attempts to combine several swizzling schemes into a single hybrid approach. <ref> [McAul94] </ref> contains a similar study to the one presented in [Kemper93], comparing swizzling performance using several different workloads. The results in [McAul94] differ from those found in [Kemper93], and indicate that indirect swizzling performs best. The study in [McAul94] differs from the work presented here in that it only examines the relative CPU cost of operations involving pointers, while we compare different swizzling schemes based on their overall system-level performance. [McAul94] also <p> that attempts to combine several swizzling schemes into a single hybrid approach. <ref> [McAul94] </ref> contains a similar study to the one presented in [Kemper93], comparing swizzling performance using several different workloads. The results in [McAul94] differ from those found in [Kemper93], and indicate that indirect swizzling performs best. The study in [McAul94] differs from the work presented here in that it only examines the relative CPU cost of operations involving pointers, while we compare different swizzling schemes based on their overall system-level performance. [McAul94] also does not discuss hardware-based swiz-zling techniques. <p> in <ref> [McAul94] </ref> differ from those found in [Kemper93], and indicate that indirect swizzling performs best. The study in [McAul94] differs from the work presented here in that it only examines the relative CPU cost of operations involving pointers, while we compare different swizzling schemes based on their overall system-level performance. [McAul94] also does not discuss hardware-based swiz-zling techniques. A detailed proposal advocating the use of virtual memory techniques to trigger the transfer of persistent objects from disk to main memory first appeared in [Wilso90].
Reference: [Mohan92] <author> C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh, P. Schwartz, </author> <title> "ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging", </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 17, No. 1, </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: In addition, [Frank92] discusses the issues that must be addressed when implementing recovery in a client-server environment. The recovery algorithm described in [Frank92] is based on ARIES <ref> [Mohan92] </ref>, and supports write-ahead-logging and a STEAL/NO FORCE buffer management policy at the server. However, the ESM currently requires that all dirty pages be shipped from a client to the server before a transaction commits. This could be termed a force-to-server-at-commit policy.
Reference: [Mohan94] <author> C. Mohan, I. Narang, "ARIES/CSA: </author> <title> A Method for Database Recovery in Client-Server Architectures", </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <address> Min-neapolis, MN, </address> <year> 1994. </year>
Reference-contexts: This could be termed a force-to-server-at-commit policy. We note here that while ESM addresses the recovery issues raised by 107 a client server architecture, it does not address the issues discussed in Section 6.1, i.e. issues that are specific to object-oriented systems and memory-mapped stores. More recently, <ref> [Mohan94] </ref> has presented an algorithm termed ARIES/CSA which also extends the basic ARIES recovery algorithm to the client-server environment. ARIES/CSA differs from ESM in that it supports fine-granularity locking which ESM currently does not. ARIES/CSA also supports unconditional undo.
Reference: [Moss92] <author> J. Eliot B. Moss, </author> <title> "Working with Persistent Objects: To Swizzle or Not to Swizzle", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(8) </volume> <pages> 657-673, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Finally, Chapter 7 summarizes the contributions of the work presented in the thesis. CHAPTER 2 OVERVIEW OF POINTER SWIZZLING The number of different, possible pointer swizzling techniques is surprisingly large. The first attempt at presenting a thorough taxonomy of swizzling techniques appeared in <ref> [Moss92] </ref>. However, since that time the number of criteria that have been used to distinguish different swizzling schemes has grown considerably. This chapter discusses the salient features that distinguish alternative pointer swizzling techniques and presents a survey of related work on pointer swizzling. <p> Uncaching vs. No Uncaching The issue of uncaching vs. no uncaching separates systems that support the incremental uncaching of objects during a transaction from those that do not. This distinction was not made in <ref> [Moss92] </ref> since none of the techniques described there supported uncaching. <p> Special care must be taken to deal with swizzled pointers in this case. 2.5. Eager vs. Lazy Swizzling Eager swizzling schemes perform very aggressive pointer swizzling. In fact, pure eager swizzling, as defined in <ref> [Moss92] </ref>, swizzles all of the pointers contained in a collection of objects (i.e. a set of objects that reference one another either directly or transitively) before an application begins accessing objects in the collection. <p> Lazy swizzling techniques that swizzle individual pointers can be further categorized by the set of basic pointer operations (dereference, compare, fetch, and store) used to trigger swizzling [McAul94]. We note here that the term eager swizzling has a slightly different meaning in [Kemper93] and [McAul94] than in <ref> [Moss92] </ref>. [Moss92] defines an eager technique as one that eliminates the need for pointer checks by doing aggressive swizzling, while [Kemper93] and [McAul94] consider any swizzling technique that swizzles all of the pointers in an object (or page) together to be an eager technique. 7 2.6. Direct vs. <p> Lazy swizzling techniques that swizzle individual pointers can be further categorized by the set of basic pointer operations (dereference, compare, fetch, and store) used to trigger swizzling [McAul94]. We note here that the term eager swizzling has a slightly different meaning in [Kemper93] and [McAul94] than in <ref> [Moss92] </ref>. [Moss92] defines an eager technique as one that eliminates the need for pointer checks by doing aggressive swizzling, while [Kemper93] and [McAul94] consider any swizzling technique that swizzles all of the pointers in an object (or page) together to be an eager technique. 7 2.6. Direct vs. <p> Some early work on software implementations of pointer swizzling was done as part of an implementation of PS-Algol [Atkin83, Cock84]. This approach used pointer dereferences to trigger the transfer of objects from secondary storage into main memory. <ref> [Moss92] </ref> presents a more recent study of software swizzling techniques that, like the study presented in Chapter 3, examines the issue of accessing persistent objects in the buffer pool of the underlying object manager versus copying them into an object cache. [Moss92] also examines the differences between eager and lazy swizzling. <p> transfer of objects from secondary storage into main memory. <ref> [Moss92] </ref> presents a more recent study of software swizzling techniques that, like the study presented in Chapter 3, examines the issue of accessing persistent objects in the buffer pool of the underlying object manager versus copying them into an object cache. [Moss92] also examines the differences between eager and lazy swizzling. The lazy swizzling scheme described in [Moss92] takes an object-at-a-time approach to swizzling, in which objects that are in memory are classified as either swizzled or unswizzled. <p> software swizzling techniques that, like the study presented in Chapter 3, examines the issue of accessing persistent objects in the buffer pool of the underlying object manager versus copying them into an object cache. <ref> [Moss92] </ref> also examines the differences between eager and lazy swizzling. The lazy swizzling scheme described in [Moss92] takes an object-at-a-time approach to swizzling, in which objects that are in memory are classified as either swizzled or unswizzled. Under this approach, all pointers in an unswizzled object are swizzled immediately upon the first use of the object. <p> In particular, unswizzled objects, while they are memory resident, have, by definition not been referenced. A restricted form of software swizzling is supported by EPVM 1.0 [Schuh90]. The major difference between the approach discussed in [Schuh90] and those presented in <ref> [Moss92] </ref>, is that [Schuh90] allows objects to be replaced in memory during a transaction. [Kemper93] examines the performance of several software swizzling schemes which, like the approach of [Schuh90], also allow objects to be replaced during a transaction. [Kemper93] explores the issues of both direct versus indirect swizzling and eager versus <p> Software checks are used to distinguish swizzled and unswizzled pointers. This seems reasonable since the price of such checks should be a very small part of overall program execution time; this fact has been independently confirmed in <ref> [Moss92] </ref>. Furthermore, it is possible to do standard kinds of compiler optimizations to eliminate checks from a program (though the E compiler currently does not do this). <p> The swizzling scheme used in EPVM 2.0 is further characterized by the fact that it swizzles pointers one-at-a-time, as opposed to the approach described in [Wilso90] which swizzles them a page-at-a-time, and <ref> [Moss92] </ref> which swizzles pointers at the granularity of objects. The type of swizzling scheme used by EPVM 2.0 is referred to as an 'edge marking' scheme in [Moss92]. <p> characterized by the fact that it swizzles pointers one-at-a-time, as opposed to the approach described in [Wilso90] which swizzles them a page-at-a-time, and <ref> [Moss92] </ref> which swizzles pointers at the granularity of objects. The type of swizzling scheme used by EPVM 2.0 is referred to as an 'edge marking' scheme in [Moss92]. Implementation Strategy Since pointers are swizzled dynamically during program execution, the key decision that must be made is when during execution to actually do the swizzling. One possibility is to swizzle pointers when they are dereferenced. <p> The advantage of this approach is that access to in-memory persistent objects is just as efficient as access to transient objects, i.e. application programs access objects by dereferencing normal virtual memory pointers, with no overhead for software residency checks in contrast to <ref> [Moss92, Schuh90, White92] </ref>. QuickStore is implemented as a C++ class library that can be linked with an application, requiring no special compiler support. Instead, QuickStore uses a modified version of gdb to obtain information describing the physical layout of persistent objects (see Section 4.4 for details).
Reference: [Objec90] <institution> Object Design, Inc., </institution> <note> "ObjectStore User Guide", Release 1.0, </note> <month> October </month> <year> 1990. </year>
Reference-contexts: The technique described in [Wilso90] allows programs to access persistent objects by dereferencing standard virtual memory pointers, eliminating the need for software residency checks. 9 The basic ideas presented in [Wilso90] were, at the same time, independently developed by the designers of ObjectStore <ref> [Objec90, Lamb91] </ref>, a commercial OODBMS product from Object Design, Inc. However, the implementation of ObjectStore, outlined briefly in [Objec90], differs in some interesting ways from the scheme described in [Wilso90]. <p> However, the implementation of ObjectStore, outlined briefly in <ref> [Objec90] </ref>, differs in some interesting ways from the scheme described in [Wilso90]. The most notable differences lie in the way that pointer swizzling is implemented and in how pointers are represented on disk. Under the approach outlined in [Objec90], pointers between persistent objects are stored on disk as virtual memory pointers <p> However, the implementation of ObjectStore, outlined briefly in <ref> [Objec90] </ref>, differs in some interesting ways from the scheme described in [Wilso90]. The most notable differences lie in the way that pointer swizzling is implemented and in how pointers are represented on disk. Under the approach outlined in [Objec90], pointers between persistent objects are stored on disk as virtual memory pointers instead of being stored in a different disk format as in [Wilso90]. <p> The first architecture is represented by EPVM 1.0 which supports a more limited form of pointer swizzling than EPVM 2.0. The second architecture does not support pointer swizzling, and corresponds to using a conventional non-persistent programming language, i.e. C++, to call ESM directly. The final system is ObjectStore V1.2 <ref> [Objec90] </ref>, a commercially available object-oriented DBMS. ObjectStore uses a memory-mapped approach to support pointer swizzling and fault objects into main memory.
Reference: [Objy92] <institution> Objectivity, Inc., </institution> <note> "Objectivity Reference Manual". </note> <year> 1992. </year>
Reference-contexts: Since the 1980's object-oriented database technology has advanced significantly, and during the last five years, Object-Oriented Database Management Systems (OODBMSs), have gained a foothold in the commercial marketplace. For example, current commercial OODBMSs include ObjectStore [Lamb91], Objectivity <ref> [Objy92] </ref>, Ontos [Ontos92], O 2 [Deux91], GemStone [Butter91], and Versant [Versan92]. Despite their greater expressive power, however, whether OODBMSs continue to gain in popularity will ultimately depend upon their ability to meet the stringent performance demands of their potential market.
Reference: [Ontos92] <author> Ontos, Inc. </author> <title> "Ontos Reference Manual", </title> <year> 1992. </year>
Reference-contexts: Since the 1980's object-oriented database technology has advanced significantly, and during the last five years, Object-Oriented Database Management Systems (OODBMSs), have gained a foothold in the commercial marketplace. For example, current commercial OODBMSs include ObjectStore [Lamb91], Objectivity [Objy92], Ontos <ref> [Ontos92] </ref>, O 2 [Deux91], GemStone [Butter91], and Versant [Versan92]. Despite their greater expressive power, however, whether OODBMSs continue to gain in popularity will ultimately depend upon their ability to meet the stringent performance demands of their potential market.
Reference: [OO7] <author> UW OO7 Benchmarking Team, </author> <type> personal communication, </type> <month> August </month> <year> 1994. </year>
Reference-contexts: PC1M is 33% faster than EPVM1 because hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 It is also possible that the poor performance of ObjectStore in this case is due, at least in part, to a network-related performance bug that was known to cause problems in some pre-version-2.0 ObjectStore installations on Sun systems <ref> [OO7] </ref>. 27 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Traversal without updates iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Version Cold I/Os Warm I/Os iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii CESM 10.586 325 0.285 2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii EPVM1 10.655 327 0.180 2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii PC1M 11.386 327 0.120 2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii OS 12.530 217 0.066 1 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c
Reference: [Orens92] <author> J. </author> <title> Orenstein, </title> <type> personal communication, </type> <month> May </month> <year> 1992. </year>
Reference-contexts: Callback messages are sent by the server to clients in order to maintain the coherence of cached data. This allows the ObjectStore client to cache locks between transactions as well as data pages. To efficiently support callbacks, the ObjectStore client is divided into two processes <ref> [Orens92] </ref>: a callback process, and an application process. When only a single client is connected with the server, the two-process architecture does not have a noticeable effect on performance since the application process communicates directly with the server to obtain data pages and locks on those pages. <p> OS has the worst performance in the cold iteration. Based on our experience with QuickStore, we believe this is due to the cost of managing paging in the client buffer pool for ObjectStore, and also to poorer I/O performance for Object-Store relative to ESM <ref> [Orens92] </ref>. PC1M performs the best in the warm iteration, but comparing PC1M to the other architectures is not strictly fair in this case since it is allowed to use all of the available memory, as shown by the number of page faults that it experiences.
Reference: [Rich93] <author> J. Richardson, M. Carey, and D. Schuh, </author> <title> "The Design of the E Programming Language", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 15, No. 3, </volume> <month> July </month> <year> 1993. </year>
Reference-contexts: CHAPTER 3 POINTER SWIZZLING IN E This chapter examines the performance of several software-based pointer swizzling schemes that were implemented in the context of the E programming language <ref> [Rich93] </ref>. In addition, the performance of the software-based schemes is compared to that of ObjectStore, a commercial OODBMS that incorporates hardware support for pointer swizzling. The issue of whether it is even beneficial to do pointer swizzling is also examined. 3.1.
Reference: [Schuh90] <author> D. Schuh, M. Carey, and D. Dewitt, </author> <title> Persistence in E Revisited---Implementation Experiences, in Implementing Persistent Object Bases Principles and Practice, </title> <booktitle> Proceedings of the Fourth International Workshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, MA, </address> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Partial vs. Full Swizzling Systems that use partial swizzling only swizzle a subset of all possible pointers, while systems that perform full swizzling may swizzle any pointer that references a persistent object. <ref> [Schuh90] </ref> uses partial swizzling to avoid the difficult problem (mentioned above) of unswizzling swizzled pointers when the objects that they reference leave main memory. The technique described in [Schuh90] only swizzles pointers that are local variables in functions. <p> swizzle a subset of all possible pointers, while systems that perform full swizzling may swizzle any pointer that references a persistent object. <ref> [Schuh90] </ref> uses partial swizzling to avoid the difficult problem (mentioned above) of unswizzling swizzled pointers when the objects that they reference leave main memory. The technique described in [Schuh90] only swizzles pointers that are local variables in functions. Variables of this type are maintained on a special pointer stack that is separate from the usual procedure activation stack. This significantly simplifies the task of locating swizzled pointers. 2.8. <p> In particular, unswizzled objects, while they are memory resident, have, by definition not been referenced. A restricted form of software swizzling is supported by EPVM 1.0 <ref> [Schuh90] </ref>. The major difference between the approach discussed in [Schuh90] and those presented in [Moss92], is that [Schuh90] allows objects to be replaced in memory during a transaction. [Kemper93] examines the performance of several software swizzling schemes which, like the approach of [Schuh90], also allow objects to be replaced during a <p> In particular, unswizzled objects, while they are memory resident, have, by definition not been referenced. A restricted form of software swizzling is supported by EPVM 1.0 <ref> [Schuh90] </ref>. The major difference between the approach discussed in [Schuh90] and those presented in [Moss92], is that [Schuh90] allows objects to be replaced in memory during a transaction. [Kemper93] examines the performance of several software swizzling schemes which, like the approach of [Schuh90], also allow objects to be replaced during a transaction. [Kemper93] explores the issues of both direct versus <p> In particular, unswizzled objects, while they are memory resident, have, by definition not been referenced. A restricted form of software swizzling is supported by EPVM 1.0 <ref> [Schuh90] </ref>. The major difference between the approach discussed in [Schuh90] and those presented in [Moss92], is that [Schuh90] allows objects to be replaced in memory during a transaction. [Kemper93] examines the performance of several software swizzling schemes which, like the approach of [Schuh90], also allow objects to be replaced during a transaction. [Kemper93] explores the issues of both direct versus indirect swizzling and eager versus lazy swizzling. <p> of software swizzling is supported by EPVM 1.0 <ref> [Schuh90] </ref>. The major difference between the approach discussed in [Schuh90] and those presented in [Moss92], is that [Schuh90] allows objects to be replaced in memory during a transaction. [Kemper93] examines the performance of several software swizzling schemes which, like the approach of [Schuh90], also allow objects to be replaced during a transaction. [Kemper93] explores the issues of both direct versus indirect swizzling and eager versus lazy swizzling. <p> The implementation of E uses an interpreter, the E Persistent Virtual Machine (EPVM), to coordinate access to persistent data <ref> [Schuh90] </ref> that is stored using the EXODUS Storage Manager [Carey89]. Under the approach taken by EPVM 1.0 (the original implementation of EPVM), memory resident persistent objects are accessed in-place in the buffer pool of the EXODUS Storage Manager (ESM). <p> This is done as an optimization to handle the case when an unswizzled local pointer variable may be dereferenced a number of times in succession. Swiz-zling the pointer when it is first dereferenced lessens the cost of the dereferences that follow and can improve performance <ref> [Schuh90] </ref>. It is important to note that the benefits of this type of swizzling are temporary, because when the function containing the local variable finishes its execution, the local variable that has been swizzled is lost. <p> No pointer swizzling is done in this architecture. A single software version based on this architecture was used (referred to as CESM). The size of the ESM client and server buffer pools was 5 megabytes. The second architecture represents the approach taken by EPVM 1.0 <ref> [Schuh90] </ref>. Figure 3.6 shows the client portion of this architecture (the server portion is identical to the server shown in Figure 3.5). EPVM 1.0 avoids calls to the storage manager by maintaining a cache of worthy objects in the ESM client buffer pool. Objects are accessed in the following way. <p> The advantage of this approach is that access to in-memory persistent objects is just as efficient as access to transient objects, i.e. application programs access objects by dereferencing normal virtual memory pointers, with no overhead for software residency checks in contrast to <ref> [Moss92, Schuh90, White92] </ref>. QuickStore is implemented as a C++ class library that can be linked with an application, requiring no special compiler support. Instead, QuickStore uses a modified version of gdb to obtain information describing the physical layout of persistent objects (see Section 4.4 for details).
Reference: [Shek90] <author> E. Shekita and M. Zwilling, "Cricket: </author> <title> A Mapped Persistent Object Store", </title> <booktitle> Proceedings of the Fourth International Wor kshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, MA, </address> <month> Sept. </month> <year> 1990. </year> <month> 115 </month>
Reference-contexts: This limitation could conceivably be overcome by using some form of garbage collection to reclaim memory space, but this would add additional overhead and complexity to the system. The hardware approach has been used in several commercial and research systems, including ObjectStore [Lamb91], Texas [Singh92], Cricket <ref> [Shek90] </ref>, Dali [Jagad94], and QuickStore (see Chapter 4). partial lazy indirect copy software swizzling uncaching full eager direct in-place hardware no-swizzling no uncaching 2.3. In-place vs. Copy Swizzling Copy and in-place strategies differ primarily in where they cache persistent objects in main memory. <p> The hope is that processing this information will be less expensive on average than swizzling the pointers on pages that are faulted into memory by the application program. The Texas [Singh92] and Cricket <ref> [Shek90] </ref> storage systems also use virtual memory techniques to implement persistence. Texas stores pointers on disk as 8-byte file offsets, and swizzles pointers to virtual addresses at fault time as described in [Wilso90]. <p> Texas stores pointers on disk as 8-byte file offsets, and swizzles pointers to virtual addresses at fault time as described in [Wilso90]. Cricket, on the other hand, uses the Mach external pager facility to map persistent data into an application's address space (see <ref> [Shek90] </ref> for details). [Hoski93] examines the performance of several object faulting schemes in the context of a persistent Smalltalk implementation. [Hoski93] includes one scheme that uses virtual memory techniques to detect accesses to nonresident objects. <p> Thus, the pointer swizzling schemes 57 used in the two systems are nearly identical. Finally, both QuickStore and ObjectStore are based on persistent C++, and both limit the amount of data that can be accessed during a transaction to the size of virtual memory. The Texas [Singh92] and Cricket <ref> [Shek90] </ref> storage systems have also used virtual memory techniques to support object faulting and swizzling. Texas stores pointers on disk as 8-byte file offsets, and swizzles pointers to virtual addresses as described in [Wilso90] at fault time. <p> Cricket, on the other hand, uses the Mach external pager facility to map persistent data into an application's address space (see <ref> [Shek90] </ref> for details). A very recent related system is Dali [Jagad94] which is designed to be a main memory storage manager. Dali uses memory mapping techniques, but since it is specifically designed to handle main memory databases, it differs substantially from QuickStore. For example, Dali itself performs no pointer swizzling.
Reference: [Ultrix90] <institution> Ultrix 4.0 General Information (commands), Digital Equipment Corporation, </institution> <note> vol. 3b, </note> <month> June </month> <year> 1990. </year>
Reference-contexts: In performing the analysis, PC1Mpage caching using a 1 megabyte client buffer poolwas selected to serve as representative of the EPVM 2.0 approach. The results presented in this section were obtained by using the Unix pixie profiling tool <ref> [Ultrix90] </ref> and by analyzing assembly language listings of the relevant functions. 3.5.1. Hot Traversal Performance We begin by breaking down the hot time of 58 milliseconds shown for PC1M in Table 3.3 of Section 3.4.
Reference: [Versan92] <author> Versant, Inc., </author> <title> "Versant Reference Manual", </title> <year> 1992. </year>
Reference-contexts: Since the 1980's object-oriented database technology has advanced significantly, and during the last five years, Object-Oriented Database Management Systems (OODBMSs), have gained a foothold in the commercial marketplace. For example, current commercial OODBMSs include ObjectStore [Lamb91], Objectivity [Objy92], Ontos [Ontos92], O 2 [Deux91], GemStone [Butter91], and Versant <ref> [Versan92] </ref>. Despite their greater expressive power, however, whether OODBMSs continue to gain in popularity will ultimately depend upon their ability to meet the stringent performance demands of their potential market.
Reference: [Wilso90] <author> Paul R. Wilson, </author> <title> "Pointer Swizzling at Page Fault Time: Efficiently Supporting Huge Address Spaces on Standard Hardware", </title> <type> Technical Report UIC-EECS-90-6, </type> <institution> University of Illinois at Chicago, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: In the simple case, the swizzled pointer can then be used to directly access the object that it references. 2.2. Hardware vs. Software-based Swizzling Pointer swizzling schemes have traditionally used software checks to determine if a pointer has been swizzled. More recently, hardware-based swizzling schemes <ref> [Wilso90, Lamb91] </ref> that use virtual memory access protection violations to detect accesses of non-resident objects have been proposed. <p> This causes the 8 objects that the pointers reference to be faulted into memory and marked as unswizzled, after which the initial object is marked as swizzled. One advantage of the object-at-a-time approach over the page-at-a-time approach of <ref> [Wilso90] </ref> (see below) is that it should generally perform less unnecessary swizzling and unswizzling work. A disadvantage, however, is that objects that are not accessed by a program can be faulted into memory by the swizzling mechanism, resulting in unnecessary I/O operations. <p> A detailed proposal advocating the use of virtual memory techniques to trigger the transfer of persistent objects from disk to main memory first appeared in <ref> [Wilso90] </ref>. The basic approach described in [Wilso90] is termed "pointer swizzling at page fault time" since under this scheme all pointers on a page are converted from their disk format to normal virtual memory pointers (i.e. swizzled) by a page-fault handling routine before an application is given access to a newly <p> A detailed proposal advocating the use of virtual memory techniques to trigger the transfer of persistent objects from disk to main memory first appeared in <ref> [Wilso90] </ref>. The basic approach described in [Wilso90] is termed "pointer swizzling at page fault time" since under this scheme all pointers on a page are converted from their disk format to normal virtual memory pointers (i.e. swizzled) by a page-fault handling routine before an application is given access to a newly resident page. <p> In addition, pages of virtual memory are allocated to non-resident pages one step ahead of their actual use; they are access protected so that references to these pages will cause a page-fault to be signaled. The technique described in <ref> [Wilso90] </ref> allows programs to access persistent objects by dereferencing standard virtual memory pointers, eliminating the need for software residency checks. 9 The basic ideas presented in [Wilso90] were, at the same time, independently developed by the designers of ObjectStore [Objec90, Lamb91], a commercial OODBMS product from Object Design, Inc. <p> The technique described in <ref> [Wilso90] </ref> allows programs to access persistent objects by dereferencing standard virtual memory pointers, eliminating the need for software residency checks. 9 The basic ideas presented in [Wilso90] were, at the same time, independently developed by the designers of ObjectStore [Objec90, Lamb91], a commercial OODBMS product from Object Design, Inc. However, the implementation of ObjectStore, outlined briefly in [Objec90], differs in some interesting ways from the scheme described in [Wilso90]. <p> residency checks. 9 The basic ideas presented in <ref> [Wilso90] </ref> were, at the same time, independently developed by the designers of ObjectStore [Objec90, Lamb91], a commercial OODBMS product from Object Design, Inc. However, the implementation of ObjectStore, outlined briefly in [Objec90], differs in some interesting ways from the scheme described in [Wilso90]. The most notable differences lie in the way that pointer swizzling is implemented and in how pointers are represented on disk. <p> Under the approach outlined in [Objec90], pointers between persistent objects are stored on disk as virtual memory pointers instead of being stored in a different disk format as in <ref> [Wilso90] </ref>. In other words, in ObjectStore pointer fields in objects simply contain the value that they last were assigned when the page was resident in main memory. <p> The Texas [Singh92] and Cricket [Shek90] storage systems also use virtual memory techniques to implement persistence. Texas stores pointers on disk as 8-byte file offsets, and swizzles pointers to virtual addresses at fault time as described in <ref> [Wilso90] </ref>. <p> The swizzling scheme used in EPVM 2.0 is further characterized by the fact that it swizzles pointers one-at-a-time, as opposed to the approach described in <ref> [Wilso90] </ref> which swizzles them a page-at-a-time, and [Moss92] which swizzles pointers at the granularity of objects. The type of swizzling scheme used by EPVM 2.0 is referred to as an 'edge marking' scheme in [Moss92]. <p> CHAPTER 4 THE DESIGN OF QUICKSTORE This chapter describes the design of QuickStore, a memory-mapped storage system for persistent C++ that was built using the EXODUS Storage Manager (ESM) [Carey89]. QuickStore uses standard virtual memory hardware to trigger the transfer of persistent data from secondary storage into main memory <ref> [Wilso90] </ref>. The advantage of this approach is that access to in-memory persistent objects is just as efficient as access to transient objects, i.e. application programs access objects by dereferencing normal virtual memory pointers, with no overhead for software residency checks in contrast to [Moss92, Schuh90, White92]. <p> The Texas [Singh92] and Cricket [Shek90] storage systems have also used virtual memory techniques to support object faulting and swizzling. Texas stores pointers on disk as 8-byte file offsets, and swizzles pointers to virtual addresses as described in <ref> [Wilso90] </ref> at fault time. This means that whenever a page is faulted into memory, Texas must swizzle all of the pointers on the page. Currently, all data is stored in a single file (implemented on a raw Unix disk partition) in Texas [Singh92].

References-found: 38

