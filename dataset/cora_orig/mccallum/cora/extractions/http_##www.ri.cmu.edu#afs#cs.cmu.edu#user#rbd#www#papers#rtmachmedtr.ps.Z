URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/rbd/www/papers/rtmachmedtr.ps.Z
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/rbd/www/bib-tactus.html
Root-URL: 
Title: Performance Measurements of the Multimedia Testbed on Real-Time Mach  
Author: Roger B. Dannenberg, David B. Anderson, Tom Neuendorffer, Dean Rubine 
Note: This research was performed by the Carnegie Mellon Information Technology Center and supported by the IBM Corporation.  
Address: Pittsburgh, PA 15213-3890  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: April 1994  
Pubnum: CMU-CS-94-141  
Abstract: Multimedia has generated widespread interest in real-time support within general purpose operating systems. Multimedia also places new demands on operating systems for interprocess communication. The Multimedia Testbed is a set of applications that stress consistent low-latency response and efficient interprocess communication for large blocks of data. The Multimedia Testbed was ported to Real-Time Mach in the hopes of providing predictable low-latency response and, consequently, good synchronization and low jitter as required for multimedia applications. Our work compares the performance of Real-Time Mach with that of Mach 3.0. Although the fixed-priority scheduling of Real-Time Mach is a substantial improvement, user threads are still preempted by device drivers, and the overall real-time performance is not suitable for multimedia applications. We discuss areas where Real-Time Mach needs improvement. 
Abstract-found: 1
Intro-found: 1
Reference: [Accetta 86] <author> Accetta, M., R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, M. Young. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In Proc. of Summer Usenix. Usenix, </booktitle> <month> July, </month> <year> 1986. </year>
Reference-contexts: Our work assumes this microkernel approach, so we run all of our experiments with a Unix Server process providing a ``normal'' Unix environment. In a previous report [Dannenberg 93a] we described an evaluation of the Mach Microkernel <ref> [Accetta 86] </ref> as a base for multimedia support. For this evaluation, we ported multimedia software from other systems and measured their performance. Rather than just measure the timing of individual operations, we have focused on ``end-to-end'' performance measurements in a system configured for normal use.
Reference: [Dannenberg 93a] <author> Dannenberg, R. B., D. B. Anderson, T. Neuendorffer, D. Rubine, J. Zelenka. </author> <title> Performance Measurements of the Multimedia Testbed on Mach 3.0: Experience Writing Real-Time Device Drivers, Servers, </title> <institution> and Applications.Technical Report CMU-CS-93-205, School of Computer Science, Carnegie Mellon University, </institution> <month> July, </month> <year> 1993. </year>
Reference-contexts: This approach supports existing applications and can even allow multiple operating system interfaces to coexist on a single machine. Our work assumes this microkernel approach, so we run all of our experiments with a Unix Server process providing a ``normal'' Unix environment. In a previous report <ref> [Dannenberg 93a] </ref> we described an evaluation of the Mach Microkernel [Accetta 86] as a base for multimedia support. For this evaluation, we ported multimedia software from other systems and measured their performance. <p> We would like to stress again that the bottom line for real-time performance is the worst case. If nothing else, our measurements should serve as reminders of this fact and encourage designers to address all of the problem areas rather than a few. 2. Related Work Our previous work <ref> [Dannenberg 93a] </ref> measured the latency and IPC performance of Mach 3.0. The cited report describes other related work, including work at Fujitsu Laboratories using Mach 2.5 [Nakajima 91] and Mach 3.0 [Nakajima 92] with real-time extensions similar to those of RT Mach. <p> Latency Measurements From our Multimedia Testbed, we ported an application that outputs 100 MIDI messages per second. The details of this application and the drivers that support it were reported previously <ref> [Dannenberg 93a] </ref>. To summarize, a user-level thread waits for a message from a timer device. When the message arrives, the user-level thread transfers data to an output buffer and awakens an output thread. The output thread writes directly to a hardware output port, and the data appears as serial output.
Reference: [Dannenberg 93b] <author> Dannenberg, R. B., T. Neuendorffer, J. M. Newcomer, D. Rubine, D. Anderson. Tactus: </author> <title> Toolkit-level Support for Synchronized Interactive Multimedia. </title> <journal> Multimedia Systems Journal 1(2) </journal> <pages> 77-86, </pages> <year> 1993. </year>
Reference-contexts: Software Digital Video We used Tactus to implement a software digital video playback system. Since we have reported on the features of Tactus and its support for interactivity elsewhere <ref> [Dannenberg 93b, Rubine 94] </ref>, we will restrict this discussion to the performance of Tactus under RT Mach. The software digital video task is related to the previous scheduling task.
Reference: [Karplus 83] <author> Karplus, K., and Strong, A. </author> <title> Digital Synthesis of Plucked-String and Drum Timbres. </title> <journal> Computer Music Journal 7(2) </journal> <pages> 43-55, </pages> <month> Summer, </month> <year> 1983. </year>
Reference-contexts: The network driver introduces some especially large latencies into interrupt processing time. 5. Digital Audio Application Our digital audio application consists of a simple audio signal synthesis process controlled by MIDI input. The synthesis technique used is the Karplus-Strong plucked string algorithm <ref> [Karplus 83] </ref>, in which a table of samples is repeatedly read and output. As samples are output, adjacent samples are averaged and rewritten to the table. The averaging operation is effectively a low-pass filter, so on each pass the table is slightly different.
Reference: [Nakajima 91] <author> Nakajima, J., M. Yazaki, and H. Matsumoto. </author> <title> Multimedia/Realtime Extensions for the Mach Operating System. </title> <booktitle> In Proceedings of the Summer USENIX Conference, </booktitle> <pages> pages 183-198. </pages> <publisher> USENIX Association, </publisher> <year> 1991. </year>
Reference-contexts: Related Work Our previous work [Dannenberg 93a] measured the latency and IPC performance of Mach 3.0. The cited report describes other related work, including work at Fujitsu Laboratories using Mach 2.5 <ref> [Nakajima 91] </ref> and Mach 3.0 [Nakajima 92] with real-time extensions similar to those of RT Mach. A recent paper describes synchronization primitives for RT Mach [Nakajima 93]. This work would have been ideal for our applications, but it was not implemented until after our own simpler synchronization primitives.
Reference: [Nakajima 92] <author> Nakajima, J., M. Yazaki, and H. Matsumoto. </author> <title> Multimedia/Realtime Extensions for Mach 3.0. </title> <booktitle> In Usenix Workshop Proceedings on Micro-kernels and Other Kernel Architectures, </booktitle> <pages> pages 183-198. </pages> <publisher> USENIX Association, </publisher> <year> 1992. </year>
Reference-contexts: Related Work Our previous work [Dannenberg 93a] measured the latency and IPC performance of Mach 3.0. The cited report describes other related work, including work at Fujitsu Laboratories using Mach 2.5 [Nakajima 91] and Mach 3.0 <ref> [Nakajima 92] </ref> with real-time extensions similar to those of RT Mach. A recent paper describes synchronization primitives for RT Mach [Nakajima 93]. This work would have been ideal for our applications, but it was not implemented until after our own simpler synchronization primitives.
Reference: [Nakajima 93] <author> Nakajima, T., T. Kitayama, H. Arakawa, and H. Tokuda. </author> <title> Integrated Management of Priority Inversion in Real-Time Mach. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 120-130. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1993. </year>
Reference-contexts: The cited report describes other related work, including work at Fujitsu Laboratories using Mach 2.5 [Nakajima 91] and Mach 3.0 [Nakajima 92] with real-time extensions similar to those of RT Mach. A recent paper describes synchronization primitives for RT Mach <ref> [Nakajima 93] </ref>. This work would have been ideal for our applications, but it was not implemented until after our own simpler synchronization primitives. Later, when the RT Mach group released a system that supported synchronization with priority inheritance, we adopted their code. 3. <p> Recent work in RT Mach has gone into integrating communication with scheduling so that a client's priority can be handed off to the server <ref> [Nakajima 93] </ref>. Our video experiments indicate that this effort will not offer any real improvements for our applications, since our priorities are already correct. In other words, the problem is not with priority choice or scheduling policy, but with other factors.

References-found: 7

