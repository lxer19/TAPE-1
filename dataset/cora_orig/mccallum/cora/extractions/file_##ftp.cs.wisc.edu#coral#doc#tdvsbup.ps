URL: file://ftp.cs.wisc.edu/coral/doc/tdvsbup.ps
Refering-URL: http://www.cs.wisc.edu/coral/coral.papers.html
Root-URL: 
Email: fraghu,sudarshag@cs.wisc.edu  
Title: Top-Down vs. Bottom-Up Revisited  
Author: Raghu Ramakrishnan and S. Sudarshan 
Address: Madison, WI 53706, USA  
Affiliation: University of Wisconsin-Madison  
Abstract: Ullman ([Ull89a, Ull89b]) has shown that for the evaluation of safe Datalog programs, bottom-up evaluation using Magic Sets optimization has time complexity less than or equal to a particular top-down strategy, Queue-based Rule Goal Tree (QRGT) evaluation. This result has sometimes been incorrectly interpreted to mean that bottom-up evaluation beats top-down evaluation for evaluating Datalog programs|top-down strategies such as Prolog (which does no memoing, and uses last call optimization) can beat both QRGT and bottom-up evaluation on some Datalog programs. In this paper we compare a Prolog evaluation based on the WAM model (using last call optimization) with a bottom-up execution based on Magic Templates with Tail Recursion optimization ([Ros91]), and show the following: (1) Bottom-up evaluation makes no more inferences than Prolog for range-restricted programs. (2) For a restricted class of programs (which properly includes safe Datalog) the cost of bottom-up evaluation is never worse than a constant times the cost of Prolog evaluation (and can be much better than Prolog for many programs). Our other main contribution is to identify the factors that make the cost of an inference potentially more expensive in the bottom-up model in the general case; this leads to a clearer understanding of the potential implementation costs of memoing/set-oriented evaluations, and suggests an important direction for future research. 
Abstract-found: 1
Intro-found: 1
Reference: [Ban85] <author> Francois Bancilhon. </author> <title> Naive evaluation of recursively defined relations. </title> <editor> In Brodie and My-lopoulos, editors, </editor> <title> On Knowledge Base Management Systems | Integrating Database and AI Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Using rule R1 we can infer the facts q (b; c) and q (b; d). The use of this higher-order syntax is not essential for our discussion, but it makes the presentation concise. We assume that Semi-Naive evaluation <ref> [BR87a, Ban85] </ref> is used. In a bottom-up evaluation, a derivation is made as follows: previously derived facts are unified with each predicate in the body of a rule; the head of the instantiated rule is the fact that is derived. <p> The given program is first rewritten using Magic Templates with Tail Recursion (Section 4), and then by Semi-Naive rewriting <ref> [BR87a, Ban85] </ref>. Next the rewritten program is evaluated using Semi-Naive evaluation. We model the entire set of actions in a Semi-Naive bottom-up evaluation as a sequence of uses of facts to derive other facts.
Reference: [BM72] <author> R. S. Boyer and J. S. Moore. </author> <title> The sharing of structure in theorem-proving programs. </title> <booktitle> Computational Logic, </booktitle> <pages> pages 101-116, </pages> <year> 1972. </year>
Reference-contexts: Otherwise extensive copying would be required, and the cost of an inference would be linear in the size of the fact generated. Even if subterms are shared, extensive copying may be required if a variable in a shared non-ground structure is instantiated. Boyer and Moore's structure sharing scheme <ref> [BM72] </ref> can avoid this copying, but it has other overheads such as the time required to traverse a term. More importantly, it does not help with the next problem that we describe.
Reference: [BMSU86] <author> Francois Bancilhon, David Maier, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Cambridge, Massachusetts, </address> <month> March </month> <year> 1986. </year>
Reference: [BR87a] <author> I. Balbin and K. Ramamohanarao. </author> <title> A generalization of the differential approach to recursive query evaluation. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(3), </volume> <month> September </month> <year> 1987. </year>
Reference-contexts: Using rule R1 we can infer the facts q (b; c) and q (b; d). The use of this higher-order syntax is not essential for our discussion, but it makes the presentation concise. We assume that Semi-Naive evaluation <ref> [BR87a, Ban85] </ref> is used. In a bottom-up evaluation, a derivation is made as follows: previously derived facts are unified with each predicate in the body of a rule; the head of the instantiated rule is the fact that is derived. <p> The given program is first rewritten using Magic Templates with Tail Recursion (Section 4), and then by Semi-Naive rewriting <ref> [BR87a, Ban85] </ref>. Next the rewritten program is evaluated using Semi-Naive evaluation. We model the entire set of actions in a Semi-Naive bottom-up evaluation as a sequence of uses of facts to derive other facts.
Reference: [BR87b] <author> Catriel Beeri and Raghu Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference: [CD85] <author> J.H. Chang and A. M. Despain. </author> <title> Semi-intelligent backtracking of Prolog based on static data-dependency analysis. </title> <booktitle> In Proc. Symposium on Logic Programming, </booktitle> <pages> pages 10-21, </pages> <year> 1985. </year>
Reference-contexts: We refer to this step as the "generation of an answer" to the subgoal to which control returns. 2 For instance, we disallow Intelligent Backtracking (see eg. <ref> [CD85] </ref>). 3 5. On successfully getting an answer for a literal, if there are no more literals in the body of the rule Prolog fl returns from the rule to the calling subgoal as described in the previous step.
Reference: [CKW89] <author> Weidong Chen, Michael Kifer, and Davis S. Warren. Hilog: </author> <title> A first-order semantics for higher-order logic programming constructs. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 1090-1114, </pages> <year> 1989. </year>
Reference-contexts: The programs that are generated as a result of the rewriting we use are not necessarily Horn clause programs|they use higher order syntactic features that are part of Hilog <ref> [CKW89] </ref>.
Reference: [Got74] <author> E. Goto. </author> <title> Monocopy and associative algorithms in an extended lisp. </title> <type> Technical Report 74-03, </type> <institution> Information Science Laboratory, Univ. of Tokyo, </institution> <address> Tokyo, Japan, </address> <month> May </month> <year> 1974. </year>
Reference-contexts: show how to implement the operations of unification, indexing and checking of subsumption efficiently for the rewritten program P T , given that P with the query is NGSF Evaluable. 7.1 Unification Efficient unification of large terms that are ground can be achieved by a term representation called hash consing <ref> [Got74, SG76] </ref>. The idea behind this representation is to assign each term a unique identifier (ID)|the identifiers of two terms match if and only if they are identical. Thus unification of ground terms takes only constant time.
Reference: [MW88] <author> David Maier and David S. Warren. </author> <title> Computing With Logic. </title> <publisher> The Benjamin Cummings Publishing Company Inc., </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction The following example demonstrates that Prolog with last call optimization (see, eg. <ref> [MW88] </ref>) can beat bottom-up evaluation using Magic Sets/Magic Templates optimization ([RLK86, Sek89, BMSU86, BR87b, Ram88]) for some Datalog programs. Example 1.1 This example is from [Ros91]. <p> Definition 3.1 Prolog fl : We define Prolog fl evaluation as Prolog evaluation using the standard Warren abstract machine model (see eg. <ref> [MW88] </ref>), with last call optimization, but without using any other optimizations that affect the number of subgoals set up, or the number of answers generated. 2 We assume that Prolog fl evaluation proceeds till all answers are generated (i.e., Prolog fl does not stop at the request of the user), and <p> In each of these cases, there is no reason to return to rule R|Prolog fl can therefore change the return address so that the call to ?q n (a n ) returns directly, bypassing R. This optimization is called last call optimization (see for instance <ref> [MW88] </ref>). In particular, when q n is the same as p, i.e., when R is tail recursive, we may return directly past a large number of invocations of R.
Reference: [NR91] <author> Jeffrey F. Naughton and Raghu Ramakrishnan. </author> <title> Bottom-up evaluation of logic programs. </title> <editor> In J-L. Lassez, editor, </editor> <booktitle> Computational Logic: Essays in Honor of Alan Robinson. </booktitle> <year> 1991. </year>
Reference-contexts: However, bottom-up methods have the virtue of being complete (for positive Horn clause programs), and permit the use of a wide range of additional optimizations that we have not discussed (see, e.g., <ref> [NR91] </ref>).
Reference: [Ram88] <author> Raghu Ramakrishnan. </author> <title> Magic Templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: To achieve this effect for the case of bottom-up evaluation, Ross [Ros91] proposed a rewriting technique that extends the Magic Templates rewriting algorithm <ref> [Ram88] </ref>. For the convenience of the reader, we describe this technique in Section 4. Ross compares this technique with bottom-up evaluation, and proves that under some sufficient conditions it computes fewer facts than bottom-up evaluation. However Ross does not compare his technique with Prolog. <p> as a unification of a subgoal with the head of a rule, or generation of a subquery), and no more than 2 different derivations are mapped on to the same action of Prolog fl . 2 By taking last call optimization into account, this theorem extends earlier results of Ramakr-ishnan <ref> [Ram88] </ref> and Seki [Sek89] which compare the number of inferences made by bottom-up evaluation with the number of inferences made by specific top-down strategies. We observe again that the number of inferences is only one aspect of the cost of an evaluation strategy.
Reference: [RLK86] <author> J. Rohmer, R. Lescoeur, and J. M. Kerisit. </author> <title> The Alexander method | a technique for the processing of recursive axioms in deductive database queries. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 522-528, </pages> <year> 1986. </year>
Reference: [Ros91] <author> Kenneth Ross. </author> <title> Modular acyclicity and tail recursion in logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference-contexts: 1 Introduction The following example demonstrates that Prolog with last call optimization (see, eg. [MW88]) can beat bottom-up evaluation using Magic Sets/Magic Templates optimization ([RLK86, Sek89, BMSU86, BR87b, Ram88]) for some Datalog programs. Example 1.1 This example is from <ref> [Ros91] </ref>. <p> To achieve this effect for the case of bottom-up evaluation, Ross <ref> [Ros91] </ref> proposed a rewriting technique that extends the Magic Templates rewriting algorithm [Ram88]. For the convenience of the reader, we describe this technique in Section 4. Ross compares this technique with bottom-up evaluation, and proves that under some sufficient conditions it computes fewer facts than bottom-up evaluation. <p> If bottom-up evaluation is to perform as well as Prolog fl , it too must bypass the step of computing a fact for the head of rule R. This is precisely the optimization achieved by the program rewriting technique of Ross <ref> [Ros91] </ref>, which we describe in Section 4. 4 Magic Templates With Tail Recursion Ross ([Ros91]) proposed a modification to Magic Templates ([Ram88]).
Reference: [Sek89] <author> H. Seki. </author> <title> On the power of Alexander templates. </title> <booktitle> In Proc. of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 150-159, </pages> <year> 1989. </year> <month> 13 </month>
Reference-contexts: of a subgoal with the head of a rule, or generation of a subquery), and no more than 2 different derivations are mapped on to the same action of Prolog fl . 2 By taking last call optimization into account, this theorem extends earlier results of Ramakr-ishnan [Ram88] and Seki <ref> [Sek89] </ref> which compare the number of inferences made by bottom-up evaluation with the number of inferences made by specific top-down strategies. We observe again that the number of inferences is only one aspect of the cost of an evaluation strategy.
Reference: [SG76] <author> M. Sassa and E. Goto. </author> <title> A hashing method for fast set operations. </title> <journal> Information Processing Letters, </journal> <volume> 5(4) </volume> <pages> 31-34, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: show how to implement the operations of unification, indexing and checking of subsumption efficiently for the rewritten program P T , given that P with the query is NGSF Evaluable. 7.1 Unification Efficient unification of large terms that are ground can be achieved by a term representation called hash consing <ref> [Got74, SG76] </ref>. The idea behind this representation is to assign each term a unique identifier (ID)|the identifiers of two terms match if and only if they are identical. Thus unification of ground terms takes only constant time.
Reference: [Ull89a] <author> Jeffrey D. Ullman. </author> <title> Bottom-up beats top-down for datalog. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 140-149, </pages> <address> Philadelphia, Pennsylvania, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: We conjecture that for each predicate p we need construct no more indices than the number of adorned/rectified predicates generated from p by Ullman's techniques <ref> [Ull89a] </ref>. Our indexing technique allows us to get rid of the adornment step normally used with Magic sets rewriting, as well as the rectification step used by Ullman [Ull89a, Ull89b], without losing efficiency of unification or indexing of relations. <p> Our indexing technique allows us to get rid of the adornment step normally used with Magic sets rewriting, as well as the rectification step used by Ullman <ref> [Ull89a, Ull89b] </ref>, without losing efficiency of unification or indexing of relations. This simplifies some of our proofs, and can help to avoid repeated computation in some cases. 7.3 Subsumption Checking Subsumption checking is easy for relations with ground facts.
Reference: [Ull89b] <author> Jeffrey D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> volume 2. </volume> <publisher> Computer Science Press, </publisher> <year> 1989. </year> <month> 14 </month>
Reference-contexts: Our indexing technique allows us to get rid of the adornment step normally used with Magic sets rewriting, as well as the rectification step used by Ullman <ref> [Ull89a, Ull89b] </ref>, without losing efficiency of unification or indexing of relations. This simplifies some of our proofs, and can help to avoid repeated computation in some cases. 7.3 Subsumption Checking Subsumption checking is easy for relations with ground facts.
References-found: 17

