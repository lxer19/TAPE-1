URL: ftp://ftp.inria.fr/INRIA/publication/publi-ps-gz/RR/RR-2085.ps.gz
Refering-URL: http://www.cs.umd.edu/~keleher/bib/dsmbiblio/node2.html
Root-URL: 
Title: An Efficient Implementation of Sequentially Consistent Distributed Shared Memories  PROGRAMME 1 Architectures paralleles, bases de donnees,  
Author: M. Mizuno, M. Raynal, G. Singh and M.L. Neilsen reseaux 
Date: 2085 Novembre 1993  
Note: N  
Affiliation: INSTITUT NATIONAL DE RECHERCHE EN INFORMATIQUE ET AUTOMATIQUE  et systemes distribues  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Afek, Y., Brown, G., and Merritt, M. </author> <title> Lazy caching. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 182-205, </pages> <year> 1993. </year>
Reference-contexts: Note that the real time order of the operations in execution can be different from their order in this sequence. For this reason, in this paper we sometimes refer to a sequential order of operations as an "illusory sequential history." Three well known protocols to implement sequential consistency are <ref> [1, 3, 4] </ref>. These protocols assume a system model that consists of several processors with local memory connected via a network. In order to guarantee a unique illusory sequential history to appear to all the processors, all three protocols rely on atomic broadcast to synchronize write operations.
Reference: [2] <author> Ahamad, M., Hutto, P., and John, R. </author> <title> Implementing and programming causal distributed shared memory. </title> <booktitle> In Proceedings of the IEEE Int'l Conference on Distributed Computing Systems, </booktitle> <pages> pages 274-281, </pages> <year> 1991. </year>
Reference-contexts: Now, we will demonstrate that CR2 generalizes the data structures used in our protocol and the protocol proposed by Ahamad et al. <ref> [2] </ref> to capture causal relations among write and read operations. We can view array Causal used by the protocol described in Section 3.3 as CR2 being collapsed into a one-dimensional array, such that Causal [x] = P j2Processor Range CR2 [j; x], for x 2 Object Range. <p> This is possible by assigning system wide version numbers to all write operations on an object, instead of processor-level version numbers. Ahamad et al. proposed a protocol for a weaker notion of consistency than sequential consistency, called causal consistency <ref> [2] </ref>. The protocol maintains a one-dimensional array V T [P rocessor Range]. We can view V T as CR2 being collapsed into one-dimensional array such that V T [j] = P x2Object Range CR2 [j; x], for j 2 P rocessor Range.
Reference: [3] <author> Attiya, H. and Welch, J. </author> <title> Sequential consistency versus linearizability. </title> <booktitle> In Proceedings of the 3rd ACM Sym. Parallel Algorithms and Architectures, </booktitle> <pages> pages 304-315, </pages> <year> 1991. </year>
Reference-contexts: Note that the real time order of the operations in execution can be different from their order in this sequence. For this reason, in this paper we sometimes refer to a sequential order of operations as an "illusory sequential history." Three well known protocols to implement sequential consistency are <ref> [1, 3, 4] </ref>. These protocols assume a system model that consists of several processors with local memory connected via a network. In order to guarantee a unique illusory sequential history to appear to all the processors, all three protocols rely on atomic broadcast to synchronize write operations.
Reference: [4] <author> Brown, G. </author> <title> Asynchronous multicaches. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 31-36, </pages> <year> 1990. </year>
Reference-contexts: Note that the real time order of the operations in execution can be different from their order in this sequence. For this reason, in this paper we sometimes refer to a sequential order of operations as an "illusory sequential history." Three well known protocols to implement sequential consistency are <ref> [1, 3, 4] </ref>. These protocols assume a system model that consists of several processors with local memory connected via a network. In order to guarantee a unique illusory sequential history to appear to all the processors, all three protocols rely on atomic broadcast to synchronize write operations.
Reference: [5] <author> C.J. Fidge. </author> <title> Logical time in distributed computing systems. </title> <journal> IEEE Computer, </journal> <volume> 24(8) </volume> <pages> 28-33, </pages> <year> 1991. </year>
Reference-contexts: In message passing systems, vector clocks are often used to identify causal relations among events, each of which is an execution of a send, receive, or internal operation <ref> [5, 8] </ref>. A vector clock consists of a set of local clocks, one for each processor. In an implementation of a shared memory system, we have to order operations on each object. For this purpose, we can employ a separate vector clock for each object.
Reference: [6] <author> Lamport, L. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <note> C-28:690-691, 1979. RR n-2085 14 M. Mizuno and M. Raynal </note>
Reference-contexts: Traditional data consistency protocols require that all copies of an object to be identical at all times [7]. However, this requirement may be unnecessarily stringent for many applications. Lamport proposed a relaxed form of consistency, called sequential consistency <ref> [6] </ref>, which allows more concurrency than the traditional notion of consistency and still can be used in many applications.
Reference: [7] <author> Li, K. and Hudak, P. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(4) </volume> <pages> 321-359, </pages> <year> 1989. </year>
Reference-contexts: In such systems, modification to individual copies must be handled carefully to avoid inconsistent system states. Protocols which manage multiple copies in a consistent manner are called data consistency protocols. Traditional data consistency protocols require that all copies of an object to be identical at all times <ref> [7] </ref>. However, this requirement may be unnecessarily stringent for many applications. Lamport proposed a relaxed form of consistency, called sequential consistency [6], which allows more concurrency than the traditional notion of consistency and still can be used in many applications.
Reference: [8] <author> F. Mattern. </author> <title> Virtual time and global states of distributed systems. </title> <editor> In Cosnard, Quinton, Raynal, and Robert, editors, </editor> <booktitle> International Workshop on Parallel and Distributed Algorithms, </booktitle> <pages> pages 215-226, </pages> <publisher> North-Holland, </publisher> <address> Bonas, France, </address> <year> 1989. </year>
Reference-contexts: In message passing systems, vector clocks are often used to identify causal relations among events, each of which is an execution of a send, receive, or internal operation <ref> [5, 8] </ref>. A vector clock consists of a set of local clocks, one for each processor. In an implementation of a shared memory system, we have to order operations on each object. For this purpose, we can employ a separate vector clock for each object.
Reference: [9] <author> Raynal, M. and Mizuno, M. </author> <title> How to find his way in the jungle of consistency criteria for distributed shared memories (or how to escape from Minos' labyrinth). </title> <booktitle> In Proceedings of International Conference on Future Trends of Distributed Computing Systems, </booktitle> <address> Lisboa (Portugal), </address> <year> 1993. </year> <title> Inria Distributed Shared Memories 15 </title>
Reference-contexts: An implementation of the protocol is currently in progress on a distributed memory parallel machine. Besides sequential consistency, many other consistency criteria have been proposed for distributed shared memory systems. Readers will find a survey on these criteria in <ref> [9] </ref>.
References-found: 9

