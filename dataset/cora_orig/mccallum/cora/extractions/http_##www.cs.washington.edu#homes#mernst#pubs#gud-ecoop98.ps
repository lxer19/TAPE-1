URL: http://www.cs.washington.edu/homes/mernst/pubs/gud-ecoop98.ps
Refering-URL: http://www.cs.washington.edu/homes/mernst/pubs/gud-ecoop98-abstract.html
Root-URL: 
Title: Predicate Dispatching: A Unified Theory of Dispatch  
Author: Michael Ernst, Craig Kaplan, and Craig Chambers 
Abstract: Department of Computer Science and Engineering University of Washington Seattle, WA, USA 98195-2350 fmernst;csk;chambersg@cs.washington.edu http://www.cs.washington.edu/research/projects/cecil/ This paper appears in ECOOP '98, the 12th European Conference on Object Oriented Programming, Brussels, Belgium, July 20-24, 1998, pp. 186-211. Abstract. Predicate dispatching generalizes previous method dispatch mechanisms by permitting arbitrary predicates to control method applicability and by using logical implication between predicates as the overriding relationship. The method selected to handle a message send can depend not just on the classes of the arguments, as in ordinary object-oriented dispatch, but also on the classes of subcomponents, on an argument's state, and on relationships between objects. This simple mechanism subsumes and extends object-oriented single and multiple dispatch, ML-style pattern matching, predicate classes, and classifiers, which can all be regarded as syntactic sugar for predicate dispatching. This paper introduces predicate dispatching, gives motivating examples, and presents its static and dynamic semantics. An implementation of predicate dispatching is available.
Abstract-found: 1
Intro-found: 1
Reference: [AGS94] <author> Eric Amiel, Olivier Gruber, and Eric Simon. </author> <title> Optimizing multi-method dispatch using compressed dispatch tables. </title> <booktitle> In Proceedings OOPSLA '94, </booktitle> <pages> pages 244-258, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year>
Reference: [BKK + 86] <author> Daniel G. Bobrow, Ken Kahn, Gregor Kiczales, Larry Masinter, Mark Ste-fik, and Frank Zdybel. Commonloops: </author> <title> Merging lisp and object-oriented programming. </title> <booktitle> In Proceedings OOPSLA '86, </booktitle> <pages> pages 17-29, </pages> <month> November </month> <year> 1986. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 21, number 11. </volume>
Reference: [Cha92] <author> Craig Chambers. </author> <title> Object-oriented multi-methods in Cecil. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings ECOOP '92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 33-56, </pages> <address> Utrecht, The Netherlands, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference: [Cha93a] <author> Craig Chambers. </author> <title> The Cecil language: Specification and rationale. </title> <type> Technical Report UW-CSE-93-03-05, </type> <institution> Department of Computer Science and Engineering. University of Washington, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Multiple dispatching [BKK + 86,Cha92] enables testing the classes of all of the arguments. One method overrides another if its specializer classes are subclasses of the other's, using either lexicographic (CLOS [Ste90]) or pointwise (Cecil <ref> [Cha93a] </ref>) ordering. Predicate classes [Cha93b] automatically classify an object of class A as an instance of virtual subclass B (a subclass of A) whenever B's predicate (an arbitrary expression typically testing the runtime state of an object) is true.
Reference: [Cha93b] <author> Craig Chambers. </author> <title> Predicate classes. </title> <editor> In O. Nierstrasz, editor, </editor> <booktitle> Proceedings ECOOP '93, </booktitle> <volume> LNCS 707, </volume> <pages> pages 268-296, </pages> <address> Kaiserslautern, Germany, July 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Multiple dispatching [BKK + 86,Cha92] enables testing the classes of all of the arguments. One method overrides another if its specializer classes are subclasses of the other's, using either lexicographic (CLOS [Ste90]) or pointwise (Cecil [Cha93a]) ordering. Predicate classes <ref> [Cha93b] </ref> automatically classify an object of class A as an instance of virtual subclass B (a subclass of A) whenever B's predicate (an arbitrary expression typically testing the runtime state of an object) is true. <p> Multiply-dispatched object-oriented languages have more challenging problems in implementation [KR89,CTK94,AGS94] and typechecking [CL95], and predicate dispatching in its unrestricted form shares these challenges. Predicate classes <ref> [Cha93b] </ref> are an earlier extension of object-oriented dispatching to include arbitrary boolean predicates. A predicate class which inherits from class A and has an associated predicate expression guard would be modeled as a named predicate abstraction that tests @A and guard .
Reference: [CL95] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and modules for multi-methods. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(6) </volume> <pages> 805-843, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: If inheritance and subtyping are separate notions, then the predicates become more complex. Our typechecking need not test that methods conform to signatures, unlike previous work on typechecking multimethods <ref> [CL95] </ref>. In predicate dispatching, a method's formal argument has two distinct types: the "external" type derived from the signature declaration, and the possibly finer "internal" type guaranteed by successful evaluation of the method's predicate. <p> Singly-dispatched object-oriented languages have efficient method lookup algorithms and separate typechecking, which depend crucially on the absence of any separate modules that dispatch on other argument positions. Multiply-dispatched object-oriented languages have more challenging problems in implementation [KR89,CTK94,AGS94] and typechecking <ref> [CL95] </ref>, and predicate dispatching in its unrestricted form shares these challenges. Predicate classes [Cha93b] are an earlier extension of object-oriented dispatching to include arbitrary boolean predicates. <p> Similarly, separate typechecking of collections of predicated methods will build upon current work to develop modular and incremental methods for typechecking multimethods <ref> [CL95] </ref>. Acknowledgments Todd Millstein, Vassily Litvinov, Wilson Hsieh, David Grove, and the anonymous referees made helpful comments on a draft of this paper.
Reference: [CTK94] <author> Weimin Chen, Volker Turau, and Wolfgang Klas. </author> <title> Efficient dynamic lookup strategy for multi-methods. </title> <editor> In M. Tokoro and R. Pareschi, editors, </editor> <booktitle> Proceedings ECOOP '94, </booktitle> <volume> LNCS 821, </volume> <pages> pages 408-431, </pages> <address> Bologna, Italy, July 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference: [HHM90a] <author> J. Hamer, J.G. Hosking, and W.B. Mugridge. </author> <title> A method for integrating classification within an object-oriented environment. </title> <note> Technical Report Auck-land Computer Science Report No. 48, </note> <institution> Department of Computer Science, University of Auckland, </institution> <month> October </month> <year> 1990. </year>
Reference: [HHM90b] <author> J.G. Hosking, J. Hamer, and W.B. Mugridge. </author> <title> Integrating functional and object-oriented programming. </title> <booktitle> In Technology of Object-Oriented Languages and Systems TOOLS 3, </booktitle> <pages> pages 345-355, </pages> <address> Sydney, </address> <year> 1990. </year>
Reference-contexts: This creation of virtual class hierarchies makes method dispatching applicable even 186 in cases where the effective class of an object may change over time. Classi--fiers <ref> [HHM90b] </ref> and modes [Tai93] are similar mechanisms for reclassifying an object into one of a number of subclasses based on a case-statement-like test of arbitrary boolean conditions. Pattern matching (as in ML [MTH90]) bases applicability tests on the run-time datatype constructor tags of the arguments and their subcomponents. <p> Additionally, a single object can be classified in multiple independent ways by different predicate abstractions without being forced to define all the possible conjunctions of independent predicates as explicit classes, relieving some of the problems associated with a mix-in style of class organization [HHM90b,HHM90a]. 2.5 Classifiers Classifiers <ref> [HHM90b] </ref> are a convenient syntax for imposing a linear ordering on a collection of predicates, ensuring mutual exclusion. They combine the state testing of predicate classes and the total ordering of pattern matching.
Reference: [HJW + 92] <author> Paul Hudak, Simon Peyton Jones, Philip Wadler, Brian Boutel, Jon Fairbairn, Joseph Fasel, Maria Guzman, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Will Partain, and John Peterson. </author> <title> Report on the programming language Haskell, version 1.2. </title> <journal> SIG-PLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Pattern matching (as in ML [MTH90]) bases applicability tests on the run-time datatype constructor tags of the arguments and their subcomponents. As with classifiers and modes, textual ordering determines overriding. Some languages, such as Haskell <ref> [HJW + 92] </ref>, allow arbitrary boolean guards to accompany patterns, restricting applicability. Views [Wad87] extend pattern matching to abstract data types by enabling them to offer interfaces like various concrete datatypes. Predicate dispatching integrates, generalizes, and provides a uniform interface to these similar but previously incomparable mechanisms. <p> Mode reselection can be done either explicitly at the end of each method or implicitly after each assignment using a declaratively specified classification. 5.2 Pattern matching approaches Predicate dispatching supports many of the facilities found in pattern matching as in ML [MTH90] and Haskell <ref> [HJW + 92] </ref>, including tests over arbitrary nested structure, binding of names to subcomponents, and arbitrary boolean guard expressions.
Reference: [KM89] <author> Paris C. Kanellakis and John C. Mitchell. </author> <title> Polymorphic unification and ML typing. </title> <booktitle> In ACM-SIGPLAN ACM-SIGACT, editor, Conference Record of the 16th Annual ACM Symposium on Principles of Programming Languages (POPL '89), </booktitle> <pages> pages 105-115, </pages> <address> Austin, TX, USA, </address> <month> January </month> <year> 1989. </year> <note> ACM Press. </note>
Reference-contexts: Inline expansion of predicate abstractions similarly contributes to this blowup. As with ML typechecking <ref> [KM89] </ref>, which is exponential in the worst case but linear in practice, we anticipate that predicates leading to exponential behavior will be rare. In what follows, we consider two expressions identical if, after canonicaliza-tion, they have the same abstract syntax tree.
Reference: [KR89] <author> Gregor Kiczales and Luis Rodriguez. </author> <title> Efficient method dispatch in PCL. </title> <type> Technical Report SSL 89-95, </type> <institution> Xerox PARC Systems Sciences Laboratory, </institution> <year> 1989. </year>
Reference: [MHH91] <author> Warwick B. Mugridge, John Hamer, and John G. Hosking. </author> <title> Multi-methods in a statically-typed programming language. </title> <editor> In P. America, editor, </editor> <booktitle> Proceedings ECOOP '91, </booktitle> <volume> LNCS 512, </volume> <pages> pages 307-324, </pages> <address> Geneva, Switzerland, July 15-19 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year> <month> 205 </month>
Reference-contexts: Classi--fiers [HHM90b] and modes [Tai93] are similar mechanisms for reclassifying an object into one of a number of subclasses based on a case-statement-like test of arbitrary boolean conditions. Pattern matching (as in ML <ref> [MTH90] </ref>) bases applicability tests on the run-time datatype constructor tags of the arguments and their subcomponents. As with classifiers and modes, textual ordering determines overriding. Some languages, such as Haskell [HJW + 92], allow arbitrary boolean guards to accompany patterns, restricting applicability. <p> Mode reselection can be done either explicitly at the end of each method or implicitly after each assignment using a declaratively specified classification. 5.2 Pattern matching approaches Predicate dispatching supports many of the facilities found in pattern matching as in ML <ref> [MTH90] </ref> and Haskell [HJW + 92], including tests over arbitrary nested structure, binding of names to subcomponents, and arbitrary boolean guard expressions.
Reference: [OW97] <author> Martin Odersky and Philip Wadler. </author> <title> Pizza into Java: Translating theory into practice. </title> <booktitle> In Conference Record of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 146-159, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: Views must be isomorphisms, which enables equational reasoning over them; by contrast, named predicate abstractions provide conditional views of an object without requiring the presence of both in and out views. Pizza <ref> [OW97] </ref> supports both algebraic datatypes (and associated pattern matching) and object-oriented dispatching, but the two mechanisms are largely distinct. The authors argue that datatypes are good for fixed numbers of representations with extensible operations, while classes are good for a fixed set of operations with extensible representations.
Reference: [Ste90] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1990. </year> <note> Second edition. </note>
Reference-contexts: Multiple dispatching [BKK + 86,Cha92] enables testing the classes of all of the arguments. One method overrides another if its specializer classes are subclasses of the other's, using either lexicographic (CLOS <ref> [Ste90] </ref>) or pointwise (Cecil [Cha93a]) ordering. Predicate classes [Cha93b] automatically classify an object of class A as an instance of virtual subclass B (a subclass of A) whenever B's predicate (an arbitrary expression typically testing the runtime state of an object) is true. <p> There are several unsatisfactory alternatives to the use of implication to determine overriding relationships. ML-style pattern matching requires all cases to be written in one place and put in a particular total order, resolving ambiguities in favor of the first successfully matching pattern. Likewise, a lexicographic ordering for multimethods <ref> [Ste90] </ref> is error-prone and unnatural, and programmers are not warned of potential ambiguities.
Reference: [Tai93] <author> Antero Taivalsaari. </author> <title> Object-oriented programming with modes. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 25-32, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: This creation of virtual class hierarchies makes method dispatching applicable even 186 in cases where the effective class of an object may change over time. Classi--fiers [HHM90b] and modes <ref> [Tai93] </ref> are similar mechanisms for reclassifying an object into one of a number of subclasses based on a case-statement-like test of arbitrary boolean conditions. Pattern matching (as in ML [MTH90]) bases applicability tests on the run-time datatype constructor tags of the arguments and their subcomponents. <p> Kea is a purely functional language, so classifiers do not need to consider the semantics of reclassifying objects when the values of predicates change; predicate dispatching addresses this issue by (conceptually) performing reclassification as needed as part of message dispatching. Modes <ref> [Tai93] </ref> are another mechanism for adding dynamic reclassification of a class into a subclass. Unlike predicate classes and classifiers, the modes of a class are not first-class subclasses but rather internal components of a class that cannot be extended externally and that cannot exploit inheritance to factor shared code.
Reference: [Wad87] <author> Philip Wadler. </author> <title> Views: A way for pattern matching to cohabit with data abstraction. </title> <booktitle> In Proceedings of the Fourteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 307-313, </pages> <address> Munich, Germany, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: Pattern matching (as in ML [MTH90]) bases applicability tests on the run-time datatype constructor tags of the arguments and their subcomponents. As with classifiers and modes, textual ordering determines overriding. Some languages, such as Haskell [HJW + 92], allow arbitrary boolean guards to accompany patterns, restricting applicability. Views <ref> [Wad87] </ref> extend pattern matching to abstract data types by enabling them to offer interfaces like various concrete datatypes. Predicate dispatching integrates, generalizes, and provides a uniform interface to these similar but previously incomparable mechanisms. <p> Finally, new methods can be added to existing generic functions without changing any existing code, while new patterns can be added to a function only by modifying it. Views <ref> [Wad87] </ref> extend pattern matching to abstract data types by allowing an abstract data type to offer a number of views of itself as a concrete datatype, over which pattern matching is defined.
Reference: [Zel93] <author> John M. Zelle. </author> <title> Learning search-control heuristics for logic programs: Applications tospeed-up learning and languageacquisitions. </title> <type> Technical Report AI93-200, </type> <institution> University of Texas, Austin, </institution> <month> May 1, </month> <year> 1993. </year>
Reference-contexts: If a more specific one is true, then the less specific one is certain to be satisfied; however, such satisfaction is irrelevant since the more specific predicate will be chosen. Third, clauses and methods can be reordered to succeed or fail more quickly, as in some Prolog implementations <ref> [Zel93] </ref>. 3.2 Static semantics and typechecking The operational model of predicate dispatch described in Sect. 3.1 can raise a run-time exception at a message send if no method is applicable or if no applicable method overrides all the others.
References-found: 19

