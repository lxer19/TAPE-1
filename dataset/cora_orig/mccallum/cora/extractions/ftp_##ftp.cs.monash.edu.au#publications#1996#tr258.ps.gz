URL: ftp://ftp.cs.monash.edu.au/publications/1996/tr258.ps.gz
Refering-URL: http://www.cs.monash.edu.au/~kelly/publications/group.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Optimizing Compilation of Constraint Logic Programming Languages  
Author: Andrew D. Kelly Andrew Macdonald Kim Marriott Peter J. Stuckey Roland H.C. Yap 
Abstract: Constraint Logic Programming (CLP) is an innovation in programming language design. CLP languages extend logic programming by allowing constraints from different domains such as real numbers or Boolean functions. Building efficient compilers and interpreters for CLP languages has proved difficult due to the expensive constraint solving algorithms required for the domains. We present a highly optimizing compiler for CLP(R) a CLP language which extends Prolog by allowing linear arithmetic constraints. This compiler overcomes many of the efficiency problems of current implementations. The main innovation in the compiler is the incorporation of powerful program optimizations and associated sophisticated global analyses which determine information about various kinds of interaction among constraints. The optimizations presented in this paper are: reordering of constraints, bypass of the constraint solver, splitting and dead code elimination, future redundancy, removal of redundant variables, and no fail constraints. The six program optimizations are designed to remove the overhead of constraint solving when possible and keep the number of constraints in the store as small as possible. We present the performance of our compiler on a number of benchmark programs. Our results indicate that the highly optimizing compiler leads to a threefold increase in execution speed and one third decrease in space requirements when compared against the released version of the CLP(R) compiler (v1.2).
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. At-Kaci. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The optimizing compiler has four main components (see Figure 1): the optimizer which performs the optimizations; a global analyzer and a constraint solver which provide information to guide the optimizer; and a code generator which produces CLAM abstract machine code. CLAM is an extension of the Prolog WAM <ref> [1] </ref> architecture which supports calls to constraint solvers. The main complication in the design of the optimizer is the number of different optimizations. This is exacerbated by non-trivial interaction between the optimizations.
Reference: [2] <author> T. Armstrong, K. Marriott, P. Schachte and H. Stndergaard. </author> <title> Boolean functions for dependency analysis: Algebraic properties and efficient representation. </title> <editor> In B. Le Charlier, editor, </editor> <title> Static Analysis: </title> <booktitle> Proc. First Int. Symp. (Lecture Notes in Computer Science 864), </booktitle> <pages> 266-280. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: If this program is analyzed for the class of calls in which the first argument is ground, that is bound to a number, then the following annotated program results. The description domain consists of Boolean functions which capture groundness information about variables and definite dependencies among variables <ref> [2] </ref>. For example the function N ^ (F $ F2) indicates that the variable N is ground, and that if F is ever ground, then so is F2 and vice versa.
Reference: [3] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation and application to logic programs. </title> <journal> Journal of Logic Programming 13 (2&3): </journal> <pages> 103-179, </pages> <year> 1992. </year> <month> 13 </month>
Reference-contexts: The analyzer performs global analysis of programs, that is, program information (descriptions) is inferred about the calls "between" different rules of the program as well as inferring the local information "within" each rule. The global analysis is based on abstract interpretation of logic programs and constraint logic programs <ref> [3, 14, 15] </ref> in which operations in the execution of the goal are mimicked by abstract operations on the domain of descriptions, (the analyses). The analyzer has two novel features.
Reference: [4] <author> J. Darlington, Y. Guo and H. </author> <title> Pull. A new perspective on integrating functional and logic languages. </title> <booktitle> Proc. Fifth Generation Computer Systems, </booktitle> <pages> 682-693. </pages> <address> Tokyo, </address> <year> 1992. </year>
Reference-contexts: optimizations and compiler design are specific to CLP (R) , the general ideas behind the optimizations and compiler design are applicable to any CLP language and also to other constraint programming paradigms such as concurrent constraint programming languages [19], constraint databases [7], constraint imperative languages [5] and constraint functional languages <ref> [4] </ref>. The main contributions of this paper are: * A general design for optimizing compilers of CLP languages.
Reference: [5] <author> B. Freeman-Benson and A. Borning. </author> <title> The design and implementation of Kaleidoscope'90: A constraint imperative programming language. </title> <booktitle> Proc. IEEE Int. Conf. Computer Languages, </booktitle> <pages> 174-180. </pages> <publisher> IEEE Computer Soc. Press, </publisher> <year> 1992. </year>
Reference-contexts: Although some details of the optimizations and compiler design are specific to CLP (R) , the general ideas behind the optimizations and compiler design are applicable to any CLP language and also to other constraint programming paradigms such as concurrent constraint programming languages [19], constraint databases [7], constraint imperative languages <ref> [5] </ref> and constraint functional languages [4]. The main contributions of this paper are: * A general design for optimizing compilers of CLP languages.
Reference: [6] <author> M. Hermenegildo, G. Peubla, K. Marriott, and P. Stuckey. </author> <title> Incremental Analysis of Logic Programs. </title> <booktitle> In Proc. of the Int. Conf. on Logic Programming, </booktitle> <address> Tokyo, Japan, </address> <publisher> MIT Press, </publisher> <month> June </month> <year> 1995, </year> <pages> 797-814. </pages>
Reference-contexts: When rules are modified, then from correctness of the transformations, the analyzer knows that all success pattern information is still correct, meaning that in practice little additional analysis is needed. Details about the algorithms used can be found in <ref> [6] </ref>. Details of the description domains are deliberately kept insulated from the optimizer so as to make it easier to change these. The most difficult condition to analyze for is deadness. This is because not being textually alive may not mean a variable is dead, for two reasons.
Reference: [7] <author> P.C. Kanellakis, G.M. Kuper and P. Revesz. </author> <title> Constraint query languages. </title> <booktitle> Proc. ACM Symp. Principles of Database Systems, </booktitle> <pages> 299-313, </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Although some details of the optimizations and compiler design are specific to CLP (R) , the general ideas behind the optimizations and compiler design are applicable to any CLP language and also to other constraint programming paradigms such as concurrent constraint programming languages [19], constraint databases <ref> [7] </ref>, constraint imperative languages [5] and constraint functional languages [4]. The main contributions of this paper are: * A general design for optimizing compilers of CLP languages.
Reference: [8] <author> A. Kelly, A. Macdonald, K. Marriott, H. Sondergaard, P. Stuckey, and R. Yap. </author> <title> An Optimizing Compiler for CLP(R). </title> <booktitle> In Proc of the First Int. Conf. on Principles and Practices of Constraint Programming, </booktitle> <publisher> LNCS 976, Springer-Verlag, </publisher> <pages> 222-239, </pages> <year> 1995. </year>
Reference-contexts: Indeed, in some sense the optimizing compiler can be viewed as an efficient program synthesizer as it takes an executable logical specification of the program and transforms this into specialized CLIC programs which handle different types of goals. This paper continues our work on the implementation of CLP (R) <ref> [10, 9, 13, 8] </ref> and on preliminary studies of each of the optimizations considered here [11, 9, 17, 13, 16]. <p> The only other paper which describes an optimizing compiler for a CLP language, that we are aware of, is <ref> [8] </ref> which describes a preliminary version of this compiler which only provided three of the six optimizations used in the current compiler. The main difference from this earlier work is that analysis and optimization were each performed in a single static phase.
Reference: [9] <author> J. Jaffar, S. Michaylov, P. Stuckey and R. Yap. </author> <title> An abstract machine for CLP(R). </title> <booktitle> Proc. ACM Conf. Programming Language Design and Implementation, </booktitle> <pages> 128-139. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: Indeed, in some sense the optimizing compiler can be viewed as an efficient program synthesizer as it takes an executable logical specification of the program and transforms this into specialized CLIC programs which handle different types of goals. This paper continues our work on the implementation of CLP (R) <ref> [10, 9, 13, 8] </ref> and on preliminary studies of each of the optimizations considered here [11, 9, 17, 13, 16]. <p> This paper continues our work on the implementation of CLP (R) [10, 9, 13, 8] and on preliminary studies of each of the optimizations considered here <ref> [11, 9, 17, 13, 16] </ref>. The only other paper which describes an optimizing compiler for a CLP language, that we are aware of, is [8] which describes a preliminary version of this compiler which only provided three of the six optimizations used in the current compiler. <p> If the constraint is made redundant by each such combination of constraints (which is determined using the constraint solver) it is marked as add remove. 1 Code Generator The code generator maps the CLIC code into CLAM <ref> [9] </ref> instructions which are executed by the CLAM emulator. The existing CLP (R) compiler also produced CLAM code, but used only a core set. The new compiler makes use of extended CLAM instructions for achieving the optimizations that are made possible by global analysis.
Reference: [10] <author> J. Jaffar, S. Michaylov, P. Stuckey and R. Yap. </author> <title> The CLP(R) language and system. </title> <booktitle> ACM Transactions on Programming Languages and Systems 14 (3): </booktitle> <pages> 339-395, </pages> <year> 1992. </year>
Reference-contexts: Indeed, in some sense the optimizing compiler can be viewed as an efficient program synthesizer as it takes an executable logical specification of the program and transforms this into specialized CLIC programs which handle different types of goals. This paper continues our work on the implementation of CLP (R) <ref> [10, 9, 13, 8] </ref> and on preliminary studies of each of the optimizations considered here [11, 9, 17, 13, 16].
Reference: [11] <author> N. Jtrgensen, K. Marriott and S. Michaylov. </author> <title> Some global compile-time optimizations for CLP(R). </title> <editor> In V. Saraswat and K. Ueda, editors, </editor> <booktitle> Logic Programming: Proc. 1991 Int. Symp., </booktitle> <pages> 420-434. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: This paper continues our work on the implementation of CLP (R) [10, 9, 13, 8] and on preliminary studies of each of the optimizations considered here <ref> [11, 9, 17, 13, 16] </ref>. The only other paper which describes an optimizing compiler for a CLP language, that we are aware of, is [8] which describes a preliminary version of this compiler which only provided three of the six optimizations used in the current compiler.
Reference: [12] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental evaluation of a generic abstract interpretation algorithm for Prolog. </title> <booktitle> ACM Transactions on Programming Languages and Systems 16 (1): </booktitle> <pages> 35-101, </pages> <year> 1994. </year>
Reference-contexts: In this section we describe in more detail the global analyzer, optimizer and code generator. The Analyzer To facilitate the rich variety of analyses required in the compiler, the analyzer is a generic tool like other analysis engines, such as PLAI [18] and GAIA <ref> [12] </ref> developed for Prolog. Generic analyses engines are not only designed to do many different analyses but also to allow for the easy addition of new analyses. The core of the analyzer is an algorithm for efficient fixpoint computation.
Reference: [13] <author> A. Macdonald, P. Stuckey and R. Yap. </author> <title> Redundancy of variables in CLP(R). </title> <booktitle> In Logic Programming: Proc. 1993 Int. Symp., </booktitle> <pages> 75-93. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Indeed, in some sense the optimizing compiler can be viewed as an efficient program synthesizer as it takes an executable logical specification of the program and transforms this into specialized CLIC programs which handle different types of goals. This paper continues our work on the implementation of CLP (R) <ref> [10, 9, 13, 8] </ref> and on preliminary studies of each of the optimizations considered here [11, 9, 17, 13, 16]. <p> This paper continues our work on the implementation of CLP (R) [10, 9, 13, 8] and on preliminary studies of each of the optimizations considered here <ref> [11, 9, 17, 13, 16] </ref>. The only other paper which describes an optimizing compiler for a CLP language, that we are aware of, is [8] which describes a preliminary version of this compiler which only provided three of the six optimizations used in the current compiler.
Reference: [14] <author> K. Marriott and H. Stndergaard. </author> <title> Analysis of constraint logic programs. </title> <editor> In S. Debray and M. Hermenegildo, </editor> <booktitle> Logic Programming: Proc. North American Conf. </booktitle> <year> 1990, </year> <pages> 531-547. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The analyzer performs global analysis of programs, that is, program information (descriptions) is inferred about the calls "between" different rules of the program as well as inferring the local information "within" each rule. The global analysis is based on abstract interpretation of logic programs and constraint logic programs <ref> [3, 14, 15] </ref> in which operations in the execution of the goal are mimicked by abstract operations on the domain of descriptions, (the analyses). The analyzer has two novel features.
Reference: [15] <author> K. Marriott, H. Stndergaard and N. D. Jones. </author> <title> Denotational abstract interpretation of logic programs. </title> <booktitle> ACM Transactions on Programming Languages and Systems 16 (3): </booktitle> <pages> 607-648, </pages> <year> 1994. </year>
Reference-contexts: The analyzer performs global analysis of programs, that is, program information (descriptions) is inferred about the calls "between" different rules of the program as well as inferring the local information "within" each rule. The global analysis is based on abstract interpretation of logic programs and constraint logic programs <ref> [3, 14, 15] </ref> in which operations in the execution of the goal are mimicked by abstract operations on the domain of descriptions, (the analyses). The analyzer has two novel features.
Reference: [16] <author> K. Marriott, H. Stndergaard, P. Stuckey and R. Yap. </author> <title> Optimizing compilation for CLP(R). </title> <editor> In G. Gupta, editor, </editor> <booktitle> Proc. Seventeenth Australian Computer Science Conf., Australian Computer Science Comm. </booktitle> <volume> 16 (1): </volume> <pages> 551-560, </pages> <year> 1994. </year>
Reference-contexts: This paper continues our work on the implementation of CLP (R) [10, 9, 13, 8] and on preliminary studies of each of the optimizations considered here <ref> [11, 9, 17, 13, 16] </ref>. The only other paper which describes an optimizing compiler for a CLP language, that we are aware of, is [8] which describes a preliminary version of this compiler which only provided three of the six optimizations used in the current compiler. <p> to global analysis and the resultant simplification of constraint solving is even larger than the speedup resulting from moving from the original CLP (R) interpreter to the compiler. 6 Conclusion The highly optimizing compiler presented in this paper is an implementation of the major components of the compiler proposed in <ref> [16] </ref>. The results demonstrate that global analysis and optimization can significantly improve the performance of CLP languages. Many of the techniques applied herein we expect will prove useful for other CLP languages, especially reordering of constraints and removal of redundant variables.
Reference: [17] <author> K. Marriott and P. Stuckey. </author> <title> The 3 R's of optimizing constraint logic programs: Refinement, removal and reordering. </title> <booktitle> Proc. Twentieth ACM Symp. Principles of Programming Languages, </booktitle> <pages> 334-344. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: This paper continues our work on the implementation of CLP (R) [10, 9, 13, 8] and on preliminary studies of each of the optimizations considered here <ref> [11, 9, 17, 13, 16] </ref>. The only other paper which describes an optimizing compiler for a CLP language, that we are aware of, is [8] which describes a preliminary version of this compiler which only provided three of the six optimizations used in the current compiler.
Reference: [18] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-time derivation of variable dependency using abstract interpretation. </title> <journal> Journal of Logic Programming 13 (2&3): </journal> <pages> 315-347, </pages> <year> 1992. </year>
Reference-contexts: In this section we describe in more detail the global analyzer, optimizer and code generator. The Analyzer To facilitate the rich variety of analyses required in the compiler, the analyzer is a generic tool like other analysis engines, such as PLAI <ref> [18] </ref> and GAIA [12] developed for Prolog. Generic analyses engines are not only designed to do many different analyses but also to allow for the easy addition of new analyses. The core of the analyzer is an algorithm for efficient fixpoint computation.
Reference: [19] <author> V. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Although some details of the optimizations and compiler design are specific to CLP (R) , the general ideas behind the optimizations and compiler design are applicable to any CLP language and also to other constraint programming paradigms such as concurrent constraint programming languages <ref> [19] </ref>, constraint databases [7], constraint imperative languages [5] and constraint functional languages [4]. The main contributions of this paper are: * A general design for optimizing compilers of CLP languages.
Reference: [20] <author> H. Stndergaard. </author> <title> An application of abstract interpretation of logic programs: Occur check reduction. </title> <editor> In B. Robinet and R. Wilhelm, editors, </editor> <booktitle> Proc. ESOP 86 (Lecture Notes in Computer Science 213), </booktitle> <pages> 327-338. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <month> 14 </month>
Reference-contexts: We use ROBDDs to represent the Boolean functions. 8 CallAlive This consists of lists of variables which may be directly referenced later in execution. Shar This captures information about possible structure sharing of variables between Prolog terms. It is based on descriptions introduced by Stndergaard <ref> [20] </ref> for eliminating occur checks in Prolog. The description consists of a possible sharing relation for variables. Consider the goal Y = f (X), p (X), Y = f (Z), q (Z). After Y = f (X), X and Y possibly share, but Z does not share with anything else.
References-found: 20

