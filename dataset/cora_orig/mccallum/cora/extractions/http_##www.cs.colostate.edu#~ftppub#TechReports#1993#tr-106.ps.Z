URL: http://www.cs.colostate.edu/~ftppub/TechReports/1993/tr-106.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Affiliation: Department of Computer Science Colorado State University  
Abstract: A Functional Implementation of the Jacobi Eigen-Solver * A.P.W. Bohm and R.E. Hiromoto Technical Report CS-93-106 May 5, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Arvind, R.A. Ianucci, </author> <title> Instruction Set Definition for a Tagged Token Dataflow Machine LCS, </title> <publisher> MIT, </publisher> <year> 1983 </year>
Reference: [2] <author> A.P.W. Bohm, R. E. Hiromoto, </author> <title> The Dataflow Time and Space Complexity of FFTs, </title> <note> Submitted to the Journal of Parallel and Distributed Computing, a special Datalow issue, guest edited by Gao et al. </note>
Reference-contexts: From the description of this algorithm given below, the computational use and organization of the data is initially seen to be a challenging task for implementation in a functional language. As in previous work <ref> [2] </ref>, we will use the notion of abstracted complexity , first used as a metric for comparing the computational complexity between sequential and parallel Fortran implementations [6]. This metric will provide us with a quantitative measure of equivalence between functional and non-functional implementations.
Reference: [3] <author> G.E. Forsythe and P. Henrici, </author> <title> The Cyclic Jacobi Method for the Principal Values of a Complex Matrix, </title> <journal> Trans. Amer. Math. Soc., </journal> <volume> 94 (1960), </volume> <pages> pp. 1-23. </pages>
Reference-contexts: A rotation (p; q) is followed by (p; q + 1) if p &lt; n 1; q &lt; n; (1; 2) if p = n 1; q = n: Under this cyclic row major ordering, we have the following theorem by Forsythe and Henrici <ref> [3] </ref>. THEOREM 1. Let a sequence of Jacobi transformations be applied to a symmetric matrix A. Further, let the angle k be restricted as follows: k 2 [a; b] and 2 : If the off-diagonal elements are annihilated using a cyclic row major ordering, then this Jacobi method converges.
Reference: [4] <author> David Cann, </author> <title> Retire Fortran? A Debate Rekindled, </title> <booktitle> Proceedings of Supercomputing '91, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1991, </year> <pages> pp. 264-272. </pages>
Reference-contexts: Functional languages have yet to provide sufficient evidence that they can achieve the same levels of performance. Some recent results of an applicative language have demonstrated this capability <ref> [4] </ref>. In this paper, we present the design and complexity analysis of a numerical algorithm, the Jacobi eigen-solver, written in the functional dataflow language Id [9]. The programming constructs are functional, but we are using explicit I-structures in implementing array computations.
Reference: [5] <author> J.R. Gurd, A.P.W. Bohm and Y.M. Teo, </author> <title> Performance Issues in Dataflow Machines, </title> <journal> Future Generation Computer Systems, </journal> <volume> 3, </volume> <year> 1987, </year> <pages> pp. 285-297. </pages>
Reference: [6] <author> J.J. Lambiotte, Jr., R. Voigt, </author> <title> The Solution of Tridiagonal Linear Systems on the CDC STAR-100 Computer, </title> <journal> ACM Transaction on Mathematical Software, </journal> <volume> 1, </volume> <pages> pp. 308-329, </pages> <year> 1975. </year>
Reference-contexts: As in previous work [2], we will use the notion of abstracted complexity , first used as a metric for comparing the computational complexity between sequential and parallel Fortran implementations <ref> [6] </ref>. This metric will provide us with a quantitative measure of equivalence between functional and non-functional implementations. We begin with a direct functional implementation taken from the specifications of the numerical algorithm.
Reference: [7] <institution> Id World User's Manual, Motorola, Inc., </institution> <year> 1992. </year>
Reference: [8] <author> D. R. </author> <title> Morais, ID World: An Environment for the Development of Dataflow Programs Written in ID, </title> <publisher> MIT LCS TR-365, </publisher> <month> may </month> <year> 1986. </year>
Reference: [9] <author> R.S. Nikhil, </author> <title> Id (version 90.0) Reference Manual. </title> <type> TR CSG Memo 284-1, </type> <institution> MIT LCS 1990. </institution>
Reference-contexts: Department of Energy under contract # W-7405-ENG-36. 1 parallel gateway to novel parallel machine architectures, such as multithreaded or hybrid von Neumann/dataflow, it is of vital interest to computational scientists and designers of numerical algorithms for these machines that functional languages provide expressive power and efficient implementation. Id <ref> [9] </ref> is a language with the potential to provide all of this. It is our opinion that there is a need for careful study of the effectiveness of the functional language paradigm in expressing numerical algorithms, as the suitability of a programming language extends beyond mere elegance. <p> Some recent results of an applicative language have demonstrated this capability [4]. In this paper, we present the design and complexity analysis of a numerical algorithm, the Jacobi eigen-solver, written in the functional dataflow language Id <ref> [9] </ref>. The programming constructs are functional, but we are using explicit I-structures in implementing array computations. We have used none of the non-functional programming features provide by the Id language such as mutable-arrays. Algorithms for eigen-solvers represent an important class of numerical software typically found in standard Fortran system libraries.
Reference: [10] <editor> W.H. Press et al., </editor> <title> Numerical Recipes, </title> <booktitle> the art of Scientific programming, </booktitle> <publisher> Cambridge University Press. </publisher>
Reference-contexts: Id in a highly elegant fashion. 2 2 Description and Complexity of Jacobi Eigenvalue Solver Given a symetric N fi N matrix A, the eigenvalue problem is the determination of the corresponding eigenvectors x and eigenvalues defined by the relationship Ax = x: (1) Any standard reference on numerical methods <ref> [10] </ref> will provide a number of methods available for determining the solution to this problem.
Reference: [11] <author> A. H. Sameh, </author> <title> On Jacobi-like Algorithm for a Parallel Computer, </title> <journal> Math. Comput., </journal> <volume> 25 (1971), </volume> <pages> pp. 579-590. </pages>
Reference-contexts: The Jacobi algorithm selected is one of several methods used in solving the eigenvalues of a symmetric matrix. Surprisingly, our parallel Jacobi algorithm is an improved version of an algorithm that was designed for the ILLAC-IV <ref> [11] </ref>. <p> A set of groups partitions and covers the upper triangle of A iff all points in the upper triangle of A are included in exactly one group. In <ref> [11] </ref> Sameh defines a minimal number of 2n 1 groups k of maximal size bN=2c. These groups are essentially anti-diagonals which wrap around the matrix boundaries.
Reference: [12] <author> G. Shroff and R. Schreiver, </author> <title> On the Convergence of the Cyclic Jocobi Method for Parallel Block Orderings, </title> <journal> SIAM J. Matrix Anal. Appl., </journal> <volume> Vol. 10, No. 3, </volume> <pages> pp. 326-346, </pages> <month> July </month> <year> 1989. </year> <month> 20 </month>
Reference-contexts: This undesireable feature finally lead to the parallel cyclic ordering described above. However, with the new ordering it is important that convergence is still guaranteed. Fortunately, Shroff and Schreiver <ref> [12] </ref> have introduced the notion of "cyclic wavefront" orderings where in a cyclic ordering of pairs f (i; j); 1 j &lt; j ng the rotation index I (i; j) at the which the pair (i; j) occurs. <p> (26) Under these permutations, the following cyclic ordering results: 2 6 6 6 4 : 3 4 5 1 : 2 3 : 7 7 7 7 (14) Therefore (1) is a P (ermutation)-wavefront ordering that is equivalent to (2). (2) converges and under the permutation equivalence so does (1) <ref> [12] </ref>. 6 Conclusion In this paper we have discussed the design of an efficient, parallel implementation of the Jacobi eigen-solver algorithm. It is often claimed that without some form of destructive updates, the computational efficiency of some algorithms can be increased.
References-found: 12

