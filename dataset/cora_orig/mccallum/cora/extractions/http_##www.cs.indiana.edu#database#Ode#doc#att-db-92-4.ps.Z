URL: http://www.cs.indiana.edu/database/Ode/doc/att-db-92-4.ps.Z
Refering-URL: http://www.cs.indiana.edu/database/Ode/doc/
Root-URL: http://www.cs.indiana.edu
Title: CQL++ A SQL for a C++ Based Object-Oriented DBMS  
Author: S. Dar N. H. Gehani H. V. Jagadish 
Address: Murray Hill, New Jersey 07974  
Affiliation: AT&T Bell Laboratories  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Agrawal and N. H. Gehani, </author> <title> ``Ode (Object Database and Environment): The Language and the Data Model'', </title> <booktitle> Proc. ACM-SIGMOD 1989 Int'l Conf. Management of Data, </booktitle> <address> Portland, Oregon, </address> <month> May-June </month> <year> 1989, </year> <pages> 36-45. </pages>
Reference-contexts: 1. INTRODUCTION Ode is a database system and environment based on the object paradigm. It offers an integrated data model for both database and general purpose manipulation <ref> [1, 2] </ref>. The database is defined, queried, and manipulated in the database programming language O++ which is based on C++ [24]. O++ borrows and extends the object definition facility of C++, called the class.
Reference: [2] <author> R. Agrawal and N. H. Gehani, </author> <title> ``Rationale for the Design of Persistence and Query Processing Facilities in the Database Programming Language O++'', </title> <booktitle> 2nd Int'l Workshop on Database Programming Languages, </booktitle> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: 1. INTRODUCTION Ode is a database system and environment based on the object paradigm. It offers an integrated data model for both database and general purpose manipulation <ref> [1, 2] </ref>. The database is defined, queried, and manipulated in the database programming language O++ which is based on C++ [24]. O++ borrows and extends the object definition facility of C++, called the class.
Reference: [3] <author> R. Agrawal, S. J. Buroff, N. H. Gehani and D. Shasha, </author> <title> ``Object Versioning in Ode'', </title> <booktitle> Proc. IEEE 7th Int'l Conf. Data Engineering, </booktitle> <address> Tokyo, Japan, </address> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: The bodies of the print and identify functions of Employee are void Employee::print () - cout &lt;< ssnum () &lt;< ", " &lt;< name &lt;< ", " &lt;< dept-&gt;dname; - void Employee::identify () - cout &lt;< name; - O++ also provides facilities for creating versions of objects <ref> [3] </ref> and for associating constraints and triggers with objects [11]. 3. DESIGN GOALS CQL++ is designed to allow SQL users a smooth transition from a relational database to the object-oriented database Ode. Here are the specific design goals we had for CQL++: 1.
Reference: [4] <author> A. M. Alashqur, S. Y. W. Su and H. Lam, ``OQL: </author> <title> A Query Language for Manipulating Object-Oriented Databases'', </title> <booktitle> Proc. 15th Int'l Conf. Very Large Data Bases, </booktitle> <address> Amsterdam, The Netherlands, </address> <month> Aug. </month> <year> 1989, </year> <pages> 433-442. </pages>
Reference: [5] <author> D. Beech, </author> <title> ``A Foundation for Evolution from Relational to Object Databases'', </title> <booktitle> Proc. of Int'l Conf. on Extending Database Technology, </booktitle> <month> March </month> <year> 1988. </year>
Reference-contexts: Other OODBMS companies are embarked on similar paths [7, 8]. When object-ids are added to the picture, the semantics of the corresponding language become more difficult to define. OSQL <ref> [5] </ref>, developed as part of the Iris project [9], takes a functional view of objects and object-ids. An object-id is not simply a handle to an object, but an intrinsic property of the object that never changes. Attributes are modeled as functions applied to object-ids.
Reference: [6] <author> M. J. Carey, D. J. DeWitt and S. L. Vandenberg, </author> <title> ``A Data Model and Query Language for EXODUS'', </title> <booktitle> Proc. ACM-SIGMOD 1988 Int'l Conf. on Management of Data, </booktitle> <address> Chicago, Illinois, </address> <month> June </month> <year> 1988, </year> <pages> 413-423. </pages>
Reference-contexts: They both support user-defined data types, structured complex objects, and methods. Object-SQL also supports inheritance. Functions (methods) are written in a general purpose programming language, for example LISP or C for Object-SQL, and PASCAL/R for HDBL. Similar operational extensions have been developed for the QUEL language <ref> [6, 21] </ref>. The languages in this group follow the ``evolutionary approach'' of extending the relational model with object-oriented functionality. There are some recent SQL extensions that, like CQL++, are based on C++.
Reference: [7] <author> O. </author> <title> Deux, ``The O 2 Database Programming Language'', </title> <journal> Communications of the ACM, </journal> <month> Sep. </month> <year> 1991. </year>
Reference-contexts: The design goals of Ontologic's SQL are similar to ours, however the language is quite restricted. It particular, updates are not allowed, storing query results is not addressed, and it is unclear if normal (value based) joins can be used. Other OODBMS companies are embarked on similar paths <ref> [7, 8] </ref>. When object-ids are added to the picture, the semantics of the corresponding language become more difficult to define. OSQL [5], developed as part of the Iris project [9], takes a functional view of objects and object-ids.
Reference: [8] <author> P. Dewan, A. Vikram and B. Bhargava, </author> <title> ``Engineering the Object-Relation Model in O-Raid'', </title> <booktitle> Proceedings Of The International Conference on Foundations of Data Organization and Algorithms, </booktitle> <month> June </month> <year> 1989, </year> <pages> 389-403. </pages>
Reference-contexts: The design goals of Ontologic's SQL are similar to ours, however the language is quite restricted. It particular, updates are not allowed, storing query results is not addressed, and it is unclear if normal (value based) joins can be used. Other OODBMS companies are embarked on similar paths <ref> [7, 8] </ref>. When object-ids are added to the picture, the semantics of the corresponding language become more difficult to define. OSQL [5], developed as part of the Iris project [9], takes a functional view of objects and object-ids.
Reference: [9] <author> D. H. Fishman, J. Annevelink, E. C. Chow, T. Connors, J. W. Davis, W. Hassan, C. G. Hoch, W. Kent, S. Leichner, P. Lyngbaek, B. Mahbod, M. A. Neimat, T. Risch, M. C. Shan and W. K. Wilkinson, </author> <title> ``Overview of the Iris DBMS'', </title> <type> Technical Report HPL-SAL-89-15, </type> <institution> HP Labs, </institution> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: Other OODBMS companies are embarked on similar paths [7, 8]. When object-ids are added to the picture, the semantics of the corresponding language become more difficult to define. OSQL [5], developed as part of the Iris project <ref> [9] </ref>, takes a functional view of objects and object-ids. An object-id is not simply a handle to an object, but an intrinsic property of the object that never changes. Attributes are modeled as functions applied to object-ids.
Reference: [10] <author> G. Gardarin, J. P. Cheiney, G. Kiernan, D. Pastre and H. Stora, </author> <title> ``Managing Complex Objects in an Extensible Relational DBMS'', </title> <booktitle> Proc. 15th Int'l Conf. Very Large Data Bases, </booktitle> <address> Amsterdam, The Netherlands, </address> <month> Aug. </month> <year> 1989, </year> <pages> 55-65. </pages>
Reference-contexts: A major strength of these proposals is that they are based on well defined data models. These models, like the relational model itself, comprise a formal description of the data structures of the database and the algebraic operations on these structures. In contrast, object-oriented languages <ref> [4-6, 10, 12, 14, 16, 21] </ref> are usually defined ``operationally'' rather then algebraically or axiomatically. CQL++ strives to combine the advantages of the structural and operational models. <p> In particular, functions (methods) cannot serve as attributes in these models. Several operational extensions are designed around the notion of abstract data types. Two SQL extensions in this category are Object-SQL <ref> [10] </ref> and HDBL [16]. They both support user-defined data types, structured complex objects, and methods. Object-SQL also supports inheritance. Functions (methods) are written in a general purpose programming language, for example LISP or C for Object-SQL, and PASCAL/R for HDBL.
Reference: [11] <author> N. H. Gehani and H. V. Jagadish, </author> <title> ``Ode as an Active Database: Constraints and Triggers'', </title> <booktitle> Proc. 17th Int'l Conf. Very Large Data Bases, </booktitle> <address> Barcelona, Spain, </address> <year> 1991, </year> <pages> 327-336. </pages>
Reference-contexts: identify functions of Employee are void Employee::print () - cout &lt;< ssnum () &lt;< ", " &lt;< name &lt;< ", " &lt;< dept-&gt;dname; - void Employee::identify () - cout &lt;< name; - O++ also provides facilities for creating versions of objects [3] and for associating constraints and triggers with objects <ref> [11] </ref>. 3. DESIGN GOALS CQL++ is designed to allow SQL users a smooth transition from a relational database to the object-oriented database Ode. Here are the specific design goals we had for CQL++: 1. CQL++ should ``look and feel'' like SQL as much as possible. 2.
Reference: [12] <author> W. Kim, </author> <title> ``A Model of Queries for Object-Oriented Databases'', </title> <booktitle> Proc. 15th Int'l Conf. Very Large Data Bases, </booktitle> <address> Amsterdam, The Netherlands, </address> <month> Aug. </month> <year> 1989, </year> <pages> 423-432. </pages>
Reference-contexts: A major strength of these proposals is that they are based on well defined data models. These models, like the relational model itself, comprise a formal description of the data structures of the database and the algebraic operations on these structures. In contrast, object-oriented languages <ref> [4-6, 10, 12, 14, 16, 21] </ref> are usually defined ``operationally'' rather then algebraically or axiomatically. CQL++ strives to combine the advantages of the structural and operational models. <p> Although the objects manipulated by such a hierarchical query are of different types <ref> [12] </ref>, the types are related in that they are derived from the same base type and they share the attributes of the base type. Only the shared attributes of the base class can be referenced in the projection list and in the search expression. <p> An object-id is not simply a handle to an object, but an intrinsic property of the object that never changes. Attributes are modeled as functions applied to object-ids. True functions, in the programming language sense, are not supported however, except for the definition of computed attributes. In ORION <ref> [12, 13] </ref>, a query returns the id's of the objects in the result. The application must then make explicit requests for the actual instances. In a single-operand query with projection, the projected attribute values may also be returned.
Reference: [13] <author> W. Kim, N. Ballou, H. Chou, J. F. Garza and D. Woelk, </author> <title> ``Features of the Orion Object Database System'', in Object-Oriented Concepts and Databases, </title> <editor> W. Kim and F.H. Lochovsky (ed.), </editor> <publisher> Addison-Wesley, </publisher> <year> 1989, </year> <pages> 251-282. </pages>
Reference-contexts: An object-id is not simply a handle to an object, but an intrinsic property of the object that never changes. Attributes are modeled as functions applied to object-ids. True functions, in the programming language sense, are not supported however, except for the definition of computed attributes. In ORION <ref> [12, 13] </ref>, a query returns the id's of the objects in the result. The application must then make explicit requests for the actual instances. In a single-operand query with projection, the projected attribute values may also be returned.
Reference: [14] <author> C. Lecluse, P. Richard and F. Velez, </author> <title> ``O 2 , an Object-Oriented Data Model'', </title> <booktitle> Proc. ACM-SIGMOD 1988 Int'l Conf. on Management of Data, </booktitle> <address> Chicago, Illinois, </address> <month> June </month> <year> 1988, </year> <pages> 424-433. </pages>
Reference-contexts: A major strength of these proposals is that they are based on well defined data models. These models, like the relational model itself, comprise a formal description of the data structures of the database and the algebraic operations on these structures. In contrast, object-oriented languages <ref> [4-6, 10, 12, 14, 16, 21] </ref> are usually defined ``operationally'' rather then algebraically or axiomatically. CQL++ strives to combine the advantages of the structural and operational models.
Reference: [15] <author> D. Lieuwen and D. DeWitt, </author> <title> ``Optimizing Loops in Database Programming Languages'', </title> <booktitle> 3rd Int'l Workshop on Database Programming Languages, </booktitle> <address> Nafplion, Greece , 1991. </address>
Reference-contexts: As a first step in this direction, we are currently implementing some of the ideas in <ref> [15] </ref>. We hope that the combination of a familiar interface and increased functionality will encourage SQL users to utilize object-oriented database technology. ACKNOWLEDGMENTS We are very grateful to Rick Greer for his comments and suggestions. - 14 -
Reference: [16] <author> V. Linnemann, K. Kuspert, P. Dadam, P. Pistor, R. Erbe, A. Kemper, N. Sudkamp, G. Walch and M. Wallrath, </author> <title> ``Design and Implementation of an Extensible Database Management System Supporting User Defined Data Types and Functions'', </title> <booktitle> Proc. 14th Int'l Conf. Very Large Data Bases, </booktitle> <address> Los Angeles, California, Aug.-Sept. </address> <year> 1988, </year> <pages> 294-305. </pages>
Reference-contexts: A major strength of these proposals is that they are based on well defined data models. These models, like the relational model itself, comprise a formal description of the data structures of the database and the algebraic operations on these structures. In contrast, object-oriented languages <ref> [4-6, 10, 12, 14, 16, 21] </ref> are usually defined ``operationally'' rather then algebraically or axiomatically. CQL++ strives to combine the advantages of the structural and operational models. <p> In particular, functions (methods) cannot serve as attributes in these models. Several operational extensions are designed around the notion of abstract data types. Two SQL extensions in this category are Object-SQL [10] and HDBL <ref> [16] </ref>. They both support user-defined data types, structured complex objects, and methods. Object-SQL also supports inheritance. Functions (methods) are written in a general purpose programming language, for example LISP or C for Object-SQL, and PASCAL/R for HDBL. Similar operational extensions have been developed for the QUEL language [6, 21].
Reference: [17] <editor> J. Melton, (ed.), </editor> <title> ``(ISO-ANSI Working Draft) Database Language SQL2 and SQL3'', ANSI X3H2-90-001, </title> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: O++ borrows and extends the object definition facility of C++, called the class. O++ provides facilities for creating and manipulating persistent objects, defining sets, and iterating over sets and clusters of persistent objects. It also provides facilities for specifying constraints and triggers. CQL++ is an adaptation of SQL <ref> [17] </ref> to the Ode object-oriented model. We were motivated to design a SQL-like interface to Ode because SQL is by far the most popular database interface. Typical database users are not likely to use a programming language such as O++.
Reference: [18] <author> P. B. Mitschang, </author> <title> ``Extending the Relational Algebra to Capture Complex Objects'', </title> <booktitle> Proc. 15th Int'l Conf. Very Large Data Bases, </booktitle> <address> Amsterdam, The Netherlands, </address> <month> Aug. </month> <year> 1989, </year> <pages> 297-305. </pages>
Reference-contexts: Typical database users are not likely to use a programming language such as O++. A declarative interface to Ode based on SQL would appeal to such users. Several designs have been proposed for adapting a relational language such as SQL to nested and recursive data models <ref> [18, 20, 22] </ref>. A major strength of these proposals is that they are based on well defined data models. These models, like the relational model itself, comprise a formal description of the data structures of the database and the algebraic operations on these structures. <p> RELATED WORK Previous work extending SQL or QUEL beyond the relational model can be roughly classified into structural vs. operational extensions. Structural extensions include support for NF 2 relations [20, 22] and more general schemas allowing recursive and/or nested type definitions <ref> [18, 19, 23] </ref>. These proposals are intended to support complex (i.e., user-defined type) objects, and do not capture the operational aspects of the object model. In particular, functions (methods) cannot serve as attributes in these models. Several operational extensions are designed around the notion of abstract data types.
Reference: [19] <author> P. Pistor and F. Andersen, </author> <title> ``Designing A Generalized NF2 Model With an SQL-Type Interface'', </title> <booktitle> Proc. 12th Int'l Conf. on Very Large Databases, </booktitle> <address> Kyoto, Japan, </address> <month> Aug. </month> <year> 1986, </year> <pages> 278-285. - 15 </pages> - 
Reference-contexts: RELATED WORK Previous work extending SQL or QUEL beyond the relational model can be roughly classified into structural vs. operational extensions. Structural extensions include support for NF 2 relations [20, 22] and more general schemas allowing recursive and/or nested type definitions <ref> [18, 19, 23] </ref>. These proposals are intended to support complex (i.e., user-defined type) objects, and do not capture the operational aspects of the object model. In particular, functions (methods) cannot serve as attributes in these models. Several operational extensions are designed around the notion of abstract data types.
Reference: [20] <author> M. A. Roth, H. F. Korth and D. S. Batory, ``SQL/NF: </author> <title> A Query Langage For 1NF Relational Databases'', </title> <booktitle> Information Systems 12, 1 (1987), </booktitle> <pages> 99-114. </pages>
Reference-contexts: Typical database users are not likely to use a programming language such as O++. A declarative interface to Ode based on SQL would appeal to such users. Several designs have been proposed for adapting a relational language such as SQL to nested and recursive data models <ref> [18, 20, 22] </ref>. A major strength of these proposals is that they are based on well defined data models. These models, like the relational model itself, comprise a formal description of the data structures of the database and the algebraic operations on these structures. <p> (Name n, char s, int snum, Date bday, persistent department *d); int salary (); void update_salary (int new_salary); virtual void print (); virtual void identify (); -; _ ____________________________________________________________________________________ The Department class referenced by Employee is defined as follows: - 3 - class Department - int budget; public: char dname <ref> [20] </ref>; int dno; Address location; persistent Employee *mgr; persistent Employee *emps [[DEPT_EMPS]]; Department (char nam [20], Address loc, persistent Employee *m, persistent Employee *es [[DEPT_EMPS]]); virtual void print (); virtual void identify (); -; _ ____________________________________________________________________________________ _ ____________________________________________________________________________________ O++ provides a high-level iteration facility for accessing objects in a set or <p> update_salary (int new_salary); virtual void print (); virtual void identify (); -; _ ____________________________________________________________________________________ The Department class referenced by Employee is defined as follows: - 3 - class Department - int budget; public: char dname <ref> [20] </ref>; int dno; Address location; persistent Employee *mgr; persistent Employee *emps [[DEPT_EMPS]]; Department (char nam [20], Address loc, persistent Employee *m, persistent Employee *es [[DEPT_EMPS]]); virtual void print (); virtual void identify (); -; _ ____________________________________________________________________________________ _ ____________________________________________________________________________________ O++ provides a high-level iteration facility for accessing objects in a set or a cluster. <p> For example, they could check the user's id and decide how much information to show accordingly. 7. RELATED WORK Previous work extending SQL or QUEL beyond the relational model can be roughly classified into structural vs. operational extensions. Structural extensions include support for NF 2 relations <ref> [20, 22] </ref> and more general schemas allowing recursive and/or nested type definitions [18, 19, 23]. These proposals are intended to support complex (i.e., user-defined type) objects, and do not capture the operational aspects of the object model. In particular, functions (methods) cannot serve as attributes in these models.
Reference: [21] <author> L. A. Rowe and M. R. Stonebraker, </author> <title> ``The POSTGRES Data Model'', </title> <booktitle> Proc. 13th Int'l Conf. Very Large Data Bases, </booktitle> <address> Brighton, England, </address> <month> Sept. </month> <year> 1987, </year> <pages> 83-96. </pages>
Reference-contexts: A major strength of these proposals is that they are based on well defined data models. These models, like the relational model itself, comprise a formal description of the data structures of the database and the algebraic operations on these structures. In contrast, object-oriented languages <ref> [4-6, 10, 12, 14, 16, 21] </ref> are usually defined ``operationally'' rather then algebraically or axiomatically. CQL++ strives to combine the advantages of the structural and operational models. <p> They both support user-defined data types, structured complex objects, and methods. Object-SQL also supports inheritance. Functions (methods) are written in a general purpose programming language, for example LISP or C for Object-SQL, and PASCAL/R for HDBL. Similar operational extensions have been developed for the QUEL language <ref> [6, 21] </ref>. The languages in this group follow the ``evolutionary approach'' of extending the relational model with object-oriented functionality. There are some recent SQL extensions that, like CQL++, are based on C++.
Reference: [22] <author> H. J. Schek and M. Scholl, </author> <title> ``The Relation Model with Relation-Valued Attributes'', </title> <journal> Information Sys. </journal> <volume> 11, </volume> <month> 2 </month> <year> (1986), </year> . 
Reference-contexts: Typical database users are not likely to use a programming language such as O++. A declarative interface to Ode based on SQL would appeal to such users. Several designs have been proposed for adapting a relational language such as SQL to nested and recursive data models <ref> [18, 20, 22] </ref>. A major strength of these proposals is that they are based on well defined data models. These models, like the relational model itself, comprise a formal description of the data structures of the database and the algebraic operations on these structures. <p> For example, they could check the user's id and decide how much information to show accordingly. 7. RELATED WORK Previous work extending SQL or QUEL beyond the relational model can be roughly classified into structural vs. operational extensions. Structural extensions include support for NF 2 relations <ref> [20, 22] </ref> and more general schemas allowing recursive and/or nested type definitions [18, 19, 23]. These proposals are intended to support complex (i.e., user-defined type) objects, and do not capture the operational aspects of the object model. In particular, functions (methods) cannot serve as attributes in these models.
Reference: [23] <author> D. L. Spooner, M. Hardwick and G. Samaras, </author> <title> ``Some Conceptual Ideas For Extending SQL For Object-Oriented Engineering Database Systems'', </title> <booktitle> Proc. IEEE 1st International Conference on Data and Knowledge Systems for Manufacturing and Engineering, </booktitle> <month> Oct. </month> <year> 1987, </year> <pages> 163-169. </pages>
Reference-contexts: RELATED WORK Previous work extending SQL or QUEL beyond the relational model can be roughly classified into structural vs. operational extensions. Structural extensions include support for NF 2 relations [20, 22] and more general schemas allowing recursive and/or nested type definitions <ref> [18, 19, 23] </ref>. These proposals are intended to support complex (i.e., user-defined type) objects, and do not capture the operational aspects of the object model. In particular, functions (methods) cannot serve as attributes in these models. Several operational extensions are designed around the notion of abstract data types.
Reference: [24] <author> B. Stroustrup, </author> <title> The C++ Programming Language (2nd Ed.), </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year> <month> CQL++ </month>
Reference-contexts: 1. INTRODUCTION Ode is a database system and environment based on the object paradigm. It offers an integrated data model for both database and general purpose manipulation [1, 2]. The database is defined, queried, and manipulated in the database programming language O++ which is based on C++ <ref> [24] </ref>. O++ borrows and extends the object definition facility of C++, called the class. O++ provides facilities for creating and manipulating persistent objects, defining sets, and iterating over sets and clusters of persistent objects. It also provides facilities for specifying constraints and triggers. <p> It hides from users such programming language details as object-ids, public and private members of objects, and the implementation (bodies) of member functions. See [ Dar Gehani Jagadish memorandum CQL++ ] for more detail. 2. BACKGROUND The object model of Ode is based on C++ <ref> [24] </ref>. The database schema is a set of classes. A class is similar to an abstract data type: it has public members (components), which represent the interface to the class, and private members, which represent the implementation of the class.
References-found: 24

