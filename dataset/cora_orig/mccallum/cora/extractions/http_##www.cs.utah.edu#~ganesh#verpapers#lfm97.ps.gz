URL: http://www.cs.utah.edu/~ganesh/verpapers/lfm97.ps.gz
Refering-URL: http://www.cs.utah.edu/~mjones/papers/utah.notes.html
Root-URL: 
Email: fratan,ganeshg@cs.utah.edu  
Title: PV: A Model-Checker for Verifying LTL-X Properties  
Author: Ratan Nalumasu Ganesh Gopalakrishnan 
Note: Supported in part by ARPA Order #B990 Under SPAWAR Contract #N0039-95-C-0018 (Avalanche), DARPA under contract #DABT6396C0094 (UV), and NSF MIP MIP-9321836.  
Date: February 28, 1997  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah,  
Abstract-found: 0
Intro-found: 1
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction With the increasing scale of hardware systems and the corresponding increase in the number of concurrent protocols involved in their design, formal verification of concurrent protocols is an important practical need. Explicit state enumeration methods <ref> [CES86, Hol91, Dil96] </ref> have shown considerable promise in verification of real-world protocol verification problems and have been used with success on many industrial designs [YGM + 95].
Reference: [CKK96] <author> John B. Carter, Chen-Chi Kuo, and Ravindra Kuramkote. </author> <title> A comparison of software and hardware synchronization mechanisms for distributed shared memory multiprocessors. </title> <type> Technical Report UUCS-96-011, </type> <institution> University of Utah, </institution> <address> Salt Lake City, UT, USA, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: An important run-time optimization called partial-order reductions [Pel96, God95, Val93] helps avoid having to examine all possible interleavings among processes, and is crucial to handling large models. In our research in system-level hardware design, specifically in the verification of cache coherence protocols used in the Utah Avalanche multiprocessor <ref> [CKK96] </ref>, we observed that existing tools that support partial-order reductions [God95, HP94] failed to provide sufficient reductions. We traced this state explosion to their use of run-time provisos (explained later) in deciding which processes to run in a given state. <p> This paper presents a new partial-order reduction algorithm called Two phase that, in most cases, outperforms all comparable algorithms, and is part of a new protocol verification tool called PV that finds routine application in our multiprocessor design project <ref> [CKK96] </ref>. In some cases (e.g., the invalidate protocol considered for use in the Avalanche processor), not only did PV's search finish when others' didn't, but it also found some bugs which the others missed in their incomplete search. <p> As a result the Two phase degenerates to full state space, while Spin reduces the number of states appreciably (from 3 n states to 2 n+1 1 states for where n=5, 6, or 7). Mig and inv are two cache coherency protocols used in <ref> [CKK96] </ref>. On inv, Spin fails to complete the graph construction in 64MB of memory. PV tool on the other hand finishes comfortably generating 255,781 states (without selective caching) or 135,404 states (with selective caching). SC is a server/client protocol.
Reference: [CP95] <author> Ching-Tsun Chou and Doron Peled. </author> <title> Formal verification of a partial-order reduction technique for model-checking. </title> <address> ftp://ftp.cs.ucla.edu/pub/chou/por.ps, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Source code for PV is available in source code from [NG96]. Currently, we are planning to 7 verify the proofs presented in this paper using PVS [ORR + 96]. We believe that verification of Two phase would be much simpler than the verification of [Pel96] algorithm <ref> [CP95] </ref> for two reasons. First, Two phase is intrinsically simpler than [Pel96] algorithm. Second, in [CP95], the authors used HOL. Compared to HOL, PVS is much more mechanized, and hence we expect the effort required to be substantially smaller. Verification effort using PVS would be reported elsewhere. <p> We believe that verification of Two phase would be much simpler than the verification of [Pel96] algorithm <ref> [CP95] </ref> for two reasons. First, Two phase is intrinsically simpler than [Pel96] algorithm. Second, in [CP95], the authors used HOL. Compared to HOL, PVS is much more mechanized, and hence we expect the effort required to be substantially smaller. Verification effort using PVS would be reported elsewhere.
Reference: [Dil96] <author> David Dill. </author> <title> The stanford murphi verifier. </title> <booktitle> In Computer Aided Verification, </booktitle> <pages> pages 390-393, </pages> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year> <title> Tool demo. </title>
Reference-contexts: 1 Introduction With the increasing scale of hardware systems and the corresponding increase in the number of concurrent protocols involved in their design, formal verification of concurrent protocols is an important practical need. Explicit state enumeration methods <ref> [CES86, Hol91, Dil96] </ref> have shown considerable promise in verification of real-world protocol verification problems and have been used with success on many industrial designs [YGM + 95]. <p> Using most explicit state enumeration tools, a concurrent system is modeled as a set of concurrent processes communicating via shared variables <ref> [Dil96] </ref> and/or communication channels [Hol91] executing under an interleaving model. An important run-time optimization called partial-order reductions [Pel96, God95, Val93] helps avoid having to examine all possible interleavings among processes, and is crucial to handling large models.
Reference: [GHP92] <author> Patrice Godefroid, Gerard Holzmann, and Didier Pirottin. </author> <title> State-space caching revisited. </title> <booktitle> In Computer Aided Verification, </booktitle> <pages> pages 178-191, </pages> <address> Montreal, Canada, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: If the partial order reduction algorithm uses 4 Adding list to the V r is really not necessary, but for our implementation it is easier to add list to V r than to reset list. 5 PO-PACKAGE uses a weaker form of proviso along with sleepsets <ref> [GHP92] </ref>, but it preserves only safety properties. 5 (a) Best case (b) State space by 2 phase (c) State space generated by Spin tool Two phase algorithm. (c) State space generated by Spin. Dotted lines in (c) show some of the transitions that were not attempted due to the proviso.
Reference: [God95] <author> Patrice Godefroid. </author> <title> Partial-Order Methods for the Verification of Concurrent Systems: An approach to the State-Explosion Problem. </title> <type> PhD thesis, </type> <institution> Univerite De Liege, </institution> <year> 1994-95. </year>
Reference-contexts: Using most explicit state enumeration tools, a concurrent system is modeled as a set of concurrent processes communicating via shared variables [Dil96] and/or communication channels [Hol91] executing under an interleaving model. An important run-time optimization called partial-order reductions <ref> [Pel96, God95, Val93] </ref> helps avoid having to examine all possible interleavings among processes, and is crucial to handling large models. <p> In our research in system-level hardware design, specifically in the verification of cache coherence protocols used in the Utah Avalanche multiprocessor [CKK96], we observed that existing tools that support partial-order reductions <ref> [God95, HP94] </ref> failed to provide sufficient reductions. We traced this state explosion to their use of run-time provisos (explained later) in deciding which processes to run in a given state. <p> Partial order reductions attempt to generate a subgraph of G f , called reduced graph G r , that satisfies the property iff the property is satisfied by G f . As mentioned earlier, these algorithms <ref> [Val93, NG97, God95, Pel96] </ref> attempt to generate G r by exploiting the fact that when a process P i is in a local state, its transitions commute with the transitions of P j (j 6= i). <p> Of course, special care must be taken to ensure that no enabled transition is indefinitely postponed. Previous algorithms such as <ref> [God95] </ref> and [Pel96] use proviso 2 to ensure that no transition is indefinitely postponed. Both these algorithms (as well as Two Phase) use a stack to maintain the list of states currently being expanded. When expanding the current top of the stack, [God95] and [Pel96] algorithms require that the subset of <p> Previous algorithms such as <ref> [God95] </ref> and [Pel96] use proviso 2 to ensure that no transition is indefinitely postponed. Both these algorithms (as well as Two Phase) use a stack to maintain the list of states currently being expanded. When expanding the current top of the stack, [God95] and [Pel96] algorithms require that the subset of transitions selected to explore do not result in a state that is already on the stack 3 . <p> Without this variable, if a process is in a deterministic loop, the 2 The provisos differ slightly depending on whether they preserve LTL-X or safety only. 3 The proviso used in the two algorithms differ slightly because <ref> [God95] </ref> preserves only stutter-free safety properties while [Pel96] preserves LTL-X. <p> In this case, of course, line 8 also has to be modified appropriately. This technique constitutes a simple form of selective caching. PV also supports this selective caching. 4 Experimental Results The Two phase algorithm outperforms the [Pel96] algorithm and a similar algorithm implemented in PO-PACKAGE 5 <ref> [God95] </ref> when the proviso is invoked often. In most reactive systems, a transaction typically involves a subset of processes. For example, in a server-client model of computation, a server and a client may communicate without any interruption from other servers or clients to complete a transaction.
Reference: [Hol91] <author> Gerard Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction With the increasing scale of hardware systems and the corresponding increase in the number of concurrent protocols involved in their design, formal verification of concurrent protocols is an important practical need. Explicit state enumeration methods <ref> [CES86, Hol91, Dil96] </ref> have shown considerable promise in verification of real-world protocol verification problems and have been used with success on many industrial designs [YGM + 95]. <p> Using most explicit state enumeration tools, a concurrent system is modeled as a set of concurrent processes communicating via shared variables [Dil96] and/or communication channels <ref> [Hol91] </ref> executing under an interleaving model. An important run-time optimization called partial-order reductions [Pel96, God95, Val93] helps avoid having to examine all possible interleavings among processes, and is crucial to handling large models.
Reference: [HP94] <author> Gerard Holzmann and Doron Peled. </author> <title> An improvement in formal verification. </title> <booktitle> In FORTE, </booktitle> <address> Bern, Switzerland, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: In our research in system-level hardware design, specifically in the verification of cache coherence protocols used in the Utah Avalanche multiprocessor [CKK96], we observed that existing tools that support partial-order reductions <ref> [God95, HP94] </ref> failed to provide sufficient reductions. We traced this state explosion to their use of run-time provisos (explained later) in deciding which processes to run in a given state.
Reference: [HP96] <author> Gerard J. Holzmann and Doron Peled. </author> <title> The state of spin. </title> <booktitle> In Computer Aided Verification, </booktitle> <pages> pages 385-389, </pages> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year> <title> Tool demo. </title>
Reference-contexts: Hence, it is not necessary to explore s (line 27) and the recursive call terminates. As an example, consider the protocol shown in Figure 2 (a). On this protocol, the state space generated by [Pel96] algorithm, implemented in <ref> [HP96] </ref>, is shown in Figure 2 (c). As can be seen, when the search reaches the state &lt;S0, S1&gt;, due to proviso, the algorithm selects process P2 and generates &lt;S1, S1&gt;. <p> In other realistic systems also the number of extra states generated due to the proviso can be high. Two phase does not use the proviso, thus avoiding generating the extra states. Table 1 shows results of running the [Pel96] algorithm implemented in Spin <ref> [HP96] </ref>, Two phase with selective state caching disabled, and Two phase with selective caching enabled on various protocols. This table shows number of states in V r and time taken in seconds to complete the graph construction on a Super Sparc 20.
Reference: [NG96] <author> Ratan Nalumasu and Ganesh Gopalakrishnan. </author> <title> The PV Tool. </title> <institution> Univ. of Utah, </institution> <address> http://www.cs.utah.edu/ ratan/pv-tool/, </address> <year> 1996. </year>
Reference-contexts: Commutativity depends on the communication primitives provided. Typical communication primitives include shared memory (global variables), bounded buffers, unbounded buffers, and rendezvous communication. The PV tool <ref> [NG96] </ref> supports communication through shared memory and bounded buffers. In this paper, for the sake of simplicity, we assume that there is exactly one shared variable (implicitly named g), and that there is no other means of communication. <p> By avoiding the proviso and using deterministic transitions to bring the reductions, the algorithm can bring better reductions than other algorithms on a number of practical protocols. Two phase algorithm is implemented in PV. Source code for PV is available in source code from <ref> [NG96] </ref>. Currently, we are planning to 7 verify the proofs presented in this paper using PVS [ORR + 96]. We believe that verification of Two phase would be much simpler than the verification of [Pel96] algorithm [CP95] for two reasons. First, Two phase is intrinsically simpler than [Pel96] algorithm.
Reference: [NG97] <author> Ratan Nalumasu and Ganesh Gopalakrishnan. </author> <title> A new partial order reduction algorithm for concurrent system verification. </title> <booktitle> In CHDL, </booktitle> <address> Toledo, Spain, </address> <month> April </month> <year> 1997. </year> <note> to appear. 8 </note>
Reference-contexts: In some cases (e.g., the invalidate protocol considered for use in the Avalanche processor), not only did PV's search finish when others' didn't, but it also found some bugs which the others missed in their incomplete search. In an earlier paper <ref> [NG97] </ref>, we showed that Two phase preserves safety properties. In this paper, we prove that Two phase preserves all stutter-free LTL (LTL-X) properties. <p> Partial order reductions attempt to generate a subgraph of G f , called reduced graph G r , that satisfies the property iff the property is satisfied by G f . As mentioned earlier, these algorithms <ref> [Val93, NG97, God95, Pel96] </ref> attempt to generate G r by exploiting the fact that when a process P i is in a local state, its transitions commute with the transitions of P j (j 6= i). <p> Usage of the proviso, in some cases, causes the G r to be quite large even though a much smaller G r can be computed <ref> [NG97] </ref>. Two phase algorithm attempts to rectify this problem by avoiding the proviso and using a different search strategy. 3 3 Two Phase Algorithm Two phase is shown in Figure 1. Unlike previous algorithms, this algorithm does not use proviso. Instead its execution is divided into two phases.
Reference: [ORR + 96] <author> S. Owre, S. Rajan, J. M. Rushby, N. Shankar, and M. Srivas. PVS: </author> <title> Combining specification, proof checking and model checking. </title> <booktitle> In CAV, </booktitle> <pages> pages 411-414, </pages> <address> New Brunswick, NJ, USA, </address> <year> 1996. </year>
Reference-contexts: Two phase algorithm is implemented in PV. Source code for PV is available in source code from [NG96]. Currently, we are planning to 7 verify the proofs presented in this paper using PVS <ref> [ORR + 96] </ref>. We believe that verification of Two phase would be much simpler than the verification of [Pel96] algorithm [CP95] for two reasons. First, Two phase is intrinsically simpler than [Pel96] algorithm. Second, in [CP95], the authors used HOL.
Reference: [Pel96] <author> Doron Peled. </author> <title> Combining partial order reductions with on-the-fly model-checking. </title> <journal> Journal of Formal Methods in Systems Design, </journal> <volume> 8 </volume> (1):39-64, 1996. also in CAV, 1994. 
Reference-contexts: Using most explicit state enumeration tools, a concurrent system is modeled as a set of concurrent processes communicating via shared variables [Dil96] and/or communication channels [Hol91] executing under an interleaving model. An important run-time optimization called partial-order reductions <ref> [Pel96, God95, Val93] </ref> helps avoid having to examine all possible interleavings among processes, and is crucial to handling large models. <p> Partial order reductions attempt to generate a subgraph of G f , called reduced graph G r , that satisfies the property iff the property is satisfied by G f . As mentioned earlier, these algorithms <ref> [Val93, NG97, God95, Pel96] </ref> attempt to generate G r by exploiting the fact that when a process P i is in a local state, its transitions commute with the transitions of P j (j 6= i). <p> Of course, special care must be taken to ensure that no enabled transition is indefinitely postponed. Previous algorithms such as [God95] and <ref> [Pel96] </ref> use proviso 2 to ensure that no transition is indefinitely postponed. Both these algorithms (as well as Two Phase) use a stack to maintain the list of states currently being expanded. When expanding the current top of the stack, [God95] and [Pel96] algorithms require that the subset of transitions selected <p> Previous algorithms such as [God95] and <ref> [Pel96] </ref> use proviso 2 to ensure that no transition is indefinitely postponed. Both these algorithms (as well as Two Phase) use a stack to maintain the list of states currently being expanded. When expanding the current top of the stack, [God95] and [Pel96] algorithms require that the subset of transitions selected to explore do not result in a state that is already on the stack 3 . <p> Without this variable, if a process is in a deterministic loop, the 2 The provisos differ slightly depending on whether they preserve LTL-X or safety only. 3 The proviso used in the two algorithms differ slightly because [God95] preserves only stutter-free safety properties while <ref> [Pel96] </ref> preserves LTL-X. <p> Hence, it is not necessary to explore s (line 27) and the recursive call terminates. As an example, consider the protocol shown in Figure 2 (a). On this protocol, the state space generated by <ref> [Pel96] </ref> algorithm, implemented in [HP96], is shown in Figure 2 (c). As can be seen, when the search reaches the state &lt;S0, S1&gt;, due to proviso, the algorithm selects process P2 and generates &lt;S1, S1&gt;. <p> In this case, of course, line 8 also has to be modified appropriately. This technique constitutes a simple form of selective caching. PV also supports this selective caching. 4 Experimental Results The Two phase algorithm outperforms the <ref> [Pel96] </ref> algorithm and a similar algorithm implemented in PO-PACKAGE 5 [God95] when the proviso is invoked often. In most reactive systems, a transaction typically involves a subset of processes. <p> In other realistic systems also the number of extra states generated due to the proviso can be high. Two phase does not use the proviso, thus avoiding generating the extra states. Table 1 shows results of running the <ref> [Pel96] </ref> algorithm implemented in Spin [HP96], Two phase with selective state caching disabled, and Two phase with selective caching enabled on various protocols. This table shows number of states in V r and time taken in seconds to complete the graph construction on a Super Sparc 20. <p> Source code for PV is available in source code from [NG96]. Currently, we are planning to 7 verify the proofs presented in this paper using PVS [ORR + 96]. We believe that verification of Two phase would be much simpler than the verification of <ref> [Pel96] </ref> algorithm [CP95] for two reasons. First, Two phase is intrinsically simpler than [Pel96] algorithm. Second, in [CP95], the authors used HOL. Compared to HOL, PVS is much more mechanized, and hence we expect the effort required to be substantially smaller. Verification effort using PVS would be reported elsewhere. <p> Currently, we are planning to 7 verify the proofs presented in this paper using PVS [ORR + 96]. We believe that verification of Two phase would be much simpler than the verification of <ref> [Pel96] </ref> algorithm [CP95] for two reasons. First, Two phase is intrinsically simpler than [Pel96] algorithm. Second, in [CP95], the authors used HOL. Compared to HOL, PVS is much more mechanized, and hence we expect the effort required to be substantially smaller. Verification effort using PVS would be reported elsewhere.
Reference: [Val93] <author> Antti Valmari. </author> <title> On-the-fly verification with stubborn sets. </title> <booktitle> In Computer Aided Verification, </booktitle> <pages> pages 397-408, </pages> <address> Elounda, Greece, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Using most explicit state enumeration tools, a concurrent system is modeled as a set of concurrent processes communicating via shared variables [Dil96] and/or communication channels [Hol91] executing under an interleaving model. An important run-time optimization called partial-order reductions <ref> [Pel96, God95, Val93] </ref> helps avoid having to examine all possible interleavings among processes, and is crucial to handling large models. <p> Partial order reductions attempt to generate a subgraph of G f , called reduced graph G r , that satisfies the property iff the property is satisfied by G f . As mentioned earlier, these algorithms <ref> [Val93, NG97, God95, Pel96] </ref> attempt to generate G r by exploiting the fact that when a process P i is in a local state, its transitions commute with the transitions of P j (j 6= i).
Reference: [YGM + 95] <author> Lawrence Yang, David Gao, Jamshid Mostoufi, Raju Joshi, and Paul Loewen-stein. </author> <title> System design methodology of UltraSPARC-I. </title> <booktitle> In Proc. ACM/IEEE 24th Design Automation Conference, </booktitle> <pages> pages 7-12, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Explicit state enumeration methods [CES86, Hol91, Dil96] have shown considerable promise in verification of real-world protocol verification problems and have been used with success on many industrial designs <ref> [YGM + 95] </ref>. Using most explicit state enumeration tools, a concurrent system is modeled as a set of concurrent processes communicating via shared variables [Dil96] and/or communication channels [Hol91] executing under an interleaving model.
References-found: 15

