URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-rosenblueth.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Email: drosenbl@servidor.unam.mx  
Title: An Exhaustive-Search Method using Layered Streams Obtained through a Meta-Interpreter for Chain Programs  
Author: David A. Rosenblueth 
Address: Apdo. 20-726, 01000 Mexico D.F.  
Affiliation: Instituto de Investigaciones en Matematicas Aplicadas en Sistemas Universidad Nacional Autonoma de Mexico  
Abstract-found: 0
Intro-found: 1
Reference: [1] <editor> Andre Marien and Bart Demoen. Findall without findall/3. In David S. Warren, editor, </editor> <booktitle> Proceeding of the Tenth International Conference on Logic Programming, </booktitle> <pages> pages 408-423. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Each such deterministic, layered-stream program supposedly performs exhaustive search over the space generated by some nondeterministic, naive program. However, a method converting a nondeterministic program into a corresponding exhaustive-search, layered-stream version has not yet been proposed, as far as we know <ref> [1] </ref>. Layered streams have thus remained difficult to use [4, p. 408], since the programmer must be concerned both about factorization of heads and exhaustive search. We build upon the work of Okumura and Matsumoto by showing how to translate nondeterministic programs into exhaustive-search, layered-stream form. <p> This allows us to include "garbage" at any level. For instance the layered stream: [ 1fl [3fl [ ]; 4fl [2fl [ ]]]; 2fl [4fl [1fl [3flbegin]]]; 3fl [1fl [4fl [2flbegin]]]; 4fl [1fl [3fl [ ]]; 2fl [ ]] ] (1) represents <ref> [[2; 4; 1; 3] </ref>; [3; 1; 4; 2]]. As an example of an exhaustive-search program using layered streams, we reproduce in problem. The answer to the goal fourQueen (begin; Z) is the layered stream given above (1). <p> This allows us to include "garbage" at any level. For instance the layered stream: [ 1fl [3fl [ ]; 4fl [2fl [ ]]]; 2fl [4fl [1fl [3flbegin]]]; 3fl [1fl [4fl [2flbegin]]]; 4fl [1fl [3fl [ ]]; 2fl [ ]] ] (1) represents [[2; 4; 1; 3]; <ref> [3; 1; 4; 2] </ref>]. As an example of an exhaustive-search program using layered streams, we reproduce in problem. The answer to the goal fourQueen (begin; Z) is the layered stream given above (1). Perhaps begin was originally so called because some layered-stream programs built the intended lists in reverse. <p> N 1; q (hValues ; Placed i; XPlaced ); p (hN 0 ; Values ; XPlaced i; AllPlaced ) q (h [XjXs ]; Placed i; [XjPlaced ]) safe (hX; 1; Placed i) q (h [XjXs ]; Placed i; XPlaced ) q (hXs; Placed i; XPlaced ) Example goal: p (h5; <ref> [1; 2; 3; 4; 5] </ref>; [ ]i; P ).
Reference: [2] <author> Akira Okumura and Yuji Matsumoto. </author> <title> Parallel programming with layered streams. </title> <booktitle> In Proceedings of the 1987 Symposium on Logic Programming, </booktitle> <pages> pages 224-231, </pages> <address> San Francisco, California, U.S.A., </address> <year> 1987. </year> <note> Lecture Notes in Computer Science 348. </note>
Reference-contexts: 1 Introduction Okumura and Matsumoto have published <ref> [2] </ref> examples of logic programs using a data structure they call "layered stream," especially suited for completely traversing a search space in a deterministic manner [3, 5]. A layered stream is a representation of a list of lists, in which common heads of adjacent sublists have been factored. <p> This allows us to include "garbage" at any level. For instance the layered stream: [ 1fl [3fl [ ]; 4fl [2fl [ ]]]; 2fl [4fl [1fl [3flbegin]]]; 3fl [1fl [4fl [2flbegin]]]; 4fl [1fl [3fl [ ]]; 2fl [ ]] ] (1) represents [[2; 4; 1; 3]; <ref> [3; 1; 4; 2] </ref>]. As an example of an exhaustive-search program using layered streams, we reproduce in problem. The answer to the goal fourQueen (begin; Z) is the layered stream given above (1). Perhaps begin was originally so called because some layered-stream programs built the intended lists in reverse. <p> The answer to the goal fourQueen (begin; Z) is the layered stream given above (1). Perhaps begin was originally so called because some layered-stream programs built the intended lists in reverse. Garbage can be eliminated to a large extent by using variants of the predicate with symbol filter <ref> [2, 4] </ref>. For simplicity, we will not be concerned here about such elimination. We also omit mentioning the merits of layered streams, for which we refer to [2, 4]. 2 fourQueen (Xs 0 ; Xs 4 ) qs (Xs 0 ; Xs 1 ); qs (Xs 1 ; Xs 2 ); <p> Garbage can be eliminated to a large extent by using variants of the predicate with symbol filter <ref> [2, 4] </ref>. For simplicity, we will not be concerned here about such elimination. We also omit mentioning the merits of layered streams, for which we refer to [2, 4]. 2 fourQueen (Xs 0 ; Xs 4 ) qs (Xs 0 ; Xs 1 ); qs (Xs 1 ; Xs 2 ); qs (Xs 2 ; Xs 3 ); qs (Xs 3 ; Xs 4 ) qs (In; [1flOut 1 ; 2flOut 2 ; 3flOut 3 ; 4flOut 4 <p> N 1; q (hValues ; Placed i; XPlaced ); p (hN 0 ; Values ; XPlaced i; AllPlaced ) q (h [XjXs ]; Placed i; [XjPlaced ]) safe (hX; 1; Placed i) q (h [XjXs ]; Placed i; XPlaced ) q (hXs; Placed i; XPlaced ) Example goal: p (h5; <ref> [1; 2; 3; 4; 5] </ref>; [ ]i; P ).
Reference: [3] <author> H. Tamaki. </author> <title> Stream-based compilation of ground I/O Prolog into committed-choice languages. </title> <booktitle> In Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <pages> pages 376-393, </pages> <address> Melbourne, Australia, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction Okumura and Matsumoto have published [2] examples of logic programs using a data structure they call "layered stream," especially suited for completely traversing a search space in a deterministic manner <ref> [3, 5] </ref>. A layered stream is a representation of a list of lists, in which common heads of adjacent sublists have been factored. This factorization allows the pruning of several branches of the search space in constant time and is also a source of parallelism [4, p. 147]. <p> This allows us to include "garbage" at any level. For instance the layered stream: [ 1fl [3fl [ ]; 4fl [2fl [ ]]]; 2fl [4fl [1fl [3flbegin]]]; 3fl [1fl [4fl [2flbegin]]]; 4fl [1fl [3fl [ ]]; 2fl [ ]] ] (1) represents <ref> [[2; 4; 1; 3] </ref>; [3; 1; 4; 2]]. As an example of an exhaustive-search program using layered streams, we reproduce in problem. The answer to the goal fourQueen (begin; Z) is the layered stream given above (1). <p> This allows us to include "garbage" at any level. For instance the layered stream: [ 1fl [3fl [ ]; 4fl [2fl [ ]]]; 2fl [4fl [1fl [3flbegin]]]; 3fl [1fl [4fl [2flbegin]]]; 4fl [1fl [3fl [ ]]; 2fl [ ]] ] (1) represents [[2; 4; 1; 3]; <ref> [3; 1; 4; 2] </ref>]. As an example of an exhaustive-search program using layered streams, we reproduce in problem. The answer to the goal fourQueen (begin; Z) is the layered stream given above (1). Perhaps begin was originally so called because some layered-stream programs built the intended lists in reverse. <p> This suggests using a breadth-first evaluation of both compositions and unions of relations. Hence, we will use a left-to-right evaluation of (3) and (4). (Using other strategies leads to meta-interpreters having essentially the same behavior as either the continuation-based [5] or the stream-based <ref> [3] </ref> exhaustive-search methods.) The top-level predicate list solve subgoal (P; [x 1 ; : : : ; x d ]; Zs) is intended to hold iff Zs = 2 (f (x 1 ; x 1 ); : : : ; (x d ; x d )g ; P ): Here, and <p> N 1; q (hValues ; Placed i; XPlaced ); p (hN 0 ; Values ; XPlaced i; AllPlaced ) q (h [XjXs ]; Placed i; [XjPlaced ]) safe (hX; 1; Placed i) q (h [XjXs ]; Placed i; XPlaced ) q (hXs; Placed i; XPlaced ) Example goal: p (h5; <ref> [1; 2; 3; 4; 5] </ref>; [ ]i; P ).
Reference: [4] <author> Evan Tick. </author> <title> Parallel Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: A layered stream is a representation of a list of lists, in which common heads of adjacent sublists have been factored. This factorization allows the pruning of several branches of the search space in constant time and is also a source of parallelism <ref> [4, p. 147] </ref>. The published examples include the N -queen problem and "instant insanity" (a precursor of Ru-bik's cube). Each such deterministic, layered-stream program supposedly performs exhaustive search over the space generated by some nondeterministic, naive program. <p> However, a method converting a nondeterministic program into a corresponding exhaustive-search, layered-stream version has not yet been proposed, as far as we know [1]. Layered streams have thus remained difficult to use <ref> [4, p. 408] </ref>, since the programmer must be concerned both about factorization of heads and exhaustive search. We build upon the work of Okumura and Matsumoto by showing how to translate nondeterministic programs into exhaustive-search, layered-stream form. Our method is restricted to generate-and-test programs fitting a certain schema. <p> This allows us to include "garbage" at any level. For instance the layered stream: [ 1fl [3fl [ ]; 4fl [2fl [ ]]]; 2fl [4fl [1fl [3flbegin]]]; 3fl [1fl [4fl [2flbegin]]]; 4fl [1fl [3fl [ ]]; 2fl [ ]] ] (1) represents <ref> [[2; 4; 1; 3] </ref>; [3; 1; 4; 2]]. As an example of an exhaustive-search program using layered streams, we reproduce in problem. The answer to the goal fourQueen (begin; Z) is the layered stream given above (1). <p> This allows us to include "garbage" at any level. For instance the layered stream: [ 1fl [3fl [ ]; 4fl [2fl [ ]]]; 2fl [4fl [1fl [3flbegin]]]; 3fl [1fl [4fl [2flbegin]]]; 4fl [1fl [3fl [ ]]; 2fl [ ]] ] (1) represents [[2; 4; 1; 3]; <ref> [3; 1; 4; 2] </ref>]. As an example of an exhaustive-search program using layered streams, we reproduce in problem. The answer to the goal fourQueen (begin; Z) is the layered stream given above (1). Perhaps begin was originally so called because some layered-stream programs built the intended lists in reverse. <p> The answer to the goal fourQueen (begin; Z) is the layered stream given above (1). Perhaps begin was originally so called because some layered-stream programs built the intended lists in reverse. Garbage can be eliminated to a large extent by using variants of the predicate with symbol filter <ref> [2, 4] </ref>. For simplicity, we will not be concerned here about such elimination. We also omit mentioning the merits of layered streams, for which we refer to [2, 4]. 2 fourQueen (Xs 0 ; Xs 4 ) qs (Xs 0 ; Xs 1 ); qs (Xs 1 ; Xs 2 ); <p> Garbage can be eliminated to a large extent by using variants of the predicate with symbol filter <ref> [2, 4] </ref>. For simplicity, we will not be concerned here about such elimination. We also omit mentioning the merits of layered streams, for which we refer to [2, 4]. 2 fourQueen (Xs 0 ; Xs 4 ) qs (Xs 0 ; Xs 1 ); qs (Xs 1 ; Xs 2 ); qs (Xs 2 ; Xs 3 ); qs (Xs 3 ; Xs 4 ) qs (In; [1flOut 1 ; 2flOut 2 ; 3flOut 3 ; 4flOut 4 <p> An advantage over not think in terms of exhaustive search or layered streams. Writing a layered-stream version of the N -queen problem could perhaps be found to be relatively straightforward. Writing layered-stream programs for other problems may require considerably more cunning, as shown in <ref> [4] </ref>. Tick [4, pp. 305-310] uses 38 clauses and 12 predicates for labeling polyhedra scenes. A disadvantage of our approach at this point, however, is that we are limited to chain programs. <p> An advantage over not think in terms of exhaustive search or layered streams. Writing a layered-stream version of the N -queen problem could perhaps be found to be relatively straightforward. Writing layered-stream programs for other problems may require considerably more cunning, as shown in [4]. Tick <ref> [4, pp. 305-310] </ref> uses 38 clauses and 12 predicates for labeling polyhedra scenes. A disadvantage of our approach at this point, however, is that we are limited to chain programs. <p> If we fix the problem size, then all four layered-stream examples in <ref> [4] </ref> can readily be written in quasi-chain form: the N -queen problem [4, p. 117], instant insanity, [4, p. 241], the "turtle problem" [4, p. 266], and Waltz's polyhedra-scene labeling [4, p. 300]. <p> If we fix the problem size, then all four layered-stream examples in [4] can readily be written in quasi-chain form: the N -queen problem <ref> [4, p. 117] </ref>, instant insanity, [4, p. 241], the "turtle problem" [4, p. 266], and Waltz's polyhedra-scene labeling [4, p. 300]. <p> If we fix the problem size, then all four layered-stream examples in [4] can readily be written in quasi-chain form: the N -queen problem [4, p. 117], instant insanity, <ref> [4, p. 241] </ref>, the "turtle problem" [4, p. 266], and Waltz's polyhedra-scene labeling [4, p. 300]. <p> If we fix the problem size, then all four layered-stream examples in [4] can readily be written in quasi-chain form: the N -queen problem [4, p. 117], instant insanity, [4, p. 241], the "turtle problem" <ref> [4, p. 266] </ref>, and Waltz's polyhedra-scene labeling [4, p. 300]. <p> If we fix the problem size, then all four layered-stream examples in [4] can readily be written in quasi-chain form: the N -queen problem [4, p. 117], instant insanity, [4, p. 241], the "turtle problem" [4, p. 266], and Waltz's polyhedra-scene labeling <ref> [4, p. 300] </ref>. <p> A disadvantage of our transformation is that it is restricted to programs in quasi-chain form (actually a slight generalization allowing variable-size problems illustrated in appendix A.1). However, we were able to easily write in this form all four layered-stream examples of <ref> [4] </ref>. Out of these four examples, two of the programs produced by our method, namely the programs for the N -queen problem and instant insanity, construct exactly the same intermediate layered streams as those of the programs crafted manually (up to variable renaming). <p> This suggests that the virtues (such as the amount of parallelism) of the original programs are preserved in ours. The programs for the other two problems solved with layered streams in <ref> [4] </ref> (the turtle problem and Waltz's polyhedra-scene labeling) are incomparable with ours in this sense because of using different representations of the problem. We have demonstrated that chain programs, together with meta-interpretation and partial deduction are useful for reasoning about exhaustive search. <p> N 1; q (hValues ; Placed i; XPlaced ); p (hN 0 ; Values ; XPlaced i; AllPlaced ) q (h [XjXs ]; Placed i; [XjPlaced ]) safe (hX; 1; Placed i) q (h [XjXs ]; Placed i; XPlaced ) q (hXs; Placed i; XPlaced ) Example goal: p (h5; <ref> [1; 2; 3; 4; 5] </ref>; [ ]i; P ).
Reference: [5] <author> Kazunori Ueda. </author> <title> Making exhaustive search programs deterministic. </title> <journal> New Generation Computing, </journal> <volume> 5 </volume> <pages> 29-44, </pages> <year> 1987. </year> <month> 9 </month>
Reference-contexts: 1 Introduction Okumura and Matsumoto have published [2] examples of logic programs using a data structure they call "layered stream," especially suited for completely traversing a search space in a deterministic manner <ref> [3, 5] </ref>. A layered stream is a representation of a list of lists, in which common heads of adjacent sublists have been factored. This factorization allows the pruning of several branches of the search space in constant time and is also a source of parallelism [4, p. 147]. <p> This suggests using a breadth-first evaluation of both compositions and unions of relations. Hence, we will use a left-to-right evaluation of (3) and (4). (Using other strategies leads to meta-interpreters having essentially the same behavior as either the continuation-based <ref> [5] </ref> or the stream-based [3] exhaustive-search methods.) The top-level predicate list solve subgoal (P; [x 1 ; : : : ; x d ]; Zs) is intended to hold iff Zs = 2 (f (x 1 ; x 1 ); : : : ; (x d ; x d )g ; <p> N 1; q (hValues ; Placed i; XPlaced ); p (hN 0 ; Values ; XPlaced i; AllPlaced ) q (h [XjXs ]; Placed i; [XjPlaced ]) safe (hX; 1; Placed i) q (h [XjXs ]; Placed i; XPlaced ) q (hXs; Placed i; XPlaced ) Example goal: p (h5; <ref> [1; 2; 3; 4; 5] </ref>; [ ]i; P ).
References-found: 5

