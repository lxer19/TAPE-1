URL: ftp://www.cs.rutgers.edu/pub/technical-reports/dcs-tr-367.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: http://www.cs.rutgers.edu
Title: PRACTICAL POINTER ALIASING ANALYSIS  Written under the direction of  
Author: BY XIANG-XIANG SEAN ZHANG Barbara Gershon Ryder 
Degree: A dissertation submitted to the Graduate School|New Brunswick  in partial fulfillment of the requirements for the degree of Doctor of Philosophy  and approved by  
Date: October, 1998  
Note: Graduate Program in Computer Science  
Address: New Jersey  Brunswick, New Jersey  
Affiliation: Rutgers, The State University of  New  
Abstract-found: 0
Intro-found: 1
Reference: [AFL95] <author> Alexander Aiken, Manuel Fahndrich, and Ralph Levien. </author> <title> Better static memory management: Improving region-based analysis of higher-order languages. </title> <booktitle> In Proceedings of SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 174-185, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The analysis is mainly intraprocedural; its cost may be a problem when extending to interprocedural analysis. Region Inference <ref> [AFL95, BTV96, TT94] </ref> statically determines the lifetime of all run-time values including basic values, records, and function closures. Values of similar lifetime are grouped together to form a region, which are allocated and deallocated in a stack-like fashion. <p> The technique is aiming at achieving efficient use of memory resources and avoiding garbage collection conventionally used in implementations of applicative languages. The first region inference algorithm was given by Tofte and Taplin [TT94], which was later improved by Aiken, etc. <ref> [AFL95] </ref> and Birkedal, etc. [BTV96]. 3.6 Call Graph Construction Depending on the programming languages being considered, work in this research area can be classified into four groups. The first concerns call graph construction in the 26 presence of procedure parameters as in FORTRAN77.
Reference: [AL94a] <author> Rita Altucher and William Landi. </author> <title> Call graph analysis in the presence of function pointers. </title> <institution> presentation at Siemens Corporate Research, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: This idea of program decomposition was motivated by the work by Altucher and Landi at Siemens Corporate Research that separates the analysis of function pointers from other pointers for call graph construction <ref> [AL94a] </ref>. In Chapter 5, we present the program decomposition algorithm for programs without indirect calls, unions or casting; in Chapter 6, we extend it to handle programs with indirect calls, unions and casting by using the points-to analysis on selected parts of programs to resolve indirect calls and type casting. <p> Ghiya [Ghi92] extended Hendren's algorithm [HN89, HN90] to deal with function pointers. Emami, Ghiya, and Hendren [EGH94] handled function pointers in their points-to analysis. Altucher and Landi <ref> [AL94a] </ref> had an algorithm for constructing call graphs for programs with indirect calls through function pointers. <p> The other analysis algorithms [BCCH95, Ste95, WL95] also handle function pointers and calls through them as a part of the analyses. The idea of program decomposition for pointer aliasing analysis in this thesis was motivated by Altucher and Landi's work <ref> [AL94a] </ref>. Resolving Dynamically Bound Invocations Object-oriented languages provide the feature of dynamic bindings of method invocations at run time. In a statically typed language (e.g., C++), it is accomplished by the use of virtual methods.
Reference: [AL94b] <author> Rita Altucher and William Landi. </author> <type> Personal communication. </type> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: Furthermore, the effect of this context representation in practice is not clear as they did not provide any empirical results of their analysis. Marlowe, etc. [MLR + 93] gave a good comparison of this algorithm and Landi and Ryder's [LR92]. Altucher and Landi <ref> [AL94b] </ref> implemented an algorithm for finding program aliases. Given a program, a set of names is derived first and initially each name is in an equivalence class by itself.
Reference: [AL95] <author> Rita Altucher and William Landi. </author> <title> An extended form of must alias analysis for dynamic allocation. </title> <booktitle> In Conference Record of the 22nd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 74-84, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: The algorithm 17 is flow-sensitive, context-sensitive, and is based on the idea of abstract interpretation; it can be potentially expensive. He did not have any empirical results to show the precision and cost of the analysis. Altucher and Landi <ref> [AL95] </ref> presented an algorithm for calculating local must alias information for dynamically allocated locations. They named dynamic locations either by allocation sites in the case of calls to library allocation routines or by return nodes in the case of calls to user-defined allocation routines. <p> Shapiro and Horwitz [SH97a] presented some empirical results of GMOD analysis, live variable analysis, and program slicing for C programs. Pande, Ryder, and Landi [PRL91] worked on reaching definition and Def-Use problems for C. Altucher and Landi <ref> [AL95] </ref> improved the analyses using localized must-alias information. Ghiya and Hendren [GH98] used points-to and heap analyses for optimizations such 29 as loop-invariant removal, location-invariant removal, global common subexpression elimination, program understanding and debugging. <p> Our prototype implementation is written in C and compiled by gcc with optimization turned on (-O2). Our implementation utilizes the blackbox language <ref> [AL95] </ref> to specify effects of library functions so that one call to a library function can be treated independent of other calls to the same function; by doing this, we avoid forcing actual arguments for the same formal argument of a library function to be in the same PE equivalence class.
Reference: [And94] <author> Lars Ole Andersen. </author> <title> Program analysis and specialization for the C programming language. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <month> may </month> <year> 1994. </year>
Reference-contexts: In this thesis, we provide some solutions to the aforementioned problems. A Points-to Analysis Algorithm Inspired by Andersen's work <ref> [And94] </ref>, we developed a points-to analysis algorithm that handles unions and type casting. Instead of using constraints and constraint solving techniques, as Andersen did, we formulate the analysis as a data flow analysis. <p> The analysis computes both possible (i.e., may) and definite (i.e., must) points-to pairs, where the definite information can be used to improve the kill effect of statements. They handle function pointers naturally in the points-to analysis and construct the invocation graph incrementally. Andersen <ref> [And94] </ref> developed a flow-insensitive and context-sensitive points-to analysis algorithm, which seems to be the only one of its kind.
Reference: [APS93] <author> Ole Agesen, Jens Palsberg, and Michael Schwartzback. </author> <title> Type inference of self: Analysis of objects with dynamic and multiple inheritance. </title> <booktitle> In Proceedings of ECOOP'93, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: This problem is tantamount to type determination for objects in programs. Chambers and Ungar [CU90] proposed an iterative type analysis for SELF. Pande and Ryder [PR94] developed a static type determination algorithm for C++ in the presence of pointers. Other analyses have also been given in the literature <ref> [APS93, BS96, DGC98, GDDC97, PC94] </ref> First-class Functions in Higher-order Functional Languages In functional languages such as Scheme, functions are first class citizens. They are just data that can be created at run-time, stored into aggregates, passed as arguments to procedures, or returned as values from functions, etc.
Reference: [Ash96] <author> Michael Ashley. </author> <title> A practical and flexible flow analysis for higher-order languages. </title> <booktitle> In Conference Record of the 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 184-194, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: In essence, the algorithm is similar to these of Hall and Kennedy [HK93] and Lakhotia [Lak93]. It is not precise and may be very approximate because of the ubiquitous uses of first class functions in Scheme. Other works in this area include <ref> [Ash96, Ash97, HM97, JW95, NN97, SZ94] </ref>. 3.7 Applications Using Aliasing or Points-to Information There are many analyses or optimizations using results of aliasing or points-to analyses. In this section, we briefly mention some of these works.
Reference: [Ash97] <author> Michael Ashley. </author> <title> The effectiveness of flow analysis for inlining. </title> <booktitle> In Proceedings of the 1997 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 199-111, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: In essence, the algorithm is similar to these of Hall and Kennedy [HK93] and Lakhotia [Lak93]. It is not precise and may be very approximate because of the ubiquitous uses of first class functions in Scheme. Other works in this area include <ref> [Ash96, Ash97, HM97, JW95, NN97, SZ94] </ref>. 3.7 Applications Using Aliasing or Points-to Information There are many analyses or optimizations using results of aliasing or points-to analyses. In this section, we briefly mention some of these works.
Reference: [Ban78] <author> J. Banning. </author> <title> A method for determining the side effects of procedure calls. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering, Stanford University, </institution> <year> 1978. </year>
Reference-contexts: Without the alias information, conservative assumptions have to be made in these analyses, optimizations and tools. The call-by-reference may alias problem has been well studied <ref> [Ban78, Coo85] </ref>. There has been much research on the pointer may alias problem as well [Wei80, CR82, Cou86, LH88, Coo89, LR92, CBC93, AL94b, Deu94, AL95, NPD87, SFRW90, EGH94, And94, BCCH95, Ruf95, WL95, Ste95, Ste96a, Ste96b, SH97b]; some of the work calculate points-to information, from which may aliases can be derived.
Reference: [BCCH95] <author> Michael Burke, Paul Carini, Jong-Deok Choi, and Michael Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> number No. 892, </volume> <pages> pages 234-250. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <booktitle> Proceedings from the 7th International Workshop on Languages and Compilers for Parallel Computing. </booktitle>
Reference-contexts: His analysis considered the direct effects of type casting, but not the indirect ones such as locations being accessed inconsistently. No empirical results of the analysis were given. Burke, Carini, Choi, and Hind <ref> [BCCH95] </ref> gave a flow-insensitive, context-insensitive algorithm for finding points-to information. One difference between this algorithm and others is that they employed two kinds of precomputed kill information to improve the precision of the flow-insensitive analysis. <p> The difference between their work and others is that they safely identified pointers related to function pointers and applied Landi and Ryder aliasing analysis [LR92] to those pointers only; others simply applied analyses to all pointers. The other analysis algorithms <ref> [BCCH95, Ste95, WL95] </ref> also handle function pointers and calls through them as a part of the analyses. The idea of program decomposition for pointer aliasing analysis in this thesis was motivated by Altucher and Landi's work [AL94a].
Reference: [BS96] <author> David Bacon and Peter Sweeney. </author> <title> Fast static analysis of C++ virtual function calls. </title> <booktitle> In Proceedings of the 11th Annual Conference on Object-oriented Programming Systems, Languages, and Applications (OOPSLA'96), Octo-ber 1996. </booktitle> <pages> 235 </pages>
Reference-contexts: This problem is tantamount to type determination for objects in programs. Chambers and Ungar [CU90] proposed an iterative type analysis for SELF. Pande and Ryder [PR94] developed a static type determination algorithm for C++ in the presence of pointers. Other analyses have also been given in the literature <ref> [APS93, BS96, DGC98, GDDC97, PC94] </ref> First-class Functions in Higher-order Functional Languages In functional languages such as Scheme, functions are first class citizens. They are just data that can be created at run-time, stored into aggregates, passed as arguments to procedures, or returned as values from functions, etc.
Reference: [BTV96] <author> Lars Birkedal, Mads Tofte, and Magnus Vejlstrup. </author> <title> From region inference to von neumann machines via region representation inference. </title> <booktitle> In Conference Record of the 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 171-183, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: The analysis is mainly intraprocedural; its cost may be a problem when extending to interprocedural analysis. Region Inference <ref> [AFL95, BTV96, TT94] </ref> statically determines the lifetime of all run-time values including basic values, records, and function closures. Values of similar lifetime are grouped together to form a region, which are allocated and deallocated in a stack-like fashion. <p> The technique is aiming at achieving efficient use of memory resources and avoiding garbage collection conventionally used in implementations of applicative languages. The first region inference algorithm was given by Tofte and Taplin [TT94], which was later improved by Aiken, etc. [AFL95] and Birkedal, etc. <ref> [BTV96] </ref>. 3.6 Call Graph Construction Depending on the programming languages being considered, work in this research area can be classified into four groups. The first concerns call graph construction in the 26 presence of procedure parameters as in FORTRAN77.
Reference: [CBC93] <author> J. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedu-ral computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of the 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The analysis explicitly represents all 16 possible aliases using the k-limiting scheme [JM81], which may not be efficient with programs using recursive data structures. Choi, Burke, and Carini <ref> [CBC93] </ref> had a pointer aliasing algorithm similar to Landi and Ryder's [LR92]. There are two main differences. First, they used a compact representation of aliases, that is, aliases that can be derived from others are not explicitly represented.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fix-points. </title> <booktitle> In Conference Record of the 4th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <month> Jan. </month> <year> 1977. </year>
Reference-contexts: The support sets are used to determine if two expressions can be evaluated independently (i.e., it is used for dependence analysis). They used the approach of abstract interpretation <ref> [CC77] </ref>. 18 3.4 Points-to Analysis Points-to analysis uses the points-to representation, for example, (p,a) means variable p points to the location a. This is a partial representation of alias information as complete alias information needs to be derived from points-to pairs using transitive closure, with potential loss of precision [EGH94].
Reference: [CCHK90] <author> D. Callahan, A. Carle, M. W. Hall, and K. Kennedy. </author> <title> Constructing the procedure call multigraph. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 483-487, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: The algorithm propagates procedure vectors on an incomplete call graph and extends the call graph, when calls through procedure parameters are resolved. Her algorithm is precise. Callahan, Carle, Hall, and Kennedy <ref> [CCHK90] </ref> extended Ryder's algorithm to handle recursion. Hall and Kennedy [HK93] simplified Ryder's algorithm by propagating single pairs, each made of a procedure parameter and a procedure name, rather than procedure vectors, on incomplete call graphs. Their algorithm is more efficient, but is not as precise.
Reference: [CL97] <author> K. Cooper and J. Lu. </author> <title> Register promotion in C programs. </title> <booktitle> In Proceedings of SIGPLAN'97 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 308-319. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: There have been a lot of works in heap analysis for conflict analysis, dependence test, and parallelization [Gua88, Har89, HHN92a, HPR89, HHN92b, LH88, RRH92]. Other applications of aliasing or points-to information include register promotion <ref> [CL97] </ref> and data prefetching [LM96]. 30 Chapter 4 Flow-insensitive Points-to Analysis with Unions and Type Casting In this chapter, we present a flow-insensitive points-to analysis algorithm, which we also call the PT analysis.
Reference: [Coo71] <author> S. A. Cook. </author> <title> The complexity of theorem proving procedures. </title> <booktitle> In Proceedings of the Third Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 151-158, </pages> <year> 1971. </year>
Reference-contexts: Myers [Mye81] used the NP-complete 3-satisfiability problem <ref> [Coo71] </ref> to prove that the interprocedural live variable problem is NP-complete, the interprocedural available expression problem and must-summary problem are co-NP-complete in the presence of call-by-reference aliases. These problems are intractable because there may be an exponential number of alias sets.
Reference: [Coo85] <author> K. Cooper. </author> <title> Analyzing aliases of reference formal parameters. </title> <booktitle> In Conference Record of the 12nd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-290, </pages> <month> Jan. </month> <year> 1985. </year>
Reference-contexts: Without the alias information, conservative assumptions have to be made in these analyses, optimizations and tools. The call-by-reference may alias problem has been well studied <ref> [Ban78, Coo85] </ref>. There has been much research on the pointer may alias problem as well [Wei80, CR82, Cou86, LH88, Coo89, LR92, CBC93, AL94b, Deu94, AL95, NPD87, SFRW90, EGH94, And94, BCCH95, Ruf95, WL95, Ste95, Ste96a, Ste96b, SH97b]; some of the work calculate points-to information, from which may aliases can be derived.
Reference: [Coo89] <author> B. Cooper. </author> <title> Ambitious data flow analysis of procedural programs. </title> <type> Master's thesis, </type> <institution> University of Minnesota, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Their analysis is mainly about how to maintain these labels and is quite complicated. They used the k-limiting technique [JM81] and summary nodes to deal with unboundedness of alias graphs. The interprocedural version of the analysis propagates along unrealizable paths. Cooper <ref> [Coo89] </ref> developed an aliasing algorithm that used the last call site and a set of aliases at procedure entries to ensure that aliases are propagated interprocedurally along realizable paths. This approach may not be practical because of the potentially exponential cost in time and space.
Reference: [Cou86] <author> D. Coutant. </author> <title> Retargetable high-level alias analysis. </title> <booktitle> In Conference Record of the 13th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 110-118, </pages> <month> Jan. </month> <year> 1986. </year>
Reference-contexts: Interprocedural propagation of aliases in their algorithm is imprecise as aliases at the exit of a procedure are propagated to all calls of the procedure and thus all calling contexts are merged together. Coutant <ref> [Cou86] </ref> gave a staged analysis for finding program aliases. In the first stage, a set of language-specific alias rules are applied and a set of equations are set up.
Reference: [CR82] <author> A. Chow and A. Rudmik. </author> <title> The design of a data flow analyzer. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 106-113, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: So an iterative algorithm is used to calculate the AF F ECT relation by considering all pointer assignments and aliases for their left hand sides. The alias solution is AF F ECT fl ffi (AF F ECT fl ) &gt; . Chow and Rudmik <ref> [CR82] </ref> presented an algorithm for finding aliases at program points. Similar to Weihl's work, they handled aliases caused by both pointers and call-by-references, and used the name flp to represent any location accessible through the variable p. <p> Other works in this area include [Ash96, Ash97, HM97, JW95, NN97, SZ94]. 3.7 Applications Using Aliasing or Points-to Information There are many analyses or optimizations using results of aliasing or points-to analyses. In this section, we briefly mention some of these works. Chow and Rudmik <ref> [CR82] </ref> used the results of their aliasing analysis to compute direct MOD/REF information for statements, summary MOD/REF information for procedures, and interprocedural MOD information for call sites and procedures. In their calculation, the MOD information at one call site may include side effects caused by aliases introduced by other calls.
Reference: [CU90] <author> C. Chambers and D. Ungar. </author> <title> Iterative type analysis and extended message splitting: optimizing dynamically-typed object-oriented programs. </title> <booktitle> In Proceedings of SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 150-164, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: To reduce the overhead associated with dynamic dispatches of method invocations, static analysis has been used to resolve method invocations at compile time. This problem is tantamount to type determination for objects in programs. Chambers and Ungar <ref> [CU90] </ref> proposed an iterative type analysis for SELF. Pande and Ryder [PR94] developed a static type determination algorithm for C++ in the presence of pointers.
Reference: [CWZ90] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year> <month> 236 </month>
Reference-contexts: This may not be such a good idea because no single approach may be effective for different kinds of pointers in terms of cost and precision. The exceptions are the work on shape analysis <ref> [JM81, JM82, HN89, CWZ90, HN90, Ghi95, GH96, SRW96] </ref>, where they only focus on pointers to dynamic data structures, and the work done at McGill University [EGH94, Ghi95, GH96], where they first proposed different analyses for pointers to the stack, pointers to the heap and pointers to dynamically allocated arrays. <p> The compile-time lifetime information can be used for heap allocation optimization, for example, each allocation site can associated with a procedure such that all locations allocated at the site can be safely associated with an activation record of the procedure. Chase, Wegman and Zadeck <ref> [CWZ90] </ref> associated one storage shape graph with each program point in their shape analysis. Their approach is different from Jones and Muchnick's [JM81, JM82] in that the k-limiting technique is not used.
Reference: [Deu90] <author> Alain Deutsch. </author> <title> On determining lifetime and aliasing of dynamically allocated data in higher-order functional specifications. </title> <booktitle> In Conference Record of The 17th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages pp157-168, </pages> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: Unknown nodes may have outgoing edges and these edges are not labeled. The k-limiting notion is also used by other researchers [LR92, LH88]. Later, Jones and Muchnick [JM82] extended this work to interprocedural analysis and used the formal approach of abstract interpretation. Deutsch <ref> [Deu90] </ref> gave an analysis that determine if a location can be accessed at a 23 program point for higher order functional languages. Although the accessibility information can be used to derive other useful information such as liveness or isolation of data structures, it is really coarse-grain for other applications.
Reference: [Deu94] <author> Alain Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In Proceedings of SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The algorithm uses the lower-level offset-size representation for names to handle features such as unions and type casting. If two names may be overlapped, they are considered aliased. They also handle function pointers and indirect calls. Deutsch <ref> [Deu94] </ref> presented an aliasing analysis for recursive pointer data structures. He used regular expressions with integer variables to represent names (e.g., x ! (tl ! ) i hd, where i is 0, 1, ...).
Reference: [DGC98] <author> Greg DeFouw, David Grove, and Craig Chambers. </author> <title> Fast interprocedural class analysis. </title> <booktitle> In Conference Record of the 25th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 222-236, </pages> <month> January </month> <year> 1998. </year>
Reference-contexts: This problem is tantamount to type determination for objects in programs. Chambers and Ungar [CU90] proposed an iterative type analysis for SELF. Pande and Ryder [PR94] developed a static type determination algorithm for C++ in the presence of pointers. Other analyses have also been given in the literature <ref> [APS93, BS96, DGC98, GDDC97, PC94] </ref> First-class Functions in Higher-order Functional Languages In functional languages such as Scheme, functions are first class citizens. They are just data that can be created at run-time, stored into aggregates, passed as arguments to procedures, or returned as values from functions, etc.
Reference: [DMW98] <author> Saumya Debray, Robert Muth, and Mattew Weippert. </author> <title> Alias analysis of executable code. </title> <booktitle> In Conference Record of the 25th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 12-24, </pages> <month> Jan. </month> <year> 1998. </year>
Reference-contexts: Altucher and Landi [AL95] improved the analyses using localized must-alias information. Ghiya and Hendren [GH98] used points-to and heap analyses for optimizations such 29 as loop-invariant removal, location-invariant removal, global common subexpression elimination, program understanding and debugging. Debray, Muth, and Weippert <ref> [DMW98] </ref> presented a dependence analysis for low level representation of memory and used it in moving loop-invariant load operations out of loops. Hendren and Nicolau [HN89, HN90] used a simple shape analysis for parallelizing programs with recursive data structures.
Reference: [EGH94] <author> Maryam Emami, Rakesh Ghiya, and Laurie Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The exceptions are the work on shape analysis [JM81, JM82, HN89, CWZ90, HN90, Ghi95, GH96, SRW96], where they only focus on pointers to dynamic data structures, and the work done at McGill University <ref> [EGH94, Ghi95, GH96] </ref>, where they first proposed different analyses for pointers to the stack, pointers to the heap and pointers to dynamically allocated arrays. In this thesis, we provide some solutions to the aforementioned problems. <p> There are two main differences. First, they used a compact representation of aliases, that is, aliases that can be derived from others are not explicitly represented. This may improve analysis precision in some cases and may deteriorate precision in others <ref> [EGH94] </ref>. Second, they used an alias set and a call site to represent a call context; by doing this, they were able to differentiate calling contexts better than Landi and Ryder [LR92]. <p> This is a partial representation of alias information as complete alias information needs to be derived from points-to pairs using transitive closure, with potential loss of precision <ref> [EGH94] </ref>. For example, if we have the points-to pairs, (p,a) and (q,a), we can say (flp,flq) is an alias, but only when the two points-to pairs hold along same execution paths. <p> On the other hand, the points-to representation is more compact than the alias representation; in some cases, it can prevent extraneous aliases <ref> [EGH94] </ref>. Most points-to analyses determines may information, that is, a pointer may point to a location along some execution paths. There are few analyses that compute definite information, that is, a pointer must point to a location if it points to anything along all execution paths. <p> But the analyses are intraprocedural only and they only allow pointers to simple types (i.e., single-level pointers only, no arrays, no records as in PASCAL). Emami, Ghiya, and Hendren <ref> [EGH94] </ref> presented a flow-sensitive, context-sensitive algorithm for points-to analysis. The algorithm is mainly for points-to relations between stack locations as there is only one abstract location for all heap locations, to which all heap-directed pointers may point. <p> Finally, he solved the constraint system and instantiated the type variable for a location with a set of abstract locations, to which the location points. To identifying different contexts for procedures, he unfolded call graphs to get static call graphs, which is similar to the invocation graphs <ref> [EGH94] </ref>. If a procedure has n call contexts based on static call graphs, each of its formal parameters, location variables, allocation sites, etc., has n variants, one for each call context; each constraint derived from programs is over vectors of variants. <p> All analyses are flow-sensitive and context-sensitive, similar to <ref> [EGH94] </ref>. Ghiya and Hendren [GH96] presented a flow-sensitive, context-sensitive algorithm of shape analysis for C programs. The analysis is performed after a points-to analysis [EGH94] and focuses on pointers found to point to heap by the points-to analysis. <p> All analyses are flow-sensitive and context-sensitive, similar to <ref> [EGH94] </ref>. Ghiya and Hendren [GH96] presented a flow-sensitive, context-sensitive algorithm of shape analysis for C programs. The analysis is performed after a points-to analysis [EGH94] and focuses on pointers found to point to heap by the points-to analysis. They use storeless abstractions (i.e., relationships between names) such as direction matrix and interface matrix, which are similar to path matrix [HN89, HN90]. <p> They use storeless abstractions (i.e., relationships between names) such as direction matrix and interface matrix, which are similar to path matrix [HN89, HN90]. These are very simple yet practical abstractions, but may not be powerful enough for programs with many structure changes. The invocation graph <ref> [EGH94] </ref> is used to make the analysis 25 context-sensitive, but also makes the analysis costly that it may not scale to large programs. Sagiv, Reps and Wilhelm [SRW96] presented an intraprocedural, flow-sensitive algorithm of shape analysis for LISP-like languages. <p> Ghiya [Ghi92] extended Hendren's algorithm [HN89, HN90] to deal with function pointers. Emami, Ghiya, and Hendren <ref> [EGH94] </ref> handled function pointers in their points-to analysis. Altucher and Landi [AL94a] had an algorithm for constructing call graphs for programs with indirect calls through function pointers. <p> Landi, Ryder and Zhang [LRZ93] developed an algorithm for the modification side effect analysis for C using Landi and Ryder's aliasing algorithm [LR92]. The algorithm can also be used with other aliasing analyses [SRLZ98]. Empirical results of modification or references through pointer indirections were also reported in <ref> [EGH94, ZRL96] </ref>. Shapiro and Horwitz [SH97a] presented some empirical results of GMOD analysis, live variable analysis, and program slicing for C programs. Pande, Ryder, and Landi [PRL91] worked on reaching definition and Def-Use problems for C. Altucher and Landi [AL95] improved the analyses using localized must-alias information.
Reference: [GDDC97] <author> David Grove, Greg DeFouw, Jeffrey Dean, and Craig Chambers. </author> <title> Call graph construction in object-oriented languages. </title> <booktitle> In Proceedings of the 12th Annual Conference on Object-oriented Programming Systems, Languages, and Applications (OOPSLA'97), </booktitle> <pages> pages 108-124, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: This problem is tantamount to type determination for objects in programs. Chambers and Ungar [CU90] proposed an iterative type analysis for SELF. Pande and Ryder [PR94] developed a static type determination algorithm for C++ in the presence of pointers. Other analyses have also been given in the literature <ref> [APS93, BS96, DGC98, GDDC97, PC94] </ref> First-class Functions in Higher-order Functional Languages In functional languages such as Scheme, functions are first class citizens. They are just data that can be created at run-time, stored into aggregates, passed as arguments to procedures, or returned as values from functions, etc.
Reference: [GH96] <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Is it a tree, a dag, or a cyclic graph? a shape analysis for heap-directed pointers in C. </title> <booktitle> In Conference Record of the 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: This may not be such a good idea because no single approach may be effective for different kinds of pointers in terms of cost and precision. The exceptions are the work on shape analysis <ref> [JM81, JM82, HN89, CWZ90, HN90, Ghi95, GH96, SRW96] </ref>, where they only focus on pointers to dynamic data structures, and the work done at McGill University [EGH94, Ghi95, GH96], where they first proposed different analyses for pointers to the stack, pointers to the heap and pointers to dynamically allocated arrays. <p> The exceptions are the work on shape analysis [JM81, JM82, HN89, CWZ90, HN90, Ghi95, GH96, SRW96], where they only focus on pointers to dynamic data structures, and the work done at McGill University <ref> [EGH94, Ghi95, GH96] </ref>, where they first proposed different analyses for pointers to the stack, pointers to the heap and pointers to dynamically allocated arrays. In this thesis, we provide some solutions to the aforementioned problems. <p> All analyses are flow-sensitive and context-sensitive, similar to [EGH94]. Ghiya and Hendren <ref> [GH96] </ref> presented a flow-sensitive, context-sensitive algorithm of shape analysis for C programs. The analysis is performed after a points-to analysis [EGH94] and focuses on pointers found to point to heap by the points-to analysis.
Reference: [GH98] <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Putting pointer analysis to work. </title> <booktitle> In Conference Record of the 25th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 121-133, </pages> <month> Jan. </month> <year> 1998. </year>
Reference-contexts: Shapiro and Horwitz [SH97a] presented some empirical results of GMOD analysis, live variable analysis, and program slicing for C programs. Pande, Ryder, and Landi [PRL91] worked on reaching definition and Def-Use problems for C. Altucher and Landi [AL95] improved the analyses using localized must-alias information. Ghiya and Hendren <ref> [GH98] </ref> used points-to and heap analyses for optimizations such 29 as loop-invariant removal, location-invariant removal, global common subexpression elimination, program understanding and debugging. Debray, Muth, and Weippert [DMW98] presented a dependence analysis for low level representation of memory and used it in moving loop-invariant load operations out of loops.
Reference: [Ghi92] <author> Rakesh Ghiya. </author> <title> Interprocedural analysis in the presence of function pointers. </title> <type> ACAPS Technical Memo 62, </type> <institution> McGill University, School of Computer Science, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: Therefore, most aliasing or points-to analysis algorithms can be adapted for function pointers to construct call graphs incrementally. 27 Weihl's aliasing algorithm [Wei80] can handle procedure variables and build call graphs incrementally as values for procedure variables are determined. Ghiya <ref> [Ghi92] </ref> extended Hendren's algorithm [HN89, HN90] to deal with function pointers. Emami, Ghiya, and Hendren [EGH94] handled function pointers in their points-to analysis. Altucher and Landi [AL94a] had an algorithm for constructing call graphs for programs with indirect calls through function pointers.
Reference: [Ghi95] <author> Rakesh Ghiya. </author> <title> Practical techniques for interprocedural heap analysis. </title> <type> Master's thesis, </type> <institution> McGill University, Montreal, Canada, </institution> <month> march </month> <year> 1995. </year>
Reference-contexts: This may not be such a good idea because no single approach may be effective for different kinds of pointers in terms of cost and precision. The exceptions are the work on shape analysis <ref> [JM81, JM82, HN89, CWZ90, HN90, Ghi95, GH96, SRW96] </ref>, where they only focus on pointers to dynamic data structures, and the work done at McGill University [EGH94, Ghi95, GH96], where they first proposed different analyses for pointers to the stack, pointers to the heap and pointers to dynamically allocated arrays. <p> The exceptions are the work on shape analysis [JM81, JM82, HN89, CWZ90, HN90, Ghi95, GH96, SRW96], where they only focus on pointers to dynamic data structures, and the work done at McGill University <ref> [EGH94, Ghi95, GH96] </ref>, where they first proposed different analyses for pointers to the stack, pointers to the heap and pointers to dynamically allocated arrays. In this thesis, we provide some solutions to the aforementioned problems. <p> One path matrix is associated with each program point. The analysis is flow-sensitive and is able to detect list or tree structures, but gives up on cyclic data structures. A unique feature of the analysis is that may and must information is maintained simultaneously in path matrices. Ghiya <ref> [Ghi95] </ref> proposed three analyses that focused on heap-directed pointers. Three kinds of matrices are calculated by the analyses, one by each analysis. All matrices are variations of path matrices [HN89, HN90], but only contain boolean values; they are designed to collect coarse path information efficiently.
Reference: [Gua88] <author> Vincent A. Guarna. </author> <title> A technique for analyzing pointer and structure references in parallel restructuring compilers. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <pages> pages 2 212-220, </pages> <year> 1988. </year>
Reference-contexts: Hendren and Nicolau [HN89, HN90] used a simple shape analysis for parallelizing programs with recursive data structures. There have been a lot of works in heap analysis for conflict analysis, dependence test, and parallelization <ref> [Gua88, Har89, HHN92a, HPR89, HHN92b, LH88, RRH92] </ref>. Other applications of aliasing or points-to information include register promotion [CL97] and data prefetching [LM96]. 30 Chapter 4 Flow-insensitive Points-to Analysis with Unions and Type Casting In this chapter, we present a flow-insensitive points-to analysis algorithm, which we also call the PT analysis.
Reference: [Har89] <author> Williams Ludwell Harrison. </author> <title> The interprocedural analysis and automatic parallelization of scheme programs. LISP and Symbolic Computation, </title> <address> 2(3-4):179-396, </address> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Hendren and Nicolau [HN89, HN90] used a simple shape analysis for parallelizing programs with recursive data structures. There have been a lot of works in heap analysis for conflict analysis, dependence test, and parallelization <ref> [Gua88, Har89, HHN92a, HPR89, HHN92b, LH88, RRH92] </ref>. Other applications of aliasing or points-to information include register promotion [CL97] and data prefetching [LM96]. 30 Chapter 4 Flow-insensitive Points-to Analysis with Unions and Type Casting In this chapter, we present a flow-insensitive points-to analysis algorithm, which we also call the PT analysis.
Reference: [Hec77] <author> M. S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> Elsevier North-Holland, </publisher> <year> 1977. </year> <month> 237 </month>
Reference-contexts: Finally, in Section 3.7, some analyses or optimizations that use aliasing or points-to results are briefly mentioned. 3.1 Program Decomposition for Data Flow Analyses Any of the traditional data flow problems such as reaching definitions and live variables problems <ref> [Hec77] </ref>, when solved for a program without any aliasing, can be thought of as a set of subproblems, one for each variable in the program. Each subproblem can be solved independent of others. The program can be easily decomposed for these subproblems.
Reference: [HHN92a] <author> Laurie Hendren, Joseph Hummel, and Alexandru Nicolau. </author> <title> Abstractions for recursive pointer data structures: improving the analysis and transformation of imperative programs. </title> <booktitle> In Proceedings of SIGPLAN'92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 249-260, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Hendren and Nicolau [HN89, HN90] used a simple shape analysis for parallelizing programs with recursive data structures. There have been a lot of works in heap analysis for conflict analysis, dependence test, and parallelization <ref> [Gua88, Har89, HHN92a, HPR89, HHN92b, LH88, RRH92] </ref>. Other applications of aliasing or points-to information include register promotion [CL97] and data prefetching [LM96]. 30 Chapter 4 Flow-insensitive Points-to Analysis with Unions and Type Casting In this chapter, we present a flow-insensitive points-to analysis algorithm, which we also call the PT analysis.
Reference: [HHN92b] <author> Joseph Hummel, Laurie Hendren, and Alexandru Nicolau. </author> <title> Applying an anstract data structure description approach to parallelizing scientific pointer programs. </title> <booktitle> In Proceedings of 1992 international conference on parallel processing, </booktitle> <pages> pages 100-104, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Hendren and Nicolau [HN89, HN90] used a simple shape analysis for parallelizing programs with recursive data structures. There have been a lot of works in heap analysis for conflict analysis, dependence test, and parallelization <ref> [Gua88, Har89, HHN92a, HPR89, HHN92b, LH88, RRH92] </ref>. Other applications of aliasing or points-to information include register promotion [CL97] and data prefetching [LM96]. 30 Chapter 4 Flow-insensitive Points-to Analysis with Unions and Type Casting In this chapter, we present a flow-insensitive points-to analysis algorithm, which we also call the PT analysis.
Reference: [HK93] <author> Mary W. Hall and Ken Kennedy. </author> <title> Efficient call graph analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(3) </volume> <pages> 227-242, </pages> <year> 1993. </year>
Reference-contexts: The algorithm propagates procedure vectors on an incomplete call graph and extends the call graph, when calls through procedure parameters are resolved. Her algorithm is precise. Callahan, Carle, Hall, and Kennedy [CCHK90] extended Ryder's algorithm to handle recursion. Hall and Kennedy <ref> [HK93] </ref> simplified Ryder's algorithm by propagating single pairs, each made of a procedure parameter and a procedure name, rather than procedure vectors, on incomplete call graphs. Their algorithm is more efficient, but is not as precise. <p> Since functions can be created at run time in Scheme, the algorithm collapses all functions created at a program point to one static function. In essence, the algorithm is similar to these of Hall and Kennedy <ref> [HK93] </ref> and Lakhotia [Lak93]. It is not precise and may be very approximate because of the ubiquitous uses of first class functions in Scheme.
Reference: [HM97] <author> Nevin Heintze and David McAllester. </author> <title> Linear-time subtransitive control flow analysis. </title> <booktitle> In Proceedings of SIGPLAN'97 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 261-272, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: In essence, the algorithm is similar to these of Hall and Kennedy [HK93] and Lakhotia [Lak93]. It is not precise and may be very approximate because of the ubiquitous uses of first class functions in Scheme. Other works in this area include <ref> [Ash96, Ash97, HM97, JW95, NN97, SZ94] </ref>. 3.7 Applications Using Aliasing or Points-to Information There are many analyses or optimizations using results of aliasing or points-to analyses. In this section, we briefly mention some of these works.
Reference: [HN89] <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages (II) 49-56, </pages> <year> 1989. </year>
Reference-contexts: This may not be such a good idea because no single approach may be effective for different kinds of pointers in terms of cost and precision. The exceptions are the work on shape analysis <ref> [JM81, JM82, HN89, CWZ90, HN90, Ghi95, GH96, SRW96] </ref>, where they only focus on pointers to dynamic data structures, and the work done at McGill University [EGH94, Ghi95, GH96], where they first proposed different analyses for pointers to the stack, pointers to the heap and pointers to dynamically allocated arrays. <p> Strong updates are used to improve analysis precision in certain circumstances. For implementation, they employ an efficient data structures for storage shape graphs. Hendren <ref> [HN89, HN90] </ref> gave an analysis that focused on relationships among pointers. <p> A unique feature of the analysis is that may and must information is maintained simultaneously in path matrices. Ghiya [Ghi95] proposed three analyses that focused on heap-directed pointers. Three kinds of matrices are calculated by the analyses, one by each analysis. All matrices are variations of path matrices <ref> [HN89, HN90] </ref>, but only contain boolean values; they are designed to collect coarse path information efficiently. <p> The analysis is performed after a points-to analysis [EGH94] and focuses on pointers found to point to heap by the points-to analysis. They use storeless abstractions (i.e., relationships between names) such as direction matrix and interface matrix, which are similar to path matrix <ref> [HN89, HN90] </ref>. These are very simple yet practical abstractions, but may not be powerful enough for programs with many structure changes. The invocation graph [EGH94] is used to make the analysis 25 context-sensitive, but also makes the analysis costly that it may not scale to large programs. <p> Therefore, most aliasing or points-to analysis algorithms can be adapted for function pointers to construct call graphs incrementally. 27 Weihl's aliasing algorithm [Wei80] can handle procedure variables and build call graphs incrementally as values for procedure variables are determined. Ghiya [Ghi92] extended Hendren's algorithm <ref> [HN89, HN90] </ref> to deal with function pointers. Emami, Ghiya, and Hendren [EGH94] handled function pointers in their points-to analysis. Altucher and Landi [AL94a] had an algorithm for constructing call graphs for programs with indirect calls through function pointers. <p> Debray, Muth, and Weippert [DMW98] presented a dependence analysis for low level representation of memory and used it in moving loop-invariant load operations out of loops. Hendren and Nicolau <ref> [HN89, HN90] </ref> used a simple shape analysis for parallelizing programs with recursive data structures. There have been a lot of works in heap analysis for conflict analysis, dependence test, and parallelization [Gua88, Har89, HHN92a, HPR89, HHN92b, LH88, RRH92].
Reference: [HN90] <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transaction on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <year> 1990. </year>
Reference-contexts: This may not be such a good idea because no single approach may be effective for different kinds of pointers in terms of cost and precision. The exceptions are the work on shape analysis <ref> [JM81, JM82, HN89, CWZ90, HN90, Ghi95, GH96, SRW96] </ref>, where they only focus on pointers to dynamic data structures, and the work done at McGill University [EGH94, Ghi95, GH96], where they first proposed different analyses for pointers to the stack, pointers to the heap and pointers to dynamically allocated arrays. <p> Strong updates are used to improve analysis precision in certain circumstances. For implementation, they employ an efficient data structures for storage shape graphs. Hendren <ref> [HN89, HN90] </ref> gave an analysis that focused on relationships among pointers. <p> A unique feature of the analysis is that may and must information is maintained simultaneously in path matrices. Ghiya [Ghi95] proposed three analyses that focused on heap-directed pointers. Three kinds of matrices are calculated by the analyses, one by each analysis. All matrices are variations of path matrices <ref> [HN89, HN90] </ref>, but only contain boolean values; they are designed to collect coarse path information efficiently. <p> The analysis is performed after a points-to analysis [EGH94] and focuses on pointers found to point to heap by the points-to analysis. They use storeless abstractions (i.e., relationships between names) such as direction matrix and interface matrix, which are similar to path matrix <ref> [HN89, HN90] </ref>. These are very simple yet practical abstractions, but may not be powerful enough for programs with many structure changes. The invocation graph [EGH94] is used to make the analysis 25 context-sensitive, but also makes the analysis costly that it may not scale to large programs. <p> Therefore, most aliasing or points-to analysis algorithms can be adapted for function pointers to construct call graphs incrementally. 27 Weihl's aliasing algorithm [Wei80] can handle procedure variables and build call graphs incrementally as values for procedure variables are determined. Ghiya [Ghi92] extended Hendren's algorithm <ref> [HN89, HN90] </ref> to deal with function pointers. Emami, Ghiya, and Hendren [EGH94] handled function pointers in their points-to analysis. Altucher and Landi [AL94a] had an algorithm for constructing call graphs for programs with indirect calls through function pointers. <p> Debray, Muth, and Weippert [DMW98] presented a dependence analysis for low level representation of memory and used it in moving loop-invariant load operations out of loops. Hendren and Nicolau <ref> [HN89, HN90] </ref> used a simple shape analysis for parallelizing programs with recursive data structures. There have been a lot of works in heap analysis for conflict analysis, dependence test, and parallelization [Gua88, Har89, HHN92a, HPR89, HHN92b, LH88, RRH92].
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of SIGPLAN'89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Hendren and Nicolau [HN89, HN90] used a simple shape analysis for parallelizing programs with recursive data structures. There have been a lot of works in heap analysis for conflict analysis, dependence test, and parallelization <ref> [Gua88, Har89, HHN92a, HPR89, HHN92b, LH88, RRH92] </ref>. Other applications of aliasing or points-to information include register promotion [CL97] and data prefetching [LM96]. 30 Chapter 4 Flow-insensitive Points-to Analysis with Unions and Type Casting In this chapter, we present a flow-insensitive points-to analysis algorithm, which we also call the PT analysis.
Reference: [JM81] <author> Neil D. Jones and Steven S. Muchnick. </author> <title> Flow analysis and optimization of lisp-like structures. </title> <editor> In Steven S. Muchnick and Neil D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, Inc., </publisher> <year> 1981. </year>
Reference-contexts: This may not be such a good idea because no single approach may be effective for different kinds of pointers in terms of cost and precision. The exceptions are the work on shape analysis <ref> [JM81, JM82, HN89, CWZ90, HN90, Ghi95, GH96, SRW96] </ref>, where they only focus on pointers to dynamic data structures, and the work done at McGill University [EGH94, Ghi95, GH96], where they first proposed different analyses for pointers to the stack, pointers to the heap and pointers to dynamically allocated arrays. <p> The labels in alias graphs are very important because they allow accesses at different statements to be compared and conflicts to be detected. Their analysis is mainly about how to maintain these labels and is quite complicated. They used the k-limiting technique <ref> [JM81] </ref> and summary nodes to deal with unboundedness of alias graphs. The interprocedural version of the analysis propagates along unrealizable paths. <p> They presented empirical results of the analysis on a set of test programs and discussed various cases in which approximation must be made for the safety of the analysis. The analysis explicitly represents all 16 possible aliases using the k-limiting scheme <ref> [JM81] </ref>, which may not be efficient with programs using recursive data structures. Choi, Burke, and Carini [CBC93] had a pointer aliasing algorithm similar to Landi and Ryder's [LR92]. There are two main differences. <p> The latter tries to determine the lifetime of dynamic data structures; this information is useful for heap optimizations such as compile-time garbage collection, stack allocations instead of heap allocations. Usually, neither analysis considers aliasing among stack locations. Jones and Muchnick <ref> [JM81] </ref> first worked on the shape analysis problem for first order LISP-like languages. Their analysis, which is intraprocedural only, calculates for each program point a set of graphs representing stores on one or more execution paths up to the program point. <p> Chase, Wegman and Zadeck [CWZ90] associated one storage shape graph with each program point in their shape analysis. Their approach is different from Jones and Muchnick's <ref> [JM81, JM82] </ref> in that the k-limiting technique is not used. Nodes in storage shape graphs are merged only if they are allocated by the same statement and if other conditions are true, for example, they are not pointed to by a variable.
Reference: [JM82] <author> Neil D. Jones and Steven S. Muchnick. </author> <title> A flexible approach to interprocedu-ral data flow analysis and programs with recursive data structures. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <year> 1982. </year>
Reference-contexts: This may not be such a good idea because no single approach may be effective for different kinds of pointers in terms of cost and precision. The exceptions are the work on shape analysis <ref> [JM81, JM82, HN89, CWZ90, HN90, Ghi95, GH96, SRW96] </ref>, where they only focus on pointers to dynamic data structures, and the work done at McGill University [EGH94, Ghi95, GH96], where they first proposed different analyses for pointers to the stack, pointers to the heap and pointers to dynamically allocated arrays. <p> Unknown nodes may have outgoing edges and these edges are not labeled. The k-limiting notion is also used by other researchers [LR92, LH88]. Later, Jones and Muchnick <ref> [JM82] </ref> extended this work to interprocedural analysis and used the formal approach of abstract interpretation. Deutsch [Deu90] gave an analysis that determine if a location can be accessed at a 23 program point for higher order functional languages. <p> Chase, Wegman and Zadeck [CWZ90] associated one storage shape graph with each program point in their shape analysis. Their approach is different from Jones and Muchnick's <ref> [JM81, JM82] </ref> in that the k-limiting technique is not used. Nodes in storage shape graphs are merged only if they are allocated by the same statement and if other conditions are true, for example, they are not pointed to by a variable.
Reference: [JW95] <author> Suresh Jagannathan and Stephen Weeks. </author> <title> A unified treatment of flow analysis in higher-order languages. </title> <booktitle> In Conference Record of the 22nd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 393-407, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: In essence, the algorithm is similar to these of Hall and Kennedy [HK93] and Lakhotia [Lak93]. It is not precise and may be very approximate because of the ubiquitous uses of first class functions in Scheme. Other works in this area include <ref> [Ash96, Ash97, HM97, JW95, NN97, SZ94] </ref>. 3.7 Applications Using Aliasing or Points-to Information There are many analyses or optimizations using results of aliasing or points-to analyses. In this section, we briefly mention some of these works.
Reference: [KR88] <author> Brian W. Kernighan and Dennis M. Richie. </author> <title> The C Programming Language. </title> <booktitle> Prentice-Hall,Englewood Cliffs,NJ, 2nd edition, </booktitle> <year> 1988. </year>
Reference-contexts: In the analysis, assignments are treated asymmetrically, that is, given an assignment lhs = rhs, lhs points to whatever rhs points to, but not vice versa. Declared unions are considered by calculating their common initial sequences <ref> [KR88] </ref> and treating names in the common initial sequences as aliases.
Reference: [Lak93] <author> Arun Lakhotia. </author> <title> Constructing call multigraphs using dependence graphs. </title> <booktitle> In Conference Record of the 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 273-284, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Hall and Kennedy [HK93] simplified Ryder's algorithm by propagating single pairs, each made of a procedure parameter and a procedure name, rather than procedure vectors, on incomplete call graphs. Their algorithm is more efficient, but is not as precise. Lakhotia <ref> [Lak93] </ref> gave a more general algorithm which allows assignments for what he called procedure variables. The algorithm propagates single pairs on program dependence graphs. His algorithm treats procedure calls through these variables as arbitrary branches and thus is approximate. <p> Since functions can be created at run time in Scheme, the algorithm collapses all functions created at a program point to one static function. In essence, the algorithm is similar to these of Hall and Kennedy [HK93] and Lakhotia <ref> [Lak93] </ref>. It is not precise and may be very approximate because of the ubiquitous uses of first class functions in Scheme.
Reference: [Lan92] <author> William Landi. </author> <title> Undecidability of static analysis. </title> <journal> ACM letters on programming languages and systems, </journal> <volume> 1 </volume> <pages> 323-337, </pages> <year> 1992. </year> <month> 238 </month>
Reference-contexts: Their proofs of NP-hardness are also variations of Myers's. Landi <ref> [Lan92] </ref> showed that the may aliasing problem is P-space hard for any finite number ( 2) of pointer dereferences and is undecidable for recursive data structures, where the number of dereferences is not known at compile time.
Reference: [Lar91] <author> James R. Larus. </author> <title> Compiling lisp programs for parallel execution. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 4 </volume> <pages> 29-99, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: These problems are intractable because there may be an exponential number of alias sets. Using a variation of the proof by Myers, Larus <ref> [Lar91] </ref> proved that the intraproce-dural aliasing problem in the presence of dynamic data structures is NP-complete.
Reference: [LH88] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: To remedy this, she allowed user-provided specifications of effects of procedures. The alias rules such as the assignment rule and the delayed-action rule for fl , are very similar to our constraints or data flow equations for points-to analysis in Chapter 4. Larus and Hilfinger <ref> [LH88] </ref> calculated alias graphs at program points. Nodes in alias graphs represent variables or structure locations and edges represent pointers. Edges are labeled with structure member names and nodes are labeled with paths in alias graphs. Intuitively, alias graphs describe relations between variables, structures, and pointers. <p> Nodes beyond labeled paths of length k are partitioned into undirected connected components and all nodes in each component are collapsed into a unknown node. Unknown nodes may have outgoing edges and these edges are not labeled. The k-limiting notion is also used by other researchers <ref> [LR92, LH88] </ref>. Later, Jones and Muchnick [JM82] extended this work to interprocedural analysis and used the formal approach of abstract interpretation. Deutsch [Deu90] gave an analysis that determine if a location can be accessed at a 23 program point for higher order functional languages. <p> Hendren and Nicolau [HN89, HN90] used a simple shape analysis for parallelizing programs with recursive data structures. There have been a lot of works in heap analysis for conflict analysis, dependence test, and parallelization <ref> [Gua88, Har89, HHN92a, HPR89, HHN92b, LH88, RRH92] </ref>. Other applications of aliasing or points-to information include register promotion [CL97] and data prefetching [LM96]. 30 Chapter 4 Flow-insensitive Points-to Analysis with Unions and Type Casting In this chapter, we present a flow-insensitive points-to analysis algorithm, which we also call the PT analysis.
Reference: [LM96] <author> C. Luk and T. Mowry. </author> <title> Compiler-based prefetching for recursive data structures. </title> <booktitle> In Proceedings of the Seventh International Conference on Arche-tectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 222-233, </pages> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: There have been a lot of works in heap analysis for conflict analysis, dependence test, and parallelization [Gua88, Har89, HHN92a, HPR89, HHN92b, LH88, RRH92]. Other applications of aliasing or points-to information include register promotion [CL97] and data prefetching <ref> [LM96] </ref>. 30 Chapter 4 Flow-insensitive Points-to Analysis with Unions and Type Casting In this chapter, we present a flow-insensitive points-to analysis algorithm, which we also call the PT analysis.
Reference: [LR91] <author> William Landi and Barbara G. Ryder. </author> <title> Pointer-induced aliasing: a problem classification. </title> <booktitle> In Conference Record of the 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: These problems are intractable because there may be an exponential number of alias sets. Using a variation of the proof by Myers, Larus [Lar91] proved that the intraproce-dural aliasing problem in the presence of dynamic data structures is NP-complete. Landi and Ryder <ref> [LR91] </ref> proved that both the may aliasing problem and the must aliasing problem (intraprocedural or interprocedural) are polynomial for single-level pointers (i.e., only one pointer dereference is allowed); they also showed the intraproce-dural may aliasing problem is NP-hard and the intraprocedural must aliasing problem is co-NP-hard for for multiple-level pointers (i.e.,
Reference: [LR92] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of 1992 ACM Symposium on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: In Chapter 4, we present the points-to analysis algorithm and compare it empirically with the Landi/Ryder aliasing algorithm <ref> [LR92] </ref>. Our empirical results show the points-to analysis is fast and almost as precise as the Landi/Ryder algorithm for some test programs. Program decomposition We developed an algorithm that calculates an equivalence relation on the names in a program. <p> Cooper [Coo89] developed an aliasing algorithm that used the last call site and a set of aliases at procedure entries to ensure that aliases are propagated interprocedurally along realizable paths. This approach may not be practical because of the potentially exponential cost in time and space. Landi and Ryder <ref> [LR92] </ref> gave a flow-sensitive and context-sensitive algorithm for pointer aliasing analysis. The algorithm calculates program-point-specific may aliases. Interprocedurally, it uses assumed aliases for calling contexts. <p> The analysis explicitly represents all 16 possible aliases using the k-limiting scheme [JM81], which may not be efficient with programs using recursive data structures. Choi, Burke, and Carini [CBC93] had a pointer aliasing algorithm similar to Landi and Ryder's <ref> [LR92] </ref>. There are two main differences. First, they used a compact representation of aliases, that is, aliases that can be derived from others are not explicitly represented. This may improve analysis precision in some cases and may deteriorate precision in others [EGH94]. <p> This may improve analysis precision in some cases and may deteriorate precision in others [EGH94]. Second, they used an alias set and a call site to represent a call context; by doing this, they were able to differentiate calling contexts better than Landi and Ryder <ref> [LR92] </ref>. However, even with this representation, a mix of aliases from different calls may still happen as the call sites in their representation are just simple call chains of length 1. <p> Furthermore, the effect of this context representation in practice is not clear as they did not provide any empirical results of their analysis. Marlowe, etc. [MLR + 93] gave a good comparison of this algorithm and Landi and Ryder's <ref> [LR92] </ref>. Altucher and Landi [AL94b] implemented an algorithm for finding program aliases. Given a program, a set of names is derived first and initially each name is in an equivalence class by itself. <p> Nodes beyond labeled paths of length k are partitioned into undirected connected components and all nodes in each component are collapsed into a unknown node. Unknown nodes may have outgoing edges and these edges are not labeled. The k-limiting notion is also used by other researchers <ref> [LR92, LH88] </ref>. Later, Jones and Muchnick [JM82] extended this work to interprocedural analysis and used the formal approach of abstract interpretation. Deutsch [Deu90] gave an analysis that determine if a location can be accessed at a 23 program point for higher order functional languages. <p> Altucher and Landi [AL94a] had an algorithm for constructing call graphs for programs with indirect calls through function pointers. The difference between their work and others is that they safely identified pointers related to function pointers and applied Landi and Ryder aliasing analysis <ref> [LR92] </ref> to those pointers only; others simply applied analyses to all pointers. The other analysis algorithms [BCCH95, Ste95, WL95] also handle function pointers and calls through them as a part of the analyses. <p> In their calculation, the MOD information at one call site may include side effects caused by aliases introduced by other calls. Landi, Ryder and Zhang [LRZ93] developed an algorithm for the modification side effect analysis for C using Landi and Ryder's aliasing algorithm <ref> [LR92] </ref>. The algorithm can also be used with other aliasing analyses [SRLZ98]. Empirical results of modification or references through pointer indirections were also reported in [EGH94, ZRL96]. Shapiro and Horwitz [SH97a] presented some empirical results of GMOD analysis, live variable analysis, and program slicing for C programs. <p> Thru-deref MOD/REF Results In Figures 4.25 and 4.26, we present the Thru-deref MOD/REF results of the PT analysis for the test programs. For comparison, we also show the Thru-deref MOD/REF results of an extended version of the Landi/Ryder flow- and context-sensitive aliasing analysis (the FS analysis) <ref> [LR92] </ref> for 8 of the test programs; for other test programs, the FS analysis runs out of memory after a while. The extended Landi/Ryder's algorithm handles unions and type casting in a different way from ours. <p> Statements have IDs associated with them, where an ID is in the range of 1..(# of statements). Conditional and goto statements use statement IDs for their destinations. This is a quadruple representation and it can be depicted in a graphical form such as the ICFG <ref> [LR92] </ref>. Object names are used extensively in the representation. 5.2 Relations on Sets of Object Names For easy presentation, we will not consider accessor [ ] and names with [ ] in them in this chapter. We will consider those names in the next chapter. <p> Statements have IDs associated with them, where an ID is in the range of 1..(# of statements). Conditional and goto statements use statement IDs for their destinations. This is a quadruple representation and it can be depicted in a graphical form such as the ICFG <ref> [LR92] </ref>. We will have the same restrictions on input programs as those mentioned in Section 4.4.4. Some of the restrictions are reflected in the intermediate representation; for example, a C program with type casting between a pointer and an integer, can not be translated into the representation. <p> For our experiments with three combined analyses, we have used the following analysis algorithms: 1. the Landi/Ryder flow-sensitive and context-sensitive aliasing algorithm <ref> [LR92, SRLZ98] </ref> (the FS analysis) 2. a flow-insensitive and context-insensitive points-to analysis algorithm presented in Chapter 4 (the PT analysis) 165 3. a flow-insensitive and context-insensitive aliasing analysis algorithm presented in Chapter 6 (the FA analysis) Both the FA and PT analyses can handle unions and type casting with some restrictions.
Reference: [LRZ93] <author> William Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of SIG-PLAN'93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In their calculation, the MOD information at one call site may include side effects caused by aliases introduced by other calls. Landi, Ryder and Zhang <ref> [LRZ93] </ref> developed an algorithm for the modification side effect analysis for C using Landi and Ryder's aliasing algorithm [LR92]. The algorithm can also be used with other aliasing analyses [SRLZ98]. Empirical results of modification or references through pointer indirections were also reported in [EGH94, ZRL96].
Reference: [MLR + 93] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. D. Choi, M. G. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: a clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <year> 1993. </year>
Reference-contexts: Furthermore, the effect of this context representation in practice is not clear as they did not provide any empirical results of their analysis. Marlowe, etc. <ref> [MLR + 93] </ref> gave a good comparison of this algorithm and Landi and Ryder's [LR92]. Altucher and Landi [AL94b] implemented an algorithm for finding program aliases. Given a program, a set of names is derived first and initially each name is in an equivalence class by itself.
Reference: [Mye81] <author> E. Myers. </author> <title> A precise interprocedural data flow algorithm. </title> <booktitle> In Conference Record of the 8th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <month> Jan. </month> <year> 1981. </year>
Reference-contexts: One of his target problems was points-to analysis. 13 3.2 Theoretic Classification of Aliasing-related Problems Weihl [Wei80] proved that the problem of determining possible values for procedure variables (i.e., single-level function pointers in C) for programs without any other aliasing is P-space hard. Myers <ref> [Mye81] </ref> used the NP-complete 3-satisfiability problem [Coo71] to prove that the interprocedural live variable problem is NP-complete, the interprocedural available expression problem and must-summary problem are co-NP-complete in the presence of call-by-reference aliases. These problems are intractable because there may be an exponential number of alias sets.
Reference: [NN97] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Infinitary control flow analysis: A collecting semantics for closure analysis. </title> <booktitle> In Conference Record of the 24th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 332-345, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: In essence, the algorithm is similar to these of Hall and Kennedy [HK93] and Lakhotia [Lak93]. It is not precise and may be very approximate because of the ubiquitous uses of first class functions in Scheme. Other works in this area include <ref> [Ash96, Ash97, HM97, JW95, NN97, SZ94] </ref>. 3.7 Applications Using Aliasing or Points-to Information There are many analyses or optimizations using results of aliasing or points-to analyses. In this section, we briefly mention some of these works.
Reference: [NPD87] <author> A. Neirynck, P. Panangaden, and A. Demers. </author> <title> Computation of aliases and support sets. </title> <booktitle> In Conference Record of the 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 274-283, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: An inexpensive and non-iterative analysis is applied to each segment to calculate the must aliases for dynamic location names. They empirically showed that these must aliases can be used to kill reaching definitions of dynamic locations and thus improve the quality of def-use information. Neirynck, Panangaden, and Demers <ref> [NPD87] </ref> presented an algorithm for finding aliases in a higher order functional language with a few imperative constructs. They introduced the concept of variables which denote locations; two variables may refer the same location and thus are aliased through assignments or parameter passing. These variables are similar to single-level pointers.
Reference: [PC94] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise concrete type inference for object-oriented languages. </title> <booktitle> In Proceedings of the 9th Annual Conference on Object-oriented Programming Systems, Languages, and Applications (OOP-SLA'94), </booktitle> <pages> pages 324-340, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: This problem is tantamount to type determination for objects in programs. Chambers and Ungar [CU90] proposed an iterative type analysis for SELF. Pande and Ryder [PR94] developed a static type determination algorithm for C++ in the presence of pointers. Other analyses have also been given in the literature <ref> [APS93, BS96, DGC98, GDDC97, PC94] </ref> First-class Functions in Higher-order Functional Languages In functional languages such as Scheme, functions are first class citizens. They are just data that can be created at run-time, stored into aggregates, passed as arguments to procedures, or returned as values from functions, etc.
Reference: [PR94] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Static type determination for C++. </title> <booktitle> In Proceedings of USENIX 6th C++ Technical Conference, </booktitle> <pages> pages 85-97, </pages> <month> April </month> <year> 1994. </year> <month> 239 </month>
Reference-contexts: To reduce the overhead associated with dynamic dispatches of method invocations, static analysis has been used to resolve method invocations at compile time. This problem is tantamount to type determination for objects in programs. Chambers and Ungar [CU90] proposed an iterative type analysis for SELF. Pande and Ryder <ref> [PR94] </ref> developed a static type determination algorithm for C++ in the presence of pointers. Other analyses have also been given in the literature [APS93, BS96, DGC98, GDDC97, PC94] First-class Functions in Higher-order Functional Languages In functional languages such as Scheme, functions are first class citizens.
Reference: [PRL91] <author> Hemant D. Pande, Barbara G. Ryder, and William Landi. </author> <title> Interprocedural Def-Use associations in C programs. </title> <booktitle> In Proceedings of the Fifth Testing, Analysis, and Verification Symposium, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: Empirical results of modification or references through pointer indirections were also reported in [EGH94, ZRL96]. Shapiro and Horwitz [SH97a] presented some empirical results of GMOD analysis, live variable analysis, and program slicing for C programs. Pande, Ryder, and Landi <ref> [PRL91] </ref> worked on reaching definition and Def-Use problems for C. Altucher and Landi [AL95] improved the analyses using localized must-alias information. Ghiya and Hendren [GH98] used points-to and heap analyses for optimizations such 29 as loop-invariant removal, location-invariant removal, global common subexpression elimination, program understanding and debugging.
Reference: [Ram94] <author> G. Ramalingam. </author> <title> The undecidability of aliasing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1467-1471, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Their proofs of NP-hardness are also variations of Myers's. Landi [Lan92] showed that the may aliasing problem is P-space hard for any finite number ( 2) of pointer dereferences and is undecidable for recursive data structures, where the number of dereferences is not known at compile time. Ramalingam <ref> [Ram94] </ref> provided a simpler proof of the same results by reducing the Post Correspondence Problem to the may aliasing problem. 3.3 Aliasing Analysis Aliasing analysis represents aliases by pairs of names, for example, (flp,flq) means the two names, flp and flq, refer to the same location.
Reference: [RM88] <author> C. </author> <title> Ruggieri and T.P. Murtagh. Lifetime analysis of dynamically allocated objects. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-293, </pages> <year> 1988. </year>
Reference-contexts: He allowed closures and continuations, and used a very formal approach of abstract interpretation, but did not allow assignments (side effect) in the languages. Ruggieri and Murtagh <ref> [RM88] </ref> had an algorithm that collected, at compile time, lifetime information of dynamic locations. They do not distinguish different locations allocated by the same statement and assume they will have the same lifetime. The algorithm has two passes, one for intraprocedural and another for interprocedural analysis.
Reference: [RRH92] <author> Anne Rogers, John Reppy, and Laurie Hendren. </author> <title> Supporting spmd execution for dynamic data structures. </title> <booktitle> In Conference Records of the 5th Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 123-134, </pages> <month> August </month> <year> 1992. </year> <title> use continuation-pass-style. </title>
Reference-contexts: Hendren and Nicolau [HN89, HN90] used a simple shape analysis for parallelizing programs with recursive data structures. There have been a lot of works in heap analysis for conflict analysis, dependence test, and parallelization <ref> [Gua88, Har89, HHN92a, HPR89, HHN92b, LH88, RRH92] </ref>. Other applications of aliasing or points-to information include register promotion [CL97] and data prefetching [LM96]. 30 Chapter 4 Flow-insensitive Points-to Analysis with Unions and Type Casting In this chapter, we present a flow-insensitive points-to analysis algorithm, which we also call the PT analysis.
Reference: [Ruf95] <author> Erik Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <month> june </month> <year> 1995. </year>
Reference-contexts: Nevertheless, the effectiveness of the kill information in practice is unknown as no empirical results were given. Their algorithm also does incremental analysis for function pointers and 20 constructs call graphs incrementally. Ruf <ref> [Ruf95] </ref> presented an empirical comparison of one context-sensitive and one context-insensitive points-to analyses. Both analyses are flow-sensitive, but one propagates along realizable paths only, and another propagates along all paths in a super-graph consisting of the control flow graphs of all procedures.
Reference: [Ruf97] <author> Erik Ruf. </author> <title> Partitioning dataflow analyses using types. </title> <booktitle> In Conference Record of the 24th ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: The program decomposition allows different aliasing analyses to be applied to independent parts of the program. The idea of the technique is presented in Chapter 5 of this thesis. Ruf <ref> [Ruf97] </ref> talked about the idea of program decomposition for data flow analyses. To obtain a decomposition, he suggested using either declared types in programs or using type inference techniques such as [Ste96a, Ste96b].
Reference: [Ryd79] <author> Barbara G. Ryder. </author> <title> Constructing the call graph of a program. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 5(3) </volume> <pages> 216-226, </pages> <month> May </month> <year> 1979. </year>
Reference-contexts: Assignments for procedure parameters are not allowed; only a procedure name or another procedure parameter can be used as an actual argument for a procedure parameter. A procedure call through a procedure parameter may invoke any of procedures passed to that parameter. Ryder <ref> [Ryd79] </ref> presented the first algorithm for call graph construction for FORTRAN programs with calls through procedure parameters.
Reference: [SFRW90] <author> S. Sagiv, N. Francez, M. Rodeh, and R. Wilhelm. </author> <title> A logic-based approach to data flow analysis problems. </title> <booktitle> In LNCS 456,International Workshop on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 277-292. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Few points-to analyses handle language features such as type casting and unions in C. Unless mentioned specifically for an analysis, it is assumed that it does not consider these features. Sagiv, Francez, Rodeh, and Wilhelm <ref> [SFRW90] </ref> presented an approach to calculating statically simple assertions that may or must hold at program points during execution.
Reference: [SH97a] <author> Marc Shapiro and Susan Horwitz. </author> <title> The effects of the precision of pointer analysis. </title> <booktitle> In Proceedings of the Fourth International Symposium on Static Analysis, </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: The algorithm can also be used with other aliasing analyses [SRLZ98]. Empirical results of modification or references through pointer indirections were also reported in [EGH94, ZRL96]. Shapiro and Horwitz <ref> [SH97a] </ref> presented some empirical results of GMOD analysis, live variable analysis, and program slicing for C programs. Pande, Ryder, and Landi [PRL91] worked on reaching definition and Def-Use problems for C. Altucher and Landi [AL95] improved the analyses using localized must-alias information.
Reference: [SH97b] <author> Marc Shapiro and Susan Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In Conference Record of the 24th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: It seems that they do not handle unions and type casting. They use the points-to results to slice C++ programs in a program understanding environment. Shapiro and Horwitz <ref> [SH97b] </ref> presented two flow-insensitive, context-insensitive algorithms for points-to analysis. The first one is similar to Steensgaard's [Ste96b]. The 22 difference is that variables in a program are partitioned into categories and nodes for two variables are unioned if they are in the same category.
Reference: [Shi88] <author> Olin Shivers. </author> <title> Control flow analysis in scheme. </title> <booktitle> In Proceedings of SIG-PLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 164-174, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: They are just data that can be created at run-time, stored into aggregates, passed as arguments to procedures, or returned as values from functions, etc. Shiver <ref> [Shi88] </ref> proposed the first algorithm for resolving function invocations through 28 variables in Scheme; he called the problem control flow analysis. He considered the problem as determining possible values for variables.
Reference: [SRLZ98] <author> Philip Stocks, Barbara Ryder, William Landi, and Sean Zhang. </author> <title> Comparing flow and context sensitivity on the modification side effect problem. </title> <booktitle> In Proceedings of the International Symposium on Software Testing and Analysis, </booktitle> <pages> pages 11-20, </pages> <month> March </month> <year> 1998. </year>
Reference-contexts: Landi, Ryder and Zhang [LRZ93] developed an algorithm for the modification side effect analysis for C using Landi and Ryder's aliasing algorithm [LR92]. The algorithm can also be used with other aliasing analyses <ref> [SRLZ98] </ref>. Empirical results of modification or references through pointer indirections were also reported in [EGH94, ZRL96]. Shapiro and Horwitz [SH97a] presented some empirical results of GMOD analysis, live variable analysis, and program slicing for C programs. Pande, Ryder, and Landi [PRL91] worked on reaching definition and Def-Use problems for C. <p> For our experiments with three combined analyses, we have used the following analysis algorithms: 1. the Landi/Ryder flow-sensitive and context-sensitive aliasing algorithm <ref> [LR92, SRLZ98] </ref> (the FS analysis) 2. a flow-insensitive and context-insensitive points-to analysis algorithm presented in Chapter 4 (the PT analysis) 165 3. a flow-insensitive and context-insensitive aliasing analysis algorithm presented in Chapter 6 (the FA analysis) Both the FA and PT analyses can handle unions and type casting with some restrictions.
Reference: [SRW96] <author> Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> In Conference Record of the 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 16-31, </pages> <month> Jan. </month> <year> 1996. </year> <month> 240 </month>
Reference-contexts: This may not be such a good idea because no single approach may be effective for different kinds of pointers in terms of cost and precision. The exceptions are the work on shape analysis <ref> [JM81, JM82, HN89, CWZ90, HN90, Ghi95, GH96, SRW96] </ref>, where they only focus on pointers to dynamic data structures, and the work done at McGill University [EGH94, Ghi95, GH96], where they first proposed different analyses for pointers to the stack, pointers to the heap and pointers to dynamically allocated arrays. <p> These are very simple yet practical abstractions, but may not be powerful enough for programs with many structure changes. The invocation graph [EGH94] is used to make the analysis 25 context-sensitive, but also makes the analysis costly that it may not scale to large programs. Sagiv, Reps and Wilhelm <ref> [SRW96] </ref> presented an intraprocedural, flow-sensitive algorithm of shape analysis for LISP-like languages. They used the shape graphs to represent possible shapes at program points (i.e., store-based abstraction).
Reference: [Ste95] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <type> Technical Report MSR-TR-95-08, </type> <institution> Microsoft Research, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: The version of the algorithm for programs without indirect calls, unions, or type casting is similar to Steensgaard's work <ref> [Ste95, Ste96b] </ref>, but was discovered independently. The version for programs with indirect calls, unions, and type castings is different from Steensgaard's algorithms in the way that unions and casting are handled. * empirical results for the above algorithms. <p> Since explicit offsets and sizes are used, they can handle features such as type casting and unions. The analysis is exponential in the worst case where an exponential number of PTFs is required. Steensgaard <ref> [Ste95, Ste96a, Ste96b] </ref> applied type inference techniques to points-to analysis of C programs. <p> His type inference algorithm is monomorphic, that is, function calls are considered in context-insensitive manner. The result is a mapping from variables to the non-standard types, which describe the points-to relationship. Steensgaard's first algorithm <ref> [Ste95] </ref> treats each assignment in a program as symmetric and only uses type equality constraints. The next algorithm [Ste96b] treats an assignment as asymmetric when the right hand side of the assignment is not of pointer types and thus uses both equality and inequality constraints. <p> The difference between their work and others is that they safely identified pointers related to function pointers and applied Landi and Ryder aliasing analysis [LR92] to those pointers only; others simply applied analyses to all pointers. The other analysis algorithms <ref> [BCCH95, Ste95, WL95] </ref> also handle function pointers and calls through them as a part of the analyses. The idea of program decomposition for pointer aliasing analysis in this thesis was motivated by Altucher and Landi's work [AL94a].
Reference: [Ste96a] <author> Bjarne Steensgaard. </author> <title> Points-to analysis by type inference of prorams with structures and unions. </title> <booktitle> In International Conference on Compiler Construction, number 1060 in Lecture Notes in Computer Science, </booktitle> <pages> pages 136-150. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1996. </year>
Reference-contexts: The idea of the technique is presented in Chapter 5 of this thesis. Ruf [Ruf97] talked about the idea of program decomposition for data flow analyses. To obtain a decomposition, he suggested using either declared types in programs or using type inference techniques such as <ref> [Ste96a, Ste96b] </ref>. One of his target problems was points-to analysis. 13 3.2 Theoretic Classification of Aliasing-related Problems Weihl [Wei80] proved that the problem of determining possible values for procedure variables (i.e., single-level function pointers in C) for programs without any other aliasing is P-space hard. <p> Since explicit offsets and sizes are used, they can handle features such as type casting and unions. The analysis is exponential in the worst case where an exponential number of PTFs is required. Steensgaard <ref> [Ste95, Ste96a, Ste96b] </ref> applied type inference techniques to points-to analysis of C programs. <p> The next algorithm [Ste96b] treats an assignment as asymmetric when the right hand side of the assignment is not of pointer types and thus uses both equality and inequality constraints. Neither algorithm handles structures or unions. In his latest extension to deal with structures and unions <ref> [Ste96a] </ref>, locations are described by the following types: * blank for all initial locations * simple for locations accessed as one unit * struct for locations accessed as structures * object for locations accessed as unions These types form a simple lattice with the following partial ordering: blank v simple v
Reference: [Ste96b] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Conference Record of the 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: The version of the algorithm for programs without indirect calls, unions, or type casting is similar to Steensgaard's work <ref> [Ste95, Ste96b] </ref>, but was discovered independently. The version for programs with indirect calls, unions, and type castings is different from Steensgaard's algorithms in the way that unions and casting are handled. * empirical results for the above algorithms. <p> The idea of the technique is presented in Chapter 5 of this thesis. Ruf [Ruf97] talked about the idea of program decomposition for data flow analyses. To obtain a decomposition, he suggested using either declared types in programs or using type inference techniques such as <ref> [Ste96a, Ste96b] </ref>. One of his target problems was points-to analysis. 13 3.2 Theoretic Classification of Aliasing-related Problems Weihl [Wei80] proved that the problem of determining possible values for procedure variables (i.e., single-level function pointers in C) for programs without any other aliasing is P-space hard. <p> Since explicit offsets and sizes are used, they can handle features such as type casting and unions. The analysis is exponential in the worst case where an exponential number of PTFs is required. Steensgaard <ref> [Ste95, Ste96a, Ste96b] </ref> applied type inference techniques to points-to analysis of C programs. <p> The result is a mapping from variables to the non-standard types, which describe the points-to relationship. Steensgaard's first algorithm [Ste95] treats each assignment in a program as symmetric and only uses type equality constraints. The next algorithm <ref> [Ste96b] </ref> treats an assignment as asymmetric when the right hand side of the assignment is not of pointer types and thus uses both equality and inequality constraints. Neither algorithm handles structures or unions. <p> It seems that they do not handle unions and type casting. They use the points-to results to slice C++ programs in a program understanding environment. Shapiro and Horwitz [SH97b] presented two flow-insensitive, context-insensitive algorithms for points-to analysis. The first one is similar to Steensgaard's <ref> [Ste96b] </ref>. The 22 difference is that variables in a program are partitioned into categories and nodes for two variables are unioned if they are in the same category. It is not known how to partition variables or how many categories are appropriate.
Reference: [SZ94] <author> Dan Stefanescu and Yuli Zhou. </author> <title> An equational framework for the flow analysis of higher-order functional languages. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: In essence, the algorithm is similar to these of Hall and Kennedy [HK93] and Lakhotia [Lak93]. It is not precise and may be very approximate because of the ubiquitous uses of first class functions in Scheme. Other works in this area include <ref> [Ash96, Ash97, HM97, JW95, NN97, SZ94] </ref>. 3.7 Applications Using Aliasing or Points-to Information There are many analyses or optimizations using results of aliasing or points-to analyses. In this section, we briefly mention some of these works.
Reference: [TAFM97] <author> Paolo Tonella, Giuliano Antoniol, Roberto Fiutem, and Ettore Merlo. </author> <title> Flow-insensitive C++ pointers and polymorphism analysis and its application to slicing. </title> <booktitle> In Proceedings of the 19th International Conference on Software Engineering (ICSE97), </booktitle> <pages> pages 433-443, </pages> <year> 1997. </year>
Reference-contexts: For example, a simple and a struct become a object; two different struct become a object. Because pointer assignments are treated symmetrically, with type casting, it is possible to have many inconsistent uses of locations and thus to have many objects. Tonella, Antoniol, Fiutem, and Merlo <ref> [TAFM97] </ref> extended Steensgaard's approach to deal with features of C++ language such as classes, polymorphism and virtual functions. It seems that they do not handle unions and type casting. They use the points-to results to slice C++ programs in a program understanding environment.
Reference: [Tar83] <author> Robert E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <year> 1983. </year>
Reference-contexts: Therefore there are no more than N 0 calls to MERGE () and the number of calls to FIND () will be O (N 0 ). If we use a fast union/find algorithm such as the one in <ref> [Tar83] </ref>, the cost of all calls to UNION () and FIND () in Phase 2 is O (N 0 fi ff (N 0 ,N 0 )), where ff is the inverse of the Ackermann's function; the cost of calls to MERGE () in Phase 2 is (O (N 0 fi ff
Reference: [TT94] <author> Mads Tofte and Jean-Pierre Taplin. </author> <title> Implementation of the typed call-by-value lambda calculus using a stack of regions. </title> <booktitle> In Conference Record of the 21st ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 188-201, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: The analysis is mainly intraprocedural; its cost may be a problem when extending to interprocedural analysis. Region Inference <ref> [AFL95, BTV96, TT94] </ref> statically determines the lifetime of all run-time values including basic values, records, and function closures. Values of similar lifetime are grouped together to form a region, which are allocated and deallocated in a stack-like fashion. <p> The technique is aiming at achieving efficient use of memory resources and avoiding garbage collection conventionally used in implementations of applicative languages. The first region inference algorithm was given by Tofte and Taplin <ref> [TT94] </ref>, which was later improved by Aiken, etc. [AFL95] and Birkedal, etc. [BTV96]. 3.6 Call Graph Construction Depending on the programming languages being considered, work in this research area can be classified into four groups.
Reference: [Wei80] <author> W. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <booktitle> In Conference Record of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> Jan. </month> <year> 1980. </year>
Reference-contexts: To obtain a decomposition, he suggested using either declared types in programs or using type inference techniques such as [Ste96a, Ste96b]. One of his target problems was points-to analysis. 13 3.2 Theoretic Classification of Aliasing-related Problems Weihl <ref> [Wei80] </ref> proved that the problem of determining possible values for procedure variables (i.e., single-level function pointers in C) for programs without any other aliasing is P-space hard. <p> Unless noted, all aliases mentioned in this section are may aliases. Few aliasing analyses handle languages features such as type casting and unions in C. In the following discussion, unless mentioned specifically for an analysis, it is assumed that it does not consider these features. Weihl <ref> [Wei80] </ref> probably developed the first algorithm for finding pointer aliases. His algorithm calculated aliases due to both pointers and call-by-reference. He did not take control flow information into account and considered all pointers as if they were single-level; the name flp represents any location accessible through the variable p. <p> Therefore, most aliasing or points-to analysis algorithms can be adapted for function pointers to construct call graphs incrementally. 27 Weihl's aliasing algorithm <ref> [Wei80] </ref> can handle procedure variables and build call graphs incrementally as values for procedure variables are determined. Ghiya [Ghi92] extended Hendren's algorithm [HN89, HN90] to deal with function pointers. Emami, Ghiya, and Hendren [EGH94] handled function pointers in their points-to analysis.
Reference: [WL95] <author> Robert Wilson and Monica Lam. </author> <title> Efficient context-sensitive pointer analysis for C programs. </title> <booktitle> In Proceedings of SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> june </month> <year> 1995. </year>
Reference-contexts: Ruf offered some explanations in the paper such as the characteristics of the test programs, the simplicity of the Thru-deref MOD/REF problems, etc. It is not clear if this result about context-sensitivity holds in general. Wilson and Lam <ref> [WL95] </ref> presented a flow-sensitive, context-sensitive algorithm for points-to analysis of C programs. Their idea is to use partial transfer functions (PTFs) to summarize the points-to effects of procedures and use them for context-sensitive analysis. <p> The difference between their work and others is that they safely identified pointers related to function pointers and applied Landi and Ryder aliasing analysis [LR92] to those pointers only; others simply applied analyses to all pointers. The other analysis algorithms <ref> [BCCH95, Ste95, WL95] </ref> also handle function pointers and calls through them as a part of the analyses. The idea of program decomposition for pointer aliasing analysis in this thesis was motivated by Altucher and Landi's work [AL94a].
Reference: [ZRL96] <author> Sean Zhang, Barbara G. Ryder, and William Landi. </author> <title> Program decomposition for pointer aliasing: A step toward practical analyses. </title> <booktitle> In Proceedings of the Fourth ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 81-92, </pages> <month> October </month> <year> 1996. </year> <month> 241 </month>
Reference-contexts: Each subproblem can be solved independent of others. The program can be easily decomposed for these subproblems. Zhang, Ryder and Landi <ref> [ZRL96] </ref> presented a program decomposition technique, which partitions the assignments in a program with respect to their aliasing effects. The program decomposition allows different aliasing analyses to be applied to independent parts of the program. The idea of the technique is presented in Chapter 5 of this thesis. <p> Landi, Ryder and Zhang [LRZ93] developed an algorithm for the modification side effect analysis for C using Landi and Ryder's aliasing algorithm [LR92]. The algorithm can also be used with other aliasing analyses [SRLZ98]. Empirical results of modification or references through pointer indirections were also reported in <ref> [EGH94, ZRL96] </ref>. Shapiro and Horwitz [SH97a] presented some empirical results of GMOD analysis, live variable analysis, and program slicing for C programs. Pande, Ryder, and Landi [PRL91] worked on reaching definition and Def-Use problems for C. Altucher and Landi [AL95] improved the analyses using localized must-alias information.
References-found: 84

