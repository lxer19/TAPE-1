URL: http://www.cs.arizona.edu/people/gene/PAPERS/russ.reg.ps
Refering-URL: http://www.cs.arizona.edu/people/gene/vita.html
Root-URL: http://www.cs.arizona.edu
Title: A Four Russians Algorithm for Regular Expression Pattern Matching  
Author: GENE MYERS 
Keyword: Categories and Subject Descriptors: F.2.2 [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems Pattern matching; I.1.2 [Algebraic Manipulation]: Algorithms Analysis of Algorithms; I.5.0 [Pattern Recognition] General. General Terms: Algorithms, Theory Additional Keywords and Phrases: Finite Automaton, Four Russians Paradigm, Node listing, Regular Expression  
Date: 1  
Note: This research was supported in part by the National Library of Medicine under Grant R01 LM4960. Author's address:  
Address: Tucson, Arizona  Tucson, AZ 85721.  
Affiliation: The University of Arizona,  Department of Computer Science, The University of Arizona,  
Abstract: Given a regular expression R of length P and a word A of length N, the membership problem is to determine if A is in the language denoted by R. An O(PN/ lg N) time algorithm is presented that is based on a lg N speedup of the standard O(PN) time simulation of R's non-deterministic finite automaton on A using a combination of the node-listing and ``Four Russians'' paradigms. This result places a new worst-case upper bound on regular expression pattern matching. Moreover, in practice the method provides an implementation that is faster than existing software for small regular expressions. 
Abstract-found: 1
Intro-found: 1
Reference: [Aho80] <author> Aho, </author> <title> A.V. ``Pattern matching in strings.'' Formal Language Theory (R. Book, </title> <editor> ed.), </editor> <publisher> Academic Press (1980). </publisher>
Reference-contexts: With this choice, the tables require less than 2520P words of memory, and the time to build them is less than 4P milliseconds on a VAX8650 - 2 - running 4.3bsd UNIX. For small patterns, our implementation is competitive with egrep, which employs an O ( N) expected-time algorithm <ref> [Aho80, ASU85 (3.7)] </ref> and is the fastest tool currently used in practice. 1. Regular Expressions, Parse Trees, and Finite Automata Regular expression are built up from individual symbols via union, concatenation, and concatenation-closure operations. <p> Recall that L is the number of leaves in the parse tree for the regular expression. For example, over the ASCII alphabet at most 270L integers are needed for K = 10, and 2520L for K = 14. Software of the same functionality as UNIX egrep <ref> [Aho80] </ref> was built using our bit-vector algorithm for regular expression pattern matching. A number of pragmatic optimizations were employed. As in egrep, character classes are implemented as a single atomic state. Second, the tables are built directly from T R ; F * is never explicitly constructed. <p> Compiled scanner for F * of Figure 3. - 18 - We compared the scanning speeds over ASCII texts of our program, called mgrep, against an implementation of the standard state-set simulation, called sgrep, and another employing Aho's cache-based deterministic simulation used in the UNIX System 5 implementation of egrep <ref> [Aho80, ASU (3.7)] </ref>. Care was taken to fully optimize these implementations too, as evidenced by the fact that our implementation of egrep is faster than the UNIX implementation. Table 1 shows the scanning speed of the three programs on a set of patterns chosen to illustrate the following points.
Reference: [AHU75] <author> Aho, A.V., J.E. Hopcroft, and J.D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley (1975). </publisher>
Reference: [AKD70] <author> Arlazarov, V.L., E.A. Dinic, M.A. Kronrod, and I.A. Faradzev. </author> <title> ``On economic construction of the transitive closure of a directed graph.'' </title> <journal> Dokl. Acad. Nauk SSSR 194 (1970), 487-488 (in Russian). English translation in Soviet Math. Dokl. </journal> <volume> 11 (1975), </volume> <pages> 1209-1210. </pages>
Reference-contexts: 0. Introduction The ``Four Russians'' paradigm, first introduced in <ref> [AKD70] </ref>, decomposes a problem into smaller subparts, precomputes in a table all possible outcomes of a small computation, and then solves the larger problem by looking up a series of solutions to its subparts. <p> This technique led to an O (N 3 /lg N) time boolean matrix multiplication algorithm <ref> [AKD70, AHU75 (6.6)] </ref>, and an O (N 2 /lg N) time sequence comparison algorithm [MaP80]. Both of these results assumed a RAM model with logarithmic operation costs, i.e. operations take time proportional to the size (number of bits) in their operands.
Reference: [ASU85] <author> Aho, A.V., R. Sethi, and J.D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools, </booktitle> <publisher> Addison-Wesley (1985). </publisher>
Reference-contexts: Second, the tables are built directly from T R ; F * is never explicitly constructed. This is done by computing the predecessor and successor relations of states in F * directly from T R in two O (P) sweeps of the tree as observed in Section 3.9 of <ref> [ASU85] </ref>. Third, Atom and Succ tables are not built for modules all of whose leaves are modular.
Reference: [Gal85] <author> Galil, Z. </author> <title> ``Open problems in stringology.'' Combinatorial Algorithms on Words (A. </title> <editor> Apostolico and Z. Galil, eds.), </editor> <publisher> Springer-Verlag (1985), </publisher> <pages> 1-8. </pages>
Reference-contexts: Under the logarithmic cost model, the standard algorithm is O (PNlg P) and ours is O ( PN). Thus our algorithm places a new upper bound on regular expression pattern matching and affirmatively answers an open "stringology" problem posed in <ref> [Gal85] </ref>. Unlike the implementation of the sequence comparison algorithm of [MaP80], which outperformed its standard counterpart [WaF74] only when N 262,000 [MaP83], our method yields an implementation on architectures supporting bit-vectors that is faster than existing software for small patterns.
Reference: [HeU75] <author> Hecht, M.S. and J.D. Ullman. </author> <title> ``A simple algorithm for global flow analysis programs.'' </title> <journal> SIAM J. Computing 4, </journal> <volume> 4 (1975), </volume> <pages> 519-532. </pages>
Reference-contexts: The remaining back edges consist of just those from f R to q R in the diagram of F R* . For those familiar with the data flow analysis literature, Part 2 of Lemma 1 asserts that the loop connectedness parameter of the automaton's graph is 1 <ref> [HeU75] </ref>. LEMMA 1. Consider any finite automaton, F, constructed by the above processes. (1) Any cycle-free path in F that begins at q consists solely of dag edges. (2) Any cycle-free path in F has at most one back edge. PROOF. Suppose a path from q has a back edge.
Reference: [Ken75] <author> Kennedy, K. </author> <title> ``Node listing techniques applied to data flow analysis.'' </title> <booktitle> Proc. 2nd ACM Conf. on Principles of Programming Languages (1975), </booktitle> <pages> 10-21. </pages>
Reference-contexts: For those familiar with the data flow analysis literature, the correctness of the closure phase follows simply from the fact that the list obtained by concatenating two copies of the topological order of states in c is a node listing <ref> [Ken75] </ref> for the set of all e-paths to states in c with at most one back edge. The algorithm of Figure 4 starts by initializing Set to model the state-set - q in lines 1-3.
Reference: [MaP80] <author> Masek, W.J. </author> <title> and M.S. Paterson. ``A faster algorithm for computing string-edit distances.'' </title> <editor> J. </editor> <booktitle> Computer and System Science 20, 1 (1980), </booktitle> <pages> 18-31. </pages>
Reference-contexts: This technique led to an O (N 3 /lg N) time boolean matrix multiplication algorithm [AKD70, AHU75 (6.6)], and an O (N 2 /lg N) time sequence comparison algorithm <ref> [MaP80] </ref>. Both of these results assumed a RAM model with logarithmic operation costs, i.e. operations take time proportional to the size (number of bits) in their operands. In this paper we assume that operation costs are uniform. <p> If B (lg N)/ 2, then choosing K = (lg N)/ 2 yields an O (PN/lg N) time and space algorithm. These results assume the alphabet S is finite, as does the result in <ref> [MaP80] </ref>. This restriction can be relaxed at an additional cost in the time complexity of O ( Nlg P). <p> Thus our algorithm places a new upper bound on regular expression pattern matching and affirmatively answers an open "stringology" problem posed in [Gal85]. Unlike the implementation of the sequence comparison algorithm of <ref> [MaP80] </ref>, which outperformed its standard counterpart [WaF74] only when N 262,000 [MaP83], our method yields an implementation on architectures supporting bit-vectors that is faster than existing software for small patterns.
Reference: [MaP83] <author> Masek, W.J. </author> <title> and M.S. Paterson. ``How to compute string-edit distances quickly.'' Time Warps, String Edits, and Macromolecules: The Theory and Practice of Sequence Comparison, </title> <editor> D. Sankoff and J.B. Kruskal, eds., </editor> <publisher> Addison-Wesley (1983), </publisher> <pages> 337-349. - 20 </pages> - 
Reference-contexts: Thus our algorithm places a new upper bound on regular expression pattern matching and affirmatively answers an open "stringology" problem posed in [Gal85]. Unlike the implementation of the sequence comparison algorithm of [MaP80], which outperformed its standard counterpart [WaF74] only when N 262,000 <ref> [MaP83] </ref>, our method yields an implementation on architectures supporting bit-vectors that is faster than existing software for small patterns. Most machines support at least 16-bit word operations, so our strategy in practice is to choose K = 14 regardless of N or P.
Reference: [Mil88] <author> Miller, W. </author> <title> ``Efficient searching of biosequence databases.'' </title> <type> Tech. Rep. </type> <institution> CS-88-34, Dept. of Computer Science, The Pennsylvania State University, University Park, </institution> <address> PA 16802. </address>
Reference-contexts: Once R has been processed and before A is scanned, so much is known about the control flow and values in the inner loops of lines 6 to 9 that significant time gains can be achieved by compiling code for these lines that is tailored to R <ref> [Pen86, Mil88] </ref>. Figure 5 shows a hypothetical C-program tailored to the pattern in Figures 2 and 3. The calls to e closure () are in-line, and each loop in lines 6-7 and 12-14 has been completely unrolled.
Reference: [MyM88] <author> Myers, E.W., and W. Miller. </author> <title> ``Approximate matching of regular expressions.'' </title> <journal> Bull. Math. Biol. </journal> <volume> 51, </volume> <month> 1 </month> <year> (1988), </year> <note> to appear. </note>
Reference-contexts: But then by Corollary 4, s S i c if and only if there is an e-path to s from a state in S h i with at most one back edge. As in the algorithm of <ref> [MyM88] </ref>, the algorithm of edges. Recall that the subgraph of F * restricted to dag edges is acyclic and so a topological ordering exists. <p> The approximate regular expression matching problem, also known as regular order correction [WaS78], involves the fusion of sequence comparison and exact pattern matching concepts. For this problem, the node-listing algorithm of <ref> [MyM88] </ref> has a structure that may lend itself to modulari-zation as in this paper. Can the ``Four Russians'' paradigm be successfully applied to approximate regular expression pattern matching? ACKNOWLEDGEMENTS. The author wishes to thank the referees for their effort and comments that lead to an improved paper.
Reference: [Pen86] <author> Penello, T.J. </author> <title> ``Very fast LR parsing.'' </title> <journal> ACM SIGPLAN Notices 21, </journal> <volume> 7 (1986), </volume> <pages> 145-150. </pages>
Reference-contexts: Once R has been processed and before A is scanned, so much is known about the control flow and values in the inner loops of lines 6 to 9 that significant time gains can be achieved by compiling code for these lines that is tailored to R <ref> [Pen86, Mil88] </ref>. Figure 5 shows a hypothetical C-program tailored to the pattern in Figures 2 and 3. The calls to e closure () are in-line, and each loop in lines 6-7 and 12-14 has been completely unrolled.
Reference: [Sed83] <author> Sedgewick, R. </author> <title> Algorithms, </title> <publisher> Addison-Wesley (1983). </publisher>
Reference: [Tho68] <author> Thompson, K. </author> <title> ``Regular expression search algorithm.'' </title> <journal> Comm. ACM 11, </journal> <volume> 6 (1968), </volume> <pages> 419-422. </pages>
Reference-contexts: For a small integer parameter K, our method achieves a K-fold speedup of the standard O ( PN) state-set simulation of R's non-deterministic finite automaton, F, on the word A <ref> [Tho68, Sed83 (9)] </ref>. For a given K, F is hierarchically decomposed into O (P/K) modules. In O (K2 K ) time and O (2 K ) space, tables are constructed that permit the state-set of a module to be advanced in O (1) time. <p> These results assume the alphabet S is finite, as does the result in [MaP80]. This restriction can be relaxed at an additional cost in the time complexity of O ( Nlg P). Our result represents a worst-case improvement over the standard state-set simulation <ref> [Tho68] </ref>, because it is an O (lg P) factor faster, regardless of whether a uniform or logarithmic cost model is chosen. The standard O (PN) time claim relies on a lg P-bit uniform model, in which case our algorithm takes O ( PN/lg P) time. <p> Computing each current state-set takes O ( P) time for an automaton such as F R , giving an O (PN) time, O (P) space algorithm <ref> [Tho68, Sed83 (9)] </ref>. The algorithm of Figure 4 computes the same sequence of state-sets as the standard algorithm but in only O (P/K) time per state-set.
Reference: [WaF74] <author> Wagner, R.A. and M.J. Fischer. </author> <title> ``The string-to-string correction problem.'' </title> <editor> J. </editor> <booktitle> ACM 21 (1974), </booktitle> <pages> 168-173. </pages>
Reference-contexts: Thus our algorithm places a new upper bound on regular expression pattern matching and affirmatively answers an open "stringology" problem posed in [Gal85]. Unlike the implementation of the sequence comparison algorithm of [MaP80], which outperformed its standard counterpart <ref> [WaF74] </ref> only when N 262,000 [MaP83], our method yields an implementation on architectures supporting bit-vectors that is faster than existing software for small patterns. Most machines support at least 16-bit word operations, so our strategy in practice is to choose K = 14 regardless of N or P.
Reference: [WaS78] <author> Wagner, R.A. and J.I. Seiferas. </author> <title> ``Correcting counter-automaton-recognizable languages.'' </title> <journal> SIAM J. Computing 7, </journal> <volume> 3 (1978), </volume> <pages> 357-375. - 21 </pages> - 
Reference-contexts: An Open Problem The ``Four Russians'' paradigm has provided algorithms for sequence comparison and regular expression pattern matching that are superior in the worst case. The approximate regular expression matching problem, also known as regular order correction <ref> [WaS78] </ref>, involves the fusion of sequence comparison and exact pattern matching concepts. For this problem, the node-listing algorithm of [MyM88] has a structure that may lend itself to modulari-zation as in this paper. Can the ``Four Russians'' paradigm be successfully applied to approximate regular expression pattern matching? ACKNOWLEDGEMENTS.
References-found: 16

