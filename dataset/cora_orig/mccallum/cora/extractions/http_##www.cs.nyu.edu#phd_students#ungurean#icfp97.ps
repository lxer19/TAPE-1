URL: http://www.cs.nyu.edu/phd_students/ungurean/icfp97.ps
Refering-URL: http://www.cs.nyu.edu/phd_students/ungurean/index.html
Root-URL: http://www.cs.nyu.edu
Email: email: fungurean,goldbergg@cs.nyu.edu  
Title: Formal Models of Distributed Memory Management compact manner two garbage collectors; the first one does
Author: Cristian Ungureanu and Benjamin Goldberg 
Note: This model allows us to specify and prove correct in a  
Address: New York University  
Affiliation: Department of Computer Science  
Abstract: We develop an abstract model of memory management in distributed systems. The model is low-level enough so that we can express communication, allocation and garbage collection, but otherwise hides many of the lower-level details of an actual implementation. Recently, such formal models have been developed for memory management in a functional, sequential setting [10]. The models are rewriting systems whose terms are programs. Programs have both the "code" (control string) and the "store" syntactically apparent. Evaluation is expressed as conditional rewriting and includes store operations. Garbage collection becomes a rewriting relation that removes part of the store without affecting the behavior of the program. Distribution adds another dimension to an already complex problem. By using techniques developed for communicating and concurrent systems [9], we extend their work to a distributed environment. Sending and receiving messages is also made apparent at the syntactic level. A very general garbage collection rule based on reachability is introduced and proved correct. Now proving correct a specific collection strategy is reduced to showing that the relation between programs defined by the strategy is a sub-relation of the general relation. Any actual implementation which is capable of providing the transitions (including their atomicity constraints) specified by the strategy is therefore correct. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ben-Ari. </author> <title> Algorithms for on-the-fly garbage collection. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6, </volume> <year> 1984. </year>
Reference-contexts: In these systems, the collector is allowed to proceed in parallel with the mutator, but otherwise the mutator itself is not distributed. The first garbage collector of this kind is that proposed by Dijkstra et al. [3], together with a proof of correctness. Ben-Ari <ref> [1] </ref> improves on the algorithm and simplifies the proof. There has been considerable more work on proving correctness of sequential programs with state. The work which inspired our paper is that of Morrisett et al. on a syntactic theory of memory management [10].
Reference: [2] <author> Gerard Boudol. </author> <title> Towards a lambda-calculus for concurrent and communicating systems. </title> <publisher> TAPSOFT'89 LNCS 351, </publisher> <pages> pages 149-161, </pages> <year> 1989. </year>
Reference-contexts: This property was previously reported [5], but its proof was less formal. The communication model in our language is based on Milner's CCS [8]. A full description of CCS and its proof methods is [9]. Our calculus also has some similarities with the fl-calculus proposed by Boudol in <ref> [2] </ref>: his t -actions, on which the evaluation of the language is based, corresponds to our unobservable transitions.
Reference: [3] <author> Edsger Dijkstra, Leslie Lamport, A.J. Martin, C.S. Scholten, and E.F.M. Steffens. </author> <title> On-the-fly garbage collection: An exercise in cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <year> 1978. </year>
Reference-contexts: Proofs of correctness have been given for concurrent garbage collectors. In these systems, the collector is allowed to proceed in parallel with the mutator, but otherwise the mutator itself is not distributed. The first garbage collector of this kind is that proposed by Dijkstra et al. <ref> [3] </ref>, together with a proof of correctness. Ben-Ari [1] improves on the algorithm and simplifies the proof. There has been considerable more work on proving correctness of sequential programs with state. <p> Also, the garbage collection may be allowed to proceed in parallel with the computation even on the same node (as described in <ref> [3] </ref>). This can be achieved by raising the scan relation to a transition in the language, together with a way of synchronizing the mutator with the collector. However, the more refined the models are, the more complicated the proofs become.
Reference: [4] <author> Matthias Felleisen and Robert Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 102, </volume> <year> 1992. </year>
Reference-contexts: In this paper, we are presenting such a model. Starting from the v -S calculus of Felleisen and Hieb <ref> [4] </ref>, and from Milner's CCS [9], we introduce a language, k , which roughly corresponds to a distributed, impure functional language. In Section 2, we present the language k with a rewriting semantics that makes allocation and communication explicit. <p> Following <ref> [4] </ref>, reachability is modeled by con sidering the free variables. If a heap binding is reachable, and the value bound contains free variables, the bindings of these variables are reachable. <p> There has been considerable more work on proving correctness of sequential programs with state. The work which inspired our paper is that of Morrisett et al. on a syntactic theory of memory management [10]. The theoretical background of their treatment is given by the work of Felleisen and Hieb <ref> [4] </ref>, who extend the v calculus of Plotkin [11], to a calculus called v -S, suitable for reasoning about state and control in sequential programming languages. While in [4] an important effort is made in their model to avoid the garbage generated during computation, in order to obtain a "clean" equational <p> The theoretical background of their treatment is given by the work of Felleisen and Hieb <ref> [4] </ref>, who extend the v calculus of Plotkin [11], to a calculus called v -S, suitable for reasoning about state and control in sequential programming languages. While in [4] an important effort is made in their model to avoid the garbage generated during computation, in order to obtain a "clean" equational reasoning, in [10] the main topic is exactly that garbage.
Reference: [5] <author> Benjamin Goldberg and Michael Gloger. </author> <title> Polymorphic type reconstruction for garbage collection without tags. </title> <booktitle> Symposium on LISP and Functional Programming, </booktitle> <year> 1992. </year>
Reference-contexts: Using the model developed for a typed language with polymorphism, they were able to prove formally that some reachable data is garbage (it will never be accessed). This property was previously reported <ref> [5] </ref>, but its proof was less formal. The communication model in our language is based on Milner's CCS [8]. A full description of CCS and its proof methods is [9].
Reference: [6] <author> Paul Hudak and Robert Keller. </author> <title> Garbage collection and task deletion in distributed applicative processing systems. </title> <booktitle> Symposium on LISP and Functional Programming, </booktitle> <pages> pages 168-178, </pages> <year> 1982. </year>
Reference-contexts: However, most are concerned with presenting the algorithms rather than proving formally their correctness. Example of such papers are <ref> [6, 7, 12] </ref>. Hudak and Keller describe in [6] the marking-tree collector, suitable for a real-time distributed garbage collector. This collector, of the tracing kind, is capable of also deleting irrelevant processes and dormant subgraphs. Hughes describes in [7] a collector for a distributed architecture. <p> However, most are concerned with presenting the algorithms rather than proving formally their correctness. Example of such papers are [6, 7, 12]. Hudak and Keller describe in <ref> [6] </ref> the marking-tree collector, suitable for a real-time distributed garbage collector. This collector, of the tracing kind, is capable of also deleting irrelevant processes and dormant subgraphs. Hughes describes in [7] a collector for a distributed architecture.
Reference: [7] <author> John Hughes. </author> <title> A distributed garbage collection algorithm. </title> <booktitle> In Functional Programming Languages and Computer Architectures, number 201 in Lecture Notes in Computer Science, </booktitle> <pages> pages 256-271. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: However, most are concerned with presenting the algorithms rather than proving formally their correctness. Example of such papers are <ref> [6, 7, 12] </ref>. Hudak and Keller describe in [6] the marking-tree collector, suitable for a real-time distributed garbage collector. This collector, of the tracing kind, is capable of also deleting irrelevant processes and dormant subgraphs. Hughes describes in [7] a collector for a distributed architecture. <p> Example of such papers are [6, 7, 12]. Hudak and Keller describe in [6] the marking-tree collector, suitable for a real-time distributed garbage collector. This collector, of the tracing kind, is capable of also deleting irrelevant processes and dormant subgraphs. Hughes describes in <ref> [7] </ref> a collector for a distributed architecture. His collector, capable of collecting garbage cycles spanning multiple nodes, uses time-stamps to coordinate local collections with the global ones. Shapiro et al. [12] describe a protocol for garbage collection in a fault-tolerant, distributed object-oriented system.
Reference: [8] <author> Robin Milner. </author> <title> A calculus for communicating systems. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 92, </volume> <year> 1980. </year>
Reference-contexts: This property was previously reported [5], but its proof was less formal. The communication model in our language is based on Milner's CCS <ref> [8] </ref>. A full description of CCS and its proof methods is [9]. Our calculus also has some similarities with the fl-calculus proposed by Boudol in [2]: his t -actions, on which the evaluation of the language is based, corresponds to our unobservable transitions.
Reference: [9] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: In this paper, we are presenting such a model. Starting from the v -S calculus of Felleisen and Hieb [4], and from Milner's CCS <ref> [9] </ref>, we introduce a language, k , which roughly corresponds to a distributed, impure functional language. In Section 2, we present the language k with a rewriting semantics that makes allocation and communication explicit. <p> Rules without hypotheses are called axioms. The other rules are called inference rules. This mode of defining the relations will allow us to prove transition invariants by induction on the length of the proof that the transition is possible. This proof method is called transition induction <ref> [9] </ref>. As an example, the relation sum is defined by the rules Sum, Fix, Par 1 and Par 2 . Rule Sum is an axiom, while rule Par 1 has a hypothesis. <p> This property was previously reported [5], but its proof was less formal. The communication model in our language is based on Milner's CCS [8]. A full description of CCS and its proof methods is <ref> [9] </ref>. Our calculus also has some similarities with the fl-calculus proposed by Boudol in [2]: his t -actions, on which the evaluation of the language is based, corresponds to our unobservable transitions.
Reference: [10] <author> Greg Morrisett, Matthias Felleisen, and Robert Harper. </author> <title> Abstract models of memory management. </title> <booktitle> In Functional Programming Languages and Computer Architectures, </booktitle> <year> 1995. </year>
Reference-contexts: They are modified to account for the possibility of non-local bindings of variables. The computation relation is intended to define a left-to-right call-by-value evaluation order. The expression is decomposed into an evaluation context and an instruction. The decomposition is guaranteed to be unique <ref> [10] </ref>, and is obtained by scanning the expression from left to right and taking as the instruction the first redex encountered. The context is the expression with a hole replacing the redex. <p> Note that the relation leaves open the possibility of a garbage collection algorithm to replace the value a variable is bound to with something else (the integer zero, for example), as long as the programs remain bisimilar. ( This corresponds to replacing a pointer with NULL.) This is done in <ref> [10] </ref> to reclaim space occupied by objects which, although reachable, would never be accessed by the pro gram. 3.1 Free variable rule The garbage collection algorithms we are going to define are all based on tracing: all the reachable bindings are preserved. <p> Ben-Ari [1] improves on the algorithm and simplifies the proof. There has been considerable more work on proving correctness of sequential programs with state. The work which inspired our paper is that of Morrisett et al. on a syntactic theory of memory management <ref> [10] </ref>. The theoretical background of their treatment is given by the work of Felleisen and Hieb [4], who extend the v calculus of Plotkin [11], to a calculus called v -S, suitable for reasoning about state and control in sequential programming languages. <p> While in [4] an important effort is made in their model to avoid the garbage generated during computation, in order to obtain a "clean" equational reasoning, in <ref> [10] </ref> the main topic is exactly that garbage. Using the model developed for a typed language with polymorphism, they were able to prove formally that some reachable data is garbage (it will never be accessed). This property was previously reported [5], but its proof was less formal.
Reference: [11] <author> Gordon Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: The work which inspired our paper is that of Morrisett et al. on a syntactic theory of memory management [10]. The theoretical background of their treatment is given by the work of Felleisen and Hieb [4], who extend the v calculus of Plotkin <ref> [11] </ref>, to a calculus called v -S, suitable for reasoning about state and control in sequential programming languages.
Reference: [12] <author> Mark Shapiro, David Plainfosse, and Olivier Gruber. </author> <title> A garbage detection protocol for a realistic distributed object-support system. </title> <type> Technical Report 1320, </type> <institution> IN-RIA, </institution> <year> 1990. </year>
Reference-contexts: Each local GC cleans the exit table of useless entries. In turn, exit tables are used to clean remote entry tables, yielding successively better estimates. More details about this method can be found in <ref> [12] </ref> It is important to note that these steps can be described in our framework (the domain of the transition relations can be augmented with sets for these tables). However, including them would have made the presentation less clear. Theorem 3 establishes the correctness of the algorithm. <p> However, most are concerned with presenting the algorithms rather than proving formally their correctness. Example of such papers are <ref> [6, 7, 12] </ref>. Hudak and Keller describe in [6] the marking-tree collector, suitable for a real-time distributed garbage collector. This collector, of the tracing kind, is capable of also deleting irrelevant processes and dormant subgraphs. Hughes describes in [7] a collector for a distributed architecture. <p> This collector, of the tracing kind, is capable of also deleting irrelevant processes and dormant subgraphs. Hughes describes in [7] a collector for a distributed architecture. His collector, capable of collecting garbage cycles spanning multiple nodes, uses time-stamps to coordinate local collections with the global ones. Shapiro et al. <ref> [12] </ref> describe a protocol for garbage collection in a fault-tolerant, distributed object-oriented system. Given the complexity of these algorithms, and the low level of abstraction at which they are presented, the proof of correctness is too complex to be given formally (however, in the papers mentioned proof sketches are given).
References-found: 12

