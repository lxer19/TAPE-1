URL: http://www.cs.tamu.edu/research/phoenix/techreports/TR_95-041.ps.Z
Refering-URL: http://www.cs.tamu.edu/research/phoenix/papers_bib.html
Root-URL: 
Title: Object Replication in Spring Using Subcontracts  
Author: Ganesha Beedubail Udo Pooch and Peter Kessler 
Address: College Station, TX 77843.  2550 Garcia Avenue, Mountainview, CA 94043.  
Affiliation: Department of Computer Science, Texas A&M University,  Sun Microsystems, Inc.,  
Abstract: Technical Report (TR 95-41) September 1995. Abstract This paper presents the design of a framework for the development of replicated objects in Spring (object oriented, distributed) Operating System. For this framework, we make use of the subcontract abstraction provided by Spring. We designed two subcontracts (replicon and repleton) which can be used to develop replicated objects. We also specify the methodology for developing a replicated object server. The object replication achieved by our design is transparent to the clients (users) of the (replicated) object. The framework provides mechanism for the server developer to plug in his replica consistency algorithm. We used this design to develop a replicated naming service (RNS) for Spring. We also developed a Master-Slave protocol for replica consistency and fault tolerance. The novelty of this protocol is that, it is specified and implemented using only RPCs (synchronous communication). Lower level message passing mechanism is not exploited (which is difficult to program). The protocol is self contained. It does not assume the existence of any lower level reliable services other than simple timeout mechanism to detect failures. The paper also presents preliminary results measured from the prototype implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Mitchel et al., </author> <title> "An overview of the spring system," </title> <booktitle> In Proceedings of of Compcon Spring 1994, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: This work was motivated by the availability of subcontract abstraction in Spring Operating system <ref> [1, 2, 3, 4, 5] </ref>. Subcontract abstraction is developed for providing a flexible base for distributed programming. We also wanted to develop a fault tolerant distributed protocol using only RPC mechanism. <p> In the following we will briefly describe the Spring OS, Subcontracts in Spring and Spring Naming Service. For a detailed descriptions of these topics refer to <ref> [1, 3, 2, 4, 5] </ref>. 2.1 Overview of Spring OS Spring is a micro kernel based object oriented distributed operating system [1]. All services in Spring (user services as well as system services) are implemented as objects. <p> In the following we will briefly describe the Spring OS, Subcontracts in Spring and Spring Naming Service. For a detailed descriptions of these topics refer to [1, 3, 2, 4, 5]. 2.1 Overview of Spring OS Spring is a micro kernel based object oriented distributed operating system <ref> [1] </ref>. All services in Spring (user services as well as system services) are implemented as objects. All objects in Spring have well defined interfaces, and these interfaces are defined in Interface Definition Language (IDL). <p> Object invocations across the network are handled by network proxies. Network proxies connect the nuclii of different machines transparently.Spring provides other standard system services as user level objects. These include file system service, machine name service, TCP/UDP/IP service, tty service etc. For details refer to <ref> [1, 2] </ref>. 2 2.2 Spring Subcontracts Spring provides a flexible mechanism for plugging in different kinds of object run time machinery. This mechanism is known as subcontract. A subcontract is a definition of a representation for an object and corresponding invocation protocol.
Reference: [2] <author> S. Radia et al., </author> <title> "The spring object model," </title> <booktitle> In Conference on Object-Oriented Technologies(COOTS), </booktitle> <month> February </month> <year> 1995. </year>
Reference-contexts: This work was motivated by the availability of subcontract abstraction in Spring Operating system <ref> [1, 2, 3, 4, 5] </ref>. Subcontract abstraction is developed for providing a flexible base for distributed programming. We also wanted to develop a fault tolerant distributed protocol using only RPC mechanism. <p> In the following we will briefly describe the Spring OS, Subcontracts in Spring and Spring Naming Service. For a detailed descriptions of these topics refer to <ref> [1, 3, 2, 4, 5] </ref>. 2.1 Overview of Spring OS Spring is a micro kernel based object oriented distributed operating system [1]. All services in Spring (user services as well as system services) are implemented as objects. <p> Object invocations across the network are handled by network proxies. Network proxies connect the nuclii of different machines transparently.Spring provides other standard system services as user level objects. These include file system service, machine name service, TCP/UDP/IP service, tty service etc. For details refer to <ref> [1, 2] </ref>. 2 2.2 Spring Subcontracts Spring provides a flexible mechanism for plugging in different kinds of object run time machinery. This mechanism is known as subcontract. A subcontract is a definition of a representation for an object and corresponding invocation protocol.
Reference: [3] <author> G. Hamilton and P. Kougiouris, </author> <title> "The spring nucleus: A microkernel for objects," </title> <booktitle> In Proc. of 1993 Summer Usenix Conference, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: This work was motivated by the availability of subcontract abstraction in Spring Operating system <ref> [1, 2, 3, 4, 5] </ref>. Subcontract abstraction is developed for providing a flexible base for distributed programming. We also wanted to develop a fault tolerant distributed protocol using only RPC mechanism. <p> In the following we will briefly describe the Spring OS, Subcontracts in Spring and Spring Naming Service. For a detailed descriptions of these topics refer to <ref> [1, 3, 2, 4, 5] </ref>. 2.1 Overview of Spring OS Spring is a micro kernel based object oriented distributed operating system [1]. All services in Spring (user services as well as system services) are implemented as objects.
Reference: [4] <author> G. Hamilton, M. Powell, and J. Mitchell, "Subcontract: </author> <title> A flexible base for distributed programming," </title> <booktitle> In Proc. of 14th Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: This work was motivated by the availability of subcontract abstraction in Spring Operating system <ref> [1, 2, 3, 4, 5] </ref>. Subcontract abstraction is developed for providing a flexible base for distributed programming. We also wanted to develop a fault tolerant distributed protocol using only RPC mechanism. <p> In the following we will briefly describe the Spring OS, Subcontracts in Spring and Spring Naming Service. For a detailed descriptions of these topics refer to <ref> [1, 3, 2, 4, 5] </ref>. 2.1 Overview of Spring OS Spring is a micro kernel based object oriented distributed operating system [1]. All services in Spring (user services as well as system services) are implemented as objects. <p> Singleton represents each object as a single door. Any call to the object is converted to an invocation through this door. Another example os subcontract is caching subcontract which is used by cacheable objects. For the details of subcontracts refer to <ref> [4] </ref>. We developed two subcontracts, replicon and repleton to support object replication in Spring. 2.3 Spring Naming Service Spring provides a uniform name service. Any object can be bound to any name.
Reference: [5] <author> S. Radia, M. Nelson, and M. Powell, </author> <title> "The spring name service," </title> <type> Technical Report SMLI-9316, </type> <institution> Sun Microsystems Laboratories, </institution> <year> 1993. </year> <month> 22 </month>
Reference-contexts: This work was motivated by the availability of subcontract abstraction in Spring Operating system <ref> [1, 2, 3, 4, 5] </ref>. Subcontract abstraction is developed for providing a flexible base for distributed programming. We also wanted to develop a fault tolerant distributed protocol using only RPC mechanism. <p> In the following we will briefly describe the Spring OS, Subcontracts in Spring and Spring Naming Service. For a detailed descriptions of these topics refer to <ref> [1, 3, 2, 4, 5] </ref>. 2.1 Overview of Spring OS Spring is a micro kernel based object oriented distributed operating system [1]. All services in Spring (user services as well as system services) are implemented as objects. <p> An inner node in the naming graph can be referred by a compound name. In Spring, the NS is implemented by one or more object managers called name servers. Name servers implement the context objects. For more details about Spring NS refer to <ref> [5, 6] </ref>. 2.4 Objectives of this Project The following discussion highlights the motivations for carrying out this project. * We wanted to exercise the features of subcontract concept, to show that one can develop different subcontracts as the application requirements for various semantics (may be to provide variations of the base <p> First, we wanted to develop a real life (practical) application using the framework developed above. The Spring team at Sun was interested in a Fault Tolerant Village Name Service (for the details of Spring Naming Service and Village Name Service refer to <ref> [5, 6] </ref>). Simply stated, Village Name Service is the shared/distributed name service available for a group of Spring Machines in a LAN. Another reason is that, in our object replication scheme, we assumed the existence of a fault tolerant naming service which needed to be realized some how. <p> Figure 7 shows the interfaces and subcontracts involved in the RNS. The naming context interface currently implements all the functions required by a naming service (refer <ref> [5] </ref>). The repl ctx interface (object) is used by rmgr to construct the client side representation (the list of fat pointers to the RNS servers).
Reference: [6] <author> S. Radia, </author> <title> "The spring naming policy," </title> <booktitle> In 1st Intl. Workshop on Services in Distributed and Networked Environments, </booktitle> <year> 1994. </year>
Reference-contexts: An inner node in the naming graph can be referred by a compound name. In Spring, the NS is implemented by one or more object managers called name servers. Name servers implement the context objects. For more details about Spring NS refer to <ref> [5, 6] </ref>. 2.4 Objectives of this Project The following discussion highlights the motivations for carrying out this project. * We wanted to exercise the features of subcontract concept, to show that one can develop different subcontracts as the application requirements for various semantics (may be to provide variations of the base <p> First, we wanted to develop a real life (practical) application using the framework developed above. The Spring team at Sun was interested in a Fault Tolerant Village Name Service (for the details of Spring Naming Service and Village Name Service refer to <ref> [5, 6] </ref>). Simply stated, Village Name Service is the shared/distributed name service available for a group of Spring Machines in a LAN. Another reason is that, in our object replication scheme, we assumed the existence of a fault tolerant naming service which needed to be realized some how.
Reference: [7] <author> F. Schneider, </author> <title> "Implementing fault tolerant services using the state machine approach: A tutorial," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 22, no. 4, </volume> <pages> pp. 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: This approach is known as active replication or the state machine approach <ref> [7] </ref>. 2) Designate one server as the primary and all others as backups. Clients make requests by sending messages only to the primary. The primary forwards the requests to the backups (so that, backups can synchronize their state with the primary) and then responds to the client 1 . <p> We provide one support for this in terms of group list. Since each of the replicas (sobj mgr objects) has list of all other replicas, it is possible to implement some kind of fault tolerant protocol for replica consistency. The reader can refer to <ref> [13, 7, 12, 17, 18] </ref> for the discussions of the various approaches used for solving this problem. 4.5 Adding/Deleting Replicas In practice, it is necessary to add new replicas to the existing replica set to ensure a high availability level (or it may be the case that, a machine hosting a
Reference: [8] <author> P. Alsberg and J. Day, </author> <title> "A principle for resilient sharing of distributed resrources," </title> <booktitle> In Proc. Of Second Intl' Conf. on software Engg., </booktitle> <address> San Francisco, CA., </address> <pages> pp. 562-570, </pages> <year> 1976. </year>
Reference-contexts: The primary forwards the requests to the backups (so that, backups can synchronize their state with the primary) and then responds to the client 1 . If the primary fails, then one of the backups becomes the primary. This approach is known as the primary-backup or the primary copy <ref> [8] </ref>. <p> the above two basic strategies 2 . 1 The algorithms vary in how the request is forwarded to the backups and when the primary responds to the client. 2 The voting scheme or variations of the voting schemes can be implemented as variations of primary-copy scheme. 4 Alsberg and Day <ref> [8] </ref> proposed one of the earliest primary-backup protocol. The paper presents the error detection and recovery schemes for two-host resiliency (tolerating one failure) and the extension of this concept n hosts. In [9] Budhiraja et. al. present some theoretical aspects of primary backup approach.
Reference: [9] <author> N. Budhiraja et al., </author> <title> "The primary-backup approach," In Distributed Systems, 2ed Edition, </title> <editor> S. Mullender, </editor> <booktitle> editor, </booktitle> <pages> pp. 199-216, </pages> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: The paper presents the error detection and recovery schemes for two-host resiliency (tolerating one failure) and the extension of this concept n hosts. In <ref> [9] </ref> Budhiraja et. al. present some theoretical aspects of primary backup approach. Their system assumes closely synchronized clocks in the system.
Reference: [10] <author> B. Liskov et al., </author> <title> "Replication in the harp file system," </title> <type> Technical Report MIT/LCS/TM-456, </type> <institution> Massachusetts Institute Of Technology, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: They also provide protocols to prove that their lower bounds are tight. The Harp File System also uses a primary-backup protocol <ref> [10] </ref>. It is assumed that the system clocks are closely synchronized and all the machines are equipped with a UPS (uninterrupted power supply). The protocol keeps a log of updates on volatile memory (the UPS is necessary to write back this log to disk in case of power failure).
Reference: [11] <author> K. P. Birman et al., </author> <title> "Implementing fault-tolerant distributed objects," </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. 6, no. 11, </volume> <pages> pp. 502-508, </pages> <year> 1985. </year>
Reference-contexts: Operations on the log are applied to the system in the background. Thus the disk access is removed from the critical path, and good response time is achieved. In <ref> [11] </ref> Birman et. al. describe a technique to implement k-resilient distributed object. They use coordinator-cohort scheme, a variation of primary-backup scheme. The coordinator services the client requests and periodically checkpoints its state to the cohorts.
Reference: [12] <author> G. Beedubail et al., </author> <title> "Fault tolerant objects in distributed systems using hot replication," </title> <type> Technical Report TR95-23, </type> <institution> Computer Science Department,Texas A&M University, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: The coordinator also forwards the result of any external action to the cohorts (called retained results). Thus the cohorts will have all the information to take over as a coordinator if the original coordinator fails. In <ref> [12] </ref> Beedubail et. al. extend the primary backup protocol for nested object invocation where to service a client request and object can invoke the services of other objects. That scheme assumes the existence of a reliable multicast and group management service. <p> We provide one support for this in terms of group list. Since each of the replicas (sobj mgr objects) has list of all other replicas, it is possible to implement some kind of fault tolerant protocol for replica consistency. The reader can refer to <ref> [13, 7, 12, 17, 18] </ref> for the discussions of the various approaches used for solving this problem. 4.5 Adding/Deleting Replicas In practice, it is necessary to add new replicas to the existing replica set to ensure a high availability level (or it may be the case that, a machine hosting a <p> We specify the update methods so that only requests for these methods should execute the consistency protocol. The read requests need not execute the protocol. The rest of the fields at the server side has the obvious meanings. 5.4 Fault Tolerant Replica Consistency Protocol We use Master-Slave <ref> [12] </ref> configuration for replica consistency control and fault tolerance 6 . The novelty of this algorithm is that: * It is self contained. It does not use any other services (other than the basic "time-out" mechanism to detect failures. * It is specified and implemented using only RPCs (synchronous communication). <p> We also need to enhance the replica consistency protocol so that the RNS works when the name space is implemented by multiple name server domains. This is somewhat harder problem. We may be able to adapt the solution given in <ref> [12] </ref> for this situation. Another feature that needs some improvement is with respect to the stale fat pointers (stale object references).
Reference: [13] <author> E. C. Cooper, </author> <title> "Replicated distributed programs," </title> <booktitle> In ACM Symp. on Oper. Syst. Princ., </booktitle> <pages> pp. 63-78, </pages> <year> 1985. </year>
Reference-contexts: In [12] Beedubail et. al. extend the primary backup protocol for nested object invocation where to service a client request and object can invoke the services of other objects. That scheme assumes the existence of a reliable multicast and group management service. The replicated distributed programs described by Cooper <ref> [13] </ref> is an example of active replication. Here, all the replicas (called the members of a troupe) execute the client calls independently. A higher level application protocol should make sure that all the replicas get their client calls in the same order. <p> We provide one support for this in terms of group list. Since each of the replicas (sobj mgr objects) has list of all other replicas, it is possible to implement some kind of fault tolerant protocol for replica consistency. The reader can refer to <ref> [13, 7, 12, 17, 18] </ref> for the discussions of the various approaches used for solving this problem. 4.5 Adding/Deleting Replicas In practice, it is necessary to add new replicas to the existing replica set to ensure a high availability level (or it may be the case that, a machine hosting a
Reference: [14] <author> T. Joseph and K. Birman, </author> <title> "Data replication in distributed systems," In Distributed Systems, </title> <editor> S. Mullender, </editor> <booktitle> editor, </booktitle> <pages> pp. 319-367, </pages> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Here, all the replicas (called the members of a troupe) execute the client calls independently. A higher level application protocol should make sure that all the replicas get their client calls in the same order. In <ref> [14] </ref> Birman et.al., describe, how the totally ordered, reliable broadcasts can be used to maintain replicated data (active replication). Object Replication in Arjuna [15] uses active replication 3 . The replication algorithm uses the support of naming and binding service and the atomic action service provided by Arjuna system.
Reference: [15] <author> M. C. Little, </author> <title> Object Replication in a Distributed System, </title> <type> PhD thesis, </type> <institution> Computer Science Dept., University of Newcastle upon Tyne, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: A higher level application protocol should make sure that all the replicas get their client calls in the same order. In [14] Birman et.al., describe, how the totally ordered, reliable broadcasts can be used to maintain replicated data (active replication). Object Replication in Arjuna <ref> [15] </ref> uses active replication 3 . The replication algorithm uses the support of naming and binding service and the atomic action service provided by Arjuna system. A higher level group locking (issued by the application program) protocol avoids the need of reliable ordered broadcast.
Reference: [16] <author> M. F. Kaasshoek, A. S. Tanenbaum, and K. Verstoep, </author> <title> "Using group communication to implement a fault-tolerant directory service," </title> <booktitle> In International Conf. Distributed Computing Systems, </booktitle> <year> 1993. </year>
Reference-contexts: Object Replication in Arjuna [15] uses active replication 3 . The replication algorithm uses the support of naming and binding service and the atomic action service provided by Arjuna system. A higher level group locking (issued by the application program) protocol avoids the need of reliable ordered broadcast. In <ref> [16] </ref> kaashoek et.al., describe the fault tolerant directory service implemented in Amoeba distributed operating system. They use the closed group communication service supported in Amoeba to implement the directory service. Our work provides a mechanism for implementing object replication. The server developer can use any of the above algorithms.
Reference: [17] <author> K. Yap, P. Jalote, and S. Tripati, </author> <title> "Fault tolerant remote procedure call," </title> <booktitle> In International Conf. Distributed Computing Systems, </booktitle> <pages> pp. 48-54, </pages> <year> 1988. </year>
Reference-contexts: We provide one support for this in terms of group list. Since each of the replicas (sobj mgr objects) has list of all other replicas, it is possible to implement some kind of fault tolerant protocol for replica consistency. The reader can refer to <ref> [13, 7, 12, 17, 18] </ref> for the discussions of the various approaches used for solving this problem. 4.5 Adding/Deleting Replicas In practice, it is necessary to add new replicas to the existing replica set to ensure a high availability level (or it may be the case that, a machine hosting a
Reference: [18] <author> P. Jalote, </author> <title> "Resilient objects in broadcast networks," </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. 15, no. 1, </volume> <pages> pp. 68-72, </pages> <month> January </month> <year> 1989. </year> <month> 23 </month>
Reference-contexts: We provide one support for this in terms of group list. Since each of the replicas (sobj mgr objects) has list of all other replicas, it is possible to implement some kind of fault tolerant protocol for replica consistency. The reader can refer to <ref> [13, 7, 12, 17, 18] </ref> for the discussions of the various approaches used for solving this problem. 4.5 Adding/Deleting Replicas In practice, it is necessary to add new replicas to the existing replica set to ensure a high availability level (or it may be the case that, a machine hosting a
References-found: 18

