URL: http://www.csl.sri.com/reports/postscript/todaes96.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Abstract: Copyright (C) 1995 by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or direct commercial advantage and that copies show this notice on the first page or initial screen of a display along with the full citation. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component of this work in other works, requires prior specific permission and/or a fee. Permissions may be requested from Publications Dept, ACM Inc., 1515 Broadway, New York, NY 10036 USA, fax +1 (212) 869-0481, or permissions@acm.org 
Abstract-found: 1
Intro-found: 1
Reference: [Ael94] <author> F.V. Aelten et.al, </author> <title> Event-Based Verification of Synchronous Globally Controlled, Logic Designs Against Signal Flow Graphs, </title> <journal> IEEE Trans. on CAD of ICs., </journal> <volume> Vol. 13, No. </volume> <month> 1 Jan </month> <year> 1994. </year>
Reference-contexts: In this work, a strong notion of behavior equivalence based on an imperative semantics tied to a particular model of representation is used. A post facto verification method for comparing logic-level designs against a restricted class of data-ow graphs in SILAGE was presented by Aelten and others <ref> [AAD93, Ael94] </ref>. A formalization of SILAGE transformations in HOL was studied by Angelo [Ang94]. 7.2. Formal Characterization of SIL In this section we first introduce a relation that describes refinement on ports. The refinement relation is specified without giving a concrete model of the behavior of ports.
Reference: [Ang94] <author> C. Angelo, </author> <type> PhD Thesis, </type> <institution> IMEC, Leuven, </institution> <year> 1994. </year>
Reference-contexts: A post facto verification method for comparing logic-level designs against a restricted class of data-ow graphs in SILAGE was presented by Aelten and others [AAD93, Ael94]. A formalization of SILAGE transformations in HOL was studied by Angelo <ref> [Ang94] </ref>. 7.2. Formal Characterization of SIL In this section we first introduce a relation that describes refinement on ports. The refinement relation is specified without giving a concrete model of the behavior of ports.
Reference: [Ast95] <author> P. </author> <title> Asthana, </title> <journal> Jumping the technology S-curve , IEEE Spectrum, </journal> <month> June </month> <year> 1995, </year> <pages> pp. 49-54, </pages> <year> 1995. </year>
Reference-contexts: This results in a preference for an approach towards synthesis that achieves correctness by construction. 3. Life Cycle-Imposed Constraints While minimizing design time is certainly a major issue we feel that the importance of minimizing time-to-market is sometimes overrated, certainly in the field of high-level synthesis. <ref> [Ast95] </ref> shows that we are not alone in this observation. We believe that when taking the complete life cycle of a design into account, exibility and efficiency of the design method are at least as important.
Reference: [ASU86] <author> A.V. Aho, R. Sethi, J.D. Ullman, </author> <booktitle> Compilers, Principles, Techniques, and Tools, Chapter 10, </booktitle> <publisher> Addison Wesley, </publisher> <address> ISBN 0 - 201-10088-6, </address> <year> 1986. </year>
Reference-contexts: Related Work The use of transformations for the design of both software and hardware is not new. While formal program refinement techniques never really caught on, the use of transformations in software compilers is common <ref> [Lov77, ASU86] </ref>. There are, however, several aspects that make hardware design different from software design and the use of formal tech - niques more attractive. In hardware design, rebuilding hardware normally has a very high cost and is time-consuming.
Reference: [BCD88] <author> R.K. Brayton and R. Camposano and G. De Micheli and R.H.J.M. Otten and J.T.J. van Eijndhoven, </author> <title> The Yorktown Silicon Compiler System, </title> <editor> eds. D. </editor> <publisher> Gajski Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Interactively used transformations on the control ow are discussed in [WaT89]. In [MCF93] correctness of transformations in the System Architects Workbench is investigated. Several errors were found, often related to incorrect use of bit array data types. The Yorktown Silicon Compiler-based <ref> [BCD88] </ref> system [Cam89] emphasizes transformations to improve scheduling and allocation. The computations and control structure are not changed. The Yorktown Internal Form, which is similar to CDFG languages, is used as intermediate language. The transformation steps used for scheduling and allocation are proven correct. <p> Correctness of register-transfer level transformations for scheduling and allocation has been dealt with in [Vem90]. A formal analysis of transformations used in Systems Architects Workbench (SAW) high-level synthesis was studied by McFarland [McF93]. Transformations used in YIF (Yorktown Internal Form) <ref> [BCD88] </ref> have been proved to be behavior-preserving [Cam89]. In this work, a strong notion of behavior equivalence based on an imperative semantics tied to a particular model of representation is used.
Reference: [BCD95] <editor> C. Basile, A.P. Cavallerano, M.S. Deiss, et al., </editor> <title> The U.S. HDTV standard: The Grand Alliance, </title> <journal> IEEE Spectrum, </journal> <volume> Vol. 32, No. 4, </volume> <pages> pp. 36-45, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: We have selected the direction detector because it is relevant in industry and currently used in television sys tems and could also prove useful for IPSC in the new HDTV standard <ref> [BCD95] </ref>. In a previous custom implementation the direction detector accounted for 40% of the size of the data path while the field and line memory consumed the most chip area.
Reference: [BRB90] <author> K.S. Brace, R.L. Rudell and R.E. Bryant, </author> <title> Efficient Implementation of a BDD Package, </title> <booktitle> Proc. of the 27 th ACM/IEEE DAC, </booktitle> <pages> pp. 40-45, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In general, the proofs of transformations proceed by rewriting, using axioms and proved theorems, and finally simplifying to a set of Boolean expressions containing only relations between ports and port arrays. At this final stage the Boolean simplifier based on Binary Decision Diagrams (BDD) <ref> [BRB90, Jan93] </ref> integrated in PVS, is used to determine that the conjunction of Boolean expressions is indeed true. We show the runtimes of verifying the various transformations in Table II.
Reference: [Bro92] <author> R.W. Brodersen, et al, </author> <title> Anatomy of a Silicon Compiler, </title> <publisher> Kluwer, </publisher> <address> ISBN 0-79239249-3, </address> <year> 1992. </year>
Reference-contexts: Furthermore the efficiency and real-time requirements are also very stringent compared to most software. Many (partially) transformation-based design systems exist or are under construction as part of larger projects. The HYPER system developed at the University of Berkeley <ref> [Bro92, Cha92, IPS93, Pot94] </ref> provides a set of transformations for automatic algorithmic-level design optimization. HYPER consists of transformations from the optimization, refinement, timespace assignment categories. The refinement transformations are however limited to strength reduction. Silage is used as specification language and translated to the HYPER CDFG [RaH90].
Reference: [Cam89] <author> R. Camposano, </author> <title> Behavior-Preserving Transformations for High-Level Synthesis, Hardware Specification, Verification and Synthesis: </title> <booktitle> Mathematical Aspects, Cornell MSI Workshop, Lecture Notes in Computer Science 408, </booktitle> <pages> pp. 106-128, </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: Interactively used transformations on the control ow are discussed in [WaT89]. In [MCF93] correctness of transformations in the System Architects Workbench is investigated. Several errors were found, often related to incorrect use of bit array data types. The Yorktown Silicon Compiler-based [BCD88] system <ref> [Cam89] </ref> emphasizes transformations to improve scheduling and allocation. The computations and control structure are not changed. The Yorktown Internal Form, which is similar to CDFG languages, is used as intermediate language. The transformation steps used for scheduling and allocation are proven correct. <p> Correctness of register-transfer level transformations for scheduling and allocation has been dealt with in [Vem90]. A formal analysis of transformations used in Systems Architects Workbench (SAW) high-level synthesis was studied by McFarland [McF93]. Transformations used in YIF (Yorktown Internal Form) [BCD88] have been proved to be behavior-preserving <ref> [Cam89] </ref>. In this work, a strong notion of behavior equivalence based on an imperative semantics tied to a particular model of representation is used. A post facto verification method for comparing logic-level designs against a restricted class of data-ow graphs in SILAGE was presented by Aelten and others [AAD93, Ael94].
Reference: [CaT89] <author> R. Camposano, </author> <title> R.M. </title> <booktitle> Tabet, Design representation for the synthesis of behavioral VHDL models , Proc. 9th Int. Conf. on CHDL, </booktitle> <pages> pp. 49-58, </pages> <editor> eds. J.A. Darringer and F.J. Ramming, </editor> <publisher> Elsevier Science Publishers B.V., North Holland, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: For these reasons design cost estimators are no part of TRADES. If required by the designer they will be provided as add-on analysis tools. The control data ow graphs (CDFG) often used as design representation in high-level synthesis <ref> [CaT89] </ref> are not limited to a specific architecture. On the contrary, CDFGs are very exible and have been used to efficiently represent both hardware and software structures [Mid95]. Much P.F.A. Middelhoek & S.P. <p> [0k];d:bit [0l])y:bit [0m]= begin y = ((a+b)+c)+d; + + c y 5 17 4 + + y 5 17 17 max. logic depth: 5% size resources: +35% with k=3; l=15 and m=16 and use of ripple adders Tree Height Reduction formats have shown to be very useful in high-level synthesis <ref> [CaT89] </ref> and allow for formalization of their semantics [HuK94]. An overview of data ow languages and their semantics can be found in [LeP95]. The best known CDFG variants in high-level synthesis are those derived from the applicative language Silage [Hil85].
Reference: [CGR93] <author> V. Chaiyakul, D.D. Gajski, L. Ramanchandran, </author> <title> High-Level Transformations for Minimizing Syntactic Variances , Proc. </title> <booktitle> of DAC 93, </booktitle> <pages> pp. 413-418, </pages> <year> 1993. </year>
Reference-contexts: Section 5.3 focuses on constructs of SIL, which are required for preserving the implementation suggestion and are different from most other CDFG languages. 5.2. Implementation Suggestion While others consider the implementation suggestion an unwanted side-effect of the specification process requiring a normalization step to dispose <ref> [Jan94, CGR93, Gaj94] </ref>, we do not. On the contrary, the implementation suggestion may very well be intended by the designer and contain valuable pointers in the design space towards the optimal solution. This is especially so if the specification is written by an experienced designer. <p> Techniques proposed in [CGR93 and Jan94] are useful for this latter aspect but neither is capable of obtaining a unique, normalized representation for each behavior. Due to the (intentional) ambiguity in the representation of the imple - mentation suggestion in <ref> [CGR93] </ref> we think the format is not suited as backbone for synthesis. types where maintaining the implementation suggestion is important. The graph on the left most closely matches the implementation suggestion contained in the specification. <p> Furthermore, the proof assumes the existence of a normal form of a behavior and the use of invertible transformations. As far as we know such a normal form is not known and attempts to define one <ref> [Jan94, CGR93] </ref> have failed. Because transformations on SIL can reduce design freedom (for example the constantsplitting transformation shown in Figure 7) they are generally not invertible. Because of the large number of transformations, the efficiency of the process of implementing and verifying transformations requires special attention.
Reference: [Cha92] <author> A. Chandrakasan, M. Potkonjak, J. Rabaey, R. Broderson, </author> <title> An Approach For Power Minimization Using Transformations, </title> <booktitle> Proc. of the IEEE VLSI Signal Processing Workshop, </booktitle> <pages> pp. 41 - 50, </pages> <year> 1992. </year>
Reference-contexts: This step potentially reduces the critical path, power consumption, and increases the amount of parallelism <ref> [Cha92] </ref>. However, because of the unbalanced data types in this instantiation of the parame - terized design, tree height reduction has the opposite effect and the critical path, in fact, increases due to the larger circuit size. <p> Furthermore the efficiency and real-time requirements are also very stringent compared to most software. Many (partially) transformation-based design systems exist or are under construction as part of larger projects. The HYPER system developed at the University of Berkeley <ref> [Bro92, Cha92, IPS93, Pot94] </ref> provides a set of transformations for automatic algorithmic-level design optimization. HYPER consists of transformations from the optimization, refinement, timespace assignment categories. The refinement transformations are however limited to strength reduction. Silage is used as specification language and translated to the HYPER CDFG [RaH90].
Reference: [CPM95] <author> A.P. Chandrakasan, M. Potkonjak, R. Mehra, J. Rabaey and R.W. Broderson, </author> <title> Optimizing Power Using Transformations, </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, </journal> <volume> vol. 14, no. 1, </volume> <pages> pp. 12-31, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: This approach is known as transfor - mational design and illustrated in Figure 3. 4.3. Existing Solutions Existing silicon compilers (e.g. Cathedral Compilers [DeM86], Piramid [WBM90], and the commercial version DSP Station by Mentor Graphics, Phideo [LMW91], Hyper (-LP) <ref> [CPM95] </ref>) are specialized towards specific application and target domains. While this specialization was initially introduced to allow construction of efficient automatic synthesis tools, consisting of design steps, cost estimators, and optimization algorithms, it is now more and more becoming a limitation.
Reference: [CRS94] <author> D. Cyrluk, S. Rajan, N. Shankar and M. Srivas, </author> <title> Effective Theorem Proving for Hardware Verification, </title> <booktitle> Proc. of the 2 nd International Conference on Theorem Provers in Circuit Design, </booktitle> <address> Bad Heerenalb (Blackforest), Germany, </address> <month> 26-29 September </month> <year> 1994. </year>
Reference-contexts: The checking is done by comparing the specified properties of the entities. For example, one can compare if a register-transfer level imple mentation of hardware satisfies the properties expressed by its high-level specification. PVS has been used for reasoning in many domains, such as in hardware verification <ref> [Cyr93, CRS94, RSS95] </ref>, protocol verification, and algorithm verification [LOR93]. We have specified and verified transformations such as copy propagation, constant propagation, common subexpres-sion insertion, commutativity, associativity, distributivity, and strength reduction described by Engelen and others [EMH93] in PVS.
Reference: [Cyr93] <author> D. Cyrluk, </author> <title> Microprocessor Verification in PVS: A methodology and simple example , SRI-CSL-93-12, </title> <type> Technical Report, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: The checking is done by comparing the specified properties of the entities. For example, one can compare if a register-transfer level imple mentation of hardware satisfies the properties expressed by its high-level specification. PVS has been used for reasoning in many domains, such as in hardware verification <ref> [Cyr93, CRS94, RSS95] </ref>, protocol verification, and algorithm verification [LOR93]. We have specified and verified transformations such as copy propagation, constant propagation, common subexpres-sion insertion, commutativity, associativity, distributivity, and strength reduction described by Engelen and others [EMH93] in PVS.
Reference: [DeM86] <author> H. De Man, J. Rabaey, P. Six, L. Claesen, Cathedral-II: </author> <title> A Silicon Compiler for Digital Signal Processing, </title> <booktitle> IEEE Design & Test, </booktitle> <month> December </month> <year> 1986. </year>
Reference-contexts: For TRADES the above considerations resulted in a combination of formally verified, designerselected, pre-proven behavior-preserving transformations and a CDFG as design representation. This approach is known as transfor - mational design and illustrated in Figure 3. 4.3. Existing Solutions Existing silicon compilers (e.g. Cathedral Compilers <ref> [DeM86] </ref>, Piramid [WBM90], and the commercial version DSP Station by Mentor Graphics, Phideo [LMW91], Hyper (-LP) [CPM95]) are specialized towards specific application and target domains. <p> An overview of data ow languages and their semantics can be found in [LeP95]. The best known CDFG variants in high-level synthesis are those derived from the applicative language Silage [Hil85]. They are, for instance, used in the Cathedral <ref> [DeM86] </ref>, Piramid [WBM90], and as DFL in the commercial DSP Station tools.
Reference: [EMH93] <author> W. Engelen, P.F.A. Middelhoek, C. Huijs, J. Hofstede, Th. Krol, </author> <title> Applying Software Transformations to SIL, </title> <booktitle> SPRITE deliverable LS.a.5.2/UT/Y5/M6/1A, </booktitle> <month> June </month> <year> 1993.* </year>
Reference-contexts: Traditionally most emphasis in high-level synthesis has been on scheduling and allocation steps [Gaj94, WaC95]. An overview of transformations used in TRADES can be found in <ref> [EMH93] </ref>. tail merging transformation is used to merge identical opera - tions in two mutually exclusive data paths, like the ones generated in the translation of if-then-else constructs. The transformation is used in the design of the Abs_Diff function as shown in Sidebar I. <p> PVS has been used for reasoning in many domains, such as in hardware verification [Cyr93, CRS94, RSS95], protocol verification, and algorithm verification [LOR93]. We have specified and verified transformations such as copy propagation, constant propagation, common subexpres-sion insertion, commutativity, associativity, distributivity, and strength reduction described by Engelen and others <ref> [EMH93] </ref> in PVS. In general, the proofs of transformations proceed by rewriting, using axioms and proved theorems, and finally simplifying to a set of Boolean expressions containing only relations between ports and port arrays.
Reference: [Eve87] <author> H. Eveking, </author> <title> Verification, Synthesis and Correctness-Preserving Transformations - Cooperative Approaches to Correct Hardware Design, HDL Descriptions to Quaranteed Correct Circuit Designs, </title> <editor> ed. S. Borrione, </editor> <publisher> Elsevier Science Publishers B.V., North Holland, </publisher> <year> 1987. </year>
Reference-contexts: In fact an executable specification can be viewed as an initial, though most likely not very efficient, implementation. For the next step from specification to implementation three approaches towards design correctness can be identified: simulation, verification, and correctness by construction <ref> [Eve87] </ref>. Simulation is the most popular but cannot be used to assure the correctness of a design with respect to its specification since exhaustive simulation quickly becomes infeasible for even relatively small designs. The latter two methods are formal and can be used to guarantee the correctness of an implementation.
Reference: [ELL90] <institution> Computer General Electronic Design, </institution> <note> The ELLA Language Reference Manual, </note> <institution> The New Church, Henry St. Bath BA1 1JR, U.K., </institution> <note> issue 4.0, </note> <year> 1990. </year>
Reference: [FNS94] <author> F. Franssen, L. Nachtergaele, H. Samsom, F. Catthoor, H. De Man, </author> <title> Control Flow Optimization For Fast System Simulation and Storage Minimization, </title> <booktitle> Proc. of EDTC 1994, </booktitle> <pages> pp. 20-24, </pages> <address> Paris, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: The tool provides (affine) transformations on loops with manifest (i.e. data-independent) bounds. Transformations are performed on Silage and can be used in both an interactive and automatic mode using the memory optimization tool MASAI <ref> [FNS94, SFC94] </ref>. A geometry-based verification model has been developed for automatic post-verification of the design after applying loop transformations. SynGuide is very applicationspecific compared to TRADES and used post - verification, but it shares our philosophy on the implementation suggestion and interactive design.
Reference: [Fou90] <author> M.P. Fourman, </author> <title> Formal System Design, Formal Methods for VLSI Design, </title> <editor> ed. J. Staunstrup, </editor> <publisher> North-Holland, IFIP, </publisher> <year> 1990. </year>
Reference-contexts: Furthermore, we can handle CDFGs of arbitrary structure and size for verification, unlike previously proposed techniques. A formal model was proposed for verifying correctness of high-level transformations by McFarland and Parker [McP83]. A formal system using transformations for hard - ware synthesis has been discussed by Fourman <ref> [Fou90] </ref>. A synthesis system for a language based on an algebraic formalism has been presented by Jones and Sheeran [She90], and its formalization has been presented by Rossen [Ros90]. Another algebraic approach to transformational design of hardware has been worked out by Johnson [Joh84].
Reference: [Gaj94] <author> D.D. Gajski, L. Ramachandran, </author> <title> Introduction to High-Level Synthesis, </title> <booktitle> IEEE Design and Test of Computers, </booktitle> <month> Winter </month> <year> 1994. </year>
Reference-contexts: Section 5.3 focuses on constructs of SIL, which are required for preserving the implementation suggestion and are different from most other CDFG languages. 5.2. Implementation Suggestion While others consider the implementation suggestion an unwanted side-effect of the specification process requiring a normalization step to dispose <ref> [Jan94, CGR93, Gaj94] </ref>, we do not. On the contrary, the implementation suggestion may very well be intended by the designer and contain valuable pointers in the design space towards the optimal solution. This is especially so if the specification is written by an experienced designer. <p> The struc - ture of the algorithm in time and space can be altered by means of retiming, multi-rate, loop, and scheduling transfor - mations. Traditionally most emphasis in high-level synthesis has been on scheduling and allocation steps <ref> [Gaj94, WaC95] </ref>. An overview of transformations used in TRADES can be found in [EMH93]. tail merging transformation is used to merge identical opera - tions in two mutually exclusive data paths, like the ones generated in the translation of if-then-else constructs.
Reference: [HaP95] <author> J. Hallberg, Z. Peng, </author> <title> Synthesis under Local Timing Constraints in the CAMAD High-Level Synthesis System, </title> <booktitle> Proc. of IEEE EUROMICRO 95, </booktitle> <address> Como, Italy, </address> <year> 1995. </year>
Reference-contexts: TRADES and HYPER are largely complementary. The automatic optimization algorithms developed for HYPER could be applied within TRADES while HYPER could benefit from our more powerful CDFG language, support for VHDL, and much larger set of preproven design transformations which guarantees correctness by construction. The CAMAD <ref> [Pen89, Pen94, HaP95] </ref> high-level synthesis system uses automatic transformations for scheduling and allocation. Algorithms written in Pascal or Behavioral VHDL used for specification are translated into an Extended Timed Petri Net representation in which data and control ow are separated.
Reference: [Hen95] <author> J. Hennessy, </author> <title> Hardware/Software Codesign of Processors: Concepts and Example, </title> <booktitle> Lecture notes NATO/ASI course on hardware software codesign, part I, </booktitle> <address> Tremezzo, Italy, </address> <month> June </month> <year> 1995. </year> <note> P.F.A. Middelhoek & S.P. Rajan February 14, 1996 18 </note>
Reference-contexts: To achieve the desired quick turnaround times and to reduce the cost of making many design iterations, general-purpose reusable and programmable hardware is required. The ability to model a system at different levels of detail is crucial in this phase to speed up simulation times <ref> [Hen95] </ref>. Products initially often have strict time-to-market requirements in order to capture market share. In product volume this phase represents only a few percent of total sales. Later on in its life cycle other considerations become important.
Reference: [HHK92] <author> C. Huijs, J. Hofstede, T. Krol, SIL: </author> <title> a Useful Interface between Specifications and Silicon Compilers, </title> <booktitle> Proc. of the ProRISC/IEEE Workshop on CSSP, </booktitle> <pages> pp. 99-104, </pages> <address> Houthalen, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Miranda, Silage, VHDL, C) and high-level synthesis tools. This includes translation of the implementation suggestion hidden in specifications, such as the ordering and overwriting mechanism in imperative languages. In <ref> [HHK92] </ref> it was demonstrated how a SIL graph with an imperative implementation suggestion can be transformed into a functional-style graph. The next section will discuss our view on the implementation suggestion.
Reference: [Hil85] <author> P. N. Hilfinger, Silage: </author> <title> a High-level Language and Silicon Compiler for Digital Signal Processing, </title> <booktitle> Proceedings of IEEE Custom Integrated Circuits Conference, </booktitle> <pages> pp. 213-216, </pages> <address> Portland, OR, </address> <month> May </month> <year> 1985. </year>
Reference-contexts: Distributivity Correctness in design deals with maintaining consis - tency between these levels. Figure 1 illustrates this for a top-down design methodology. The specification is usually written in HDLs such as VHDL [VHD88] or Silage <ref> [Hil85] </ref>. The only practical way to validate the behavior of a specification against the user requirements is through the execution of the specification (i.e. simulation) using a test suite as input. This process cannot guarantee correctness because it is not exhaustive. Execution requires an imple mentation and therefore structure. <p> An overview of data ow languages and their semantics can be found in [LeP95]. The best known CDFG variants in high-level synthesis are those derived from the applicative language Silage <ref> [Hil85] </ref>. They are, for instance, used in the Cathedral [DeM86], Piramid [WBM90], and as DFL in the commercial DSP Station tools.
Reference: [HuK94] <author> C. Huijs, Th. Krol, </author> <title> A Formal Semantic Model to Fit SIL for Transformational Design , Proc. </title> <booktitle> of 20th Euromicro Conference, </booktitle> <pages> pp. 100-107, </pages> <address> Liverpool, </address> <month> September </month> <year> 1994.* </year>
Reference-contexts: + c y 5 17 4 + + y 5 17 17 max. logic depth: 5% size resources: +35% with k=3; l=15 and m=16 and use of ripple adders Tree Height Reduction formats have shown to be very useful in high-level synthesis [CaT89] and allow for formalization of their semantics <ref> [HuK94] </ref>. An overview of data ow languages and their semantics can be found in [LeP95]. The best known CDFG variants in high-level synthesis are those derived from the applicative language Silage [Hil85]. <p> The proven applicability of CDFG languages to digital design and the need for compositional formal semantics made us choose the CDFG-like language SIL [Klo92, Klo93, KMN92], which integrates both control and data ow into a single graph and has formal semantics <ref> [HuK94] </ref>. SIL has been developed cooperatively by Philips Research, IMEC, and the University of Twente as part of the EC-funded ESPRIT/SPRITE project. It includes support for hierarchy, structured data types, recursion, multi-rate, ordering, and control structures.
Reference: [HLD90] <author> F.K. Hanna M. Longley, N. Daeche, </author> <title> Formal Synthesis of Digital Systems, Formal VLSI Specification and Synthesis, VLSI Design Methods, I, </title> <editor> Editor L.J.M. Claesen, </editor> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: This in contrast to [WaC95] which limits high-level synthesis to the scheduling, allocation, and binding problem. The design time of a system consists of the time required for synthesis and achieving correctness <ref> [HLD90] </ref>. To reduce design time most research in high-level synthesis concen - trates on the automatic synthesis of efficient implementations of well-defined behavioral specifications using a parameterized target architecture consisting of functional, memory, and interconnection units.
Reference: [IPS93] <author> Z. Iqbal, M. Potkonjak, S. Dey, A. Parker, </author> <title> Critical Path Minimization Using Retiming and Algebraic SpeedUp, </title> <booktitle> Proc. of DAC 93, </booktitle> <pages> pp. 573-577, </pages> <year> 1993. </year>
Reference-contexts: Furthermore the efficiency and real-time requirements are also very stringent compared to most software. Many (partially) transformation-based design systems exist or are under construction as part of larger projects. The HYPER system developed at the University of Berkeley <ref> [Bro92, Cha92, IPS93, Pot94] </ref> provides a set of transformations for automatic algorithmic-level design optimization. HYPER consists of transformations from the optimization, refinement, timespace assignment categories. The refinement transformations are however limited to strength reduction. Silage is used as specification language and translated to the HYPER CDFG [RaH90].
Reference: [Jan93] <author> G. </author> <type> Janssen, </type> <institution> ROBDD software , Department of Electrical Engineering, Technical University of Eindhoven, Eindhoven, Netherlands, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: In general, the proofs of transformations proceed by rewriting, using axioms and proved theorems, and finally simplifying to a set of Boolean expressions containing only relations between ports and port arrays. At this final stage the Boolean simplifier based on Binary Decision Diagrams (BDD) <ref> [BRB90, Jan93] </ref> integrated in PVS, is used to determine that the conjunction of Boolean expressions is indeed true. We show the runtimes of verifying the various transformations in Table II.
Reference: [Jan94] <author> M. Janssen, F. Catthoor, H. de Man, </author> <title> A Specification Invariant Technique for Operation Cost Minimisation in Flow-Graphs, </title> <booktitle> Proc. of the Seventh International Symposium on High-Level Synthesis, </booktitle> <pages> pp. 146-151, </pages> <address> Niagara-on-the-Lake, Ontario, Canada, </address> <year> 1994. </year>
Reference-contexts: Section 5.3 focuses on constructs of SIL, which are required for preserving the implementation suggestion and are different from most other CDFG languages. 5.2. Implementation Suggestion While others consider the implementation suggestion an unwanted side-effect of the specification process requiring a normalization step to dispose <ref> [Jan94, CGR93, Gaj94] </ref>, we do not. On the contrary, the implementation suggestion may very well be intended by the designer and contain valuable pointers in the design space towards the optimal solution. This is especially so if the specification is written by an experienced designer. <p> Even for the transformational design of the small Abs_Diff design, which calculates the absolute value of the difference of two signals, shown in Sidebar I, well over 25 different kinds of transformation are needed (not counting type transformations). In <ref> [Jan94] </ref> it is suggested that selecting a set of transformations for trans - formational design is relatively simple; our experience however indi cates the opposite. <p> Furthermore, the proof assumes the existence of a normal form of a behavior and the use of invertible transformations. As far as we know such a normal form is not known and attempts to define one <ref> [Jan94, CGR93] </ref> have failed. Because transformations on SIL can reduce design freedom (for example the constantsplitting transformation shown in Figure 7) they are generally not invertible. Because of the large number of transformations, the efficiency of the process of implementing and verifying transformations requires special attention. <p> While their approach is interesting for prototyping we feel hardware/software codesign of commercial products will require many more transformation steps and could be better tackled with TRADES. For automatic optimization of sparsely-multiplexed data paths at the algorithmic level the GATE tool <ref> [Jan94] </ref> has been developed at IMEC, Belgium. The tool uses optimizing, strength reduction, and retiming transformations. The optimization strategy is based on transforming DFG-based specifications of data paths into a pseudo-normalized P.F.A. Middelhoek & S.P. Rajan February 14, 1996 10 6. <p> That formal verification of transformations is not a luxury has been shown in [Raj95ab] and [MCF93]. Furthermore most of these systems employ an automated approach to the application and selection of transformations. To facilitate this they limit the application domain to for instance data path <ref> [Jan94] </ref> or memory optimization [SFC94]. Although such approaches have proven to be useful in many cases (examples include memory reduc tion, optimizing resource utiliza tion, critical path and power reduction, and to improve testability, and scheduling, allocation), we found that they are too limited for fullscale transformational design.
Reference: [Joh84] <author> S. D. Johnson, </author> <title> Synthesis of Digital Designs from Recursion Equations, </title> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1984. </year>
Reference-contexts: A synthesis system for a language based on an algebraic formalism has been presented by Jones and Sheeran [She90], and its formalization has been presented by Rossen [Ros90]. Another algebraic approach to transformational design of hardware has been worked out by Johnson <ref> [Joh84] </ref>. Correctness of register-transfer level transformations for scheduling and allocation has been dealt with in [Vem90]. A formal analysis of transformations used in Systems Architects Workbench (SAW) high-level synthesis was studied by McFarland [McF93]. Transformations used in YIF (Yorktown Internal Form) [BCD88] have been proved to be behavior-preserving [Cam89].
Reference: [Jz95] <author> L. Jzwiak, </author> <title> An Efficient Verification Method for Application in Transformational Design, </title> <booktitle> Proc. of Euromicro 95, </booktitle> <pages> pp. 118-129, </pages> <address> Como, Italy, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Smallness is required to ensure that it is reasonable to verify the correctness of both the definition and implementation of the transformation. Achieving correct implementations can be further aided by reverse mapping techniques where both the forward transformation and its inverse are implemented independently <ref> [Jz95] </ref>. Locality is needed to exploit the compositionality of behavior. It also guarantees that execution of transformations is nearly instantaneous and independent of the size of the design. At first sight it may seem that some transformations, such as partitioning, are global, but this is not the case.
Reference: [Klo92] <author> W.E.H. Kloosterhuis, M.M.R. Eyckmans, J. Hofstede, C. Huijs, Th. Krol, O.P. McArdle, W.J.M. Smits, L.G.L. Svensson, </author> <title> SIL-2 Language Report, </title> <booktitle> SPRITE deliverable LS.a.a/Philips/Y3-M12/2, </booktitle> <year> 1993.* </year>
Reference-contexts: They are, for instance, used in the Cathedral [DeM86], Piramid [WBM90], and as DFL in the commercial DSP Station tools. The proven applicability of CDFG languages to digital design and the need for compositional formal semantics made us choose the CDFG-like language SIL <ref> [Klo92, Klo93, KMN92] </ref>, which integrates both control and data ow into a single graph and has formal semantics [HuK94]. SIL has been developed cooperatively by Philips Research, IMEC, and the University of Twente as part of the EC-funded ESPRIT/SPRITE project. <p> The parameter mechanism of SIL can be used to describe and transform designs which for instance use parameterized types (Figure 4). This was used but not shown for the Abs_Diff design in Sidebar I. A complete definition of syntax and informal semantics of SIL-1 and -2 <ref> [Klo92, Klo93] </ref> can be found on our Web site: &lt;http://wwwspa.cs.utwente.nl/aid/aid.html&gt; 5.4. Transformations Our design ow is based on the consecutive application of preproven behavior-preserving transformations. The use of preproven generalized transformations in a compositional design description eliminates the need for (post-) verification or simulation steps.
Reference: [Klo93] <author> W.E.H. Kloosterhuis, M.M.R. Eyckmans, Th. Krol, O.P. McArdle, W.J.M. Smits, </author> <title> SIL-2 Language Report, </title> <booktitle> SPRITE deliverable LS.a.2/Philips/Y3-M12/1, </booktitle> <year> 1993.* </year>
Reference-contexts: They are, for instance, used in the Cathedral [DeM86], Piramid [WBM90], and as DFL in the commercial DSP Station tools. The proven applicability of CDFG languages to digital design and the need for compositional formal semantics made us choose the CDFG-like language SIL <ref> [Klo92, Klo93, KMN92] </ref>, which integrates both control and data ow into a single graph and has formal semantics [HuK94]. SIL has been developed cooperatively by Philips Research, IMEC, and the University of Twente as part of the EC-funded ESPRIT/SPRITE project. <p> The parameter mechanism of SIL can be used to describe and transform designs which for instance use parameterized types (Figure 4). This was used but not shown for the Abs_Diff design in Sidebar I. A complete definition of syntax and informal semantics of SIL-1 and -2 <ref> [Klo92, Klo93] </ref> can be found on our Web site: &lt;http://wwwspa.cs.utwente.nl/aid/aid.html&gt; 5.4. Transformations Our design ow is based on the consecutive application of preproven behavior-preserving transformations. The use of preproven generalized transformations in a compositional design description eliminates the need for (post-) verification or simulation steps.
Reference: [KMN92] <author> T. Krol, J. van Meerbergen, C. Niessen, W. Smits, J. Huisken, </author> <title> The Sprite Input Language: An Intermediate Format for High-Level Synthesis, </title> <booktitle> Proc. of EDAC 92, </booktitle> <pages> pp. 186-192, </pages> <address> Brussels, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: They are, for instance, used in the Cathedral [DeM86], Piramid [WBM90], and as DFL in the commercial DSP Station tools. The proven applicability of CDFG languages to digital design and the need for compositional formal semantics made us choose the CDFG-like language SIL <ref> [Klo92, Klo93, KMN92] </ref>, which integrates both control and data ow into a single graph and has formal semantics [HuK94]. SIL has been developed cooperatively by Philips Research, IMEC, and the University of Twente as part of the EC-funded ESPRIT/SPRITE project.
Reference: [Kun88] <author> S.Y. Kung, </author> <title> VLSI Array Processors, </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Figure 6a is a shorthand notation for 6b. Figure 6a can be obtained by folding the dependency graph from Figure 6b. This process is very similar to the folding (projection) techniques used in array processor synthesis where dependency graphs are folded onto a regular array of processing elements <ref> [Kun88] </ref>. In Figure 6c a partially folded, multi-rate SIL description of the circuit is shown. The upsample (US) and downsample (DS) nodes function as cyclo-static de/multi - plexers. The numbers indicate the active phase.
Reference: [LeP95] <author> E.A. Lee, </author> <title> T.M. Parks, Dataow Process Networks, </title> <journal> Proc. of the IEEE, </journal> <volume> Vol. 83, No. 5, </volume> <pages> pp. 773-799, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: An excellent overview can be found in <ref> [LeP95] </ref>. 4.2. Efficiency Achieving efficient and preferably optimal solutions is a difficult problem in high-level synthesis and much effort has been put in developing good optimization algorithms. <p> An overview of data ow languages and their semantics can be found in <ref> [LeP95] </ref>. The best known CDFG variants in high-level synthesis are those derived from the applicative language Silage [Hil85]. They are, for instance, used in the Cathedral [DeM86], Piramid [WBM90], and as DFL in the commercial DSP Station tools.
Reference: [LKL94] <author> M.H. Lee, J.H. Kim, J.S. Lee, K.K. Ryu, D.I. Song, </author> <title> A New Al - gorithm for Interlaced to Progressive Scan Conversion Based on Directional Correlations and Its IC Design, </title> <journal> IEEE Trans. Consumer Electronics, </journal> <volume> vol. 40, No. 2, </volume> <pages> pp. 119-125, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Recent extensions to the filter include the use of motion compensation for determining the correct pixel from the previous field. Further extensions have been proposed in <ref> [LKL94] </ref>, which also con tains a more complete overview of the algorithm and its history. We have selected the direction detector because it is relevant in industry and currently used in television sys tems and could also prove useful for IPSC in the new HDTV standard [BCD95].
Reference: [LMW91] <author> P.E.R. Lippens, J.L. van Meerbergen, A. van der Werf, W.F.J. Verhaegh, B.T. McSweeney, J.O. Huisken, </author> <title> O.P. McArdle, PHIDEO: A Silicon Compiler for High Speed Algorithms, </title> <booktitle> Proc. of EDAC 91, </booktitle> <address> pp.436-441, Amsterdam, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: This approach is known as transfor - mational design and illustrated in Figure 3. 4.3. Existing Solutions Existing silicon compilers (e.g. Cathedral Compilers [DeM86], Piramid [WBM90], and the commercial version DSP Station by Mentor Graphics, Phideo <ref> [LMW91] </ref>, Hyper (-LP) [CPM95]) are specialized towards specific application and target domains. While this specialization was initially introduced to allow construction of efficient automatic synthesis tools, consisting of design steps, cost estimators, and optimization algorithms, it is now more and more becoming a limitation. <p> In a previous custom implementation the direction detector accounted for 40% of the size of the data path while the field and line memory consumed the most chip area. The example has been studied extensively both at Philips Research <ref> [LMW91] </ref> and IMEC [SaR92] as part of the ESPRIT/SPRITE pro ject and both a prototype and custom implementations have been developed. This allows us to compare our results with respect to efficiency and exibility with those obtained previously using different methodologies and tools.
Reference: [LOR93] <author> P. Lincoln, S. Owre, J. Rushby, N. Shankar, F. von Henke, </author> <title> Eight Papers on Formal Verification, </title> <type> Technical Report SRI-CSL-93-4, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: For example, one can compare if a register-transfer level imple mentation of hardware satisfies the properties expressed by its high-level specification. PVS has been used for reasoning in many domains, such as in hardware verification [Cyr93, CRS94, RSS95], protocol verification, and algorithm verification <ref> [LOR93] </ref>. We have specified and verified transformations such as copy propagation, constant propagation, common subexpres-sion insertion, commutativity, associativity, distributivity, and strength reduction described by Engelen and others [EMH93] in PVS.
Reference: [Lov77] <author> D.B. Loveman, </author> <title> Program Improvement by Source-to-Source transformations, </title> <journal> Journal of the ACM, </journal> <volume> VOl 24, No. 1, </volume> <pages> pp. 121 - 145, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: Related Work The use of transformations for the design of both software and hardware is not new. While formal program refinement techniques never really caught on, the use of transformations in software compilers is common <ref> [Lov77, ASU86] </ref>. There are, however, several aspects that make hardware design different from software design and the use of formal tech - niques more attractive. In hardware design, rebuilding hardware normally has a very high cost and is time-consuming.
Reference: [McF93] <author> M.C. McFarland, </author> <title> Formal Analysis of Correctness of Behavioral Transformations, </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> Vol. 2, No. 3, </volume> <pages> pp. 231-257, </pages> <publisher> Kluwer, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: For specification, the Instruction Set Processor Specification (ISPS) language is used. Transformations supported include hierarchy introduction, expansion, constant propagation, loop unrolling, and common subexpression elimination. Interactively used transformations on the control ow are discussed in [WaT89]. In <ref> [MCF93] </ref> correctness of transformations in the System Architects Workbench is investigated. Several errors were found, often related to incorrect use of bit array data types. The Yorktown Silicon Compiler-based [BCD88] system [Cam89] emphasizes transformations to improve scheduling and allocation. The computations and control structure are not changed. <p> Most systems incorrectly ignore the inuence of data typing on both correctness at the bit-level [Mid94a] and efficiency (Section 5.2, Figure 4). Very few can guarantee correctness because the transformations are not formally verified. That formal verification of transformations is not a luxury has been shown in [Raj95ab] and <ref> [MCF93] </ref>. Furthermore most of these systems employ an automated approach to the application and selection of transformations. To facilitate this they limit the application domain to for instance data path [Jan94] or memory optimization [SFC94]. <p> Another algebraic approach to transformational design of hardware has been worked out by Johnson [Joh84]. Correctness of register-transfer level transformations for scheduling and allocation has been dealt with in [Vem90]. A formal analysis of transformations used in Systems Architects Workbench (SAW) high-level synthesis was studied by McFarland <ref> [McF93] </ref>. Transformations used in YIF (Yorktown Internal Form) [BCD88] have been proved to be behavior-preserving [Cam89]. In this work, a strong notion of behavior equivalence based on an imperative semantics tied to a particular model of representation is used.
Reference: [McP83] <author> M.C. McFarland and A.C. Parker, </author> <title> An Abstract Model of Behavior for Hardware Descriptions, </title> <journal> IEEE Trans. on Computers C-32(7), </journal> <pages> pp. 621-36, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: This makes it applicable to a variety of CDFG formalisms used in different high-level synthesis frameworks. Furthermore, we can handle CDFGs of arbitrary structure and size for verification, unlike previously proposed techniques. A formal model was proposed for verifying correctness of high-level transformations by McFarland and Parker <ref> [McP83] </ref>. A formal system using transformations for hard - ware synthesis has been discussed by Fourman [Fou90]. A synthesis system for a language based on an algebraic formalism has been presented by Jones and Sheeran [She90], and its formalization has been presented by Rossen [Ros90].
Reference: [Mid94a] <editor> P.F.A. Middelhoek, </editor> <booktitle> Transformational Design of Digital Signal Processing Applications , Proc. of the ProRISC/IEEE Workshop on CSSP, </booktitle> <pages> pp. 176-180, </pages> <address> Arnhem, Netherlands, </address> <month> March </month> <year> 1994.* </year>
Reference-contexts: A novel approach to the verification of design transformations is discussed in Section 7. 2. Correctness Achieving correct designs is crucial in high-level synthesis and played the central role in the development of our methodology and design system TRADES <ref> [Mid94a, Mid94b, MMM95, Mid95] </ref>. We identify four major levels in the design of digital systems: requirements, specification, implementation, and realization. The system requirements capture the desired properties of a system informally , often in natural language. <p> Because of the size of both designs and design space, and the nature of the optimization problems (many are NP-hard), optimal solutions can in general not be guaranteed. We think, and early results confirm this <ref> [Mid94a, Mid94b, MMM95, Mid95] </ref>, that better, more efficient designs can be obtained by exploiting the exibility, creativity, and experience of the designer in an interactive design environment. As noted earlier, in real life a designer most often already has experience with a design or similar designs. <p> Good methods for dealing with data typing are very important both from a correctness and efficiency point of view. Achieving bittrue behavior between the original design and the transformed one is non - trivial <ref> [Mid94a] </ref>. The same is true for the calculation of minimal bit-widths to optimize area and timing. The struc - ture of the algorithm in time and space can be altered by means of retiming, multi-rate, loop, and scheduling transfor - mations. <p> This requires a partial attening of the design. While area optimization was the primary objective in the Abs_Diff example, the methodology can also be applied to minimize power or increase speed which typically requires the use of time-space transformations <ref> [Mid94a, Mid94b, MMM95, Mid95] </ref>. The set of transformations required for fullscale trans - formational design is very large even though we have attempted to minimize this set by using generalized, primitive transformations. <p> Conditional execution is emulated through multiplexer-like constructs. Within HYPER many automatic optimization scripts have been developed successfully for different purposes, including optimizing resource utiliza tion, critical path and power reduction, and to improve testability. The transformations are not verified and designs are not bittrue with respect to the specification <ref> [Mid94a] </ref>. Simulation is required to evaluate both correctness and the numerical behavior of the transformed design. The methodology is therefore not correct by construction. The system does not support mixed-level designs or refinement (of data types) nor does it support the construction of architectures. TRADES and HYPER are largely complementary. <p> The transformation steps used for scheduling and allocation are proven correct. Correctness by construction is based on transitivity of behavioral equivalence but no use is made of compositionality. Most systems incorrectly ignore the inuence of data typing on both correctness at the bit-level <ref> [Mid94a] </ref> and efficiency (Section 5.2, Figure 4). Very few can guarantee correctness because the transformations are not formally verified. That formal verification of transformations is not a luxury has been shown in [Raj95ab] and [MCF93].
Reference: [Mid94b] <author> P.F.A. Middelhoek, </author> <title> Transformational Design of a Direction Detector for the Progressive Scan Conversion Processor , CSMemorandum 94-64, </title> <institution> University of Twente, Netherlands, </institution> <month> October </month> <year> 1994.* </year>
Reference-contexts: A novel approach to the verification of design transformations is discussed in Section 7. 2. Correctness Achieving correct designs is crucial in high-level synthesis and played the central role in the development of our methodology and design system TRADES <ref> [Mid94a, Mid94b, MMM95, Mid95] </ref>. We identify four major levels in the design of digital systems: requirements, specification, implementation, and realization. The system requirements capture the desired properties of a system informally , often in natural language. <p> Because of the size of both designs and design space, and the nature of the optimization problems (many are NP-hard), optimal solutions can in general not be guaranteed. We think, and early results confirm this <ref> [Mid94a, Mid94b, MMM95, Mid95] </ref>, that better, more efficient designs can be obtained by exploiting the exibility, creativity, and experience of the designer in an interactive design environment. As noted earlier, in real life a designer most often already has experience with a design or similar designs. <p> Within TRADES this implies that the selection of design steps (i.e. transformations) and where to apply them is done manually by the desig ner, aided by a rule-based system that can suggest design strategies <ref> [Mid94b] </ref>. Obviously, some well-understood parts of design ows, especially the lower levels (e.g. logic synthesis), for which good, generally appli cable optimization algorithms exist, or in cases where efficiency is not the primary concern, the selection and application of transformations can and will be automated to further reduce design time. <p> This requires a partial attening of the design. While area optimization was the primary objective in the Abs_Diff example, the methodology can also be applied to minimize power or increase speed which typically requires the use of time-space transformations <ref> [Mid94a, Mid94b, MMM95, Mid95] </ref>. The set of transformations required for fullscale trans - formational design is very large even though we have attempted to minimize this set by using generalized, primitive transformations. <p> The smallest gradient indicates the direction of the edge. In combination with linear interpolation of the luminance signal this is known as the edge-based line average (ELA) algorithm. A diagram of the direction detector is shown in Figure 9. A more detailed description can be found in <ref> [Mid94b, MMM95] </ref>. Our direc - tion detector was used in combination with an extended form of the ELA algorithm which first feeds the input signal P.F.A. Middelhoek & S.P.
Reference: [Mid95] <author> P.F.A. Middelhoek, </author> <title> Arbitrary Hardware Software TradeOffs, </title> <booktitle> Proc. of the 6th IEEE International Workshop on Rapid Systems Prototyping, </booktitle> <pages> pp. 19-25, </pages> <address> Chapel Hill, NC, </address> <month> June </month> <year> 1995.* </year>
Reference-contexts: A novel approach to the verification of design transformations is discussed in Section 7. 2. Correctness Achieving correct designs is crucial in high-level synthesis and played the central role in the development of our methodology and design system TRADES <ref> [Mid94a, Mid94b, MMM95, Mid95] </ref>. We identify four major levels in the design of digital systems: requirements, specification, implementation, and realization. The system requirements capture the desired properties of a system informally , often in natural language. <p> The example of Section 6 will demonstrate how both a processor based and full custom architecture can be used. Other examples of architecture construction have been discussed in <ref> [Mid95] </ref>. Generalizing design cost estimators and the ordering of design steps in heuristics to make them target-independent seems to be much more difficult. Implementation cost expressed in area, speed, and power is directly related to the target architecture, as is the ordering of design steps. <p> The control data ow graphs (CDFG) often used as design representation in high-level synthesis [CaT89] are not limited to a specific architecture. On the contrary, CDFGs are very exible and have been used to efficiently represent both hardware and software structures <ref> [Mid95] </ref>. Much P.F.A. Middelhoek & S.P. <p> Because of the size of both designs and design space, and the nature of the optimization problems (many are NP-hard), optimal solutions can in general not be guaranteed. We think, and early results confirm this <ref> [Mid94a, Mid94b, MMM95, Mid95] </ref>, that better, more efficient designs can be obtained by exploiting the exibility, creativity, and experience of the designer in an interactive design environment. As noted earlier, in real life a designer most often already has experience with a design or similar designs. <p> The integration of control and data ow allows the same transformations to be used in both domains. Furthermore, it eases the transition of functionality between data and control ow as occurs when, for instance, the amount of hardware sharing is changed. Examples of this can be found in <ref> [Mid95] </ref> where we show how filter implementations with different levels of hardware sharing, optimized for area and power, can be derived using transformations. The amount of control ow ranges from none to extensive control ow in a processor/program-based implementation. <p> To maintain the same throughput the operating frequency of the adders can be halved. This allows a reduction of the supply voltage from 5 to 3 Volts and a power reduction of a factor 2.5 in a CMOS implementation. In <ref> [Mid95] </ref> we have shown how space-time mappings can be used for both power and area optimizations. Some important aspects of SIL that we have skipped are the typing and parameter mechanisms. All ports in SIL are typed. <p> This requires a partial attening of the design. While area optimization was the primary objective in the Abs_Diff example, the methodology can also be applied to minimize power or increase speed which typically requires the use of time-space transformations <ref> [Mid94a, Mid94b, MMM95, Mid95] </ref>. The set of transformations required for fullscale trans - formational design is very large even though we have attempted to minimize this set by using generalized, primitive transformations.
Reference: [Mid96] <author> P.F.A. Middelhoek, </author> <title> Transformations on Loops and Arrays, </title> <type> CS Memorandum 96, </type> <institution> University of Twente, Netherlands, </institution> <note> to be published, </note> <year> 1996. </year>
Reference-contexts: While the decision about where to partition is a global problem the partitioning itself can be done by many small local steps. The same is true for scheduling. In [Sam95] it is claimed that loop transformations cannot be tackled with this approach, but as we have shown in <ref> [Mid96] </ref> loop transformations discussed in [Sam95] can in fact be decomposed into smaller transformation steps.
Reference: [MKM91] <author> G. De Micheli, D. Ku, F. Mailhot, T. Truong, </author> <title> The Olympus Synthesis System for Digital Design, Internal report Center for Integrated Systems, </title> <institution> Stanford University, Stanford, </institution> <address> CA 94305, </address> <year> 1991. </year>
Reference-contexts: A geometry-based verification model has been developed for automatic post-verification of the design after applying loop transformations. SynGuide is very applicationspecific compared to TRADES and used post - verification, but it shares our philosophy on the implementation suggestion and interactive design. The Olympus tool set developed at Stanford University <ref> [MKM91] </ref> is oriented to high and low-level synthesis. The tool achieves some target architecture independence by using bottom-up synthesis to calculate design costs instead of using architecture dependent cost estimators. HardwareC is used as specification language at the algorithmic level.
Reference: [MMH95] <author> E. Molenkamp, G.E. Mekenkamp, J. Hofstede, Th. Krol, SIL: </author> <title> an intermediate for syntax based VHDL synthesis, </title> <booktitle> Proc. of the VIUF Spring 95, </booktitle> <address> San Diego, CA, </address> <month> April </month> <year> 1995.* </year>
Reference-contexts: Within TRADES we are therefore developing an alternative syntax-based approach to the translation of full VHDL (with the exception of the explicit time constructs AFTER and FOR) <ref> [MMH95, MMM96] </ref>. It requires only a P.F.A. Middelhoek & S.P. <p> Due to the syntax-based translation, the VHDL event mechanism appears in SIL and manifests itself as two nested loop levels, modeled in SIL by means of recursion. The inner loops model the continued execution of processes. The outer loop triggers computation if internal events occur (the delta mechanism) <ref> [MMH95, MMM96] </ref>. Loop and other transformations are used to remove this event mechanism. How this is done largely depends on the structure of the waitstatement in the original VHDL specification. For the IPS example the cleanup step was performed interactively.
Reference: [MMM95] <author> P.F.A. Middelhoek, G.E. Mekenkamp, E. Molenkamp, Th. Krol, </author> <title> A Transformational Approach to VHDL and CDFG based High-Level Synthesis: a Case Study, </title> <booktitle> Proc. of the CICC 95, </booktitle> <pages> pp. 37-40, </pages> <address> Santa Clara, CA, </address> <month> May </month> <year> 1995.* </year>
Reference-contexts: A novel approach to the verification of design transformations is discussed in Section 7. 2. Correctness Achieving correct designs is crucial in high-level synthesis and played the central role in the development of our methodology and design system TRADES <ref> [Mid94a, Mid94b, MMM95, Mid95] </ref>. We identify four major levels in the design of digital systems: requirements, specification, implementation, and realization. The system requirements capture the desired properties of a system informally , often in natural language. <p> Because of the size of both designs and design space, and the nature of the optimization problems (many are NP-hard), optimal solutions can in general not be guaranteed. We think, and early results confirm this <ref> [Mid94a, Mid94b, MMM95, Mid95] </ref>, that better, more efficient designs can be obtained by exploiting the exibility, creativity, and experience of the designer in an interactive design environment. As noted earlier, in real life a designer most often already has experience with a design or similar designs. <p> This requires a partial attening of the design. While area optimization was the primary objective in the Abs_Diff example, the methodology can also be applied to minimize power or increase speed which typically requires the use of time-space transformations <ref> [Mid94a, Mid94b, MMM95, Mid95] </ref>. The set of transformations required for fullscale trans - formational design is very large even though we have attempted to minimize this set by using generalized, primitive transformations. <p> The smallest gradient indicates the direction of the edge. In combination with linear interpolation of the luminance signal this is known as the edge-based line average (ELA) algorithm. A diagram of the direction detector is shown in Figure 9. A more detailed description can be found in <ref> [Mid94b, MMM95] </ref>. Our direc - tion detector was used in combination with an extended form of the ELA algorithm which first feeds the input signal P.F.A. Middelhoek & S.P.
Reference: [MMM96] <author> G.E. Mekenkamp, P.F.A. Middelhoek, E. Molenkamp, J. Hofstede, Th. Krol, </author> <title> A Syntax based VHDL to CDFG Translation Model for High-Level Synthesis, </title> <booktitle> Proc. of VHDL International Users Forum (VIUF), </booktitle> <address> Santa Clara, </address> <month> February 28, </month> <year> 1996.* </year>
Reference-contexts: Within TRADES we are therefore developing an alternative syntax-based approach to the translation of full VHDL (with the exception of the explicit time constructs AFTER and FOR) <ref> [MMH95, MMM96] </ref>. It requires only a P.F.A. Middelhoek & S.P. <p> Due to the syntax-based translation, the VHDL event mechanism appears in SIL and manifests itself as two nested loop levels, modeled in SIL by means of recursion. The inner loops model the continued execution of processes. The outer loop triggers computation if internal events occur (the delta mechanism) <ref> [MMH95, MMM96] </ref>. Loop and other transformations are used to remove this event mechanism. How this is done largely depends on the structure of the waitstatement in the original VHDL specification. For the IPS example the cleanup step was performed interactively.
Reference: [MuH95] <author> G. Musgrave, R.B. Hughes, </author> <title> Review of Verification Techniques, </title> <booktitle> Lecture notes NATO/ASI course on hardware software co - design, part II, </booktitle> <address> Tremezzo, Italy, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Formal verification validates the implementation with respect to the specification. A disadvantage of formal verification is that errors are caught only after the design stage. As a consequence there will still be a need for time - consuming debug cycles <ref> [MuH95] </ref>. [SFC94] for instance, uses post-verification techniques based on a geometric model to verify the application of loop trans formations. <p> The Lambda/Dialog system is an example of this latter approach. A more thorough overview of verification techniques including the Lambda system can be found in <ref> [MuH95] </ref> contains. In the third, transformation-based method, the design ow from specification to implementation consists of the consecutive application of preproven behavior-preserving transformations in a compositional design description. The use of preproven transformations removes the burden of verification from the chip designer. <p> Furthermore, due to the black-box nature of silicon compilation systems, tracing an error in the realization back to its origin can be rather difficult. We also feel that formal methods do not naturally appeal to chip designers <ref> [MuH95] </ref>. To overcome this the formal aspect of a design methodology should be presented to the designer in a convenient and easy to understand manner. The use of behavior-preserving transformations that have been proven correct by the tool designer provides this.
Reference: [OSR93] <author> S. Owre, N. Shankar and J.M. Rushby, </author> <title> User Guide for the PVS Specification and Verification System, Language, and Proof Checker (Beta Release) , Computer Science Laboratory, </title> <booktitle> SRI International, </booktitle> <address> Menlo Park, CA, USA,February, </address> <year> 1993. </year>
Reference-contexts: AND % We trigger the inputs of final graph with a refinement of the values of the initial graph silimp (par00,par0) AND silimp (par11,par1) IMPLIES % We show that the outputs of the initial and final graphs are refinements silimp (r2,r1) 7.5 Mechanization in PVS The Prototype Verification System (PVS) <ref> [OSR93] </ref> is an environme nt for spec ifying entities suc h a s hardware/software models and algorithms and verifying properties associated with the entities. An entity is usually specified by asserting a small number of known true general properties. These known properties are then used to derive other desired properties.
Reference: [Pen89] <author> Z. Peng, K. Kuchcinski, B. Lyles, CAMAD: </author> <title> A Unified Data Path/Control Synthesis Environment, </title> <booktitle> Design Methodologies for VLSI and Computer Architecture, </booktitle> <pages> pp. 53-67, </pages> <editor> ed. D.A. Edwards, </editor> <year> 1989. </year>
Reference-contexts: TRADES and HYPER are largely complementary. The automatic optimization algorithms developed for HYPER could be applied within TRADES while HYPER could benefit from our more powerful CDFG language, support for VHDL, and much larger set of preproven design transformations which guarantees correctness by construction. The CAMAD <ref> [Pen89, Pen94, HaP95] </ref> high-level synthesis system uses automatic transformations for scheduling and allocation. Algorithms written in Pascal or Behavioral VHDL used for specification are translated into an Extended Timed Petri Net representation in which data and control ow are separated.
Reference: [Pen94] <author> Z. Peng, K. Kuchcinski, </author> <title> Automated Transformation of Algorithms into Register-Transfer Level Implementations , IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, </title> <journal> Vol. </journal> <volume> 13, No. 2, </volume> <pages> pp. 150-166, </pages> <year> 1994. </year>
Reference-contexts: TRADES and HYPER are largely complementary. The automatic optimization algorithms developed for HYPER could be applied within TRADES while HYPER could benefit from our more powerful CDFG language, support for VHDL, and much larger set of preproven design transformations which guarantees correctness by construction. The CAMAD <ref> [Pen89, Pen94, HaP95] </ref> high-level synthesis system uses automatic transformations for scheduling and allocation. Algorithms written in Pascal or Behavioral VHDL used for specification are translated into an Extended Timed Petri Net representation in which data and control ow are separated.
Reference: [Pig89] <author> C. Piguet, </author> <title> Design Methodologies and CAD Tools, </title> <booktitle> Proc. of the CICC 89, </booktitle> <year> 1989. </year>
Reference-contexts: Efficiency of the results of these automatic tools is for many applications still insufficient. While this is improving it must come very close to good manual designs to be acceptable for mass production applications. This is often still not the case for anything other than benchmark examples. In <ref> [Pig89] </ref> it is reported that due to the use of design automation the transistor density normalized to minimum feature size has decreased significantly over the years, indicating less efficient use of silicon.
Reference: [Pot94] <author> M. Potkonjak, J. Rabaey, </author> <title> Optimizing Resource Utilization Using Transformations , IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, </title> <journal> vol. </journal> <volume> 13, no. 3, </volume> <month> March </month> <year> 1994. </year>
Reference-contexts: Furthermore the efficiency and real-time requirements are also very stringent compared to most software. Many (partially) transformation-based design systems exist or are under construction as part of larger projects. The HYPER system developed at the University of Berkeley <ref> [Bro92, Cha92, IPS93, Pot94] </ref> provides a set of transformations for automatic algorithmic-level design optimization. HYPER consists of transformations from the optimization, refinement, timespace assignment categories. The refinement transformations are however limited to strength reduction. Silage is used as specification language and translated to the HYPER CDFG [RaH90].
Reference: [Pre92] <author> R.S. Pressman, </author> <title> Software Engineering: a Practitioners Approach, </title> <editor> 3th ed., p. </editor> <volume> 107, </volume> <publisher> McGraw-Hill, Inc., </publisher> <address> NewYork, ISBN 0-07-112779-8, </address> <year> 1992. </year>
Reference-contexts: We call this approach, which is based on fixed application domain, target architecture pairs: a vertical approach to synthesis. It is, however, well known that for complex designs verification can take from 30% to 80% <ref> [Pre92] </ref> of the total design time.
Reference: [RaH90] <author> J. Rabaey, P. Hoang, </author> <title> HYPER Flowgraph Policy, </title> <type> Version 1.2, </type> <institution> Internal Document University of Berkeley, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: HYPER consists of transformations from the optimization, refinement, timespace assignment categories. The refinement transformations are however limited to strength reduction. Silage is used as specification language and translated to the HYPER CDFG <ref> [RaH90] </ref>. Repetition is modeled by means of iteration nodes. Conditional execution is emulated through multiplexer-like constructs. Within HYPER many automatic optimization scripts have been developed successfully for different purposes, including optimizing resource utiliza tion, critical path and power reduction, and to improve testability.
Reference: [Raj95a] <author> S.P. Rajan, </author> <title> Correctness of Transformations in High Level Synthesis, </title> <booktitle> Accepted for the Proc. of the IFIP International Conference on CHDL, Chiba, </booktitle> <address> Japan, </address> <month> August </month> <year> 1995. </year>
Reference: [Raj95b] <author> S.P. Rajan, </author> <title> Transformations on Dependency Graphs: Formal Specification and Efficient Mechanical Verification, </title> <type> PhD Thesis, </type> <institution> Department of Computer Science, University of British Columbia, Vancouver, Canada, </institution> <month> Oktober </month> <year> 1995. </year>
Reference-contexts: If every g' i is a refinement of g i , then G' is a refinement of G. i.e., (" i: refines (g' i , g i )) fi refines (G', G) The proof follows by induction on graph structure. A detailed proof is given in a doctoral thesis <ref> [Raj95b] </ref>. 7.4 .Verification of Transformations The general method we employ to specify and verify trans - formations consists of the following steps: 1. Specify the structure of a SIL graph, i.e. the transforma - tion domain, on which the transformation is to be applied.
Reference: [Ros 90] <author> Lars Rossen, </author> <title> Formal Ruby, Formal Methods for VLSI Design, </title> <editor> J. Staunstrup (ed.), </editor> <publisher> North-Holland, IFIP 1990. </publisher>
Reference: [RSS95] <author> S.P. Rajan, N. Shankar, </author> <title> M.K. </title> <booktitle> Srivas, An Integration of Model-Checking with Automated Proof Checking , Lecture Notes in Computer Science, </booktitle> <volume> Volume 939, </volume> <pages> pp. 84-97, </pages> <editor> editor P. Wolper, </editor> <publisher> Springer-Verlag, Liege, </publisher> <address> Belgium, </address> <year> 1995. </year>
Reference-contexts: The checking is done by comparing the specified properties of the entities. For example, one can compare if a register-transfer level imple mentation of hardware satisfies the properties expressed by its high-level specification. PVS has been used for reasoning in many domains, such as in hardware verification <ref> [Cyr93, CRS94, RSS95] </ref>, protocol verification, and algorithm verification [LOR93]. We have specified and verified transformations such as copy propagation, constant propagation, common subexpres-sion insertion, commutativity, associativity, distributivity, and strength reduction described by Engelen and others [EMH93] in PVS.
Reference: [Sam93] <author> H. Samsom, L. Claesen, H. De Man, SynGuide: </author> <title> An Environment for Doing Interactive Correctness Preserving Transformations, </title> <booktitle> Proc. of VLSI Signal Processing VI, </booktitle> <pages> pp. 269-277, </pages> <editor> Eds. L.D.J. Eggermont, P. Dewilde, E. Deprettere and J. van Meerbergen, IEEE, </editor> <year> 1993. </year>
Reference-contexts: For the optimization of specifications which use multi - dimensional signals, such as those from the video and image processing domains, SynGuide <ref> [Sam93, Sam95] </ref> has been developed at IMEC, Belgium. The tool provides (affine) transformations on loops with manifest (i.e. data-independent) bounds. Transformations are performed on Silage and can be used in both an interactive and automatic mode using the memory optimization tool MASAI [FNS94, SFC94].
Reference: [Sam95] <author> H. Samsom, </author> <title> Formal Verification and Transformation of Video and Image Specifications , PhD Thesis, </title> <institution> IMEC/University of Leuven, </institution> <year> 1995. </year>
Reference-contexts: This is especially so if the specification is written by an experienced designer. Furthermore, preserving the original implementation suggestion makes the design process more transparent to the designer, which is essential in a user centered methodology. In <ref> [Sam95] </ref> support for our view of the implementation suggestion can be found. Since specification and implementation should by definition exhibit equivalent behavior (a refinement in behavior could be allowed, see also Section 7.2), adding or changing the implementation suggestion of a specification is the sole purpose of synthesis. <p> At first sight it may seem that some transformations, such as partitioning, are global, but this is not the case. While the decision about where to partition is a global problem the partitioning itself can be done by many small local steps. The same is true for scheduling. In <ref> [Sam95] </ref> it is claimed that loop transformations cannot be tackled with this approach, but as we have shown in [Mid96] loop transformations discussed in [Sam95] can in fact be decomposed into smaller transformation steps. <p> The same is true for scheduling. In <ref> [Sam95] </ref> it is claimed that loop transformations cannot be tackled with this approach, but as we have shown in [Mid96] loop transformations discussed in [Sam95] can in fact be decomposed into smaller transformation steps. <p> For the optimization of specifications which use multi - dimensional signals, such as those from the video and image processing domains, SynGuide <ref> [Sam93, Sam95] </ref> has been developed at IMEC, Belgium. The tool provides (affine) transformations on loops with manifest (i.e. data-independent) bounds. Transformations are performed on Silage and can be used in both an interactive and automatic mode using the memory optimization tool MASAI [FNS94, SFC94].
Reference: [SaR92] <author> Z. Sahraoui, L. Rijnders, </author> <title> Report on the DIRDET Experiments , internal report IMEC, </title> <year> 1992. </year>
Reference-contexts: In a previous custom implementation the direction detector accounted for 40% of the size of the data path while the field and line memory consumed the most chip area. The example has been studied extensively both at Philips Research [LMW91] and IMEC <ref> [SaR92] </ref> as part of the ESPRIT/SPRITE pro ject and both a prototype and custom implementations have been developed. This allows us to compare our results with respect to efficiency and exibility with those obtained previously using different methodologies and tools. <p> The latter would be difficult to notate correctly without the use of behavior-preserving transforma - tions because the design is less intuitive and certainly less comprehensible than the high-level VHDL specification. The implementation derived from the structural specification required 13 pipeline stages to reach the 27 MHz throughput requirement. <ref> [SaR92] </ref> claims that the optimized structural specification resulted in a speed gain of 25%. We noted however that it did not seem very likely that transfor - mations based on stuck-at detection (i.e. constant signal detection) could result in any speed gain other than that obtained because of fanout reduction. <p> It seemed more likely that the reported gain was due to the inability of the timing tools to calculate data-dependent crit ical paths. That this is indeed the case has been confirmed by the authors of <ref> [SaR92] </ref>. Different optimizations used at IMEC resulted in a speed increase of up to 41% at the expense of area. Delay estimation using a carry-ripple model indicates a speed gain close to 50% for the implementation obtained using TRADES.
Reference: [SFC94] <author> H. Samsom, F. Franssen, F. Catthoor, H. de Man, </author> <title> Verification of Loop Transformations for Real Time Signal Processing Applications, </title> <booktitle> Proc. of VLSI Signal Processing VII, IEEE, </booktitle> <year> 1994. </year>
Reference-contexts: Formal verification validates the implementation with respect to the specification. A disadvantage of formal verification is that errors are caught only after the design stage. As a consequence there will still be a need for time - consuming debug cycles [MuH95]. <ref> [SFC94] </ref> for instance, uses post-verification techniques based on a geometric model to verify the application of loop trans formations. <p> The tool provides (affine) transformations on loops with manifest (i.e. data-independent) bounds. Transformations are performed on Silage and can be used in both an interactive and automatic mode using the memory optimization tool MASAI <ref> [FNS94, SFC94] </ref>. A geometry-based verification model has been developed for automatic post-verification of the design after applying loop transformations. SynGuide is very applicationspecific compared to TRADES and used post - verification, but it shares our philosophy on the implementation suggestion and interactive design. <p> That formal verification of transformations is not a luxury has been shown in [Raj95ab] and [MCF93]. Furthermore most of these systems employ an automated approach to the application and selection of transformations. To facilitate this they limit the application domain to for instance data path [Jan94] or memory optimization <ref> [SFC94] </ref>. Although such approaches have proven to be useful in many cases (examples include memory reduc tion, optimizing resource utiliza tion, critical path and power reduction, and to improve testability, and scheduling, allocation), we found that they are too limited for fullscale transformational design.
Reference: [She90] <author> G. Jones and M. Sheeran, </author> <title> Circuit Design in Ruby, Formal Methods for VLSI Design , J. </title> <editor> Staunstrup (ed.), </editor> <publisher> North-Holland, IFIP 1990. </publisher>
Reference-contexts: A formal system using transformations for hard - ware synthesis has been discussed by Fourman [Fou90]. A synthesis system for a language based on an algebraic formalism has been presented by Jones and Sheeran <ref> [She90] </ref>, and its formalization has been presented by Rossen [Ros90]. Another algebraic approach to transformational design of hardware has been worked out by Johnson [Joh84]. Correctness of register-transfer level transformations for scheduling and allocation has been dealt with in [Vem90].
Reference: [SOR93] <author> N. Shankar and S. Owre and J.M. Rushby, </author> <title> The PVS Proof Checker: A Reference Manual (Beta Release), </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> Februari </month> <year> 1993. </year>
Reference-contexts: The PVS specification language allows us to specify the proper - ties using a convenient level of abstraction. The PVS verifier features automatic procedures and interactive infer - ence rules to check properties of specifications. The infer - ence rules are based on higher-order logic <ref> [SOR93] </ref>. The rest of the section is organized as follows. We discuss related work in Section 7.1. We provide a formal characterization for SIL, and a verification scheme for transformations in Section 7.2.
Reference: [StP94] <author> E. Stoy, Z. Peng, </author> <title> A Design Representation for Hardware/Software CoSynthesis, </title> <booktitle> Proc. of IEEE Euromicro 1994, </booktitle> <pages> pp. 192-199, </pages> <address> Liverpool, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: In comparison with TRADES this system is automatic and only supports a very small part of the design path from high-level specification to efficient implementation. For hardware/software codesign the ETPN representation is partitioned in a hardware and software part <ref> [StP94] </ref>. The hardware part is synthesized using CAMAD while C compilers are used for software synthesis. However, for many applications (e.g. DSP based systems) where codesign techniques are useful the quality of code produced by Ccompilers is not nearly sufficient.
Reference: [TDW88] <author> D. Thomas, E.M. Dirkes, R.A. Walker, J.V. Rajan, J.A. Nestor and R.L. Blackburn, </author> <title> The System Architect's Workbench, </title> <booktitle> Proc. of the 25th ACM/IEEE Design Automation Conference, </booktitle> <pages> pp. 337-343, </pages> <year> 1988. </year>
Reference-contexts: Each transformation adds a module to the current partial (initially empty) implementation. A transformation is correct if there exists a remainder that when combined with the new partial implementation implements the specification. This approach is completely different from TRADES. The System Architects Workbench <ref> [TDW88, WaT89] </ref> uses the Value Trace CDFG as design representation. For specification, the Instruction Set Processor Specification (ISPS) language is used. Transformations supported include hierarchy introduction, expansion, constant propagation, loop unrolling, and common subexpression elimination. Interactively used transformations on the control ow are discussed in [WaT89].
Reference: [TLG93] <author> W.D. Tiedeman, S. Lenk, C. Grobe and W. Grass, </author> <title> Introducing Structure into Behavioral Descriptions obtained from Timing Diagram Specifications, </title> <booktitle> Proc. of IEEE Euromicro 93, </booktitle> <address> Barcelona, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: While the architectural model is very simple the work is interesting because it addresses the completeness problem of a set of design transformations as discussed in Section 5.4. As part of the Format project <ref> [TLG93] </ref> behavior - preserving transformations are used to synthesize behavioral specifications of communication-dominated hardware into structural VHDL. Specifications are defined by means of timing diagrams which are translated to T-LOTOS. An interactive bottom-up transformational approach is used. Each transformation adds a module to the current partial (initially empty) implementation.
Reference: [Vem90] <author> R.Vemuri, </author> <title> How to Proof the Completeness of a Set of Register Level Design Transformations, </title> <booktitle> Proc. of the 27th DAC, </booktitle> <pages> pp. 207-212, </pages> <address> ACM/IEEE, </address> <month> June </month> <year> 1990. </year> <note> P.F.A. Middelhoek & S.P. Rajan February 14, 1996 19 </note>
Reference-contexts: A set of primitive transformations is said to be complete if for all pairs of behaviorally equivalent designs in the design space, there exists a valid sequence of primitive transformations between them. In general there will be more than one set of transformations that satisfies this property. In <ref> [Vem90] </ref> a method for proving the completeness of a set of 18 RTL design transformations for the Single Architectural Register Transfer model is presented. Unfortunately this repre - sentation model is very simple compared to SIL and uses only structural transformations. <p> The tool only provides a very small number of transformations and uses simulation to determine correctness. A complete set of transformations is defined for a class of RT-level designs called Single Architectural Register Transfer designs <ref> [Vem90] </ref>. This work is limited to structural transformations (basically scheduling and allocation) which can be used as basis for an interactive design exploration tool. <p> Another algebraic approach to transformational design of hardware has been worked out by Johnson [Joh84]. Correctness of register-transfer level transformations for scheduling and allocation has been dealt with in <ref> [Vem90] </ref>. A formal analysis of transformations used in Systems Architects Workbench (SAW) high-level synthesis was studied by McFarland [McF93]. Transformations used in YIF (Yorktown Internal Form) [BCD88] have been proved to be behavior-preserving [Cam89].
Reference: [VHD88] <author> The Institute of Electrical and Electronics Engineers, </author> <title> IEEE Standard VHDL Language Reference Manual, </title> <journal> IEEE std. </journal> <pages> 1076-88, </pages> <publisher> IEEE Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Distributivity Correctness in design deals with maintaining consis - tency between these levels. Figure 1 illustrates this for a top-down design methodology. The specification is usually written in HDLs such as VHDL <ref> [VHD88] </ref> or Silage [Hil85]. The only practical way to validate the behavior of a specification against the user requirements is through the execution of the specification (i.e. simulation) using a test suite as input. This process cannot guarantee correctness because it is not exhaustive.
Reference: [WaC95] <author> R.A. Walker, A. Chaudhura, </author> <title> Introduction to the Scheduling Problem, </title> <booktitle> IEEE Design and Test of Computers, </booktitle> <month> Summer </month> <year> 1995. </year>
Reference-contexts: In this paper we take a broad view on high-level synthesis of synchronous digital systems and define it to include what some call algorithmic or architectural synthesis. This in contrast to <ref> [WaC95] </ref> which limits high-level synthesis to the scheduling, allocation, and binding problem. The design time of a system consists of the time required for synthesis and achieving correctness [HLD90]. <p> The struc - ture of the algorithm in time and space can be altered by means of retiming, multi-rate, loop, and scheduling transfor - mations. Traditionally most emphasis in high-level synthesis has been on scheduling and allocation steps <ref> [Gaj94, WaC95] </ref>. An overview of transformations used in TRADES can be found in [EMH93]. tail merging transformation is used to merge identical opera - tions in two mutually exclusive data paths, like the ones generated in the translation of if-then-else constructs.
Reference: [WaT89] <author> R.A. Walker, D.E. Thomas, </author> <title> Behavioral Transformation for Algorithmic Level IC Design, </title> <journal> IEEE Trans. on CAD, </journal> <volume> Vol. 8, No.10, </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: Each transformation adds a module to the current partial (initially empty) implementation. A transformation is correct if there exists a remainder that when combined with the new partial implementation implements the specification. This approach is completely different from TRADES. The System Architects Workbench <ref> [TDW88, WaT89] </ref> uses the Value Trace CDFG as design representation. For specification, the Instruction Set Processor Specification (ISPS) language is used. Transformations supported include hierarchy introduction, expansion, constant propagation, loop unrolling, and common subexpression elimination. Interactively used transformations on the control ow are discussed in [WaT89]. <p> The System Architects Workbench [TDW88, WaT89] uses the Value Trace CDFG as design representation. For specification, the Instruction Set Processor Specification (ISPS) language is used. Transformations supported include hierarchy introduction, expansion, constant propagation, loop unrolling, and common subexpression elimination. Interactively used transformations on the control ow are discussed in <ref> [WaT89] </ref>. In [MCF93] correctness of transformations in the System Architects Workbench is investigated. Several errors were found, often related to incorrect use of bit array data types. The Yorktown Silicon Compiler-based [BCD88] system [Cam89] emphasizes transformations to improve scheduling and allocation. The computations and control structure are not changed.
Reference: [WBM90] <author> R. Woudsma, F. Beenker, J. van Meerbergen, C. Niessen, Piramid: </author> <title> an Architecture-Driven Silicon Compiler for Complex DSP Applications, </title> <booktitle> Proc. of IEEE International Symposium on Circuits and Systems, </booktitle> <pages> pp. 2696-2700, </pages> <year> 1990. </year> * <note> available at http://wwwspa.cs.utwente.nl/aid/trades/ </note>
Reference-contexts: For TRADES the above considerations resulted in a combination of formally verified, designerselected, pre-proven behavior-preserving transformations and a CDFG as design representation. This approach is known as transfor - mational design and illustrated in Figure 3. 4.3. Existing Solutions Existing silicon compilers (e.g. Cathedral Compilers [DeM86], Piramid <ref> [WBM90] </ref>, and the commercial version DSP Station by Mentor Graphics, Phideo [LMW91], Hyper (-LP) [CPM95]) are specialized towards specific application and target domains. <p> An overview of data ow languages and their semantics can be found in [LeP95]. The best known CDFG variants in high-level synthesis are those derived from the applicative language Silage [Hil85]. They are, for instance, used in the Cathedral [DeM86], Piramid <ref> [WBM90] </ref>, and as DFL in the commercial DSP Station tools.
References-found: 78

