URL: ftp://ftp.eecs.umich.edu/groups/gasm/wam.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.eecs.umich.edu
Title: CHAPTER 1 The WAM|Definition and Compiler Correctness  
Author: Egon Borger Dean Rosenzweig 
Keyword: LOGIC PROGRAMMING: FORMAL METHODS AND PRACTICAL APPLICATIONS  
Note: Edited by C. Beierle and L. Plumer c 1994 Elsevier Science Publishers B.V. All rights reserved  
Address: Pisa, Cso Italia 40, I-56100 Pisa  Zagreb, Salajeva 5, 41000 Zagreb, Croatia  
Affiliation: Dipartimento di Informatica, Universita di  FSB, University of  
Abstract: Contents Introduction : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 3 Evolving Algebras : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 6 1. Prolog|Tree and Stack Models : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 9 1.1. Prolog Tree : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 9 1.2. From Tree to Stack : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 16 1.3. Reusing Choicepoints : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 20 2. Predicate Structure : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 22 2.1. Determinacy Detection (look-ahead optimization) : : : : : : : : : : : : : : : : : : : : : : : 23 2.2. Compilation of Predicate Structure : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 24 2.3. Switching : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 27 3. Clause Structure : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 29 3.1. Sharing the Continuation Stack : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 29 3.2. Compilation of Clause Structure : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 33 4. Term Structure : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 37 4.1. Representing Terms|Compilation of Term Structure : : : : : : : : : : : : : : : : : : : : 37 4.2. Prolog with Term Representation : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 48 4.3. The WAM : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 57 References : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 62 Appendix 1. Rules for Prolog tree model : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 64 Appendix 2. Rules for Compiled Predicate Structure : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 65 Appendix 3. Rules for Compiled Clause Structure : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 67 Appendix 4. Rules for the WAM : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 68 
Abstract-found: 1
Intro-found: 1
Reference: [Ait-Kaci 91] <author> Ait-Kaci, H. </author> <title> Warren's Abstract Machine. A Tutorial Reconstruction. </title> <publisher> MIT Press 1991. </publisher>
Reference-contexts: The proof provides a clear scheme to such designers for proving their WAM to be correct, without need for extensive testing of all components, including the well known ones. We feel that the mathematical beauty of the WAM gets revealed in the process. We join <ref> [Ait-Kaci 91] </ref> in saying, from a different context, that ...this understanding can make one appreciate all the more David H.D.Warren's feat, as he conceived this architecture in his mind as one whole. <p> All we assume of the reader is general understanding of Prolog as a programming language. Although the paper is technically self-contained, familiarity with the WAM might help. For extended discussion of basic concepts of the WAM we refer the reader to <ref> [Ait-Kaci 91] </ref>. For more background on evolving algebra methodology the reader is referred to [Gurevich 91]. There have been other attempts at analysis and correctness proof of the WAM in the literature. The book [Ait-Kaci 91] provides a penetrating but informal tutorial analysis, without any pretension to proof, proceeding by elaborating <p> For extended discussion of basic concepts of the WAM we refer the reader to <ref> [Ait-Kaci 91] </ref>. For more background on evolving algebra methodology the reader is referred to [Gurevich 91]. There have been other attempts at analysis and correctness proof of the WAM in the literature. The book [Ait-Kaci 91] provides a penetrating but informal tutorial analysis, without any pretension to proof, proceeding by elaborating successive partial Prologs at the same level of abstraction (unlike our successive partial elaborations of full Prolog). [Russinoff 92] proves correctness of a partial (simplified) WAM wrt a form of SLD-resolution, relying on ad <p> Since it is largely independent of the exact way how the structure of Prolog clauses and terms is compiled, we may, for the time being, abstract the latter away, assuming that CODEAREA stores indexing instructions <ref> [Warren 83, Ait-Kaci 91] </ref> interspersed with proper clauses. The resulting model may be seen as elaborating only the disjunctive, predicate structure of a Prolog program, providing thus a splendid example of freedom, inherent to the evolving algebra approach, of fine-tuning the level of abstraction to the problem at hand. <p> We thus allow for switching |see next section, and <ref> [Warren 83, Ait-Kaci 91] </ref>| but do not assume any specific indexing method. A preferred method may be thought of as being abstractly encoded by the function procdef . <p> These remarks should suffice to establish Proposition 2.2. The model of 2.2. is, given Compiler Assumption 1 and WAM Assumption 1, correct and complete wrt that of 2.1. 2.3. Switching We have so far allowed for indexing <ref> [Warren 83, Ait-Kaci 91] </ref> encapsulating it in the procdef function, which in a magical, i.e. abstract way finds a proper chain (see Compiler Assumption 1). Here we introduce the switching instructions [Warren 83, Ait-Kaci 91], permitting the compiler to arrange for a concrete indexing scheme, without however comitting ourselves (i.e. our <p> Switching We have so far allowed for indexing <ref> [Warren 83, Ait-Kaci 91] </ref> encapsulating it in the procdef function, which in a magical, i.e. abstract way finds a proper chain (see Compiler Assumption 1). Here we introduce the switching instructions [Warren 83, Ait-Kaci 91], permitting the compiler to arrange for a concrete indexing scheme, without however comitting ourselves (i.e. our correctness proof for the WAM) to any specific one. <p> Of other rules in the sequel, `running the main program', we shall tacitly assume to contain the guard OK & what to do = Run. In view of WAM Assumption 2, it is straightforward to recognize the above as a deterministic variant of Herbrand's algorithm <ref> [Apt 90, Ait-Kaci 91] </ref>|thus Unification Lemma. <p> A compiler could then be clever with variable numbering and trim the environment on the fly by generating a decreasing sequence of environment sizes (in third arguments of call instructions, cf. <ref> [Ait-Kaci 91] </ref>. According to [Warren 83], `: : : variables are arranged in their environment in such a way that they can be discarded as soon as they are no longer needed .' (our italics). <p> Corresponding occurences of Y n in the clause are termed unsafe <ref> [Warren 83, Ait-Kaci 91] </ref>. The first of the two conditions amounts to Y n occurring in an argument position of a body goal in which it is no more needed. <p> In Example 11, for instance, X is temporary while Y is permanent. Note however that our definition is parameterized by the notion of being needed , which we are going to optimize in 4.3.2, making the above equivalent to Warren's full definition. <ref> [Ait-Kaci 91] </ref> has also attempted to derive Warren's original definition by optimizing the more naive notion above, but notions of environment trimming and unsafe variables are not adapted smoothly, what has later to be patched up by a notion of `delayed trimming' (see the discussion in op.cit. section 5.9). <p> note that get variable (x i ; x i ) and put value (x i ; x i ) have the effect of succeed , permitting the compiler to be clever about numbering of temporary variables, confusing them with proper argument registers in order to minimize data movement (`peep-hole optimization', <ref> [Ait-Kaci 91] </ref>). In case of a fact or a chain rule there will be no permanent variables, and allocate would just store cp on the stack. <p> It would however be wasteful to allocate a cutpt in every environment, regardless of whether a cut could be executed within the corresponding clause body at all. A usual decision <ref> [Ait-Kaci 91] </ref> is to allocate a cutpt only when it could be needed, i.e. when the corresponding body could contain a cut 11 .
Reference: [Apt 90] <author> Apt, C. </author> <title> Logic Programing. </title> <editor> In: J.van Leeuwen (ed.), </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <publisher> Elsevier, </publisher> <address> Vol.B, </address> <year> 1990, </year> <pages> 493-574 </pages>
Reference-contexts: of substitutions, coming together with an abstract unification function unify : TERM fi T ERM ! SU BST [ fnil g associating to two terms either their unifying substitution or the answer that there is none 1 ; for application and composition of substitutions we use the usual notation of <ref> [Apt 90] </ref>. We represent renaming of variables abstractly, without going into details of term and variable representation, by introducing a function rename : TERM fi N ! TERM renaming all variables in the given term at the given index (renaming level). <p> The classification of nodes suggests connections both to SLD-tree <ref> [Apt 90, Lloyd 84] </ref> and to stack models of Prolog, to be elaborated in subsequent sections. In [BoeRos 93] its correctness wrt SLD-resolution was established. 1.2. <p> The mathematical (nondeterministic) unification algorithm <ref> [Apt 90, Lloyd 84] </ref> should fail on attempt to bind a variable to a term in which it occurs|unification is then said to be STO (subject to occur-check ). <p> Of other rules in the sequel, `running the main program', we shall tacitly assume to contain the guard OK & what to do = Run. In view of WAM Assumption 2, it is straightforward to recognize the above as a deterministic variant of Herbrand's algorithm <ref> [Apt 90, Ait-Kaci 91] </ref>|thus Unification Lemma.
Reference: [BeiBoe 92] <author> Beierle, C. & Borger, E. </author> <title> Correctness proof for the WAM with types. </title> <booktitle> In: Computer Science Logic 91. </booktitle> <editor> (Eds. E.Borger, G.Jager, H.Kleine-Buning,M.Richter), </editor> <publisher> Springer LNCS 626 , 1992, </publisher> <pages> pp. 15-34 </pages>
Reference-contexts: It simplified a lot to deal with the or-structure before the and-structure, and to base the or-structure treatment on trees instead of stacks. Semantics and implementation of dynamic code and database operations have been analyzed in [BoeRos 91b], by extending some of the models used here. The work of <ref> [BeiBoe 92] </ref> on Protos-L, a Prolog with types, and [Salamone 93] on constraint propagation language CLP (R), where the construction and the proofs were smoothly ported to the `PAM' [BeiBoe 92] and the `CLAM' [Salamone 93], confirms the conjecture from [Boerger,Rosenzweig 91a], that `: : : our explication should essentially apply <p> The work of <ref> [BeiBoe 92] </ref> on Protos-L, a Prolog with types, and [Salamone 93] on constraint propagation language CLP (R), where the construction and the proofs were smoothly ported to the `PAM' [BeiBoe 92] and the `CLAM' [Salamone 93], confirms the conjecture from [Boerger,Rosenzweig 91a], that `: : : our explication should essentially apply to WAM-based implementation of other logic languages with the same and-or structure as Prolog.' Acknowledgements.
Reference: [Boerger 90a] <author> Borger, E. </author> <title> A logical operational semantics of full Prolog: Part 1. Selection core and control. </title> <booktitle> In: CSL '89, 3rd Workshop on Computer Science Logic (Eds. </booktitle> <address> E.Borger, H.Kleine-Buning,M.Richter), </address> <publisher> Springer LNCS 440, </publisher> <year> 1990, </year> <pages> pp. 36-64 </pages>
Reference-contexts: We thus start from scratch. In the same section we refine to a stack model (to the very same stack model on which the meaning of database operations was analyzed in [BoeRos 91b], elaborating on the stack model of <ref> [Boerger 90a] </ref>). A stack model may be viewed as linear layout of Prolog tree traversal into `computer memory' which brings us closer to the implementation view of the WAM. Section 2 provides a complete account of WAM clause selection, i.e. representation of predicate structure.
Reference: [Boerger 90b] <author> Borger, E. </author> <title> A logical operational semantics of full Prolog: Part 2. Built-in predicates for database manipulations. In: MFCS '90 (Ed. </title> <publisher> B.Rovan, Springer LNCS 452, </publisher> <year> 1990, </year> <pages> pp. 1-14 </pages>
Reference: [BoeRos 91a] <author> Borger, E. & Rosenzweig D. </author> <title> From Prolog Algebras Towards WAM|A Mathematical Study of Implementation. </title> <booktitle> In: CSL '90, 4th Workshop on Computer Science Logic (Eds. </booktitle> <address> E.Borger, H.Kleine-Buning,M.Richter,W.Schonfeld), </address> <publisher> Springer LNCS 533, </publisher> <year> 1991, </year> <pages> pp. 31-66 </pages>
Reference: [BoeRos 91b] <author> Borger, E. & Rosenzweig D. </author> <title> An Analysis of Prolog Database Views and Their Uniform Implementation CSE-TR-88-91, </title> <institution> University of Michigan, Ann Arbor, Michigan, </institution> <year> 1991. </year>
Reference-contexts: We thus start from scratch. In the same section we refine to a stack model (to the very same stack model on which the meaning of database operations was analyzed in <ref> [BoeRos 91b] </ref>, elaborating on the stack model of [Boerger 90a]). A stack model may be viewed as linear layout of Prolog tree traversal into `computer memory' which brings us closer to the implementation view of the WAM. <p> It simplified a lot to deal with the or-structure before the and-structure, and to base the or-structure treatment on trees instead of stacks. Semantics and implementation of dynamic code and database operations have been analyzed in <ref> [BoeRos 91b] </ref>, by extending some of the models used here.
Reference: [BoeRos 91c] <author> Borger, E. & Rosenzweig D. </author> <title> WAM Algebras|A Mathematical Study of Implementation, Part 2. In: Logic Programming (Ed. </title> <editor> A. Voronkov). </editor> <publisher> Springer LNCS 592, </publisher> <year> 1991, </year> <month> pp.35-54 </month>
Reference: [BoeRos 93] <author> Borger, E. & Rosenzweig D. </author> <title> A Mathematical Definition of Full Prolog, </title> <note> to appear in The Science of Computer Programming (also appeared as Technical Report TR-33/92, </note> <institution> Dipartimento di Informatica, Universita di Pisa 1992) </institution>
Reference-contexts: It is easily shown to be correct wrt SLD-resolution (for pure Prolog programs), and has been extended to a transparent yet rigorous formulation of the full language <ref> [BoeRos 93] </ref>, although we restrict it here to pure Prolog with cut . We thus start from scratch. <p> This mathematical model captures the usual intuitive operational understanding of Prolog, what justifies its use as basis for our correctness proof. It is also close to SLD-resolution proof trees, (and allows a simple correctness proof with respect to the latter, for pure Prolog programs, <ref> [BoeRos 93] </ref>). We then show how to lay out these trees linearly, thus transforming the tree into a stack model which is closer to what is needed for a mathematical analysis of the stack based WAM. 1.1. <p> The model could be extended to cover various built-in predicates and language constructs simply by adding appropriate rules, like in <ref> [BoeRos 93] </ref>. The reader might have noticed that the guards for rules goal success, cut, true, fail never mention mode. <p> The classification of nodes suggests connections both to SLD-tree [Apt 90, Lloyd 84] and to stack models of Prolog, to be elaborated in subsequent sections. In <ref> [BoeRos 93] </ref> its correctness wrt SLD-resolution was established. 1.2. <p> Corollary. The full WAM is, given WAM Assumptions 1-5 and Compiler Assumptions 1-11, correct, for pure Prolog programs, wrt SLD-resolution constrained to non-STO unification. The Corollary follows immediately, given the Prolog Tree Theorem of <ref> [BoeRos 93] </ref>. 12 When a cut variable is not allocated, cutpt (e) is not used in the model of section 3 anyway, except for a neck cut, for which ct suffices. 62 E. Borger, D. Rosenzweig
Reference: [GlaRos 93] <author> Glavan, P. & Rosenzweig, D. </author> <title> Communicating Evolving Algebras, </title> <booktitle> in: Computer Science Logic, Selected Papers from CSL'92, </booktitle> <editor> (E.Borger, G.Jager, H. Kleine Buning, S.Martini, M.M.Richter eds.) </editor> <publisher> Springer LNCS 702, </publisher> <pages> pp. 182-215 </pages>
Reference-contexts: It is the straightjacket of fixed abstraction level, and the induced combinatorial explosion of formalism and/or mathematics, which usually makes semantical investigation of real situations so difficult. The method of evolving algebras of [Gurevich 88,91], see also <ref> [GlaRos 93] </ref>, that we have adopted (here and in [Boerger,Rosenzweig 91a-d,93], continuing the work in [Boerger 90a,90b]), allows precisely the kind of fine-tuning of abstraction level to the problem at hand, and natural modelling of dynamics at all levels, that is required here. <p> Simultaneous execution helps us avoid fussing and coding to, say, interchange two values. Since functions may be partial, equality in the guards is to be interpreted in the sense of `partial algebras' [Wirsing 90], as implying that both arguments are defined (see also <ref> [GlaRos 93] </ref>). More precisely, Definition. An evolving algebra is given by a finite set of transition rules. The signature of a rule, or that of an evolving algebra, can always be reconstructed, as the set of function symbols occurring there. Definition. Let A be an evolving algebra. <p> We tacitly understand the notion of interpretation as validating any integrity constraints imposed. Our rules will always be constructed so that the guards imply consistency of updates, for discussion cf. <ref> [GlaRos 93] </ref>. While the effect of executing a rule in a static algebra is intuitively clear, it is given precisely by Definition. <p> may (and should) depend on t i 's, setting the values of some functions on newly created elements t i of A. [Gurevich 91] has however shown how to reduce such setups to the above basic model of a homogenous signature (with one universe) and function updates only (see also <ref> [GlaRos 93] </ref>). 8 E. Borger, D. Rosenzweig As Prolog is a sequential language, our rules are organized in such a way that at every moment at most one rule is applicable.
Reference: [Gurevich 88] <author> Gurevich,Y. </author> <title> Logic and the challenge of computer science. </title> <editor> in: E.Borger (Ed.), </editor> <booktitle> Trends in Theoretical Computer Science. </booktitle> <publisher> Computer Science Press, </publisher> <address> Rockville MA 1988, pp.1-57 </address>
Reference: [Gurevich 91] <author> Gurevich,Y. </author> <title> Evolving Algebras. A Tutorial Introduction. </title> <booktitle> in: Bulletin of the European Association for Theoretical Computer Science, </booktitle> <address> no.43, </address> <month> February </month> <year> 1991, </year> <pages> pp. 264-284 </pages>
Reference-contexts: Although the paper is technically self-contained, familiarity with the WAM might help. For extended discussion of basic concepts of the WAM we refer the reader to [Ait-Kaci 91]. For more background on evolving algebra methodology the reader is referred to <ref> [Gurevich 91] </ref>. There have been other attempts at analysis and correctness proof of the WAM in the literature. <p> Last not least, special thanks go to one of anonymous referees, for his very careful reading of the whole text and valuable detailed comments. Evolving Algebras All Prolog models, constructed in this paper by stepwise refinement, are evolving algebras, which is a notion introduced by <ref> [Gurevich 91] </ref>. Since this notion is a mathematically rigorous form of fundamental operational intuitions of computing, the paper can be followed without any particular theoretical prerequisites. The reader who is not interested in foundational issues, might read our rules as `pseudocode over abstract data'. <p> and shrink in time|update forms are provided to extend a universe: extend A by t 1 ; : : : ; t n with updates endextend where updates may (and should) depend on t i 's, setting the values of some functions on newly created elements t i of A. <ref> [Gurevich 91] </ref> has however shown how to reduce such setups to the above basic model of a homogenous signature (with one universe) and function updates only (see also [GlaRos 93]). 8 E. Borger, D. <p> We intend an update sequence to trigger sequential execution of update (i) (for i = 1; : : : ; n) so that the overall system does not attempt another rule application before update (n) has been executed. This construct, which does not appear in Gurevich's original definition in <ref> [Gurevich 91] </ref> is reducible to rules with function updates, as the reader might verify as an exercise.
Reference: [ISO WG17 93] <author> Prolog. </author> <title> Part 1, General core. </title> <note> Committee Draft ISO/IEC JTCI SC22 WG17 N.110, </note> <year> 1993. </year>
Reference-contexts: We choose however to allow for the usual practice of Prolog implementations, which, for pragmatic reasons, generally skip the occur check, and to adhere to the draft standard proposal <ref> [ISO WG17 93] </ref>, which refrains from specifying the behaviour of systems upon STO unification by considering it as `implementation dependent'. Hence we make no assumption whatsoever on STO binding.
Reference: [LinO'Ke 87] <author> Lindholm, T.G. & O'Keefe, R.A. </author> <title> Efficient Implementation of a Defensible Semantics for Dynamic Prolog Code. </title> <booktitle> In: Proceedings of the Fourth International Conference on Logic Programming, </booktitle> <pages> pp. </pages> <note> 21-39 The WAM|Definition and Compiler Correctness 63 </note>
Reference-contexts: Since recognizing the (potentially) current choicepoint as becoming silly amounts to detecting the current call to be determinate (i.e. to have no (more) alternative clauses), the look-ahead optimization is sometimes called `determinacy detection', eg. <ref> [LinO'Ke 87] </ref>. The reader might care to see, by simulating Example 1 on the current model, how creation of silly choicepoints is prevented. <p> It would be straightforward to set up, for sake of proof, an intermediate model with additional colored indexing instructions used only for handling internal choicepoints, coloring the latter as well as internal, not unlike internal dynamic else used, for other purposes, by <ref> [LinO'Ke 87] </ref>.
Reference: [Lloyd 84] <author> Lloyd, J.W. </author> <title> Foundations of Logic Programming, </title> <publisher> Springer, </publisher> <address> Berlin-Heidelberg-New York 1984. </address>
Reference-contexts: The classification of nodes suggests connections both to SLD-tree <ref> [Apt 90, Lloyd 84] </ref> and to stack models of Prolog, to be elaborated in subsequent sections. In [BoeRos 93] its correctness wrt SLD-resolution was established. 1.2. <p> The mathematical (nondeterministic) unification algorithm <ref> [Apt 90, Lloyd 84] </ref> should fail on attempt to bind a variable to a term in which it occurs|unification is then said to be STO (subject to occur-check ).
Reference: [Russinoff 92] <author> Rusinoff, </author> <title> M.D. A Verified Prolog Compiler for the Warren Abstract Machine, </title> <journal> Journal of Logic Programming 13(1992), </journal> <pages> 367-412. </pages>
Reference-contexts: The book [Ait-Kaci 91] provides a penetrating but informal tutorial analysis, without any pretension to proof, proceeding by elaborating successive partial Prologs at the same level of abstraction (unlike our successive partial elaborations of full Prolog). <ref> [Russinoff 92] </ref> proves correctness of a partial (simplified) WAM wrt a form of SLD-resolution, relying on ad hoc arithmetical encoding and a specific compiler.
Reference: [Salamone 93] <author> Salamone, R. </author> <title> An Abstract Modular Specification of the CLAM , Tesi di laurea, </title> <institution> Dipartimento di Informatica, Universita di Pisa 1993. </institution>
Reference-contexts: Semantics and implementation of dynamic code and database operations have been analyzed in [BoeRos 91b], by extending some of the models used here. The work of [BeiBoe 92] on Protos-L, a Prolog with types, and <ref> [Salamone 93] </ref> on constraint propagation language CLP (R), where the construction and the proofs were smoothly ported to the `PAM' [BeiBoe 92] and the `CLAM' [Salamone 93], confirms the conjecture from [Boerger,Rosenzweig 91a], that `: : : our explication should essentially apply to WAM-based implementation of other logic languages with the <p> The work of [BeiBoe 92] on Protos-L, a Prolog with types, and <ref> [Salamone 93] </ref> on constraint propagation language CLP (R), where the construction and the proofs were smoothly ported to the `PAM' [BeiBoe 92] and the `CLAM' [Salamone 93], confirms the conjecture from [Boerger,Rosenzweig 91a], that `: : : our explication should essentially apply to WAM-based implementation of other logic languages with the same and-or structure as Prolog.' Acknowledgements. We are indebted to Yuri Gurevich for permanent discussion on the whole evolving algebra framework.
Reference: [Warren 83] <author> Warren, D.H.D. </author> <title> An Abstract Prolog Instruction Set, </title> <note> Technical Note 309, Artificial Intelligence Center, SRI International 1983. </note>
Reference-contexts: It proceeds by stepwise refinement of Prolog models, starting from an abstract, phenomenological, programmer's model. The proof follows the analysis closely, and consists in a chain of local proofs, of (relative) correctness and completeness for each refinement step. The WAM, as described by <ref> [Warren 83] </ref>, resembles an intricate puzzle, whose many pieces fit tightly together in a miraculous way. We analayze the complex web of their interdependencies, attempting to isolate the orthogonal components along the following lines. <p> The notion of a variable being needed at a body goal turns out to be the crucial hidden concept which clarifies them all. We thus arrive at the full WAM of <ref> [Warren 83] </ref>, and at a proof of its correctness and completeness wrt Prolog trees (Main Theorem in 4.3). There was no need to prescribe a specific compiler|the cumulative assumptions, that we explicitly introduce along the way, provide a set of sufficient conditions for a compiler to be correct. <p> Since it is largely independent of the exact way how the structure of Prolog clauses and terms is compiled, we may, for the time being, abstract the latter away, assuming that CODEAREA stores indexing instructions <ref> [Warren 83, Ait-Kaci 91] </ref> interspersed with proper clauses. The resulting model may be seen as elaborating only the disjunctive, predicate structure of a Prolog program, providing thus a splendid example of freedom, inherent to the evolving algebra approach, of fine-tuning the level of abstraction to the problem at hand. <p> We thus allow for switching |see next section, and <ref> [Warren 83, Ait-Kaci 91] </ref>| but do not assume any specific indexing method. A preferred method may be thought of as being abstractly encoded by the function procdef . <p> These remarks should suffice to establish Proposition 2.2. The model of 2.2. is, given Compiler Assumption 1 and WAM Assumption 1, correct and complete wrt that of 2.1. 2.3. Switching We have so far allowed for indexing <ref> [Warren 83, Ait-Kaci 91] </ref> encapsulating it in the procdef function, which in a magical, i.e. abstract way finds a proper chain (see Compiler Assumption 1). Here we introduce the switching instructions [Warren 83, Ait-Kaci 91], permitting the compiler to arrange for a concrete indexing scheme, without however comitting ourselves (i.e. our <p> Switching We have so far allowed for indexing <ref> [Warren 83, Ait-Kaci 91] </ref> encapsulating it in the procdef function, which in a magical, i.e. abstract way finds a proper chain (see Compiler Assumption 1). Here we introduce the switching instructions [Warren 83, Ait-Kaci 91], permitting the compiler to arrange for a concrete indexing scheme, without however comitting ourselves (i.e. our correctness proof for the WAM) to any specific one. <p> To be completely formal, we have h (l) j l tr (l ) j l 1 p (l) j l 2 x i (l) j l 5 i hb j val (h (b)) Other layouts are of course possible, this is the original form of <ref> [Warren 83] </ref>. The indexing (choicepoint handling) instructions of section 2 (try me else j try, retry me else j retry, trust me j trust ) will now obtain an additional argument|the predicate arity n. <p> A compiler could then be clever with variable numbering and trim the environment on the fly by generating a decreasing sequence of environment sizes (in third arguments of call instructions, cf. [Ait-Kaci 91]. According to <ref> [Warren 83] </ref>, `: : : variables are arranged in their environment in such a way that they can be discarded as soon as they are no longer needed .' (our italics). <p> Corresponding occurences of Y n in the clause are termed unsafe <ref> [Warren 83, Ait-Kaci 91] </ref>. The first of the two conditions amounts to Y n occurring in an argument position of a body goal in which it is no more needed. <p> A variable which is not temporary is permanent . This may seem to be a weird way of saying that a temporary variable `does not occur in more than one goal in the body, counting the head of the clause as part of the first goal' <ref> [Warren 83] </ref>. In Example 11, for instance, X is temporary while Y is permanent. <p> A temporary variable is a variable that has its first occurrence in the head or in a structure or in the last goal, and that does not occur in more than one goal in the body, where the head of the clause is counted as part of the first goal. <ref> [Warren 83] </ref> Example 12.[Ait-Kaci 91] In the clause a : b (X; X); c: the variable X is by the latest definition permanent. <p> The above discussion may then be summed up as 60 E. Borger, D. Rosenzweig Classification Lemma. Warren's classification of variables and on the fly initialization preserve the Pure Prolog Theorem. We have arrived at the model expressing all aspects of <ref> [Warren 83] </ref>, which we then dare to call the full WAM .
Reference: [Wirsing 90] <author> Wirsing, M. </author> <title> Algebraic Specification, </title> <editor> in J. van Leeuwen (Ed.): </editor> <booktitle> Handbook of Theoretical Computer Science B, </booktitle> <publisher> Elsevier 1990, </publisher> <pages> pp. 675-788. </pages> <note> 64 E. </note> <editor> Borger, D. </editor> <publisher> Rosenzweig </publisher>
Reference-contexts: Simultaneous execution helps us avoid fussing and coding to, say, interchange two values. Since functions may be partial, equality in the guards is to be interpreted in the sense of `partial algebras' <ref> [Wirsing 90] </ref>, as implying that both arguments are defined (see also [GlaRos 93]). More precisely, Definition. An evolving algebra is given by a finite set of transition rules.
References-found: 19

