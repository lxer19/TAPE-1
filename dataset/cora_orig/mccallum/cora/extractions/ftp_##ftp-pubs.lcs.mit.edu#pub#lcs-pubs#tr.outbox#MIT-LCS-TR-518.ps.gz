URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-518.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr500.html
Root-URL: 
Title: The Real-Time Cost of Timing Uncertainty: Consensus and Failure Detection  
Author: by Stephen J. Ponzio Nancy A. Lynch Arthur C. Smith 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degrees of Bachelor of Science in Electrical Engineering and Master of Science in Electrical Engineering and Computer Science at the  All rights reserved. Signature of Author  Certified by  Thesis Supervisor Accepted by  Chairman, Departmental Committee on Graduate Students  
Date: May 1991  May, 1991  
Affiliation: Massachusetts Institute of Technology  c Massachusetts Institute of Technology, 1991.  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [ADLS90] <author> H. Attiya, C. Dwork, N. Lynch, and L. Stockmeyer. </author> <title> Bounds on the time to reach agreement in the presence of timing uncertainty. </title> <type> Report TM-435, </type> <institution> Laboratory for Computer Science, MIT, </institution> <month> November </month> <year> 1990. </year> <note> Also in STOC 1991. </note>
Reference-contexts: This simulation strategy is described in Section 3.1. Thus, upper bounds of approximately (f + 1)Cd are easily derived. For Byzantine failures, it is not clear how to simulate a synchronous algorithm correctly. In <ref> [ADLS90] </ref>, Attiya, Dwork, Lynch, and Stockmeyer prove nearly tight upper and lower bounds on the time to reach consensus in the presence of stopping failures. <p> Other problems recently studied in our model of timing uncertainty include the problem of mutual exclusion ([AL89]) and the complexity of a network synchronizer algorithm ([AM90]). 1.3 Results of this thesis 1.3.1 Consensus in the presence of omission failures In Chapter 3, we strengthen the algorithm of <ref> [ADLS90] </ref> to tolerate omission failures. The resulting algorithm has a running time of 4 (f +1)d+Cd for n 2f +1. This is approximately within a constant factor (4) of the lower bounds of (f + 1)d and (f 1)d + Cd ([ADLS90]) and minimizes the dependence on the timing uncertainty C. <p> According to the model of [AL89] and <ref> [ADLS90] </ref> (used in Chapter 3), every message sent by a process is delivered within time d of when it is sent, regardless of the rate at which messages are sent. In reality, if a link is flooded with messages, their delay may be much greater. <p> In reality, if a link is flooded with messages, their delay may be much greater. Our algorithm for omission failures and the algorithm of <ref> [ADLS90] </ref> ignore this consideration by requiring a process to send a message at every step it takes. This enables failures to be detected as quickly as possible, but is grossly inefficient in its use of messages. <p> We show that these bounds are nearly optimal by proving a lower bound of the lesser of 2Cd + d= and C 2 d= + Cd + d. 11 Chapter 2 Model and Definitions Our underlying formal model is essentially the same as that used in <ref> [ADLS90] </ref>. Our model differs by assuming for ease of presentation that all messages are delivered in the order sent and that processes begin executing the algorithm at the same time. <p> The former assumption is not used in our algorithm for Byzantine failures and is easily removed from our algorithm for omission failures by employing a more complicated protocol for receiving messages. The latter assumption is avoided in <ref> [ADLS90] </ref> by instead providing a special individual input event for each process, in which it receives its initial value for the consensus protocol. In measuring the time complexity of the algorithm, time is measured only from the earliest time that all processes have received an input. <p> Without this assumption, the problem is complicated by the need to determine when all processes have received inputs. Also, in addition to allowing stronger failures than <ref> [ADLS90] </ref>, we assume that processes know the number of failures, f , to be tolerated. 2.1 Formal model We consider a system of n processes 1; : : : ; n. Each process is a deterministic state machine with possibly an infinite number of states and a distinguished start state. <p> Note that the validity condition does not imply termination; termination is implied by the third condition. We consider the binary version of the problem, where the initial values are 0 or 1. Like the algorithm of <ref> [ADLS90] </ref>, our algorithm for omission failures can be extended to work for any value set, using the same extension given there ([ADLS90], Section 5.4). <p> The algorithm uses the same strategy as that of <ref> [ADLS90] </ref>; we first elucidate this strategy by describing a synchronous consensus algorithm upon which it is based and explaining our algorithm in terms of that synchronous algorithm. <p> Therefore a process may decide 0 if it has run for more than (f + 1)(d + c 2 )=c 1 steps without deciding. This takes at most time approximately (f + 1)Cd. Finally, we remark that the efficient algorithm of <ref> [ADLS90] </ref> can be modified to tolerate omission failures by using the timeout task for omission failures outlined above. The running time, however, is then roughly f 2 d + Cd. This bound follows from a modification of the part of the analysis of [ADLS90] which takes the sum over each phase <p> we remark that the efficient algorithm of <ref> [ADLS90] </ref> can be modified to tolerate omission failures by using the timeout task for omission failures outlined above. The running time, however, is then roughly f 2 d + Cd. This bound follows from a modification of the part of the analysis of [ADLS90] which takes the sum over each phase r of the number of processes that fail during the sending of an r message. Because only stopping failures are considered in [ADLS90], the analysis there concludes that a process may fail during the sending of at most one r message and therefore <p> This bound follows from a modification of the part of the analysis of <ref> [ADLS90] </ref> which takes the sum over each phase r of the number of processes that fail during the sending of an r message. Because only stopping failures are considered in [ADLS90], the analysis there concludes that a process may fail during the sending of at most one r message and therefore the sum over all r is at most f . <p> there are at most f + 2 phases in any f -admissible execution, the sum over all r is at most (f + 1)f , resulting in a bound of approximately (f + 1)f d + Cd. 16 3.2 Intuition: the underlying synchronous algorithm Our algorithm and the algorithm of <ref> [ADLS90] </ref> may be interpreted as simulations of an underlying synchronous algorithm. In this underlying synchronous algorithm, all processes begin executing in round 0. In even numbered rounds, processes may decide only on 0; in odd numbered rounds, processes may decide only on 1. <p> Both our algorithm and that of <ref> [ADLS90] </ref> "simulate" this synchronous algorithm, making several important optimizations in order to improve the running time for our model. <p> The key to the improved efficiency of our algorithm relative to that of <ref> [ADLS90] </ref> is the addition of a mechanism for a process to detect its own failure. We require that a process receive at least n f acknowledgments for every message of the synchronous algorithm that it sends. <p> For C large, this algorithm may be far more efficient that a direct rounds simulation. The bound we obtain for n 2f + 1 is within approximately a factor of 4 of optimal: our bound is 4 (f + 1)d + Cd; the lower bound proved in <ref> [ADLS90] </ref> is (f 1)d + Cd. Having bounded the time for quiet phases in Lemma 3.18, we need only bound the time for any phase that is not quiet. <p> The number of processes blocked in phase r + 1 is exactly b r ; our bound for phase r is roughly b r d. This is the key difference between our algorithm and the algorithm of <ref> [ADLS90] </ref>: a faulty process may cause delay d only if it sends exclusively to other faulty processes; the convention of requiring acknowledgments ensures that each faulty process can do so only once. <p> the previous phase, another d is for a faulty process (here, b r + 1) that is not blocked in phase r + 1 to send an r message to a nonfaulty process, and another d is for the remaining nonfaulty processes (here, i) to receive an r message. (In <ref> [ADLS90] </ref>, only the last extra d is incurred; this leads to the factor of 2 in their bound, instead of 4 in ours.) Lemma 3.20 For n 2f + 1 and r 1, if for all r 0 r phase r 0 is not quiet, then t r t r1 (3 <p> analysis of the previous section shows that the running time of our algorithm is (5 + 3 f Note that if f is close to n, say n = f + 1, then the bound is roughly proportional to f 2 d, which is no improvement on the algorithm of <ref> [ADLS90] </ref>. However, for these proportional values of n and f, we are better able to bound the running time. <p> If it is assumed that all messages sent are delivered within time d of when they are sent, then the following simple protocol minimizes the time between any failure and its detection. (This is the strategy employed in the algorithm of <ref> [ADLS90] </ref> and our algorithm of Chapter 3.) Each processor broadcasts a message at every step that it takes. If no message is received from another processor for more than (d + c 2 )=c 1 local steps, that processor is declared faulty. <p> the algorithm on demand by more closely intertwining the main algorithm and the fault detection task. 59 Chapter 6 Conclusions We first summarize the known bounds for consensus: Failure type n Lower bound Upper bound Reference Stopping f + 1 (f 1)d + Cd; 2 (f + 1)d + Cd <ref> [ADLS90] </ref> Omissions (sending) 2f + 1 " 4 (f + 1)d + Cd Thm. 3.21 f + 1 " nf + 5)(f + 1)d + Cd; p Thm. 3.25 "Timing" f + 1 " (f + 1)(Cd + d) (see below) Byzantine 3f + 1 " (f + 1)(d + 2Cd) <p> The simple direct rounds simulation first described in Chapter 3 tolerates timing failures as well, implying a consensus algorithm with running time (f + 1)(Cd + d). The algorithm of <ref> [ADLS90] </ref> is also correct despite timing failures, but each of its phases may take up to time Cd + d. In fact, no algorithm is known to tolerate timing failures in less than time O (f Cd). <p> is because process clocks are perfectly synchronized: whereas in our model the time between failure and detection may be anywhere in the range [d; d + Cd], in this model it must be (plus or minus twice the step time, which is assumed to be much less than ffi; see <ref> [ADLS90] </ref>, x7).) The length of each phase except the last must therefore be and must have at least =ffi 3 failures (processes in B r ). <p> The running time is the maximum of this expression and 4 (f + 1)ffi + . Similarly for the stopping failures algorithm of <ref> [ADLS90] </ref>, the running time is the maximum of 2 (f + 1)d) + Cd and ( ffi )(f + 1)ffi + . <p> We also note that the different model considered there, which enables processes to send to at most one process per step, does not affect the time bound asymptotically.) Note that in contrast to our algorithm and the algorithm of <ref> [ADLS90] </ref>, the running times of the algorithms of [DLS88] in the [HK89] model do not depend at all on , the upper bound on message delay time. <p> in the [HK89] model, relative to our semi-synchronous model. 6.2 Directions for further research There are many possible directions for interesting research addressing the issues and concerns of real-time behavior of distributed systems: * The existence of the underlying synchronous algorithm described in Section 3.2 suggests that the results of <ref> [ADLS90] </ref> and this thesis may be generalizable to certain classes of synchronous algorithms.
Reference: [AL89] <author> H. Attiya and N. A. Lynch. </author> <title> Time bounds for real-time process control in the presence of timing uncertainty. </title> <booktitle> Proc. 10th IEEE Real-Time Systems Symposium, </booktitle> <year> 1989, </year> <pages> pp. 268-284. </pages> <note> Also: Technical Memo MIT/LCS/TM-403, </note> <institution> Laboratory for Computer Science, MIT, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: The time complexity of an asynchronous algorithm is usually measured by letting one time unit equal the maximum delay of any message ([Gal82, Awe85]). The model we use is a slightly simplified version of the semi-synchronous model introduced in <ref> [AL89] </ref>, which is in turn based on the formal model of timed automata in [MMT90]. In this model, processors have inexact knowledge about the time needed to perform certain primitive operations. <p> According to the model of <ref> [AL89] </ref> and [ADLS90] (used in Chapter 3), every message sent by a process is delivered within time d of when it is sent, regardless of the rate at which messages are sent. In reality, if a link is flooded with messages, their delay may be much greater. <p> Therefore in this execution q does not detect the failure of p within time B. This is a contradiction on the assumed protocol. Our lower bound proof uses the retiming techniques of "shifting" events in time and "shrinking" portions of executions that were developed in <ref> [AL89] </ref> and [LL84]. Theorem 5.2 In a system with links of capacity and delay d, no correct timeout protocol can guarantee failures to be detected within less than time min (2Cd + d=; C 2 d= + Cd + d).
Reference: [Awe85] <author> B. Awerbuch. </author> <title> Complexity of network synchronization. </title> <journal> Journal of the ACM, </journal> <volume> 32(4) </volume> <pages> 804-823, </pages> <month> October </month> <year> 1985. </year>
Reference: [AM90] <author> H. Attiya and M. Mavronicolas. </author> <title> Efficiency of asynchronous vs. semi-synchronous networks. </title> <booktitle> the 28th annual Allerton Conference on Communication, Control and Computing, </booktitle> <month> October </month> <year> 1990. </year>
Reference: [B91] <author> A. Bharali. </author> <type> Personal communication, </type> <month> August </month> <year> 1991. </year>
Reference: [CASD86] <author> F. Cristian, H. Aghili, R. Strong and D. Dolev. </author> <title> Atomic broadcast: from simple message diffusion to byzantine agreement. </title> <booktitle> Proc. 15th Int. Conf. on Fault Tolerant Computing, </booktitle> <year> 1985, </year> <pages> pp. 1-7. </pages> <note> Also: IBM Research Report RJ5244, revised October 1989. </note>
Reference: [CD86] <author> B. A. Coan and C. Dwork. </author> <title> Simultaneity is harder than agreement. </title> <booktitle> Proc. 5th IEEE Symp. on Reliability in Distributed Software and Database Systems, </booktitle> <year> 1986, </year> <pages> pp. 141-150. </pages>
Reference: [CT90] <author> B. Coan and G. Thomas. </author> <title> Agreeing on a leader in real-time. </title> <booktitle> Proc. 11th IEEE Real-Time Systems Symposium, </booktitle> <year> 1990. </year>
Reference: [DLM82] <author> R. DeMillo, N. A. Lynch and M. Merritt. </author> <title> Cryptographic protocols. </title> <booktitle> Proc. 14th Annual ACM Symp. on Theory of Computing, </booktitle> <month> May </month> <year> 1982, </year> <pages> pp. 383-400. 65 </pages>
Reference-contexts: The time complexity of the consensus problem has been well studied in the synchronous rounds model (see, for example, <ref> [LSP82, PSL80, FL82, DS83, DLM82] </ref>). It is well known 8 that f +1 rounds of communication are both sufficient ([PSL80]) and necessary ([FL82, M85, DM86, CD86]) to reach consensus, regardless of the severity of failures (stopping, omission, or Byzantine).
Reference: [DDS87] <author> D. Dolev, C. Dwork and L. Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 34, No. </volume> <month> 1 (January </month> <year> 1987), </year> <pages> pp. 77-97. </pages>
Reference-contexts: It is well known ([FLP85]) that in an asynchronous system, this problem cannot be solved deteministically even if the only failure to be tolerated is the unannounced halting (stopping) of a single process. The work of <ref> [DDS87] </ref> methodically explores the synchrony necessary to reach consensus; they show that if there is no upper bound on message delay or there is no upper bound on the relative rate of process steps|if any of our bounds d, c 1 , or c 2 does not hold|then there is no
Reference: [DRS82] <author> D. Dolev, R. Reischuk, and H. R. </author> <title> Strong. Eventual is earlier than immediate. </title> <booktitle> Proceedings of the 23rd IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1982, </year> <pages> pp. 196-203. </pages>
Reference: [DS83] <author> D. Dolev and H. R. </author> <title> Strong. Authenticated algorithms for byzantine agreement. </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 12, No. </volume> <month> 3 (November </month> <year> 1983), </year> <pages> pp. 656-666. </pages>
Reference-contexts: The time complexity of the consensus problem has been well studied in the synchronous rounds model (see, for example, <ref> [LSP82, PSL80, FL82, DS83, DLM82] </ref>). It is well known 8 that f +1 rounds of communication are both sufficient ([PSL80]) and necessary ([FL82, M85, DM86, CD86]) to reach consensus, regardless of the severity of failures (stopping, omission, or Byzantine).
Reference: [DLS88] <author> C. Dwork, N. Lynch, and L. Stockmeyer. </author> <title> Consensus in the presence of partial synchrony. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 35 (1988), </volume> <pages> pp. 288-323. </pages>
Reference-contexts: It is well known 8 that f +1 rounds of communication are both sufficient ([PSL80]) and necessary ([FL82, M85, DM86, CD86]) to reach consensus, regardless of the severity of failures (stopping, omission, or Byzantine). In <ref> [DLS88] </ref>, the problem was studied using a model of partial synchrony in which upper bounds on message delivery time and/or processes' relative step rates exist, but they are unknown a priori to the processes. The algorithms of [DLS88] are concerned with fault tolerance rather than timing efficiency, and therefore translate to <p> In <ref> [DLS88] </ref>, the problem was studied using a model of partial synchrony in which upper bounds on message delivery time and/or processes' relative step rates exist, but they are unknown a priori to the processes. The algorithms of [DLS88] are concerned with fault tolerance rather than timing efficiency, and therefore translate to relatively slow algorithms for our model. <p> Our algorithm for Byzantine failures is not interesting in this model, as it is trivial to design an algorithm taking only time (f + 1) (our algorithm takes (2f + 1) + f ffi). In comparison, the algorithms of <ref> [DLS88] </ref> may also be used in the model of [HK89]. For stopping and omission failures (sending and receiving), their algorithms require n 2f + 1; for Byzantine failures, they require n 3f + 1. <p> The running times are O (ffi 2 + n 2 ) for all types failures. (As noted in <ref> [DLS88] </ref>, the running times can be improved to O (ffi 2 + f 2 ). <p> We also note that the different model considered there, which enables processes to send to at most one process per step, does not affect the time bound asymptotically.) Note that in contrast to our algorithm and the algorithm of [ADLS90], the running times of the algorithms of <ref> [DLS88] </ref> in the [HK89] model do not depend at all on , the upper bound on message delay time. This is possible because the model of [HK89] provides an extra degree of power to the algorithm by assuming that process clocks are perfectly synchronized. The algorithms of [DLS88] do not give <p> the algorithms of <ref> [DLS88] </ref> in the [HK89] model do not depend at all on , the upper bound on message delay time. This is possible because the model of [HK89] provides an extra degree of power to the algorithm by assuming that process clocks are perfectly synchronized. The algorithms of [DLS88] do not give good bounds in our model; the running times depend only polynomially on the ratio of process step rate, C.
Reference: [DM86] <author> C. Dwork and Y. Moses. </author> <title> Knowledge and common knowledge in byzantine environments I: crash failures. </title> <booktitle> Proc. 1st Conf. on Theoretical Aspects of Reasoning About Knowledge, </booktitle> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1986, </year> <pages> pp. </pages> <note> 149-170; Information and Computation, to appear. </note>
Reference: [FL82] <author> M. Fischer and N. Lynch. </author> <title> A lower bound for the time to assure interactive consistency. </title> <journal> Information Processing Letters, </journal> <volume> Vol. 14, No. </volume> <month> 4 (June </month> <year> 1982), </year> <pages> pp. 183-186. </pages>
Reference-contexts: The time complexity of the consensus problem has been well studied in the synchronous rounds model (see, for example, <ref> [LSP82, PSL80, FL82, DS83, DLM82] </ref>). It is well known 8 that f +1 rounds of communication are both sufficient ([PSL80]) and necessary ([FL82, M85, DM86, CD86]) to reach consensus, regardless of the severity of failures (stopping, omission, or Byzantine).
Reference: [FLM86] <author> M. Fischer, N. Lynch and M. Merritt. </author> <title> Easy impossibility proofs for distributed consensus problems. </title> <journal> Distributed Computing, </journal> <volume> No. 1, </volume> <year> 1986, </year> <pages> pp. 26-39. </pages>
Reference-contexts: The lower bound for authenticated Byzantine failures, not presented in this thesis, is interesting (greater than Cd) only for the limited range of n 2f , and therefore says nothing interesting about unauthenticated Byzantine failures. The proof of this bound is similar to the "shifting scenarios" proofs of <ref> [FLM86] </ref>.
Reference: [FLP85] <author> M. Fischer, N. Lynch and M. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 32, No. 2 (1985), </volume> <pages> pp. 374-382. </pages>
Reference: [Gal82] <author> R. G. Gallager. </author> <title> Distributed minimum hop algorithms. </title> <type> Technical report LIDS-P-1175, </type> <institution> MIT, </institution> <month> January </month> <year> 1982. </year>
Reference: [H84] <author> V. Hadzilacos. </author> <title> Issues of Fault Tolerance in Concurrent Computations, </title> <type> Ph.D. Thesis, </type> <institution> Harvard University, </institution> <month> June </month> <year> 1984. </year> <type> Technical Report TR-11-84, </type> <institution> Department of Computer Science, Harvard University. </institution>
Reference: [HK89] <author> A. Herzberg and S. Kutten. </author> <title> Efficient Detection of Message Forwarding Faults. </title> <booktitle> Proc. 8th ACM Symp. on Principles of Distributed Computing, </booktitle> <year> 1989, </year> <pages> pp. 339-353. </pages>
Reference-contexts: The relationship between those results and ours is unclear; a better understanding of the differences between two different models is posed as a direction for further research in Section 6.2. A related model is studied in <ref> [HK89] </ref> to explore the time complexity of detecting failures along a network path. This model assumes synchronous processes but differentiates between the (known) a priori worst-case bound on message delay, , and the (unknown) actual worst-case message delay in a given execution, ffi. <p> differs by the inclusion of the following: the upper bound for authenticated Byzantine failures when n 2f + 1, the improvement of the constant from 4 to 3 for the running time of the omissions algorithm ([B91]), and the more careful analysis of the running time in the model of <ref> [HK89] </ref>. 60 sending an r message. <p> The proof of this bound is similar to the "shifting scenarios" proofs of [FLM86]. Before suggesting other directions for further research, we first comment on the implications of our bounds for consensus in a closely related model. 6.1 Consensus in the related model of <ref> [HK89] </ref> Herzberg and Kutten [HK89] consider a model in which the actual worst-case message delay in a given execution, ffi, may be much less than the a priori worst-case bound on message delay, . It is thus desirable for the running time of algorithms to depend minimally on . <p> The proof of this bound is similar to the "shifting scenarios" proofs of [FLM86]. Before suggesting other directions for further research, we first comment on the implications of our bounds for consensus in a closely related model. 6.1 Consensus in the related model of <ref> [HK89] </ref> Herzberg and Kutten [HK89] consider a model in which the actual worst-case message delay in a given execution, ffi, may be much less than the a priori worst-case bound on message delay, . It is thus desirable for the running time of algorithms to depend minimally on . <p> In this model, our algorithms yield an improvement over direct simulation strategies similar to the corresponding improvement in our semi-synchronous model. It is not difficult to see that our algorithms may be run without modification in the model of <ref> [HK89] </ref>, yielding the same running times with the syntactic substitution of for Cd and ffi for d. <p> Our algorithm for Byzantine failures is not interesting in this model, as it is trivial to design an algorithm taking only time (f + 1) (our algorithm takes (2f + 1) + f ffi). In comparison, the algorithms of [DLS88] may also be used in the model of <ref> [HK89] </ref>. For stopping and omission failures (sending and receiving), their algorithms require n 2f + 1; for Byzantine failures, they require n 3f + 1. <p> We also note that the different model considered there, which enables processes to send to at most one process per step, does not affect the time bound asymptotically.) Note that in contrast to our algorithm and the algorithm of [ADLS90], the running times of the algorithms of [DLS88] in the <ref> [HK89] </ref> model do not depend at all on , the upper bound on message delay time. This is possible because the model of [HK89] provides an extra degree of power to the algorithm by assuming that process clocks are perfectly synchronized. <p> affect the time bound asymptotically.) Note that in contrast to our algorithm and the algorithm of [ADLS90], the running times of the algorithms of [DLS88] in the <ref> [HK89] </ref> model do not depend at all on , the upper bound on message delay time. This is possible because the model of [HK89] provides an extra degree of power to the algorithm by assuming that process clocks are perfectly synchronized. The algorithms of [DLS88] do not give good bounds in our model; the running times depend only polynomially on the ratio of process step rate, C. <p> The algorithms of [DLS88] do not give good bounds in our model; the running times depend only polynomially on the ratio of process step rate, C. This difference in the model also accounts for the simplicity of solving consensus in the presence of Byzantine failures in the <ref> [HK89] </ref> model, relative to our semi-synchronous model. 6.2 Directions for further research There are many possible directions for interesting research addressing the issues and concerns of real-time behavior of distributed systems: * The existence of the underlying synchronous algorithm described in Section 3.2 suggests that the results of [ADLS90] and this
Reference: [LSP82] <author> L. Lamport, R. Shostak and M. Pease. </author> <title> The byzantine generals problem. </title> <journal> ACM Transaction on Prog. Lang. and Sys., </journal> <volume> Vol. 4, No. </volume> <month> 3 (July </month> <year> 1982), </year> <pages> pp. 382-401. 66 </pages>
Reference-contexts: The time complexity of the consensus problem has been well studied in the synchronous rounds model (see, for example, <ref> [LSP82, PSL80, FL82, DS83, DLM82] </ref>). It is well known 8 that f +1 rounds of communication are both sufficient ([PSL80]) and necessary ([FL82, M85, DM86, CD86]) to reach consensus, regardless of the severity of failures (stopping, omission, or Byzantine).
Reference: [LL84] <author> J. Lundelius and N. Lynch. </author> <title> An upper and lower bound for clock synchronization. </title> <journal> Information and Control, </journal> <volume> Vol. 62, </volume> <pages> Nos. </pages> <month> 2/3 (August/September </month> <year> 1984), </year> <pages> pp. 190-204. </pages>
Reference-contexts: Therefore in this execution q does not detect the failure of p within time B. This is a contradiction on the assumed protocol. Our lower bound proof uses the retiming techniques of "shifting" events in time and "shrinking" portions of executions that were developed in [AL89] and <ref> [LL84] </ref>. Theorem 5.2 In a system with links of capacity and delay d, no correct timeout protocol can guarantee failures to be detected within less than time min (2Cd + d=; C 2 d= + Cd + d).
Reference: [LA90] <author> N. Lynch and H. Attiya. </author> <title> Using mappings to prove timing properties. </title> <booktitle> Proceedings of the 9th ACM PODC, </booktitle> <pages> pp. 265-280, </pages> <month> August </month> <year> 1990. </year> <note> Expanded version appears as MIT/LCS/TM-412.b, December 1989. Submitted for publication. </note>
Reference: [LG89] <author> N. Lynch and K. Goldman. </author> <booktitle> Distributed algorithms|lecture notes for 6.852 Fall 1989. </booktitle> <volume> MIT/LCS/RSS 5, </volume> <month> May </month> <year> 1989. </year>
Reference: [LT87] <author> N. A. Lynch and M. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> Proceedings of the 6th ACM PODC, </booktitle> <pages> pp. 137-151, </pages> <month> August </month> <year> 1987. </year> <note> Also, expanded version as MIT/LCS/TR-387, </note> <month> April </month> <year> 1987. </year>
Reference: [LF81] <author> N. A. Lynch and M. J. Fischer. </author> <title> On describing the behavior and implementation of distributed systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 13(1): </volume> <pages> 17-43, </pages> <month> January </month> <year> 1981. </year>
Reference: [M85] <author> M. Merritt. </author> <title> Notes on the Dolev-Strong lower bound for byzantine agreement. </title> <type> Unpublished manuscript, </type> <year> 1985. </year>
Reference: [MMT90] <author> M. Merritt, F. Modugno and M. Tuttle. </author> <title> Time constrained automata. </title> <type> Unpublished manuscript, </type> <month> August </month> <year> 1990. </year>
Reference-contexts: The model we use is a slightly simplified version of the semi-synchronous model introduced in [AL89], which is in turn based on the formal model of timed automata in <ref> [MMT90] </ref>. In this model, processors have inexact knowledge about the time needed to perform certain primitive operations.
Reference: [PSL80] <author> M. Pease, R. Shostak and L. Lamport. </author> <title> Reaching agreement in the presence of faults. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 27, No. 2 (1980), </volume> <pages> pp. 228-234. </pages>
Reference-contexts: The time complexity of the consensus problem has been well studied in the synchronous rounds model (see, for example, <ref> [LSP82, PSL80, FL82, DS83, DLM82] </ref>). It is well known 8 that f +1 rounds of communication are both sufficient ([PSL80]) and necessary ([FL82, M85, DM86, CD86]) to reach consensus, regardless of the severity of failures (stopping, omission, or Byzantine).
Reference: [PF77] <author> G. Peterson and M. J. Fischer. </author> <title> Economical solutions for the critical section problem in a distributed system. </title> <booktitle> Proceedings of the 9th STOC, </booktitle> <pages> pp. 91-97, </pages> <month> May </month> <year> 1977. </year>
Reference: [SWL86] <author> B. Simons, J. L. Welch and N. Lynch. </author> <title> An overview of clock synchronization. </title> <booktitle> Proceedings of IBM Fault-Tolerant Computing Workshop, </booktitle> <month> March, </month> <year> 1986. </year>
Reference-contexts: Our algorithms run equally well in this model; we remark on how our bounds translate to this model in Section 6.1. Other work in this area includes the extensive literature on clock synchronization algorithms (see <ref> [SWL86] </ref> for a survey).
Reference: [SDC90] <author> R. Strong, D. Dolev and F. Cristian. </author> <title> New latency bounds for atomic broadcast. </title> <booktitle> 11th IEEE Real-Time Systems Symposium, </booktitle> <year> 1990. </year>
Reference-contexts: lower bound of (f 1)d + Cd in a proof that combines the arguments of the synchronous lower bound with techniques from asynchronous lower bounds and retiming techniques for our semi-synchronous model. 1.2 Related work Current research also concentrating on the real time complexity of the consensus problem appears in <ref> [SDC90] </ref>. There, processes are assumed to have clocks that are synchronized to within a fixed additive error. In contrast to our results, the results of [SDC90] are stated in terms of process clock time, not absolute time. <p> and retiming techniques for our semi-synchronous model. 1.2 Related work Current research also concentrating on the real time complexity of the consensus problem appears in <ref> [SDC90] </ref>. There, processes are assumed to have clocks that are synchronized to within a fixed additive error. In contrast to our results, the results of [SDC90] are stated in terms of process clock time, not absolute time. The relationship between those results and ours is unclear; a better understanding of the differences between two different models is posed as a direction for further research in Section 6.2.
Reference: [WL88] <author> J. L. Welch and N. Lynch. </author> <title> A new fault-tolerant algorithm for clock synchronization. </title> <journal> Information and Computation, </journal> <volume> Vol. 77, No. </volume> <month> 1 (April </month> <year> 1988), </year> <pages> pp. 1-36. 67 </pages>
Reference-contexts: The partial synchronization works by using a combination of two criteria for advancing to further phases, one based on elapsed local time and the other based on messages received. A similar technique is used in <ref> [WL88] </ref> to initiate new rounds of clock resynchronization. In particular, our criteria for ending round 1 is essentially the same as the criteria used in [WL88] for ending every round; our criteria for subsequent rounds is different. 4.1 The simulation algorithm The algorithm simulates a synchronous algorithm by ensuring that each <p> A similar technique is used in <ref> [WL88] </ref> to initiate new rounds of clock resynchronization. In particular, our criteria for ending round 1 is essentially the same as the criteria used in [WL88] for ending every round; our criteria for subsequent rounds is different. 4.1 The simulation algorithm The algorithm simulates a synchronous algorithm by ensuring that each nonfaulty process receives all round r messages of the synchronous algorithm from all other nonfaulty processes before advancing to round r + 1.
References-found: 33

