URL: ftp://osm7.cs.byu.edu/papers/ModelEquivalent.ps
Refering-URL: http://osm7.cs.byu.edu/Papers.html
Root-URL: 
Email: (liddle@cs.byu.edu)  (embley@cs.byu.edu)  (woodfiel@cs.byu.edu)  
Title: Unifying Modeling and Programming through an Active, Object-Oriented, Model-Equivalent Programming Language  
Author: Stephen W. Liddle David W. Embley Scott N. Woodfield 
Keyword: Key Words: Database programming languages, model-equivalent languages, semantics of models and languages, impedance mismatch.  
Address: Provo, UT 84602  
Affiliation: Department of Computer Science Brigham Young University  
Abstract: The intricate and complex structure of existing advanced database applications results in part from poor integration of existing models and languages. This complexity is a barrier to effectively understanding and developing advanced applications. We can significantly reduce the complexity of advanced-application specification and implementation by using a model-equivalent language (a language with a one-to-one correspondence to an underlying, executable model as defined herein). In this paper we explain the difficulties encountered in making models and languages equivalent, and we resolve these difficulties for a particular language and model. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M.P. Atkinson and O.P. Buneman, </author> <title> Types and Persistence in Database Programming Languages, </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 19 no. 2, </volume> <pages> pp. 105-190, </pages> <year> 1987. </year>
Reference-contexts: We can achieve scalar semantics by associating an OSM object-class cardinality constraint of 1 with an object class. For example, x <ref> [1] </ref>: real; forces x to have exactly one member. The corresponding notation in OSM is to place a 1 in the upper right corner of an object-class rectangle (as in Figure 5). In addition to the variable concept, there is the related concept of type constructor. <p> Club Person Address Name Street City State ZIP 1:* 0:* 1:* 1:* 1:* 1 1:* 1 1 13 textual equivalent of the graphical model instance of Figure 8 is the following: Club [1:*] is a set of Person [0:*]; Person <ref> [1] </ref> has Name [1:*]; Person [1:*] has Address [1:*]; Address includes [1:*] Street [1:*], [1] City [1:*], [1] State [1:*], [1] ZIP [1:*]; The ranges in brackets are participation constraints, indicating the number of times objects from a particular class may participate in a given relationship set. <p> Street City State ZIP 1:* 0:* 1:* 1:* 1:* 1 1:* 1 1 13 textual equivalent of the graphical model instance of Figure 8 is the following: Club [1:*] is a set of Person [0:*]; Person <ref> [1] </ref> has Name [1:*]; Person [1:*] has Address [1:*]; Address includes [1:*] Street [1:*], [1] City [1:*], [1] State [1:*], [1] ZIP [1:*]; The ranges in brackets are participation constraints, indicating the number of times objects from a particular class may participate in a given relationship set. <p> ZIP 1:* 0:* 1:* 1:* 1:* 1 1:* 1 1 13 textual equivalent of the graphical model instance of Figure 8 is the following: Club [1:*] is a set of Person [0:*]; Person <ref> [1] </ref> has Name [1:*]; Person [1:*] has Address [1:*]; Address includes [1:*] Street [1:*], [1] City [1:*], [1] State [1:*], [1] ZIP [1:*]; The ranges in brackets are participation constraints, indicating the number of times objects from a particular class may participate in a given relationship set. <p> 1:* 1:* 1:* 1 1:* 1 1 13 textual equivalent of the graphical model instance of Figure 8 is the following: Club [1:*] is a set of Person [0:*]; Person <ref> [1] </ref> has Name [1:*]; Person [1:*] has Address [1:*]; Address includes [1:*] Street [1:*], [1] City [1:*], [1] State [1:*], [1] ZIP [1:*]; The ranges in brackets are participation constraints, indicating the number of times objects from a particular class may participate in a given relationship set. <p> Persistence is defined as the ability of a programs data to outlast the execution of a program. Persistence is type-complete if any kind of object can persist (i.e., persistence is a property orthogonal to type; see <ref> [1] </ref> for a thorough discussion of this topic). Melody supports persistence by declaring that object classes and relationship sets persist for the duration of their scope. When a thread enters a nested scope, a nested model instance associated with the scope is instantiated.
Reference: [2] <author> L. Cardelli and P. Wegner, </author> <title> On Understanding Types, Data Abstraction, </title> <journal> and Polymor-phism, ACM Computing Surveys, </journal> <volume> vol. 17, no. 4, </volume> <pages> pp. 471-522, </pages> <year> 1985. </year>
Reference: [3] <author> R.G.G. Cattell (ed.), </author> <title> The Object Database Standard: ODMG-93, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, California, </address> <year> 1994. </year>
Reference-contexts: In its Object Query Language (OQL), the Object Database Standard defines a path traversal operator, ., that allows navigation from an object into its attributes or through simple relationships <ref> [3] </ref>. Melody has a similar, but more general traversal operator.
Reference: [4] <author> S. Chakravarthy et al., HiPAC: </author> <title> A Research Project in Active, Time-Constrained Database Management, </title> <type> Final Technical Report, </type> <institution> XAIT-89-02, Xerox Advanced Information Technology, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: A state net is essentially a set of rules that describe when and how an object will perform particular actions [19] and is similar in many ways to rule components in active systems such as <ref> [4] </ref>, [9], and [13]. An object behaves by continually evaluating its triggering rules and performing appropriate actions. The textual view in Figure 10 (b) looks much like a propositional production system [26], emphasizing this rule orientation. More complex state nets would have many such when rules.
Reference: [5] <author> S.W. Clyde, D.W. Embley, </author> <title> and S.N. Woodfield, The Complete Formal Definition for the Syntax and Semantics of OSA, </title> <type> Technical Report BYU-CS-92-2, </type> <institution> Computer Science Department, Brigham Young University, </institution> <year> 1992. </year>
Reference-contexts: This demonstration of computational completeness is informal, but it is sufficient for our purpose here. We point out, however, that we can go a step further. Another important characteristic of OSM is that it is formally defined <ref> [5] </ref>. The formal definition provides the rigorous foundation required to support a model-equivalent language. Also, using the formal definition of OSM, we can rigorously construct the simulation described above, and show that our simulation is correct.
Reference: [6] <author> S.W. Clyde, D.W. Embley, </author> <title> and S.N. Woodfield, Tunable Formalism in Object-oriented Systems Analysis: Meeting the Needs of Both Theoreticians and Practitioners, </title> <booktitle> OOPSLA 92 Conference Proceedings, </booktitle> <pages> pp. 452-465, </pages> <address> Vancouver, British Columbia, Canada, </address> <month> Octo-ber </month> <year> 1992. </year>
Reference-contexts: Thus, we can implement systems directly in OSM, without moving to another language. A novel aspect of OSMs formalism is that it is tunable <ref> [6] </ref>. Not all users of a system will be capable of dealing in terms of detailed formalism. The needs of theoreticians, tool builders, programmers, and customers all differ with respect to the degree of formal understanding required or expected.
Reference: [7] <author> B.D. Czejdo, R.P. Tucci, D.W. Embley, and S.W. Liddle, </author> <title> Graphical Query Specification with Cardinality Constraints, </title> <booktitle> Proceedings of the Fifth International Conference on Computing and Information, </booktitle> <pages> pp. 433-437, </pages> <address> Sudbury, Ontario, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: With the OSM Composer, a user can create OSM model instances for systems analysis, specification, design, and implementation. The Composer also provides a platform for integrating other tools to assist in the development of OSM-based systems. For example, we have a rapid-prototyping component [14, 15], a graphical query language <ref> [7, 30] </ref>, and a database normalization assistant [12, 23]. Other related projects are also planned or under way (see [34]). We have implemented a subset of the Melody language, and we are continuing to enlarge the implementation. Currently, we can create, store, and parse any Melody program.
Reference: [8] <author> M.D. Davis and E.J. Weyuker, </author> <title> Computability, Complexity, and Languages, </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: We demonstrate OSMs computational completeness by explaining how to convert any S-language program to an OSM model instance. Since the S language is computationally complete <ref> [8] </ref>, if OSM can represent any S-language program, then OSM is also computationally complete. The definition of S is simple.
Reference: [9] <author> U. Dayal, </author> <title> Active Database Management Systems, </title> <booktitle> Proceedings of the Third International Conference on Data and Knowledge Bases: Improving Usability and Responsiveness, </booktitle> <pages> pp. 150-169, </pages> <address> Jerusalem, Israel, </address> <month> June </month> <year> 1988. </year> <month> 28 </month>
Reference-contexts: A state net is essentially a set of rules that describe when and how an object will perform particular actions [19] and is similar in many ways to rule components in active systems such as [4], <ref> [9] </ref>, and [13]. An object behaves by continually evaluating its triggering rules and performing appropriate actions. The textual view in Figure 10 (b) looks much like a propositional production system [26], emphasizing this rule orientation. More complex state nets would have many such when rules.
Reference: [10] <author> D.W. Embley, </author> <title> B.D. Kurtz, and S.N. Woodfield, Object-Oriented Systems Analysis: A Model-Driven Approach, </title> <publisher> Yourdon Press Series, Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1992. </year>
Reference-contexts: In this paper, we show how we can overcome these problems and obtain a model-equivalent language, with its advantages. We do so by giving a specific example: our language is Melody [17], and our model is the Object-oriented Systems Model (OSM) <ref> [10, 20] </ref>. Our purpose is to explore the issues behind the design of a model-equivalent language and to describe how we address these issues. <p> We conclude in Section 5, where we also give the status of our implementation. 2 The OSM Model The Object-oriented Systems Model (OSM) is a derivative of OSA, which was originally developed for systems analysis <ref> [10] </ref>. OSM is a non-traditional object-oriented model, with structural and behavioral sub-models. It is non-traditional because there are no attributes only objects and relationships [18, 22] and because behavior is active, driven by events and conditions, rather than being passive and driven by method invocation. <p> As indicated in this example, Melody supports predicate calculus directly. OSM also directly supports predicate calculus (see Appendix A of <ref> [10] </ref>). Within the body of a transition action, logic rules can be freely interspersed with other Melody statements. Thus, we could place the hlrs statement above in Figure 10 (c) either before or after the when statement.
Reference: [11] <author> D.W. Embley, R.B. Jackson, </author> <title> and S.N. Woodfield, Object-Oriented Systems Analysis: Is It or Isnt It?, </title> <journal> IEEE Software, </journal> <note> to appear. </note>
Reference-contexts: Moreover, full-fledged psychology experiments are time consuming and expensive. We thus do not comment here on OSMs expressiveness, other than to assert our view that it is highly expressive. (The interested reader may consult <ref> [11] </ref> where there is a comparative discussion, including expressiveness, among several different analysis models.) In order to achieve bijectivity between a model and a language, we must ensure that the computational power of the model is equivalent to the computational power of the language.
Reference: [12] <author> D.W. Embley and T.W. Ling, </author> <title> Synergistic Database Design with an Extended Entity-Relationship Model, </title> <booktitle> Proceedings of the Eighth International Conference on Entity-Relationship Approach, </booktitle> <pages> pp. 118-135, </pages> <address> Toronto, Canada, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: The Composer also provides a platform for integrating other tools to assist in the development of OSM-based systems. For example, we have a rapid-prototyping component [14, 15], a graphical query language [7, 30], and a database normalization assistant <ref> [12, 23] </ref>. Other related projects are also planned or under way (see [34]). We have implemented a subset of the Melody language, and we are continuing to enlarge the implementation. Currently, we can create, store, and parse any Melody program.
Reference: [13] <author> N.H. Gehani, H.V. Jagadish, and O. Shmueli, </author> <title> Event Specification in an Active Object-Oriented Database, </title> <booktitle> Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pp. 81-90, </pages> <address> San Diego, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: A state net is essentially a set of rules that describe when and how an object will perform particular actions [19] and is similar in many ways to rule components in active systems such as [4], [9], and <ref> [13] </ref>. An object behaves by continually evaluating its triggering rules and performing appropriate actions. The textual view in Figure 10 (b) looks much like a propositional production system [26], emphasizing this rule orientation. More complex state nets would have many such when rules.
Reference: [14] <author> R.B. Jackson, </author> <title> Object-Oriented Requirements Specification: A Model, A Tool and A Technique, </title> <type> Ph.D. Dissertation, </type> <institution> Computer Science Department, Brigham Young University, </institution> <year> 1994. </year>
Reference-contexts: With the OSM Composer, a user can create OSM model instances for systems analysis, specification, design, and implementation. The Composer also provides a platform for integrating other tools to assist in the development of OSM-based systems. For example, we have a rapid-prototyping component <ref> [14, 15] </ref>, a graphical query language [7, 30], and a database normalization assistant [12, 23]. Other related projects are also planned or under way (see [34]). We have implemented a subset of the Melody language, and we are continuing to enlarge the implementation.
Reference: [15] <author> R.B. Jackson, D.W. Embley, </author> <title> and S.N. Woodfield, Automated Support for the Development of Formal Object-Oriented Requirements Specifications, </title> <booktitle> Proceedings of the 6th International Conference on Advanced Information Systems Engineering, in Lecture Notes in Computer Science, </booktitle> <volume> vol. 811, </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: With the OSM Composer, a user can create OSM model instances for systems analysis, specification, design, and implementation. The Composer also provides a platform for integrating other tools to assist in the development of OSM-based systems. For example, we have a rapid-prototyping component <ref> [14, 15] </ref>, a graphical query language [7, 30], and a database normalization assistant [12, 23]. Other related projects are also planned or under way (see [34]). We have implemented a subset of the Melody language, and we are continuing to enlarge the implementation.
Reference: [16] <author> S.W. Liddle, </author> <title> Object-Oriented Systems Implementation: A Model-Equivalent Approach, </title> <type> Ph.D. Dissertation, </type> <institution> Computer Science Department, Brigham Young University, </institution> <note> in progress. </note>
Reference-contexts: Currently, we can create, store, and parse any Melody program. We have implemented the core of our initial 27 Melody interpreter, and we can execute some parsed Melody programs. We are currently working on event handling, logic programming, and concurrency control <ref> [16] </ref>. Acknowledgements We appreciate the able assistance of James Banks, Steve Clyde, Christopher Davis, Bob Jackson, Jeff Light, Bruce Mitchel, Jeff Pinkston, Aparna Seetharaman, Bruce Walton, and Andy Wu, who have done much of the implementation work. We are also grateful to the creators of the Gnu software tools.
Reference: [17] <author> S.W. Liddle, D.W. Embley, </author> <title> and S.N. Woodfield, Melody Language Specification, </title> <type> Technical Report, </type> <note> available via anonymous ftp at osm7.cs.byu.edu, or the World Wide Web at URL http://osm7.cs.byu.edu/, Computer Science Department, </note> <institution> Brigham Young University, </institution> <note> in progress. </note>
Reference-contexts: In this paper, we show how we can overcome these problems and obtain a model-equivalent language, with its advantages. We do so by giving a specific example: our language is Melody <ref> [17] </ref>, and our model is the Object-oriented Systems Model (OSM) [10, 20]. Our purpose is to explore the issues behind the design of a model-equivalent language and to describe how we address these issues. <p> Then for each predicate in the add statement, the parameter objects are inserted in the corresponding 14 object classes (if necessary), and then the parameter objects are related to form new relationships in the named relationship sets. (More details are found in [18] and <ref> [17] </ref>.) Any logical structure can be modeled in OSM using object classes and relationship sets, and so any physical structure, such as an array, can be emulated. For those bulk structures that are common, we provide optimized physical structures in the implementation of Melody. <p> Furthermore, these objects may be involved in relationships with other objects. Because we have generalized the concept of data storage, we also need to generalize the concept of assignment statement for Melody. The full details are extensive <ref> [17] </ref>, so we only give several examples here. The general form of Melody assignment is path.class := expression. <p> We call this pattern a model-equivalent language. We have discussed some of the important principles and properties of model-equivalent languages, in general, and the design of the model-equivalent language Melody, in particular. A more complete description of Melody is available on the World Wide Web <ref> [17] </ref>. The scope of model-equivalent languages is quite broad, encompassing at least analysis/design models, programming languages, operating systems, and database systems. However, the advantages of a model-equivalent language are clear.
Reference: [18] <author> S.W. Liddle, D.W. Embley, and Y.K. Ng, "Melody: </author> <title> Combining Object Orientation and Logic," </title> <note> manuscript submitted for review. </note>
Reference-contexts: OSM is a non-traditional object-oriented model, with structural and behavioral sub-models. It is non-traditional because there are no attributes only objects and relationships <ref> [18, 22] </ref> and because behavior is active, driven by events and conditions, rather than being passive and driven by method invocation. Objects and relationships among objects are captured in a sub-model called the Object-Relationship Model (ORM). OSM captures object behavior in two ways: individual object behavior and object interaction. <p> Then for each predicate in the add statement, the parameter objects are inserted in the corresponding 14 object classes (if necessary), and then the parameter objects are related to form new relationships in the named relationship sets. (More details are found in <ref> [18] </ref> and [17].) Any logical structure can be modeled in OSM using object classes and relationship sets, and so any physical structure, such as an array, can be emulated. For those bulk structures that are common, we provide optimized physical structures in the implementation of Melody.
Reference: [19] <author> S.W. Liddle, D.W. Embley, </author> <title> S.N. Woodfield, S.W. Clyde, and B.D. Czejdo, Analysis and Design for Active Object Bases, </title> <booktitle> Proceedings of the Sixth International Conference on Computing and Information, </booktitle> <pages> pp. 1553-1568, </pages> <address> Sudbury, Ontario, </address> <month> May </month> <year> 1994. </year> <note> This is available through the World Wide Web at URL http://www.cs.tufts.edu/icci/94/- TOC.html. </note>
Reference-contexts: Figure 10 shows an example of the same behavior expressed in three representations: graphical, textual, and mixed. A state net is essentially a set of rules that describe when and how an object will perform particular actions <ref> [19] </ref> and is similar in many ways to rule components in active systems such as [4], [9], and [13]. An object behaves by continually evaluating its triggering rules and performing appropriate actions.
Reference: [20] <author> S.W. Liddle, D.W. Embley, </author> <title> and S.N. Woodfield, A Seamless Model for Object-Oriented Systems Development, </title> <booktitle> Proceedings of the International Symposium on Object-Oriented Methodologies and Systems, ISOOMS 94, </booktitle> <pages> pp. 123-131, </pages> <address> Palermo, Italy, </address> <month> Septem-ber </month> <year> 1994. </year> <month> 29 </month>
Reference-contexts: In this paper, we show how we can overcome these problems and obtain a model-equivalent language, with its advantages. We do so by giving a specific example: our language is Melody [17], and our model is the Object-oriented Systems Model (OSM) <ref> [10, 20] </ref>. Our purpose is to explore the issues behind the design of a model-equivalent language and to describe how we address these issues.
Reference: [21] <author> S.W. Liddle, D.W. Embley, </author> <title> and S.N. Woodfield, "Cardinality Constraints in Semantic Data Models," </title> <journal> Data and Knowledge Engineering, </journal> <volume> vol. 11, no. 3, </volume> <pages> pp. 235-270, </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: First, however, in Sections 2.1 through 2.3 we give an overview of OSM in terms of its sub-models. 2.1 Object-Relationship Model The ORM has several fundamental constructs, including objects, object classes, relationships, and relationship sets. There are also powerful general constraints and rich cardinality constraints <ref> [21] </ref>. Objects have unique identity and are grouped (or classified) into sets called object classes. An object class may be a generalization and/or a specialization of other object classes. A specialization class is a subset of each of its generalization classes.
Reference: [22] <author> S.W. Liddle, D.W. Embley, </author> <title> and S.N. Woodfield, Attributes: Should We Eliminate Them from Semantic and Object-Oriented Data Models?, </title> <booktitle> Proceedings of the 22nd Annual ACM Computer Science Conference, </booktitle> <pages> pp. 340-347, </pages> <address> Phoenix, Arizona, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: OSM is a non-traditional object-oriented model, with structural and behavioral sub-models. It is non-traditional because there are no attributes only objects and relationships <ref> [18, 22] </ref> and because behavior is active, driven by events and conditions, rather than being passive and driven by method invocation. Objects and relationships among objects are captured in a sub-model called the Object-Relationship Model (ORM). OSM captures object behavior in two ways: individual object behavior and object interaction.
Reference: [23] <author> J. </author> <title> Light, The Implementation of a Technique for ORM Model-Instance Normalization, </title> <type> Masters Thesis, </type> <institution> Computer Science Department, Brigham Young University, </institution> <note> in progress. </note>
Reference-contexts: The Composer also provides a platform for integrating other tools to assist in the development of OSM-based systems. For example, we have a rapid-prototyping component [14, 15], a graphical query language [7, 30], and a database normalization assistant <ref> [12, 23] </ref>. Other related projects are also planned or under way (see [34]). We have implemented a subset of the Melody language, and we are continuing to enlarge the implementation. Currently, we can create, store, and parse any Melody program.
Reference: [24] <author> O. Nierstrasz, </author> <title> Regular Types for Active Objects, </title> <booktitle> OOPSLA 93 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Washington, D.C., </address> <month> October </month> <year> 1993. </year>
Reference-contexts: If we think of object interactions as service requests, we see that OSM exhibits non-uniform service availability <ref> [24] </ref>, since interactions can only occur when objects are in appropriate states. center represent interactions. Interactions may be specified at two levels of abstraction: interactions between objects, or interactions between threads (which are associated with objects).
Reference: [25] <editor> F. Bancilhon, C. Delobel, and P. Kanellakis (eds.), </editor> <title> Building an Object-Oriented Database System: </title> <publisher> The Story of O , Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1992. </year> <month> 2 </month>
Reference-contexts: We are not aware of any existing language that fits our definition of model-equivalence, though there are systems that move in this direction. For example, IEF [32] provides both analysis/design tools and code generators, but only for a narrow application domain, and object-oriented database systems such as O <ref> [25] </ref> provide a general language and an imple-2 mentation model, but support no analysis and design models.
Reference: [26] <author> D.R. Olsen, </author> <title> User Interface Management Systems: Models and Algorithms, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, California, </address> <year> 1992. </year>
Reference-contexts: An object behaves by continually evaluating its triggering rules and performing appropriate actions. The textual view in Figure 10 (b) looks much like a propositional production system <ref> [26] </ref>, emphasizing this rule orientation. More complex state nets would have many such when rules. The graphical view of this same state net in Figure 10 (a), visually emphasizes the imperative processing flow of the behavior of Actor objects. components, and partly in terms of Melody code.
Reference: [27] <author> R. Ramakrishnan, D. Srivastava, S. Sudarshan, and P. Seshadri, </author> <title> The CORAL Deductive System, </title> <journal> VLDB Journal, </journal> <volume> vol. 3, no. 2, </volume> <pages> pp. 161-210, </pages> <publisher> Boxwood Press, </publisher> <address> Pacific Grove, Cal-ifornia, </address> <year> 1994. </year>
Reference-contexts: Melody builds on this multi-paradigm foundation, integrating programming features from imperative, logic, and constraint paradigms. Basically, Melody programs can be thought of as having an imperative skeleton, with logic elements fleshing out the structure (this is similar in a number of ways to CORAL <ref> [27] </ref>, though CORAL does not unify C++ and logic at the model level). The imperative skeleton acts by evaluating constraints and triggers and executing transition actions.
Reference: [28] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen, </author> <title> Object-Oriented Modeling and Design, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1991. </year>
Reference-contexts: Hence, every program written in a model-equivalent language is fully integrated with and fully compatible with a model instance. To illustrate what a model-equivalent language is, first let us show what it is not. Consider the OMT model, which includes persistence and concurrency <ref> [28] </ref>, and the C++ language, which supports neither persistence nor concurrency. To obtain persistence, the programmer must provide code to save and restore data values, and to obtain concurrency, the programmer has to coordinate multiple C++ program components through the operating system.
Reference: [29] <author> D. Ungar and R.B. Smith, </author> <title> Self: The Power of Simplicity, </title> <booktitle> OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-242, </pages> <address> Orlando, Florida, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: It is typical, for example, to define an object as an instantiation of a class, and a class as a list of attributes together with a set of methods to operate on those attributes. Prototype-based (as opposed to class-based) object-oriented systems (e.g., <ref> [29] </ref>) are more dynamic in their definition of what an object is, but it is still evident that physical implementation issues have affected the type-system design. This creates a direct conflict with the desire to be free from physical concerns at the model level.
Reference: [30] <author> H.A. Wu, OSM-QL: </author> <title> A Calculus-Based Graphical Query Language for Object-Oriented Systems Modeling, </title> <type> Masters Thesis, </type> <institution> Computer Science Department, Brigham Young University, </institution> <year> 1993. </year>
Reference-contexts: With the OSM Composer, a user can create OSM model instances for systems analysis, specification, design, and implementation. The Composer also provides a platform for integrating other tools to assist in the development of OSM-based systems. For example, we have a rapid-prototyping component [14, 15], a graphical query language <ref> [7, 30] </ref>, and a database normalization assistant [12, 23]. Other related projects are also planned or under way (see [34]). We have implemented a subset of the Melody language, and we are continuing to enlarge the implementation. Currently, we can create, store, and parse any Melody program.
Reference: [31] <author> S.B. Zdonik and D. Maier, </author> <title> Fundamentals of Object-Oriented Databases, in Readings in Object-Oriented Database Systems, </title> <editor> ed. S.B. Zdonik and D. </editor> <booktitle> Maier, </booktitle> <pages> pp. 1-32, </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1990. </year>
Reference-contexts: This section describes how we addressed these issues in the design of Melody. Again, we organize our discussion in terms of structure, behavior, and interaction. 11 3.1 A Uniform Structural Model To provide a uniform structural model, we must resolve the impedance mismatch <ref> [31] </ref> for types between imperative and declarative languages, and we must provide for a seamless integration of persistent and non-persistent data. <p> This 16 gives rise to another aspect of the impedance mismatch problem database systems are usually declarative while programming languages are usually imperative <ref> [31] </ref>.
Reference: [32] <institution> A Guide to Information Engineering Using the IEF, 2nd Edition, Texas Instruments, Dallas, Texas, Part Number 2739756-0001, </institution> <year> 1990. </year>
Reference-contexts: Thus, C++ is not model-equivalent with OMT. We are not aware of any existing language that fits our definition of model-equivalence, though there are systems that move in this direction. For example, IEF <ref> [32] </ref> provides both analysis/design tools and code generators, but only for a narrow application domain, and object-oriented database systems such as O [25] provide a general language and an imple-2 mentation model, but support no analysis and design models.
Reference: [33] <institution> OSM Composer, Computer Science Department, Brigham Young University. </institution> <note> This software tool is currently available for HP Series 700 workstations running HP-UX 9.X via anonymous ftp at osm7.cs.byu.edu. See also [34]. </note>
Reference-contexts: However, we recognize that a number of important optimization issues currently remain open. Our implementation of Melody has been underway for some time now. We have created an OSM diagramming tool, called the OSM Composer, that forms the basis for our OSM/Melody programming environment <ref> [33] </ref>. With the OSM Composer, a user can create OSM model instances for systems analysis, specification, design, and implementation. The Composer also provides a platform for integrating other tools to assist in the development of OSM-based systems.
Reference: [34] <institution> OSM Lab Home Page, </institution> <note> World Wide Web URL http://osm7.cs.byu.edu/. </note>
Reference-contexts: For example, we have a rapid-prototyping component [14, 15], a graphical query language [7, 30], and a database normalization assistant [12, 23]. Other related projects are also planned or under way (see <ref> [34] </ref>). We have implemented a subset of the Melody language, and we are continuing to enlarge the implementation. Currently, we can create, store, and parse any Melody program. We have implemented the core of our initial 27 Melody interpreter, and we can execute some parsed Melody programs.
References-found: 34

