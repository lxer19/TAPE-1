URL: ftp://ftp.csd.uu.se/pub/papers/reports/0129.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: jorge@ids.de  decker@werra.zfe.siemens.de  kifer@cs.sunysb.edu  voronkov@csd.uu.se  
Title: Databases and the Meaning of Change  
Author: Jorge Bocca Hendrick Decker Michael Kifer Andrei Voronkov 
Address: Munich, Germany;  England  SE 4 D-81730 Munchen Germany  NY 11794-4400 U.S.A.  Box 311, S 751 05 Uppsala, Sweden  
Affiliation: IDS Integral Decisions Systems SE GmbH  University of Birmingham  Siemens ZFE T  Department of Computer Science SUNY at Stony Brook Stony Brook,  Computing Science Department Uppsala University  
Note: Logic  
Abstract: UPMAIL Technical Report No. 129 September 19, 1996 ISSN 1100-0686 
Abstract-found: 1
Intro-found: 1
Reference: [CCD] <author> Celma, Casamayor, Decker. </author> <title> Improving integrity checking by compiling derivation paths. </title> <booktitle> In Proc. 4th Australian Database Conf., </booktitle> <year> 1993. </year>
Reference: [CaD] <author> Casamayor, Decker. </author> <title> Hypothetical query answering in first-order databases. </title> <booktitle> In Proc. 5th SCAI, </booktitle> <year> 1995. </year>
Reference-contexts: of a database clause in a derivation against a literal in the body of an input clause only involves a slight extension of the usual backward reasoning capabilities of SLD-like procedures, which is still far from the expensive generality of arbitrary first-order procedures such as SL resolution [KK] or SLY <ref> [CaD] </ref>.
Reference: [CD] <author> Celma, Decker. </author> <title> Integrity checking in deductive databases | the ultimate method? In Proc. </title> <booktitle> 5th Australasian Database Conf., </booktitle> <year> 1994. </year>
Reference-contexts: In fact, this seems to be the easiest way to capture possible negative consequences of hypotheses, in the average case. ([CCD, CD] showed that, in some cases, it might be advantageous to spend some more effort on computing a more precise characterization of possible consequences of hypothetical updates, but <ref> [CD, DC] </ref> conclude that, usually, an approach as pursued in SLIC is more satisfying, because it is always simpler and most often more efficient than procedures which invest more effort in computing consequences of updates that "go through negation".) Back to [KM1, KM2] and SLDAI.
Reference: [DC] <author> Decker, Celma. </author> <title> A slick procedure for integrity checking in deductive databases. </title> <booktitle> In Proc. 11th ICLP, </booktitle> <year> 1994. </year>
Reference-contexts: Moreover, SLDAI avoids redundant computations that are unnecessarily run in other procedures. SLDAI combines two lines of development. One has led to SLIC, a Selection-driven Linear resolution procedure based on SLDNF, for Integrity Checking in deductive databases <ref> [DC] </ref>. The other line of development has started with Eshghi & Kowalski's work [EK] on casting the negation-as-failure rule of SLDNF in an abductive framework, and has led to the abductive procedure for database updating by Kakas & Mancarella [KM1, KM2], and beyond. <p> In fact, this seems to be the easiest way to capture possible negative consequences of hypotheses, in the average case. ([CCD, CD] showed that, in some cases, it might be advantageous to spend some more effort on computing a more precise characterization of possible consequences of hypothetical updates, but <ref> [CD, DC] </ref> conclude that, usually, an approach as pursued in SLIC is more satisfying, because it is always simpler and most often more efficient than procedures which invest more effort in computing consequences of updates that "go through negation".) Back to [KM1, KM2] and SLDAI.
Reference: [De] <author> Decker. </author> <title> Integrity enforcement on deductive databases. </title> <booktitle> In Proc. Expert Database Systems, </booktitle> <year> 1987. </year>
Reference-contexts: Such extensions have been first proposed in Sadri & Kowalski's procedure [SK] for integrity checking upon insertions in definite databases. [SK], together with other procedures proposed in <ref> [De] </ref> and [LT], is a forerunner of SLIC.) Moreover, there is another, more intricate kind of forward reasoning which may complicate matters considerably. Complications arise if abduced hypotheses have to be propagated in forward direction through literals of opposed polarity, for generating negative hypothetical consequences. <p> Then, p is not derivable, but the hypothesis of :q (which overrides the presence of q, suggesting that q should be deleted) makes p derivable. Dealing head-on with the intricacies just outlined is responsible for lots of unpleasant complications encountered in procedures for integrity checking and view updating, e.g. <ref> [De, SK, DW, Ol] </ref> and others. As opposed to these procedures, SLIC and SLDAI adapt a much simpler kind of forward reasoning through literals of opposed polarity as proposed in [LT].
Reference: [D2] <author> Decker. </author> <title> Drawing updates from derivations. </title> <booktitle> In Proc. 3rd ICDT, </booktitle> <year> 1990. </year>
Reference-contexts: In simple cases, that can be done by tracing attempts to derive the request, and drawing updates from the reasons of failure of the attempts, as e.g., in <ref> [To, D2, GL, KM1, KM2] </ref>. This approach is complicated by the presence of integrity constraints which may invalidate updates drawn from failed derivations, and also by negation in the condition of database clauses, as observed in [D2]. <p> This approach is complicated by the presence of integrity constraints which may invalidate updates drawn from failed derivations, and also by negation in the condition of database clauses, as observed in <ref> [D2] </ref>. In [KM1, KM2], the abductive approach of processing negation by [EK] is extended to deal also with positive hypotheses, not just negative ones. The hypotheses correspond to the reasons of failure to derive the request and, when assumed to hold, contribute to make the request derivable.
Reference: [DTU] <author> Decker, Teniente, Urpi. </author> <title> How to tackle schema validation by view updating. </title> <booktitle> In Proc. 5th EDBT, </booktitle> <year> 1996. </year>
Reference-contexts: In comparison, SLDAI does better wrt computing existing solutions than other abductive procedures. No extension for reasoning with arbitrary first-order theories are needed for that. We briefly sketch how to use SLDAI for schema validation <ref> [DTU] </ref>. We argue that SLDAI has the potential for tackling abductive tasks which reach beyond a conventional database context.
Reference: [DW] <author> Das, Williams. </author> <title> A path-finding method for checking integrity in deductive databases. </title> <journal> Data and Knowledge Engineering, </journal> <volume> 4, </volume> <year> 1989. </year>
Reference-contexts: Then, p is not derivable, but the hypothesis of :q (which overrides the presence of q, suggesting that q should be deleted) makes p derivable. Dealing head-on with the intricacies just outlined is responsible for lots of unpleasant complications encountered in procedures for integrity checking and view updating, e.g. <ref> [De, SK, DW, Ol] </ref> and others. As opposed to these procedures, SLIC and SLDAI adapt a much simpler kind of forward reasoning through literals of opposed polarity as proposed in [LT].
Reference: [EK] <author> Eshghi, Kowalski. </author> <title> Abduction compared with negation by failure. </title> <booktitle> In Proc. 7th ICLP, </booktitle> <year> 1989. </year>
Reference-contexts: This approach is complicated by the presence of integrity constraints which may invalidate updates drawn from failed derivations, and also by negation in the condition of database clauses, as observed in [D2]. In [KM1, KM2], the abductive approach of processing negation by <ref> [EK] </ref> is extended to deal also with positive hypotheses, not just negative ones. The hypotheses correspond to the reasons of failure to derive the request and, when assumed to hold, contribute to make the request derivable. <p> SLDAI combines two lines of development. One has led to SLIC, a Selection-driven Linear resolution procedure based on SLDNF, for Integrity Checking in deductive databases [DC]. The other line of development has started with Eshghi & Kowalski's work <ref> [EK] </ref> on casting the negation-as-failure rule of SLDNF in an abductive framework, and has led to the abductive procedure for database updating by Kakas & Mancarella [KM1, KM2], and beyond. While [EK] is an example of default reasoning, [KM1, KM2] is one for reasoning with non-default hypotheses. <p> The other line of development has started with Eshghi & Kowalski's work <ref> [EK] </ref> on casting the negation-as-failure rule of SLDNF in an abductive framework, and has led to the abductive procedure for database updating by Kakas & Mancarella [KM1, KM2], and beyond. While [EK] is an example of default reasoning, [KM1, KM2] is one for reasoning with non-default hypotheses.
Reference: [GL] <author> Guessoum, Lloyd. </author> <title> Updating knowledge bases I/II. New Generation Computing, 8/10, 1990/1991. Hendrick Decker. View updating by abduction and integrity maintenance 5 </title>
Reference-contexts: In simple cases, that can be done by tracing attempts to derive the request, and drawing updates from the reasons of failure of the attempts, as e.g., in <ref> [To, D2, GL, KM1, KM2] </ref>. This approach is complicated by the presence of integrity constraints which may invalidate updates drawn from failed derivations, and also by negation in the condition of database clauses, as observed in [D2].
Reference: [KK] <author> Kowalski, Kuehner. </author> <title> Linear resolution with selection function. </title> <journal> Artificial Intelligence, </journal> <volume> 2, </volume> <year> 1971. </year>
Reference-contexts: in the head of a database clause in a derivation against a literal in the body of an input clause only involves a slight extension of the usual backward reasoning capabilities of SLD-like procedures, which is still far from the expensive generality of arbitrary first-order procedures such as SL resolution <ref> [KK] </ref> or SLY [CaD].
Reference: [KM1] <author> Kakas, Mancarella. </author> <title> Database updates through abduction. </title> <booktitle> In Proc. 16th VLDB, </booktitle> <year> 1990. </year>
Reference-contexts: In simple cases, that can be done by tracing attempts to derive the request, and drawing updates from the reasons of failure of the attempts, as e.g., in <ref> [To, D2, GL, KM1, KM2] </ref>. This approach is complicated by the presence of integrity constraints which may invalidate updates drawn from failed derivations, and also by negation in the condition of database clauses, as observed in [D2]. <p> This approach is complicated by the presence of integrity constraints which may invalidate updates drawn from failed derivations, and also by negation in the condition of database clauses, as observed in [D2]. In <ref> [KM1, KM2] </ref>, the abductive approach of processing negation by [EK] is extended to deal also with positive hypotheses, not just negative ones. The hypotheses correspond to the reasons of failure to derive the request and, when assumed to hold, contribute to make the request derivable. <p> The other line of development has started with Eshghi & Kowalski's work [EK] on casting the negation-as-failure rule of SLDNF in an abductive framework, and has led to the abductive procedure for database updating by Kakas & Mancarella <ref> [KM1, KM2] </ref>, and beyond. While [EK] is an example of default reasoning, [KM1, KM2] is one for reasoning with non-default hypotheses. An essential difference between SLDNF and procedures [KM1, KM2], SLIC, SLDAI is that clauses in denial form, by which integrity theories are represented, can (at least to a certain extent) <p> The other line of development has started with Eshghi & Kowalski's work [EK] on casting the negation-as-failure rule of SLDNF in an abductive framework, and has led to the abductive procedure for database updating by Kakas & Mancarella <ref> [KM1, KM2] </ref>, and beyond. While [EK] is an example of default reasoning, [KM1, KM2] is one for reasoning with non-default hypotheses. An essential difference between SLDNF and procedures [KM1, KM2], SLIC, SLDAI is that clauses in denial form, by which integrity theories are represented, can (at least to a certain extent) be taken into account as candidate input clauses by the latter, while <p> negation-as-failure rule of SLDNF in an abductive framework, and has led to the abductive procedure for database updating by Kakas & Mancarella <ref> [KM1, KM2] </ref>, and beyond. While [EK] is an example of default reasoning, [KM1, KM2] is one for reasoning with non-default hypotheses. An essential difference between SLDNF and procedures [KM1, KM2], SLIC, SLDAI is that clauses in denial form, by which integrity theories are represented, can (at least to a certain extent) be taken into account as candidate input clauses by the latter, while SLDNF only is able to deal with positive input clauses, i.e., normal database clauses with exactly <p> While SLDNF always reasons backward, denials may act as input clauses only if resolution proceeds forward. However, <ref> [KM1, KM2] </ref> takes integrity constraints into account only to a limited extent. [KM1, KM2] proceeds forward from hypotheses only in singular resolution steps, never by two or more forward steps in a row. <p> While SLDNF always reasons backward, denials may act as input clauses only if resolution proceeds forward. However, <ref> [KM1, KM2] </ref> takes integrity constraints into account only to a limited extent. [KM1, KM2] proceeds forward from hypotheses only in singular resolution steps, never by two or more forward steps in a row. Hence, indirect consequences of hypotheses are not considered, even though they may be as harmful wrt integrity as immediate consequences. <p> precise characterization of possible consequences of hypothetical updates, but [CD, DC] conclude that, usually, an approach as pursued in SLIC is more satisfying, because it is always simpler and most often more efficient than procedures which invest more effort in computing consequences of updates that "go through negation".) Back to <ref> [KM1, KM2] </ref> and SLDAI. In general, the [KM1, KM2] abductive framework is simplified and extended by SLDAI. User-defined integrity is maintained by each SLDAI-computed solution for satisfying some update request. <p> updates, but [CD, DC] conclude that, usually, an approach as pursued in SLIC is more satisfying, because it is always simpler and most often more efficient than procedures which invest more effort in computing consequences of updates that "go through negation".) Back to <ref> [KM1, KM2] </ref> and SLDAI. In general, the [KM1, KM2] abductive framework is simplified and extended by SLDAI. User-defined integrity is maintained by each SLDAI-computed solution for satisfying some update request.
Reference: [KM2] <author> Kakas, Mancarella. </author> <title> Knowledge assimilation and abduction. </title> <booktitle> In Proc. ECAI workshop on Truth Maintenance, </booktitle> <publisher> LNAI, </publisher> <year> 1990. </year>
Reference-contexts: In simple cases, that can be done by tracing attempts to derive the request, and drawing updates from the reasons of failure of the attempts, as e.g., in <ref> [To, D2, GL, KM1, KM2] </ref>. This approach is complicated by the presence of integrity constraints which may invalidate updates drawn from failed derivations, and also by negation in the condition of database clauses, as observed in [D2]. <p> This approach is complicated by the presence of integrity constraints which may invalidate updates drawn from failed derivations, and also by negation in the condition of database clauses, as observed in [D2]. In <ref> [KM1, KM2] </ref>, the abductive approach of processing negation by [EK] is extended to deal also with positive hypotheses, not just negative ones. The hypotheses correspond to the reasons of failure to derive the request and, when assumed to hold, contribute to make the request derivable. <p> The other line of development has started with Eshghi & Kowalski's work [EK] on casting the negation-as-failure rule of SLDNF in an abductive framework, and has led to the abductive procedure for database updating by Kakas & Mancarella <ref> [KM1, KM2] </ref>, and beyond. While [EK] is an example of default reasoning, [KM1, KM2] is one for reasoning with non-default hypotheses. An essential difference between SLDNF and procedures [KM1, KM2], SLIC, SLDAI is that clauses in denial form, by which integrity theories are represented, can (at least to a certain extent) <p> The other line of development has started with Eshghi & Kowalski's work [EK] on casting the negation-as-failure rule of SLDNF in an abductive framework, and has led to the abductive procedure for database updating by Kakas & Mancarella <ref> [KM1, KM2] </ref>, and beyond. While [EK] is an example of default reasoning, [KM1, KM2] is one for reasoning with non-default hypotheses. An essential difference between SLDNF and procedures [KM1, KM2], SLIC, SLDAI is that clauses in denial form, by which integrity theories are represented, can (at least to a certain extent) be taken into account as candidate input clauses by the latter, while <p> negation-as-failure rule of SLDNF in an abductive framework, and has led to the abductive procedure for database updating by Kakas & Mancarella <ref> [KM1, KM2] </ref>, and beyond. While [EK] is an example of default reasoning, [KM1, KM2] is one for reasoning with non-default hypotheses. An essential difference between SLDNF and procedures [KM1, KM2], SLIC, SLDAI is that clauses in denial form, by which integrity theories are represented, can (at least to a certain extent) be taken into account as candidate input clauses by the latter, while SLDNF only is able to deal with positive input clauses, i.e., normal database clauses with exactly <p> While SLDNF always reasons backward, denials may act as input clauses only if resolution proceeds forward. However, <ref> [KM1, KM2] </ref> takes integrity constraints into account only to a limited extent. [KM1, KM2] proceeds forward from hypotheses only in singular resolution steps, never by two or more forward steps in a row. <p> While SLDNF always reasons backward, denials may act as input clauses only if resolution proceeds forward. However, <ref> [KM1, KM2] </ref> takes integrity constraints into account only to a limited extent. [KM1, KM2] proceeds forward from hypotheses only in singular resolution steps, never by two or more forward steps in a row. Hence, indirect consequences of hypotheses are not considered, even though they may be as harmful wrt integrity as immediate consequences. <p> precise characterization of possible consequences of hypothetical updates, but [CD, DC] conclude that, usually, an approach as pursued in SLIC is more satisfying, because it is always simpler and most often more efficient than procedures which invest more effort in computing consequences of updates that "go through negation".) Back to <ref> [KM1, KM2] </ref> and SLDAI. In general, the [KM1, KM2] abductive framework is simplified and extended by SLDAI. User-defined integrity is maintained by each SLDAI-computed solution for satisfying some update request. <p> updates, but [CD, DC] conclude that, usually, an approach as pursued in SLIC is more satisfying, because it is always simpler and most often more efficient than procedures which invest more effort in computing consequences of updates that "go through negation".) Back to <ref> [KM1, KM2] </ref> and SLDAI. In general, the [KM1, KM2] abductive framework is simplified and extended by SLDAI. User-defined integrity is maintained by each SLDAI-computed solution for satisfying some update request.
Reference: [LT] <author> Lloyd, Topor. </author> <title> A basis for deductive database systems II. </title> <journal> J. Logic Programming, </journal> <volume> 3, </volume> <year> 1986. </year>
Reference-contexts: Such extensions have been first proposed in Sadri & Kowalski's procedure [SK] for integrity checking upon insertions in definite databases. [SK], together with other procedures proposed in [De] and <ref> [LT] </ref>, is a forerunner of SLIC.) Moreover, there is another, more intricate kind of forward reasoning which may complicate matters considerably. Complications arise if abduced hypotheses have to be propagated in forward direction through literals of opposed polarity, for generating negative hypothetical consequences. <p> As opposed to these procedures, SLIC and SLDAI adapt a much simpler kind of forward reasoning through literals of opposed polarity as proposed in <ref> [LT] </ref>. More precisely, for a hypothesis L and a clause A B with literal L 0 in B such that the atoms of L and L 0 unify but L and L 0 are of opposed polarity, SLIC infers the clause :A :A as a consequence.
Reference: [Ol] <author> Olive. </author> <title> Integrity constraints checking in deductive databases. </title> <booktitle> In Proc. 17th VLDB, </booktitle> <year> 1991. </year>
Reference-contexts: Then, p is not derivable, but the hypothesis of :q (which overrides the presence of q, suggesting that q should be deleted) makes p derivable. Dealing head-on with the intricacies just outlined is responsible for lots of unpleasant complications encountered in procedures for integrity checking and view updating, e.g. <ref> [De, SK, DW, Ol] </ref> and others. As opposed to these procedures, SLIC and SLDAI adapt a much simpler kind of forward reasoning through literals of opposed polarity as proposed in [LT].
Reference: [SK] <author> Sadri, </author> <title> Kowalski A theorem-proving approach to database integrity. </title> <editor> In : Minker (ed), </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <year> 1988. </year>
Reference-contexts: Such extensions have been first proposed in Sadri & Kowalski's procedure <ref> [SK] </ref> for integrity checking upon insertions in definite databases. [SK], together with other procedures proposed in [De] and [LT], is a forerunner of SLIC.) Moreover, there is another, more intricate kind of forward reasoning which may complicate matters considerably. <p> Such extensions have been first proposed in Sadri & Kowalski's procedure <ref> [SK] </ref> for integrity checking upon insertions in definite databases. [SK], together with other procedures proposed in [De] and [LT], is a forerunner of SLIC.) Moreover, there is another, more intricate kind of forward reasoning which may complicate matters considerably. <p> Then, p is not derivable, but the hypothesis of :q (which overrides the presence of q, suggesting that q should be deleted) makes p derivable. Dealing head-on with the intricacies just outlined is responsible for lots of unpleasant complications encountered in procedures for integrity checking and view updating, e.g. <ref> [De, SK, DW, Ol] </ref> and others. As opposed to these procedures, SLIC and SLDAI adapt a much simpler kind of forward reasoning through literals of opposed polarity as proposed in [LT].
Reference: [TK] <author> Toni, Kowalski. </author> <title> Reduction of abductive logic programs to normal logic programs. </title> <booktitle> In Proc. 12th ICLP, </booktitle> <year> 1995. </year>
Reference-contexts: It can be shown that SLDAI is sound wrt the strong notion of integrity satisfaction for classes that are broader than the class of stratified databases. With a transformation as described in <ref> [TK] </ref>, SLDAI is sound wrt all normal databases and requests (i.e., no restrictions whatsoever need to be imposed).
Reference: [TO] <author> Teniente, Olive. </author> <title> Updating knowledge bases while maintaining their consistency. </title> <journal> VLDB Journal, </journal> <volume> 4, </volume> <year> 1995. </year>
Reference-contexts: In simple cases, that can be done by tracing attempts to derive the request, and drawing updates from the reasons of failure of the attempts, as e.g., in <ref> [To, D2, GL, KM1, KM2] </ref>. This approach is complicated by the presence of integrity constraints which may invalidate updates drawn from failed derivations, and also by negation in the condition of database clauses, as observed in [D2]. <p> The procedure for computing view updates by Teniente & Olive' <ref> [TO] </ref> is, to our knowledge, the only one which does not depend on the selection function, but suffers from other drawbacks, not addressed in this abstract.) 4 Logic Databases and the Meaning of Change Another feature of SLDAI which sets it apart from other abductive procedures: The latter may assume new

Reference: [AGM85] <author> C. Alchourron, P Gardenfors, and D. Makinson. </author> <title> On the logic of theory change : Partial meet contraction and revision functions. </title> <journal> The journal of symbolic logic, </journal> <volume> 50(2), </volume> <year> 1985. </year>
Reference: [CD88] <author> F. Cuppens and R. Demolombe. </author> <title> Cooperative Answering: a methodology to provide intelligent access to Databases. </title> <booktitle> In Proc of Expert Database Systems, </booktitle> <year> 1988. </year>
Reference: [CD92] <author> S. Cazalens and R. Demolombe. </author> <title> Intelligent access to data and knowledge bases via users' topics of interest. </title> <booktitle> In Proceedings of IFIP Conference, </booktitle> <pages> pages 245-251, </pages> <year> 1992. </year>
Reference: [CD94] <author> L. Cholvy and R. Demolombe. </author> <title> Reasoning with information sources ordered by topics. </title> <booktitle> In Proceedings of Artificial Intelligence : Methods, Systems and Applications (AIMSA). World Scientific, </booktitle> <address> Sofia, </address> <month> september </month> <year> 1994. </year>
Reference: [CDJ94] <author> L. Cholvy, R. Demolombe, and A. Jones. </author> <title> Reasoning about the safety of information : from logical formalization to operational definition. </title> <booktitle> In Lecture notes in Artificial Intelligence, number 869. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [Cho93] <author> L. Cholvy. </author> <title> Proving theorems in a multi-sources environment. </title> <booktitle> In Proceedings of IJCAI, </booktitle> <pages> pages 66-71, </pages> <year> 1993. </year>
Reference: [Cho94] <author> L. Cholvy. </author> <title> A logical approach to multi-sources reasoning. </title> <booktitle> In Lecture notes in Artificial Intelligence, number 808. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [Cho95] <author> L. Cholvy. </author> <title> Automated reasoning with merged contradictory information whose reliability depends on topics. </title> <booktitle> In Proceedings of the European Conference on Symbolic and Quantitative Approaches to Reasoning and Uncertainty (ECSQARU), Fribourg, </booktitle> <month> July </month> <year> 1995. </year>
Reference: [Cho96] <author> L. Cholvy. </author> <title> Answering queries addressed to a group of deductive databases. In Workshop on flexible query-answering. </title> <institution> Roskilde University, </institution> <year> 1996. </year>
Reference: [FKUV86] <author> R. Fagin, G. Kupper, J. Ullman, and M. Vardi. </author> <title> Updating logical databases. </title> <booktitle> Advances in Computing Research, </booktitle> <volume> 3, </volume> <year> 1986. </year>
Reference: [FUV83] <author> R. Fagin, J.D. Ullman, and M. Vardi. </author> <title> On the semantics of updates in databases. </title> <journal> In ACM TODS, </journal> <pages> pages 352-365, </pages> <year> 1983. </year>
Reference: [Gar88] <author> P. Gardenfors. </author> <title> Knowledge in Flux : Modeling the Dynamics of Epistemic States. </title> <publisher> The MIT Press, </publisher> <year> 1988. </year>
Reference: [GM92] <author> P. Gardenfors and D. Makinson. </author> <title> Nonmonotonic inference based on expectations. </title> <journal> Artificial Intelligence, </journal> <note> to appear, </note> <year> 1992. </year>
Reference: [GMN78] <editor> H. Gallaire, J. Minker, and J.M. Nicolas. </editor> <title> An overview and introduction to logic and database. </title> <publisher> Plenum, </publisher> <year> 1978. </year>
Reference: [GMN84] <editor> H. Gallaire, J. Minker, and J. M. Nicolas. </editor> <title> Logic and databases : a deductive approach. </title> <journal> ACM Surveys, </journal> <volume> 16(2), </volume> <year> 1984. </year>
Reference: [HC72] <author> G. E. Hughes and M. J. Cresswell. </author> <title> An introduction to modal logic. </title> <address> Methren London and New York, </address> <year> 1972. </year>
Reference: [JD94] <author> A. Jones and R. Demolombe. </author> <title> Deriving answers to safety queries. </title> <editor> In R. Demolombe and T. Imielin-ski, editors, </editor> <title> Non standard queries and answers. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference: [KM91] <author> H. Katsuno and A. Mendelzon. </author> <title> Propositional knowledge base revision and minimal change. </title> <journal> Artificial Intelligence, </journal> <volume> 52, </volume> <year> 1991. </year>
Reference: [MS86] <author> J. P. Martins and S. C. Shapiro. </author> <title> Theoretical foundations for belief revision. </title> <booktitle> In Reasoning about knowledge, </booktitle> <year> 1986. </year>
Reference: [Neb89] <author> B. Nebel. </author> <title> A knowledge level analysis of belief revision. </title> <booktitle> In Proc of KR'89, </booktitle> <year> 1989. </year>
Reference: [Rei84] <author> R. Reiter. </author> <title> Towards a logical reconstruction of relational database theory, chapter 8. </title> <publisher> Springer Verlag, </publisher> <year> 1984. </year>
Reference: [Som94] <author> Lea Sombe. </author> <title> A glance at revision and updating in knowledge bases. </title> <journal> International Journal of Intelligent Systems, </journal> <volume> 9(1), </volume> <year> 1994. </year>
References-found: 40

