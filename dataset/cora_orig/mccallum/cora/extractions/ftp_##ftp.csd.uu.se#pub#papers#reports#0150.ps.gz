URL: ftp://ftp.csd.uu.se/pub/papers/reports/0150.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: email: fdantsin,voronkovg@csd.uu.se  
Title: Set Unification  
Author: Evgeny Dantsin Andrei Voronkov 
Address: Fontanka 27, St.Petersburg 191011 Russia  Box 311, S-751 05 Uppsala Sweden  
Affiliation: Steklov Institute of Mathematics at St.Petersburg  Computing Science Department Uppsala University  
Note: Bag and  Supported by grants from the Swedish Royal Academy of Sciences, the Swedish Institute and INTAS/RFBR. Supported by a TFR grant.  
Abstract: UPMAIL Technical Report No. 150 November 27, 1997 
Abstract-found: 1
Intro-found: 1
Reference: <author> Abiteboul, S. & Beeri, C. </author> <year> (1995), </year> <title> `The power of languages for the manipulation of complex values', </title> <journal> VLDB Journal 4, </journal> <pages> 727-794. </pages>
Reference-contexts: The rest of the proof is similar. 2 Again, this subdomain is a minimal domain for which unifiability is NP-hard. 7.2 A typed universe We shall present a typed universe for complex values containing bags and finite sets following <ref> (Abiteboul & Beeri 1995) </ref>. The domain of (Abiteboul & Beeri 1995) does not contain bags but we add them in a natural way. <p> The rest of the proof is similar. 2 Again, this subdomain is a minimal domain for which unifiability is NP-hard. 7.2 A typed universe We shall present a typed universe for complex values containing bags and finite sets following <ref> (Abiteboul & Beeri 1995) </ref>. The domain of (Abiteboul & Beeri 1995) does not contain bags but we add them in a natural way.
Reference: <author> Abiteboul, S. & Grumbach, S. </author> <year> (1988), </year> <title> Col: A logic-based language for complex objects, </title> <editor> in J. Schmidt, S. Ceri & M. Missikoff, eds, </editor> <booktitle> `Advances in Database Technology - EDBT'88. Proceedings of the International Conference on Extending Database Technology', Vol. 303 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <address> Venice, Italy, </address> <pages> pp. 271-293. </pages>
Reference: <author> Abiteboul, S. & Grumbach, S. </author> <year> (1991), </year> <title> `A rule-based language with functions and sets', </title> <journal> ACM Transactions on Database Systems 16(1), </journal> <pages> 1-30. </pages>
Reference: <author> Aiken, A. </author> <year> (1992), </year> <title> Set constraints: Results, applications and future directions, </title> <booktitle> in `Proceedings of the Workshop on Principles and Practice of Constraint Programming', Vol. 874 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pp. 326-335. </pages>
Reference: <author> Apt, K. </author> <year> (1990), </year> <title> Logic programming, </title> <editor> in J. Van Leeuwen, ed., </editor> <booktitle> `Handbook of Theoretical Computer Science', </booktitle> <volume> Vol. </volume> <editor> B: </editor> <title> Formal Methods and Semantics, </title> <publisher> Elsevier Science, </publisher> <address> Amsterdam, chapter 10, </address> <pages> pp. 493-574. </pages>
Reference: <author> Baader, F. & Siekmann, J. </author> <year> (1994), </year> <title> Unification theory, </title> <editor> in D. Gabbay, C. Hogger & J. Robinson, eds, </editor> <booktitle> `Handbook of Logic in Artificial Intelligence and Logic Programming', </booktitle> <publisher> Oxford University Press. </publisher>
Reference-contexts: Complete sets of unifiers provide an alternative to constraints when complete sets of unifiers have a good structure (for example, when they are finite and have a small number of members). In this section we shall investigate the structure of complete sets of unifiers. It is well known <ref> (Baader & Siekmann 1994) </ref> that if a system S has a finite complete set of minimal unifiers consisting of n members then we have: 1. Any complete set of unifiers has at least n members. 22 Section 5.1. Unifiers for D computed by the algorithm 2.
Reference: <author> Bachmair, L., Ganzinger, H. & Waldmann, U. </author> <year> (1993), </year> <title> Set constraints are the monadic class, </title> <booktitle> in `Proc. IEEE Conference on Logic in Computer Science (LICS)', </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 75-83. </pages>
Reference: <author> Beeri, C. & Kornatzky, Y. </author> <year> (1994), </year> <title> `A logical query language for hypermedia systems', </title> <booktitle> Information Sciences 77, </booktitle> <pages> 1-38. </pages>
Reference: <author> Beeri, C., Naqvi, S., Schmueli, O. & Tsur, S. </author> <year> (1991), </year> <title> `Set constructors in a logic database language', </title> <journal> Journal of Logic Programming 10, </journal> <pages> 181-232. </pages>
Reference: <author> Boudet, A., Contejean, E. & Marce, C. </author> <year> (1996), </year> <title> AC-complete unification and its application to theorem proving, </title> <editor> in H. Ganzinger, ed., </editor> <booktitle> `7th International Conference on Rewriting Techniques and Applications', Vol. 1103 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pp. 18-32. </pages>
Reference: <author> Charatonic, W. & Podelski, A. </author> <year> (1997), </year> <title> Set constraints with intersection, </title> <editor> in G. Winskel, ed., </editor> <booktitle> `Proc. IEEE Conference on Logic in Computer Science (LICS)', </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pp. 362-372. </pages> <note> 42 BIBLIOGRAPHY Dantsin, </note> <author> E. & Voronkov, A. </author> <year> (1997a), </year> <title> Complexity of query answering in logic databases with complex values, </title> <editor> in S. Adian & A. Nerode, eds, </editor> <booktitle> `Logical Foundations of Computer Science. 4th International Symposium, LFCS'97', Vol. 1234 of Lecture Notes in Computer Science, </booktitle> <address> Yaroslavl, Russia, </address> <pages> pp. 56-66. </pages>
Reference: <author> Dantsin, E. & Voronkov, A. </author> <year> (1997b), </year> <title> Complexity of query answering in logic databases with complex data, </title> <type> UPMAIL Technical Report 149, </type> <institution> Uppsala University, Computing Science Department. </institution>
Reference-contexts: Our results can be used to implement logic programs and deductive databases working with bags, finite sets and trees. Another application of our results is the characterization of complexity for nonrecursive Horn clause logic programs over bags and/or finite sets and/or trees. In <ref> (Dantsin & Voronkov 1997b) </ref> we proved the following result. If equation solving over a domain is in NP, then the complexity of nonrecursive Horn clause logic programs over this domain is in NEXPTIME (see (Dantsin & Voronkov 1997b) for precise definitions). This, together with another result of (Dantsin & Voronkov 1997b) <p> In <ref> (Dantsin & Voronkov 1997b) </ref> we proved the following result. If equation solving over a domain is in NP, then the complexity of nonrecursive Horn clause logic programs over this domain is in NEXPTIME (see (Dantsin & Voronkov 1997b) for precise definitions). This, together with another result of (Dantsin & Voronkov 1997b) proves that the complexity of nonrecursive logic programs over bags and/or sets and/or trees is NEXPTIME-complete. <p> In <ref> (Dantsin & Voronkov 1997b) </ref> we proved the following result. If equation solving over a domain is in NP, then the complexity of nonrecursive Horn clause logic programs over this domain is in NEXPTIME (see (Dantsin & Voronkov 1997b) for precise definitions). This, together with another result of (Dantsin & Voronkov 1997b) proves that the complexity of nonrecursive logic programs over bags and/or sets and/or trees is NEXPTIME-complete. It is interesting to consider constraint logic programming over bags and finite sets which uses more powerful primitives than just the bag and set constructors.
Reference: <author> Dovier, A., Omodeo, E., Pontelli, E. & Rossi, G. </author> <year> (1996), </year> <title> `flogg: A language for programming in logic with finite sets', </title> <journal> Journal of Logic Programming 28(1), </journal> <pages> 1-44. </pages>
Reference-contexts: A unification algorithm for a domain containing bags, finite sets and trees together is presented. Unification algorithms for finite sets have been discussed in the literature: (Kapur & Narendran 1986) investigated flat finite sets, <ref> (Dovier et al. 1996) </ref> investigated so-called colored sets). As far as we know, unification algorithms for bags have not been described previously 1 . 2. The unifiability problem for D is NP-complete. As a consequence, we prove that the bag unifiability and the finite set unifiability problems are NP-complete. <p> NP-completeness of the finite set unifiability problem for flat sets (i.e. sets whose members are non-set terms) is proved in (Kapur & Narendran 1986). NP-completeness for a domain containing hereditarily finite sets (i.e. the domain allowing for sets of sets of sets etc.) is claimed in <ref> (Dovier et al. 1996) </ref>. However, their paper presents no proof of membership in NP 2 . <p> However, their paper presents no proof of membership in NP 2 . We consider related work throughout the paper and also in Section 8. 1 Incorporating bags in a logic programming language is stated as an open problem in <ref> (Dovier et al. 1996, page 34) </ref>. 2 We cite (Dovier et al. 1996, page 10): "we refer the interested reader to (Kapur & Narendran 1986) for a similar and easily adaptable proof." (Kapur & Narendran 1986) prove NP-completeness of set unifiability for flat sets, i.e. sets whose members are non-set terms. <p> However, their paper presents no proof of membership in NP 2 . We consider related work throughout the paper and also in Section 8. 1 Incorporating bags in a logic programming language is stated as an open problem in (Dovier et al. 1996, page 34). 2 We cite <ref> (Dovier et al. 1996, page 10) </ref>: "we refer the interested reader to (Kapur & Narendran 1986) for a similar and easily adaptable proof." (Kapur & Narendran 1986) prove NP-completeness of set unifiability for flat sets, i.e. sets whose members are non-set terms. <p> Application of the algorithm is illustrated by some examples in Section 6. Our algorithm can be optimized in several ways, but such optimizations are beyond the scope of our paper. The set unification algorithm presented in this paper is slightly more sophisticated than the one of <ref> (Dovier et al. 1996) </ref>. The unification algorithm of (Dovier et al. 1996) does not establish NP-completeness of the set unifiability problem: the algorithm is nondeterministic and the termination proof for any nondeterministically chosen branch uses a lexicographic well-ordering and may give branches of exponential depth. <p> Our algorithm can be optimized in several ways, but such optimizations are beyond the scope of our paper. The set unification algorithm presented in this paper is slightly more sophisticated than the one of <ref> (Dovier et al. 1996) </ref>. The unification algorithm of (Dovier et al. 1996) does not establish NP-completeness of the set unifiability problem: the algorithm is nondeterministic and the termination proof for any nondeterministically chosen branch uses a lexicographic well-ordering and may give branches of exponential depth. Section 5.2 contains a more detailed comparison of these algorithms. <p> This set has 2 n 2 members. Hence, any complete set of unifiers for this equation has at least 2 n 2 members. 5.2 Comparison with Dovier et.al. Although our algorithm has much in common with the one described in <ref> (Dovier et al. 1996) </ref>, it has some essential differences. First, we show that our algorithm is "optimal", at least for a certain kind of equations. <p> Proof. Similar to Lemma 5.7. 2 In some case it is possible to calculate the cardinality of a complete set of minimal unifiers. We shall consider some simple set unification problems and compare the numbers of unifiers computed by our algorithm and the algorithm of <ref> (Dovier et al. 1996) </ref>. Lemma 5.9 Let X and Y be sequences consisting of m and n variables respectively, all pairwise different. <p> Then the number D m;n of different set correspondences between X and Y can be calculated as D m;n = &gt; &gt; &gt; &lt; 1; if m = 1; 1 + k=0 l=1 m 1 l D mk1;nl if m; n 2: The algorithm of <ref> (Dovier et al. 1996) </ref> on the input fx 1 ; : : : ; x m g = fy 1 ; : : : ; y n g returns D m;n unifiers that are most general unifiers for all set correspondences between x 1 ; : : : ; x m <p> Examples 5.5 and 5.6 also hold for T . This proves part 3. 2 7.3 A colored universe In this section we consider a domain for bags, finite sets and trees that is completely type-free. This domain extends to bags the domain of colored sets introduced in <ref> (Dovier et al. 1996) </ref>. Having a set constructor and other function symbol in a completely type-free language causes the following problem. Since the language is type-free, we have to admit terms of the form fs j tg, where t is an arbitrary term, not necessarily denoting a set. <p> Consider any ground term fs 1 ; : : : ; s n j tg, where t does not denote a set. In <ref> (Dovier et al. 1996) </ref> such a term t is called a color and the corresponding set value is called a colored set with elements s 1 ; : : : ; s n and color t. Two colored sets are equal when they have the same colors and same elements. <p> To modify the unification algorithm for colored bags and sets, no serious changes are needed. Section 8 Conclusion, related work and future research We have already considered some related works, especially <ref> (Dovier et al. 1996) </ref>, throughout the paper. In this section we also briefly mention other related work. Our results can be used to implement logic programs and deductive databases working with bags, finite sets and trees.
Reference: <author> Fortenbacher, A. </author> <year> (1987), </year> <title> `An algebraic approach to unification under associativity and commuta-tivity', </title> <journal> Journal of Symbolic Computations 3(3), </journal> <pages> 217-229. </pages>
Reference: <author> Gallier, J. & Raatz, S. </author> <year> (1989), </year> <title> `Extending SLD-resolution to equational Horn clauses using E-unification', </title> <journal> Journal of Logic Programming 6(3), </journal> <pages> 3-44. </pages>
Reference-contexts: Complete sets of unifiers can be used in the operational semantics of logic programming with complex values instead of constraint SLD-resolution in the following way. We modify SLD-resolution to use unifiers from a complete set instead of the most general unifier, for details see <ref> (Gallier & Raatz 1989) </ref>. Complete sets of unifiers provide an alternative to constraints when complete sets of unifiers have a good structure (for example, when they are finite and have a small number of members). In this section we shall investigate the structure of complete sets of unifiers.
Reference: <author> Grumbach, S. & Vianu, V. </author> <year> (1995), </year> <title> `Tractable query languages for complex object databases', </title> <journal> Journal of Computer and System Sciences 51(2), </journal> <pages> 149-167. </pages>
Reference: <author> Kanella kis, P., Kuper, G. & Revesz, P. </author> <year> (1995), </year> <title> `Constraint query languages', </title> <journal> Journal of Computer and System Sciences 51, </journal> <pages> 26-52. </pages>
Reference: <author> Kapur, D. & Narendran, P. </author> <year> (1986), </year> <title> NP-completeness of the set unification and matching problems, </title> <editor> in J. Siekmann, ed., </editor> <booktitle> `Proc. 8th CADE', Vol. 230 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 489-495. </pages>
Reference-contexts: The following novelties are introduced in our paper compared to other papers in the area: 1. A unification algorithm for a domain containing bags, finite sets and trees together is presented. Unification algorithms for finite sets have been discussed in the literature: <ref> (Kapur & Narendran 1986) </ref> investigated flat finite sets, (Dovier et al. 1996) investigated so-called colored sets). As far as we know, unification algorithms for bags have not been described previously 1 . 2. The unifiability problem for D is NP-complete. <p> The unifiability problem for D is NP-complete. As a consequence, we prove that the bag unifiability and the finite set unifiability problems are NP-complete. NP-completeness of the finite set unifiability problem for flat sets (i.e. sets whose members are non-set terms) is proved in <ref> (Kapur & Narendran 1986) </ref>. NP-completeness for a domain containing hereditarily finite sets (i.e. the domain allowing for sets of sets of sets etc.) is claimed in (Dovier et al. 1996). However, their paper presents no proof of membership in NP 2 . <p> We consider related work throughout the paper and also in Section 8. 1 Incorporating bags in a logic programming language is stated as an open problem in (Dovier et al. 1996, page 34). 2 We cite (Dovier et al. 1996, page 10): "we refer the interested reader to <ref> (Kapur & Narendran 1986) </ref> for a similar and easily adaptable proof." (Kapur & Narendran 1986) prove NP-completeness of set unifiability for flat sets, i.e. sets whose members are non-set terms. It is hardly possible to adapt their proof to hereditarily finite sets at all. <p> in Section 8. 1 Incorporating bags in a logic programming language is stated as an open problem in (Dovier et al. 1996, page 34). 2 We cite (Dovier et al. 1996, page 10): "we refer the interested reader to <ref> (Kapur & Narendran 1986) </ref> for a similar and easily adaptable proof." (Kapur & Narendran 1986) prove NP-completeness of set unifiability for flat sets, i.e. sets whose members are non-set terms. It is hardly possible to adapt their proof to hereditarily finite sets at all. <p> Theorem 4.9 The problem of solvability of constraints over D is NP-complete. Proof. NP-hardness follows from <ref> (Kapur & Narendran 1986) </ref>. NP-completeness is a straightforward consequence of the soundness and completeness of our algorithm. 2 20 Section 4.2. Rules We shall prove similar results for other domains in Section 7. Application of the algorithm is illustrated by some examples in Section 6. <p> Lemma 7.1 The unifiability problem is NP-hard already for the subdomain of D consisting of sets of flat terms. Proof. The proof is similar to the one given in <ref> (Kapur & Narendran 1986) </ref>. We shall use reduction of the 3-SAT problem which can be described as follows. A literal is either x = t or x = f. A 3-clause is a multiset consisting of three literals.
Reference: <author> Kuper, G. </author> <year> (1990), </year> <title> `Logic programming with sets', </title> <journal> Journal of Computer and System Sciences 41, </journal> <pages> 44-64. </pages>
Reference: <author> Leone, N. & Rullo, P. </author> <year> (1993), </year> <title> `Ordered logic programming with sets', </title> <journal> Journal of Logic and Computation 3(6), </journal> <pages> 621-642. </pages>
Reference: <author> Lincoln, P. & Christian, J. </author> <year> (1989), </year> <title> `Adventures in associative-commutative unification (a summary)', </title> <journal> Journal of Symbolic Computations 8(1/2), </journal> <pages> 217-240. </pages>
Reference: <author> Lloyd, J. </author> <year> (1987), </year> <booktitle> Foundations of Logic Programming (2nd edition), </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: A logic program over D is a finite set of Horn clauses. A Herbrand model of a logic program P over D is any model of P that is a Herbrand model. The following statement is a straightforward generalization of the standard facts of logic programming theory <ref> (Lloyd 1987, Apt 1990) </ref>: Theorem 3.1 Any logic program over D has the least Herbrand model. As usual, the least Herbrand model can be constructed using a suitable fixpoint operator. <p> The proof of this statement is a straightforward generalization of the standard completeness proofs in logic programming and constraint logic programming <ref> (Lloyd 1987, Apt 1990, Maher 1992, Maher 1993) </ref>. Section 4 Unification algorithm In this section we introduce a unification algorithm for D. The algorithm is presented as a nondeterministic constraint satisfaction algorithm whose work consists of repeated applications of transformation rules.
Reference: <author> Maher, M. </author> <year> (1992), </year> <title> A CLP view of logic programming, </title> <booktitle> in `Proc. Conf. on Algebraic and Logic Programming', Vol. 632 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 364-383. </pages>
Reference-contexts: The standard way is to use a modification of SLD-resolution. Instead of defining SLD-resolution using substitutions, we shall define constraint SLD-resolution similar to <ref> (Maher 1992, Maher 1993) </ref>. Evgeny Dantsin and Andrei Voronkov. Bag and set unification 9 Let ' be any formula whose free variables are x 1 ; : : : ; x n .
Reference: <author> Maher, M. </author> <year> (1993), </year> <title> A logic programming view of CLP, </title> <booktitle> in `International Conference on Logic Programming', </booktitle> <pages> pp. 737-753. </pages>
Reference: <author> Martelli, A. & Montanari, U. </author> <year> (1982), </year> <title> `An efficient unification algorithm', </title> <journal> ACM Transactions on Programming Languages and Systems 4(2), </journal> <pages> 258-282. </pages>
Reference-contexts: Remove the equation z = f (x 1 ; : : : ; x n ) from S and reduce S using x 1 = y 1 ; : : : ; x n = y n . (This rule is close to the term decomposition rule of <ref> (Martelli & Montanari 1982) </ref>). 16 Section 4.2. Rules Rule 2 (Bag Decomposition) The rule can be applied to a system S if the system contains bag equations z = s and z = t, where s and t are different.
Reference: <author> McAllister, D., Givan, R., Witty, C. & Kozen, D. </author> <year> (1996), </year> <title> Tarskian set constraints, </title> <booktitle> in `Proc. IEEE Conference on Logic in Computer Science (LICS)', </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> New Brunswick, New Jersey, </address> <pages> pp. 138-147. </pages>
Reference: <author> Pacholski, L. & Podelski, A. </author> <year> (1997), </year> <title> Set constraints: a pearl in research on constraints, </title> <editor> in G. Smolka, ed., </editor> <booktitle> `Proceedings of the Third International Conference on Constraint Programming', number 1330 in `Lecture Notes in Computer Science'. </booktitle>
Reference-contexts: constraints have recently received a considerable attention in connection with program verification, but mostly for infinite sets and constraints that are less relevant to databases or logic programs, see e.g. (Aiken 1992, Bachmair, Ganzinger & Waldmann 1993, McAllister, Givan, Witty & Kozen 1996, Charatonic & Podelski 1997) and the survey <ref> (Pacholski & Podelski 1997) </ref>). Results on AC- and ACI-unification are relevant to this problem but not immediately applicable, see (Stickel 1981, Fortenbacher 1987, Lincoln & Christian 1989, Boudet, Contejean & Marce 1996).
Reference: <author> Evgeny Dantsin and Andrei Voronkov. </author> <title> Bag and set unification 43 Paterson, </title> <editor> M. & Wegman, M. </editor> <year> (1978), </year> <title> `Linear unification', </title> <journal> Journal of Computer and System Sciences 16, </journal> <pages> 158-167. </pages>
Reference: <author> Shmueli, O., Tsur, S. & Zaniolo, C. </author> <year> (1992), </year> <title> `Compilation of set terms in the logic data language (LDL)', </title> <journal> Journal of Logic Programming 12(1), </journal> <pages> 89-119. </pages>
Reference: <author> Stickel, M. </author> <year> (1981), </year> <title> `A complete unification algorithm for associative-commutative functions', </title> <journal> Journal of the Association for Computing Machinery 28(3), </journal> <pages> 423-434. </pages>
Reference: <author> Stolzenburg, F. </author> <year> (1996), </year> <title> Membership-constraints and complexity in logic programming with sets, </title> <editor> in F. Baader & K. Schulz, eds, </editor> <booktitle> `Frontiers in Combining Systems', </booktitle> <publisher> Kluwer Academic, </publisher> <pages> pp. 285-302. </pages>
Reference-contexts: For examples, what is the complexity of constraint satisfaction when we also have primitives like [ or ? An algorithm for extended constraints is given in <ref> (Stolzenburg 1996) </ref> but only for a limited special case of flat finite sets and without the complexity analysis of constraint satisfiability.
Reference: <author> Vadaparty, K. </author> <year> (1991), </year> <title> On the power of rule-based languages with sets, </title> <booktitle> in `ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems', </booktitle> <pages> pp. 26-36. </pages>
Reference: <author> Voronkov, A. </author> <year> (1992), </year> <title> Logic programming with bounded quantifiers, </title> <editor> in A. Voronkov, ed., </editor> <booktitle> `Logic Programming', Vol. 592 of Lecture Notes in Artificial Intelligence, </booktitle> <publisher> Springer Verlag, </publisher> <pages> pp. 486-514. </pages>
Reference: <author> Voronkov, A. </author> <year> (1997), </year> <title> Logic programming with bounded quantifiers revisited, </title> <type> UPMAIL Technical Report 114, </type> <institution> Uppsala University, Computing Science Department. </institution>
References-found: 34

