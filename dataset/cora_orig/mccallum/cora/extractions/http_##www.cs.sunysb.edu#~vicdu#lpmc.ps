URL: http://www.cs.sunysb.edu/~vicdu/lpmc.ps
Refering-URL: http://www.cs.sunysb.edu/~vicdu/
Root-URL: http://www.cs.sunysb.edu
Title: Logic Programming and Model Checking  
Author: Baoqiu Cui, Yifei Dong, Xiaoqun Du, K. Narayan Kumar, C. R. Ramakrishnan, I. V. Ramakrishnan, Abhik Roychoudhury, Scott A. Smolka, David S. Warren 
Web: http://www.cs.sunysb.edu/~lmc  
Address: NY 11794-4400, USA  
Affiliation: Department of Computer Science SUNY at Stony Brook Stony Brook,  
Abstract: We report on the current status of the LMC project, which seeks to deploy the latest developments in logic-programming technology to advance the state of the art of system specification and verification. In particular, the XMC model checker for value-passing CCS and the modal mu-calculus is discussed, as well as the XSB tabled logic programming system, on which XMC is based. Additionally, several ongoing efforts aimed at extending the LMC approach beyond traditional finite-state model checking are considered, including compositional model checking, the use of explicit induction techniques to model check parameterized systems, and the model checking of real-time systems. Finally, after a brief conclusion, future research directions are identified. 
Abstract-found: 1
Intro-found: 1
Reference: [ACD93] <author> R. Alur, C. Courcoubetis, and D. Dill. </author> <title> Model-checking for real-time systems. </title> <journal> Information and Computation, </journal> <volume> 104(1) </volume> <pages> 2-34, </pages> <year> 1993. </year>
Reference-contexts: A state of a timed automaton comprises a location and an assignment of values to clock variables. Clearly, since clocks range over infinite domains, timed automata are infinite-state automata. Real-time extensions to temporal logics, such as timed extensions of the modal mu-calculus <ref> [ACD93, HNSY94, SS95] </ref>, are used to specify the properties of interest. Traditional model-checking algorithms do not directly work in the case of real-time systems since the underlying state-space is infinite. The key then is to consider only finitely many regions of the state space.
Reference: [AD94] <author> R. Alur and D. Dill. </author> <title> The theory of timed automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 126(2), </volume> <year> 1994. </year>
Reference-contexts: Most embedded systems such as avionics boxes and medical devices are required to satisfy certain timing constraints, and real-time system specifications allow a system designer to explicitly capture these constraints. Real-time systems are often specified as timed automata <ref> [AD94] </ref>. A timed automaton consists of a set of locations (analogous to states in a finite automaton), and a set of edges between locations denoting transitions. Locations as well as transitions may be decorated with constraints on clocks. An example of a timed automaton appears in Figure 6. <p> Traditional model-checking algorithms do not directly work in the case of real-time systems since the underlying state-space is infinite. The key then is to consider only finitely many regions of the state space. In <ref> [AD94] </ref> it is shown that when the constraints on clocks are restricted to those of the form X &lt; Y + c where X and Y are clock variables and c is a constant, the state space of a timed automaton can be partitioned into finitely many stable regions|sets of indistinguishable
Reference: [AH96] <editor> R. Alur and T. A. Henzinger, editors. </editor> <booktitle> Computer Aided Verification (CAV '96), volume 1102 of Lecture Notes in Computer Science, </booktitle> <address> New Brunswick, New Jersey, July 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference: [ASW94] <author> H. R. Andersen, C. Stirling, and G. Winskel. </author> <title> A compositional proof system for the modal mu-calculus. </title> <booktitle> In Proceedings of the Ninth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 144-153, </pages> <address> Paris, France, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: Andersen, Stirling and Winskel <ref> [ASW94] </ref> present an elegant compositional proof system for the verification of processes defined in a synchronous process calculus similar to Milner's SCCS [Mil83] with respect to properties expressed in the modal mu-calculus. A useful feature of their system is the algorithmic nature of the rules. <p> Both of these sources of nondeterminism are unavoidable. In this respect, it differs from many systems reported in literature which require a clever choice of intermediate assertions to guide the choice of rules. Andersen et al. in <ref> [ASW94] </ref> also present an encoding of CCS into their synchronous process calculus and consequently it is possible to use their proof system to verify CCS processes. This encoding, however, has two disadvantages. <p> Our system retains the algorithmic nature of their system, yet incorporates the CCS parallel composition operator and avoids the costly alphabet blowup. This adaptation is achieved by providing rules at three levels as opposed to two in <ref> [ASW94] </ref>. The first level deals with processes that are not in the scope of a parallel composition operator, the second for processes in the scope of a parallel composition operator, and the third for processes appearing in the scope of relabeling and parallel composition operators. <p> Performance evaluation is ongoing. Our compositional system can indeed provide proofs for properties of partially defined processes as illustrated by the following example from <ref> [ASW94] </ref>. Let p ::= (tau o p) # T and q ::= (tau o q) # T where T is an unspecified process. The formula x += box (tau, x) expresses the impossibility of divergence.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252. </pages> <publisher> ACM Press, </publisher> <year> 1977. </year>
Reference-contexts: Additional efficiency and ease-of-use issues are worthy of future investigation. First, since model checkers are specified at the level of semantic equations, equations of abstract semantics <ref> [CC77] </ref> can be encoded with equal ease. These can be used to incorporate process and formula abstractions, which have been used successfully to ameliorate state explosion in model checking [Dam96], into an LMC-style model checker.
Reference: [CE81] <author> E. M. Clarke and E. A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching-time temporal logic. </title> <editor> In D. Kozen, editor, </editor> <booktitle> Proceedings of the Workshop on Logic of Programs, </booktitle> <address> Yorktown Heights, </address> <booktitle> volume 131 of Lecture Notes in Computer Science, </booktitle> <pages> pages 52-71. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: The ESS program director is Dr. William W. Agresti. The current primary focus of our ESS grant is model checking <ref> [CE81, QS82, CES86] </ref>, the problem of determining whether a system specification possesses a property expressed as a temporal logic formula. Model checking has enjoyed wide success in verifying, or finding design errors in, real-life systems. An interesting account of a number of these success stories can be found in [CW96b].
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM TOPLAS, </journal> <volume> 8(2), </volume> <year> 1986. </year>
Reference-contexts: The ESS program director is Dr. William W. Agresti. The current primary focus of our ESS grant is model checking <ref> [CE81, QS82, CES86] </ref>, the problem of determining whether a system specification possesses a property expressed as a temporal logic formula. Model checking has enjoyed wide success in verifying, or finding design errors in, real-life systems. An interesting account of a number of these success stories can be found in [CW96b].
Reference: [CLSS96] <author> R. Cleaveland, P. M. Lewis, S. A. Smolka, and O. Sokolsky. </author> <title> The Concurrency Factory: A development environment for concurrent systems. </title> <booktitle> In Alur and Henzinger [AH96], </booktitle> <pages> pages 398-401. </pages>
Reference-contexts: An interesting account of a number of these success stories can be found in [CW96b]. We call our approach to model checking logic-programming-based model checking, or LMC for short, and it is centered on two large software systems developed independently at SUNY Stony Brook: the Concurrency Factory <ref> [CLSS96] </ref> and ? Research supported in part by NSF grants CDA-9303181, CCR-9404921, CCR-9505562, CDA-9504275, CCR-9705998, CCR-9711386 and AFOSR grants F49620-95-1-0508 and F49620-96-1-0087. 1 There are two additional co-Principal Investigators on the grant who are no longer at Stony Brook: Y.S. <p> With regard to the efficiency issue, XMC is highly competitive with state-of-the-art model checkers hand-coded in C/C++, such as SPIN [HP96] and the Concurrency Factory <ref> [CLSS96] </ref>. This performance can be attributed in part to various aspects of the underlying XSB implementation, including its extensive support of tabling and the use of trie data structures to encode tables. In [LRS98] we describe how XMC can be extended to the full modal mu-calculus. <p> Overall the system consists of less than 200 lines of well-documented tabled Prolog code. Preliminary experiments show that the ease of implementation does not penalize the performance of the model checker. In fact, XMC has been shown (see [RRR + 97]) to consistently outperform the Concurrency Factory's model checker <ref> [CLSS96] </ref> and virtually match the performance of SPIN [HP96] on a well-known set of benchmarks. We recently obtained results from XMC on the i-protocol, a sophisticated sliding-window protocol used for file transfers over serial lines, such as telephone lines.
Reference: [CMCHG96] <author> E. M. Clarke, K. McMillan, S. Campos, and V. Hartonas-GarmHausen. </author> <title> Symbolic model checking. </title> <booktitle> In Alur and Henzinger [AH96], </booktitle> <pages> pages 419-422. </pages>
Reference-contexts: The i-protocol is part of the protocol stack of the GNU UUCP package available from the Free Software Foundation, and consists of about 300 lines of C code. Table 1 contains the execution-time and memory-usage requirements for XMC, SPIN, COSPAN [HHK96], and SMV <ref> [CMCHG96] </ref> applied to the i-protocol to detect a non-trivial livelock error that can occur under certain message-loss conditions. This livelock error was first detected using the Concurrency Factory.
Reference: [CW96a] <author> W. Chen and D. S. Warren. </author> <title> Tabled evaluation with delaying for general logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 43(1) </volume> <pages> 20-74, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Moreover, the implementation of negation in Prolog differs from the semantics of logical negation in the model theory. Consequently, traditional Prolog systems do not offer the needed support to directly implement model checkers. As alluded to above, evaluation strategies such as tabling <ref> [TS86, CW96a] </ref> overcome these limitations (see Section 2.2). Hence, tabled logic programming systems appear to offer a suitable platform for implementing model checkers. The pertinent question is whether one can construct a model checker using this approach that is efficient enough to be deemed practical. <p> And even if the fact is in the fixed point, Prolog's search strategy may not find it. So even though the semantics of logic programming is a useful semantics for model checking, its computation mechanism of SLD is too weak to be practical. The XSB system implements SLG resolution <ref> [CW96a] </ref>, which to a first approximation can be understood as a tabled version of SLD resolution.
Reference: [CW96b] <author> E. M. Clarke and J. M. Wing. </author> <title> Formal methods: State of the art and future directions. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(4), </volume> <month> December </month> <year> 1996. </year>
Reference-contexts: Model checking has enjoyed wide success in verifying, or finding design errors in, real-life systems. An interesting account of a number of these success stories can be found in <ref> [CW96b] </ref>.
Reference: [Dam96] <author> D. Dams. </author> <title> Abstract Interpretation and Partition Refinement for Model Checking. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, </institution> <year> 1996. </year>
Reference-contexts: First, since model checkers are specified at the level of semantic equations, equations of abstract semantics [CC77] can be encoded with equal ease. These can be used to incorporate process and formula abstractions, which have been used successfully to ameliorate state explosion in model checking <ref> [Dam96] </ref>, into an LMC-style model checker. Secondly, the programmability of an LP system allows for direct encoding of traditional model-checking optimizations, such as partial order reduction [HPP96]. Finally, the high level at which model checking is specified correspondingly elevates the level at which erroneous system specifications can be diagnosed and debugged.
Reference: [EL86] <author> E. A. Emerson and C.-L. Lei. </author> <title> Efficient model checking in fragments of the propositional mu-calculus. </title> <booktitle> In Proceedings of the First Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 267-278, </pages> <year> 1986. </year>
Reference-contexts: The evidence we have accumulated during the first year of our LMC project indicates that the answer to this question is most definitely "yes." In particular, we have developed XMC [RRR + 97], a model checker for Milner's CCS [Mil89] and the alternation-free fragment <ref> [EL86] </ref> of the modal mu-calculus. The full value-passing version of CCS is supported, and a generalized prefix operator is used that allows arbitrary Prolog terms to appear as computational units in XMC system specifications. <p> Consequently, the XSB program will terminate under XSB's tabling method when there are a finite number of states in the transition system. 3.2 Model Checking the Full Modal Mu-Calculus Intuitively, the alternation depth of a modal mu-calculus formula <ref> [EL86] </ref> f is the level of nontrivial nesting of fixed points in f with adjacent fixed points being of different type. When this level is 1, f is said to be "alternation-free".
Reference: [GL88] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In International Conference on Logic Programming, </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: For such formulas, we need to evaluate one of the stable models of the resultant program <ref> [GL88] </ref>, and the choice of the stable model itself depends on the structure of alternation in the formula. Such a model can be computed by extending the well-founded model.
Reference: [HHK96] <author> R. H. Hardin, Z. Har'El, and R. P. </author> <title> Kurshan. </title> <booktitle> COSPAN. In Alur and Hen-zinger [AH96], </booktitle> <pages> pages 423-427. </pages>
Reference-contexts: The i-protocol is part of the protocol stack of the GNU UUCP package available from the Free Software Foundation, and consists of about 300 lines of C code. Table 1 contains the execution-time and memory-usage requirements for XMC, SPIN, COSPAN <ref> [HHK96] </ref>, and SMV [CMCHG96] applied to the i-protocol to detect a non-trivial livelock error that can occur under certain message-loss conditions. This livelock error was first detected using the Concurrency Factory.
Reference: [HNSY94] <author> T. A. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Symbolic model checking for real-time systems. </title> <journal> Information and Computation, </journal> <volume> 111(2), </volume> <year> 1994. </year>
Reference-contexts: A state of a timed automaton comprises a location and an assignment of values to clock variables. Clearly, since clocks range over infinite domains, timed automata are infinite-state automata. Real-time extensions to temporal logics, such as timed extensions of the modal mu-calculus <ref> [ACD93, HNSY94, SS95] </ref>, are used to specify the properties of interest. Traditional model-checking algorithms do not directly work in the case of real-time systems since the underlying state-space is infinite. The key then is to consider only finitely many regions of the state space.
Reference: [HP96] <author> G. J. Holzmann and D. Peled. </author> <title> The state of SPIN. </title> <booktitle> In Alur and Henzinger [AH96], </booktitle> <pages> pages 385-389. </pages>
Reference-contexts: With regard to the efficiency issue, XMC is highly competitive with state-of-the-art model checkers hand-coded in C/C++, such as SPIN <ref> [HP96] </ref> and the Concurrency Factory [CLSS96]. This performance can be attributed in part to various aspects of the underlying XSB implementation, including its extensive support of tabling and the use of trie data structures to encode tables. <p> Preliminary experiments show that the ease of implementation does not penalize the performance of the model checker. In fact, XMC has been shown (see [RRR + 97]) to consistently outperform the Concurrency Factory's model checker [CLSS96] and virtually match the performance of SPIN <ref> [HP96] </ref> on a well-known set of benchmarks. We recently obtained results from XMC on the i-protocol, a sophisticated sliding-window protocol used for file transfers over serial lines, such as telephone lines.
Reference: [HPP96] <author> G. Holzmann, D. Peled, and V. Pratt, </author> <title> editors. Partial-Order Methods in Verification (POMIV '96), </title> <booktitle> DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year> <journal> American Mathematical Society. </journal>
Reference-contexts: These can be used to incorporate process and formula abstractions, which have been used successfully to ameliorate state explosion in model checking [Dam96], into an LMC-style model checker. Secondly, the programmability of an LP system allows for direct encoding of traditional model-checking optimizations, such as partial order reduction <ref> [HPP96] </ref>. Finally, the high level at which model checking is specified correspondingly elevates the level at which erroneous system specifications can be diagnosed and debugged.
Reference: [JL87] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <year> 1987. </year>
Reference-contexts: To validate this claim, we have been experimenting with ways of augmenting XMC with the power of induction, with an eye toward the verification of parameterized systems (Section 4.2). By using constraints (as in Constraint LP <ref> [JL87] </ref>) to finitely represent infinite sets and tabled resolution to efficiently compute fixed points over these sets, we are looking at how tabled constraint LP can be used to verify real-time systems (Section 4.3). The rest of the paper is structured follows.
Reference: [Koz83] <author> D. Kozen. </author> <title> Results on the propositional -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 27 </volume> <pages> 333-354, </pages> <year> 1983. </year>
Reference-contexts: Ramakrishna of Sun Microsystems and Terrance Swift located at the University of Maryland, College Park. XSB [XSB98]. The Concurrency Factory is a specification and verification envi-ronment supporting integrated graphical/textual specification and simulation, and model checking in the modal mu-calculus <ref> [Koz83] </ref> temporal logic. XSB is a logic programming system that extends Prolog-style SLD resolution with tabled resolution. The principal merits of this extension are that XSB terminates on programs having finite models, avoids redundant subcomputations, and computes the well-founded model of normal logic programs. <p> Finally, we show how the structural operational semantics of CCS, with full value-passing support, can also be naturally captured as a tabled logic program. 3.1 Model Checking the Alternation-Free Modal Mu-Calculus The modal mu-calculus <ref> [Koz83] </ref> is an expressive temporal logic whose semantics is usually described over sets of states of labeled transition systems.
Reference: [Llo84] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer, </publisher> <year> 1984. </year>
Reference-contexts: The modal mu-calculus, the logic of choice for XMC, uses explicit least and greatest fixed-point operators and consequently subsumes virtually all other temporal logics in expressive power. 2.2 The XSB Tabled Logic Programming System The fundamental theorem of logic programming <ref> [Llo84] </ref> is that, given a set of Horn clauses (i.e., a "pure" Prolog program), the set of facts derivable by SLD resolution (the computational mechanism of Prolog) is the same as the set of facts logically implied by the Horn clauses, which is the same as the set of facts in
Reference: [LRS98] <author> X. Liu, C. R. Ramakrishnan, and S. A. Smolka. </author> <title> Fully local and efficient evaluation of alternating fixed points. </title> <booktitle> In Proceedings of the Fourth International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS '98), Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: This performance can be attributed in part to various aspects of the underlying XSB implementation, including its extensive support of tabling and the use of trie data structures to encode tables. In <ref> [LRS98] </ref> we describe how XMC can be extended to the full modal mu-calculus. Buoyed by the success of XMC, we are currently investigating ways in which the LMC approach can be extended beyond traditional finite-state model checking. In particular, the following efforts are underway. <p> Initial experiments indicate that XMC computes alternating fixed points very efficiently using the above strategy, even outperforming existing model checkers crafted to carry out the same kind of computation. Details appear in <ref> [LRS98] </ref>. 3.3 On-the-Fly Construction of Labeled Transition Systems The above encoding assumes that processes are given as labeled transition systems. For processes specified using a process algebra such as CCS [Mil89], we can construct the labeled transition system on the fly, using CCS's structural operational semantics.
Reference: [Mil83] <author> R. Milner. </author> <title> Calculi for synchrony and asynchrony. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 267-310, </pages> <year> 1983. </year>
Reference-contexts: Andersen, Stirling and Winskel [ASW94] present an elegant compositional proof system for the verification of processes defined in a synchronous process calculus similar to Milner's SCCS <ref> [Mil83] </ref> with respect to properties expressed in the modal mu-calculus. A useful feature of their system is the algorithmic nature of the rules.
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: The evidence we have accumulated during the first year of our LMC project indicates that the answer to this question is most definitely "yes." In particular, we have developed XMC [RRR + 97], a model checker for Milner's CCS <ref> [Mil89] </ref> and the alternation-free fragment [EL86] of the modal mu-calculus. The full value-passing version of CCS is supported, and a generalized prefix operator is used that allows arbitrary Prolog terms to appear as computational units in XMC system specifications. <p> Details appear in [LRS98]. 3.3 On-the-Fly Construction of Labeled Transition Systems The above encoding assumes that processes are given as labeled transition systems. For processes specified using a process algebra such as CCS <ref> [Mil89] </ref>, we can construct the labeled transition system on the fly, using CCS's structural operational semantics. In effect, we can treat trans as a computed (IDB) relation instead of as a static (EDB) relation, without changing the definition of models. <p> Recursion is provided by a set of defining equations, Def, of the form P N ::= E. The formal semantics of our language is given using structural operational semantics, closely paralleling that of CCS <ref> [Mil89] </ref>. Due to space limitations, we present here the axioms and inference rules for only a few key constructs.
Reference: [NS96] <author> I. Niemela and P. Simons. </author> <title> Efficient implementation of the well-founded and stable model semantics. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 289-303, </pages> <year> 1996. </year>
Reference-contexts: When the well-founded model has unknown values, XSB constructs a residual program which captures the dependencies between the predicates with unknown values. We compute the values of these remaining literals in the preferred stable model by invoking the stable model generator smodels <ref> [NS96] </ref> on the residual program. The algorithm used in smodels recursively assigns truth values to literals until all literals have been assigned values, or an assignment is inconsistent with the program rules. When an inconsistency is detected, it backtracks and tries alternate truth assignments for previously encountered literals.
Reference: [QS82] <author> J. P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Proceedings of the International Symposium in Programming, volume 137 of Lecture Notes in Computer Science, </booktitle> <address> Berlin, 1982. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The ESS program director is Dr. William W. Agresti. The current primary focus of our ESS grant is model checking <ref> [CE81, QS82, CES86] </ref>, the problem of determining whether a system specification possesses a property expressed as a temporal logic formula. Model checking has enjoyed wide success in verifying, or finding design errors in, real-life systems. An interesting account of a number of these success stories can be found in [CW96b].
Reference: [RRR + 97] <author> Y. S. Ramakrishna, C. R. Ramakrishnan, I. V. Ramakrishnan, S. A. Smolka, T. W. Swift, and D. S. Warren. </author> <title> Efficient model checking using tabled resolution. </title> <booktitle> In Proceedings of the 9th International Conference on Computer-Aided Verification (CAV '97), </booktitle> <address> Haifa, Israel, July 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The evidence we have accumulated during the first year of our LMC project indicates that the answer to this question is most definitely "yes." In particular, we have developed XMC <ref> [RRR + 97] </ref>, a model checker for Milner's CCS [Mil89] and the alternation-free fragment [EL86] of the modal mu-calculus. The full value-passing version of CCS is supported, and a generalized prefix operator is used that allows arbitrary Prolog terms to appear as computational units in XMC system specifications. <p> Overall the system consists of less than 200 lines of well-documented tabled Prolog code. Preliminary experiments show that the ease of implementation does not penalize the performance of the model checker. In fact, XMC has been shown (see <ref> [RRR + 97] </ref>) to consistently outperform the Concurrency Factory's model checker [CLSS96] and virtually match the performance of SPIN [HP96] on a well-known set of benchmarks. We recently obtained results from XMC on the i-protocol, a sophisticated sliding-window protocol used for file transfers over serial lines, such as telephone lines.
Reference: [RRRS98] <author> A. Roychoudhury, C. R. Ramakrishnan, I. V. Ramakrishnan, and S. A. Smolka. </author> <title> Tabulation-based induction proofs with applications to automated verification. </title> <booktitle> In Workshop on Tabulation in Parsing and Deduction, </booktitle> <year> 1998. </year>
Reference-contexts: In order to make the structure of induction explicit, it is often necessary to perform folding steps, where instances of rule bodies are replaced by the corresponding heads. In <ref> [RRRS98] </ref> we describe how tabled resolution's ability to compute conditional answers, and folding mechanisms can be combined to reveal the structure of induction.
Reference: [SS95] <author> O. Sokolsky and S. A. Smolka. </author> <title> Local model checking for real-time systems. </title> <booktitle> In Proceedings of the 7th International Conference on Computer-Aided Verification. </booktitle> <publisher> American Mathematical Society, </publisher> <year> 1995. </year>
Reference-contexts: A state of a timed automaton comprises a location and an assignment of values to clock variables. Clearly, since clocks range over infinite domains, timed automata are infinite-state automata. Real-time extensions to temporal logics, such as timed extensions of the modal mu-calculus <ref> [ACD93, HNSY94, SS95] </ref>, are used to specify the properties of interest. Traditional model-checking algorithms do not directly work in the case of real-time systems since the underlying state-space is infinite. The key then is to consider only finitely many regions of the state space. <p> States hL 0 ; t = 4i and hL 0 ; t = 6i, however, can be distinguished, since only from the latter can we make a transition to hL 1 ; t = 6i, where an a-transition is enabled. In <ref> [SS95] </ref>, we presented a local algorithm for model checking real-time systems, where the finite discretization of the state space is done on demand, and only to the extent needed to prove or disprove the formula at hand.
Reference: [SSW96] <author> K. Sagonas, T. Swift, and D. S. Warren. </author> <title> An abstract machine to compute fixed-order dynamically stratified programs. </title> <booktitle> In International Conference on Automated Deduction (CADE), </booktitle> <year> 1996. </year>
Reference-contexts: The auxiliary predicate negate (F, NF) is defined such that NF is a positive formula equivalent to (:F). For alternation-free formulas, the encoding yields dynamically stratified programs (i.e., a program whose evaluation does not involve traversing loops with negation), and has a two-valued minimal model. In <ref> [SSW96] </ref> it was shown that the evaluation method underlying XSB correctly computes this class of programs. Tabling ensures that each explored system state is visited only once in the evaluation of a modal mu-calculus formula.
Reference: [TS86] <author> H. Tamaki and T. Sato. </author> <title> OLDT resolution with tabulation. </title> <booktitle> In International Conference on Logic Programming, </booktitle> <pages> pages 84-98. </pages> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Moreover, the implementation of negation in Prolog differs from the semantics of logical negation in the model theory. Consequently, traditional Prolog systems do not offer the needed support to directly implement model checkers. As alluded to above, evaluation strategies such as tabling <ref> [TS86, CW96a] </ref> overcome these limitations (see Section 2.2). Hence, tabled logic programming systems appear to offer a suitable platform for implementing model checkers. The pertinent question is whether one can construct a model checker using this approach that is efficient enough to be deemed practical.
Reference: [vRS91] <author> A. van Gelder, K. A. Ross, and J. S. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 38(3), </volume> <year> 1991. </year>
Reference-contexts: In contrast to the alternation-free fragment of the modal mu-calculus, when a formula contains alternation, the resultant XSB program is not dynamically stratified, and hence the well-founded model may contain literals with unknown values <ref> [vRS91] </ref>. For such formulas, we need to evaluate one of the stable models of the resultant program [GL88], and the choice of the stable model itself depends on the structure of alternation in the formula. Such a model can be computed by extending the well-founded model.
Reference: [Wol86] <author> P. Wolper. </author> <title> Expressing interesting properties of programs in propositional temporal logic. </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Programming, </booktitle> <pages> pages 184-192, </pages> <address> St. Petersburgh, </address> <month> January </month> <year> 1986. </year>
Reference-contexts: XMC is written in approximately 200 lines of XSB tabled-logic-programming Prolog code, and is primarily intended for the model checking of finite-state systems, although it is capable of handling certain kinds of infinite-state systems, such as those exhibiting "data independence" <ref> [Wol86] </ref>. With regard to the efficiency issue, XMC is highly competitive with state-of-the-art model checkers hand-coded in C/C++, such as SPIN [HP96] and the Concurrency Factory [CLSS96].
Reference: [XSB98] <author> XSB. </author> <title> The XSB logic programming system v1.8, 1998. Available from http://www.cs.sunysb.edu/~sbprolog. This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Ramakrishna of Sun Microsystems and Terrance Swift located at the University of Maryland, College Park. XSB <ref> [XSB98] </ref>. The Concurrency Factory is a specification and verification envi-ronment supporting integrated graphical/textual specification and simulation, and model checking in the modal mu-calculus [Koz83] temporal logic. XSB is a logic programming system that extends Prolog-style SLD resolution with tabled resolution.
References-found: 34

