URL: ftp://ftp.eecs.umich.edu/groups/gasm/modcheck.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: email: kirsten@first.gmd.de  
Title: Model Checking for Abstract State Machines  
Author: Kirsten Winter 
Address: FIRST Rudower Chaussee 5, D-12489 Berlin, Germany  
Affiliation: GMD  
Abstract: In this paper, we discuss the use of a model checker in combination with the specification method of Abstract State Machines (ASMs). A schema is introduced for transforming ASM models into the language of a model checker. We prove that the transformation preserves the semantics of ASMs and provide a theoretical framework for a transformation tool. Experience with model-checking the ASM model of the Production Cell demonstrates that this approach offers effective support for verifying ASM specifications. Key Words: Formal Methods, Abstract State Machines, Model Checking, Tool Support, Requirement Specification, Verification 
Abstract-found: 1
Intro-found: 1
Reference: [Bharadwaj, Heitmeyer 97] <author> Bharadwaj, R., Heitmeyer, C.: </author> <title> "Verifying SCR Requirements Specification Using State Exploration"; Proc. </title> <booktitle> First ACM SIGPLAN Workshop on Automatic Analysis of Software, </booktitle> <month> Jan., </month> <year> (1997). </year>
Reference-contexts: One proposal to overcome the problem of state explosion is to provide a correctness-preserving reduction to an abstract model with a reduced state space [Clarke et al. 92], [Dingel, Filkorn 96], <ref> [Bharadwaj, Heitmeyer 97] </ref>. <p> Bharadwaj and Heitmeyer report on their experiences in combining SCR with the model checker SPIN in <ref> [Bharadwaj, Heitmeyer 97] </ref>. In the context of the ASM methodology, our work is related to the "Abstract State Machine/Virtual Architecture" (ASM/VA, formerly known as EAM) by Del Castillo, Durdanovic and Glasser [Del Castillo et al. 96].
Reference: [Borger 95] <author> Borger, E.: </author> <title> "Annotated Bibliography on Evolving Algebras"; in Borger, </title> <editor> E. (Eds.): </editor> <publisher> "Specification and Validation Method"; Oxford University Press, </publisher> <year> (1995), </year> <pages> 37-51. </pages>
Reference-contexts: The process of specification and verification is guided by the notion of stepwise refinement. The developer can choose any level of abstraction to focus on specific aspects of the system. With ASMs, we have a formal method for practical use, as the list of contributions in <ref> [Borger 95] </ref> shows. When using formal methods for developing safety-critical systems, one of the major goals is to verify that the safety requirements are satisfied. Interactive Theorem provers are adequate for showing the properties of infinite state systems, but their drawback is the often immense human effort needed for verification.
Reference: [Borger 95a] <author> Borger, E.: </author> <title> "Why Use Evolving Algebras for Hardware and Software Engineering?", </title> <editor> Bartosek, M., Staudek, J., Wiedermann, J. (Eds.), </editor> <publisher> SOFSEM'95; LNCS 1012, </publisher> <year> (1995), </year> <month> 236-271. </month> <title> 700 Winter K.: Model Checking for Abstract State Machines </title>
Reference-contexts: Using ASMs, we can start from the opposite direction by exploiting the possibility of modeling at arbitrary levels of abstraction: we start with an abstract ground model (in the sense of <ref> [Borger 95a] </ref>) to obtain an overview of the problem, and then refine ideally in a provably correct way the model in several steps in order to get more concrete versions.
Reference: [Borger, Mearelli 97] <author> Borger, E., Mearelli, L.: </author> <title> "Integrating ASMs into the Software Development Life Cycle"; contribution in this volume. </title>
Reference-contexts: We explain this novel use of model-checking ASMs using the example of the Production Cell. We have chosen the SMV model checker that offers the language facilities needed to simulate ASM models. We transform the ASM model of the Production Cell <ref> [Borger, Mearelli 97] </ref> into the language of SMV. (We chose the refined model of the Production Cell which also operates in a finite state space and allows us to formalize all safety and liveness properties.) The required safety and liveness properties [Lewerentz, Lindner 95a], [Borger, Mearelli 97] are formalized in a <p> ASM model of the Production Cell <ref> [Borger, Mearelli 97] </ref> into the language of SMV. (We chose the refined model of the Production Cell which also operates in a finite state space and allows us to formalize all safety and liveness properties.) The required safety and liveness properties [Lewerentz, Lindner 95a], [Borger, Mearelli 97] are formalized in a temporal logic. The resulting system model can be checked against the formalized requirements automatically. In Section 2, we explain our choice of the SMV model checker. Section 3 describes the transformation of the ASM rules and the structure of the system model. <p> At the end of this section, we describe how to find an adequate variable ordering. 3.1 The Transformation from an ASM Model to a SMV Model For our case study, we use the Production Cell [Lewerentz, Lindner 95a] modeled with ASMs <ref> [Borger, Mearelli 97] </ref>. We restrict our investigation to simple update rules, sequential and conditional rules [Gurevich 95], because no other constructs are needed for this example. <p> All modules are running whenever the module main or the system is running. By way of an example, Figure 1 shows a fragment of the SMV model of the Production Cell. (In the SMV code, we shorten the variable names and remove the macro definitions as given in <ref> [Borger, Mearelli 97] </ref>.) MODULE DepositBelt (s) ASSIGN next (s.Critical):= case (s.DBMot=run & !s.Critical) & s.PieceInLightBarr : 1; (s.DBMot=run & s.Critical) & !s.PieceInLightBarr : 0; 1 : s.Critical; esac; next (s.DBMot):= case (s.DBMot=run & s.Critical) & !s.PieceInLightBarr : idle; (s.DBMot=idle) & !s.PieceAtBeltEnd : run; 1 : s.DBMot; esac; : : : 3.5 <p> Using this simple heuristic, we made good progress in the case study. This procedure could be automated for all ASMs. 4 Specification of the System Requirements In our experiments with the ASM model of the Production Cell, we first consider the safety properties of the system as listed in <ref> [Borger, Mearelli 97] </ref> (Section 4.2) and then the liveness property (Section 4.3). Furthermore, we show how model checking can be used to support manual proving by checking particular lemmas like the Agent Progress Lemma as introduced for the liveness proof in [Borger, Mearelli 97] (Section 4.4). <p> the safety properties of the system as listed in <ref> [Borger, Mearelli 97] </ref> (Section 4.2) and then the liveness property (Section 4.3). Furthermore, we show how model checking can be used to support manual proving by checking particular lemmas like the Agent Progress Lemma as introduced for the liveness proof in [Borger, Mearelli 97] (Section 4.4). We formulate the system requirements in the temporal logic CTL, which is based on atomic formulas that express information about states using state variables and Boolean connectors. <p> We therefore choose the refined ASM model as the system description we want to check. Continuous intervals as for the angle values were treated as a finite set of discrete values, because "only a finite number of the real values are relevant" <ref> [Borger, Mearelli 97] </ref>, (Section 4.3). The safety properties of the Production Cell are given as properties of its components, but the complexity of the system allows us to check the system as a whole. <p> BDD nodes representing transition relation: 25718 + 1 4.2 The Liveness Property of the Production Cell We formalize the liveness property, reflecting the whole process as a sequence of different steps, and check that always the next action of this sequence (in the sense of the Blank Progress Lemma in <ref> [Borger, Mearelli 97] </ref>, see below) will eventually be executable. We split the cyclic process into subprocesses at the points where "blanks can progress" owing to the actions of the cell components. <p> regular sequence: it is transported by the feed belt to the elevating rotary table, then moved by the robot to the press, and from there to the deposit belt, where the traveling crane puts it back on the feed belt. (This is what is stated in the Blank Progress Lemma <ref> [Borger, Mearelli 97] </ref>.) The presence and location of "blanks" in the system is formalized in terms of the ASM model notions, e.g. a blank is transported from the beginning of the feed belt to the end when the feed belt changes from NormalRun to CriticalRun. (By the Cell Assumption, it is <p> Moreover, to ensure that action executable will be reached at all, we have to verify that eventually the action will be executable: ( AF action executable) has to be checked for every first action in the set of action pairs. Integrating the Agent Progress Lemma used in <ref> [Borger, Mearelli 97] </ref> in the proof of the Blank Progress Lemma, we obtain the following sequence of actions characterizing the control-critical moments in the life of a blank in the Production Cell: F eedBelt is in N ormalRun, F eedBelt is in CriticalRun, T able is stopped in load position, T <p> We found that the system satisfies the property if (and only if) the initial condition guarantees that there are at least two blanks in the system. (This has to do with the order of the robot actions; see the discussion in <ref> [Borger, Mearelli 97] </ref>.) Since we do not model an operator that puts new blanks on the feed belt, we have to change the initial condition in order to get more than one blank within the system (see the Insertion Priority Assumption and the proof of the Strong Performance Property in [Borger, <p> <ref> [Borger, Mearelli 97] </ref>.) Since we do not model an operator that puts new blanks on the feed belt, we have to change the initial condition in order to get more than one blank within the system (see the Insertion Priority Assumption and the proof of the Strong Performance Property in [Borger, Mearelli 97]). <p> true resources used: user time: 10.1333 s, system time: 0.95 s BDD nodes allocated: 56832 Bytes allocated: 18350080 BDD nodes representing transition relation: 25718 + 1 We conclude that the system model satisfies the liveness property as claimed in the problem definition. 4.3 The Agent Progress Lemma Borger and Mearelli <ref> [Borger, Mearelli 97] </ref> introduce the Agent Progress Lemma in order to prove the liveness of the system. Proof of this lemma requires inspection of the rules. We suggest supporting the user with the model checker in order to check the interactive behavior of the overall system. <p> On the other hand, it is not possible to use the ASM/VA for automated verification of system requirements. In this paper, we evaluated the model-checking approach using the given ASM model of the Production Cell <ref> [Borger, Mearelli 97] </ref>. It was to be expected 699Winter K.: Model Checking for Abstract State Machines that additional effort would be needed for formalization. The informal natural--language descriptions of the safety and liveness properties had to be transformed into temporal-logic formulas.
Reference: [Burch et al. 92] <author> Burch, J.R., Clarke, E.M., McMillan, K.L., Dill, D.L., Hwan, L.J.: </author> <title> "Symbolic model checking 10 20 states and beyond"; Information and Computation, </title> <type> 98, </type> <month> 2 </month> <year> (1992), </year> <pages> 142-170. </pages>
Reference: [Bryant 86] <author> Bryant, R.E.: </author> <title> "Graph-Based Algorithms for Boolean Function Manipulation"; IEEE Transactions On Computers, </title> <journal> C-35, </journal> <volume> 8, </volume> <year> (1986). </year>
Reference: [Clarke et al. 92] <author> Clarke, E., Grumberg, O., Long, D.: </author> <booktitle> "Model-Checking and Abstraction"; Proc. 19th ACM Symposium on Principles of Programming Languages, </booktitle> <publisher> ACM Press, </publisher> <year> (1992), </year> <pages> 343-354. </pages>
Reference-contexts: One proposal to overcome the problem of state explosion is to provide a correctness-preserving reduction to an abstract model with a reduced state space <ref> [Clarke et al. 92] </ref>, [Dingel, Filkorn 96], [Bharadwaj, Heitmeyer 97].
Reference: [Chang et al. 92] <author> Chang, E., Manna, Z., Pnueli, A.: </author> <title> "The Safety-Progress Classification"; Dep. </title> <institution> of Comp. Science, Stanford Univ., STAN-CS-92-1408, </institution> <year> (1992). </year>
Reference: [Day 1993] <author> Day, N.: </author> <title> "A Model Checker for Statecharts (Linking CASE Tools with Formal Methods)"; Tech.Report 93-35, </title> <institution> Dep. of Computer Science, Univ. of British Columbia, Vancouver, B.C., Canada, </institution> <year> (1993). </year>
Reference-contexts: A combination of model checkers and more sophisticated specification languages (as compared with Boolean functions) is needed. In this context, several authors have discussed the transformation from an operational specification language to the language of a chosen model checker. <ref> [Day 1993] </ref> uses the Voss model checker to apply model checking to Statecharts. [Grahlmann, Best 93] present a system environment for developing programs with Petri nets that includes a model checker. Bharadwaj and Heitmeyer report on their experiences in combining SCR with the model checker SPIN in [Bharadwaj, Heitmeyer 97].
Reference: [Del Castillo et al. 96] <author> Del Castillo, G., Durdanovic, I., Glasser, U.: </author> <title> "An Evolving Algebra Abstract Machine"; Proc. </title> <journal> CSL'95, </journal> <volume> LNCS 1092, </volume> <year> (1996), </year> <pages> 191-214. </pages>
Reference-contexts: Bharadwaj and Heitmeyer report on their experiences in combining SCR with the model checker SPIN in [Bharadwaj, Heitmeyer 97]. In the context of the ASM methodology, our work is related to the "Abstract State Machine/Virtual Architecture" (ASM/VA, formerly known as EAM) by Del Castillo, Durdanovic and Glasser <ref> [Del Castillo et al. 96] </ref>. With their ASM-based specification and design environment, they also address the scope of tool support. Among other things, they supply the developers with a simulation tool for ASMs. Compared with the ASM/VA, the SMV model checker provides very limited simulation facilities. <p> Dingel and Filkorn [Dingel, Filkorn 96] suggest a procedure of this sort. Also, a more powerful simulation facility would help to analyze system behavior if it fails to meet the requirements. To provide adequate tool support, a combination of the model checker SMV and the ASM/VA <ref> [Del Castillo et al. 96] </ref> might be fruitful. Acknowledgments My special thanks are due to E. Borger and L. Mearelli for encouraging my work on their ASM model of the Production Cell. I also wish to thank S. Herrmann and J.
Reference: [Dingel, Filkorn 96] <author> Dingel, J., Filkorn, T.: </author> <title> "Model checking for infinite state systems using data abstraction, assumption-commitment style reasoning and theorem proving"; Proc. </title> <type> CAV '95, LNCS 939, </type> <year> (1996), </year> <pages> 54-69. </pages>
Reference-contexts: One proposal to overcome the problem of state explosion is to provide a correctness-preserving reduction to an abstract model with a reduced state space [Clarke et al. 92], <ref> [Dingel, Filkorn 96] </ref>, [Bharadwaj, Heitmeyer 97]. <p> A compilation algorithm should be implemented for automatic transformation; it could be enhanced with interaction facilities for user guidance. To cover all proof obligations, the combined use of a model checker and a theorem prover would be interesting. Dingel and Filkorn <ref> [Dingel, Filkorn 96] </ref> suggest a procedure of this sort. Also, a more powerful simulation facility would help to analyze system behavior if it fails to meet the requirements.
Reference: [Grahlmann, Best 93] <author> Grahlmann, B., Best, E.: </author> <title> "PEP More than a Petri Net Tool"; Procs. of TACAS'96, </title> <publisher> Springer LNCS 1055, </publisher> <year> (1996). </year>
Reference-contexts: In this context, several authors have discussed the transformation from an operational specification language to the language of a chosen model checker. [Day 1993] uses the Voss model checker to apply model checking to Statecharts. <ref> [Grahlmann, Best 93] </ref> present a system environment for developing programs with Petri nets that includes a model checker. Bharadwaj and Heitmeyer report on their experiences in combining SCR with the model checker SPIN in [Bharadwaj, Heitmeyer 97].
Reference: [Gurevich 95] <author> Gurevich, Y.: </author> <title> "Evolving Algebras 1993: Lipari Guide"; E. </title> <editor> Borger (Eds.): </editor> <publisher> "Specification and Validation Methods"; Oxford University Press, </publisher> <year> (1995). </year>
Reference-contexts: 1 Introduction Abstract State Machines (ASMs) <ref> [Gurevich 95] </ref> denote a formal method that allows us to write succinct and understandable specifications for a wide spectrum of applications. The process of specification and verification is guided by the notion of stepwise refinement. <p> We restrict our investigation to simple update rules, sequential and conditional rules <ref> [Gurevich 95] </ref>, because no other constructs are needed for this example. Further work has to be done to obtain transformation schemas for other rule constructs of ASMs. 3.2 Transformation Schema for an Update Instruction Following [Gurevich 95], the semantics of an update instruction R : f ( t) := t 0 <p> We restrict our investigation to simple update rules, sequential and conditional rules <ref> [Gurevich 95] </ref>, because no other constructs are needed for this example. Further work has to be done to obtain transformation schemas for other rule constructs of ASMs. 3.2 Transformation Schema for an Update Instruction Following [Gurevich 95], the semantics of an update instruction R : f ( t) := t 0 is that the current value of t 0 is mapped to the function f at the current value of t, i.e. it is given formally by firing its update ff = (l; y) at the <p> In <ref> [Gurevich 95] </ref>, the semantics of R is given in terms of update sets: U pdate (R; S) = U pdate (R i ; S) if g i is the first guard that holds, and U pdate (R; S) = ; if none of the guards is true in S (i.e. nothing
Reference: [Havelund, Shankar 95] <author> Havelund, K., Shankar, N.: </author> <title> "Experiments in Theorem Proving and Model Checking for Protocol Verification"; SRI International Menlo Park, </title> <type> Report, </type> <address> USA (1995). </address>
Reference-contexts: In ASMs, modules and all the transition rules inside a module are running concurrently. We transform ASM modules into SMV modules that are instantiated without the keyword process, which yields the right semantics of simultaneous execution. We also borrow some ideas from the schema of Havelund and Shankar <ref> [Havelund, Shankar 95] </ref>. To be able to simulate the communication with global variables, we need a module state consisting of the declaration of all variables that are used in common.
Reference: [Lewerentz, Lindner 95a] <author> C. Lewerentz, T. Lindner: </author> <title> "Formal Development Of Reactive Systems. </title> <booktitle> Case Study "Production Cell""; Springer LNCS 891 (1995), </booktitle> <pages> 9-21. </pages>
Reference-contexts: We transform the ASM model of the Production Cell [Borger, Mearelli 97] into the language of SMV. (We chose the refined model of the Production Cell which also operates in a finite state space and allows us to formalize all safety and liveness properties.) The required safety and liveness properties <ref> [Lewerentz, Lindner 95a] </ref>, [Borger, Mearelli 97] are formalized in a temporal logic. The resulting system model can be checked against the formalized requirements automatically. In Section 2, we explain our choice of the SMV model checker. <p> At the end of this section, we describe how to find an adequate variable ordering. 3.1 The Transformation from an ASM Model to a SMV Model For our case study, we use the Production Cell <ref> [Lewerentz, Lindner 95a] </ref> modeled with ASMs [Borger, Mearelli 97]. We restrict our investigation to simple update rules, sequential and conditional rules [Gurevich 95], because no other constructs are needed for this example.
Reference: [Long 93] <author> Long, D.,E.: </author> <title> "Model Checking, Abstraction and Compositional Verification"; CMU Report, </title> <address> USA (1993). </address>
Reference: [McMillan 93] <author> McMillan, K.: </author> <title> "Symbolic Model Checking"; Kluwer Academic Publishers, Boston (1993). </title> <editor> 701Winter K.: </editor> <title> Model Checking for Abstract State Machines </title>
Reference-contexts: We conclude with a discussion of some related research and a look at possible future work. 2 The Choice of SMV for ASMs We decided to use SMV <ref> [McMillan 93] </ref>, because like ASMs it is based on transition systems and on states that are denoted by the values of the state variables. Internally SMV treat transitions symbolically as binary decision diagrams (which provide very efficient algorithms), but this representation is hidden at the level of the description language. <p> It is a peculiarity of SMV that expressions are implicitly treated as nondeterministic. They evaluate to sets of possible values. A constant is mapped to a singleton. The semantics of the assignment of the next operator is given in <ref> [McMillan 93] </ref> as follows: [jASSIGN next (l) := y j] R = ( l 0 2 (running ! ([jyj]; l)) ) 691Winter K.: Model Checking for Abstract State Machines where l 0 is the value of l in the next state. ! stands for the if-then-else operator, which has the intuitive
References-found: 17

