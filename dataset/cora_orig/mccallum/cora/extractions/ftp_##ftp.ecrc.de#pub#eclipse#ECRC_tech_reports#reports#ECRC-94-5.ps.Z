URL: ftp://ftp.ecrc.de/pub/eclipse/ECRC_tech_reports/reports/ECRC-94-5.ps.Z
Refering-URL: http://www.ecrc.de/eclipse/html/CHIC_Methodology.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: thom@ecrc.de  
Title: Temporal Reasoning with Constraint Handling Rules  
Author: Thom Fruhwirth 
Address: Arabellastr. 17, D-81925 Munchen Germany  
Affiliation: European Computer-Industry Research Centre GmbH  
Abstract: Technical Report ECRC-94-05 February 16, 1994 
Abstract-found: 1
Intro-found: 1
Reference: [All83] <author> J. F. Allen, </author> <title> Maintaining Knowledge about Temporal Intervals, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 26, No. 11, </volume> <year> 1983, </year> <pages> pp 823-843. </pages>
Reference-contexts: If ge 2 QU AL then (1)::0 2 QU AN T . If le 2 QU AL then 0::1 2 QU AN T . Interval Constraints <ref> [All83] </ref>. There are 13 primitive constraints possible between two intervals, equality and 6 other relations with their converses. These constraints can be defined in terms of the end-points of the intervals. Let I=[X; Y ], J=[U; V ]. <p> From (k; j; i) we get Kf=gI. Another round of computation causes no more change, so the fixpoint is reached with J f=gK; Kf=gI (which is also minimal). One path consistency algorithm was given by <ref> [All83] </ref>. for use with his temporal interval constraints. <p> For example, a tree as temporal constraint network is always path consistent and minimal. We are also looking at extension to take durations of intervals into account <ref> [All83] </ref>. While our approach cannot match the speed of hard-coded constraint solvers, we think it is still suitable for sparse heterogeneous networks as they are likely appear in real-life (scheduling).
Reference: [Coh90] <author> J. Cohen, </author> <title> Constraint Logic Programming Languages, </title> <journal> Communications of the ACM 33(7) </journal> <pages> 52-68, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The purpose of this paper is to show how our approach is beneficial for understanding and developing temporal reasoning and constraint consistency techniques. Constraint logic programming (CLP) <ref> [JaLa87, Sar89, Coh90, VH91] </ref> combines the advantages of logic programming and constraint solving. In logic programming, problems are stated in a declarative way using rules to define relations (predicates). Problems are solved by the built-in logic programming engine (LPE) using nondeterministic backtrack search.
Reference: [D*88] <author> M. Dincbas et al., </author> <title> The Constraint Logic Programming Language CHIP, </title> <booktitle> Fifth Generation Computer Systems, </booktitle> <address> Tokyo, Japan, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: CHIP was the first constraint logic programming language to introduce the necessary constructs. These constructs have been called "demon constructs" <ref> [D*88] </ref> because of their event-driven activation whenever new information is available. These various constructs have been generalized into CH rules. <p> Finite domains are unary quantitative constraints. They can be modeled by binary con 14 straints whose first argument is zero. Because of this, no propagation is necessary. The treatment of equality is different. We use the notation I::C of CHIP <ref> [D*88] </ref> instead of ctr (0,I,C). The choice for backtrack search is modified. Instead of choosing a primitive constraint, a value from the quantitative constraint is chosen. % Constraint Declaration and Definition constraint I::C. callable I::C if not singleton (C).
Reference: [DMP91] <author> R. Dechter, I. Meiri and J. Pearl, </author> <title> Temporal Constraint Networks, </title> <journal> Journal of Artificial Intelligence 49 </journal> <pages> 61-95, </pages> <year> 1991. </year>
Reference-contexts: A f&lt;; &gt;g B is the same as A 6= B. Qualitative Point Constraints [ViKa86]. Variables represent time points and there are three primitive constraints &lt;; =; &gt;. &lt; is the converse of &gt; and equality is the converse of 2 itself. Quantitative Point Constraints <ref> [DMP91] </ref>. The primitive constraints restrict the distance of two time points X and Y to be in an interval a::b, i.e. a (Y X) b 2 . Note that there is an infinite number of constraints. From the meaning it follows that the converse of an interval a::b is (b)::(a). <p> Given n nodes, instead of n 2 indirect constraints, n suffice, and the number of propagation steps is reduced accordingly. Based on this observation we give an example of specialization to quantitative constraints over single intervals as considered in <ref> [DMP91] </ref>. Their notation for ctr (I,J,[A..B]) is A=&lt;I-J=<B. The starting node is specified by the constraint start. constraint start (X). % gives starting node constraint A=&lt;X-Y=<B. % direct constraint constraint A=&lt;*X-Y=<*B. % indirect constraint start (X),A=&lt;X-Y=&lt;B ==&gt; A=&lt;*Y=<*B. start (X),A=&lt;Y-X=&lt;B ==&gt; (-B)=&lt;*X-Y=&lt;*(-A). A=&lt;*X-Y=<*B &lt;=&gt; A&gt;=B | false.
Reference: [Fru92] <author> T. Fruhwirth, </author> <title> Constraint Simplification Rules (old name for CH rules), </title> <type> Technical Report ECRC-92-18, </type> <institution> ECRC Munich, Germany, </institution> <note> July 1992 (revised version of internal Report ECRC-91-18i, </note> <month> October </month> <year> 1991). </year>
Reference-contexts: Hard-coding guarantees maximum efficiency for the given set of constraints. However it has the serious drawback that it is hard to extend and specialize the built-in CS, combine it with other CS's and build a CS over a new domain. Constraint handling rules (CH rules) <ref> [Fru92] </ref> are a language extension providing the application-programmer (user) with a declarative and flexible means to introduce user-defined constraints (in addition to built-in constraints of the underlying language). CH rules define simplification of and propagation over user-defined constraints. Simplification replaces constraints by simpler constraints while preserving logical equivalence.
Reference: [HaJa90] <author> S. Haridi and S. Janson, </author> <title> Kernel Andorra Prolog and its Computation Model, </title> <booktitle> Seventh Int Conference on Logic Programming, </booktitle> <publisher> MIT Press 1990, </publisher> <pages> pp. 31-46. </pages>
Reference-contexts: These various constructs have been generalized into CH rules. CH rules are essentially multi-headed guarded rules and as such have their roots in concurrent logic programming languages [Sha89] and can be related to the Swedish branch of the Andorra family <ref> [HaJa90] </ref> and Saraswats cc-framework of concurrent constraint programming [Sar89]. However these general purpose programming languages lack features essential to define non-trivial constraint evaluation, namely multi-headed guarded rules and and a way to define constraint propagation by rules, while CH rules form a special purpose language extension for user-defined constraint solvers.
Reference: [JaLa87] <author> J. Jaffar and J.-L. Lassez, </author> <title> Constraint Logic Programming, </title> <booktitle> ACM 14th POPL 87, </booktitle> <address> Munich, Germany, </address> <month> January </month> <year> 1987, </year> <pages> pp. 111-119. </pages>
Reference-contexts: The purpose of this paper is to show how our approach is beneficial for understanding and developing temporal reasoning and constraint consistency techniques. Constraint logic programming (CLP) <ref> [JaLa87, Sar89, Coh90, VH91] </ref> combines the advantages of logic programming and constraint solving. In logic programming, problems are stated in a declarative way using rules to define relations (predicates). Problems are solved by the built-in logic programming engine (LPE) using nondeterministic backtrack search.
Reference: [KaLa91] <author> H. A. Kautz and P. B. Ladkin, </author> <title> Integrating Metric and Qualitative Temporal Reasoning, </title> <booktitle> AAAI 91, </booktitle> <pages> pp 241-246. </pages>
Reference-contexts: Note that there is an infinite number of constraints. From the meaning it follows that the converse of an interval a::b is (b)::(a). The interval 0..0 corresponds to equality. Relating Point Constraints <ref> [KaLa91] </ref>. Qualitative can be mapped into quantitative point constraints, quantitative constraints can only be approximated by qualitative constraints. These mappings are used to solve heterogeneous constraints over the same variables. Let QU AN T (QU AL) be a quantitative (qualitative) temporal constraint. <p> Relating Point and Interval Constraints <ref> [KaLa91] </ref>. Points can be represented by end-points of intervals. Interval constraints can be approximated by constraints on their endpoints. Given two points X; Y . Let I=[X; A], J=[Y; B] be intervals. If X&gt;Y then I fduring,finishes,overlapped by,met by,afterg J. If X=Y then I fequals,starts,started byg J.
Reference: [LaRe92] <author> P. B. Ladkin and A. Reinefeld, </author> <title> Effective Solution of Qualitative Interval Constraint Problems, </title> <journal> Journal of Artificial Intelligence 57 </journal> <pages> 105-124, </pages> <year> 1992. </year>
Reference-contexts: In the following we will solve the above mentioned constraint satisfaction problems except optimization ("best" solution) by a single algorithm that combines backtrack search and path consistency <ref> [LaRe92] </ref>. Backtrack search. Backtrack search can be used to compute solutions, but has exponential complexity in the number of choices. Search will be therefore more efficient if we minimize the number of potential choices by computing the minimal network before making a choice. <p> The simplification corresponds to merging the corresponding nodes in the network. ctr (I,J,C) , equality (C),singleton (C) | I=J. Backtracking. Another optimization, which is also used in <ref> [LaRe92] </ref>, deals with the backtrack search. The idea follows the first fail principle in choosing more constraining primitive relations first. This can be achieved by a modification of the choose predicate. The most constraining primitive relation is equality.
Reference: [Mac77] <author> A. K. Mackworth, </author> <title> Consistency in Networks of Relations, </title> <journal> Journal of Artificial Intelligence 8 </journal> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: T emp then Q := Q [ f (i; k)g T emp := c kj c ki c ij if T emp = fg then inconsistent if c kj 6= T emp then Q := Q [ f (k; j)g endfor endwhile Another classical algorithm named PC-2 was given by <ref> [Mac77] </ref>. It is an optimization based on the idea that if needed, c ij can be computed as the converse of c ji , which saves half of the computation, and that c ii can only be equality. <p> So we can replace newc by ctr in the above implementation. If the simplification step is performed (sufficiently often) before a propagation step, then termination is guaranteed. Algorithm. The complete algorithm below takes the optimizations of PC-2 <ref> [Mac77] </ref> into account. The optimization is based on the idea that if needed, c ij can be computed as the converse of c ji , which saves about half of the computation, and that c ii can only be equality.
Reference: [MaFr85] <author> A. K. Mackworth and E. C. Freuder, </author> <title> The Complexity of Some Polynomial Network Consistency Algorithms for Constraint Satisfaction Problems, </title> <journal> Journal of Artificial Intelligence 25 </journal> <pages> 65-74, </pages> <year> 1985. </year>
Reference-contexts: This means for each triple of nodes (i; k; j) we repeatedly compute c ij := c ij c ik c kj until a fixpoint is reached. The complexity of such an algorithm is O (n 3 ), where n is the number of nodes in the network <ref> [MaFr85] </ref>. For example, given If&lt;; =gK ^ Kf&lt;; =gJ ^ If=; &gt;gJ , and taking the triple (i; j; k), then c ik c kj results in If&lt;; =gJ , the result of intersecting with c ij is If=gJ .
Reference: [Mei91] <author> I. Meiri, </author> <title> Combining Qualitative and Quantitative Constraints in Temporal Reasoning, </title> <booktitle> AAAI 91, </booktitle> <pages> pp 260-267. </pages>
Reference-contexts: of constraint solving in the same formalism as the rest of the program greatly facilitates the prototyping, extension, specialization and combination of constraint solvers as well as reasoning about correctness, termination and confluence of a set of CH rules. 2 Preliminaries In this section we introduce the framework of Meiri <ref> [Mei91] </ref>. It integrates many forms of temporal relations qualitative and quantitative (metric) over time points and intervals by considering them as disjunctive binary constraints. We give the primitive relations for various forms of temporal constraints. <p> Point Interval Constraints <ref> [Mei91] </ref>. There are 5 possible primitive constraints between a point and an interval. Note that there cannot be equality. Again, the primitive constraints can be defined in terms of the end-points of the interval. Let X be a point, J=[U; V ] an interval.
Reference: [Sar89] <author> V. A. Saraswat, </author> <title> Concurrent Constraint Programming Languages, </title> <type> Ph.D. Dissertation, </type> <institution> Carnegie Mellon Univ., </institution> <note> also TR CMU-CS-89-108, </note> <year> 1989. </year>
Reference-contexts: The purpose of this paper is to show how our approach is beneficial for understanding and developing temporal reasoning and constraint consistency techniques. Constraint logic programming (CLP) <ref> [JaLa87, Sar89, Coh90, VH91] </ref> combines the advantages of logic programming and constraint solving. In logic programming, problems are stated in a declarative way using rules to define relations (predicates). Problems are solved by the built-in logic programming engine (LPE) using nondeterministic backtrack search. <p> These various constructs have been generalized into CH rules. CH rules are essentially multi-headed guarded rules and as such have their roots in concurrent logic programming languages [Sha89] and can be related to the Swedish branch of the Andorra family [HaJa90] and Saraswats cc-framework of concurrent constraint programming <ref> [Sar89] </ref>. However these general purpose programming languages lack features essential to define non-trivial constraint evaluation, namely multi-headed guarded rules and and a way to define constraint propagation by rules, while CH rules form a special purpose language extension for user-defined constraint solvers.
Reference: [Sha89] <author> E. Shapiro, </author> <title> The Family of Concurrent Logic Programming Languages, </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 413-510, </pages> <month> September </month> <year> 1989. </year> <month> 17 </month>
Reference-contexts: These constructs have been called "demon constructs" [D*88] because of their event-driven activation whenever new information is available. These various constructs have been generalized into CH rules. CH rules are essentially multi-headed guarded rules and as such have their roots in concurrent logic programming languages <ref> [Sha89] </ref> and can be related to the Swedish branch of the Andorra family [HaJa90] and Saraswats cc-framework of concurrent constraint programming [Sar89].
Reference: [Smo91] <author> G. Smolka, </author> <title> Residuation and Guarded Rules for Constraint Logic Programming, </title> <institution> Digital Equipment Paris Research Laboratory Research Report, France, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: This view that provides a tight and sound integration of the host language with user-defined constraint solvers and also motivates the work of Smolka on Guarded Rules <ref> [Smo91] </ref>.
Reference: [VH91] <author> P. van Hentenryck, </author> <title> Constraint Logic Programming, </title> <journal> The Knowledge Engineering Review, </journal> <volume> Vol 6:3, </volume> <year> 1991, </year> <pages> pp 151-194. </pages>
Reference-contexts: The purpose of this paper is to show how our approach is beneficial for understanding and developing temporal reasoning and constraint consistency techniques. Constraint logic programming (CLP) <ref> [JaLa87, Sar89, Coh90, VH91] </ref> combines the advantages of logic programming and constraint solving. In logic programming, problems are stated in a declarative way using rules to define relations (predicates). Problems are solved by the built-in logic programming engine (LPE) using nondeterministic backtrack search.
Reference: [ViKa86] <author> M. Vilain, H. Kautz, </author> <title> Constraint Propagation Algorithms for Temporal Reasoning, </title> <booktitle> AAAI 86, </booktitle> <pages> pp 377-382. </pages>
Reference-contexts: Disjunctive binary constraints allow us to model various forms of temporal constraints. A f&lt;g B; A f&lt;; &gt;g B; A f&lt;; =; &gt;g B are disjunctive binary constraints c AB between A and B. A f&lt;; &gt;g B is the same as A 6= B. Qualitative Point Constraints <ref> [ViKa86] </ref>. Variables represent time points and there are three primitive constraints &lt;; =; &gt;. &lt; is the converse of &gt; and equality is the converse of 2 itself. Quantitative Point Constraints [DMP91].
References-found: 17

