URL: http://www.eecs.umich.edu/~gurevich/Opera/117.ps
Refering-URL: http://www.eecs.umich.edu/~gurevich/annotated.html
Root-URL: http://www.cs.umich.edu
Title: Equivalence Is In The Eye Of The Beholder  
Author: Yuri Gurevich and James K. Huggins 
Address: Ann Arbor, MI, 48109-2122, USA.  
Affiliation: EECS Department, University of Michigan,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> E. Borger, </author> <title> "Annotated Bibliography on Evolving Algebras", in Specification and Validation Methods, </title> <editor> ed. E. Borger, </editor> <publisher> Oxford University Press, </publisher> <year> 1995, </year> <pages> 37-51. </pages>
Reference-contexts: An N process ring buffer C pcsp , in Pseudo-CSP. Fig. 5. Moves of C pcsp . 4 p pp [0] pp <ref> [1] </ref> pp [2] pp [3] 1 1 0 0 0 3 1 1 1 0 5 0 1 1 1 . . . . . . . . . Fig. 6.
Reference: [2] <author> E. Borger and I. D - urd -anovic, </author> <title> "Correctness of compiling Occam to Transputer code." </title> <journal> Computer Journal, </journal> <volume> vol. 39, no. 1, </volume> <year> 1996, </year> <pages> 52-92. </pages>
Reference-contexts: An N process ring buffer C pcsp , in Pseudo-CSP. Fig. 5. Moves of C pcsp . 4 p pp [0] pp [1] pp <ref> [2] </ref> pp [3] 1 1 0 0 0 3 1 1 1 0 5 0 1 1 1 . . . . . . . . . Fig. 6. <p> Comment for CSP experts. Synchronization is implicit in CSP. It is a built-in magic of CSP. We have doers of synchronization. (In this connection, the reader may want to see the EA treatment of Occam in <ref> [2] </ref>.) Nevertheless, synchronization remains abstract. In a sense the abstraction level is even higher: similar agents can synchronize more than two processes. Comment. The nondeterministic formalizations of the input and output environments are abstract and may be refined in many ways. Initial states.
Reference: [3] <author> E. Borger and D. Rosenzweig, </author> <title> "The WAM definition and compiler correctness," In L.C. </title> <editor> Beierle and L. Pluemer, eds., </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications, North-Holland Series in Computer Science and Artificial Intelligence, </booktitle> <year> 1994. </year>
Reference-contexts: An N process ring buffer C pcsp , in Pseudo-CSP. Fig. 5. Moves of C pcsp . 4 p pp [0] pp [1] pp [2] pp <ref> [3] </ref> 1 1 0 0 0 3 1 1 1 0 5 0 1 1 1 . . . . . . . . . Fig. 6. The correspondence between values of pp and p, for N = 4. 1.2 Discussion There are three issues where we disagree with Lamport. <p> Since its introduction, this methodology has been used for a wide variety of applications: programming language semantics, hardware specification, protocol verification, etc.. It has been used to show equivalences of various kinds, including equivalences across a variety of abstraction levels for various real-world systems, e.g. <ref> [3] </ref>. See [1,10] for numerous other examples. We recall here only as much of evolving algebra definitions [6] as needed in 7 this paper. Evolving algebras (often abbreviated ealgebras or EA) have many other capabilities not shown here: for example, creating or destroying agents during the evolution.
Reference: [4] <author> Y. Gurevich, </author> <title> "Logic and the challenge of computer science." </title> <editor> In E. Borger, editor, </editor> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <pages> pp. 1-57, </pages> <publisher> Computer Science Press, </publisher> <year> 1988. </year> <month> 32 </month>
Reference-contexts: Issue 1: The Notion of Equivalence. What does it mean that two programs are equivalent? In our opinion, the answer to the question depends on the desired abstraction <ref> [4] </ref>. There are many reasonable definitions of equivalence.
Reference: [5] <author> Y. Gurevich, </author> <title> "Evolving Algebras: An Attempt to Discover Semantics", </title> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <editor> eds. G. Rozenberg and A. Salomaa, </editor> <publisher> World Scientific, </publisher> <year> 1993, </year> <pages> 266-292. </pages> <note> (First published in Bull. EATCS 57 (1991), 264-284; an updated version appears in [10].) </note>
Reference-contexts: We simply point out that "the insubstantiality of processes" may itself be in the eye of the beholder. The same two programs can be equivalent with respect to some reasonable definitions of equivalence and inequivalent with respect to others. 2 Evolving Algebras Evolving algebras were introduced in <ref> [5] </ref>; a more detailed definition has appeared in [6]. Since its introduction, this methodology has been used for a wide variety of applications: programming language semantics, hardware specification, protocol verification, etc..
Reference: [6] <author> Y. Gurevich, </author> <title> "Evolving Algebras 1993: Lipari Guide", in Specification and Validation Methods, </title> <editor> ed. E. Borger, </editor> <publisher> Oxford University Press, </publisher> <year> 1995, </year> <pages> 9-36. </pages>
Reference-contexts: The same two programs can be equivalent with respect to some reasonable definitions of equivalence and inequivalent with respect to others. 2 Evolving Algebras Evolving algebras were introduced in [5]; a more detailed definition has appeared in <ref> [6] </ref>. Since its introduction, this methodology has been used for a wide variety of applications: programming language semantics, hardware specification, protocol verification, etc.. It has been used to show equivalences of various kinds, including equivalences across a variety of abstraction levels for various real-world systems, e.g. [3]. <p> It has been used to show equivalences of various kinds, including equivalences across a variety of abstraction levels for various real-world systems, e.g. [3]. See [1,10] for numerous other examples. We recall here only as much of evolving algebra definitions <ref> [6] </ref> as needed in 7 this paper. Evolving algebras (often abbreviated ealgebras or EA) have many other capabilities not shown here: for example, creating or destroying agents during the evolution. <p> To fire this update, redefine the successor of a; the new successor is a itself. This update destroys the ring (unless the ring had only one node). To guard from such undesirable changes, the function Next can be declared static (see <ref> [6] </ref>) which will make any update of Next illegal. An update set over a state S is a set of updates of S. An update set is consistent at S if no two updates in the set have the same location but different values. <p> The new rules use variables. Formal treatment of variables requires some care but the semantics of the new rules is quite obvious, especially because we do not need to nest constructors with variables here. Thus we skip the formalities and refer the reader to <ref> [6] </ref>. As above S is a state of sufficiently rich vocabulary. A parallel synchronous rule (or declaration rule, as in [6]) R has the form: var x ranges over U R (x) endvar where x is a variable name, U is a universe name, and R (x) can be viewed as <p> Thus we skip the formalities and refer the reader to <ref> [6] </ref>. As above S is a state of sufficiently rich vocabulary. A parallel synchronous rule (or declaration rule, as in [6]) R has the form: var x ranges over U R (x) endvar where x is a variable name, U is a universe name, and R (x) can be viewed as a rule template with free variable x. <p> The names of the modules reflect the intended meanings. In particular, modules BuffFrontEnd and BuffBackEnd correspond to the two processes Receiver and Sender of R pcsp . Comment for ealgebraists. In terms of <ref> [6] </ref>, the InputChannel agent is a two-member team comprising the InputEnvironment and the BuffFrontEnd agents; functions Sender and Receiver are similar to functions Member 1 and Member 2 . Similarly the OutputChannel agent is a team.
Reference: [7] <author> Y. Gurevich, "Platonism, </author> <title> Constructivism, and Computer Proofs vs. Proofs by Hand", </title> <journal> Bull. </journal> <note> EATCS 57 (1995), 145-166. </note>
Reference-contexts: Our complete proof, with "Q.E.D." steps and low-level reasoning omitted, appears in Appendix A. We prefer to separate the process of explaining a proof to people from the process of computer-aided verification of the same proof <ref> [7] </ref>. A human-oriented exposition is much easier for humans to read and understand than expositions attempting to satisfy both concerns at once. Writing a good human-oriented proof is the art of creating the correct images in the mind of the reader.
Reference: [8] <author> Y. Gurevich, and J. Huggins, </author> <title> "The Semantics of the C Programming Language," </title> <booktitle> in Seected papers from CSL'92 (Computer Science Logic), Springer Lecture Notes in Computer Science 702, </booktitle> <year> 1993, </year> <pages> 274-308. </pages>
Reference-contexts: 10 if Token1 = Token2 then Colored (Token1) := true endif Its meaning is the following: if the two tokens are at the same node, then color that node. 2.4 Rules with Variables Basic rules are sufficient for many purposes, e.g. to give operational semantics for the C programming language <ref> [8] </ref>, but in this paper we need two additional rule constructors. The new rules use variables. Formal treatment of variables requires some care but the semantics of the new rules is quite obvious, especially because we do not need to nest constructors with variables here.
Reference: [9] <author> C.A.R. Hoare, </author> <title> "Communicating sequential processes." </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-667, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: These dependencies are illustrated pictorially in Figure 1, where circles represent the actions to be taken and arrows represent dependency relationships between actions. Fig. 1. Moves of the ring-buffer algorithm. Lamport writes the two programs in a semi-formal language reminiscent of CSP <ref> [9] </ref> which we call Pseudo-CSP. The first program, which we denote by R pcsp , is shown in Figure 2. It operates the buffer using two processes; one handles input into the buffer and the other handles output from the buffer.
Reference: [10] <author> J. Huggins, ed., </author> <title> "Evolving Algebras Home Page", </title> <institution> EECS Department, University of Michigan, </institution> <note> http://www.eecs.umich.edu/ealgebras/. </note>
Reference: [11] <author> L. Lamport, </author> <title> "How to write a proof." </title> <type> Research Report 94, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> February </month> <year> 1993. </year> <note> To appear in American Mathematical Monthly. </note>
Reference-contexts: Moreover, the same inequivalence arguments apply to R pcsp and C pcsp as well. 6 Issue 3: The Formality of Proofs. Continuing, Lamport writes [13]: We now give a hierarchically structured proof that 2 and N [the TLA translations of R pcsp and C pcsp - GH] are equivalent <ref> [11] </ref>. The proof is completely formal, meaning that each step is a mathematical formula. English is used only to explain the low-level reasoning.
Reference: [12] <author> L. Lamport, </author> <title> "The temporal logic of actions." </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: In Section 3, we will give a more complete explanation of the two programs in terms of evolving algebras. After presenting the two algorithms in Pseudo-CSP, Lamport describes them by means of formulas in TLA, the Temporal Logic of Actions <ref> [12] </ref>, and proves 2 in, out : channel of Value buf : array 0 : : : N 1 of Value p; g : internal Natural initially 0 Receiver :: fl 2 4 p := p + 1 7 k Sender :: fl 2 4 g := g + 1 7 <p> We do not know how to write a completely formal proof that two programming language representations of the ring buffer are equivalent. In Section 2, we represent the program formally in TLA, the Temporal Logic of Actions <ref> [12] </ref>. We believe that it is not only possible but also beneficial to give a rigorous meaning to one's programming language and to prove the desired equivalence of programs directly. The evolving algebra method has been used to give rigorous meaning to various programming languages [1,10].
Reference: [13] <author> L. Lamport, </author> <title> "Processes are in the Eye of the Beholder." </title> <type> Research Report 132, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1994. </year> <month> 33 </month>
Reference-contexts: 1 Introduction This is a reaction to Leslie Lamport's "Processes are in the Eye of the Be holder" <ref> [13] </ref>. Lamport writes: A concurrent algorithm is traditionally represented as the composition of processes. We show by an example that processes are an artifact of how an algorithm is represented. <p> However, Lamport provides a hint as to why the two programs themselves are equivalent. There is a close correspondence of values between p and pp, and between g and gg. Figure 6, taken from <ref> [13] </ref>, illustrates the correspondence between p and pp for N = 4. The nth row describes the values of variables p and pp after n inputs. <p> However, they are not equivalent in the sense of definition (iv) for certain observers, or in the sense of some space-complexity versions of definitions (ii) and (iii). See Section 5 in this connection. Issue 2: Representing Programs as Formulas. Again, we quote Lam-port <ref> [13] </ref>: We will not attempt to give a rigorous meaning to the program text. Programming languages evolved as a method of describing algorithms to compilers, not as a method for reasoning about them. <p> Then we point out that our programs are inequivalent according to some natural definitions of equivalence. Moreover, the same inequivalence arguments apply to R pcsp and C pcsp as well. 6 Issue 3: The Formality of Proofs. Continuing, Lamport writes <ref> [13] </ref>: We now give a hierarchically structured proof that 2 and N [the TLA translations of R pcsp and C pcsp - GH] are equivalent [11]. The proof is completely formal, meaning that each step is a mathematical formula. English is used only to explain the low-level reasoning.
References-found: 13

