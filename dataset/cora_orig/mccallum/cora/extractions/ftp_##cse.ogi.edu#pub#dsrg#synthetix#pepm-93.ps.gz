URL: ftp://cse.ogi.edu/pub/dsrg/synthetix/pepm-93.ps.gz
Refering-URL: http://www.cse.ogi.edu/~walpole/publications.html
Root-URL: http://www.cse.ogi.edu
Email: fconsel,pu,walpoleg@cse.ogi.edu  
Title: Incremental Partial Evaluation: The Key to High Performance, Modularity and Portability in Operating Systems  
Author: Charles Consel Calton Pu Jonathan Walpole 
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Vadim Abrossimov, Marc Rozier, and Marc Shapiro. </author> <title> Generic Virtual Memory Management for Operating System Kernels. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Operating Systems Principles, </booktitle> <month> December 3-6 </month> <year> 1989. </year> <note> Also published as technical report CS/TR-89-18. </note>
Reference-contexts: Some micro-kernel OS's do define various machine-independent interfaces within their micro-kernels, but these are unrelated to the system structuring mechanisms used in the higher layers of their OS code, and make a coarse-grained distinction between machine-dependent and portable code <ref> [1, 11] </ref>. This coarse-grained approach limits portability by limiting the amount of code that can be reused. The state of the art in OS design can be summarized as follows. The vast majority of OS's in active use are monolithic, having traded portability and modularity for performance.
Reference: [2] <author> David L. Black, David B. Golub, Daniel P. Julin, Richard F. Rashid, Richard P. Draves, Randall W. Dean, Alessandro Forin, Joseph Barrera, Hideyuki Tokuda, Gerald Malan, and David Bohman. </author> <title> Micro-kernel Operating System Architecture and Mach. </title> <booktitle> In Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 11-30, </pages> <address> Seattle WA (USA), </address> <month> April </month> <year> 1992. </year> <booktitle> Usenix. </booktitle>
Reference-contexts: 1 Introduction The most prominent recent trend in operating system (OS) design has been the move towards micro-kernel based OS's <ref> [2, 8, 9, 12, 14] </ref>. Micro-kernel based OS's allow high-level OS code to be structured as a collection of modules above a minimal kernel.
Reference: [3] <author> Allan Bricker, Michel Gien, Marc Guillemont, Jim Lip-kis, Douglas Orr, and Marc Rozier. </author> <title> A New Look at Microkernel-Based UNIX Operating Systems; Lessons in Performance and Compatibility. </title> <booktitle> In Proceedings of the USENIX Winter Conference, </booktitle> <address> Dallax, TX, </address> <month> January 21-25, </month> <year> 1991. </year> <note> Also published as technical report CS/TR-90-69. </note>
Reference-contexts: Micro-kernel based OS's allow high-level OS code to be structured as a collection of modules above a minimal kernel. Despite the many advantages of this modular approach, the performance overhead associated with existing modular implementations has proven to be a major liability in the commercial acceptance of these systems <ref> [3] </ref>. Finding a solution to the conflict between performance and modularity remains a critical research issue of practical importance. Contrary to popular belief, the micro-kernel approach to OS structuring does not lead to major improvements in portability.
Reference: [4] <author> Charles Consel and Olivier Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 493-501, </pages> <year> 1993. </year>
Reference-contexts: Consequently, the OS code is initially very high-level and comprehensive, allowing a high-degree of portability, and then gradually adapts to its environment in a manner that allows it to achieve better performance. 3 Optimization via Incremental Partial Evaluation Traditional partial evaluation <ref> [4, 13] </ref> is a program transformation technique for specializing a program with respect to some known parts of its input. Since many situations can be shown to be "specializations" of a more general problem, this provides the basis for a simple and automatic approach to program development. <p> Partial evaluation generically removes this interpretive overhead at compile time, yielding faster specialized routines for run time <ref> [4] </ref>. This notion of binding time can be also applied to a system utility like file management. Opening a file requires one to supply information that will not change until that file is closed, e.g.,, read/write mode and file format.
Reference: [5] <author> N. D. Jones and S. S. Muchnick. </author> <title> Some thoughts towards the design of an ideal language. </title> <booktitle> In ACM Conference on Principles of Programming Languages, </booktitle> <pages> pages 77-94, </pages> <year> 1976. </year>
Reference-contexts: As illustrated by these two examples, our use of incremental partial evaluation is based on invariants that become known at various stages. A related approach was proposed by Jones and Muchnick to design an "ideal programming language", several years ago <ref> [5] </ref>. 5 Conclusions The basic goal of our approach is to investigate the application of multi-level programming and incremental partial evaluation in OS's. We suggest that these techniques are the key to high-performance, modular, and portable OS's.
Reference: [6] <author> Henry Massalin and Calton Pu. </author> <title> Threads and input/output in the Synthesis kernel. </title> <booktitle> In Proceedings of the Twelfth Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <address> Arizona, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: However, this assumption remains to be validated. The wealth of incremental partial evaluation techniques proposed here also introduces a tight coupling between the compiler, specializer and in some cases the OS itself. In the Synthesis project <ref> [6, 10] </ref>, we already demonstrated the performance gains at execution time far outweigh code generation costs in a carefully hand-tuned kernel. Here, the challenge is to show that similar high performance and modularity can be achieved in a systematic way, without sacrificing portability.
Reference: [7] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Multi-level program structuring is the technique we propose for extending programs in a manner that makes them amenable to incremental partial evaluation. We plan to gradually rewrite existing systems, and construct new systems using a multi-level programming language based on Standard ML <ref> [7] </ref>. ML has a well-defined semantics and is strongly typed, both features are essential for a systematic application of partial evaluation. We also expect the higher-order functions and the parameterized module system to be useful for incremental partial evaluation.
Reference: [8] <author> Toshio Okamoto, Hideo Segawa, Sung Ho Shin, Hiroshi Nozue, Ken-ichi Maeda, and Mitsuo Saito. </author> <title> A Micro Kernel Architecture for Next Generation Processors. </title> <booktitle> In Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 83-94, </pages> <address> Seattle WA (USA), </address> <month> April </month> <year> 1992. </year> <booktitle> Usenix. </booktitle>
Reference-contexts: 1 Introduction The most prominent recent trend in operating system (OS) design has been the move towards micro-kernel based OS's <ref> [2, 8, 9, 12, 14] </ref>. Micro-kernel based OS's allow high-level OS code to be structured as a collection of modules above a minimal kernel.
Reference: [9] <author> Dave Presotto, Rob Pike, Ken Thompson, and Howard Trickey. </author> <title> Plan 9, A Distributed System. </title> <booktitle> In Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 31-37, </pages> <address> Seattle WA (USA), </address> <month> April </month> <year> 1992. </year> <booktitle> Usenix. </booktitle>
Reference-contexts: 1 Introduction The most prominent recent trend in operating system (OS) design has been the move towards micro-kernel based OS's <ref> [2, 8, 9, 12, 14] </ref>. Micro-kernel based OS's allow high-level OS code to be structured as a collection of modules above a minimal kernel.
Reference: [10] <author> Calton Pu, Henri Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <month> Winter </month> <year> 1988. </year>
Reference-contexts: The trade-off here is to generate these specialized routines fast enough to make it worth it to use the specialized routines. The Synthesis kernel uses hand-coded templates to generate the specialized routines <ref> [10] </ref>. As illustrated by these two examples, our use of incremental partial evaluation is based on invariants that become known at various stages. <p> However, this assumption remains to be validated. The wealth of incremental partial evaluation techniques proposed here also introduces a tight coupling between the compiler, specializer and in some cases the OS itself. In the Synthesis project <ref> [6, 10] </ref>, we already demonstrated the performance gains at execution time far outweigh code generation costs in a carefully hand-tuned kernel. Here, the challenge is to show that similar high performance and modularity can be achieved in a systematic way, without sacrificing portability.
Reference: [11] <author> Richard Rashid, Avadis Tevanian Jr., Michael Young, David Golub, Robert Baron, David Black, William J. Bolosky, and Jonathan Chew. </author> <title> Machine-independent virtual memory management for paged uniprocessor and multiprocessor architectures. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(8) </volume> <pages> 896-908, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Some micro-kernel OS's do define various machine-independent interfaces within their micro-kernels, but these are unrelated to the system structuring mechanisms used in the higher layers of their OS code, and make a coarse-grained distinction between machine-dependent and portable code <ref> [1, 11] </ref>. This coarse-grained approach limits portability by limiting the amount of code that can be reused. The state of the art in OS design can be summarized as follows. The vast majority of OS's in active use are monolithic, having traded portability and modularity for performance.
Reference: [12] <author> Marc Rozier, Vadim Abrossimov, F. Armand, I. Boule, Michel Gien, Marc Guillemont, F. Herrman, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> Overview of the Chorus Distributed Operating System. </title> <booktitle> In Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 39-70, </pages> <address> Seattle WA (USA), </address> <month> April </month> <year> 1992. </year> <booktitle> Usenix. </booktitle>
Reference-contexts: 1 Introduction The most prominent recent trend in operating system (OS) design has been the move towards micro-kernel based OS's <ref> [2, 8, 9, 12, 14] </ref>. Micro-kernel based OS's allow high-level OS code to be structured as a collection of modules above a minimal kernel.
Reference: [13] <author> Peter Sestoft and Alexander V. Zamulin. </author> <title> Annotated bibliography on partial evaluation and mixed computation. </title> <editor> In D. Bjtrner, A. P. Ershov, and N. D. Jones, editors, </editor> <title> Partial Evaluation and Mixed Computation. </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Consequently, the OS code is initially very high-level and comprehensive, allowing a high-degree of portability, and then gradually adapts to its environment in a manner that allows it to achieve better performance. 3 Optimization via Incremental Partial Evaluation Traditional partial evaluation <ref> [4, 13] </ref> is a program transformation technique for specializing a program with respect to some known parts of its input. Since many situations can be shown to be "specializations" of a more general problem, this provides the basis for a simple and automatic approach to program development.
Reference: [14] <author> Robbert van Renesse and Andrew S. Tanenbaum. </author> <title> Short Overview of Amoeba. </title> <booktitle> In Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 1-10, </pages> <address> Seattle WA (USA), </address> <month> April </month> <year> 1992. </year> <booktitle> Usenix. </booktitle>
Reference-contexts: 1 Introduction The most prominent recent trend in operating system (OS) design has been the move towards micro-kernel based OS's <ref> [2, 8, 9, 12, 14] </ref>. Micro-kernel based OS's allow high-level OS code to be structured as a collection of modules above a minimal kernel.
References-found: 14

