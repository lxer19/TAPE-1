URL: ftp://rtcl.eecs.umich.edu/outgoing/dlk/main.ps.Z
Refering-URL: http://www.eecs.umich.edu/RTCL/harts/
Root-URL: http://www.cs.umich.edu
Title: SWSL: A Synthetic Workload Specification Language for Real-Time Systems  
Author: Daniel L. Kiskis and Kang G. Shin 
Keyword: Index Terms Synthetic workloads, real-time workloads, distributed real-time systems, performance and dependability measurement experiments.  
Date: April 11, 1995  
Address: Ann Arbor, Michigan 48109-2122  
Affiliation: Real-Time Computing Laboratory Computer Science and Engineering Division Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: In this paper we discuss the issues which must be addressed in the specification and generation of synthetic workloads for distributed real-time systems. We describe a synthetic workload specification language (SWSL) which defines a workload in a form that can be compiled by a synthetic workload generator (SWG) to produce an executable synthetic workload. The synthetic workload is then downloaded to the target machine and executed while performance and dependability measurements are made. SWSL defines the workload at the task level using a dataflow graph and at the operation level using control constructs and synthetic operations taken from a library. It is intended to be easy to use, flexible, and capable of creating synthetic workloads which are representative of real real-time workloads. It provides a compact, parameterized notation. It supports automatic replication of objects to facilitate the specification of large workloads for distributed real-time systems. It also provides extensive support for the experimentation process. The work reported in this report was supported in part by the National Science Foundation under Grants MIP-9012549 and MIP-9203895, the NASA under Grant No. NAG-1-492, and the Office of Naval Research under Grant No. N00014-91-J-1115. Since September 1992, Daniel L. Kiskis has been with the U.S. Naval Research Laboratory, Washington, DC. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. K. Agrawala, J. M. Mohr, and R. M. Bryant, </author> <title> "An approach to the workload characterization problem," </title> <journal> IEEE Computer, </journal> <volume> vol. 9, no. 6, </volume> <pages> pp. 18-32, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: There are two uses for object templates. The first is to specify an object which represents a member of a class of objects with similar parameters. This technique is common in workload characterization [30] and has been used often to specify SWs, e.g., <ref> [1] </ref>. A set of n parameters are selected to define the important characteristics of the workload tasks. For each task, these parameters are measured and the task is plotted in the n-dimensional space defined by the parameter vector.
Reference: [2] <author> R. Baird, </author> <title> "APET a versatile tool for estimating computer application performance," </title> <journal> Software-Practice and Experience, </journal> <volume> vol. 3, </volume> <pages> pp. 385-395, </pages> <year> 1973. </year>
Reference-contexts: Given this observation, we use a structure-based method for constructing a representative SW. That is, the SW is specified and constructed such that its structure models that of the workload. Other researchers <ref> [2, 35] </ref> have successfully produced sufficiently accurate and flexible benchmark programs for uniprocessor systems by modeling the structure of the actual workload. We expect the technique to be successful for distributed systems as well. <p> The operations and control constructs from the workload model have been adapted for specifying SWs. Computation and communication are implemented with synthetic operations. Synthetic operations exercise specific resources in a predefined manner. The use of synthetic operations has been described in <ref> [2, 35, 33] </ref>. The synthetic operations are located in a library of operations. Synthetic operations are implemented as C functions. These functions are parameterized so the user can control their behavior. By defining them as functions, we hide the implementation details.
Reference: [3] <author> R. Blumofe and A. Hecht, </author> <title> "Executing real-time structured analysis specifications," </title> <journal> ACM Software Engineering Notes, </journal> <volume> vol. 13, no. 3, </volume> <pages> pp. 32-40, </pages> <month> July </month> <year> 1988. </year>
Reference: [4] <author> W. Bruyn, R. Jensen, D. Keskar, and P. Ward, "ESML: </author> <title> An extended systems modeling language based on the data flow diagram," </title> <journal> ACM Software Engineering Notes, </journal> <volume> vol. 13, no. 1, </volume> <pages> pp. 58-67, </pages> <year> 1988. </year>
Reference-contexts: The workload is described in terms of a dataflow graph, a notation commonly used to specify software for distributed real-time systems. The model is a generalization of the rapid prototyping languages such as PSDL [20], and structured analysis (SA) notations such as ESML <ref> [4] </ref> and others [36, 13]. SA notations are commonly used in CASE tools to specify and analyze the requirements and structure of real-time software. <p> These workload objects will be described in detail in the following sections. The graphical representation of all components are shown in Figure 1. These symbols are taken directly from the graphical representation for ESML <ref> [4] </ref>. 2.2.1 Transformations The set of transformations T represents the work done by the workload. Transformations encapsulate both the processing of data and the control logic of the workload. <p> We define D = fd j d = (v; s)g. Each unit of data has a value, v, and a size, s. 2.2.6 Interconnection Rules Construction of a workload with our model is based on the construction of one using ESML <ref> [4] </ref>. The model construction rules are specified formally by the definitions of the flow types. <p> A flow is specified implicitly using the OUTPUT parameter of the source object and the INPUT parameter of the destination object. Each INPUT, OUTPUT pair denotes a separate connection between the objects. In software specification languages such as ESML <ref> [4] </ref>, the Ward/Mellor transformation schema [36], and PSDL [20], all transformations must be connected by flows to other objects. A transformation that does not receive data from other objects is useless; it can not do useful work. In contrast, in the SW, no transformation does useful work.
Reference: [5] <author> W. Buchholz, </author> <title> "A synthetic job for measuring system performance," </title> <journal> IBM Systems Journal, </journal> <volume> vol. 8, no. 4, </volume> <pages> pp. 309-318, </pages> <year> 1969. </year>
Reference-contexts: The tasks, or jobs, which make up the SW, are selected to represent a particular application domain for a certain class of computers. Early SWs were designed to represent typical business applications running on a mainframe computer, e.g., <ref> [5, 40, 29, 18] </ref>. SW design was later studied extensively by Ferrari [9, 10, 11]. However, his work also concentrated on general-purpose uniprocessor computers. At the Real-Time Computing Laboratory of The University of Michigan, we are designing and building the Hexagonal Architecture for Real-Time Systems (HARTS) [31].
Reference: [6] <author> R. M. Cohen, </author> <title> "Formal specifications for real-time systems," </title> <booktitle> in Proc. Texas Conference on Computing Systems, </booktitle> <pages> pp. </pages> <address> 1.1-1.8. </address> <publisher> IEEE, </publisher> <year> 1978. </year>
Reference-contexts: In a real-time system, the value of a computation depends not only on the logical correctness of the results, but also on the time at which the results are produced. This definition describes a class of systems with characteristics that set them and their workloads apart from general-purpose systems <ref> [22, 34, 6] </ref>. They are usually embedded in a larger system that performs a particular function. The real-time system serves as the controller computer for this larger system. The real-time system is designed to execute specific application software required to control the larger system.
Reference: [7] <author> H. Falk, </author> <title> "CASE tools emerge to handle real-time systems," </title> <booktitle> Computer Design, </booktitle> <volume> vol. 27, no. 1, </volume> <pages> pp. 53-74, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Therefore, a workload specified using our model is portable and may be used to comparatively evaluate different systems. * As real-time software becomes more complex, the use of structured methods to design the software will become widespread. The design process will be supported by computer-aided software engineering (CASE) tools <ref> [7, 26] </ref>. Our approach allows the SWG to become an integral part of a CASE tool. A number of CASE tools use SA and similar notations. Hence, high-level software designs created by CASE tools can be translated to our model and used by the SWG to create SWs.
Reference: [8] <author> F. Feather, D. Siewiorek, and Z. Segall, </author> <title> "Validation of a fault-tolerant multiprocessor: Synthetic workload implementation," </title> <booktitle> in Proc. Int'l Conf. on Distributed Computing Systems, </booktitle> <pages> pp. 303-312, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: The SWs which had been developed for general-purpose systems are inadequate for use on a distributed real-time system like HARTS. They are unable to accurately reproduce the behaviors which are characteristic of real-time workloads. Previous SWs developed for real-time systems, e.g., one for FTMP <ref> [8] </ref> and an early one for HARTS [41], were too inflexible and had no provisions to exercise communication facilities of a distributed system. An SW for a general-purpose distributed computer system was proposed by Singh and Segall [33, 32].
Reference: [9] <author> D. Ferrari, </author> <title> "Workload characterization and selection in computer performance measurement," </title> <journal> IEEE Computer, </journal> <volume> vol. 5, no. 4, </volume> <pages> pp. 18-24, </pages> <month> July </month> <year> 1972. </year>
Reference-contexts: Early SWs were designed to represent typical business applications running on a mainframe computer, e.g., [5, 40, 29, 18]. SW design was later studied extensively by Ferrari <ref> [9, 10, 11] </ref>. However, his work also concentrated on general-purpose uniprocessor computers. At the Real-Time Computing Laboratory of The University of Michigan, we are designing and building the Hexagonal Architecture for Real-Time Systems (HARTS) [31].
Reference: [10] <author> D. Ferrari, </author> <title> Computer Systems Performance Evaluation, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, </address> <year> 1978. </year>
Reference-contexts: Early SWs were designed to represent typical business applications running on a mainframe computer, e.g., [5, 40, 29, 18]. SW design was later studied extensively by Ferrari <ref> [9, 10, 11] </ref>. However, his work also concentrated on general-purpose uniprocessor computers. At the Real-Time Computing Laboratory of The University of Michigan, we are designing and building the Hexagonal Architecture for Real-Time Systems (HARTS) [31]. <p> Previous approaches to modeling workloads consisted of capturing the behavior of the workload using queueing networks or describing the workload in terms of a vector quantifying the workload characteristics <ref> [10] </ref>. However, the properties of a real-time workload are not accurately modeled by a queueing network or as a simple vector of workload parameters because these techniques model average-case performance. Therefore, they cannot capture the details of the timing characteristics of the workload.
Reference: [11] <author> D. Ferrari, </author> <booktitle> "On the foundations of artificial workload design," in Proc. of 1984 ACM SIGMETRICS Conf. on Meas. and Modeling of Comp. Sys., </booktitle> <pages> pp. 8-14, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Early SWs were designed to represent typical business applications running on a mainframe computer, e.g., [5, 40, 29, 18]. SW design was later studied extensively by Ferrari <ref> [9, 10, 11] </ref>. However, his work also concentrated on general-purpose uniprocessor computers. At the Real-Time Computing Laboratory of The University of Michigan, we are designing and building the Hexagonal Architecture for Real-Time Systems (HARTS) [31]. <p> To measure representativeness, we use a performance-based metric. By this metric, an SW is representative of a workload if the performance of the system (as measured by a set of performance indices) while executing the SW is the same as the performance while executing the workload <ref> [11] </ref>. However, "[e]xcept for certain cases : : :, this definition of [representativeness] does not directly suggest a method for designing an artificial workload" [11]. Given this observation, we use a structure-based method for constructing a representative SW. <p> performance of the system (as measured by a set of performance indices) while executing the SW is the same as the performance while executing the workload <ref> [11] </ref>. However, "[e]xcept for certain cases : : :, this definition of [representativeness] does not directly suggest a method for designing an artificial workload" [11]. Given this observation, we use a structure-based method for constructing a representative SW. That is, the SW is specified and constructed such that its structure models that of the workload.
Reference: [12] <author> H. Gomaa, </author> <title> "A software design method for real-time systems," </title> <journal> Communications of the ACM, </journal> <volume> vol. 27, no. 9, </volume> <pages> pp. 938-949, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: These features provide a generality which makes our model flexible and thus more widely applicable. So, it is capable of modeling the features of a number of SA, rapid prototyping, and other notations like those in <ref> [25, 12, 21] </ref>, and can be used to describe a wide range of real-time workloads which have been specified using these notations. Our model extends these notations to specify the timing and resource usage properties of the workload.
Reference: [13] <author> D. J. Hatley and I. A. Pribhai, </author> <title> Strategies for Real-Time System Specification, </title> <publisher> Dorset House Publishing, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: The workload is described in terms of a dataflow graph, a notation commonly used to specify software for distributed real-time systems. The model is a generalization of the rapid prototyping languages such as PSDL [20], and structured analysis (SA) notations such as ESML [4] and others <ref> [36, 13] </ref>. SA notations are commonly used in CASE tools to specify and analyze the requirements and structure of real-time software. The dataflow model captures the basic aspects of the workload like parallelism and inter 5 actions between tasks, and it allows for modeling at multiple levels of abstraction. <p> This model will generally be a good approximation of the structure of the workload <ref> [13] </ref>. Thus, by using a similar model for our SW, we can produce an SW which will closely approximate the structure and behavior of the proposed software. The experimental evaluations performed using this SW will then provide useful and meaningful results.
Reference: [14] <author> D. L. Kiskis and K. G. Shin, </author> <title> "A synthetic workload for real-time systems," </title> <booktitle> in Proc. Seventh IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <pages> pp. 77-81, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Furthermore, the B-language contains no support for specifying SWs for real-time systems. Since there are no other sufficiently powerful SWs for distributed real-time systems, we have designed and implemented our own SW <ref> [14, 15] </ref>. The SW operates in a distributed 2 manner. Each processor executes a set of synthetic tasks and a driver process. The synthetic tasks produce the resource demands for the SW.
Reference: [15] <author> D. L. Kiskis, </author> <title> Generation of Synthetic Workloads for Distributed Real-Time Computing Systems, </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <month> August </month> <year> 1992. </year> <month> 33 </month>
Reference-contexts: Furthermore, the B-language contains no support for specifying SWs for real-time systems. Since there are no other sufficiently powerful SWs for distributed real-time systems, we have designed and implemented our own SW <ref> [14, 15] </ref>. The SW operates in a distributed 2 manner. Each processor executes a set of synthetic tasks and a driver process. The synthetic tasks produce the resource demands for the SW. <p> The level of representativeness may be measured by the performance-based metric. The ability of SWSL to produce representative SWs is demonstrated in <ref> [15] </ref>. 12 3.3 Flexibility Flexibility is another important characteristic of SWSL. If SWSL is to be useful for experimentation, it must be flexible. The user must be able to easily change the values of specific workload characteristics. <p> Based on statistical comparison, the SW was shown to be representative of the actual control software. The SWG was also used to evaluate the performance of the communication subsystem of HARTS under different workloads <ref> [15] </ref>. Enhancements to the language are being considered. One is to simplify the naming conventions for objects. In particular, we would devise a naming scheme which would allow multiple instantiations of an object from a template to reside on the same processor.
Reference: [16] <author> H. F. Ledgard and M. Marcotty, </author> <title> "A genealogy of control structures," </title> <journal> Communications of the ACM, </journal> <volume> vol. 18, no. 11, </volume> <pages> pp. 629-639, </pages> <month> November </month> <year> 1975. </year>
Reference-contexts: This accuracy cannot be obtained from a simple dataflow model [38]. It requires the more detailed specifications allowed by this model. The function specified by is defined based on the D-structures described by Ledgard and Marcotty <ref> [16] </ref>. The set of D-structures is a small functionally-complete set of control constructs for programs. They consist of simple operations, composition of D-structures, a conditional control construct, and a loop construct. A simple operation is any computation, system call, or input or output statement, etc. <p> For two D-structures s1 and s2, composition is represented as s1; s2. The conditional control construct is the "if condition then s1 else s2" construct. The looping construct is the "while condition do s" construct. With these constructs, all other control constructs may be realized <ref> [16] </ref>. The complete specification of a transformation depends on the system upon which it is to be implemented. Different operating systems require different information to create and schedule the implementation of the transformation. Therefore, the transformation specification includes a number of system-specific parameters, i .
Reference: [17] <author> C. D. Locke, </author> <title> "Generic avionic software," IBM Systems Integration Division, </title> <type> DRAFT, </type> <month> October </month> <year> 1988. </year>
Reference-contexts: The experimental evaluations performed using this SW will then provide useful and meaningful results. Similarly, developers of experimental systems can make use of published workload specifications <ref> [19, 17, 23, 39] </ref> to produce representative SWs to be used to evaluate their systems. * Since the workload is modeled at a high level of abstraction, the model is system independent. The model does not contain any information that is particular to a given hardware architecture or operating system.
Reference: [18] <author> H. C. Lucas, Jr., </author> <title> "Synthetic program specifications for performance evaluation," </title> <booktitle> in Proc. ACM Annual Conference, </booktitle> <pages> pp. 1041-1058, </pages> <address> Boston, </address> <month> August </month> <year> 1972. </year>
Reference-contexts: The tasks, or jobs, which make up the SW, are selected to represent a particular application domain for a certain class of computers. Early SWs were designed to represent typical business applications running on a mainframe computer, e.g., <ref> [5, 40, 29, 18] </ref>. SW design was later studied extensively by Ferrari [9, 10, 11]. However, his work also concentrated on general-purpose uniprocessor computers. At the Real-Time Computing Laboratory of The University of Michigan, we are designing and building the Hexagonal Architecture for Real-Time Systems (HARTS) [31].
Reference: [19] <author> G. A. Ludgate, B. Haley, L. Lee, and Y. N. Miles, </author> <title> "The use of structured analysis and design in the engineering of the TRIUMF data acquisition and analysis system," </title> <journal> IEEE Trans. Nuclear Science, </journal> <volume> vol. NS-34, no. 1, </volume> <pages> pp. 157-161, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: The experimental evaluations performed using this SW will then provide useful and meaningful results. Similarly, developers of experimental systems can make use of published workload specifications <ref> [19, 17, 23, 39] </ref> to produce representative SWs to be used to evaluate their systems. * Since the workload is modeled at a high level of abstraction, the model is system independent. The model does not contain any information that is particular to a given hardware architecture or operating system.
Reference: [20] <author> Luqi, V. Berzins, and R. T. Yeh, </author> <title> "A prototyping language for real-time software," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 14, no. 10, </volume> <pages> pp. 1409-1423, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: The workload is described in terms of a dataflow graph, a notation commonly used to specify software for distributed real-time systems. The model is a generalization of the rapid prototyping languages such as PSDL <ref> [20] </ref>, and structured analysis (SA) notations such as ESML [4] and others [36, 13]. SA notations are commonly used in CASE tools to specify and analyze the requirements and structure of real-time software. <p> A flow is specified implicitly using the OUTPUT parameter of the source object and the INPUT parameter of the destination object. Each INPUT, OUTPUT pair denotes a separate connection between the objects. In software specification languages such as ESML [4], the Ward/Mellor transformation schema [36], and PSDL <ref> [20] </ref>, all transformations must be connected by flows to other objects. A transformation that does not receive data from other objects is useless; it can not do useful work. In contrast, in the SW, no transformation does useful work.
Reference: [21] <author> H. G. Mendelbaum and D. Finkelman, "CASDA: </author> <title> Synthesized graphic design of real-time systems," </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> vol. 9, no. 1, </volume> <pages> pp. 40-46, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: These features provide a generality which makes our model flexible and thus more widely applicable. So, it is capable of modeling the features of a number of SA, rapid prototyping, and other notations like those in <ref> [25, 12, 21] </ref>, and can be used to describe a wide range of real-time workloads which have been specified using these notations. Our model extends these notations to specify the timing and resource usage properties of the workload.
Reference: [22] <author> A. K. Mok, </author> <title> "The design of real-time programming systems based on process models," </title> <booktitle> Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 5-17, </pages> <month> December </month> <year> 1984. </year>
Reference-contexts: In a real-time system, the value of a computation depends not only on the logical correctness of the results, but also on the time at which the results are produced. This definition describes a class of systems with characteristics that set them and their workloads apart from general-purpose systems <ref> [22, 34, 6] </ref>. They are usually embedded in a larger system that performs a particular function. The real-time system serves as the controller computer for this larger system. The real-time system is designed to execute specific application software required to control the larger system.
Reference: [23] <author> J. Molini, S. Maimon, and P. Watson, </author> <title> "Real time distributed system studies/scenarios," </title> <booktitle> in ONR Third Annual Workshop: Foundations of Real-Time Computing, </booktitle> <pages> pp. 187-209, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The experimental evaluations performed using this SW will then provide useful and meaningful results. Similarly, developers of experimental systems can make use of published workload specifications <ref> [19, 17, 23, 39] </ref> to produce representative SWs to be used to evaluate their systems. * Since the workload is modeled at a high level of abstraction, the model is system independent. The model does not contain any information that is particular to a given hardware architecture or operating system.
Reference: [24] <author> J. J. Molini, S. K. Maimon, and P. H. Watson, </author> <title> "Real-time system scenarios," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 214-225. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1990. </year>
Reference-contexts: Sharing a random number stream would cause correlation between actions that would be irreproducible in a nondeterministic environment. 4 An Example SW Specification We will present the structure of SWSL in the context of an example. The example system is the submarine passive sonar system developed at IBM <ref> [24] </ref>. We have followed the specification in [24] as closely as possible. In places where the specification was vague or incomplete, we made assumptions and fabricated details based on the informal descriptions in the specification. <p> The example system is the submarine passive sonar system developed at IBM <ref> [24] </ref>. We have followed the specification in [24] as closely as possible. In places where the specification was vague or incomplete, we made assumptions and fabricated details based on the informal descriptions in the specification. We will not present the entire specification, but instead will use components from the system to demonstrate the features of SWSL. <p> In this example, kinst (), sread (), and swrite () are synthetic operations. A call to kinst (n) executes n fi 1000 integer operations. This synthetic operation is used to produce the desired computation load, which is specified in Kiloinstructions in <ref> [24] </ref>. The sread and swrite operations are particularly important.
Reference: [25] <author> A. H. Muntz and R. W. Lichota, </author> <title> "A requirements specification method for adaptive real-time systems," </title> <booktitle> in Proc. Real-Time Systems Symposium, </booktitle> <pages> pp. 264-273. </pages> <publisher> IEEE, </publisher> <month> De-cember </month> <year> 1991. </year>
Reference-contexts: These features provide a generality which makes our model flexible and thus more widely applicable. So, it is capable of modeling the features of a number of SA, rapid prototyping, and other notations like those in <ref> [25, 12, 21] </ref>, and can be used to describe a wide range of real-time workloads which have been specified using these notations. Our model extends these notations to specify the timing and resource usage properties of the workload.
Reference: [26] <author> P. W. Oman, </author> <title> "CASE analysis and design tools," </title> <journal> IEEE Software, </journal> <volume> vol. 7, no. 3, </volume> <pages> pp. 37-43, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Therefore, a workload specified using our model is portable and may be used to comparatively evaluate different systems. * As real-time software becomes more complex, the use of structured methods to design the software will become widespread. The design process will be supported by computer-aided software engineering (CASE) tools <ref> [7, 26] </ref>. Our approach allows the SWG to become an integral part of a CASE tool. A number of CASE tools use SA and similar notations. Hence, high-level software designs created by CASE tools can be translated to our model and used by the SWG to create SWs.
Reference: [27] <author> P. Pulli, J. Dahler, H.-P. Gisiger, and A. Kundig, </author> <title> "Execution of Ward's transformation schema on the graphic specification and prototyping tool SPECS," </title> <booktitle> in COMPEURO-88 System Design: Concepts, Methods and Tools, </booktitle> <pages> pp. 16-25, </pages> <month> April </month> <year> 1988. </year>
Reference: [28] <author> E. L. Reilly and J. W. Brackett, </author> <title> "An experimental system for executing real-time structured analysis models," </title> <booktitle> in Proceedings, Twelfth Structured Methods Conference, </booktitle> <pages> pp. 301-314, </pages> <month> August </month> <year> 1987. </year>
Reference: [29] <author> H. D. Schwetman and J. C. Brown, </author> <title> "An experimental study of computer system performance," </title> <booktitle> in Proc. ACM Annual Conference, </booktitle> <pages> pp. 693-703, </pages> <year> 1972. </year>
Reference-contexts: The tasks, or jobs, which make up the SW, are selected to represent a particular application domain for a certain class of computers. Early SWs were designed to represent typical business applications running on a mainframe computer, e.g., <ref> [5, 40, 29, 18] </ref>. SW design was later studied extensively by Ferrari [9, 10, 11]. However, his work also concentrated on general-purpose uniprocessor computers. At the Real-Time Computing Laboratory of The University of Michigan, we are designing and building the Hexagonal Architecture for Real-Time Systems (HARTS) [31].
Reference: [30] <editor> G. Serazzi, editor, </editor> <title> Workload Characterization of Computer Systems and Computer Networks, </title> <publisher> North-Holland, </publisher> <year> 1985. </year> <month> 34 </month>
Reference-contexts: All instances of the object will have the same values of all the i parameters. There are two uses for object templates. The first is to specify an object which represents a member of a class of objects with similar parameters. This technique is common in workload characterization <ref> [30] </ref> and has been used often to specify SWs, e.g., [1]. A set of n parameters are selected to define the important characteristics of the workload tasks. For each task, these parameters are measured and the task is plotted in the n-dimensional space defined by the parameter vector.
Reference: [31] <author> K. G. Shin, </author> <title> "HARTS: A distributed real-time architecture," </title> <journal> IEEE Computer, </journal> <volume> vol. 24, no. 5, </volume> <pages> pp. 25-35, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: SW design was later studied extensively by Ferrari [9, 10, 11]. However, his work also concentrated on general-purpose uniprocessor computers. At the Real-Time Computing Laboratory of The University of Michigan, we are designing and building the Hexagonal Architecture for Real-Time Systems (HARTS) <ref> [31] </ref>. HARTS is a distributed real-time system consisting of a number of multiprocessor nodes connected by a custom hexagonal mesh interconnection network. HARTS is an experimental system which is to serve as a testbed for developing and evaluating real-time communication, fault-tolerance, and operating system concepts.
Reference: [32] <author> A. Singh, </author> <title> Pegasus: A Controllable, Interactive, Workload Generator for Multiprocessors, </title> <type> Master's thesis, </type> <institution> Carnegie Mellon University, </institution> <month> December </month> <year> 1981. </year>
Reference-contexts: Previous SWs developed for real-time systems, e.g., one for FTMP [8] and an early one for HARTS [41], were too inflexible and had no provisions to exercise communication facilities of a distributed system. An SW for a general-purpose distributed computer system was proposed by Singh and Segall <ref> [33, 32] </ref>. Their system, called Pegasus, was to produce SWs for a distributed system. They defined a novel language, the B-language, to describe the SWs. <p> An SW for a general-purpose distributed computer system was proposed by Singh and Segall [33, 32]. Their system, called Pegasus, was to produce SWs for a distributed system. They defined a novel language, the B-language, to describe the SWs. However, no compiler for the B-language was implemented <ref> [32] </ref>, and thus, the feasibility and usefulness of the language for specifying SWs for large systems has not been demonstrated. Furthermore, the B-language contains no support for specifying SWs for real-time systems.
Reference: [33] <author> A. Singh and Z. Segall, </author> <title> "Synthetic workload generation for experimentation with multiprocessors," </title> <booktitle> in Proc. Int'l Conf. on Distributed Computing Systems, </booktitle> <pages> pp. 778-785, </pages> <year> 1982. </year>
Reference-contexts: Previous SWs developed for real-time systems, e.g., one for FTMP [8] and an early one for HARTS [41], were too inflexible and had no provisions to exercise communication facilities of a distributed system. An SW for a general-purpose distributed computer system was proposed by Singh and Segall <ref> [33, 32] </ref>. Their system, called Pegasus, was to produce SWs for a distributed system. They defined a novel language, the B-language, to describe the SWs. <p> The operations and control constructs from the workload model have been adapted for specifying SWs. Computation and communication are implemented with synthetic operations. Synthetic operations exercise specific resources in a predefined manner. The use of synthetic operations has been described in <ref> [2, 35, 33] </ref>. The synthetic operations are located in a library of operations. Synthetic operations are implemented as C functions. These functions are parameterized so the user can control their behavior. By defining them as functions, we hide the implementation details. <p> By looping a random number of times, the loop simulates the behavior of data-dependent loops in the workload being modeled. Branching is accomplished using the SWITCH construct. It is a generalization of the if-then-else construct in the workload model. It is derived from the SWITCH operation in <ref> [33] </ref>. In the SWITCH statement, the user specifies alternate blocks of code to be executed. Probability values are assigned to each block. Each time the SWITCH is executed, one block is selected at random based on the probability value assigned to that block.
Reference: [34] <author> J. A. Stankovic, </author> <title> "Misconceptions about real-time computing: A serious problem for next-generation systems," </title> <journal> IEEE Computer, </journal> <volume> vol. 21, no. 10, </volume> <pages> pp. 10-19, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: In a real-time system, the value of a computation depends not only on the logical correctness of the results, but also on the time at which the results are produced. This definition describes a class of systems with characteristics that set them and their workloads apart from general-purpose systems <ref> [22, 34, 6] </ref>. They are usually embedded in a larger system that performs a particular function. The real-time system serves as the controller computer for this larger system. The real-time system is designed to execute specific application software required to control the larger system.
Reference: [35] <author> R. E. Walters, </author> <title> "Benchmark techniques: a constructive approach," </title> <journal> The Computer Journal, </journal> <volume> vol. 19, no. 1, </volume> <pages> pp. 50-55, </pages> <month> February </month> <year> 1976. </year>
Reference-contexts: Given this observation, we use a structure-based method for constructing a representative SW. That is, the SW is specified and constructed such that its structure models that of the workload. Other researchers <ref> [2, 35] </ref> have successfully produced sufficiently accurate and flexible benchmark programs for uniprocessor systems by modeling the structure of the actual workload. We expect the technique to be successful for distributed systems as well. <p> The operations and control constructs from the workload model have been adapted for specifying SWs. Computation and communication are implemented with synthetic operations. Synthetic operations exercise specific resources in a predefined manner. The use of synthetic operations has been described in <ref> [2, 35, 33] </ref>. The synthetic operations are located in a library of operations. Synthetic operations are implemented as C functions. These functions are parameterized so the user can control their behavior. By defining them as functions, we hide the implementation details.
Reference: [36] <author> P. T. Ward and S. J. Mellor, </author> <title> Structured Development for Real-Time Systems, volume 1-3, </title> <publisher> Yourdon Press, </publisher> <address> Englewood Cliffs, </address> <year> 1986. </year>
Reference-contexts: The workload is described in terms of a dataflow graph, a notation commonly used to specify software for distributed real-time systems. The model is a generalization of the rapid prototyping languages such as PSDL [20], and structured analysis (SA) notations such as ESML [4] and others <ref> [36, 13] </ref>. SA notations are commonly used in CASE tools to specify and analyze the requirements and structure of real-time software. The dataflow model captures the basic aspects of the workload like parallelism and inter 5 actions between tasks, and it allows for modeling at multiple levels of abstraction. <p> A flow is specified implicitly using the OUTPUT parameter of the source object and the INPUT parameter of the destination object. Each INPUT, OUTPUT pair denotes a separate connection between the objects. In software specification languages such as ESML [4], the Ward/Mellor transformation schema <ref> [36] </ref>, and PSDL [20], all transformations must be connected by flows to other objects. A transformation that does not receive data from other objects is useless; it can not do useful work. In contrast, in the SW, no transformation does useful work.
Reference: [37] <author> M. Webb and P. T. Ward, </author> <title> "Executable data flow diagrams: an experimental implementation," </title> <booktitle> Structured Development Forum VIII, </booktitle> <month> August </month> <year> 1986. </year>
Reference: [38] <author> S. M. White and J. Z. Lavi, </author> <title> "Embedded computer system requirements workshop," </title> <journal> IEEE Computer, </journal> <volume> vol. 18, no. 4, </volume> <pages> pp. 67-70, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: This flexibility in defining task interactions is necessary when specifying SWs for real-time systems. If the SW is to be representative of real applications, the synthetic tasks must accurately reproduce the complex timing and resource sharing dependencies between tasks. This accuracy cannot be obtained from a simple dataflow model <ref> [38] </ref>. It requires the more detailed specifications allowed by this model. The function specified by is defined based on the D-structures described by Ledgard and Marcotty [16]. The set of D-structures is a small functionally-complete set of control constructs for programs.
Reference: [39] <author> B. E. Withers, D. C. Rich, D. S. Lowman, and R. C. Buckland, </author> <title> "Software requirements: Guidance and control software development specification," </title> <type> NASA Contractor Report 182058, </type> <institution> Research Triangle Institute, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: The experimental evaluations performed using this SW will then provide useful and meaningful results. Similarly, developers of experimental systems can make use of published workload specifications <ref> [19, 17, 23, 39] </ref> to produce representative SWs to be used to evaluate their systems. * Since the workload is modeled at a high level of abstraction, the model is system independent. The model does not contain any information that is particular to a given hardware architecture or operating system.
Reference: [40] <author> D. C. Wood and E. H. Forman, </author> <title> "Throughput measurement using a synthetic job stream," </title> <booktitle> in AFIPS Fall Joint Computer Conference, </booktitle> <volume> volume 39, </volume> <pages> pp. 51-55, </pages> <month> Novem-ber </month> <year> 1971. </year>
Reference-contexts: The tasks, or jobs, which make up the SW, are selected to represent a particular application domain for a certain class of computers. Early SWs were designed to represent typical business applications running on a mainframe computer, e.g., <ref> [5, 40, 29, 18] </ref>. SW design was later studied extensively by Ferrari [9, 10, 11]. However, his work also concentrated on general-purpose uniprocessor computers. At the Real-Time Computing Laboratory of The University of Michigan, we are designing and building the Hexagonal Architecture for Real-Time Systems (HARTS) [31].
Reference: [41] <author> M. H. Woodbury, </author> <title> Workload Characterization of Real-Time Computing Systems, </title> <type> PhD thesis, </type> <institution> The University of Michigan, </institution> <address> Ann Arbor, MI 48109, </address> <month> August </month> <year> 1988. </year> <month> 35 </month>
Reference-contexts: They are unable to accurately reproduce the behaviors which are characteristic of real-time workloads. Previous SWs developed for real-time systems, e.g., one for FTMP [8] and an early one for HARTS <ref> [41] </ref>, were too inflexible and had no provisions to exercise communication facilities of a distributed system. An SW for a general-purpose distributed computer system was proposed by Singh and Segall [33, 32]. Their system, called Pegasus, was to produce SWs for a distributed system.
References-found: 41

