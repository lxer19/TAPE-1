URL: file://ftp.di.unipi.it/pub/Papers/bagnara/WSA92.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: fbagnara,giaco,levig@di.unipi.it  
Title: Static Analysis of CLP Programs over Numeric Domains approximate inference techniques, well known in the
Author: Roberto Bagnara, Roberto Giacobazzi, Giorgio Levi 
Address: Corso Italia 40, 56125 Pisa  
Affiliation: Dipartimento di Informatica Universita di Pisa  
Note: Bigre n-81-82 September 1992 Workshop on Static Analysis 92 WSA92  Extended Abstract The original contribution of the present work is the integration of  
Abstract: Constraint logic programming (CLP) is a generalization of the pure logic programming paradigm, having similar model-theoretic, fixpoint and operational semantics [9]. Since the basic operational step in program execution is a test for solvability of constraints in a given algebraic structure, CLP has in addition an algebraic semantics. CLP is then a general paradigm which may be instantiated on various semantic domains, thus achieving a good expressive power. One relevant feature is the distinction between testing for solvability and computing a solution of a given constraint formula. In the logic programming case, this corresponds to the unification process, which tests for solvability by computing a solution (a set of equations in solved form or most general unifier ). In CLP, the computation of a solution of a constraint is left to a constraint solver, which does not affect the semantic definition of the language. This allows different computational domains, e.g. real arithmetic, to be considered without requiring complicated encodings of data objects as first order terms. Since the fundamental linguistic aspects of CLP can be separated from the details specific to particular constraint systems, it seems natural to parameterize the semantics of CLP languages with respect to the underlying constraint system [16]. For example, considering a domain of "abstract constraints" instead of the "concrete constraints" that are actually manipulated during program execution, we obtain for free a formal treatment of abstract interpretation of CLP programs: this provides a foundation for dataflow analysis and program manipulation of CLP programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. F. Allen. </author> <title> Maintaining Knowledge About Temporal Intervals. </title> <journal> Commun. of the ACM, </journal> <volume> 26(11) </volume> <pages> 832-843, </pages> <year> 1983. </year>
Reference-contexts: Previous inference results are cached by adding arcs or refining their labels (and possibly by restricting the intervals associated with quantities). In our work we currently use only the inference techniques 1 (but computing the full transitive closure, as in <ref> [1] </ref>) and 4. The resulting system is still powerful enough to perform useful deductions for our purposes. All the inferences made are recorded along with their justifications (i.e. sets of arcs). This is important, as we will see shortly.
Reference: [2] <author> R. Bagnara. Interpretazione Astratta di Linguaggi Logici con Vincoli su Domini Finiti. M.Sc. </author> <type> thesis, </type> <institution> Universita di Pisa, </institution> <month> July </month> <year> 1992. </year>
Reference: [3] <author> W. W. Bledsoe. </author> <title> The Sup-Inf Method in Presburger Arithmetic. </title> <institution> Memo ATP-18, Math. Dept., University of Texas at Austin, Austin, </institution> <year> 1974. </year>
Reference: [4] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference: [5] <author> G. B. Dantzig and B. C. Eaves. </author> <title> Fourier-Motzkin Elimination and its Dual. </title> <journal> Journal of Combinatorial Theory (A), </journal> <volume> 14 </volume> <pages> 288-297, </pages> <year> 1973. </year>
Reference: [6] <author> E. Davis. </author> <title> Constraint Propagation with Interval Labels. </title> <journal> Artificial Intelligence, </journal> <volume> 32 </volume> <pages> 281-331, </pages> <year> 1987. </year> <note> 8 Roberto Bagnara, Roberto Giacobazzi, Giorgio Levi </note>
Reference: [7] <author> R. Giacobazzi, S. Debray, and G. Levi. </author> <title> A Generalized Semantics for Constraint Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 581-591, </pages> <year> 1992. </year>
Reference: [8] <author> R. Helm, K. Marriot, and M. Odersky. </author> <title> Spatial Query Optimization: from Boolean Constraints to Range Queries. </title> <type> Technical Report RC 17231, </type> <institution> IBM Research Division, T. J. Watson Research Center, Yorktown Heights, </institution> <year> 1991. </year>
Reference: [9] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference: [10] <author> J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(R) Language and System. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> 1991. To appear. </note>
Reference-contexts: 1 CLP (R) denotes the CLP (&lt;) implementation described in <ref> [10] </ref>. Static Analysis of CLP Programs over Numeric Domains 5 are binary relations over expressions. We abstract them by means of labelled digraphs. Nodes are called quantities and are labeled with the corrisponding arithmetic formula (and possibly a variation interval). Arcs are labelled with relation symbols.
Reference: [11] <author> N. Jtrgensen, K. Marriot, and S. Michaylov. </author> <title> Some Global Compile-Time Optimizations for CLP(&lt;). </title> <booktitle> In Proc. 1991 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 420-434, </pages> <year> 1991. </year>
Reference-contexts: Since in both cases the induced arc T &gt; 1 does not have the textual arc T &gt; 1 into its justification, the textual arc T &gt; 1 is future redundant <ref> [11] </ref>. In general a textual arc (constraint) is future redundant if it can be doubled by an induced arc labelled with an equal or stronger relation and if this induced arc does not have the textual arc into its justification.
Reference: [12] <author> J. H. M. Lee and M. H. van Emden. </author> <title> Adapting CLP(R) to Floating-Point Arithmetic. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 996-1003, </pages> <year> 1992. </year>
Reference: [13] <author> A. K. Mackworth. </author> <title> Consistency in Networks of Relations. </title> <journal> Artificial Intelligence, </journal> <volume> 8 </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference: [14] <author> A. K. Mackworth and E. C. Freuder. </author> <title> The Complexity of Some Polynomial Network Consistency Algorithms for Constraint Satisfaction Problems. </title> <journal> Artificial Intelligence, </journal> <volume> 25 </volume> <pages> 65-74, </pages> <year> 1985. </year>
Reference: [15] <author> W. Pugh. </author> <title> The Omega Test: a Fast and Practical Integer Programming Algorithm for Dependence Analysis. </title> <booktitle> In Supercomputing '91, </booktitle> <year> 1991. </year> <note> To appear in Commun. of the ACM. </note>
Reference: [16] <author> V. A. Saraswat, M. Rinard, and P. Panangaden. </author> <title> Semantic foundation of concurrent constraint programming. </title> <booktitle> In Proc. Eighteenth Annual ACM Symp. on Principles of Programming Languages. ACM, </booktitle> <year> 1991. </year>
Reference: [17] <author> R. Shostak. </author> <title> On The Sup-Inf Method in for Proving Presburger Formulas. </title> <journal> Journal of the ACM, </journal> <volume> 24(4) </volume> <pages> 529-543, </pages> <year> 1977. </year>
Reference: [18] <author> R. Simmons. </author> <title> Representing and Reasoning About Change in Geologic Interpretation. </title> <type> Technical Report 749, </type> <institution> MIT AI Laboratory, </institution> <year> 1983. </year>
Reference-contexts: Now we must answer the question: how do we infer new constraints at a reasonable computational cost? An answer comes (as before) from AI where approximate deduction holds the spotlight since the origins. In <ref> [18, 19] </ref> an arithmetic reasoning system, called the Quantity Lattice, is described. The Quantity Lattices supports, in a computationally efficient way, various qualitative and quantitative reasoning techniques. All these techniques are integrated, that is, inference made with one technique can trigger further inferences by the other ones.
Reference: [19] <author> R. Simmons. </author> <title> Commonsense Arithmetic Reasoning. </title> <booktitle> In Proceedings AAAI-86, </booktitle> <pages> pages 118-124, </pages> <year> 1986. </year>
Reference-contexts: Now we must answer the question: how do we infer new constraints at a reasonable computational cost? An answer comes (as before) from AI where approximate deduction holds the spotlight since the origins. In <ref> [18, 19] </ref> an arithmetic reasoning system, called the Quantity Lattice, is described. The Quantity Lattices supports, in a computationally efficient way, various qualitative and quantitative reasoning techniques. All these techniques are integrated, that is, inference made with one technique can trigger further inferences by the other ones.
References-found: 19

