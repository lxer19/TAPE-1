URL: http://www.cis.ohio-state.edu/~gb/Papers/TR93-059.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~gb/Papers/
Root-URL: 
Email: gb@cs.purdue.edu russo@cs.purdue.edu  
Title: Signatures: A C Extension for Type Abstraction and Subtype Polymorphism  
Author: Gerald Baumgartner Vincent F. Russo 
Date: December 12, 1994  
Address: West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences Purdue University  
Pubnum: Technical Report CSD-TR-93-059  
Abstract: C ++ uses inheritance as a substitute for subtype polymorphism. We give examples where this makes the type system too inflexible. We then describe a conservative language extension that allows us to define an abstract type hierarchy independent of any implementation hierarchies, to retroactively abstract over an implementation, and to decouple subtyping from inheritance. This extension gives the user more of the flexibility of dynamic typing while retaining the efficiency and security of static typing. With default implementations and views we provide flexible mechanisms for implementing an abstract type by different concrete class types. We first show how our language extension can be implemented in a preprocessor to a C ++ compiler, and then detail and analyze the efficiency of an implementation we directly incorporated in the GNU C ++ compiler.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Kamal Abdali, Guy W. Cherry, and Neil Soiffer. </author> <title> "An object-oriented approach to algebra system design." </title> <editor> In Bruce W. Char (ed.): </editor> <booktitle> Proceedings of the 1986 Symposium on Symbolic and Algebraic Computation (SYMSAC '86), </booktitle> <address> Waterloo, Ontario, Canada, </address> <month> 21-23 July </month> <year> 1986, </year> <pages> pp. 24-30. </pages> <institution> Association for Computing Machinery, </institution> <year> 1986. </year>
Reference-contexts: While this wouldn't be difficult to implement, the syntax of views would become excessively complicated. Instead, all member functions with the same name are renamed the same. A similar renaming mechanism can be found in Views, an experimental computer algebra system written in Smalltalk <ref> [1, 2] </ref>, or in the algebraic specification language OBJ3 [17]. 4 Examples In this section, we present three examples that show a typical use of a signature with multiple implementations, how constants can be used to encode semantic information in a signature, and how signatures integrate with templates.
Reference: [2] <author> S. Kamal Abdali, Guy W. Cherry, and Neil Soiffer. </author> <title> "A Smalltalk system for algebraic manipulation." </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 277-283. </pages>
Reference-contexts: While this wouldn't be difficult to implement, the syntax of views would become excessively complicated. Instead, all member functions with the same name are renamed the same. A similar renaming mechanism can be found in Views, an experimental computer algebra system written in Smalltalk <ref> [1, 2] </ref>, or in the algebraic specification language OBJ3 [17]. 4 Examples In this section, we present three examples that show a typical use of a signature with multiple implementations, how constants can be used to encode semantic information in a signature, and how signatures integrate with templates.
Reference: [3] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> "Subtyping Recursive Types." </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 15, No. 4, </volume> <month> September </month> <year> 1993, </year> <pages> pp. 575-631. </pages>
Reference: [4] <author> Pierre America and Frank van der Linden. </author> <title> "A parallel object-oriented language with inheritance and subtyping." </title> <booktitle> In Proceedings of OOPSLA '90 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Ottawa, Canada, </address> <month> 21-25 October </month> <year> 1990. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 25, No. 10, </volume> <month> October </month> <year> 1990, </year> <pages> pp. 161-168. </pages>
Reference-contexts: by defining a data structure containing signature pointers of type S*. #include &lt;iostream.h&gt; int main () - 13 cout &lt;< p [0]-&gt;text () &lt;< p [1]-&gt;text () &lt;< ""n"; return 0; - When run, the above program will print the string "Hello World."n". 4.2 Properties Other languages, such as POOL-I <ref> [4] </ref> or Axiom [21], offer language constructs for defining properties of signature and implementation types. These properties are used as a shorthand for axioms written in first-order logic or equational logic to encode semantic information as part of the specification of an abstract type. <p> Emerald [8] has first-class types instead of classes, and Trellis/Owl [28] has a class hierarchy in which only type information but no implementation is inherited. Signatures in C ++ come closest to categories in Axiom [21] and types in POOL-I <ref> [4] </ref>. But Axiom is an abstract data type language, and POOL-I lacks overloading and private and protected member functions and fields. Also, while categories and domains in Axiom as well as types in POOL-I are first class, signatures and classes in our C ++ extension are not.
Reference: [5] <author> J.G.P. Barnes. </author> <booktitle> Programming in ADA. </booktitle> <address> Reading, Massachusetts: </address> <publisher> Addison-Wesley, </publisher> <year> 1982. </year>
Reference: [6] <author> Gerald Baumgartner and Vincent F. Russo. </author> <title> "Implementing Signatures for C ++ ." In Proceedings of the 1994 USENIX C ++ Conference, </title> <address> Cambridge, Massachusetts, </address> <month> 11-14 April </month> <year> 1994, </year> <pages> pp. 37-56. </pages>
Reference-contexts: Such an implementation is described in Reference <ref> [6] </ref>. Advantages of using thunks would be that we wouldn't have the overhead of testing the flags in a signature member function call, and we wouldn't need to add a zero offset to the this pointer in case of single inheritance. Thunks would, instead, just contain the appropriate code.
Reference: [7] <author> Gerald Baumgartner and Ryan D. Stansifer. </author> <title> A Proposal to Study Type Systems for Computer Algebra. </title> <type> RISC-Linz Report 90-87.0, </type> <institution> Research Institute for Symbolic Computation, Linz, Austria, </institution> <month> March </month> <year> 1990. </year>
Reference: [8] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> "Object structure in the Emerald system." </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 78-86. </pages>
Reference-contexts: However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes. Russel [15] and Haskell [20] have notions related to signatures, but both lack classes. Emerald <ref> [8] </ref> has first-class types instead of classes, and Trellis/Owl [28] has a class hierarchy in which only type information but no implementation is inherited. Signatures in C ++ come closest to categories in Axiom [21] and types in POOL-I [4].
Reference: [9] <author> Peter S. Canning, William R. Cook, Walter L. Hill, and Walter G. Olthoff. </author> <title> "Interfaces for strongly-typed object-oriented programming." </title> <booktitle> In Proceedings of OOPSLA '89 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> New Orleans, Louisiana, </address> <month> 1-6 October </month> <year> 1989. </year> <journal> SIG-PLAN Notices, </journal> <volume> Vol. 24, No. 10, </volume> <month> October </month> <year> 1989, </year> <pages> pp. 457-467. 22 </pages>
Reference: [10] <author> Luca Cardelli. </author> <title> "A semantics of multiple inheritance." </title> <editor> In G. Kahn, David B. MacQueen, and Gordon Plotkin (eds.): </editor> <booktitle> Semantics of Data Types. Proceedings of the International Symposium on the Semantics of Data Types, Sophia-Antipolis, </booktitle> <address> France, </address> <month> 27-29 June </month> <year> 1984. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <pages> 173, </pages> <address> New York: </address> <publisher> Springer-Verlag, </publisher> <year> 1984, </year> <pages> pp. 51-67. </pages>
Reference: [11] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, Greg Nelson. </author> <title> "Modula-3 Language Definition." </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 27, No. 8, </volume> <month> August </month> <year> 1992, </year> <pages> pp. 15-43. </pages>
Reference-contexts: We proposed language constructs for specifying and working with signature types. These constructs allow us to decouple subtyping from inheritance. The result, C ++ with signatures, has a type system related to those of several other modern programming languages. Similarly as in ML [24, 25], Modula-2 [36], and Modula-3 <ref> [11] </ref>, signatures in C ++ allow a clean separation of specification and implementation. However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes.
Reference: [12] <author> Luca Cardelli and Peter Wegner. </author> <title> "On Understanding Types, Data Abstraction, and Polymorphism." </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 17, No. 4, </volume> <month> December </month> <year> 1985, </year> <pages> pp. 471-522. </pages>
Reference: [13] <author> William R. Cook. </author> <title> "Interfaces and specifications for the Smalltalk-80 collection classes." </title> <booktitle> In Proceedings of OOPSLA '92 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Vancouver, Canada, </address> <month> 18-22 October </month> <year> 1992. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 27, No. 10, </volume> <month> October </month> <year> 1992, </year> <pages> pp. 1-15. </pages>
Reference: [14] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> "Inheritance is not subtyping." </title> <booktitle> In Proceedings of 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <month> 17-19 January </month> <year> 1990, </year> <pages> pp. 125-135. </pages>
Reference: [15] <author> James Donahue and Alan Demers. </author> <title> "Data types are values." </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 7, No. 3, </volume> <month> July </month> <year> 1985, </year> <pages> pp. 426-445. </pages>
Reference-contexts: However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes. Russel <ref> [15] </ref> and Haskell [20] have notions related to signatures, but both lack classes. Emerald [8] has first-class types instead of classes, and Trellis/Owl [28] has a class hierarchy in which only type information but no implementation is inherited.
Reference: [16] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C ++ Reference Manual. </title> <address> Reading, Mas-sachusetts: </address> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference: [17] <author> J.A. Goguen and T. Winkler. </author> <title> Introducing OBJ3. </title> <type> Technical Report CSL-88-9, </type> <institution> SRI International, </institution> <year> 1988. </year>
Reference-contexts: Instead, all member functions with the same name are renamed the same. A similar renaming mechanism can be found in Views, an experimental computer algebra system written in Smalltalk [1, 2], or in the algebraic specification language OBJ3 <ref> [17] </ref>. 4 Examples In this section, we present three examples that show a typical use of a signature with multiple implementations, how constants can be used to encode semantic information in a signature, and how signatures integrate with templates.
Reference: [18] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <address> Reading, Massachusetts: </address> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference: [19] <author> Elana D. Granston and Vincent F. Russo. </author> <booktitle> "Signature-based polymorphism for C ++ ." In Proceedings of USENIX C ++ Technical Conference, </booktitle> <address> Washington, D.C., </address> <year> 1991. </year>
Reference: [20] <editor> Paul Hudak et al. </editor> <title> "Report on the programming Language Haskell: A non-strict, purely functional language, version 1.2." </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 27, No. 5, </volume> <month> May </month> <year> 1992, </year> <note> Section R. </note>
Reference-contexts: However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes. Russel [15] and Haskell <ref> [20] </ref> have notions related to signatures, but both lack classes. Emerald [8] has first-class types instead of classes, and Trellis/Owl [28] has a class hierarchy in which only type information but no implementation is inherited.
Reference: [21] <author> Richard D. Jenks and Robert S. Sutor. </author> <title> AXIOM: The Scientific Computation System. </title> <address> New York: </address> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: data structure containing signature pointers of type S*. #include &lt;iostream.h&gt; int main () - 13 cout &lt;< p [0]-&gt;text () &lt;< p [1]-&gt;text () &lt;< ""n"; return 0; - When run, the above program will print the string "Hello World."n". 4.2 Properties Other languages, such as POOL-I [4] or Axiom <ref> [21] </ref>, offer language constructs for defining properties of signature and implementation types. These properties are used as a shorthand for axioms written in first-order logic or equational logic to encode semantic information as part of the specification of an abstract type. <p> Russel [15] and Haskell [20] have notions related to signatures, but both lack classes. Emerald [8] has first-class types instead of classes, and Trellis/Owl [28] has a class hierarchy in which only type information but no implementation is inherited. Signatures in C ++ come closest to categories in Axiom <ref> [21] </ref> and types in POOL-I [4]. But Axiom is an abstract data type language, and POOL-I lacks overloading and private and protected member functions and fields.
Reference: [22] <author> Jacob Katzenelson, Shlomit S. Pinter, and Eugen Schenfeld. </author> <title> "Type matching, type-graphs, and the Schanuel conjecture." </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 14, No. 4, </volume> <month> October </month> <year> 1992, </year> <pages> pp. 574-588. </pages>
Reference-contexts: The other possibility is to make signature tables external and to have linker support to eliminate identical tables. Both the signature table manager and the link-time table comparison could be implemented efficiently using the type matching scheme described in Reference <ref> [22] </ref>.
Reference: [23] <author> Wilf R. LaLonde, Dave A. Thomas, and John R. Pugh. </author> <title> "An exemplar based Smalltalk." </title> <booktitle> In Proceedings of OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 322-330. </pages>
Reference: [24] <author> David B. MacQueen. </author> <title> "Modules for Standard ML." </title> <journal> Polymorphism, </journal> <volume> Vol. 2, No. 2, </volume> <year> 1985. </year>
Reference-contexts: We proposed language constructs for specifying and working with signature types. These constructs allow us to decouple subtyping from inheritance. The result, C ++ with signatures, has a type system related to those of several other modern programming languages. Similarly as in ML <ref> [24, 25] </ref>, Modula-2 [36], and Modula-3 [11], signatures in C ++ allow a clean separation of specification and implementation. However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes.
Reference: [25] <author> David B. MacQueen. </author> <title> "An implementation of Standard ML modules." </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Snowbird, Utah, </address> <month> 25-27 July </month> <year> 1988. </year> <journal> Association for Computing Machinery, </journal> <pages> pp. 212-223. </pages>
Reference-contexts: We proposed language constructs for specifying and working with signature types. These constructs allow us to decouple subtyping from inheritance. The result, C ++ with signatures, has a type system related to those of several other modern programming languages. Similarly as in ML <ref> [24, 25] </ref>, Modula-2 [36], and Modula-3 [11], signatures in C ++ allow a clean separation of specification and implementation. However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes.
Reference: [26] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <address> Cambridge, Massachusetts: </address> <publisher> The MIT Press, </publisher> <year> 1991. </year> <month> 23 </month>
Reference: [27] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <address> Cambridge, Mas--sachusetts: </address> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference: [28] <author> Craig Schaffert et al. </author> <title> "An introduction to Trellis/Owl." </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September-2 October </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 9-16. </pages>
Reference-contexts: Russel [15] and Haskell [20] have notions related to signatures, but both lack classes. Emerald [8] has first-class types instead of classes, and Trellis/Owl <ref> [28] </ref> has a class hierarchy in which only type information but no implementation is inherited. Signatures in C ++ come closest to categories in Axiom [21] and types in POOL-I [4].
Reference: [29] <author> Alan Snyder. </author> <title> "Encapsulation and inheritance in object-oriented programming languages." </title> <booktitle> In Proceedings of OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 38-45. </pages>
Reference: [30] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Cambridge, Massachusetts: Free Software Foundation, </title> <editor> V. 2.3, </editor> <month> 16 December </month> <year> 1992. </year>
Reference-contexts: Using this method it is possible to write a compiler preprocessor, say cfrontfront, that translates from C ++ with signatures into C ++ without signatures. We then present our GCC <ref> [30] </ref> implementation, which is designed to minimize the run-time overhead. Our implementation only modifies GCC's C ++ front end, cc1plus; the technique is independent of the compiler and, e.g., could be used to implement signatures in the AT&T cfront compiler as well. <p> For pragmatic reasons, however, such drastic changes are undesirable for an extension of C ++ , as they would affect the behavior of existing programs. Availability Parts of the language extension have been implemented in the GNU project C ++ compiler <ref> [30] </ref> as a compiler extension. The implementation is included in versions GCC-2.6.0 and higher. Acknowledgement We would like to thank Michal Young and Konstantin Laufer for reading parts of the paper and providing many valuable comments, and Andy Muckelbauer for numerous discussions about the implementation.
Reference: [31] <author> Bjarne Stroustrup. </author> <booktitle> "Multiple inheritance for C ++ ." In EUUG Spring '87 Conference, </booktitle> <year> 1987. </year>
Reference: [32] <author> Bjarne Stroustrup. </author> <booktitle> "Parameterized types for C ++ ." In Proceedings of USENIX C ++ Technical Conference, </booktitle> <address> Denver, Colorado, </address> <year> 1988, </year> <pages> pp. 1-18. </pages>
Reference: [33] <author> Bjarne Stroustrup and Dmitry Lenkov. </author> <title> "Run-time type identification for C ++ (revised)." </title> <booktitle> In Proceedings of USENIX C ++ Technical Conference, </booktitle> <address> Portland, Oregon, </address> <month> 10-13 August </month> <year> 1992, </year> <pages> pp. 313-339. </pages>
Reference-contexts: Both the signature table manager and the link-time table comparison could be implemented efficiently using the type matching scheme described in Reference [22]. If a signature table manager is used and we have type information of objects available at run time (e.g., using typeid <ref> [33] </ref>) we can generate the signature tables for virtual subclasses at run-time, eliminating the need for double indirection when looking up the address of a virtual member function and eliminating copying of signature tables when assigning one signature pointer to another. 6 Cost Analysis The memory required for storing a signature
Reference: [34] <author> Robert S. Sutor and Richard D. Jenks. </author> <title> "The type inference and coercion facilities in the Scratchpad II interpreter." </title> <booktitle> In Proceedings of SIGPLAN '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <month> 24-26 June </month> <year> 1987, </year> <title> St. Paul, Minnesota. </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 22, No. 7, </volume> <year> 1987, </year> <pages> pp. 56-63. </pages>
Reference: [35] <author> Stephen M. Watt, Richard D. Jenks, Robert S. Sutor, and Barry M. Trager. </author> <title> "The Scratchpad II Type System: Domains and Subdomains." </title> <editor> In Alfonso M. Miola (ed.): </editor> <title> Computing Tools for Scientific Problem Solving. </title> <publisher> London: Academic Press, </publisher> <year> 1990, </year> <pages> pp. 63-82. </pages>
Reference: [36] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <booktitle> Texts and Monographs in Computer Science. </booktitle> <address> Berlin-Heidelberg, Germany: </address> <publisher> Springer Verlag, </publisher> <year> 1985. </year> <month> 24 </month>
Reference-contexts: We proposed language constructs for specifying and working with signature types. These constructs allow us to decouple subtyping from inheritance. The result, C ++ with signatures, has a type system related to those of several other modern programming languages. Similarly as in ML [24, 25], Modula-2 <ref> [36] </ref>, and Modula-3 [11], signatures in C ++ allow a clean separation of specification and implementation. However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes.
References-found: 36

