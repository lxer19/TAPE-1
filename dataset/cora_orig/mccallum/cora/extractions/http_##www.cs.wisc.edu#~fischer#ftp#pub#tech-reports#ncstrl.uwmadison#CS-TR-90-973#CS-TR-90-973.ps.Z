URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-90-973/CS-TR-90-973.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-90-973/
Root-URL: http://www.cs.wisc.edu
Title: -1- THE DESIGN, IMPLEMENTATION, AND PERFORMANCE EVALUATION OF BERMUDA  
Author: Yannis E. Ioannidis Manolis M. Tsangaris 
Keyword: Index Terms Deductive databases, logic programming, loosely-coupled systems, Prolog, system integration.  
Note: This research has been partially supported by the National Science Foundation under Grant IRI-8703592. The second author has been partially supported by a NATO fellowship.  
Address: Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin  
Abstract: We describe the design and implementation of BERMUDA, which is a loosely-coupled system interfacing Prolog to the Britton-Lee Intelligent Database Machine (IDM-500). BERMUDA allows multiple concurrent Prolog processes, possibly running on different machines, to share a database. In addition, it preserves the semantics of Prolog programs and makes the use of the database system transparent to the user. We discuss several architectural issues faced by such systems and the approach adopted for each one in BERMUDA. We also present the performance results of a variety of experiments with the system. These include single-user benchmarks of BERMUDA against stand-alone Prolog and stand-alone IDM, detailed profiling of the costs of the modules of BER-MUDA that shows the overhead imposed by the interface, and multi-user benchmarks of BER-MUDA that show how the system behaves under heavier load. These experiments demonstrate the effectiveness of loosely-coupled systems in general and of BERMUDA specifically. They also help in the identification of some aspects of the design and implementation of BERMUDA that could be improved. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. et al. Astrahan, </author> <title> "System R: Relational Approach to Database Management", </title> <journal> ACM Transactions on Database Systems 1, </journal> <month> 2 (June </month> <year> 1976), </year> <pages> pp. 97-137. </pages>
Reference-contexts: Otherwise, this information is kept in an attribute cache in the Formatter, and the auxiliary query is avoided. The query tree is then transformed into an SQL statement <ref> [1] </ref>, which in turn, is used to create a new stored command. In the second case, all the above steps are bypassed, because a stored command exists already in IDM.
Reference: [2] <author> R. et al. Baron, </author> <title> "Mach: A New Kernel Foundation For UNIX Development", </title> <booktitle> in Proc. Winter '86 USENIX, </booktitle> <year> 1986, </year> <pages> pp. 93-112. </pages>
Reference-contexts: For both the BA-Prolog and the BA-Loader connections, a shared memory communication scheme would be even better than the shared file one, because then much I/O would be avoided. For operating systems that support -42--shared memory between processes, this would be the scheme of choice <ref> [2] </ref>. Similarly, the Loaders could be abandoned altogether if the operating system supported light-weight processes (threads) [13]. In the case of BER-MUDA, however, which was developed under Unix 4.3 BSD, since the latter does not offer such services, a shared file scheme appears to be the preferable choice.
Reference: [3] <author> BIM, BIM_Prolog, </author> <note> Version 2.5, </note> <year> 1989. </year>
Reference: [4] <author> D. Bitton, D. J. DeWitt, and C. Turbyfill, </author> <title> "Benchmarking Database Systems: A Systematic Approach", </title> <booktitle> in Proc. 9th International VLDB Conference , Florence, </booktitle> <address> Italy, </address> <month> August </month> <year> 1983, </year> <pages> pp. 8-19. </pages>
Reference-contexts: In the second category of experiments, we compare the cost of the individual modules of BERMUDA, i.e., the Prolog process, the Connector Module, and the IDM. The results of these categories of experiments are described in the following two subsections. -19--4.1. Benchmarks The Wisconsin Benchmark <ref> [4] </ref> is widely accepted as a good set of queries to test the performance of database systems. Hence, unlike other projects that have developed specialized benchmarks [31], we have adopted the Wisconsin Benchmark for comparing the performance of BERMUDA, Prolog, and IDM. <p> In all these experiments, IDM has run the original SQL query of the benchmark, whereas Prolog and BER-MUDA have run the equivalent Prolog query. Details on the Wisconsin benchmark can be found elsewhere <ref> [4] </ref>. The following are the most important parameters of the relations used. iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Parameter Value iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii Relation Size (tuples) 1000 or 10000 Tuple size (bytes) 182 Value distribution uniform iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c Table 1: Database parameters.
Reference: [5] <author> J. Bocca, </author> <title> "On the Evaluation Strategy of EDUCE", </title> <booktitle> in Proc. of the 1986 ACM-SIGMOD Conference on the Management of Data, </booktitle> <address> Washington, DC, </address> <month> May </month> <year> 1986, </year> <pages> pp. 368-378. </pages>
Reference: [6] <author> J. Bocca, </author> <title> "EDUCE A Marriage of Convenience: Prolog and a Relational DBMS", </title> <booktitle> in Proc. of the 1986 Symposium on Logic Programming, </booktitle> <address> Salt Lake City, UT, </address> <month> September </month> <year> 1986, </year> <pages> pp. 36-45. </pages>
Reference-contexts: This version allows for Prolog to call compiled C routines for execution, a capability that was very significant in the implementation of the system. Prolog itself cannot communicate with other processes, and this is a problem that has been faced by other similar projects as well <ref> [6, 16] </ref>. The capability of calling C routines, however, solves the problem by implementing all interprocess communication on the same machine or across different machines with such routines. Communication is achieved using Unix domain sockets for processes on the same machine and TCP sock -13--ets for processes on different machines.
Reference: [7] <editor> J. et al. Bocca, </editor> <title> "Some Steps towards DBMS Based KBMS", </title> <booktitle> in Information Processing 86, </booktitle> <publisher> North Holland, </publisher> <month> September </month> <year> 1986, </year> <pages> pp. 1061-1067. </pages>
Reference-contexts: The corresponding variable and constant lists are as follows: Vars = [S, D], Consts = <ref> [john, 100000, 7] </ref>. The above three lists together with the associated database name are the arguments of the dbq predicate that replaces the original database cluster in the Prolog program: dbq (DB, Qtemp, Vars, Consts).
Reference: [8] <author> S. Ceri, G. Gottlob, and G. Wiederhold, </author> <title> "Interfacing Relational Databases and Prolog Efficiently", </title> <booktitle> in Proc. of the 1st International Conference on Expert Database Systems, </booktitle> <address> Charleston, SC, </address> <month> April </month> <year> 1986, </year> <pages> pp. 141-153. </pages>
Reference-contexts: Sending a single query for each maximal database cluster minimizes the number of times this overhead is paid. An alternative suggested by some other systems <ref> [8, 9] </ref> would be to send only single relation queries to IDM. This would have inferior join performance, however, since nested-loops would be the only join algorithm used. <p> They can be realized by employing techniques from partial evaluation of Prolog programs [30], but they will also make the preprocessor significantly more expensive. In the current design of BERMUDA, the cache is used to answer identical queries that are repeated. Similarly to other systems <ref> [8, 9] </ref>, this can be expanded so that the BA checks for query subsumption [14] and not for query equivalence only. This will increase the number of times that database queries are not sent to IDM. <p> In addition, since the unit of transformation of Prolog subclauses to database queries is the maximal database cluster in BERMUDA, we feel that query subsumption will not be applicable as often as in other systems whose corresponding unit was a single database predicate <ref> [8, 9] </ref>. 6.2. Design Alternatives In this subsection, we identify some alternative designs for BERMUDA and briefly discuss some estimates of the corresponding overhead. These alternatives were conceived based on the overall goal to reduce that overhead.
Reference: [9] <author> S. Ceri, G. Gottlob, and G. Wiederhold, </author> <title> "Efficient Database Access from Prolog", </title> <journal> IEEE Transactions on Software Engineering 15, </journal> <month> 2 (February </month> <year> 1989), </year> <pages> pp. 153-164. </pages>
Reference-contexts: Sending a single query for each maximal database cluster minimizes the number of times this overhead is paid. An alternative suggested by some other systems <ref> [8, 9] </ref> would be to send only single relation queries to IDM. This would have inferior join performance, however, since nested-loops would be the only join algorithm used. <p> They can be realized by employing techniques from partial evaluation of Prolog programs [30], but they will also make the preprocessor significantly more expensive. In the current design of BERMUDA, the cache is used to answer identical queries that are repeated. Similarly to other systems <ref> [8, 9] </ref>, this can be expanded so that the BA checks for query subsumption [14] and not for query equivalence only. This will increase the number of times that database queries are not sent to IDM. <p> In addition, since the unit of transformation of Prolog subclauses to database queries is the maximal database cluster in BERMUDA, we feel that query subsumption will not be applicable as often as in other systems whose corresponding unit was a single database predicate <ref> [8, 9] </ref>. 6.2. Design Alternatives In this subsection, we identify some alternative designs for BERMUDA and briefly discuss some estimates of the corresponding overhead. These alternatives were conceived based on the overall goal to reduce that overhead.
Reference: [10] <author> S. Ceri, G. Gottlob, and L. Tanca, </author> <title> "What you Always Wanted to Know about Datalog (and Never Dared to Ask)", </title> <journal> IEEE Transactions on Knowledge and Data Engineering 1, </journal> <month> 1 (March </month> <year> 1989), </year> <pages> pp. 146-166. </pages>
Reference: [11] <author> C. L. Chang and A. Walker, "PROSQL: </author> <title> A Prolog Programming Interface with SQL/DS", </title> <booktitle> in Expert Database Systems, Proc. from the First International Workshop, </booktitle> <editor> edited by L. Kerschberg, Benjamin/Cummings, </editor> <publisher> Inc., </publisher> <address> Menlo Park, CA, </address> <year> 1986, </year> <pages> pp. 233-246. </pages>
Reference: [12] <author> E. Denoel, D. Roelants, and M. Vauclair, </author> <title> "Query Translation for Coupling Prolog with a Relational Database Management System", </title> <booktitle> in Proc. Workshop on Integration of Logic Programming and Databases, </booktitle> <address> Venice, Italy, </address> <month> December </month> <year> 1986. </year>
Reference-contexts: Also, no negation is included in database queries due to their occasional semantic problems. Such enhancements will be very useful to BERMUDA and have been incorporated in other systems <ref> [12] </ref>. They can be realized by employing techniques from partial evaluation of Prolog programs [30], but they will also make the preprocessor significantly more expensive. In the current design of BERMUDA, the cache is used to answer identical queries that are repeated.
Reference: [13] <author> R. P. Draves and E. C. Cooper, </author> <title> "C Threads", </title> <type> Technical Report, </type> <institution> Dept. of Computer Science, Carnegie Mellon University, </institution> <year> 1987. </year>
Reference-contexts: For operating systems that support -42--shared memory between processes, this would be the scheme of choice [2]. Similarly, the Loaders could be abandoned altogether if the operating system supported light-weight processes (threads) <ref> [13] </ref>. In the case of BER-MUDA, however, which was developed under Unix 4.3 BSD, since the latter does not offer such services, a shared file scheme appears to be the preferable choice.
Reference: [14] <author> S. Finkelstein, </author> <title> "Common Expression Analysis in Database Applications", </title> <booktitle> in Proc. of the 1982 ACM-SIGMOD Conference on the Management of Data, </booktitle> <address> Orlando, FL, </address> <month> June </month> <year> 1982, </year> <pages> pp. 235-245. </pages>
Reference-contexts: In the current design of BERMUDA, the cache is used to answer identical queries that are repeated. Similarly to other systems [8, 9], this can be expanded so that the BA checks for query subsumption <ref> [14] </ref> and not for query equivalence only. This will increase the number of times that database queries are not sent to IDM. It will also increase, however, the complexity of the BA, because the latter will need to operate on flat files to obtain the answer of the subsumed query.
Reference: [15] <editor> H. Gallaire and J. Minker, </editor> <booktitle> Logic and Data Bases, </booktitle> <publisher> Plenum Press, </publisher> <address> New York, N.Y., </address> <year> 1978. </year>
Reference: [16] <author> S. Ghosh, C. C. Lin, and T. Sellis, </author> <title> "Implementation of a Prolog-INGRES Interface", </title> <booktitle> ACM-SIGMOD record 17, </booktitle> <month> 2 (June </month> <year> 1988), </year> <pages> pp. 77-88. </pages>
Reference-contexts: This version allows for Prolog to call compiled C routines for execution, a capability that was very significant in the implementation of the system. Prolog itself cannot communicate with other processes, and this is a problem that has been faced by other similar projects as well <ref> [6, 16] </ref>. The capability of calling C routines, however, solves the problem by implementing all interprocess communication on the same machine or across different machines with such routines. Communication is achieved using Unix domain sockets for processes on the same machine and TCP sock -13--ets for processes on different machines.
Reference: [17] <author> Inc. IDM, </author> <title> Program Interface Manual, Version 2.0, </title> <address> Berkeley, CA, </address> <year> 1989. </year>
Reference-contexts: During the time when BERMUDA was being developed the IDM software that was available to us did not have the above capability, and therefore such a policy was not implementable. The most recent versions of the IDM software, however, do offer the above service <ref> [17] </ref>. If Loaders were allowed to take advantage of this service and deal with multiple open queries simultaneously, their design would become significantly more complicated. Every database query from the same clause of the same Prolog process would have to be sent to the same Loader.
Reference: [18] <author> Y. E. Ioannidis, J. Chen, M. A. Friedman, and M. Tsangaris, </author> <title> BERMUDA An Architectural Perspective on Interfacing Prolog to a Database Machine", </title> <booktitle> in Proc. of the 2st International Conference on Expert Database Systems, </booktitle> <address> Tysons Corner, VA, </address> <month> April </month> <year> 1988, </year> <pages> pp. 91-105. </pages>
Reference-contexts: With the exception of LDL [22], however, languages of current database systems do not support that. Regarding the buffer replacement strategy that was used in the BA, simplicity was the primary motivation for our choice. A more complicated strategy, like the one used in the first version of BERMUDA <ref> [18] </ref>, would definitely be beneficial. However, disk I/O is a very small fraction of the current overhead due to prefetching. This has been an additional reason for the decision to abandon the original, complex buffer management strategy and adopt the current one.
Reference: [19] <author> M. Jarke, J. Clifford, and Y. Vassiliou, </author> <title> "An Optimizing Prolog Front-End to a Relational Query System", </title> <booktitle> in Proc. of the 1984 ACM-SIGMOD Conference on the Management of Data, </booktitle> <address> Boston, MA, </address> <month> June </month> <year> 1984, </year> <pages> pp. 296-306. </pages>
Reference: [20] <author> K. Morris, J. D. Ullman, and A. VanGelder, </author> <title> "NAIL! System Design Overview", </title> <booktitle> in Proc. of the 3rd International Conference on Logic Programming, </booktitle> <address> London, England, </address> <month> July </month> <year> 1986, </year> <pages> pp. 554-568. </pages>
Reference: [21] <author> L. Naish and J. A. Thom, </author> <title> "The MU-Prolog Deductive Database", </title> <type> Technical Report 83/10, </type> <institution> Computer Science Dept., University of Melburne, </institution> <month> November </month> <year> 1983. </year>
Reference: [22] <author> S. Naqvi and S. Tsur, </author> <title> A Logical Language for Data and Knowledge Bases, </title> <publisher> Computer Science Press, </publisher> <address> New -44- York, NY, </address> <year> 1989. </year>
Reference-contexts: For the case of cuts, of course, the ideal would be to send a query that asks for a single tuple, which would require for the query language to support nondeterministic choice. With the exception of LDL <ref> [22] </ref>, however, languages of current database systems do not support that. Regarding the buffer replacement strategy that was used in the BA, simplicity was the primary motivation for our choice. A more complicated strategy, like the one used in the first version of BERMUDA [18], would definitely be beneficial.
Reference: [23] <author> J. M. Nicolas and K. Yazdanian, </author> <title> "An Outline of BDGEN: A Deductive DBMS", in Information Processing 83, edited by R. </title> <editor> E. Mason, </editor> <publisher> North Holland, </publisher> <year> 1983, </year> <pages> pp. 711-717. </pages>
Reference: [24] <author> D. M. Ritchie and K. Thompson, </author> <title> "The UNIX Time-Sharing System", </title> <journal> The Bell System Technical Journal 57, </journal> <volume> 6 (July-August 1978), </volume> <pages> pp. 1905-1929. </pages>
Reference: [25] <author> P. et al. Selinger, </author> <title> "Access Path Selection in a Relational Data Base System", </title> <booktitle> in Proc. of the 1979 ACM-SIGMOD Conference on the Management of Data, </booktitle> <address> Boston, MA, </address> <month> June </month> <year> 1979, </year> <pages> pp. 23-34. </pages>
Reference-contexts: This is motivated by the following two advantages. First, like most relational database systems, IDM supports several query processing algorithms for joins, as opposed to Prolog, which supports a fixed one (essentially nested-loops <ref> [25] </ref>), and it has the ability to use indices to expedite data access. In addition, it employs sophisticated optimization techniques to choose the most efficient algorithm for each query. Thus, in most cases, a query is executed much faster in IDM than in Prolog.
Reference: [26] <author> A. P. Sheth and A. B. O'Hare, </author> <title> "The Architecture of BrAID: A System for Efficient AI/DB Integration", </title> <type> Technical Memorandum TM-STS-015544, </type> <institution> Bellcore, </institution> <month> November </month> <year> 1989. </year>
Reference: [27] <author> A. P. Sheth and A. B. O'Hare, </author> <title> "The Architecture of BrAID: A System for Bridging AI/DB Systems", </title> <booktitle> in Proc. 7th International Conference on Data Engineering, </booktitle> <address> Kobe, Japan, </address> <month> April </month> <year> 1991. </year>
Reference: [28] <author> M. Stonebraker, </author> <title> "Triggers and Inference in Data Base Systems", </title> <booktitle> in Proc. of the Islamorada Workshop on Large Scale Knowledge Base and Reasoning Systems, </booktitle> <address> Islamorada, FL, </address> <month> February </month> <year> 1985. </year>
Reference: [29] <author> M. Ubell, </author> <title> "The Intelligent Database Machine (IDM)", in Query Processing in Database Systems, edited by W. </title> <editor> Kim, D. Reiner, and D. Batory, </editor> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1984. </year>
Reference: [30] <author> R. Venken, </author> <title> "A Prolog Meta-Interpreter for Partial Evaluation and its Applications to Source to Source Transformation and Query-Optimization", </title> <booktitle> in Proc. ECCAI, edited by T. </booktitle> <address> O'Shea, </address> <publisher> Elsevier (North Holland), </publisher> <address> Amsterdam, The Netherlands, </address> <year> 1984, </year> <pages> pp. 91-100. </pages>
Reference-contexts: Also, no negation is included in database queries due to their occasional semantic problems. Such enhancements will be very useful to BERMUDA and have been incorporated in other systems [12]. They can be realized by employing techniques from partial evaluation of Prolog programs <ref> [30] </ref>, but they will also make the preprocessor significantly more expensive. In the current design of BERMUDA, the cache is used to answer identical queries that are repeated.
Reference: [31] <author> M. H. Williams, P. Massey, and J. Crammond, </author> <title> "Benchmarking Prolog for Database Applications", </title> <type> Technical Report No. 87/7, </type> <institution> Heriot-Watt University, Edinburgh, </institution> <year> 1987. </year>
Reference-contexts: The results of these categories of experiments are described in the following two subsections. -19--4.1. Benchmarks The Wisconsin Benchmark [4] is widely accepted as a good set of queries to test the performance of database systems. Hence, unlike other projects that have developed specialized benchmarks <ref> [31] </ref>, we have adopted the Wisconsin Benchmark for comparing the performance of BERMUDA, Prolog, and IDM. We have concentrated on selection and join queries, because they are the ones that can be run on all three systems and they are the most common.
References-found: 31

