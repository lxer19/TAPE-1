URL: http://www.cs.cornell.edu/Info/People/bba/proposal.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/bba/papers.html
Root-URL: http://www.cs.cornell.edu
Email: bba@cs.cornell.edu  
Title: Adding Group Communication to Java in a Non-Intrusive Way Using the Ensemble Toolkit  
Author: Bela Ban 
Date: Nov 11 1997  
Affiliation: Dept. of Computer Science Cornell University  
Abstract-found: 0
Intro-found: 1
Reference: [Bir96] <author> Kenneth P. Birman. </author> <title> Building Secure and Reliable Network Applications. </title> <publisher> Manning Publications Co., </publisher> <year> 1996. </year>
Reference-contexts: Introduction This paper describes a possible approach to merge the work done at Cornell (Isis, Horus, Ensemble) <ref> [Bir96] </ref> with the Java environment. Java is currently lacking group communication facilities, communication both on the socket- and RMI-level [RMI96] is only one-to-one rather than one-to-many 1 . Adding group communication to Java would greatly enhance the range of applications that can be built in Java. <p> The dispatcher has to take care that these messages are exchanged between the corresponding objects in parallel to its other tasks. 9 Generation/dispatching of RMI request and wrapping/unwrapping in/from En--semble is done using special Ensemble layers <ref> [Bir96] </ref> for RMI, as shown in fig. 2.4. 8 Using the partly opened-up design of RMI should allow to 'slide in' the Ensemble functionality between a Java RMI method invocation and its reception by the remote server (dispatcher). 2.3.1 RMI and IIOP Layer in the Ensemble Stack 8 Note that additional
Reference: [GHJV95] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: as the original one and has to be found in the CLASSPATH before the original class. 3 For a more detailed discussion see section 2.2.2. 5 they could probably be moved to a separate class and each object would delegate this functionality to an instance of that class (strategy pattern <ref> [GHJV95] </ref>).
Reference: [Gra97] <author> Ennio Grasso. Jrb: </author> <title> A reflective orb. </title> <type> Technical report, </type> <institution> CSELT, </institution> <year> 1997. </year>
Reference-contexts: Having only one dispatcher process instead of multiple Java servers reduces management and memory requirements and simplifies the whole process. A similar approach used to implement a reflective Java ORB is described in <ref> [Gra97] </ref>. 3.1.3 Eliminating the Need to Implement Interface Serializable For Parameters It seems that the main reason for requiring a remote object to implement interface Serializable is to allow an implementor to override the 2 methods defined in that interface for marshaling/unmarshaling the remote object's state. (The default implementation for marshaling/unmarshaling
Reference: [Maf95] <author> Silvano Maffeis. </author> <title> Run-Time Support for Object-Oriented Distributed Programming. </title> <type> PhD thesis, </type> <institution> Institute of Computer Science, University of Zurich, </institution> <year> 1995. </year>
Reference-contexts: Of course, handling of all responses could be made visible by adding another method for X which returns a list of results rather than just a single result (see <ref> [Maf95] </ref> for details of response collection). However, this would force applications that need explicit response collection to be modified to access the new method. The private member view is a list of all members of the group.
Reference: [RMI96] <author> Sun Microsystems Inc. </author> <title> Java Remote Method Invocation Specification, </title> <address> 1.1 edition, </address> <month> November </month> <year> 1996. </year> <note> Draft. </note>
Reference-contexts: Introduction This paper describes a possible approach to merge the work done at Cornell (Isis, Horus, Ensemble) [Bir96] with the Java environment. Java is currently lacking group communication facilities, communication both on the socket- and RMI-level <ref> [RMI96] </ref> is only one-to-one rather than one-to-many 1 . Adding group communication to Java would greatly enhance the range of applications that can be built in Java. Applications that have to be highly reliable and robust have to-date to be created using traditional languages such as C/C++.
Reference: [Ste90] <author> Guy L. Steele. </author> <title> Common LISP. The Language. </title> <publisher> Digital Press, </publisher> <year> 1990. </year>
Reference-contexts: Procedure: analysis of several change requirements (e.g. those above), synthesis of major modifications and design of framework. Changes might occur at compile time vs. runtime, class level vs. instance level, attributes vs. methods etc. Can before- around and -after methods help ? (CLOS) <ref> [Ste90] </ref> 15
Reference: [Sun96] <author> Sun Microsystems Inc. </author> <title> Java Core Reflection. API and Specification, </title> <month> October </month> <year> 1996. </year> <month> 16 </month>
Reference-contexts: The process of marshaling / unmarshaling, and dispatching to the correct method can be done in a more generic way at runtime using Java's Core Reflection API <ref> [Sun96] </ref>. This functionality would be similar to a CORBA BOA and could be located in a dynamic dispatcher process. A dispatcher demultiplexes requests coming in over a socket and dispatches them to the correct objects and methods within them using entirely the Core Reflection API, and no compile-time generated code.
References-found: 7

