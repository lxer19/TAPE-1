URL: ftp://ftp.csd.uu.se/pub/papers/reports/0096.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: with Reflection  
Author: Jonas Barklund Stefania Costantini Pierangelo Dell'Acqua Gaetano A. Lanzarone 
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Uppsala University Universita degli Studi di Milano Uppsala University Computing Science Department  Universita degli Studi di Milano and Up-psala Univ.  
Note: SLD-Resolution  P. Dell'Acqua has been supported by both  
Abstract: UPMAIL Technical Report No. 96 20 January, 1995 Abstract We present a language containing names of ground expressions and a corresponding simple extension to SLD-resolution which allows meta-level computation and interlevel communication through reflection. The extended language allows significant freedom in the choice of names and as an example of a possible policy we discuss self-naming expressions. We go on to present a language in which the choice of naming relation has been partly determined by specifying that names of compound expressions are compositional. This is a sensible design decision and we present in detail a rewrite system for extended unification for the language, having certain similarities with a constraint solving system over names. Comparisons are made with related languages and systems. This paper was presented at the 1994 International Symposium on Logic Programming, held in Ithaca, New York. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aiello, L. C., Cecchi, C. and Sartini, D., </author> <title> Representation and Use of Meta knowledge, </title> <journal> Proc. of the IEEE, </journal> <volume> 74 </volume> <month> 1304-1321 </month> <year> (1986). </year>
Reference-contexts: That is the responsibility of the extended unification rewrite system, which is to be given as a parameter of the inference system. Metalevel Architectures The advantages deriving from the ability of explicitly expressing and using metalevel knowledge have been widely recognized, especially in the AI literature <ref> [1, 2] </ref>. The need to formally represent knowledge and metaknowledge 1 This is the difference with respect to Reflective Prolog, as mentioned above. 1 has led to the study of metalevel architectures [4], where these two kinds of knowledge are explicitly represented. <p> Rewrite rules for A [Evaluate up arrows.] If any " expression has become instantiated, then replace it with another expression. hH; E ["ff]i ! hH; E <ref> [ 1 ] </ref>i if ff b H is a constant hH; E ["ff]i ! hH; E [[f 1 ; "ff 1 ; : : : ; "ff k ]]i if ff b H is f (ff 1 ; : : : ; ff k ) A [Evaluate down arrows.] If any <p> ; "ff 1 ; : : : ; "ff k ]]i if ff b H is f (ff 1 ; : : : ; ff k ) A [Evaluate down arrows.] If any # expression has become instantiated, then replace it with another expression. hH; E [#fi]i ! hH; E <ref> [ 1 ] </ref>i if fi b H is a metaconstant hH; E [#fi]i ! hH; E [[#fi 0 ; #fi 1 ; : : : ; #fi k ]]i if fi b H is [fi 0 ; fi 1 ; : : : ; fi k ] A hH [ ffalseg;
Reference: [2] <author> Aiello, L. C., Nardi, D. and Schaerf, M., </author> <title> Reasoning about Knowledge and Reasoning in a Meta-Level Architecture, </title> <journal> Intl. J. of Appl. </journal> <note> Int., 1 (1991). </note>
Reference-contexts: That is the responsibility of the extended unification rewrite system, which is to be given as a parameter of the inference system. Metalevel Architectures The advantages deriving from the ability of explicitly expressing and using metalevel knowledge have been widely recognized, especially in the AI literature <ref> [1, 2] </ref>. The need to formally represent knowledge and metaknowledge 1 This is the difference with respect to Reflective Prolog, as mentioned above. 1 has led to the study of metalevel architectures [4], where these two kinds of knowledge are explicitly represented.
Reference: [3] <author> Barklund, J., Boberg, K. and Dell'Acqua, P., </author> <title> A Basis for a Multilevel Meta logic Programming Language, </title> <booktitle> Proc. 4th Intl. Workshop on Metaprogramming in Logic, </booktitle> <year> 1994. </year>
Reference-contexts: Names of expressions will thus always appear as variables in metapro-grams. The metalevel part of a program can use the operations associated with the datatype to manipulate names. The naming relation of Godel is compositional and it seems to fit in our framework. The Alloy metalogic programming language <ref> [3] </ref> exploits an extended version of the scheme described in this paper, including names also of non-ground expressions. This complicates the rewriting system but allows a 13 metalevel program to express properties of more general object level formulas.
Reference: [4] <author> Bowen, K. A. and Kowalski, R. A., </author> <title> Amalgamating Language and Metalan guage in Logic Programming, </title> <editor> in: K. L. Clark and S. A. Tarnlund (eds.), </editor> <booktitle> Logic Programming, </booktitle> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1982. </year>
Reference-contexts: The need to formally represent knowledge and metaknowledge 1 This is the difference with respect to Reflective Prolog, as mentioned above. 1 has led to the study of metalevel architectures <ref> [4] </ref>, where these two kinds of knowledge are explicitly represented.
Reference: [5] <author> Cervesato, I. and Rossi, G., </author> <title> Logic Meta-Programming Facilities in 'Log, </title> <editor> in: A. Pettorossi (ed.), </editor> <booktitle> Meta-Programming in Logic, </booktitle> <publisher> LNCS 649, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Sato [20] has presented a style of metaprogramming based on a truth predicate in three-valued logic. His emphasis is not on presenting a proof system, but rather a metainterpreter for the truth predicate. Cervesato and Rossi <ref> [5] </ref> present a metalevel extension of a logic programming language, called 0 Log. The extension consists of a naming scheme that associates two different metarepresentations with every syntactic object of the language, and of a destructuring operator allowing us to relate these metarepresentations.
Reference: [6] <author> Christiansen, H., </author> <title> Efficient and Complete Demo Predicates for Definite Clause Languages, </title> <type> Technical report, </type> <institution> Dept. of Comp. Sci., Roskilde Univ., </institution> <year> 1994. </year>
Reference-contexts: His logic intentionally tries to remove the distinction between predicate and function symbols, etc. For ground expressions his naming scheme can be captured in our framework, by self-naming. We are aware of a study by Christiansen <ref> [6] </ref>, whose idea is also to use a delay mechanism when computing names of expressions. His approach is somewhat different as he takes as his formalism a Prolog system extended with a delaying primitive. The Godel programming language has names as an abstract datatype [12].
Reference: [7] <author> Clark, K. L., </author> <title> Negation as Failure, </title> <editor> in: H. Gallaire and J. Minker (eds.), </editor> <booktitle> Logic and Data Bases, </booktitle> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year> <month> 14 </month>
Reference-contexts: The intuition is that "ff means the name of ff and #fi what fi names. The Herbrand equality theory <ref> [7] </ref> is extended with axioms on the forms * if "ff = "fi, then ff = fi; * if #ff = #fi, then ff = fi; * #"ff = ff; * "ff = ff 1 and #fi = fi 1 for every ground expression ff and name fi; * "ff 6=
Reference: [8] <author> Clark, K. L., </author> <title> Logic-Programming Schemes and Their Implementations, </title> <editor> in: J.-L. Lassez and G. Plotkin (eds.), </editor> <booktitle> Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: This system will be our starting point for a formal definition of SLD*-resolution. SLD-Resolution with Equations To begin with, note that it is well known how to reformulate SLD-resolution over definite clause programs in terms of sets of equations rather than substitutions (see, e.g., Clark <ref> [8] </ref>). <p> of equations might not be detected until further rewriting can take place. (This system is similar to 3 In Chapter 5 (Unification dans les langages de premier ordre) of Huet's Ph.D. thesis there is a very elegant unification algorithm for first-order expressions, which always terminates. 3 AGLD-resolution, defined by Clark <ref> [8] </ref>, originating from Wolfram, Maher and Lassez [22].) Adding Names and Reflection Consider the usual language of definite clause programs [18] extended so that for every ground term or atom there is exactly one ground term that names it.
Reference: [9] <author> Costantini, S. and Lanzarone, G. A., </author> <title> A Metalogic Programming Language, </title> <editor> in: G. Levi and M. Martelli (eds.), </editor> <booktitle> Proc. 6th Intl. Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: For example, we can choose a naming relation and a rewrite system for names to obtain a slightly modified variant of Reflective Prolog <ref> [9, 10] </ref>. The question of using ground or nonground representations in metalogic programming has been discussed intensively for a long time. In this proposal we sidestep the question, as the proposed inference system restricts reflection so only ground expressions are ever communicated between levels.
Reference: [10] <author> Costantini, S. and Lanzarone, G. A., </author> <title> A Metalogical Programming Approach: Language, Semantics and Applications, </title> <editor> J. Exper. </editor> <booktitle> Theor. Art. Int., </booktitle> <month> 1 </month> <year> (1993). </year>
Reference-contexts: For example, we can choose a naming relation and a rewrite system for names to obtain a slightly modified variant of Reflective Prolog <ref> [9, 10] </ref>. The question of using ground or nonground representations in metalogic programming has been discussed intensively for a long time. In this proposal we sidestep the question, as the proposed inference system restricts reflection so only ground expressions are ever communicated between levels. <p> In the full version of this paper, we give declarative and procedural semantics of SLD*-resolution for K (and thus L) and establish theorems of soundness and completeness. More specifically we show that (i) every answer computed by SLD*-resolution is a correct answer with respect to the Reflective Model semantics <ref> [10] </ref> and (ii) if UN is canonical, then SLD*-resolution is complete with respect to this semantics. 2 SLD*-Resolution Let us first describe informally a variant of SLD-resolution that might delay unification. This system will be our starting point for a formal definition of SLD*-resolution.
Reference: [11] <author> Heintze, N., Michaylov, S., Stuckey, P. J. and Yap, R., </author> <booktitle> On Metaprogramming in CLP(R), in: Proc. 1989 North-American Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: Here we present a brief overview, together with some other relevant work, in chronological order. Heintze et al. <ref> [11] </ref> propose an approach that integrates metaprogramming facilities and the constraint paradigm. They extend the language CLP (R) [15] with the aim of allowing manipulations of CLP (R) programs and introduce some facilities to access the coded form of the current set of constraints.
Reference: [12] <author> Hill, P. M. and Lloyd, J. W., </author> <title> The Godel Programming Language, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: His approach is somewhat different as he takes as his formalism a Prolog system extended with a delaying primitive. The Godel programming language has names as an abstract datatype <ref> [12] </ref>. Names of expressions will thus always appear as variables in metapro-grams. The metalevel part of a program can use the operations associated with the datatype to manipulate names. The naming relation of Godel is compositional and it seems to fit in our framework.
Reference: [13] <author> Huet, G., </author> <title> Resolution d'equations dans les langages d'ordre 1, </title> <type> 2, : : : , !, Ph.D. Thesis, </type> <institution> Universite Paris VII, Paris, </institution> <year> 1976. </year>
Reference-contexts: Unification can in this process be seen as a rewriting system that takes a set of equations to an equivalent Herbrand assignment (under the Herbrand equality theory). Unification algorithms that can be expressed as such rewriting systems have been defined, e.g, by Huet <ref> [13] </ref> 3 and Martelli & Montanari [19]. The assumption that unification rewrites the whole set of equations to a Herbrand assignment can be relaxed.
Reference: [14] <author> Jaffar, J. and Lassez, J.-L., </author> <title> Constraint Logic Programming, </title> <booktitle> in: Proc. 14th ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1987. </year>
Reference-contexts: The addition of these facilities enables one to develop new applications and simplification algorithms. Lim and Stuckey [17] propose a metalevel structure of computation in order to give a logical meaning to metaprograms. In particular, they extend the theory of CLP <ref> [14] </ref> with a metalevel structure that incorporates a method for representing object level terms and interpreted relations (con-straints) for manipulating object level terms. Thus, each metaprogram can be seen as a constraint logic program over this structure.
Reference: [15] <author> Jaffar, J. and Michaylov, S., </author> <title> Methodology and Implementation of a CLP System, </title> <editor> in: J.-L. Lassez (ed.), </editor> <booktitle> Proc. 4th Intl. Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1987. </year>
Reference-contexts: Here we present a brief overview, together with some other relevant work, in chronological order. Heintze et al. [11] propose an approach that integrates metaprogramming facilities and the constraint paradigm. They extend the language CLP (R) <ref> [15] </ref> with the aim of allowing manipulations of CLP (R) programs and introduce some facilities to access the coded form of the current set of constraints. The addition of these facilities enables one to develop new applications and simplification algorithms.
Reference: [16] <author> Jiang, Y. J., </author> <title> On the Semantics of Real Metalogic Programming|a Preliminary Report, </title> <type> draft, </type> <institution> Imperial College, </institution> <address> London, </address> <year> 1993. </year>
Reference-contexts: The extension consists of a naming scheme that associates two different metarepresentations with every syntactic object of the language, and of a destructuring operator allowing us to relate these metarepresentations. They use constraint satisfaction techniques to characterize the destructuring operator, rather that reflection. Jiang <ref> [16] </ref> proposes an approach quite different from ours, where he takes the syntactic ambiguity of Prolog even further. His logic intentionally tries to remove the distinction between predicate and function symbols, etc. For ground expressions his naming scheme can be captured in our framework, by self-naming.
Reference: [17] <author> Lim, P. and Stuckey, P. J., </author> <title> Meta Programming as Constraint Programming, </title> <editor> in: S. Debray and M. Hermenegildo (eds.), </editor> <booktitle> Proc. 1990 North-American Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: They extend the language CLP (R) [15] with the aim of allowing manipulations of CLP (R) programs and introduce some facilities to access the coded form of the current set of constraints. The addition of these facilities enables one to develop new applications and simplification algorithms. Lim and Stuckey <ref> [17] </ref> propose a metalevel structure of computation in order to give a logical meaning to metaprograms. In particular, they extend the theory of CLP [14] with a metalevel structure that incorporates a method for representing object level terms and interpreted relations (con-straints) for manipulating object level terms.
Reference: [18] <author> Lloyd, J. W., </author> <title> Foundations of Logic Programming, Second Edition, </title> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: 5 (Unification dans les langages de premier ordre) of Huet's Ph.D. thesis there is a very elegant unification algorithm for first-order expressions, which always terminates. 3 AGLD-resolution, defined by Clark [8], originating from Wolfram, Maher and Lassez [22].) Adding Names and Reflection Consider the usual language of definite clause programs <ref> [18] </ref> extended so that for every ground term or atom there is exactly one ground term that names it. <p> It is an instance of the language K of the previous section. The language is that of definite programs, as defined by Lloyd <ref> [18] </ref>, except that terms are defined differently in order to include name terms that are intended to denote expressions of the language itself.
Reference: [19] <author> Martelli, A. and Montanari, U., </author> <title> An Efficient Unification Algorithm, </title> <journal> ACM TOPLAS, </journal> <volume> 4 </volume> <month> 258-282 </month> <year> (1982). </year>
Reference-contexts: Unification can in this process be seen as a rewriting system that takes a set of equations to an equivalent Herbrand assignment (under the Herbrand equality theory). Unification algorithms that can be expressed as such rewriting systems have been defined, e.g, by Huet [13] 3 and Martelli & Montanari <ref> [19] </ref>. The assumption that unification rewrites the whole set of equations to a Herbrand assignment can be relaxed. Let a state instead consist of a triple hG; H; Ei, where G is a set of atoms, H is a Herbrand assignment, and E is a set of equations over terms.
Reference: [20] <author> Sato, T., </author> <title> Meta-Programming through a Truth Predicate, </title> <editor> in: K. Apt (ed.), </editor> <booktitle> Proc. Joint Intl. Conf. Symp. on Logic Programming 1992, </booktitle> <publisher> MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1992. </year> <title> [21] van Harmelen, F., Definable Naming Relations in Meta-level Systems, </title> <editor> in: A. Pettorossi (ed.), </editor> <booktitle> Meta-Programming in Logic, </booktitle> <publisher> LNCS 649, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: In particular, they extend the theory of CLP [14] with a metalevel structure that incorporates a method for representing object level terms and interpreted relations (con-straints) for manipulating object level terms. Thus, each metaprogram can be seen as a constraint logic program over this structure. Sato <ref> [20] </ref> has presented a style of metaprogramming based on a truth predicate in three-valued logic. His emphasis is not on presenting a proof system, but rather a metainterpreter for the truth predicate. Cervesato and Rossi [5] present a metalevel extension of a logic programming language, called 0 Log.
Reference: [22] <author> Wolfram, D. A., Maher, M. J. and Lassez, J.-L., </author> <title> A Unified Treatment of Resolution Strategies for Logic Programs, </title> <editor> in: S. A. Tarnlund (ed.), </editor> <booktitle> Proc. Second Intl. Logic Programming Conf., </booktitle> <institution> Uppsala Univ., Comp. Sci. Dept., </institution> <year> 1984. </year> <month> 15 </month>
Reference-contexts: further rewriting can take place. (This system is similar to 3 In Chapter 5 (Unification dans les langages de premier ordre) of Huet's Ph.D. thesis there is a very elegant unification algorithm for first-order expressions, which always terminates. 3 AGLD-resolution, defined by Clark [8], originating from Wolfram, Maher and Lassez <ref> [22] </ref>.) Adding Names and Reflection Consider the usual language of definite clause programs [18] extended so that for every ground term or atom there is exactly one ground term that names it.
References-found: 21

