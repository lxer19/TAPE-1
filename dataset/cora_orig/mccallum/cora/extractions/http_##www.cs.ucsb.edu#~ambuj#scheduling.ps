URL: http://www.cs.ucsb.edu/~ambuj/scheduling.ps
Refering-URL: http://www.cs.ucsb.edu/~ambuj/research.html
Root-URL: http://www.cs.ucsb.edu
Title: Dynamic Resource Allocation Using Views  
Author: Manhoi Choy and Ambuj K. Singh 
Address: Santa Barbara, California 93106  
Affiliation: Department of Computer Science University of California at Santa Barbara  
Abstract: In the dynamic resource allocation problem, resources have to be allocated to a set of processes whose requests vary over time. We solve this problem through the idea of views. A view of a dynamic graph is a collection of static local views, where a local view defines the neighborhood of a process. We specify the requirements of view computation, and present algorithms for computation of views. Later, we combine views with existing solutions to static resource allocation and (ffi + 1)-coloring to solve the dynamic problem. The time and message complexities of the resulting algorithm depend minimally on global parameters. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Awerbuch and M. Saks. </author> <title> A dining philosophers algorithm with polynomial response time. </title> <booktitle> In Proceedings of the 31st Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 65-74, </pages> <year> 1990. </year>
Reference-contexts: The best known deterministic solution to the resource allocation problem was presented by Awerbuch and Saks <ref> [1] </ref>. Their solution employs a distributed queue technique and achieves a response time of O (ffi 2 log M ) and a message complexity of O (ffi 2 log M ), where M is the number of processes in a system.
Reference: [2] <author> J. Bar-Ilan and D. Peleg. </author> <title> Distributed resource allocation algorithms. </title> <booktitle> In 6th International Workshop on Distributed Algorithms, </booktitle> <pages> pages 277-291, </pages> <year> 1992. </year>
Reference-contexts: Most importantly however, our algorithm minimizes the dependence of the complexity measures on global parameters. Recently, Bar-Ilan and Peleg <ref> [2] </ref> consider the resource allocation problem under the model of a synchronous complete communication network.
Reference: [3] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight Causal and Atomic Group Multicast. </title> <journal> ACM Trans. Computer Systems, </journal> <volume> vol. 9, no. 3, </volume> <pages> pp. 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: In general, this technique of merging consecutive lock requests into groups reduces the likelihood of expensive deadlocks, and can reduce overall response time. Several concepts proposed in the literature are related to the views as proposed here. In <ref> [3] </ref>, ISIS supports four types of groups: peer groups, diffusion groups, client/server groups, and hierarchical groups. The group type determines the set of communication channels allowed in a group. For example, a client in a client/server group communicates with the server but not with other clients. <p> For example, a client in a client/server group communicates with the server but not with other clients. A group is similar to the idea of a view presented here. Processes can enter and leave groups dynamically. A centralized group management has been used in <ref> [3] </ref>. Views in our paper are more dynamic in nature and there is no limit on the types of groups that are supported. Communication channels within a view correspond to the resource requests and conflicts encountered during runtime.
Reference: [4] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley Pub. Co., </publisher> <address> Reading, Mass., </address> <year> 1988. </year>
Reference-contexts: Instead of developing an algorithm from first principles, our solution reduces the dynamic resource allocation problem to two subproblems: static resource allocation or the dining philosophers problem <ref> [4] </ref>, and the vertex coloring problem. This reduction-based approach not only allows us to use the currently best algorithms for the two subproblems, but also to automatically obtain a better (dynamic) resource allocation algorithm when more efficient algorithms are available for the subproblems in the future. <p> At this time, process p4 may make a new request such that it conflicts with processes p1 and p5. The resulting conflict graph is shown in Figure 1 c). Note that in the dining philosophers problem <ref> [4] </ref>, the conflict graph is fixed so that every time a process make a request, it conflicts with a fixed set of neighbors in the conflict graph. <p> Though any dining philosophers solution can be used in Algorithm J1, the setting of the initial state requires special care. For example, consider the dining philosophers solution due to Chandy and Misra <ref> [4] </ref>. As a part of the initial state, this solution requires an acyclic graph connecting all the processes. The process IDs can be used to obtain this initial acyclic graph by directing the edge between two processes towards the one with the higher ID.
Reference: [5] <author> M. Choy and A. K. Singh. </author> <title> Efficient fault tolerant algorithms for distributed resource allocation. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> vol. 17, no. 3, </volume> <pages> pp. 535-559, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: In particular, the algorithm obtained by combining the (ffi + 1)-coloring algorithm of Goldberg, Plotkin, and Shannon [8] with a dining philosophers algorithm in <ref> [5] </ref> has a response time of O ((ffi 3 + ffi log fl M )- + O (ffi 2 )t ) and a message complexity of O (ffi 2 + ffi log fl M ). 2 The local computation time is ignored in the calculation of response time. 19 6.1 Algorithm <p> Corollary 1 The response time of algorithm J 2 is O (ffi 3 + ffi log fl M ) and the message complexity is O (ffi 2 + ffi log fl M ) when the (ffi + 1)-coloring algorithm in Figure 6 and the dining philosophers algorithm in <ref> [5] </ref> are used. Note that if only one view is used and the dining philosophers algorithm is invoked after (ffi +1)- coloring at executing 1 then the total response time would be ffi fl ( response time of (ffi + 1)-coloring + response time of dining philosophers).
Reference: [6] <author> A. El Abbadi and S. Toueg. </author> <title> Maintaining Availability in Partitioned Replicated Databases. </title> <journal> ACM Trans. Database Systems, </journal> <volume> vol. 14, no. 2, </volume> <pages> pp. 264-90. </pages> <year> 1989. </year>
Reference-contexts: Views are formed in a distributed fashion and messages of the applications can be delivered before the entire view is formed globally. Blocking is possible, however, if messages are to be delivered to conflicting processes that are executing in other views. The concept of view introduced in <ref> [6, 10] </ref> is for supporting one-copy serializable executions of transactions in a replicated database environment. The view of a site A in [6] is the set of sites that A "believes" it can communicate with. Each transaction T has a home site home (T ). <p> Blocking is possible, however, if messages are to be delivered to conflicting processes that are executing in other views. The concept of view introduced in [6, 10] is for supporting one-copy serializable executions of transactions in a replicated database environment. The view of a site A in <ref> [6] </ref> is the set of sites that A "believes" it can communicate with. Each transaction T has a home site home (T ). If the view of a site A changes, all active transaction whose home is A must abort. They can be restarted with A's new view. <p> They can be restarted with A's new view. Successive views of a site are assigned with view identifiers. Views in [10] are collection of sites that hold replicated copies of data. Centralized view management schemes are used in <ref> [6, 10] </ref>. View in our paper are collections of active processes that cooperate to execute an algorithm. All sites in a view of [6, 10] are updated with data and view information when view change occurs. <p> Views in [10] are collection of sites that hold replicated copies of data. Centralized view management schemes are used in <ref> [6, 10] </ref>. View in our paper are collections of active processes that cooperate to execute an algorithm. All sites in a view of [6, 10] are updated with data and view information when view change occurs. On the other hand, our view changes occur in a distributed manner and a single process does not need to know about the entire view.
Reference: [7] <author> R. Friedman and R. van Renesse. </author> <title> Strong and Weak Virtual Synchrony in Horus. </title> <booktitle> In Proceedings of the 15th Annual Symposium on Reliable Distributed Systems, </booktitle> <pages> pp. 140-149, </pages> <year> 1996. </year> <month> 27 </month>
Reference-contexts: Communication channels within a view correspond to the resource requests and conflicts encountered during runtime. The virtual synchrony execution model was introduced in ISIS and extended and implemented in a number of systems including Horus <ref> [7, 11] </ref>. In [7], the authors distinguish the notions of strong 26 virtual synchrony and weak virtual synchrony. With strong virtual synchrony, every message is delivered within the view in which it was sent. <p> Communication channels within a view correspond to the resource requests and conflicts encountered during runtime. The virtual synchrony execution model was introduced in ISIS and extended and implemented in a number of systems including Horus [7, 11]. In <ref> [7] </ref>, the authors distinguish the notions of strong 26 virtual synchrony and weak virtual synchrony. With strong virtual synchrony, every message is delivered within the view in which it was sent.
Reference: [8] <author> A. V. Goldberg, S. A. Plotkin, and G. E. Shannon. </author> <title> Parallel symmetry-breaking in sparse graphs. </title> <booktitle> In Proceedings of the 19th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 315-324, </pages> <year> 1987. </year>
Reference-contexts: In particular, the algorithm obtained by combining the (ffi + 1)-coloring algorithm of Goldberg, Plotkin, and Shannon <ref> [8] </ref> with a dining philosophers algorithm in [5] has a response time of O ((ffi 3 + ffi log fl M )- + O (ffi 2 )t ) and a message complexity of O (ffi 2 + ffi log fl M ). 2 The local computation time is ignored in the <p> phase 3 fl = obtain 3-colorings from the 6-colorings; = fl phase 4 fl = reduce the 3-colorings to a valid (ffi + 1)-coloring that does not use colors in set P ; The (ffi + 1)-coloring algorithm used here is based on the algorithm by Goldberg, Plotkin, and Shannon <ref> [8] </ref>. However, our algorithm (shown in Figure 6) is implemented in a distributed message passing environment instead of a shared memory environment and the validity of a coloring is slightly different. A node invoking our coloring algorithm has two parameters R and P such that jRj + jP j ffi. <p> Since an edge points outward from a node in pseudo forest G k only if the node assigns k to the edge, the out-degree of each node in a pseudo forest is at most one. In the second phase of the algorithm, the 6-coloring algorithm described in <ref> [8] </ref> is executed on 22 each pseudo forest G k . <p> concatenation of ith bit of its previous color and the binary representation of i, where i is the least significant bit of p's color that is different from the corresponding bit of the color of p's parent. (For a root node, i is taken as zero.) It is shown in <ref> [8] </ref> that a 6-coloring is obtained for each pseudo forest after the re-coloring procedure is repeated for O (log fl M ) steps where M is the maximum value of the IDs.
Reference: [9] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: A history is formed by a sequence of global state transitions. A global state s precedes another global state t in a given history if s occurs prior to t in the history. We use the following linear time temporal logic operators <ref> [9] </ref> in our specifications and proofs. * 2 p means that p holds currently and at all future global states. * 2 p means that p holds currently and at all previous global states. * 3 p means that p holds currently or at some future global state. * 3 p
Reference: [10] <author> B. Oki and B. Liskov. </author> <title> Viewstamped Replication: A New Primary Copy Method to Support Highly-Available Distributed Systems. </title> <booktitle> In Proceedings of the Seventh Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 8-17, </pages> <year> 1988. </year>
Reference-contexts: Views are formed in a distributed fashion and messages of the applications can be delivered before the entire view is formed globally. Blocking is possible, however, if messages are to be delivered to conflicting processes that are executing in other views. The concept of view introduced in <ref> [6, 10] </ref> is for supporting one-copy serializable executions of transactions in a replicated database environment. The view of a site A in [6] is the set of sites that A "believes" it can communicate with. Each transaction T has a home site home (T ). <p> Each transaction T has a home site home (T ). If the view of a site A changes, all active transaction whose home is A must abort. They can be restarted with A's new view. Successive views of a site are assigned with view identifiers. Views in <ref> [10] </ref> are collection of sites that hold replicated copies of data. Centralized view management schemes are used in [6, 10]. View in our paper are collections of active processes that cooperate to execute an algorithm. <p> They can be restarted with A's new view. Successive views of a site are assigned with view identifiers. Views in [10] are collection of sites that hold replicated copies of data. Centralized view management schemes are used in <ref> [6, 10] </ref>. View in our paper are collections of active processes that cooperate to execute an algorithm. All sites in a view of [6, 10] are updated with data and view information when view change occurs. <p> Views in [10] are collection of sites that hold replicated copies of data. Centralized view management schemes are used in <ref> [6, 10] </ref>. View in our paper are collections of active processes that cooperate to execute an algorithm. All sites in a view of [6, 10] are updated with data and view information when view change occurs. On the other hand, our view changes occur in a distributed manner and a single process does not need to know about the entire view.
Reference: [11] <author> R. van Renesse, K. P. Birman, R. Friedman, M. Hayden, and D. A. Karr. </author> <title> A Framework for Protocol Composition in Horus. </title> <booktitle> In Proceedings of the Fourteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 80-89, </pages> <year> 1995. </year>
Reference-contexts: Communication channels within a view correspond to the resource requests and conflicts encountered during runtime. The virtual synchrony execution model was introduced in ISIS and extended and implemented in a number of systems including Horus <ref> [7, 11] </ref>. In [7], the authors distinguish the notions of strong 26 virtual synchrony and weak virtual synchrony. With strong virtual synchrony, every message is delivered within the view in which it was sent.
References-found: 11

