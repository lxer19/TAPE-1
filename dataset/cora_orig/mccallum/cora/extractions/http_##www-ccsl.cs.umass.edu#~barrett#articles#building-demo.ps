URL: http://www-ccsl.cs.umass.edu/~barrett/articles/building-demo.ps
Refering-URL: http://www-ccsl.cs.umass.edu/~barrett/publications.html
Root-URL: 
Title: Building A Demo: A Comparison Of Three Software Integration Mechanisms  
Author: Daniel J. Barrett Jack Wileden, Professor 
Note: (printed  
Date: December 15, 1993  February 6, 1995)  
Address: 791N  
Affiliation: Computer Science  
Abstract: This paper describes my experience in using ToolTalk, Polylith, and Q to integrate the components of a large software system. This experiment uncovered practical details about these integration mech anisms that are not obvious from their literature.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Daniel J. Barrett. </author> <title> SDL BMS: A Simple Broadcast Message Server. Arcadia Document UM-93-03, </title> <institution> University of Massachusetts, Software Development Laboratory, Computer Science Department, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: The PIC Demo was originally integrated using an RPC mechanism called Q [6], which allows communication of data values between C and Ada programs. Using Q as a foundation, a broadcast message server called BMS <ref> [1] </ref> was created to handle communication among the clients. For communication between the clients and Server, a software interface called PICPocket was created, again using Q.
Reference: [2] <author> Barry W. Boehm and William L. Scherlis. </author> <note> Megaprogramming (Preliminary Version). </note>
Reference-contexts: 1 Introduction The problem of high-level communication between concurrently executing programs has been addressed by many ([4], [5], [10], [11], et. al.). Recently, the term megaprogramming <ref> [2, 14] </ref> has been invented to describe the integration of large, diverse software systems or megamodules [14]. Whether existing software integration mechanisms can handle the rigors of megapro-gramming has yet to be seen.
Reference: [3] <author> Charles Falkenberg, Christine Hofmeister, Chen Chen, Elizabeth White, Joanne Atlee, Paul Hagger, and James Purtilo. </author> <title> The Polylith Interconnection System: Programming Manual for the Network Bus. </title> <institution> University of Maryland, College Park, </institution> <address> 3.0 edition, </address> <month> September </month> <year> 1993. </year> <note> Draft. 17 </note>
Reference-contexts: Several of these disadvantages have been addressed in Polylith 3.0. 7.3 About Polylith 3.0 As this document went to press, Jim Purtilo sent me a draft of the manual for Polylith 3.0 <ref> [3] </ref>. This version contains some significant changes that will make Polylith much more suitable for the PIC Demo and other applications with similar requirements for dynamic behavior.
Reference: [4] <author> Colin Gerety. </author> <title> HP SoftBench: A New Generation of Software Devel--opment Tools. SoftBench Technical Note Series SESD-89-25, Revision 1.4, </title> <institution> Hewlett-Packard, </institution> <month> November </month> <year> 1989. </year>
Reference-contexts: All three mechanisms surveyed require source code modifica-tion. Other mechanisms such as SoftBench <ref> [4] </ref> do not, but they have other limitations. "Program Registration" and "Message Filtering" indicate how (if at all) participating programs register for integration mechanism services in general, and for receipt of particular messages, respectively.
Reference: [5] <author> Astrid Julienne and Larry Russell. </author> <title> Why You Need ToolTalk. </title> <journal> SunEX-PERT Magazine, </journal> <pages> pages 51-58, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: 1 Introduction The problem of high-level communication between concurrently executing programs has been addressed by many ([4], <ref> [5] </ref>, [10], [11], et. al.). Recently, the term megaprogramming [2, 14] has been invented to describe the integration of large, diverse software systems or megamodules [14]. Whether existing software integration mechanisms can handle the rigors of megapro-gramming has yet to be seen. <p> Whether existing software integration mechanisms can handle the rigors of megapro-gramming has yet to be seen. As an experiment, three such integration mechanisms | remote procedure calls (RPC) [13], ToolTalk <ref> [5] </ref>, and Polylith [10] | were each used to integrate a large software system called the Precise Interface Control (PIC) Demo [15]. <p> The SDL PIC Demo exceeded this limit regularly, since the arrays of records managed by PICPocket were very large. 6 ToolTalk ToolTalk <ref> [5] </ref> is an integration mechanism created by Sun Microsystems. It is a library of over 200 functions for message passing. Its operation is similar to that of Q: data values are packed into messages that get transmitted. However, ToolTalk has several notable differences from Q and BMS: 1.
Reference: [6] <author> M. Maybee, L. J. Osterweil, and S. D. Sykes. </author> <title> Q: A Multi-lingual In-terprocess Communications System for Software Environment Implementation. </title> <type> Technical Report CU-CS-476-90, </type> <institution> University of Colorado, Boulder, </institution> <month> June </month> <year> 1990. </year> <note> Currently undergoing review for publication in Software Practice and Experience. </note>
Reference-contexts: The clients have 1 We later discuss other kinds of clients, such as "BMS clients." 3 4 a shared ontology [14] with their view of the server and their broadcast communication system. The PIC Demo was originally integrated using an RPC mechanism called Q <ref> [6] </ref>, which allows communication of data values between C and Ada programs. Using Q as a foundation, a broadcast message server called BMS [1] was created to handle communication among the clients. For communication between the clients and Server, a software interface called PICPocket was created, again using Q. <p> When Server is once again compilable, I will update my work to use it so the true Demo can be run. I expect this update to be very little work. 5 Sun RPC, Q, and the SDL BMS Q <ref> [6] </ref> is an RPC mechanism closely patterned after Sun's XDR [12]. It is nearly function-call-compatible with XDR; but unlike XDR, Q provides a programmer's interface for Ada. This makes Q a potentially suitable choice for integrating the SDL PIC Demo. Q RPC works in the following way: 1.
Reference: [7] <author> James Purtilo, </author> <month> December </month> <year> 1993. </year> <type> Personal communication. </type>
Reference-contexts: The PIC clients use command-line arguments. However, in the current implementation, Polylith "steals" all command-line arguments for its own purposes. This is a conflict. Polylith's object attribute features, which are often used in place of command-line arguments <ref> [7] </ref>, unfortu nately must be declared statically in a program's MIL specification. 2 2 There is reportedly another Polylith feature called polyargs which is dynamic enough to use for the PIC Demo.
Reference: [8] <author> James Purtilo, Charles Falkenberg, Elizabeth White, William Ander-sen, and Tess Ollove. </author> <title> An Exercise With Prototyping Technology. </title> <type> Technical report, </type> <institution> University of Maryland, </institution> <year> 1993. </year> <note> Draft. </note>
Reference-contexts: This should not be seen as a denigration of Polylith's capabilities, but rather as a realization of its 13 inappropriateness for this particular application. Polylith has been shown to be useful for other real-life programming problems <ref> [8] </ref>. 7.2 Pros & Cons Polylith has some important strengths: * Once application programs have been modified to contain bus read and write calls, it is very convenient to create and modify connections between programs using MIL. This property makes Polylith good for rapid prototyping.
Reference: [9] <author> James Purtilo, Richard T. Snodgrass, and Alexander Wolf. </author> <title> Software Bus Organization: Reference Model and Comparison of Two Existing Systems. Technical Note 8, DARPA Module Interconnection Formalism Working Group, </title> <month> November </month> <year> 1991. </year>
Reference-contexts: The semantics of unregistering in ToolTalk are not well documented. 7 Polylith Polylith [10] was created by Jim Purtilo of the University of Maryland. It is an implementation of the software bus concept <ref> [9] </ref> in which programs may communicate point-to-point via named "bus channels." Program integration with Polylith is accomplished in the following manner: 1. One or more bus channels are invented by choosing arbitrary names. 2.
Reference: [10] <author> James M. Purtilo. </author> <title> The Polylith Software Bus. </title> <type> Technical Report UMIACS-TR-90-65, </type> <institution> University of Maryland, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The problem of high-level communication between concurrently executing programs has been addressed by many ([4], [5], <ref> [10] </ref>, [11], et. al.). Recently, the term megaprogramming [2, 14] has been invented to describe the integration of large, diverse software systems or megamodules [14]. Whether existing software integration mechanisms can handle the rigors of megapro-gramming has yet to be seen. <p> Whether existing software integration mechanisms can handle the rigors of megapro-gramming has yet to be seen. As an experiment, three such integration mechanisms | remote procedure calls (RPC) [13], ToolTalk [5], and Polylith <ref> [10] </ref> | were each used to integrate a large software system called the Precise Interface Control (PIC) Demo [15]. <p> A brute-force method | "suspend" causes Server to unregister for all messages except the "resume" message | failed for unknown reasons. The semantics of unregistering in ToolTalk are not well documented. 7 Polylith Polylith <ref> [10] </ref> was created by Jim Purtilo of the University of Maryland. It is an implementation of the software bus concept [9] in which programs may communicate point-to-point via named "bus channels." Program integration with Polylith is accomplished in the following manner: 1.
Reference: [11] <author> Steven P. Reiss. </author> <title> Connecting Tools Using Message Passing in the Field Environment. </title> <journal> IEEE Software, </journal> <month> July </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The problem of high-level communication between concurrently executing programs has been addressed by many ([4], [5], [10], <ref> [11] </ref>, et. al.). Recently, the term megaprogramming [2, 14] has been invented to describe the integration of large, diverse software systems or megamodules [14]. Whether existing software integration mechanisms can handle the rigors of megapro-gramming has yet to be seen.
Reference: [12] <author> Sun Microsystems. XDR: </author> <title> External Data Representation Standard. </title> <type> Technical Report RFC-1014, </type> <institution> Sun Microsystems, Inc., </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: When Server is once again compilable, I will update my work to use it so the true Demo can be run. I expect this update to be very little work. 5 Sun RPC, Q, and the SDL BMS Q [6] is an RPC mechanism closely patterned after Sun's XDR <ref> [12] </ref>. It is nearly function-call-compatible with XDR; but unlike XDR, Q provides a programmer's interface for Ada. This makes Q a potentially suitable choice for integrating the SDL PIC Demo. Q RPC works in the following way: 1. The program declares a "handle" variable. 2.
Reference: [13] <author> Sun Microsystems. </author> <title> RPC: Remote Procedure Call Protocol Specification. </title> <type> Technical Report RFC-1057, </type> <institution> Sun Microsystems, Inc., </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Recently, the term megaprogramming [2, 14] has been invented to describe the integration of large, diverse software systems or megamodules [14]. Whether existing software integration mechanisms can handle the rigors of megapro-gramming has yet to be seen. As an experiment, three such integration mechanisms | remote procedure calls (RPC) <ref> [13] </ref>, ToolTalk [5], and Polylith [10] | were each used to integrate a large software system called the Precise Interface Control (PIC) Demo [15].
Reference: [14] <author> Gio Wiederhold, Peter Wegner, and Stefano Ceri. </author> <title> Toward Megapro-gramming. </title> <journal> Communications of the ACM, </journal> <month> November </month> <year> 1992. </year>
Reference-contexts: 1 Introduction The problem of high-level communication between concurrently executing programs has been addressed by many ([4], [5], [10], [11], et. al.). Recently, the term megaprogramming <ref> [2, 14] </ref> has been invented to describe the integration of large, diverse software systems or megamodules [14]. Whether existing software integration mechanisms can handle the rigors of megapro-gramming has yet to be seen. <p> 1 Introduction The problem of high-level communication between concurrently executing programs has been addressed by many ([4], [5], [10], [11], et. al.). Recently, the term megaprogramming [2, 14] has been invented to describe the integration of large, diverse software systems or megamodules <ref> [14] </ref>. Whether existing software integration mechanisms can handle the rigors of megapro-gramming has yet to be seen. <p> See Figure 1, page 4. Light arrows represent Class 1 communication, and bold arrows represent Class 2 communication. From a megaprogramming point of view, the PIC Demo may be viewed in several ways. On the one hand, each of the seven programs may be considered a "megamodule" <ref> [14] </ref> since it is a separate program. However, the PIC clients are not very large and have relatively simple purposes compared to Server. So an alternate way of viewing the Demo is to consider Server as one megamodule, and the set of clients as another. <p> So an alternate way of viewing the Demo is to consider Server as one megamodule, and the set of clients as another. The clients have 1 We later discuss other kinds of clients, such as "BMS clients." 3 4 a shared ontology <ref> [14] </ref> with their view of the server and their broadcast communication system. The PIC Demo was originally integrated using an RPC mechanism called Q [6], which allows communication of data values between C and Ada programs.
Reference: [15] <author> Alexander L. Wolf, Lori A. Clarke, and Jack C. Wileden. </author> <title> Ada-Based Support for Programming-in-the-Large. </title> <journal> IEEE Software, </journal> <volume> 2(2) </volume> <pages> 58-71, </pages> <month> March </month> <year> 1985. </year> <month> 18 </month>
Reference-contexts: As an experiment, three such integration mechanisms | remote procedure calls (RPC) [13], ToolTalk [5], and Polylith [10] | were each used to integrate a large software system called the Precise Interface Control (PIC) Demo <ref> [15] </ref>. This paper discusses each mechanism and evaluates its suitability for the task. 1 2 Definitions For the purposes of this paper, an integration mechanism is a software entity that is used to permit two or more programs to communicate. <p> The Demo consists of seven C and Ada programs, comprising 100,000 lines (4 megabytes) of source code, running concurrently on a Sun SPARCstation. These programs work together to demonstrate Precise Interface Control (PIC) <ref> [15] </ref>, a paradigm which gives a software engineer control over the import and export behavior of source code modules. The Demo follows a client-server architecture in which are clients and an Ada program is the server.
References-found: 15

