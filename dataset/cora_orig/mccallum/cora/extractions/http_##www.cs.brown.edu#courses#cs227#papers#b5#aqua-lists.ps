URL: http://www.cs.brown.edu/courses/cs227/papers/b5/aqua-lists.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Title: The AQUA Approach to Querying Lists and Trees in Object-Oriented Databases  
Author: Bharathi Subramanian Theodore W. Leung Brown Universityy Brown Universityy Scott L. Vandenberg Stanley B. Zdonik Siena Collegez Brown Universityy 
Date: 1995  
Note: To appear in Proc. 11th Intl. Conf. on Data Engg.,  
Abstract: Relational database systems and most object-oriented database systems provide support for queries. Usually these queries represent retrievals over sets or multisets. Many new applications for databases, such as multimedia systems and digital libraries, need support for queries on complex bulk types such as lists and trees. In this paper we describe an object-oriented query algebra for lists and trees. The operators in the algebra preserve the ordering between the elements of a list or tree, even when the result list or tree contains an arbitrary set of nodes from the original tree. We also present predicate languages for lists and trees which allow order-sensitive queries because they use pattern matching to examine groups of list or tree nodes rather than individual nodes. The ability to decompose predicate patterns enables optimizations that make use of indices. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, M. Ganapathi, and S. W. K. Tjiang, </author> <title> "Code Generation using Tree Matching and Dynamic Programming," </title> <journal> ACM Trans. on Programming Languages and Systems 11 (1989), </journal> <pages> 491-516. </pages>
Reference-contexts: Similarly, scientific applications often deal with RNA-sequences [28] or with multi-dimensional arrays. Other applications that can benefit from a more comprehensive approach to queries and bulk types include geographic databases, electronic libraries, vision [26], molecular biology [28], program compilation <ref> [1] </ref>, natural language processing, and hypermedia applications.
Reference: [2] <author> C. Beeri and Y. Kornatzky, </author> <title> "Algebraic Optimization of Object-Oriented Query Languages," </title> <booktitle> Proc. ICDT (1990), </booktitle> <pages> 72-83. </pages>
Reference-contexts: However, most of the previous work deals with ordered types in a piecemeal fashion our work is unique in that it takes a holistic approach to bulk types, including a richer notion of pattern matching. The operations described in <ref> [2] </ref> are intended to be applicable to any bulk type, not just to lists and trees. As a result, operations like selecting a sublist are not provided. MDM [24] presents a query algebra to support lists in an object-oriented data model.
Reference: [3] <author> C. Beeri and P. Ta-Shma, </author> <title> "Bulk Data Types, A Theoretical Approach," </title> <booktitle> Proc. DBPL (1993), </booktitle> <pages> 80-96. </pages>
Reference: [4] <author> J. A. Brzozowski, </author> <title> "Derivatives of regular expressions," </title> <editor> J. </editor> <booktitle> ACM 11 (1964), </booktitle> <pages> 481-494. </pages>
Reference: [5] <author> R. G. G. Cattell, ed., </author> <title> The Object Database Standard: ODMG-93, </title> <publisher> Release 1.1 , Morgan Kaufmann Publishers, </publisher> <address> San Francisco, </address> <year> 1994. </year>
Reference-contexts: There we present opti To appear in Proc. 11th Intl. Conf. on Data Engg., 1995 mization rules and access methods for ordered data types. As part of our research on AQUA, we have developed a mapping for the ODMG set and bag algebra <ref> [5] </ref> to the AQUA set and multiset algebra. The array type in the ODMG specification is similar to our notion of list, and we believe that we will have little difficulty simulating the ODMG arrays with AQUA lists. Our view of predicates, however, is significantly more powerful.
Reference: [6] <author> J. Doner, </author> <title> "Tree Acceptors and Some of their Applications," </title> <editor> J. </editor> <booktitle> of Computer and System Sciences 4 (1970), </booktitle> <pages> 406-451. </pages>
Reference: [7] <editor> H. Ehrig, H. -J. Kreowski, and G. Rozenberg, eds., </editor> <title> Graph Grammars and Their Applications to Computer Science #532, </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [8] <author> J. Engelfriet and G. Rozenberg, </author> <title> "Graph Grammars based on node rewriting: An Introduction to NLC Graph Grammars ," Proc. </title> <booktitle> 4th Intl. on Graph Grammars and Their Applications to Computer Science 532 (1991), </booktitle> <pages> 12-23. </pages>
Reference: [9] <author> C. Faloutsos, M. Ranganathan, and Y. Manolopoulos, </author> <title> "Fast Subsequence Matching in Time-Series Databases," </title> <booktitle> Proc. SIGMOD (1994), </booktitle> <pages> 419-429. </pages>
Reference-contexts: Such metrics are easily accommodated in our formalisms. The authors also present various optimizations for distance-based queries with associated indices that can be expressed by query transformations in the AQUA algebra. Approximate subsequence matching for lists is addressed in <ref> [9] </ref>, but only fixed-length patterns are allowed (no regular expressions). Many commercial systems (e.g.
Reference: [10] <author> N. H. Gehani, H. V. Jagadish, and O. Shumueli, </author> <title> "Composite Event Specification in Active Databases," </title> <booktitle> Proc. VLDB (1992), </booktitle> <pages> 327-338. </pages>
Reference-contexts: simply the same queries that can be asked of sets; the ordering properties of lists are not taken into account in either the predicate language or in the result of the query. 7.2 Predicates for List and Tree Queries A model and language for sequences of events is presented in <ref> [10] </ref>. Their pattern language is equivalent to regular expressions, but the result of any query is a single sequence, restricting the set of allowable queries. Query optimizations such as ours are not addressed. A powerful pattern language for strings (but not trees) is described in [13].
Reference: [11] <author> S. Ginsburg and X. Wang, </author> <title> "Pattern Matching by Rs-Operations: Towards a Unified Approach to Querying Sequenced Data," </title> <booktitle> Proc. PODS (1992), </booktitle> <pages> 293-300. </pages>
Reference-contexts: A tree-like structure in a document (paragraphs under sections) is handled by treating it as a nested sequence of sequences. The predicate language is limited in its power for example, it cannot be used to extract sublists. To appear in Proc. 11th Intl. Conf. on Data Engg., 1995 Rs-operations <ref> [11] </ref> are sequence operations that are based on pattern matching. Ginsburg and Wang define a set of powerful operations based on regular expressions that act as a kind of template for the operation, i.e., the regular expressions define what the operation should do "by example".
Reference: [12] <author> G. H. Gonnet and F. W. Tompa, </author> <title> "Mind Your Grammar: a New Approach to Modelling Text," </title> <booktitle> Proc. VLDB (1987), </booktitle> <pages> 339-346. </pages>
Reference: [13] <author> G. Grahne, M. Nykanen, and E. Ukkonen, </author> <title> "Reasoning about Strings in Datbases," </title> <booktitle> Proc. PODS (1994), </booktitle> <pages> 303-312. </pages>
Reference-contexts: Their pattern language is equivalent to regular expressions, but the result of any query is a single sequence, restricting the set of allowable queries. Query optimizations such as ours are not addressed. A powerful pattern language for strings (but not trees) is described in <ref> [13] </ref>. This language is context-sensitive and thus more powerful than ours, but no attention is given to fitting it into an object-oriented context or into a query optimization scheme. It extends the relational algebra select by allowing filters based on multitape automata.
Reference: [14] <author> R. H. Guting, "GraphDB: </author> <title> A Data Model and Query Language for Graphs in Databases," </title> <booktitle> Proc. VLDB (1994). </booktitle>
Reference-contexts: There are some papers that address other types like trees [2,3] and graphs <ref> [14] </ref>. However, most of the previous work deals with ordered types in a piecemeal fashion our work is unique in that it takes a holistic approach to bulk types, including a richer notion of pattern matching.
Reference: [15] <author> R. H. Guting, R. Zicari, and D. M. Choy, </author> <title> "An Algebra for Structured Office Documents," </title> <journal> ACM Trans. on Office Info. Systems 7 (1989), </journal> <pages> 123-157. </pages>
Reference-contexts: However, their predicate language for lists is not as versatile as regular expressions since predicates are applied to each element of the list rather than the list as a whole. The NST algebra <ref> [15] </ref> is specifically designed for structured office documents and is an extension of relational algebra. It tries to maintain the order of the input lists whenever possible, with a higher preference for the order of the first input list. As a result, most of the operators are not commutative.
Reference: [16] <author> M. Gyssens, J. Paredaens, and D. V. Gucht, </author> <title> "A Grammar-Based Approach Towards Unifying Hierarchical Data Models," </title> <booktitle> Proc. SIGMOD (1989), </booktitle> <pages> 263-272. </pages>
Reference: [17] <author> C. M. Hoffmann and M. J. O'Donnell, </author> <title> "Pattern Matching in Trees," </title> <editor> J. </editor> <booktitle> ACM 29 (1982), </booktitle> <pages> 68-95. </pages>
Reference: [18] <author> R. Karp, R. Miller, and A. Rosenberg, </author> <title> "Rapid Identification of Repeated Patterns in Strings, Trees, and Arrays," </title> <booktitle> Proc. STOC (1972), </booktitle> <pages> 125-136. </pages>
Reference: [19] <author> T. W. Leung, G. Mitchell, B. Subramanian, B. Vance, S. L. Vandenberg, and S. B. Zdonik, </author> <title> "The AQUA Data Model and Algebra," </title> <booktitle> Proc. DBPL (1993), </booktitle> <pages> 157-175. </pages>
Reference-contexts: The resulting sub-pieces are frequently able to make good use of indexes. In another paper [31] we propose a framework for optimizing list and tree queries, and provide some guidelines and rules that can be used for query rewrites. This work is done in the context of the AQUA <ref> [19] </ref> query algebra that has been developed jointly among Oregon Graduate Institute, University of Wisconsin, and Brown University as a standard input language for query optimizers. The remainder of the paper is organized as follows. Section 2 provides background and overview of AQUA. <p> In Section 7 we discuss related work and finally in Section 8 we give a summary of the paper and a brief outline of future and ongoing work. 2 Background In this section we provide a brief overview of the AQUA data model <ref> [19] </ref> with special emphasis on those aspects that apply to ordered bulk types. All entities in the AQUA model are objects, i.e. all entities have identity and provide a set of functions which define the protocol for the object. Since every object has identity, issues of equality [29] become critical. <p> The AQUA data model consists of the following type constructors: Set, Multiset, Tuple, Union, Function, Abstraction, List, Tree, and Graph. Each of these types provides a collection of algebraic operators <ref> [19] </ref>, which form the basis for the algebra. One design criteria for the list and tree operators was to generalize existing operators for sets and multisets when possible. For example, AQUA's sets can be viewed as trees or lists with an empty edge set. <p> It can be used to construct all of the other matching operators. Additionally, split may be viewed as an order-preserving analog for fold <ref> [19] </ref> that is based on pattern matching. Split also allows us to preserve the context of the match. One might ask, though, what is the use of retaining the context.
Reference: [20] <author> D. Maier and B. Vance, </author> <title> "A Call to Order," </title> <booktitle> Proc. PODS (1993), </booktitle> <pages> 1-16. </pages>
Reference: [21] <author> R. McNaughton and H. Yamada, </author> <title> "Regular expressions and state graphs for automata," </title> <journal> IEEE Trans. on Electronic Computers 9 (1960), </journal> <pages> 39-47. </pages>
Reference: [22] <author> G. Mitchell, U. Dayal, and S. B. Zdonik, </author> <title> "Control of an Extensible Query Optimizer: </title> <booktitle> A Planning-Based Approach ," Proc. VLDB (1993), </booktitle> <pages> 517-528. </pages>
Reference-contexts: Our view of predicates, however, is significantly more powerful. We are currently developing a cost model and incorporating the list and tree algebras into the EPOQ extensible query optimizer <ref> [22] </ref> being developed at Brown University. Acknowledgements We would like to thank Catriel Beeri, Mitch Cherni-ack, Darryn Lavery, Gail Mitchell, Arnold Rosenberg, Dennis Shasha, Hagit Shatkay, Sairam Subramanian, Bennet Vance, and Jason Wang for useful discussions.
Reference: [23] <author> J. Orenstein, S. Haradhvala, B. Margulies, and D. Sakahara, </author> <title> "Query Processing in the ObjectStore Database System," </title> <booktitle> Proc. SIGMOD (1992), </booktitle> <pages> 403-412. </pages>
Reference-contexts: The authors also present various optimizations for distance-based queries with associated indices that can be expressed by query transformations in the AQUA algebra. Approximate subsequence matching for lists is addressed in [9], but only fixed-length patterns are allowed (no regular expressions). Many commercial systems (e.g. ObjectStore <ref> [23] </ref>) claim to support queries on lists, but these are simply the same queries that can be asked of sets; the ordering properties of lists are not taken into account in either the predicate language or in the result of the query. 7.2 Predicates for List and Tree Queries A model
Reference: [24] <author> J. Richardson, </author> <title> "Supporting Lists in a Data Model (A Timely Approach)," </title> <booktitle> Proc. VLDB (1992). </booktitle>
Reference-contexts: The operations described in [2] are intended to be applicable to any bulk type, not just to lists and trees. As a result, operations like selecting a sublist are not provided. MDM <ref> [24] </ref> presents a query algebra to support lists in an object-oriented data model. The salient feature of their algebra is the extension of the predicate language to allow position-dependent queries.
Reference: [25] <author> A. Salomaa, </author> <title> "Two complete axiom systems for the algebra of regular events," </title> <editor> J. </editor> <booktitle> ACM 13(1966), </booktitle> <pages> 158-169. </pages>
Reference: [26] <author> H. Samet, </author> <title> "Distance Transform for Images represented by Quadtrees," </title> <journal> IEEE Trans. on Pattern Analysis and Machine Intelligence 4 (1982), </journal> <pages> 298-303. </pages>
Reference-contexts: Similarly, scientific applications often deal with RNA-sequences [28] or with multi-dimensional arrays. Other applications that can benefit from a more comprehensive approach to queries and bulk types include geographic databases, electronic libraries, vision <ref> [26] </ref>, molecular biology [28], program compilation [1], natural language processing, and hypermedia applications.
Reference: [27] <author> P. Seshadri, M. Livny, and R. Ramakrishnan, </author> <title> "Sequence Query Processing," </title> <booktitle> Proc. SIGMOD (1994), </booktitle> <pages> 430-441. </pages>
Reference-contexts: Each schema, represented by a tree, defines an "isa" relationship between the parent node and the child nodes. These papers, however, do not address the issue of more general trees. An algebra for queries on sequences is presented in <ref> [27] </ref>, but this algebra does not address pattern-matching (its predicates are applied to one node at a time). All of the operators result in a single sequence. Recent work [35,36] on approximate tree matching discusses tree algebras targeted towards problems in vision and molecular biology.
Reference: [28] <author> B. A. Shapiro and K. Zhang, </author> <title> "Comparing Multiple RNA Secondary Structures using Tree Comparisions," </title> <journal> Comput. Appl. Biosci. </journal> <volume> 6 (1990), </volume> <pages> 309-318. </pages>
Reference-contexts: Here, a document can be viewed as a tree of document components; a video is a sequence of frames; a sound-track is a sequence of tones. Similarly, scientific applications often deal with RNA-sequences <ref> [28] </ref> or with multi-dimensional arrays. Other applications that can benefit from a more comprehensive approach to queries and bulk types include geographic databases, electronic libraries, vision [26], molecular biology [28], program compilation [1], natural language processing, and hypermedia applications. <p> Similarly, scientific applications often deal with RNA-sequences <ref> [28] </ref> or with multi-dimensional arrays. Other applications that can benefit from a more comprehensive approach to queries and bulk types include geographic databases, electronic libraries, vision [26], molecular biology [28], program compilation [1], natural language processing, and hypermedia applications.
Reference: [29] <author> G. M. Shaw and S. B. Zdonik, </author> <title> "Object-Oriented Queries: Equivalence and Optimization," </title> <booktitle> Proc. 1st Intl. Conf. on Deductive and Object-Oriented Databases (1989), </booktitle> <pages> 264-278. </pages>
Reference-contexts: All entities in the AQUA model are objects, i.e. all entities have identity and provide a set of functions which define the protocol for the object. Since every object has identity, issues of equality <ref> [29] </ref> become critical. AQUA allows equality to be specified as a parameter to some of its operators (e.g., set union), thereby allowing queries to use various notions of equality. The AQUA data model consists of the following type constructors: Set, Multiset, Tuple, Union, Function, Abstraction, List, Tree, and Graph.
Reference: [30] <author> B. Subramanian, T. W. Leung, S. L. Vandenberg, and S. B. Zdonik, </author> <title> "The AQUA Approach to Querying Lists and Trees in Object-Oriented Databases," </title> <institution> Brown Univ., Dept. of CS, </institution> <type> Tech. Report, </type> <address> Providence, RI 02912-1910, </address> <year> 1994. </year>
Reference-contexts: As described above, AQUA has a large number of query operators which have been chosen for their usefulness and succinctness; however they can all be expressed in terms of a smaller subset of primitive operators. The primitive tree query operators are apply and split <ref> [30] </ref>. 5 More Tree Queries In order to demonstrate the use and power of the algebra, we consider a slightly more complex example. Consider a parse tree T of a database query. <p> Other operators like all anc (lp; f)(L), all desc (lp; f)(L), and split (lp; f)(L) are also similar to their corresponding tree operators except for their input and return types (which are lists). Formal definitions of these operators are given in <ref> [30] </ref>. To illustrate the behavior of these operators let us consider a very simple example of a music database. The database consists of a large number of songs, where each song is represented as a list consisting of nodes that represent a note. <p> All desc and split would work similarly. The primitive query operator for lists is split and all other query operators can be expressed in terms of it <ref> [30] </ref>. 7 Related Work In this section we discuss related work in the area of algebra and data model support for lists and trees, followed by a discussion of work in the area of predicate languages for these types. 7.1 Ordered Types in Other Data Models Much of the previous work
Reference: [31] <author> B. Subramanian, T. W. Leung, S. L. Vandenberg, and S. B. Zdonik, </author> <title> "Optimization of List and Tree Queries in AQUA," </title> <institution> Brown Univ., Dept. of CS, </institution> <type> Tech. Report, </type> <address> Providence, RI 02912-1910, </address> <year> 1994. </year>
Reference-contexts: Query algebras should be designed to facilitate optimizations by providing opportunities for algebraic rewrites. Queries in our algebra can be rewritten by decomposing the predicates into smaller pieces. The resulting sub-pieces are frequently able to make good use of indexes. In another paper <ref> [31] </ref> we propose a framework for optimizing list and tree queries, and provide some guidelines and rules that can be used for query rewrites. <p> Regular expressions are familiar, powerful, and well suited to a number of application domains. We briefly demonstrated how algebraic decomposition techniques can be used to optimize queries on lists and trees. A companion paper <ref> [31] </ref> treats the problem of optimization in more detail. There we present opti To appear in Proc. 11th Intl. Conf. on Data Engg., 1995 mization rules and access methods for ordered data types.
Reference: [32] <author> B. Subramanian, S. B. Zdonik, T. W. Leung, and S. L. Van-denberg, </author> <title> "Ordered Types in the AQUA Data Model," </title> <booktitle> Proc. DBPL (1993), </booktitle> <pages> 115-135. </pages>
Reference-contexts: This universe includes lists, trees, arrays, and graphs as well as the more conventional sets and multisets. Query optimization strategies would apply more uniformly across all of these types. Moreover, queries on arbitrary compositions of these bulk types (e.g., set [tree]) could be handled more uniformly. In <ref> [32] </ref>, we introduced an object-oriented model and a query algebra (called AQUA) for sets and multi-sets. In this paper, we extend the AQUA query algebra by introducing operators and pattern matching primitives specific to lists and trees.
Reference: [33] <author> J. W. Thatcher and J. B. Wright, </author> <title> "Generalized Finite Automata Theory with an Application to a Decision Problem of Second-Order Logic," </title> <booktitle> Mathematical Systems Theory 2 (1968), </booktitle> <pages> 57-81. </pages>
Reference: [34] <author> S. L. Vandenberg and D. J. DeWitt, </author> <title> "Algebraic Support for Complex Objects with Arrays, Identity, and Inheritance," </title> <booktitle> Proc. SIGMOD (1991), </booktitle> <pages> 158-167. </pages>
Reference-contexts: However, they do not mention how these operations can be extended to trees or specify how these operations fit into a query optimization scheme. The EXTRA/EXCESS system <ref> [34] </ref> contains an array type constructor and various operations on arrays. The elements of an array are accessed using their array indices. However, the system provides no support for lists (as opposed to arrays), trees or pattern-matching predicates.
Reference: [35] <author> T-L. Wang and D. Shasha, </author> <title> "Query Processing for Distance Metrics," </title> <booktitle> Proc. VLDB (1990), </booktitle> <pages> 602-613. </pages>
Reference: [36] <author> K. Zhang, D. Shasha, and J. T. L. Wang, </author> <title> "Approximate Tree Matching in the Presence of Variable Length Don't Cares," </title> <editor> J. </editor> <booktitle> of Algorithms 15 (1993). </booktitle>
References-found: 36

