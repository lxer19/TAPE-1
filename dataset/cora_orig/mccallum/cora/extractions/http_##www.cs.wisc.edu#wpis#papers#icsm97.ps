URL: http://www.cs.wisc.edu/wpis/papers/icsm97.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Email: fsiff, repsg@cs.wisc.edu  
Title: Identifying Modules Via Concept Analysis  
Author: Michael Siff and Thomas Reps 
Address: 1210 West Dayton Street Madison, WI 53706  
Affiliation: University of Wisconsin-Madison  
Abstract: We describe a general technique for identifying modules in legacy code. The method is based on concept analysis | a branch of lattice theory that can be used to identify similarities among a set of objects based on their attributes. We discuss how concept analysis can identify potential modules using both "positive" and "negative" information. We present an algorithmic framework to construct a lattice of concepts from a program, where each concept represents a potential module. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. L. Achee and Doris L. Carver. </author> <title> A greedy approach to object identification in imperative code. </title> <booktitle> In Third Workshop on Program Comprehension, </booktitle> <pages> pages 4-11, </pages> <year> 1994. </year>
Reference-contexts: The additional discriminatory power of the concept-analysis approach is due to the fact that it is able to exploit both positive and negative information. There has been a certain amount of work involving the use of cluster analysis to identify potential modules (e.g., <ref> [8, 1, 9, 2] </ref>). This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions. We are currently investigating the link between concept analysis and cluster analysis. Concept analysis has been applied to many kinds of problems.
Reference: [2] <author> G. Canfora, A. Cimitile, and M. Munro. </author> <title> An improved algorithm for identifying objects in code. </title> <journal> Software|Practice and Experience, </journal> <volume> 26(1) </volume> <pages> 25-48, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Given that some user interaction will be required, the concept-analysis approach offers certain advantages over other previously proposed techniques (e.g., <ref> [11, 5, 13, 12, 2] </ref>), namely, the ability to "stay within the system" (as opposed to applying ad hoc methods) when the user judges that the modularization that the system suggests is unsatisfactory. <p> The reader is referred to <ref> [2, pp. 27-32] </ref> for an extensive discussion of the literature on the modularization problem. <p> It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of the present paper. Canfora et al. discuss two types of links that cause undesirable clustering of functions <ref> [2] </ref>. The first type, "coincidental links", caused by routines that implement more than one function, can be overcome by program slicing [19, 7]. The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. <p> The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types. The work described in <ref> [11, 5, 12, 21, 2] </ref> will all stumble on examples that exhibit spurious links. In our approach, an analogous kind of spurious link arises due to functions that access internal fields of more than one struct. <p> The additional discriminatory power of the concept-analysis approach is due to the fact that it is able to exploit both positive and negative information. There has been a certain amount of work involving the use of cluster analysis to identify potential modules (e.g., <ref> [8, 1, 9, 2] </ref>). This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions. We are currently investigating the link between concept analysis and cluster analysis. Concept analysis has been applied to many kinds of problems.
Reference: [3] <author> G. Canfora, A. Cimitile, M. Tortorella, and M. Munro. </author> <title> Experiments in identifying reusable abstract data types in program code. </title> <booktitle> In Second Workshop on Program Comprehension, </booktitle> <pages> pages 36-45, </pages> <year> 1993. </year>
Reference-contexts: The resulting information can then be supplied to a suitable transformation tool that maps C code to C++ code, as in the aforementioned example. Although other modularization algorithms are able to identify the same decomposition <ref> [3, 21] </ref>, they are unable to handle a variant of this example in which stack and queue are more tightly intertwined (see Section 3.2). In Section 3.2, we show that concept analysis is able to group the code from the latter example into separate queue and stack modules. <p> It is relatively straightforward to separate the code shown in Figure 1a into two modules, and techniques such as those described in <ref> [3, 21] </ref> will also create the same grouping. We now show that concept analysis offers the possibility to go beyond previously defined methods: It offers the ability to tease apart code that is, in some sense, more "tangled". <p> As explained above, the concept-analysis approach can naturally generate a variety of possible decompositions (i.e., different collections of concepts that partition the set of objects). The concept-analysis approach is more general than that of Canfora et al. <ref> [3] </ref>, which identifies abstract data types by analyzing a graph that links functions to their argument types and return types. <p> By adding attributes that indicate whether fields of compound data types are used in a function, as is done in the example used in this paper, concept-analysis becomes a more powerful tool for identifying potential modules than the technique described in <ref> [3] </ref>. The work described in [4] and [5] expands on the abstract-data-type identification technique described in [3]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. <p> of compound data types are used in a function, as is done in the example used in this paper, concept-analysis becomes a more powerful tool for identifying potential modules than the technique described in <ref> [3] </ref>. The work described in [4] and [5] expands on the abstract-data-type identification technique described in [3]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of the present paper. Canfora et al. discuss two types of links that cause undesirable clustering of functions [2].
Reference: [4] <author> G. Canfora, A. De Lucia, G. A. Di Lucca, and A. R. Fasolino. </author> <title> Recovering the architectural design for software comprehension. </title> <booktitle> In Third Workshop on Program Comprehension, </booktitle> <pages> pages 30-38, </pages> <year> 1994. </year>
Reference-contexts: By adding attributes that indicate whether fields of compound data types are used in a function, as is done in the example used in this paper, concept-analysis becomes a more powerful tool for identifying potential modules than the technique described in [3]. The work described in <ref> [4] </ref> and [5] expands on the abstract-data-type identification technique described in [3]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of the present paper. <p> The work described in <ref> [4] </ref> and [5] expands on the abstract-data-type identification technique described in [3]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of the present paper. Canfora et al. discuss two types of links that cause undesirable clustering of functions [2]. The first type, "coincidental links", caused by routines that implement more than one function, can be overcome by program slicing [19, 7].
Reference: [5] <author> A. Cimitile, M. Tortorella, and M. Munro. </author> <title> Program comprehension through the identification of abstract data types. </title> <booktitle> In Third Workshop on Program Comprehension, </booktitle> <pages> pages 12-19, </pages> <year> 1994. </year>
Reference-contexts: Given that some user interaction will be required, the concept-analysis approach offers certain advantages over other previously proposed techniques (e.g., <ref> [11, 5, 13, 12, 2] </ref>), namely, the ability to "stay within the system" (as opposed to applying ad hoc methods) when the user judges that the modularization that the system suggests is unsatisfactory. <p> By adding attributes that indicate whether fields of compound data types are used in a function, as is done in the example used in this paper, concept-analysis becomes a more powerful tool for identifying potential modules than the technique described in [3]. The work described in [4] and <ref> [5] </ref> expands on the abstract-data-type identification technique described in [3]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of the present paper. <p> The work described in [4] and <ref> [5] </ref> expands on the abstract-data-type identification technique described in [3]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [4] and [5] with the concept-analysis approach of the present paper. Canfora et al. discuss two types of links that cause undesirable clustering of functions [2]. The first type, "coincidental links", caused by routines that implement more than one function, can be overcome by program slicing [19, 7]. <p> The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types. The work described in <ref> [11, 5, 12, 21, 2] </ref> will all stumble on examples that exhibit spurious links. In our approach, an analogous kind of spurious link arises due to functions that access internal fields of more than one struct.
Reference: [6] <author> R. Godin, R. Missaoui, and H. Alaoui. </author> <title> Incremental concept formation algorithms based on galois (concept) lattices. </title> <journal> Computational Intelligence, </journal> <volume> 11(2) </volume> <pages> 246-267, </pages> <year> 1995. </year>
Reference-contexts: This computation corresponds to the fact that c 1 t c 2 = c 5 in the lattice shown in Figure 2. There are several algorithms for computing the concept lattice for a given context <ref> [6, 18] </ref>. We describe a simple bottom-up algorithm here. An important fact about concepts and contexts used in the algorithm is that, given a set of objects X, the smallest concept with extent containing X is (t ((X)); (X)).
Reference: [7] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: This reveals that the type of f 's first argument is distinct from the type of 1 Some legacy code is monolithic | multiple tasks are contained within one function. In such cases, it may be preferable to have objects correspond to slices <ref> [19, 7] </ref> rather than functions. top (f 0 ; 1 ; 2 ; 3 ; 4 ; 5 ; 6 ; 7 g; ;) universal concept c 7 (f 0 ; 2 ; 3 ; 4 ; 5 ; 6 g; fff 4 g) c 5 (f 1 ; 3 ; <p> Canfora et al. discuss two types of links that cause undesirable clustering of functions [2]. The first type, "coincidental links", caused by routines that implement more than one function, can be overcome by program slicing <ref> [19, 7] </ref>. The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types.
Reference: [8] <author> David H. Hutchens and Victor R. Basili. </author> <title> System structure analysis: Clustering with data bindings. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(8):749-757, </volume> <month> August </month> <year> 1985. </year>
Reference-contexts: The additional discriminatory power of the concept-analysis approach is due to the fact that it is able to exploit both positive and negative information. There has been a certain amount of work involving the use of cluster analysis to identify potential modules (e.g., <ref> [8, 1, 9, 2] </ref>). This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions. We are currently investigating the link between concept analysis and cluster analysis. Concept analysis has been applied to many kinds of problems.
Reference: [9] <author> Thomas Kunz. </author> <title> Evaluating process clusters to support automatic program understanding. </title> <booktitle> In Fourth Workshop on Program Comprehension, </booktitle> <pages> pages 198-207, </pages> <year> 1996. </year>
Reference-contexts: The additional discriminatory power of the concept-analysis approach is due to the fact that it is able to exploit both positive and negative information. There has been a certain amount of work involving the use of cluster analysis to identify potential modules (e.g., <ref> [8, 1, 9, 2] </ref>). This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions. We are currently investigating the link between concept analysis and cluster analysis. Concept analysis has been applied to many kinds of problems.
Reference: [10] <author> Christian Lindig and Gregor Snelting. </author> <title> Assessing modular structure of legacy code based on mathematical concept analysis. </title> <booktitle> In Proceedings of the 19th International Conference on Software Engineering, </booktitle> <pages> pages 349-359, </pages> <year> 1997. </year>
Reference-contexts: Other possibilities for attributes include the following: * Variable-usage information: Related functions can sometimes be identified by their use of common global variables. An attribute capturing this information might be of the form "uses global variable x" <ref> [10, 15] </ref>. * Dataflow and slicing information can be useful in identifying modules. <p> Concept analysis has been applied to many kinds of problems. Concept analysis was first applied to software engineering in the NORA/RECS tool, where it was used to identify conflicts in software-configuration information [18]. Contemporaneously with our own work, Lindig and Snelting <ref> [10] </ref> and Sahraoui et al. [15] independently explored the idea of applying concept analysis to the modularization problem. In both of these studies, the context relations used for concept analysis relate each function of the program to the global variables accessed by the function.
Reference: [11] <author> Sying-Syang Liu and Norman Wilde. </author> <title> Identifying objects in a conventional procedural language: An example of data design recovery. </title> <booktitle> In Conference on Software Maintenance, </booktitle> <pages> pages 266-271. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> November </month> <year> 1990. </year>
Reference-contexts: Given that some user interaction will be required, the concept-analysis approach offers certain advantages over other previously proposed techniques (e.g., <ref> [11, 5, 13, 12, 2] </ref>), namely, the ability to "stay within the system" (as opposed to applying ad hoc methods) when the user judges that the modularization that the system suggests is unsatisfactory. <p> Liu and Wilde <ref> [11] </ref> make use of a table that is very much like the object-attribute relation of a context. However, whereas our work uses concept analysis to analyze such tables, Liu and Wilde propose a less powerful analysis. <p> The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types. The work described in <ref> [11, 5, 12, 21, 2] </ref> will all stumble on examples that exhibit spurious links. In our approach, an analogous kind of spurious link arises due to functions that access internal fields of more than one struct.
Reference: [12] <author> Panos E. Livadas and Theordore Johnson. </author> <title> A new approach to finding objects in programs. Software Maintenance: </title> <journal> Research and Practice, </journal> <volume> 6 </volume> <pages> 249-260, </pages> <year> 1994. </year>
Reference-contexts: Given that some user interaction will be required, the concept-analysis approach offers certain advantages over other previously proposed techniques (e.g., <ref> [11, 5, 13, 12, 2] </ref>), namely, the ability to "stay within the system" (as opposed to applying ad hoc methods) when the user judges that the modularization that the system suggests is unsatisfactory. <p> The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types. The work described in <ref> [11, 5, 12, 21, 2] </ref> will all stumble on examples that exhibit spurious links. In our approach, an analogous kind of spurious link arises due to functions that access internal fields of more than one struct.
Reference: [13] <author> Philip Newcomb. </author> <title> Reengineering procedural into object-oriented systems. </title> <booktitle> In Second Working Conference on Reverse Engineering, </booktitle> <pages> pages 237-249, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Given that some user interaction will be required, the concept-analysis approach offers certain advantages over other previously proposed techniques (e.g., <ref> [11, 5, 13, 12, 2] </ref>), namely, the ability to "stay within the system" (as opposed to applying ad hoc methods) when the user judges that the modularization that the system suggests is unsatisfactory.
Reference: [14] <author> Robert O'Callahan and Daniel Jackson. </author> <title> Practical program understanding with type inference. </title> <type> Technical Report CMU-CS-96-130, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Attributes capturing this information might be of the form "may use a value that flows from statement s" or "is part of the slice with respect to statement s". * Information obtained from type inferencing: Type inference can be used to uncover distinctions between seemingly identical types <ref> [16, 14] </ref>. For example, if f is a function declared to be of type int fi int ! bool, type inference might discover that f 's most general type is of the form ff fi fi ! bool.
Reference: [15] <author> Houari A. Sahraoui, Walcelio Melo, Hakim Lounis, and Fran~cois Dumont. </author> <title> Applying concept formation methods to object identification in procedural code. </title> <type> Technical Report CRIM-97/05-77, </type> <institution> CRIM, </institution> <year> 1997. </year>
Reference-contexts: Other possibilities for attributes include the following: * Variable-usage information: Related functions can sometimes be identified by their use of common global variables. An attribute capturing this information might be of the form "uses global variable x" <ref> [10, 15] </ref>. * Dataflow and slicing information can be useful in identifying modules. <p> Concept analysis has been applied to many kinds of problems. Concept analysis was first applied to software engineering in the NORA/RECS tool, where it was used to identify conflicts in software-configuration information [18]. Contemporaneously with our own work, Lindig and Snelting [10] and Sahraoui et al. <ref> [15] </ref> independently explored the idea of applying concept analysis to the modularization problem. In both of these studies, the context relations used for concept analysis relate each function of the program to the global variables accessed by the function.
Reference: [16] <author> Michael Siff and Thomas Reps. </author> <title> Program generalization for software reuse: From C to C++. </title> <booktitle> In Fourth ACM SIG-SOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 135-146, </pages> <address> San Francisco, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Attributes capturing this information might be of the form "may use a value that flows from statement s" or "is part of the slice with respect to statement s". * Information obtained from type inferencing: Type inference can be used to uncover distinctions between seemingly identical types <ref> [16, 14] </ref>. For example, if f is a function declared to be of type int fi int ! bool, type inference might discover that f 's most general type is of the form ff fi fi ! bool.
Reference: [17] <author> Michael Siff and Thomas Reps. </author> <title> Identifying modules via concept analysis. </title> <type> Technical Report CS-TR-97-1337, </type> <institution> University of Wisconsin-Madison, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: This can be achieved by augmenting a context with negative information (similar to what we did in Section 3.2). Details of how this can be done, along with an algorithm to find all the partitions of a concept lattice, can be found in <ref> [17] </ref>. 5 Implementation and Results We have implemented a prototype tool that employs concept analysis to propose modularizations of C programs. It is written in Standard ML of New Jersey (version 109.27) in conjunction with the SmlTK interface to Tcl/Tk. It runs on a Sun Sparc under Solaris 2.5.1.
Reference: [18] <author> Gregor Snelting. </author> <title> Reengineering of configurations based on mathematical concept analysis. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(2) </volume> <pages> 146-189, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: This computation corresponds to the fact that c 1 t c 2 = c 5 in the lattice shown in Figure 2. There are several algorithms for computing the concept lattice for a given context <ref> [6, 18] </ref>. We describe a simple bottom-up algorithm here. An important fact about concepts and contexts used in the algorithm is that, given a set of objects X, the smallest concept with extent containing X is (t ((X)); (X)). <p> We are currently investigating the link between concept analysis and cluster analysis. Concept analysis has been applied to many kinds of problems. Concept analysis was first applied to software engineering in the NORA/RECS tool, where it was used to identify conflicts in software-configuration information <ref> [18] </ref>. Contemporaneously with our own work, Lindig and Snelting [10] and Sahraoui et al. [15] independently explored the idea of applying concept analysis to the modularization problem.
Reference: [19] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: This reveals that the type of f 's first argument is distinct from the type of 1 Some legacy code is monolithic | multiple tasks are contained within one function. In such cases, it may be preferable to have objects correspond to slices <ref> [19, 7] </ref> rather than functions. top (f 0 ; 1 ; 2 ; 3 ; 4 ; 5 ; 6 ; 7 g; ;) universal concept c 7 (f 0 ; 2 ; 3 ; 4 ; 5 ; 6 g; fff 4 g) c 5 (f 1 ; 3 ; <p> Canfora et al. discuss two types of links that cause undesirable clustering of functions [2]. The first type, "coincidental links", caused by routines that implement more than one function, can be overcome by program slicing <ref> [19, 7] </ref>. The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types.
Reference: [20] <author> Rudolf Wille. </author> <title> Restructuring lattice theory: An approach based on hierarchies of concepts. </title> <editor> In Ivan Rival, editor, </editor> <booktitle> Ordered Sets, </booktitle> <pages> pages 445-470. </pages> <institution> NATO Advanced Study Institute, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: Section 4 defines the notion of a concept partition. Section 5 discusses the implementation. Section 6 concerns related work. 2 A Concept Analysis Primer Concept analysis provides a way to identify sensible groupings of objects that have common attributes <ref> [20] </ref>. To illustrate concept analysis, we consider the example of a crude classification of a group of mammals: cats, chimpanzees, dogs, dolphins, humans, and whales. Suppose we consider five attributes: four-legged, hair-covered, intelligent, marine, and thumbed. Table 1 shows which animals are considered to have which attributes. <p> For instance, (fdolphins, whalesg, fintelligent, marineg) is a sub-concept of (fchimpanzees, dolphins, humans, whalesg, fintelligentg). The subconcept relation forms a complete partial order (the concept lattice) over the set of concepts. The concept lattice for the mammal example is shown in Figure 2. The fundamental theorem for concept lattices <ref> [20] </ref> relates subconcepts and superconcepts as follows: G (X i ; Y i ) = t " Y i ; i2I ! The significance of the theorem is that the least common superconcept of a set of concepts can be computed by intersecting their intents, and by finding the common objects
Reference: [21] <author> Alexander Yeh, David R. Harris, and Howard B. Reubenstein. </author> <title> Recovering abstract data types and object instances from a conventional procedural language. </title> <booktitle> In Second Working Conference on Reverse Engineering, </booktitle> <pages> pages 227-236, </pages> <year> 1995. </year>
Reference-contexts: The resulting information can then be supplied to a suitable transformation tool that maps C code to C++ code, as in the aforementioned example. Although other modularization algorithms are able to identify the same decomposition <ref> [3, 21] </ref>, they are unable to handle a variant of this example in which stack and queue are more tightly intertwined (see Section 3.2). In Section 3.2, we show that concept analysis is able to group the code from the latter example into separate queue and stack modules. <p> It is relatively straightforward to separate the code shown in Figure 1a into two modules, and techniques such as those described in <ref> [3, 21] </ref> will also create the same grouping. We now show that concept analysis offers the possibility to go beyond previously defined methods: It offers the ability to tease apart code that is, in some sense, more "tangled". <p> The second type, "spurious links", is caused by functions that access supporting data structures of more than one object type. In most of the approaches mentioned above, spurious links arise from a function that accesses several global variables of different types. The work described in <ref> [11, 5, 12, 21, 2] </ref> will all stumble on examples that exhibit spurious links. In our approach, an analogous kind of spurious link arises due to functions that access internal fields of more than one struct.
References-found: 21

