URL: http://www.cs.cornell.edu/Info/People/mhr/papers/mincut.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/mhr/project.html
Root-URL: 
Title: Approximating Minimum Cuts under Insertions  
Author: Monika Rauch Henzinger 
Keyword: vertex cut with amortized insertion time O(n(log  
Address: Ithaca, NY 14853, USA  
Affiliation: Department of Computer Science, Cornell University,  
Abstract: This paper presents insertions-only algorithms for maintaining the exact and/or approximate size of the minimum edge cut and the minimum vertex cut of a graph. The algorithms output the approximate or exact size k in time O(1) and a cut of size k in time linear in its size. For the minimum edge cut problem and for any 0 &lt; * 1, the amortized time per insertion is O(1=* 2 ) for a (2 + *)-approximation, O((log )((log n)=*) 2 ) for a (1 + *)-approximation, and O( log n) for the exact size , where n is the number of nodes in the graph and is the size of the minimum cut. The (2 + *)-approximation algorithm and the exact algorithm are deterministic, the (1 + *)-approximation algorithm is randomized. The algorithms are optimal in the sense that the time needed for m insertions matches the time needed by the best static algorithm on a m-edge graph. We also present a static 2-approximation algorithm for the size of the minimum vertex cut in a graph, which takes time O(n 2 min( This is a factor of faster than the best algorithm for computing the exact size, which takes time O( 2 n 2 + 3 n 1:5 ). We give an insertions-only algorithm for maintaining a (2 + *)-approximation of the minimum p
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. Cheriyan, M. Y. Kao, and R. Thurimella, </author> <title> "Scan-first search and sparse certificates|an improved parallel algorithm for k-vertex connectivity", </title> <journal> SIAM Journal on Computing, </journal> <volume> 22, </volume> <year> 1993, </year> <pages> 157-174. </pages>
Reference-contexts: It takes time O (n 2 min ( p This is a speed-up of a factor of at least over the fastest exact algorithm for computing , which takes time O ( 2 n 2 + 3 n 1:5 ) <ref> [1, 10, 18] </ref>. Using this 2-approximation algorithm as subroutine gives an incremental algorithm with total time O (m 0 + m 1 n + n 2 (log )=*). If the initial graph is empty, the amortized time per insertion is O (n (log )=*). <p> It takes time O (n 2 min ( p best algorithm to compute the exact solution takes time O ( 2 n 2 + 3 n 3=2 )([10] with <ref> [1, 18] </ref>). Our algorithm applies only to graphs, not to multigraphs and uses ideas from [17].
Reference: 2. <author> E. A. Dinitz, A. V. Karzanov, </author> <title> and M.V. Lomonosov, "On the structure of the system of minimal edge cuts in a graph", Studies in Discrete Optimization, </title> <booktitle> 1990, </booktitle> <pages> 290-306. </pages>
Reference-contexts: If an insertion increments the size of one of these cuts, it is no longer minimum. Thus, the current solution is correct as long as there still exists a minimum cut whose size has not been increased. To store all minimum edge cuts we use the cactus tree representation <ref> [2] </ref>.
Reference: 3. <author> Ye. Dinitz, </author> <title> "Maintaining the 4-edge-connected components of a graph on-line", </title> <booktitle> Proc. 2nd Israel Symp. on Theory of Computing and Systems (ISTCS'93), </booktitle> <publisher> IEEE Computing Society press, </publisher> <year> 1993, </year> <pages> 88-97. </pages>
Reference-contexts: This technique was introduced by Karger [15] in his static algorithm, which needs time O (m + n ((log n)=*) 3 ) to compute a (1 + *)- approximation of . Related results: (1) For any fixed k, Dinitz <ref> [3] </ref> gives an algorithm that supports Same-k-Component? queries and edge insertions in a (k-1)-edge-connected graph. <p> If is even, two simple cycles of G c have at most one common node, every edge that does not belong to a cycle has weight , and every edge that belongs to a cycle has weight =2. As observed by Dinitz <ref> [3] </ref>, given a cactus-tree the data structure of [11, 16] can maintain the cactus tree for a fixed value of such that the total time for u insertions is O ((u + n)ff (u + n; n)).
Reference: 4. <author> Ye. Dinitz, Z. Nutov, </author> <title> "A 2-level cactus model for the system of minimum and minimum+1 edge-cuts in a graph and its incremental maintenance", </title> <note> to appear in Proc. 27nd Symp. on Theory of Computing, </note> <year> 1995. </year>
Reference-contexts: Our algorithms achieve exponential improvements. He also gives an insertions and deletions algorithm that maintains a 1 + 2=*-approximation algorithm in ~ O (n 1=2+* ) time per edge insertions and deletions. (4) Recently, Dinitz and Nutov <ref> [4] </ref> gave an algorithm that maintains all cuts of size or + 1.
Reference: 5. <author> D. Eppstein, Z. Galil, G. F. Italiano, A. Nissenzweig, </author> <title> "Sparsification ATechnique for Speeding up Dynamic Graph Algorithms" Proc. </title> <booktitle> 33rd Symp. on Foundations of Computer Science, </booktitle> <year> 1992, </year> <pages> 60-69. </pages>
Reference-contexts: It takes time O (m 0 + k 2 n log (n=k) + (q + n)ff (q; n)), where q is the total number of operations. (2) For any fixed k, Eppstein et. al <ref> [5] </ref> give a insertions and deletions algorithm that tests if the whole graph is k-edge-connected in O (1) time.
Reference: 6. <author> S. </author> <title> Even, "An algorithm for determining whether the connectivity of a graph is at least k" SIAM Journal on Computing, </title> <type> 4, </type> <year> 1975, </year> <pages> 393-396. </pages>
Reference-contexts: They are extensions of lemmata in <ref> [6] </ref>. We use (G; a) to denote the set of neighbors of a in G. The following fact is used repeatedly.
Reference: 7. <author> S. Even and R. E. Tarjan, </author> <title> "Network flow and testing graph connectivity", </title> <journal> SIAM Journal on Computing, </journal> <volume> 4, </volume> <year> 1975, </year> <pages> 507-518. </pages>
Reference-contexts: It takes time O (n 2 min ( p best algorithm to compute the exact solution takes time O ( 2 n 2 + 3 n 3=2 )([10] with [1, 18]). Our algorithm applies only to graphs, not to multigraphs and uses ideas from [17]. Even and Tarjan <ref> [7] </ref> give an algorithm to compute the minimum vertex cut (a; b) between the nodes a and b in time O (min (m p n; m)), which we call the pair algorithm (PA). The exact minimum vertex cut algorithm [10] makes O (k 2 + n) calls to PA.
Reference: 8. <author> H. N. Gabow, </author> <title> "A matroid approach to finding edge connectivity and packing ar-borescences" Proc. </title> <booktitle> 23rd Symp. on Theory of Computing, </booktitle> <year> 1991, </year> <pages> 112-122. </pages>
Reference-contexts: It is an incremental version of Matula's static (2 + *)-approximation algorithm [17], which takes time O (m=*). If the initial graph is empty, our amortized time per operation is O (1=* 2 ). The second algorithm is an incremental version of Gabow's (exact) minimum edge cut algorithm <ref> [8] </ref>, which computes the size of the minimum edge cut in time O (m + 2 n log (n 2 =(m + 1))). Our incremental algorithm takes time O (m 0 + m 1 ff (n; n) + 2 n log (n 2 =(m 0 + 1))).
Reference: 9. <author> H. N. Gabow, </author> <title> "Applications of a poset representation to edge connectivity and graph rigidity" Proc. </title> <booktitle> 32nd Symp. on Foundations of Computer Science, </booktitle> <year> 1991, </year> <pages> 812-821. </pages>
Reference-contexts: Determining if there exists a minimum cut whose size has not been increased takes constant time. To quickly compute the cactus tree representation of a multigraph we use an algorithm by Gabow <ref> [9] </ref>. The algorithm computes first a subgraph of G, called a complete -intersection or I (), with at most n edges, and uses the complete -intersection to compute the cactus tree.
Reference: 10. <author> Z. Galil, </author> <title> "Finding the vertex connectivity of graphs", </title> <journal> SIAM Journal on Computing, </journal> <year> 1980, </year> <pages> 197-199. </pages>
Reference-contexts: It takes time O (n 2 min ( p This is a speed-up of a factor of at least over the fastest exact algorithm for computing , which takes time O ( 2 n 2 + 3 n 1:5 ) <ref> [1, 10, 18] </ref>. Using this 2-approximation algorithm as subroutine gives an incremental algorithm with total time O (m 0 + m 1 n + n 2 (log )=*). If the initial graph is empty, the amortized time per insertion is O (n (log )=*). <p> Even and Tarjan [7] give an algorithm to compute the minimum vertex cut (a; b) between the nodes a and b in time O (min (m p n; m)), which we call the pair algorithm (PA). The exact minimum vertex cut algorithm <ref> [10] </ref> makes O (k 2 + n) calls to PA. Let ffi 0 be ffi=2. We reduce the number of calls to dn=ffi 0 e using the following two observations: 1. The last ffi 0 nodes in the mcs-order computed by DA are pairwise ffi 0 -connected. 2.
Reference: 11. <author> Z. Galil and G. P. </author> <title> Italiano, "Maintaining the 3-edge-connected components of a graph on-line", </title> <journal> SIAM Journal on Computing, </journal> <year> 1993, </year> <pages> 11-28. </pages>
Reference-contexts: If is a constant, our running time is close to the running time of the best "special purpose" algorithms: Determining if two nodes are connected, 2-edge-connected, or 3-edge-connected takes amortized time O (ff (m; n)) per insertion or query <ref> [20, 11, 16] </ref>. Finally we combine the previous two (deterministic) algorithms with random sampling to achieve an incremental Monte Carlo algorithm that maintains a (1 + *)-approximation of the minimum edge cut with high probability. <p> As observed by Dinitz [3], given a cactus-tree the data structure of <ref> [11, 16] </ref> can maintain the cactus tree for a fixed value of such that the total time for u insertions is O ((u + n)ff (u + n; n)). Determining if there exists a minimum cut whose size has not been increased takes constant time.
Reference: 12. <author> A. Ya. Gordon, </author> <title> "One algorithm for the solution of the minimax assignment problem", Studies in Discrete Optimization, </title> <editor> A. A. Fridman (Ed.), </editor> <publisher> Nauka, </publisher> <address> Moscow, </address> <year> 1976, </year> <note> 327-333 (in Russian). </note>
Reference-contexts: For each b j we incremently maintain the maximum flow from a to b j by augmenting the breadth-first search tree. Thus, for any j the total time spent for incrementing the maximum flow from a to b j by 1 is O (m + n) (see also <ref> [12] </ref>). The algorithm recomputes every new solution from scratch. We denote by ffi the minimum degree in the current graph, and by d the minimum degree in the graph during the last recomputation.
Reference: 13. <author> F. Harary, </author> <title> "Graph Theory", </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1969. </year>
Reference-contexts: An edge cut of G is a set of edges in G whose removal disconnects G. A minimum edge cut is a cut of size (G). By Menger's theorem <ref> [13] </ref>, a graph is k-edge connected iff every two distinct nodes in G are connected by at least k edge disjoint paths. ? Maiden Name: Monika H. Rauch. This research was supported by an NSF CAREER Award. Let G = (V; E) be an undirected, unweighted graph. <p> A vertex cut of G is a set of vertices in G such that the removal of the vertices and their incident edges disconnects G. A minimum vertex cut is a cut of size (G). By Menger's theorem <ref> [13] </ref>, a graph is k-vertex connected iff every two distinct nodes in G are connected by at least k vertex disjoint paths. Note that k-vertex connectivity implies k-edge connectivity, but not vice versa. <p> A contraction reduces the number of nodes in G, but does not reduce the size of the minimum edge cut. We contract a forest F if we contract all edges of G that are in F . If a graph is k-edge connected, it contains (kn) edges: Lemma 1. <ref> [13] </ref> If a n-node (multi)graph is k-edge connected, then it contains at least kn=2 edges. 4 Incremental Algorithms for the Minimum Edge Cut 4.1 An Incremental (2 + *)-Approximation Using the generic algorithm of Section 2 we create an incremental algorithm that maintains a (2 + *)-approximation of the minimum cut.
Reference: 14. <author> D. Karger, </author> <title> "Using randomized sparsification to approximate minimum cuts" Proc. </title> <booktitle> 5th Symp. on Discrete Algorithms, </booktitle> <year> 1994, </year> <pages> 424-432. </pages>
Reference-contexts: The times per edge insertion or deletion is O (k 2 n log (n=k)). (3) Karger <ref> [14] </ref> gives a randomized algorithm, which maintains a p 1 + 2=*-approximation of the minimum edge cut in expected time ~ O (n * ) per insertion. <p> Karger <ref> [14] </ref> pointed out that dynamically approximating connectivity can be reduced to dynamically maintaining exact connectivity in O (log n)-connected graph using randomized sparsification. <p> The following lemma shows that the resulting incremental algorithm maintains a (1 + *)-approximation of the minimum cut with high probability. Lemma 10. <ref> [14] </ref> Let G be any graph with minimum cut and let p = 2 (d + 2)(ln n)=(* 2 ) for any * 1. 1. With probability 1O (1=n d ) the size of the minimum cut in G (p) is fi ((log n)=* 2 ). 2.
Reference: 15. <author> D. Karger, </author> <title> "Random sampling in cut, flow, and network design problems", </title> <booktitle> Proc. 26rd Symp. on Theory of Computing, </booktitle> <year> 1994, </year> <pages> 648-657. </pages>
Reference-contexts: The total expected time for m 1 insertions is O ((m 0 + m 1 )(log )((log n)=*) 2 ). Thus, if the initial graph is empty, the amortized expected time per insertion is O ((log )(log n=*) 2 ). This technique was introduced by Karger <ref> [15] </ref> in his static algorithm, which needs time O (m + n ((log n)=*) 3 ) to compute a (1 + *)- approximation of . Related results: (1) For any fixed k, Dinitz [3] gives an algorithm that supports Same-k-Component? queries and edge insertions in a (k-1)-edge-connected graph.
Reference: 16. <author> H. La Poutre, </author> <title> "Maintenance of 2- and 3-connected components of graphs, Part II: 2- and 3-edge-connected components and 2-vertex-connected components", </title> <institution> Tech.Rep. RUU-CS-90-27, Utrecht University, </institution> <year> 1990. </year>
Reference-contexts: If is a constant, our running time is close to the running time of the best "special purpose" algorithms: Determining if two nodes are connected, 2-edge-connected, or 3-edge-connected takes amortized time O (ff (m; n)) per insertion or query <ref> [20, 11, 16] </ref>. Finally we combine the previous two (deterministic) algorithms with random sampling to achieve an incremental Monte Carlo algorithm that maintains a (1 + *)-approximation of the minimum edge cut with high probability. <p> As observed by Dinitz [3], given a cactus-tree the data structure of <ref> [11, 16] </ref> can maintain the cactus tree for a fixed value of such that the total time for u insertions is O ((u + n)ff (u + n; n)). Determining if there exists a minimum cut whose size has not been increased takes constant time.
Reference: 17. <author> D. W. Matula, </author> <title> "A linear time 2+* approximation algorithm for edge connectivity" Proc. </title> <booktitle> 4th Symp. on Discrete Algorithms, </booktitle> <year> 1993, </year> <pages> 500-504. </pages>
Reference-contexts: The first algorithm maintains a (2 + *)-approximation of in total time O ((m 0 + n)=* + m 1 =* 2 ) for any 1 * &gt; 0. It is an incremental version of Matula's static (2 + *)-approximation algorithm <ref> [17] </ref>, which takes time O (m=*). If the initial graph is empty, our amortized time per operation is O (1=* 2 ). <p> It takes time O (n 2 min ( p best algorithm to compute the exact solution takes time O ( 2 n 2 + 3 n 3=2 )([10] with [1, 18]). Our algorithm applies only to graphs, not to multigraphs and uses ideas from <ref> [17] </ref>. Even and Tarjan [7] give an algorithm to compute the minimum vertex cut (a; b) between the nodes a and b in time O (min (m p n; m)), which we call the pair algorithm (PA).
Reference: 18. <author> H. Nagamochi and T. Ibaraki, </author> <title> "Linear time algorithms for finding a sparse k-connected spanning subgraph of a k-connected graph", </title> <type> Algorithmica 7, </type> <year> 1992, </year> <pages> 583-596. </pages>
Reference-contexts: It takes time O (n 2 min ( p This is a speed-up of a factor of at least over the fastest exact algorithm for computing , which takes time O ( 2 n 2 + 3 n 1:5 ) <ref> [1, 10, 18] </ref>. Using this 2-approximation algorithm as subroutine gives an incremental algorithm with total time O (m 0 + m 1 n + n 2 (log )=*). If the initial graph is empty, the amortized time per insertion is O (n (log )=*). <p> If two nodes are connected in F i , they are i-edge connected. Nagamochi and Ibaraki <ref> [18] </ref> give a linear time algorithm (referred to as decomposition algorithm (DA)) that computes a special msfd, called DA-msfd, of order m in time O (m + n). A DA-msfd fulfills the following additional conditions [18]: If G is a graph then, (1) G is k-vertex connected iff F 1 [ <p> Nagamochi and Ibaraki <ref> [18] </ref> give a linear time algorithm (referred to as decomposition algorithm (DA)) that computes a special msfd, called DA-msfd, of order m in time O (m + n). A DA-msfd fulfills the following additional conditions [18]: If G is a graph then, (1) G is k-vertex connected iff F 1 [ : : : [ F ffi is k-vertex connected. <p> It takes time O (n 2 min ( p best algorithm to compute the exact solution takes time O ( 2 n 2 + 3 n 3=2 )([10] with <ref> [1, 18] </ref>). Our algorithm applies only to graphs, not to multigraphs and uses ideas from [17]. <p> O ((s; t)) per insertion. 6 Appendix We want to prove Lemma 15 and 16. We first present DA and show two properties of DA. Using a further lemma of <ref> [18] </ref>, we then prove Lemma 15. The proof of Lemma 16 follows. In DA, whenever a node is added to a forest F i , the edge is also given an direction. The Decomposition Algorithm [18] 1. <p> Using a further lemma of <ref> [18] </ref>, we then prove Lemma 15. The proof of Lemma 16 follows. In DA, whenever a node is added to a forest F i , the edge is also given an direction. The Decomposition Algorithm [18] 1. E 1 = E 2 = : : : = E m = ;, every node and every edge in G is unscanned. 2. for all v 2 V do r (v) = 0. 3. while there exists an unscanned node do 4. <p> After scanning the first such edge, r (x) is incremented to i + 1, but for each unscanned edge fx; yg, r (y) i. Thus, r (x) cannot be incremented again, i.e. x cannot become the root of another tree. In <ref> [18] </ref> the following properties of DA are proven: Lemma 23. 1. For a graph G = (V; E), let F 1 ; : : :; F m be a DA-msfd of G and let G 0 = (V; E 0 ) with E 0 = [ iffi F i . <p> Assume that j &lt; i and let s be the last node of S that is scanned by DA. Lemma 3.2 of <ref> [18] </ref> shows that at the time when s is scanned there is no path between u and v in any forest F l with l &gt; j.
Reference: 19. <author> D. D. Sleator, R. E. Tarjan, </author> <title> "A data structure for dynamic trees" J. </title> <journal> Comput. System Sci. </journal> <volume> 24, </volume> <year> 1983, </year> <pages> 362-381. </pages>
Reference: 20. <author> J. Westbrook and R. E. Tarjan, </author> <title> "Maintaining bridge-connected and biconnected components on-line", </title> <type> Algorithmica (7) 5/6, </type> <year> 1992, </year> <month> 433-464. </month> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: If is a constant, our running time is close to the running time of the best "special purpose" algorithms: Determining if two nodes are connected, 2-edge-connected, or 3-edge-connected takes amortized time O (ff (m; n)) per insertion or query <ref> [20, 11, 16] </ref>. Finally we combine the previous two (deterministic) algorithms with random sampling to achieve an incremental Monte Carlo algorithm that maintains a (1 + *)-approximation of the minimum edge cut with high probability.
References-found: 20

