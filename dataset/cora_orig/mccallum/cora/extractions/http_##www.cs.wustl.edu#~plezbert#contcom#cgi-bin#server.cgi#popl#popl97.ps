URL: http://www.cs.wustl.edu/~plezbert/contcom/cgi-bin/server.cgi/popl/popl97.ps
Refering-URL: http://www.cs.wustl.edu/~plezbert/contcom/
Root-URL: http://www.cs.wustl.edu
Title: Does "Just in Time" "Better Late than Never"?  
Author: Michael P. Plezbert and Ron K. Cytron 
Address: Box 1045  St. Louis, MO 63130 USA  
Affiliation: Washington University  Department of Computer Science  
Abstract: The World-Wide Web is emerging as a medium for distributing platform-independent, intermediate-form programs. Most Java vendors have recently announced plans to construct "just-in-time" systems, which translate the intermediate text into native code on demand. In this paper, we present experiments that show the benefits of just-in-time systems as compared with the traditional (compile prior to execution) systems. We introduce a new method|the continuous compiler| that can outperform just-in-time systems by overlapping compilation with program interpretation and native execution. Based on those results, we then present a smart just-in-time system that blends interpretation with native-code execution, thereby obtaining improved performance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ali-Reza Adl-Tabatabai, Geoff Langdale, Steven Lucco, and Robert Wahbe. </author> <title> Efficient and language-independent mobile programs. </title> <booktitle> Proceedings of the 1996 ACM SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 127-136, </pages> <year> 1996. </year>
Reference-contexts: These programs were written in C: there is as yet no set of large Java applications available for study; moreover, it is likely that Web-based systems will support languages such as C in the near future <ref> [1] </ref>. Specifically, our study involved 5 program executions of three applications as detailed below: 2 pico is a widely used text editor, similar to emacs but scaled down in scope. Our copy was obtained from the University of Washington and represents version 2.4 of pico. <p> Java is likely not to be the only language available for safe execution on the Web. Recent work <ref> [1] </ref> from CMU and Colusa (now Microsoft) is likely to lead to efficient and safe implementations of inherently unsafe languages such as C.
Reference: [2] <author> Joel Auslander, Matthai Philipose, Craig Chambers, Susan J. Eggers, and Brian N. Bershad. </author> <title> Fast, </title> <booktitle> effective dynamic compilation. </booktitle> <pages> pages 149-159, </pages> <year> 1996. </year>
Reference-contexts: Visual languages, for example, or any interactive development environment could benefit from such an approach. We anticipate that the ideas presented in this paper may prove useful in the area of run-time code generation <ref> [10, 2] </ref>, where the profitability of spending time to generate more optimal code must be assessed. Acknowledgements We are grateful to Jim Larus for making his EEL system available to us. We thank Noah Treuhaft for his work in Summer '95, using EEL to instrument the C programs we studied.
Reference: [3] <author> Symantec Corporation. </author> <title> Just-in-time compiler for windows 95/nt, </title> <booktitle> 1996. </booktitle> <address> http://cafe.symantec.com /cafe/fs jit.html. </address>
Reference-contexts: To remedy performance problems, vendors such as Borland [7], Sun [14], Symantec <ref> [3] </ref>, and others are implementing systems that transform interpreted Java VM code into native form "just-in-time": a class (compilation unit) is transmitted in Java VM form, but interpretation never takes place. Instead, the portable VM code is compiled to native code when first needed by the executing program. <p> point of any given compilation unit has no effect on the general strategies presented for either smart JIT compilation or continuous compilation. 6 Previous work The idea of just-in-time compilation is relatively new, though apparently nearly every Java vendor is eager to produce environments that include the just-in-time compilation approach <ref> [14, 3, 7] </ref>.
Reference: [4] <author> S. Feldman. </author> <title> Make A program for maintaining computer programs. </title> <journal> Software Practice and Experience, </journal> <volume> 9 </volume> <pages> 255-265, </pages> <year> 1979. </year>
Reference-contexts: The setup information for real programs was obtained using the make utility to generate file dependencies <ref> [4] </ref> and the ctags utility to determine which functions were contained in each source file. File sizes were obtained using wc after expansion by the preprocessor.
Reference: [5] <author> Alan R. Feuer. </author> <title> si|and interpreter for the C language. </title> <booktitle> Proceedings of the 1995 Usenix Summer Conference, 1985. </booktitle> <address> Portland, OR. </address>
Reference-contexts: For languages such as C, which have long been implemented primarily by compilation to native code (an exception is the si system <ref> [5] </ref>), interpreters are experiencing somewhat of a comeback: Proebsting and others are making interpreters much more efficient [13] by combining compiled with interpreted text; moreover, a strong market force is at play in the World-Wide Web, where Sun has created the HotJava system for distributing applications in a machine-independent fashion [11].
Reference: [6] <author> Urs Holzle. </author> <title> Adaptive optimization for Self: Reconciling High Performance with Exploratory Programming. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1994. </year> <note> Report STAN-CS-TR-94-1520. </note>
Reference-contexts: Adaptive optimization has been considered for the Self language, with the idea of using a fast compiler to generate initial code while an optimizing compiler recompiles heavily used parts <ref> [6] </ref>.
Reference: [7] <author> David Intersimone. </author> <title> Interview with regis cre-lier. </title> <type> Technical report, </type> <note> Borland International, 1996. http://www.borland.com/internet/java /interviews/regis2.html. 11 </note>
Reference-contexts: To remedy performance problems, vendors such as Borland <ref> [7] </ref>, Sun [14], Symantec [3], and others are implementing systems that transform interpreted Java VM code into native form "just-in-time": a class (compilation unit) is transmitted in Java VM form, but interpretation never takes place. <p> point of any given compilation unit has no effect on the general strategies presented for either smart JIT compilation or continuous compilation. 6 Previous work The idea of just-in-time compilation is relatively new, though apparently nearly every Java vendor is eager to produce environments that include the just-in-time compilation approach <ref> [14, 3, 7] </ref>.
Reference: [8] <author> Uwe Kastens. </author> <title> Generating interpreters automati-cally from compiler specifications. </title> <type> Technical report, </type> <institution> Paderborn University, </institution> <month> August </month> <year> 1994. </year> <note> Report tr-ri-94-151. </note>
Reference-contexts: how to generate interpreters automatically 10 Phase ghostview pico render combined Scanning 5.29 3.33 4.02 4.28 Parsing 22.20 11.98 23.48 17.45 Semantic 2.25 1.84 1.90 2.03 Code Gen. 34.43 37.69 32.36 35.83 Optimize 14.90 22.07 13.92 18.23 Library 13.78 15.21 17.16 14.68 Other 7.15 7.88 7.15 7.50 from compiler specifications <ref> [8] </ref>.
Reference: [9] <author> James R. Larus and Eric Schnarr. Eel: </author> <title> Machine-independent executable editing. </title> <booktitle> Proceedings of the SIGPLAN '95 Conference on Programming Lan-gauge Design and Implementation (Sigplan NOTICES), </booktitle> <volume> 30(6), </volume> <year> 1995. </year>
Reference-contexts: Obtaining the behavior traces proved to be more difficult. Neither gprof nor purify could supply us with the needed data. We were fortunate to have Jim Larus's excellent tool EEL <ref> [9] </ref> for instrumenting the executables to generate trace information. EEL was then used to create a utility (called eer) to modify binary executables of our test programs. When these instrumented binaries are subsequently executed, each procedure entry and exit causes a time-stamped record to be generated for the behavior file.
Reference: [10] <author> Peter Lee and Mark Leone. </author> <title> Optimizing ml with run-time code generation. </title> <booktitle> Proceedings of the 1996 ACM SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 137-148, </pages> <year> 1996. </year>
Reference-contexts: Visual languages, for example, or any interactive development environment could benefit from such an approach. We anticipate that the ideas presented in this paper may prove useful in the area of run-time code generation <ref> [10, 2] </ref>, where the profitability of spending time to generate more optimal code must be assessed. Acknowledgements We are grateful to Jim Larus for making his EEL system available to us. We thank Noah Treuhaft for his work in Summer '95, using EEL to instrument the C programs we studied.
Reference: [11] <author> Sun Microsystems. </author> <title> Sun offers a cupful of. </title> . . <journal> hot-java. Network world, </journal> <volume> 12(21), </volume> <month> May </month> <year> 1995. </year>
Reference-contexts: [5]), interpreters are experiencing somewhat of a comeback: Proebsting and others are making interpreters much more efficient [13] by combining compiled with interpreted text; moreover, a strong market force is at play in the World-Wide Web, where Sun has created the HotJava system for distributing applications in a machine-independent fashion <ref> [11] </ref>. Java is likely not to be the only language available for safe execution on the Web. Recent work [1] from CMU and Colusa (now Microsoft) is likely to lead to efficient and safe implementations of inherently unsafe languages such as C.
Reference: [12] <author> Michael P. Plezbert. </author> <title> Continuous compilation for software development and mobile computing. </title> <type> Master's thesis, </type> <institution> Washington University, </institution> <year> 1996. </year> <note> http://www.cs.wustl.edu/plezbert /contcom/thesis/thesis-main.html. </note>
Reference-contexts: Replace-preemptive is more effective, though implementation of this strategy is more difficult. <ref> [12] </ref> For the purposes of our study here, we adopt the replace-preemptive strategy. Monitor: The Compiler and Interpreter modules communicate through the Monitor shared data structure, which contains information needed by both. <p> The compilation thread of our continuous compiler is able to translate compilation units into native-code form one at a time. Our experiments show that a program's execution time under continuous compilation is strongly affected by the order in which the routines are translated into native code. <ref> [12] </ref> Here, we focus only on the strategy we call "longest-so-far", in which the compilation unit chosen by the Compiler module contains the methods that have collectively consumed the greatest amount of interpreted execution time so far. <p> As shown in Figure 10, the simulator is designed to accept information about either real or synthetic programs. In this paper, we report on our experiments with real programs. Experiments on synthetic programs can be found in <ref> [12] </ref>. Information about the program structure is contained in the setup files while the behavior file contains a trace of the program execution. Each of these is described in detail below. 5.1 Simulator Input The setup file contains static data about the program. It consists of three sections: 1.
Reference: [13] <author> Todd A. Proebsting. </author> <title> Optimizing an ANSI C interpreter with superoperators. </title> <booktitle> In Conference Record of POPL '95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 322-332, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: For languages such as C, which have long been implemented primarily by compilation to native code (an exception is the si system [5]), interpreters are experiencing somewhat of a comeback: Proebsting and others are making interpreters much more efficient <ref> [13] </ref> by combining compiled with interpreted text; moreover, a strong market force is at play in the World-Wide Web, where Sun has created the HotJava system for distributing applications in a machine-independent fashion [11]. Java is likely not to be the only language available for safe execution on the Web.
Reference: [14] <author> Evan Quinn. </author> <title> Sun's java workshop revolutionizes software development. </title> <type> Technical report, </type> <institution> Sun Mic-rosystems, </institution> <year> 1996. </year> <note> http://www.eu.sun.com/sunsoft /Developer-products/java/literature/idc.html. 12 </note>
Reference-contexts: To remedy performance problems, vendors such as Borland [7], Sun <ref> [14] </ref>, Symantec [3], and others are implementing systems that transform interpreted Java VM code into native form "just-in-time": a class (compilation unit) is transmitted in Java VM form, but interpretation never takes place. Instead, the portable VM code is compiled to native code when first needed by the executing program. <p> point of any given compilation unit has no effect on the general strategies presented for either smart JIT compilation or continuous compilation. 6 Previous work The idea of just-in-time compilation is relatively new, though apparently nearly every Java vendor is eager to produce environments that include the just-in-time compilation approach <ref> [14, 3, 7] </ref>.
References-found: 14

