URL: http://www.cs.umd.edu/projects/hermes/publications/postscripts/tods94.ps
Refering-URL: http://www.cs.umd.edu/projects/hermes/publications/abstracts/akb.html
Root-URL: 
Title: Amalgamating Knowledge Bases  
Author: V.S.Subrahmanian 
Abstract: Integrating knowledge from multiple sources is an important aspect of automated reasoning systems. When different knowledge bases are used to store knowledge provided by multiple sources, we are faced with the problem of integrating multiple knowledge bases: under these circumstances, we are also confronted with the prospect of inconsistency. In this paper, we present a uniform theoretical framework, based on annotated logics, for amalgamating multiple knowledge bases when these knowledge bases (possibly) contain inconsistencies, uncertainties, and non-monotonic modes of negation. We will show that annotated logics may be used, with some modifications, to mediate between different knowledge bases. The multiple knowledge bases are amalgamated by a transformation of the individual knowledge bases into new annotated logic programs, together with the addition of a new axiom scheme. We will characterize the declarative semantics of such amalgamated knowledge bases, and study how the semantics of the amalgam is related to the semantics of the individual knowledge bases being combined.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Adal and V.S. Subrahmanian. </author> <title> (1993) Integrating Multiple Knowledge Bases, </title> <note> submitted for conference publication. Journal version in preparation. </note>
Reference-contexts: Intuitively, dt stands for "true by default." 5. &lt;<ref> [0; 1] </ref>: the set of real numbers between (and including) 0 and 1. This is a complete lattice under the usual ordering. The real numbers in the [0; 1] interval may be viewed as "fuzzy" or, in other cases, as "possibilistic" truth values [9]. 6. TIME 1 : the power-set of non-negative integers is a complete lattice when ordered under the ordering. 6 (c) SIX ltlf f FOURTWO (b)(a) tf t 7. <p> When M = 1, we will often abuse notation and write A : 1 instead of A : <ref> [ 1 ] </ref>. In the sequel, we will use to denote a metavariable ranging over objects in the T j language, while will stand for an M-tuple of the form [ 1 ; : : : ; M ]. <p> The other rules are similar. Example 3.2 (Fault Identification Example) The amalgamated clause check (c 2 ) : <ref> [fsg; 1] </ref> broken (c 2 ) : [f1g; 0:5] & broken (c 2 ) : [f2g; 0:5]: represents one of the conflict resolution statements in the fault identification example. <p> Then the amalgamation transform of C, denoted AT (C), is the amalgamated clause A 0 : [fig; 0 ] A 1 : <ref> [fig; 1 ] </ref> & : : : & A n : [fig; n ] & The amalgamation transform, AT (DB i ), of DB i , is the set fAT (C) j C 2 DB i g. <p> Definition 3.10 Suppose DB 1 ; : : : ; DB n are GAPs. A supervisory database S is a set of clauses such that every ground instance of a clause in S is of the form: A 0 : [fsg; ] A 1 : <ref> [D 1 ; 1 ] </ref> & : : : & A n : [D n ; n ] & where, for all 1 i (n + m), D i f1; : : : ; n; sg. <p> As Q contains the combination axioms, R e Q (I)(A D ) = f j A : [D 0 ; ] B 1 : <ref> [D 1 ; 1 ] </ref> & : : : & B n : [D n ; n ] & not (B n+1 : [D n+1 ; n+1 ]) & : : : & not (B n+m : [D n+m ; n+m ]) is a ground instance of a clause in Q <p> A strong supervisory knowledge base is a finite set of amalgamated clauses such that each ground instance of a clause in the strong supervisory KB is of the form: A 0 : [fsg; ] A 1 : <ref> [D 1 ; 1 ] </ref> & : : : & A n : [D n ; n ] & where each D j , 1 j (n + m), is a subset of f1; : : : ; Ng. <p> Dubois, Lang and Prade [11], also suggest that formulas in knowledge bases can be annotated with, for each source, a lower bound of a degree of certainty associated with that source. The spirit behind their approach is similar to ours, though interest is restricted to the <ref> [0; 1] </ref> lattice, the stable and well-founded semantics are not addressed, and amalgamation theorems are not studied. However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. The authors have extended their work to accommodate time in [10]. <p> The spirit behind their approach is similar to ours, though interest is restricted to the <ref> [0; 1] </ref> lattice, the stable and well-founded semantics are not addressed, and amalgamation theorems are not studied. However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. The authors have extended their work to accommodate time in [10]. <p> There are two mitigating factors here first, N is the number of local databases being integrated which is a relatively small number in practice. There are not too many applications that require more than 4 or 5 databases to be integrated. Second, in <ref> [1] </ref>, we will show how to implement a sound and complete OLDT-resolution based query processing scheme that does not require an explicit instantiation of the combination axiom scheme. The basic idea behind [1] is the following: during query processing, at any given point in time, it is only necessary to store <p> Second, in <ref> [1] </ref>, we will show how to implement a sound and complete OLDT-resolution based query processing scheme that does not require an explicit instantiation of the combination axiom scheme. The basic idea behind [1] is the following: during query processing, at any given point in time, it is only necessary to store (in an OLDT-table), atoms of the form A : [fig; ] where fig is a singleton set. <p> To evaluate these, all one needs to do is to compute t d2D d where A : [fdg; d ] is stored in the OLDT-table. <ref> [1] </ref> gives algorithms and data structures for doing this. 7.3 Flaws in our Framework: Directions for Future Work No system is without flaws our framework is certainly no exception. In this section, we briefly overview some of the immediate flaws, and suggest some open problems.
Reference: [2] <author> R. Anand and V.S. Subrahmanian. </author> <year> (1987) </year> <month> FLOG: </month> <title> A Logic Programming System Based on a Six-Valued Logic, </title> <booktitle> AAAI/Xerox Second Intl. Symp. on Knowledge Engg., </booktitle> <address> Madrid, Spain. </address>
Reference-contexts: FOUR is extremely useful in reasoning about inconsistency: intuitively, &gt; stands for the truth value "inconsistent in classical logic," while ? stands for "unknown." 3. SIX: This lattice was introduced in <ref> [2] </ref> and consists of the set ft; f ; lt; lf ; ?; &gt;g ordered as shown in Figure 2 (c). Intuitively, lt and lf stand, respectively, for "likely to be true" and "likely to be false." This lattice contains the lattice FOUR embedded in it. 4.
Reference: [3] <author> C. Baral, S. Kraus and J. Minker. </author> <title> (1991) Combining Multiple Knowledge Bases, </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 3, 2, </volume> <pages> pps 200-220. </pages>
Reference-contexts: In fact, the approach of Whang et. al. is in the same spirit as that of metalogic programming discussed earlier. Whang et. al. do not give a formal semantics for multi-databases containing inconsistency and/or uncertainty and/or non-monotonicity and/or temporal information. Baral et. al. <ref> [3, 4] </ref> have developed algorithms for combining different logic databases which generalizes the update strategy by giving priorities to some updates (when appropriate) and as well as not giving priorities to updates (which corresponds to combining 21 two theories without any preferences). <p> Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. [13, 14]). As we shall argue in Section 7.2, our framework can express maximal consistency as well. <ref> [3, 4] </ref> do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [3, 4] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework is able to do so. <p> As we shall argue in Section 7.2, our framework can express maximal consistency as well. <ref> [3, 4] </ref> do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [3, 4] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework is able to do so.
Reference: [4] <author> C. Baral, S. Kraus, J. Minker and V.S. Subrahmanian. </author> <title> (1992) Combining Knowledge Bases Consisting of First Order Theories, </title> <journal> Computational Intelligence, </journal> <volume> 8, 1, </volume> <pages> pps 45-71. </pages>
Reference-contexts: In fact, the approach of Whang et. al. is in the same spirit as that of metalogic programming discussed earlier. Whang et. al. do not give a formal semantics for multi-databases containing inconsistency and/or uncertainty and/or non-monotonicity and/or temporal information. Baral et. al. <ref> [3, 4] </ref> have developed algorithms for combining different logic databases which generalizes the update strategy by giving priorities to some updates (when appropriate) and as well as not giving priorities to updates (which corresponds to combining 21 two theories without any preferences). <p> Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. [13, 14]). As we shall argue in Section 7.2, our framework can express maximal consistency as well. <ref> [3, 4] </ref> do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [3, 4] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework is able to do so. <p> As we shall argue in Section 7.2, our framework can express maximal consistency as well. <ref> [3, 4] </ref> do not develop a formal model-theoretic treatment of combining multiple knowledge bases, whereas our method does provide such a model theory. [3, 4] are unable to handle non-monotonicity (in terms of stable/well-founded semantics), nor uncertainty, nor time-stamped information our framework is able to do so.
Reference: [5] <author> C. Baral and V.S. Subrahmanian. </author> <title> (1991) Dualities between Alternative Semantics for Logic Programming and Non-Monotonic Reasoning, </title> <note> to appear in: Journal of Automated Reasoning. Preliminary version in: Proc. 1991 Intl. Workshop on Logic Programming and Non-Monotonic Reasoning (eds. </note> <editor> A. Nerode, W. Marek and V.S. Subrahmanian), </editor> <publisher> MIT Press. </publisher>
Reference-contexts: However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. The authors have extended their work to accommodate time in [10]. In [17], Fitting generalizes results in <ref> [5, 45] </ref>, to obtain a well-founded semantics for bilattice-based logic programs. 4 Unlike annotated logics, bilattice-valued logic programs are just (unannotated) sets of clauses C A B 1 & : : : & B n & :D 1 & : : : & :D m : An interpretation, -, assigns truth
Reference: [6] <author> H. A. Blair and V.S. Subrahmanian. </author> <title> (1987) Paraconsistent Logic Programming, </title> <journal> Theoretical Computer Science, </journal> <volume> 68, </volume> <pages> pp 35-54. </pages> <note> Preliminary version in: LNCS 287, Dec. 1987, Springer. 27 </note>
Reference-contexts: could conclude (correctly) that it is 50K. 3 Amalgamation Logic: Syntax In this section, we describe the basic syntax of the language in which databases are expressed. 3.1 The Underlying Languages The base language we will use is that of annotated logic developed by Subrahmanian [41] and studied further in <ref> [6, 8, 26, 27, 28, 29, 31, 39, 43] </ref>. <p> FOUR: the set ft; f ; ?; &gt;g ordered as shown in Figure 2 (b). This set of truth values was initially studied by Belnap and used in logic programming by Blair and Subrahmanian <ref> [6] </ref> and Fitting [15, 16]. FOUR is extremely useful in reasoning about inconsistency: intuitively, &gt; stands for the truth value "inconsistent in classical logic," while ? stands for "unknown." 3.
Reference: [7] <author> K. Bowen and R. Kowalski. </author> <title> (1982) Amalgamating Language and Metalanguage in Logic Programming, in "Logic Programming" (eds. </title> <editor> K. L. Clark and S.-A. Tarn-lund), </editor> <address> pps 153-172, </address> <publisher> Academic Press. </publisher>
Reference-contexts: Metalogic programming was introduced by Bowen and Kowalski <ref> [7] </ref> who showed how to amalgamate object language and metalanguage via the device of Godel numbering. They showed that this allowed a database to refer to components of the database.
Reference: [8] <author> N.C.A. da Costa, V.S. Subrahmanian and C. Vago. </author> <title> (1991) The Paraconsistent Logics PT, </title> <journal> Zeitschrift fur Mathematische Logik und Grundlagen der Mathematik, </journal> <volume> Vol. 37, </volume> <pages> pps 139-148. </pages>
Reference-contexts: could conclude (correctly) that it is 50K. 3 Amalgamation Logic: Syntax In this section, we describe the basic syntax of the language in which databases are expressed. 3.1 The Underlying Languages The base language we will use is that of annotated logic developed by Subrahmanian [41] and studied further in <ref> [6, 8, 26, 27, 28, 29, 31, 39, 43] </ref>.
Reference: [9] <author> D. Dubois, J. Lang and H. Prade. </author> <title> (1991) Towards Possibilistic Logic Programming, </title> <booktitle> Proc. 1991 Intl. Conf. on Logic Programming, </booktitle> <editor> ed. K. Furukawa, </editor> <address> pps 581-595, </address> <publisher> MIT Press. </publisher>
Reference-contexts: This is a complete lattice under the usual ordering. The real numbers in the [0; 1] interval may be viewed as "fuzzy" or, in other cases, as "possibilistic" truth values <ref> [9] </ref>. 6. TIME 1 : the power-set of non-negative integers is a complete lattice when ordered under the ordering. 6 (c) SIX ltlf f FOURTWO (b)(a) tf t 7.
Reference: [10] <author> D. Dubois, J. Lang and H. Prade. </author> <title> (1991) Timed Possibilistic Logic, </title> <journal> Fundamenta Informaticae, </journal> <volume> Vol. XV, No. </volume> <pages> 3-4, pps 211-234. </pages>
Reference-contexts: However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. The authors have extended their work to accommodate time in <ref> [10] </ref>.
Reference: [11] <author> D. Dubois, J. Lang and H. Prade. </author> <title> (1992) Dealing with Multi-Source Information in Possibilistic Logic, </title> <booktitle> Proc. 10th European Conf. on Artificial Intelligence, </booktitle> <publisher> Wiley. </publisher>
Reference-contexts: Dubois, Lang and Prade <ref> [11] </ref>, also suggest that formulas in knowledge bases can be annotated with, for each source, a lower bound of a degree of certainty associated with that source.
Reference: [12] <author> D. Etherington. </author> <title> (1988) Reasoning with Incomplete Information, </title> <publisher> Pitman Publishers. </publisher>
Reference-contexts: Representing Maximal Consistent Subsets. It is well known <ref> [12] </ref> that maximal consis tent subsets of a theory may be viewed as the extensions of a corresponding normal default theory.
Reference: [13] <author> R. Fagin, J.D. Ullman, and M.Y. Vardi. </author> <title> (1983) On the Semantics of Updates in Databases, </title> <booktitle> Proc. ACM SIGACT/SIGMOD Symposium on Principles of Database Systems, </booktitle> <address> pps 352-365. </address>
Reference-contexts: Given a database DB and a new fact F , updating DB by asserting F is tantamount to combining the database DB with a database containing the single fact F with priority being given to the update, F . This has been studied by Fagin et. al. <ref> [13, 14] </ref>. A great deal of work has been done in multidatabase systems and interoperable database systems [21, 46, 47]. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. <p> Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. <ref> [13, 14] </ref>).
Reference: [14] <author> R. Fagin, G. Kuper, J. Ullman, and M. Vardi. </author> <title> (1986) Updating Logical Databases, </title> <booktitle> In Advances in Computing Research, </booktitle> <volume> volume 3, </volume> <pages> pages 1-18, </pages> <year> 1986. </year>
Reference-contexts: Given a database DB and a new fact F , updating DB by asserting F is tantamount to combining the database DB with a database containing the single fact F with priority being given to the update, F . This has been studied by Fagin et. al. <ref> [13, 14] </ref>. A great deal of work has been done in multidatabase systems and interoperable database systems [21, 46, 47]. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. <p> Combining two theories corresponds, roughly, to finding maximally consistent subsets (also called flocks by Fagin et. al. <ref> [13, 14] </ref>).
Reference: [15] <author> M. C. </author> <title> Fitting. (1989) Negation as Refutation, </title> <booktitle> Proc. 4th Symp. on Logic in Computer Science, </booktitle> <address> pps 63-70. </address>
Reference-contexts: FOUR: the set ft; f ; ?; &gt;g ordered as shown in Figure 2 (b). This set of truth values was initially studied by Belnap and used in logic programming by Blair and Subrahmanian [6] and Fitting <ref> [15, 16] </ref>. FOUR is extremely useful in reasoning about inconsistency: intuitively, &gt; stands for the truth value "inconsistent in classical logic," while ? stands for "unknown." 3.
Reference: [16] <author> M. C. </author> <title> Fitting. (1991) Bilattices and the Semantics of Logic Programming, </title> <journal> Journal of Logic Programming, </journal> <volume> 11, </volume> <pages> pps 91-116. </pages>
Reference-contexts: FOUR: the set ft; f ; ?; &gt;g ordered as shown in Figure 2 (b). This set of truth values was initially studied by Belnap and used in logic programming by Blair and Subrahmanian [6] and Fitting <ref> [15, 16] </ref>. FOUR is extremely useful in reasoning about inconsistency: intuitively, &gt; stands for the truth value "inconsistent in classical logic," while ? stands for "unknown." 3. <p> the other ordering and that various distributivity properties hold. 5 An important point to note is that in Fitting's semantics, : is antimonotonic w.r.t. the t operator, and hence, this clause transforms non-monotonicity from the body of C to a non-monotonic annotation function in the head of C. 22 Fitting <ref> [16] </ref> defines both the well-founded and stable semantics of bilattice-valued logic programs in terms of an operator, 0 Z where 0 Z (-) is the least fixpoint, according to the t ordering, of the operator x: Z (x; -).
Reference: [17] <author> M. C. </author> <title> Fitting. (1991) Well-Founded Semantics, Generalized, </title> <booktitle> Proc. 1991 Intl. Logic Programming Symposium, </booktitle> <address> pps 71-83, </address> <publisher> MIT Press. </publisher>
Reference-contexts: The principal model-theoretic technical advance on [30] is the development of the notions of stable model and well-founded model for GAPs, thus enabling uncertainty, inconsistency and temporal data to be handled within non-monotonic local databases. This is related to work by Fitting <ref> [17] </ref> on stable model semantics for bilattices. * Amalgamation Theory: Figure 1 shows how multiple knowledge bases interact with a supervisory database 1 (supervisory KBs are called mediators in [40, p.119]) that specifies, amongst other things, how local KBs are to combined. <p> However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. The authors have extended their work to accommodate time in [10]. In <ref> [17] </ref>, Fitting generalizes results in [5, 45], to obtain a well-founded semantics for bilattice-based logic programs. 4 Unlike annotated logics, bilattice-valued logic programs are just (unannotated) sets of clauses C A B 1 & : : : & B n & :D 1 & : : : & :D m : <p> In particular, the "consensus" operator, , defined by Fitting <ref> [17] </ref>, which takes the glb (in the k -ordering) of the least and greatest fixpoints of 0 Z can be described in terms of annotated logic. From results of Kifer and Subrahmanian [30], it is already known (even in the negation-free case), that bilattices cannot subsume GAPs.
Reference: [18] <author> M. C. </author> <title> Fitting. (1992) The Family of Stable Models, </title> <note> to appear in: Journal of Logic Programming. </note>
Reference: [19] <author> M. Gelfond and V. Lifschitz. </author> <title> (1988) The Stable Model Semantics for Logic Programming, </title> <booktitle> in: Proc. 5th International Conference and Symposium on Logic Programming, </booktitle> <editor> ed R. A. Kowalski and K. A. </editor> <booktitle> Bowen, </booktitle> <pages> pp 1070-1080. </pages>
Reference-contexts: Our framework is rich enough to integrate databases that contain: * non-monotonic modes of negation (interpreted in terms of both the stable model semantics <ref> [19] </ref> and the well-founded semantics [44]), * uncertainty in the form of possibilistic logic and fuzzy logic, * simple temporal information such as that used to denote at what time points and/or time intervals certain statements are true, as well as * inconsistencies in the sense of classical logic. <p> In particular, the D j 's are not allowed to evaluate to a set with s in it. 3 This is an incarnation of the familiar program p not p in logic programming that is well known not to possess a stable model <ref> [19] </ref>. 15 Thus, strong supervisory databases differ from arbitrary amalgamated knowledge bases in the sense that ground instances of clauses can: * only have heads of the form A 0 : [fsg; ], i.e. the first component of the annotation is fixed to fsg, and * the first component of all
Reference: [20] <author> M. L. Ginsberg. </author> <title> (1988) Multivalued Logics: A Uniform Approach to Reasoning in Artificial Intelligence, </title> <journal> Computational Intelligence, </journal> <volume> 4, </volume> <pages> pps 265-316. </pages>
Reference-contexts: Intuitively, lt and lf stand, respectively, for "likely to be true" and "likely to be false." This lattice contains the lattice FOUR embedded in it. 4. DEF: Ginsberg <ref> [20] </ref> has proposed a lattice of truth values the elements in this lattice are ft; f ; &gt;; ?; d&gt;; dt; df g. Intuitively, dt stands for "true by default." 5. &lt;[0; 1]: the set of real numbers between (and including) 0 and 1. <p> The theorem shows that Fitting's Z can be accurately captured by the R operator associated with the annotated logic program Z ann . 4 A bilattice, due to M. Ginsberg <ref> [20] </ref> is a set that is a complete lattice under two orderings, a "truth" ordering, t , and a "knowledge" ordering, k .
Reference: [21] <author> J. Grant, W. Litwin, N. Roussopoulos and T. Sellis. </author> <title> (1991) An Algebra and Calculus for Relational Multidatabase Systems, </title> <booktitle> Proc. First International Workshop on Interoperability in Multidatabase Systems, </booktitle> <publisher> IEEE Computer Society Press (1991) 118-124. </publisher>
Reference-contexts: This has been studied by Fagin et. al. [13, 14]. A great deal of work has been done in multidatabase systems and interoperable database systems <ref> [21, 46, 47] </ref>. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. <p> However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. The work of Grant et. al. <ref> [21] </ref> is an exception: the authors develop a calculus and an algebra for integrating information from multiple databases. This calculus extends the standard relational calculus. Further work specialized to handle inter-operability of multidatabases is critically needed.
Reference: [22] <author> L. J. Henschen and J.J. Lu. </author> <title> (1991) The Paraconsistent Closed World Assumption, </title> <note> to appear in: Theoretical Computer Science. </note>
Reference: [23] <author> L. J. Henschen and J.J. Lu. </author> <title> (1992) The Completeness of Gp-resolution for Annotated Logics, </title> <journal> Information Processing Letters, </journal> <volume> 44, </volume> <pages> pps 135-140. 28 </pages>
Reference-contexts: Complexity Issues As an amalgamated knowledge base is just an annotated logic pro gram over an expanded set of atoms, procedures for processing queries to annotated logics (e.g. <ref> [23] </ref>) can be used to process queries to amalgamated logic programs.
Reference: [24] <author> Y. Ioannidis and T. Sellis. </author> <title> (1989) Conflict Resolution of Rules Assigning Values to Virtual Attributes, </title> <booktitle> Proc. ACM SIGMOD Symp. on Management of Data. </booktitle>
Reference: [25] <author> M. Kifer and T. Krishnaprasad. </author> <title> (1989) An Evidence Based Framework for a Theory of Inheritance, </title> <booktitle> Proc. 1989 International Joint Conference on Artificial Intelligence, </booktitle> <address> pps 1093-1098, Morgan-Kauffman. </address> <note> Full version to appear in: Artificial Intelligence. </note>
Reference: [26] <author> M. Kifer, T. Krishnaprasad and D.S. Warren. </author> <title> (1989) On the Declarative Semantics of Inheritance Networks, </title> <booktitle> Proc. 1989 International Joint Conference on Artificial Intelligence, </booktitle> <address> pps 1099-1103, Morgan-Kauffman. </address>
Reference-contexts: could conclude (correctly) that it is 50K. 3 Amalgamation Logic: Syntax In this section, we describe the basic syntax of the language in which databases are expressed. 3.1 The Underlying Languages The base language we will use is that of annotated logic developed by Subrahmanian [41] and studied further in <ref> [6, 8, 26, 27, 28, 29, 31, 39, 43] </ref>. <p> GAPs are based on annotated logics which have been fairly well-studied from a foundational point of view, as well as from the point of view of reasoning about temporal data, object-oriented databases [31], and inheritance nets <ref> [26] </ref>. Acknowledgements. I have benefited from discussions with Sibel Adal, Bobbie Cochrane, Sarit Kraus, Jim Lu and Raymond Ng.
Reference: [27] <author> M. Kifer and A. Li. </author> <title> (1988) On the Semantics of Rule-Based Expert Systems with Uncertainty, </title> <booktitle> 2-nd Intl. Conf. on Database Theory, </booktitle> <publisher> Springer Verlag LNCS 326, </publisher> <editor> (eds. M. Gyssens, J. Paredaens, D. Van Gucht), Bruges, </editor> <address> Belgium, </address> <pages> pp. 102-117. </pages>
Reference-contexts: could conclude (correctly) that it is 50K. 3 Amalgamation Logic: Syntax In this section, we describe the basic syntax of the language in which databases are expressed. 3.1 The Underlying Languages The base language we will use is that of annotated logic developed by Subrahmanian [41] and studied further in <ref> [6, 8, 26, 27, 28, 29, 31, 39, 43] </ref>.
Reference: [28] <author> M. Kifer and E. Lozinskii. </author> <title> (1989) RI: A Logic for Reasoning with Inconsistency, </title> <booktitle> 4-th Symposium on Logic in Computer Science, Asilomar, </booktitle> <address> CA, </address> <pages> pp. 253-262. </pages>
Reference-contexts: could conclude (correctly) that it is 50K. 3 Amalgamation Logic: Syntax In this section, we describe the basic syntax of the language in which databases are expressed. 3.1 The Underlying Languages The base language we will use is that of annotated logic developed by Subrahmanian [41] and studied further in <ref> [6, 8, 26, 27, 28, 29, 31, 39, 43] </ref>.
Reference: [29] <author> M. Kifer and E. Lozinskii. </author> <title> (1992) A Logic for Reasoning with Inconsistency, </title> <journal> Journal of Automated Reasoning, </journal> <volume> 9, 2, </volume> <pages> pps 179-215. </pages>
Reference-contexts: could conclude (correctly) that it is 50K. 3 Amalgamation Logic: Syntax In this section, we describe the basic syntax of the language in which databases are expressed. 3.1 The Underlying Languages The base language we will use is that of annotated logic developed by Subrahmanian [41] and studied further in <ref> [6, 8, 26, 27, 28, 29, 31, 39, 43] </ref>.
Reference: [30] <author> M. Kifer and V.S. Subrahmanian. </author> <title> (1989) Theory of Generalized Annotated Logic Programming and its Applications, </title> <journal> Journal of Logic Programming, </journal> <volume> 12, 4, </volume> <pages> pps 335-368, </pages> <year> 1992. </year> <title> Preliminary version in: </title> <booktitle> Proc. 1989 North American Conf. on Logic Programming, </booktitle> <publisher> MIT Press. </publisher>
Reference-contexts: The model-theoretic framework will be based on the semantics of generalized annotated programs (GAPs for short) developed in <ref> [30] </ref>. GAPs are logic programs interpreted over complete lattices of truth values. The principal model-theoretic technical advance on [30] is the development of the notions of stable model and well-founded model for GAPs, thus enabling uncertainty, inconsistency and temporal data to be handled within non-monotonic local databases. <p> The model-theoretic framework will be based on the semantics of generalized annotated programs (GAPs for short) developed in <ref> [30] </ref>. GAPs are logic programs interpreted over complete lattices of truth values. The principal model-theoretic technical advance on [30] is the development of the notions of stable model and well-founded model for GAPs, thus enabling uncertainty, inconsistency and temporal data to be handled within non-monotonic local databases. <p> be based on a slight extension of annotated logic that takes the cross product of M (where M 1) complete lattices T 1 ; : : : ; T M in the case when M = 1 and negations are absent, we will obtain the framework of Kifer and Subrahmanian <ref> [30] </ref> as a special case. We use the notation, T loc = T 1 fi fi T M . Some examples of individual lattices that could be involved in the cross product are (however, users are free to choose other lattices to reflect their individual preferences): 1. <p> Definition 3.3 (Generalized Annotated Program) A generalized annotated program (GAP, for short) is a finite set of annotated clauses. A GAP is said to be negation-free just in case it contains only negation-free annotated clauses. In <ref> [30] </ref>, Kifer and Subrahmanian studied the semantics of negation-free GAPs. In Sections 5.1 and 6, we will characterize the semantics of GAPs containing negation. 3.2 Amalgamated Knowledge Bases Using the notation just set out, we are now in a position to define amalgamated logic programs. <p> that "According to the supervisor, component c 2 must be checked with certainty 1 if both DB 1 and DB 2 say that component c 2 is broken with certainty at least 0:5. 3.3 Model Theory for GAPs In this section, we recapitulate the model theory of GAPs developed in <ref> [30] </ref>. The reader familiar with [30] may skip ahead to section 3.4. Definition 3.5 (r-Interpretation) [30] A restricted Herbrand interpretation (r-interpretation, for short) of language L, is any map from the Herbrand Base, B L , to T loc . <p> component c 2 must be checked with certainty 1 if both DB 1 and DB 2 say that component c 2 is broken with certainty at least 0:5. 3.3 Model Theory for GAPs In this section, we recapitulate the model theory of GAPs developed in <ref> [30] </ref>. The reader familiar with [30] may skip ahead to section 3.4. Definition 3.5 (r-Interpretation) [30] A restricted Herbrand interpretation (r-interpretation, for short) of language L, is any map from the Herbrand Base, B L , to T loc . In particular, observe that when local GAPs are being considered, L is the base language. <p> both DB 1 and DB 2 say that component c 2 is broken with certainty at least 0:5. 3.3 Model Theory for GAPs In this section, we recapitulate the model theory of GAPs developed in <ref> [30] </ref>. The reader familiar with [30] may skip ahead to section 3.4. Definition 3.5 (r-Interpretation) [30] A restricted Herbrand interpretation (r-interpretation, for short) of language L, is any map from the Herbrand Base, B L , to T loc . In particular, observe that when local GAPs are being considered, L is the base language. <p> Kifer and Subrahmanian <ref> [30] </ref> have proved that when P contains no negation, R e P is monotone (but not continuous), that the pre-fixpoints of R e P coincide with the r-models of P , and that R e P has a unique "least" r-model. <p> In particular, the "consensus" operator, , defined by Fitting [17], which takes the glb (in the k -ordering) of the least and greatest fixpoints of 0 Z can be described in terms of annotated logic. From results of Kifer and Subrahmanian <ref> [30] </ref>, it is already known (even in the negation-free case), that bilattices cannot subsume GAPs. <p> enables us to study the relationship between the semantics of the local knowledge bases (in terms of stable models, and/or well-founded models) in a uniform way. * Furthermore, the language used for expressing the local KBs and the supervisory database is an extension of the language of generalized annotated programs <ref> [30] </ref> (GAPs). GAPs are based on annotated logics which have been fairly well-studied from a foundational point of view, as well as from the point of view of reasoning about temporal data, object-oriented databases [31], and inheritance nets [26]. Acknowledgements.
Reference: [31] <author> M. Kifer and J. Wu. </author> <title> (1989) A Logic for Object Oriented Logic Programming, </title> <booktitle> Proc. 8th ACM SIGACT/SIGMOD/SIGART Symp. on Principles of Database Systems, </booktitle> <address> Philadelphia, pps 379-393. </address>
Reference-contexts: could conclude (correctly) that it is 50K. 3 Amalgamation Logic: Syntax In this section, we describe the basic syntax of the language in which databases are expressed. 3.1 The Underlying Languages The base language we will use is that of annotated logic developed by Subrahmanian [41] and studied further in <ref> [6, 8, 26, 27, 28, 29, 31, 39, 43] </ref>. <p> GAPs are based on annotated logics which have been fairly well-studied from a foundational point of view, as well as from the point of view of reasoning about temporal data, object-oriented databases <ref> [31] </ref>, and inheritance nets [26]. Acknowledgements. I have benefited from discussions with Sibel Adal, Bobbie Cochrane, Sarit Kraus, Jim Lu and Raymond Ng.
Reference: [32] <author> J. W. Lloyd. </author> <booktitle> (1987) Foundations of Logic Programming, </booktitle> <publisher> Springer. </publisher>
Reference-contexts: In addition, L contains an infinite set, OV , of variable symbols (called ordinary variables). The concepts of terms, atoms, and literals are defined in the usual way (cf. Lloyd <ref> [32] </ref>). L is the language in which all the local knowledge bases are expressed. T j Languages: Each member of T j , 1 j M, is a constant symbol in the T j -language. <p> T j Languages: Each member of T j , 1 j M, is a constant symbol in the T j -language. In addition, for each 1 j M, and each i 1, we postulate that there is a family F i j of total continuous (hence monotonic, <ref> [32] </ref>) functions, each of type (T j ) i ! T j , called annotation functions over lattice T j .
Reference: [33] <author> J. J. Lu. </author> <title> (1992) Automated Deduction in Paraconsistent Logics, </title> <type> Ph.D. thesis, </type> <institution> Northwestern University, </institution> <month> May </month> <year> 1992. </year>
Reference: [34] <author> W. Marek, A. Nerode and J. Remmel. </author> <title> (1990) A Theory of Non-Monotonic Rule Systems, I, </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <note> 1991. Preliminary version in: Proc. 1990 Conf. on Logic in Computer Science. </note>
Reference: [35] <author> W. Marek, A. Nerode and J. Remmel. </author> <title> (1992) The Stable Models of a Predicate Logic Program , in: </title> <booktitle> Proc. 1992 Intl. Conf. on Logic Programming (ed. K.R. Apt), </booktitle> <publisher> MIT Press. </publisher>
Reference: [36] <author> N.V. Murray and E. Rosenthal. </author> <title> (1991) Signed Formulas: A Classical Approach to Multiple-Valued Logics, </title> <institution> TR-91-12, State University of New York at Albany. </institution>
Reference: [37] <author> R. T. Ng and V.S. Subrahmanian. </author> <title> (1990) Probabilistic Logic Programming, </title> <note> to appear in Information and Computation. Preliminary version in: </note> <editor> Proc. </editor> <booktitle> 1990 Intl. Symp. on Methodologies for Intelligent Systems, </booktitle> <publisher> North Holland. </publisher>
Reference: [38] <author> R. T. Ng and V.S. Subrahmanian. </author> <title> (1991) A Semantical Framework for Supporting Subjective and Conditional Probabilities in Deductive Databases,, </title> <journal> Journal of Automated Reasoning, </journal> <volume> 10, 2, </volume> <pages> pps 191-235, </pages> <year> 1993. </year> <note> A preliminary version of this paper appeared in the Proc. of the 1991 Intl. </note> <editor> Conf. </editor> <booktitle> on Logic Programming, </booktitle> <publisher> MIT Press. </publisher>
Reference: [39] <author> C. Sakama. </author> <title> (1992) Extended Well-Founded Semantics for Paraconsistent Logic Programs, </title> <booktitle> Proc. 1992 Intl. Conf. on Fifth Generation Computer Systems, </booktitle> <address> Tokyo. </address> <month> 29 </month>
Reference-contexts: could conclude (correctly) that it is 50K. 3 Amalgamation Logic: Syntax In this section, we describe the basic syntax of the language in which databases are expressed. 3.1 The Underlying Languages The base language we will use is that of annotated logic developed by Subrahmanian [41] and studied further in <ref> [6, 8, 26, 27, 28, 29, 31, 39, 43] </ref>.
Reference: [40] <author> A. Silberschatz, M. Stonebraker and J. D. Ullman. </author> <title> (1991) Database Systems: Achievements and Opportunities, </title> <journal> Comm. of the ACM, </journal> <volume> 34, 10, </volume> <pages> pps 110-120. </pages>
Reference-contexts: Electronic Mail: vs@cs.umd.edu 1 In a recent NSF workshop on identifying the "technology pull factors that will serve as forcing functions for advanced database technology" <ref> [40, p. 111] </ref>, Silberschatz, Stone-braker and Ullman observed that "cooperation among different organizations on common scientific, engineering, and commercial problems will require large-scale, heterogeneous, distributed databases." They further emphasize ([40, p. 118]) "the necessity of logically integrating databases from multiple organizations into what appears to be a single database." The primary <p> This is related to work by Fitting [17] on stable model semantics for bilattices. * Amalgamation Theory: Figure 1 shows how multiple knowledge bases interact with a supervisory database 1 (supervisory KBs are called mediators in <ref> [40, p.119] </ref>) that specifies, amongst other things, how local KBs are to combined. The language within which supervisory DBs are expressed must have the ability to reason about, and manipulate local knowledge bases. <p> In an implementation, it is conceivable that such rules are implicitly added by the system. 8 Conclusions In the context of integrating multiple databases, Silberschatz, Stonebraker and Ullman <ref> [40, p.119] </ref> have remarked that: "As the problems of fusion and semantic inconsistency are so severe, there is need for a class of information sources that stand between the user and the heterogeneous databases." They refer to this class of information sources as mediators because they mediate between multiple knowledge bases,
Reference: [41] <editor> V.S. Subrahmanian. </editor> <booktitle> (1987) On the Semantics of Quantitative Logic Programs, Proc. 1987 IEEE Symp. on Logic Programming, </booktitle> <address> pps 173-182. </address>
Reference-contexts: Doe's current salary, then they could conclude (correctly) that it is 50K. 3 Amalgamation Logic: Syntax In this section, we describe the basic syntax of the language in which databases are expressed. 3.1 The Underlying Languages The base language we will use is that of annotated logic developed by Subrahmanian <ref> [41] </ref> and studied further in [6, 8, 26, 27, 28, 29, 31, 39, 43].
Reference: [42] <author> V.S. Subrahmanian. </author> <title> (1989) A Simple Formulation of the Theory of Metalogic Programming, in "Meta-Programming in Logic Programming" (eds. </title> <editor> H. Abramson and M. Rogers), </editor> <address> pps 65-101, </address> <publisher> MIT Press. </publisher>
Reference-contexts: Metalogic programming was introduced by Bowen and Kowalski [7] who showed how to amalgamate object language and metalanguage via the device of Godel numbering. They showed that this allowed a database to refer to components of the database. Sub-rahmanian <ref> [42, pps. 88-89] </ref> showed how metalogic programming may be used to address cooperative reasoning problems, as well as the database update problem [42, pps. 91-94]. However, the development of a formal semantics for (even monotonic) metalogic programming has remained a rather difficult and contentious issue. <p> They showed that this allowed a database to refer to components of the database. Sub-rahmanian [42, pps. 88-89] showed how metalogic programming may be used to address cooperative reasoning problems, as well as the database update problem <ref> [42, pps. 91-94] </ref>. However, the development of a formal semantics for (even monotonic) metalogic programming has remained a rather difficult and contentious issue. Database updates are also closely related to combining multiple knowledge bases.
Reference: [43] <author> V.S. Subrahmanian. </author> <title> (1992) Paraconsistent Disjunctive Deductive Databases, </title> <journal> Theoretical Computer Science, </journal> <volume> 93, </volume> <pages> pps 115-141. </pages>
Reference-contexts: could conclude (correctly) that it is 50K. 3 Amalgamation Logic: Syntax In this section, we describe the basic syntax of the language in which databases are expressed. 3.1 The Underlying Languages The base language we will use is that of annotated logic developed by Subrahmanian [41] and studied further in <ref> [6, 8, 26, 27, 28, 29, 31, 39, 43] </ref>.
Reference: [44] <author> A. van Gelder, K. Ross and J. Schlipf. </author> <title> (1988) Unfounded Sets and Well-founded Semantics for General Logic Programs, </title> <booktitle> in Proc. 7th Symposium on Principles of Database Systems, </booktitle> <pages> pp 221-230. </pages>
Reference-contexts: Our framework is rich enough to integrate databases that contain: * non-monotonic modes of negation (interpreted in terms of both the stable model semantics [19] and the well-founded semantics <ref> [44] </ref>), * uncertainty in the form of possibilistic logic and fuzzy logic, * simple temporal information such as that used to denote at what time points and/or time intervals certain statements are true, as well as * inconsistencies in the sense of classical logic.
Reference: [45] <author> A. van Gelder. </author> <title> (1989) The Alternating Fixpoint of Logic Programs with Negation, </title> <booktitle> Proc. 8th ACM Symp. on Principles of Database Systems, </booktitle> <volume> pps 1 - 10. </volume>
Reference-contexts: However, for the [0; 1] case, their framework is a bit richer than ours when nonmonotonic negations are absent. The authors have extended their work to accommodate time in [10]. In [17], Fitting generalizes results in <ref> [5, 45] </ref>, to obtain a well-founded semantics for bilattice-based logic programs. 4 Unlike annotated logics, bilattice-valued logic programs are just (unannotated) sets of clauses C A B 1 & : : : & B n & :D 1 & : : : & :D m : An interpretation, -, assigns truth
Reference: [46] <author> W.K. Whang, S. B. Navathe and S. Chakravarthy. </author> <title> (1991) Logic-Based Approach for Realizing a Federated Information System, </title> <booktitle> Proc. First International Workshop on Interoperability in Multidatabase Systems, </booktitle> <publisher> IEEE Computer Society Press (1991) 92-100. </publisher>
Reference-contexts: This has been studied by Fagin et. al. [13, 14]. A great deal of work has been done in multidatabase systems and interoperable database systems <ref> [21, 46, 47] </ref>. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. <p> Zicari et. al [47] describe how interoperability may be achieved between a rule-based system (deductive DB) and an object-oriented database using special import/export primitives. No formal theory is developed in [47]. Perhaps closer to our goal is that of Whang et. al. <ref> [46] </ref> who argue that Prolog is a suitable framework for schema integration. In fact, the approach of Whang et. al. is in the same spirit as that of metalogic programming discussed earlier.
Reference: [47] <author> R. Zicari, S. Ceri, and L. Tanca. </author> <title> (1991) Interoperability between a Rule-Based Database Language and an Object-Oriented Language, </title> <booktitle> Proc. First International Workshop on Interoperability in Multidatabase Systems, </booktitle> <publisher> IEEE Computer Society Press (1991) 125-135. </publisher>
Reference-contexts: This has been studied by Fagin et. al. [13, 14]. A great deal of work has been done in multidatabase systems and interoperable database systems <ref> [21, 46, 47] </ref>. However, most of this work combines standard relational databases (no deductive capabilities). Not much has been done on the development of a semantic foundation for such databases. <p> This calculus extends the standard relational calculus. Further work specialized to handle inter-operability of multidatabases is critically needed. However, our paper addresses a different topic that of integrating multiple deductive databases containing (possibly) inconsistencies, uncertainty, non-monotonic negation, and possibly even temporal information. Zicari et. al <ref> [47] </ref> describe how interoperability may be achieved between a rule-based system (deductive DB) and an object-oriented database using special import/export primitives. No formal theory is developed in [47]. <p> Zicari et. al <ref> [47] </ref> describe how interoperability may be achieved between a rule-based system (deductive DB) and an object-oriented database using special import/export primitives. No formal theory is developed in [47]. Perhaps closer to our goal is that of Whang et. al. [46] who argue that Prolog is a suitable framework for schema integration. In fact, the approach of Whang et. al. is in the same spirit as that of metalogic programming discussed earlier.
References-found: 47

