URL: http://www.cs.wustl.edu/~schmidt/Act-Obj.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/new.html
Root-URL: http://www.cs.wustl.edu
Email: G.Lavender@isode.com schmidt@cs.wustl.edu  
Title: Active Object An Object Behavioral Pattern for Concurrent Programming  
Author: R. Greg Lavender Douglas C. Schmidt 
Address: Austin, TX Washington University, St. Louis  
Affiliation: ISODE Consortium Inc. Department of Computer Science  
Abstract: An earlier version of this paper appeared in a chapter in the book Pattern Languages of Program Design 2 ISBN 0-201-89527-7, edited by John Vlissides, Jim Coplien, and Norm Kerth published by Addison-Wesley, 1996. Abstract This paper describes the Active Object pattern, which decou-ples method execution from method invocation in order to simplify synchronized access to an object that resides in its own thread of control. The Active Object pattern allows one or more independent threads of execution to interleave their access to data modeled as a single object. A broad class of producer/consumer and reader/writer applications are well-suited to this model of concurrency. This pattern is commonly used in distributed systems requiring multi-threaded servers. In addition, client applications, such as window-ing systems and network browsers, employ active objects to simplify concurrent, asynchronous network operations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: Object design pattern decouples method execution from method invocation to enhance concurrency and simplify synchronized access to an object that resides in its own thread of control. 2 Also Known As Concurrent Object and Actor 3 Example To illustrate the Active Object pattern, consider the design of a communication Gateway <ref> [1] </ref>. A Gateway decouples cooperating components and allows them to interact without having direct dependencies among each other [2]. The Gateway shown in Figure 1 routes messages from one or more supplier processes to one or more consumer processes in a distributed system [3].
Reference: [2] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: A Gateway decouples cooperating components and allows them to interact without having direct dependencies among each other <ref> [2] </ref>. The Gateway shown in Figure 1 routes messages from one or more supplier processes to one or more consumer processes in a distributed system [3]. <p> This method is automatically converted into a method request object and passed to another thread of control, where it is converted back into a method and executed on the object implementation. An active object consists of the following components. A Proxy <ref> [5, 2] </ref> represents the interface of the object and a Servant [6] provides the object's implementation. <p> loop - m = act_queue_.dequeue () if (m.guard ()) m.call () - Servant 1 m2 () Activation Queue enqueue () dequeue () 1 n Method Request guard () call () 4: m1 () 1 1 M3 There are six key participants in the Active Object pattern: Proxy * A Proxy <ref> [2, 5] </ref> provides an interface that allows clients to invoke publically accessible methods on an Active Object using standard, strongly-typed programming language features, rather than passing loosely-typed messages between threads. <p> A Future object can be garbage collected after the writer and all readers no longer reference the Future. In languages like C++, which do not support garbage collection natively, the Future objects can be reclaimed when they are no longer in use via idioms like Counter Pointer <ref> [2] </ref>. In our Gateway example, the get method invoked on the MQ Proxy ultimately results in the Get::call method being dispatched by the MQ Scheduler, as shown in Step 2 above. Since the MQ Proxy get method returns a value, a Message Future is returned when the client calls it. <p> same &lt;Message_Future_Rep&gt;, which is // created if necessary. void operator= (const Message_Future &f); // ... other constructors/destructors, etc., // Type conversion, which blocks 7 // waiting to obtain the result of the // asynchronous method invocation. operator Message (); -; The Message Future is implemented using the Counted Pointer idiom <ref> [2] </ref>. This idiom simplifies memory management for dynamically allocated C++ objects by using a reference counted Message Future Rep body that is accessed solely through the Message Future handle. <p> Message_Future future = mq.get (); // Do something else here... // Evaluate future in the conversion operator; // may block if the result is not available yet. Message msg = Message (future); 10 Example Resolved Internally, the Gateway software contains Supplier and Consumer Handlers that act as local proxies <ref> [2, 5] </ref> for remote suppliers and consumers, respectively. As shown in remote suppliers, inspect address fields in the messages, and use the address as a key into a Routing Table that identifies which remote consumer should receive the message. <p> This pattern typically uses the Active Object pattern to implement the Synchronous task layer, the Reactor pattern [24] to implement the Asynchronous task layer, and a Producer/Consumer pattern to implement the Queueing layer. The Command Processor pattern <ref> [2] </ref> is similar to the Active Object pattern. Its intent is to separate the issuing of requests from their execution. A command processor, which corresponds to the scheduler, maintains pending service requests, which are implemented as Commands [5]. These are executed on suppliers, which correspond to servants. <p> The Command Processor pattern does not focus on concurrency, however, and clients, the command processor, and suppliers reside in the same thread of control. Thus, there are no proxies that represent the servants to clients. Clients create commands and pass them directly to the command processor. The Broker pattern <ref> [2] </ref> has many of the same components as the Active Object pattern. In particular, clients access Brokers via Proxies and servers implement remote objects via Servants.
Reference: [3] <author> D. C. Schmidt, </author> <title> A Family of Design Patterns for Application-level Gateways, </title> <journal> The Theory and Practice of Object Systems (Special Issue on Patterns and Pattern Languages), </journal> <volume> vol. 2, no. 1, </volume> <year> 1996. </year>
Reference-contexts: A Gateway decouples cooperating components and allows them to interact without having direct dependencies among each other [2]. The Gateway shown in Figure 1 routes messages from one or more supplier processes to one or more consumer processes in a distributed system <ref> [3] </ref>. WIDE AREA NETWORK SATELLITESSATELLITES TRACKINGTRACKING STATIONSTATION PEERSPEERS STATUS INFO COMMANDS BULK DATA TRANSFER LOCAL AREA NETWORK GROUND STATION PEERS GATEWAY In our example, the Gateway, suppliers, and consumers communicate over TCP, which is a connection-oriented protocol [4].
Reference: [4] <author> W. R. Stevens, </author> <title> TCP/IP Illustrated, </title> <booktitle> Volume 1. </booktitle> <address> Reading, Mas-sachusetts: </address> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: WIDE AREA NETWORK SATELLITESSATELLITES TRACKINGTRACKING STATIONSTATION PEERSPEERS STATUS INFO COMMANDS BULK DATA TRANSFER LOCAL AREA NETWORK GROUND STATION PEERS GATEWAY In our example, the Gateway, suppliers, and consumers communicate over TCP, which is a connection-oriented protocol <ref> [4] </ref>. Therefore, the Gateway software may encounter flow control from the TCP transport layer when it tries to send data to a remote consumer.
Reference: [5] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: This method is automatically converted into a method request object and passed to another thread of control, where it is converted back into a method and executed on the object implementation. An active object consists of the following components. A Proxy <ref> [5, 2] </ref> represents the interface of the object and a Servant [6] provides the object's implementation. <p> loop - m = act_queue_.dequeue () if (m.guard ()) m.call () - Servant 1 m2 () Activation Queue enqueue () dequeue () 1 n Method Request guard () call () 4: m1 () 1 1 M3 There are six key participants in the Active Object pattern: Proxy * A Proxy <ref> [2, 5] </ref> provides an interface that allows clients to invoke publically accessible methods on an Active Object using standard, strongly-typed programming language features, rather than passing loosely-typed messages between threads. <p> This is typically 5 implemented as a thread-safe bounded-buffer that is shared between the client threads and the thread where the Sched-uler and Servant run. An Activation Queue also provides an iterator that allows the Scheduler to traverse its elements in accordance with the Iterator pattern <ref> [5] </ref>. <p> Message_Future future = mq.get (); // Do something else here... // Evaluate future in the conversion operator; // may block if the result is not available yet. Message msg = Message (future); 10 Example Resolved Internally, the Gateway software contains Supplier and Consumer Handlers that act as local proxies <ref> [2, 5] </ref> for remote suppliers and consumers, respectively. As shown in remote suppliers, inspect address fields in the messages, and use the address as a key into a Routing Table that identifies which remote consumer should receive the message. <p> The Command Processor pattern [2] is similar to the Active Object pattern. Its intent is to separate the issuing of requests from their execution. A command processor, which corresponds to the scheduler, maintains pending service requests, which are implemented as Commands <ref> [5] </ref>. These are executed on suppliers, which correspond to servants. The Command Processor pattern does not focus on concurrency, however, and clients, the command processor, and suppliers reside in the same thread of control. Thus, there are no proxies that represent the servants to clients.
Reference: [6] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.2 ed., </editor> <month> Feb. </month> <year> 1998. </year>
Reference-contexts: An active object consists of the following components. A Proxy [5, 2] represents the interface of the object and a Servant <ref> [6] </ref> provides the object's implementation. Both the Proxy and the Servant run in separate threads so that method invocation and method execution can run concurrently: the proxy runs in the client thread, while the servant runs in a different thread. <p> The Proxy then passes the Method Request to the Scheduler, which enqueues it on the Activation Queue. If the method is defined as a two-way <ref> [6] </ref>, a binding to a Future is returned to the client that invoked the method. No Future is returned if a method is defined as a oneway, i.e., it has no return values. 2. Method execution: In this phase, the Scheduler runs continuously in a different thread than its clients. <p> The Scheduler then assigns a new job as soon as one is available. 12 Known Uses The following are specific known uses of the Active Object pattern: CORBA ORBs: The Active Object pattern has been used to implement concurrent ORB middleware frameworks, such as CORBA <ref> [6] </ref> and DCOM [16]. For instance, the TAO ORB [17] implements the Active Object pattern for its default concurrency model [18]. In this design, CORBA stubs correspond to the Active Object pattern's Proxies, which transform remote operation invocations into CORBA Requests.
Reference: [7] <author> R. H. Halstead, Jr., </author> <title> Multilisp: A Language for Concurrent Symbolic Computation, </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> vol. 7, </volume> <pages> pp. 501538, </pages> <month> Oct. </month> <year> 1985. </year>
Reference-contexts: A Servant method is invoked when its corresponding Method Request is executed by a Scheduler; thus, Servants execute in the Scheduler's thread of control. Servants may provide other methods used by Method Requests to implement their guards. Future * A Future <ref> [7, 8] </ref> allows a client to obtain the results of method invocations after the Servant finishes executing the method. When a client invokes methods through a Proxy, a Future is returned immediately to the client. The Future reserves space for the invoked method to store its results.
Reference: [8] <author> B. Liskov and L. Shrira, </author> <title> Promises: Linguistic Support for Efficient Asynchronous Procedure Calls in Distributed Systems, </title> <booktitle> in Proceedings of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 260 267, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: A Servant method is invoked when its corresponding Method Request is executed by a Scheduler; thus, Servants execute in the Scheduler's thread of control. Servants may provide other methods used by Method Requests to implement their guards. Future * A Future <ref> [7, 8] </ref> allows a client to obtain the results of method invocations after the Servant finishes executing the method. When a client invokes methods through a Proxy, a Future is returned immediately to the client. The Future reserves space for the invoked method to store its results.
Reference: [9] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: m.call () - MQMQ ServantServant INVISIBLEINVISIBLE TOTO CLIENTSCLIENTS VISIBLEVISIBLE TOTO CLIENTSCLIENTS 1: enqueue (Put) 2: enqueue (new Put) 3: dispatch () put () ActivationActivation QueueQueue enqueue () dequene () PutPut GetGet MethodMethod RequestRequest guard () call () nn 4: put () this section uses reusable components from the ACE framework <ref> [9] </ref>. ACE provides a rich set of reusable C++ wrappers and framework components that perform common communication software tasks across a wide range of OS platforms. 1. Implement the Servant: A Servant defines the behavior and state that is being modeled as an Active Object. <p> ACE Framework: Reusable implementations of the Method Request, Activation Queue, and Future components in the Active Object pattern are provided in the ACE framework <ref> [9] </ref>. These components have been used to implement many production distributed systems. Siemens MedCom: The Active Object pattern is used in the Siemens MedCom framework, which provides a black-box component-oriented framework for electronic medical systems [20].
Reference: [10] <author> P. </author> <title> America, Inheritance and Subtyping in a Parallel Object-Oriented Language, </title> <booktitle> in ECOOP'87 Conference Proceedings, </booktitle> <pages> pp. 234242, </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: For instance, in our Gateway example, the methods in the MQ Servant class do not include any code that implements synchronization. This class only provides methods that implement the Servant's functionality and check its internal state. This design avoids the inheritance anomaly <ref> [10, 11, 12, 13] </ref> problem, which inhibits the reuse of Servant implementations if subclasses require different synchronization policies. Thus, a change to the synchronization constraints of the Active Object need not affect its servant implementation. 2.
Reference: [11] <author> D. G. Kafura and K. H. Lee, </author> <title> Inheritance in Actor-Based Concurrent Object-Oriented Languages, </title> <booktitle> in ECOOP'89 Conference Proceedings, </booktitle> <pages> pp. 131145, </pages> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: For instance, in our Gateway example, the methods in the MQ Servant class do not include any code that implements synchronization. This class only provides methods that implement the Servant's functionality and check its internal state. This design avoids the inheritance anomaly <ref> [10, 11, 12, 13] </ref> problem, which inhibits the reuse of Servant implementations if subclasses require different synchronization policies. Thus, a change to the synchronization constraints of the Active Object need not affect its servant implementation. 2.
Reference: [12] <author> S. Matsuoka, K. Wakita, and A. Yonezawa, </author> <title> Analysis of Inheritance Anomaly in Concurrent Object-Oriented Languages, </title> <journal> OOPS Messenger, </journal> <year> 1991. </year>
Reference-contexts: For instance, in our Gateway example, the methods in the MQ Servant class do not include any code that implements synchronization. This class only provides methods that implement the Servant's functionality and check its internal state. This design avoids the inheritance anomaly <ref> [10, 11, 12, 13] </ref> problem, which inhibits the reuse of Servant implementations if subclasses require different synchronization policies. Thus, a change to the synchronization constraints of the Active Object need not affect its servant implementation. 2.
Reference: [13] <author> M. Papathomas, </author> <title> Concurrency Issues in Object-Oriented Languages, in Object Oriented Development (D. Tsichritzis, </title> <publisher> ed.), </publisher> <pages> pp. </pages> <institution> 207245, Centre Universitaire D'Informatique, University of Geneva, </institution> <year> 1989. </year>
Reference-contexts: For instance, in our Gateway example, the methods in the MQ Servant class do not include any code that implements synchronization. This class only provides methods that implement the Servant's functionality and check its internal state. This design avoids the inheritance anomaly <ref> [10, 11, 12, 13] </ref> problem, which inhibits the reuse of Servant implementations if subclasses require different synchronization policies. Thus, a change to the synchronization constraints of the Active Object need not affect its servant implementation. 2.
Reference: [14] <author> W. R. Stevens, </author> <title> UNIX Network Programming, Second Edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: The Scheduler thread plays the role of consumer, de-queueing Method Requests when their guards evaluate to true and invoking their call hooks to execute Servant methods. The Activation Queue is designed as a bounded-buffer using condition variables and mutexes <ref> [14] </ref>. Therefore, the Scheduler thread will block for msec timeout amount of time when trying to remove Method Requests from an empty Activation Queue.
Reference: [15] <author> R. G. Lavender and D. G. Kafura, </author> <title> A Polymorphic Future and First-Class Function Type for Concurrent Object-Oriented Programming in C++, in Forthcoming, </title> <note> 1995. http://www.cs.utexas.edu/users/lavender/papers/futures.ps. </note>
Reference-contexts: However, message passing is typically more tedious and error-prone since application developers are responsible for programming the Proxy and Servant logic, rather than letting the Active Object developers write this code. Polymorphic futures: A Polymorphic Future <ref> [15] </ref> allows parameterization of the eventual result type represented by the Future and enforces the necessary synchronization. In particular, a Polymorphic Future result value provides write-once, read-many synchronization. Whether a client blocks on a future depends on whether or not a result value has been computed.
Reference: [16] <author> D. </author> <title> Box, Essential COM. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1997. </year>
Reference-contexts: The Scheduler then assigns a new job as soon as one is available. 12 Known Uses The following are specific known uses of the Active Object pattern: CORBA ORBs: The Active Object pattern has been used to implement concurrent ORB middleware frameworks, such as CORBA [6] and DCOM <ref> [16] </ref>. For instance, the TAO ORB [17] implements the Active Object pattern for its default concurrency model [18]. In this design, CORBA stubs correspond to the Active Object pattern's Proxies, which transform remote operation invocations into CORBA Requests.
Reference: [17] <author> D. C. Schmidt, D. L. Levine, and S. Mungee, </author> <title> The Design and Performance of Real-Time Object Request Brokers, </title> <journal> Computer Communications, </journal> <volume> vol. 21, </volume> <pages> pp. 294324, </pages> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: For instance, the TAO ORB <ref> [17] </ref> implements the Active Object pattern for its default concurrency model [18]. In this design, CORBA stubs correspond to the Active Object pattern's Proxies, which transform remote operation invocations into CORBA Requests.
Reference: [18] <author> D. C. Schmidt, </author> <title> Evaluating Architectures for Multi-threaded CORBA Object Request Brokers, </title> <journal> Communications of the ACM special issue on CORBA, </journal> <volume> vol. 41, </volume> <month> Oct. </month> <year> 1998. </year>
Reference-contexts: For instance, the TAO ORB [17] implements the Active Object pattern for its default concurrency model <ref> [18] </ref>. In this design, CORBA stubs correspond to the Active Object pattern's Proxies, which transform remote operation invocations into CORBA Requests. The TAO ORB Core's Reactor is the Sched-uler and the socket queues in the ORB Core correspond to the Activation Queues.
Reference: [19] <institution> Object Management Group, </institution> <note> CORBA Messaging Specification, OMG Document orbos/98-05-05 ed., </note> <month> May </month> <year> 1998. </year>
Reference-contexts: Clients can either make synchronous two-way invocations, which block the calling thread until the operation returns, or they can make asynchronous method invocations, which return a Poller future object that can be evaluated at a later point <ref> [19] </ref>. ACE Framework: Reusable implementations of the Method Request, Activation Queue, and Future components in the Active Object pattern are provided in the ACE framework [9]. These components have been used to implement many production distributed systems.
Reference: [20] <author> P. Jain, S. Widoff, and D. C. Schmidt, </author> <title> The Design and Performance of MedJava Experience Developing Performance-Sensitive Distributed Applications with Java, </title> <journal> IEE/BCS Distributed Systems Engineering Journal, </journal> <year> 1998. </year>
Reference-contexts: These components have been used to implement many production distributed systems. Siemens MedCom: The Active Object pattern is used in the Siemens MedCom framework, which provides a black-box component-oriented framework for electronic medical systems <ref> [20] </ref>. MedCom employ the Active Object pattern 10 in conjunction with the Command Processor pattern to sim-plify client windowing applications that access patient information on various medical servers. Siemens Call Center management system: This system uses the thread pool variant of the Active Object pattern.
Reference: [21] <author> G. Agha, </author> <title> A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Siemens Call Center management system: This system uses the thread pool variant of the Active Object pattern. Actors: The Active Object pattern has been used to implement Actors <ref> [21] </ref>. An Actor contains a set of instance variables and behaviors that react to messages sent to an Actor by other Actors. Messages sent to an Actor are queued in the Actor's message queue. In the Actor model, messages are executed in order of arrival by the current behavior.
Reference: [22] <author> C. Tomlinson and V. Singh, </author> <title> Inheritance and Synchronization with Enabled-Sets, </title> <booktitle> in OOPSLA'89 Conference Proceedings, </booktitle> <pages> pp. 103112, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Each behavior nominates a replacement behavior to execute the next message, possibly before the nominating behavior has completed execution. Variations on the basic Actor model allow messages in the message queue to be executed based on criteria other than arrival order <ref> [22] </ref>. When the Active Object pattern is used to implement Actors, the Scheduler corresponds to the Actor scheduling mechanism, Method Request correspond to the behaviors defined for an Actor, and the Servant is the set of instance variables that collectively represent the state of an Actor [23].
Reference: [23] <author> D. Kafura, M. Mukherji, and G. Lavender, </author> <title> ACT++: A Class Library for Concurrent Programming in C++ using Actors, </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pp. 4756, </pages> <month> Octo-ber </month> <year> 1992. </year>
Reference-contexts: When the Active Object pattern is used to implement Actors, the Scheduler corresponds to the Actor scheduling mechanism, Method Request correspond to the behaviors defined for an Actor, and the Servant is the set of instance variables that collectively represent the state of an Actor <ref> [23] </ref>. The Proxy is simply a strongly-typed mechanism used to pass a message to an Actor. 13 Consequences The Active Object pattern provides the following benefits: Enhance application concurrency and simplify synchronization complexity: Concurrency is enhanced by allowing client threads and asynchronous method executions to run simultaneously.
Reference: [24] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Monitors are generally more efficient than Active Objects since they incur less context switching and data movement overhead. However, it is harder to add a distribution boundary between client and server threads using the Monitor pattern. The Reactor pattern <ref> [24] </ref> is responsible for demultiplexing and dispatching of multiple event handlers that are triggered when it is possible to initiate an operation without blocking. This pattern is often used in lieu of the Active Object pattern to schedule callback operations to passive objects. <p> The Half-Sync/Half-Async pattern [25] is an architectural pattern that decouples synchronous I/O from asynchronous I/O in a system to simplify concurrent programming effort without degrading execution efficiency. This pattern typically uses the Active Object pattern to implement the Synchronous task layer, the Reactor pattern <ref> [24] </ref> to implement the Asynchronous task layer, and a Producer/Consumer pattern to implement the Queueing layer. The Command Processor pattern [2] is similar to the Active Object pattern. Its intent is to separate the issuing of requests from their execution.
Reference: [25] <author> D. C. Schmidt and C. D. Cranor, Half-Sync/Half-Async: </author> <title> an Architectural Pattern for Efficient and Well-structured Concurrent I/O, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 110, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: This pattern is often used in lieu of the Active Object pattern to schedule callback operations to passive objects. It can also be used in conjunction of the Active Object pattern to form the Half-Sync/Half-Async pattern described in the next paragraph. The Half-Sync/Half-Async pattern <ref> [25] </ref> is an architectural pattern that decouples synchronous I/O from asynchronous I/O in a system to simplify concurrent programming effort without degrading execution efficiency.
Reference: [26] <author> Paul E. McKinney, </author> <title> A Pattern Language for Parallelizing Existing Programs on Shared Memory Multiprocessors, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlis-sides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: The primary difference between the Broker pattern and the Active Object pattern is that there's a distribution boundary between proxies and servants in the Broker pattern vs. a threading boundary between proxies and servants in the Active Object pattern. The Mutual Exclusion (Mutex) pattern <ref> [26] </ref> is a simple locking pattern that is often used in lieu of Active Objects when implementing concurrent Passive Objects, also known as Monitors. The Mutex pattern can occur in slightly different forms, such as a spin lock or a semaphore.
References-found: 26

