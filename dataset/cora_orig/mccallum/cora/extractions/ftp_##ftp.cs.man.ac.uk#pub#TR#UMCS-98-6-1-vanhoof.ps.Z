URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-vanhoof.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Email: e-mail: fwimvh,dannyd,berng@cs.kuleuven.ac.be  
Title: Bottom Up Specialisation: Towards General Foundations  
Author: Wim Vanhoof Danny De Schreye Bern Martens 
Address: Celestijnenlaan 200A, B-3001, Heverlee, Belgium.  
Affiliation: Department of Computer Science, Katholieke Universiteit Leuven,  
Abstract: In this abstract, we develop a solid theoretical foundation for a bottom-up program specialisation technique, capable of specialising a logic program w.r.t. a set of unit clauses. Extending a well-known operator, originally introduced for composing logic programs, we define a bottom-up partial deduction operator and prove correctness of the transformation with respect to the S-semantics. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> The S-semantics approach: </title> <journal> Theory and applications. Journal of Logic Programming, </journal> 19/20:149-197, 1994. 
Reference-contexts: In a subsequent section, we provide a formal framework for such bottom-up specialisation and pinpoint a condition necessary for the correctness of the transformation. Section 4 briefly describes a concrete instance of our framework and addresses the relation with compositional semantics <ref> [2, 1] </ref> and top down partial deduction. Throughout this abstract, we consider definite logic programs. 2 Motivating Bottom Up Specialisation In this section, we recapitulate briefly our motivation for a bottom up speciali-sation scheme. More information can be found in [10, 12]. <p> The issues of control and integration with top-down specialisa-tion will be elaborated in future work. First, we recall the concept of a non-ground T P operator, acting on sets of clauses instead of atoms as in the context of compositional semantics (see e.g. <ref> [2, 1] </ref>). In what follows, HC denotes the set of all Horn clauses over a fixed first order language L, underlying a given definite program P . Let j be the variant relation on HC. For any set S, 2 S denotes its powerset. Definition 1. <p> there exist A 1 B 1 m 1 ,. . . , A n B n m n fresh variants of clauses in S, such that = mgu ((B 1 ; : : : ; B n ); (A 1 ; : : : ; A n )) exists.g From <ref> [1] </ref>, we know that T C P is continuous and its least fixpoint T C P " ! exists. By definition, T C P " ! is a set of unit clauses denoting the least S-Herbrand model [6, 1] of P , M s (P ). <p> By definition, T C P " ! is a set of unit clauses denoting the least S-Herbrand model <ref> [6, 1] </ref> of P , M s (P ). That is, M s (P ) = Heads (T C P " !) where Heads is a function that projects a set of (unit) clauses onto their heads. <p> A worked out proof can be found in the full version of this paper. In <ref> [6, 1, 2] </ref> the equivalence between the operational semantics and the S-semantics is established. <p> We enrich the compositional T C P operator <ref> [2, 1] </ref> with abstraction and thus obtain a generic bottom-up partial deduction operator A C P . We prove soundness and completeness of the transformation provided a particular condition is imposed on A C P . <p> While in general A C P is not continuous, it can be defined finitary. This is mandatory if we plan to use it for program transformation, since the transformation as well as the resulting program must be finite. As noted in <ref> [2, 1] </ref>, the result of computing the compositonal semantics of P , T C P " !, is in essence a set of resultants which can be seen as the result of a top down partial deduction of P w.r.t. a set of atomic goals of the form p (X 1
Reference: 2. <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> A compositional semantics for logic programs. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 122(1-2):3-47, </address> <year> 1994. </year>
Reference-contexts: In a subsequent section, we provide a formal framework for such bottom-up specialisation and pinpoint a condition necessary for the correctness of the transformation. Section 4 briefly describes a concrete instance of our framework and addresses the relation with compositional semantics <ref> [2, 1] </ref> and top down partial deduction. Throughout this abstract, we consider definite logic programs. 2 Motivating Bottom Up Specialisation In this section, we recapitulate briefly our motivation for a bottom up speciali-sation scheme. More information can be found in [10, 12]. <p> The issues of control and integration with top-down specialisa-tion will be elaborated in future work. First, we recall the concept of a non-ground T P operator, acting on sets of clauses instead of atoms as in the context of compositional semantics (see e.g. <ref> [2, 1] </ref>). In what follows, HC denotes the set of all Horn clauses over a fixed first order language L, underlying a given definite program P . Let j be the variant relation on HC. For any set S, 2 S denotes its powerset. Definition 1. <p> A worked out proof can be found in the full version of this paper. In <ref> [6, 1, 2] </ref> the equivalence between the operational semantics and the S-semantics is established. <p> We enrich the compositional T C P operator <ref> [2, 1] </ref> with abstraction and thus obtain a generic bottom-up partial deduction operator A C P . We prove soundness and completeness of the transformation provided a particular condition is imposed on A C P . <p> While in general A C P is not continuous, it can be defined finitary. This is mandatory if we plan to use it for program transformation, since the transformation as well as the resulting program must be finite. As noted in <ref> [2, 1] </ref>, the result of computing the compositonal semantics of P , T C P " !, is in essence a set of resultants which can be seen as the result of a top down partial deduction of P w.r.t. a set of atomic goals of the form p (X 1
Reference: 3. <author> Y. Cosmadopoulos, M. Sergot, and R. W. Southwick. </author> <title> Data-driven transformation of meta-interpreters: A sketch. </title> <editor> In H. Boley and M. M. Richter, editors, </editor> <booktitle> Proceedings of the International Workshop on Processing Declarative Knowledge (PDK'91), volume 567 of LNAI, </booktitle> <pages> pages 301-308. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Or it/they will likely contain no information (all arguments free) since the latter flows bottom-up (further complicating top down control). So, in a number of cases, proceeding bottom-up is a more natural solution. Bottom-up transformation and specialisation has been considered occasionally before (see e.g. <ref> [8, 3] </ref>). However, to the best of our knowledge, our ongoing effort is the first attempt to achieve these in a completely general and automatic way. 3 Defining the Framework As mentioned in Section 1, this abstract outlines a firm foundation for bottom-up transformation.
Reference: 4. <author> D. De Schreye, M. Leuschel, and B. Martens. </author> <title> Tutorial on program specialisation (abstract). </title> <editor> In J.W. Lloyd, editor, </editor> <booktitle> Proceedings ILPS'95, </booktitle> <pages> pages 615-616, </pages> <address> Portland, Oregon, December 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: 1 Introduction Partial deduction is an important transformation technique for logic programs, capable of removing inefficiencies from programs <ref> [7, 9, 4] </ref>. As an on-line special-isation technique, it is based on an evaluation mechanism for logic programs. The input to a typical partial deducer is a program and a partially instantiated query.
Reference: 5. <author> F. Denis and J.P. Delahaye. </author> <title> Unfolding, procedural and fixpoint semantics of logic programs. </title> <booktitle> In 8th Annual Symposium on Theoretical Aspects of Computer Science, volume 480 of LNCS, </booktitle> <pages> pages 511-522. </pages> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: Then, if A C P "n 0 is inside-closed, M s (P 0 ) = M s (P ), thus P 0 is sound and complete w.r.t. P . Proof. (Outline). Using Proposition II.1 from <ref> [5] </ref>, we can prove by induction that for all i n 0 : M s (P i ) M s (P ) where P i = A C P "i [ Res (A C P "i), and thus M s (P 0 ) M s (P ). for every k; T
Reference: 6. <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative modeling of the operational behaviour of logic programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: By definition, T C P " ! is a set of unit clauses denoting the least S-Herbrand model <ref> [6, 1] </ref> of P , M s (P ). That is, M s (P ) = Heads (T C P " !) where Heads is a function that projects a set of (unit) clauses onto their heads. <p> A worked out proof can be found in the full version of this paper. In <ref> [6, 1, 2] </ref> the equivalence between the operational semantics and the S-semantics is established.
Reference: 7. <author> J. Gallagher. </author> <title> Specialisation of logic programs: A tutorial. </title> <booktitle> In Proceedings PEPM'93, ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 88-98, </pages> <address> Copenhagen, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction Partial deduction is an important transformation technique for logic programs, capable of removing inefficiencies from programs <ref> [7, 9, 4] </ref>. As an on-line special-isation technique, it is based on an evaluation mechanism for logic programs. The input to a typical partial deducer is a program and a partially instantiated query.
Reference: 8. <author> H. J. Komorowski. </author> <title> Synthesis of programs in the partial deduction framework. </title> <editor> In Michael R. Lowry and Robert D. McCartney, editors, </editor> <booktitle> Automating Software Design, </booktitle> <pages> pages 377-403. </pages> <publisher> AAAI Press, </publisher> <year> 1991. </year>
Reference-contexts: Or it/they will likely contain no information (all arguments free) since the latter flows bottom-up (further complicating top down control). So, in a number of cases, proceeding bottom-up is a more natural solution. Bottom-up transformation and specialisation has been considered occasionally before (see e.g. <ref> [8, 3] </ref>). However, to the best of our knowledge, our ongoing effort is the first attempt to achieve these in a completely general and automatic way. 3 Defining the Framework As mentioned in Section 1, this abstract outlines a firm foundation for bottom-up transformation.
Reference: 9. <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial evaluation in logic programming. </title> <journal> Journal of Logic Programming, </journal> 11(3&4):217-242, 1991. 
Reference-contexts: 1 Introduction Partial deduction is an important transformation technique for logic programs, capable of removing inefficiencies from programs <ref> [7, 9, 4] </ref>. As an on-line special-isation technique, it is based on an evaluation mechanism for logic programs. The input to a typical partial deducer is a program and a partially instantiated query.
Reference: 10. <author> W. Vanhoof. </author> <title> Bottom up information propagation for partial deduction. </title> <editor> In M. Leuschel, editor, </editor> <booktitle> Proceedings of the International Workshop on Specialization of Declarative Programs and its Applications, </booktitle> <pages> pages 73 - 82, </pages> <address> Port Jefferson, Long Island N.Y. (USA), </address> <month> October </month> <year> 1997. </year> <note> Proceedings available as report CW255, </note> <institution> Dept. of Computer Science, K.U.Leuven, Belgium. </institution>
Reference-contexts: Throughout this abstract, we consider definite logic programs. 2 Motivating Bottom Up Specialisation In this section, we recapitulate briefly our motivation for a bottom up speciali-sation scheme. More information can be found in <ref> [10, 12] </ref>. In a logic program, some information flows naturally in a bottom-up fashion, starting from a set of unit clauses.
Reference: 11. <author> W. Vanhoof and B. Martens. </author> <title> To parse or not to parse. </title> <editor> In N. Fuchs, editor, </editor> <booktitle> Proceedings of LOPSTR'97, </booktitle> <address> Leuven, Belgium, </address> <month> July </month> <year> 1997. </year> <note> To appear in Lecuture Notes in Computer Science series (Springer-Verlag). </note>
Reference-contexts: Achieving it in a general and completely automatic way, however, is far from trivial since control information, needed by the spe-cialiser to decide whether or not to continue the specialisation, might also flow bottom up. In particular, (Vanilla-like) meta-programs typically present difficulties of this kind <ref> [11] </ref>. Consider the following example, taken from [12]: The predicate make list (T; I; R) can be used to create a list of a fixed length (type T ), with each element initialised with I. The result is returned in R.
Reference: 12. <author> W. Vanhoof, B. Martens, D. De Schreye, and K. De Vlaminck. </author> <title> Specialising the other way around. </title> <editor> In J. Jaffar, editor, </editor> <booktitle> Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <address> Manchester, United Kingdom, </address> <month> June </month> <year> 1998. </year> <note> To appear (MIT-Press). </note>
Reference-contexts: Since the new program has less computations to perform, in general, it will be more efficient. In recent work <ref> [12] </ref>, we argued the need for a complementary partial deduction technique, capable of "specialising" a program w.r.t. a set of (unit) clauses instead of a goal. It seems natural to define such a specialisation scheme in terms of bottom-up evaluation. <p> Report number UMCS-98-6-1. http://www.cs.man.ac.uk/cstechrep/titles98.html ?? Supported by a specialisation grant of the Flemish Institute for the Promotion of Scientific-Technological Research in Industry (IWT), Belgium. ? ? ? Senior Research Associate of the Belgian National Fund for Scientific Research. y Partially supported by Esprit project 25503, ARGo In <ref> [12] </ref>, we developed a specific, and very concrete control scheme for such a bot-tom up transformation and provided some examples showing that a combination of bottom up transformation and classical (goal-directed) top down partial deduction achieves at least equally good results as a top down scheme alone, while requiring a much <p> Throughout this abstract, we consider definite logic programs. 2 Motivating Bottom Up Specialisation In this section, we recapitulate briefly our motivation for a bottom up speciali-sation scheme. More information can be found in <ref> [10, 12] </ref>. In a logic program, some information flows naturally in a bottom-up fashion, starting from a set of unit clauses. <p> In particular, (Vanilla-like) meta-programs typically present difficulties of this kind [11]. Consider the following example, taken from <ref> [12] </ref>: The predicate make list (T; I; R) can be used to create a list of a fixed length (type T ), with each element initialised with I. The result is returned in R. <p> The aim of a concrete control scheme should be to maximize the propagation of information in the program, while preserving the least S-Herbrand model. Without abstraction, the process reduces to bottom-up evaluation and P 0 = M s (P ). In <ref> [12] </ref>, such a concrete bottom up specialisation scheme is presented: an operator D P is introduced that, starting from the unit clauses in P , builds a dag D with atoms as nodes, and an edge from A 1 to A 2 if A 2 is an immediate consequence of A
References-found: 12

