URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/all.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Note: Contents  
Abstract-found: 0
Intro-found: 1
Reference: [AL88] <author> Martin Abadi and Leslie Lamport. </author> <title> The Existence of Refinement Mappings. </title> <institution> Research Report SRC29, Digital Equipment Corporation, Systems Research Center, </institution> <month> August </month> <year> 1988. </year> <note> A short version of this paper appeared in the Proceedings of the Third Annual Symposium on Logic in Computer Science. </note>
Reference-contexts: To study realizability, we consider a specification to be a type of infinite game of perfect information [Mar75], where the system plays against the environment and wins if it produces a correct behavior. Under hypotheses justified by previous work <ref> [AL88] </ref>, we prove that specifications are determined games, meaning that one of the players fl Digital Equipment Corporation, Systems Research Center, 130 Lytton Avenue, Palo Alto, CA 94301, USA. y Institut Montefiore, B28, Universite de Liege, B-4000 Liege Sart-Tilman, Belgium. <p> Prima facie, weak realizability is weaker than realizability. However, we prove that the two concepts coincide for Borel specifications and we bound the complexity of realizability. 2.1 Specifications We now describe our model. Since it is similar to ones used in previous work <ref> [Lam86, AL88] </ref>, the description will be brief. Informally, a specification describes the sequences of states that some object under observation can go through. The object could be a screen, a register, or a sheet of paper. <p> Note that even if the complete property is a Borel set, the external part of the complete property is not always a Borel set|it is a 1 1 set. However, we will show that under reasonable and useful restrictions on its specification (from <ref> [AL88] </ref>), the external part of a property is also a Borel set. The first restriction requires that the external part ~ (P ) of the closure of the complete property, P , is closed. <p> Theorem 1 All regular specifications define Borel properties. This theorem provides a partial answer to questions on the expressive power of regular specifications that were left open in previous work <ref> [AL88] </ref>. Its proof is omitted. In the rest of Section 2, we assume that the state space is fixed once and for all.
Reference: [AS85] <author> Bowen Alpern and Fred B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21 </volume> <pages> 181-185, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: A convenient way of expressing the complete property P is as the conjunction of a safety property M [AS86] and a supplementary property L. The supplementary property can be arbitrary and typically expresses liveness requirements <ref> [AS85] </ref>. We advocate the use of transition axioms or state machines for expressing safety properties, and the use of suitable logics, such as various temporal logics [Pnu81], for expressing supplementary properties. Topologically, a safety property is a closed set.
Reference: [AS86] <author> Bowen Alpern and Fred B. Schneider. </author> <title> Recognizing Safety and Liveness. </title> <type> Technical Report TR86-727, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> January </month> <year> 1986. </year>
Reference-contexts: However, all specifications that prescribe the same input/output behavior should be considered equivalent, even if they mention different internal data structures. A convenient way of expressing the complete property P is as the conjunction of a safety property M <ref> [AS86] </ref> and a supplementary property L. The supplementary property can be arbitrary and typically expresses liveness requirements [AS85]. We advocate the use of transition axioms or state machines for expressing safety properties, and the use of suitable logics, such as various temporal logics [Pnu81], for expressing supplementary properties.
Reference: [BHR84] <author> S. D. Brookes, C. A. R. Hoare, and A. W. Roscoe. </author> <title> A theory of communicating sequential processes. </title> <journal> Journal of the ACM, </journal> <volume> 31(7) </volume> <pages> 560-599, </pages> <year> 1984. </year> <month> 14 </month>
Reference-contexts: In other words, the semantics of a process is a set of failures and a set of infinite words. 10 Now, we associate an element (F; I) of the semantic domain with a process P = (P t ; P i ). We use the usual definitions <ref> [BHR84, Hoa85] </ref> to associate a set F of failures with the transition system P t . We denote by L ! (P t ) the set of infinite behaviors allowed by P t .
Reference: [BL69] <author> J. Richard Buchi and Lawrence H. </author> <title> Landweber. Solving sequential condi-tions by finite state strategies. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 138 </volume> <pages> 295-311, </pages> <year> 1969. </year>
Reference-contexts: Martin's theorem involves extremely complex strategies [Fri71]. However, the strategies for safety properties are much simpler than those for arbitrary properties. Moreover, in important "finite cases", the result can be refined to provide finite-state strategies <ref> [BL69, GH82] </ref>. Thus, issues of realizability are relatively simple for safety specifications and propositional specifications, and become more complex as intricate liveness requirements are introduced. From Theorem 5, we derive the following complexity result. Corollary 1 For Borel specifications, the realizability problem is 1 2 .
Reference: [Buc62] <author> J. R. Buchi. </author> <title> On a decision method in restricted second order arithmetic. </title> <booktitle> In Proc. Internat. Congr. Logic, Method and Philos. Sci. </booktitle> <year> 1960, </year> <pages> pages 1-12, </pages> <publisher> Stanford University Press, Stanford, </publisher> <year> 1962. </year>
Reference-contexts: As a special case, we consider finite-state processes linked by synchronous communication, in the style of CCS [Mil80] and CSP [Hoa85]. Specifications consist of finite-state machines plus liveness conditions expressed by Buchi automata <ref> [Buc62, VW86a] </ref> or temporal logic formulas [Pnu81, MW84, VW86a]. We show that the realizability problem for these specifications is hard for pspace with respect to logspace reductions and can be solved in exptime. Our algorithm to check realizability yields a program that satisfies the specification.
Reference: [Dav64] <author> Morton Davis. </author> <title> Infinite games of perfect information. </title> <editor> In M. Dresher, L. S. Shapley, and A. W. Tucker, editors, </editor> <booktitle> Advances in game theory, </booktitle> <pages> pages 85-101, </pages> <publisher> Princeton University Press, </publisher> <address> Princeton, New Jersey, </address> <year> 1964. </year>
Reference-contexts: In view of these differences, it may seem reasonable to introduce a new class of games, perhaps similar to the Davis-Dubins games, where player I has freedom in choosing when to act <ref> [Dav64] </ref>. We find it more convenient to define the games that correspond to specifications as a special case of the basic scenario we have outlined. For a specification S, we define a game G (S) as follows.
Reference: [EC82] <author> E. A. Emerson and E. M. Clarke. </author> <title> Using branching time logic to synthesize synchronization skeletons. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2 </volume> <pages> 241-266, </pages> <year> 1982. </year>
Reference-contexts: One might think that the realizabil-ity problem would have been addressed by work on synthesizing concurrent programs from temporal logic specifications|for example, by Emerson and Clarke <ref> [EC82] </ref> or Manna and Wolper [MW84]. However, these approaches avoid the issue of realizabil-ity by dealing only with closed systems, in which there is no environment. The work of Pnueli and Rosner [PR89a, PR89b] probably comes the closest to describing the realizability problem as we understand it.
Reference: [EJ88] <author> E. Allen Emerson and Charanjit Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proceedings of the 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: The tree automaton is thus a Rabin tree automaton with a number of states exponential in the size of (P t ; P i ) and a linear number of accepting pairs. One then checks whether this tree automaton is nonempty. Using results of Emer-son and Jutla <ref> [EJ88] </ref>, this can done in time polynomial in the size of the tree automaton. Our algorithm for checking realizability is thus in exptime.
Reference: [Fri71] <author> Harvey Friedman. </author> <title> Higher set theory and mathematical practice. </title> <journal> Annals of Mathematical Logic, </journal> <volume> 2 </volume> <pages> 326-357, </pages> <year> 1971. </year>
Reference-contexts: For more common specifications, realizability coincides with weak realizability, and thus appears as a robust notion. Martin has proved that all Borel games are determined [Mar75], which implies: Theorem 5 Weak realizability and realizability are equivalent conditions on Borel specifications. Martin's theorem involves extremely complex strategies <ref> [Fri71] </ref>. However, the strategies for safety properties are much simpler than those for arbitrary properties. Moreover, in important "finite cases", the result can be refined to provide finite-state strategies [BL69, GH82].
Reference: [GH82] <author> Yuri Gurevich and Leo Harrington. </author> <title> Trees, automata, and games. </title> <booktitle> In Proceedings of the 14th Symposium on Theory of Computing, </booktitle> <pages> pages 60-65, </pages> <publisher> ACM, </publisher> <month> May </month> <year> 1982. </year>
Reference-contexts: Martin's theorem involves extremely complex strategies [Fri71]. However, the strategies for safety properties are much simpler than those for arbitrary properties. Moreover, in important "finite cases", the result can be refined to provide finite-state strategies <ref> [BL69, GH82] </ref>. Thus, issues of realizability are relatively simple for safety specifications and propositional specifications, and become more complex as intricate liveness requirements are introduced. From Theorem 5, we derive the following complexity result. Corollary 1 For Borel specifications, the realizability problem is 1 2 .
Reference: [GS53] <author> D. Gale and F.M. Stewart. </author> <title> Infinite games with perfect information. </title> <editor> In H. W. Kuhn and A. W. Tucker, editors, </editor> <booktitle> Contributions to the theory of games, </booktitle> <volume> Volume 2, </volume> <pages> pages 245-266, </pages> <publisher> Princeton University Press, </publisher> <address> Princeton, New Jersey, </address> <year> 1953. </year>
Reference-contexts: We now make this correspondence between games and specifications precise and reap a few results from known theorems on infinite games. Infinite games of perfect information have been considered in mathematics, starting in Polish taverns in the 1930's <ref> [Mau81, GS53] </ref>. Recently, infinite games of perfect information have received much attention in descriptive set theory [Mar77]. In one of the typical scenarios, players I and II alternately produce moves; if the sequence of moves belongs to a certain payoff set A, then player II wins, otherwise player I wins. <p> First, using the Axiom of Choice, Gale and Stewart have constructed games which are not determined|that is, where neither of the players has a winning strategy <ref> [GS53] </ref>. From this result, one derives the existence of weakly realizable but not realizable specifications. Theorem 4 Some specifications are weakly realizable but not realizable. All the examples we know of specifications that are weakly realizable but not realizable seem artificial.
Reference: [Hen87] <author> M. Hennessy. </author> <title> Why testing equivalence is natural. </title> <month> April </month> <year> 1987. </year> <note> Handwritten note. </note>
Reference-contexts: We want our semantics to be fully abstract with respect to parallel composition. That is, we want to be able to determine the semantics of a composed process from its parts, and we want our semantics to be the weakest one compatible with this requirement. Main [Mai86] and Hennessy <ref> [Hen87] </ref> have shown that if we restrict attention only to finite behaviors, then the process semantics satisfying our requirement are essentially failure semantics [Hoa85].
Reference: [Hoa85] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: This in turn implies that the realizability problem is 1 2 |easier than could be expected, but still harder than the consistency problem, which is in 1 1 . As a special case, we consider finite-state processes linked by synchronous communication, in the style of CCS [Mil80] and CSP <ref> [Hoa85] </ref>. Specifications consist of finite-state machines plus liveness conditions expressed by Buchi automata [Buc62, VW86a] or temporal logic formulas [Pnu81, MW84, VW86a]. We show that the realizability problem for these specifications is hard for pspace with respect to logspace reductions and can be solved in exptime. <p> We then describe an algorithm for deciding realizability and discuss the implications of realizability for finite-state verification. 3.1 Process Definition We explore a framework suitable for the verification of finite-state processes. Our framework is in the tradition of CCS [Mil80] and TCSP <ref> [Hoa85] </ref> in that we use handshaking as a communication mechanism. However, we only use a simple process description language. Basic processes are finite automata, and parallel composition is the only operation on processes. <p> Main [Mai86] and Hennessy [Hen87] have shown that if we restrict attention only to finite behaviors, then the process semantics satisfying our requirement are essentially failure semantics <ref> [Hoa85] </ref>. The failures of a process are the pairs (s; X), where s is a sequence of external actions of the process and X is a set of actions the process can refuse after executing s. <p> In other words, the semantics of a process is a set of failures and a set of infinite words. 10 Now, we associate an element (F; I) of the semantic domain with a process P = (P t ; P i ). We use the usual definitions <ref> [BHR84, Hoa85] </ref> to associate a set F of failures with the transition system P t . We denote by L ! (P t ) the set of infinite behaviors allowed by P t .
Reference: [HP85] <author> David Harel and Amir Pnueli. </author> <booktitle> On the development of reactive systems, </booktitle> <pages> pages 477-498. </pages> <publisher> NATO ASI Series, F13, Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: A more subtle danger is specifying the behavior of part of the universe outside the implementor's control. This source of unrealizability is most likely to infect specifications of concurrent systems or reactive systems <ref> [HP85] </ref>. It is this source of unrealizability that concerns us. Formally, a specification is a set of sequences of states, which represents the set of allowed behaviors of a system.
Reference: [HR72] <author> R. Hossley and C. W. Rackoff. </author> <title> The emptiness problem for automata on infinite trees. </title> <booktitle> In Proc. 13th IEEE Symp. on Switching and Automata Theory, </booktitle> <pages> pages 121-124, </pages> <year> 1972. </year>
Reference-contexts: Using results of Emer-son and Jutla [EJ88], this can done in time polynomial in the size of the tree automaton. Our algorithm for checking realizability is thus in exptime. If the tree automaton is indeed nonempty, it follows by the results of Hossley and Rackoff <ref> [HR72] </ref> that there is a finitely generated tree accepted by the automaton. This implies that if a process has an infinite realization, then it also has a finite-state realization.
Reference: [Lam83] <author> Leslie Lamport. </author> <title> What good is temporal logic? In R. </title> <editor> E. A. Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Congress, IFIP, </booktitle> <publisher> North Holland, </publisher> <address> Paris, </address> <month> September </month> <year> 1983. </year>
Reference-contexts: A set of behaviors P is closed under stuttering iff P = (P ). A property (over ) is a set of infinite behaviors closed under stuttering. Closure under stuttering is essential for relating specifications at different levels of abstraction <ref> [Lam83] </ref>. An infinite behavior is terminating iff at most finitely many of its labels differ from .
Reference: [Lam86] <author> Leslie Lamport. </author> <title> A simple approach to specifiying and verifying concurrent systems. </title> <type> Research Report 15, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1986. </year> <month> 15 </month>
Reference-contexts: Prima facie, weak realizability is weaker than realizability. However, we prove that the two concepts coincide for Borel specifications and we bound the complexity of realizability. 2.1 Specifications We now describe our model. Since it is similar to ones used in previous work <ref> [Lam86, AL88] </ref>, the description will be brief. Informally, a specification describes the sequences of states that some object under observation can go through. The object could be a screen, a register, or a sheet of paper.
Reference: [Mai86] <author> Michael G. </author> <title> Main. Demons, Catastrophies and Communicating Processes. </title> <type> Technical Report CU-CS-343-86, </type> <institution> Department of Computer Science, University of Colorado, </institution> <month> July </month> <year> 1986. </year>
Reference-contexts: We want our semantics to be fully abstract with respect to parallel composition. That is, we want to be able to determine the semantics of a composed process from its parts, and we want our semantics to be the weakest one compatible with this requirement. Main <ref> [Mai86] </ref> and Hennessy [Hen87] have shown that if we restrict attention only to finite behaviors, then the process semantics satisfying our requirement are essentially failure semantics [Hoa85].
Reference: [Mar75] <author> Donald A. Martin. </author> <title> Borel determinacy. </title> <journal> Annals of Mathematics, </journal> <volume> 102 </volume> <pages> 363-371, </pages> <year> 1975. </year>
Reference-contexts: However, for liveness requirements, which assert that something good must eventually happen, it is not easy to determine if they constrain the environment. To study realizability, we consider a specification to be a type of infinite game of perfect information <ref> [Mar75] </ref>, where the system plays against the environment and wins if it produces a correct behavior. <p> All the examples we know of specifications that are weakly realizable but not realizable seem artificial. For more common specifications, realizability coincides with weak realizability, and thus appears as a robust notion. Martin has proved that all Borel games are determined <ref> [Mar75] </ref>, which implies: Theorem 5 Weak realizability and realizability are equivalent conditions on Borel specifications. Martin's theorem involves extremely complex strategies [Fri71]. However, the strategies for safety properties are much simpler than those for arbitrary properties.
Reference: [Mar77] <author> Donald A. Martin. </author> <title> Descriptive set theory: projective sets. </title> <editor> In J. Barwise, editor, </editor> <booktitle> Handbook of Mathematical Logic, </booktitle> <pages> pages 783-815, </pages> <publisher> North-Holland Publishing Co., </publisher> <year> 1977. </year>
Reference-contexts: In this case, we let lim oe i be oe. The definition of convergence determines a topology on (; ) ! . We use the following standard topological notions <ref> [Mar77] </ref>. Let oe be a behavior in (; ) ! and let P be a subset of (; ) ! . We say that oe is a limit point of P iff there exist elements oe i in P such that lim oe i = oe. <p> Infinite games of perfect information have been considered in mathematics, starting in Polish taverns in the 1930's [Mau81, GS53]. Recently, infinite games of perfect information have received much attention in descriptive set theory <ref> [Mar77] </ref>. In one of the typical scenarios, players I and II alternately produce moves; if the sequence of moves belongs to a certain payoff set A, then player II wins, otherwise player I wins.
Reference: [Mau81] <author> R. Daniel Mauldin, </author> <title> editor. The Scottish Book. </title> <publisher> Birkhauser, </publisher> <address> Boston, </address> <year> 1981. </year>
Reference-contexts: We now make this correspondence between games and specifications precise and reap a few results from known theorems on infinite games. Infinite games of perfect information have been considered in mathematics, starting in Polish taverns in the 1930's <ref> [Mau81, GS53] </ref>. Recently, infinite games of perfect information have received much attention in descriptive set theory [Mar77]. In one of the typical scenarios, players I and II alternately produce moves; if the sequence of moves belongs to a certain payoff set A, then player II wins, otherwise player I wins.
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus of Communicating Systems. </title> <booktitle> Volume 92 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: This in turn implies that the realizability problem is 1 2 |easier than could be expected, but still harder than the consistency problem, which is in 1 1 . As a special case, we consider finite-state processes linked by synchronous communication, in the style of CCS <ref> [Mil80] </ref> and CSP [Hoa85]. Specifications consist of finite-state machines plus liveness conditions expressed by Buchi automata [Buc62, VW86a] or temporal logic formulas [Pnu81, MW84, VW86a]. We show that the realizability problem for these specifications is hard for pspace with respect to logspace reductions and can be solved in exptime. <p> We then describe an algorithm for deciding realizability and discuss the implications of realizability for finite-state verification. 3.1 Process Definition We explore a framework suitable for the verification of finite-state processes. Our framework is in the tradition of CCS <ref> [Mil80] </ref> and TCSP [Hoa85] in that we use handshaking as a communication mechanism. However, we only use a simple process description language. Basic processes are finite automata, and parallel composition is the only operation on processes. <p> However, we only use a simple process description language. Basic processes are finite automata, and parallel composition is the only operation on processes. This is not really a restriction, since finite-state CCS or TCSP programs can be systematically transformed into transition systems <ref> [Mil80, Mil84, Old85] </ref>. One substantial difference between our framework and more usual ones is that we consider the infinite behaviors of the processes and allow a restriction on these behaviors as part of the specification of processes.
Reference: [Mil84] <author> R. Milner. </author> <title> A complete inference system for a class of regular behaviours. </title> <journal> Journal of Compututer and System Science, </journal> <volume> 28 </volume> <pages> 439-466, </pages> <year> 1984. </year>
Reference-contexts: However, we only use a simple process description language. Basic processes are finite automata, and parallel composition is the only operation on processes. This is not really a restriction, since finite-state CCS or TCSP programs can be systematically transformed into transition systems <ref> [Mil80, Mil84, Old85] </ref>. One substantial difference between our framework and more usual ones is that we consider the infinite behaviors of the processes and allow a restriction on these behaviors as part of the specification of processes.
Reference: [MW84] <author> Z. Manna and P. Wolper. </author> <title> Synthesis of communicating processes from temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(1) </volume> <pages> 68-93, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: As a special case, we consider finite-state processes linked by synchronous communication, in the style of CCS [Mil80] and CSP [Hoa85]. Specifications consist of finite-state machines plus liveness conditions expressed by Buchi automata [Buc62, VW86a] or temporal logic formulas <ref> [Pnu81, MW84, VW86a] </ref>. We show that the realizability problem for these specifications is hard for pspace with respect to logspace reductions and can be solved in exptime. Our algorithm to check realizability yields a program that satisfies the specification. <p> For instance, one could state that in all infinite behaviors some action should be taken infinitely often. This can be done either by using an automaton on infinite words|such as a Buchi automaton [Buc62]|or by using a propositional temporal logic formula <ref> [Pnu81, MW84] </ref>, which can be converted to a Buchi automaton [WVS83, VW88]. The specification of a process is then the combination of a finite automaton describing the allowed transitions of the system 8 and a Buchi automaton restricting the infinite behaviors of the system. <p> One might think that the realizabil-ity problem would have been addressed by work on synthesizing concurrent programs from temporal logic specifications|for example, by Emerson and Clarke [EC82] or Manna and Wolper <ref> [MW84] </ref>. However, these approaches avoid the issue of realizabil-ity by dealing only with closed systems, in which there is no environment. The work of Pnueli and Rosner [PR89a, PR89b] probably comes the closest to describing the realizability problem as we understand it.
Reference: [Old85] <author> E. R. Olderog. </author> <title> Process theory: semantics, specification and verification. </title> <booktitle> In Proc. Advanced School on Current Trends in Concurrency, </booktitle> <pages> pages 442-509, </pages> <booktitle> Volume 224, </booktitle> <publisher> LNCS, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: However, we only use a simple process description language. Basic processes are finite automata, and parallel composition is the only operation on processes. This is not really a restriction, since finite-state CCS or TCSP programs can be systematically transformed into transition systems <ref> [Mil80, Mil84, Old85] </ref>. One substantial difference between our framework and more usual ones is that we consider the infinite behaviors of the processes and allow a restriction on these behaviors as part of the specification of processes.
Reference: [Par85] <author> J. Parrow. </author> <title> Fairness Properties in Process Algebra. </title> <type> PhD thesis, </type> <institution> University of Uppsala, Sweden, </institution> <year> 1985. </year>
Reference-contexts: In this case, of course, the verification of the abstract descriptions is meaningless, and the implemented system may exhibit unexpected behaviors such as deadlocks. Parrow <ref> [Par85] </ref> has introduced an interesting "infinitary process algebra". It is essentially an extension of CCS with restrictions on infinite behaviors expressed by temporal logic formulas or Buchi automata. The theory of this algebra is quite well developed and is used for verification.
Reference: [Pnu81] <author> A. Pnueli. </author> <title> The temporal semantics of concurrent programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 45-60, </pages> <year> 1981. </year>
Reference-contexts: As a special case, we consider finite-state processes linked by synchronous communication, in the style of CCS [Mil80] and CSP [Hoa85]. Specifications consist of finite-state machines plus liveness conditions expressed by Buchi automata [Buc62, VW86a] or temporal logic formulas <ref> [Pnu81, MW84, VW86a] </ref>. We show that the realizability problem for these specifications is hard for pspace with respect to logspace reductions and can be solved in exptime. Our algorithm to check realizability yields a program that satisfies the specification. <p> The supplementary property can be arbitrary and typically expresses liveness requirements [AS85]. We advocate the use of transition axioms or state machines for expressing safety properties, and the use of suitable logics, such as various temporal logics <ref> [Pnu81] </ref>, for expressing supplementary properties. Topologically, a safety property is a closed set. In most formalisms, such as temporal logics, it is either impossible or unnatural to express properties that are not Borel sets. We therefore assume that the supplementary properties are Borel sets. <p> For instance, one could state that in all infinite behaviors some action should be taken infinitely often. This can be done either by using an automaton on infinite words|such as a Buchi automaton [Buc62]|or by using a propositional temporal logic formula <ref> [Pnu81, MW84] </ref>, which can be converted to a Buchi automaton [WVS83, VW88]. The specification of a process is then the combination of a finite automaton describing the allowed transitions of the system 8 and a Buchi automaton restricting the infinite behaviors of the system.
Reference: [PR89a] <author> Amir Pnueli and Roni Rosner. </author> <title> On the synthesis of a reactive module. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: However, these approaches avoid the issue of realizabil-ity by dealing only with closed systems, in which there is no environment. The work of Pnueli and Rosner <ref> [PR89a, PR89b] </ref> probably comes the closest to describing the realizability problem as we understand it. There, one finds an elegant approach for synthesizing reactive modules from finite-state specifications. Their synthesis method uses automata on trees and is similar to our method for checking realizability in the finite-state case.
Reference: [PR89b] <author> Amir Pnueli and Roni Rosner. </author> <title> On the synthesis of an asynchronous reactive module. </title> <booktitle> In Proceedings of ICALP 89, Stresa, </booktitle> <month> July </month> <year> 1989. </year>
Reference-contexts: However, these approaches avoid the issue of realizabil-ity by dealing only with closed systems, in which there is no environment. The work of Pnueli and Rosner <ref> [PR89a, PR89b] </ref> probably comes the closest to describing the realizability problem as we understand it. There, one finds an elegant approach for synthesizing reactive modules from finite-state specifications. Their synthesis method uses automata on trees and is similar to our method for checking realizability in the finite-state case.
Reference: [Rab69] <author> M. O. Rabin. </author> <title> Decidability of second order theories and automata on infinite trees. </title> <journal> Transaction of the AMS, </journal> <volume> 141 </volume> <pages> 1-35, </pages> <year> 1969. </year>
Reference-contexts: For the latter step, we use a result of Safra [Saf88] to construct a deterministic version of the Buchi automaton. This yields a Rabin automaton <ref> [Rab69] </ref> with a number of states exponential in the size of the Buchi automaton, but with a linear number of accepting pairs.
Reference: [Saf88] <author> Shmuel Safra. </author> <title> On the complexity of omega-automata. </title> <booktitle> In Proceedings of the 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: For the latter step, we use a result of Safra <ref> [Saf88] </ref> to construct a deterministic version of the Buchi automaton. This yields a Rabin automaton [Rab69] with a number of states exponential in the size of the Buchi automaton, but with a linear number of accepting pairs.
Reference: [SVW87] <author> A. P. Sistla, M. Y. Vardi, and P. Wolper. </author> <title> The complementation problem for Buchi automata with applications to temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 217-237, </pages> <year> 1987. </year> <month> 16 </month>
Reference-contexts: We show that the realizability problem for these specifications is hard for pspace with respect to logspace reductions and can be solved in exptime. Our algorithm to check realizability yields a program that satisfies the specification. By contrast, the consistency problem for such specifications is complete in nlogspace <ref> [SVW87] </ref>. 2 The General Case In this section, we study realizability in a general model. We first present our model and show that, under simple hypotheses, specifications in this model allow only Borel sets in a suitable topology on the set of behaviors. <p> To solve the consistency problem, one can check that the product of the transition system and the Buchi automaton is nonempty, which can be done in polynomial time|in fact, the problem is complete for nlogspace <ref> [SVW87] </ref>. <p> This follows from the example of Figure 1, which shows that the universality problem for Buchi automata, which is pspace-complete <ref> [SVW87] </ref>, can be reduced to the realizability problem. 3.5 Realizability and Verification One can verify that a set of finite-state processes operating concurrently satisfies a requirement by verifying that their parallel composition satisfies it.
Reference: [VW86a] <author> M. Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to auto-matic program verification. </title> <booktitle> In Proc. Symp. on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: As a special case, we consider finite-state processes linked by synchronous communication, in the style of CCS [Mil80] and CSP [Hoa85]. Specifications consist of finite-state machines plus liveness conditions expressed by Buchi automata <ref> [Buc62, VW86a] </ref> or temporal logic formulas [Pnu81, MW84, VW86a]. We show that the realizability problem for these specifications is hard for pspace with respect to logspace reductions and can be solved in exptime. Our algorithm to check realizability yields a program that satisfies the specification. <p> As a special case, we consider finite-state processes linked by synchronous communication, in the style of CCS [Mil80] and CSP [Hoa85]. Specifications consist of finite-state machines plus liveness conditions expressed by Buchi automata [Buc62, VW86a] or temporal logic formulas <ref> [Pnu81, MW84, VW86a] </ref>. We show that the realizability problem for these specifications is hard for pspace with respect to logspace reductions and can be solved in exptime. Our algorithm to check realizability yields a program that satisfies the specification.
Reference: [VW86b] <author> M. Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 182-221, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The idea of the proof is, following the ideas in <ref> [VW86b] </ref>, to build a tree automaton on infinite trees that accepts an infinite tree iff it is a realization of the specification P .
Reference: [VW88] <author> M. Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computation paths. </title> <note> 1988. To appear. </note>
Reference-contexts: This can be done either by using an automaton on infinite words|such as a Buchi automaton [Buc62]|or by using a propositional temporal logic formula [Pnu81, MW84], which can be converted to a Buchi automaton <ref> [WVS83, VW88] </ref>. The specification of a process is then the combination of a finite automaton describing the allowed transitions of the system 8 and a Buchi automaton restricting the infinite behaviors of the system. As one would expect, a finite automaton is a realizable specification.
Reference: [WVS83] <author> P. Wolper, M. Y. Vardi, and A. P. Sistla. </author> <title> Reasoning about infinite computation paths. </title> <booktitle> In Proc. 24th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 185-194, </pages> <address> Tucson, </address> <year> 1983. </year> <month> 17 </month>
Reference-contexts: This can be done either by using an automaton on infinite words|such as a Buchi automaton [Buc62]|or by using a propositional temporal logic formula [Pnu81, MW84], which can be converted to a Buchi automaton <ref> [WVS83, VW88] </ref>. The specification of a process is then the combination of a finite automaton describing the allowed transitions of the system 8 and a Buchi automaton restricting the infinite behaviors of the system. As one would expect, a finite automaton is a realizable specification.
References-found: 37

