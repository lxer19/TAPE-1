URL: ftp://ftp.cs.brown.edu/pub/techreports/96/cs96-34.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-96-34.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. Alefeld and J. Herzberger. </author> <title> Introduction to Interval Computations. </title> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1983. </year>
Reference-contexts: See Section 6 of [21] for a discussion on this issue. 2 2 Interval Analysis In this section, we review some basic concepts needed for this paper, including interval arithmetic and the representation of constraints. More information on interval arithmetic can be found in many places (e.g., <ref> [1, 7, 6, 15, 16, 18, 20] </ref>). Our definitions are slightly non-standard. 2.1 Interval Arithmetic We consider &lt; 1 = &lt; [ f1; 1g the set of real numbers extended with the two infinity symbols and the extension of the relation &lt; to this set. <p> For instance, the interval function is the most precise interval extension of addition (i.e., it returns the smallest possible interval containing all real results) while a function always returning <ref> [1; 1] </ref> would be the least accurate. In the following, we assume fixed monotonic interval extensions for the primitive operators and relations (for instance, the interval extension of + is defined by ). In addition, we overload the real symbols and use them for their interval extensions. <p> Example 3 Let c be the constraint x 2 1 + x 2 2 = 1. c is arc-consistent wrt h <ref> [1; 1] </ref> ; [1; 1] i but is not arc-consistent wrt h [1; 1] ; [2; 2] i since, for instance, there is no value r 1 for x 1 in [1; 1] such that r 2 1 + 2 2 = 1. <p> Example 3 Let c be the constraint x 2 1 + x 2 2 = 1. c is arc-consistent wrt h <ref> [1; 1] </ref> ; [1; 1] i but is not arc-consistent wrt h [1; 1] ; [2; 2] i since, for instance, there is no value r 1 for x 1 in [1; 1] such that r 2 1 + 2 2 = 1. <p> Example 3 Let c be the constraint x 2 1 + x 2 2 = 1. c is arc-consistent wrt h <ref> [1; 1] </ref> ; [1; 1] i but is not arc-consistent wrt h [1; 1] ; [2; 2] i since, for instance, there is no value r 1 for x 1 in [1; 1] such that r 2 1 + 2 2 = 1. <p> Let c be the constraint x 2 1 + x 2 2 = 1. c is arc-consistent wrt h <ref> [1; 1] </ref> ; [1; 1] i but is not arc-consistent wrt h [1; 1] ; [2; 2] i since, for instance, there is no value r 1 for x 1 in [1; 1] such that r 2 1 + 2 2 = 1. <p> Example 4 Consider the constraint x 1 + x 2 x 1 = 0: The constraint is not arc-consistent in h <ref> [1; 1] </ref>; [1; 1]i since there is no value r 1 for x 1 which satisfies r 1 + 1 r 1 = 0. On the other hand, the interval constraint X 1 X 2 X 1 0 is box-consistent, since ([1; 1] [1; 1 + ] [1; 1]) " [0; <p> Example 4 Consider the constraint x 1 + x 2 x 1 = 0: The constraint is not arc-consistent in h <ref> [1; 1] </ref>; [1; 1]i since there is no value r 1 for x 1 which satisfies r 1 + 1 r 1 = 0. On the other hand, the interval constraint X 1 X 2 X 1 0 is box-consistent, since ([1; 1] [1; 1 + ] [1; 1]) " [0; 0] 6= <p> On the other hand, the interval constraint X 1 X 2 X 1 0 is box-consistent, since ([1; 1] <ref> [1; 1 + ] </ref> [1; 1]) " [0; 0] 6= ; ([1; 1] [1 ; 1] [1; 1]) " [0; 0] 6= ;: 3.2 Interval Extensions for Box Consistency Box consistency strongly depends on the interval extensions chosen for the constraints and differ ent interval extensions can produce different (often incomparable) <p> arc-consistent in h <ref> [1; 1] </ref>; [1; 1]i since there is no value r 1 for x 1 which satisfies r 1 + 1 r 1 = 0. On the other hand, the interval constraint X 1 X 2 X 1 0 is box-consistent, since ([1; 1] [1; 1 + ] [1; 1]) " [0; 0] 6= ; ([1; 1] [1 ; 1] [1; 1]) " [0; 0] 6= ;: 3.2 Interval Extensions for Box Consistency Box consistency strongly depends on the interval extensions chosen for the constraints and differ ent interval extensions can produce different (often incomparable) tradeoffs between pruning and <p> On the other hand, the interval constraint X 1 X 2 X 1 0 is box-consistent, since ([1; 1] [1; 1 + ] [1; 1]) " [0; 0] 6= ; ([1; 1] <ref> [1 ; 1] </ref> [1; 1]) " [0; 0] 6= ;: 3.2 Interval Extensions for Box Consistency Box consistency strongly depends on the interval extensions chosen for the constraints and differ ent interval extensions can produce different (often incomparable) tradeoffs between pruning and computational complexity. <p> On the other hand, the interval constraint X 1 X 2 X 1 0 is box-consistent, since (<ref> [1; 1] </ref> [1; 1 + ] [1; 1]) " [0; 0] 6= ; ([1; 1] [1 ; 1] [1; 1]) " [0; 0] 6= ;: 3.2 Interval Extensions for Box Consistency Box consistency strongly depends on the interval extensions chosen for the constraints and differ ent interval extensions can produce different (often incomparable) tradeoffs between pruning and computational complexity. <p> The Transistor Modeling Problem The bound-consistency algorithm was applied to find all solutions of the transistor modeling problem. Branching was applied until a safe box or a box of width smaller than 10 8 was obtained. The algorithm returned a unique box x <ref> [1] </ref> = 0.8999999 + [0.485178e-7 , 0.566954e-7] x [3] = 1.00000648 + [0.60195e-9 , 0.43303e-8] x [5] = 7.9999714 + [0.3767867e-7 , 0.4259589e-7] x [7] = 5.00003127 + [0.338646e-8 , 0.848255e-8] x [9] = 2.00005248 + [0.47411e-9 , 0.649037e-8] in the original range [0; 10] 9 , together with a proof
Reference: [2] <author> F. Benhamou, D. McAllester, and P. Van Hentenryck. </author> <title> CLP(Intervals) Revisited. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS-94), </booktitle> <pages> pages 124-138, </pages> <address> Ithaca, NY, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Section 3 describes the branch and prune algorithm while Section 3.5 presents a simple way to prove existence of a solution in a box. 3.1 Box Consistency Box consistency <ref> [2] </ref> is an approximation of arc consistency, a notion well-known in artificial intelligence [13] which states a simple local condition on a constraint c and the set of possible values for each of its variables, say D 1 ; : : : ; D n . <p> Example 3 Let c be the constraint x 2 1 + x 2 2 = 1. c is arc-consistent wrt h [1; 1] ; [1; 1] i but is not arc-consistent wrt h [1; 1] ; <ref> [2; 2] </ref> i since, for instance, there is no value r 1 for x 1 in [1; 1] such that r 2 1 + 2 2 = 1. <p> Moreover, decomposing complex constraints into simple constraints entails a substantial loss in pruning, making this approach not practical on many applications. See <ref> [2] </ref> for experimental results on this approach and their comparison with the approach presented in this paper. The notion of box consistency introduced in [2] is a coarser approximation of arc consistency which provides a much better trade-off between efficiency and pruning. <p> Moreover, decomposing complex constraints into simple constraints entails a substantial loss in pruning, making this approach not practical on many applications. See <ref> [2] </ref> for experimental results on this approach and their comparison with the approach presented in this paper. The notion of box consistency introduced in [2] is a coarser approximation of arc consistency which provides a much better trade-off between efficiency and pruning. It consists in replacing the existential quantification in the above condition by the evaluation of an interval extension of the constraint on the intervals of the existential variables.
Reference: [3] <author> F. Benhamou and W. </author> <title> Older. Applying Interval Arithmetic to Real, Integer and Boolean Constraints. </title> <journal> Journal of Logic Programming, </journal> <note> 1995. To appear. </note>
Reference-contexts: 9r 1 2 I 1 ; : : : ; 9r i1 2 I i1 ; : : : ; 9r i+1 2 I i+1 ; 9r n 2 I n : c (r 1 ; : : : ; r n ) gg: This condition, used in systems like <ref> [19, 3] </ref>, is easily enforced on simple constraints such as x 1 = x 2 + x 3 ; x 1 = x 2 x 3 ; x 1 = x 2 fi x 3 but it is also computationally very expensive for complex constraints with multiple occurrences of the same <p> Branching was applied until a safe box or a box of width smaller than 10 8 was obtained. The algorithm returned a unique box x [1] = 0.8999999 + [0.485178e-7 , 0.566954e-7] x <ref> [3] </ref> = 1.00000648 + [0.60195e-9 , 0.43303e-8] x [5] = 7.9999714 + [0.3767867e-7 , 0.4259589e-7] x [7] = 5.00003127 + [0.338646e-8 , 0.848255e-8] x [9] = 2.00005248 + [0.47411e-9 , 0.649037e-8] in the original range [0; 10] 9 , together with a proof that the box contains a solution.
Reference: [4] <author> O. Caprani and K. Madsen. </author> <title> Mean Value Forms in Interval Analysis. </title> <journal> Computing, </journal> <volume> 25 </volume> <pages> 147-154, </pages> <year> 1980. </year>
Reference-contexts: The proof of the following proposition can be found in <ref> [4] </ref>. Proposition 3 The mean value interval extension of a function, a constraint, or a system of constraints is a monotonic interval extension.
Reference: [5] <author> J.J. Ebers and J.L. Moll. </author> <title> Large-Scale Behaviour of Junction Transistors. </title> <booktitle> IEE Proc., </booktitle> <address> 42:1761--1772, </address> <year> 1954. </year>
Reference-contexts: 1 Introduction The transistor modeling problem of Ebers and Moll <ref> [5] </ref> is the system of nonlinear equations 8 &gt; : (1 x 1 x 2 )x 3 [ exp (x 6 (g 1k g 2k g 3k x 7 10 3 + g 4k x 9 10 3 )) 1 ] g 5k x 1 + g 4k = 0 (1 <p> Branching was applied until a safe box or a box of width smaller than 10 8 was obtained. The algorithm returned a unique box x [1] = 0.8999999 + [0.485178e-7 , 0.566954e-7] x [3] = 1.00000648 + [0.60195e-9 , 0.43303e-8] x <ref> [5] </ref> = 7.9999714 + [0.3767867e-7 , 0.4259589e-7] x [7] = 5.00003127 + [0.338646e-8 , 0.848255e-8] x [9] = 2.00005248 + [0.47411e-9 , 0.649037e-8] in the original range [0; 10] 9 , together with a proof that the box contains a solution. <p> A fundamental topic for future research is thus to determine when bound consistency is more effective than box consistency and, more generally, to characterize the class of nonlinear problems for which these techniques are effective. 5 Conclusion In this paper, the transistor modeling problem from Ebers and Moll <ref> [5] </ref> was reconsidered. This problem consists of 9 nonlinear equations and is challenging both for local and global methods. The problem was tackled by a novel branch and prune algorithm combining techniques from interval methods and constraint satisfaction.
Reference: [6] <author> E.R. Hansen and R.I. Greenberg. </author> <title> An Interval Newton Method. </title> <journal> Appl. Math. Comput., </journal> <volume> 12 </volume> <pages> 89-98, </pages> <year> 1983. </year>
Reference-contexts: See Section 6 of [21] for a discussion on this issue. 2 2 Interval Analysis In this section, we review some basic concepts needed for this paper, including interval arithmetic and the representation of constraints. More information on interval arithmetic can be found in many places (e.g., <ref> [1, 7, 6, 15, 16, 18, 20] </ref>). Our definitions are slightly non-standard. 2.1 Interval Arithmetic We consider &lt; 1 = &lt; [ f1; 1g the set of real numbers extended with the two infinity symbols and the extension of the relation &lt; to this set.
Reference: [7] <author> E.R. Hansen and S. Sengupta. </author> <title> Bounding Solutions of Systems of Equations Using Interval Analysis. </title> <journal> BIT, </journal> <volume> 21 </volume> <pages> 203-211, </pages> <year> 1981. </year>
Reference-contexts: See Section 6 of [21] for a discussion on this issue. 2 2 Interval Analysis In this section, we review some basic concepts needed for this paper, including interval arithmetic and the representation of constraints. More information on interval arithmetic can be found in many places (e.g., <ref> [1, 7, 6, 15, 16, 18, 20] </ref>). Our definitions are slightly non-standard. 2.1 Interval Arithmetic We consider &lt; 1 = &lt; [ f1; 1g the set of real numbers extended with the two infinity symbols and the extension of the relation &lt; to this set. <p> Proposition 3 The mean value interval extension of a function, a constraint, or a system of constraints is a monotonic interval extension. It is interesting to note that box consistency on the mean value interval extension of a system of constraints is closely related to the Hansen-Sengupta's operator <ref> [7] </ref>, which is an improvement over Krawczyk's operator [11]. Hansen and Smith also argue that these operators are more effective when the interval Jacobian of the system is diagonally dominant [8] and they suggest to condition the system S. <p> Branching was applied until a safe box or a box of width smaller than 10 8 was obtained. The algorithm returned a unique box x [1] = 0.8999999 + [0.485178e-7 , 0.566954e-7] x [3] = 1.00000648 + [0.60195e-9 , 0.43303e-8] x [5] = 7.9999714 + [0.3767867e-7 , 0.4259589e-7] x <ref> [7] </ref> = 5.00003127 + [0.338646e-8 , 0.848255e-8] x [9] = 2.00005248 + [0.47411e-9 , 0.649037e-8] in the original range [0; 10] 9 , together with a proof that the box contains a solution.
Reference: [8] <author> E.R. Hansen and R.R. Smith. </author> <title> Interval Arithmetic in Matrix Computation: Part II. </title> <journal> SIAM Journal on Numerical Analysis, </journal> <volume> 4 </volume> <pages> 1-9, </pages> <year> 1967. </year>
Reference-contexts: Hansen and Smith also argue that these operators are more effective when the interval Jacobian of the system is diagonally dominant <ref> [8] </ref> and they suggest to condition the system S. For the purpose of this paper, it is sufficient to abstract the notion of conditioning by the following definition. Definition 12 [Conditioning] Let S be a system of constraints and let ~ I be a box.
Reference: [9] <author> R.B. Kearfott. </author> <title> Preconditioners for the Interval Gauss-Seidel Method. </title> <journal> SIAM Journal of Numerical Analysis, </journal> <volume> 27, </volume> <year> 1990. </year>
Reference-contexts: The conditioning used in our algorithm for a system S in a box ~ I is denoted by cond (S; ~ I) in the following and we use the notation t c (S; ~ I) to denote t (cond (S; ~ I); ~ I). See <ref> [9, 10] </ref> for an extensive coverage of conditioners. 3.3 Bound Consistency Box consistency has been shown to be effective for solving a variety of nonlinear applications [22]. <p> The algorithm returned a unique box x [1] = 0.8999999 + [0.485178e-7 , 0.566954e-7] x [3] = 1.00000648 + [0.60195e-9 , 0.43303e-8] x [5] = 7.9999714 + [0.3767867e-7 , 0.4259589e-7] x [7] = 5.00003127 + [0.338646e-8 , 0.848255e-8] x <ref> [9] </ref> = 2.00005248 + [0.47411e-9 , 0.649037e-8] in the original range [0; 10] 9 , together with a proof that the box contains a solution. The algorithm only performs 118 branchings and takes 2359.80 seconds (roughly 40 minutes) on a Sun Ultra-2 running Solaris.
Reference: [10] <author> R.B. Kearfott. </author> <title> A Review of Preconditioners for the Interval Gauss-Seidel Method. Interval Computations 1, </title> <booktitle> 1 </booktitle> <pages> 59-85, </pages> <year> 1991. </year>
Reference-contexts: It suffices to say that successful attempts require very elaborate procedures, sometimes combining several globally convergent algorithms. Ratschek and Rokne in the same paper [21] propose an interval method which solves the problem globally in the box <ref> [0; 10] </ref> 9 . In particular, they show that there exists a unique solution in this box and they provide a guaranteed error estimate by enclosing the solution in a box whose intervals are of width smaller than 3:2 10 4 . <p> The conditioning used in our algorithm for a system S in a box ~ I is denoted by cond (S; ~ I) in the following and we use the notation t c (S; ~ I) to denote t (cond (S; ~ I); ~ I). See <ref> [9, 10] </ref> for an extensive coverage of conditioners. 3.3 Bound Consistency Box consistency has been shown to be effective for solving a variety of nonlinear applications [22]. <p> The algorithm returned a unique box x [1] = 0.8999999 + [0.485178e-7 , 0.566954e-7] x [3] = 1.00000648 + [0.60195e-9 , 0.43303e-8] x [5] = 7.9999714 + [0.3767867e-7 , 0.4259589e-7] x [7] = 5.00003127 + [0.338646e-8 , 0.848255e-8] x [9] = 2.00005248 + [0.47411e-9 , 0.649037e-8] in the original range <ref> [0; 10] </ref> 9 , together with a proof that the box contains a solution. The algorithm only performs 118 branchings and takes 2359.80 seconds (roughly 40 minutes) on a Sun Ultra-2 running Solaris. This is of course a considerable improvement over the results of Ratschek and Rokne [21]. <p> In particular, the algorithm enforces a local consistency condition called bound consistency which strengthens the notion of box consistency introduced in [22]. The algorithm was applied to find all solutions to the transistor modeling problem and it returned a unique safe box in the range <ref> [0; 10] </ref> 9 in about 40 minutes, performing only 118 branchings. The paper also indicated that bound consistency may be too strong a local condition for many problems, since it is slower than box-consistency on benchmarks from continuation methods [23].
Reference: [11] <author> R. Krawczyk. </author> <title> Newton-Algorithmen zur Bestimmung von Nullstellen mit Fehlerschranken. </title> <journal> Computing, </journal> <volume> 4 </volume> <pages> 187-201, </pages> <year> 1969. </year>
Reference-contexts: It is interesting to note that box consistency on the mean value interval extension of a system of constraints is closely related to the Hansen-Sengupta's operator [7], which is an improvement over Krawczyk's operator <ref> [11] </ref>. Hansen and Smith also argue that these operators are more effective when the interval Jacobian of the system is diagonally dominant [8] and they suggest to condition the system S. For the purpose of this paper, it is sufficient to abstract the notion of conditioning by the following definition.
Reference: [12] <author> O. Lhomme. </author> <title> Consistency Techniques for Numerical Constraint satisfaction Problems. </title> <booktitle> In Proceedings of the 1993 International Joint Conference on Artificial Intelligence, </booktitle> <address> Chamberry, France, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: For some applications however, and for the transistor modeling problem in particular, a better efficiency can be obtained by using a stronger local consistency condition that we call bound consistency. Bound consistency is related to the notions of path-consistency [14] and to the consistency notions presented in <ref> [12] </ref>. It is is defined in terms of box consistency or, more precisely, in terms of whether a system can be made box-consistent.
Reference: [13] <author> A.K. Mackworth. </author> <title> Consistency in Networks of Relations. </title> <journal> Artificial Intelligence, </journal> <volume> 8(1) </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: Section 3 describes the branch and prune algorithm while Section 3.5 presents a simple way to prove existence of a solution in a box. 3.1 Box Consistency Box consistency [2] is an approximation of arc consistency, a notion well-known in artificial intelligence <ref> [13] </ref> which states a simple local condition on a constraint c and the set of possible values for each of its variables, say D 1 ; : : : ; D n .
Reference: [14] <author> U. Montanari. </author> <title> Networks of Constraints : Fundamental Properties and Applications to Picture Processing. </title> <journal> Information Science, </journal> <volume> 7(2) </volume> <pages> 95-132, </pages> <year> 1974. </year>
Reference-contexts: For some applications however, and for the transistor modeling problem in particular, a better efficiency can be obtained by using a stronger local consistency condition that we call bound consistency. Bound consistency is related to the notions of path-consistency <ref> [14] </ref> and to the consistency notions presented in [12]. It is is defined in terms of box consistency or, more precisely, in terms of whether a system can be made box-consistent.
Reference: [15] <author> R.E. Moore. </author> <title> Interval Analysis. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1966. </year>
Reference-contexts: See Section 6 of [21] for a discussion on this issue. 2 2 Interval Analysis In this section, we review some basic concepts needed for this paper, including interval arithmetic and the representation of constraints. More information on interval arithmetic can be found in many places (e.g., <ref> [1, 7, 6, 15, 16, 18, 20] </ref>). Our definitions are slightly non-standard. 2.1 Interval Arithmetic We consider &lt; 1 = &lt; [ f1; 1g the set of real numbers extended with the two infinity symbols and the extension of the relation &lt; to this set. <p> This extension is an example of centered forms which are interval extensions introduced by Moore <ref> [15] </ref> and studied by many authors, since they have important properties. The mean value interval extension of a constraint is parametrized by the intervals for the variables in the constraint.
Reference: [16] <author> R.E. Moore. </author> <title> Methods and Applications of Interval Analysis. </title> <publisher> SIAM Publ., </publisher> <year> 1979. </year>
Reference-contexts: See Section 6 of [21] for a discussion on this issue. 2 2 Interval Analysis In this section, we review some basic concepts needed for this paper, including interval arithmetic and the representation of constraints. More information on interval arithmetic can be found in many places (e.g., <ref> [1, 7, 6, 15, 16, 18, 20] </ref>). Our definitions are slightly non-standard. 2.1 Interval Arithmetic We consider &lt; 1 = &lt; [ f1; 1g the set of real numbers extended with the two infinity symbols and the extension of the relation &lt; to this set.
Reference: [17] <author> R.E. Moore and S.T. Jones. </author> <title> Safe Starting Regions for Iterative Methods. </title> <journal> SIAM Journal on Numerical Analysis, </journal> <volume> 14 </volume> <pages> 1051-1065, </pages> <year> 1977. </year>
Reference-contexts: If I 0 then there exists a zero in hI 0 1 ; : : : ; I 0 n i. A proof of this result can be found in <ref> [17] </ref>. 11 Benchmarks v d range Box-Time Box-Branch.
Reference: [18] <author> A. Neumaier. </author> <title> Interval Methods for Systems of Equations. </title> <booktitle> PHI Series in Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: See Section 6 of [21] for a discussion on this issue. 2 2 Interval Analysis In this section, we review some basic concepts needed for this paper, including interval arithmetic and the representation of constraints. More information on interval arithmetic can be found in many places (e.g., <ref> [1, 7, 6, 15, 16, 18, 20] </ref>). Our definitions are slightly non-standard. 2.1 Interval Arithmetic We consider &lt; 1 = &lt; [ f1; 1g the set of real numbers extended with the two infinity symbols and the extension of the relation &lt; to this set. <p> Our algorithm uses two extensions: the natural interval extension and the mean value interval extension. 3 It is interesting to note that this definition is also related to the theorem of Miranda <ref> [18] </ref>. In this case, box consistency can be seen as replacing universally quantified variables by their intervals. 7 3.2.1 The Natural Interval Extension The simplest interval extension of a function (resp. constraint) is its natural interval extension.
Reference: [19] <author> W. Older and A. Vellino. </author> <title> Extending Prolog with Constraint Arithmetics on Real Intervals. </title> <booktitle> In Canadian Conference on Computer & Electrical Engineering, </booktitle> <address> Ottawa, </address> <year> 1990. </year>
Reference-contexts: 9r 1 2 I 1 ; : : : ; 9r i1 2 I i1 ; : : : ; 9r i+1 2 I i+1 ; 9r n 2 I n : c (r 1 ; : : : ; r n ) gg: This condition, used in systems like <ref> [19, 3] </ref>, is easily enforced on simple constraints such as x 1 = x 2 + x 3 ; x 1 = x 2 x 3 ; x 1 = x 2 fi x 3 but it is also computationally very expensive for complex constraints with multiple occurrences of the same
Reference: [20] <author> H. Ratschek and J. Rokne. </author> <title> New Computer Methods for Global Optimization. </title> <publisher> Ellis Horwood Limited, </publisher> <address> Chichester, </address> <year> 1988. </year>
Reference-contexts: See Section 6 of [21] for a discussion on this issue. 2 2 Interval Analysis In this section, we review some basic concepts needed for this paper, including interval arithmetic and the representation of constraints. More information on interval arithmetic can be found in many places (e.g., <ref> [1, 7, 6, 15, 16, 18, 20] </ref>). Our definitions are slightly non-standard. 2.1 Interval Arithmetic We consider &lt; 1 = &lt; [ f1; 1g the set of real numbers extended with the two infinity symbols and the extension of the relation &lt; to this set.
Reference: [21] <author> H. Ratschek and J. Rokne. </author> <title> Experiments Using Interval Analysis for Solving a Circuit Design Problem. </title> <journal> Journal of Global Optimization, </journal> <volume> 3 </volume> <pages> 501-518, </pages> <year> 1993. </year> <month> 14 </month>
Reference-contexts: Ratschek and Rokne <ref> [21] </ref> summarize various attempts to find a solution to this problem using local methods and these descriptions will not be repeated here. It suffices to say that successful attempts require very elaborate procedures, sometimes combining several globally convergent algorithms. Ratschek and Rokne in the same paper [21] propose an interval method <p> Ratschek and Rokne <ref> [21] </ref> summarize various attempts to find a solution to this problem using local methods and these descriptions will not be repeated here. It suffices to say that successful attempts require very elaborate procedures, sometimes combining several globally convergent algorithms. Ratschek and Rokne in the same paper [21] propose an interval method which solves the problem globally in the box [0; 10] 9 . <p> It is therefore recommended that such methods for solving unstable systems should be further investigated with the aim of reducing the computations. These methods would be based on improved selection criteria for the subdivision process. No computation times were given in <ref> [21] </ref>, since this was not the primary aim of the paper. However, a preliminary draft of the paper indicated that the overall process took over 14 months using a network of 30 Sun Sparc 1 workstations. <p> Section 4 reports the experimental results and Section 5 concludes the paper. 1 Proving that the safe box contains a unique solution requires some experimental trial and error work because of the nature of these proofs. See Section 6 of <ref> [21] </ref> for a discussion on this issue. 2 2 Interval Analysis In this section, we review some basic concepts needed for this paper, including interval arithmetic and the representation of constraints. More information on interval arithmetic can be found in many places (e.g., [1, 7, 6, 15, 16, 18, 20]). <p> The algorithm only performs 118 branchings and takes 2359.80 seconds (roughly 40 minutes) on a Sun Ultra-2 running Solaris. This is of course a considerable improvement over the results of Ratschek and Rokne <ref> [21] </ref>. Interestingly, the box-consistency algorithm performs 135099 branchings and takes 11841 seconds (roughly 3 hours and 20 minutes) on the same machine. This is of course still a considerable improvement over [21]. <p> This is of course a considerable improvement over the results of Ratschek and Rokne <ref> [21] </ref>. Interestingly, the box-consistency algorithm performs 135099 branchings and takes 11841 seconds (roughly 3 hours and 20 minutes) on the same machine. This is of course still a considerable improvement over [21]. Benchmarks from Continuation Methods It is worth comparing the box-consistency and bound-consistency algorithms on some standard benchmarks from continuation methods [23]. The box-consistency algorithm was shown to compare well with continuation methods on these benchmarks [22].
Reference: [22] <author> P. Van Hentenryck, D. McAllister, and D. Kapur. </author> <title> Solving Polynomial Systems Using a Branch and Prune Approach. </title> <journal> SIAM Journal on Numerical Analysis, </journal> <volume> 34(2), </volume> <year> 1997. </year>
Reference-contexts: The pruning techniques, some of which were presented in <ref> [22] </ref> and some of which are novel, are based on constraint satisfaction techniques from artificial intelligence and are particularly effective when far from a solution. These techniques are thus orthogonal to traditional interval techniques which are most effective close to a solution (when the boxes are small). <p> The pruning step applies a local consistency condition at each node of the search tree. A previous version of our algorithm <ref> [22] </ref> uses a condition called box consistency. The algorithm presented here enforces a stronger local condition called bound consistency. The rest of this section is organized as follows. <p> See [9, 10] for an extensive coverage of conditioners. 3.3 Bound Consistency Box consistency has been shown to be effective for solving a variety of nonlinear applications <ref> [22] </ref>. For some applications however, and for the transistor modeling problem in particular, a better efficiency can be obtained by using a stronger local consistency condition that we call bound consistency. Bound consistency is related to the notions of path-consistency [14] and to the consistency notions presented in [12]. <p> The function BRANCH splits the box into two subboxes along one dimension (variable). The choice of the variable to branch next is important and, in our experimental results, we simply assume that the variable with the largest interval is selected. See also <ref> [22] </ref> for other pragmatic considerations in implementing the ideal model described here. 3.5 Existence Proof We now describe how the algorithm proves the existence of a solution in a box. <p> In the result, the bound-consistency algorithm means the branch and prune algorithm presented in the previous section, while the box-consistency algorithm is the same algorithm, except that the pruning step applies box-consistency instead of bound-consistency. The box-consistency algorithm was presented in <ref> [22] </ref>. The Transistor Modeling Problem The bound-consistency algorithm was applied to find all solutions of the transistor modeling problem. Branching was applied until a safe box or a box of width smaller than 10 8 was obtained. <p> This is of course still a considerable improvement over [21]. Benchmarks from Continuation Methods It is worth comparing the box-consistency and bound-consistency algorithms on some standard benchmarks from continuation methods [23]. The box-consistency algorithm was shown to compare well with continuation methods on these benchmarks <ref> [22] </ref>. Table 1 reports the results and gives, for each benchmark, the number of variables, the degree of the polynomial system, the initial range of the variables, and the CPU time and number of branchings of the box-consistency and bound-consistency algorithms. See [23, 22] for a description of the benchmarks. <p> Table 1 reports the results and gives, for each benchmark, the number of variables, the degree of the polynomial system, the initial range of the variables, and the CPU time and number of branchings of the box-consistency and bound-consistency algorithms. See <ref> [23, 22] </ref> for a description of the benchmarks. The intention is not to compare the two algorithms systematically 12 but rather to make readers aware that none of two algorithms is really superior. <p> The problem was tackled by a novel branch and prune algorithm combining techniques from interval methods and constraint satisfaction. In particular, the algorithm enforces a local consistency condition called bound consistency which strengthens the notion of box consistency introduced in <ref> [22] </ref>. The algorithm was applied to find all solutions to the transistor modeling problem and it returned a unique safe box in the range [0; 10] 9 in about 40 minutes, performing only 118 branchings.
Reference: [23] <author> J Verschelde, P. Verlinden, and R. Cools. </author> <title> Homotopies Exploiting Newton Polytopes For Solving Sparse Polynomial Systems. </title> <journal> SIAM Journal on Numerical Analysis, </journal> <volume> 31(3) </volume> <pages> 915-930, </pages> <year> 1994. </year> <month> 15 </month>
Reference-contexts: This is of course still a considerable improvement over [21]. Benchmarks from Continuation Methods It is worth comparing the box-consistency and bound-consistency algorithms on some standard benchmarks from continuation methods <ref> [23] </ref>. The box-consistency algorithm was shown to compare well with continuation methods on these benchmarks [22]. <p> Table 1 reports the results and gives, for each benchmark, the number of variables, the degree of the polynomial system, the initial range of the variables, and the CPU time and number of branchings of the box-consistency and bound-consistency algorithms. See <ref> [23, 22] </ref> for a description of the benchmarks. The intention is not to compare the two algorithms systematically 12 but rather to make readers aware that none of two algorithms is really superior. <p> The paper also indicated that bound consistency may be too strong a local condition for many problems, since it is slower than box-consistency on benchmarks from continuation methods <ref> [23] </ref>. An interesting avenue of research is to characterize more formally the class of applications for which bound consistency and box consistency are effective pruning techniques. Acknowledgments Special thanks to Christian Bliek for bringing the transistor modeling problem to our attention and to Yves Deville for many interesting discussions.
References-found: 23

