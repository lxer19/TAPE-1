URL: http://www.cs.rice.edu/~andras/ECAI/watson.ps
Refering-URL: http://www.cs.rice.edu/~andras/ECAI/watson.html
Root-URL: 
Email: watson@RibbitSoft.com  
Title: Implementing and using finite automata toolkits  
Author: Bruce W. Watson 
Address: Box 24040, 297 Bernard Kelowna, BC V1Y 9P9 Canada  
Affiliation: Ribbit Software Systems  
Abstract: Finite automata (and various extensions of them) are used in areas as diverse as: compilers, digital flight control, speech recognition, genetic sequencing, and Java program verification. Unfortunately, as the number of applications has grown, so has the variety of implementations and implementation techniques. Typically, programmers will be confused enough to resort to their text books for the most elementary algorithms. Recently, advances have been made in taxonomizing algorithms (for constructing automata) and in evaluating various implementation strategies. Armed with this, a number of general-purpose toolkits have been developed at universities. One of these, known as the FIRE Lite, was developed at the Eindhoven University of Technology, in the Netherlands. We will consider the structure and use of this toolkit, which provides implementations of all of the known algorithms for constructing automata from regular expressions, and all of the known algorithms for minimizing deterministic finite automata. The first edition of the toolkit was designed with compilers in mind. More recently, computation linguists have become interested in using the toolkit. This has lead to the development of a much more general interface to the toolkit, including the support of both Mealy (transition labeled) and Moore (state labeled) regular transducers. While such a toolkit may appear extremely complex, there are only a few choices to be made. We also consider a "recipe" for making good use of the toolkits. Lastly, we consider the future of the toolkit. While this toolkit has some obvious commercial value (and it is being commercialized), we are committed to maintaining a version which is freely available for non-commercial use. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Raymond and D. Wood, </author> <title> `The grail papers', </title> <institution> University of Waterloo technical report series, </institution> <year> (1996). </year>
Reference-contexts: There are a number of other general purpose finite automata toolkits | such as Grail (developed by Darrell Raymond and Derick Wood at the University of Waterloo and the University of Western Ontario) <ref> [1] </ref>. Grail is an extremely flexible toolkit, well implemented, and of great educational value. It is, however, a bit less efficient than FIRE Lite. Choosing between the two toolkits can be particularly difficult and usually comes down to a choice between flexibility and performance.
Reference: [2] <author> B.W. Watson, </author> <title> Taxonomies and Toolkits of Regular Language Algorithms, </title> <institution> Eindhoven University of Technology, Eindhoven, </institution> <address> The Netherlands, </address> <year> 1995. </year> <title> Implementing and using finite automata toolkits 100 B.W. </title> <institution> Watson </institution>
Reference-contexts: 1 INTRODUCTION In this paper, we briefly present the structure and use of the FIRE Lite | a toolkit for regular acceptors (simple finite automata) and regular transducers. The toolkit grew out of thesis research <ref> [2] </ref>, which had a particular emphasis on compiler-oriented algorithms. <p> The taxonomy, which is fully presented in <ref> [2] </ref>, provides full correctness arguments for the algorithms in a format which is easy to understand and which facilitates comparison of the algorithms. <p> It is, however, a bit less efficient than FIRE Lite. Choosing between the two toolkits can be particularly difficult and usually comes down to a choice between flexibility and performance. Much more extensive documentation on the toolkit is provided in <ref> [2] </ref>. We begin with a description of regular acceptors in the toolkit; this is followed by a description of transducers, and a guide to making use of the toolkit. We conclude with an outline of future directions for the toolkit. <p> The choices range from a deterministic automaton (having the fastest transition time, but the slowest construction time) to a general nondeterministic automaton (having a relatively slow transition time, but extremely fast construction times). The precise performance characteristics (of the various types of au tomata) are detailed in <ref> [2] </ref>. 3. If the automaton is to be used as a transducer, outputs will be required for each transition. The output portion of a transition's label is usually a simple addition to the normal transition label. <p> The toolkit provides extensive support for regular acceptors and regular transducers. All of the known algorithms for constructing automata are implemented in the toolkit, using their abstract versions presented in the taxonomy in <ref> [2] </ref>. The toolkit has already been heavily used in compilers and in various pattern matching applications | both of which have made extensive use of multithreading. Extensive benchmarking (also reported in [2]) shows that the toolkit's performance is significantly better than that of other toolkits. <p> known algorithms for constructing automata are implemented in the toolkit, using their abstract versions presented in the taxonomy in <ref> [2] </ref>. The toolkit has already been heavily used in compilers and in various pattern matching applications | both of which have made extensive use of multithreading. Extensive benchmarking (also reported in [2]) shows that the toolkit's performance is significantly better than that of other toolkits. Since transduction was originally added to the toolkit at the suggestion of computational linguists, it will be interesting to see what kinds of new applications are devised for the toolkit.
References-found: 2

