URL: http://glen.lcs.mit.edu/~devadas/pubs/isdl.ps
Refering-URL: http://glen.lcs.mit.edu/~devadas/pubs/compiler.html
Root-URL: 
Title: ISDL: An Instruction Set Description Language for Retargetability  
Abstract: We present the Instruction Set Description Language, ISDL, a machine description language used to describe target architectures to a retargetable compiler. A retargetable compiler is capable of compiling application code into machine code for different processors. The features and flexibility of ISDL enable the description of vastly different architectures such as an ASIP VLIW processor and a commercial DSP microprocessor. For instance, unlike other machine description languages, ISDL explicitly supports constraints which define valid operation groupings within an instruction, increasing the range of specifiable architectures. We have written a tool which, given an ISDL description of a processor, can automatically generate an assembler for it. Ongoing work includes the development of an automatic code-generator generator. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Goossens, F. Catthoor, D. Lanneer, and H. De Man. </author> <title> Integration of Signal Processing Systems on Heterogeneous IC Architectures. </title> <booktitle> In Proceedings of the 6th International Workshop on High-Level Synthesis, </booktitle> <pages> pages 16-26, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: 1 Introduction 1.1 Embedded Systems For a variety of reasons, manufacturers profit from integrating an entire system on a single integrated circuit (IC) <ref> [1] </ref> [2]. Such a high level of integration has brought new challenges in the design of digital systems. Designing an entire system with a custom integrated circuit is now neither economical nor practical. <p> Each subfield is 8 bits long. DBM.OP is the MSB and Main.OP is the LSB. Section Global_Definitions ISDL: An Instruction Set Description Language for Retargetability 16 // assembly token type value Token X [0..1] X_R ival - yylval.ival = yytext <ref> [1] </ref> - '0'; -; Token Y [0..1] Y_R ival - yylval.ival = yytext [1] - '0'; -; Token BA BA_D ival - -; Token A10 A10_D ival - -; Token X: XMEM ival - -; ... Text between the // and the end of the line is a comment. <p> DBM.OP is the MSB and Main.OP is the LSB. Section Global_Definitions ISDL: An Instruction Set Description Language for Retargetability 16 // assembly token type value Token X [0..1] X_R ival - yylval.ival = yytext <ref> [1] </ref> - '0'; -; Token Y [0..1] Y_R ival - yylval.ival = yytext [1] - '0'; -; Token BA BA_D ival - -; Token A10 A10_D ival - -; Token X: XMEM ival - -; ... Text between the // and the end of the line is a comment. The next five lines define a list of tokens. <p> The last set of brackets in each operation contains timing information. Section Constraints ~( REP *) & (<ref> [1] </ref> DO *,*)) This constraint denotes that any DO instruction is illegal when fetched as the next instruction after a REP instruction. The [1] indicates a time shift of one instruction fetch for the DO instruction. 5 Automatic Assembler Generator We required that ISDL be capable of automatically generating an assembler. This allows us to decouple the development of the compiler from that of the simulator.
Reference: [2] <author> F. Depuydt. </author> <title> Register Optimization and Scheduling for Real-Time Digital Signal Processing Architectures. </title> <type> PhD thesis, </type> <institution> Katholieke Universiteit Leuven, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: 1 Introduction 1.1 Embedded Systems For a variety of reasons, manufacturers profit from integrating an entire system on a single integrated circuit (IC) [1] <ref> [2] </ref>. Such a high level of integration has brought new challenges in the design of digital systems. Designing an entire system with a custom integrated circuit is now neither economical nor practical.
Reference: [3] <author> R. K. Gupta and G. De Micheli. </author> <title> Hardware-Software Cosynthesis for Digital Systems. </title> <booktitle> IEEE Design & Test of Computers, </booktitle> <pages> pages 29-41, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: There have been proposals for the hardware-software co-design of digital systems (e.g., <ref> [3] </ref>, [4], and [5]). The simplified view of a generic co-design methodology is shown in Figure 2. In this design flow, designers first determine which parts of the functionality of the system will be implemented in hardware and which parts in software.
Reference: [4] <author> A. Kalavade and E. A. Lee. </author> <title> A Hardware-Software Codesign Methodology for DSP Applications. </title> <booktitle> IEEE Design & Test of Computers, </booktitle> <pages> pages 16-28, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: There have been proposals for the hardware-software co-design of digital systems (e.g., [3], <ref> [4] </ref>, and [5]). The simplified view of a generic co-design methodology is shown in Figure 2. In this design flow, designers first determine which parts of the functionality of the system will be implemented in hardware and which parts in software.
Reference: [5] <author> D. E. Thomas, J. K. Adams, and H. </author> <title> Schmit. A Model and Methodology for Hardware-Software Codesign. </title> <booktitle> IEEE Design & Test of Computers, </booktitle> <pages> pages 6-15, </pages> <month> September </month> <year> 1993. </year> <title> ISDL: An Instruction Set Description Language for Retargetability 22 </title>
Reference-contexts: There have been proposals for the hardware-software co-design of digital systems (e.g., [3], [4], and <ref> [5] </ref>). The simplified view of a generic co-design methodology is shown in Figure 2. In this design flow, designers first determine which parts of the functionality of the system will be implemented in hardware and which parts in software.
Reference: [6] <author> R. Cattell. </author> <title> Automatic Derivation of Code Generators from Machine Descriptions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(2) </volume> <pages> 173-190, </pages> <year> 1980. </year>
Reference-contexts: One approach to generating code is to perform pattern-matching on expression trees. This approach is also capable of performing local optimizations. Cattell designed a framework in which code generators based on pattern-matching are automatically derived from a machine description language <ref> [6] </ref>. The landmark paper by Aho et al. [7] established the foundation in which several modern dynamic-programming code-generator generators find their origin. One such code-generator generator is Iburg [8], employed in the compiler framework Lcc [9].
Reference: [7] <author> A. Aho, M. Ganapathi, and S. Tjiang. </author> <title> Code Generation Using Tree Matching and Dynamic Programming. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 491-516, </pages> <year> 1989. </year>
Reference-contexts: One approach to generating code is to perform pattern-matching on expression trees. This approach is also capable of performing local optimizations. Cattell designed a framework in which code generators based on pattern-matching are automatically derived from a machine description language [6]. The landmark paper by Aho et al. <ref> [7] </ref> established the foundation in which several modern dynamic-programming code-generator generators find their origin. One such code-generator generator is Iburg [8], employed in the compiler framework Lcc [9]. The dynamic-programming methodology yields only locally optimal code (i.e., within the expression tree) which is often insufficient.
Reference: [8] <author> C. W. Fraser, D. R. Hanson, and T. A. Proebsting. </author> <title> Engineering a Simple, Efficient Code-Generator Generator. </title> <journal> ACM Letters of Programming Languages and Systems, </journal> <volume> 1(3) </volume> <pages> 213-226, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Cattell designed a framework in which code generators based on pattern-matching are automatically derived from a machine description language [6]. The landmark paper by Aho et al. [7] established the foundation in which several modern dynamic-programming code-generator generators find their origin. One such code-generator generator is Iburg <ref> [8] </ref>, employed in the compiler framework Lcc [9]. The dynamic-programming methodology yields only locally optimal code (i.e., within the expression tree) which is often insufficient. More recently, Bradlee proposed a retargetable scheduler, Marion, that is used for RISC architectures [10]. <p> It also includes a 16-entry hardware stack. The instruction word is 99 bits long and does not require additional words. We provide portions of our ISDL description for the Motorola DSP56000 processor to illustrate the structure of ISDL, and how it is used. Section Format DBM = OP <ref> [8] </ref>, MODE [8]; Main = OP [8]; This describes a 24 bit instruction word divided into three subfields: DBM.OP, DBM.MODE, and Main.OP. Each subfield is 8 bits long. DBM.OP is the MSB and Main.OP is the LSB. <p> The instruction word is 99 bits long and does not require additional words. We provide portions of our ISDL description for the Motorola DSP56000 processor to illustrate the structure of ISDL, and how it is used. Section Format DBM = OP <ref> [8] </ref>, MODE [8]; Main = OP [8]; This describes a 24 bit instruction word divided into three subfields: DBM.OP, DBM.MODE, and Main.OP. Each subfield is 8 bits long. DBM.OP is the MSB and Main.OP is the LSB. <p> The instruction word is 99 bits long and does not require additional words. We provide portions of our ISDL description for the Motorola DSP56000 processor to illustrate the structure of ISDL, and how it is used. Section Format DBM = OP <ref> [8] </ref>, MODE [8]; Main = OP [8]; This describes a 24 bit instruction word divided into three subfields: DBM.OP, DBM.MODE, and Main.OP. Each subfield is 8 bits long. DBM.OP is the MSB and Main.OP is the LSB.
Reference: [9] <author> C. W. Fraser and D. R. Hanson. </author> <title> A Retargetable C Compiler: Design and Implementation. </title> <publisher> Benjamin/Cummings Publishing Company, </publisher> <address> Redwood City, California, </address> <year> 1995. </year> <note> ISBN 0-8053-1670-1. </note>
Reference-contexts: The landmark paper by Aho et al. [7] established the foundation in which several modern dynamic-programming code-generator generators find their origin. One such code-generator generator is Iburg [8], employed in the compiler framework Lcc <ref> [9] </ref>. The dynamic-programming methodology yields only locally optimal code (i.e., within the expression tree) which is often insufficient. More recently, Bradlee proposed a retargetable scheduler, Marion, that is used for RISC architectures [10].
Reference: [10] <author> D. G. Bradlee, R. R. Henry, and S. J. Eggers. </author> <title> The Marion System for Retargetable Instruction Scheduling. </title> <booktitle> In Proceedings of the 1991 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 229-240, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: One such code-generator generator is Iburg [8], employed in the compiler framework Lcc [9]. The dynamic-programming methodology yields only locally optimal code (i.e., within the expression tree) which is often insufficient. More recently, Bradlee proposed a retargetable scheduler, Marion, that is used for RISC architectures <ref> [10] </ref>.
Reference: [11] <author> P. Marwedel. </author> <title> The MIMOLA Design System: Tools for the Design of Digital Processors. </title> <booktitle> In Proceedings of the 21th Design Automation Conference, </booktitle> <pages> pages 587-593, </pages> <year> 1984. </year>
Reference-contexts: It uses a machine description that models pipelines and superscalar instruction issues, and schedules instructions to effectively utilize the features and to reduce conflicts. 2.2 Retargetability in Embedded Processors We briefly review three representative research projects in the area of code generation for embedded systems: Mimola <ref> [11] </ref>, Chess [12], and FlexWare [13]. The proceedings of the Dagstuhl Workshop [14] contain a collection of papers documenting several other contributors' efforts. The Mimola design system was originally conceived as a design environment for hardware structures using the Mimola hardware description language [15]. <p> The Mimola design system was originally conceived as a design environment for hardware structures using the Mimola hardware description language [15]. It later evolved into an environment for hardware-software co-design and includes a retargetable microcode compiler <ref> [11] </ref> [16]. One of the key features that distinguishes the Mimola project from others is that the microcode compiler infers rules for code generation directly from a structural description (e.g., a net-list) of the target architecture instead of a behavioral description (e.g., the instruction set).
Reference: [12] <author> D. Lanneer, J. Van Praet, A. Kifli, K. Schoofs, W. Geurts, F. Thoen, and G. Goossens. </author> <title> CHESS: Retargetable Code Generation for Embedded DSP Processors. </title> <editor> In P. Marwedel and G. Goossens, editors, </editor> <title> Code Generation for Embedded Processors, </title> <booktitle> chapter 5, </booktitle> <pages> pages 85-102. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: It uses a machine description that models pipelines and superscalar instruction issues, and schedules instructions to effectively utilize the features and to reduce conflicts. 2.2 Retargetability in Embedded Processors We briefly review three representative research projects in the area of code generation for embedded systems: Mimola [11], Chess <ref> [12] </ref>, and FlexWare [13]. The proceedings of the Dagstuhl Workshop [14] contain a collection of papers documenting several other contributors' efforts. The Mimola design system was originally conceived as a design environment for hardware structures using the Mimola hardware description language [15]. <p> However, Mimola descriptions are generally very low level, and therefore laborious to write and ISDL: An Instruction Set Description Language for Retargetability 7 modify. In addition, Mimola does not support explicit constraints, nor does it allow for automatic assembler generation. Chess <ref> [12] </ref> is a retargetable code generation environment for fixed-point DSPs and ASIPs; it was developed in the context of the Cathedral II high-level synthesis system [17]. The target machine is described using the language nML [18].
Reference: [13] <author> P. G. Paulin, C. Liem, T. C. May, and S. Sutarwala. </author> <title> DSP Design Tool Requirements for Embedded Systems: A Telecommunications Industrial Perspective. </title> <journal> Journal of VLSI Signal Processing, </journal> 9(1/2):23-47, January 1995. 
Reference-contexts: uses a machine description that models pipelines and superscalar instruction issues, and schedules instructions to effectively utilize the features and to reduce conflicts. 2.2 Retargetability in Embedded Processors We briefly review three representative research projects in the area of code generation for embedded systems: Mimola [11], Chess [12], and FlexWare <ref> [13] </ref>. The proceedings of the Dagstuhl Workshop [14] contain a collection of papers documenting several other contributors' efforts. The Mimola design system was originally conceived as a design environment for hardware structures using the Mimola hardware description language [15]. <p> FlexWare consists of two components: a code generator, CodeSyn [19], and an instruction-set simulator, Insulin [20]. FlexWare is a tool-set developed in response to the results of the survey conducted by Paulin et al. regarding trends and requirements in DSP design environments <ref> [13] </ref>. The machine description for CodeSyn consists of three components: the instruction set, the available resources and their classification, and an interconnect graph.
Reference: [14] <author> P. Marwedel and G. Goossens, </author> <title> editors. Code Generation for Embedded Processors. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, Massachusetts, </address> <year> 1995. </year> <title> Proceedings of the 1994 Dagstuhl Workshop on Code Generation for Embedded Processors. </title> <note> ISBN 0-7923-9577-8. </note>
Reference-contexts: The proceedings of the Dagstuhl Workshop <ref> [14] </ref> contain a collection of papers documenting several other contributors' efforts. The Mimola design system was originally conceived as a design environment for hardware structures using the Mimola hardware description language [15]. It later evolved into an environment for hardware-software co-design and includes a retargetable microcode compiler [11] [16].
Reference: [15] <author> G. Zimmermann. </author> <title> The MIMOLA Design System: A Computer Aided Digital Processors Design Method. </title> <booktitle> In Proceedings of the 16th Design Automation Conference, </booktitle> <pages> pages 53-58, </pages> <year> 1979. </year> <title> ISDL: An Instruction Set Description Language for Retargetability 23 </title>
Reference-contexts: The proceedings of the Dagstuhl Workshop [14] contain a collection of papers documenting several other contributors' efforts. The Mimola design system was originally conceived as a design environment for hardware structures using the Mimola hardware description language <ref> [15] </ref>. It later evolved into an environment for hardware-software co-design and includes a retargetable microcode compiler [11] [16].
Reference: [16] <author> P. Marwedel. </author> <title> Tree-Based Mapping of Algorithms to Predefined Structures. </title> <booktitle> In Proceedings of the 1993 IEEE/ACM International Conference on Computer-Aided Design, </booktitle> <pages> pages 586-593, </pages> <month> November </month> <year> 1993. </year> <title> Extended version: </title> <type> Technical report 431, </type> <institution> Lehrstuhl Informatik XII, University of Dortmund, Germany. </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: The Mimola design system was originally conceived as a design environment for hardware structures using the Mimola hardware description language [15]. It later evolved into an environment for hardware-software co-design and includes a retargetable microcode compiler [11] <ref> [16] </ref>. One of the key features that distinguishes the Mimola project from others is that the microcode compiler infers rules for code generation directly from a structural description (e.g., a net-list) of the target architecture instead of a behavioral description (e.g., the instruction set).
Reference: [17] <author> G. Goossens, D. Lanneer, M. Pauwels, F. Depuydt, K. Schoofs, A. Kifli, M. Conero, P. Petroni, F. Catthoor, and H. De Man. </author> <title> Integration of Medium-Throughput Signal Processing Algorithms on Flexible Instruction-Set Architectures. </title> <journal> Journal of VLSI Signal Processing, </journal> <volume> 9(1) </volume> <pages> 49-65, </pages> <year> 1995. </year>
Reference-contexts: In addition, Mimola does not support explicit constraints, nor does it allow for automatic assembler generation. Chess [12] is a retargetable code generation environment for fixed-point DSPs and ASIPs; it was developed in the context of the Cathedral II high-level synthesis system <ref> [17] </ref>. The target machine is described using the language nML [18]. A graphical representation of the architecture called the instruction-set graph (ISG) is then derived from the nML description. The ISG contains structural information such as connectivity and timing characteristics of the processor resources.
Reference: [18] <author> A. Fauth, J. Van Praet, and M. Freericks. </author> <title> Describing Instruction Sets Using nML (Extended Version). </title> <type> Technical report, </type> <institution> Technische Universitat Berlin and IMEC, </institution> <address> Berlin (Ger-many)/Leuven (Belgium), </address> <year> 1995. </year>
Reference-contexts: Chess [12] is a retargetable code generation environment for fixed-point DSPs and ASIPs; it was developed in the context of the Cathedral II high-level synthesis system [17]. The target machine is described using the language nML <ref> [18] </ref>. A graphical representation of the architecture called the instruction-set graph (ISG) is then derived from the nML description. The ISG contains structural information such as connectivity and timing characteristics of the processor resources.
Reference: [19] <author> P. G. Paulin, C. Liem, T. C. May, and S. Sutarwala. CodeSyn: </author> <title> A Retargetable Code Synthesis System. </title> <booktitle> In Proceedings of the 7th International High-Level Synthesis Workshop, </booktitle> <month> Spring </month> <year> 1994. </year>
Reference-contexts: While it appears possible to automatically generate an assembler from an nML description, the nML publications do not make a claim to this effect. FlexWare consists of two components: a code generator, CodeSyn <ref> [19] </ref>, and an instruction-set simulator, Insulin [20]. FlexWare is a tool-set developed in response to the results of the survey conducted by Paulin et al. regarding trends and requirements in DSP design environments [13].
Reference: [20] <author> S. Sutarwala, P. G. Paulin, and Y. Kumar. Insulin: </author> <title> An Instruction Set Simluation Environment. </title> <booktitle> In Proceedings of the 1993 Conference on Hardware Description Languages, </booktitle> <pages> pages 355-362, </pages> <year> 1993. </year>
Reference-contexts: While it appears possible to automatically generate an assembler from an nML description, the nML publications do not make a claim to this effect. FlexWare consists of two components: a code generator, CodeSyn [19], and an instruction-set simulator, Insulin <ref> [20] </ref>. FlexWare is a tool-set developed in response to the results of the survey conducted by Paulin et al. regarding trends and requirements in DSP design environments [13]. The machine description for CodeSyn consists of three components: the instruction set, the available resources and their classification, and an interconnect graph.
Reference: [21] <institution> Stanford Compiler Group. </institution> <address> The SUIF Library, </address> <note> version 1.0 edition, </note> <year> 1994. </year>
Reference-contexts: The compiler front end receives a source program written in C or C++. It then parses the source program and generates an intermediate format description in SUIF 1 <ref> [21] </ref>. The compiler back end takes the SUIF code as well as the ISDL description as inputs and produces assembly code specific to, and optimized for, the target processor. The ISDL description is also used to create an assembler (see Section 5).
Reference: [22] <author> J. Levine, T. Mason, and D. Brown. </author> <title> lex & yacc. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <year> 1992. </year>
Reference-contexts: The definitions consist of four main types: Tokens, Non-terminals, Split functions, and Macro definitions. With the exception of macro definitions, these definitions are designed to help create an automatically generated assembler using Lex and Yacc 2 <ref> [22] </ref>. Tokens are a symbolic representation of the assembly syntax within the parser. Tokens are used to represent entities such as register and memory bank names, immediate constants, etc. In addition, we allow groupings of syntactically related tokens.
References-found: 22

