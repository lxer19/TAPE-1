URL: http://www.cs.cmu.edu/~fp/papers/lics97.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/fp/www/lfs-bib.html
Root-URL: 
Email: filianojfpg@cs.cmu.edu  
Title: Linear Higher-Order Pre-Unification  
Author: Iliano Cervesato and Frank Pfenning 
Address: Pittsburgh, PA 15213-3891  
Affiliation: Department of Computer Science Carnegie Mellon University  
Abstract: We develop an efficient representation and a pre This extended abstract has been accepted at the Twelfth Annual Symposium on Logic in Computer Science - LICS'97, Warsaw, Poland, June 29th - July 2nd 1997. unification algorithm in the style of Huet for the linear -calculus !ffi&&gt; which includes intuitionistic functions (!), linear functions (ffi), additive pairing (&), and additive unit (&gt;). Applications lie in proof search, logic programming, and logical frameworks based on linear type theories. We also show that, surprisingly, a similar pre-unification algorithm does not exist for certain sublanguages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Barber. </author> <title> Dual intuitionistic linear logic. </title> <type> Technical Report ECS-LFCS-96-347, </type> <institution> Laboratory for Foundations of Computer Sciences, University if Edinburgh, </institution> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: Curry-Howard isomorphism, to the fragment of intuitionistic linear logic freely generated from the con-nectives !, ffi, & and &gt;, which constitutes the propositional core of Lolli [15] and LLF [4]. !ffi&&gt; is also the simply-typed variant of the term language of LLF and shares similarities with the calculus proposed in <ref> [1] </ref>. Its theoretical relevance derives from the fact that it is the largest linear -calculus that admits unique long fi-normal forms.
Reference: [2] <author> I. Cervesato. </author> <title> A Linear Logical Framework. </title> <type> PhD thesis, </type> <institution> Dipartimento di Informatica, Universita di Torino, </institution> <month> Feb. </month> <year> 1996. </year> <month> 11 </month>
Reference-contexts: In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. More recent proposals, such as the language of the linear logical framework LLF <ref> [2, 4] </ref> and the system RLF [17], introduce linearity not only at the level of formulas, but also within terms. Consequently, implementations of these languages must solve higher-order equations on linear terms in order to instantiate existential variables. <p> 1 ^M 2 (linear functions) j A 1 & A 2 j hM 1 ; M 2 i j fst M j snd M (additive pairs) j &gt; j hi (additive unit) Signatures: ::= j ; c : A Contexts: ::= j ; x : A of moves in games <ref> [2] </ref>. When we want to specify, manipulate, or reason about such objects (which is common in logic and the theory of programming languages), then internal linearity constraints are critical in practice (see, for example, the first formalizations of cut-elimination in linear logic and type preservation for Mini-ML with references [4]). <p> reduction semantics of !ffi&&gt; is given by the transitive and reflexive closure of the congruence rela tion built on the following fi-reduction rules: fst hM; N i ! M ( ^ x : A: M )^N ! [N=x]M Similarly to ! , !ffi&&gt; enjoys a number of highly desirable properties <ref> [2] </ref>. In particular, since every extension (for example with and multiplicative pairs) introduces commutative conversions, it is the largest linear -calculus for which strong normalization holds and yields unique normal forms.
Reference: [3] <author> I. Cervesato, J. S. Hodas, and F. Pfenning. </author> <title> Efficient resource management for linear logic proof search. </title> <editor> In R. Dyckhoff, H. Herre, and P. Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the 5th International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 67-81, </pages> <address> Leipzig, Germany, </address> <month> Mar. </month> <title> 1996. </title> <publisher> Springer-Verlag LNAI 1050. </publisher>
Reference-contexts: The only new aspect in the operational semantics of most proposals, such as Lolli [15], Lygon [12] and Forum [22], concerns the management of linear context formulas <ref> [3] </ref>. In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. <p> As expected, equations among intuitionistic operands are created with an empty linear context (pu iapp). Context splitting in rule pu lapp represents a new form of non-determinism not present in Huet's algorithm. Standard techniques of lazy context management <ref> [3] </ref> can however be used in order to handle it efficiently and deterministically in an actual implementation. A new inherent form of non-determinism arises in the generation of the spine of substitution terms.
Reference: [4] <author> I. Cervesato and F. Pfenning. </author> <title> A linear logical framework. </title> <editor> In E. Clarke, editor, </editor> <booktitle> Proceedings of the Eleventh Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 264-275, </pages> <address> New Brunswick, New Jersey, July 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. More recent proposals, such as the language of the linear logical framework LLF <ref> [2, 4] </ref> and the system RLF [17], introduce linearity not only at the level of formulas, but also within terms. Consequently, implementations of these languages must solve higher-order equations on linear terms in order to instantiate existential variables. <p> The introduction of linear term languages in LLF and RLF has been motivated by a number of applications. Linear terms provide a statically checkable notation for natural deductions [17] or sequent derivations <ref> [4] </ref> in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [4] or sequences Types: A ::= a Terms: M ::= c j x j A 1 ! A 2 j x : A: M j M 1 M 2 (intuitionistic functions) j A <p> Linear terms provide a statically checkable notation for natural deductions [17] or sequent derivations <ref> [4] </ref> in substructural logics. In the realm of programming languages, linear terms naturally model computations in imperative languages [4] or sequences Types: A ::= a Terms: M ::= c j x j A 1 ! A 2 j x : A: M j M 1 M 2 (intuitionistic functions) j A 1 ffi A 2 j ^ x : A: M j M 1 ^M 2 (linear functions) j <p> When we want to specify, manipulate, or reason about such objects (which is common in logic and the theory of programming languages), then internal linearity constraints are critical in practice (see, for example, the first formalizations of cut-elimination in linear logic and type preservation for Mini-ML with references <ref> [4] </ref>). Differently from the first-order case, higher-order unification in Church's simply typed -calculus ! is undecidable and does not admit most general unifiers [11]. Nevertheless sound and complete (although possibly non-terminating) procedures have been proposed in order to enumerate solutions [18]. <p> be devised for linear sublan-guages deprived of &gt; and of the corresponding constructor. !ffi&&gt; corresponds, via a natural extension of the Curry-Howard isomorphism, to the fragment of intuitionistic linear logic freely generated from the con-nectives !, ffi, & and &gt;, which constitutes the propositional core of Lolli [15] and LLF <ref> [4] </ref>. !ffi&&gt; is also the simply-typed variant of the term language of LLF and shares similarities with the calculus proposed in [1]. Its theoretical relevance derives from the fact that it is the largest linear -calculus that admits unique long fi-normal forms.
Reference: [5] <author> I. Cervesato and F. Pfenning. </author> <title> Linear higher-order pre-unification, </title> <year> 1997. </year>
Reference-contexts: More details on the topics covered in this extended abstract can be found in the technical reports [6] and <ref> [5] </ref>. Our presentation is organized as follows. In Section 2, we define !ffi&&gt; and give an equivalent formulation better suited for our purposes. The pre-unification algorithm is the subject of Section 3. <p> We do not show the deduction rules for these judgments. The interested reader can extract them from the non-flexible cases in Figures 4 or consult <ref> [5] </ref>. <p> It is also non-deterministically complete, i.e., every solution to the original system is an instance of a unifier or pre-unifier which can be found with our procedure. These properties are expressed by the theorems below. Detailed proofs can be found in <ref> [5] </ref>. We write D :: J if D is a derivation of the judgment J , and [fi]ffi for the result of applying the substitution fi to each equation in ffi.
Reference: [6] <author> I. Cervesato and F. Pfenning. </author> <title> A linear spine calculus. </title> <type> Technical Report CMU-CS-97-125, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <address> Pitts-burgh, PA, </address> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: More details on the topics covered in this extended abstract can be found in the technical reports <ref> [6] </ref> and [5]. Our presentation is organized as follows. In Section 2, we define !ffi&&gt; and give an equivalent formulation better suited for our purposes. The pre-unification algorithm is the subject of Section 3. <p> The spine calculus S !ffi&&gt; <ref> [6] </ref> permits recovering both efficient head accesses and notational convenience. Every atomic term M of !ffi&&gt; is written in this presentation as a root H S, where H corresponds to the head of M and the spine S collects the sequence of destructors applied to it. <p> For reasons of space, we omit the typing rules for these judgments <ref> [6] </ref>, although they will indirectly appear in the inference system for pre-unification. There exists a structural translation of terms in !ffi&&gt; to terms in S !ffi&&gt; , and vice versa [6]. <p> For reasons of space, we omit the typing rules for these judgments <ref> [6] </ref>, although they will indirectly appear in the inference system for pre-unification. There exists a structural translation of terms in !ffi&&gt; to terms in S !ffi&&gt; , and vice versa [6]. Space constraints do not allow presenting this mapping and the proofs of soundness and completeness for the respective typing derivations. <p> Consequently, roots have always base type and so do the target types in the spine typing judgment. The fi-reduction rules above preserve long forms so that - expansion steps never need to be performed <ref> [6] </ref>. <p> By strong normalization and the Church-Rosser theorem <ref> [6] </ref>, it suffices to compute Can (U 1 ) and Can (U 2 ) and check whether they are syntactically equal (modulo renaming of bound variables).
Reference: [7] <author> G. Dowek, T. Hardin, C. Kirchner, and F. Pfenning. </author> <title> Unification via explicit substitutions: The case of higher-order patterns. </title> <editor> In M. Maher, editor, </editor> <booktitle> Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 259-273, </pages> <address> Bonn, Germany, Sept. 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The second equation above would simply be postponed as a solvable equational constraint. Based on our experience with constraint simplification in Elf [25] and preliminary experiments, we believe that this will be a practical solution. In particular, the use of explicit substitutions, investigated in <ref> [7] </ref> relatively to Elf, seems to provide a hook for the required linearity constraints. 5 Conclusion and Future Work In this extended abstract, we have studied the problem of higher-order unification in the context of the linear simply typed -calculus !ffi&&gt; .
Reference: [8] <author> D. Duggan. </author> <title> Unification with extended patterns. </title> <type> Technical Report CS-93-37, </type> <institution> University of Waterloo, Waterloo, </institution> <address> Ontario, Canada, </address> <month> July </month> <year> 1993. </year> <month> Revised March </month> <year> 1994 </year> <month> and September </month> <year> 1994. </year>
Reference-contexts: In particular, !& coincides with the simply-typed -calculus with pairs while !&&gt; corresponds to its extension with a unit type and unit element. Unification in the restricted setting of higher-order patterns has been studied for these two languages in <ref> [8] </ref> and [9], respectively. The appropriate restrictions of the rules in Figures 4-6 implement a general pre-unification procedure for these calculi. <p> Despite these difficulties, the natural generalization of the notion of higher-order pattern introduced by <ref> [8] </ref> and [9] for products to the linear case, leads to a decidable unification problem for !ffi&&gt; .
Reference: [9] <author> R. Fettig and B. Lochner. </author> <title> Unification of higher-order patterns in a simply typed lambda-calculus with finite products and terminal type. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the Seventh International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 347-361, </pages> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year> <note> Springer-Verlag LNCS 1103. </note>
Reference-contexts: In particular, !& coincides with the simply-typed -calculus with pairs while !&&gt; corresponds to its extension with a unit type and unit element. Unification in the restricted setting of higher-order patterns has been studied for these two languages in [8] and <ref> [9] </ref>, respectively. The appropriate restrictions of the rules in Figures 4-6 implement a general pre-unification procedure for these calculi. <p> Despite these difficulties, the natural generalization of the notion of higher-order pattern introduced by [8] and <ref> [9] </ref> for products to the linear case, leads to a decidable unification problem for !ffi&&gt; .
Reference: [10] <author> J.-Y. Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Linear logic <ref> [10] </ref> enriches more traditional logical formalisms with a notion of consumable resource, which provides direct means for expressing and reasoning about mutable state. Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. <p> We study the unification problem in sublanguages of !ffi&&gt; and hint at the possibility of a practical implementation in Section 4. In order to facilitate our description in the available space, we must assume the reader familiar with traditional higher-order unification [16] and linear logic <ref> [10] </ref>. 2 A Linear Simply-Typed -Calculus This section defines the simply-typed linear - calculus !ffi&&gt; (Section 2.1) and presents an equivalent formulation, S !ffi&&gt; (Section 2.2), which is more convenient for describing and implementing unifica tion. 2 con lvar ; x : A ` x : A ivar ; x :
Reference: [11] <author> W. D. Goldfarb. </author> <title> The undecidability of the second-order unification problem. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 225-230, </pages> <year> 1981. </year>
Reference-contexts: Differently from the first-order case, higher-order unification in Church's simply typed -calculus ! is undecidable and does not admit most general unifiers <ref> [11] </ref>. Nevertheless sound and complete (although possibly non-terminating) procedures have been proposed in order to enumerate solutions [18]. In particular, Huet's pre-unification algorithm [16] computes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages [23].
Reference: [12] <author> J. Harland and D. Pym. </author> <title> A uniform proof-theoretic investigation of linear logic programming. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(2) </volume> <pages> 175-207, </pages> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. The only new aspect in the operational semantics of most proposals, such as Lolli [15], Lygon <ref> [12] </ref> and Forum [22], concerns the management of linear context formulas [3]. In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language.
Reference: [13] <author> J. Harland and D. Pym. </author> <title> Resource distribution via boolean constraints. </title> <editor> In W. McCune, editor, </editor> <booktitle> Proceedings of the Fourteenth International Conference on Automated Deduction | CADE-14, Townsville, </booktitle> <address> Aus-tralia, </address> <month> July </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: An actual implementation would avoid this additional non-determinism by postponing the choices between the four imitations. A detailed treatment of the necessary constraints between variables occurrences is be yond the scope of this paper (see Section 4.2 for further discussion; a similar technique is used in <ref> [13] </ref>). 4 Discussion In this section, we consider various sublanguages of S !ffi&&gt; (or equivalently !ffi&&gt; ) obtained by eliding some of the type operators and the corresponding term constructors and destructors (Section 4.1). <p> example above, the solution would be F ^ x 0 : a: c^(F 1 ^x 0 )^(F 2 ^x 0 ) with the additional constraint that if x 0 occurs in F 1 ^x 0 then it must be absorbed (by hi) in F 2 ^x 0 and vice versa <ref> [13] </ref>. The second equation above would simply be postponed as a solvable equational constraint. Based on our experience with constraint simplification in Elf [25] and preliminary experiments, we believe that this will be a practical solution.
Reference: [14] <author> H. </author> <type> Herbelin. </type> <institution> Sequents qu'on calcule: de l'interpretation du calcul des sequents comme calcul de lambda-termes et comme calcul de strategies gagnantes. </institution> <type> PhD thesis, </type> <institution> Universite Paris 7, </institution> <year> 1995. </year>
Reference-contexts: This approach was suggested by an empirical study of higher-order logic programs based on ! terms [20] and is reminiscent of the notion of abstract Bohm trees <ref> [14] </ref>; its practical merits in our setting are currently assessed in an experimental implementation. The following grammar describes the syntax of S !ffi&&gt; : we write constructors as in !ffi&&gt; , but use new symbols to distinguish a spine operator from the corresponding term destructor.
Reference: [15] <author> J. Hodas and D. Miller. </author> <title> Logic programming in a fragment of intuitionistic linear logic. </title> <journal> Information and Computation, </journal> <volume> 110(2) </volume> <pages> 327-365, </pages> <year> 1994. </year> <booktitle> A preliminary version appeared in the Proceedings of the Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 32-42, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. The only new aspect in the operational semantics of most proposals, such as Lolli <ref> [15] </ref>, Lygon [12] and Forum [22], concerns the management of linear context formulas [3]. In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. <p> such algorithm can be devised for linear sublan-guages deprived of &gt; and of the corresponding constructor. !ffi&&gt; corresponds, via a natural extension of the Curry-Howard isomorphism, to the fragment of intuitionistic linear logic freely generated from the con-nectives !, ffi, & and &gt;, which constitutes the propositional core of Lolli <ref> [15] </ref> and LLF [4]. !ffi&&gt; is also the simply-typed variant of the term language of LLF and shares similarities with the calculus proposed in [1]. Its theoretical relevance derives from the fact that it is the largest linear -calculus that admits unique long fi-normal forms. <p> The inference rules for this judgment are displayed in Figure 2. Deleting the terms that appear in them results in the usual rules for the (! ffi&&gt;) fragment of intuitionistic linear logic, ILL !ffi&&gt; <ref> [15] </ref>, in a natural deduction style formulation. !ffi&&gt; and ILL !ffi&&gt; are related by a form of the Curry-Howard isomorphism. Note that the interactions of rules unit and lapp can flatten distinct proofs to the same !ffi&&gt; term.
Reference: [16] <author> G. Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: Differently from the first-order case, higher-order unification in Church's simply typed -calculus ! is undecidable and does not admit most general unifiers [11]. Nevertheless sound and complete (although possibly non-terminating) procedures have been proposed in order to enumerate solutions [18]. In particular, Huet's pre-unification algorithm <ref> [16] </ref> computes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages [23]. Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. <p> We study the unification problem in sublanguages of !ffi&&gt; and hint at the possibility of a practical implementation in Section 4. In order to facilitate our description in the available space, we must assume the reader familiar with traditional higher-order unification <ref> [16] </ref> and linear logic [10]. 2 A Linear Simply-Typed -Calculus This section defines the simply-typed linear - calculus !ffi&&gt; (Section 2.1) and presents an equivalent formulation, S !ffi&&gt; (Section 2.2), which is more convenient for describing and implementing unifica tion. 2 con lvar ; x : A ` x : A
Reference: [17] <author> S. Ishtiaq and D. Pym. </author> <title> A relevant analysis of natural deduction, </title> <month> Dec. </month> <year> 1996. </year> <type> Manuscript. </type>
Reference-contexts: In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language. More recent proposals, such as the language of the linear logical framework LLF [2, 4] and the system RLF <ref> [17] </ref>, introduce linearity not only at the level of formulas, but also within terms. Consequently, implementations of these languages must solve higher-order equations on linear terms in order to instantiate existential variables. In this paper we present a complete algorithm fl This work was supported by NSF Grant CCR-9303383. <p> The introduction of linear term languages in LLF and RLF has been motivated by a number of applications. Linear terms provide a statically checkable notation for natural deductions <ref> [17] </ref> or sequent derivations [4] in substructural logics.
Reference: [18] <author> D. C. Jensen and T. Pietrzykowski. </author> <title> Mechanizing !- order type theory through unification. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 123-171, </pages> <year> 1976. </year>
Reference-contexts: Differently from the first-order case, higher-order unification in Church's simply typed -calculus ! is undecidable and does not admit most general unifiers [11]. Nevertheless sound and complete (although possibly non-terminating) procedures have been proposed in order to enumerate solutions <ref> [18] </ref>. In particular, Huet's pre-unification algorithm [16] computes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages [23]. Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. <p> The possibility of achieving an algorithms a la Huet depend crucially on flex-flex equations being always solvable. If this property does not hold, as in some sublanguages of S !ffi&&gt; we will discuss shortly, these equations must be analyzed with techniques similar to <ref> [18] </ref> or [21]. The procedure we just described is not guaranteed to terminate for generic equation systems since flex-rigid steps can produce arbitrarily complex new equations.
Reference: [19] <author> J. Levy. </author> <title> Linear second-order unification. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the Seventh International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 332-346, </pages> <address> New Brunswick, New Jersey, </address> <month> July </month> <year> 1996. </year> <note> Springer-Verlag LNCS 1103. </note>
Reference-contexts: An example are Miller's higher-order patterns [21], that have been implemented in the higher-order constraint logic programming language Elf [25]. Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated <ref> [19] </ref>. Unification in ! with linear restrictions on existential variables has been studied in [26]. In this extended abstract, we investigate the unification problem in the linear simply-typed -calculus !ffi&&gt; . <p> In conclusion, pre-unification procedures in the sense of Huet are not achievable in the calculi with ffi but without &gt;. Finally, a restricted form of unification in the purely linear calculus ffi has been studied in <ref> [19] </ref>.
Reference: [20] <author> S. Michaylov and F. Pfenning. </author> <title> An empirical study of the runtime behavior of higher-order logic programs. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the Workshop on the Prolog Programming Language, </booktitle> <pages> pages 257-271, </pages> <address> Philadelphia, Pennsylvania, </address> <month> July </month> <year> 1992. </year> <institution> University of Pennsylvania. </institution> <note> Available as Technical Report MS-CIS-92-86. </note>
Reference-contexts: Application and ";" have opposite associativity so that M 1 is the innermost subterm of M while U 1 is outermost in the spine of U . This approach was suggested by an empirical study of higher-order logic programs based on ! terms <ref> [20] </ref> and is reminiscent of the notion of abstract Bohm trees [14]; its practical merits in our setting are currently assessed in an experimental implementation.
Reference: [21] <author> D. Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <editor> In P. Schroeder-Heister, editor, </editor> <booktitle> Proceedings of the International Workshop on Extensions of Logic Programming, </booktitle> <pages> pages 253-281, </pages> <address> Tubingen, Ger-many, 1989. </address> <publisher> Springer-Verlag LNAI 475. </publisher>
Reference-contexts: Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. An example are Miller's higher-order patterns <ref> [21] </ref>, that have been implemented in the higher-order constraint logic programming language Elf [25]. Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated [19]. <p> The possibility of achieving an algorithms a la Huet depend crucially on flex-flex equations being always solvable. If this property does not hold, as in some sublanguages of S !ffi&&gt; we will discuss shortly, these equations must be analyzed with techniques similar to [18] or <ref> [21] </ref>. The procedure we just described is not guaranteed to terminate for generic equation systems since flex-rigid steps can produce arbitrarily complex new equations. <p> However, the non-determinism it introduces remains a problem, especially in logic programming. This issue is exacerbated in !ffi&&gt; due to its additional resource non-determinism during imitation and projections. For ! , this problem has been addressed by Miller's language of higher-order patterns L <ref> [21] </ref>, which allows occurrences of logical variables to be applied to distinct parameters only. This syntactic restriction guarantees decidability and most general unifiers.
Reference: [22] <author> D. Miller. </author> <title> A multiple-conclusion specification logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 165(1) </volume> <pages> 201-232, </pages> <year> 1996. </year>
Reference-contexts: Attempts at mechanizing this additional expressive power led to the design of several logic programming languages based on various fragments of linear logic. The only new aspect in the operational semantics of most proposals, such as Lolli [15], Lygon [12] and Forum <ref> [22] </ref>, concerns the management of linear context formulas [3]. In particular, the instantiation of logical variables relies on the traditional unification algorithms, in their first- or higher-order variants, depending on the language.
Reference: [23] <author> G. Nadathur and D. Miller. </author> <title> An overview of Prolog. </title> <editor> In K. A. Bowen and R. A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Washington, Aug. 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Nevertheless sound and complete (although possibly non-terminating) procedures have been proposed in order to enumerate solutions [18]. In particular, Huet's pre-unification algorithm [16] computes unifiers in a non-redundant manner as constraints and has therefore been adopted in the implementation of higher-order logic programming languages <ref> [23] </ref>. Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. An example are Miller's higher-order patterns [21], that have been implemented in the higher-order constraint logic programming language Elf [25]. <p> clearly apply also in this setting, but we have no result about the decidability of higher-order unification in this fragment. 4.2 Towards a Practical Implementation Huet's algorithm for pre-unification in ! has been implemented in general proof search engines such as Isabelle [24] and logic programming languages such as Prolog <ref> [23] </ref> and shown itself to be reasonably efficient in practice. However, the non-determinism it introduces remains a problem, especially in logic programming. This issue is exacerbated in !ffi&&gt; due to its additional resource non-determinism during imitation and projections.
Reference: [24] <editor> T. Nipkow and L. C. Paulson. Isabelle-91. In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 673-676, </pages> <address> Saratoga Springs, NY, </address> <year> 1992. </year> <note> Springer-Verlag LNAI 607. System abstract. </note>
Reference-contexts: The above counterexamples clearly apply also in this setting, but we have no result about the decidability of higher-order unification in this fragment. 4.2 Towards a Practical Implementation Huet's algorithm for pre-unification in ! has been implemented in general proof search engines such as Isabelle <ref> [24] </ref> and logic programming languages such as Prolog [23] and shown itself to be reasonably efficient in practice. However, the non-determinism it introduces remains a problem, especially in logic programming. This issue is exacerbated in !ffi&&gt; due to its additional resource non-determinism during imitation and projections.
Reference: [25] <author> F. Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In G. Huet and G. Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Fragments of ! of practical relevance for which unification is decidable and yields most general unifiers have also been discovered. An example are Miller's higher-order patterns [21], that have been implemented in the higher-order constraint logic programming language Elf <ref> [25] </ref>. Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated [19]. Unification in ! with linear restrictions on existential variables has been studied in [26]. <p> This syntactic restriction guarantees decidability and most general unifiers. An algorithm that solves equations in the pattern fragment but postpones as constraints any non L constraint has been successfully implemented in the higher-order logic programming language Elf <ref> [25] </ref>. Unfortunately, an analogous restriction for !ffi&&gt; which would cover the situations arising in practice does not admit most general unifiers. <p> The second equation above would simply be postponed as a solvable equational constraint. Based on our experience with constraint simplification in Elf <ref> [25] </ref> and preliminary experiments, we believe that this will be a practical solution.
Reference: [26] <author> C. Prehofer. </author> <title> Solving Higher-Order Equations: From Logic to Programming. </title> <type> PhD thesis, </type> <institution> Technische Uni-versitat Munchen, </institution> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: Unification in the context of linear -calculi has received limited attention in the literature and, to our knowledge, only a restricted fragment of a multiplicative language has been treated [19]. Unification in ! with linear restrictions on existential variables has been studied in <ref> [26] </ref>. In this extended abstract, we investigate the unification problem in the linear simply-typed -calculus !ffi&&gt; . We give a pre-unification procedure in the style of Huet and discuss the new sources of non-determinism due to linearity.
Reference: [27] <author> W. Snyder and J. H. Gallier. </author> <title> Higher order unification revisited: Complete sets of transformations. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8(1-2):101-140, </volume> <year> 1989. </year> <month> 12 </month>
Reference-contexts: Proof: By induction on the structure of X . 2 Note that it is not difficult to generalize this procedure to full unification (as, for example, in <ref> [27] </ref>), although we fail to see its practical value.
References-found: 27

