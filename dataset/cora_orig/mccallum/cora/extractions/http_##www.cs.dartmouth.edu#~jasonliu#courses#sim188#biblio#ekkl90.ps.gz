URL: http://www.cs.dartmouth.edu/~jasonliu/courses/sim188/biblio/ekkl90.ps.gz
Refering-URL: http://www.cs.dartmouth.edu/~jasonliu/courses/sim188/notes-10.html
Root-URL: http://www.cs.dartmouth.edu
Title: Techniques for Efficient Inline Tracing on a Shared-Memory Multiprocessor design, few traces of parallel programs
Author: David R. Keppel, Eric J. Koldinger, Susan J. Eggers, and Henry M. Levy 
Date: 1, May  
Note: cessor  This work was supported in part by the National Science Foundation under Grants No. CCR-8619663, CCR-8904190 and CCR-8907666, and by The Boeing Corporation. Published in Proceedings of the 1990 ACM Sigmetrics Conference on Measurement and Modeling of Computer Systems. Performance Evaluation Review Volume 18, Number  1990.  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: This paper describes a new tool, called MPtrace, for collecting traces of multithreaded parallel programs executing on shared-memory multiprocessors. MPtrace requires no hardware or mi crocode modification; it collects complete program traces; it is portable; and it reduces execution-time dilation to less than a factor 3. MPtrace is based on inline tracing, in which a program is automatically modified to produce trace information as it executes. We show how the use of compiler flow analysis techniques can reduce the amount of data collected and therefore the runtime dilation of the traced program. We also discuss problematic issues concerning buffering and writing of trace data on a multiprocessor. 
Abstract-found: 1
Intro-found: 1
Reference: [Agarwal et al. 86] <author> A. Agarwal, R. L. Sites, and M. Horowitz. ATUM: </author> <title> A new technique for capturing address traces using microcode. </title> <booktitle> In Proceedings of the 13th International Symposium on Computer Architecture, </booktitle> <pages> pages 119-127, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: A more efficient alternative to trap-oriented trace 1 generation is microcode modification on a micropro--grammed computer. One such tool, called ATUM, has been used on both uniprocessors and multiprocessors <ref> [Agarwal et al. 86, Sites & Agarwal 88] </ref>. An advantage of microcode alteration is that all exe cuting code, including the operating system, can be traced. <p> Even with the microcode approach, the dilation may be as high as 20, because a special microrou-tine is invoked on every reference <ref> [Agarwal et al. 86] </ref>. This paper describes a software tool, called MPtrace, that provides another alternative for tracing the execution of multi-threaded applications on a shared-memory multiprocessor.
Reference: [Bershad et al. 88] <author> B. N. Bershad, E. D. Lazowska, and H. M. Levy. </author> <title> PRESTO: A system for object-oriented parallel programming. </title> <journal> Software Practice and Experience, </journal> <volume> 18(8), </volume> <month> August </month> <year> 1988. </year>
Reference: [Borg et al. 89] <author> A. Borg, R. Kessler, G. Lazana, and D. W. Wall. </author> <title> Long address traces from RISC machines: Generation and analysis. </title> <type> Technical Report 89/14, </type> <institution> Digtal Equipment Corporation Western Research Laboratory, </institution> <address> Palo Alto, CA, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: A similar system, based on link-time code modification, has been constructed for uniprocessor tracing and analysis on the TITAN <ref> [Borg et al. 89] </ref>. Its dilation, again excluding simulation, ranges from 8 to 12 times normal program execution. Finally, a similar technique has been used to implement a software instruction counter for debugging [Mellor-Crummey & LeBlanc 89].
Reference: [Devadas & Newton 87] <author> S. Devadas and A. New-ton. </author> <title> Topological optimization of multiple level array logic. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <month> November </month> <year> 1987. </year>
Reference-contexts: We purposely separate measurements of tracing from those including storage of trace buffers: the former reflects the capability of our techniques; the latter reflects the capacity of the underlying hardware configuration. The four traced programs, which are listed in Table 1, were originally written for the Sequent Balance. Topopt <ref> [Devadas & Newton 87] </ref> does topological compaction of MOS circuits, using dynamic windowing and partitioning techniques; Topopt's algorithm is based on simulated annealing. Psplice is a circuit simulator combining the original direct method solution with waveform relaxation.
Reference: [Eggers & Katz 89] <author> S. J. Eggers and R. H. Katz. </author> <title> The effect of sharing on the cache and bus performance of parallel programs. </title> <booktitle> In Proceedings of the 3rd International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> April </month> <year> 1989. </year>
Reference: [Hill 87] <author> M. D. Hill. </author> <title> Aspects of Cache Memory and Instruction Buffer Performance. </title> <type> PhD dissertation, </type> <institution> University of Califor-nia, Berkeley, </institution> <month> November </month> <year> 1987. </year>
Reference: [Lovett & Thakkar 88] <author> R. Lovett and S. Thakkar. </author> <title> The Symmetry multiprocessory system. </title> <booktitle> In Proceedings of the 1988 International Conference on Parallel Processing, </booktitle> <pages> pages 303-310, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: The tracing code is highly portable; the machine-dependent portions of the system are limited to 25 percent of the code, over two thirds of which is a description of the instruction set. (While the current implementation of MPtrace executes on the Sequent Symmetry <ref> [Lovett & Thakkar 88] </ref>, which uses Intel 80386 processors, RISC machines will have much smaller descriptions, and therefore proportionately less machine-dependent code.) If the OS scheduler allows migration, then it must be modified so that when a process (thread) is rescheduled, the scheduler will drop a timestamp and processor number into
Reference: [Ma et al. 87] <author> H.-K. T. Ma, S. Devadas, R. Wei, and A. Sangiovanni-Vincentelli. </author> <title> Logic verification algorithms and their parallel implementation. </title> <booktitle> In Proceedings of the 24th Design Automation Conference, </booktitle> <pages> pages 283-290, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Topopt [Devadas & Newton 87] does topological compaction of MOS circuits, using dynamic windowing and partitioning techniques; Topopt's algorithm is based on simulated annealing. Psplice is a circuit simulator combining the original direct method solution with waveform relaxation. Ver ify <ref> [Ma et al. 87] </ref> is a combinational logic verification program, that compares two different circuit implementations to determine whether they are functionally (Boolean) equivalent. The final program, Psim, simulates switch nodes for a non-shared bus interconnect.
Reference: [Mellor-Crummey & LeBlanc 89] <author> J. M. Mellor-Crummey and T. J. LeBlanc. </author> <title> A software instruction counter. </title> <booktitle> In Proceedings of the 3rd Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 78-86, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Its dilation, again excluding simulation, ranges from 8 to 12 times normal program execution. Finally, a similar technique has been used to implement a software instruction counter for debugging <ref> [Mellor-Crummey & LeBlanc 89] </ref>. The objective of this paper is both to describe MPtrace and to evaluate the techniques it uses to reduce dilation. The rest of the paper is organized as follows. The next section presents an overview of MPtrace, describing its operation and its processing phases.
Reference: [MIPS 86] <author> MIPS. </author> <title> Languages and Programmer's Manual. MIPS Computer Systems, </title> <publisher> Inc., </publisher> <year> 1986. </year>
Reference-contexts: The basic approach, inline tracing, has been used in other tracing and performance tools. Our technique differs from these systems in both the application targeted and the amount of dilation achieved. Pixie <ref> [MIPS 86] </ref> is a profiling tool developed to analyze basic block usage and execution time on the MIPS R2000. TRAPEDS [Stunkel & Fuchs 89] is a facility for performing trace-driven simulations on non-shared memory multicomputers (e.g., the Intel Hypercube).
Reference: [Przybylski et al. 88] <author> S. Przybylski, M. Horowitz, and J. Hennessy. </author> <title> Performance tradeoffs in cache design. </title> <booktitle> In Proceedings of the 15th International Symposium on Computer Architecture, </booktitle> <pages> pages 290-298, </pages> <month> May </month> <year> 1988. </year>
Reference: [Shustek 78] <author> L. J. Shustek. </author> <title> Analysis and Performance of Computer Instruction Sets. </title> <type> PhD dissertation, </type> <institution> Stanford University, </institution> <month> January </month> <year> 1978. </year>
Reference-contexts: While trap-oriented trace generation is sufficient for use in uniprocessors, its application for multiprocessor tracing is somewhat questionable. The problem is that traps and subsequent instruction analysis drastically slow the execution of a program, often by two or three orders of magnitude <ref> [Shustek 78, Wiecek 82] </ref>. This dilation is not important in the uniprocessor case, because the trace content is independent of the dilation factor; in other words, data gathered by the trap analysis is identical to data that would be gathered in real-time by a hardware monitor.
Reference: [Sites & Agarwal 88] <author> R. L. Sites and A. Agar-wal. </author> <title> Multiprocessor cache analysis using ATUM. </title> <booktitle> In Proceedings of the 15th International Symposium on Computer Architecture, </booktitle> <pages> pages 186-195, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: A more efficient alternative to trap-oriented trace 1 generation is microcode modification on a micropro--grammed computer. One such tool, called ATUM, has been used on both uniprocessors and multiprocessors <ref> [Agarwal et al. 86, Sites & Agarwal 88] </ref>. An advantage of microcode alteration is that all exe cuting code, including the operating system, can be traced.
Reference: [Smith 82] <author> A. J. Smith. </author> <title> Cache memories. </title> <journal> ACM Computing Surveys, </journal> <volume> 14(3) </volume> <pages> 473-530, </pages> <month> September </month> <year> 1982. </year>
Reference: [Stunkel & Fuchs 89] <author> C. B. Stunkel and W. K. Fuchs. TRAPEDS: </author> <title> Producing traces for multicomputers via execution driven simulation. </title> <booktitle> In Proceedings of the International Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 70-78, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Our technique differs from these systems in both the application targeted and the amount of dilation achieved. Pixie [MIPS 86] is a profiling tool developed to analyze basic block usage and execution time on the MIPS R2000. TRAPEDS <ref> [Stunkel & Fuchs 89] </ref> is a facility for performing trace-driven simulations on non-shared memory multicomputers (e.g., the Intel Hypercube). It modifies an assembly program, but inserts both tracing instructions and calls to a run-time simulator; the simulator processes and then disposes of the trace data.
Reference: [Wiecek 82] <author> C. A. Wiecek. </author> <title> A case study of VAX-11 instruction set usage for compiler execution. </title> <booktitle> In Proceedings, Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 177-184, </pages> <month> March </month> <year> 1982. </year>
Reference-contexts: While trap-oriented trace generation is sufficient for use in uniprocessors, its application for multiprocessor tracing is somewhat questionable. The problem is that traps and subsequent instruction analysis drastically slow the execution of a program, often by two or three orders of magnitude <ref> [Shustek 78, Wiecek 82] </ref>. This dilation is not important in the uniprocessor case, because the trace content is independent of the dilation factor; in other words, data gathered by the trap analysis is identical to data that would be gathered in real-time by a hardware monitor.
References-found: 16

