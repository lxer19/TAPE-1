URL: http://www.iro.umontreal.ca/~lecuyer/myftp/papers/clcg4.ps
Refering-URL: http://www.iro.umontreal.ca/~lecuyer/papers.html
Root-URL: http://www.iro.umontreal.ca
Title: A Random Number Generator Based on the Combination of Four LCGs  
Author: Pierre L'ECUYER Terry H. ANDRES P. L'Ecuyer, T. Andres, AECL Whiteshell 
Keyword: Random number generation, jump-ahead, software package.  
Address: Montreal  Montreal, C.P. 6128, Succ. Centre-Ville, Montreal, H3C 3J7, Canada;  Pinawa, Manitoba, R0E 1L0, Canada;  
Affiliation: Universite de  Atomic Energy of Canada Limited  Departement d'Informatique et de Recherche Operationnelle (IRO), Universite de  Laboratories  
Note: Version:  Authors' Addresses:  
Email: e-mail: lecuyer@iro.umontreal.ca  e-mail: andrest@wl.aecl.ca  
Web: www: http://www.iro.umontreal.ca/lecuyer  
Date: November 25, 1997  
Abstract: A portable package for uniform random number generation is proposed, based on a backbone generator with period length near 2 121 , which is a combination of four linear congruential generators. The package provides for multiple (virtual) generators evolving in parallel. Each generator also has many disjoint subsequences, and software tools are provided to reset the state of any generator to the beginning of its first, previous, or current subsequence. Such facilities are helpful to maintain synchronization for implementing variance reduction methods in simulation. Computer implementations are available in the C and Modula-2 languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Bratley, B. L. Fox, and L. E. </author> <title> Schrage. A Guide to Simulation. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1987. </year>
Reference-contexts: What is the use of such a package? Suppose one wants to compare two similar systems using simulation with common random numbers, with n simulation runs for each system. (For more details about common random numbers and other variance reduction techniques, see for example <ref> [1, 3] </ref>.) To make sure that each pair of runs comparing the two systems uses the same random numbers for the same purpose, one would assign different generators to different parts of the system (e.g., for comparing two similar queueing systems, one stream for the interarrival times, one stream for the <p> Those values must satisfy: 1 s [0] 2147483646, 1 s <ref> [1] </ref> 2147483542, 1 s [2] 2147483422, 10 1 s [3] 2147483322. The initial seeds of all other generators are recomputed accordingly, so they are spaced V W values apart, and all generators are reinitialized to their initial seeds. void InitGenerator (Gen g, SeedType Where); Reinitialize the generator g. <p> The last seed L g is also reset to the same value as C g . void SetSeed (Gen g, long s [4]); Set initial seed I g of generator g to s <ref> [1] </ref>,...,s [4]. Those values must satisfy: 1 s [0] 2147483646, 1 s [1] 2147483542, 1 s [2] 2147483422, 1 s [3] 2147483322. <p> g are also put to that seed. void GetState (Gen g, long s [4]); Returns the current state C g of generator g in s [0],...,s [3]. void WriteState (Gen g); Writes the current state C g of generator g. double GenVal (Gen g); Returns a "uniform" random number over <ref> [0; 1] </ref>, using generator g.
Reference: [2] <author> D. E. Knuth. </author> <booktitle> The Art of Computer Programming, Volume 2: Seminumerical Algorithms. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <note> second edition, </note> <year> 1981. </year>
Reference-contexts: Another application is for parallel simulation on several processors. In this case, one uses a different (virtual) generator on each processor. These generators are the same except for their seeds. This makes the implementation much easier. For more background on random number generation see, for example, <ref> [2, 7, 8, 12] </ref>. In the next section, we explain how the backbone generator was chosen, based on a lattice structure analysis of its successive output values. <p> It turns out that T t is equal to the intersection of a lattice L t with the unit t-dimensional cube [0; 1) t , which means that the points of T t form a very regular structure (see, e.g., <ref> [2, 11, 10] </ref> for more details on this lattice structure). In particular, all these points lie on a relatively small number of equidistant parallel hyperplanes. <p> Computing d t can be formulated as a quadratic integer optimization problem and is sometimes called the spectral test <ref> [2] </ref>. The value of d t can be normalized to S t = d fl t (m)=d t , where d fl t (m) is a lower bound on d t for any t-dimensional lattice whose intersection with the unit hypercube [0; 1) t contains m points. <p> Those values must satisfy: 1 s [0] 2147483646, 1 s [1] 2147483542, 1 s <ref> [2] </ref> 2147483422, 10 1 s [3] 2147483322. The initial seeds of all other generators are recomputed accordingly, so they are spaced V W values apart, and all generators are reinitialized to their initial seeds. void InitGenerator (Gen g, SeedType Where); Reinitialize the generator g. <p> The last seed L g is also reset to the same value as C g . void SetSeed (Gen g, long s [4]); Set initial seed I g of generator g to s [1],...,s [4]. Those values must satisfy: 1 s [0] 2147483646, 1 s [1] 2147483542, 1 s <ref> [2] </ref> 2147483422, 1 s [3] 2147483322.
Reference: [3] <author> A. M. Law and W. D. </author> <title> Kelton. Simulation Modeling and Analysis. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1991. </year>
Reference-contexts: What is the use of such a package? Suppose one wants to compare two similar systems using simulation with common random numbers, with n simulation runs for each system. (For more details about common random numbers and other variance reduction techniques, see for example <ref> [1, 3] </ref>.) To make sure that each pair of runs comparing the two systems uses the same random numbers for the same purpose, one would assign different generators to different parts of the system (e.g., for comparing two similar queueing systems, one stream for the interarrival times, one stream for the <p> 22222222; 33333333; 44444444). void InitDefault (); Initializes the package as in Init, with the default values V = 2 31 and W = 2 41 . void SetInitialSeed (long s [4]); Set the initial seed I 0 of generator number 0 (g = 0) to the integer values s [0],...,s <ref> [3] </ref>. Those values must satisfy: 1 s [0] 2147483646, 1 s [1] 2147483542, 1 s [2] 2147483422, 10 1 s [3] 2147483322. <p> and W = 2 41 . void SetInitialSeed (long s [4]); Set the initial seed I 0 of generator number 0 (g = 0) to the integer values s [0],...,s <ref> [3] </ref>. Those values must satisfy: 1 s [0] 2147483646, 1 s [1] 2147483542, 1 s [2] 2147483422, 10 1 s [3] 2147483322. The initial seeds of all other generators are recomputed accordingly, so they are spaced V W values apart, and all generators are reinitialized to their initial seeds. void InitGenerator (Gen g, SeedType Where); Reinitialize the generator g. <p> Those values must satisfy: 1 s [0] 2147483646, 1 s [1] 2147483542, 1 s [2] 2147483422, 1 s <ref> [3] </ref> 2147483322. The current state C g and last seed L g are also put to that seed. void GetState (Gen g, long s [4]); Returns the current state C g of generator g in s [0],...,s [3]. void WriteState (Gen g); Writes the current state C g of generator g. <p> s [0] 2147483646, 1 s [1] 2147483542, 1 s [2] 2147483422, 1 s <ref> [3] </ref> 2147483322. The current state C g and last seed L g are also put to that seed. void GetState (Gen g, long s [4]); Returns the current state C g of generator g in s [0],...,s [3]. void WriteState (Gen g); Writes the current state C g of generator g. double GenVal (Gen g); Returns a "uniform" random number over [0; 1], using generator g.
Reference: [4] <author> P. L'Ecuyer. </author> <title> Efficient and portable combined random number generators. </title> <journal> Communications of the ACM, </journal> <note> 31(6) 742-749 and 774, 1988. See also the correspondance in the same journal, 32, 8 (1989) 1019-1024. </note>
Reference-contexts: L'Ecuyer and Cote [9] describe a package with 32 (virtual) generators, with seeds spaced 2 50 values apart. It is based on a combined linear congruential generator (LCG) with period length ae 2 61 , previously proposed by L'Ecuyer <ref> [4] </ref>. Each generator corresponds to a subsequence of 2 50 values, which is further split into V = 2 20 segments of length W = 2 30 . <p> Section 3 gives the functional definition of the package, and then the implementation, in the C language. 2 A Combination of Four LCGs 2.1 Combined LCGs Wichmann and Hill [13] and L'Ecuyer <ref> [4] </ref> proposed slightly different methods for combining LCGs with distinct prime moduli. <p> L'Ecuyer and Tezuka [11] later showed that a combined generator of the Wichmann and Hill type is in fact an LCG with modulus equal to the product of the moduli of the individual components, and that the combination method of <ref> [4] </ref> is approximately equivalent. To be more specific, consider J LCGs, based on the recurrences x j;n = a j x j;n1 mod m j ; for j = 1; : : : ; J. <p> The tests applied included in particular the 21 tests that were applied in <ref> [4] </ref>, the 10 tests applied in [6] (which many popular generators failed), plus many others. <p> The initial seed is set by default to (11111111; 22222222; 33333333; 44444444). void InitDefault (); Initializes the package as in Init, with the default values V = 2 31 and W = 2 41 . void SetInitialSeed (long s <ref> [4] </ref>); Set the initial seed I 0 of generator number 0 (g = 0) to the integer values s [0],...,s [3]. Those values must satisfy: 1 s [0] 2147483646, 1 s [1] 2147483542, 1 s [2] 2147483422, 10 1 s [3] 2147483322. <p> The last seed L g is also reset to the same value as C g . void SetSeed (Gen g, long s <ref> [4] </ref>); Set initial seed I g of generator g to s [1],...,s [4]. Those values must satisfy: 1 s [0] 2147483646, 1 s [1] 2147483542, 1 s [2] 2147483422, 1 s [3] 2147483322. <p> The last seed L g is also reset to the same value as C g . void SetSeed (Gen g, long s <ref> [4] </ref>); Set initial seed I g of generator g to s [1],...,s [4]. Those values must satisfy: 1 s [0] 2147483646, 1 s [1] 2147483542, 1 s [2] 2147483422, 1 s [3] 2147483322. The current state C g and last seed L g are also put to that seed. void GetState (Gen g, long s [4]); Returns the current state C g of <p> g of generator g to s [1],...,s <ref> [4] </ref>. Those values must satisfy: 1 s [0] 2147483646, 1 s [1] 2147483542, 1 s [2] 2147483422, 1 s [3] 2147483322. The current state C g and last seed L g are also put to that seed. void GetState (Gen g, long s [4]); Returns the current state C g of generator g in s [0],...,s [3]. void WriteState (Gen g); Writes the current state C g of generator g. double GenVal (Gen g); Returns a "uniform" random number over [0; 1], using generator g. <p> The current state C g is changed, but not I g and L g . #endif 4 Implementation in C #include &lt;stdio.h&gt; #include "clcg4.h" /***********************************************************************/ /* Private part. */ /***********************************************************************/ #define H 32768 /* = 2^15 : use in MultModM. */ static long aw <ref> [4] </ref>, avw [4], /* a [j]^-2^w- et a [j]^-2^-v+w--. */ a [4] = - 45991, 207707, 138556, 49689 -, static long Ig [4][Maxgen+1], Lg [4][Maxgen+1], Cg [4][Maxgen+1]; /* Initial seed, previous seed, and current seed. */ static short i, j; static long MultModM (long s, long t, long M) 11 /* <p> The current state C g is changed, but not I g and L g . #endif 4 Implementation in C #include &lt;stdio.h&gt; #include "clcg4.h" /***********************************************************************/ /* Private part. */ /***********************************************************************/ #define H 32768 /* = 2^15 : use in MultModM. */ static long aw <ref> [4] </ref>, avw [4], /* a [j]^-2^w- et a [j]^-2^-v+w--. */ a [4] = - 45991, 207707, 138556, 49689 -, static long Ig [4][Maxgen+1], Lg [4][Maxgen+1], Cg [4][Maxgen+1]; /* Initial seed, previous seed, and current seed. */ static short i, j; static long MultModM (long s, long t, long M) 11 /* Returns (s*t) <p> is changed, but not I g and L g . #endif 4 Implementation in C #include &lt;stdio.h&gt; #include "clcg4.h" /***********************************************************************/ /* Private part. */ /***********************************************************************/ #define H 32768 /* = 2^15 : use in MultModM. */ static long aw <ref> [4] </ref>, avw [4], /* a [j]^-2^w- et a [j]^-2^-v+w--. */ a [4] = - 45991, 207707, 138556, 49689 -, static long Ig [4][Maxgen+1], Lg [4][Maxgen+1], Cg [4][Maxgen+1]; /* Initial seed, previous seed, and current seed. */ static short i, j; static long MultModM (long s, long t, long M) 11 /* Returns (s*t) MOD M. <p> += S1*(t - k*q); while (R &lt; 0) R += M; - while (R &lt; 0) R += M; - - if (R &gt; 0) R -= M; while (R &lt; 0) R += M; - return R; - /* Public part. */ /*---------------------------------------------------------*/ void SetSeed (Gen g, long s <ref> [4] </ref>) - if (g &gt; Maxgen) printf ("ERROR: SetSeed with g &gt; Maxgen "n"); for (j = 0; j &lt; 4; j++) Ig [j][g] = s [j]; InitGenerator (g, InitialSeed); - void WriteState (Gen g) - printf (""n State of generator g = %u :", g); for (j = 0; j <p> [j][g] = s [j]; InitGenerator (g, InitialSeed); - void WriteState (Gen g) - printf (""n State of generator g = %u :", g); for (j = 0; j &lt; 4; j++) printf (""n Cg [%u] = %lu", j, Cg [j][g]); - printf (""n"); - void GetState (Gen g, long s <ref> [4] </ref>) - - void InitGenerator (Gen g, SeedType Where) - if (g &gt; Maxgen) printf ("ERROR: InitGenerator with g &gt; Maxgen "n"); for (j = 0; j &lt; 4; j++) switch (Where) - case InitialSeed : Lg [j][g] = Ig [j][g]; break; case NewSeed : Lg [j][g] = MultModM (aw [j], <p> InitGenerator with g &gt; Maxgen "n"); for (j = 0; j &lt; 4; j++) switch (Where) - case InitialSeed : Lg [j][g] = Ig [j][g]; break; case NewSeed : Lg [j][g] = MultModM (aw [j], Lg [j][g], m [j]); break; case LastSeed : break; - - void SetInitialSeed (long s <ref> [4] </ref>) - for (j = 0; j &lt; 4; j++) Ig [j][0] = s [j]; InitGenerator (0, InitialSeed); for (g = 1; g &lt;= Maxgen; g++) - Ig [j][g] = MultModM (avw [j], Ig [j][g-1], m [j]); InitGenerator (g, InitialSeed); - void Init (long v, long w) - long sd [4] <p> <ref> [4] </ref>) - for (j = 0; j &lt; 4; j++) Ig [j][0] = s [j]; InitGenerator (0, InitialSeed); for (g = 1; g &lt;= Maxgen; g++) - Ig [j][g] = MultModM (avw [j], Ig [j][g-1], m [j]); InitGenerator (g, InitialSeed); - void Init (long v, long w) - long sd [4] = -11111111, 22222222, 33333333, 44444444-; for (j = 0; j &lt; 4; j++) aw [j] = a [j]; aw [j] = MultModM (aw [j], aw [j], m [j]); avw [j] = aw [j]; avw [j] = MultModM (avw [j], avw [j], m [j]); - SetInitialSeed (sd); - double GenVal (Gen
Reference: [5] <author> P. L'Ecuyer. </author> <title> Random numbers for simulation. </title> <journal> Communications of the ACM, </journal> <volume> 33(10) </volume> <pages> 85-97, </pages> <year> 1990. </year>
Reference: [6] <author> P. L'Ecuyer. </author> <title> Testing random number generators. </title> <booktitle> In Proceedings of the 1992 Winter Simulation Conference, </booktitle> <pages> pages 305-313. </pages> <publisher> IEEE Press, </publisher> <month> Dec </month> <year> 1992. </year>
Reference-contexts: The tests applied included in particular the 21 tests that were applied in [4], the 10 tests applied in <ref> [6] </ref> (which many popular generators failed), plus many others.
Reference: [7] <author> P. L'Ecuyer. </author> <title> Uniform random number generation. </title> <journal> Annals of Operations Research, </journal> <volume> 53 </volume> <pages> 77-120, </pages> <year> 1994. </year>
Reference-contexts: Another application is for parallel simulation on several processors. In this case, one uses a different (virtual) generator on each processor. These generators are the same except for their seeds. This makes the implementation much easier. For more background on random number generation see, for example, <ref> [2, 7, 8, 12] </ref>. In the next section, we explain how the backbone generator was chosen, based on a lattice structure analysis of its successive output values.
Reference: [8] <author> P. L'Ecuyer. </author> <title> Random number generation. In Jerry Banks, editor, Handbook on Simulation. </title> <publisher> Wiley, </publisher> <year> 1997. </year> <note> To appear. Also GERAD technical report number G-96-38. </note>
Reference-contexts: Another application is for parallel simulation on several processors. In this case, one uses a different (virtual) generator on each processor. These generators are the same except for their seeds. This makes the implementation much easier. For more background on random number generation see, for example, <ref> [2, 7, 8, 12] </ref>. In the next section, we explain how the backbone generator was chosen, based on a lattice structure analysis of its successive output values.
Reference: [9] <author> P. L'Ecuyer and S. Cote. </author> <title> Implementing a random number package with splitting facilities. </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 17(1) </volume> <pages> 98-111, </pages> <year> 1991. </year>
Reference-contexts: Almost always, all these sequences are from the same underlying random number generator, but using different starting points (or seeds) in the main sequence. L'Ecuyer and Cote <ref> [9] </ref> describe a package with 32 (virtual) generators, with seeds spaced 2 50 values apart. It is based on a combined linear congruential generator (LCG) with period length ae 2 61 , previously proposed by L'Ecuyer [4]. <p> construct a combined LCG with 4 components, with the following properties. * Each component is an LCG with prime modulus m j slightly smaller than 2 31 , multiplier a j such that (m j mod a j ) &lt; m j =a j (for ease of implementation, as in <ref> [9] </ref>), and full period length ae j = m j 1. * The moduli satisfy m j &lt; m j1 100 for j &gt; 1 and (m 1 1)=2; : : : ; (m 4 1)=2 have no common factor, so the combined generator has period length equal to the product <p> For comparison, Table 2 gives the corresponding values for the combined LCG with two components on which the package of <ref> [9] </ref> is based. In all dimensions t, the distances d t between the hyperplanes are significantly smaller in Table 1 than in Table 2, so the new proposal is a clear improvement. <p> So, empirically, it behaves as expected. Of course, empirical statistical testing never proves that a generator is safe, but at least it improves one's confidence. 3 Functional Definition of the Package We now give the functional definition of the package. In contrast to L'Ecuyer and Cote <ref> [9] </ref>, here the values of V and W can be changed by calling the procedure Init. The default values are V = 2 31 and W = 2 41 . The initial seed can also be changed by calling SetInitialSeed after calling Init.
Reference: [10] <author> P. L'Ecuyer and R. Couture. </author> <title> An implementation of the lattice and spectral tests for multiple recursive linear random number generators. </title> <journal> INFORMS Journal on Computing, </journal> <note> Circa 1997. To appear. </note>
Reference-contexts: It turns out that T t is equal to the intersection of a lattice L t with the unit t-dimensional cube [0; 1) t , which means that the points of T t form a very regular structure (see, e.g., <ref> [2, 11, 10] </ref> for more details on this lattice structure). In particular, all these points lie on a relatively small number of equidistant parallel hyperplanes. <p> Computing q t is typically more costly than d t . Both can be computed using the software package of <ref> [10] </ref>. 2.3 Finding a Good Combination Our goal was to construct a combined LCG with 4 components, with the following properties. * Each component is an LCG with prime modulus m j slightly smaller than 2 31 , multiplier a j such that (m j mod a j ) &lt; m
Reference: [11] <author> P. L'Ecuyer and S. Tezuka. </author> <title> Structural properties for two classes of combined random number generators. </title> <journal> Mathematics of Computation, </journal> <volume> 57(196) </volume> <pages> 735-746, </pages> <year> 1991. </year>
Reference-contexts: Section 3 gives the functional definition of the package, and then the implementation, in the C language. 2 A Combination of Four LCGs 2.1 Combined LCGs Wichmann and Hill [13] and L'Ecuyer [4] proposed slightly different methods for combining LCGs with distinct prime moduli. L'Ecuyer and Tezuka <ref> [11] </ref> later showed that a combined generator of the Wichmann and Hill type is in fact an LCG with modulus equal to the product of the moduli of the individual components, and that the combination method of [4] is approximately equivalent. <p> Define the two combinations: z n = @ j=1 1 3 and 0 J X ffi j x j;n 1 Let m = j=1 m j . The following is proved in <ref> [11] </ref>. Theorem 1. (i) The sequences fu n g and fw n g both have period length ae = lcm (ae 1 ; : : : ; ae J ) (the least common multiple of the ae j ). <p> even and the maximum possible value of ae is ae = (m 1 1) (m J 1)=2 J1 . (ii) The w n obey the recurrence: x n = ax n1 mod m; w n = x n =m; (3) where a can be computed by a formula given in <ref> [11] </ref> and does not depend on the ffi j . (iii) One has u n = w n + * n , with * n + , where and + can be computed as explained in [11] and are very small when the m j are close to each other. <p> x n =m; (3) where a can be computed by a formula given in <ref> [11] </ref> and does not depend on the ffi j . (iii) One has u n = w n + * n , with * n + , where and + can be computed as explained in [11] and are very small when the m j are close to each other. The combinations (1) and (2) are thus practical ways of implementing an LCG with large modulus m and multiplier a. <p> It turns out that T t is equal to the intersection of a lattice L t with the unit t-dimensional cube [0; 1) t , which means that the points of T t form a very regular structure (see, e.g., <ref> [2, 11, 10] </ref> for more details on this lattice structure). In particular, all these points lie on a relatively small number of equidistant parallel hyperplanes.
Reference: [12] <author> H. Niederreiter. </author> <title> Random Number Generation and Quasi-Monte Carlo Methods, </title> <booktitle> volume 63 of SIAM CBMS-NSF Regional Conference Series in Applied Mathematics. </booktitle> <publisher> SIAM, </publisher> <address> Philadelphia, </address> <year> 1992. </year>
Reference-contexts: Another application is for parallel simulation on several processors. In this case, one uses a different (virtual) generator on each processor. These generators are the same except for their seeds. This makes the implementation much easier. For more background on random number generation see, for example, <ref> [2, 7, 8, 12] </ref>. In the next section, we explain how the backbone generator was chosen, based on a lattice structure analysis of its successive output values.
Reference: [13] <author> B. A. Wichmann and I. D. Hill. </author> <title> An efficient and portable pseudo-random number generator. </title> <journal> Applied Statistics, </journal> <volume> 31 </volume> <pages> 188-190, </pages> <year> 1982. </year> <note> See also corrections and remarks in the same journal by Wichmann and Hill, 33 (1984) 123; McLeod 34 (1985) 198-200; Zeisel 35 (1986) 89. </note>
Reference-contexts: Section 3 gives the functional definition of the package, and then the implementation, in the C language. 2 A Combination of Four LCGs 2.1 Combined LCGs Wichmann and Hill <ref> [13] </ref> and L'Ecuyer [4] proposed slightly different methods for combining LCGs with distinct prime moduli.
References-found: 13

