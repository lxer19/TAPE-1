URL: http://www.cs.wisc.edu/~samit/gnu_plot/sigmod98.ps
Refering-URL: http://www.cs.wisc.edu/~samit/gnu_plot/
Root-URL: 
Email: famit,pmd,naughtong@cs.wisc.edu  
Title: Materialized View Selection for Multidimensional Datasets  
Author: Amit Shukla Prasad M. Deshpande Jeffrey F. Naughton 
Date: 207  
Note: Paper Number  
Address: Wisconsin Madison  
Affiliation: Computer Sciences Department University of  
Abstract: To fulfill the requirement of fast interactive multidimensional data analysis, database systems frequently statically precompute aggregate views on some subsets of dimensions and their corresponding hierarchies. However, the decision of what to precompute is difficult. The leading existing algorithm, BPUS, has a running time that is polynomial in the number of views and is guaranteed to be within (0:63 f) of optimal, where f is the fraction of available space consumed by the largest aggregate. We prove that this bound can be improved to (0:63 *) of optimal without changing the running time of BPUS by allowing aggregate views to be partially precomputed. Unfortunately, BPUS can be impractically slow. In view of this, we study the structure of the precomputation problem and show that for an important subclass of schemas, those which give rise to hypercube lattices, BPUS can be implemented very efficiently. Furthermore, we show that under certain broad conditions on hypercube lattices, an even simpler and faster algorithm, PBS, achieves the (0:63 f ) bound. Our empirically study of the behavior of PBS shows that even when this condition does not hold, PBS picks a surprisingly good set of aggregates for precomputation.
Abstract-found: 1
Intro-found: 1
Reference: [AAD+96] <author> S. Agarwal, R. Agrawal, P.M. Deshpande, A. Gupta, J.F. Naughton, R. Ramakrishnan, S. Sarawagi. </author> <title> On the Computation of Multidimensional Aggregates, </title> <booktitle> Proc. of the 22nd Int. VLDB Conf., </booktitle> <volume> 506521, </volume> <year> 1996. </year>
Reference-contexts: Lastly, alternative approaches to precomputation are offered by indexing. In particular, Bitmaps [OQ97], and Join indices [OG95] are popular ways to speedup OLAP applications. Actual precom-putation of the set of aggregates can be accomplished by using algorithms explored in <ref> [AAD+96, ZDN97] </ref>. The input to the precomputation algorithm is a lattice containing the database and the aggregate views selected for precomputation. The paper is organized as follows. Section 2 describes and justifies the cost model that we use. <p> These experiments were performed on a 200 MHz Pentium Pro running Solaris 2.5.1. The workstation had a total physical memory of 128MB. 6.1 Experiments on distributions found in Real-datasets Table 3 lists four real-life datasets which appeared in <ref> [AAD+96] </ref>. They are derived from sales transactions of department stores and mail-order companies. The number that appears next to an attribute represents the number of distinct values. We now describe the datasets. Dataset R1 This is data about a mail order company.
Reference: [BPT97] <author> E. Baralis, S. Paraboschi, E. Teniente. </author> <title> Materialized View Selection in a Multidimensional Database, </title> <booktitle> Proc. of the 23rd Int. VLDB Conf., </booktitle> <year> 1997. </year>
Reference-contexts: We call such lattices Size Restricted or SR-hypercube lattices. We show that for SR-hypercube lattices, an even simpler and faster algorithm, PBS, achieves the (0:63 f 0 ) bound. Finally, there are lattices so large that even scanning them once is expensive. For example, <ref> [BPT97] </ref> examines lattices with 10 13 aggregate views. For 2 such a large lattice, they provide heuristics to determine what views should be precomputed based a set of views the user supplies.
Reference: [DRSN97] <author> P.M. Deshpande, K. Ramasamy, A. Shukla, J.F. Naughton. </author> <title> Caching Multidimensional Queries Using Chunks. </title> <note> Submitted for publication to SIGMOD98. </note>
Reference-contexts: Another feature of this scheme is that it 5 also allows queries to partially reuse the results of previous queries with which they overlap. This is done by reorganizing storage and partitioning and storing precomputed aggregate views. An implementation of this scheme is proposed in <ref> [DRSN97] </ref>.
Reference: [GBLP96] <author> J. Gray, A. Bosworth, A. Layman, H. Pirahesh. </author> <title> Data Cube: A Relational Aggregation Operator Generalizing Group-By, </title> <booktitle> Cross-Tab, and Sub-Totals, Proc. of the 12th Int. Conf. on Data Engg., </booktitle> <pages> pp 152-159, </pages> <year> 1996. </year>
Reference-contexts: The most important class of lattices is hypercube lattices, in which aggregate views are subsets of a set of attributes. The data cube <ref> [GBLP96] </ref> operator described previously generates a hypercube lattice. Unfortunately, for a general lattice, BPUS [HRU96] can be impractically slow since it traverses the lattice multiple times while picking each view. We show by using the structure inherent in hypercube lattices, that BPUS can be implemented very efficiently for such lattices. <p> BPUS-S improves the benefit of the set of views precomputed, while retaining the execution time of BPUS. 4 Hypercube Lattices The most commonly occurring class of lattices is called hypercube lattices. They are obtained by applying the data cube operator <ref> [GBLP96] </ref>, which is the n-dimensional generalization of the SQL group-by operator. The cube on n attributes computes the group-by aggregates for each possible subset of these dimensions and their hierarchies. As with general lattices, elements of a hypercube lattice L have a partial ordering defined on them.
Reference: [GHRU97] <author> H. Gupta, V. Harinarayan, A. Rajaraman, J.D. Ullman. </author> <title> Index Selection for OLAP. </title> <booktitle> Proc. of the 13th ICDE, </booktitle> <address> 208219, </address> <year> 1997. </year>
Reference-contexts: For example, [BPT97] examines lattices with 10 13 aggregate views. For 2 such a large lattice, they provide heuristics to determine what views should be precomputed based a set of views the user supplies. Other related work includes <ref> [GHRU97] </ref>, where the authors consider the selection of views and indexes together. [Gupt97] presents a theoretical framework for the view-selection problem, and proposes a general algorithm and several heuristics. [Ull96] surveys techniques proposed for determining what aggregates should be precomputed. Lastly, alternative approaches to precomputation are offered by indexing.
Reference: [Gupt97] <author> H. Gupta. </author> <title> Selection of Views to Materialize in a Data Warehouse. </title> <booktitle> Proc. of the Sixth ICDT, </booktitle> <volume> 98112, </volume> <year> 1997. </year>
Reference-contexts: For 2 such a large lattice, they provide heuristics to determine what views should be precomputed based a set of views the user supplies. Other related work includes [GHRU97], where the authors consider the selection of views and indexes together. <ref> [Gupt97] </ref> presents a theoretical framework for the view-selection problem, and proposes a general algorithm and several heuristics. [Ull96] surveys techniques proposed for determining what aggregates should be precomputed. Lastly, alternative approaches to precomputation are offered by indexing.
Reference: [HRU96] <author> V. Harinarayan, A. Rajaraman, J.D. Ullman. </author> <title> Implementing Data Cubes Efficiently, </title> <booktitle> Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <address> 205227, </address> <year> 1996. </year>
Reference-contexts: The problem we address in this paper is determining which aggregates should be precomputed. 1 Sometimes one aggregate view can be used to compute another aggregate view. This relation between aggregate views can be used to place them within a lattice framework as proposed by <ref> [HRU96] </ref>. The following properties define a general lattice L of aggregate views. (a) There exists a partial order between aggregate views in the lattice. <p> If a set S of aggregate views is chosen for materialization, the benefit of S is the sum of the benefits of all views in S. To find a set of aggregates to materialize, <ref> [HRU96] </ref> proposes a greedy algorithm that attempts to maximize the benefit per unit space. We shall call this algorithm BPUS. <p> The most important class of lattices is hypercube lattices, in which aggregate views are subsets of a set of attributes. The data cube [GBLP96] operator described previously generates a hypercube lattice. Unfortunately, for a general lattice, BPUS <ref> [HRU96] </ref> can be impractically slow since it traverses the lattice multiple times while picking each view. We show by using the structure inherent in hypercube lattices, that BPUS can be implemented very efficiently for such lattices. <p> This model is also used by <ref> [HRU96] </ref>, which presents an experimental validation of the model. The lattice in Figure 2 has 4 dimensions: A, B, C and D. An aggregate view is labeled using the names of the attributes it is aggregated on. For example, view AB is aggregated on attributes A and B. <p> B p (v; S) = uv p u B u In our experimental evaluation section, we use the average query cost for a given set of queries as our metric since it is easier to understand for our purpose. The benefit formula presented earlier is used in <ref> [HRU96] </ref> to maximize the benefit of a set of aggregates: X B p (v; S) (2) It is not obvious that maximizing the benefit (Equation 2) is the same as minimizing the average query cost (Equation 1). <p> For 6 dimension and no hierarchies, the cost is of the order of 2 64 ! Clearly, computing the optimal set of aggregates exhaustively is not feasible; this is in fact an intractable problem (NP-hard). <ref> [HRU96] </ref> proposed a polynomial time greedy algorithm that does a good job of figuring out what to precompute. <p> Since a set of k views can widely vary in size, it is more reasonable to expect that a user will specify the amount of space available for precomputation rather than the number of aggregates to precompute. In view of this, <ref> [HRU96] </ref> presents a modified algorithm that uses the benefit per unit space of an aggregate. We will call this algorithm BPUS. <p> Proof. We show that when jvj=jwj 1=(1 + k) holds, PBS and BPUS will pick the same set of aggregates. In <ref> [HRU96] </ref>, the authors prove that if f is the ratio of the size of the largest view to the size of the database, then BPUS will pick a set of aggregate views whose benefit is no less than (0:63 f ) of the optimal benefit. <p> The database had 10M tuples. BPUS-N didn't terminate after 8 hours of execution. in Section 3 BPUS-N (Naive implementation based on algorithm proposed in <ref> [HRU96] </ref>). BPUS-H refers to the implementation we propose in Section 4 for hypercube lattices.
Reference: [RK96] <author> R. Kimball. </author> <title> The Data Warehouse Toolkit, </title> <publisher> John Wiley & Sons, </publisher> <year> 1996. </year> <month> 23 </month>
Reference: [OQ97] <author> P. O'Neil, D. Quass, </author> <title> Improved Query Performance with Variant Indexes. </title> <booktitle> Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <volume> 3849, </volume> <year> 1997. </year>
Reference-contexts: Lastly, alternative approaches to precomputation are offered by indexing. In particular, Bitmaps <ref> [OQ97] </ref>, and Join indices [OG95] are popular ways to speedup OLAP applications. Actual precom-putation of the set of aggregates can be accomplished by using algorithms explored in [AAD+96, ZDN97]. The input to the precomputation algorithm is a lattice containing the database and the aggregate views selected for precomputation.
Reference: [OG95] <author> P. O'Neil, G. Graefe, </author> <title> Multi-Table Joins Through Bitmapped Join Indices. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 811, </volume> <month> September </month> <year> 1995. </year>
Reference-contexts: Lastly, alternative approaches to precomputation are offered by indexing. In particular, Bitmaps [OQ97], and Join indices <ref> [OG95] </ref> are popular ways to speedup OLAP applications. Actual precom-putation of the set of aggregates can be accomplished by using algorithms explored in [AAD+96, ZDN97]. The input to the precomputation algorithm is a lattice containing the database and the aggregate views selected for precomputation. The paper is organized as follows.
Reference: [RS97] <author> K.A. Ross, D. Srivastava. </author> <title> Fast Computation of Sparse Datacubes. </title> <booktitle> Proc. of the 23rd Int. VLDB Conf., </booktitle> <volume> 116125, </volume> <year> 1997. </year>
Reference-contexts: We performed experiments on both real-life and synthetic datasets. Our experiments assume that queries on any aggregate are equally likely. We use analytical formulas presented in <ref> [SDNR96, RS97] </ref> to estimate the size of aggregates formed by the data cube operator. For example, consider a relation R having attributes A, B, C and D. Suppose we want to estimate the size of the group by on attributes A and B.
Reference: [SDNR96] <author> A. Shukla, P.M. Deshpande, J.F. Naughton, K. Ramasamy, </author> <title> Storage Estimation for Multidimensional Aggregates in the Presence of Hierarchies, </title> <booktitle> Proc. of the 22nd Int. VLDB Conf., </booktitle> <volume> 522531, </volume> <year> 1996. </year>
Reference-contexts: For example, consider a hypercube lattice with 6 dimensions, where each dimension has 6 or more distinct values. If we use the uniform distribution assumption to obtain sizes of the different aggregates views (as in <ref> [SDNR96] </ref>), the resulting lattice is an SR-hypercube lattice. In Section 6 we examine 4 real-life datasets, of which 3 datasets form SR-hypercube lattices. For the class of SR-hypercube lattices, we propose a very fast algorithm called PBS. PBS essentially picks aggregates for precomputation in increasing order of their size. <p> We performed experiments on both real-life and synthetic datasets. Our experiments assume that queries on any aggregate are equally likely. We use analytical formulas presented in <ref> [SDNR96, RS97] </ref> to estimate the size of aggregates formed by the data cube operator. For example, consider a relation R having attributes A, B, C and D. Suppose we want to estimate the size of the group by on attributes A and B.
Reference: [Ull96] <author> J.D. Ullman, </author> <title> Efficient Implementation of Data Cubes Via Materialized Views A survey of the field for the 1996 KDD conference. </title>
Reference-contexts: Other related work includes [GHRU97], where the authors consider the selection of views and indexes together. [Gupt97] presents a theoretical framework for the view-selection problem, and proposes a general algorithm and several heuristics. <ref> [Ull96] </ref> surveys techniques proposed for determining what aggregates should be precomputed. Lastly, alternative approaches to precomputation are offered by indexing. In particular, Bitmaps [OQ97], and Join indices [OG95] are popular ways to speedup OLAP applications.
Reference: [ZDN97] <author> Y. Zhao, P.M. Deshpande, J.F. Naughton. </author> <title> An ArrayBased Algorithm for Simultaneous Multidimensional Aggregates, </title> <booktitle> Proc. ACM SIGMOD Int. Conf. on Management of Data, </booktitle> <volume> 159170, </volume> <year> 1997. </year> <month> 24 </month>
Reference-contexts: Lastly, alternative approaches to precomputation are offered by indexing. In particular, Bitmaps [OQ97], and Join indices [OG95] are popular ways to speedup OLAP applications. Actual precom-putation of the set of aggregates can be accomplished by using algorithms explored in <ref> [AAD+96, ZDN97] </ref>. The input to the precomputation algorithm is a lattice containing the database and the aggregate views selected for precomputation. The paper is organized as follows. Section 2 describes and justifies the cost model that we use.
References-found: 14

