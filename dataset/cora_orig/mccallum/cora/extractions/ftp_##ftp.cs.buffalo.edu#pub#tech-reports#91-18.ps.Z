URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/91-18.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Title: On the Power of One Bit of a P Function  
Author: Kenneth W. Regan SUNY/Buffalo Thomas Schwentick 
Keyword: of bounded-depth circuits. Keywords Computational complexity, theory of computation, polynomial-time hierarchy, randomness, counting classes, oracles.  
Note: which satisfy certain congruence relations, one which also matters to the theory  The first author was supported in part by NSF Grant CCR-9011248  
Address: Mainz  
Affiliation: University of  
Email: regan@cs.buffalo.edu  tick@uaimzti.mathematik.uni-mainz.de  
Date: June 5, 1992  
Abstract: We introduce the class MP of languages L which can be solved in polynomial time with an oracle for one selected bit of the value f (y) of a # P function f on a selected argument y. This extends the much-studied language classes P and PP, which correspond to the power of the least and most significant bits, respectively. We show that MP is captured by the power of the middle bit; namely: a language L is in MP iff for some # P function f 0 and all x, x 2 L () the middle bit of f 0 (x) in binary notation is a `1'. Also, S. Toda's proof [Tod89, Tod91] that the polynomial hierarchy (PH) is contained in P # P actually gives: PH BP[ P] C P MP. The class MP has complete problems, and is closed under complements and under polynomial-time many-one reducibility. We show that MP is closed under intersection iff, for any fixed k &gt; 0, k bits of a # P function are no more powerful than one. Moreover, if there is a polynomial-time construction for the closure under intersection, then O(log n)-many bits have the same power as one. We examine the subclass AmpMP of languages whose MP representations can be "amplified," showing that BP[ P] AmpMP, and that for any p m - closed subclass C of AmpMP, MP C = MP. Hence BP[ P] is low for MP, and if C=P AmpMP, then PP PP = MP. Finally, our work leads to a purely mathematical question about the size of integer-valued polynomials p(x; y) 
Abstract-found: 1
Intro-found: 1
Reference: [ACGS84] <author> W. Alexi, B. Chor, O. Goldreich, and C.P. Schnorr. </author> <title> RSA/Rabin bits are 1=2 + 1=poly(logN ) secure. </title> <booktitle> In The Proceedings of the 25th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 449-457, </pages> <year> 1984. </year>
Reference-contexts: We suppose that the values f (y) are encoded as binary numbers, possibly with leading zeroes, with the least significant bit written rightmost but indexed first. This subject has been investigated extensively for functions f of cryptographic importance, in particular, for the discrete log and inverse RSA functions <ref> [ACGS84, Cho86, SS90] </ref>. We raise it for functions f belonging to the class # P, whose typical (complete) members are much harder than the discrete log or RSA 1 , unless NP = coNP.
Reference: [BGH90] <author> R. Beigel, J. Gill, and U. Hertrampf. </author> <title> Counting classes: thresholds, parity, </title> <booktitle> mods, and fewness. In The Proceedings of the Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 49-57, </pages> <year> 1990. </year>
Reference-contexts: Essentially by definition, the most significant bit gives the power of PP, while the least significant bit gives the power of P. From the proof that Few P <ref> [BGH90] </ref> it is known that the rightmost O (log n) bits still give the power of P; we show that the leftmost O (log n) bits do likewise for PP. <p> Then MP [d p ] = MP. Proof. The proof, which is given in the Appendix, is via a standard padding argument. The next result tells us that bits very close to either end are probably easier than the middle bit. Theorem 11. (a) <ref> [BGH90] </ref> If d p = O (log n), then MP [d p ] = P. (b) If p d p = O (log n), then MP [d p ] = PP. Proof. (a) The basic idea from [BGH90] is that by Lucas' theorem, BIT (z; k) = 1 iff the binomial <p> Theorem 11. (a) <ref> [BGH90] </ref> If d p = O (log n), then MP [d p ] = P. (b) If p d p = O (log n), then MP [d p ] = PP. Proof. (a) The basic idea from [BGH90] is that by Lucas' theorem, BIT (z; k) = 1 iff the binomial coefficient ( y 2 k1 ) is odd.
Reference: [BRS91] <author> R. Beigel, N. Reingold, and D. Spielman. </author> <title> PP is closed under intersection. </title> <booktitle> In The Proceedings of the 23rd ACM Symposium on the Theory of Computation, </booktitle> <pages> pages 1-11, </pages> <year> 1991. </year>
Reference-contexts: Proof. (a) The basic idea from [BGH90] is that by Lucas' theorem, BIT (z; k) = 1 iff the binomial coefficient ( y 2 k1 ) is odd. If k = O (log n), then this coefficient gives a P representation. (b) By the closure under intersection of PP <ref> [BRS91] </ref> it follows that the language L 0 := f (x; k; k 0 )jk # p R (x) &lt; k 0 g is in PP. <p> Note that MP is p-closed under complements. The well-known closures of # P functions under addition, multiplication, and concatenation of bitstring representations f (x)g (x) are also polynomial-time constructive; the last operation expands by a factor of 2. The closure of PP under intersection <ref> [BRS91] </ref> also meets the conditions of Definition 22. Lemma 23. Let D be a language, and let F be a polynomial-time computable function which is used by some deterministic polynomial-time procedure P .
Reference: [Cho86] <author> B. Chor. </author> <title> Two Issues in Public-Key Cryptography: RSA Bit Security and a New Knapsack-Type System. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: We suppose that the values f (y) are encoded as binary numbers, possibly with leading zeroes, with the least significant bit written rightmost but indexed first. This subject has been investigated extensively for functions f of cryptographic importance, in particular, for the discrete log and inverse RSA functions <ref> [ACGS84, Cho86, SS90] </ref>. We raise it for functions f belonging to the class # P, whose typical (complete) members are much harder than the discrete log or RSA 1 , unless NP = coNP.
Reference: [FR91] <author> L. Fortnow and N. Reingold. </author> <title> PP is closed under truth-table reductions. </title> <booktitle> In The Proceedings of the 6th Annual IEEE Conference on Structure in Complexity Theory, </booktitle> <pages> pages 13-15, </pages> <year> 1991. </year>
Reference-contexts: If p (jxj) d p (x) is logarithmically bounded in jxj there are only polynomially many such intervals, therefore L can be decided by polynomially many non-adaptive questions to a L 0 -oracle. Hence L 2 PP by the closure of PP under polynomial-time truth-table reductions <ref> [FR91] </ref>. 6 4. Subclasses of MP and Lowness S. Toda [Tod89] proved that PH BP [ P] and that C P P # P . His proof of the latter actually showed that C P MP.
Reference: [PZ83] <author> C. H. Papadimitriou and S. Zachos. </author> <title> Two remarks on the power of counting. </title> <booktitle> In The 6th GI Conference on Theoretical Computer Science, Lecture Notes in Computer Science No. </booktitle> <volume> 145, </volume> <pages> pages 269-276. </pages> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: Papadimitriou and S. Zachos of P P = P <ref> [PZ83] </ref>.) Then the accepting computation paths of N on input x can be partitioned into those in which all "guessed" oracle answers are correct, and those which have some wrong guess.
Reference: [Sch85] <author> U. Schoning. </author> <title> Complexity and Structure, </title> <booktitle> volume 211 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: We show that the two classes are equal iff there is a "polynomial-time computable construction" which witnesses that MP is closed under intersection. They have also observed [personal communication] that P is low <ref> [Sch85] </ref> for both these classes; i.e. that MP P = MP and likewise for the latter class. 2. Counting classes and "middle-bit P" We use the alphabets := f 0; 1 g and := f 0; 1; ; g, where ; is an extra symbol used to form tuples.
Reference: [Smo91] <author> C. </author> <title> Smorynski. </title> <journal> Logical Number Theory, </journal> <volume> volume 1. </volume> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Kobler, J. Toran, and F. Green [personal communication] have studied the class of languages L such that for some f 2 # P and g 2 PF, and all x, x 2 L iff the binomial coefficient ( f (x) g (x) ) is odd. By Lucas' Theorem (see <ref> [Smo91] </ref>), this happens iff no bit of g (x) is `1' where the corresponding bit of f (x) is `0'; i.e., if f (x) "masks" g (x). For want of a better or agreed-on name, call this class MaskP.
Reference: [SS90] <author> A. Schrift and A. Shamir. </author> <title> The discrete log is very discreet. </title> <booktitle> In The Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 405-415, </pages> <year> 1990. </year>
Reference-contexts: We suppose that the values f (y) are encoded as binary numbers, possibly with leading zeroes, with the least significant bit written rightmost but indexed first. This subject has been investigated extensively for functions f of cryptographic importance, in particular, for the discrete log and inverse RSA functions <ref> [ACGS84, Cho86, SS90] </ref>. We raise it for functions f belonging to the class # P, whose typical (complete) members are much harder than the discrete log or RSA 1 , unless NP = coNP.
Reference: [Tod89] <author> S. </author> <title> Toda. </title> <booktitle> On the computational power of PP and P. In The Proceedings of the 30th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 514-519, </pages> <year> 1989. </year>
Reference-contexts: This justifies the name MP or "middle-bit P" for this class of languages. The second reason for the importance of MP is that S. Toda's celebrated proof <ref> [Tod89, Tod91] </ref> that the polynomial hierarchy PH is contained in P # P actually shows the following (where we have written C P for Toda's P P): Theorem 1. [after Toda]. PH C P MP. <p> Hence L 2 PP by the closure of PP under polynomial-time truth-table reductions [FR91]. 6 4. Subclasses of MP and Lowness S. Toda <ref> [Tod89] </ref> proved that PH BP [ P] and that C P P # P . His proof of the latter actually showed that C P MP. We observe that a slight modification of this proof highlights a special property of languages in C P.
Reference: [Tod91] <author> S. </author> <title> Toda. PP is as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20 </volume> <pages> 865-877, </pages> <year> 1991. </year>
Reference-contexts: This justifies the name MP or "middle-bit P" for this class of languages. The second reason for the importance of MP is that S. Toda's celebrated proof <ref> [Tod89, Tod91] </ref> that the polynomial hierarchy PH is contained in P # P actually shows the following (where we have written C P for Toda's P P): Theorem 1. [after Toda]. PH C P MP. <p> there is a polynomial p and a # P-function g such that for every x x 2 D =) g (x) 2 1 t+1 f0; 1g p (jxj) By setting f (x) := g (x) + 2 p (jxj) we obtain (a). (b) This follows directly from Toda's recurrence lemma <ref> [Tod91] </ref>. (c) Because P is closed under polynomial-time Turing-reductions we can amplify BP [ P] in the same manner as BPP.
Reference: [Tor91] <author> J. Toran. </author> <title> Complexity classes defined by counting quantifiers. </title> <journal> Journal of the ACM, </journal> <volume> 38 </volume> <pages> 753-774, </pages> <year> 1991. </year>
Reference: [TW90] <author> S. Toda and O. Watanabe. </author> <title> Polynomial time 1-turing reductions from #PH to # P. </title> <type> Technical report, </type> <institution> University of Electro-Communications, </institution> <address> Tokyo, </address> <year> 1990. </year>
Reference-contexts: Corollary 17. (a) BP [ P] is low for MP. (b) If C=P AmpMP then PP PP = MP. By combining Theorem 16 with PH BP [ P] AmpMP one may quickly obtain a result obtained via lengthy calculations by Toda and O. Watanabe <ref> [TW90] </ref>: Corollary 18. #PH PF # P [1] . 5. The power of more than one bit Definition 19. Let k be a number (or a numerical function of jxj).
Reference: [Val79] <author> L. Valiant. </author> <title> The complexity of enumeration and reliability problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 8 </volume> <pages> 410-421, </pages> <year> 1979. </year>
Reference-contexts: The # P function associated to (R; p) is defined by # p R (x) := kf y : R (x ; y) gk. The original definition of # P in <ref> [Val79] </ref> was in terms of the number acc N (x) of accepting computations of polynomial-time NTMs N on given inputs x.
Reference: [Wag86] <author> K. Wagner. </author> <title> The complexity of combinatorial problems with succinct input representation. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 325-356, </pages> <year> 1986. </year> <month> 15 </month>
Reference-contexts: We show that BP [ P] AmpMP, and that for any class C AmpMP which is closed downward under polynomial-time many-one reductions, such as BP [ P] itself, MP C = MP. If AmpMP = MP, or even if PP AmpMP or C=P AmpMP, then the counting hierarchy <ref> [Wag86] </ref> collapses with PP PP = P PP = MP. Third, there is evidence that the bits toward the right or left end of f (x) are not as hard to compute as the bits in the middle.
References-found: 15

