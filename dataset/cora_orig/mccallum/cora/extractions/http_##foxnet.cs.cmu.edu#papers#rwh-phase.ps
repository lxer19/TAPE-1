URL: http://foxnet.cs.cmu.edu/papers/rwh-phase.ps
Refering-URL: http://foxnet.cs.cmu.edu/papers.html
Root-URL: 
Phone: 3  
Title: Higher-Order Modules and the Phase Distinction  
Author: Robert Harper John C. Mitchell Eugenio Moggi 
Web: CCR-8814921.  
Note: under the same contract. 2 Stanford University, Stanford, CA 94305. Partially supported by an NSF PYI Award, matching funds from Digital Equipment Corporation, Xerox Corporation and the Powell Foundation and by NSF grant  Supported by ESPRIT Basic Research Action No. 3003, Categorical Logic In Computer Science.  
Address: Pittsburgh, PA 15213  Cambridge, Cambridge CB2 3QG, UK.  
Affiliation: School of Computer Science Carnegie Mellon University  University of  
Date: October 1989  
Pubnum: CMU-CS-89-197  
Abstract: This report is an expanded version of a paper to be presented at the 17th Symposium on Principles of Programming Languages, San Francisco, CA, January, 1990. 
Abstract-found: 1
Intro-found: 1
Reference: [BL84] <author> R. Burstall and B. Lampson. </author> <title> A kernel language for abstract data types and modules. </title> <booktitle> In Proc. Int. Symp. on Semantics of Data Types, Sophia-Antipolis (France), </booktitle> <publisher> Springer LNCS 173, </publisher> <pages> pages 1-50, </pages> <year> 1984. </year>
Reference-contexts: This is particularly unfortunate for higher-order modules, since these seem useful in supporting separate compilation or as an alternative to ML's "sharing" specifications <ref> [BL84, Mac86] </ref>. In this paper, we redesign XML so that compile-time type checking is an intrinsic part of the type-theoretic framework. Since it is difficult to characterize the difference between compile-time and run-time precisely, we focus on establishing a phase distinction, in the terminology of [Car88].
Reference: [BMM89] <author> K. B. Bruce, A. R. Meyer, and J. C. Mitchell. </author> <title> The semantics of second-order lambda calculus. </title> <journal> Information and Computation, </journal> <note> 1989. (to appear). </note>
Reference-contexts: It is then easy to show that type checking in ML is decidable. This is a well-known property of the polymorphic lambda calculus F ! (c.f. <ref> [Gir71, Gir72, Rey74, BMM89] </ref>), which may be seen as an impredicative extension of the ML calculus. Lemma 2.2 There is a straightforward one-pass algorithm which decides, for an arbitrary well-formed theory T and formation judgement F , whether or not ML [T ] ` F .
Reference: [C + 86] <author> Constable et al. </author> <title> Implementing Mathematics with the Nuprl Proof Development System, volume 37 of Graduate Texts in Mathematics. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: The main technical accomplishment of this paper is to present a full calculus encompassing the module expressions of ML which has a compile-time decidable type checking problem. 3 Modules Calculus 3.1 Overview In the XML account of Standard ML modules [Mac86, MH88] (see also <ref> [NPS88, C + 86, Mar84] </ref> for related ideas), a structure is an element of a strong sum type of the form x:A:B. For example, a structure with one type and one value component is regarded as a pair [t; e] of type S = t:T:.
Reference: [Car88] <author> L. Cardelli. </author> <title> Phase distinctions in type theory. </title> <type> Manuscript, </type> <year> 1988. </year>
Reference-contexts: In this paper, we redesign XML so that compile-time type checking is an intrinsic part of the type-theoretic framework. Since it is difficult to characterize the difference between compile-time and run-time precisely, we focus on establishing a phase distinction, in the terminology of <ref> [Car88] </ref>. However, to give better intuition, we generally refer to these phases as compile-time and run-time. The main benefit of our redesign is that type checking becomes decidable, even in the presence of higher-order functors and arbitrary equational axioms between "run-time" expressions.
Reference: [Gir71] <author> J.-Y. Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <editor> In J.E. Fenstad, editor, </editor> <booktitle> 2nd Scandinavian Logic Symposium, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland, </publisher> <year> 1971. </year>
Reference-contexts: It is then easy to show that type checking in ML is decidable. This is a well-known property of the polymorphic lambda calculus F ! (c.f. <ref> [Gir71, Gir72, Rey74, BMM89] </ref>), which may be seen as an impredicative extension of the ML calculus. Lemma 2.2 There is a straightforward one-pass algorithm which decides, for an arbitrary well-formed theory T and formation judgement F , whether or not ML [T ] ` F .
Reference: [Gir72] <author> J.-Y. Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <institution> These D'Etat, Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: It is then easy to show that type checking in ML is decidable. This is a well-known property of the polymorphic lambda calculus F ! (c.f. <ref> [Gir71, Gir72, Rey74, BMM89] </ref>), which may be seen as an impredicative extension of the ML calculus. Lemma 2.2 There is a straightforward one-pass algorithm which decides, for an arbitrary well-formed theory T and formation judgement F , whether or not ML [T ] ` F .
Reference: [HMM86] <author> R. Harper, D.B. MacQueen, and R. Milner. </author> <title> Standard ml. </title> <type> Technical Report ECS-LFCS-86-2, </type> <institution> Lab. for Foundations of Computer Science, University of Edinburgh, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: 1 Introduction The module system of Standard ML <ref> [HMM86] </ref> provides a convenient mechanism for factoring ML programs into separate but interrelated program units. The basic constructs are structures, which are a form of generalized "records" with type, value and structure components, and functors, which may be regarded as parameterized structures or functions from structures to structures.
Reference: [HMT87a] <author> R. Harper, R. Milner, and M. Tofte. </author> <title> The semantics of standard ML. </title> <type> Technical Report ECS-LFCS-87-36, </type> <institution> Lab. for Foundations of Computer Science, University of Edinburgh, </institution> <month> August </month> <year> 1987. </year> <month> 19 </month>
Reference-contexts: In this respect, the current language only uses "first-order" modules. There are two formal analyses of the module system, one operational and the other a syntactic translation leading to a denotational semantics. The structured operational semantics of <ref> [HMT87b, HMT87a, Tof87] </ref> includes a computational characterization of the type checker. This gives a precise, implementation-independent definition of the Standard ML language that may be used for a variety of purposes. The second formal analysis is a type-theoretic description of ML, which leads to a denotational semantics to the language.
Reference: [HMT87b] <author> R. Harper, R. Milner, and M. Tofte. </author> <title> A type discipline for program modules. </title> <booktitle> In TAPSOFT '87, volume 250 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <month> March </month> <year> 1987. </year>
Reference-contexts: In this respect, the current language only uses "first-order" modules. There are two formal analyses of the module system, one operational and the other a syntactic translation leading to a denotational semantics. The structured operational semantics of <ref> [HMT87b, HMT87a, Tof87] </ref> includes a computational characterization of the type checker. This gives a precise, implementation-independent definition of the Standard ML language that may be used for a variety of purposes. The second formal analysis is a type-theoretic description of ML, which leads to a denotational semantics to the language.
Reference: [Mac86] <author> D.B. MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In Proc. 13-th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 277-286, </pages> <year> 1986. </year>
Reference-contexts: This gives a precise, implementation-independent definition of the Standard ML language that may be used for a variety of purposes. The second formal analysis is a type-theoretic description of ML, which leads to a denotational semantics to the language. The second line of work, beginning with <ref> [Mac86] </ref> and continued in [MH88], uses dependent sum types x:A:B to explain structures and dependent function types x:A:B for functors. In addition to providing some insight into the functional behavior of the module constructs, the XML calculus introduced in [MH88] establishes a framework for studying a class of ML-like languages. <p> This is particularly unfortunate for higher-order modules, since these seem useful in supporting separate compilation or as an alternative to ML's "sharing" specifications <ref> [BL84, Mac86] </ref>. In this paper, we redesign XML so that compile-time type checking is an intrinsic part of the type-theoretic framework. Since it is difficult to characterize the difference between compile-time and run-time precisely, we focus on establishing a phase distinction, in the terminology of [Car88]. <p> The main technical accomplishment of this paper is to present a full calculus encompassing the module expressions of ML which has a compile-time decidable type checking problem. 3 Modules Calculus 3.1 Overview In the XML account of Standard ML modules <ref> [Mac86, MH88] </ref> (see also [NPS88, C + 86, Mar84] for related ideas), a structure is an element of a strong sum type of the form x:A:B. For example, a structure with one type and one value component is regarded as a pair [t; e] of type S = t:T:. <p> This is syntactically cumbersome. In keeping with the syntax of Standard ML, and practical programming considerations, we will consider a more natural notation based on <ref> [Mac86, MH88] </ref>. However, our calculus will nonetheless respect the phase distinction inherent in representing functors as structures. This is achieved by employing a non-standard equational theory that, when used during type checking, makes explicit the underlying "split" interpretation of module expressions, and hence eliminates apparent phase violations.
Reference: [Mar84] <author> P. Martin-Lof. </author> <title> Intuitionistic Type Theory. </title> <type> Bibliopolis, </type> <institution> Napoli, </institution> <year> 1984. </year>
Reference-contexts: The main technical accomplishment of this paper is to present a full calculus encompassing the module expressions of ML which has a compile-time decidable type checking problem. 3 Modules Calculus 3.1 Overview In the XML account of Standard ML modules [Mac86, MH88] (see also <ref> [NPS88, C + 86, Mar84] </ref> for related ideas), a structure is an element of a strong sum type of the form x:A:B. For example, a structure with one type and one value component is regarded as a pair [t; e] of type S = t:T:.
Reference: [MH88] <author> J.C. Mitchell and R. Harper. </author> <title> The essence of ML. </title> <booktitle> In Proc. 15-th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 28-46, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: The second formal analysis is a type-theoretic description of ML, which leads to a denotational semantics to the language. The second line of work, beginning with [Mac86] and continued in <ref> [MH88] </ref>, uses dependent sum types x:A:B to explain structures and dependent function types x:A:B for functors. In addition to providing some insight into the functional behavior of the module constructs, the XML calculus introduced in [MH88] establishes a framework for studying a class of ML-like languages. <p> The second line of work, beginning with [Mac86] and continued in <ref> [MH88] </ref>, uses dependent sum types x:A:B to explain structures and dependent function types x:A:B for functors. In addition to providing some insight into the functional behavior of the module constructs, the XML calculus introduced in [MH88] establishes a framework for studying a class of ML-like languages. Because variants of Standard ML may be considered as XML theories, the emphasis of this approach is on properties of Standard ML that remain invariant under extensions of the language. <p> The paper is organized as follows. In Section 2 we introduce the core calculus, ML , which we later extend to include modules. ML is essentially the HML calculus given in [Mog89a] and closely related to the Core-XML calculus given in <ref> [MH88] </ref>. In Section 3 we introduce ML mod , the full calculus of higher-order modules. We prove that ML mod is a definitional extension of a simpler "structures-only" calculus and use this result to establish decidability and compile-time type checking for the full calculus of modules. <p> The types of ML , whose elements are terms, include cartesian products, function spaces and polymorphic types. The terms of the calculus correspond to the basic expression forms of ML, but are written in an explicitly-typed syntax, following <ref> [MH88] </ref>. It is important to note that our "types" correspond roughly to ML's "type schemes," the essential difference being that we require them to be closed with respect to quantification over all kinds (not just the kind of monotypes) and function spaces. <p> These additional closure conditions for type schemes are needed to make the the category of modules for ML relatively cartesian closed (i.e., closed under formation of dependent products and sums). The type structure of ML is a refinement of that of Core-XML <ref> [MH88] </ref>. The kind T of monotypes corresponds directly to the first universe U 1 of Core-XML. However, the second universe, U 2 , of Core-XML is separated into distinct collections of kinds and types. <p> We sometimes write ff to stand for an arbitrary judgement when we wish to make the context part explicit. 2.4 Formation Rules The syntax of ML is specified by a set of inference rules for deriving formation judgements. These resemble rules in <ref> [MH88, Mog89a] </ref> and are given in Appendix A. We write ML ` F to indicate that the formation judgement F is derivable using these rules. The formation rules may be summarized as follows. <p> The terms amount to an explicitly-typed presentation of the ML core language, similar to 4 that presented in <ref> [MH88] </ref>. (The let construct is omitted since it is definable here.) 2.5 Equality rules The rules for deriving equational judgements also resemble rules in [MH88, Mog89a] and are given in Appendix A. We write ML ` E to indicate that an equation E is derivable in accordance with these rules. <p> The terms amount to an explicitly-typed presentation of the ML core language, similar to 4 that presented in [MH88]. (The let construct is omitted since it is definable here.) 2.5 Equality rules The rules for deriving equational judgements also resemble rules in <ref> [MH88, Mog89a] </ref> and are given in Appendix A. We write ML ` E to indicate that an equation E is derivable in accordance with these rules. <p> The main technical accomplishment of this paper is to present a full calculus encompassing the module expressions of ML which has a compile-time decidable type checking problem. 3 Modules Calculus 3.1 Overview In the XML account of Standard ML modules <ref> [Mac86, MH88] </ref> (see also [NPS88, C + 86, Mar84] for related ideas), a structure is an element of a strong sum type of the form x:A:B. For example, a structure with one type and one value component is regarded as a pair [t; e] of type S = t:T:. <p> This is syntactically cumbersome. In keeping with the syntax of Standard ML, and practical programming considerations, we will consider a more natural notation based on <ref> [Mac86, MH88] </ref>. However, our calculus will nonetheless respect the phase distinction inherent in representing functors as structures. This is achieved by employing a non-standard equational theory that, when used during type checking, makes explicit the underlying "split" interpretation of module expressions, and hence eliminates apparent phase violations. <p> Corollary 3.13 Given any well-formed theory T , the derivability of formation judgements in ML mod [T ] is decidable and does not depend on run-time axioms nor the axioms in T . 4 Conclusion Although the relatively straightforward ML-like function calculus XML of <ref> [MH88] </ref> illustrates some important properties of ML-like languages, it does not provide an adequate basis for the 18 design of a compile-time type checker. Similar problems arise in other programming language models based on dependent types.
Reference: [Mog89a] <author> E. Moggi. </author> <title> A category-theoretic account of program modules. </title> <booktitle> In Summer Conf. on Category Theory and Computer Science, </booktitle> <pages> pages 101-117, </pages> <year> 1989. </year>
Reference-contexts: This allows us to compute compile-time (type) values of these expressions without evaluating run-time expressions e 1 or e 2 . This approach follows naturally from the development of <ref> [Mog89a] </ref>, which defines the category of modules over any suitable indexed category representing a typed language. In categorical terms, the category of modules is the Grothendieck construction on an indexed category, which is proved relatively cartesian closed when certain natural assumptions about the indexed category are satisfied. <p> The paper is organized as follows. In Section 2 we introduce the core calculus, ML , which we later extend to include modules. ML is essentially the HML calculus given in <ref> [Mog89a] </ref> and closely related to the Core-XML calculus given in [MH88]. In Section 3 we introduce ML mod , the full calculus of higher-order modules. <p> (x::e) j e 1 e 2 j (flv:k:e) j e [u] 2 context :: = ; j ; v:k j ; x: Table 1: ML raw expressions 2 Core Calculus We begin by giving the definition of the ML core calculus, ML , which is essentially the calculus HML of <ref> [Mog89a] </ref>. This calculus captures many of the essential features of the ML type system, but omits, for the sake of simplicity, ML's concrete and abstract types (which could be modeled using existential types [MP88]), recursive types (which can be described through a ML theory), and record types. <p> We sometimes write ff to stand for an arbitrary judgement when we wish to make the context part explicit. 2.4 Formation Rules The syntax of ML is specified by a set of inference rules for deriving formation judgements. These resemble rules in <ref> [MH88, Mog89a] </ref> and are given in Appendix A. We write ML ` F to indicate that the formation judgement F is derivable using these rules. The formation rules may be summarized as follows. <p> The terms amount to an explicitly-typed presentation of the ML core language, similar to 4 that presented in [MH88]. (The let construct is omitted since it is definable here.) 2.5 Equality rules The rules for deriving equational judgements also resemble rules in <ref> [MH88, Mog89a] </ref> and are given in Appendix A. We write ML ` E to indicate that an equation E is derivable in accordance with these rules. <p> In this section we develop a calculus ML mod of higher-order modules with a phase distinction based on the categorical analysis of <ref> [Mog89a] </ref>. We begin with a simpler "structures-only" calculus that is primarily a technical device used in the proofs. The full calculus of higher-order modules has a standard syntax for dependent strong sums and functions, resembling XML, but a non-standard equational theory inspired by the categorical interpretation of program modules [Mog89a]. <p> of <ref> [Mog89a] </ref>. We begin with a simpler "structures-only" calculus that is primarily a technical device used in the proofs. The full calculus of higher-order modules has a standard syntax for dependent strong sums and functions, resembling XML, but a non-standard equational theory inspired by the categorical interpretation of program modules [Mog89a]. The calculus also employs a single non-standard typing rule for structures that we conjecture is not needed for decidable typing, but which allows a more generous (and simple) type-checking algorithm without invalidating the categorical semantics. <p> The calculus of structures may be understood in terms of a translation into the core calculus, which amounts to showing that ML str may be interpreted into the category of modules of <ref> [Mog89a] </ref>. For a ML str context, define fl to be the ML context obtained by replacing all structure variable declarations s : [v:k; ] by the pair of declarations s c : k and s r : [s c =v]. Lemma 3.1 Let T be a well-formed ML theory. 1. <p> 1 M 2 [u 1 u 2 ; e 1 [u 2 ] e 2 ] where M [ i = [u i ; e i ] Table 8: Translation of ML mod into ML str The non-standard typing rule is consistent with the interpretation in the category of modules <ref> [Mog89a] </ref>, but (we conjecture that) without it the main properties of ML mod , namely the compile-time type checking theorem and the decidability of typing judgements, would still hold. The reason for having such rule is mainly pragmatic: to have a simple type checking algorithm (see Definition 3.9). <p> The basis for our development is the "category of modules" over an indexed category, which is an instance of the Grothedieck construction. General properties of the category of modules are explained in the companion paper <ref> [Mog89a] </ref>. In the specific case of ML , our non-standard equational axioms lead to a calculus which bears a natural relationship to the category of modules.
Reference: [Mog89b] <author> E. Moggi. </author> <title> Computational lambda calculus and monads. </title> <booktitle> In Fourth IEEE Symp. Logic in Computer Science, </booktitle> <pages> pages 14-23, </pages> <year> 1989. </year>
Reference-contexts: We show that ML typing is decidable for any variant of the calculus based on any (possibly undecidable) equational theory for "run-time" expressions. A similar development may be carried out using the computational -calculus approach of <ref> [Mog89b] </ref> in place of equational axioms, but we will not go into that in this paper. The paper is organized as follows. In Section 2 we introduce the core calculus, ML , which we later extend to include modules. <p> We also do not consider pattern matching, or computational aspects such as side-effects and exceptions. A promising approach toward integrating these features is described in <ref> [Mog89b] </ref>. 2.1 Syntactic Preliminaries There are four basic syntactic classes in ML : kinds,constructors,types and terms. The kinds include T , the collection of all monotypes, and are closed under formation of products and function spaces.
Reference: [MP88] <author> J.C. Mitchell and G.D. Plotkin. </author> <title> Abstract types have existential types. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <year> 1988. </year> <note> Preliminary version appeared in Proc. 12-th ACM Symp. on Principles of Programming Languages, </note> <year> 1985. </year>
Reference-contexts: This calculus captures many of the essential features of the ML type system, but omits, for the sake of simplicity, ML's concrete and abstract types (which could be modeled using existential types <ref> [MP88] </ref>), recursive types (which can be described through a ML theory), and record types. We also do not consider pattern matching, or computational aspects such as side-effects and exceptions.
Reference: [NPS88] <author> B. Nordstrom, K. Peterson, and J. Smith. </author> <title> Programming in martin-lof's type theory. </title> <institution> University of Gothenburg / Chalmers Institue of Technology, </institution> <note> Book draft of Midsummer 1988. </note>
Reference-contexts: The main technical accomplishment of this paper is to present a full calculus encompassing the module expressions of ML which has a compile-time decidable type checking problem. 3 Modules Calculus 3.1 Overview In the XML account of Standard ML modules [Mac86, MH88] (see also <ref> [NPS88, C + 86, Mar84] </ref> for related ideas), a structure is an element of a strong sum type of the form x:A:B. For example, a structure with one type and one value component is regarded as a pair [t; e] of type S = t:T:.
Reference: [Rey74] <author> J.C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Paris Colloq. on Programming, </booktitle> <pages> pages 408-425. </pages> <publisher> Springer-Verlag LNCS 19, </publisher> <year> 1974. </year>
Reference-contexts: It is then easy to show that type checking in ML is decidable. This is a well-known property of the polymorphic lambda calculus F ! (c.f. <ref> [Gir71, Gir72, Rey74, BMM89] </ref>), which may be seen as an impredicative extension of the ML calculus. Lemma 2.2 There is a straightforward one-pass algorithm which decides, for an arbitrary well-formed theory T and formation judgement F , whether or not ML [T ] ` F .
Reference: [Tof87] <author> M. Tofte. </author> <title> Operational Semantics and Polymorphic Type Inference. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference-contexts: In this respect, the current language only uses "first-order" modules. There are two formal analyses of the module system, one operational and the other a syntactic translation leading to a denotational semantics. The structured operational semantics of <ref> [HMT87b, HMT87a, Tof87] </ref> includes a computational characterization of the type checker. This gives a precise, implementation-independent definition of the Standard ML language that may be used for a variety of purposes. The second formal analysis is a type-theoretic description of ML, which leads to a denotational semantics to the language.
References-found: 18

