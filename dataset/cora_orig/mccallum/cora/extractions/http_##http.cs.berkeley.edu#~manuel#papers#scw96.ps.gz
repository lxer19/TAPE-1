URL: http://http.cs.berkeley.edu/~manuel/papers/scw96.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~manuel/publications.html
Root-URL: 
Email: fmanuel,aikeng@cs.berkeley.edu  
Title: Making Set-Constraint Program Analyses Scale  
Author: Manuel Fahndrich Alexander Aiken 
Date: August 13, 1996  
Address: Berkeley, CA 94720-1776  
Affiliation: EECS Department University of California, Berkeley  
Abstract-found: 0
Intro-found: 1
Reference: [App92] <author> Andrew Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Currently, we evaluate our design on an application inferring types and exceptions for Standard ML [MTH90] with subtyping. Our implementation analyzes SML programs in the lambda intermediate representation produced by the SML/NJ compiler <ref> [App92] </ref>. The largest program analyzed thus far is the parser generator sml-yacc, containing 6017 non-comment lines of source, which translate into 66120 abstract syntax tree nodes in the SML/NJ intermediate representation.
Reference: [AW93] <author> A. Aiken and E. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: We describe the type language and the meaning of types informally. A formal development of an ideal model for this type language can be found in <ref> [AW93] </ref>. <p> An instance with ff = cons (fi; fl) yields cons (fi; fl) ! false. Solving constraints involving general intersection, union, and function types is still an open problem <ref> [AW93, Dam94] </ref>. Our system restricts the forms of constraints involving intersections on the left-hand side and unions on the right-hand side of constraints in order to solve them. For the purpose of this paper, it is sufficient to consider the core type language defined below, which avoids these irregularities.
Reference: [AWL94] <author> A. Aiken, E. Wimmers, </author> <title> and T.K. Lakshman. Soft typing with conditional types. </title> <booktitle> In Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: To the best of our knowledge, this is currently the largest program analyzed by a set constraint implementation (including results reported in <ref> [AWL94, Hei94] </ref>). Full type and exception inference for sml-yacc currently takes less than 10 minutes on an HP9000/715 running at 64MHz equipped with 64MB of main memory. <p> The other non-standard expression is conditional types t 1 ) t 2 (formerly t 2 ?t 1 in <ref> [AWL94] </ref>).
Reference: [Dam94] <author> Flemming M. Damm. </author> <title> Subtyping with union types, intersection types and recursive types. </title> <booktitle> In Proceedings of the '94 International Symposium on Theoretical Aspects of Computer Software, </booktitle> <pages> pages 687-706, </pages> <month> April </month> <year> 1994. </year> <month> 9 </month>
Reference-contexts: An instance with ff = cons (fi; fl) yields cons (fi; fl) ! false. Solving constraints involving general intersection, union, and function types is still an open problem <ref> [AW93, Dam94] </ref>. Our system restricts the forms of constraints involving intersections on the left-hand side and unions on the right-hand side of constraints in order to solve them. For the purpose of this paper, it is sufficient to consider the core type language defined below, which avoids these irregularities.
Reference: [Hei94] <author> Nevin Heintze. </author> <title> Set Based Analysis of ML Programs. </title> <booktitle> In Proceedings of the 1994 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 306-17, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: To the best of our knowledge, this is currently the largest program analyzed by a set constraint implementation (including results reported in <ref> [AWL94, Hei94] </ref>). Full type and exception inference for sml-yacc currently takes less than 10 minutes on an HP9000/715 running at 64MHz equipped with 64MB of main memory. <p> Our empirical results show that our system can almost certainly handle programs larger than sml-yacc; it just happens that sml-yacc is the largest example we currently have. Though our implementation scales nicely, it is currently much slower on medium-size programs than the system described in <ref> [Hei94] </ref>. The remainder of the paper is organized as follows: Section 2 gives a short overview of the set expressions and constraints used in our framework. Section 3 presents the techniques we find useful in building a scalable system. Section 4 discusses our implementation and preliminary empirical results. <p> Thus the program must be analyzed in small pieces. This single observation leads to a radically different overall design than whole program analyses systems that analyze only complete programs (e.g., see <ref> [Hei94] </ref>). To achieve a scalable system, we analyze parts of programs separately and combine the results later. We use four techniques to achieve this goal: polymorphism, simplification, separation, and sparse constraint representation. <p> Fewer simplifications save time, but the space usage for the constraints is larger, and the traversal of the constraints takes more time. Absolute analysis times are still high, in particular compared to the performance of the system implemented by Heintze <ref> [Hei94] </ref>, which is based on different techniques. We hope to gain some insights into the speed discrepancy by studying his implementation. 6 Acknowledgments We are grateful to Kwangkeun Yi for sharing his experience and his implementation with us, and to John Boyland for his comments on a draft of this paper.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Scalability is achieved through four techniques: polymorphism, simplification, separation, and sparse representation of constraints. Our ultimate goal is to demonstrate constraint-based analysis on programs of at least 100,000 lines of code. Currently, we evaluate our design on an application inferring types and exceptions for Standard ML <ref> [MTH90] </ref> with subtyping. Our implementation analyzes SML programs in the lambda intermediate representation produced by the SML/NJ compiler [App92]. The largest program analyzed thus far is the parser generator sml-yacc, containing 6017 non-comment lines of source, which translate into 66120 abstract syntax tree nodes in the SML/NJ intermediate representation.
Reference: [Pot96] <author> Fran~cois Pottier. </author> <title> Simplifying subtyping constraints. </title> <booktitle> In Proceedings of the SIGPLAN '96 International Conference on Functional Programming, </booktitle> <month> May </month> <year> 1996. </year> <note> to appear. </note>
Reference-contexts: Currently, our simplification suite simply consists of a set of equivalences we have found necessary to achieve scalability, readability, and to a lesser extent performance. A general, uniform simplification framework would clearly be preferable, but we know of none. Recent work by Pottier <ref> [Pot96] </ref> proposes a more uniform framework based on an entailment relation. The uniform part of his framework is a soundness test for simplifying substitutions. He does not propose a uniform framework for finding candidates for simplification|this part of the system is still heuristic.
Reference: [Smi94] <author> Geoffrey S. Smith. </author> <title> Principal type schemes for functional programs with overloading and subtyp-ing. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 23(2-3):197-226, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: He does not propose a uniform framework for finding candidates for simplification|this part of the system is still heuristic. In [TS96], the authors develop a decidable, incomplete subtyping relation based on entailment which is more powerful than Pottier's, but still incomplete. In <ref> [Smi94] </ref>, Smith describes a set of type simplifications similar to ours, but for a simpler type language. Since our primary goal is to reduce the number of variables, the patterns we recognize for simplifications all involve variables.
Reference: [TS96] <author> Valery Trifonov and Scott Smith. </author> <title> Subtyping Constrained Types. In Proceedings of the 3rd International Static Analysis Symposium, </title> <note> page to be published, </note> <month> September </month> <year> 1996. </year>
Reference-contexts: Recent work by Pottier [Pot96] proposes a more uniform framework based on an entailment relation. The uniform part of his framework is a soundness test for simplifying substitutions. He does not propose a uniform framework for finding candidates for simplification|this part of the system is still heuristic. In <ref> [TS96] </ref>, the authors develop a decidable, incomplete subtyping relation based on entailment which is more powerful than Pottier's, but still incomplete. In [Smi94], Smith describes a set of type simplifications similar to ours, but for a simpler type language.
Reference: [Yi94] <author> Kwangkeun Yi. </author> <title> Compile-time detection of uncaught exceptions for Standard ML programs. </title> <booktitle> In Proceedings of the First Annual Static Analysis Symposium, volume 864 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1994. </year> <month> 10 </month>
Reference-contexts: Full type and exception inference for sml-yacc currently takes less than 10 minutes on an HP9000/715 running at 64MHz equipped with 64MB of main memory. Even though the analysis time is still far from practical, we improve upon a similar analysis done previously by Yi <ref> [Yi94] </ref> by a factor of 50. His abstract interpretation for estimating uncaught exceptions runs about 617 minutes for sml-yacc on an SGI Challenger. Our empirical results show that our system can almost certainly handle programs larger than sml-yacc; it just happens that sml-yacc is the largest example we currently have.
References-found: 10

