URL: http://www.research.microsoft.com/~ymwang/papers/IPL-1994.ps
Refering-URL: http://www.research.microsoft.com/~ymwang/papers/IPL94CR.htm
Root-URL: http://www.research.microsoft.com
Phone: 704  
Title: Consistent Global Checkpoints Based on Direct Dependency Tracking  
Author: Yi-Min Wang Andy Lowry W. Kent Fuchs 
Keyword: Key words: distributed systems, fault tolerance, consistent global checkpoints, uncoordinated checkpointing, direct dependency tracking  
Address: 600 Mountain Avenue P.O. Box  Murray Hill, NJ 07974 Yorktown Heights, NY 10598 Urbana, IL 61801  
Affiliation: AT&T Bell Laboratories IBM T.J. Watson Research Center Coordinated Science Laboratory  University of Illinois  
Abstract: We model the consistent global checkpoints in a distributed system as the maximum-sized antichains in the partially ordered set generated by the happened before relation. While the partially ordered set generated by the direct dependency tracking in uncoordinated checkpointing protocols does not capture the complete happened before relation among all checkpoints, we show that the missing happened before information does not affect the identification of consistent global checkpoints. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> I. Anderson. </author> <title> Combinatorics of finite sets. </title> <publisher> Clarendon Press, Oxford, </publisher> <year> 1987. </year> <title> 3 Notice that, however, without the PWD assumption the interval dependency relation is not necessarily a partial order. </title> <type> 8 </type>
Reference-contexts: Then as we show below, the consistent global checkpoints of P are exactly the maximum-sized antichains <ref> [1] </ref> of R P , and a unique maximal maximum-sized antichain exists. This latter antichain is in a sense the latest available consistent global checkpoint, and therefore the preferred global checkpoint for recovery purposes. We call this global checkpoint the recovery line of P. <p> Thus M is a consistent global checkpoint of P. 2 For any poset P = (S; ), Anderson <ref> [1, x13.1-13.2] </ref> defines a lattice-inducing partial order on the maximum-sized antichains of P as follows: M 1 M 2 iff, for every x 1 2 M 1 , there exists x 2 2 M 2 such that x 1 x 2 .
Reference: [2] <author> B. Bhargava and S. R. Lian. </author> <title> Independent checkpointing and concurrent rollback for recovery An optimistic approach. </title> <booktitle> In Proc. IEEE Symp. on Reliable Distr. Syst., </booktitle> <pages> pages 3-12, </pages> <year> 1988. </year>
Reference-contexts: This latter antichain is in a sense the latest available consistent global checkpoint, and therefore the preferred global checkpoint for recovery purposes. We call this global checkpoint the recovery line of P. In the uncoordinated checkpointing protocols <ref> [2, 5, 9-12] </ref>, various dependency tracking mechanisms are used to record the happened before relation as it develops among the checkpoints, so that the recovery line can be established should some process initiate a rollback. <p> Johnson and Zwaenepoel [5] demonstrate that such interval dependencies yield a lattice structure among recoverable system states (N fi N matrices of state intervals), which is isomorphic to our lattice of maximum-sized antichains based on checkpoint dependencies. The message flow information described by Bhargava and Lian <ref> [2] </ref> can be viewed as applying the interval dependencies to checkpoint intervals in a non-PWD scenario 3 .
Reference: [3] <author> K. P. Bogart. </author> <title> Introductory combinatorics. </title> <publisher> Pitman Publishing Inc., </publisher> <address> Massachusetts, </address> <year> 1983. </year>
Reference-contexts: A consistent global checkpoint is a global checkpoint in which no two constituent checkpoints are related by the happened before relation [6]. Let R P = (C P ; ) be the induced subposet <ref> [3] </ref> of Q P obtained by 1 We do not explicitly represent messages in the execution history; rather, they are implied by the presence of message send and receive events. 2 For completeness, brief definitions of poset, chain, antichain, and lattice are provided in an appendix. 2 restricting the relation to
Reference: [4] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: We wish to stress that our transformation is fundamentally different from event swapping <ref> [4] </ref> or receive event reordering [13], in that it only operates on the checkpoint and communication patterns (c.c.p.'s) and has nothing to do with the actual computations being modeled.
Reference: [5] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> Recovery in distributed systems using optimistic message logging and checkpointing. </title> <journal> J. of Algorithms, </journal> <volume> 11 </volume> <pages> 462-491, </pages> <year> 1990. </year>
Reference-contexts: This latter antichain is in a sense the latest available consistent global checkpoint, and therefore the preferred global checkpoint for recovery purposes. We call this global checkpoint the recovery line of P. In the uncoordinated checkpointing protocols <ref> [2, 5, 9-12] </ref>, various dependency tracking mechanisms are used to record the happened before relation as it develops among the checkpoints, so that the recovery line can be established should some process initiate a rollback. <p> Specifically, two major alternatives exist: * Transitive Dependency Tracking [9, 10]: Complete happened before information is tracked. That is, if c i;x depends on c j;y , then p i will learn this fact when it receives the message giving rise to the dependency. * Direct Dependency Tracking <ref> [5, 9, 11, 12] </ref>: Processes do not learn of dependencies resulting from chains of two or more messages. <p> that all three patterns share the same set of consistent global checkpoints and that these checkpoints are precisely the maximum-sized antichains of the poset corresponding to the transitive closure of (d). 4 Related Work Much of the literature in this area is based on a model of piecewise determinism (PWD) <ref> [5, 8-10] </ref>. Under PWD assumptions, each process execution is viewed as a number of state intervals bounded by nondeterministic events, 7 such as message receipt. Execution within each state interval is completely deterministic, and hence replayable. This allows the use of message logging as a form of checkpointing. <p> Johnson and Zwaenepoel <ref> [5] </ref> demonstrate that such interval dependencies yield a lattice structure among recoverable system states (N fi N matrices of state intervals), which is isomorphic to our lattice of maximum-sized antichains based on checkpoint dependencies.
Reference: [6] <author> R. Koo and S. Toueg. </author> <title> Checkpointing and rollback-recovery for distributed systems. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> SE-13(1):23-31, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: Instead, a partial order on the events can be defined, using Lamport's happened before relation: in the global event set, we say that event e 1 directly happened before event e 2 <ref> [6, 7] </ref>, denoted by e 1 &lt; d e 2 , if 1. e 1 and e 2 are events in the same process and e 1 occurs immediately before e 2 ; or 2. e 1 is the sending of a message m and e 2 is the receiving of <p> A global checkpoint is defined as a set of N local checkpoints, one from each process. A consistent global checkpoint is a global checkpoint in which no two constituent checkpoints are related by the happened before relation <ref> [6] </ref>.
Reference: [7] <author> L. Lamport. </author> <title> Time, clocks and the ordering of events in a distributed system. </title> <journal> Comm. of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: In this paper we focus on uncoordinated checkpointing. We prove that the happened before relation <ref> [7] </ref>, commonly used as the formal basis for defining globally consistent states, is a sufficient but not necessary condition for construction of consistent global checkpoints from local checkpoints, and thus show that the tracking of full happened before information by the checkpointing protocol is not necessary in all applications. 2 A <p> Instead, a partial order on the events can be defined, using Lamport's happened before relation: in the global event set, we say that event e 1 directly happened before event e 2 <ref> [6, 7] </ref>, denoted by e 1 &lt; d e 2 , if 1. e 1 and e 2 are events in the same process and e 1 occurs immediately before e 2 ; or 2. e 1 is the sending of a message m and e 2 is the receiving of <p> The transitive closure of the &lt; d relation is the happened before relation &lt; <ref> [7] </ref>. For our purposes, the events of interest in any distributed system are the sending and receiving of messages, and the recording of local checkpoints by individual processes. An execution history restricted to these events will be called a checkpoint and communication pattern.
Reference: [8] <author> A. Lowry, J. R. Russell, and A. P. Goldberg. </author> <title> Optimistic failure recovery for very large networks. </title> <booktitle> In Proc. IEEE Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 66-75, </pages> <year> 1991. </year>
Reference: [9] <author> A. P. Sistla and J. L. Welch. </author> <title> Efficient distributed recovery using message logging In Proc. </title> <booktitle> 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 223-238, </pages> <year> 1989. </year>
Reference-contexts: One way in which dependency tracking schemes differ is in the completeness of this dependency information. Specifically, two major alternatives exist: * Transitive Dependency Tracking <ref> [9, 10] </ref>: Complete happened before information is tracked. <p> Specifically, two major alternatives exist: * Transitive Dependency Tracking [9, 10]: Complete happened before information is tracked. That is, if c i;x depends on c j;y , then p i will learn this fact when it receives the message giving rise to the dependency. * Direct Dependency Tracking <ref> [5, 9, 11, 12] </ref>: Processes do not learn of dependencies resulting from chains of two or more messages.
Reference: [10] <author> R. E. Strom and S. Yemini. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: One way in which dependency tracking schemes differ is in the completeness of this dependency information. Specifically, two major alternatives exist: * Transitive Dependency Tracking <ref> [9, 10] </ref>: Complete happened before information is tracked.
Reference: [11] <author> K. Tsuruoka, A. Kaneko, and Y. Nishihara. </author> <title> Dynamic recovery schemes for distributed processes. </title> <booktitle> In Proc. IEEE 2nd Symp. on Reliability in Distr. Software and Database Systems, </booktitle> <pages> pages 124-130, </pages> <year> 1981. </year>
Reference-contexts: Specifically, two major alternatives exist: * Transitive Dependency Tracking [9, 10]: Complete happened before information is tracked. That is, if c i;x depends on c j;y , then p i will learn this fact when it receives the message giving rise to the dependency. * Direct Dependency Tracking <ref> [5, 9, 11, 12] </ref>: Processes do not learn of dependencies resulting from chains of two or more messages.
Reference: [12] <author> Y. M. Wang, P. Y. Chung, I. J. Lin, and W. K. Fuchs, </author> <title> Checkpoint space reclamation for uncoordinated check-pointing in message-passing systems. </title> <type> Tech. Rep. </type> <institution> CRHC-92-06, Coordinated Science Laboratory, University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: Specifically, two major alternatives exist: * Transitive Dependency Tracking [9, 10]: Complete happened before information is tracked. That is, if c i;x depends on c j;y , then p i will learn this fact when it receives the message giving rise to the dependency. * Direct Dependency Tracking <ref> [5, 9, 11, 12] </ref>: Processes do not learn of dependencies resulting from chains of two or more messages. <p> As another example, Wang et al. have used this approach to develop an optimal garbage collection algorithm for uncoordinated checkpoints <ref> [12] </ref>. 5 Concluding Remarks We have shown that although the notion of checkpoint consistency is based on the happened before relation, that relation contains sufficient but not necessary information for the determination of consistent global checkpoints.
Reference: [13] <author> Y. M. Wang and W. K. Fuchs, </author> <title> Scheduling message processing for reducing rollback propagation, </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symposium (FTCS-22), </booktitle> <pages> pp. 204-211, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: We wish to stress that our transformation is fundamentally different from event swapping [4] or receive event reordering <ref> [13] </ref>, in that it only operates on the checkpoint and communication patterns (c.c.p.'s) and has nothing to do with the actual computations being modeled.
Reference: [14] <author> Y. M. Wang, Y. Huang, and W. K. Fuchs, </author> <title> Progressive retry for software error recovery in distributed systems, </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symposium (FTCS-23), </booktitle> <pages> pp. 138-144, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Specifically, the logging of a nondeterministic event is logically equivalent to a local checkpoint taken at the end of the ensuing state interval. The antichain model of consistent global checkpoints can then be applied to these logical checkpoints <ref> [14] </ref>. A more common approach in working with state intervals is to define a dependency relation directly on the intervals themselves: a state interval directly depends on the prior interval in its process, as well as on the interval in another process from which the message it receives was sent.
References-found: 14

