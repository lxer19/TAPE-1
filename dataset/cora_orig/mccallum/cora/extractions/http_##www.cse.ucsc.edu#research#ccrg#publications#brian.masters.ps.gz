URL: http://www.cse.ucsc.edu/research/ccrg/publications/brian.masters.ps.gz
Refering-URL: http://www.cse.ucsc.edu/research/ccrg/publications.html
Root-URL: http://www.cse.ucsc.edu
Title: A Comparison of Known Classes of Reliable Multicast Protocols  
Author: Brian Neil Levine 
Degree: A thesis submitted in partial satisfaction of the requirements for the degree of Master of Science in Computer Engineering by  The thesis of Brian Neil Levine is approved: Professor J.J. Garcia-Luna-Aceves Professor Alexandre Brandwajn Professor Darrell  
Date: June 1996  
Affiliation: University of California Santa Cruz  D.E. Long Dean of Graduate Studies and Research  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Jo-Mei Chang and N. F. Maxemchuk. </author> <title> Reliable broadcast protocols. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 251-273, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Although reliable broadcast protocols have existed for quite some time (e.g., see <ref> [1] </ref>), viable approaches on the provision of reliable multicasting over the Internet are just emerging. The reliable multicast problem facing the future Internet is compounded by its current size and continuing growth, which makes the handling of acknowledgments a major challenge commonly referred to as the acknowledgment (ack) implosion problem. <p> One of the first proposals for reliable multicasting is the token ring protocol (TRP) <ref> [1] </ref>; its aim was to combine the throughput advantages of naks with the reliability of acks. The Reliable Multicast Protocol (RMP) [17] discussed an updated WAN version of TRP. Although multiple rings are used in a naming hierarchy, the same class of protocol is used for the actual rings. <p> Extensions of the generic tree-based protocols that ensure liveness and safety when nodes can fail are discussed by Levine, Lavo, and Garcia-Luna-Aceves [19]. The proof of correctness for ring-based protocols is given by Chang and Maxemchuk <ref> [1] </ref>. The proof that sender-initiated unicast protocols are safe and live is available from many sources (e.g., see Bertsekas and Gallager [18]). The proof does not change significantly for the sender-initiated class of reliable multicast protocols and is omitted for brevity. <p> Taking expectations, we obtain E [Y R ] = E [Y a ] + (1 p) E [Y p ] + E [Y f ] + p E <ref> [L U + p (E [M r jM r &gt; 1] </ref> 1) E [Y n ] + p 2 (E [M r jM r &gt; 2] 2) E [Y t ]: (4.48) 30 As shown previously [2] E [M r jM r &gt; 1] = 1 p and as stated in <p> Taking expectations, we obtain E [Y R ] = E [Y a ] + (1 p) E [Y p ] + E [Y f ] + p E [L U + p (E <ref> [M r jM r &gt; 1] </ref> 1) E [Y n ] + p 2 (E [M r jM r &gt; 2] 2) E [Y t ]: (4.48) 30 As shown previously [2] E [M r jM r &gt; 1] = 1 p and as stated in the previous section E [M <p> E [Y p ] + E [Y f ] + p E [L U + p (E <ref> [M r jM r &gt; 1] </ref> 1) E [Y n ] + p 2 (E [M r jM r &gt; 2] 2) E [Y t ]: (4.48) 30 As shown previously [2] E [M r jM r &gt; 1] = 1 p and as stated in the previous section E [M r jM r &gt; 2] = 1 p Substituting Equations 4.40, 4.49, and 4.50 into Equation 4.48 we have E [Y R ] = E [X a ] + (1 p) E [Y <p> The baseline uses protocol A and can support exactly one receiver; if ! [R]; ! 2 fA; N 1; N 2;H1; H2; Rg is the speed of the processor that can support at most R receivers under protocol !, we set A <ref> [1] </ref> = 1. The baseline cost is equal to [2, 3] E [X A ] fi fi = A [1] 1 p 3 p : (5.1) Using Equations 5.1, 4.17, 4.34, and 4.45 we can derive the following 's for tree-based, tree-NAPP, and ring-based protocols, respectively: H1 [R] = E [X <p> if ! [R]; ! 2 fA; N 1; N 2;H1; H2; Rg is the speed of the processor that can support at most R receivers under protocol !, we set A <ref> [1] </ref> = 1. The baseline cost is equal to [2, 3] E [X A ] fi fi = A [1] 1 p 3 p : (5.1) Using Equations 5.1, 4.17, 4.34, and 4.45 we can derive the following 's for tree-based, tree-NAPP, and ring-based protocols, respectively: H1 [R] = E [X A ] = E [X A ] = E [X A ] H2 [R] = E [X A ]
Reference: [2] <author> Sridhar Pingali, Don Towsley, and James F. Kurose. </author> <title> A comparison of sender-initiated and receiver-initiated reliable multicast protocols. </title> <journal> In Performance Evaluation Review, </journal> <volume> volume 22, </volume> <pages> pages 221-230, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: The first comparative analysis of sender-initiated and receiver-initiated reliable multicast protocols was presented by Pingali et al. <ref> [2, 3] </ref>. <p> This thesis addresses the question of whether a reliable multicast protocol can be 2 designed that enjoys all the scaling properties of receiver-initiated protocols, while still being able to operate correctly with finite memory. To address this question, the previous analysis <ref> [2, 3] </ref> is extended to consider the maximum throughput of generic ring-based protocols, and two classes of tree-based protocols. These classes are the other three known approaches that can be used to solve the ack-implosion problem. <p> Chapter 3 addresses the correctness of the various classes of reliable multicast protocols introduced in our taxonomy, showing that the type of receiver-initiated protocols proposed to date require infinite memory. Chapter 4 extends the analysis by Pingali et al. <ref> [2, 3] </ref> by analyzing the maximum throughput of three protocol classes: tree-based, tree-based with local nak-avoidance and periodic polling (tree-NAPP), and ring-based protocols. <p> Chapter 6 provides concluding remarks. 4 2. Background 2.1 A New Taxonomy of Reliable Multicast Protocols We now describe the four generic approaches known to date for reliable multicasting. Well-known protocols (for unicast and multicast purposes) are mapped into each class. Our taxonomy differs from prior work <ref> [3, 2, 4] </ref> addressing receiver-initiated strategies for reliable multicasting in that we decouple the definition of the mechanisms needed for pacing of data transmission from the mechanisms needed for the allocation of memory at the source. <p> In the internet, these trees will be built using such protocols as DVMRP [7], Core Based Trees (CBT) [8] or Protocol Independent Multicast (PIM) [9]. 2.2 Sender-Initiated Protocols In the past <ref> [2] </ref>, sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. However, this characterization is overly restrictive and does not reflect the way in which several reliable multicast protocols that rely on positive acknowledgments from the receivers to the source have been designed. <p> The two known methods that address this limitation are: (a) using naks instead of acks, and (b) delegating retransmission responsibility to members of the receiver set by organizing the receivers into a ring or a tree. We discuss both approaches subsequently. 2.3 Receiver-Initiated Protocols Previous work <ref> [2] </ref> characterizes receiver-initiated protocols as placing the responsibility for ensuring reliable packet delivery at each receiver. The critical aspect of these protocols for our taxonomy is that no acks are used. <p> To remedy this problem, previous work on receiver-initiated protocols <ref> [2, 4] </ref> adopts the nak-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with nak-avoidance (RINA) protocols have been shown [2] to have improved the performance over the basic receiver-initiated protocol. <p> To remedy this problem, previous work on receiver-initiated protocols [2, 4] adopts the nak-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with nak-avoidance (RINA) protocols have been shown <ref> [2] </ref> to have improved the performance over the basic receiver-initiated protocol. The resulting generic RINA protocol is as follows [2]: The sender multicasts all packets and state information, giving priority to retransmissions. <p> Receiver-initiated with nak-avoidance (RINA) protocols have been shown <ref> [2] </ref> to have improved the performance over the basic receiver-initiated protocol. The resulting generic RINA protocol is as follows [2]: The sender multicasts all packets and state information, giving priority to retransmissions. Whenever a receiver detects a packet loss, it waits for a random time period and then multicasts a nak to the sender and all other receivers. <p> Maximum Throughput Analysis 4.1 Assumptions To analyze the maximum throughput that each of the generic reliable multicast protocols introduced in Chapter 2 can achieve, we use the same model used by Pingali et al. <ref> [2, 3] </ref>, which focuses on the processing requirements of generic reliable multicast protocols, rather than the communication bandwidth requirements. <p> Table 1 summarizes the bounds on maximum throughput for all the known classes of reliable multicast protocols. Our results clearly show that tree-NAPP protocols constitute the most scalable alternative. 4.2 Sender- and Receiver-Initiated Protocols Following the notation introduced by Pingali et al. <ref> [2, 3] </ref>, we place a superscript A on any variable related to the sender-initiated protocol, and N 1 and N 2 on variables related to the receiver-initiated and RINA protocols, respectively. <p> The maximum throughput of the protocols for a constant stream of packets to R receivers is <ref> [2] </ref>: 1=fl A 2 O R (1 + 1 p 1=fl N 1 2 O 1 + 1 p ; (4.2) p ln R Even as the probability of packet loss goes to zero, the throughput of the sender-initiated protocol is inversely dependent on R, the size of the receiver set, <p> No subscript denotes overall system throughput. X ; Y Times to process the reception and transmission, respectively, of a periodic hack. 19 protocol processor requirements p as a constant p ! 0 Sender-initiated <ref> [2] </ref> O 1p ) O (R ln R) O (R) Receiver-initiated nak-avoidance [2] O 1 + p ln R Ring-based (unicast retrans.) O 1 + 1p O (R) O (1) Tree-based O (B (1 p) + pB ln B) O (1) O (1) Tree-NAPP O 1p+p ln B+p 2 (14p) Table <p> No subscript denotes overall system throughput. X ; Y Times to process the reception and transmission, respectively, of a periodic hack. 19 protocol processor requirements p as a constant p ! 0 Sender-initiated <ref> [2] </ref> O 1p ) O (R ln R) O (R) Receiver-initiated nak-avoidance [2] O 1 + p ln R Ring-based (unicast retrans.) O 1 + 1p O (R) O (1) Tree-based O (B (1 p) + pB ln B) O (1) O (1) Tree-NAPP O 1p+p ln B+p 2 (14p) Table 1: Analytical bounds. sent by every receiver to the source once a <p> f ] + E [M ] E [X p ] + (E [M ] 1) E [X t ] + E [L H1 ] E [X h ]: (4.5) What we have derived so far is extremely similar to Equations (1) and (2) in the analysis by Pingali et al. <ref> [2] </ref>. In fact, we can use all of that analysis, with the understanding that B is the size of the receiver subset from which the source collects hacks. <p> E [X f ] + E [M ] E [X p ] + (E [M ] 1) E [X t ] + E [M ]B (1 p) E [X h ]: Because in H 1 the number of receivers R = B, the expected number of transmissions per packet is <ref> [10, 2] </ref> E [M ] = i=1 B B 1 A (1) i+1 1 : (4.8) Pingali et al. [3, 2] provided a bound of E [M ] using the following four equations. <p> t ] + E [M ]B (1 p) E [X h ]: Because in H 1 the number of receivers R = B, the expected number of transmissions per packet is [10, 2] E [M ] = i=1 B B 1 A (1) i+1 1 : (4.8) Pingali et al. <ref> [3, 2] </ref> provided a bound of E [M ] using the following four equations. H B E [M ] 1 + ln p 21 where H B = P B i=1 1=i, the harmonic numbers. <p> Notice that leaf nodes in the H1 protocol will process fewer retransmissions and thus send fewer acknowledgments than receivers in the A protocol. We can again use an analysis similar to the one by Pingali et al. <ref> [2] </ref> for receivers using a sender-initiated protocol. <p> Taking expectations of Eq. 4.28, E [Y H2 ] = E [M ](1 p) E [Y p ] + E [Y f ] + E [Y ] + (E [M ] 1) E [Y n ] + (B 1) B + ProbfM r &gt; 2g (E <ref> [M r jM r &gt; 2] </ref> 2) E [Y t ]: (4.29) It follows from the distribution of M r that [2] E [M r jM r &gt; 2] = (3 2p)=(1 p): (4.30) Therefore, noting Eq. 4.30 and that ProbfM r &gt; 2g = p 2 , we derive from <p> ] + E [Y f ] + E [Y ] + (E [M ] 1) E [Y n ] + (B 1) B + ProbfM r &gt; 2g (E [M r jM r &gt; 2] 2) E [Y t ]: (4.29) It follows from the distribution of M r that <ref> [2] </ref> E [M r jM r &gt; 2] = (3 2p)=(1 p): (4.30) Therefore, noting Eq. 4.30 and that ProbfM r &gt; 2g = p 2 , we derive from Eq. 4.29 the expected cost as E [Y H2 ] = E [M ](1 p) E [Y p ] + E <p> E [Y f ] + E [Y ] + (E [M ] 1) E [Y n ] + (B 1) B + ProbfM r &gt; 2g (E <ref> [M r jM r &gt; 2] </ref> 2) E [Y t ]: (4.29) It follows from the distribution of M r that [2] E [M r jM r &gt; 2] = (3 2p)=(1 p): (4.30) Therefore, noting Eq. 4.30 and that ProbfM r &gt; 2g = p 2 , we derive from Eq. 4.29 the expected cost as E [Y H2 ] = E [M ](1 p) E [Y p ] + E [Y f <p> Taking expectations, we obtain E [Y R ] = E [Y a ] + (1 p) E [Y p ] + E [Y f ] + p E [L U + p (E [M r jM r &gt; 1] 1) E [Y n ] + p 2 (E <ref> [M r jM r &gt; 2] </ref> 2) E [Y t ]: (4.48) 30 As shown previously [2] E [M r jM r &gt; 1] = 1 p and as stated in the previous section E [M r jM r &gt; 2] = 1 p Substituting Equations 4.40, 4.49, and 4.50 into <p> (1 p) E [Y p ] + E [Y f ] + p E [L U + p (E [M r jM r &gt; 1] 1) E [Y n ] + p 2 (E [M r jM r &gt; 2] 2) E [Y t ]: (4.48) 30 As shown previously <ref> [2] </ref> E [M r jM r &gt; 1] = 1 p and as stated in the previous section E [M r jM r &gt; 2] = 1 p Substituting Equations 4.40, 4.49, and 4.50 into Equation 4.48 we have E [Y R ] = E [X a ] + (1 p) <p> [M r jM r &gt; 1] 1) E [Y n ] + p 2 (E <ref> [M r jM r &gt; 2] </ref> 2) E [Y t ]: (4.48) 30 As shown previously [2] E [M r jM r &gt; 1] = 1 p and as stated in the previous section E [M r jM r &gt; 2] = 1 p Substituting Equations 4.40, 4.49, and 4.50 into Equation 4.48 we have E [Y R ] = E [X a ] + (1 p) E [Y p ] + E [Y f ] + p E [Y p ] + 1 p E <p> The graph represents the inverse of Equations 4.18, 4.34, and 4.45, respectively, which are the throughputs for the tree-based, tree-NAPP, and ring-based protocols, as well as the inverse of the throughput equations derived previously <ref> [2] </ref> for sender- and receiver-initiated protocols. The top, middle and bottom graphs correspond to increasing probabilities of packet loss, 1%, 10%, and 25%, respectively. The performance of nak-avoidance protocols, especially tree-NAPP protocols, is clearly superior. However, our assumptions place these two sub-classes at an advantage over their base classes. <p> This number is obtained by normalizing all classes to a baseline processor, as described by Pingali et al. <ref> [2, 3] </ref>. The baseline uses protocol A and can support exactly one receiver; if ! [R]; ! 2 fA; N 1; N 2;H1; H2; Rg is the speed of the processor that can support at most R receivers under protocol !, we set A [1] = 1. <p> The baseline cost is equal to <ref> [2, 3] </ref> E [X A ] fi fi = A [1] 1 p 3 p : (5.1) Using Equations 5.1, 4.17, 4.34, and 4.45 we can derive the following 's for tree-based, tree-NAPP, and ring-based protocols, respectively: H1 [R] = E [X A ] = E [X A ] = E <p> [X A ] = E [X A ] 1 p R [R] = E [X A ] = E [X A ] 1 + 1 + 1 + (1 p) 1 2 (R 1)p 35 The number of supportable receivers derived for sender- and receiver-initiated protocols are shown to be <ref> [2, 3] </ref>, A [R] = E [X A ] N1 [R] = E [X A ] N2 [R] = E [X A ] Because the exact value of E [M ] is difficult to compute for large values of R, we use the approximation [2, 3], E [M ] a + <p> receiver-initiated protocols are shown to be <ref> [2, 3] </ref>, A [R] = E [X A ] N1 [R] = E [X A ] N2 [R] = E [X A ] Because the exact value of E [M ] is difficult to compute for large values of R, we use the approximation [2, 3], E [M ] a + ln (p) where a is the value of E [M ] for R = 35 and H k is the harmonic series.
Reference: [3] <author> Sridhar Pingali. </author> <title> Protocol and Real-Time Scheduling Issues for Multimedia Applications. </title> <type> PhD thesis, </type> <institution> University of Massachusetts Amherst, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: The first comparative analysis of sender-initiated and receiver-initiated reliable multicast protocols was presented by Pingali et al. <ref> [2, 3] </ref>. <p> This thesis addresses the question of whether a reliable multicast protocol can be 2 designed that enjoys all the scaling properties of receiver-initiated protocols, while still being able to operate correctly with finite memory. To address this question, the previous analysis <ref> [2, 3] </ref> is extended to consider the maximum throughput of generic ring-based protocols, and two classes of tree-based protocols. These classes are the other three known approaches that can be used to solve the ack-implosion problem. <p> Chapter 3 addresses the correctness of the various classes of reliable multicast protocols introduced in our taxonomy, showing that the type of receiver-initiated protocols proposed to date require infinite memory. Chapter 4 extends the analysis by Pingali et al. <ref> [2, 3] </ref> by analyzing the maximum throughput of three protocol classes: tree-based, tree-based with local nak-avoidance and periodic polling (tree-NAPP), and ring-based protocols. <p> Chapter 6 provides concluding remarks. 4 2. Background 2.1 A New Taxonomy of Reliable Multicast Protocols We now describe the four generic approaches known to date for reliable multicasting. Well-known protocols (for unicast and multicast purposes) are mapped into each class. Our taxonomy differs from prior work <ref> [3, 2, 4] </ref> addressing receiver-initiated strategies for reliable multicasting in that we decouple the definition of the mechanisms needed for pacing of data transmission from the mechanisms needed for the allocation of memory at the source. <p> Maximum Throughput Analysis 4.1 Assumptions To analyze the maximum throughput that each of the generic reliable multicast protocols introduced in Chapter 2 can achieve, we use the same model used by Pingali et al. <ref> [2, 3] </ref>, which focuses on the processing requirements of generic reliable multicast protocols, rather than the communication bandwidth requirements. <p> Table 1 summarizes the bounds on maximum throughput for all the known classes of reliable multicast protocols. Our results clearly show that tree-NAPP protocols constitute the most scalable alternative. 4.2 Sender- and Receiver-Initiated Protocols Following the notation introduced by Pingali et al. <ref> [2, 3] </ref>, we place a superscript A on any variable related to the sender-initiated protocol, and N 1 and N 2 on variables related to the receiver-initiated and RINA protocols, respectively. <p> t ] + E [M ]B (1 p) E [X h ]: Because in H 1 the number of receivers R = B, the expected number of transmissions per packet is [10, 2] E [M ] = i=1 B B 1 A (1) i+1 1 : (4.8) Pingali et al. <ref> [3, 2] </ref> provided a bound of E [M ] using the following four equations. H B E [M ] 1 + ln p 21 where H B = P B i=1 1=i, the harmonic numbers. <p> This number is obtained by normalizing all classes to a baseline processor, as described by Pingali et al. <ref> [2, 3] </ref>. The baseline uses protocol A and can support exactly one receiver; if ! [R]; ! 2 fA; N 1; N 2;H1; H2; Rg is the speed of the processor that can support at most R receivers under protocol !, we set A [1] = 1. <p> The baseline cost is equal to <ref> [2, 3] </ref> E [X A ] fi fi = A [1] 1 p 3 p : (5.1) Using Equations 5.1, 4.17, 4.34, and 4.45 we can derive the following 's for tree-based, tree-NAPP, and ring-based protocols, respectively: H1 [R] = E [X A ] = E [X A ] = E <p> [X A ] = E [X A ] 1 p R [R] = E [X A ] = E [X A ] 1 + 1 + 1 + (1 p) 1 2 (R 1)p 35 The number of supportable receivers derived for sender- and receiver-initiated protocols are shown to be <ref> [2, 3] </ref>, A [R] = E [X A ] N1 [R] = E [X A ] N2 [R] = E [X A ] Because the exact value of E [M ] is difficult to compute for large values of R, we use the approximation [2, 3], E [M ] a + <p> receiver-initiated protocols are shown to be <ref> [2, 3] </ref>, A [R] = E [X A ] N1 [R] = E [X A ] N2 [R] = E [X A ] Because the exact value of E [M ] is difficult to compute for large values of R, we use the approximation [2, 3], E [M ] a + ln (p) where a is the value of E [M ] for R = 35 and H k is the harmonic series.
Reference: [4] <author> Sally Floyd, Van Jacobson, Steven McCanne, Ching-Gung Liu, and Lixia Zhang. </author> <title> A reliable multicast framework for light-weight sessions and application level framing. </title> <booktitle> In Proc. ACM SIGCOMM'95. ACM Computer Communication Review, </booktitle> <pages> pages 342-356, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Chapter 6 provides concluding remarks. 4 2. Background 2.1 A New Taxonomy of Reliable Multicast Protocols We now describe the four generic approaches known to date for reliable multicasting. Well-known protocols (for unicast and multicast purposes) are mapped into each class. Our taxonomy differs from prior work <ref> [3, 2, 4] </ref> addressing receiver-initiated strategies for reliable multicasting in that we decouple the definition of the mechanisms needed for pacing of data transmission from the mechanisms needed for the allocation of memory at the source. <p> However, as suggested by the results reported by Floyd et al. <ref> [4] </ref>, a better approach for pacing a multicast session is for each receiver to set its own timeout. <p> To remedy this problem, previous work on receiver-initiated protocols <ref> [2, 4] </ref> adopts the nak-avoidance scheme first proposed for NAPP, which is a sender-initiated protocol. Receiver-initiated with nak-avoidance (RINA) protocols have been shown [2] to have improved the performance over the basic receiver-initiated protocol. <p> The generic RINA protocol we have just described constitutes the basis for the operation of the scalable reliable multicasting (SRM) algorithm <ref> [4] </ref>. SRM has been successfully embedded into a internet collaborative whiteboard application called wb. SRM sets timers based on low-rate, periodic, "session-messages" multicast by every receiver.
Reference: [5] <author> Jon B. Postel, ed. </author> <title> Transmission control protocol. </title> <type> RFC 793, </type> <month> September </month> <year> 1981. </year>
Reference-contexts: In practice, protocols may use a single window for pacing and memory (e.g., TCP <ref> [5] </ref>) or separate windows (e.g., NETBLT [6]). It will become apparent that this decoupling is critical in obtaining an accurate understanding of why reliable unicasting and multicasting protocols scale and work correctly with finite memory.
Reference: [6] <author> David D. Clark, Mark L. Lambert, and Lixia Zhang. NETBLT: </author> <title> A high throughput transport protocol. </title> <booktitle> In Proc. ACM SIGCOMM. ACM Computer Communication Review, </booktitle> <pages> pages 353-359, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: In practice, protocols may use a single window for pacing and memory (e.g., TCP [5]) or separate windows (e.g., NETBLT <ref> [6] </ref>). It will become apparent that this decoupling is critical in obtaining an accurate understanding of why reliable unicasting and multicasting protocols scale and work correctly with finite memory. Each reliable protocol assumes the existence of multicast routing tree (s) that are provided by underlying multicast routing protocols.
Reference: [7] <author> Stephen Deering and David Cheriton. </author> <title> Multicast routing in datagram inter-networks and extended lans. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(2) </volume> <pages> 85-110, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Each reliable protocol assumes the existence of multicast routing tree (s) that are provided by underlying multicast routing protocols. In the internet, these trees will be built using such protocols as DVMRP <ref> [7] </ref>, Core Based Trees (CBT) [8] or Protocol Independent Multicast (PIM) [9]. 2.2 Sender-Initiated Protocols In the past [2], sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender.
Reference: [8] <author> Tony Ballardie, Paul Francis, and Jon Crowcroft. </author> <title> Core based trees (CBT): An architecture for scalable inter-domain multicast routing. </title> <booktitle> In Proc. ACM SIGCOMM'93, </booktitle> <pages> pages 85-95, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Each reliable protocol assumes the existence of multicast routing tree (s) that are provided by underlying multicast routing protocols. In the internet, these trees will be built using such protocols as DVMRP [7], Core Based Trees (CBT) <ref> [8] </ref> or Protocol Independent Multicast (PIM) [9]. 2.2 Sender-Initiated Protocols In the past [2], sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. <p> Our assumptions clearly fail to model real systems accurately but greatly increase the tractability of the model. Such multicast routing protocols as CBT, PIM, and DVMRP <ref> [8, 9, 20] </ref> organize routers into trees, which means that there is a correlation between packet loss at each receiver.
Reference: [9] <author> Stephen Deering, Deborah Estrin, Dino Farinacci, Van Jacobson, and others. </author> <title> An architecture for wide-area multicast routing. </title> <booktitle> In ACM SIGCOMM'94, </booktitle> <pages> pages 126-135, </pages> <year> 1994. </year>
Reference-contexts: Each reliable protocol assumes the existence of multicast routing tree (s) that are provided by underlying multicast routing protocols. In the internet, these trees will be built using such protocols as DVMRP [7], Core Based Trees (CBT) [8] or Protocol Independent Multicast (PIM) <ref> [9] </ref>. 2.2 Sender-Initiated Protocols In the past [2], sender-initiated protocols have been characterized as placing the responsibility of reliable delivery at the sender. <p> Our assumptions clearly fail to model real systems accurately but greatly increase the tractability of the model. Such multicast routing protocols as CBT, PIM, and DVMRP <ref> [8, 9, 20] </ref> organize routers into trees, which means that there is a correlation between packet loss at each receiver.
Reference: [10] <author> S. Ramakrishnan and B. N. Jain. </author> <title> A negative acknowledgment with periodic polling protocol for multicast over lan. </title> <booktitle> In IEEE Infocom, </booktitle> <pages> pages 502-511, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: A protocol similar to NETBLT is the "Negative Acknowledgments with Periodic Polling" (NAPP) protocol <ref> [10] </ref>. This protocol is a broadcast protocol for LANs. Like NETBLT, NAPP groups together large partitions of the data that are periodically acked, while lost packets within the partition are naked. NAPP advances the cw by naks and periodically advances the mw by acks. <p> We define a tree-NAPP protocol as a tree-based protocol that uses nak-avoidance and periodic polling <ref> [10] </ref> in the local groups. Naks alone are not sufficient to guarantee reliability with finite memory, so receivers send a periodic positive (hierarchical) acknowledgment to their parents to advance the cw. <p> E [X f ] + E [M ] E [X p ] + (E [M ] 1) E [X t ] + E [M ]B (1 p) E [X h ]: Because in H 1 the number of receivers R = B, the expected number of transmissions per packet is <ref> [10, 2] </ref> E [M ] = i=1 B B 1 A (1) i+1 1 : (4.8) Pingali et al. [3, 2] provided a bound of E [M ] using the following four equations. <p> TRP and RMP limit their throughput by requiring retransmissions to be unicast. It would be possible to reduce the cost bound to O (ln R), assuming p to be a constant, if the nak-avoidance techniques presented by Ramakrishnan and Jain <ref> [10] </ref> were used. Our analysis shows that trees are the answer to the scalability problem for reliable multicasting. Only tree-based and tree-NAPP classes have a throughput that is constant with respect to the number of receivers even when the probability of packet loss is not negligible.
Reference: [11] <author> W. Timothy Strayer, Bert Dempsey, and Alfred Weaver. XTP: </author> <title> The Xpress Transfer Protocol. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1992. </year>
Reference-contexts: The use of periodic polling limits NAPP to LANs, because the source can still suffer from an ack-implosion problem even if acks occur less often. Other sender-initiated protocols, like the Xpress Transfer Protocol (XTP) <ref> [11] </ref>, were created for use on an internet, but still suffer from the ack-implosion problem. The main limitation of sender-initiated protocols is not that acks are used, but the need for the source to process all of the acks and to know the receiver set.
Reference: [12] <author> Hugh Holbrook, Sandeep K. Singhal, and David R. Cheriton. </author> <title> Log-based receiver-reliable multicast for distributed interactive simulation. </title> <booktitle> In Proc. ACM SIGCOMM'95, </booktitle> <pages> pages 328-341, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Another example of a receiver-initiated protocol is the "log-based receiver-reliable multi-cast" (LBRM) <ref> [12] </ref>, which uses a hierarchy of log servers that store information indefinitely and receivers recover by contacting a log server. Using log servers is feasible only for applications that can afford the servers and leaves many issues unresolved.
Reference: [13] <author> Sanjoy Paul, Krishan K. Sabnani, and David K. Kristol. </author> <title> Multicast transport protocols for high speed networks. </title> <booktitle> In International Conference on Network Protocols, </booktitle> <pages> pages 4-14, </pages> <year> 1994. </year>
Reference-contexts: Because out analysis focuses on maximum attainable throughput of protocol classes, we will assume that ack tree perfectly mirrors the routing tree created by the underlying routing protocol. The first application of tree-based protocols to reliable multicasting over the internet was 11 reported by Paul et al. <ref> [13] </ref>, who compare three basic schemes for reliable point-to-multipoint multicasting using hierarchical structures. Their results have been fully developed as the reliable multicast transport protocol (RMTP) [14].
Reference: [14] <author> John C. Lin and Sanjoy Paul. RMTP: </author> <title> A reliable multicast transport protocol. </title> <booktitle> In IEEE Infocom, </booktitle> <pages> pages 1414-1425, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: The first application of tree-based protocols to reliable multicasting over the internet was 11 reported by Paul et al. [13], who compare three basic schemes for reliable point-to-multipoint multicasting using hierarchical structures. Their results have been fully developed as the reliable multicast transport protocol (RMTP) <ref> [14] </ref>. While our generic protocol sends a hack for every packet sent by the source, RMTP sends hacks only periodically, so as not to conserve bandwidth. RMTP has been implemented on several platforms and has been used successfully in AT&T's call detail data distribution network [15].
Reference: [15] <author> Sanjoy Paul, Richard Buskens, Krishan Sabnani, Muhammad Siddiqui, John Lin, and Supratik Bhattacharya. </author> <title> Reliable multicasting. </title> <booktitle> Slides presented at IEEE Computer Communications Workshop, </booktitle> <address> Orcas Island, Washington, </address> <month> Sept </month> <year> 1995. </year>
Reference-contexts: While our generic protocol sends a hack for every packet sent by the source, RMTP sends hacks only periodically, so as not to conserve bandwidth. RMTP has been implemented on several platforms and has been used successfully in AT&T's call detail data distribution network <ref> [15] </ref>. Tree-based protocols eliminate the ack implosion problem and free the source from having to know the receiver set, work with finite memory, provide maximum end-to-end delays that are bounded, and operate solely on messages exchanged in local groups (between a node and its children in the ack tree).
Reference: [16] <author> Rajendra Yavatkar, James Griffioen, and Madhu Sudan. </author> <title> A reliable dissemination protocol for interactive collaborative applications. </title> <booktitle> In Proc. ACM Multimedia, </booktitle> <pages> pages 333-44, </pages> <year> 1995. </year> <month> 39 </month>
Reference-contexts: Note that messages sent for the setting of timers needed for nak-avoidance are limited to the local group, which is scalable. The tree-based multicast transport protocol (TMTP) <ref> [16] </ref> is the only specification of a tree-NAPP protocol to date. 2.5 Ring-Based Protocols Token-ring based protocols for reliable multicast were originally developed to provide support for applications that require an atomic and total ordering of transmissions at all receivers.
Reference: [17] <author> Brian Whetten, Simon Kaplan, and Todd Montgomery. </author> <title> A high performance totally ordered multicast protocol. </title> <note> Available from research.ivv.nasa.gov by ftp /pub/doc/RMP/RMP dagstuhl.ps, </note> <month> August </month> <year> 1994. </year>
Reference-contexts: One of the first proposals for reliable multicasting is the token ring protocol (TRP) [1]; its aim was to combine the throughput advantages of naks with the reliability of acks. The Reliable Multicast Protocol (RMP) <ref> [17] </ref> discussed an updated WAN version of TRP. Although multiple rings are used in a naming hierarchy, the same class of protocol is used for the actual rings.
Reference: [18] <author> Dimitri Bertsekas and Robert Gallager. </author> <title> Data Networks. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: Because out analysis focuses on maximum attainable throughput of protocol classes, we will assume that the token is passed exactly once per message. 13 3. Protocol Correctness A protocol is considered correct if it is shown to be both safe and live <ref> [18] </ref>. For any reliable multicast protocol to be considered safe, it must deliver all data in order to a higher layer at the receivers. To be live, the reliable multicast protocol must never have a case where data cannot be delivered to a higher layer at any of the receivers. <p> The proof of correctness for ring-based protocols is given by Chang and Maxemchuk [1]. The proof that sender-initiated unicast protocols are safe and live is available from many sources (e.g., see Bertsekas and Gallager <ref> [18] </ref>). The proof does not change significantly for the sender-initiated class of reliable multicast protocols and is omitted for brevity. <p> Therefore, the proof follows from the correctness proof of unicast retransmission protocols presented by Bertsekas and Gallager <ref> [18] </ref>. For h &gt; 1, assume the theorem holds for any t such that (1 t &lt; h). We must prove the theorem holds for some t = h. <p> For clarity, we assume a single ack tree rooted at the source in the analysis of tree-based protocols. A selective repeat retransmission strategy is assumed in all the protocol classes since it is the retransmission strategy with the highest throughput <ref> [18] </ref>, and its requirement of keeping buffers at the receivers is a non-issue given the small of cost memory. Assumptions specific to each protocol are listed in Chapter 2, and are in the interest of modeling maximum throughput.
Reference: [19] <author> Brian Neil Levine, David Lavo, and J.J. Garcia-Luna-Aceves. </author> <title> The case for concurrent reliable multicasting using shared ack trees. </title> <booktitle> In Proc. ACM Multimedia, </booktitle> <month> November </month> <year> 1996. </year>
Reference-contexts: We assume that there exists some non-zero probability that a packet is received error-free, and that all senders and receivers have finite memory. Extensions of the generic tree-based protocols that ensure liveness and safety when nodes can fail are discussed by Levine, Lavo, and Garcia-Luna-Aceves <ref> [19] </ref>. The proof of correctness for ring-based protocols is given by Chang and Maxemchuk [1]. The proof that sender-initiated unicast protocols are safe and live is available from many sources (e.g., see Bertsekas and Gallager [18]). <p> The number of tree hops from the receiver to the source is also a factor in how quickly the source can release data from memory in the presence of node failures, as discussed by Levine, Lavo, and Garcia-Luna-Aceves <ref> [19] </ref>. relative to processor speed requirements. This number is obtained by normalizing all classes to a baseline processor, as described by Pingali et al. [2, 3]. <p> Based on these results, our future work focuses on developing new tree-based protocols for scalable reliable multicasting in the Internet <ref> [19] </ref>. 38
Reference: [20] <author> Stephen Deering. </author> <title> Multicast routing in a datagram internetwork. </title> <type> PhD thesis, </type> <institution> Stanford University, Palo Alto, California, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Our assumptions clearly fail to model real systems accurately but greatly increase the tractability of the model. Such multicast routing protocols as CBT, PIM, and DVMRP <ref> [8, 9, 20] </ref> organize routers into trees, which means that there is a correlation between packet loss at each receiver.
References-found: 20

