URL: ftp://ftp.cs.arizona.edu/xkernel/Papers/tr96-11.ps
Refering-URL: http://swarm.cs.wustl.edu/~picco/papers/biblio/misc.bib.html
Root-URL: 
Title: Liquid Software: A New Paradigm for Networked Systems  
Author: John Hartman, Udi Manber, Larry Peterson, and Todd Proebsting 
Address: Tucson, AZ 85721  
Affiliation: Department of Computer Science The University of Arizona  
Date: TR 96-11  
Abstract: This paper introduces the idea of dynamically moving functionality in a networkbetween clients and servers, and between hosts at the edge of the network and nodes inside the network. At the heart of moving functionality is the ability to support mobile codecode that is not tied to any single machine, but instead can easily move from one machine to another. Mobile code has been studied mostly for application-level code. This paper explores its use for all facets of the network, and in a much more general way. Issues of efficiency, interface design, security, and resource allocation, among others, are addressed. We use the term liquid software to describe the complete pictureliquidsoftware is an entire infrastructure for dynamically moving functionality throughout a network. We expect liquid software to enble new paradigms, such as active networks that allow users and applications to customize the network by interjecting code into it. 
Abstract-found: 1
Intro-found: 1
Reference: [BDH + 95] <author> C. M. Bowman, P. B. Danzig, D. R. Hardy, U. Manber, and M. F. Schwartz. </author> <title> The Harvest information discovery and access system. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 28 </volume> <pages> 119-125, </pages> <year> 1995. </year>
Reference-contexts: We are using the search applications as a vehicle to perform large-scale experiments with liquid software, and at the same time provide very useful tools for others. This follows naturally our work on Glimpse [MW94] and Harvest <ref> [BDH + 95] </ref>. 4 System Infrastructure We are building a complete system to demonstrate liquid software.
Reference: [CAC94] <editor> Special issue on intelligent agents. </editor> <booktitle> Communications of the ACM, </booktitle> <volume> 37, </volume> <month> July </month> <year> 1994. </year>
Reference-contexts: Ertl demonstrated the speed advantages and complexities involved in caching multiple stack elements in registers in a stack-based interpreter [Ert95]. 5.2 Mobile Search The closest area to mobile search is the area of intelligent information agents, which have received a lot of deserved attention lately <ref> [CAC94, WJ95] </ref>. Attempts to combine several search engines has been carried out most prominently by the meta-crawler [SE95]. Wiederhold [Wie92] (and many others) suggest mediators, which mediate between the users, their data, and their application software.
Reference: [Eng96] <author> D. R. Engler. </author> <title> VCODE: a retargetable, extensible, very fast dynamic code generation system. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <month> May </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: The machine specifications indicate the translation from the tree format to machine instructions, and the binary format of those instructions. Porting DCG to a new platform requires creating new machine specifications. Engler has created a newer, more efficient dynamic code generation system called VCODE <ref> [Eng96] </ref>. VCODE is a machine-independent intermediate representation that resembles 3-address code for a RISC-like instruction set architecture. The VCODE is simple to translate (suboptimally) to machine code. The translation system requires about 20 instructions per instruction generated. Like DCG the VCODE system is built with tools that process machine specifications.
Reference: [EP94] <author> Dawson R. Engler and Todd A. Proebsting. </author> <title> DCG: An efficient, retargetable dynamic code generation system. </title> <booktitle> In International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 263-273, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: optimized compiler components from concise specifications, and (2) modifications to the Java bytecode distribution format to decrease the overhead of processing the bytecodes. 2.1 Retargetable Compiler Issues If the host receives machine-independent liquid software, but must execute at native speeds, the mobile code must be translated dynamically to native code <ref> [EP94] </ref>. The problem of dynamic translation of Java bytecode to native code is complicated by the need to have a (necessarily machine-dependent) translator for every host architecture. Quickly generating machine code requires three fast compiler components: fast instruction selection, fast instruction assembly, and fast address relocation. <p> Leone and Lee's system automatically generates specialized routines for a functional language, Fabius [LL94]. Their system does not expose any details of the code generation to the user, and operates relatively efficiently. 10 Engler and Proebsting took a more nuts-and-bolts approach to dynamic code generation with their DCG system <ref> [EP94] </ref>. At run time users specify code to be emitted in a machine-independent tree format which is subsequently translated by DCG to binary code for immediate execution. The translation is efficient, executing about 300 instructions for every instruction generated.
Reference: [Ert95] <author> M. Anton Ertl. </author> <title> Stack caching for interpreters. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 315-327, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Much of the work has centered around the time/space tradeoffs for various encodings of the interpreted code (e.g., direct-threaded vs. indirect threaded)[Pit87, Kli81]. Ertl demonstrated the speed advantages and complexities involved in caching multiple stack elements in registers in a stack-based interpreter <ref> [Ert95] </ref>. 5.2 Mobile Search The closest area to mobile search is the area of intelligent information agents, which have received a lot of deserved attention lately [CAC94, WJ95]. Attempts to combine several search engines has been carried out most prominently by the meta-crawler [SE95].
Reference: [Fra94] <author> Michael Steffan Oliver Franz. </author> <title> Code-Generation On-the-Fly: A Key to Portable Software. </title> <type> PhD thesis, </type> <institution> Swiss Federal Institute of Technology Zurich, </institution> <year> 1994. </year>
Reference-contexts: The generated routines can also handle the relocation of addresses within previously assembled instructions. Unfortunately, the generated routines, while useful, are not optimized for speed. Franz developed a system for generating code on the fly for Oberon programs <ref> [Fra94] </ref>. Like Java, Oberon modules load dynamically, piece by piece. Franz's system loaded compiled modules as abstract syntax trees for immediate translation to machine code.
Reference: [FS91] <author> G. Fischer and C. Stevens. </author> <title> Information access in complex, poorly structured information spaces. </title> <booktitle> Human Factors in Comp. Sys. (CHI91) proc, </booktitle> <pages> pages 63-70, </pages> <year> 1991. </year>
Reference-contexts: Using user preferences and histories has been incorporated into several search applications including NetAgent [PC95], which allows users to share common views and feedback through collaborative indexing (they used our Glimpse system for their indexing), INFOSCOPE <ref> [FS91] </ref>, which makes suggestions based on previous usage patterns, and the Expertise Locator [KMS95] of Bell Labs for locating experts in any particular topic (they also use our Glimpse system).
Reference: [jav95] <author> The JAVA language: </author> <title> A white paper. </title> <type> Technical report, </type> <institution> Sun Microsystems, </institution> <year> 1995. </year>
Reference-contexts: The goal is to compile liquid software as fast as it can be transmitted over the networkthat is, to build a gigabit compiler. For initial evaluation, Java bytecode is being used for the machine-independent code representation <ref> [jav95] </ref>. Sun Microsystems developed Java bytecode to support mobile code on the World Wide Web. The bytecode achieves machine independence by fixing the byte-ordering, data alignment, calling conventions, data layouts, and so on, to a fixed standard.
Reference: [Kli81] <author> Paul Klint. </author> <title> Interpretation techniques. </title> <journal> Software Practice and Experience, </journal> <volume> 11(10) </volume> <pages> 963-973, </pages> <month> October </month> <year> 1981. </year>
Reference: [KMS95] <author> H. Kautz, A. Milewski, and B. Selman. </author> <title> Agent amplified communication. </title> <booktitle> AAAI Spring Symposium Series on Information Gathering from Distributed, Heterogeneous Environments, </booktitle> <year> 1995. </year>
Reference-contexts: Using user preferences and histories has been incorporated into several search applications including NetAgent [PC95], which allows users to share common views and feedback through collaborative indexing (they used our Glimpse system for their indexing), INFOSCOPE [FS91], which makes suggestions based on previous usage patterns, and the Expertise Locator <ref> [KMS95] </ref> of Bell Labs for locating experts in any particular topic (they also use our Glimpse system).
Reference: [Kup93] <author> Michael D. Kupfer. </author> <title> Sprite on Mach. </title> <booktitle> Proceedings of the Third USENIX Mach Symposium, </booktitle> <pages> pages 307-322, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Micro-kernel operating systems 7 offer a concrete example of this peril. Touted as a mechanism for implementing flexible operating system services, in reality they created lower-level static interfaces of their own that often proved inadequate <ref> [Kup93] </ref>. The static interface of primary concern for liquid software is that of the application programmer's interface, or API. The API is the interface to the services provided by the underlying operating system.
Reference: [LL94] <author> Mark Leone and Peter Lee. </author> <title> Lightweight run-time code generation. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 97-106, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Dynamic code generation is routinely studied as it relates to generating highly specialized routines optimized with respect to values that could only be known at run time. Leone and Lee's system automatically generates specialized routines for a functional language, Fabius <ref> [LL94] </ref>. Their system does not expose any details of the code generation to the user, and operates relatively efficiently. 10 Engler and Proebsting took a more nuts-and-bolts approach to dynamic code generation with their DCG system [EP94].
Reference: [MMO + 95] <author> A. Montz, D. Mosberger, S. W. O'Malley, L. Peterson, and T. Proebsting. </author> <title> Scout: A communications-oriented operating system. </title> <booktitle> In Proceedings of the Fifth HotOS Workshop, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: The system supports the mobile search application implemented in Java and a fast and dynamic compiler for Java bytecode, all running on top of Scouta communication-oriented OS explicitly designed to support customization <ref> [MMO + 95] </ref>. Once completed, this platform will be used to experiment with liquid software as an approach to building large-scale, dynamically-customizable networks. Our main objective in pursuing this demonstration system is to gain experience with liquid software.
Reference: [MW94] <author> U. Manber and S. Wu. GLIMPSE: </author> <title> A tool to search through entire file systems. </title> <booktitle> In Usenix Winter 1994 Technical Conference, </booktitle> <pages> pages 23-32, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: We are using the search applications as a vehicle to perform large-scale experiments with liquid software, and at the same time provide very useful tools for others. This follows naturally our work on Glimpse <ref> [MW94] </ref> and Harvest [BDH + 95]. 4 System Infrastructure We are building a complete system to demonstrate liquid software.
Reference: [OPM94] <author> Sean O'Malley, Todd A. Proebsting, and A. Brady Montz. </author> <title> USC: A universal stub compiler. </title> <booktitle> In Proceedings of SIGCOMM 94 Conference on Communications Architectures, Protocols and Applications, </booktitle> <pages> pages 295-306, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: To read these values quickly, they must be marshalled efficiently. We plan to automatically generate marshalling code optimized for each target machine, to ensure efficient (and accurate) reading of unaligned data. Experiments have shown that general-purpose marshalling routines used in network protocols can increase speeds by 20fi <ref> [OPM94] </ref>. 2.5 Symbol Tables Both the verifier and the bytecode compiler must maintain symbol-table information in order to properly process the bytecode. The current Java-bytecode distribution format contains enough information to efficiently resolve all symbol table references within a given class.
Reference: [PC95] <author> Taeha Park and Kilnam Chon. Netagent: </author> <title> A global search system over internet resources by distributed agents. </title> <booktitle> In INET'95 Hypermedia Proceedings, </booktitle> <year> 1995. </year>
Reference-contexts: These mediators are assumed to reside in the servers, but they could also be implemented as liquid software. Using user preferences and histories has been incorporated into several search applications including NetAgent <ref> [PC95] </ref>, which allows users to share common views and feedback through collaborative indexing (they used our Glimpse system for their indexing), INFOSCOPE [FS91], which makes suggestions based on previous usage patterns, and the Expertise Locator [KMS95] of Bell Labs for locating experts in any particular topic (they also use our Glimpse
Reference: [PEK96] <author> Massimiliano Poletto, Dawson R. Engler, and M. Frans Kaashoek. tcc: </author> <title> A template-based compiler for `C. </title> <booktitle> In Proceedings of the Workshop on Compiler Support for Systems Software, </booktitle> <pages> pages 1-7, </pages> <month> February </month> <year> 1996. </year> <month> 12 </month>
Reference-contexts: The translation system requires about 20 instructions per instruction generated. Like DCG the VCODE system is built with tools that process machine specifications. VCODE is currently the target of a high-level language, `C, that is designed to ease the development of programs that rely on dynamic code generation <ref> [PEK96] </ref>. Ramsey and Fernandez have developed the New Jersey Machine Code Toolkit, which translates a specification of a machine's instruction set into C routines that can assemble and disassemble binary images of those instructions. The generated routines can also handle the relocation of addresses within previously assembled instructions.
Reference: [Pit87] <author> T. Pittman. </author> <title> Two-level hybrid interpreter/native code execution for combined space-time program effi-ciency. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 150-152, </pages> <month> June </month> <year> 1987. </year>
Reference: [Pro95a] <author> Todd A. Proebsting. </author> <title> BURS automata generation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3) </volume> <pages> 461-486, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Optimizing code quickly requires making tradeoffs of analysis time against anticipated efficiency gainsa tradeoff that historically has been made in favor of efficiency gains, which may not make sense when analysis time is indistinguishable from run-time. Fortunately, retargetable code-generator generator systems can help here <ref> [Pro95a] </ref>. Code-generator generators can produce optimized code generators for various target architectures from concise machine specifications.
Reference: [Pro95b] <author> Todd A. Proebsting. </author> <title> Optimizing an ANSI C interpreter with superoperators. </title> <booktitle> In Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 322-332, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Interpretation often results in slowdowns of 10-1000fi relative to native execution speeds. Our research indicates that optimizing code-generation techniques can be applied to interpreter generation to consistently get slowdowns of less than 10fi <ref> [Pro95b] </ref>. These efficient interpreters rely on techniques normally applied to compilers. Techniques include the efficient register use, the efficient instruction schedules, and efficient instruction selection. Other efficiency enhancing techniques are more specifically applicable to interpreters.
Reference: [RF95] <author> Norman Ramsey and Mary F. Fernandez. </author> <title> The New Jersey machine-code toolkit. </title> <booktitle> In Proceedings of the 1995 Usenix Winter Conference, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: Fortunately, only a finite number of encodings exist for any instruction set. To ensure that our compiler can encode instructions quickly, we are creating a tool that generates optimized instruction assemblers from concise specifications of instruction set formats. (Non-optimizing tools with the same functionality exist <ref> [RF95] </ref>, but they make no effort to optimize the instruction assembler.) These specifications are being coordinated with the specifications used for instruction selection to enable the instruction selector to directly assemble and emit instructions without any delays from intermediate representations.
Reference: [SE95] <author> Erik Selberg and Oren Etzioni. </author> <title> Multi-service search and comparison using the metacrawler. </title> <booktitle> In Proceedings of the 4th World Wide Web Conference, </booktitle> <pages> pages 195-208, </pages> <year> 1995. </year>
Reference-contexts: Attempts to combine several search engines has been carried out most prominently by the meta-crawler <ref> [SE95] </ref>. Wiederhold [Wie92] (and many others) suggest mediators, which mediate between the users, their data, and their application software. These mediators are assumed to reside in the servers, but they could also be implemented as liquid software.
Reference: [Wie92] <author> G. Wiederhold. </author> <booktitle> Mediators in the architecture of future information systems. IEEE Computer, </booktitle> <pages> pages 38-49, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Attempts to combine several search engines has been carried out most prominently by the meta-crawler [SE95]. Wiederhold <ref> [Wie92] </ref> (and many others) suggest mediators, which mediate between the users, their data, and their application software. These mediators are assumed to reside in the servers, but they could also be implemented as liquid software.
Reference: [WJ95] <author> M. Wooldridge and N. R. Jennings, </author> <title> editors. Intelligent Agents Theories, Architectures, </title> <journal> and Languages, </journal> <volume> volume 890. </volume> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <month> 13 </month>
Reference-contexts: Ertl demonstrated the speed advantages and complexities involved in caching multiple stack elements in registers in a stack-based interpreter [Ert95]. 5.2 Mobile Search The closest area to mobile search is the area of intelligent information agents, which have received a lot of deserved attention lately <ref> [CAC94, WJ95] </ref>. Attempts to combine several search engines has been carried out most prominently by the meta-crawler [SE95]. Wiederhold [Wie92] (and many others) suggest mediators, which mediate between the users, their data, and their application software.
References-found: 24

