URL: http://www.cs.washington.edu:80/homes/pardy/research/papers/WCS/dispatcher.ps.Z
Refering-URL: http://www.cs.washington.edu:80/homes/pardy/research/papers/index.html
Root-URL: http://www.cs.washington.edu
Title: Language and Runtime Support for Dynamic Interposition of System Code  
Author: Przemys law Pardyak Stefan Savage Brian N. Bershad 
Date: November 3, 1995  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: Extensible operating systems require an efficient means to dynamically bind extensions to existing code. The SPIN operating system provides this functionality via an event-based invocation mechanism. Events in SPIN are well-known typed procedure names that are used by extensions to decouple the provider of a service from potential clients. Extensions communicate with a centralized dispatcher service to register their interest in raising or handling such events. To implement this binding, the dispatcher relies on the Modula-3 language and run-time in providing safety and high performance of event operations and it employs run-time code generation techniques to create highly optimized communications paths between raisers and handlers. 
Abstract-found: 1
Intro-found: 1
Reference: [B + 92] <editor> D. L. Black et al. </editor> <booktitle> Microkernel Operating System Architecture and Mach. In Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 11-30, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: The dispatcher is highly integrated with the Modula-3 runtime, which we found essential for providing safety, high performance, flexibility, and a simple representation for events within the Modula-3 language. Previous work has explored safe interposition <ref> [Jon93, Pat93, B + 92, VGA94] </ref>, but the high cost of protecting system code from extension code has generally limited its utility to coarse grain system interfaces, and has rarely been competitive with monolithic implementations.
Reference: [BC94] <author> Arindam Banerji and David L. Cohn. </author> <title> Protected Shared Libraries. </title> <type> Technical Report 37, </type> <institution> University of Notre Dame, </institution> <year> 1994. </year>
Reference-contexts: For example, different extensions may implement different network protocols, but they all must be called from the same network device driver, therefore the decision to execute a particular extension must be a dynamic one, based on the contents of a network packet. Dynamic linking <ref> [OBLM93, BC94] </ref> and method lookup are two mechanisms that facilitate late binding. The first enables code to be installed into a running system, but tightly couples clients to a particular service implementation. By itself, dynamic linking does not provide for the transparent routing of requests to alternate or supplementary services.
Reference: [BSP + 95] <author> Brian N. Bershad, Stefan Savage, Przemyslaw Pardyak, Emin G n Sirer, Marc Fi-uczynski, David Becker, Susan Eggers, and Craig Chambers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <address> Copper Mountain, CO, </address> <month> Decem-ber </month> <year> 1995. </year>
Reference-contexts: 1 Introduction An extensible operating system allows application programs to customize operating system services, thereby improving performance, correctness or simplicity. The SPIN operating system supports extensibility by allowing application code to interpose on kernel interfaces <ref> [BSP + 95] </ref>. These system extensions are directly linked into the kernel address space, and their memory safety is guaranteed by writing them in a type-safe programming language (Modula-3) [Nel91]. Interposition is implemented using an event-based invocation mechanism that centralizes all communication through the SPIN dispatcher service.
Reference: [CEA + 96] <author> C. Chambers, S. Eggers, J. Auslander, M. Philipose, M. Mock, and P. Pardyak. </author> <title> Automatic dynamic compilation support for event dispatching in extensible systems. </title> <booktitle> Submitted to the First Workshop on Compiler Support for Systems Software, </booktitle> <month> November </month> <year> 1996. </year>
Reference-contexts: By eliminating common subexpressions and transforming similar comparisions into hash table lookups we expect to achieve dispatch overhead which is linear with the number of executed rather than potential handlers. Furthermore, we intend to take advantage of on-going research into automatic run-time code generation <ref> [CEA + 96] </ref> to automate our optimizations. 5 Conclusions SPIN's event handling services allow extensions to interact with systems services in a decoupled manner.
Reference: [HP94] <author> J.S. Heidemann and G.J. Popek. </author> <title> File-System Development with Stackable Layers. </title> <journal> Communications of the ACM, </journal> <volume> 12(1) </volume> <pages> 58-89, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: To be effective, this mechanism must be efficient, simple to use, and generally applicable. To be used extensively, the mechanism must also be flexible enough to allow the run-time composition and manipulation of independently written extensions. Common extension schemas, such as stacking <ref> [HP94] </ref> and filtering [MRA87, YBMM94] can only be decomposed if the binding can be transparently routed to multiple extensions.
Reference: [Jon93] <author> Michael B. Jones. </author> <title> Interposition Agents: Transparently Interposing User Code at the System Call. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 80-93, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: The dispatcher is highly integrated with the Modula-3 runtime, which we found essential for providing safety, high performance, flexibility, and a simple representation for events within the Modula-3 language. Previous work has explored safe interposition <ref> [Jon93, Pat93, B + 92, VGA94] </ref>, but the high cost of protecting system code from extension code has generally limited its utility to coarse grain system interfaces, and has rarely been competitive with monolithic implementations. <p> The first enables code to be installed into a running system, but tightly couples clients to a particular service implementation. By itself, dynamic linking does not provide for the transparent routing of requests to alternate or supplementary services. Method lookup, such as Mach's transparent system call emulation facility <ref> [Jon93] </ref>, allows for transparent service interposition, but does not allow multiple modules to service the same request. Using either dynamic linking or method lookup, multiple independent extensions may not provide different parts of a service without explictly cooperating.
Reference: [MRA87] <author> J. Mogul, R. Rashid, and M. Accetta. </author> <title> The Packet Filter: An Efficient Mechanism for User-level Network Code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: To be effective, this mechanism must be efficient, simple to use, and generally applicable. To be used extensively, the mechanism must also be flexible enough to allow the run-time composition and manipulation of independently written extensions. Common extension schemas, such as stacking [HP94] and filtering <ref> [MRA87, YBMM94] </ref> can only be decomposed if the binding can be transparently routed to multiple extensions.
Reference: [Nel91] <author> Greg Nelson, </author> <title> editor. System Programming in Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: The SPIN operating system supports extensibility by allowing application code to interpose on kernel interfaces [BSP + 95]. These system extensions are directly linked into the kernel address space, and their memory safety is guaranteed by writing them in a type-safe programming language (Modula-3) <ref> [Nel91] </ref>. Interposition is implemented using an event-based invocation mechanism that centralizes all communication through the SPIN dispatcher service. The dispatcher allows extensions to dynamically change the body of code executed in response to a service request.
Reference: [OBLM93] <author> Doug Orr, John Bonn, Jay Lepreau, and Robert Mecklenburg. </author> <title> Fast and Flexible Shared Libraries. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: For example, different extensions may implement different network protocols, but they all must be called from the same network device driver, therefore the decision to execute a particular extension must be a dynamic one, based on the contents of a network packet. Dynamic linking <ref> [OBLM93, BC94] </ref> and method lookup are two mechanisms that facilitate late binding. The first enables code to be installed into a running system, but tightly couples clients to a particular service implementation. By itself, dynamic linking does not provide for the transparent routing of requests to alternate or supplementary services.
Reference: [Pat93] <author> Simon Patience. </author> <title> Redirecting Systems Calls in Mach 3.0, An Alternative to the Emulator. </title> <booktitle> In Proceedings of the Third USENIX Mach Symposium, </booktitle> <pages> pages 57-73, </pages> <address> Santa Fe, NM, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: The dispatcher is highly integrated with the Modula-3 runtime, which we found essential for providing safety, high performance, flexibility, and a simple representation for events within the Modula-3 language. Previous work has explored safe interposition <ref> [Jon93, Pat93, B + 92, VGA94] </ref>, but the high cost of protecting system code from extension code has generally limited its utility to coarse grain system interfaces, and has rarely been competitive with monolithic implementations.
Reference: [SFPB96] <author> E.G. Sirer, M. Fiuczynski, P. Pardyak, and B.N. Bershad. </author> <title> Safe Dynamic Linking in an Extensible Operating System. </title> <booktitle> Submitted to the First Workshop on Compiler Support for Systems Software, </booktitle> <month> November </month> <year> 1996. </year>
Reference-contexts: How to control which handlers are allowed to handle a particular instance of an event raise? * Authorization. How to control which module can control static and dynamic acccess con trol? We rely on a safe dynamic linker <ref> [SFPB96] </ref> for static access control of events. This is an issue of event name visibility. An event name is simply a linker symbol. If the extension is not linked against the protected context in which the symbol is defined, then the event is not visible.
Reference: [VGA94] <author> A. Vahdat, P. Ghormley, and T.E. Anderson. </author> <title> Efficient, Portable and Robust Extension of Operating System Functionality. </title> <type> Technical Report UCB CS-94-842, </type> <institution> University of California, Berkeley, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: The dispatcher is highly integrated with the Modula-3 runtime, which we found essential for providing safety, high performance, flexibility, and a simple representation for events within the Modula-3 language. Previous work has explored safe interposition <ref> [Jon93, Pat93, B + 92, VGA94] </ref>, but the high cost of protecting system code from extension code has generally limited its utility to coarse grain system interfaces, and has rarely been competitive with monolithic implementations.
Reference: [YBMM94] <author> Masanobu Yuhara, Brian N. Bershad, Chris Maeda, and J. Eliot B. Moss. </author> <title> Efficient Packet Demultiplexing for Multiple Endpoints and Large Messages. </title> <booktitle> In Proceedings of the 1994 Winter USENIX Conference, </booktitle> <pages> pages 153-165, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1994. </year> <month> 7 </month>
Reference-contexts: To be effective, this mechanism must be efficient, simple to use, and generally applicable. To be used extensively, the mechanism must also be flexible enough to allow the run-time composition and manipulation of independently written extensions. Common extension schemas, such as stacking [HP94] and filtering <ref> [MRA87, YBMM94] </ref> can only be decomposed if the binding can be transparently routed to multiple extensions.
References-found: 13

