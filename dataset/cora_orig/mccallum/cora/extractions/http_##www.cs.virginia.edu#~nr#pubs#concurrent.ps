URL: http://www.cs.virginia.edu/~nr/pubs/concurrent.ps
Refering-URL: http://www.cs.virginia.edu/~nr/pubs/index.html
Root-URL: http://www.cs.virginia.edu
Title: Concurrent programming in ML lines of Standard ML. It uses call with current continuation, callcc,
Author: Norman Ramsey 
Note: The implementation takes only 220  
Date: April 1990  
Address: 35 Olden Street Princeton, New Jersey 08544  
Affiliation: Department of Computer Science, Princeton University  
Abstract: Three features of Standard ML|polymorphism, garbage collection, and modules|work exceptionally well with concurrency. Polymorphic functions that combine the concurrent primitives can be used in many programs. One can write processes that do not explicitly provide for their own termination; the garbage collector reclaims them when they can no longer communicate. Finally, one can use the Standard ML modules system to make small adjustments in the meanings of the primitives. 
Abstract-found: 1
Intro-found: 1
Reference: [AJ89] <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In 16th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: My implementation of the primitives requires 220 lines of Standard ML. It uses call with current continuation (callcc) to simulate concurrent execution on a sequential machine, essentially as described in [Wan80]. callcc can be implemented efficiently because SML-NJ uses no runtime stack <ref> [AJ89] </ref>. This paper shows the implementation of plumbing in terms of the concurrent primitives, and it sketches applications in which I have used the plumbing. It also gives implementations of different semantic changes to the primitives; the new semantics are derived from the old using the ML modules system.
Reference: [App89] <author> Andrew W. Appel. </author> <title> Simple generational garbage collection and fast allocation. </title> <journal> Software|Practice & Experience, </journal> <volume> 19(2) </volume> <pages> 171-183, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: The ML implementation is not perfect; its most annoying defect is that the program appears to halt for a few seconds every time it performs a major garbage collection <ref> [App89] </ref>. 7 Modifying the primitives I have used ML functors to map the primitives described above onto slightly different sets of primitives. I have restricted channels so that messages flow in one direction only; mkchan () then returns a pair: the input and output sides of the channel. <p> sec 34 (16%) 211 sec 1.00 1.00 No queues 151 35 (19%) 186 .85 .87 Unfair sched 142 30 (17%) 172 .80 .82 Unfair & NQ 115 30 (21%) 145 .65 .69 Function call 5 0 5 .03 .02 The large garbage collection overhead comes from updating the reference list <ref> [App89] </ref>. It could be reduced substantially by using virtual memory techniques [Sha87]. The factor of 35 disparity between the costs of communication and function call is consistent with the observation that a send/receive pair requires 27 function calls on average.
Reference: [App90] <author> Andrew W. Appel. </author> <title> A runtime system. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3 </volume> <pages> 343-380, </pages> <year> 1990. </year>
Reference-contexts: The implementation is slow because it is general and it is written entirely in ML. If speed is important, the most useful version of the primitives can be implemented in C (or assembler) and linked with the Standard ML of New Jersey runtime system <ref> [App90] </ref>.
Reference: [AS83] <author> Gregory R. Andrews and Fred B. Schneider. </author> <title> Concepts and notations for concurrent programming. </title> <journal> Computing Surveys, </journal> <volume> 15(1) </volume> <pages> 1-43, </pages> <month> March </month> <year> 1983. </year>
Reference: [Bur88] <author> Alan Burns. </author> <title> Programming in occam 2. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: A channel is reclaimed when no unblocked process can reach it. In Occam 2, programmers must exercise considerable ingenuity to get groups of processes to terminate gracefully <ref> [Bur88] </ref>; in ML, programmers can just let processes block.
Reference: [Hoa78] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: Introduction I have added concurrent primitives to the functional language Standard ML. My model of concurrency is derived from CSP <ref> [Hoa78] </ref>, but processes do not communicate directly; they interact by communicating over channels. Also, processes and channels can be created dynamically. Writing concurrent programs in ML has three advantages. <p> I have mapped my primitives to the primitives used in the Pegasus Meta-Language [Rep88]. Finally, I have added Boolean guards to potential communications, so that select statements can use combinations of Booleans and communications after the manner of CSP <ref> [Hoa78] </ref>. These four modifications are orthogonal; their implementations, which range in size from 6 to 27 lines, are given below. The brevity of these implementations suggests that the primitives shown above have wide applicability.
Reference: [McI90] <author> M. Douglas McIlroy. </author> <title> Squinting at power series. </title> <note> To appear in Software|Practice & Experience, </note> <year> 1990. </year>
Reference-contexts: I have used plumbing in two applications: a simulation of sequential circuits and a multiuser version of a "talk" program. I have also used it to duplicate an implementation of operations on power series <ref> [McI90] </ref>. It is sometimes convenient to make small changes in the semantics of the primitives. <p> I have restricted channels so that it is impossible to send a message until it is asked for; this is an abstraction of McIlroy's demand channels <ref> [McI90] </ref>. I have mapped my primitives to the primitives used in the Pegasus Meta-Language [Rep88]. Finally, I have added Boolean guards to potential communications, so that select statements can use combinations of Booleans and communications after the manner of CSP [Hoa78]. <p> This has been implemented by making each channel a pair, half for requests and half for data <ref> [McI90] </ref>, but I have implemented it more abstractly by providing three basic communication primitives instead of two.
Reference: [Pik89a] <author> Rob Pike. </author> <title> Lectures on the implementation of Newsqueak. </title> <institution> Given at Princeton University, </institution> <month> April </month> <year> 1989. </year>
Reference-contexts: Implementing the primitives Unlike the concurrent primitives in Pegasus and Newsqueak, which are implemented in C++ and C respectively <ref> [Rep88, Pik89a] </ref>, my concurrent primitives are implemented completely in ML. They respect the ML type system and do not have access to the internal representations of data. The simulation of concurrency is as in [Wan80].
Reference: [Pik89b] <author> Rob Pike. Newsqueak: </author> <title> A language for communicating with mice. </title> <type> Technical Report 143, </type> <institution> AT&T Bell Laboratories, Computing Science Dept, </institution> <month> April </month> <year> 1989. </year>
Reference: [Rep88] <author> John H. Reppy. </author> <title> Synchronous operations as first-class values. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 250-259, </pages> <month> June </month> <year> 1988. </year> <month> 13 </month>
Reference-contexts: All communication is synchronous. These primitives are equivalent to those of the Pegasus Meta-Language <ref> [Rep88] </ref> (although developed independently); Below I show how to transform them into the Pegasus primitives. I have implemented two new primitives, wait and WAIT, which wait for input from or output to files to be possible. <p> I have restricted channels so that it is impossible to send a message until it is asked for; this is an abstraction of McIlroy's demand channels [McI90]. I have mapped my primitives to the primitives used in the Pegasus Meta-Language <ref> [Rep88] </ref>. Finally, I have added Boolean guards to potential communications, so that select statements can use combinations of Booleans and communications after the manner of CSP [Hoa78]. These four modifications are orthogonal; their implementations, which range in size from 6 to 27 lines, are given below. <p> The sync primitive is the only primitive with a side effect; sync e "synchronizes with" the event e (similar to actualizing a potential communication) <ref> [Rep88] </ref>. I have used functors to transform my model of concurrency into the Pegasus model. <p> UNIT (in Pegasus, anyevent) is an event that can always be chosen, but does nothing; sync (UNIT) is equivalent to (). I represent events as lists of potential communications (this corresponds to the canonical form of events described in <ref> [Rep88] </ref>). <p> Implementing the primitives Unlike the concurrent primitives in Pegasus and Newsqueak, which are implemented in C++ and C respectively <ref> [Rep88, Pik89a] </ref>, my concurrent primitives are implemented completely in ML. They respect the ML type system and do not have access to the internal representations of data. The simulation of concurrency is as in [Wan80].
Reference: [Rep89] <author> John H. Reppy. </author> <title> First-class synchronous operations in Standard ML. </title> <type> Technical Report TR 89-1068, </type> <institution> Cornell University Department of Computer Science, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: val a = ref 0 fun accum (n:int) = a := !a + n in accum end; In the benchmarks, the functions send (accumulator ()) and faccumulator () were called repeatedly with argument 1. 4 This technique was subsequently used in a re-implementation of the Pegasus concurrency primitives in ML <ref> [Rep89] </ref>. 12 I tested the communicating version with my standard implementation of the primitives and also with implementations I modified for increased speed. The first modification uses restricted channels whose queues hold at most one blocked process.
Reference: [Sha87] <author> Robert A. Shaw. </author> <title> Improving garbage collector performance in virtual memory. </title> <type> Technical Report CSL-TR-87-323, </type> <institution> Stanford University Computer Systems Laboratory, </institution> <month> March </month> <year> 1987. </year>
Reference-contexts: It could be reduced substantially by using virtual memory techniques <ref> [Sha87] </ref>. The factor of 35 disparity between the costs of communication and function call is consistent with the observation that a send/receive pair requires 27 function calls on average.
Reference: [Wan80] <author> Mitchell Wand. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Proceedings of the 1980 LISP Conference, </booktitle> <pages> pages 19-28, </pages> <year> 1980. </year>
Reference-contexts: My implementation of the primitives requires 220 lines of Standard ML. It uses call with current continuation (callcc) to simulate concurrent execution on a sequential machine, essentially as described in <ref> [Wan80] </ref>. callcc can be implemented efficiently because SML-NJ uses no runtime stack [AJ89]. This paper shows the implementation of plumbing in terms of the concurrent primitives, and it sketches applications in which I have used the plumbing. <p> They respect the ML type system and do not have access to the internal representations of data. The simulation of concurrency is as in <ref> [Wan80] </ref>. Functions of type unit -&gt; unit represent processes whose executions are suspended; applying such a function to () resumes the process. Scheduling is non-preemptive; processes run until they attempt to communicate or to spawn a new process, or until they finish. <p> Many programs work unchanged with such channels, and these channels can be changed into general channels using one piece of plumbing. The second modification replaces the nondeterministic scheduler with one that keeps ready processes on a stack; it is unfair but fast (like the one in <ref> [Wan80] </ref>). To find the cost of communication, I measured the amount of user time required to send 10,000 integers on a VAX 8650 running 4.3 BSD Unix, then repeated this measurement several times. Similarly, I called the accumulator function 1,000,000 times.
Reference: [Xil88] <author> Xilinx, Inc. </author> <title> The Programmable Gate Array Data Book, </title> <booktitle> 1988. </booktitle> <pages> 14 </pages>
Reference-contexts: begin combine ([a1,b1,carry1],sum, fn [a,b,c]=&gt;xor (a,xor (b,c))); combine ([a2,b2,carry2],carryout, fn [a,b,c]=&gt;(a andalso b) orelse (b andalso c) orelse (c andalso a)) end I have used latch and combine to write, in about 70 lines, a simulation of a Configurable Logic Block, the basic unit of the Xilinx programmable gate array <ref> [Xil88] </ref>. This simulation could be used to test and debug a circuit configuration before downloading it to the gate array. Conference talk Two people can use the Unix talk program to converse using the computer.
References-found: 14

