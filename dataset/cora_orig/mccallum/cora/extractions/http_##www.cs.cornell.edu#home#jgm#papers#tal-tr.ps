URL: http://www.cs.cornell.edu/home/jgm/papers/tal-tr.ps
Refering-URL: http://www.cs.cornell.edu/home/jgm/papers.html
Root-URL: 
Title: From System F to Typed Assembly Language (Extended Version)  
Author: Greg Morrisett David Walker Karl Crary Neal Glew 
Date: November 21, 1997  
Affiliation: Cornell University  
Abstract: We motivate the design of a statically typed assembly language (TAL) and present a type-preserving translation from System F to TAL. The TAL we present is based on a conventional RISC assembly language, but its static type system provides support for enforcing high-level language abstractions, such as closures, tuples, and objects, as well as user-defined abstract data types. The type system ensures that well-typed programs cannot violate these abstractions. In addition, the typing constructs place almost no restrictions on low-level optimizations such as register allocation, instruction selection, or instruction scheduling. Our translation to TAL is specified as a sequence of type-preserving transformations, including CPS and closure conversion phases; type-correct source programs are mapped to type-correct assembly language. A key contribution is an approach to polymorphic closure conversion that is considerably simpler than previous work. The compiler and typed assembly language provide a fully automatic way to produce proof carrying code, suitable for use in systems where untrusted and potentially malicious code must be checked for safety before execution.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Shail Aditya, Christine Flood, and James Hicks. </author> <title> Garbage collection for strongly-typed languages using run-time type reconstruction. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 12-23, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: This avoids the need for abstract kinds (since there are no type environments), as well as translucent types. A type-erasure interpretation is not without its costs: It precludes some advanced implementation techniques <ref> [31, 43, 1, 30] </ref> and has subtle interactions with side-effects. We address the latter concern by forcing polymorphic abstractions to be values [42, 49] (i.e., they must be syntactically attached to value abstractions). To support this interpretation, we consider the partial application of functions to type arguments to be values. <p> 1 i is created as follows (where types have been added for clarity): let x 0 :hint 0 ; int 0 i = malloc [int; int] x 1 :hint 1 ; int 0 i = x 0 [0] v 0 x :hint 1 ; int 1 i = x 1 <ref> [1] </ref> v 1 . . . The "x 0 = malloc [int; int]" step allocates an uninitialized tuple and binds the address (i.e., label) of the tuple to x 0 . <p> Note that x 1 is assigned a type where the first field has a "1" superscript, indicating that this field is initialized. Finally, the "x = x 1 <ref> [1] </ref> v 1 " step initializes the second field of the tuple with v 1 and binds the address of the tuple to x, which is assigned the fully initialized type hint 1 ; int 1 i. Hence, both 0 and 1 are allowed on x. <p> : ht 1 ; : : : ; t n i alloc ; y n ; ( ~ d 1 ; : : : ; ~ d n ; y 0 = malloc [A [[t 1 ]]; : : : ; A [[t n ]]]; y 1 = y 0 <ref> [1] </ref> v 0 . . . n ) ` H ; ; ` H v : 8 [ff; ~ fi](~t) ! void alloc ; v 0 ; ~ d ; ; ` H v [] : 8 [ ~ fi](~t [=ff]) ! void ; v 0 [A [[]]]; ~ d ` <p> in if0 (n; let [fi; k unpack ] = unpack k k code = 0 (k unpack ) k env = 1 (k unpack ) in k code (k env ; 1); let x = n 1 y 5 = malloc [int; t k ] y 6 = y 5 <ref> [1] </ref> n y 8 = malloc [(hint 1 ; t 1 k i; int) ! void ; hint 1 ; t 1 k i; ] y 9 = y 8 [1] ` cont y 10 = y 9 [2] y 7 in ` fact (env; x; pack [hint 1 ; t <p> ; 1); let x = n 1 y 5 = malloc [int; t k ] y 6 = y 5 <ref> [1] </ref> n y 8 = malloc [(hint 1 ; t 1 k i; int) ! void ; hint 1 ; t 1 k i; ] y 9 = y 8 [1] ` cont y 10 = y 9 [2] y 7 in ` fact (env; x; pack [hint 1 ; t 1 k i; y 10 ] as t k )) ` cont 7! code [ ](env:hint 1 ; t 1 k i; y:int): k = 1 (env) [fi; k unpack <p> (k unpack ) in k code (k env ; z) ` halt 7! code [ ](env:hi; n:int): let in halt [int](n) in let y 0 = malloc [ ] y 1 = malloc [ ] y 2 = malloc [(hi; int) ! void ; hi] y 3 = y 2 <ref> [1] </ref> ` halt y 4 = y 3 [2] y 1 in ` fact (y 0 ; 6; pack [hi; y 4 ] as t k ) where t k is 9ff:h (ff; int) ! void 1 ; ff 1 i 21 types t ::= ff j int j 8 [~ff]: <p> of these type correctness lemmas is the type correctness of the entire compiler: 30 (H; fg; S) where H = l fact: code [ ]fr1:hi,r2:int,r3:t k g. bnz r2,l nonzero unpack [ff,r3],r3 % zero branch: call k (in r3) with 1 ld r4,r3 [0] % project k code ld r1,r3 <ref> [1] </ref> % project k environment mov r2,1 jmp r4 % jump with fr1 = env; r2 = 1g l nonzero: code [ ]fr1:hi,r2:int,r3:t k g: sub r4,r2,1 % n 1 malloc r5 [int; t k ] % create environment for cont in r5 st r5 [0],r2 % store n into environment <p> k % abstract the type of the environment jmp l f % jump to k with fr1 = env; r2 = n 1; r3 = contg l cont: code [ ]fr1:hint 1 ; t 1 k i;r2:intg: % r2 contains (n 1)! ld r3,r1 [0] % retrieve n ld r4,r1 <ref> [1] </ref> % retrieve k mul r2,r3,r2 % n fi (n 1)! unpack [ff,r4],r4 % unpack k ld r3,r4 [0] % project k code ld r1,r4 [1] % project k environment jmp r3 % jump to k with fr1 = env; r2 = n!g l halt: code [ ]fr1:hi;r2:intg. mov r1,r2 halt <p> contg l cont: code [ ]fr1:hint 1 ; t 1 k i;r2:intg: % r2 contains (n 1)! ld r3,r1 [0] % retrieve n ld r4,r1 <ref> [1] </ref> % retrieve k mul r2,r3,r2 % n fi (n 1)! unpack [ff,r4],r4 % unpack k ld r3,r4 [0] % project k code ld r1,r4 [1] % project k environment jmp r3 % jump to k with fr1 = env; r2 = n!g l halt: code [ ]fr1:hi;r2:intg. mov r1,r2 halt [int] % halt with result in r1 and S = malloc r1 [ ] % create an empty environment (hi) malloc r2 [ ] %
Reference: [2] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: 5 = malloc [int; t k ] y 6 = y 5 [1] n y 8 = malloc [(hint 1 ; t 1 k i; int) ! void ; hint 1 ; t 1 k i; ] y 9 = y 8 [1] ` cont y 10 = y 9 <ref> [2] </ref> y 7 in ` fact (env; x; pack [hint 1 ; t 1 k i; y 10 ] as t k )) ` cont 7! code [ ](env:hint 1 ; t 1 k i; y:int): k = 1 (env) [fi; k unpack ] = unpack k k code = 0 <p> ; z) ` halt 7! code [ ](env:hi; n:int): let in halt [int](n) in let y 0 = malloc [ ] y 1 = malloc [ ] y 2 = malloc [(hi; int) ! void ; hi] y 3 = y 2 [1] ` halt y 4 = y 3 <ref> [2] </ref> y 1 in ` fact (y 0 ; 6; pack [hi; y 4 ] as t k ) where t k is 9ff:h (ff; int) ! void 1 ; ff 1 i 21 types t ::= ff j int j 8 [~ff]: j ht ' 1 n i j 9ff:t <p> Each of these may be implemented as a type-preserving transformation on TAL code using well-known techniques <ref> [2] </ref>. 6.5 TAL Factorial The factorial computation translated into TAL appears in Figure 26. To obtain the code shown, a few standard optimizations were applied; in particular, a clever (but automatable) register allocation and the removal of redundant moves.
Reference: [3] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Compiling a source language to a statically typed intermediate language has compelling advantages over a conventional untyped compiler. An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion <ref> [15, 35, 3, 13, 19] </ref>, closure conversion [21, 40, 20, 4, 27], unboxing [23, 31, 39], subsumption elimination [10, 12], or region inference [8]. <p> This allows the compiler to aggressively optimize code between any of the translation steps. The inspiration for the phases and their ordering is derived from SML/NJ <ref> [5, 3] </ref> (which is in turn based on the Rabbit [40] and Orbit compilers [20]) except that types are used throughout compilation. The rest of this paper proceeds by describing each of the languages and translations in our compiler in full detail.
Reference: [4] <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <address> Austin, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [15, 35, 3, 13, 19], closure conversion <ref> [21, 40, 20, 4, 27] </ref>, unboxing [23, 31, 39], subsumption elimination [10, 12], or region inference [8]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37].
Reference: [5] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In Martin Wirsing, editor, </editor> <booktitle> Third International Symposium on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <title> Springer-Verlag. </title> <booktitle> Volume 528 of Lecture Notes in Computer Science. </booktitle>
Reference-contexts: This allows the compiler to aggressively optimize code between any of the translation steps. The inspiration for the phases and their ordering is derived from SML/NJ <ref> [5, 3] </ref> (which is in turn based on the Rabbit [40] and Orbit compilers [20]) except that types are used throughout compilation. The rest of this paper proceeds by describing each of the languages and translations in our compiler in full detail.
Reference: [6] <author> Brain Bershad, Stefan Savage, Przemyslaw Pardyak, Emin Sirer, Marc Fiuczynski, David Becker, Craig Chambers, and Susan Eggers. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 267-284, </pages> <address> Copper Mountain, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: TAL not only allows us to reap the benefits of types throughout a compiler, but it also enables a practical system for executing untrusted code both safely and efficiently. For example, as suggested by the SPIN project <ref> [6] </ref>, operating systems could allow users to download TAL extensions into the kernel.
Reference: [7] <author> Lars Birkedal, Nick Rothwell, Mads Tofte, and David N. Turner. </author> <title> The ML Kit (version 1). </title> <type> Technical Report 93/14, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <year> 1993. </year>
Reference-contexts: Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 29]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [23, 34, 7, 41, 25, 38, 14] </ref>. However, in all of these compilers, there is a fl This material is based on work supported in part by AFOSR grant F49620-97-1-0013, ARPA/RADC grant FC30602-96-1-0317, NSF grant CCR-9244739, and ONR grant N00014-92-J-1764.
Reference: [8] <author> Lars Birkedal, Mads Tofte, and Magnus Vejlstrup. </author> <title> From region inference to von Neumann machines via region representation inference. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 171-183, </pages> <address> St. Petersburg, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [15, 35, 3, 13, 19], closure conversion [21, 40, 20, 4, 27], unboxing [23, 31, 39], subsumption elimination [10, 12], or region inference <ref> [8] </ref>. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37].
Reference: [9] <author> Hans J. Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: It is straightforward to link our TAL to a conservative garbage collector <ref> [9] </ref> in order to reclaim unused heap values. Support for an accurate collector would require introducing tags so that we may distinguish pointers from integers, or else require a type-passing interpretation [43, 30].
Reference: [10] <author> Val Breazu-Tannen, Thierry Coquand, Carl A. Gunter, and Andre Scedrov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [15, 35, 3, 13, 19], closure conversion [21, 40, 20, 4, 27], unboxing [23, 31, 39], subsumption elimination <ref> [10, 12] </ref>, or region inference [8]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37].
Reference: [11] <author> Karl Crary. </author> <title> KML Reference Manual. </title> <institution> Department of Computer Science, Cornell University, </institution> <year> 1996. </year>
Reference-contexts: To substantiate this claim, we are constructing a compiler called TALC that maps the KML programming language <ref> [11] </ref> to a variant of the TAL described here, suitably adapted for the Intel x86 family of processors. We have found it straightforward to enrich the target language type system to include support for other type constructors, such as references, higher-order constructors, and recursive types.
Reference: [12] <author> Karl Crary. </author> <title> Foundations for the implementation of higher-order subtyping. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 125-135, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [15, 35, 3, 13, 19], closure conversion [21, 40, 20, 4, 27], unboxing [23, 31, 39], subsumption elimination <ref> [10, 12] </ref>, or region inference [8]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37].
Reference: [13] <author> Olivier Danvy and Andrzej Filinski. </author> <title> Representing control: a study of the CPS transformation. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 361-391, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Compiling a source language to a statically typed intermediate language has compelling advantages over a conventional untyped compiler. An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion <ref> [15, 35, 3, 13, 19] </ref>, closure conversion [21, 40, 20, 4, 27], unboxing [23, 31, 39], subsumption elimination [10, 12], or region inference [8]. <p> Section 2 presents F , the compiler's source language. Section 3 presents the first intermediate language, K , and gives a typed CPS translation to it based on Danvy and Filinski <ref> [13] </ref> and Harper and Lillibridge [19]. Section 4 presents the next intermediate language, C , and gives a typed closure translation based on, but considerably simpler than, the presentation of Minamide, Morrisett, and Harper [27]. <p> Aside from these issues, the static semantics for K is completely standard and appears in Figure 2. 3.1 Translating F to K The implementation of CPS-conversion follows Danvy and Filinski <ref> [13] </ref> and Harper and Lillib-ridge [19]. Danvy and Filinski give a CPS translation with a two-level type system that distinguishes between static (or "administrative") fi-redices and dynamic ones.
Reference: [14] <author> Allyn Dimock, Robert Muller, Franklyn Turbak, and J. B. Wells. </author> <title> Strongly typed flow-directed reprsentation transformations. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 85-98, </pages> <address> Ams-terdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 29]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [23, 34, 7, 41, 25, 38, 14] </ref>. However, in all of these compilers, there is a fl This material is based on work supported in part by AFOSR grant F49620-97-1-0013, ARPA/RADC grant FC30602-96-1-0317, NSF grant CCR-9244739, and ONR grant N00014-92-J-1764.
Reference: [15] <author> M. J. Fischer. </author> <title> Lambda calculus schemata. </title> <booktitle> In Proceedings of the ACM Conference on Proving Assertions about Programs, </booktitle> <pages> pages 104-109, </pages> <year> 1972. </year>
Reference-contexts: 1 Introduction Compiling a source language to a statically typed intermediate language has compelling advantages over a conventional untyped compiler. An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion <ref> [15, 35, 3, 13, 19] </ref>, closure conversion [21, 40, 20, 4, 27], unboxing [23, 31, 39], subsumption elimination [10, 12], or region inference [8]. <p> They use this in a one-pass translation that produces an efficient CPS value and prove the resulting value fi-equivalent to a standard CPS translation (as given by Fischer and Plotkin <ref> [15, 35] </ref>) They also show how to modify their translation so that it is "properly tail-recursive" (i.e., so that the unnecessary -expansions of tail-recursive functions are eliminated). Our translation uses both the two-level system and the tail-recursion optimizations.
Reference: [16] <author> Jean-Yves Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination de coupures dans l'analyse et la theorie des types. </title> <editor> In J. E. Fenstad, editor, </editor> <booktitle> Proceedings of the Second Scandinavian Logic Symposium, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland Publishing Co., </publisher> <year> 1971. </year>
Reference-contexts: In Section 7 we show the type correctness of the compiler and in Section 8 we discuss extensions to TAL to support language constructs not considered here. 2 System F The source language for our compiler, F , is a call-by-value variant of System F <ref> [16, 17, 36] </ref> (the polymorphic -calculus) augmented with products and recursion on terms.
Reference: [17] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: In Section 7 we show the type correctness of the compiler and in Section 8 we discuss extensions to TAL to support language constructs not considered here. 2 System F The source language for our compiler, F , is a call-by-value variant of System F <ref> [16, 17, 36] </ref> (the polymorphic -calculus) augmented with products and recursion on terms.
Reference: [18] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: Consequently, the initialization flags do not prevent a field from being 16 initialized twice. It is possible to use monads [44, 22] or linear types <ref> [18, 45, 46] </ref> to ensure that a tuple is initialized exactly once, but we have avoided these approaches in the interest of a simpler type system. The static semantics for A are given in Figure 14. Figure 15 presents the type translation from H to A .
Reference: [19] <author> Robert Harper and Mark Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 206-219, </pages> <address> Charleston, </address> <month> January </month> <year> 1993. </year> <month> 33 </month>
Reference-contexts: 1 Introduction Compiling a source language to a statically typed intermediate language has compelling advantages over a conventional untyped compiler. An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion <ref> [15, 35, 3, 13, 19] </ref>, closure conversion [21, 40, 20, 4, 27], unboxing [23, 31, 39], subsumption elimination [10, 12], or region inference [8]. <p> Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline <ref> [23, 19, 31, 37] </ref>. Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 29]. <p> Section 2 presents F , the compiler's source language. Section 3 presents the first intermediate language, K , and gives a typed CPS translation to it based on Danvy and Filinski [13] and Harper and Lillibridge <ref> [19] </ref>. Section 4 presents the next intermediate language, C , and gives a typed closure translation based on, but considerably simpler than, the presentation of Minamide, Morrisett, and Harper [27]. Section 5 presents the A intermediate language and a translation that makes allocation and initialization of data structures explicit. <p> Aside from these issues, the static semantics for K is completely standard and appears in Figure 2. 3.1 Translating F to K The implementation of CPS-conversion follows Danvy and Filinski [13] and Harper and Lillib-ridge <ref> [19] </ref>. Danvy and Filinski give a CPS translation with a two-level type system that distinguishes between static (or "administrative") fi-redices and dynamic ones.
Reference: [20] <author> David Kranz, R. Kelsey, J. Rees, P. R. Hudak, J. Philbin, and N. Adams. </author> <title> ORBIT: An optimizing compiler for Scheme. </title> <booktitle> In Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 219-233, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [15, 35, 3, 13, 19], closure conversion <ref> [21, 40, 20, 4, 27] </ref>, unboxing [23, 31, 39], subsumption elimination [10, 12], or region inference [8]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37]. <p> This allows the compiler to aggressively optimize code between any of the translation steps. The inspiration for the phases and their ordering is derived from SML/NJ [5, 3] (which is in turn based on the Rabbit [40] and Orbit compilers <ref> [20] </ref>) except that types are used throughout compilation. The rest of this paper proceeds by describing each of the languages and translations in our compiler in full detail. We give the syntax and static semantics of each language as well as type-directed and type-preserving translations between them.
Reference: [21] <author> P. J. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer J., </journal> <volume> 6(4) </volume> <pages> 308-20, </pages> <year> 1964. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [15, 35, 3, 13, 19], closure conversion <ref> [21, 40, 20, 4, 27] </ref>, unboxing [23, 31, 39], subsumption elimination [10, 12], or region inference [8]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37].
Reference: [22] <author> John Launchbury and Simon L. Peyton Jones. </author> <title> State in Haskell. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 293-341, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Consequently, the initialization flags do not prevent a field from being 16 initialized twice. It is possible to use monads <ref> [44, 22] </ref> or linear types [18, 45, 46] to ensure that a tuple is initialized exactly once, but we have avoided these approaches in the interest of a simpler type system. The static semantics for A are given in Figure 14.
Reference: [23] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 177-188, </pages> <address> Albuquerque, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [15, 35, 3, 13, 19], closure conversion [21, 40, 20, 4, 27], unboxing <ref> [23, 31, 39] </ref>, subsumption elimination [10, 12], or region inference [8]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37]. <p> Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline <ref> [23, 19, 31, 37] </ref>. Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 29]. <p> Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 29]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [23, 34, 7, 41, 25, 38, 14] </ref>. However, in all of these compilers, there is a fl This material is based on work supported in part by AFOSR grant F49620-97-1-0013, ARPA/RADC grant FC30602-96-1-0317, NSF grant CCR-9244739, and ONR grant N00014-92-J-1764.
Reference: [24] <author> Xavier Leroy. </author> <title> The effectiveness of type-based unboxing. </title> <booktitle> In Workshop on Types in Compilation, </booktitle> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year> <institution> ACM SIGPLAN. Published as Boston College Computer Science Dept. </institution> <note> Technical Report BCCS-97-03. </note>
Reference-contexts: Finally, since we chose a type-erasure interpretation of polymorphism, adding floats to the language requires a boxing translation. However, recent work by Leroy <ref> [24] </ref> suggests that it is only important to unbox floats in arrays and within compilation units, which is easily done in our framework. 9 Summary We have given a compiler from System F to a statically typed assembly language.
Reference: [25] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 29]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [23, 34, 7, 41, 25, 38, 14] </ref>. However, in all of these compilers, there is a fl This material is based on work supported in part by AFOSR grant F49620-97-1-0013, ARPA/RADC grant FC30602-96-1-0317, NSF grant CCR-9244739, and ONR grant N00014-92-J-1764.
Reference: [26] <author> Robin Milner, Mads Tofte, Robert Harper, and Dave MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: Instead, a closure is constructed that consists of closed code, a value environment mapping variables to values, and a type environment mapping type variables to types. In our approach, we assume a type-erasure interpretation of polymorphism as in The Definition of Standard ML <ref> [26] </ref>, and polymorphic instantiation is semantically handled via substitution (i.e., making a copy of the code with the types substituted for the type variables). As types will ultimately be erased from terms for execution, the "copies" can (and will) be represented by the same term.
Reference: [27] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 271-283, </pages> <address> St. Petersburg, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [15, 35, 3, 13, 19], closure conversion <ref> [21, 40, 20, 4, 27] </ref>, unboxing [23, 31, 39], subsumption elimination [10, 12], or region inference [8]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37]. <p> Section 4 presents the next intermediate language, C , and gives a typed closure translation based on, but considerably simpler than, the presentation of Minamide, Morrisett, and Harper <ref> [27] </ref>. Section 5 presents the A intermediate language and a translation that makes allocation and initialization of data structures explicit. At this point in compilation, the intermediate code is essentially in a -calculus syntax for assembly language, following the ideas of Wand [48]. <p> We begin with closure conversion proper; the hoisting step is considered in Section 4.1. Our approach to typed closure conversion is based on that of Minamide et al. <ref> [27] </ref>: If two functions with the same type but different free variables (and therefore different environment types) were naively closure converted, the types of their closures would not be the same. To prevent this, closures are given existential types [28] where the type of the environment is held abstract.
Reference: [28] <author> John C. Mitchell and Gordon D. Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Progam-ming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: To prevent this, closures are given existential types <ref> [28] </ref> where the type of the environment is held abstract. However, we propose an approach to polymorphic closure conversion that is considerably simpler than that of Minamide et al. which requires both abstract kinds and translucent types.
Reference: [29] <author> G. Morrisett, D. Tarditi, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> The TIL/ML compiler: Performance and safety through types. </title> <booktitle> In Workshop on Compiler Support for Systems Software, </booktitle> <address> Tucson, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37]. Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations <ref> [41, 29] </ref>. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits [23, 34, 7, 41, 25, 38, 14].
Reference: [30] <author> Greg Morrisett and Robert Harper. </author> <title> Semantics of memory management for polymorphic languages. </title> <editor> In A.D. Gordon and A.M. Pitts, editors, </editor> <title> Higher Order Operational Techniques in Semantics, </title> <publisher> Publications of the Newton Institute. Cambridge University Press, </publisher> <year> 1997. </year>
Reference-contexts: This avoids the need for abstract kinds (since there are no type environments), as well as translucent types. A type-erasure interpretation is not without its costs: It precludes some advanced implementation techniques <ref> [31, 43, 1, 30] </ref> and has subtle interactions with side-effects. We address the latter concern by forcing polymorphic abstractions to be values [42, 49] (i.e., they must be syntactically attached to value abstractions). To support this interpretation, we consider the partial application of functions to type arguments to be values. <p> It is straightforward to link our TAL to a conservative garbage collector [9] in order to reclaim unused heap values. Support for an accurate collector would require introducing tags so that we may distinguish pointers from integers, or else require a type-passing interpretation <ref> [43, 30] </ref>. The tagging approach is readily accomplished in our framework. 6.3 TAL Static Semantics The static semantics for TAL appears in Figures 21 and 22 and consists of thirteen judgments, summarized in Figure 20 and elaborated briefly below. <p> The static semantics is inspired by and follows the conventions of Morrisett and Harper's !8 gc <ref> [30] </ref>.
Reference: [31] <author> Gregory Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year> <note> Published as CMU Technical Report CMU-CS-95-226. </note>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [15, 35, 3, 13, 19], closure conversion [21, 40, 20, 4, 27], unboxing <ref> [23, 31, 39] </ref>, subsumption elimination [10, 12], or region inference [8]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37]. <p> Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline <ref> [23, 19, 31, 37] </ref>. Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 29]. <p> This avoids the need for abstract kinds (since there are no type environments), as well as translucent types. A type-erasure interpretation is not without its costs: It precludes some advanced implementation techniques <ref> [31, 43, 1, 30] </ref> and has subtle interactions with side-effects. We address the latter concern by forcing polymorphic abstractions to be values [42, 49] (i.e., they must be syntactically attached to value abstractions). To support this interpretation, we consider the partial application of functions to type arguments to be values.
Reference: [32] <author> George Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Twenty-Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 106-119, </pages> <address> Paris, </address> <year> 1997. </year>
Reference-contexts: In contrast, TAL does not have the overhead of the additional sandboxing code, as typechecking is performed o*ine. With regard to these security properties, TAL is an instance of Necula and Lee's proof carrying code (PCC) <ref> [33, 32] </ref>. Necula suggests that the relevant operational content of simple type systems may be encoded using extensions to first-order predicate logic, and proofs of relevant security properties such as memory safety may be automatically verified [32]. <p> Necula suggests that the relevant operational content of simple type systems may be encoded using extensions to first-order predicate logic, and proofs of relevant security properties such as memory safety may be automatically verified <ref> [32] </ref>. In addition, Necula's approach places no restrictions on code sequences or instruction scheduling, whereas TAL has a small number of such restrictions (see Section 6.2). However, in general there is no complete algorithm for constructing the proof that the code satisfies the desired security properties.
Reference: [33] <author> George Necula and Peter Lee. </author> <title> Safe kernel extensions without run-time checking. </title> <booktitle> In Proceedings of Operating System Design and Implementation, </booktitle> <pages> pages 229-243, </pages> <address> Seattle, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: In contrast, TAL does not have the overhead of the additional sandboxing code, as typechecking is performed o*ine. With regard to these security properties, TAL is an instance of Necula and Lee's proof carrying code (PCC) <ref> [33, 32] </ref>. Necula suggests that the relevant operational content of simple type systems may be encoded using extensions to first-order predicate logic, and proofs of relevant security properties such as memory safety may be automatically verified [32].
Reference: [34] <author> Simon L. Peyton Jones, Cordelia V. Hall, Kevin Hammond, Will Partain, and Philip Wadler. </author> <title> The Glasgow Haskell compiler: a technical overview. </title> <booktitle> In Proc. UK Joint Framework for Information Technology (JFIT) Technical Conference, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 29]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [23, 34, 7, 41, 25, 38, 14] </ref>. However, in all of these compilers, there is a fl This material is based on work supported in part by AFOSR grant F49620-97-1-0013, ARPA/RADC grant FC30602-96-1-0317, NSF grant CCR-9244739, and ONR grant N00014-92-J-1764.
Reference: [35] <author> G. D. Plotkin. </author> <title> Call-by-name, call-by-value, and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: 1 Introduction Compiling a source language to a statically typed intermediate language has compelling advantages over a conventional untyped compiler. An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion <ref> [15, 35, 3, 13, 19] </ref>, closure conversion [21, 40, 20, 4, 27], unboxing [23, 31, 39], subsumption elimination [10, 12], or region inference [8]. <p> They use this in a one-pass translation that produces an efficient CPS value and prove the resulting value fi-equivalent to a standard CPS translation (as given by Fischer and Plotkin <ref> [15, 35] </ref>) They also show how to modify their translation so that it is "properly tail-recursive" (i.e., so that the unnecessary -expansions of tail-recursive functions are eliminated). Our translation uses both the two-level system and the tail-recursion optimizations.
Reference: [36] <author> John C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Programming Symposium, volume 19 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-425, </pages> <address> New York, </address> <year> 1974. </year>
Reference-contexts: In Section 7 we show the type correctness of the compiler and in Section 8 we discuss extensions to TAL to support language constructs not considered here. 2 System F The source language for our compiler, F , is a call-by-value variant of System F <ref> [16, 17, 36] </ref> (the polymorphic -calculus) augmented with products and recursion on terms.
Reference: [37] <author> Erik Ruf. </author> <title> Partitioning dataflow analyses using types. </title> <booktitle> In Twenty-Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 15-26, </pages> <address> Paris, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline <ref> [23, 19, 31, 37] </ref>. Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 29].
Reference: [38] <author> Z. Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Workshop on Types in Compilation, </booktitle> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year> <institution> ACM SIGPLAN. Published as Boston College Computer Science Dept. </institution> <note> Technical Report BCCS-97-03. </note>
Reference-contexts: Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 29]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [23, 34, 7, 41, 25, 38, 14] </ref>. However, in all of these compilers, there is a fl This material is based on work supported in part by AFOSR grant F49620-97-1-0013, ARPA/RADC grant FC30602-96-1-0317, NSF grant CCR-9244739, and ONR grant N00014-92-J-1764.
Reference: [39] <author> Zhong Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 85-98, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [15, 35, 3, 13, 19], closure conversion [21, 40, 20, 4, 27], unboxing <ref> [23, 31, 39] </ref>, subsumption elimination [10, 12], or region inference [8]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37].
Reference: [40] <author> Guy L. Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1978. </year>
Reference-contexts: An optimizing compiler for a high-level language such as ML may make as many as 20 passes over a single program, performing sophisticated analyses and transformations such as CPS conversion [15, 35, 3, 13, 19], closure conversion <ref> [21, 40, 20, 4, 27] </ref>, unboxing [23, 31, 39], subsumption elimination [10, 12], or region inference [8]. Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37]. <p> This allows the compiler to aggressively optimize code between any of the translation steps. The inspiration for the phases and their ordering is derived from SML/NJ [5, 3] (which is in turn based on the Rabbit <ref> [40] </ref> and Orbit compilers [20]) except that types are used throughout compilation. The rest of this paper proceeds by describing each of the languages and translations in our compiler in full detail.
Reference: [41] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181-192, </pages> <address> Philadelphia, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Many of these optimizations require type information in order to succeed, and even those that do not often benefit from the additional structure supplied by a typing discipline [23, 19, 31, 37]. Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations <ref> [41, 29] </ref>. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits [23, 34, 7, 41, 25, 38, 14]. <p> Furthermore, the ability to typecheck intermediate code provides an invaluable tool for debugging new transformations and optimizations [41, 29]. Today a small number of compilers work with typed intermediate languages in order to realize some or all of these benefits <ref> [23, 34, 7, 41, 25, 38, 14] </ref>. However, in all of these compilers, there is a fl This material is based on work supported in part by AFOSR grant F49620-97-1-0013, ARPA/RADC grant FC30602-96-1-0317, NSF grant CCR-9244739, and ONR grant N00014-92-J-1764.
Reference: [42] <author> Mads Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: A type-erasure interpretation is not without its costs: It precludes some advanced implementation techniques [31, 43, 1, 30] and has subtle interactions with side-effects. We address the latter concern by forcing polymorphic abstractions to be values <ref> [42, 49] </ref> (i.e., they must be syntactically attached to value abstractions). To support this interpretation, we consider the partial application of functions to type arguments to be values.
Reference: [43] <author> Andrew Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> Orlando, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: This avoids the need for abstract kinds (since there are no type environments), as well as translucent types. A type-erasure interpretation is not without its costs: It precludes some advanced implementation techniques <ref> [31, 43, 1, 30] </ref> and has subtle interactions with side-effects. We address the latter concern by forcing polymorphic abstractions to be values [42, 49] (i.e., they must be syntactically attached to value abstractions). To support this interpretation, we consider the partial application of functions to type arguments to be values. <p> It is straightforward to link our TAL to a conservative garbage collector [9] in order to reclaim unused heap values. Support for an accurate collector would require introducing tags so that we may distinguish pointers from integers, or else require a type-passing interpretation <ref> [43, 30] </ref>. The tagging approach is readily accomplished in our framework. 6.3 TAL Static Semantics The static semantics for TAL appears in Figures 21 and 22 and consists of thirteen judgments, summarized in Figure 20 and elaborated briefly below.
Reference: [44] <author> Philip Wadler. </author> <title> Comprehending monads. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 61-78, </pages> <address> Nice, </address> <month> June </month> <year> 1990. </year> <month> 34 </month>
Reference-contexts: Consequently, the initialization flags do not prevent a field from being 16 initialized twice. It is possible to use monads <ref> [44, 22] </ref> or linear types [18, 45, 46] to ensure that a tuple is initialized exactly once, but we have avoided these approaches in the interest of a simpler type system. The static semantics for A are given in Figure 14.
Reference: [45] <author> Philip Wadler. </author> <title> Linear types can change the world! In M. </title> <editor> Broy and C. Jones, editors, </editor> <booktitle> Programming Concepts and Methods, Sea of Galilee, </booktitle> <address> Israel, </address> <month> April </month> <year> 1990. </year> <title> North Holland. </title> <booktitle> IFIP TC 2 Working Conference. </booktitle>
Reference-contexts: Consequently, the initialization flags do not prevent a field from being 16 initialized twice. It is possible to use monads [44, 22] or linear types <ref> [18, 45, 46] </ref> to ensure that a tuple is initialized exactly once, but we have avoided these approaches in the interest of a simpler type system. The static semantics for A are given in Figure 14. Figure 15 presents the type translation from H to A .
Reference: [46] <author> Philip Wadler. </author> <title> A taste of linear logic. </title> <booktitle> In Mathematical Foundations of Computer Science, volume 711 of LNCS, </booktitle> <address> Gdansk, Poland, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: Consequently, the initialization flags do not prevent a field from being 16 initialized twice. It is possible to use monads [44, 22] or linear types <ref> [18, 45, 46] </ref> to ensure that a tuple is initialized exactly once, but we have avoided these approaches in the interest of a simpler type system. The static semantics for A are given in Figure 14. Figure 15 presents the type translation from H to A .
Reference: [47] <author> Robert Wahbe, Steven Lucco, Thomas Anderson, and Susan Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <address> Asheville, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Furthermore, critical inner-loops could be hand-written in assembly language in order to achieve optimal performance. TAL could also be used to support extensible web-browsers, extensible servers, active networks, or any other "kernel" where security, performance, and language independence are desired. Software Fault Isolation (SFI) <ref> [47] </ref> also provides memory safety and language independence. However, SFI requires the insertion of extra "sandboxing" code, corresponding to dynamic type tests, to ensure that the extension is safe. In contrast, TAL does not have the overhead of the additional sandboxing code, as typechecking is performed o*ine.
Reference: [48] <author> Mitchell Wand. </author> <title> Correctness of procedure representations in higher-order assembly language. </title> <editor> In S. Brookes, editor, </editor> <booktitle> Proceedings Mathematical Foundations of Programming Semantics '91, volume 598 of Lecture Notes in Computer Science, </booktitle> <pages> pages 294-311. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Section 5 presents the A intermediate language and a translation that makes allocation and initialization of data structures explicit. At this point in compilation, the intermediate code is essentially in a -calculus syntax for assembly language, following the ideas of Wand <ref> [48] </ref>. Finally, Section 6 presents our typed assembly language and defines a translation from A to TAL.
Reference: [49] <author> A. K. Wright. </author> <title> Simple imperative polymorphism. </title> <journal> LISP and Symbolic Computation, </journal> <volume> 8(4), </volume> <month> December </month> <year> 1995. </year> <month> 35 </month>
Reference-contexts: A type-erasure interpretation is not without its costs: It precludes some advanced implementation techniques [31, 43, 1, 30] and has subtle interactions with side-effects. We address the latter concern by forcing polymorphic abstractions to be values <ref> [42, 49] </ref> (i.e., they must be syntactically attached to value abstractions). To support this interpretation, we consider the partial application of functions to type arguments to be values.
References-found: 49

