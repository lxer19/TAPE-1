URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-93-1137/CS-TR-93-1137.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-93-1137/
Root-URL: http://www.cs.wisc.edu
Email: tom@cs.wisc.edu larus@cs.wisc.edu  
Title: Branch Prediction For Free  
Author: THOMAS BALL JAMES R. LARUS 
Date: February 9, 1993  
Address: 1210 W. Dayton St. Madison, WI 53706 USA  
Affiliation: Computer Sciences Department University of Wisconsin Madison  
Pubnum: Technical Report #1137  
Abstract: An abridged version of this paper will appear in the 1993 SIGPLAN Conference on Programming Language Design and Implementation (June, 1993). 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aho, R. Sethi, and J. Ullman, </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: The root vertex of the control flow graph is the entry point of the procedure. A basic block containing a return (procedure exit) has no successors in the control flow graph. Some of our heuristics make use of the control flow graph's domination and postdomination relations <ref> [1] </ref>. A vertex v dominates w if every path from the entry point of the procedure to w includes v. A vertex w postdominates v if every path from v to any exit vertex includes w. <p> Such branches can be easily identified by natural loop analysis <ref> [1] </ref> of the control flow graph, as we now review. Each vertex that is the target of one (or more) loop backedges (as identified by a depth-first search of the control flow graph from the root vertex) is a loop head.
Reference: 2. <author> T. Ball and J. R. Larus, </author> <title> Optimally Profiling and Tracing Programs, </title> <booktitle> Conference Record of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Albuquerque, NM, </address> <month> January 19-22, </month> <year> 1992), </year> <pages> pp. 59-70 ACM, </pages> <year> (1992). </year>
Reference-contexts: To help alleviate this problem, some architectures predict that forward conditional branches are not taken and backward conditional branches are taken, thereby relying on a compiler to arrange code to conform to these expectations. Run-time profile information <ref> [2, 8] </ref> from a program execution typically is used to statically predict branch directions. Fisher and Freudenberger observed that profiled-based static branch prediction works well because most branches take one direction with high probability and the highly probable direction is the same across different program executions [7]. <p> Associated with each conditional branch instruction is its target successor the instruction to which control passes if the branch condition evaluates to trueand its fall-thru successorthe instruction to which control passes if the branch condition evaluates to false. - 2 - We used our profiling and tracing tool QPT <ref> [2] </ref> both as a platform for studying branch behavior and for making branch predictions.
Reference: 3. <author> S. Bandyopadhyay, V. S. Begwani, and R. B. Murray, </author> <title> Compiling for the CRISP Microprocessor, </title> <booktitle> Spring Compcon 87, </booktitle> <pages> pp. </pages> <publisher> 96-100 IEEE Computer Society, </publisher> <month> (February </month> <year> 1987). </year>
Reference-contexts: J. E. Smith discusses several static prediction strategies based on instruction opcodes, applied to six FORTRAN programs with success [16]. Program-based static prediction was used by Bandyopadhyay, et. al. in a C compiler for the CRISP microprocessor <ref> [3] </ref>. They identified loop tests as those in the boolean expression associated with a loop construct. Branch prediction for tests associated with if statements was accomplished by a table lookup based on the comparison operator and operand types.
Reference: 4. <institution> Systems Performance Evaluation Cooperative, </institution> <note> SPEC Newsletter (K. Mendoza, editor) 1(1)(1989). </note>
Reference-contexts: A vertex w postdominates v if every path from v to any exit vertex includes w. If the successor of a branch postdominates the branch, then no matter which direction the branch takes, the successor eventually executes. We analyzed the programs in the SPEC89 benchmark suite <ref> [4] </ref>, along with a number of other programs. These benchmarks (23 of them) are listed in Table 1, along with a description of their function.
Reference: 5. <author> J. A. Fisher, </author> <title> Trace Scheduling: A Technique for Global Microcode Compaction, </title> <journal> IEEE Transactions on Computers C-30(7) pp. </journal> <month> 478-490 (July </month> <year> 1981). </year>
Reference-contexts: However, such a metric does not identify the performance benefit that can be realized when the percent of mispredicted branches decreases. For example, with good branch prediction instruction-level parallel architectures can find more data-independent threads to execute in parallel <ref> [5] </ref> and compilers can globally schedule code to improve program performance [14]. This section measures the performance of branch prediction based on its ability to find sequences of instructions without a mispredicted branch.
Reference: 6. <author> J. A. Fisher, J. R. Ellis, J. C. Ruttenberg, and A. Nicolau, </author> <title> Parallel Processing: A Smart Compiler and a Dumb Machine, </title> <booktitle> Proc. of the ACM SIGPLAN 1984 Symposium on Compiler Construction (SIGPLAN Notices) 19(6) pp. </booktitle> <month> 37-47 (June </month> <year> 1984). </year>
Reference-contexts: Taking into account loop branchesfor which we employ a more accurate heuristic than the common technique of simply identifying backwards branchesour heuristics have an average miss rate of 20%. Many compiler optimizations rely on branch prediction to identify heavily-executed paths <ref> [6, 12, 14] </ref>. In addition, recently introduced architectures, such as the DEC Alpha [15] and MIPS R4000 [9], exact a heavy pipeline penalty for a mispredicting a branch (up to 10 cycles [15]).
Reference: 7. <author> J. A. Fisher and S. M. Freudenberger, </author> <title> Predicting Conditional Branch Directions From Previous Runs of a Program, </title> <booktitle> Proceedings of the 5th International Conference on Architectural Support for Programmming Languages and Operating Systems (ACM SIGPLAN Notices) 27(9) pp. </booktitle> <month> 85-95 (October </month> <year> 1992). </year>
Reference-contexts: Run-time profile information [2, 8] from a program execution typically is used to statically predict branch directions. Fisher and Freudenberger observed that profiled-based static branch prediction works well because most branches take one direction with high probability and the highly probable direction is the same across different program executions <ref> [7] </ref>. Profile-based branch prediction can be quite accurate, but it is inconvenient and time-consuming to use. First, a program is compiled. To be profiled, a program must be instrumented with counting code, which may be done by the compiler or another tool. <p> All of the benchmarks were compiled and analyzed on a DECstation (a MIPS R2000/R3000 processor) with -O optimization. The results presented in Sections 3 to 6 are for a single execution of each benchmark. Previous work has shown that most branches behave similarly over different executions <ref> [7] </ref>. That is, if a branch takes one direction with high probability during one execution of a program, it most likely takes the same direction with high probability in other executions. <p> The goal of this work is to show that static prediction can accurately determine these branch directions, rather than confirm previous results. However, we also tested our predictor on multiple datasets per benchmark and found similar results to those of <ref> [7] </ref>. Section 7 summarizes the results of these experiments. We are concerned with static branch prediction. That is, for each branch either the target successor or fall-thru successor is predicted, and this prediction does not change during the execution of the program. <p> This section measures the performance of branch prediction based on its ability to find sequences of instructions without a mispredicted branch. Fisher and Freudenberger have proposed a metric <ref> [7] </ref>: instructions executed per break in control (a break in control is a mispredicted branch instruction, an indirect jump other than procedure return, or an indirect call; correctly predicted branch instructions are not breaks in control). <p> As mentioned before, Fisher and Freudenberger examined profile-based static prediction in detail, showing that most branches behave similarly over different executions of the same program and that profiles can be used to effectively predict branch directions in other executions <ref> [7] </ref>. J. E. Smith discusses several static prediction strategies based on instruction opcodes, applied to six FORTRAN programs with success [16]. Program-based static prediction was used by Bandyopadhyay, et. al. in a C compiler for the CRISP microprocessor [3].
Reference: 8. <author> S. L. Graham, P. B. Kessler, and M. K. McKusick, </author> <title> An Execution Profiler for Modular Programs, </title> <journal> Software Practice and Experience 13 pp. </journal> <month> 671-685 </month> <year> (1983). </year>
Reference-contexts: To help alleviate this problem, some architectures predict that forward conditional branches are not taken and backward conditional branches are taken, thereby relying on a compiler to arrange code to conform to these expectations. Run-time profile information <ref> [2, 8] </ref> from a program execution typically is used to statically predict branch directions. Fisher and Freudenberger observed that profiled-based static branch prediction works well because most branches take one direction with high probability and the highly probable direction is the same across different program executions [7].
Reference: 9. <author> G. Kane and J. Heinrich, </author> <title> MIPS RISC Architecture, </title> <publisher> Prentice Hall (1992). </publisher>
Reference-contexts: Many compiler optimizations rely on branch prediction to identify heavily-executed paths [6, 12, 14]. In addition, recently introduced architectures, such as the DEC Alpha [15] and MIPS R4000 <ref> [9] </ref>, exact a heavy pipeline penalty for a mispredicting a branch (up to 10 cycles [15]). To help alleviate this problem, some architectures predict that forward conditional branches are not taken and backward conditional branches are taken, thereby relying on a compiler to arrange code to conform to these expectations.
Reference: 10. <author> J. K. F. Lee and A. J. Smith, </author> <title> Branch Prediction Strategies and Branch Target Buffer Design, </title> <note> Computer 17(1) pp. 6 - 22 (January 1984). </note>
Reference-contexts: He reported poor results for his estimator, compared to a randomly generated profile. Lee and A. J. Smith's paper on branch prediction strategies reported that for the workloads they considered (IBM 370, DEC PDP-11, and CDC 6400) branches were taken twice as often as they fell through <ref> [10] </ref>. Lee and Smith considered branch prediction based on instruction opcodes and dynamic branch history. They found that the miss rates for opcode prediction ranged from 20.2% to 44.8% with an average of 30.1%. 9.
Reference: 11. <author> S. McFarling and J. Hennessy, </author> <title> Reducing the Cost of Branches, </title> <booktitle> Proceedings of the 13th Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. </pages> <publisher> 396-403 ACM and IEEE Computer Society, </publisher> <month> (June </month> <year> 1986). </year>
Reference-contexts: RELATED WORK Related work on static branch prediction falls into two categories: profile-based and program-based. McFarling and Hennessy reported that profile-based static prediction yields results comparable to dynamic hardware-based methods <ref> [11] </ref>. As mentioned before, Fisher and Freudenberger examined profile-based static prediction in detail, showing that most branches behave similarly over different executions of the same program and that profiles can be used to effectively predict branch directions in other executions [7]. J. E.
Reference: 12. <author> W. G. Morris, CCG: </author> <title> A Prototype Coagulating Code Generator, </title> <booktitle> Proceedings of the SIGPLAN 91 Conference on Programming Language Design and Implementation, </booktitle> <address> (Toronto, </address> <month> June 26-28, </month> <year> 1991), </year> <journal> ACM SIGPLAN Notices 26(6) pp. </journal> <month> 45-58 (June, </month> <year> 1991). </year> <month> - 19 </month> - 
Reference-contexts: Taking into account loop branchesfor which we employ a more accurate heuristic than the common technique of simply identifying backwards branchesour heuristics have an average miss rate of 20%. Many compiler optimizations rely on branch prediction to identify heavily-executed paths <ref> [6, 12, 14] </ref>. In addition, recently introduced architectures, such as the DEC Alpha [15] and MIPS R4000 [9], exact a heavy pipeline penalty for a mispredicting a branch (up to 10 cycles [15]).
Reference: 13. <author> D. A. Patterson and J. L. Hennessy, </author> <title> Computer Architecture: A Quantitative Approach, </title> <publisher> Morgan, Kaufmann Publishers Inc. </publisher> <year> (1990). </year>
Reference-contexts: Backwards branches in code (a backwards branch passes control to an address that is before the address of the branch instruction) usually control the iteration of loops. However, many non-backwards branches can also control the iteration of loops either by exiting the loop or continuing the iteration <ref> [13] </ref>. For many of the benchmarks, loop branches that are not backwards branches account for a very high percentage of loop branches (for example, 40% of dynamic loop branches in xlisp were not backwards branches and 45% of loop branches in doduc were not backwards branches).
Reference: 14. <author> K. Pettis and R. C. Hanson, </author> <title> Profile Guided Code Positioning, </title> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation (SIGPLAN Notices) 25(6) pp. 16-27 ACM, </booktitle> <month> (June, </month> <year> 1990). </year>
Reference-contexts: Taking into account loop branchesfor which we employ a more accurate heuristic than the common technique of simply identifying backwards branchesour heuristics have an average miss rate of 20%. Many compiler optimizations rely on branch prediction to identify heavily-executed paths <ref> [6, 12, 14] </ref>. In addition, recently introduced architectures, such as the DEC Alpha [15] and MIPS R4000 [9], exact a heavy pipeline penalty for a mispredicting a branch (up to 10 cycles [15]). <p> For example, with good branch prediction instruction-level parallel architectures can find more data-independent threads to execute in parallel [5] and compilers can globally schedule code to improve program performance <ref> [14] </ref>. This section measures the performance of branch prediction based on its ability to find sequences of instructions without a mispredicted branch.
Reference: 15. <author> R. L. </author> <title> Sites, Alpha Architecture Reference Manual, </title> <publisher> Digital Press, </publisher> <address> Burlington, MA (1992). </address>
Reference-contexts: Many compiler optimizations rely on branch prediction to identify heavily-executed paths [6, 12, 14]. In addition, recently introduced architectures, such as the DEC Alpha <ref> [15] </ref> and MIPS R4000 [9], exact a heavy pipeline penalty for a mispredicting a branch (up to 10 cycles [15]). <p> Many compiler optimizations rely on branch prediction to identify heavily-executed paths [6, 12, 14]. In addition, recently introduced architectures, such as the DEC Alpha <ref> [15] </ref> and MIPS R4000 [9], exact a heavy pipeline penalty for a mispredicting a branch (up to 10 cycles [15]). To help alleviate this problem, some architectures predict that forward conditional branches are not taken and backward conditional branches are taken, thereby relying on a compiler to arrange code to conform to these expectations.
Reference: 16. <author> J. E. Smith, </author> <title> A Study of Branch Prediction Strategies, </title> <booktitle> Proceedings of the 4th Annual International Symposium on Computer Architecture (SIGARCH Newsletter) 9(3) pp. 135-148 ACM and IEEE Computer Society, </booktitle> <month> (May </month> <year> 1981). </year>
Reference-contexts: J. E. Smith discusses several static prediction strategies based on instruction opcodes, applied to six FORTRAN programs with success <ref> [16] </ref>. Program-based static prediction was used by Bandyopadhyay, et. al. in a C compiler for the CRISP microprocessor [3]. They identified loop tests as those in the boolean expression associated with a loop construct.

References-found: 16

