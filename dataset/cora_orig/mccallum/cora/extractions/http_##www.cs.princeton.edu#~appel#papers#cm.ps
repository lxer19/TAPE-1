URL: http://www.cs.princeton.edu/~appel/papers/cm.ps
Refering-URL: http://www.cs.princeton.edu/courses/archive/fall97/cs595/reading.html
Root-URL: http://www.cs.princeton.edu
Title: Hierarchical Modularity: Compilation Management for Standard ML  
Author: Matthias Blume Andrew W. Appel 
Date: July 17, 1997  
Affiliation: Princeton University  
Abstract: Many programming languages identify modular units with compilation units, while only few extend this to permit hierarchies of language-level modules within individual compilation units. But when the number of such compilation units is large, then it becomes increasingly important that they themselves can be grouped together and that explicit export interfaces can be used to control name-spaces. We explain how the group model implemented in SML/NJ's compilation manager CM provides the necessary facilities to avoid unwanted interferences between unrelated parts of large programs. We also discuss the problem of automatic dependency analysis as well as its complexity and show ways of avoiding intractability. 
Abstract-found: 1
Intro-found: 1
Reference: [Ada80] <author> Military standard: </author> <title> Ada programming language. </title> <type> Technical Report MIL-STD-1815, </type> <institution> Department of Defense, Naval Publications and Forms Center, </institution> <address> Philadelphia, PA, </address> <year> 1980. </year>
Reference-contexts: Language constructs thatlike Pascal's with [JW78]bind identifiers implicitly have been criticized before [Ten81, section 6.2.3.]. A feature that confuses dependency analysis tools will not be easy to understand by the human reader. Ada's use <ref> [Ada80] </ref>, import in Java, or using in C++ can behave like open in SMLwith all the same implications for dependency analysis. Modula-2 [Wir82] and Modula-3, on the other hand, do not have this problem.
Reference: [AG96] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: SML has structures and functors, Modula-3 [CDG + 89] has modules, C++ [ES90] has namespaces, and Java <ref> [AG96] </ref> offers packages.
Reference: [AM94] <author> Andrew W. Appel and David B. Mac-Queen. </author> <title> Separate compilation for Standard ML. </title> <booktitle> In Proc. SIGPLAN '94 Symp. on Prog. Language Design and Implementation, </booktitle> <volume> volume 29, </volume> <pages> pages 1323. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: His notion of a linkset is used as a framework for describing and reasoning about consistent, type-safe linking. Type-safe linking, for example provided by SML/NJ's visible compiler <ref> [AM94] </ref>, is a prerequisitebut not the focus of our work. In place of Cardelli's linksets our notation uses functions to express operations on environments and equations for describing their properties. This also reflects the actual implementation of CM more closely. Environments.
Reference: [ATW94] <author> Rolf Adams, Walter Tichy, and Annette Weinert. </author> <title> The cost of selective recompilation and environment processing. </title> <journal> ACM TOSEM, </journal> <volume> 3(1):328, </volume> <month> January </month> <year> 1994. </year>
Reference-contexts: As an important optimization CM always compares the context environment (equation 3) to the one used when previously compiling the same source (provided the source itself has not been modified). Recompilation can be avoided if source code and compilation context are unchanged. This strategy is known as cutoff recompilation <ref> [ATW94] </ref>, because once a modification is found to have no effect on some source recompilation will not propagate any further from there. 4 Automatic dependency analysis The problem of dependency analysis for SML is the following: For a given set of sources s = fS 1 ; : : : ;
Reference: [Blu97] <author> Matthias Blume. </author> <title> Hierarchical Modularity and Intermodular Optimization. </title> <type> PhD thesis, </type> <institution> Princeton University, </institution> <note> expected 1997. </note>
Reference-contexts: environment, and top-level definitions for symbols that were already defined by the context are permitted in this model. 2 The formalism in this summary version of the paper does not account for long identifiers, which, for example, would require adjusting equation 1. 3 The complete proof can be found in <ref> [Blu97] </ref>, and will appear in the full version of this paper if space permits. Restriction 1 In each group there can be at most one source that provides a top-level definition for any given symbol. <p> Here is one example: Restriction 2b Instances of the open syntax at top level are not permitted to introduce definitions for structure names that are used somewhere within the 5 For the complete proof see <ref> [Blu97] </ref> orspace permitting the full version of this paper. 11 group if the context already provides a definition for them. The more permissive restriction 2b no longer provides a way of calculating the set of exported definitions by processing a source in isolation from the other sources.
Reference: [Car97] <author> Luca Cardelli. </author> <title> Program fragments, linking, and modularization. </title> <booktitle> In Proceedings of the 24th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 266277, </pages> <year> 1997. </year>
Reference-contexts: CM's group model is able to eliminate modularity-inhibiting restrictions on definability and availability in a general way. The following section will discuss this more formally. 3 Environments, linking, and hierarchical modularity Cardelli <ref> [Car97] </ref> presents an excellent discussion of the problems that arise with modules and separate compilation. His notion of a linkset is used as a framework for describing and reasoning about consistent, type-safe linking.
Reference: [CDG + 89] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <note> Modula-3 report (revised). Research Report 52, </note> <institution> Systems Research Center, Digital Equipment Corp., </institution> <address> Palo Alto, CA, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: SML has structures and functors, Modula-3 <ref> [CDG + 89] </ref> has modules, C++ [ES90] has namespaces, and Java [AG96] offers packages.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: SML has structures and functors, Modula-3 [CDG + 89] has modules, C++ <ref> [ES90] </ref> has namespaces, and Java [AG96] offers packages.
Reference: [HLPR94] <author> Robert Harper, Peter Lee, Frank Pfenning, and Eugene Rollins. </author> <title> A Compilation Manager for Standard ML of New Jersey. </title> <booktitle> In 1994 ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <pages> pages 136147, </pages> <year> 1994. </year>
Reference-contexts: However, a more involved algorithm that essentially processes all sources concurrently is still capable of finding the dependency graph and proving it unique in polynomial time. A version of such an algorithm had been implemented in SC, which was CM's precursor <ref> [HLPR94] </ref>. But the authors of SC were not aware of the general problem's complexity class, so they only enforced restriction 1 and made no attempt of restricting the use of top-level open.
Reference: [JW78] <author> Kathleen Jensen and Niklaus Wirth. </author> <title> Pascal: User Manual and Report, Second Ed. </title> <address> New York, </address> <year> 1978. </year>
Reference: [KR88] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <note> second edition, </note> <year> 1988. </year>
Reference-contexts: We will also show how the restrictions that are modular can be resolved by simple local modifications to only the part of the program where they occur. Definability: A program in a language like C <ref> [KR88] </ref> cannot use certain identifiers, because they are potentially taken by libraries or other parts of the program, even if those are conceptually unrelated. Thus, these identifiers are not definable anymore (figure 5).
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: With open this becomes more involved, but still, the size of typical dependency files is only 14% of the corresponding SML source code size. 6 and the absence of datatype replication as introduced by the revised definition of SML <ref> [MTH90, MTHM97] </ref> compilation manager like CM we can structure the project shown in figure 2 into a collection of groups. The export interface on group stdio will make sure that implementation details such as the local function doprnt are not exposed to its clients A and B.
Reference: [MTHM97] <author> Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA, </address> <year> 1997. </year>
Reference-contexts: Definability: A program in a language like C [KR88] cannot use certain identifiers, because they are potentially taken by libraries or other parts of the program, even if those are conceptually unrelated. Thus, these identifiers are not definable anymore (figure 5). Availability: Programs in other languages, for example SML <ref> [MTHM97] </ref>, can have arbitrarily many definitions for the same name, but although this eliminates restrictions on definability it creates new restrictions on availability: Parts of a larger program may not be able to see an early definition for variable x, because there is a different, intervening definition for x inhibiting access <p> With open this becomes more involved, but still, the size of typical dependency files is only 14% of the corresponding SML source code size. 6 and the absence of datatype replication as introduced by the revised definition of SML <ref> [MTH90, MTHM97] </ref> compilation manager like CM we can structure the project shown in figure 2 into a collection of groups. The export interface on group stdio will make sure that implementation details such as the local function doprnt are not exposed to its clients A and B.
Reference: [Rep91] <author> John H. Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In Proc. ACM SIGPLAN '91 Conf. on Prog. Lang. Design and Implementation, </booktitle> <volume> volume 26, </volume> <pages> pages 293305. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: We believe in a programming style that uses SML's module language extensively, so there would be no need for open at top level. However, in some instances such a complete ban was prohibitive. For example, someone who is using Concurrent ML <ref> [Rep91] </ref> extensivelyas a programming language in its own rightmight want to open the CML structure to have more convenient access to its components. There are several ways of restricting the use of top-level open in a more relaxed way.
Reference: [Ten81] <author> R. D. Tennent. </author> <booktitle> Principles of Programming Languages. </booktitle> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: Language constructs thatlike Pascal's with [JW78]bind identifiers implicitly have been criticized before <ref> [Ten81, section 6.2.3.] </ref>. A feature that confuses dependency analysis tools will not be easy to understand by the human reader. Ada's use [Ada80], import in Java, or using in C++ can behave like open in SMLwith all the same implications for dependency analysis.
Reference: [Wir82] <author> Niklaus Wirth. </author> <title> Programming in MODULA-2. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, Tokyo, </address> <note> second edition, </note> <year> 1982. </year>
Reference-contexts: A feature that confuses dependency analysis tools will not be easy to understand by the human reader. Ada's use [Ada80], import in Java, or using in C++ can behave like open in SMLwith all the same implications for dependency analysis. Modula-2 <ref> [Wir82] </ref> and Modula-3, on the other hand, do not have this problem. In Modula-2 one must write FROM M IMPORT a, b, c; in order for a, b, and cand only thoseto become directly accessible without being prefixed by M.
Reference: [Wir88] <author> Niklaus Wirth. </author> <title> From Modula to Oberon. </title> <journal> Software Practice and Experience, </journal> <volume> 18(7), </volume> <month> jul </month> <year> 1988. </year>
Reference-contexts: Therefore, the identifiers defined are lexically apparent even without knowing the definition of module M. The design of Oberon takes this much further by discarding both with and from-import, leaving the language without any facility for circumventing the qualification of identifiers <ref> [Wir88] </ref>. In the context of dependency analysis it is especially troublesome that open at top level takes away the analyzer's ability to determine the set of exported definitions by simply scanning the source code.
References-found: 17

