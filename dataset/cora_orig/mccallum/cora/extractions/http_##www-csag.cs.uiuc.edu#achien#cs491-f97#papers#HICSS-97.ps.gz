URL: http://www-csag.cs.uiuc.edu/achien/cs491-f97/papers/HICSS-97.ps.gz
Refering-URL: http://www-csag.cs.uiuc.edu/achien/cs491-f97/reading.html
Root-URL: http://www.cs.uiuc.edu
Email: gokhale@cs.wustl.edu and schmidt@cs.wustl.edu  
Title: Principles for Optimizing CORBA Internet Inter-ORB Protocol Performance  
Author: Aniruddha Gokhale and Douglas C. Schmidt 
Address: St. Louis, MO 63130, USA 1  
Affiliation: Department of Computer Science, Washington University  
Abstract: The Internet Inter-ORB Protocol (IIOP) enables heterogeneous CORBA-compliant Object Request Brokers (ORBs) to interoperate over TCP/IP networks. The IIOP uses the Common Data Representation transfer syntax to map CORBA Interface Definition Language (IDL) data types into a portable network format. Due to the excessive marshaling/demarshaling overhead, data copying, and high-levels of function call overhead, conventional implementations of IIOP protocols have yielded relatively poor performance over high-speed networks. To meet the demands of emerging distributed multimedia applications, however, CORBA-compliant ORBs must support interoperable and highly efficient IIOP implementations. This paper provides three contributions to the study and design of efficient CORBA IIOP implementations. First, we outline the software architecture of a typical IIOP protocol engine. Second, we pinpoint the key sources of overhead in the SunSoft IIOP implementation (which is a standard reference implementation of IIOP written in C++) by measuring its performance for transferring richly-typed data over a high-speed ATM network. Third, we empirically demonstrate the benefits of systematically applying protocol optimizations to SunSoft IIOP. These optimizations include: optimizing for the common case; eliminating gratuitous waste; replacing general purpose methods with specialized, efficient ones; precomputing values; storing redundant state to speed up expensive operations; passing information between layers; and optimizing for better processor cache performance. The results of applying these optimizations to SunSoft IIOP improved its performance substantially for all data types. The resulting optimized IIOP implementation is competitive with existing commercial ORBs using CORBA's static invocation interface and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface. We have integrated the optimized IIOP implementation into TAO, which is a CORBA ORB targeted for real-time systems. Keywords: Distributed object computing, CORBA, IIOP performance, communication middleware protocol optimizations, high-speed networks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abbott and L. Peterson. </author> <title> Increasing Network Throughput by Integrating Protocol Layers. </title> <journal> ACM Transactions on Networking, </journal> <volume> 1(5), </volume> <month> October </month> <year> 1993. </year>
Reference-contexts: The optimizations reported in [4] are based on Principle 1, which optimizes for the common case and Principle 3, which is precompute, if possible. We present the results of applying these principles to optimize IIOP in Sections 3.2.3, 3.2.4, and 3.2.5. <ref> [5, 1, 3] </ref> describe the application of an optimization mechanism called Integrated Layer Processing (ILP). ILP is based on the observation that data manipulation loops that operate on the same protocol data are wasteful and expensive.
Reference: [2] <author> Mary L. Bailey, Burra Gopal, Prasenjit Sarkar, Michael A. Pagels, and Larry L. Peterson. Pathfinder: </author> <title> A pattern-based packet classifier. </title> <booktitle> In Proceedings of the 1 st Symposium on Operating System Design and Implementation. USENIX Association, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: We demonstrate the application of this principle to IIOP in Section 3.2.4 where we eliminated unnecessary calls to the deep free method, which frees primitive data types. [3] cautions against improper use of ILP since this may increase processor cache misses. Packet filters <ref> [18, 2, 8] </ref> are a classic example of Principle 6, which recommends passing information between layers. A packet filter demultiplexes incoming packets to the appropriate target application (s).
Reference: [3] <author> Torsten Braun and Christophe Diot. </author> <title> Protocol Implementation Using Integrated Layer Processnig. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM). ACM, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: The optimizations reported in [4] are based on Principle 1, which optimizes for the common case and Principle 3, which is precompute, if possible. We present the results of applying these principles to optimize IIOP in Sections 3.2.3, 3.2.4, and 3.2.5. <ref> [5, 1, 3] </ref> describe the application of an optimization mechanism called Integrated Layer Processing (ILP). ILP is based on the observation that data manipulation loops that operate on the same protocol data are wasteful and expensive. <p> The ILP optimization scheme is based on Principle 2, which gets rid of gratuitous waste. We demonstrate the application of this principle to IIOP in Section 3.2.4 where we eliminated unnecessary calls to the deep free method, which frees primitive data types. <ref> [3] </ref> cautions against improper use of ILP since this may increase processor cache misses. Packet filters [18, 2, 8] are a classic example of Principle 6, which recommends passing information between layers. A packet filter demultiplexes incoming packets to the appropriate target application (s).
Reference: [4] <author> David D. Clark, Van Jacobson, John Romkey, and Howard Salwen. </author> <title> An Analysis of TCP Processing Overhead. </title> <journal> IEEE Communications Magazine, </journal> <volume> 27(6):2329, </volume> <month> June </month> <year> 1989. </year>
Reference-contexts: In addition, we discuss related work on CORBA performance measurements and presentation layer marshaling. optimization) optimization) 14 Analysis for doubles Analysis for BinStructs Analysis for doubles Analysis for BinStructs Related work based on optimization principles: <ref> [4] </ref> describes a technique called header prediction that predicts the message header of incoming TCP packets. This technique is based on the observation that many members in the header remaining constant between consecutive packets. This observation led to the creation of a template for the expected packet header. <p> This technique is based on the observation that many members in the header remaining constant between consecutive packets. This observation led to the creation of a template for the expected packet header. The optimizations reported in <ref> [4] </ref> are based on Principle 1, which optimizes for the common case and Principle 3, which is precompute, if possible.
Reference: [5] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architectural Considerations for a New Generation of Protocols. </title> <booktitle> In Proceedings of the Symposium on Communications Architectures and Protocols (SIGCOMM), pages 200208, </booktitle> <address> Philadelphia, PA, </address> <month> September </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: The optimizations reported in [4] are based on Principle 1, which optimizes for the common case and Principle 3, which is precompute, if possible. We present the results of applying these principles to optimize IIOP in Sections 3.2.3, 3.2.4, and 3.2.5. <ref> [5, 1, 3] </ref> describe the application of an optimization mechanism called Integrated Layer Processing (ILP). ILP is based on the observation that data manipulation loops that operate on the same protocol data are wasteful and expensive.
Reference: [6] <author> Peter Druschel and Larry L. Peterson. Fbufs: </author> <title> A High-Bandwidth Cross-Domain Transfer Facility. </title> <booktitle> In Proceedings of the 14 th Symposium on Operating System Principles (SOSP), </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: We applied Principle 6 for IIOP in Section 3.2.4 where we passed the TypeCode information and size of the element type of a sequence to the TypeCode interpreter. Therefore, the interpreter need not calculate the same quantities repeatedly. <ref> [6] </ref> describes a facility called fast buffers (FBUFS). FBUFS combines virtual page remapping with shared virtual memory to reduce unnecessary data copying and achieve high throughput.
Reference: [7] <author> Eric Eide, Kevin Frei, Bryan Ford, Jay Lepreau, and Gary Lindstrom. Flick: </author> <title> A Flexible, Optimizing IDL Compiler. </title> <booktitle> In Proceedings of ACM SIGPLAN '97 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <address> Las Ve-gas, NV, </address> <month> June </month> <year> 1997. </year> <note> ACM. </note>
Reference-contexts: As explained in Section 5, we are currently implementing a CORBA IDL compiler [13] that can generate compiled stubs and skeletons. Our goal is to generate efficient stubs and skeletons by extending optimizations provided in USC [22] and Flick <ref> [7] </ref>, which is a flexible, optimizing IDL compiler. Flick uses an innovative scheme where intermediate representations guide the generation of optimized stubs.
Reference: [8] <author> Dawson R. Engler and M. Frans Kaashoek. DPF: </author> <title> Fast, Flexible Message Demultiplexing using Dynamic Code Generation. </title> <booktitle> In Proceedings of ACM SIGCOMM '96 Conference in Computer Communication Review, </booktitle> <pages> pages 5359, </pages> <institution> Stanford University, California, USA, </institution> <month> August </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: We demonstrate the application of this principle to IIOP in Section 3.2.4 where we eliminated unnecessary calls to the deep free method, which frees primitive data types. [3] cautions against improper use of ILP since this may increase processor cache misses. Packet filters <ref> [18, 2, 8] </ref> are a classic example of Principle 6, which recommends passing information between layers. A packet filter demultiplexes incoming packets to the appropriate target application (s).
Reference: [9] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks. </title> <booktitle> In Proceedings of SIGCOMM '96, </booktitle> <pages> pages 306317, </pages> <address> Stanford, CA, </address> <month> August </month> <year> 1996. </year> <note> ACM. </note>
Reference-contexts: The CORBA specification defines an abstract interoperability protocol known as the General Inter-ORB Protocol (GIOP). Specialized mappings of GIOP can be defined for particular transport protocols. One such mapping is called the Internet Inter-ORB Protocol (IIOP), which is the standard GIOP mapping for distributed object computing over TCP/IP. 2 <ref> [9, 10, 11] </ref> show that the performance of conventional CORBA middleware implementations is relatively poor compared to lower-level implementations using C/C++ since the ORBs incur a significant amount of data copying, marshaling, demarshaling, and demultiplexing overhead. These results, however, focused entirely on the communication performance between homogeneous ORBs. <p> In addition, earlier work on measuring CORBA performance did not present the results of optimizations to reduce key sources of ORB overhead. In this paper, we measure the performance of the standard reference implementation of IIOP, freely available from SunSoft, using a CORBA/ATM testbed environment similar to <ref> [9, 10, 11] </ref>. We measure the performance of SunSoft IIOP and precisely pinpoint its performance overheads. <p> Our optimized version of SunSoft IIOP is now comparable to existing commercial ORBs <ref> [9, 10, 11] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). <p> Optimizing such software is hard, particularly since seemingly minor mistakes (such as copying data excessively) can significantly reduce performance <ref> [9] </ref>. Therefore, developing high performance ORBs requires an iterative, multi-step process. The first step involves measuring the performance of the system and pinpointing the sources of overhead. The second step involves a careful analysis of these sources of overhead and application of optimizations to remove them. <p> We describe optimizatons for processor cache in Section 3.2.5. Related work on CORBA performance measurements: <ref> [9, 10, 11] </ref> show that the performance of CORBA middleware 15 Analysis for doubles Analysis for BinStructs Analysis for doubles Analysis for BinStructs implementations is relatively poor, compared to lower-level implementations using C/C++. <p> The primary source of ORB-level overhead stems from marshaling and demarshaling. <ref> [9] </ref> measures the performance of the static invocation interface. [10] measures the performance of the dynamic invocation interface and the dynamic skeleton interface. [11] measures performance of CORBA implementations in terms of latency and support for very large number of objects. <p> The results of applying these optimization principles to SunSoft IIOP improved its performance 1.9 times for doubles, 3.3 times for longs, 4 times for shorts, 5 times for chars/octets, and 6.7 times for richly-typed structs over ATM networks. Our optimized implementation is now competitive with existing commercial ORBs <ref> [9, 11] </ref> using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) [10].
Reference: [10] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> The Performance of the CORBA Dynamic Invocation Interface and Dynamic Skeleton Interface over High-Speed ATM Networks. </title> <booktitle> In Proceedings of GLOBECOM '96, </booktitle> <pages> pages 5056, </pages> <address> London, England, </address> <month> November </month> <year> 1996. </year> <journal> IEEE. </journal> <volume> 17 </volume>
Reference-contexts: The CORBA specification defines an abstract interoperability protocol known as the General Inter-ORB Protocol (GIOP). Specialized mappings of GIOP can be defined for particular transport protocols. One such mapping is called the Internet Inter-ORB Protocol (IIOP), which is the standard GIOP mapping for distributed object computing over TCP/IP. 2 <ref> [9, 10, 11] </ref> show that the performance of conventional CORBA middleware implementations is relatively poor compared to lower-level implementations using C/C++ since the ORBs incur a significant amount of data copying, marshaling, demarshaling, and demultiplexing overhead. These results, however, focused entirely on the communication performance between homogeneous ORBs. <p> In addition, earlier work on measuring CORBA performance did not present the results of optimizations to reduce key sources of ORB overhead. In this paper, we measure the performance of the standard reference implementation of IIOP, freely available from SunSoft, using a CORBA/ATM testbed environment similar to <ref> [9, 10, 11] </ref>. We measure the performance of SunSoft IIOP and precisely pinpoint its performance overheads. <p> Our optimized version of SunSoft IIOP is now comparable to existing commercial ORBs <ref> [9, 10, 11] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). <p> We describe optimizatons for processor cache in Section 3.2.5. Related work on CORBA performance measurements: <ref> [9, 10, 11] </ref> show that the performance of CORBA middleware 15 Analysis for doubles Analysis for BinStructs Analysis for doubles Analysis for BinStructs implementations is relatively poor, compared to lower-level implementations using C/C++. <p> The primary source of ORB-level overhead stems from marshaling and demarshaling. [9] measures the performance of the static invocation interface. <ref> [10] </ref> measures the performance of the dynamic invocation interface and the dynamic skeleton interface. [11] measures performance of CORBA implementations in terms of latency and support for very large number of objects. <p> Our optimized implementation is now competitive with existing commercial ORBs [9, 11] using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) <ref> [10] </ref>. The results of our optimizations provide sufficient proof that performance of complex distributed systems software can be improved by a systematic application of principle-driven optimizations. We are currently integrating the optimized SunSoft IIOP implementation with a complete real-time ORB called TAO [23].
Reference: [11] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Evaluating La- tency and Scalability of CORBA Over High-Speed ATM Net works. </title> <booktitle> In Proceedings of the International Conference on Distributed Computing Systems, </booktitle> <address> Baltimore, Maryland, </address> <month> May </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: The CORBA specification defines an abstract interoperability protocol known as the General Inter-ORB Protocol (GIOP). Specialized mappings of GIOP can be defined for particular transport protocols. One such mapping is called the Internet Inter-ORB Protocol (IIOP), which is the standard GIOP mapping for distributed object computing over TCP/IP. 2 <ref> [9, 10, 11] </ref> show that the performance of conventional CORBA middleware implementations is relatively poor compared to lower-level implementations using C/C++ since the ORBs incur a significant amount of data copying, marshaling, demarshaling, and demultiplexing overhead. These results, however, focused entirely on the communication performance between homogeneous ORBs. <p> In addition, earlier work on measuring CORBA performance did not present the results of optimizations to reduce key sources of ORB overhead. In this paper, we measure the performance of the standard reference implementation of IIOP, freely available from SunSoft, using a CORBA/ATM testbed environment similar to <ref> [9, 10, 11] </ref>. We measure the performance of SunSoft IIOP and precisely pinpoint its performance overheads. <p> Our optimized version of SunSoft IIOP is now comparable to existing commercial ORBs <ref> [9, 10, 11] </ref> using the static invocation interface (SII) and around 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI). <p> We describe optimizatons for processor cache in Section 3.2.5. Related work on CORBA performance measurements: <ref> [9, 10, 11] </ref> show that the performance of CORBA middleware 15 Analysis for doubles Analysis for BinStructs Analysis for doubles Analysis for BinStructs implementations is relatively poor, compared to lower-level implementations using C/C++. <p> The primary source of ORB-level overhead stems from marshaling and demarshaling. [9] measures the performance of the static invocation interface. [10] measures the performance of the dynamic invocation interface and the dynamic skeleton interface. <ref> [11] </ref> measures performance of CORBA implementations in terms of latency and support for very large number of objects. However, the results of earlier CORBA benchmarking experiments were restricted to measuring the performance of communication between homogeneous ORBs. <p> The results of applying these optimization principles to SunSoft IIOP improved its performance 1.9 times for doubles, 3.3 times for longs, 4 times for shorts, 5 times for chars/octets, and 6.7 times for richly-typed structs over ATM networks. Our optimized implementation is now competitive with existing commercial ORBs <ref> [9, 11] </ref> using the static invocation interface (SII) and 2 to 4.5 times (depending on the data type) faster than commercial ORBs using the dynamic skeleton interface (DSI) [10].
Reference: [12] <author> Aniruddha Gokhale, Douglas C. Schmidt, and Stan Moyer. </author> <title> Evaluating the Performance of Demultiplexing Strategies for Real-time CORBA. </title> <note> In Submitted to GLOBECOM '97, , Phoenix, AZ, </note> <month> November </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: Therefore, TAO defines a set of Object Adapter strategies that dispatch requests to the correct skeleton of the target object. TAO's request demulti-plexing and dispatching process provides different strategies to demultiplex requests to skeletons, including linear search, dynamic hashing or perfect hashing of operation names, or direct demultiplexing <ref> [12] </ref>. A prototype of TAO is available at www.cs.wustl.edu/~schmidt/ACE wrappers/TAO.
Reference: [13] <author> Aniruddha Gokhale, Douglas C. Schmidt, and Stan Moyer. </author> <title> Tools for Automating the Migration from DCE to CORBA. </title> <booktitle> In Proceedings of ISS 97: World Telecommunications Congress, </booktitle> <address> Toronto, Canada, </address> <month> September </month> <year> 1997. </year> <journal> IEEE Communications Society. </journal>
Reference-contexts: According to the SunSoft IIOP developers, interpretive marshaling is preferable since it decreases code size and increases the likelihood of remaining in the processor cache. As explained in Section 5, we are currently implementing a CORBA IDL compiler <ref> [13] </ref> that can generate compiled stubs and skeletons. Our goal is to generate efficient stubs and skeletons by extending optimizations provided in USC [22] and Flick [7], which is a flexible, optimizing IDL compiler. Flick uses an innovative scheme where intermediate representations guide the generation of optimized stubs.
Reference: [14] <author> Tim Harrison, David Levine, and Douglas C. Schmidt. </author> <title> The Design and Performance of a Real-time CORBA Event Ser vice. </title> <booktitle> In Proceedings of OOPSLA '97, </booktitle> <address> Atlanta, GA, </address> <month> October </month> <year> 1997. </year> <note> ACM. </note>
Reference-contexts: We plan to measure the tradeoffs of using the two marshaling schemes to achieve an optimal hybrid solution [15]. In addition, we have incorporated an Real-time Object Adapter <ref> [14] </ref> that supports de-layered active request demul 8 The SunSoft front-end CORBA IDL compiler is also freely available from ftp://ftp.omg.org/pub/OMG IDL CFE 1.3/.
Reference: [15] <author> Phillip Hoschka and Christian Huitema. </author> <title> Automatic Genera tion of Optimized Code for Marshalling Routines. </title> <booktitle> In IFIP Conference of Upper Layer Protocols, Architectures and Ap plications ULPAA'94, </booktitle> <address> Barcelona, Spain, 1994. </address> <publisher> IFIP. </publisher>
Reference-contexts: An ILP-based implementation will reduce the excessive data manipulation operations which is essential for RISC based architectures. Another technique to improve overall marshaling performance is to use a hybrid scheme <ref> [15] </ref> in which frequently transferred data types can be marshaled using fast, but large compiled stubs. In contrast, an interpretive scheme can be used to marshal data types that are seldom transferred. <p> Thus, in this scheme there is no necessity to decipher the type of the data to be marshaled at run-time. Instead, the type is known in advance, which can be used to marshal the data directly. <ref> [15] </ref> describes the tradeoffs of using compiled and inter preted marshaling schemes. Although compiled stubs are faster, they are also larger. In contrast, interpretive marshaling is slower, but smaller in size. [15] describes a hybrid scheme that combines compiled and interpretive marshaling to achieve better performance. <p> Instead, the type is known in advance, which can be used to marshal the data directly. <ref> [15] </ref> describes the tradeoffs of using compiled and inter preted marshaling schemes. Although compiled stubs are faster, they are also larger. In contrast, interpretive marshaling is slower, but smaller in size. [15] describes a hybrid scheme that combines compiled and interpretive marshaling to achieve better performance. This work was done in the context of the ASN.1/BER encoding [17]. <p> TAO is being used to compare the impact of using compiled marshaling stubs and skeletons vs. the interpretive scheme currently implemented in SunSoft IIOP. We plan to measure the tradeoffs of using the two marshaling schemes to achieve an optimal hybrid solution <ref> [15] </ref>. In addition, we have incorporated an Real-time Object Adapter [14] that supports de-layered active request demul 8 The SunSoft front-end CORBA IDL compiler is also freely available from ftp://ftp.omg.org/pub/OMG IDL CFE 1.3/.
Reference: [16] <institution> Pure Software Inc. </institution> <note> Quantify User's Guide. </note> <institution> Pure Software Inc., </institution> <year> 1996. </year>
Reference-contexts: These buffers were repeatedly sent until a total of 64 Mbytes of data was transmitted. 3.1.3 Profiling Tools The profile information for the empirical analysis was obtained using the Quantify <ref> [16] </ref> performance measurement tool. Quantify analyzes performance bottlenecks and identifies sections of code that dominate execution time. Unlike traditional sampling-based profilers (such as the UNIX gprof tool), Quantify reports results without including its own overhead.
Reference: [17] <author> International Organization for Standardization. </author> <title> Information processing systems Open Systems Interconnection Specifi cation of Basic Encoding Rules for Abstract Syntax No tation One (ASN.1), </title> <month> May </month> <year> 1987. </year>
Reference-contexts: Although compiled stubs are faster, they are also larger. In contrast, interpretive marshaling is slower, but smaller in size. [15] describes a hybrid scheme that combines compiled and interpretive marshaling to achieve better performance. This work was done in the context of the ASN.1/BER encoding <ref> [17] </ref>. According to the SunSoft IIOP developers, interpretive marshaling is preferable since it decreases code size and increases the likelihood of remaining in the processor cache. As explained in Section 5, we are currently implementing a CORBA IDL compiler [13] that can generate compiled stubs and skeletons.
Reference: [18] <author> Steven McCanne and Van Jacobson. </author> <title> The BSD Packet Filter: </title>
Reference-contexts: We demonstrate the application of this principle to IIOP in Section 3.2.4 where we eliminated unnecessary calls to the deep free method, which frees primitive data types. [3] cautions against improper use of ILP since this may increase processor cache misses. Packet filters <ref> [18, 2, 8] </ref> are a classic example of Principle 6, which recommends passing information between layers. A packet filter demultiplexes incoming packets to the appropriate target application (s).
References-found: 18

