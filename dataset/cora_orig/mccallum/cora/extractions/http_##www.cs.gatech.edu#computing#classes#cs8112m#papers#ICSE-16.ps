URL: http://www.cs.gatech.edu/computing/classes/cs8112m/papers/ICSE-16.ps
Refering-URL: http://www.cs.gatech.edu/computing/classes/cs8112m/wi95/
Root-URL: 
Title: SAAM: A Method for Analyzing the Properties of Software Architectures*  
Author: Rick Kazman, , Len Bass, Gregory Abowd, Mike Webb , 
Keyword: Software Architecture; Analysis Methods; User Interfaces User Interface Architectures  
Abstract: While software architecture has become an increasingly important research topic in recent years, insufficient attention has been paid to methods for evaluation of these architectures. Evaluating architectures is difficult for two main reasons. First, there is no common language used to describe different architectures. Second, there is no clear way of understanding an architecture with respect to an organizations life cycle concernssoftware quality concerns such as maintainability, portability, modularity, reusability, and so forth. This paper addresses these shortcomings by describing three perspectives by which we can understand the description of a software architecture and then proposing a five-step method for analyzing software architectures called SAAM (Software Architecture Analysis Method). We illustrate the method by analyzing three separate user interface architec tures with respect to the quality of modifiability.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abowd, G., Bass, L., Howard, L., Northrop, L. </author> <title> Structural Modeling: an Application Framework and Development Process for Flight Simulators. </title> <institution> Software Engineering Institute, Carnegie Mellon University Technical Report CMU-SEI-TR-93-14. </institution> <address> Pittsburgh, PA, </address> <year> 1993. </year>
Reference-contexts: Such computational and coordination models should be explicit in an architectural description <ref> [1] </ref>. However, we do not include such information in our lexicon. 2.3 Allocation The allocation of function to structure identifies how the domain functionality is realized in the software structure. <p> We may also have language or tool support. We recognize that an analysis of these other types of support is an important topic for future research. Quality attributes is a recognized driver for software architectural design, outside of the user interface domain (e.g., the structural model for ight simulators) <ref> [1] </ref>. Consequently, we believe SAAM will work for other attributes. This method of evaluation shows the degree to which an architecture was designed to support selected quality attributes. We see a strong link between quality attributes and canonical partitionings.
Reference: [2] <author> Abowd. G., Allen, R., Garlan, G. </author> <title> Using Style to Understand Descriptions of Software Architectures. </title> <journal> Software Engineering Notes, </journal> <volume> 18(5) </volume> <pages> 9-20, </pages> <year> 1993. </year> <booktitle> Proceedings of SIGSOFT 93: Symposium on the Foundations of Software Engineering. </booktitle>
Reference-contexts: They also promote the use of a small lexicon of elements to portray structure as do Abowd, Allen and Garlan <ref> [2] </ref> and Garlan and Shaw [8]. Our small lexicon, however, resulted more because it was sufficient for the task at hand and not out of any conviction that a small vocabulary was essential.
Reference: [3] <author> Bass, L., Clapper, B., Hardy, E., Kazman, R., Seacord, R. Serpent: </author> <title> A User Interface Management System. </title> <booktitle> Proceedings of the Winter 1990 USENIX Conference, </booktitle> <address> Berkeley, CA, </address> <month> January </month> <year> 1990, </year> <pages> 245-258. </pages>
Reference-contexts: Superimposed on that structural description will be the allocation of domain function given by the Arch/Slinky canonical functional partitioning. 3.2 Serpent Serpent identifies a dialogue controller, the presentation and the application as three distinct pro 7 cesses in its architecture <ref> [3] </ref>, as shown in Figure 2. Application modules contain the computational semantics required for the application. Although there can theoretically be many different applications contained within a given run-time instance of Serpent, there is typically only one.
Reference: [4] <author> Bass, L. and Coutaz, J. </author> <title> Developing Software for the User Interface, </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Having said that, there is a clear contribution in our work for the user interface development community. There is an abundance of literature which takes a taxonomic approach to classifying the many user interface development tools <ref> [4] </ref> [11] [14].
Reference: [5] <author> Bass, L. Kazman, R. and Abowd, G. </author> <title> Issues in the Evaluation of User Interface Tools. </title> <booktitle> Proceedings of the ICSE Workshop on Software Engineering and Human-Computer Interaction, </booktitle> <address> Sorrento, Italy, </address> <month> May, </month> <year> 1993. </year> <month> Forthcoming </month>
Reference-contexts: This method of evaluation shows the degree to which an architecture was designed to support selected quality attributes. We see a strong link between quality attributes and canonical partitionings. More than one canonical partitioning is possible for a given domain, each accommodating a different set of quality attributes <ref> [5] </ref>. For example, the multiagent PAC model [7] is a candidate canonical partitioning which emphasizes development time efficiency. Finally, what is really desirable is to have metrics for more precisely evaluating attributes in terms of architectures, but our understanding of this topic is not yet sufficient to define any measurements.
Reference: [6] <author> Briand, L.C., Morasca, S. and Basili, </author> <title> V.R. Measuring and Assessing Maintainability at the End of High Level Design, </title> <booktitle> Proceedings of the IEEE conference on Software Maintenance, </booktitle> <address> Montreal, Canada, </address> <year> 1993. </year>
Reference-contexts: Stevens, Myers and Constantine [26] introduced the notions of module coupling and cohesion to evaluate alternatives for program decomposition. The software metrics community has used these notions to define predictive measures of software quality (see, for example, the work by Bri-and, Morasca and Basili <ref> [6] </ref>). Our analysis method appeals to a more abstract evaluation of how the architecture fulfills the domain functionality and other nonfunctional qualities. We do not present any metrics for predictive evaluation, but instead present an example-based method for performing a more qualitative evaluation.
Reference: [7] <author> Coutaz, J. </author> <title> PAC, An Implementation Model for Dialog Design, </title> <booktitle> Proceedings of Interact 87, </booktitle> <address> Stuttgart, </address> <month> September, </month> <year> 1987, </year> <pages> 431-436. </pages>
Reference-contexts: We see a strong link between quality attributes and canonical partitionings. More than one canonical partitioning is possible for a given domain, each accommodating a different set of quality attributes [5]. For example, the multiagent PAC model <ref> [7] </ref> is a candidate canonical partitioning which emphasizes development time efficiency. Finally, what is really desirable is to have metrics for more precisely evaluating attributes in terms of architectures, but our understanding of this topic is not yet sufficient to define any measurements.
Reference: [8] <author> Garlan, D., Shaw, M. </author> <title> An Introduction to Software Architecture. </title> <booktitle> Advances in Software Engineering and Knowledge Engineering, Volume I, </booktitle> <publisher> World Scientific Publishing, </publisher> <year> 1993. </year> <month> Forthcoming. </month>
Reference-contexts: They also promote the use of a small lexicon of elements to portray structure as do Abowd, Allen and Garlan [2] and Garlan and Shaw <ref> [8] </ref>. Our small lexicon, however, resulted more because it was sufficient for the task at hand and not out of any conviction that a small vocabulary was essential. We are not original in our desire to predict the quality of a software product from a higher level design description.
Reference: [9] <author> Green, J., Selby, B. </author> <title> Dynamic Planning and Software Maintenance: A Fiscal Approach. </title> <institution> Naval Postgraduate School, </institution> <address> Monterey, CA, </address> <note> NTIS Report AD-A112 801/6, </note> <year> 1981. </year>
Reference-contexts: This is an increasingly important segment of the software market. According to a study by Green and Selby, the average age of all software is increasing <ref> [9] </ref>. In systems such as these, modifiability is of paramount importance. In the domain of user interface development, modifiability is frequently cited as a motivating factor for a particular architecture, since some changes are very common.
Reference: [10] <author> Henry, S., Kafura, D. </author> <title> Software Structure Metrics Based on Information Flow, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(5), </volume> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: For now, we simply have ways to analyze, compare and rank architectures. We believe that the work of Henry and Kafura <ref> [10] </ref> on information ow points the way to an analysis technique for architectures, but it must be augmented by techniques for measuring the understandability and consistency of architectures. 7 Acknowledgments We would very much like to thank Brian Boesch of ARPA and Dick Martin of the School of Computer Science at
Reference: [11] <author> Hix, D. </author> <title> Generations of User-Interface Management Systems, </title> <journal> IEEE Software, </journal> <volume> 7(5) </volume> <pages> 77-87, </pages> <year> 1990. </year>
Reference-contexts: Having said that, there is a clear contribution in our work for the user interface development community. There is an abundance of literature which takes a taxonomic approach to classifying the many user interface development tools [4] <ref> [11] </ref> [14].
Reference: [12] <author> Hix, D., Hartson, H. </author> <title> Formative Evaluation: Ensuring Usability in User Interfaces, </title> <editor> in Bass, L., Dewan, P. (eds.) </editor> <booktitle> User Interface Software, </booktitle> <address> Chichester: </address> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference: [13] <institution> Military Standard, Defense System Software Development (DOD-STD-2167A). Washington, D.C.: United States Department of Defense, </institution> <year> 1988. </year>
Reference-contexts: These perspectives reect a consensus within the software engineering community, as witnessed by the literature ([8], [25], [22], <ref> [13] </ref>). We will discuss each of these perspectives in turn. 2.1 Functionality A systems functionality is what the system does. It may be a single function or a bundle of related functions which together describe the systems overall behavior.
Reference: [14] <author> Myers, B. </author> <title> User-Interface Tools: Introduction and Survey, </title> <journal> IEEE Software, </journal> <volume> 6(1) </volume> <pages> 47-61, </pages> <year> 1989. </year>
Reference-contexts: Having said that, there is a clear contribution in our work for the user interface development community. There is an abundance of literature which takes a taxonomic approach to classifying the many user interface development tools [4] [11] <ref> [14] </ref>.
Reference: [15] <author> Myers, B., Giuse, D., Dannenberg, R., Vander Zanden, B., Kosbie, D., Marchal, P., Pervin, E. Mickish, A., Landay, J., McDaniel, R., Hopkins, D., </author> <title> The Garnet Reference Manuals. </title> <institution> School of Computer Science, Carnegie Mellon University Technical Report CMU-CS-90-117-R3, </institution> <year> 1992. </year>
Reference-contexts: The Interactors and Opal Graphics together strictly hide all of the X11 calls. Thus, Garnet widgets and applications do not have any window manager calls in them, only calls to the interactors, object-oriented graphics, constraints and object system. <ref> [15] </ref> Operating System KR object system X11 Common Lisp Constraint system Interactors Opal Graphics Widget set Garnet Applications 12 Given this analysis, we can re-draw Garnets architecture as follows: The X11 window system fills the physical interaction function.
Reference: [16] <author> Myers, B., Giuse, D., Dannenberg, R., Vander Zanden, B., Kosbie, D., Pervin, E., Mickish, A., Marchal, P. Garnet: </author> <title> Comprehensive Support for Graphical, Highly Interactive User Interfaces, </title> <journal> IEEE Computer, </journal> <volume> 23(11): </volume> <pages> 71-85. </pages>
Reference-contexts: This task is considerably more difficult when trying to compare architectures based upon their own representations and claims. What we have done is to develop a common language for making architectural comparisons. 3.4 Garnet The emphasis for systems developed under Garnet <ref> [16] </ref> is on control of the runtime behavior of interaction objects and the visual aspects of the interface. This is a different emphasis from Serpent and Chiron, which were expressly interested in maintainability and separation of concerns.
Reference: [17] <editor> Oskarsson, </editor> . <booktitle> Mechanisms of Modifiability in Large Software Systems. Linkping Studies in Science and Technology Dissertations No. </booktitle> <volume> 77, </volume> <year> 1982. </year>
Reference-contexts: These modifications are intended to approximately model the type and distribution of tasks which are typical of an organizations software development life cycle. This is why a set of example modifications is required. Oskarsson gives an informal characterization of classes of modifications in <ref> [17] </ref>.
Reference: [18] <author> Parnas, </author> <title> D.L. On the Criteria To Be Used in Decomposing Systems into Modules, </title> <journal> Communications of the ACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058, </pages> <year> 1972. </year> <month> 18 </month>
Reference-contexts: We are not original in our desire to predict the quality of a software product from a higher level design description. For example, Parnas <ref> [18] </ref> motivated the use of modularization or information hiding as a means of high-level system decomposition to improve exibility and comprehensibility. Stevens, Myers and Constantine [26] introduced the notions of module coupling and cohesion to evaluate alternatives for program decomposition.
Reference: [19] <author> Perry, D., Wolf, A. </author> <title> Foundations for the study of software architecture, </title> <booktitle> SIGSOFT Software Engineering Notes, </booktitle> <volume> 17(4), </volume> <month> October </month> <year> 1992, </year> <pages> 40-52. </pages>
Reference-contexts: That trend emphasizes a better understanding of general architectural concepts 3 as a foundation for the proof that a system meets more than just functional requirements. We agree with Perry and Wolf <ref> [19] </ref> that an architectural description provides multiple perspectives of different information, though their perspectives would rightly be considered as perspectives on structure in our terms.
Reference: [20] <author> Pfaff, G. (ed.). </author> <title> User Interface Management Systems. </title> <address> New York: </address> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: It is an extension of the Seeheim model of user interface management systems <ref> [20] </ref>, and is the result of wide discussion and agreement amongst user interface researchers and developers. Arch/Slinky identifies the following five basic functions of user interface software: Functional Core (FC). This component performs the data manipulation and other domain-oriented functions.
Reference: [21] <author> Pittman, J., Kitrick, C. VUIMS: </author> <title> A Visual User Interface Management System, </title> <booktitle> Proceedings of the ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <address> Snowbird, UT, </address> <month> October </month> <year> 1990, </year> <pages> 36-46. </pages>
Reference-contexts: However, it is often difficult to assess a developer's claims of qualities inherent in a software architecture. Examples of such claims are: We have developed user interface components that can be reconfigured with minimal effort. <ref> [21] </ref> Serpent encourages the separation of software systems into user interface and core application portions, a separation which will decrease the cost of subsequent modifications to the system. [23] This Nephew UIMS/Application interface is better that [sic] traditional UIMS/Application in terfaces from the modularity and code reusability point of views. [27]
Reference: [22] <author> Pressman, R. </author> <title> Software Engineering: a Practitioners Approach, </title> <booktitle> 3rd edition. </booktitle> <address> New York: </address> <publisher> McGraw-Hill, </publisher> <year> 1992. </year>
Reference-contexts: These perspectives reect a consensus within the software engineering community, as witnessed by the literature ([8], [25], <ref> [22] </ref>, [13]). We will discuss each of these perspectives in turn. 2.1 Functionality A systems functionality is what the system does. It may be a single function or a bundle of related functions which together describe the systems overall behavior.
Reference: [23] <author> Rumbaugh, J., Blaha, M., Premerlani, W., Eddy, F., Lorenson, W. </author> <title> Object-Oriented Modeling and Design, </title> <address> Englewood Cliffs, N.J.: </address> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Examples of such claims are: We have developed user interface components that can be reconfigured with minimal effort. [21] Serpent encourages the separation of software systems into user interface and core application portions, a separation which will decrease the cost of subsequent modifications to the system. <ref> [23] </ref> This Nephew UIMS/Application interface is better that [sic] traditional UIMS/Application in terfaces from the modularity and code reusability point of views. [27] The difficulty in assessing the validity of these claims arises for two reasons. First, the various architectural descriptions do not use a common vocabulary. <p> For large systems, a partitioning divides the behavior into a collection of functions which together comprise the systems function but which are individually simple to describe or otherwise conceptualize. Typically, a single systems functionality is decomposed through techniques such as structured analysis [31] or object-oriented analysis <ref> [23] </ref>, but this is not always the case.When discussing architectures for a collection of systems in some common domain, such as we are doing here, the functional partitioning is often the result of a domain analysis.
Reference: [24] <author> SEI, </author> <title> Serpent Overview, </title> <type> SEI Technical Report CMU/SEI-89-UG-2, </type> <institution> Carnegie Mellon University Software Engineering Institute, </institution> <month> August </month> <year> 1989. </year>
Reference: [25] <author> Sommerville, I. </author> <booktitle> Software Engineering, 4th edition. </booktitle> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: These perspectives reect a consensus within the software engineering community, as witnessed by the literature ([8], <ref> [25] </ref>, [22], [13]). We will discuss each of these perspectives in turn. 2.1 Functionality A systems functionality is what the system does. It may be a single function or a bundle of related functions which together describe the systems overall behavior. <p> We are only concerned with architectural support in this paper. We do not discuss other forms of support, such as language support as exemplified by the use of glue in Serpent, though we recognize their potential importance. 3.3 Chiron The Chiron architecture <ref> [25] </ref> was built with the expressed goals of addressing life cycle concerns of maintainability and sensitivity to environmental changes. A Chiron architecture consists of a client and a server. The client consists of an application, which exports a number of abstract data types (ADTs) which Chiron encapsulates within Dispatchers.
Reference: [26] <author> Stevens, W.P., Myers, G.J. and Constantine, </author> <title> L.L. Structured design, </title> <journal> IBM Systems Journal, </journal> <volume> 13(2) </volume> <pages> 115-139, </pages> <year> 1974. </year>
Reference-contexts: We are not original in our desire to predict the quality of a software product from a higher level design description. For example, Parnas [18] motivated the use of modularization or information hiding as a means of high-level system decomposition to improve exibility and comprehensibility. Stevens, Myers and Constantine <ref> [26] </ref> introduced the notions of module coupling and cohesion to evaluate alternatives for program decomposition. The software metrics community has used these notions to define predictive measures of software quality (see, for example, the work by Bri-and, Morasca and Basili [6]).
Reference: [27] <author> Szekely, P. </author> <title> Standardizing the Interface Between Applications and UIMSs, </title> <booktitle> Proceedings of the ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <address> Williamsburg, VA, </address> <month> November </month> <year> 1989, </year> <pages> 34-42. </pages>
Reference-contexts: [21] Serpent encourages the separation of software systems into user interface and core application portions, a separation which will decrease the cost of subsequent modifications to the system. [23] This Nephew UIMS/Application interface is better that [sic] traditional UIMS/Application in terfaces from the modularity and code reusability point of views. <ref> [27] </ref> The difficulty in assessing the validity of these claims arises for two reasons. First, the various architectural descriptions do not use a common vocabulary. When people develop new architectures, they typically develop new terms to describe them, or use old terms in a new way.
Reference: [28] <author> Taylor, R., Johnson, G. </author> <title> Separations of Concerns in the Chiron-1 User Interface Development and Management System, </title> <booktitle> Proceedings of InterCHI 93, </booktitle> <address> Amsterdam, </address> <month> May </month> <year> 1993, </year> <pages> 367-374. </pages>
Reference: [29] <author> Taylor, R. </author> <type> personal communication, </type> <month> July </month> <year> 1993. </year>
Reference-contexts: Once again, the location of these sorts of dialogue issues is not clear from Chirons architectural description. These dependencies might exist in the Artists or the ADTs. <ref> [29] </ref> The physical interaction component appears to be located in Chirons Virtual Window System component, and the logical interaction component is encapsulated within the ADL. As a result of this characterization, we can provisionally annotate the Chiron architecture as shown in Figure 5.
Reference: [30] <editor> UIMS Tool Developers Workshop, </editor> <title> A Metamodel for the Runtime Architecture of an Interactive System, </title> <journal> SIGCHI Bulletin, </journal> <volume> 24(1), </volume> <pages> 32-37. </pages>
Reference-contexts: Process Passive Data Repository Computational Uni-/Bi-directional Control Flow Uni-/Bi-directional Data Flow Component ( ) Active Data Repository Components Connections 6 3.1 The Arch/Slinky Metamodel The Arch/Slinky metamodel of user interface architectures <ref> [30] </ref> will serve as our canonical functional partitioning for this domain. It is an extension of the Seeheim model of user interface management systems [20], and is the result of wide discussion and agreement amongst user interface researchers and developers.
Reference: [31] <author> Yourdon, E. </author> <title> Modern Structured Analysis, </title> <address> Englewood Cliffs, N.J.: </address> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: For large systems, a partitioning divides the behavior into a collection of functions which together comprise the systems function but which are individually simple to describe or otherwise conceptualize. Typically, a single systems functionality is decomposed through techniques such as structured analysis <ref> [31] </ref> or object-oriented analysis [23], but this is not always the case.When discussing architectures for a collection of systems in some common domain, such as we are doing here, the functional partitioning is often the result of a domain analysis.
References-found: 31

