URL: http://www.research.microsoft.com/crypto/papers/thesis.ps
Refering-URL: http://www.research.microsoft.com/crypto/
Root-URL: http://www.research.microsoft.com
Title: Abstract Verifiable Secret-Ballot Elections  
Author: Josh Daniel Cohen Benaloh 
Date: 1996  
Affiliation: Yale University  
Abstract: Privacy in secret-ballot elections has traditionally been attained by using a ballot box or voting booth to disassociate voters from ballots. Although such a system might achieve privacy, there is often little confidence in the accuracy of the announced tally. This thesis describes a practical scheme for conducting secret-ballot elections in which the outcome of an election is verifiable by all participants and even by non-participating observers. All communications are public, yet under a suitable number-theoretic assumption, the privacy of votes remains intact. The tools developed here to conduct such elections have additional independent applications. Cryptographic capsules allow a prover to convince verifiers that either statement A or statement B is true without revealing substantial information as to which. Secret sharing homomorphisms enable computation on shared (secret) data and give a method of distributing shares of a secret such that each shareholder can verify the validity of all shares. 
Abstract-found: 1
Intro-found: 1
Reference: [AdHu87] <author> Adleman, L. and Huang, M. </author> <title> "Recognizing Primes In Random Polynomial Time." </title> <booktitle> Proc. 19 th ACM Symp. on Theory of Computing, </booktitle> <address> New York, NY (May 1987), </address> <pages> 462-469. </pages>
Reference: [Adle79] <author> Adleman, L. </author> <title> "Subexponential Algorithm for The Discrete Logarithm Problem." </title> <booktitle> Proc. 20 th IEEE Symp. on Foundations of Computer Science, </booktitle> <address> San Juan, PR (Oct. </address> <year> 1979), </year> <pages> 55-60. </pages>
Reference-contexts: The reader may observe the similarity between the problem of determining the residue class of a canonical root and that of evaluating discrete logarithms modulo a prime. Techniques for the latter problem can be applied directly to the former. (See [PoHe78], <ref> [Adle79] </ref>, [COS86] for work on the discrete logarithm problem.) 1 Thanks to Joe Kilian for pointing out this trick. 22 CHAPTER 2. <p> In general, discrete logarithms may be difficult to compute. However, if p is small or of one of a variety of special forms, the problem is tractable (see [PoHe78], <ref> [Adle79] </ref>, [COS86]). It should be emphasized that such special cases for p do not in any way weaken the security of our schemes. The security is not cryptographic, but rather is information theoretic. Therefore, there need be no assumptions about the difficulty of solving any special problems. 4.5.
Reference: [Adle80] <author> Adleman, L. </author> <title> "On Distinguishing Prime Numbers from Composite Numbers." </title> <booktitle> Proc. 21 st IEEE Symp. on Foundations of Computer Science, </booktitle> <address> Syracuse, NY (Oct. </address> <year> 1980), </year> <pages> 387-406. </pages>
Reference-contexts: In particular, Z r n n can be distinguished with a 1=P (jnj) advantage in this time. Proof: Apply lemma 2.29 with " = 1=P (N ). Adleman and McDonnell in [AdMc82] (see also [APR83], <ref> [Adle80] </ref>) show that an oracle which takes an r and a z and determines whether or not z is an r th residue (modulo n) can be used to generate an efficient (although not quite polynomial time) algorithm to factor n.
Reference: [AdMc82] <author> Adleman, L. and McDonnell, R. </author> <title> "An Application of Higher Reciprocity to Computational Number Theory." </title> <booktitle> Proc. 23 rd IEEE Symp. on Foundations of Computer Science, </booktitle> <address> Chicago, IL (Nov. </address> <year> 1982), </year> <pages> 100-106. </pages>
Reference-contexts: In particular, Z r n n can be distinguished with a 1=P (jnj) advantage in this time. Proof: Apply lemma 2.29 with " = 1=P (N ). Adleman and McDonnell in <ref> [AdMc82] </ref> (see also [APR83], [Adle80]) show that an oracle which takes an r and a z and determines whether or not z is an r th residue (modulo n) can be used to generate an efficient (although not quite polynomial time) algorithm to factor n.
Reference: [AFK87] <author> Abadi, M., Feigenbaum, J., and Kilian, J. </author> <title> "On Hiding Information from an Oracle." </title> <booktitle> Proc. 19 th ACM Symp. on Theory of Computing, </booktitle> <address> New York, NY (May 1987), </address> <pages> 195-203. </pages>
Reference: [Angl82] <author> Angluin, D. </author> <title> "Lecture Notes on the Complexity of Some Problems in Number Theory." </title> <institution> TR-243, Yale University, Department of Computer Science, </institution> <address> New Haven, CT (Aug. </address> <year> 1982). </year>
Reference: [AnLi83] <author> Angluin, D. and Lichtenstein, D. </author> <title> "Provable Security of Cryp-tosystems: a Survey." </title> <institution> TR-288, Yale University, Department of Computer Science, </institution> <address> New Haven, CT (Oct. </address> <year> 1983). </year> <note> 117 118 BIBLIOGRAPHY </note>
Reference-contexts: The essence of Lemma 2.7 is captured in more general terms by Angluin and Lichtenstein in <ref> [AnLi83] </ref> as the so called property of random self-reducibility. They point out that this property is common to a wide variety of number-theoretic problems and "can be used to show a problem is uniformly hard if it is hard at all".
Reference: [APR83] <author> Adleman, L., Pomerance, C., and Rumley, R. </author> <title> "On Distinguishing Prime Numbers from Composite Numbers." </title> <journal> Annals of Math. </journal> <volume> 117, </volume> <year> (1983), </year> <pages> 173-206. </pages>
Reference-contexts: In particular, Z r n n can be distinguished with a 1=P (jnj) advantage in this time. Proof: Apply lemma 2.29 with " = 1=P (N ). Adleman and McDonnell in [AdMc82] (see also <ref> [APR83] </ref>, [Adle80]) show that an oracle which takes an r and a z and determines whether or not z is an r th residue (modulo n) can be used to generate an efficient (although not quite polynomial time) algorithm to factor n.
Reference: [Arro63] <author> Arrow, K. </author> <title> Social Choice and Individual Values. </title> <publisher> John Wiley and Sons, </publisher> <address> New York (1963). </address>
Reference: [AsBl80] <author> Asmuth, C. and Bloom, J. </author> <title> "A Modular Approach to Key Safeguarding." </title> <institution> Texas A&M University, Department of Mathematics, College Station, </institution> <address> TX (1980). </address>
Reference-contexts: SECRET SHARING HOMOMORPHISMS (2) knowledge of any k 1 or fewer D i pieces leaves D completely undetermined (in the sense that all its possible values are equally likely). The pieces of a secret are often called shares. Since 1979, several different threshold schemes have been proposed (see [Blak79], <ref> [AsBl80] </ref>, and [Koth84] for some examples), and they have proved to be useful in a wide variety of interactive protocols. The threshold scheme originally proposed by Shamir in [Sham79] is the best known and is very simple and elegant. <p> Many other known threshold schemes are also (+; +)-homomorphic. The threshold schemes found in [Blak79], <ref> [AsBl80] </ref>, and [Koth84], for example, are all (+; +)-homomorphic. What if the desired composite secret is not the sum of the constituent secrets? Shamir's scheme is not (fi; fi)-composite. This is because the product of two non-constant polynomials is of higher degree than the factors.
Reference: [Baba85] <author> Babai, L. </author> <title> "Trading Group Theory for Randomness." </title> <booktitle> Proc. 17 th ACM Symp. on Theory of Computing, </booktitle> <address> Providence, RI (May 1985), </address> <pages> 421-429. </pages>
Reference: [Bena86a] <author> Benaloh, J. </author> <title> "Cryptographic Capsules: A Disjunctive Primitive for Interactive Protocols." </title> <booktitle> Crypto '86, </booktitle> <address> Santa Barbara, CA (Aug. </address> <year> 1986). </year>
Reference: [Bena86b] <author> Benaloh, J. </author> <title> "Secret Sharing Homomorphisms: Keeping Shares of a Secret Secret." </title> <booktitle> Crypto '86, </booktitle> <address> Santa Barbara, CA (Aug. </address> <year> 1986). </year>
Reference: [BenO81] <author> Ben-Or, M. </author> <title> "Probabilistic Algorithms in Finite Fields." </title> <booktitle> Proc. 22 nd IEEE Symp. on Foundations of Computer Science, </booktitle> <address> Nashville, TN (Oct. </address> <year> 1981), </year> <pages> 394-398. </pages>
Reference: [BenO83] <author> Ben-Or, M. </author> <title> "Another Advantage of Free Choice: Completely Asynchronous Agreement Protocols." </title> <booktitle> Proc. 2 nd ACM Symp. on Principles of Distributed Computing, </booktitle> <address> Montreal, PQ (Aug. </address> <year> 1983), </year> <pages> 27-30. </pages>
Reference-contexts: In practice, implementing such bulletin boards may be a problem unto itself. See [Fisc83] for a survey of the literature on this problem as well as <ref> [BenO83] </ref> and [Rabi83b] for some probabilistic approaches. 5.3. ELECTION DEFINITIONS 73 In addition, there is a publicly-readable number N called a security parameter which serves as the (only) input to each process. N controls the likelihood that the election is correct and that privacy is maintained.
Reference: [BeYu86] <author> Benaloh, J. and Yung, M. </author> <title> "Distributing the Power of a Government to Enhance the Privacy of Voters." </title> <booktitle> Proc. 5 th ACM Symp. on Principles of Distributed Computing, </booktitle> <address> Calgary, AB (Aug. </address> <year> 1986), </year> <pages> 52-62. </pages>
Reference-contexts: In fact, for a given security parameter N , the density in the [GoMi84] scheme is only 1=N while in this scheme it is (log r)=(N + log r) and thus can be made arbitrarily close to 1 by increasing r. This approach is described in the appendix of <ref> [BeYu86] </ref>. 2.8 The Prime Residuosity Assumption Section 2.7 describes how values may be encrypted using an election encryption function E , and section 2.5 shows how such an encryption function can be decrypted when the factorization of the associated n is known. <p> The first version of this work was given by Cohen (Benaloh) and Fischer in [CoFi85]. Various improvements and extensions were given by Cohen (Benaloh) in [Cohe86] and by Benaloh and Yung in <ref> [BeYu86] </ref>.
Reference: [Blak79] <author> Blakley, G. </author> <title> "Safeguarding Cryptographic Keys." </title> <booktitle> Proc. AFIPS 1979 National Computer Conference, </booktitle> <address> New York, NY (June 1979), 313-317. BIBLIOGRAPHY 119 </address>
Reference-contexts: SECRET SHARING HOMOMORPHISMS (2) knowledge of any k 1 or fewer D i pieces leaves D completely undetermined (in the sense that all its possible values are equally likely). The pieces of a secret are often called shares. Since 1979, several different threshold schemes have been proposed (see <ref> [Blak79] </ref>, [AsBl80], and [Koth84] for some examples), and they have proved to be useful in a wide variety of interactive protocols. The threshold scheme originally proposed by Shamir in [Sham79] is the best known and is very simple and elegant. <p> Many other known threshold schemes are also (+; +)-homomorphic. The threshold schemes found in <ref> [Blak79] </ref>, [AsBl80], and [Koth84], for example, are all (+; +)-homomorphic. What if the desired composite secret is not the sum of the constituent secrets? Shamir's scheme is not (fi; fi)-composite. This is because the product of two non-constant polynomials is of higher degree than the factors.
Reference: [BlMe85] <author> Blakley, G. and Meadows, C. </author> <title> "A Database Encryption Scheme Which Allows the Computation of Statistics Using Encrypted Data." </title> <booktitle> Proc. IEEE Symposium on Computer Security and Privacy, </booktitle> <address> Oakland, CA (Apr. </address> <year> 1985), </year> <pages> 116-122. </pages>
Reference: [BrCr86] <author> Brassard, G. and Crepeau, C. </author> <title> "Zero-Knowledge Simulation of Boolean Circuits." </title> <booktitle> Crypto '86, </booktitle> <address> Santa Barbara, CA (Aug. </address> <year> 1986). </year>
Reference-contexts: The method uses capsules to give a zero-knowledge protocol to interactively prove that a given Boolean formula (or arbitrary Boolean circuit with in-degree 2) has a satisfying assignment. Brassard and Crepeau in <ref> [BrCr86] </ref> independently of both this work and [GMW86] have achieved the same result, and Chaum in [Chau86a] has also independently achieved a very similar result. The major advantage of this method over the original is efficiency.
Reference: [CGMA85] <author> Chor, B., Goldwasser, S., Micali, S., and Awerbuch, B. </author> <title> "Verifiable Secret Sharing and Achieving Simultaneity in the Presence of Faults." </title> <booktitle> Proc. 26 th IEEE Symp. on Foundations of Computer Science, </booktitle> <address> Portland, OR (Oct. </address> <year> 1985), </year> <pages> 383-395. </pages>
Reference-contexts: This problem was first described by Chor, Goldwasser, Micali, and Awerbuch in <ref> [CGMA85] </ref> and the application of secret sharing homomorphisms to this problem was developed as a result of an observation made by Oded Goldreich.
Reference: [Chau81] <author> Chaum, D. </author> <title> "Untraceable Electronic Mail, Return Addresses, and Digital Pseudonyms." </title> <journal> Comm. ACM 24, </journal> <volume> 2, </volume> <month> (Feb. </month> <year> 1981), </year> <pages> 84-88. </pages>
Reference: [Chau86a] <author> Chaum, D. </author> <title> "Demonstrating that a Public Predicate can be Satisfied Without Revealing Any Information About How." </title> <booktitle> Crypto '86, </booktitle> <address> Santa Barbara, CA (Aug. </address> <year> 1986). </year>
Reference-contexts: The method uses capsules to give a zero-knowledge protocol to interactively prove that a given Boolean formula (or arbitrary Boolean circuit with in-degree 2) has a satisfying assignment. Brassard and Crepeau in [BrCr86] independently of both this work and [GMW86] have achieved the same result, and Chaum in <ref> [Chau86a] </ref> has also independently achieved a very similar result. The major advantage of this method over the original is efficiency.
Reference: [Chau86b] <author> Chaum, D. </author> <title> "Elections with Unconditionally Secret-Ballots and Disruption Equivalent to Breaking RSA." </title> <note> unpublished manuscript (1986). </note>
Reference: [CoFi85] <author> Cohen, J. and Fischer, M. </author> <title> "A Robust and Verifiable Cryptographically Secure Election Scheme." </title> <booktitle> Proc. 26 th IEEE Symp. on Foundations of Computer Science, </booktitle> <address> Portland, OR (Oct. </address> <year> 1985), </year> <pages> 372-382. </pages>
Reference-contexts: Secondly, the methods of Goldreich, Micali, and Wigderson are, although polynomially bounded, far beyond practicality, while the given schema is shown to be within the bounds of practicality with current technology. The first version of this work was given by Cohen (Benaloh) and Fischer in <ref> [CoFi85] </ref>. Various improvements and extensions were given by Cohen (Benaloh) in [Cohe86] and by Benaloh and Yung in [BeYu86].
Reference: [Cohe86] <author> Cohen, J. </author> <title> "Improving Privacy in Cryptographic Elections." </title> <institution> TR-454, Yale University, Department of Computer Science, </institution> <address> New Haven, CT (Feb. </address> <year> 1986). </year>
Reference-contexts: The first version of this work was given by Cohen (Benaloh) and Fischer in [CoFi85]. Various improvements and extensions were given by Cohen (Benaloh) in <ref> [Cohe86] </ref> and by Benaloh and Yung in [BeYu86]. <p> This solution is described in somewhat greater detail in <ref> [Cohe86] </ref>. 5.12.4 Related Schemas In addition to the election schema presented in this chapter, a number of related schemas which all conform to the election paradigm of Figure 5.1 can be devised.
Reference: [COS86] <author> Coppersmith, D., Odlyzko, A., and Schroeppel, R. </author> <title> "Discrete Logarithms in GF (p)." </title> <journal> Algorithmica, </journal> <volume> 1 (1986), </volume> <pages> 1-15. </pages>
Reference-contexts: The reader may observe the similarity between the problem of determining the residue class of a canonical root and that of evaluating discrete logarithms modulo a prime. Techniques for the latter problem can be applied directly to the former. (See [PoHe78], [Adle79], <ref> [COS86] </ref> for work on the discrete logarithm problem.) 1 Thanks to Joe Kilian for pointing out this trick. 22 CHAPTER 2. <p> In general, discrete logarithms may be difficult to compute. However, if p is small or of one of a variety of special forms, the problem is tractable (see [PoHe78], [Adle79], <ref> [COS86] </ref>). It should be emphasized that such special cases for p do not in any way weaken the security of our schemes. The security is not cryptographic, but rather is information theoretic. Therefore, there need be no assumptions about the difficulty of solving any special problems. 4.5. <p> One of these schemas is based upon the difficulty of computing the discrete logarithm modulo a known prime ([Adle79], [PoHe78], <ref> [COS86] </ref>). Another is based upon the difficulty of determining the order of an element modulo the product of two unknown primes. A third proposed schema encrypts a vote using the low order bit of a message encrypted by RSA [RSA78].
Reference: [DiHe76] <author> Diffie, W. and Hellman, M. </author> <title> "New Directions in Cryptography." </title> <journal> IEEE Trans. on Information Theory 22, </journal> <volume> 6, </volume> <month> (Nov. </month> <year> 1976), </year> <pages> 644-654. 120 BIBLIOGRAPHY </pages>
Reference: [DLM82] <author> DeMillo, R., Lynch, N. and Merritt, M. </author> <title> "Cryptographic Protocols." </title> <booktitle> Proc. 14 th ACM Symp. on Theory of Computing, </booktitle> <address> San Fran-cisco, CA (May 1982), </address> <pages> 383-400. </pages>
Reference-contexts: RELATED WORK 71 5.2 Related Work Various cryptographic schemas have been proposed for boardroom voting in which participants pass encrypted messages from one to another while performing encryption and decryption operations until a certain point is reached at which all are confident of the outcome of the vote (see <ref> [DLM82] </ref>, [Merr83], and [Yao82a]). These all share the problems that the active participants must be known in advance and if one participant stops following its protocol during the election, the election cannot continue. Thus these boardroom schemas are not well suited for large-scale elections.
Reference: [Feig85] <author> Feigenbaum, J. </author> <title> "Encrypting Problem Instances or Can You Take Advantage of Someone Without Having to Trust Him", </title> <booktitle> Proc. Crypto '85, </booktitle> <address> Santa Barbara, CA (Aug. </address> <year> 1985), </year> <pages> 477-488. </pages> <note> Published as Advances in Cryptology, </note> <editor> ed. by H. </editor> <booktitle> Williams in Lecture Notes in Computer Science, </booktitle> <volume> vol. 218, </volume> <editor> ed. by G. Goos and J. Hartmanis. </editor> <publisher> Springer-Verlag, </publisher> <address> New York (1985). </address>
Reference-contexts: This may be desirable in a number of circumstances in which computation on secret data is desired. [RAD78], [Yao82a], <ref> [Feig85] </ref>, and [GMW87] discuss problems of this sort, and it will be seen that verifiable secret sharing and verifiable secret-ballot elections can be modeled in this way. It seems, however, that the homomorphism property is not strong enough for these applications.
Reference: [Fisc83] <author> Fischer, M. </author> <title> "The Consensus Problem in Unreliable Distributed Systems", </title> <booktitle> Proc. 1983 International FCT-Conference, </booktitle> <address> Borgholm, Sweeden (Aug. </address> <year> 1983), </year> <pages> 127-140. </pages> <note> Published as Foundations of Computation Theory, </note> <editor> ed. by M. </editor> <booktitle> Karpinski in Lecture Notes in Computer Science, </booktitle> <volume> vol. 158, </volume> <editor> ed. by G. Goos and J. Hartmanis. </editor> <publisher> Springer-Verlag, </publisher> <address> New York (1983). </address>
Reference-contexts: Each bulletin board can be read by every process, but it can only be written by its owner, and then only by appending new messages, not by altering old ones. In practice, implementing such bulletin boards may be a problem unto itself. See <ref> [Fisc83] </ref> for a survey of the literature on this problem as well as [BenO83] and [Rabi83b] for some probabilistic approaches. 5.3. ELECTION DEFINITIONS 73 In addition, there is a publicly-readable number N called a security parameter which serves as the (only) input to each process.
Reference: [FMR84] <author> Fischer, M., Micali, S., and Rackoff, C. </author> <title> "A Secure Protocol for the Oblivious Transfer." </title> <booktitle> Presented at Eurocrypt '84, Paris, France (Apr. 1984). (Not in proceedings.) </booktitle>
Reference-contexts: Capsules are used in and further the capabilities of so called interactive proofs. The notion of interactive proofs was introduced and first used by Goldwasser and Micali in [GoMi83]. The ideas were further developed by the original authors together with Fischer and Rackoff in <ref> [FMR84] </ref> and [GMR85]. The fundamental idea is an extension of the notion of a formal proof to what might be called a convincing argument.
Reference: [Fort87] <author> Fortnow, L. </author> <title> "The Complexity of Perfect Zero-Knowledge." </title> <booktitle> Proc. 19 th ACM Symp. on Theory of Computing, </booktitle> <address> New York, NY (May 1987), </address> <pages> 204-209. </pages>
Reference: [Gaus01] <author> Gauss, C. Disquisitiones Arithmeticae. </author> <title> (1801). Translated by Arthur A. </title> <publisher> Clarke and published by Yale University Press, </publisher> <address> New Haven (1966). </address> <publisher> Reprinted by Springer-Verlag, </publisher> <address> New York (1986). </address>
Reference: [GHY85] <author> Galil, Z., Haber, S., and Yung, M. </author> <title> "A Private Interactive Test of a Boolean Predicate and Minimum-Knowledge Public-Key Cryp-tosystems." </title> <booktitle> Proc. 26 th IEEE Symp. on Foundations of Computer Science, </booktitle> <address> Portland, OR (Oct. </address> <year> 1985), </year> <pages> 372-382. </pages>
Reference-contexts: This is because, for each challenge w presented to Alice by Bob, Alice need only decide the class of w from among two possible residue classes (RC [0] and RC [1]) instead of from among all r possible residue classes. 3.3.3 Result-indistinguishable Residuosity <ref> [GHY85] </ref> generalizes the result of [GMR85] in such a way that an observer, Carol, watching the protocol between Alice and Bob gains no information from the protocol as to whether Alice convinced Bob that a given z was or was not a quadratic residue. <p> Z consists of elements of the same class as z, and members of Z can be randomly generated by multiplying z by randomly chosen members of Z 2 n . By using three-component capsules, the protocol given in <ref> [GHY85] </ref> can be simplified tremendously. Bob simply prepares N master capsules C i , each consisting of one member of each of X, Y , and Z. For each C i , Bob also prepares N 0 additional scratch capsules of the same form.
Reference: [GMR85] <author> Goldwasser, S., Micali, S., and Rackoff C. </author> <title> "The Knowledge Complexity of Interactive Proof-Systems." </title> <booktitle> Proc. 17 th ACM Symp. on Theory of Computing, </booktitle> <address> Providence, RI (May 1985), 291-304. BIBLIOGRAPHY 121 </address>
Reference-contexts: Capsules are used in and further the capabilities of so called interactive proofs. The notion of interactive proofs was introduced and first used by Goldwasser and Micali in [GoMi83]. The ideas were further developed by the original authors together with Fischer and Rackoff in [FMR84] and <ref> [GMR85] </ref>. The fundamental idea is an extension of the notion of a formal proof to what might be called a convincing argument. <p> Thus, it can be argued that, beyond being convinced that z 2 Z r n , Bob has learned nothing from the exchange. The limited disclosure of information seen in the interactive proof of figure 3.2 is the essence of "zero-knowledge" as defined by Goldwasser, Micali, and Rackoff in <ref> [GMR85] </ref>. The notion of zero-knowledge stems from the attempt to capture the intuition that Bob has learned nothing from the interactive proof besides that which is entailed by the claim of the proof itself. <p> In this case, in fact, there is a symmetry between multiplication and division, so the entire interactive proof can be completed without computing inverses. The interactive proof given here represents a significant simplification of the original interactive proof of quadratic non-residuosity given in <ref> [GMR85] </ref>. 3.3. <p> This is because, for each challenge w presented to Alice by Bob, Alice need only decide the class of w from among two possible residue classes (RC [0] and RC [1]) instead of from among all r possible residue classes. 3.3.3 Result-indistinguishable Residuosity [GHY85] generalizes the result of <ref> [GMR85] </ref> in such a way that an observer, Carol, watching the protocol between Alice and Bob gains no information from the protocol as to whether Alice convinced Bob that a given z was or was not a quadratic residue. The key addition to the protocol of [GMR85] is the inclusion of <p> generalizes the result of <ref> [GMR85] </ref> in such a way that an observer, Carol, watching the protocol between Alice and Bob gains no information from the protocol as to whether Alice convinced Bob that a given z was or was not a quadratic residue. The key addition to the protocol of [GMR85] is the inclusion of a third set of possibilities. Instead of choosing w from among just the two sets X = RC [0] and Y = RC [1], Bob may select from an additional set Z. <p> Their original protocol closely followed the non-residuosity protocol of <ref> [GMR85] </ref>. In [GMW86], a prover designates a graph H given by the verifier as either a permutation of graph G 1 or of graph G 2 after being convinced that the verifier already holds such a permutation. <p> a permutation of G 2 | are used to interactively prove that a given graph H is a permutation of either G 1 or G 2 . 3.3.5 Boolean Circuit Satisfiability Recently (also in [GMW86]), Goldreich, Micali, and Wigderson gave a simple and elegant zero-knowledge interactive protocol (as defined in <ref> [GMR85] </ref>) to prove for any k that a graph is k-colorable without revealing any information about a specific coloring (assuming that the prover possesses a k-coloring of the graph).
Reference: [GMT82] <author> Goldwasser, S., Micali, S., and Tong, P. </author> <title> "Why and How to Establish a Private Code On a Public Network." </title> <booktitle> Proc. 23 rd IEEE Symp. on Foundations of Computer Science, </booktitle> <address> Chicago, IL (Nov. </address> <year> 1982), </year> <pages> 134-144. </pages>
Reference: [GMW86] <author> Goldreich, O., Micali, S., and Wigderson, A. </author> <title> "Proofs that Yield Nothing But their Validity and a Methodology of Cryptographic Protocol Design." </title> <booktitle> Proc. 27 th IEEE Symp. on Foundations of Computer Science, Toronto, ON (Oct. </booktitle> <year> 1986), </year> <pages> 174-186. </pages>
Reference-contexts: Finally, a symmetry argument shows that Carol receives absolutely no information from watching this protocol that she could not have obtained on her own. 3.3.4 Graph Non-isomorphism One example in which capsules are useful without the aid of residue classes is seen in a protocol for graph non-isomorphism given in <ref> [GMW86] </ref>. Their original protocol closely followed the non-residuosity protocol of [GMR85]. In [GMW86], a prover designates a graph H given by the verifier as either a permutation of graph G 1 or of graph G 2 after being convinced that the verifier already holds such a permutation. <p> watching this protocol that she could not have obtained on her own. 3.3.4 Graph Non-isomorphism One example in which capsules are useful without the aid of residue classes is seen in a protocol for graph non-isomorphism given in <ref> [GMW86] </ref>. Their original protocol closely followed the non-residuosity protocol of [GMR85]. In [GMW86], a prover designates a graph H given by the verifier as either a permutation of graph G 1 or of graph G 2 after being convinced that the verifier already holds such a permutation. <p> Thus, capsules | each consisting of a permutation of G 1 and a permutation of G 2 | are used to interactively prove that a given graph H is a permutation of either G 1 or G 2 . 3.3.5 Boolean Circuit Satisfiability Recently (also in <ref> [GMW86] </ref>), Goldreich, Micali, and Wigderson gave a simple and elegant zero-knowledge interactive protocol (as defined in [GMR85]) to prove for any k that a graph is k-colorable without revealing any information about a specific coloring (assuming that the prover possesses a k-coloring of the graph). <p> The method uses capsules to give a zero-knowledge protocol to interactively prove that a given Boolean formula (or arbitrary Boolean circuit with in-degree 2) has a satisfying assignment. Brassard and Crepeau in [BrCr86] independently of both this work and <ref> [GMW86] </ref> have achieved the same result, and Chaum in [Chau86a] has also independently achieved a very similar result. The major advantage of this method over the original is efficiency.
Reference: [GMW87] <author> Goldreich, O., Micali, S., and Wigderson, A. </author> <title> "How to Play Any Mental Game or A Completeness Theorem for Protocols with Honest Majority." </title> <booktitle> Proc. 19 th ACM Symp. on Theory of Computing, </booktitle> <address> New York, NY (May 1987), </address> <pages> 218-203. </pages>
Reference-contexts: This may be desirable in a number of circumstances in which computation on secret data is desired. [RAD78], [Yao82a], [Feig85], and <ref> [GMW87] </ref> discuss problems of this sort, and it will be seen that verifiable secret sharing and verifiable secret-ballot elections can be modeled in this way. It seems, however, that the homomorphism property is not strong enough for these applications.
Reference: [GoKi86] <author> Goldwasser, S. and Kilian, J. </author> <title> "Almost All Primes Can be Quickly Certified." </title> <booktitle> Proc. 18 th ACM Symp. on Theory of Computing, </booktitle> <address> Berkeley, CA (May 1986), </address> <pages> 316-329. </pages>
Reference: [GoMi82] <author> Goldwasser, S. and Micali, S. </author> <title> "Probabilistic Encryption & How to Play Mental Poker, Keeping Secret All Partial Information." </title> <booktitle> Proc. 14 th ACM Symp. on Theory of Computing, </booktitle> <address> San Francisco, CA (May 1982), </address> <pages> 365-377. </pages>
Reference: [GoMi83] <author> Goldwasser, S. and Micali, S. </author> <title> "Proofs With Untrusted Oracles." </title> <note> Unpublished Manuscript (May 1983). </note>
Reference-contexts: Capsules are used in and further the capabilities of so called interactive proofs. The notion of interactive proofs was introduced and first used by Goldwasser and Micali in <ref> [GoMi83] </ref>. The ideas were further developed by the original authors together with Fischer and Rackoff in [FMR84] and [GMR85]. The fundamental idea is an extension of the notion of a formal proof to what might be called a convincing argument.
Reference: [GoMi84] <author> Goldwasser, S. and Micali, S. </author> <title> "Probabilistic Encryption." </title> <journal> J. Comp. Sys. Sci. </journal> <volume> 28, </volume> <year> (1984), </year> <pages> 270-299. </pages>
Reference-contexts: Thus, E (s; x) serves as an encryption of the secret value s which can be decrypted by any agent which possesses the factorization of n (see section 2.5). This encryption method serves as a means of probabilistic encryption which is very similar to that given in <ref> [GoMi84] </ref>. However, since each encrypted value represents the encryption of a message from a message space of size r (instead of size 2 as in the [GoMi84] scheme), the size of a message which is represented by a single encryption can be much larger, and therefore the ratio of plaintext to <p> This encryption method serves as a means of probabilistic encryption which is very similar to that given in <ref> [GoMi84] </ref>. However, since each encrypted value represents the encryption of a message from a message space of size r (instead of size 2 as in the [GoMi84] scheme), the size of a message which is represented by a single encryption can be much larger, and therefore the ratio of plaintext to ciphertext is much larger. In fact, for a given security parameter N , the density in the [GoMi84] scheme is only 1=N while in this scheme <p> r (instead of size 2 as in the <ref> [GoMi84] </ref> scheme), the size of a message which is represented by a single encryption can be much larger, and therefore the ratio of plaintext to ciphertext is much larger. In fact, for a given security parameter N , the density in the [GoMi84] scheme is only 1=N while in this scheme it is (log r)=(N + log r) and thus can be made arbitrarily close to 1 by increasing r. <p> The only assumption made is the existence of a probabilistic cryptosystem, and this is implied by the existence of a one-way permutation (see <ref> [GoMi84] </ref> and [Yao82b]). 50 CHAPTER 3. CRYPTOGRAPHIC CAPSULES In this section, we shall examine an alternate approach which gives the same result by a very different method. <p> The major disadvantage of this method compared to the original method is that the new procedure requires a (seemingly) stronger cryptographic assumption. Although both methods require a probabilistic encryption function such as the residue class based probabilistic encryption of <ref> [GoMi84] </ref>, the method given here requires a probabilistic encryption function for which two encrypted values can be proven, in a zero-knowledge manner, to be encryptions of the same value.
Reference: [GoSi86] <author> Goldwasser, S. and Sipser, M. </author> <title> "Private Coins versus Public Coins in Interactive Proof Systems." </title> <booktitle> Proc. 18 th ACM Symp. on Theory of Computing, </booktitle> <address> Berkeley, CA (May 1986), </address> <pages> 59-68. </pages>
Reference: [Koth84] <author> Kothari, S. </author> <title> "Generalized Linear Threshold Scheme." </title> <booktitle> Proc. Crypto '84, </booktitle> <address> Santa Barbara, CA (Aug. </address> <year> 1984), </year> <pages> 231-241. </pages> <note> Published as Advances in Cryptology, </note> <editor> ed. by G. Blakely and D. </editor> <booktitle> Chaum in Lecture Notes in Computer Science, </booktitle> <volume> vol. 196, </volume> <editor> ed. by G. Goos and J. Hart-manis. </editor> <publisher> Springer-Verlag, </publisher> <address> New York (1985). 122 BIBLIOGRAPHY </address>
Reference-contexts: The pieces of a secret are often called shares. Since 1979, several different threshold schemes have been proposed (see [Blak79], [AsBl80], and <ref> [Koth84] </ref> for some examples), and they have proved to be useful in a wide variety of interactive protocols. The threshold scheme originally proposed by Shamir in [Sham79] is the best known and is very simple and elegant. <p> Many other known threshold schemes are also (+; +)-homomorphic. The threshold schemes found in [Blak79], [AsBl80], and <ref> [Koth84] </ref>, for example, are all (+; +)-homomorphic. What if the desired composite secret is not the sum of the constituent secrets? Shamir's scheme is not (fi; fi)-composite. This is because the product of two non-constant polynomials is of higher degree than the factors.
Reference: [Kran86] <author> Kranakis, E. </author> <title> Primality and Cryptography. </title> <publisher> John Wiley and Sons, </publisher> <address> New York (1986). </address>
Reference-contexts: More precisely, the probability that an element of size jpj 26 CHAPTER 2. THE ELECTION ENCRYPTION FUNCTION randomly chosen from within this sequence is prime is greater than p= log e p (see <ref> [Kran86] </ref>). An integer q with jqj = N such that r j (q 1) can be uniformly chosen by randomly selecting an integer b 6= 1 with 0 b &lt; r and selecting q of size N from the sequence rx + b. <p> The general form of the prime number theorem used in lemma 2.27 (see <ref> [Kran86] </ref>) ensures that such integers have roughly the same density of primes as integers in general. Thus, approximately 1 out of N of such integers p are prime. Probabilistic primality tests can be used to test such p.
Reference: [MaAd78] <author> Manders, K. and Adleman, L. </author> <title> "NP-Complete Decision Problems for Binary Quadratics." </title> <journal> J. Comp. Sys. Sci. </journal> <volume> 16, </volume> <year> (1978), </year> <pages> 168-184. </pages>
Reference: [Merr83] <author> Merritt, M. </author> <title> "Cryptographic Protocols." </title> <type> Ph.D. </type> <institution> Thesis presented at Georgia Institute of Technology (Feb. </institution> <year> 1983). </year>
Reference-contexts: RELATED WORK 71 5.2 Related Work Various cryptographic schemas have been proposed for boardroom voting in which participants pass encrypted messages from one to another while performing encryption and decryption operations until a certain point is reached at which all are confident of the outcome of the vote (see [DLM82], <ref> [Merr83] </ref>, and [Yao82a]). These all share the problems that the active participants must be known in advance and if one participant stops following its protocol during the election, the election cannot continue. Thus these boardroom schemas are not well suited for large-scale elections.
Reference: [Mill75] <author> Miller, G. </author> <title> "Riemann's Hypothesis and Tests for Primality." </title> <institution> Research Report Cs-75-27. Department of Computer Science. University of Waterloo. Waterloo, </institution> <address> ON (Oct. </address> <year> 1975). </year> <title> (Abridged version in Proc. </title> <booktitle> 7 th ACM Symp. on Theory of Computing, </booktitle> <address> Albuquerque, NM (May 1975), </address> <pages> 234-239.) </pages>
Reference-contexts: The result of Adleman and McDonnell leads us to believe that the problems may be of comparable complexity. When n is the product of two distinct primes, computing '(n) is computa-tionally equivalent to factoring n. Miller shows in <ref> [Mill75] </ref> that for general n, the two problems are polynomial time equivalent (assuming the Extended Riemann Hypothesis). One further lemma helps to argue that the special conditions of r th residuosity and exact consonance are closely related to other problems.
Reference: [Mill76] <author> Miller, G. </author> <title> "Riemann's Hypothesis and Tests for Primality." </title> <journal> J. Comp. Sys. Sci. </journal> <volume> 13, </volume> <year> (1976), </year> <pages> 300-317. </pages>
Reference: [NiZu72] <author> Niven, I. and Zuckerman, H. </author> <title> An Introduction to the Theory of Numbers, 3 rd ed. </title> <publisher> John Wiley and Sons, </publisher> <address> New York (1972). </address>
Reference-contexts: An encrypted bit may be sent to this user by releasing a quadratic residue to indicate a zero or a quadratic non-residue of Jacobi symbol +1 to indicate a one. The user which possesses the factorization of n can easily determine which is the case (see <ref> [NiZu72] </ref>, for instance). Without 2.2. HIGHER RESIDUES 7 the factorization, however, distinguishing between the two cases is an apparently difficult problem of unknown complexity.
Reference: [PoHe78] <author> Pohlig, S. and Hellman, M. </author> <title> "An Improved Algorithm for Computing Logarithms Over GF(2) and Its Cryptographic Significance." </title> <journal> IEEE Trans. on Information Theory 24, </journal> <month> 1 (Jan. </month> <year> 1978), </year> <pages> 106-110. </pages>
Reference-contexts: The reader may observe the similarity between the problem of determining the residue class of a canonical root and that of evaluating discrete logarithms modulo a prime. Techniques for the latter problem can be applied directly to the former. (See <ref> [PoHe78] </ref>, [Adle79], [COS86] for work on the discrete logarithm problem.) 1 Thanks to Joe Kilian for pointing out this trick. 22 CHAPTER 2. <p> In general, discrete logarithms may be difficult to compute. However, if p is small or of one of a variety of special forms, the problem is tractable (see <ref> [PoHe78] </ref>, [Adle79], [COS86]). It should be emphasized that such special cases for p do not in any way weaken the security of our schemes. The security is not cryptographic, but rather is information theoretic. Therefore, there need be no assumptions about the difficulty of solving any special problems. 4.5. <p> One of these schemas is based upon the difficulty of computing the discrete logarithm modulo a known prime ([Adle79], <ref> [PoHe78] </ref>, [COS86]). Another is based upon the difficulty of determining the order of an element modulo the product of two unknown primes. A third proposed schema encrypts a vote using the low order bit of a message encrypted by RSA [RSA78].
Reference: [Rabi79] <author> Rabin, M. </author> <title> "Digitalized Signatures and Public-key Functions as Intractable as Factorization." MIT/LCS/TR-212. </title> <type> MIT Technical Report (Jan. </type> <year> 1979). </year>
Reference: [Rabi80] <author> Rabin, M. </author> <title> "Probabilistic Algorithms in Finite Fields." </title> <journal> SIAM Journal on Computing 9, </journal> <month> 2 (May </month> <year> 1980), </year> <pages> 273-280. </pages>
Reference: [Rabi83a] <author> Rabin, M. </author> <title> "Transaction Protection by Beacons." </title> <journal> J. Comp. Sys. Sci. </journal> <volume> 27, </volume> <month> 2 (Oct. </month> <year> 1983), </year> <pages> 256-267. </pages>
Reference-contexts: Most of the problems raised in the elementary election scenario of section 2.9 are addressed here. The centralized government does, however, remain. As an additional convenience, we assume here the existence of a universally trusted source of random bits | a so-called beacon (see <ref> [Rabi83a] </ref>). Although it will not be necessary to use a beacon, it is a simpler mechanism than that which will ultimately be given. <p> The first of these additional sets is the set of bit generators denoted by G. Let M = jGj. The sole responsibility of the bit generators is to generate random bits at various times to facilitate interactive proofs. If a single trusted random source (known as a beacon | <ref> [Rabi83a] </ref>) is available, then G can be the singleton set containing just this beacon. In general, G should be chosen to be a set of random sources such that each participant is confident in the integrity and the unpredictability of at least one member of G.
Reference: [Rabi83b] <author> Rabin, M. </author> <title> "Randomized Byzantine Generals." </title> <booktitle> Proc. 24 th IEEE Symp. on Foundations of Computer Science, </booktitle> <address> Tucson, AZ (Nov. </address> <year> 1983), </year> <pages> 403-409. BIBLIOGRAPHY 123 </pages>
Reference-contexts: In practice, implementing such bulletin boards may be a problem unto itself. See [Fisc83] for a survey of the literature on this problem as well as [BenO83] and <ref> [Rabi83b] </ref> for some probabilistic approaches. 5.3. ELECTION DEFINITIONS 73 In addition, there is a publicly-readable number N called a security parameter which serves as the (only) input to each process. N controls the likelihood that the election is correct and that privacy is maintained.
Reference: [RAD78] <author> Rivest, R., Adleman, L., and Dertouzos, M. </author> <title> "On Data Banks and Privacy Homomorphisms." Foundations of Secure Computation, </title> <editor> ed. by R. A. DeMillo, et. al. </editor> <publisher> Academic Press, </publisher> <address> New York, </address> <year> (1978), </year> <pages> 169-179. </pages>
Reference-contexts: This may be desirable in a number of circumstances in which computation on secret data is desired. <ref> [RAD78] </ref>, [Yao82a], [Feig85], and [GMW87] discuss problems of this sort, and it will be seen that verifiable secret sharing and verifiable secret-ballot elections can be modeled in this way. It seems, however, that the homomorphism property is not strong enough for these applications. <p> The major requirement of such a schema seems to be the existance of a function that can be computed on a set of encrypted data which preserves the sum of the unencrypted components (see <ref> [RAD78] </ref>). The variety of number theoretic problems on which such schemes can be based and the ease with which they have been found gives additional reason to believe in the usefulness of the general paradigm.
Reference: [RSA78] <author> Rivest, R., Shamir, A., and Adleman, L. </author> <title> "A Method for Obtaining Digitial Signatures and Public-key Cryptosystems." </title> <journal> Comm. ACM 21, </journal> <month> 2 (Feb. </month> <year> 1978), </year> <pages> 120-126. </pages>
Reference-contexts: Therefore, (z A ) r n z B'(n)+1 n (z '(n) ) B z n z: Thus, z A is a r th root of z modulo n. Lemma 2.3 serves as the basis for the RSA public-key cryptosystem (see <ref> [RSA78] </ref>). 2.3 Residue Classes Definition Let r, n, and y be fixed integers. <p> Another is based upon the difficulty of determining the order of an element modulo the product of two unknown primes. A third proposed schema encrypts a vote using the low order bit of a message encrypted by RSA <ref> [RSA78] </ref>. The major requirement of such a schema seems to be the existance of a function that can be computed on a set of encrypted data which preserves the sum of the unencrypted components (see [RAD78]).
Reference: [Sham79] <author> Shamir, A. </author> <title> "How to Share a Secret." </title> <journal> Comm. ACM 22, </journal> <volume> 11 (Nov. </volume> <year> 1979), </year> <pages> 612-613. </pages>
Reference-contexts: One application described here gives a method of verifiable secret sharing which is much simpler and more efficient than previous schemes. A second application gives the final piece which allows the construction of a fault-tolerant method of holding verifiable secret-ballot elections. 4.1 Threshold Schemes In 1979, Shamir in <ref> [Sham79] </ref> defined the notion of a threshold scheme (often called a secret sharing scheme). <p> The pieces of a secret are often called shares. Since 1979, several different threshold schemes have been proposed (see [Blak79], [AsBl80], and [Koth84] for some examples), and they have proved to be useful in a wide variety of interactive protocols. The threshold scheme originally proposed by Shamir in <ref> [Sham79] </ref> is the best known and is very simple and elegant. It is based on polynomial interpolation and evaluation, and for completeness it will be sketched here.
Reference: [SoSt77] <author> Solovay, R. and Strassen, V. </author> <title> "A Fast Monte-Carlo Test for Primality." </title> <journal> SIAM Journal on Computing 6, </journal> <year> (1977), </year> <pages> 84-85. </pages>
Reference: [Stra80] <author> Straffin, P. </author> <title> Topics in the Theory of Voting. </title> <publisher> Birkhauser, </publisher> <address> Boston, </address> <year> (1980). </year>
Reference-contexts: Even though Arrow's work shows that no voting method is perfect, there are alternatives to plurality voting, and once the list of voter preferences has been compiled, any voting rule can be used to determine a winner. One quite interesting rule is called approval voting (see <ref> [Stra80] </ref>). With approval voting, each voter can cast one or zero votes in favor of each candidate, and the candidate who receives the most votes is the winner.
Reference: [Yao82a] <author> Yao, A. </author> <title> "Protocols for Secure Computations." </title> <booktitle> Proc. 23 rd IEEE Symp. on Foundations of Computer Science, </booktitle> <address> Chicago, IL (Nov. </address> <year> 1982), </year> <pages> 160-164. </pages>
Reference-contexts: This may be desirable in a number of circumstances in which computation on secret data is desired. [RAD78], <ref> [Yao82a] </ref>, [Feig85], and [GMW87] discuss problems of this sort, and it will be seen that verifiable secret sharing and verifiable secret-ballot elections can be modeled in this way. It seems, however, that the homomorphism property is not strong enough for these applications. <p> 71 5.2 Related Work Various cryptographic schemas have been proposed for boardroom voting in which participants pass encrypted messages from one to another while performing encryption and decryption operations until a certain point is reached at which all are confident of the outcome of the vote (see [DLM82], [Merr83], and <ref> [Yao82a] </ref>). These all share the problems that the active participants must be known in advance and if one participant stops following its protocol during the election, the election cannot continue. Thus these boardroom schemas are not well suited for large-scale elections.
Reference: [Yao82b] <author> Yao, A. </author> <title> "Theory and Applications of Trapdoor Functions." </title> <booktitle> Proc. 23 rd IEEE Symp. on Foundations of Computer Science, </booktitle> <address> Chicago, IL (Nov. </address> <year> 1982), </year> <pages> 80-91. </pages>
Reference-contexts: The only assumption made is the existence of a probabilistic cryptosystem, and this is implied by the existence of a one-way permutation (see [GoMi84] and <ref> [Yao82b] </ref>). 50 CHAPTER 3. CRYPTOGRAPHIC CAPSULES In this section, we shall examine an alternate approach which gives the same result by a very different method.
References-found: 62

