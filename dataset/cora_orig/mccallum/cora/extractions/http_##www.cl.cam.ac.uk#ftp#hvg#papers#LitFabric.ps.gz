URL: http://www.cl.cam.ac.uk/ftp/hvg/papers/LitFabric.ps.gz
Refering-URL: http://www.cl.cam.ac.uk/Research/HVG/FTP/FTP.html
Root-URL: 
Title: The Formal Verification of the Fairisle ATM Switching Element  
Author: Paul Curzon 
Address: New Museums Site Pembroke Street Cambridge CB2 3QG United Kingdom  
Affiliation: University of Cambridge Computer Laboratory  
Date: March 1994  
Pubnum: Technical Report Number 329  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Paul Curzon. </author> <title> The formal verification of the Fairisle ATM switching element: an overview. </title> <type> Technical Report 328, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: 1 Introduction In this report we describe in detail the formal verification of the Fairisle 4 by 4 switching element. This verification was performed using the HOL90 theorem proving system so is fully machine-checked. This report should be read in conjunction with the companion report <ref> [1] </ref>. It gives an overview of the project and briefly describes the switching element. It also provides a tutorial for the specification and verification techniques used. In Section 2 we give general definitions upon which the formal specifications of the hardware are based. <p> XiNOR (SWORD [SBIT i ackTermPre; disabled],SBIT i ackTerm))) Qudos HDL DEF ACKGEN (ackIn, x, y, disabled: IN; ackTerm [0..3] : IO); xBar, yBar, ackTermPre [0..3]: IO; BEGIN InvX := XiINV (x, xBar); InvY := XiINV (y, yBar); NandAckTermPre [0] := XiNAND3 (xBar, yBar, ackIn, ackTermPre [0]); NandAckTermPre <ref> [1] </ref> := XiNAND3 (xBar, y, ackIn, ackTermPre [1]); NandAckTermPre [2] := XiNAND3 (x, yBar, ackIn, ackTermPre [2]); NandAckTermPre [3] := XiNAND3 (x, y, ackIn, ackTermPre [3]); NorDis [0-3] := XiNOR2 (ackTermPre [0-3], disabled, ackTerm [0-3]); END; 3.11.3 The Correctness Statement Because the structural definition was not generic, the correctness theorem cannot <p> ackTermPre; disabled],SBIT i ackTerm))) Qudos HDL DEF ACKGEN (ackIn, x, y, disabled: IN; ackTerm [0..3] : IO); xBar, yBar, ackTermPre [0..3]: IO; BEGIN InvX := XiINV (x, xBar); InvY := XiINV (y, yBar); NandAckTermPre [0] := XiNAND3 (xBar, yBar, ackIn, ackTermPre [0]); NandAckTermPre <ref> [1] </ref> := XiNAND3 (xBar, y, ackIn, ackTermPre [1]); NandAckTermPre [2] := XiNAND3 (x, yBar, ackIn, ackTermPre [2]); NandAckTermPre [3] := XiNAND3 (x, y, ackIn, ackTermPre [3]); NorDis [0-3] := XiNOR2 (ackTermPre [0-3], disabled, ackTerm [0-3]); END; 3.11.3 The Correctness Statement Because the structural definition was not generic, the correctness theorem cannot be generic. <p> ACKOR_N (ackTerm,ackOut) = (FOR i ::(TO (SIGLEN ackOut)). ACKOR (SBIT i ackTerm,SBIT i ackOut)) ` 8 ackTerm ackOut. ACKOR_N_SIMPL (ackTerm,ackOut) = (FOR i ::(TO (SIGLEN ackOut)). ACKOR_SPEC (SBIT i ackTerm,SBIT i ackOut)) 38 Qudos HDL AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr <ref> [1] </ref> := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); 3.12.3 The Correctness Statement As the structural description is generic with respect to word sizes, the correctness theorem can also be generic. <p> ACKOR (SBIT i ackTerm,SBIT i ackOut)) ` 8 ackTerm ackOut. ACKOR_N_SIMPL (ackTerm,ackOut) = (FOR i ::(TO (SIGLEN ackOut)). ACKOR_SPEC (SBIT i ackTerm,SBIT i ackOut)) 38 Qudos HDL AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr <ref> [1] </ref> := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); 3.12.3 The Correctness Statement As the structural description is generic with respect to word sizes, the correctness theorem can also be generic. Two restrictions are placed on the sizes. <p> ACK_SIMPL ((ackIn,grant,outputDisable),ackOut) = (LOCAL ackTerm ::(PSIG2LEN 4 4). ACKGEN_N_SPEC ((ackIn,grant,outputDisable),ackTerm) ^ ACKOR_N_SPEC (ackTerm,ackOut)) Qudos HDL AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], 42 outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr <ref> [1] </ref> := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); 3.14.3 The Correctness Statement ` FOR ackIn ackOut outputDisable ::(PSIGLEN 4). FOR grant ::(PSIG2LEN 4 2). <p> ACKGEN_N_SPEC ((ackIn,grant,outputDisable),ackTerm) ^ ACKOR_N_SPEC (ackTerm,ackOut)) Qudos HDL AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], 42 outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr <ref> [1] </ref> := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); 3.14.3 The Correctness Statement ` FOR ackIn ackOut outputDisable ::(PSIGLEN 4). FOR grant ::(PSIG2LEN 4 2). <p> d,y),SBIT 1 mux) ^ RLATCH_SPEC ((mux,outputDisable),q)) Qudos HDL DEF DMUX4T2FFC (d [0..3], clock, y, outputDisable: IN; q [0..1]: IO); yBar, mux [0..1] : IO; BEGIN Clb := XiCLBMAP5i2okr (d [0..1], y, d [2..3], clock, outputDisable, q [0..1]); InvY := XiINV (y, yBar); B [0] := AO (d [0], yBar, d <ref> [1] </ref>, y, mux [0]); B [1] := AO (d [2], yBar, d [3], y, mux [1]); BFF [0-1] := XiDFFrd (mux [0-1], clock, outputDisable, q [0-1]); END; 3.15.3 The Correctness Statement ` FOR q ::(PSIGLEN 2). <p> ((mux,outputDisable),q)) Qudos HDL DEF DMUX4T2FFC (d [0..3], clock, y, outputDisable: IN; q [0..1]: IO); yBar, mux [0..1] : IO; BEGIN Clb := XiCLBMAP5i2okr (d [0..1], y, d [2..3], clock, outputDisable, q [0..1]); InvY := XiINV (y, yBar); B [0] := AO (d [0], yBar, d <ref> [1] </ref>, y, mux [0]); B [1] := AO (d [2], yBar, d [3], y, mux [1]); BFF [0-1] := XiDFFrd (mux [0-1], clock, outputDisable, q [0-1]); END; 3.15.3 The Correctness Statement ` FOR q ::(PSIGLEN 2). <p> IN; q [0..1]: IO); yBar, mux [0..1] : IO; BEGIN Clb := XiCLBMAP5i2okr (d [0..1], y, d [2..3], clock, outputDisable, q [0..1]); InvY := XiINV (y, yBar); B [0] := AO (d [0], yBar, d <ref> [1] </ref>, y, mux [0]); B [1] := AO (d [2], yBar, d [3], y, mux [1]); BFF [0-1] := XiDFFrd (mux [0-1], clock, outputDisable, q [0-1]); END; 3.15.3 The Correctness Statement ` FOR q ::(PSIGLEN 2). <p> AO ((SBIT 0 (SBIT i d),xBar,SBIT 1 (SBIT i d),x),SBIT i dOut))) Qudos HDL DEF DMUX4T2 (d [0..3], x: IN; dOut [0..1]: IO); xBar : IO; BEGIN Clb := XiCLBMAP5i2o (d [0..1], x, d [2..3], dOut [0..1]); InvX := XiINV (x, xBar); B [0] := AO (d [0], xBar, d <ref> [1] </ref>, x, dOut [0]); B [1] := AO (d [2], xBar, d [3], x, dOut [1]); END; 3.16.3 The Correctness Statement ` 8 x. FOR d ::(PSIG2LEN 2 2). FOR dOut ::(PSIGLEN 2). <p> d),xBar,SBIT 1 (SBIT i d),x),SBIT i dOut))) Qudos HDL DEF DMUX4T2 (d [0..3], x: IN; dOut [0..1]: IO); xBar : IO; BEGIN Clb := XiCLBMAP5i2o (d [0..1], x, d [2..3], dOut [0..1]); InvX := XiINV (x, xBar); B [0] := AO (d [0], xBar, d <ref> [1] </ref>, x, dOut [0]); B [1] := AO (d [2], xBar, d [3], x, dOut [1]); END; 3.16.3 The Correctness Statement ` 8 x. FOR d ::(PSIG2LEN 2 2). FOR dOut ::(PSIGLEN 2). <p> DMUX4T2 (d [0..3], x: IN; dOut [0..1]: IO); xBar : IO; BEGIN Clb := XiCLBMAP5i2o (d [0..1], x, d [2..3], dOut [0..1]); InvX := XiINV (x, xBar); B [0] := AO (d [0], xBar, d <ref> [1] </ref>, x, dOut [0]); B [1] := AO (d [2], xBar, d [3], x, dOut [1]); END; 3.16.3 The Correctness Statement ` 8 x. FOR d ::(PSIG2LEN 2 2). FOR dOut ::(PSIGLEN 2). DMUX4T2 ((d,x),dOut) DMUX4T2_SPEC ((d,x),dOut) 3.17 DMUX2B4CAll 3.17.1 The Behavioural Specification DMUX2B4CAll chooses the grant th bit of each of the 2 words of which d consists. <p> DMUX4T2FFC_SPEC ((SBIT i d,y,outputDisable),SBIT i q)) ^ DMUX4T2_SPEC ((q,x),dOut)) Qudos HDL DEF DMUX2B4CAll (d0 [0..3], d1 [0..3], clock, x, y, outputDisable: IN; dOut [0..1]: IO); q0 [0..1], q1 [0..1]: IO; BEGIN P [0] := DMUX4T2FFC (d0 [0..3], clock, y, outputDisable, q0 [0..1]); P <ref> [1] </ref> := DMUX4T2FFC (d1 [0..3], clock, y, outputDisable, q1 [0..1]); FB := DMUX4T2 (q0 [0..1], q1 [0..1], x, dOut [0..1]); END; 3.17.3 The Correctness Statement ` 8 outputDisable. FOR d ::(PSIG2LEN 2 4). FOR q y ::(PSIGLEN 2). <p> (2 * i) d],grant,outputDisable), SWSEG 2 (2 * i) q)) 49 50 Qudos HDL (* Version that allows all bits to be cleared *) DEF DATASWITCHC (d [0..31], clock, x, y, outputDisable: IN; q [0..7]: IO); BEGIN Pr [0] := DMUX2B4CAll (d [0], d [8], d [16], d [24], d <ref> [1] </ref>, d [9], d [17], d [25], clock, x, y, outputDisable, q [0], q [1]); Pr [1] := DMUX2B4CAll (d [2], d [10], d [18], d [26], d [3], d [11], d [19], d [27], clock, x, y, outputDisable, q [2], q [3]); Pr [2] := DMUX2B4CAll (d [4], d [12], <p> (* Version that allows all bits to be cleared *) DEF DATASWITCHC (d [0..31], clock, x, y, outputDisable: IN; q [0..7]: IO); BEGIN Pr [0] := DMUX2B4CAll (d [0], d [8], d [16], d [24], d <ref> [1] </ref>, d [9], d [17], d [25], clock, x, y, outputDisable, q [0], q [1]); Pr [1] := DMUX2B4CAll (d [2], d [10], d [18], d [26], d [3], d [11], d [19], d [27], clock, x, y, outputDisable, q [2], q [3]); Pr [2] := DMUX2B4CAll (d [4], d [12], d [20], d [28], d [5], d [13], d [21], d [29], clock, x, <p> that allows all bits to be cleared *) DEF DATASWITCHC (d [0..31], clock, x, y, outputDisable: IN; q [0..7]: IO); BEGIN Pr [0] := DMUX2B4CAll (d [0], d [8], d [16], d [24], d <ref> [1] </ref>, d [9], d [17], d [25], clock, x, y, outputDisable, q [0], q [1]); Pr [1] := DMUX2B4CAll (d [2], d [10], d [18], d [26], d [3], d [11], d [19], d [27], clock, x, y, outputDisable, q [2], q [3]); Pr [2] := DMUX2B4CAll (d [4], d [12], d [20], d [28], d [5], d [13], d [21], d [29], clock, x, y, outputDisable, <p> DATASWITCHC ((d,SBIT i grant,SBIT i outputDisable),SBIT i dOut)) 52 ` 8 d grant outputDisable dOut. DATASWITCH_N_SIMPL ((d,grant,outputDisable),dOut) = (FOR i ::(TO (SIGLEN dOut)). DATASWITCHC_SPEC ((d,SBIT i grant,SBIT i outputDisable),SBIT i dOut)) Qudos HDL DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.19.3 The Correctness Statement ` FOR grant <p> DATASWITCH_N_SIMPL ((d,grant,outputDisable),dOut) = (FOR i ::(TO (SIGLEN dOut)). DATASWITCHC_SPEC ((d,SBIT i grant,SBIT i outputDisable),SBIT i dOut)) Qudos HDL DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.19.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). <p> DATASWITCH_N_SIMPL ((d,grant,outputDisable),dOut) = (FOR i ::(TO (SIGLEN dOut)). DATASWITCHC_SPEC ((d,SBIT i grant,SBIT i outputDisable),SBIT i dOut)) Qudos HDL DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.19.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). <p> DATASWITCH_N_SIMPL ((d,grant,outputDisable),dOut) = (FOR i ::(TO (SIGLEN dOut)). DATASWITCHC_SPEC ((d,SBIT i grant,SBIT i outputDisable),SBIT i dOut)) Qudos HDL DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.19.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). <p> PAUSE_DATASWITCH_SIMPL ((d,grant,outputDisable),dOut) = (LOCAL dPause ::(PSIG2LEN 4 8). PAUSE_SPEC (d,dPause) ^ DATASWITCH_N_SPEC ((dPause,grant,outputDisable),dOut)) Qudos HDL Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.20.3 The Correctness Statement ` FOR grant <p> PAUSE_DATASWITCH_SIMPL ((d,grant,outputDisable),dOut) = (LOCAL dPause ::(PSIG2LEN 4 8). PAUSE_SPEC (d,dPause) ^ DATASWITCH_N_SPEC ((dPause,grant,outputDisable),dOut)) Qudos HDL Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.20.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). <p> PAUSE_DATASWITCH_SIMPL ((d,grant,outputDisable),dOut) = (LOCAL dPause ::(PSIG2LEN 4 8). PAUSE_SPEC (d,dPause) ^ DATASWITCH_N_SPEC ((dPause,grant,outputDisable),dOut)) Qudos HDL Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.20.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). <p> PAUSE_SPEC (d,dPause) ^ DATASWITCH_N_SPEC ((dPause,grant,outputDisable),dOut)) Qudos HDL Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.20.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). <p> PRIFIL4CLB_SIMPL ((hiR,genR),req) = (FOR i ::(TO (SIGLEN req)). PRIFILUNIT_SPEC ((SBIT i hiR,SBIT i genR,SREMBIT i hiR),SBIT i req)) Qudos HDL DEF PRIFIL4CLB (hiR [0..3], genR [0..3]: IN; req [0..3]: IO); BEGIN 60 61 PriUnit [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit <ref> [1] </ref> := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit [2] := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR [3], req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three <p> PRIFILUNIT_SPEC ((SBIT i hiR,SBIT i genR,SREMBIT i hiR),SBIT i req)) Qudos HDL DEF PRIFIL4CLB (hiR [0..3], genR [0..3]: IN; req [0..3]: IO); BEGIN 60 61 PriUnit [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit <ref> [1] </ref> := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit [2] := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR [3], req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three stages. <p> PRIFILUNIT_SPEC ((SBIT i hiR,SBIT i genR,SREMBIT i hiR),SBIT i req)) Qudos HDL DEF PRIFIL4CLB (hiR [0..3], genR [0..3]: IN; req [0..3]: IO); BEGIN 60 61 PriUnit [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit <ref> [1] </ref> := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit [2] := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR [3], req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three stages. <p> PRIFILUNIT_SPEC ((SBIT i hiR,SBIT i genR,SREMBIT i hiR),SBIT i req)) Qudos HDL DEF PRIFIL4CLB (hiR [0..3], genR [0..3]: IN; req [0..3]: IO); BEGIN 60 61 PriUnit [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit <ref> [1] </ref> := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit [2] := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR [3], req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three stages. <p> ((act,pri,r1,r2,r1Bar,r2Bar),hiReq) = XiAND (SWORD [act; pri; r1Bar; r2Bar],SBIT 0 hiReq) ^ XiAND (SWORD [act; pri; r1Bar; r2],SBIT 1 hiReq) ^ XiAND (SWORD [act; pri; r1; r2Bar],SBIT 2 hiReq) ^ XiAND (SWORD [act; pri; r1; r2],SBIT 3 hiReq) Qudos HDL AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq <ref> [1] </ref> := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq [2] := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq [3] := XiAND4 (act, pri, r1, r2, hiReq [3]); 3.25.3 The Correctness Statement ` 8 act pri r1 r2 r1Bar r2Bar. FOR hiReq ::(PSIGLEN 4). <p> 0 hiReq) ^ XiAND (SWORD [act; pri; r1Bar; r2],SBIT 1 hiReq) ^ XiAND (SWORD [act; pri; r1; r2Bar],SBIT 2 hiReq) ^ XiAND (SWORD [act; pri; r1; r2],SBIT 3 hiReq) Qudos HDL AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq <ref> [1] </ref> := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq [2] := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq [3] := XiAND4 (act, pri, r1, r2, hiReq [3]); 3.25.3 The Correctness Statement ` 8 act pri r1 r2 r1Bar r2Bar. FOR hiReq ::(PSIGLEN 4). <p> GENREQ ((act,r1,r2,r1Bar,r2Bar),genReq) = XiAND (SWORD [act; r1Bar; r2Bar],SBIT 0 genReq) ^ XiAND (SWORD [act; r1Bar; r2],SBIT 1 genReq) ^ XiAND (SWORD [act; r1; r2Bar],SBIT 2 genReq) ^ XiAND (SWORD [act; r1; r2],SBIT 3 genReq) Qudos HDL AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq <ref> [1] </ref> := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); 67 AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); 3.26.3 The Correctness Statement ` 8 act r1 r2 r1Bar r2Bar. FOR genReq ::(PSIGLEN 4). <p> XiAND (SWORD [act; r1Bar; r2Bar],SBIT 0 genReq) ^ XiAND (SWORD [act; r1Bar; r2],SBIT 1 genReq) ^ XiAND (SWORD [act; r1; r2Bar],SBIT 2 genReq) ^ XiAND (SWORD [act; r1; r2],SBIT 3 genReq) Qudos HDL AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq <ref> [1] </ref> := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); 67 AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); 3.26.3 The Correctness Statement ` 8 act r1 r2 r1Bar r2Bar. FOR genReq ::(PSIGLEN 4). <p> XiINV (r1,r1Bar) ^ XiINV (r2,r2Bar) ^ HIREQ_SPEC ((act,pri,r1,r2,r1Bar,r2Bar),hiReq) ^ GENREQ_SPEC ((act,r1,r2,r1Bar,r2Bar),genReq)) Qudos HDL DEF DECODE (act, pri, r1, r2: IN; hiReq [0..3], genReq [0..3]: IO); r1Bar, r2Bar: IO; BEGIN InvR1 := XiINV (r1, r1Bar); InvR2 := XiINV (r2, r2Bar); AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq <ref> [1] </ref> := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq [2] := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq [3] := XiAND4 (act, pri, r1, r2, hiReq [3]); AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 <p> ^ GENREQ_SPEC ((act,r1,r2,r1Bar,r2Bar),genReq)) Qudos HDL DEF DECODE (act, pri, r1, r2: IN; hiReq [0..3], genReq [0..3]: IO); r1Bar, r2Bar: IO; BEGIN InvR1 := XiINV (r1, r1Bar); InvR2 := XiINV (r2, r2Bar); AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq <ref> [1] </ref> := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq [2] := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq [3] := XiAND4 (act, pri, r1, r2, hiReq [3]); AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); AndGenReq [3] := <p> AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq <ref> [1] </ref> := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq [2] := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq [3] := XiAND4 (act, pri, r1, r2, hiReq [3]); AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); END; 3.27.3 The Correctness Statement ` FOR route ::(PSIGLEN 2). FOR hiReq genReq ::(PSIGLEN 4). <p> r2Bar, hiReq [0]); AndHiReq <ref> [1] </ref> := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq [2] := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq [3] := XiAND4 (act, pri, r1, r2, hiReq [3]); AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); END; 3.27.3 The Correctness Statement ` FOR route ::(PSIGLEN 2). FOR hiReq genReq ::(PSIGLEN 4). <p> DECODE_N_SIMPL ((active,priority,route),hiReq,genReq) = (FOR i ::(TO (SIGLEN hiReq)). DECODE_SPEC ((SBIT i active,SBIT i priority,SBIT i route), SBIT i hiReq, SBIT i genReq)) Qudos HDL Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode <ref> [1] </ref> := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode [2] := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode [3] := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); 71 72 3.28.3 The Correctness Statement ` FOR active priority ::(PSIGLEN 4). FOR route ::(PSIG2LEN 4 2). <p> XiINV (reqA,reqABar) ^ XiINV (reqB,reqBBar) ^ AO ((term0,reqC,term1,reqD),yjk) ^ XiOR (SWORD [x; reqBBar],term0) ^ XiOR (SWORD [xBar; reqABar],term1)) Qudos HDL (* Jy *) InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); 73 OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := <p> XiINV (reqA,reqABar) ^ XiINV (reqB,reqBBar) ^ AO ((term0,reqC,term1,reqD),yjk) ^ XiOR (SWORD [x; reqBBar],term0) ^ XiOR (SWORD [xBar; reqABar],term1)) Qudos HDL (* Jy *) InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); 73 OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, <p> ((term0,reqC,term1,reqD),yjk) ^ XiOR (SWORD [x; reqBBar],term0) ^ XiOR (SWORD [xBar; reqABar],term1)) Qudos HDL (* Jy *) InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); 73 OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.29.3 <p> ^ XiOR (SWORD [xBar; reqABar],term1)) Qudos HDL (* Jy *) InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); 73 OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.29.3 The Correctness Statement ` 8 x <p> Jy *) InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); 73 OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.29.3 The Correctness Statement ` 8 x xBar reqA reqB reqC reqD yjk. <p> AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); 73 OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.29.3 The Correctness Statement ` 8 x xBar reqA reqB reqC reqD yjk. <p> := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy <ref> [1] </ref> := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.29.3 The Correctness Statement ` 8 x xBar reqA reqB reqC reqD yjk. <p> OrTermJy <ref> [1] </ref> := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.29.3 The Correctness Statement ` 8 x xBar reqA reqB reqC reqD yjk. <p> ARBX EL describes the common hardware. ` 8 reqA y reqB reqC xjk. ARB_XEL ((reqA,y,reqB,reqC),xjk) = (LOCAL reqBarJxKx fact0 fact1. XiINV (reqA,reqBarJxKx) ^ XiAND (SWORD [fact0; fact1],xjk) ^ XiOR (SWORD [y; reqBarJxKx],fact0) ^ XiOR (SWORD [reqB; reqC],fact1)) Qudos HDL 75 (* Jx *) InvReqJxKxCLB1 := XiINV (req <ref> [1] </ref>, reqBarJxKxCLB1); AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] <p> XiINV (reqA,reqBarJxKx) ^ XiAND (SWORD [fact0; fact1],xjk) ^ XiOR (SWORD [y; reqBarJxKx],fact0) ^ XiOR (SWORD [reqB; reqC],fact1)) Qudos HDL 75 (* Jx *) InvReqJxKxCLB1 := XiINV (req <ref> [1] </ref>, reqBarJxKxCLB1); AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.30.3 The Correctness Statement ` 8 y reqA reqB <p> ^ XiAND (SWORD [fact0; fact1],xjk) ^ XiOR (SWORD [y; reqBarJxKx],fact0) ^ XiOR (SWORD [reqB; reqC],fact1)) Qudos HDL 75 (* Jx *) InvReqJxKxCLB1 := XiINV (req <ref> [1] </ref>, reqBarJxKxCLB1); AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.30.3 The Correctness Statement ` 8 y reqA reqB reqC xjk. <p> <ref> [1] </ref>, reqBarJxKxCLB1); AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.30.3 The Correctness Statement ` 8 y reqA reqB reqC xjk. <p> [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx <ref> [1] </ref> := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.30.3 The Correctness Statement ` 8 y reqA reqB reqC xjk. <p> OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx <ref> [1] </ref> := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.30.3 The Correctness Statement ` 8 y reqA reqB reqC xjk. ARB_XEL ((reqA,y,reqB,reqC),xjk) ARB_XEL_SPEC ((reqA,y,reqB,reqC),xjk) 3.31 K ARBY 3.31.1 The Behavioural Specification K ARBY determines the K input to the JK flip-flop for the low bit of the grant signal from the arbiter. ` 8 x req ky. <p> K_ARBY_SIMPL ((x,req),ky) = (LOCAL xBar. XiINV (x,xBar) ^ ARB_YEL_SPEC ((xBar,x,SBIT 3 req,SBIT 1 req,SBIT 2 req,SBIT 0 req),ky)) Qudos HDL (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req <ref> [1] </ref>, reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.31.3 The Correctness Statement ` K_ARBY ((x,req),ky) K_ARBY_SPEC ((x,req),ky) 3.32 J ARBY 3.32.1 The Behavioural <p> XiINV (x,xBar) ^ ARB_YEL_SPEC ((xBar,x,SBIT 3 req,SBIT 1 req,SBIT 2 req,SBIT 0 req),ky)) Qudos HDL (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req <ref> [1] </ref>, reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.31.3 The Correctness Statement ` K_ARBY ((x,req),ky) K_ARBY_SPEC ((x,req),ky) 3.32 J ARBY 3.32.1 The Behavioural Specification J ARBY determines the J input to the JK flip-flop for the low bit of <p> Qudos HDL (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req <ref> [1] </ref>, reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.31.3 The Correctness Statement ` K_ARBY ((x,req),ky) K_ARBY_SPEC ((x,req),ky) 3.32 J ARBY 3.32.1 The Behavioural Specification J ARBY determines the J input to the JK flip-flop for the low bit of the grant signal from the arbiter. 77 ` 8 x req jy. <p> := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req <ref> [1] </ref>, reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.31.3 The Correctness Statement ` K_ARBY ((x,req),ky) K_ARBY_SPEC ((x,req),ky) 3.32 J ARBY 3.32.1 The Behavioural Specification J ARBY determines the J input to the JK flip-flop for the low bit of the grant signal from the arbiter. 77 ` 8 x req jy. J_ARBY_SPEC ((x,req),jy) = (8 t. <p> (x,xBar) ^ ARB_YEL_SPEC ((x,xBar,SBIT 0 req,SBIT 2 req,SBIT 3 req,SBIT 1 req),jy)) Qudos HDL (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); 78 InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); 3.32.3 The Correctness Statement ` J_ARBY ((x,req),ky) J_ARBY_SPEC ((x,req),ky) 3.33 ARBY 3.33.1 The Behavioural Specification ARBY determines the J and K inputs to the JK flip-flop for the low bit of <p> ARB_YEL_SPEC ((x,xBar,SBIT 0 req,SBIT 2 req,SBIT 3 req,SBIT 1 req),jy)) Qudos HDL (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); 78 InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); 3.32.3 The Correctness Statement ` J_ARBY ((x,req),ky) J_ARBY_SPEC ((x,req),ky) 3.33 ARBY 3.33.1 The Behavioural Specification ARBY determines the J and K inputs to the JK flip-flop for the low bit of the grant <p> HDL (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); 78 InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); 3.32.3 The Correctness Statement ` J_ARBY ((x,req),ky) J_ARBY_SPEC ((x,req),ky) 3.33 ARBY 3.33.1 The Behavioural Specification ARBY determines the J and K inputs to the JK flip-flop for the low bit of the grant signal from the arbiter. ` 8 x req jy ky. <p> XiCLBMAP5i1o (x, req [0..3], jy); 78 InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); 3.32.3 The Correctness Statement ` J_ARBY ((x,req),ky) J_ARBY_SPEC ((x,req),ky) 3.33 ARBY 3.33.1 The Behavioural Specification ARBY determines the J and K inputs to the JK flip-flop for the low bit of the grant signal from the arbiter. ` 8 x req jy ky. ARBY_SPEC ((x,req),jy,ky) = (8 t. <p> ARBY_SIMPL ((x,req),jy,ky) = J_ARBY_SPEC ((x,req),jy) ^ K_ARBY_SPEC ((x,req),ky) Qudos HDL (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); 79 InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm <p> ARBY_SIMPL ((x,req),jy,ky) = J_ARBY_SPEC ((x,req),jy) ^ K_ARBY_SPEC ((x,req),ky) Qudos HDL (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); 79 InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req <p> HDL (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); 79 InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, <p> XiCLBMAP5i1o (x, req [0..3], jy); 79 InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := <p> (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 <p> [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy <ref> [1] </ref> := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); 80 3.33.3 The Correctness Statement <p> jyTerm <ref> [1] </ref>); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); 80 3.33.3 The Correctness Statement ` ARBY ((x,req),jy,ky) ARBY_SPEC ((x,req),jy,ky) 3.34 ARBX 3.34.1 The Behavioural Specification ARBX determines <p> := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req <ref> [1] </ref>, reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); 80 3.33.3 The Correctness Statement ` ARBY ((x,req),jy,ky) ARBY_SPEC ((x,req),jy,ky) 3.34 ARBX 3.34.1 The Behavioural Specification ARBX determines the J and K inputs to <p> := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req <ref> [1] </ref>, reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); 80 3.33.3 The Correctness Statement ` ARBY ((x,req),jy,ky) ARBY_SPEC ((x,req),jy,ky) 3.34 ARBX 3.34.1 The Behavioural Specification ARBX determines the J and K inputs to the JK flip-flop for the high bit <p> XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm <ref> [1] </ref>, req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); 80 3.33.3 The Correctness Statement ` ARBY ((x,req),jy,ky) ARBY_SPEC ((x,req),jy,ky) 3.34 ARBX 3.34.1 The Behavioural Specification ARBX determines the J and K inputs to the JK flip-flop for the high bit of the grant signal from the arbiter. ` 8 y req jx <p> ARBX_SIMPL ((y,req),jx,kx) = ARB_XEL_SPEC ((SBIT 1 req,y,SBIT 3 req,SBIT 2 req),jx) ^ ARB_XEL_SPEC ((SBIT 3 req,y,SBIT 0 req,SBIT 1 req),kx) Qudos HDL ClbJxKx := XiCLBMAP5i2o (req [0], req <ref> [1] </ref>, req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx <p> ARBX_SIMPL ((y,req),jx,kx) = ARB_XEL_SPEC ((SBIT 1 req,y,SBIT 3 req,SBIT 2 req),jx) ^ ARB_XEL_SPEC ((SBIT 3 req,y,SBIT 0 req,SBIT 1 req),kx) Qudos HDL ClbJxKx := XiCLBMAP5i2o (req [0], req <ref> [1] </ref>, req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact <p> 0 req,SBIT 1 req),kx) Qudos HDL ClbJxKx := XiCLBMAP5i2o (req [0], req <ref> [1] </ref>, req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.34.3 The Correctness Statement ` ARBX ((y,req),jx,kx) ARBX_SPEC ((y,req),jx,kx) 3.35 ARBITER FF 3.35.1 The Behavioural <p> XiCLBMAP5i2o (req [0], req <ref> [1] </ref>, req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.34.3 The Correctness Statement ` ARBX ((y,req),jx,kx) ARBX_SPEC ((y,req),jx,kx) 3.35 ARBITER FF 3.35.1 The Behavioural Specification ARBITER FF consists of 2 independent JK <p> := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx <ref> [1] </ref> := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.34.3 The Correctness Statement ` ARBX ((y,req),jx,kx) ARBX_SPEC ((y,req),jx,kx) 3.35 ARBITER FF 3.35.1 The Behavioural Specification ARBITER FF consists of 2 independent JK flip-flops, each enabled by the routeEnable signal. ` 8 jx kx jy ky routeEnable x y. <p> Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx <ref> [1] </ref> := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.34.3 The Correctness Statement ` ARBX ((y,req),jx,kx) ARBX_SPEC ((y,req),jx,kx) 3.35 ARBITER FF 3.35.1 The Behavioural Specification ARBITER FF consists of 2 independent JK flip-flops, each enabled by the routeEnable signal. ` 8 jx kx jy ky routeEnable x y. <p> AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx <ref> [1] </ref> := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.34.3 The Correctness Statement ` ARBX ((y,req),jx,kx) ARBX_SPEC ((y,req),jx,kx) 3.35 ARBITER FF 3.35.1 The Behavioural Specification ARBITER FF consists of 2 independent JK flip-flops, each enabled by the routeEnable signal. ` 8 jx kx jy ky routeEnable x y. <p> JKFFce (jx, kx, clock, routeEnable, x); FFy := JKFFce (jy, ky, clock, routeEnable, y); 87 (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm <p> kx, clock, routeEnable, x); FFy := JKFFce (jy, ky, clock, routeEnable, y); 87 (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req <p> y); 87 (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, <p> := XiCLBMAP5i1o (x, req [0..3], jy); InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := <p> (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); <p> [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy <ref> [1] </ref> := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx <p> jyTerm <ref> [1] </ref>); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); <p> := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req <ref> [1] </ref>, reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], <p> XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req <ref> [1] </ref>, reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx <p> (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm <ref> [1] </ref>, req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact <p> XiOR2 (x, reqBarKyCLB3, kyTerm <ref> [1] </ref>); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.37.3 The Correctness Statement ` ARBITER_XY ((ltReq,routeEnable),x,y) ARBITER_XY_SPEC ((ltReq,routeEnable),x,y) 3.38 ARBITER 3.38.1 The Behavioural Specification <p> XiCLBMAP5i2o (req [0], req <ref> [1] </ref>, req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.37.3 The Correctness Statement ` ARBITER_XY ((ltReq,routeEnable),x,y) ARBITER_XY_SPEC ((ltReq,routeEnable),x,y) 3.38 ARBITER 3.38.1 The Behavioural Specification ARBITER performs round-robin arbitration for a single output <p> := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx <ref> [1] </ref> := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.37.3 The Correctness Statement ` ARBITER_XY ((ltReq,routeEnable),x,y) ARBITER_XY_SPEC ((ltReq,routeEnable),x,y) 3.38 ARBITER 3.38.1 The Behavioural Specification ARBITER performs round-robin arbitration for a single output port. <p> Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx <ref> [1] </ref> := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.37.3 The Correctness Statement ` ARBITER_XY ((ltReq,routeEnable),x,y) ARBITER_XY_SPEC ((ltReq,routeEnable),x,y) 3.38 ARBITER 3.38.1 The Behavioural Specification ARBITER performs round-robin arbitration for a single output port. <p> AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx <ref> [1] </ref> := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.37.3 The Correctness Statement ` ARBITER_XY ((ltReq,routeEnable),x,y) ARBITER_XY_SPEC ((ltReq,routeEnable),x,y) 3.38 ARBITER 3.38.1 The Behavioural Specification ARBITER performs round-robin arbitration for a single output port. <p> := JKFFce (jx, kx, clock, routeEnable, x); FFy := JKFFce (jy, ky, clock, routeEnable, y); (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm <p> (jx, kx, clock, routeEnable, x); FFy := JKFFce (jy, ky, clock, routeEnable, y); (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req <p> routeEnable, y); (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, <p> := XiCLBMAP5i1o (x, req [0..3], jy); InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := <p> (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm <ref> [1] </ref>, req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 <p> [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy <ref> [1] </ref> := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := <p> jyTerm <ref> [1] </ref>); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx <p> := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req <ref> [1] </ref>, reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req <p> := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req <ref> [1] </ref>, reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx <p> XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm <ref> [1] </ref>, req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact <p> := XiOR2 (x, reqBarKyCLB3, kyTerm <ref> [1] </ref>); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); AnyOr := XiOR4 (req [0..3], anyReq); AndKout := XiAND2 (anyReq, routeEnable, kOut); FFOutDis := JKFF <p> XiCLBMAP5i2o (req [0], req <ref> [1] </ref>, req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); AnyOr := XiOR4 (req [0..3], anyReq); AndKout := XiAND2 (anyReq, routeEnable, kOut); FFOutDis := JKFF (fs, kOut, clock, outputDisable, outputEnable); END; 3.38.3 The <p> := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx <ref> [1] </ref> := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); AnyOr := XiOR4 (req [0..3], anyReq); AndKout := XiAND2 (anyReq, routeEnable, kOut); FFOutDis := JKFF (fs, kOut, clock, outputDisable, outputEnable); END; 3.38.3 The Correctness Statement The proofs for the grant and outputDisable signals are treated separately. <p> Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx <ref> [1] </ref> := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); AnyOr := XiOR4 (req [0..3], anyReq); AndKout := XiAND2 (anyReq, routeEnable, kOut); FFOutDis := JKFF (fs, kOut, clock, outputDisable, outputEnable); END; 3.38.3 The Correctness Statement The proofs for the grant and outputDisable signals are treated separately. <p> AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx <ref> [1] </ref> := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); AnyOr := XiOR4 (req [0..3], anyReq); AndKout := XiAND2 (anyReq, routeEnable, kOut); FFOutDis := JKFF (fs, kOut, clock, outputDisable, outputEnable); END; 3.38.3 The Correctness Statement The proofs for the grant and outputDisable signals are treated separately. <p> DECODE_N ((active,priority,route),hiReq,genReq) ^ PRIORITY ((hiReq,genReq),req) ^ PAUSE (req,ltReq)) 96 ` 8 active priority route ltReq. PRIORITY_DECODE_SIMPL ((active,priority,route),ltReq) = (LOCAL hiReq genReq req ::(PSIG2LEN 4 4). DECODE_N_SPEC ((active,priority,route),hiReq,genReq) ^ PRIORITY_SPEC ((hiReq,genReq),req) ^ PAUSE_SPEC (req,ltReq)) Qudos HDL Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode <ref> [1] </ref> := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode [2] := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode [3] := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); PriFilter [0-3] := PRIFIL4CLB ( hiReq [0-3], hiReq [4-7], hiReq [8-11], hiReq [12-15], genReq [0-3], genReq [4-7], genReq [8-11], genReq [12-15], req <p> ARBITRATION_SIMPL ((active,priority,route,frameStart),grant,outputDisable) = (LOCAL routeEnable. LOCAL ltReq ::(PSIG2LEN 4 4). PRIORITY_DECODE_SPEC ((active,priority,route),ltReq) ^ TIMING_SPEC ((frameStart,active),routeEnable) ^ ARBITERS_SPEC ((ltReq,routeEnable,frameStart),grant,outputDisable)) 99 Qudos HDL Timing := TIMING (frameStart, clock, d [0], d [8], d [16], d [24], routeEnable); Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode <ref> [1] </ref> := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode [2] := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode [3] := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); PriFilter [0-3] := PRIFIL4CLB ( hiReq [0-3], hiReq [4-7], hiReq [8-11], hiReq [12-15], genReq [0-3], genReq [4-7], genReq [8-11], genReq [12-15], req <p> ARBITRATION_SPEC ((SBITS 0 d,SBITS 1 d,SWSEGS 2 2 d,frameStart), grant, outputDisable) ^ PAUSE_DATASWITCH_SPEC ((d,grant,outputDisable),dOut) ^ ACK_SPEC ((ackIn,grant,outputDisable),ackOut)) 104 105 Qudos HDL Timing := TIMING (frameStart, clock, d [0], d [8], d [16], d [24], routeEnable); Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode <ref> [1] </ref> := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode [2] := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode [3] := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); PriFilter [0-3] := PRIFIL4CLB ( hiReq [0-3], hiReq [4-7], hiReq [8-11], hiReq [12-15], genReq [0-3], genReq [4-7], genReq [8-11], genReq [12-15], req <p> [0-15], clock, ltReq [0-15]); Arb [0-3] := ARBITER (ltReq [0-3], ltReq [4-7], ltReq [8-11], ltReq [12-15], clock, routeEnable, frameStart, xGrant [0-3], yGrant [0-3], outputDisable [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant <p> ARBITER (ltReq [0-3], ltReq [4-7], ltReq [8-11], ltReq [12-15], clock, routeEnable, frameStart, xGrant [0-3], yGrant [0-3], outputDisable [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], <p> [0-3], ltReq [4-7], ltReq [8-11], ltReq [12-15], clock, routeEnable, frameStart, xGrant [0-3], yGrant [0-3], outputDisable [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], <p> [4-7], ltReq [8-11], ltReq [12-15], clock, routeEnable, frameStart, xGrant [0-3], yGrant [0-3], outputDisable [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], <p> yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr <ref> [1] </ref> := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); END; 3.42.3 The Correctness Statement We have proved that for all input and output signals for which the structural specification holds, there exists a signal last of the <p> DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr <ref> [1] </ref> := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); END; 3.42.3 The Correctness Statement We have proved that for all input and output signals for which the structural specification holds, there exists a signal last of the appropriate size for which the behavioural <p> [0-31] := XiINFFd (dEXT [0-31], clock, d [0-31]); O [0-31] := XiOUTFFd (dOut [0-31], clock, dOutEXT [0-31]); Ao [0-3] := XiOBUF (ackOut [0-3], ackOutEXT [0-3]); Timing := TIMING (frameStart, clock, d [0], d [8], d [16], d [24], routeEnable); Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode <ref> [1] </ref> := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode [2] := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode [3] := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); PriFilter [0-3] := PRIFIL4CLB ( hiReq [0-3], hiReq [4-7], hiReq [8-11], hiReq [12-15], genReq [0-3], genReq [4-7], genReq [8-11], genReq [12-15], req <p> clock, ltReq [0-15]); 112 Arb [0-3] := ARBITER (ltReq [0-3], ltReq [4-7], ltReq [8-11], ltReq [12-15], clock, routeEnable, frameStart, xGrant [0-3], yGrant [0-3], outputDisable [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant <p> ARBITER (ltReq [0-3], ltReq [4-7], ltReq [8-11], ltReq [12-15], clock, routeEnable, frameStart, xGrant [0-3], yGrant [0-3], outputDisable [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], <p> [0-3], ltReq [4-7], ltReq [8-11], ltReq [12-15], clock, routeEnable, frameStart, xGrant [0-3], yGrant [0-3], outputDisable [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], <p> [4-7], ltReq [8-11], ltReq [12-15], clock, routeEnable, frameStart, xGrant [0-3], yGrant [0-3], outputDisable [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw <ref> [1] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], <p> yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr <ref> [1] </ref> := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); END; 3.43.3 The Correctness Statement We have proved that for all input and output signals for which the structural specification holds, there exists a signal last of the <p> DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr <ref> [1] </ref> := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); END; 3.43.3 The Correctness Statement We have proved that for all input and output signals for which the structural specification holds, there exists a signal last of the appropriate size for which the behavioural
Reference: [2] <author> M.J.C. Gordon and T.F. Melham. </author> <title> Introduction to HOL: a theorem proving environment for higher order logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Its structural specification relies on those of all the other modules and the specifications of the basic constructs (such as logic gates) used. The latter are described in Section 2.8. A detailed account of the HOL system and the higher order logic notation is given by Gordon and Melham <ref> [2] </ref>. A description of the word library is given by Wong [3]. We do not give type information in the definitions. This can normally be determined from context. <p> i ackTerm))) Qudos HDL DEF ACKGEN (ackIn, x, y, disabled: IN; ackTerm [0..3] : IO); xBar, yBar, ackTermPre [0..3]: IO; BEGIN InvX := XiINV (x, xBar); InvY := XiINV (y, yBar); NandAckTermPre [0] := XiNAND3 (xBar, yBar, ackIn, ackTermPre [0]); NandAckTermPre [1] := XiNAND3 (xBar, y, ackIn, ackTermPre [1]); NandAckTermPre <ref> [2] </ref> := XiNAND3 (x, yBar, ackIn, ackTermPre [2]); NandAckTermPre [3] := XiNAND3 (x, y, ackIn, ackTermPre [3]); NorDis [0-3] := XiNOR2 (ackTermPre [0-3], disabled, ackTerm [0-3]); END; 3.11.3 The Correctness Statement Because the structural definition was not generic, the correctness theorem cannot be generic. <p> x, y, disabled: IN; ackTerm [0..3] : IO); xBar, yBar, ackTermPre [0..3]: IO; BEGIN InvX := XiINV (x, xBar); InvY := XiINV (y, yBar); NandAckTermPre [0] := XiNAND3 (xBar, yBar, ackIn, ackTermPre [0]); NandAckTermPre [1] := XiNAND3 (xBar, y, ackIn, ackTermPre [1]); NandAckTermPre <ref> [2] </ref> := XiNAND3 (x, yBar, ackIn, ackTermPre [2]); NandAckTermPre [3] := XiNAND3 (x, y, ackIn, ackTermPre [3]); NorDis [0-3] := XiNOR2 (ackTermPre [0-3], disabled, ackTerm [0-3]); END; 3.11.3 The Correctness Statement Because the structural definition was not generic, the correctness theorem cannot be generic. <p> ACKOR (SBIT i ackTerm,SBIT i ackOut)) ` 8 ackTerm ackOut. ACKOR_N_SIMPL (ackTerm,ackOut) = (FOR i ::(TO (SIGLEN ackOut)). ACKOR_SPEC (SBIT i ackTerm,SBIT i ackOut)) 38 Qudos HDL AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr <ref> [2] </ref> := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); 3.12.3 The Correctness Statement As the structural description is generic with respect to word sizes, the correctness theorem can also be generic. Two restrictions are placed on the sizes. <p> ACKOR_N_SIMPL (ackTerm,ackOut) = (FOR i ::(TO (SIGLEN ackOut)). ACKOR_SPEC (SBIT i ackTerm,SBIT i ackOut)) 38 Qudos HDL AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr <ref> [2] </ref> := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); 3.12.3 The Correctness Statement As the structural description is generic with respect to word sizes, the correctness theorem can also be generic. Two restrictions are placed on the sizes. <p> ACKGEN_N_SPEC ((ackIn,grant,outputDisable),ackTerm) ^ ACKOR_N_SPEC (ackTerm,ackOut)) Qudos HDL AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], 42 outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr <ref> [2] </ref> := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); 3.14.3 The Correctness Statement ` FOR ackIn ackOut outputDisable ::(PSIGLEN 4). FOR grant ::(PSIG2LEN 4 2). ACK ((ackIn,grant,outputDisable),ackOut) ACK_SPEC ((ackIn,grant,outputDisable),ackOut) 3.15 DMUX4T2FFC 3.15.1 The Behavioural Specification DMUX4T2FFC selects 2 bits from a 4-bit word d. <p> ((ackIn,grant,outputDisable),ackTerm) ^ ACKOR_N_SPEC (ackTerm,ackOut)) Qudos HDL AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], 42 outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr <ref> [2] </ref> := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); 3.14.3 The Correctness Statement ` FOR ackIn ackOut outputDisable ::(PSIGLEN 4). FOR grant ::(PSIG2LEN 4 2). ACK ((ackIn,grant,outputDisable),ackOut) ACK_SPEC ((ackIn,grant,outputDisable),ackOut) 3.15 DMUX4T2FFC 3.15.1 The Behavioural Specification DMUX4T2FFC selects 2 bits from a 4-bit word d. <p> DMUX4T2FFC (d [0..3], clock, y, outputDisable: IN; q [0..1]: IO); yBar, mux [0..1] : IO; BEGIN Clb := XiCLBMAP5i2okr (d [0..1], y, d [2..3], clock, outputDisable, q [0..1]); InvY := XiINV (y, yBar); B [0] := AO (d [0], yBar, d [1], y, mux [0]); B [1] := AO (d <ref> [2] </ref>, yBar, d [3], y, mux [1]); BFF [0-1] := XiDFFrd (mux [0-1], clock, outputDisable, q [0-1]); END; 3.15.3 The Correctness Statement ` FOR q ::(PSIGLEN 2). <p> d),x),SBIT i dOut))) Qudos HDL DEF DMUX4T2 (d [0..3], x: IN; dOut [0..1]: IO); xBar : IO; BEGIN Clb := XiCLBMAP5i2o (d [0..1], x, d [2..3], dOut [0..1]); InvX := XiINV (x, xBar); B [0] := AO (d [0], xBar, d [1], x, dOut [0]); B [1] := AO (d <ref> [2] </ref>, xBar, d [3], x, dOut [1]); END; 3.16.3 The Correctness Statement ` 8 x. FOR d ::(PSIG2LEN 2 2). FOR dOut ::(PSIGLEN 2). DMUX4T2 ((d,x),dOut) DMUX4T2_SPEC ((d,x),dOut) 3.17 DMUX2B4CAll 3.17.1 The Behavioural Specification DMUX2B4CAll chooses the grant th bit of each of the 2 words of which d consists. <p> The 4 occurrences of d are combined into a single parameterised call. For example, the HDL (d [0], d [8], d [16], d [24],: : : ) actually becomes SBITS (2 * i) d where i is 0 and similarly for (d <ref> [2] </ref>, d [10], d [18], d [26],: : : ) where i is 1. These are combined into a single word of 2 4-bit words. Note the order they are written is reversed. <p> to be cleared *) DEF DATASWITCHC (d [0..31], clock, x, y, outputDisable: IN; q [0..7]: IO); BEGIN Pr [0] := DMUX2B4CAll (d [0], d [8], d [16], d [24], d [1], d [9], d [17], d [25], clock, x, y, outputDisable, q [0], q [1]); Pr [1] := DMUX2B4CAll (d <ref> [2] </ref>, d [10], d [18], d [26], d [3], d [11], d [19], d [27], clock, x, y, outputDisable, q [2], q [3]); Pr [2] := DMUX2B4CAll (d [4], d [12], d [20], d [28], d [5], d [13], d [21], d [29], clock, x, y, outputDisable, q [4], q [5]); <p> DMUX2B4CAll (d [0], d [8], d [16], d [24], d [1], d [9], d [17], d [25], clock, x, y, outputDisable, q [0], q [1]); Pr [1] := DMUX2B4CAll (d <ref> [2] </ref>, d [10], d [18], d [26], d [3], d [11], d [19], d [27], clock, x, y, outputDisable, q [2], q [3]); Pr [2] := DMUX2B4CAll (d [4], d [12], d [20], d [28], d [5], d [13], d [21], d [29], clock, x, y, outputDisable, q [4], q [5]); Pr [3] := DMUX2B4CAll (d [6], d [14], d [22], d [30], d [7], d [15], d [23], d [31], <p> [8], d [16], d [24], d [1], d [9], d [17], d [25], clock, x, y, outputDisable, q [0], q [1]); Pr [1] := DMUX2B4CAll (d <ref> [2] </ref>, d [10], d [18], d [26], d [3], d [11], d [19], d [27], clock, x, y, outputDisable, q [2], q [3]); Pr [2] := DMUX2B4CAll (d [4], d [12], d [20], d [28], d [5], d [13], d [21], d [29], clock, x, y, outputDisable, q [4], q [5]); Pr [3] := DMUX2B4CAll (d [6], d [14], d [22], d [30], d [7], d [15], d [23], d [31], clock, x, y, outputDisable, <p> DATASWITCH_N_SIMPL ((d,grant,outputDisable),dOut) = (FOR i ::(TO (SIGLEN dOut)). DATASWITCHC_SPEC ((d,SBIT i grant,SBIT i outputDisable),SBIT i dOut)) Qudos HDL DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.19.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). <p> DATASWITCHC_SPEC ((d,SBIT i grant,SBIT i outputDisable),SBIT i dOut)) Qudos HDL DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.19.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). <p> DATASWITCHC_SPEC ((d,SBIT i grant,SBIT i outputDisable),SBIT i dOut)) Qudos HDL DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.19.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). <p> i grant,SBIT i outputDisable),SBIT i dOut)) Qudos HDL DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.19.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). <p> PAUSE_SPEC (d,dPause) ^ DATASWITCH_N_SPEC ((dPause,grant,outputDisable),dOut)) Qudos HDL Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.20.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). <p> ((dPause,grant,outputDisable),dOut)) Qudos HDL Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.20.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). <p> HDL Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.20.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). <p> [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.20.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). <p> i hiR,SBIT i genR,SREMBIT i hiR),SBIT i req)) Qudos HDL DEF PRIFIL4CLB (hiR [0..3], genR [0..3]: IN; req [0..3]: IO); BEGIN 60 61 PriUnit [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit [1] := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit <ref> [2] </ref> := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR [3], req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three stages. <p> i hiR),SBIT i req)) Qudos HDL DEF PRIFIL4CLB (hiR [0..3], genR [0..3]: IN; req [0..3]: IO); BEGIN 60 61 PriUnit [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit [1] := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit <ref> [2] </ref> := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR [3], req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three stages. <p> i req)) Qudos HDL DEF PRIFIL4CLB (hiR [0..3], genR [0..3]: IN; req [0..3]: IO); BEGIN 60 61 PriUnit [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit [1] := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit <ref> [2] </ref> := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR [3], req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three stages. <p> (hiR [0..3], genR [0..3]: IN; req [0..3]: IO); BEGIN 60 61 PriUnit [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit [1] := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit <ref> [2] </ref> := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR [3], req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three stages. First we prove a generic theorem that the structural specification given in terms of the specification of its parts implements the behavioural specification. <p> ^ XiAND (SWORD [act; pri; r1Bar; r2],SBIT 1 hiReq) ^ XiAND (SWORD [act; pri; r1; r2Bar],SBIT 2 hiReq) ^ XiAND (SWORD [act; pri; r1; r2],SBIT 3 hiReq) Qudos HDL AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq [1] := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq <ref> [2] </ref> := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq [3] := XiAND4 (act, pri, r1, r2, hiReq [3]); 3.25.3 The Correctness Statement ` 8 act pri r1 r2 r1Bar r2Bar. FOR hiReq ::(PSIGLEN 4). <p> hiReq) ^ XiAND (SWORD [act; pri; r1; r2Bar],SBIT 2 hiReq) ^ XiAND (SWORD [act; pri; r1; r2],SBIT 3 hiReq) Qudos HDL AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq [1] := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq <ref> [2] </ref> := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq [3] := XiAND4 (act, pri, r1, r2, hiReq [3]); 3.25.3 The Correctness Statement ` 8 act pri r1 r2 r1Bar r2Bar. FOR hiReq ::(PSIGLEN 4). <p> [act; r1Bar; r2Bar],SBIT 0 genReq) ^ XiAND (SWORD [act; r1Bar; r2],SBIT 1 genReq) ^ XiAND (SWORD [act; r1; r2Bar],SBIT 2 genReq) ^ XiAND (SWORD [act; r1; r2],SBIT 3 genReq) Qudos HDL AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq <ref> [2] </ref> := XiAND3 (act, r1, r2Bar, genReq [2]); 67 AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); 3.26.3 The Correctness Statement ` 8 act r1 r2 r1Bar r2Bar. FOR genReq ::(PSIGLEN 4). <p> (SWORD [act; r1Bar; r2],SBIT 1 genReq) ^ XiAND (SWORD [act; r1; r2Bar],SBIT 2 genReq) ^ XiAND (SWORD [act; r1; r2],SBIT 3 genReq) Qudos HDL AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq <ref> [2] </ref> := XiAND3 (act, r1, r2Bar, genReq [2]); 67 AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); 3.26.3 The Correctness Statement ` 8 act r1 r2 r1Bar r2Bar. FOR genReq ::(PSIGLEN 4). <p> ((act,r1,r2,r1Bar,r2Bar),genReq)) Qudos HDL DEF DECODE (act, pri, r1, r2: IN; hiReq [0..3], genReq [0..3]: IO); r1Bar, r2Bar: IO; BEGIN InvR1 := XiINV (r1, r1Bar); InvR2 := XiINV (r2, r2Bar); AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq [1] := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq <ref> [2] </ref> := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq [3] := XiAND4 (act, pri, r1, r2, hiReq [3]); AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); AndGenReq [3] := XiAND3 (act, <p> r2: IN; hiReq [0..3], genReq [0..3]: IO); r1Bar, r2Bar: IO; BEGIN InvR1 := XiINV (r1, r1Bar); InvR2 := XiINV (r2, r2Bar); AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq [1] := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq <ref> [2] </ref> := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq [3] := XiAND4 (act, pri, r1, r2, hiReq [3]); AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); END; 3.27.3 The Correctness <p> [0]); AndHiReq [1] := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq <ref> [2] </ref> := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq [3] := XiAND4 (act, pri, r1, r2, hiReq [3]); AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); END; 3.27.3 The Correctness Statement ` FOR route ::(PSIGLEN 2). FOR hiReq genReq ::(PSIGLEN 4). <p> r1Bar, r2, hiReq [1]); AndHiReq <ref> [2] </ref> := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq [3] := XiAND4 (act, pri, r1, r2, hiReq [3]); AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); END; 3.27.3 The Correctness Statement ` FOR route ::(PSIGLEN 2). FOR hiReq genReq ::(PSIGLEN 4). DECODE ((act,pri,route),hiReq,genReq) DECODE_SPEC ((act,pri,route),hiReq,genReq) 3.28 DECODE N 3.28.1 The Behavioural Specification DECODE N is the top level specification of the Decoder block in the fabric. <p> DECODE_N_SIMPL ((active,priority,route),hiReq,genReq) = (FOR i ::(TO (SIGLEN hiReq)). DECODE_SPEC ((SBIT i active,SBIT i priority,SBIT i route), SBIT i hiReq, SBIT i genReq)) Qudos HDL Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode [1] := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode <ref> [2] </ref> := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode [3] := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); 71 72 3.28.3 The Correctness Statement ` FOR active priority ::(PSIGLEN 4). FOR route ::(PSIG2LEN 4 2). FOR hiReq genReq ::(PSIG2LEN 4 4). <p> ARB_YEL ((x,xBar,reqA,reqB,reqC,reqD),yjk) = (LOCAL reqABar reqBBar term0 term1. XiINV (reqA,reqABar) ^ XiINV (reqB,reqBBar) ^ AO ((term0,reqC,term1,reqD),yjk) ^ XiOR (SWORD [x; reqBBar],term0) ^ XiOR (SWORD [xBar; reqABar],term1)) Qudos HDL (* Jy *) InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req <ref> [2] </ref>, reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm [1], req [1], jy); 73 OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], <p> AoJy := AO (jyTerm [0], req [3], jyTerm [1], req [1], jy); 73 OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req <ref> [2] </ref>, kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.29.3 The Correctness Statement ` 8 x xBar reqA reqB reqC reqD yjk. <p> XiINV (reqA,reqBarJxKx) ^ XiAND (SWORD [fact0; fact1],xjk) ^ XiOR (SWORD [y; reqBarJxKx],fact0) ^ XiOR (SWORD [reqB; reqC],fact1)) Qudos HDL 75 (* Jx *) InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req <ref> [2] </ref>, jxFact [1]); (* Kx *) InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.30.3 The Correctness Statement ` 8 y reqA reqB reqC xjk. <p> XiINV (x,xBar) ^ ARB_YEL_SPEC ((xBar,x,SBIT 3 req,SBIT 1 req,SBIT 2 req,SBIT 0 req),ky)) Qudos HDL (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req <ref> [2] </ref>, kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.31.3 The Correctness Statement ` K_ARBY ((x,req),ky) K_ARBY_SPEC ((x,req),ky) 3.32 J ARBY 3.32.1 The Behavioural Specification J ARBY determines the J input to the JK flip-flop for the low <p> J_ARBY_SIMPL ((x,req),jy) = (LOCAL xBar. XiINV (x,xBar) ^ ARB_YEL_SPEC ((x,xBar,SBIT 0 req,SBIT 2 req,SBIT 3 req,SBIT 1 req),jy)) Qudos HDL (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); 78 InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req <ref> [2] </ref>, reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm [1], req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); 3.32.3 The Correctness Statement ` J_ARBY ((x,req),ky) J_ARBY_SPEC ((x,req),ky) 3.33 ARBY 3.33.1 The Behavioural Specification ARBY determines the J and K <p> ARBY_SIMPL ((x,req),jy,ky) = J_ARBY_SPEC ((x,req),jy) ^ K_ARBY_SPEC ((x,req),ky) Qudos HDL (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); 79 InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req <ref> [2] </ref>, reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm [1], req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); <p> jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req <ref> [2] </ref>, kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); 80 3.33.3 The <p> (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req <ref> [2] </ref>, kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); 80 3.33.3 The Correctness Statement ` ARBY ((x,req),jy,ky) ARBY_SPEC ((x,req),jy,ky) 3.34 ARBX 3.34.1 The Behavioural Specification ARBX determines the J and K inputs to the JK flip-flop for the high bit of the <p> ARBX_SIMPL ((y,req),jx,kx) = ARB_XEL_SPEC ((SBIT 1 req,y,SBIT 3 req,SBIT 2 req),jx) ^ ARB_XEL_SPEC ((SBIT 3 req,y,SBIT 0 req,SBIT 1 req),kx) Qudos HDL ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req <ref> [2] </ref>, y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 <p> ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req <ref> [2] </ref>, y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.34.3 The Correctness Statement ` ARBX ((y,req),jx,kx) ARBX_SPEC ((y,req),jx,kx) 3.35 ARBITER FF 3.35.1 The Behavioural Specification ARBITER FF consists of 2 <p> kx, jx, jy, ky, clock, routeEnable, x, y); FFx := JKFFce (jx, kx, clock, routeEnable, x); FFy := JKFFce (jy, ky, clock, routeEnable, y); 87 (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req <ref> [2] </ref>, reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm [1], req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); <p> jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req <ref> [2] </ref>, kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx <p> xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req <ref> [2] </ref>, kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 <p> ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req <ref> [2] </ref>, y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.37.3 The Correctness Statement ` ARBITER_XY ((ltReq,routeEnable),x,y) ARBITER_XY_SPEC ((ltReq,routeEnable),x,y) 3.38 ARBITER 3.38.1 The Behavioural Specification ARBITER performs round-robin arbitration for a <p> (jx, kx, jx, jy, ky, clock, routeEnable, x, y); FFx := JKFFce (jx, kx, clock, routeEnable, x); FFy := JKFFce (jy, ky, clock, routeEnable, y); (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req <ref> [2] </ref>, reqBarJyCLB2); AoJy := AO (jyTerm [0], req [3], jyTerm [1], req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); <p> jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req <ref> [2] </ref>, kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) <p> (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req <ref> [2] </ref>, kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 <p> ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req <ref> [2] </ref>, y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); AnyOr := XiOR4 (req [0..3], anyReq); AndKout := XiAND2 (anyReq, routeEnable, kOut); FFOutDis := JKFF (fs, kOut, clock, outputDisable, outputEnable); END; <p> PRIORITY_DECODE_SIMPL ((active,priority,route),ltReq) = (LOCAL hiReq genReq req ::(PSIG2LEN 4 4). DECODE_N_SPEC ((active,priority,route),hiReq,genReq) ^ PRIORITY_SPEC ((hiReq,genReq),req) ^ PAUSE_SPEC (req,ltReq)) Qudos HDL Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode [1] := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode <ref> [2] </ref> := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode [3] := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); PriFilter [0-3] := PRIFIL4CLB ( hiReq [0-3], hiReq [4-7], hiReq [8-11], hiReq [12-15], genReq [0-3], genReq [4-7], genReq [8-11], genReq [12-15], req [0-3], req [4-7], req [8-11], req [12-15]); FFReq [0-15] := <p> PRIORITY_DECODE_SPEC ((active,priority,route),ltReq) ^ TIMING_SPEC ((frameStart,active),routeEnable) ^ ARBITERS_SPEC ((ltReq,routeEnable,frameStart),grant,outputDisable)) 99 Qudos HDL Timing := TIMING (frameStart, clock, d [0], d [8], d [16], d [24], routeEnable); Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode [1] := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode <ref> [2] </ref> := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode [3] := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); PriFilter [0-3] := PRIFIL4CLB ( hiReq [0-3], hiReq [4-7], hiReq [8-11], hiReq [12-15], genReq [0-3], genReq [4-7], genReq [8-11], genReq [12-15], req [0-3], req [4-7], req [8-11], req [12-15]); FFReq [0-15] := <p> 2 2 d,frameStart), grant, outputDisable) ^ PAUSE_DATASWITCH_SPEC ((d,grant,outputDisable),dOut) ^ ACK_SPEC ((ackIn,grant,outputDisable),ackOut)) 104 105 Qudos HDL Timing := TIMING (frameStart, clock, d [0], d [8], d [16], d [24], routeEnable); Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode [1] := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode <ref> [2] </ref> := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode [3] := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); PriFilter [0-3] := PRIFIL4CLB ( hiReq [0-3], hiReq [4-7], hiReq [8-11], hiReq [12-15], genReq [0-3], genReq [4-7], genReq [8-11], genReq [12-15], req [0-3], req [4-7], req [8-11], req [12-15]); FFReq [0-15] := <p> [12-15], clock, routeEnable, frameStart, xGrant [0-3], yGrant [0-3], outputDisable [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] <p> [0-3], outputDisable [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr <p> [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := <p> [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm <p> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr <ref> [2] </ref> := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); END; 3.42.3 The Correctness Statement We have proved that for all input and output signals for which the structural specification holds, there exists a signal last of the appropriate size for which the behavioural specification holds. <p> [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr <ref> [2] </ref> := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); END; 3.42.3 The Correctness Statement We have proved that for all input and output signals for which the structural specification holds, there exists a signal last of the appropriate size for which the behavioural specification holds. <p> := XiOUTFFd (dOut [0-31], clock, dOutEXT [0-31]); Ao [0-3] := XiOBUF (ackOut [0-3], ackOutEXT [0-3]); Timing := TIMING (frameStart, clock, d [0], d [8], d [16], d [24], routeEnable); Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode [1] := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode <ref> [2] </ref> := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode [3] := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); PriFilter [0-3] := PRIFIL4CLB ( hiReq [0-3], hiReq [4-7], hiReq [8-11], hiReq [12-15], genReq [0-3], genReq [4-7], genReq [8-11], genReq [12-15], req [0-3], req [4-7], req [8-11], req [12-15]); FFReq [0-15] := <p> [12-15], clock, routeEnable, frameStart, xGrant [0-3], yGrant [0-3], outputDisable [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] <p> [0-3], outputDisable [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr <p> [0-3]); Pause [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := <p> [0-31] := XiDFFd (d [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw <ref> [2] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw [3] := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm <p> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr <ref> [2] </ref> := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); END; 3.43.3 The Correctness Statement We have proved that for all input and output signals for which the structural specification holds, there exists a signal last of the appropriate size for which the behavioural specification holds. <p> [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr <ref> [2] </ref> := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); END; 3.43.3 The Correctness Statement We have proved that for all input and output signals for which the structural specification holds, there exists a signal last of the appropriate size for which the behavioural specification holds.
Reference: [3] <author> Wai Wong. </author> <title> Modelling bit vectors in HOL: the word library. </title> <booktitle> In Proceedings of the 1993 International Workshop on Higher Order Logic Theorem Proving and its Applications, </booktitle> <year> 1993. </year> <month> 114 </month>
Reference-contexts: The latter are described in Section 2.8. A detailed account of the HOL system and the higher order logic notation is given by Gordon and Melham [2]. A description of the word library is given by Wong <ref> [3] </ref>. We do not give type information in the definitions. This can normally be determined from context. Normally, the most general types possible are used. 2 General Definitions In this section we give the general definitions upon which the specifications of the modules are based. <p> disabled: IN; ackTerm [0..3] : IO); xBar, yBar, ackTermPre [0..3]: IO; BEGIN InvX := XiINV (x, xBar); InvY := XiINV (y, yBar); NandAckTermPre [0] := XiNAND3 (xBar, yBar, ackIn, ackTermPre [0]); NandAckTermPre [1] := XiNAND3 (xBar, y, ackIn, ackTermPre [1]); NandAckTermPre [2] := XiNAND3 (x, yBar, ackIn, ackTermPre [2]); NandAckTermPre <ref> [3] </ref> := XiNAND3 (x, y, ackIn, ackTermPre [3]); NorDis [0-3] := XiNOR2 (ackTermPre [0-3], disabled, ackTerm [0-3]); END; 3.11.3 The Correctness Statement Because the structural definition was not generic, the correctness theorem cannot be generic. <p> yBar, ackTermPre [0..3]: IO; BEGIN InvX := XiINV (x, xBar); InvY := XiINV (y, yBar); NandAckTermPre [0] := XiNAND3 (xBar, yBar, ackIn, ackTermPre [0]); NandAckTermPre [1] := XiNAND3 (xBar, y, ackIn, ackTermPre [1]); NandAckTermPre [2] := XiNAND3 (x, yBar, ackIn, ackTermPre [2]); NandAckTermPre <ref> [3] </ref> := XiNAND3 (x, y, ackIn, ackTermPre [3]); NorDis [0-3] := XiNOR2 (ackTermPre [0-3], disabled, ackTerm [0-3]); END; 3.11.3 The Correctness Statement Because the structural definition was not generic, the correctness theorem cannot be generic. <p> ACKOR_N_SIMPL (ackTerm,ackOut) = (FOR i ::(TO (SIGLEN ackOut)). ACKOR_SPEC (SBIT i ackTerm,SBIT i ackOut)) 38 Qudos HDL AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr <ref> [3] </ref> := ACKOR (ackTerm [12..15], ackOut [3]); 3.12.3 The Correctness Statement As the structural description is generic with respect to word sizes, the correctness theorem can also be generic. Two restrictions are placed on the sizes. First, ackOut must be the same size as the top level of ackTerm|n. <p> ACKOR_N_SIMPL (ackTerm,ackOut) = (FOR i ::(TO (SIGLEN ackOut)). ACKOR_SPEC (SBIT i ackTerm,SBIT i ackOut)) 38 Qudos HDL AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr <ref> [3] </ref> := ACKOR (ackTerm [12..15], ackOut [3]); 3.12.3 The Correctness Statement As the structural description is generic with respect to word sizes, the correctness theorem can also be generic. Two restrictions are placed on the sizes. First, ackOut must be the same size as the top level of ackTerm|n. <p> ACKOR_N_SPEC (ackTerm,ackOut)) Qudos HDL AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], 42 outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr <ref> [3] </ref> := ACKOR (ackTerm [12..15], ackOut [3]); 3.14.3 The Correctness Statement ` FOR ackIn ackOut outputDisable ::(PSIGLEN 4). FOR grant ::(PSIG2LEN 4 2). ACK ((ackIn,grant,outputDisable),ackOut) ACK_SPEC ((ackIn,grant,outputDisable),ackOut) 3.15 DMUX4T2FFC 3.15.1 The Behavioural Specification DMUX4T2FFC selects 2 bits from a 4-bit word d. <p> := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], 42 outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr <ref> [3] </ref> := ACKOR (ackTerm [12..15], ackOut [3]); 3.14.3 The Correctness Statement ` FOR ackIn ackOut outputDisable ::(PSIGLEN 4). FOR grant ::(PSIG2LEN 4 2). ACK ((ackIn,grant,outputDisable),ackOut) ACK_SPEC ((ackIn,grant,outputDisable),ackOut) 3.15 DMUX4T2FFC 3.15.1 The Behavioural Specification DMUX4T2FFC selects 2 bits from a 4-bit word d. If outputDisable is set then a zero word is output. <p> clock, y, outputDisable: IN; q [0..1]: IO); yBar, mux [0..1] : IO; BEGIN Clb := XiCLBMAP5i2okr (d [0..1], y, d [2..3], clock, outputDisable, q [0..1]); InvY := XiINV (y, yBar); B [0] := AO (d [0], yBar, d [1], y, mux [0]); B [1] := AO (d [2], yBar, d <ref> [3] </ref>, y, mux [1]); BFF [0-1] := XiDFFrd (mux [0-1], clock, outputDisable, q [0-1]); END; 3.15.3 The Correctness Statement ` FOR q ::(PSIGLEN 2). <p> Qudos HDL DEF DMUX4T2 (d [0..3], x: IN; dOut [0..1]: IO); xBar : IO; BEGIN Clb := XiCLBMAP5i2o (d [0..1], x, d [2..3], dOut [0..1]); InvX := XiINV (x, xBar); B [0] := AO (d [0], xBar, d [1], x, dOut [0]); B [1] := AO (d [2], xBar, d <ref> [3] </ref>, x, dOut [1]); END; 3.16.3 The Correctness Statement ` 8 x. FOR d ::(PSIG2LEN 2 2). FOR dOut ::(PSIGLEN 2). DMUX4T2 ((d,x),dOut) DMUX4T2_SPEC ((d,x),dOut) 3.17 DMUX2B4CAll 3.17.1 The Behavioural Specification DMUX2B4CAll chooses the grant th bit of each of the 2 words of which d consists. <p> clock, x, y, outputDisable: IN; q [0..7]: IO); BEGIN Pr [0] := DMUX2B4CAll (d [0], d [8], d [16], d [24], d [1], d [9], d [17], d [25], clock, x, y, outputDisable, q [0], q [1]); Pr [1] := DMUX2B4CAll (d [2], d [10], d [18], d [26], d <ref> [3] </ref>, d [11], d [19], d [27], clock, x, y, outputDisable, q [2], q [3]); Pr [2] := DMUX2B4CAll (d [4], d [12], d [20], d [28], d [5], d [13], d [21], d [29], clock, x, y, outputDisable, q [4], q [5]); Pr [3] := DMUX2B4CAll (d [6], d [14], <p> [0], d [8], d [16], d [24], d [1], d [9], d [17], d [25], clock, x, y, outputDisable, q [0], q [1]); Pr [1] := DMUX2B4CAll (d [2], d [10], d [18], d [26], d <ref> [3] </ref>, d [11], d [19], d [27], clock, x, y, outputDisable, q [2], q [3]); Pr [2] := DMUX2B4CAll (d [4], d [12], d [20], d [28], d [5], d [13], d [21], d [29], clock, x, y, outputDisable, q [4], q [5]); Pr [3] := DMUX2B4CAll (d [6], d [14], d [22], d [30], d [7], d [15], d [23], d [31], clock, x, <p> [10], d [18], d [26], d <ref> [3] </ref>, d [11], d [19], d [27], clock, x, y, outputDisable, q [2], q [3]); Pr [2] := DMUX2B4CAll (d [4], d [12], d [20], d [28], d [5], d [13], d [21], d [29], clock, x, y, outputDisable, q [4], q [5]); Pr [3] := DMUX2B4CAll (d [6], d [14], d [22], d [30], d [7], d [15], d [23], d [31], clock, x, y, outputDisable, q [6], q [7]); END; 3.18.3 The Correctness Statement ` FOR d ::(PSIG2LEN 4 8). FOR q ::(PSIGLEN 8). FOR grant ::(PSIGLEN 2). <p> i dOut)) Qudos HDL DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.19.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). <p> DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.19.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). DATASWITCH_N ((d,grant,outputDisable),dOut) DATASWITCH_N_SPEC ((d,grant,outputDisable),dOut) 3.20 PAUSE DATASWITCH 3.20.1 The Behavioural Specification PAUSE DATASWITCH chooses a word to be output to each of the output ports. <p> [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.19.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). DATASWITCH_N ((d,grant,outputDisable),dOut) DATASWITCH_N_SPEC ((d,grant,outputDisable),dOut) 3.20 PAUSE DATASWITCH 3.20.1 The Behavioural Specification PAUSE DATASWITCH chooses a word to be output to each of the output ports. <p> xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.19.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). DATASWITCH_N ((d,grant,outputDisable),dOut) DATASWITCH_N_SPEC ((d,grant,outputDisable),dOut) 3.20 PAUSE DATASWITCH 3.20.1 The Behavioural Specification PAUSE DATASWITCH chooses a word to be output to each of the output ports. <p> [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.20.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). PAUSE_DATASWITCH ((d,grant,outputDisable),dOut) PAUSE_DATASWITCH_SPEC ((d,grant,outputDisable),dOut) 3.21 TIMING 3.21.1 The Behavioural Specification TIMING determines when the arbitration unit is triggered. <p> DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.20.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). PAUSE_DATASWITCH ((d,grant,outputDisable),dOut) PAUSE_DATASWITCH_SPEC ((d,grant,outputDisable),dOut) 3.21 TIMING 3.21.1 The Behavioural Specification TIMING determines when the arbitration unit is triggered. <p> [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.20.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). PAUSE_DATASWITCH ((d,grant,outputDisable),dOut) PAUSE_DATASWITCH_SPEC ((d,grant,outputDisable),dOut) 3.21 TIMING 3.21.1 The Behavioural Specification TIMING determines when the arbitration unit is triggered. <p> xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); 3.20.3 The Correctness Statement ` FOR grant ::(PSIG2LEN 4 2). FOR dOut d ::(PSIG2LEN 4 8). PAUSE_DATASWITCH ((d,grant,outputDisable),dOut) PAUSE_DATASWITCH_SPEC ((d,grant,outputDisable),dOut) 3.21 TIMING 3.21.1 The Behavioural Specification TIMING determines when the arbitration unit is triggered. <p> DEF PRIFIL4CLB (hiR [0..3], genR [0..3]: IN; req [0..3]: IO); BEGIN 60 61 PriUnit [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit [1] := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit [2] := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR <ref> [3] </ref>, req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three stages. <p> genR [0..3]: IN; req [0..3]: IO); BEGIN 60 61 PriUnit [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit [1] := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit [2] := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR <ref> [3] </ref>, req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three stages. First we prove a generic theorem that the structural specification given in terms of the specification of its parts implements the behavioural specification. <p> [0..3]: IO); BEGIN 60 61 PriUnit [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit [1] := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit [2] := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR <ref> [3] </ref>, req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three stages. First we prove a generic theorem that the structural specification given in terms of the specification of its parts implements the behavioural specification. <p> BEGIN 60 61 PriUnit [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit [1] := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit [2] := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR <ref> [3] </ref>, req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three stages. First we prove a generic theorem that the structural specification given in terms of the specification of its parts implements the behavioural specification. <p> [0] := PRIFILUNIT (hiR [0], genR [0], hiR [1..3], req [0]); PriUnit [1] := PRIFILUNIT (hiR [1], genR [1], hiR [0], hiR [2..3], req [1]); PriUnit [2] := PRIFILUNIT (hiR [2], genR [2], hiR [0..1], hiR <ref> [3] </ref>, req [2]); PriUnit [3] := PRIFILUNIT (hiR [3], genR [3], hiR [0..2], req [3]); END; 3.23.3 The Correctness Statement The correctness theorem is proved in three stages. First we prove a generic theorem that the structural specification given in terms of the specification of its parts implements the behavioural specification. <p> XiAND (SWORD [act; pri; r1; r2Bar],SBIT 2 hiReq) ^ XiAND (SWORD [act; pri; r1; r2],SBIT 3 hiReq) Qudos HDL AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq [1] := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq [2] := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq <ref> [3] </ref> := XiAND4 (act, pri, r1, r2, hiReq [3]); 3.25.3 The Correctness Statement ` 8 act pri r1 r2 r1Bar r2Bar. FOR hiReq ::(PSIGLEN 4). <p> ^ XiAND (SWORD [act; pri; r1; r2],SBIT 3 hiReq) Qudos HDL AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq [1] := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq [2] := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq <ref> [3] </ref> := XiAND4 (act, pri, r1, r2, hiReq [3]); 3.25.3 The Correctness Statement ` 8 act pri r1 r2 r1Bar r2Bar. FOR hiReq ::(PSIGLEN 4). <p> r2],SBIT 1 genReq) ^ XiAND (SWORD [act; r1; r2Bar],SBIT 2 genReq) ^ XiAND (SWORD [act; r1; r2],SBIT 3 genReq) Qudos HDL AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); 67 AndGenReq <ref> [3] </ref> := XiAND3 (act, r1, r2, genReq [3]); 3.26.3 The Correctness Statement ` 8 act r1 r2 r1Bar r2Bar. FOR genReq ::(PSIGLEN 4). <p> r1; r2Bar],SBIT 2 genReq) ^ XiAND (SWORD [act; r1; r2],SBIT 3 genReq) Qudos HDL AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); 67 AndGenReq <ref> [3] </ref> := XiAND3 (act, r1, r2, genReq [3]); 3.26.3 The Correctness Statement ` 8 act r1 r2 r1Bar r2Bar. FOR genReq ::(PSIGLEN 4). GENREQ ((act,r1,r2,r1Bar,r2Bar),genReq) GENREQ_SPEC ((act,r1,r2,r1Bar,r2Bar),genReq) 3.27 DECODE 3.27.1 The Behavioural Specification DECODE converts the active, act, priority, pri, and route route signals of an input port into 4-bit position vectors genReq and hiReq. <p> hiReq [0..3], genReq [0..3]: IO); r1Bar, r2Bar: IO; BEGIN InvR1 := XiINV (r1, r1Bar); InvR2 := XiINV (r2, r2Bar); AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq [1] := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq [2] := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq <ref> [3] </ref> := XiAND4 (act, pri, r1, r2, hiReq [3]); AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); END; 3.27.3 The Correctness Statement ` <p> BEGIN InvR1 := XiINV (r1, r1Bar); InvR2 := XiINV (r2, r2Bar); AndHiReq [0] := XiAND4 (act, pri, r1Bar, r2Bar, hiReq [0]); AndHiReq [1] := XiAND4 (act, pri, r1Bar, r2, hiReq [1]); AndHiReq [2] := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq <ref> [3] </ref> := XiAND4 (act, pri, r1, r2, hiReq [3]); AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); END; 3.27.3 The Correctness Statement ` FOR route ::(PSIGLEN 2). <p> hiReq [1]); AndHiReq [2] := XiAND4 (act, pri, r1, r2Bar, hiReq [2]); AndHiReq <ref> [3] </ref> := XiAND4 (act, pri, r1, r2, hiReq [3]); AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); END; 3.27.3 The Correctness Statement ` FOR route ::(PSIGLEN 2). FOR hiReq genReq ::(PSIGLEN 4). DECODE ((act,pri,route),hiReq,genReq) DECODE_SPEC ((act,pri,route),hiReq,genReq) 3.28 DECODE N 3.28.1 The Behavioural Specification DECODE N is the top level specification of the Decoder block in the fabric. <p> pri, r1, r2Bar, hiReq [2]); AndHiReq <ref> [3] </ref> := XiAND4 (act, pri, r1, r2, hiReq [3]); AndGenReq [0] := XiAND3 (act, r1Bar, r2Bar, genReq [0]); AndGenReq [1] := XiAND3 (act, r1Bar, r2, genReq [1]); AndGenReq [2] := XiAND3 (act, r1, r2Bar, genReq [2]); AndGenReq [3] := XiAND3 (act, r1, r2, genReq [3]); END; 3.27.3 The Correctness Statement ` FOR route ::(PSIGLEN 2). FOR hiReq genReq ::(PSIGLEN 4). DECODE ((act,pri,route),hiReq,genReq) DECODE_SPEC ((act,pri,route),hiReq,genReq) 3.28 DECODE N 3.28.1 The Behavioural Specification DECODE N is the top level specification of the Decoder block in the fabric. <p> DECODE_SPEC ((SBIT i active,SBIT i priority,SBIT i route), SBIT i hiReq, SBIT i genReq)) Qudos HDL Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode [1] := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode [2] := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode <ref> [3] </ref> := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); 71 72 3.28.3 The Correctness Statement ` FOR active priority ::(PSIGLEN 4). FOR route ::(PSIG2LEN 4 2). FOR hiReq genReq ::(PSIG2LEN 4 4). <p> ARB_YEL ((x,xBar,reqA,reqB,reqC,reqD),yjk) = (LOCAL reqABar reqBBar term0 term1. XiINV (reqA,reqABar) ^ XiINV (reqB,reqBBar) ^ AO ((term0,reqC,term1,reqD),yjk) ^ XiOR (SWORD [x; reqBBar],term0) ^ XiOR (SWORD [xBar; reqABar],term1)) Qudos HDL (* Jy *) InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req <ref> [3] </ref>, jyTerm [1], req [1], jy); 73 OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy <p> [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req <ref> [3] </ref>, jyTerm [1], req [1], jy); 73 OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.29.3 The Correctness Statement ` 8 x xBar reqA reqB reqC reqD yjk. <p> XiINV (reqA,reqBarJxKx) ^ XiAND (SWORD [fact0; fact1],xjk) ^ XiOR (SWORD [y; reqBarJxKx],fact0) ^ XiOR (SWORD [reqB; reqC],fact1)) Qudos HDL 75 (* Jx *) InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req <ref> [3] </ref>, req [2], jxFact [1]); (* Kx *) InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.30.3 The Correctness Statement ` 8 y reqA reqB reqC xjk. <p> [y; reqBarJxKx],fact0) ^ XiOR (SWORD [reqB; reqC],fact1)) Qudos HDL 75 (* Jx *) InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req <ref> [3] </ref>, req [2], jxFact [1]); (* Kx *) InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.30.3 The Correctness Statement ` 8 y reqA reqB reqC xjk. <p> K_ARBY_SIMPL ((x,req),ky) = (LOCAL xBar. XiINV (x,xBar) ^ ARB_YEL_SPEC ((xBar,x,SBIT 3 req,SBIT 1 req,SBIT 2 req,SBIT 0 req),ky)) Qudos HDL (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req <ref> [3] </ref>, reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 3.31.3 The Correctness Statement ` K_ARBY ((x,req),ky) K_ARBY_SPEC ((x,req),ky) 3.32 J ARBY 3.32.1 The Behavioural Specification J ARBY determines the J <p> XiINV (x,xBar) ^ ARB_YEL_SPEC ((x,xBar,SBIT 0 req,SBIT 2 req,SBIT 3 req,SBIT 1 req),jy)) Qudos HDL (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); 78 InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req <ref> [3] </ref>, jyTerm [1], req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); 3.32.3 The Correctness Statement ` J_ARBY ((x,req),ky) J_ARBY_SPEC ((x,req),ky) 3.33 ARBY 3.33.1 The Behavioural Specification ARBY determines the J and K inputs to the JK flip-flop for the low <p> ARBY_SIMPL ((x,req),jy,ky) = J_ARBY_SPEC ((x,req),jy) ^ K_ARBY_SPEC ((x,req),ky) Qudos HDL (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); 79 InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req <ref> [3] </ref>, jyTerm [1], req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := <p> (jyTerm [0], req <ref> [3] </ref>, jyTerm [1], req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 <p> := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req <ref> [3] </ref>, reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); 80 3.33.3 The Correctness Statement ` ARBY ((x,req),jy,ky) ARBY_SPEC ((x,req),jy,ky) 3.34 ARBX 3.34.1 The Behavioural Specification ARBX determines the J and K inputs to the JK flip-flop for the high bit of the grant signal from <p> AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req <ref> [3] </ref>, jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); 80 3.33.3 The Correctness Statement ` ARBY ((x,req),jy,ky) ARBY_SPEC ((x,req),jy,ky) 3.34 ARBX 3.34.1 The Behavioural Specification ARBX determines the J and K inputs to the JK flip-flop for the high bit of the grant signal from the arbiter. ` 8 y req jx kx. <p> ARBX_SIMPL ((y,req),jx,kx) = ARB_XEL_SPEC ((SBIT 1 req,y,SBIT 3 req,SBIT 2 req),jx) ^ ARB_XEL_SPEC ((SBIT 3 req,y,SBIT 0 req,SBIT 1 req),kx) Qudos HDL ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req <ref> [3] </ref>, jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); <p> ARBX_SIMPL ((y,req),jx,kx) = ARB_XEL_SPEC ((SBIT 1 req,y,SBIT 3 req,SBIT 2 req),jx) ^ ARB_XEL_SPEC ((SBIT 3 req,y,SBIT 0 req,SBIT 1 req),kx) Qudos HDL ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req <ref> [3] </ref>, jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req <p> Qudos HDL ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req <ref> [3] </ref>, jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.34.3 The Correctness Statement ` ARBX ((y,req),jx,kx) ARBX_SPEC ((y,req),jx,kx) 3.35 ARBITER FF 3.35.1 The Behavioural Specification ARBITER FF consists <p> FFx := JKFFce (jx, kx, clock, routeEnable, x); FFy := JKFFce (jy, ky, clock, routeEnable, y); 87 (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req <ref> [3] </ref>, jyTerm [1], req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := <p> (jyTerm [0], req <ref> [3] </ref>, jyTerm [1], req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); <p> XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req <ref> [3] </ref>, reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); <p> (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req <ref> [3] </ref>, jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req <p> [1]); 88 ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req <ref> [3] </ref>, jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); 3.37.3 The Correctness Statement ` ARBITER_XY ((ltReq,routeEnable),x,y) ARBITER_XY_SPEC ((ltReq,routeEnable),x,y) 3.38 ARBITER 3.38.1 The Behavioural Specification ARBITER performs round-robin arbitration <p> y); FFx := JKFFce (jx, kx, clock, routeEnable, x); FFy := JKFFce (jy, ky, clock, routeEnable, y); (* Jy *) ClbJy := XiCLBMAP5i1o (x, req [0..3], jy); InvXJyCLB := XiINV (x, xBarJyCLB); InvReq0JyCLB := XiINV (req [0], reqBarJyCLB0); InvReq2JyCLB := XiINV (req [2], reqBarJyCLB2); AoJy := AO (jyTerm [0], req <ref> [3] </ref>, jyTerm [1], req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := <p> (jyTerm [0], req <ref> [3] </ref>, jyTerm [1], req [1], jy); OrTermJy [0] := XiOR2 (x, reqBarJyCLB2, jyTerm [0]); OrTermJy [1] := XiOR2 (xBarJyCLB, reqBarJyCLB0, jyTerm [1]); (* Ky *) ClbKy := XiCLBMAP5i1o (x, req [0..3], ky); InvXKyCLB := XiINV (x, xBarKyCLB); InvReq1KyCLB := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req [3], reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 <p> := XiINV (req [1], reqBarKyCLB1); InvReq3KyCLB := XiINV (req <ref> [3] </ref>, reqBarKyCLB3); AoKy := AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req [3], jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); <p> AO (kyTerm [0], req [2], kyTerm [1], req [0], ky); OrTermKy [0] := XiOR2 (xBarKyCLB, reqBarKyCLB1, kyTerm [0]); OrTermKy [1] := XiOR2 (x, reqBarKyCLB3, kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req <ref> [3] </ref>, jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req <p> kyTerm [1]); ClbJxKx := XiCLBMAP5i2o (req [0], req [1], req [2], y, req <ref> [3] </ref>, jx, kx); InvReqJxKxCLB1 := XiINV (req [1], reqBarJxKxCLB1); InvReqJxKxCLB3 := XiINV (req [3], reqBarJxKxCLB3); (* Jx *) AndJx := XiAND2 (jxFact [0..1], jx); OrFactJx [0] := XiOR2 (y, reqBarJxKxCLB1, jxFact [0]); OrFactJx [1] := XiOR2 (req [3], req [2], jxFact [1]); (* Kx *) AndKx := XiAND2 (kxFact [0..1], kx); OrFactKx [0] := XiOR2 (y, reqBarJxKxCLB3, kxFact [0]); OrJactKx [1] := XiOR2 (req [0], req [1], kxFact [1]); AnyOr := XiOR4 (req [0..3], anyReq); AndKout := XiAND2 (anyReq, routeEnable, kOut); FFOutDis := JKFF (fs, kOut, clock, outputDisable, <p> DECODE_N_SPEC ((active,priority,route),hiReq,genReq) ^ PRIORITY_SPEC ((hiReq,genReq),req) ^ PAUSE_SPEC (req,ltReq)) Qudos HDL Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode [1] := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode [2] := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode <ref> [3] </ref> := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); PriFilter [0-3] := PRIFIL4CLB ( hiReq [0-3], hiReq [4-7], hiReq [8-11], hiReq [12-15], genReq [0-3], genReq [4-7], genReq [8-11], genReq [12-15], req [0-3], req [4-7], req [8-11], req [12-15]); FFReq [0-15] := XiDFFd (req [0-15], clock, ltReq [0-15]); 3.40.3 The Correctness Statement <p> ARBITERS_SPEC ((ltReq,routeEnable,frameStart),grant,outputDisable)) 99 Qudos HDL Timing := TIMING (frameStart, clock, d [0], d [8], d [16], d [24], routeEnable); Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode [1] := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode [2] := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode <ref> [3] </ref> := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); PriFilter [0-3] := PRIFIL4CLB ( hiReq [0-3], hiReq [4-7], hiReq [8-11], hiReq [12-15], genReq [0-3], genReq [4-7], genReq [8-11], genReq [12-15], req [0-3], req [4-7], req [8-11], req [12-15]); FFReq [0-15] := XiDFFd (req [0-15], clock, ltReq [0-15]); Arb [0-3] := ARBITER <p> ((ackIn,grant,outputDisable),ackOut)) 104 105 Qudos HDL Timing := TIMING (frameStart, clock, d [0], d [8], d [16], d [24], routeEnable); Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode [1] := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode [2] := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode <ref> [3] </ref> := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); PriFilter [0-3] := PRIFIL4CLB ( hiReq [0-3], hiReq [4-7], hiReq [8-11], hiReq [12-15], genReq [0-3], genReq [4-7], genReq [8-11], genReq [12-15], req [0-3], req [4-7], req [8-11], req [12-15]); FFReq [0-15] := XiDFFd (req [0-15], clock, ltReq [0-15]); Arb [0-3] := ARBITER <p> [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr <p> DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); <p> [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] <p> xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR <p> <ref> [3] </ref>, outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); END; 3.42.3 The Correctness Statement We have proved that for all input and output signals for which the structural specification holds, there exists a signal last of the appropriate size for which the behavioural specification holds. <p> [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr <ref> [3] </ref> := ACKOR (ackTerm [12..15], ackOut [3]); END; 3.42.3 The Correctness Statement We have proved that for all input and output signals for which the structural specification holds, there exists a signal last of the appropriate size for which the behavioural specification holds. <p> XiOBUF (ackOut [0-3], ackOutEXT [0-3]); Timing := TIMING (frameStart, clock, d [0], d [8], d [16], d [24], routeEnable); Decode [0] := DECODE (d [0..3], hiReq [0..3], genReq [0..3]); Decode [1] := DECODE (d [8..11], hiReq [4..7], genReq [4..7]); Decode [2] := DECODE (d [16..19], hiReq [8..11], genReq [8..11]); Decode <ref> [3] </ref> := DECODE (d [24..27], hiReq [12..15], genReq [12..15]); PriFilter [0-3] := PRIFIL4CLB ( hiReq [0-3], hiReq [4-7], hiReq [8-11], hiReq [12-15], genReq [0-3], genReq [4-7], genReq [8-11], genReq [12-15], req [0-3], req [4-7], req [8-11], req [12-15]); FFReq [0-15] := XiDFFd (req [0-15], clock, ltReq [0-15]); 112 Arb [0-3] := <p> [0-31], clock, dPause [0-31]); DSw [0] := DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr <p> DATASWITCH (dPause [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); <p> [0..31], clock, xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] <p> xGrant [0], yGrant [0], outputDisable [0], dOut [0..7]); DSw [1] := DATASWITCH (dPause [0..31], clock, xGrant [1], yGrant [1], outputDisable [1], dOut [8..15]); DSw [2] := DATASWITCH (dPause [0..31], clock, xGrant [2], yGrant [2], outputDisable [2], dOut [16..23]); DSw <ref> [3] </ref> := DATASWITCH (dPause [0..31], clock, xGrant [3], yGrant [3], outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR <p> <ref> [3] </ref>, outputDisable [3], dOut [24..31]); AckGen [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr [3] := ACKOR (ackTerm [12..15], ackOut [3]); END; 3.43.3 The Correctness Statement We have proved that for all input and output signals for which the structural specification holds, there exists a signal last of the appropriate size for which the behavioural specification holds. <p> [0-3] := ACKGEN (ackIn [0-3], xGrant [0-3], yGrant [0-3], outputDisable [0-3], ackTerm [0-3], ackTerm [4-7], ackTerm [8-11], ackTerm [12-15]); AckOr [0] := ACKOR (ackTerm [0..3], ackOut [0]); AckOr [1] := ACKOR (ackTerm [4..7], ackOut [1]); AckOr [2] := ACKOR (ackTerm [8..11], ackOut [2]); AckOr <ref> [3] </ref> := ACKOR (ackTerm [12..15], ackOut [3]); END; 3.43.3 The Correctness Statement We have proved that for all input and output signals for which the structural specification holds, there exists a signal last of the appropriate size for which the behavioural specification holds.
References-found: 3

