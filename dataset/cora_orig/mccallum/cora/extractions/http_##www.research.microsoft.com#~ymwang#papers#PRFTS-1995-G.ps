URL: http://www.research.microsoft.com/~ymwang/papers/PRFTS-1995-G.ps
Refering-URL: http://www.research.microsoft.com/~ymwang/papers/PRFTS95CR.htm
Root-URL: http://www.research.microsoft.com
Title: Guaranteed Deadlock Recovery: Deadlock Resolution with Rollback Propagation  
Author: Yi-Min Wang Michael Merritt Alexander B. Romanovsky 
Abstract: Traditionally, deadlock resolution is performed by simply aborting any process or the lowest-priority process (called the victim) involved in a deadlock cycle. In message-passing systems where rollback propagation due to message dependencies is possible, the rollback of the victim may require other processes to roll back as well, and the restarted processes may get into the same deadlock again. We introduce the concept of guaranteed deadlock recovery which guarantees that a broken deadlock cycle will not be re-formed after the rollback, and show how to achieve this by carefully selecting the victim based on run-time dependency information. We also demonstrate a technique to incorporate a dynamic priority scheme into a distributed deadlock detection algorithm to guarantee deadlock recovery. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit. </title> <journal> IEEE Trans. Com-put., </journal> <volume> 41(5) </volume> <pages> 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Message logging is a technique that saves messages onto stable storage so that the messages can be replayed after a process rolls back to a checkpoint. Traditional checkpointing and message logging techniques <ref> [4, 1] </ref> have been designed primarily for hardware failure recovery. A physical failure uniquely determines the set of lost volatile process states and message logs. <p> For general nondeterministic executions, we identify a sufficient condition for guaranteed deadlock recovery in Section 3, that uses a directed rollback-dependency graph. Under the piecewise deterministic execution model <ref> [1] </ref>, we present in Section 4 a dynamic priority scheme based on transitive dependency tracking, and demonstrate a technique to incorporate it into a distributed deadlock detection algorithm so that the detecting process has sufficient information to achieve guaranteed deadlock recovery.
Reference: [2] <author> E. Knapp. </author> <title> Deadlock detection in distributed databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 19(4) </volume> <pages> 303-328, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: This paper shows that it is possible to guarantee error recovery for more specific types of errors such as deadlocks. Much of the literature on deadlocks has focused on the detection problem for different resource request models <ref> [2] </ref>. After a deadlock is detected, resolution (or recovery) is usually performed by the detecting process simply aborting itself to release the resources it has held. A static priority can be assigned to each process so that the lowest-priority process involved in a deadlock cycle becomes the victim [3]. <p> reachable nodes are marked to indicate that they must be rolled back, and the last unmarked node of each process (fc 0;1 ; c 1;1 ; c 2;2 ; c 3;1 g) forms the desired global checkpoint. 2.2 Deadlocks and wait-for graphs In this paper, we consider the one-resource model <ref> [2] </ref> in which each process can have at most one outstand ing resource request at a time, and blocks its execu-tion until the resource is granted. Figure 1 (a) shows a resource access pattern in the form of message exchanges, that results in a deadlock. <p> For the purpose of presentation, we first assume that all resource-related messages are monitored by a central server. Distributed algorithms will be considered in a later section. The server maintains a wait-for graph (WFG) <ref> [2] </ref> as follows: a WFG-edge is drawn from P i to ^ P j if P i sends r i;j to ^ P j and resource R j is not available; an edge is drawn from ^ P j to P i if ^ P j sends g j;i to P
Reference: [3] <author> D. P. Mitchell and M. J. Merritt. </author> <title> A distributed algorithm for deadlock detection and resolution. </title> <booktitle> In Proc. ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 282-284, </pages> <year> 1984. </year>
Reference-contexts: After a deadlock is detected, resolution (or recovery) is usually performed by the detecting process simply aborting itself to release the resources it has held. A static priority can be assigned to each process so that the lowest-priority process involved in a deadlock cycle becomes the victim <ref> [3] </ref>. In this paper, we consider deadlock resolution for message-passing systems in which processes communicate through interprocess messages as well as sharing resources through resource-related messages. <p> In this section, we present a dynamic priority-based algorithm which permits spontaneous priority changes at any time while preserving essential invariants for deadlock detection. This algorithm is a simple extension of a known static priority-based deadlock detection algorithm <ref> [3] </ref>. Such an extension provides a general dynamic priority scheme to take into account any recovery-related information such as degree of non-determinism, estimated rollback cost, state dependencies, etc. <p> The function inc (u) nondeter-ministically chooses a value greater than u and unique to the process. This algorithm extends an algorithm due to Mitchell and Merritt, <ref> [3] </ref>, by adding the Change P transition to allow priorities to change dynamically. 4.2.1 Correctness The important properties of this algorithm are summarized in the following two theorems, which we state here without proof. <p> However, this produces a delay of n steps to detect the deadlock, to little real advantage <ref> [3] </ref>. Instead, the algorithm only detects cycles that existed in an equivalent virtual run of the system, in a sense we make precise below.
Reference: [4] <author> R. E. Strom and S. Yemini. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: Message logging is a technique that saves messages onto stable storage so that the messages can be replayed after a process rolls back to a checkpoint. Traditional checkpointing and message logging techniques <ref> [4, 1] </ref> have been designed primarily for hardware failure recovery. A physical failure uniquely determines the set of lost volatile process states and message logs. <p> Then c 0;2 becomes reachable from c 2;2 , and deadlock recov ery can no longer be guaranteed. 4 Distributed Deadlock Recovery 4.1 Piecewise determinism Much of the literature on rollback recovery is based on a model of piecewise determinism (PWD) <ref> [4] </ref>. Under the PWD assumption, each process execution is modeled as consisting of a number of state intervals bounded by message-receiving events. Execution within each state interval is completely deterministic and replayable. This allows the use of message logging as a form of checkpointing.
Reference: [5] <author> Y. M. Wang. </author> <title> The maximum and minimum consistent global checkpoints and their applications. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 86-95, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Given a system with N processes, a set of N checkpoints, one from each process, is called a global checkpoint. A consistent global checkpoint T is a global checkpoint such that no message is sent after a checkpoint of T and received before another checkpoint of T <ref> [5] </ref>. Figure 1 (a) gives an example checkpoint and communication pattern where each vertical solid bar represents a nonvolatile checkpoint, each shaded triangle represents the current volatile process state (called a volatile checkpoint), and each directed edge represents a message. <p> Because message g 1;0 is unsent, process P 0 needs to roll back to c 0;1 , which in turn unsends m 0;3 and forces P 3 to roll back to c 3;1 . The above rollback propagation can be performed as a graph search on a rollback-dependency graph <ref> [5] </ref> (or R-graph) as illustrated in Figure 1 (b). <p> We have previously derived the following necessary and sufficient condition for finding any consistent global checkpoint containing a target set of checkpoints <ref> [5] </ref>: Lemma 2.1 Given a target set of checkpoints S, a consistent global checkpoint containing S exists if and pattern; (b) rollback-dependency graph; (c) wait-for graph. only if, for every checkpoint c i;x of S such that c i;x+1 exists, c i;x+1 does not reach any checkpoint of S (denoted by <p> To minimize the rollback distance, the following algorithm can be used to compute the most recent consistent global checkpoint containing the target set <ref> [5] </ref>: Algorithm 1 Given a target set of checkpoints S, start an R-graph search from every c i;x+1 such that c i;x 2 S, and mark every reachable node during the search. <p> Therefore, the piecewise deterministic model can be viewed as having a logical checkpoint before every message-receiving event. It has been shown that under the PWD assumption, the R-graph reach-ability can be tested in a distributed fashion if the following transitive dependency tracking is employed <ref> [5] </ref>, each process P i maintains a size-N transitive depen dency vector D i ; the entry D i [i] is initialized to 1, incremented every time a new state interval starts, and so always represents the current state interval index; every other entry D i [j], j 6= i, is <p> We next show in Theorem 2 that, under the PWD assumption, any resource manager can locally determine whether or not it is a good candidate for victim selection to achieve guaranteed deadlock recovery. The proof is based on the following lemma <ref> [5] </ref> which translates R-graph reachability into dependency vector comparison.
Reference: [6] <author> Y. M. Wang, Y. Huang, and W. K. Fuchs. </author> <title> Progressive retry for software error recovery in distributed systems. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 138-144, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Since rolling back any process (called the victim) involved in a deadlock cycle can break the cycle, we have the freedom to choose among multiple potential victims and hence multiple potential recovery lines. Our previous work on progressive retry <ref> [6] </ref> applied the technique of checkpointing and message logging to recovering failed processes from software errors caused by unknown software bugs; message replaying and message reordering were employed as heuristics to bypass the software bugs. <p> For simplicity, we assume that resources themselves do not have states, and each resource manager always has a checkpoint before every message-receiving event. This can be achieved by low-cost critical data checkpointing or by message logging under piecewise determinism <ref> [6] </ref>. For the purpose of presentation, we first assume that all resource-related messages are monitored by a central server. Distributed algorithms will be considered in a later section. <p> Execution within each state interval is completely deterministic and replayable. This allows the use of message logging as a form of checkpointing. Specifically, logging all the messages that have been processed since the most recent checkpoint equivalently places a logical checkpoint <ref> [6] </ref> at the end of current state interval (or, equivalently, just before the next message-receiving event) because of the capability of deterministic replay up to that point. Therefore, the piecewise deterministic model can be viewed as having a logical checkpoint before every message-receiving event.
References-found: 6

