URL: http://www.cs.indiana.edu/hyplan/chaynes/arity.ps
Refering-URL: http://www.cs.indiana.edu/hyplan/chaynes.html
Root-URL: http://www.cs.indiana.edu
Title: Type Reconstruction for Variable-Arity Procedures  
Author: Hsianlin Dzeng and Christopher T. Haynes 
Affiliation: Computer Science Department, Indiana University  
Abstract: We extend the ML-style type system with variable-arity procedures, supporting both optional arguments and arbitrarily long argument sequences. The language with variable-arity procedures is encoded in a core ML variant with infinitary tuples. We present an algebra of infinitary tuples and solve its unification problem. The resulting type discipline preserves principal typings and has a terminating type reconstruction algorithm. The expressive power of infinitary tuples is illustrated. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Military Standard Ada Programming Language. No. ANSI/MIL-STD-1815 A, American National Standards Institute, </institution> <address> New York, N.Y., </address> <year> 1983. </year>
Reference-contexts: Extension of an ML-style type system to support higher, but fixed, arity procedures is straightforward. A variable-arity procedure accepts an indefinite number of arguments. Many languages provide variable-arity primitive procedures, and some allow creation of variable-arity procedures. For example, Ada <ref> [1] </ref> allows the definition of procedures with optional arguments for which defaults are provided, Scheme [2] lambda expressions may have a "rest" parameter to which all remaining arguments are bound, and Common Lisp [14] supports both optional and rest arguments. <p> :; fl p ) : f Row (ae 1 ; : : :; ae p ) = @(o ) = e V &lt; @(o ) = e : = f Type (ff 1 ; : : : ; ff p ) ae i = @(ff i ) for i 2 <ref> [1; p] </ref> : : @(oe) = e ^ o = oe ^ ae = @(oe) Since the rows in our algebra are all of one sort (unlike Remy's algebra of record terms), some of the axioms are subterm-collapsing (there are axioms of the form t = t 0 in E such <p> = e fl is a cycle variable in f Row (ae 1 ; : : : ; ae p ) 9 (ff i ) i2 [1;p] ( @(f Type (ff 1 ; : : : ; ff p )) : : ae i = @(ff i ) for i 2 <ref> [1; p] </ref> : : = e fl is a cycle variable in (o ; ae) @(o ) = ae = fl = e : : = e x is a cycle variable in t and t is not of the form (o ; ae) or f Row (ae 1 ; :
Reference: [2] <editor> W. Clinger and J. Rees (Ed.). </editor> <title> Revised 4 Report on the Algorithmic Language Scheme. </title> <journal> Lisp Pointers, </journal> <volume> 4(3) </volume> <pages> 1-55, </pages> <year> 1991. </year> <month> 13 </month>
Reference-contexts: A variable-arity procedure accepts an indefinite number of arguments. Many languages provide variable-arity primitive procedures, and some allow creation of variable-arity procedures. For example, Ada [1] allows the definition of procedures with optional arguments for which defaults are provided, Scheme <ref> [2] </ref> lambda expressions may have a "rest" parameter to which all remaining arguments are bound, and Common Lisp [14] supports both optional and rest arguments. This paper presents a flexible method of supporting variable-arity procedures, with both optional and rest arguments, in the context of ML-style polymorphic type reconstruction.
Reference: [3] <author> R. K. Dybvig and R. Hieb. </author> <title> A New Approach to Procedures with Variable Arity. Lisp and Symbolic Computation: </title> <journal> An International Journal, </journal> <volume> 3(3) </volume> <pages> 229-244, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: We adopt Dybvig and Hieb's <ref> [3] </ref> rest parameter mechanism, in which rest variables may only be referenced following an &rest keyword at the end of an application, indicating that the values 1 bound to the rest variable are to be passed as additional arguments in the call.
Reference: [4] <author> H. Dzeng and C. T. Haynes. </author> <title> Typing Variable-Arity Procedures with Infinitary Tuples. </title> <type> Technical Report, </type> <institution> Computer Science Department, Indiana University, </institution> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: Both proofs are by induction on the structures of ML va expressions and follow directly from the transformation rules, the ` ML va and ` ML relations, and the definition of h. Additional details of this proof and others in this paper are reported elsewhere <ref> [4] </ref>. 3.3 Infinitary Tuple Algebra The terms of types in ML can be derived from the raw terms of an equational algebra, which we call the algebra of infinitary tuples. We prove the unification problem for the terms of this algebra is decidable and unitary unifying.
Reference: [5] <author> R. Harper, R. Milner, and M. Tofte. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In Section 2 we present the static semantics of a simple language, ML va , with variable-arity procedures. To solve the type reconstruction problem for ML va , we introduce in Section 3 an embedding of ML va into a subset of Standard ML <ref> [5] </ref> enriched with infinitary tuples and an appropriate equational algebra on its types, which we call ML . The unification problem for the type terms of ML is solved via an algebra of infinitary tuples.
Reference: [6] <author> C. T. Haynes. Infer: </author> <title> A Statically-typed Dialect of Scheme (preliminary). </title> <type> Technical Report 367, </type> <institution> Computer Science Department, Indiana University, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: This work employs elements of the record typing systems of Wand and Remy, as well as the theory of equational unification. The typing mechanism presented in this paper has been implemented in Infer <ref> [6] </ref>, a statically-typed dialect of Scheme. Though limited support for variable-arity procedures may be obtained with substantially simpler type systems, we believe our algebra of infinitary tuples is justified by its expressive power.
Reference: [7] <author> J.-P. Jouannaud and C. Kirchner. </author> <title> Solving Equations in Abstract Algebras: A Rule-Based Survey of Unification. </title> <editor> In J.-L. Lassez and G. Plotkin, editors, </editor> <booktitle> Computational Logic, </booktitle> <pages> pages 257-321. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Within each case, an induction is used on the minimal nesting depth of subterms for a constructor that is appropriate to the case. The resulting equational theory, = E , is thus syntactic. Therefore, the rewrite rules of E-unification that resolve conflicting top symbols <ref> [7, 13] </ref> specialize in our case to the following: f Row (ae 1 ; : : : ; ae p ) = (o ; %) = e V &gt; &gt; &gt; &lt; (o ; %) = e : = f Type (ff 1 ; : : :; ff p ) % <p> For strict equational theories, cycles are handled by the so-called "occurs-check" rule. Since our theory is not strict, we instead use the following rules, which are justified by Lemma 3.4 (a cycle variable is one that participates in a cycle <ref> [7] </ref>): f Row (ae 1 ; : : :; ae p ) = fl = e fl is a cycle variable in f Row (ae 1 ; : : : ; ae p ) 9 (ff i ) i2 [1;p] ( @(f Type (ff 1 ; : : : ; ff
Reference: [8] <editor> C. Kirchner. </editor> <booktitle> Computing Unification Algorithms. In Proceedings of the First Symposium on Logic in Computer Science, </booktitle> <pages> pages 206-216, </pages> <year> 1986. </year>
Reference-contexts: Definition The algebra of infinitary tuples is the equational theory T (; V)=E (a quotient of terms by E-equality). A set of axioms is syntactic if any two equal terms can be proved equal by applying axioms at most once at the top occurrence. <ref> [8, 9] </ref> Lemma 3.3 E is syntactic. The proof is tedious, involving six cases on the outermost structure of the left-hand side of an equivalence. Within each case, an induction is used on the minimal nesting depth of subterms for a constructor that is appropriate to the case.
Reference: [9] <author> C. Kirchner and F. Klay. </author> <title> Syntactic Theories and Unification. </title> <booktitle> In Proceedings of the Fifth Symposium on Logic in Computer Science, </booktitle> <pages> pages 270-277, </pages> <year> 1990. </year>
Reference-contexts: Definition The algebra of infinitary tuples is the equational theory T (; V)=E (a quotient of terms by E-equality). A set of axioms is syntactic if any two equal terms can be proved equal by applying axioms at most once at the top occurrence. <ref> [8, 9] </ref> Lemma 3.3 E is syntactic. The proof is tedious, involving six cases on the outermost structure of the left-hand side of an equivalence. Within each case, an induction is used on the minimal nesting depth of subterms for a constructor that is appropriate to the case.
Reference: [10] <author> D. Remy. </author> <title> Type Inference for Records in a Natural Extension of ML. </title> <type> Technical Report 1431, </type> <address> INRIA-Rocquencourt, BP 105, 78153 Le Chesnay Cedex, France, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Following Wand [15], we employ row variables to express indefinite sequences of terms, including both type rows and mark rows. ff, fl, and " are variables for their specified sorts. The idea of infinite base rows (i.e. abs) comes from Remy's record terms <ref> [10, 13] </ref>, but our rows do not have labels and are not sorted. This last requirement is crucial in typing rest variable references.
Reference: [11] <author> D. Remy. </author> <title> Extension of ML Type System with a Sorted Equational Theory on Types. </title> <type> Technical Report 1766, </type> <address> INRIA-Rocquencourt, BP 105, 78153 Le Chesnay Cedex, France, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: this is an attractive design choice, we opt not to do so because it complicates the type system in an inessential way. 4 3 Type Reconstruction We introduce an extension of core ML, named ML , incorporating a sorted regular equational theory on types patterned after the work of Remy <ref> [11] </ref>. By translating expressions of ML va into expressions of ML , we reduce the type reconstruction problem for ML va to that of typing ML . <p> Corollary 3.1 Unification in the algebra of ML types is decidable and unitary (every solvable unification problem has a principal unifier). Since the equational theory = E is regular and its unification is decidable and unitary, based on Remy's work <ref> [11] </ref> we deduce the following: Corollary 3.2 There exists a terminating, syntactically sound and complete type reconstruction algorithm for ML that deduces principal types.
Reference: [12] <author> D. Remy. </author> <title> Projective ML. </title> <booktitle> In Proceedings of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: In a statically-typed setting this approach is also more general; for example allowing o 1 and o 2 above to be distinct types. Variable-arity procedures may be typed by adapting techniques for typing extensible records. Wand [15] introduced "row" variables to express inclusion polymorphism on records. Remy's projective polymorphism <ref> [12] </ref> generalizes classical record operations using infinitary records with defaults. Since tuple types may be encoded as record types with numerically labelled fields, the domain type of (1) may be encoded using Remy's technique as [1 : pre o x ; 2 : " o M ; ae]. <p> Aside from nil, there are no infinitary tuples whose elements are all of the same value (such as those returned by Remy's elevation operator <ref> [12] </ref>). 3.2 Transformation Rules We now give rules for translation of expressions of ML va into expressions of ML . <p> ) :: Type Row ) Row @ :: Type ) Row f :: $(f) ) f 2 C; 2 K The @ symbol is an addition to the row constructors given in ML earlier that may be viewed as a row of shared types analogous to those used by Remy <ref> [13, 12] </ref>. It is required for unification to 8 be unitary. Let V be a denumerable set of variables with infinitely many variables of every sort in K. The set of terms of the infinitary tuple algebra generated by and V is denoted T (; V), or simply T . <p> This would solve the above problem and also enhance the polymorphism of lambda-bound rest variables. Whether such type systems have desirable properties, such as principal types and decidable type reconstruction, remains to be investigated. Remy conjectures that his projection and elevation operators may be extended to nested records <ref> [12] </ref>. An analogous extension of our system to support polymorphism of nested infini-tary tuples may be possible.
Reference: [13] <author> D. Remy. </author> <title> Syntactic Theories and the Algebra of Record Terms. </title> <type> Technical Report 1869, </type> <address> INRIA-Rocquencourt, BP 105, 78153 Le Chesnay Cedex, France, </address> <month> March </month> <year> 1993. </year>
Reference-contexts: Following Wand [15], we employ row variables to express indefinite sequences of terms, including both type rows and mark rows. ff, fl, and " are variables for their specified sorts. The idea of infinite base rows (i.e. abs) comes from Remy's record terms <ref> [10, 13] </ref>, but our rows do not have labels and are not sorted. This last requirement is crucial in typing rest variable references. <p> ) :: Type Row ) Row @ :: Type ) Row f :: $(f) ) f 2 C; 2 K The @ symbol is an addition to the row constructors given in ML earlier that may be viewed as a row of shared types analogous to those used by Remy <ref> [13, 12] </ref>. It is required for unification to 8 be unitary. Let V be a denumerable set of variables with infinitely many variables of every sort in K. The set of terms of the infinitary tuple algebra generated by and V is denoted T (; V), or simply T . <p> Within each case, an induction is used on the minimal nesting depth of subterms for a constructor that is appropriate to the case. The resulting equational theory, = E , is thus syntactic. Therefore, the rewrite rules of E-unification that resolve conflicting top symbols <ref> [7, 13] </ref> specialize in our case to the following: f Row (ae 1 ; : : : ; ae p ) = (o ; %) = e V &gt; &gt; &gt; &lt; (o ; %) = e : = f Type (ff 1 ; : : :; ff p ) %
Reference: [14] <author> G. L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: Many languages provide variable-arity primitive procedures, and some allow creation of variable-arity procedures. For example, Ada [1] allows the definition of procedures with optional arguments for which defaults are provided, Scheme [2] lambda expressions may have a "rest" parameter to which all remaining arguments are bound, and Common Lisp <ref> [14] </ref> supports both optional and rest arguments. This paper presents a flexible method of supporting variable-arity procedures, with both optional and rest arguments, in the context of ML-style polymorphic type reconstruction. The domain of an arity n procedure is typically typed as a tuple of dimension n.
Reference: [15] <author> M. Wand. </author> <title> Complete Type Inference for Simple Objects. </title> <booktitle> In Proceedings of the Second Symposium on Logic in Computer Science, </booktitle> <pages> pages 37-44, </pages> <year> 1987. </year> <month> 14 </month>
Reference-contexts: In a statically-typed setting this approach is also more general; for example allowing o 1 and o 2 above to be distinct types. Variable-arity procedures may be typed by adapting techniques for typing extensible records. Wand <ref> [15] </ref> introduced "row" variables to express inclusion polymorphism on records. Remy's projective polymorphism [12] generalizes classical record operations using infinitary records with defaults. <p> Each field contains a mark and a type. A row can also be generated by composing a mark row and a type row. Following Wand <ref> [15] </ref>, we employ row variables to express indefinite sequences of terms, including both type rows and mark rows. ff, fl, and " are variables for their specified sorts.
References-found: 15

