URL: http://www.cs.utoronto.ca/~cogrobo/congologIJCAI97.ps.Z
Refering-URL: http://www.cs.utoronto.ca/~cogrobo/
Root-URL: 
Email: degiacomo@dis.uniroma1.it  lesperan@yorku.ca  hector@cs.toronto.edu  
Title: Reasoning about concurrent execution, prioritized interrupts, and exogenous actions in the situation calculus  
Author: Giuseppe De Giacomo Yves Lesperance Hector J. Levesque 
Address: Via Salaria 113, 00198 Roma Italy  Toronto ON Canada M4N 3M6  Toronto ON Canada M5S 1A4  
Affiliation: Dip. di Informatica e Sistemistica, Universita di Roma "La Sapienza"  Dept. of Computer Science, York University  Dept. of Computer Science, University of Toronto  
Abstract: As an alternative to planning, an approach to high-level agent control based on concurrent program execution is considered. A formal definition in the situation calculus of such a programming language is presented and illustrated with a detailed example. The language includes facilities for prioritizing the concurrent execution, interrupting the execution when certain conditions become true, and dealing with exogenous actions. The language differs from other procedural formalisms for concurrency in that the initial state can be incompletely specified and the primitive actions can be user-defined by axioms in the situation calculus. When it comes to providing high-level control for robots or other agents in dynamic and incompletely known worlds, approaches based on plan synthesis may end up being too demanding computationally in all but simple settings. An alternative approach that is showing promise is that of high-level program execution [8]. The idea, roughly, is that instead of searching for a sequence of actions that would take the agent from an initial state to some goal state, the task is to find a sequence of actions that constitutes a legal execution of some high-level non-deterministic program. As in planning, to find such a sequence it is necessary to reason about the preconditions and effects of the actions within the body of the program. However, if the program happens to be almost deterministic, very little searching is required; as more and more non-determinism is included, the search task begins to resemble traditional planning. Thus, in formulating a high-level program, the user gets to control the search effort required. The hope is that in many domains, what an agent needs to do can be conveniently expressed using a suitably rich high-level programming language. Previous work on the Golog language [8] considered how to reason about actions in programs containing conditionals, iteration, recursion, and non-deterministic operators, where the primitive actions and fluents where characterized by axioms of the situation calculus. In this paper, we explore how to execute programs incorporating a rich ac count of concurrency. The execution task remains the same; what changes is that the programming language, which we call ConGolog (for Concurrent Golog), becomes considerably more expressive. One of the nice features of this language is that it allows us to conveniently formulate agent controllers that pursue goal-oriented tasks while concurrently monitoring and reacting to conditions in their environment. Of course ours is not the first formal model of concur-rency. In fact, well developed approaches are available [6, 10, 14] 1 and our work inherits many of the intuitions behind them. However, it is distinguished from these in at least two fundamental ways. First, it allows incomplete information about the environment surrounding the program. In contrast to typical computer programs, the initial state of a ConGolog program need only be partially specified by a collection of axioms. Second, it allows the primitive actions (elementary instructions) to affect the environment in a complex way. In contrast to typical computer programs whose elementary instructions are simple predefined statements (e.g. variable assignments), the primitive actions of a ConGolog program are determined by a separate domain-dependent action theory, which specifies the action preconditions and effects, and deals with the frame problem. The rest of the paper is organized as follows: in Section 1 we very briefly review planning in the situation calculus. In Section 2, we review the Golog programming language and present a variant of the original specification of the high-level execution task. In Section 3, we explain informally the sort of concurrency we are concerned with, as well as related notions of priorities and interrupts. The section concludes with changes to the Golog specification required to handle concurrency. In Section 4, we present a detailed example of a reactive multi-elevator controller formulated in ConGolog. In Section 5, we discuss some of the properties of ConGolog, its implementation, and topics for future research. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> A longer version of this paper, </institution> <note> in preparation. </note>
Reference-contexts: A concurrent execution of two processes is one where the primitive actions in both processes occur, interleaved in some fashion. So in fact, we never have more than one primitive action happening at the same time. As discussed in <ref> [1, 13] </ref>, to model actions that intuitively could occur simultaneously, e.g. actions of extended duration, we use instantaneous start and stop (i.e. clipping) actions, where once again interleaving is appropriate. An important concept in understanding concurrent execution is that of a process becoming blocked. <p> This allows an unbounded number of instances of to be running. 9 It is true, though not immediately obvious, that Trans fl remains properly defined even with these axioms containing negative occurrences of Trans. See <ref> [1] </ref> for details. Observe that with ( 1 k 2 ), if both 1 and 2 are always able to execute, the amount of interleaving between them is left completely open. <p> Such programs never terminate, so semantics based on Do cannot be used, but their behavior can nonetheless be specified using Trans <ref> [1] </ref>. 5 Discussion With all of this procedural richness, it is important not to lose sight of the logical framework. ConGolog is indeed a programming language, but one whose execution, like planning, depends on reasoning about actions. <p> And this theory must be used explicitly by a ConGolog interpreter. We have developed a prototype ConGolog interpreter in Prolog (see <ref> [1] </ref>). Indeed, a simple if somewhat inefficient interpreter can be lifted directly from Final, Trans, and Do introduced above 12 .
Reference: [2] <author> A. J. Bonner and M. Kifer. </author> <title> Concurrency and communication in transaction logic. </title> <booktitle> In Proc. </booktitle> <address> ICDT'95, </address> <year> 1995. </year>
Reference-contexts: not to change the world so much as to provide information to be used by the agent at runtime; 2) handling non-termination, that is, developing accounts of program correctness (fairness, liveness etc.) appropriate for controllers expected to operate indefinitely. 11 Although with a different emphasis, this approach is shared by <ref> [2] </ref> where a logical formalism is proposed for concurrent database transactions. 12 Exogenous actions can be simulated by generating them probabilistically or by asking the user at runtime when they should occur. 6
Reference: [3] <author> G. De Giacomo and X. Chen. </author> <title> Reasoning about nondeterministic and concurrent actions: A process algebra approach. </title> <booktitle> In Proc. AAAI'96, </booktitle> <pages> pages 658-663, </pages> <year> 1996. </year>
Reference-contexts: 1 In <ref> [3] </ref> a direct use of such approaches to model concurrent (complex) actions in AI is investigated. 1 Situation Calculus There are a number of ways of making the planning task precise, but perhaps the most appealing is to formulate a specification in terms of a general theory of action.
Reference: [4] <author> C. C. Green. </author> <title> Theorem proving by resolution as a basis for question-answering systems. </title> <booktitle> In Machine Intelligence, </booktitle> <volume> volume 4, </volume> <pages> pages 183-205. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year>
Reference-contexts: For any domain theory of this sort, we have a very clean specification of the planning task, which dates back to the work of Green <ref> [4] </ref>: Classical Planning: Given a domain theory Axioms as above, and a goal formula (s) with a single free-variable s; the planning task is to find a sequence of actions ~a such that: Axioms j= Legal (~a; S 0 ) ^ (do (~a; S 0 )) where do ([a 1 ;
Reference: [5] <author> M. Hennessy. </author> <title> The Semantics of Programming Languages. </title> <publisher> John Wiley & Sons, </publisher> <year> 1990. </year>
Reference-contexts: The kind of semantics Do associates to programs is sometimes called evaluation semantics <ref> [5] </ref> since it is based on the complete evaluation of the program. With the goal of eventually handling concurrency, it is convenient to give a slightly more refined kind of semantics called computational semantics [5], which is based on "single steps" of computation, or transitions 4 . <p> The kind of semantics Do associates to programs is sometimes called evaluation semantics <ref> [5] </ref> since it is based on the complete evaluation of the program. With the goal of eventually handling concurrency, it is convenient to give a slightly more refined kind of semantics called computational semantics [5], which is based on "single steps" of computation, or transitions 4 . A step here is either a primitive action or testing whether a condition holds in the current state. <p> In ConGolog, the current interleaving can continue successfully provided that a process other than executes next. The net effect is that is suspended or blocked, and execution must continue elsewhere. 8 The ConGolog language is exactly like Golog except with the following additional constructs: 7 See <ref> [5] </ref> for hints on the proof of this theorem. 8 Just as actions in Golog are external (e.g. there is no internal variable assignment), in ConGolog, blocking and un-blocking also happen externally, via Poss and wait actions.
Reference: [6] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall Int., </publisher> <year> 1985. </year>
Reference: [7] <author> D. Leivant. </author> <title> Higher order logic. </title> <booktitle> In Handbook of Logic in Artificial Intelligence and Logic Programming, </booktitle> <volume> volume 2, </volume> <pages> pages 229-321. </pages> <publisher> Clarendon Press, </publisher> <year> 1994. </year>
Reference-contexts: It will be necessary to quantify over programs and so, unlike in [8], we need to encode Golog programs as first-order terms, including introducing constants denoting variables, and so on. This is laborious but quite straightforward <ref> [7] </ref> 5 . We omit all such details here and simply use programs within formulas as if they were already first-order terms.
Reference: [8] <author> H. J. Levesque, R. Reiter, Y. Lesperance, F. Lin, and R. B. Scherl. GOLOG: </author> <title> A logic programming language for dynamic domains. </title> <note> To appear in the Journal of Logic Programming, </note> <year> 1996. </year>
Reference-contexts: the task is to find a sequence of actions that is executable (each action is executed in a context where its precondition is satisfied) and that achieves the goal (the goal formula holds in the final state that results from performing the actions in sequence). 2 Golog As presented in <ref> [8] </ref>, Golog is logic-programming language whose primitive actions are those of a background domain theory. <p> In <ref> [8] </ref>, a simple inductive definition of Do was presented, containing rules such as: Do ([ 1 ; 2 ]; s; s 0 ) = Do ([ 1 j def Do ([if then 1 else 2 ]; s; s 0 ) def Do ([(?; 1 ) j (:?; 2 )]; s; s <p> It will be necessary to quantify over programs and so, unlike in <ref> [8] </ref>, we need to encode Golog programs as first-order terms, including introducing constants denoting variables, and so on. This is laborious but quite straightforward [7] 5 . We omit all such details here and simply use programs within formulas as if they were already first-order terms.
Reference: [9] <author> J. McCarthy and P. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <booktitle> In Machine Intelligence, </booktitle> <volume> vol. 4, </volume> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year>
Reference-contexts: One candidate language for formulating such a theory is the situation calculus <ref> [9] </ref>.
Reference: [10] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Pren-tice Hall, </publisher> <year> 1989. </year>
Reference: [11] <author> G. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI-FN-19, </type> <institution> Computer Science Dept. Aarhus Univ. Denmark, </institution> <year> 1981. </year>
Reference-contexts: Because there are no exogenous actions or concurrent processes in Golog, waiting for amounts to testing that holds in the current state. 3 For space reasons, we ignore these here. 4 Both types of semantics belong to the family of structural operational semantics introduced in <ref> [11] </ref>. 2 Final and Trans will be characterized by a set of equiv-alence axioms, each depending on the structure of the first argument.
Reference: [12] <author> R. Reiter. </author> <title> The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression. </title> <booktitle> In Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 359-380. </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: One possibility is a theory of the following form <ref> [12] </ref>: * Axioms describing the initial situation, S 0 . * Action precondition axioms, one for each primitive action a, characterizing Poss (a; s). * Successor state axioms, one for each fluent F , stating under what conditions F (~x; do (a; s)) holds as function of what holds in situation <p> characterizing Poss (a; s). * Successor state axioms, one for each fluent F , stating under what conditions F (~x; do (a; s)) holds as function of what holds in situation s: These take the place of the so-called effect axioms, but also provide a solution to the frame problem <ref> [12] </ref>. * Unique names axioms for the primitive actions. * Some foundational, domain independent axioms.
Reference: [13] <author> R. Reiter. </author> <title> Natural actions, concurrency and continuous time in the situation calculus. </title> <booktitle> In Proc. KR'96, </booktitle> <pages> pages 2-13, </pages> <year> 1996. </year>
Reference-contexts: A concurrent execution of two processes is one where the primitive actions in both processes occur, interleaved in some fashion. So in fact, we never have more than one primitive action happening at the same time. As discussed in <ref> [1, 13] </ref>, to model actions that intuitively could occur simultaneously, e.g. actions of extended duration, we use instantaneous start and stop (i.e. clipping) actions, where once again interleaving is appropriate. An important concept in understanding concurrent execution is that of a process becoming blocked.
Reference: [14] <author> C. Stirling. </author> <title> Modal and temporal logics for processes. In Logics for Concurrency: Structure versus Automata, </title> <booktitle> number 1043 in LNCS, </booktitle> <pages> pages 149-237. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <month> 7 </month>
References-found: 14

