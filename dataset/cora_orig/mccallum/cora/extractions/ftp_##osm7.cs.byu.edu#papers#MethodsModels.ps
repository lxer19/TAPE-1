URL: ftp://osm7.cs.byu.edu/papers/MethodsModels.ps
Refering-URL: http://osm7.cs.byu.edu/Papers.html
Root-URL: 
Email: E-Mail Addresses: sbodily@osm7.cs.byu.edu woodfiel@cs.byu.edu  
Phone: Phone: (801) 378-2915 FAX: (801) 378-7775  
Title: Integrating Object-Oriented Methods and Models  
Author: Susan Bodily Scott N. Woodfield 
Keyword: Key words: formally-defined modelling, method, software engineering, object-oriented development  
Address: TMCB 3361 Provo, Utah 84602  
Affiliation: Brigham Young University Computer Science Department  
Abstract: Most of the literature does not address the important distinction between software development methods and modelling paradigms. Lack of attention to this distinction has led to over-emphasis on one or the other (usually the method) to the detriment of the software development process. We describe the advantages of using a method or a model. The characteristic problems resulting from emphasizing one or the other of these aspects of software development are described. These problems can be overcome by recognizing the distinction between methods and models and marrying a formally-defined modelling paradigm with a complementary software development method. 
Abstract-found: 1
Intro-found: 1
Reference: [Bod93] <author> Bodily, S., </author> <title> A Direct Ada Implementation for Object-Oriented Systems Analysis, </title> <type> Masters Thesis, </type> <institution> Brigham Young University, </institution> <year> 1993 </year>
Reference-contexts: Such formally defined transformations also help eliminate errors in the transitions. Transformation validity is defined by the modelling paradigm and can be easily checked. One such transformation from a final set of OSA models (a system design) to a programming language has been defined for OSA <ref> [Bod93] </ref>. 3 Software Development Methods A software development method is a step-by-step technique for developing a model of a system that is to be implemented. All methods have a modelling paradigm whether or not it is expressly defined in the method definition. <p> These kinds of object classes are not handled well by any of the three methods. On the other hand, this kind of object class is a natural part of an OSA model [EKW92] <ref> [Bod93] </ref>. Thus, these two views of system operation are quite different and require different approaches to system analysis and design.
Reference: [Boo91] <author> Booch, G., </author> <title> Object Oriented Design with Applications, </title> <publisher> Benjamin/Cummings Publishing Co., </publisher> <year> 1991 </year>
Reference-contexts: 1 Introduction Practical software development today is accomplished primarily using software development methods. By a software development method we mean the step-by-step technique for developing system models <ref> [Boo91] </ref>. Though a method is always based on some underlying software model [Jac92] 1 , the model is often not formally defined. Thus, both method developers and method users seem to understand the underlying model only at an intuitive level.
Reference: [Cly92] <author> Clyde, S.W., D.W. Embley, </author> <title> S.N. Woodfield, "Tunable Formalism in Object-oriented Systems Analysis: Meeting the Needs of Both Theoreticians and Practitioners", </title> <booktitle> OOPSLA'92 Conference Proceedings, </booktitle> <address> Vancouver, British Columbia, Canada, </address> <month> 18-22 October, </month> <year> 1992, </year> <pages> pp. 452-465 </pages>
Reference-contexts: This problem is addressed by using a modelling paradigm that is built around the idea of tunable formalism. "A software model with tunable formalism must (a) be sufficiently expressive for practitioners, (b) have a formally defined syntax and semantics, and (c) allow various levels of detail and completion." <ref> [Cly92] </ref> The combination of a formally-defined modelling paradigm, tunable formalism, and a complementary method provides a solid foundation for software development. Problems associated with a formally-defined modelling paradigm alone or a software development method alone are solved with this combination.
Reference: [Cly93] <author> Clyde, </author> <title> S.W., An Initial Theoretical Foundation for Object-Oriented Systems Analysis and Design, </title> <type> PhD Dissertation, </type> <institution> Brigham Young University, </institution> <year> 1993 </year>
Reference-contexts: We will illustrate the concepts using a formally-defined modelling paradigm and three software development methods. 1 Jacobson speaks of a method based on an architecture. We call this concept a modelling paradigm. Object-Oriented Systems Analysis (OSA) is a formally-defined modelling paradigm developed at Brigham Young University [EKW92] <ref> [Cly93] </ref>. The formal definition of OSA is a mathematical formulation based on set theory and first-order logic. It contains three basic models that provide the ability to model declarative information, object behavior, and communication among objects. <p> With a formally defined model however, it is much easier to provide a well understood and consistent means for assessing quality. Quality assessment is then moved from the domain of personal preferences into the domain of measurable criteria. One example of a quality factor in OSA is object-class congruency <ref> [Cly93] </ref>. Object-class congruency deals with the quality of classification abstractions in system models. Many software development methods require the transformation of an analysis model into a design model and from a design model into an implementation model.
Reference: [Com94] <author> Compton, J.W., </author> <title> Executable OSA, </title> <type> Masters Thesis, </type> <institution> Brigham Young University, </institution> <year> 1994 </year>
Reference-contexts: The verification is done by performing system run-throughs using the scenarios. This verification can be done by hand or with the help of a prototype. A rapid prototyping technique is available for a system model done using OSA <ref> [Com94] </ref>. During the verification of the system model, we apply modelling paradigm quality criteria. The models are then changed as necessary to give a system model of the highest possible quality. We can now begin design. System design includes two activities.
Reference: [EKW92] <author> Embley, D.W., </author> <title> B.D. Kurtz, and S.N. Woodfield, Object-Oriented Systems Analysis: A Model Driven Approach, </title> <publisher> Prentice Hall, </publisher> <year> 1992 </year>
Reference-contexts: We will illustrate the concepts using a formally-defined modelling paradigm and three software development methods. 1 Jacobson speaks of a method based on an architecture. We call this concept a modelling paradigm. Object-Oriented Systems Analysis (OSA) is a formally-defined modelling paradigm developed at Brigham Young University <ref> [EKW92] </ref> [Cly93]. The formal definition of OSA is a mathematical formulation based on set theory and first-order logic. It contains three basic models that provide the ability to model declarative information, object behavior, and communication among objects. <p> Developers understand quality criteria and model transformations in terms of the modelling paradigm. However, developers can not determine when and how to appropriately apply quality criteria and perform model transformations. For example, the OSA <ref> [EKW92] </ref> modelling paradigm allows redundancies in the model. OSA developers can determine the quality of a model using redundancy as a quality criterion. In fact, a redundancy removal technique has been developed [EmL89] [Lig94]. <p> But, the modelling paradigm does not provide the team management techniques required to apply the framework. If several people develop different parts of the system model using OSA <ref> [EKW92] </ref>, for example, there will likely be object classes that are the same but exist in two different models with two different names. The OSA modelling paradigm allows for this possibility. However, the resolution of the naming problems is not described. <p> These kinds of object classes are not handled well by any of the three methods. On the other hand, this kind of object class is a natural part of an OSA model <ref> [EKW92] </ref> [Bod93]. Thus, these two views of system operation are quite different and require different approaches to system analysis and design.
Reference: [EmL89] <author> Embley, D.W., T.W. Ling, </author> <title> "Synergistic Database Design with an Extended Entity-Relationship Model", </title> <booktitle> Proceedings of the 8th International Conference on Entity-Relationship Approach, </booktitle> <address> Toronto, Canada, </address> <month> 18-20 October </month> <year> 1989, </year> <pages> pp. 118-135 </pages>
Reference-contexts: For example, the OSA [EKW92] modelling paradigm allows redundancies in the model. OSA developers can determine the quality of a model using redundancy as a quality criterion. In fact, a redundancy removal technique has been developed <ref> [EmL89] </ref> [Lig94]. However, the information about when and how to apply this technique is not a part of the modelling paradigm. Management of a software development effort that uses no method is difficult at best.
Reference: [Hum89] <author> Humphrey, </author> <title> W.S., Managing the Software Process, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1989 </year>
Reference-contexts: The fact that a management plan exists allows the development of a repeatable process. The process allows measurement of various phases of the software development activity. This measurement can then be used to improve the process for the next software development effort <ref> [Hum89] </ref>. These management advantages are facilitated by a method but are not usually a part of a method. Jacobson discusses the difference between the method and the management process [Jac92]. OOSE is meant to be used in the context of an appropriate management process. <p> Risk assessment and mitigation are difficult or impossible. Since we do not know when or what should be happening, it is difficult to determine if development is on schedule. An important attribute of a successful software development organization is that it can improve itself by having a repeatable process <ref> [Hum89] </ref>. In addition, a way to measure that process is important to organization and process improvement. Without a method, a repeatable process and process measurement are nearly impossible. While a formally-defined modelling paradigm provides the ability to measure and improve the models themselves, it provides no help for process measurement.
Reference: [Jac92] <author> Jacobson, I., et al., </author> <title> Object-Oriented Software Engineering A Use Case Approach, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1992 </year>
Reference-contexts: 1 Introduction Practical software development today is accomplished primarily using software development methods. By a software development method we mean the step-by-step technique for developing system models [Boo91]. Though a method is always based on some underlying software model <ref> [Jac92] </ref> 1 , the model is often not formally defined. Thus, both method developers and method users seem to understand the underlying model only at an intuitive level. In contrast, formally-defined software modelling paradigms usually do not have an associated software development method. <p> There is no software development method currently associated with OSA. We have investigated three software development methods. These methods are discussed in Object Behavior Analysis (OBA) [RuG92], Designing Object-Oriented Software [WWW90], and Object-Oriented Software Engineering A Use Case Approach (OOSE) <ref> [Jac92] </ref>. These three techniques seem to represent the object-oriented software development methods that are popular today. 2 Software Modelling Paradigms A formally defined modelling paradigm is a mathematical formulation of the software development model along with consistent definitions. The paradigm may also include some notational standards. <p> This measurement can then be used to improve the process for the next software development effort [Hum89]. These management advantages are facilitated by a method but are not usually a part of a method. Jacobson discusses the difference between the method and the management process <ref> [Jac92] </ref>. OOSE is meant to be used in the context of an appropriate management process. A software development method provides the ability to consistently apply criteria for determining the quality of the software models. <p> Without a formally-defined modelling paradigm, there is no agreement about the most basic concepts that affect the system model being developed. The meaning of the models produced is not uniformly understood. Consequently, the information that the model is intended to communicate is often misinterpreted. OOSE <ref> [Jac92] </ref>, for instance, provides definitions for many of the modelling concepts it uses. However, not all of the definitions that are needed are provided. The definition of object refers to a state. However, a developer does not learn precisely what a state is. <p> Without a formally-defined modelling paradigm, the quality of models produced is not uniform. The quality of the developed software may be assessed differently by the software quality assurance organization and the development organization. This may have grave consequences for the entire development effort. For instance, OOSE <ref> [Jac92] </ref> places emphasis on localizing potential system changes as a quality indicator for design. While intuitively we may agree that this is a worthy quality goal, there is little discussion of the precise meaning of localization of change. <p> Although this proposed method is stated as a set of steps, it is not intended to be accomplished in a completely sequential fashion. Everyone seems to agree that an iterative method is the most appropriate for object-oriented development <ref> [Jac92] </ref> [RuG92] [WWW90]. A method should start with a step that establishes the context of the development [RuG92]. During this step we identify the project goals and objectives and generate management information such as development plans. This step provides both business and technical goals. <p> Once the requirements specification is agreed upon, scenarios for system operation are developed. The scenarios should cover system operation to the largest extent possible without regard to any particular operating environment <ref> [Jac92] </ref> 2 . From these scenarios the system object classes, relationships, and appropriate constraints can be extracted giving us the beginning of the analysis model. The Object Relationship Model (ORM) is then created using this information. The ORM represents the declarative information of the system. <p> Consequently, the design model of the system is a refinement of the analysis model. Delaying the application of information dealing with a particular operating environment to the design phase gives us the advantage that we have created an analysis model that can be reused in any desired operating environment <ref> [Jac92] </ref>. The development activity can begin at the design phase for new developments and not at the analysis phase. Strategies similar to those used for development of the analysis model are used for development of the operating-environment-specific portions of the design model. <p> We have prepared for good management activity by providing a step that establishes the management framework. We assume that the proposed method will be performed within the framework of a good software development process <ref> [Jac92] </ref>. One purpose of the proposed method is to facilitate the management activity, but not to describe it. This proposed method has used ideas from each of the three software development methods that we studied in preparation for this work. Each has strengths and overlapping ideas.
Reference: [Lig94] <author> Light, J., </author> <title> A Relational Database Design Tool for Object-Relationship Models, </title> <type> Masters Thesis, </type> <institution> Brigham Young University, </institution> <note> 1994 (in preparation) </note>
Reference-contexts: For example, the OSA [EKW92] modelling paradigm allows redundancies in the model. OSA developers can determine the quality of a model using redundancy as a quality criterion. In fact, a redundancy removal technique has been developed [EmL89] <ref> [Lig94] </ref>. However, the information about when and how to apply this technique is not a part of the modelling paradigm. Management of a software development effort that uses no method is difficult at best.
Reference: [RuG92] <author> Rubin, K.S., A. Goldberg, </author> <title> "Object Behavior Analysis", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 35, No. 9, </volume> <month> January </month> <year> 1992, </year> <pages> pp. 48-62 </pages>
Reference-contexts: Research is ongoing to develop model transformations and quality factors that lead from analysis to design then to code giving a working system. There is no software development method currently associated with OSA. We have investigated three software development methods. These methods are discussed in Object Behavior Analysis (OBA) <ref> [RuG92] </ref>, Designing Object-Oriented Software [WWW90], and Object-Oriented Software Engineering A Use Case Approach (OOSE) [Jac92]. <p> The method provides the ability for everyone on the team to work using the same set of rules for development. People will be able to determine what their job is and how to perform it since everyone understands the same method and the same associated modelling paradigm. OBA <ref> [RuG92] </ref>, for example, is assumed to be executed using a project process that includes periodic reviews. <p> It receives no input from any other object instance. Object classes with instances that exhibit this kind of behavior (no requested operations) are specifically excluded when using OBA <ref> [RuG92] </ref>. These kinds of object classes are not handled well by any of the three methods. On the other hand, this kind of object class is a natural part of an OSA model [EKW92] [Bod93]. <p> Although this proposed method is stated as a set of steps, it is not intended to be accomplished in a completely sequential fashion. Everyone seems to agree that an iterative method is the most appropriate for object-oriented development [Jac92] <ref> [RuG92] </ref> [WWW90]. A method should start with a step that establishes the context of the development [RuG92]. During this step we identify the project goals and objectives and generate management information such as development plans. This step provides both business and technical goals. <p> Everyone seems to agree that an iterative method is the most appropriate for object-oriented development [Jac92] <ref> [RuG92] </ref> [WWW90]. A method should start with a step that establishes the context of the development [RuG92]. During this step we identify the project goals and objectives and generate management information such as development plans. This step provides both business and technical goals. It sets the management foundation for the development effort. The development starts with the requirements specification. <p> The system model is likely to be easier for most people to understand and maintain. As has been previously mentioned, such a translation is available for OSA. Traceability is a very important element to consider for any software development activity <ref> [RuG92] </ref>. Traceability allows developers to determine "Why?" something is a part of the system model. Our proposed method for OSA preserves traceability. We provide traceability in two ways. First we base model development on scenarios that can be directly traced to the requirements specification.
Reference: [SES90] <author> Smith, D., M. Eggen, R. St. Andre, </author> <title> A Transition to Advanced Mathematics, </title> <publisher> Brooks/Cole Publishing Company, </publisher> <year> 1990 </year>
Reference-contexts: A formally-defined modelling paradigm can help eliminate this problem. Customer requirements can be stated in precise terms. The customer can then review that interpretation to verify its accuracy. As an example (due to <ref> [SES90] </ref>), suppose that the sentence "Some people dislike taxes" requires interpretation. There is an ambiguity in the phrase "dislike taxes".
Reference: [WWW90] <author> Wirfs-Brock, R., B. Wilkerson, L. Wiener, </author> <title> Designing Object-Oriented Software, </title> <publisher> Prentice Hall, </publisher> <year> 1990 </year>
Reference-contexts: There is no software development method currently associated with OSA. We have investigated three software development methods. These methods are discussed in Object Behavior Analysis (OBA) [RuG92], Designing Object-Oriented Software <ref> [WWW90] </ref>, and Object-Oriented Software Engineering A Use Case Approach (OOSE) [Jac92]. These three techniques seem to represent the object-oriented software development methods that are popular today. 2 Software Modelling Paradigms A formally defined modelling paradigm is a mathematical formulation of the software development model along with consistent definitions. <p> The method relies on its underlying modelling paradigm to determine the quality criteria, but the application of those criteria is provided by the method. The consistent application of quality criteria provides further means of managing the software process. For example, in responsibility-driven design <ref> [WWW90] </ref>, guidelines for assigning responsibilities to classes can be viewed as application of a quality criterion. Most modern software is developed by a team of people working together to produce a single system. A well-defined method provides a framework for team development activities. <p> Although this proposed method is stated as a set of steps, it is not intended to be accomplished in a completely sequential fashion. Everyone seems to agree that an iterative method is the most appropriate for object-oriented development [Jac92] [RuG92] <ref> [WWW90] </ref>. A method should start with a step that establishes the context of the development [RuG92]. During this step we identify the project goals and objectives and generate management information such as development plans. This step provides both business and technical goals. <p> This step provides both business and technical goals. It sets the management foundation for the development effort. The development starts with the requirements specification. The requirements specification should describe what the software can do and what it can not do <ref> [WWW90] </ref>. It should also provide operational constraints and the relative importance of various requirements. The requirements specification is generally provided by the customer, but may be created or augmented by the developer in conjunction with the customer. Once the requirements specification is agreed upon, scenarios for system operation are developed. <p> High-level object classes are created as required to produce an ORM with the required abstractions. From this point on when we refer to object classes we will mean these high-level object classes. The scenarios identify various responsibilities for each object class <ref> [WWW90] </ref>. The behavior of each object class carries out these responsibilities. The object class behavior is described by the Object Behavior Model (OBM). The behavior of each object class is a result of its use in the various system scenarios. <p> During the execution of the system scenarios, object classes communicate with each other. This communication accomplishes tasks such as requesting some action, requesting information, sending information, etc. We may think of object classes as having contracts with each other for services <ref> [WWW90] </ref>. The contracts are satisfied using interactions. These communication activities are described through interactions between object classes and recorded using the Object Interaction Model (OIM). 2 The Use Case is used by Jacobson. These correspond to the scenarios that we talk about.
References-found: 13

