URL: http://www-sal.cs.uiuc.edu/~harrison/pubs/research/compile-FCS.ps.Z
Refering-URL: http://www-sal.cs.uiuc.edu/~harrison/pubs/research/research.html
Root-URL: http://www.cs.uiuc.edu
Email: fharrison,kaming@cs.uiuc.edu  
Title: Compilation as Partial Evaluation of Functor Category Semantics  
Author: William L. Harrison and Samuel N. Kamin 
Keyword: Compilers, Partial Evaluation, Semantics-Based Compilation, Programming Language Semantics.  
Date: April 6, 1997  
Affiliation: Department of Computer Science University of Illinois, Urbana-Champaign  
Abstract: Our goal is to produce the same compiler as Reynolds [12] via partial evaluation. We develop a continuation semantics for a higher-order, imperative, call-by-name Algol-like language which is based on the functor category semantics of Reynolds and Oles [11], and compile programs via the first Futumura projection. Our "compilation semantics" is non-standard in some ways (e.g., the meanings of expressions involve the use of temporary storage), although the meanings of terms are recognizably equivalent to their standard denotations. The target language is three address code as in the Dragon book, where the use of memory is explicit rather than implicit as with a stack machine. The presence of store shapes in our denotational description allows actual addresses of program variables to be used in the code, and also yields a very space-efficient method of handling temporary storage in the compilation of expressions. We improve upon Reynolds [12] by introducing jumps and labels in the compilation of conditional statements, thereby eliminating tree-structured machine code and code duplication. Our experiment was inspired by Danvy and Vestergaard [3], and we improve upon their result in that our interpreter is a high-level denotational definition for the language.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference: [2] <author> O. Danvy. </author> <title> Type-Directed Partial Evaluation. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1996. </year>
Reference-contexts: This section also gives an example of the result of partial evaluation, using Danvy's type-directed partial evaluator described in <ref> [2] </ref>. Section 4. Generating machine language code with labels, thereby avoiding code duplication and infinite programs, requires a more substantial departure from the standard semantics. However, the changes represent the use of a standard approach to the semantics of programs with jumps (e.g. [13, chapter 11]).
Reference: [3] <author> O. Danvy and R. Vestergaard. </author> <title> Semantics-Based Compiling: A Case Study in Type-Directed Partial Evaluation Eighth International Symposium on Programming Language Implementation and Logic Programming, </title> <booktitle> 1996, </booktitle> <pages> pages 182-197. </pages>
Reference-contexts: In short, it should be possible to read off the machine language, in executable form, directly from the partially-evaluated program. We take our cue from two recent papers, one on partial evaluation and one on compilation: In "Semantics-Based Compilation: A Case Study in Type-Directed Partial Evaluation" <ref> [3] </ref>, Danvy and Vestergaard show how to produce code that "looks like" machine language, by expressing the standard semantics in terms of machine language-like combinators (e.g., "update", "popblock", "push"). <p> These changes were not obvious, but we think that it is obvious that they preserve the semantic meaning of programs. Section 3. Two steps are needed before the compilation semantics of section 2 can be presented to a partial evaluator. One is to introduce machine language-like combinators a la <ref> [3] </ref>; this involves a simple rewriting of the compilation semantics. <p> The semantics of expressions and of the -calculus level are unaffected, but the semantics of commands involves a "code store" | an environment containing continuations | into which the meanings of code segments are stored. A shortcoming of both [12] and <ref> [3] </ref> that we have not been able to overcome is the treatment of "closed" procedures, which are necessary to compile recursion. <p> Obviously, this cannot work if x:e occurs in a recursive definition letrec f =x:e in : : :. Reynolds therefore provides a separate compilation scheme for this case, with no clear connection to the standard semantics of open procedures. In <ref> [3] </ref>, procedure calls are handled by using machine language combinators like "PushAccessLink," which causes their interpreter to look very different from an ordinary one. <p> Following Danvy and Vestergaard's method <ref> [3] </ref>, we must rewrite the semantics in terms of machine language-like combinators. The combinators we choose are similar to the target language in [12], and are presented in Figure 7. <p> The "compilation semantics" we developed for this experiment is non-standard in some ways in the use of temporary storage in the meanings of expressions for example and yet the meanings of terms are recognizably equivalent to their standard denotations. We also improve upon Danvy and Vestergaard <ref> [3] </ref> in that our 12 interpreter is a high-level denotational description for the source language. Currently, we are exploring two extensions to this work. Firstly, we are investigating minimal extensions to the compilation semantics which would allow compilation of closed procedures and, hence, of recursive definitions.
Reference: [4] <author> D. Espinosa. </author> <title> Semantic Lego. </title> <type> Doctoral Dissertation, </type> <institution> Columbia University, </institution> <year> 1995. </year>
Reference-contexts: The introduction of labels is a start in this direction. Secondly, we are investigating other ways of formulating the compilation semantics. In particular, formulating the language definition in terms of a monad constructed with monad transformers <ref> [4, 8, 9] </ref> appears to be a promising method of specifying the compilation semantics more succinctly, extensibly, and, above all, modularly. Similarly to Liang [8], our ultimate goal is to allow for the direct derivation of compilers from a monadic language definition.
Reference: [5] <author> N. D. Jones and D. A. Schmidt. </author> <title> Compiler Generation from Denotational Semantics. </title> <editor> In N. D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, </booktitle> <address> LNCS94, </address> <year> 1980, </year> <pages> pages 70-93. </pages>
Reference: [6] <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> Prentice-Hall International Series in Computer Science, Prentice-Hall 1993. </booktitle>
Reference: [7] <author> P. Lee. </author> <title> Realistic Compiler Generation. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference: [8] <author> S. Liang. </author> <title> A Modular Semantics for Compiler Generation. </title> <institution> Yale University Department of Computer Science Technical Report TR-1067, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: The introduction of labels is a start in this direction. Secondly, we are investigating other ways of formulating the compilation semantics. In particular, formulating the language definition in terms of a monad constructed with monad transformers <ref> [4, 8, 9] </ref> appears to be a promising method of specifying the compilation semantics more succinctly, extensibly, and, above all, modularly. Similarly to Liang [8], our ultimate goal is to allow for the direct derivation of compilers from a monadic language definition. <p> In particular, formulating the language definition in terms of a monad constructed with monad transformers [4, 8, 9] appears to be a promising method of specifying the compilation semantics more succinctly, extensibly, and, above all, modularly. Similarly to Liang <ref> [8] </ref>, our ultimate goal is to allow for the direct derivation of compilers from a monadic language definition.
Reference: [9] <author> S. Liang, P. Hudak, and M. Jones. </author> <title> Monad Transformers and Modular Interpreters. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <year> 1995. </year> <month> 13 </month>
Reference-contexts: The introduction of labels is a start in this direction. Secondly, we are investigating other ways of formulating the compilation semantics. In particular, formulating the language definition in terms of a monad constructed with monad transformers <ref> [4, 8, 9] </ref> appears to be a promising method of specifying the compilation semantics more succinctly, extensibly, and, above all, modularly. Similarly to Liang [8], our ultimate goal is to allow for the direct derivation of compilers from a monadic language definition.
Reference: [10] <author> L. C. Paulson. </author> <title> Compiler Generation from Denotational Semantics. </title> <editor> In Bernard Lorho, editor, </editor> <booktitle> Methods and Tools for Compiler Construction, </booktitle> <pages> pages 219-250. </pages> <publisher> Cambridge University Press, </publisher> <year> 1984. </year>
Reference: [11] <author> J. Reynolds. </author> <title> The Essence of Algol Algorithmic Languages, </title> <booktitle> Proceedings of the International Symposium on Algorithmic Languages, </booktitle> <address> Amsterdam, </address> <month> October 26-29, </month> <year> 1981, </year> <pages> pp. 345-372. </pages>
Reference-contexts: What distinguishes Reynolds's approach is the use of functor category semantics. In the semantic definition of <ref> [11] </ref>, functor category semantics is used to account for changes in the "shape" of the state at various points in the program, which confers certain semantic advantages. In [12], Reynolds adapts this idea to the construction of a compiler. <p> A program is any well-typed term of type Cmd. For the sake of brevity, we do not include the typing rules; they are in no way surprising. The semantic domains are included in Figure 2. In a functor category semantics for an Algol-like language as in <ref> [11] </ref>, the meaning of a phrase is parameterized by a store shape. At any point in the execution of a program, the set of locations in the store which are accessible by the program can be thought of as the shape of that store. <p> Similarly, integer continuations are IC = ! int ! Sto ! Ans. Given CC and IC, we follow the usual functor category semantics of Algol, where commands are functions from continuations to continuations and expressions are functions from integer continuations to continuations. Following Reynolds and Oles <ref> [11] </ref>, integer variables are acceptor-expresser pairs. The acceptor part of a variable takes an integer value, assigns that value to its variable, and continues with the program. The expresser part of an integer variable passes the current value of its variable to the rest of the program.
Reference: [12] <author> J. Reynolds. </author> <title> Using Functor Categories to Generate Intermediate Code. </title> <booktitle> Proceedings of the ACM Conference on the Principles of Programming Languages, </booktitle> <pages> pages 25-36, </pages> <year> 1995. </year>
Reference-contexts: When the interpreter is closed over these combinators, partial evaluation of this closed term with respect to a program produces a completely dynamic term, composed of a sequence of combinators. These combinators, then, constitute the target language of the compiler. In "Using Functor Categories to Generate Intermediate Code" <ref> [12] </ref>, Reynolds shows how to produce efficient code in a compiler closely related to the standard semantics of the language. The language is a higher-order, imperative, Algol-like language with call-by-name procedures. <p> What distinguishes Reynolds's approach is the use of functor category semantics. In the semantic definition of [11], functor category semantics is used to account for changes in the "shape" of the state at various points in the program, which confers certain semantic advantages. In <ref> [12] </ref>, Reynolds adapts this idea to the construction of a compiler. The "shape" of the state supplies useful information about the assignment of stack locations to variables and intermediate results. This permits the compiler to generate excellent code, in terms of the use of stack space. <p> This has entailed some changes in the standard semantics. Our main goal has been to obtain the same compiler as in <ref> [12] </ref> by making minimal modifications to the standard semantics. Furthermore, those modifications should produce a semantics that is clearly equivalent to the original. Second, Reynolds's compiler does not generate labels in machine language code. Machine language programs are tree-structured rather than linear, and loops actually produce infinite programs. <p> The remainder of the paper is structured as follows: Section 2. Here we present our "compilation semantics," by which we mean a version of the functor category semantics that can be used to produce the compiler of <ref> [12] </ref> by partial evaluation. 2 The emphasis in our presentation is on the few changes from the standard functor category semantics that we were obliged to make. These changes were not obvious, but we think that it is obvious that they preserve the semantic meaning of programs. Section 3. <p> The semantics of expressions and of the -calculus level are unaffected, but the semantics of commands involves a "code store" | an environment containing continuations | into which the meanings of code segments are stored. A shortcoming of both <ref> [12] </ref> and [3] that we have not been able to overcome is the treatment of "closed" procedures, which are necessary to compile recursion. In [12], a -expression, or "open procedure," x:e denotes a capability to produce machine language code; given the machine language M for a command C, it produces the <p> A shortcoming of both <ref> [12] </ref> and [3] that we have not been able to overcome is the treatment of "closed" procedures, which are necessary to compile recursion. In [12], a -expression, or "open procedure," x:e denotes a capability to produce machine language code; given the machine language M for a command C, it produces the machine language for e [C=x]; in other words, it inlines M . <p> In <ref> [12] </ref>, expressions are divided into those requiring temporary storage and those that do not. We need to make that distinction in our denotational semantics (though, of course, the meaning of terms must not change). Our solution is to give each expression two continuations, a "simple" and a "complex" one. <p> Following Danvy and Vestergaard's method [3], we must rewrite the semantics in terms of machine language-like combinators. The combinators we choose are similar to the target language in <ref> [12] </ref>, and are presented in Figure 7. <p> In order to partially evaluate the semantics, we must also give a precise definition of the domain , and its operations "+1" and t . Following <ref> [12] </ref>, the store is a stack. During program execution, the run-time stack will consist of a list of frames or activation records (numbered 0,...,n1), and any information in a frame accessible by the program will have a displacement or offset. <p> x is at location &lt;0; 0&gt;, while for the second one, which is compiled within the declaration of y, x has location &lt;0; 1&gt;. 5 Conclusions and Further Work Starting with a denotational semantics based on Reynolds and Oles' functor category semantics for Algol, we reproduced the results of Reynolds <ref> [12] </ref> for non-recursive programs in a partial evaluation setting. Through the introduction of the code store into the semantics of commands in Section 4, we used jumps and labels to eliminate the tree-structuring of the machine language code in Reynolds [12] and the code duplication incurred thereby. <p> category semantics for Algol, we reproduced the results of Reynolds <ref> [12] </ref> for non-recursive programs in a partial evaluation setting. Through the introduction of the code store into the semantics of commands in Section 4, we used jumps and labels to eliminate the tree-structuring of the machine language code in Reynolds [12] and the code duplication incurred thereby. The "compilation semantics" we developed for this experiment is non-standard in some ways in the use of temporary storage in the meanings of expressions for example and yet the meanings of terms are recognizably equivalent to their standard denotations.
Reference: [13] <author> J. E. Stoy. </author> <title> Denotational Semantics: the Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year> <month> 14 </month>
Reference-contexts: Section 4. Generating machine language code with labels, thereby avoiding code duplication and infinite programs, requires a more substantial departure from the standard semantics. However, the changes represent the use of a standard approach to the semantics of programs with jumps (e.g. <ref> [13, chapter 11] </ref>). The semantics of expressions and of the -calculus level are unaffected, but the semantics of commands involves a "code store" | an environment containing continuations | into which the meanings of code segments are stored. <p> In a traditional denotational semantics <ref> [13] </ref>, the type of command continuations CC might be defined as Sto ! Ans, while in a functor-category semantics, CC is a functor mapping store shapes to domains; CC (S) = functions from stores of shape S to answers. <p> The semantics of commands is given in Figure 3. In most ways, the meaning of commands is similar to a standard continuation semantics as one might find in Stoy <ref> [13] </ref>, but the functor categorical meaning of the new construct contains some subtle differences. <p> We remedy this by use of a technique common in giving denotational semantics to programs with jumps <ref> [13] </ref>. The idea is simple: when a command jumps to a label, it is invoking the continuation "stored" at that label. We make this "continuation store" explicit, and use it to store whatever continuations will be the targets of branches.
References-found: 13

