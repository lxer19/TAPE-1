URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1997/UM-CS-1997-020.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/97-020.html
Root-URL: 
Email: ljo@cs.umass.edu  
Title: Software Processes Are Software Too, Revisited: An Invited Talk on the Most Influential Paper of
Author: Leon J. Osterweil 
Address: Amherst, MA 01003 USA  
Affiliation: University of Massachusetts Dept. of Computer Science  
Abstract: The ICSE 9 paper, "Software Processes are Software Too," suggests that software processes are themselves a form of software and that there are considerable benefits that will derive from basing a discipline of software process development on the more traditional discipline of application software development. This paper attempts to clarify some misconceptions about this original ICSE 9 suggestion and summarizes some research carried out over the past ten years that seems to confirm the original suggestion. The paper then goes on to map out some future research directions that seem indicated. The paper closes with some ruminations about the significance of the controversy that has continued to surround this work. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Bandinelli, A. Fuggetta, and S. Grigolli. </author> <title> Process modeling in-the-large with SLANG. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 75 - 83, </pages> <year> 1993. </year>
Reference-contexts: This section briefly surveys what has been learned. Process Modelling There has been a great deal of study of how well various application software modelling formalisms model software processes. For example, Petri Nets <ref> [1] </ref>, [5], Finite State Machines [6], [11], and data flow diagrams [19] have been used to model software processes. <p> A series of papers published over the past five years demonstrates the viability of this approach [20, 21, 17]. In these papers popular software design methods (SDM's) are modelled using popular software process modelling formalisms (eg. HFSP [10] and Slang <ref> [1] </ref>). Comparison frameworks are hypothesized to guide classification of SDM features. A carefully defined SDM comparison process is executed to extract comparison results from the classifications of the models of the SDM's.
Reference: [2] <author> N. Belkhatir, J. Estublier, and Walcelio L. Melo. </author> <title> Adele 2: A support to large software development process. </title> <booktitle> In Proc. of the First International Conference on the Software Process, </booktitle> <pages> pages 159 - 170, </pages> <year> 1991. </year>
Reference-contexts: Experimentation has demonstrated the value of various programming paradigms, such as the procedural programming paradigm (eg. with the APPL/A language [22]), the rule based programming paradigm (eg. with MSL, the Marvel Specification Language [8]), and real-time programming approaches (eg. with Adele <ref> [2] </ref>). But this experimentation has also shown the inadequacy of each of these by itself.
Reference: [3] <author> G. A. Bolcer and R. N. Taylor. Endeavors: </author> <title> A pro-cess system integration infrastructure. </title> <booktitle> In Proc. of the Fourth International Conference on the Software Process, </booktitle> <pages> pages 76 - 85, </pages> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: In order for the cost and quality improvements mentioned above to be realized, execution engines for such languages will have to be developed. Recent research is leading to understandings that such engines must have highly flexible distributed architectures. The Amber project [9], and the Endeavors project <ref> [3] </ref> offer good examples of such architectures.
Reference: [4] <author> S. Brinkkemper, K. Lyytinen, and R. J. Welke. </author> <title> Method Engineering. </title> <publisher> Chapman & Hall, </publisher> <address> New York, </address> <year> 1996. </year>
Reference-contexts: Evolution of all of the above is to be an expected outcome of this experimentation. A steadily growing and improving stream of classifications, characterizations, and comparisons should also result. This line of research seems to be converging interestingly with research being done by the Method Engineering community (see, eg. <ref> [4] </ref>). Beyond Software Engineering In examining the hypothesis that software processes are software, there seems to be nothing particularly special about software processes. This suggests a hypothesis that processes in general are also software.
Reference: [5] <author> V. Gruhn and R. Jegelka. </author> <title> An evaluation of FUN-SOFT nets. </title> <booktitle> In Proc. of the Second Eurpoean Workshop on Software Process Technology, </booktitle> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: This section briefly surveys what has been learned. Process Modelling There has been a great deal of study of how well various application software modelling formalisms model software processes. For example, Petri Nets [1], <ref> [5] </ref>, Finite State Machines [6], [11], and data flow diagrams [19] have been used to model software processes.
Reference: [6] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot. STATEMATE: </author> <title> A working environment for the development of complex reactive systems. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 16(4):403 - 414, </volume> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: This section briefly surveys what has been learned. Process Modelling There has been a great deal of study of how well various application software modelling formalisms model software processes. For example, Petri Nets [1], [5], Finite State Machines <ref> [6] </ref>, [11], and data flow diagrams [19] have been used to model software processes. These activities have clearly demonstrated that application software modelling approaches can be strong aids in conceptualizing processes, in helping people to communicate about processes and collaborate in their execution, and in raising intuition about processes. <p> Thus, any particular model should be expected to be useful in some contexts, but less helpful in others. To support understanding of various aspects of a software product different models are generally needed. Thus, a number of modelling systems (eg. <ref> [6] </ref>) support the development and coordination of multiple models of application software. Experience in the software process domain has been similar.
Reference: [7] <author> W. S. Humphrey. </author> <title> Managing the Software Process. </title> <address> Reading, MA:Addison-Wesley, </address> <year> 1989. </year>
Reference-contexts: Indeed, the past ten years have witnessed explosive growth in work on the evaluation of software processes. Most of this work has grown out of the proposal of Humphrey and his colleagues at the Software Engineering Institute, of the Capability Maturity Model (CMM) <ref> [7] </ref> [16]. The aim of the CMM is to provide an evaluation vehicle for determining the quality of an organization's software development processes.
Reference: [8] <author> G. E. Kaiser, N. S. Barghouti, and M. H. Sokol-sky. </author> <title> Experience with process modeling in the marvel software development environment kernel. </title> <editor> In B. Shriver, editor, </editor> <booktitle> 23rd Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 131 - 140, </pages> <address> Kona HI, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: But, here application software coding languages have proven less useful. Experimentation has demonstrated the value of various programming paradigms, such as the procedural programming paradigm (eg. with the APPL/A language [22]), the rule based programming paradigm (eg. with MSL, the Marvel Specification Language <ref> [8] </ref>), and real-time programming approaches (eg. with Adele [2]). But this experimentation has also shown the inadequacy of each of these by itself.
Reference: [9] <author> G. E. Kaiser, I. Z. Ben-Shaul, S. S. Popovich, and S. E. Dossick. </author> <title> A metalinguistic approach to process enactment extensibility. </title> <booktitle> In 4th International Conference on the Software Process (to appear), </booktitle> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: In order for the cost and quality improvements mentioned above to be realized, execution engines for such languages will have to be developed. Recent research is leading to understandings that such engines must have highly flexible distributed architectures. The Amber project <ref> [9] </ref>, and the Endeavors project [3] offer good examples of such architectures.
Reference: [10] <author> T. Katayama. </author> <title> A hierarchical and functional software process description and its enaction. </title> <booktitle> In Proc. of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 343 - 353, </pages> <year> 1989. </year>
Reference-contexts: A series of papers published over the past five years demonstrates the viability of this approach [20, 21, 17]. In these papers popular software design methods (SDM's) are modelled using popular software process modelling formalisms (eg. HFSP <ref> [10] </ref> and Slang [1]). Comparison frameworks are hypothesized to guide classification of SDM features. A carefully defined SDM comparison process is executed to extract comparison results from the classifications of the models of the SDM's.
Reference: [11] <author> M. I. Kellner. </author> <title> Software process modeling support for management planning and control. </title> <booktitle> In Proc. of the First International Conference on the Software Process, </booktitle> <pages> pages 8 - 28, </pages> <year> 1991. </year>
Reference-contexts: This section briefly surveys what has been learned. Process Modelling There has been a great deal of study of how well various application software modelling formalisms model software processes. For example, Petri Nets [1], [5], Finite State Machines [6], <ref> [11] </ref>, and data flow diagrams [19] have been used to model software processes. These activities have clearly demonstrated that application software modelling approaches can be strong aids in conceptualizing processes, in helping people to communicate about processes and collaborate in their execution, and in raising intuition about processes. <p> Thus, a number of modelling systems (eg. [6]) support the development and coordination of multiple models of application software. Experience in the software process domain has been similar. State-mate was used as a process modelling tool <ref> [11] </ref>, and its support for multiple models was useful precisely because the different models supported understanding and reasoning from a variety of aspects. In the application software domain there is a growing understanding of which modelling tools and formalisms best elucidating which issues.
Reference: [12] <author> T. S. Kuhn. </author> <title> The Structure of Scientific Revolutions. </title> <publisher> University of Chicago Press [Chicago], </publisher> <year> 1962. </year>
Reference-contexts: Debates such as these, that help lead to that shared view, are critically important. In his renowned book, The Structure of Scientific Revolutions <ref> [12] </ref>, the historian of science, Thomas S.
Reference: [13] <author> M. M. Lehman. </author> <title> The Programming Process. In IBM Res. </title> <type> Rep. RC 2722, </type> <institution> IBM Res. Center, </institution> <address> Yorktown Heights, NY 10594, </address> <month> Sept. </month> <year> 1969. </year>
Reference-contexts: Applying the discipline of orderly process to software was not original with me. Lehman <ref> [13] </ref> and others [18] had suggested this long before. But I was troubled because I had started to see the development of a whole new discipline and technology around the idea of software process, and to notice the emergence of many notions and tools that seemed eerily familiar.
Reference: [14] <author> Leon J. Osterweil. </author> <title> Improving the quality of software quality determination processes. </title> <editor> In R. Boisvert, editor, </editor> <title> The Quality of Numerical Software: Assessment and Enhancement. </title> <publisher> Chapman & Hall, </publisher> <address> London, </address> <year> 1997. </year>
Reference-contexts: Formal specifications of such higher-order processes should facilitate more precise and sure reasoning about these key processes. These ideas are developed more fully in <ref> [14] </ref>. Process Requirements The observed parallels between modelling, coding, and evaluating application software and software processes might suggest that similar parallels have been demonstrated between application requirements specification and process requirements specifications.
Reference: [15] <author> L. J. Osterweil. </author> <title> Software Processes are Software Too. </title> <booktitle> In Proceedings of the Ninth International Conference of Software Engineering, </booktitle> <pages> pages 2-13, </pages> <address> Mon-terey CA, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: Introduction "Software Processes are Software Too." How many times I have heard that phrase quoted back to me in the past ten years! And how many times it has been (sometimes amusingly) misquoted too. Often I have been flattered to have had the ICSE9 paper <ref> [15] </ref> and its catchy title referred to as being "classic" and "seminal". But often I have also been asked, "what does that really mean?" The idea is, alas, still misunderstood and misconstrued in some quarters.
Reference: [16] <author> M. C. Paulk, B. Curtis, and M. B. Chrisis. </author> <title> Capability maturity model for software, version 1.1. </title> <type> Technical Report CMU/SEI-93-TR, </type> <institution> Carnegie Mel-lon University, Software Engineering Institute, </institution> <month> Feb. </month> <year> 1993. </year>
Reference-contexts: Indeed, the past ten years have witnessed explosive growth in work on the evaluation of software processes. Most of this work has grown out of the proposal of Humphrey and his colleagues at the Software Engineering Institute, of the Capability Maturity Model (CMM) [7] <ref> [16] </ref>. The aim of the CMM is to provide an evaluation vehicle for determining the quality of an organization's software development processes.
Reference: [17] <author> R. M. Podorozhny and L. J. Osterweil. </author> <title> The Crit-icality of Modeling Formalisms in Software Design Method Comparison,. </title> <type> Technical Report TR-96-049, </type> <institution> University of Massachusetts, Computer Science Department, </institution> <address> Amherst, MA, </address> <month> Aug. </month> <year> 1996. </year>
Reference-contexts: It further suggests that detailed models and encodings of these processes, using formalisms that are based on precise and deep semantics, can be bases for correspondingly precise characterizations, classifications, and comparisons. A series of papers published over the past five years demonstrates the viability of this approach <ref> [20, 21, 17] </ref>. In these papers popular software design methods (SDM's) are modelled using popular software process modelling formalisms (eg. HFSP [10] and Slang [1]). Comparison frameworks are hypothesized to guide classification of SDM features.
Reference: [18] <editor> Potts C. (ed). </editor> <booktitle> Proc. of the softw. process worksh. In IEEE cat. n. 84CH2044-6, Comp. </booktitle> <publisher> Soc., </publisher> <address> Wash-ington D. C., </address> <month> Feb. </month> <year> 1984. </year> <title> order n. </title> <type> 587, 27 - 35. </type>
Reference-contexts: Applying the discipline of orderly process to software was not original with me. Lehman [13] and others <ref> [18] </ref> had suggested this long before. But I was troubled because I had started to see the development of a whole new discipline and technology around the idea of software process, and to notice the emergence of many notions and tools that seemed eerily familiar.
Reference: [19] <author> Richard J. Mayer et al. </author> <title> IDEF family of methods for concurrent engineering and business re-engineering applications. </title> <type> Technical report, </type> <institution> Knowledge Based Systems, Inc., </institution> <year> 1992. </year>
Reference-contexts: This section briefly surveys what has been learned. Process Modelling There has been a great deal of study of how well various application software modelling formalisms model software processes. For example, Petri Nets [1], [5], Finite State Machines [6], [11], and data flow diagrams <ref> [19] </ref> have been used to model software processes. These activities have clearly demonstrated that application software modelling approaches can be strong aids in conceptualizing processes, in helping people to communicate about processes and collaborate in their execution, and in raising intuition about processes.
Reference: [20] <author> X. Song and L. Osterweil. </author> <title> Toward Objective, Systematic Design-Method Comparisons. </title> <journal> IEEE Software, </journal> <pages> pages 43 - 53, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: It further suggests that detailed models and encodings of these processes, using formalisms that are based on precise and deep semantics, can be bases for correspondingly precise characterizations, classifications, and comparisons. A series of papers published over the past five years demonstrates the viability of this approach <ref> [20, 21, 17] </ref>. In these papers popular software design methods (SDM's) are modelled using popular software process modelling formalisms (eg. HFSP [10] and Slang [1]). Comparison frameworks are hypothesized to guide classification of SDM features.
Reference: [21] <author> X. Song and L. J. Osterweil. </author> <title> Experience with an approach to comparing software design methodologies. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 20(5):364 - 384, </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: It further suggests that detailed models and encodings of these processes, using formalisms that are based on precise and deep semantics, can be bases for correspondingly precise characterizations, classifications, and comparisons. A series of papers published over the past five years demonstrates the viability of this approach <ref> [20, 21, 17] </ref>. In these papers popular software design methods (SDM's) are modelled using popular software process modelling formalisms (eg. HFSP [10] and Slang [1]). Comparison frameworks are hypothesized to guide classification of SDM features.
Reference: [22] <author> S. M. Sutton, Jr., D. Heimbigner, and L. J. Os-terweil. APPL/A: </author> <title> A language for software-process programming. </title> <journal> ACM Trans. on Software Engineering and Methodology, </journal> <volume> 4(3):221 - 286, </volume> <month> July </month> <year> 1995. </year>
Reference-contexts: We have also begun to understand the demanding requirements of process coding languages. But, here application software coding languages have proven less useful. Experimentation has demonstrated the value of various programming paradigms, such as the procedural programming paradigm (eg. with the APPL/A language <ref> [22] </ref>), the rule based programming paradigm (eg. with MSL, the Marvel Specification Language [8]), and real-time programming approaches (eg. with Adele [2]). But this experimentation has also shown the inadequacy of each of these by itself.
Reference: [23] <author> S. M. Sutton, Jr. and L. J. Osterweil. </author> <title> The design of a next-generation process language. </title> <type> Technical Report CMPSCI Technical Report 96-30, </type> <institution> University of Massachusetts at Amherst, Computer Science Department, </institution> <address> Amherst, Massachusetts 01003, </address> <month> May </month> <year> 1996. </year> <note> Revised January, </note> <year> 1997. </year>
Reference-contexts: The act of defining the process by executable code does not necessarily unduly restrict the human, although the nature of the code may do so. Indeed, the JIL <ref> [23] </ref> language, is an example of a process coding language that supports considerable latitude in the degree of specificity of process definition. Here too, experience suggests that a wide range of process coding languages and coding styles seem to be of value. <p> Experience has shown that representing in a clear and straight forward way all of the details and complexities of soft-ware processes by means of a language with executable semantics is far more difficult and challenging than was expected ten years ago. Second generation languages such as JIL <ref> [23] </ref>, which enable the blending of the benefits of various programming language paradigms, seem to hold promise. More experimentation and evaluation of such languages is clearly indicated. In order for the cost and quality improvements mentioned above to be realized, execution engines for such languages will have to be developed.
References-found: 23

