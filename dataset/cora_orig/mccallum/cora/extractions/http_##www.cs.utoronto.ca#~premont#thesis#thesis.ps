URL: http://www.cs.utoronto.ca/~premont/thesis/thesis.ps
Refering-URL: http://www.cs.toronto.edu/~premont/
Root-URL: 
Title: THE SITUATION CALCULUS AND HEHNER'S PROGRAMMING THEORY: HARMONIZATION THROUGH REIFICATION  
Author: by Patrick Premont 
Degree: A thesis submitted in conformity with the requirements for the degree of Master of Science  
Note: c Copyright by Patrick Premont 1997  
Address: Toronto  
Affiliation: Graduate Department of Computer Science University of  
Abstract-found: 0
Intro-found: 1
Reference: [Elkan96] <author> Charles Elkan, </author> <title> "Reasoning about Unknown, Counterfactual, and Nondeterministic Actions in First-Order Logic", </title> <booktitle> Advances in Artificial Intelligence: AI '96 Proceedings, </booktitle> <address> Toronto, Ontario, Canada, </address> <month> May </month> <year> 1996, </year> <pages> pp. 54-68. </pages>
Reference-contexts: For example in <ref> [Elkan96] </ref> fluents are not treated as functions but are given a first class status. They become objects on which functions may be applied and quantification may be performed within first-order logic; they are reified. <p> of a fluent or state variable slope, in the situation or state s, we would proceed as follows: In the situation calculus we would apply the fluent slope to the situation s. slope s In slightly different variants of the situation calculus, such as the ones used by Elkan in <ref> [Elkan96] </ref> and Pinto in [Pinto94], a special function Holds is used. It takes a fluent and a situation as arguments. However, as the name suggests, Holds gives access only to propositional fluents, by telling us whether or not a proposition holds in a situation. <p> Functions are not first class objects in first order logic, therefore one cannot quantify over states or fluents if they are represented as functions. Quantification over states is required to specify the effect of actions, while quantification over fluents may or may not be required. Elkan, in <ref> [Elkan96] </ref>, uses quantification over fluents to compress the successor state axioms for all fluents into only one axiom. <p> By accessing the value of fluents through V al and by considering fluents as first class objects over which we may quantify, the successor state axioms for each fluent may be combined into a single successor state axiom. This is done in <ref> [Elkan96] </ref> for relational fluents whose truth value is accessed by Holds.
Reference: [Hehner93] <author> Eric C.R. Hehner, </author> <title> A Practical Theory of Programming, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: Another field is software engineering, where theories of programming are developed to help programmers create programs, reason about their properties, and prove that they meet the desired specifications. A particularly simple yet general formalism is Hehner's theory of programming <ref> [Hehner93] </ref>. Its general approach is also used by other researchers interested in programming from formal specifications [Morgan90]. Such a formalism is 1 Work in this area continues in the Cognitive Robotics Group at the Department of Computer Science of the University of Toronto. <p> Additional information about the formalisms will be provided progressively in the following chapters. 2.1 Hehner's Theory of Programming Hehner's theory of programming <ref> [Hehner93] </ref> provides axioms and proof rules which allow us to express and reason about states, programs and specifications. In this formalism, states are represented as lists. <p> But manual proofs are of limited interest due to 3 The operator "," is the bunch union operator which merges bunches, and consequently, creates bunches of many elements from individual elements (elementary bunches). 4 The completion rule, from <ref> [Hehner93] </ref>, says that "if a boolean expression contains unclassified boolean subexpressions, and all ways of classifying them place it in the same class, then it is in that class." The classes to which this refers are the class of formulas that equal &gt; and the class of formulas that equal ?, <p> expression contains unclassified boolean subexpressions, and all ways of classifying them place it in the same class, then it is in that class." The classes to which this refers are the class of formulas that equal &gt; and the class of formulas that equal ?, called theorems and anti-theorems in <ref> [Hehner93] </ref>. 19 the amount of work involved, and automated theorem provers would benefit considerably from the use of relations for specifications and programs because they then become first class objects characterized by standard axioms. 3.3.3 Specification of the Effect of Actions The effect of actions may be specified by describing the <p> One reason is that the situation calculus has many variants but, for the moment, no approach to time and concurrency that offers a completely satisfactory treatment of GOLOG. These approaches also differ from Hehner's approach in <ref> [Hehner93] </ref> on many fundamental aspects, which makes unification difficult. We therefore limit ourselves to a brief comparison of the approaches, which should make the main difficulties apparent. The modifications we have made previously to the formalisms should not prevent the implementation of any of these approaches.
Reference: [Hehner94] <author> Eric C.R. Hehner, </author> <title> "Abstractions of Time", chapter 12 in A Classical Mind, edited by A.W. Roscoe, </title> <booktitle> Prentice-Hall International Series in Computer Science, </booktitle> <address> London, </address> <year> 1994, </year> <pages> pp. 191-210. </pages>
Reference-contexts: The fact that parts of these processes may be executed at the same time has no impact on their effect. The processes are truly independent until they terminate. However dependencies may be inserted deliberately using communication channels, which are structures shared by the processes. In <ref> [Hehner94] </ref> there is also a different presentation of time and concurrency for Hehner's theory. Its concurrency partitions fluents between processes. Each process is responsible for specifying the values taken by some fluents, the other fluents are described by other processes. <p> Therefore neither our approach nor that of channels can accommodate all cases. Yet another approach is introduced in <ref> [Hehner94] </ref>. There it is possible to refer to intermediate states because the logical nature of specifications is modified to allow this. A specification is seen as a relation between time points. By using arithmetic on these time points it is possible to talk about the intermediate time points.
Reference: [Jackson95] <author> Michael Jackson, </author> <title> Software Requirements & Specifications, </title> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference: [Lesperance94] <author> Y. Lesperance, H. Levesque, F. Lin, D. Marcu, R. Reiter, and R. Scherl, </author> <title> "A Logical Approach to High-Level Robot Programming A Progress Report". </title> <editor> In Benjamin Kuipers ed., </editor> <booktitle> Control of the Physical World by Intelligent Systems, Papers from the 1994 AAAI Fall Symposium, </booktitle> <address> New Orleans, LA, </address> <month> November </month> <year> 1994, </year> <pages> pp. 79-85. </pages>
Reference-contexts: Its general approach is also used by other researchers interested in programming from formal specifications [Morgan90]. Such a formalism is 1 Work in this area continues in the Cognitive Robotics Group at the Department of Computer Science of the University of Toronto. For an example see <ref> [Lesperance94] </ref>. 1 not limited to the description of software processes. Its notions of states, variables and programs may be used to describe all sorts of dynamic systems.
Reference: [Lesperance96] <author> Y. Lesperance, H. Levesque, F. Lin, D. Marcu, R. Reiter, and R. Scherl, </author> <title> "Foundations of a Logical Approach to Agent Programming", </title> <editor> In M. Wooldridge, J.P. Muller, and M. Tambe, editors, </editor> <booktitle> Intelligent Agents Volume II Proceedings of the 1995 Workshop on Agent Theories, Architec 54 tures, and Languages (ATAL-95), </booktitle> <pages> pp. 331-346, </pages> <editor> Springer-Verlag, </editor> <booktitle> Lecture Notes in Artificial Intelligence, </booktitle> <year> 1996. </year>
Reference-contexts: Other variants [Pinto94] [Reiter96] allow the simultaneous execution of many primitive actions, and introduce the concept of time in the situation calculus. A variant also includes the notion of agent <ref> [Lesperance96] </ref>. <p> Pinto's treatment follows this approach, and accordingly does not present a concurrent programming construct that would create GOLOG processes. In other variants <ref> [Lesperance96] </ref>, concurrency is introduced through an interleaving of the actions. It extends the programming language to CONGOLOG (CONcurrent GOLOG). <p> In this context, rational agents are processes which obtain, maintain, and act on rational knowledge about the world. A formalization of this is presented in [Shapiro95]. The communication of knowledge, treated in [Marcu95] and <ref> [Lesperance96] </ref>, may involve the transmission of complex logical sentences about the world. Modal operators are used to operate on these sentences. However with reified expressions it becomes possible to transmit logical sentences in the form of expressions, and operate on them using standard functions.
Reference: [Levesque94] <author> Hector J. Levesque, Raymond Reiter, Yves Lesperance, Fangzhen Lin, and Richard B. Scherl, "GOLOG: </author> <title> A Logic Programming Language for Dynamic Domains", </title> <journal> Journal of Logic Programming, Special Issue on Action and Processes, </journal> <volume> vol. 31, </volume> <year> 1997, </year> <pages> pp. 59-83. </pages>
Reference-contexts: The formalism in itself does not provide a way of creating complex actions, or programs, from primitive actions. To extend the expressiveness of the formalism to complex actions, a programming language called GOLOG <ref> [Levesque94] </ref> has been developed by the Cognitive Robotics Group at the Department of Computer Science of the University of Toronto. Its semantics are defined through an extra-logical predicate Do that takes a program, an initial situation and a final situation as arguments. <p> These constructs are not composed of actions only, they also contain formulas, which are not first class objects and cannot be arguments of normal functions. 16 A solution, which is outlined but not adopted in <ref> [Levesque94] </ref>, consists in reifying formulas. We discuss this approach in section 4.2. <p> In that case applying Do to only an action returns a relation between two situations, which, as in Hehner's theory, specifies the effect of the action. The semantics of GOLOG programs may then be expressed by rewriting the usual axioms, which can be found in <ref> [Levesque94] </ref>, as follows: Do a s s 0 = (P oss a s ^ s 0 = do a s) (3.8) Do (test p) s s 0 = (p s ^ s = s 0 ) (3.9) Do [a 1 ; a 2 ] s s 0 = (9s 00 Do <p> This means that Do (iter a) s s 0 holds if and only if P s s 0 holds for the least fixed point P . GOLOG also implements procedures. To fully specify their effect in recursive cases, a least fixed point definition is used in <ref> [Levesque94] </ref>. We have not axiomatized procedures here because, as in Hehner's theory, -expressions that return programs may be used as 28 procedures. A procedure may then be named like any other object, by equating it to a symbol. <p> In such cases the axioms defining Do may not determine a unique solution for the value of Do on that action and that pair of situations. A solution is the introduction of a least fixed point definition to force the indeterminate values to be false. This is done in <ref> [Levesque94] </ref> and could be reproduced in this variant of the formalism by adding, for each recursive procedure, an axiom that constrains its semantics to the least fixed point. A trivial but illustrative example is the procedure Z recursively defined as Z = Z. <p> However overloading functions in this manner is ambiguous in cases such as 3 + 4, which should sometimes yield 7, and 43 sometimes yield an expression evaluating to 7 by adding 3 to 4. Using a different symbol is therefore preferable. The convention suggested in <ref> [Levesque94] </ref> to denote such functions is to place a hat ( b ) over the normal function's symbol.
Reference: [Lin94] <author> F. Lin and R. Reiter, </author> <title> "State Constraints Revisited", </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(5) </volume> <pages> 655-678, </pages> <note> Special Issue on Action and Processes, </note> <year> 1994. </year>
Reference-contexts: It should be noted that these transformations correspond to the reification of functions, booleans and sorts, respectively. 3.1.2 Foundational Axioms of the Situation Calculus The foundational axioms of the situation calculus <ref> [Lin94] </ref> axiomatize the situations, the function do and an ordering relation &lt; on situations. <p> This presents a problem, if there are abstract and concrete fluents which represent the same object in different forms, then there must be a state constraint which ensures that the fluents always change in a compatible manner. However state constraints <ref> [Lin94] </ref> introduce difficulties such as the ramification problem, which would require significant modifications to the specification of the effect of actions. Here however the state constraint is very simple, it maintains a bijection between two fluents or sets of fluents.
Reference: [Marcu95] <author> D. Marcu, Y. Lesperance, H. Levesque, F. Lin, R. Reiter, and R. Scherl, </author> <title> "Distributed Software Agents and Communication in the Situation Calculus", </title> <booktitle> Proceedings of the Intelligent Computer Communication (ICC'95) Conference, </booktitle> <address> Cluj-Napoca, Romania, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: In this context, rational agents are processes which obtain, maintain, and act on rational knowledge about the world. A formalization of this is presented in [Shapiro95]. The communication of knowledge, treated in <ref> [Marcu95] </ref> and [Lesperance96], may involve the transmission of complex logical sentences about the world. Modal operators are used to operate on these sentences. However with reified expressions it becomes possible to transmit logical sentences in the form of expressions, and operate on them using standard functions.
Reference: [McCarthy63] <author> John McCarthy, </author> <title> Situations, actions and causal laws, </title> <type> technical report, </type> <institution> Stanford University, </institution> <year> 1963. </year> <note> Reprinted in Semantic Information Processing (M. </note> <editor> Minsky ed.), </editor> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1968, </year> <pages> pp. 410-417. </pages>
Reference-contexts: There the problem of designing machines able to reason about the world, in all its generality, leads to the development of general formalisms to reason about actions and their effect, such as the situation calculus. This calculus has been part of artificial intelligence for a long time <ref> [McCarthy63] </ref>, but has recently received more interest as a powerful foundation for the development of serious applications such as the control of robots by rational agents 1 .
Reference: [Morgan90] <author> Carroll Morgan, </author> <title> Programming form specifications, </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: A particularly simple yet general formalism is Hehner's theory of programming [Hehner93]. Its general approach is also used by other researchers interested in programming from formal specifications <ref> [Morgan90] </ref>. Such a formalism is 1 Work in this area continues in the Cognitive Robotics Group at the Department of Computer Science of the University of Toronto. For an example see [Lesperance94]. 1 not limited to the description of software processes.
Reference: [Pinto94] <author> Javier Andres Pinto, </author> <title> Temporal Reasoning in the Situation Calculus. </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Science, University of Toronto, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: For example in [Elkan96] fluents are not treated as functions but are given a first class status. They become objects on which functions may be applied and quantification may be performed within first-order logic; they are reified. Other variants <ref> [Pinto94] </ref> [Reiter96] allow the simultaneous execution of many primitive actions, and introduce the concept of time in the situation calculus. A variant also includes the notion of agent [Lesperance96]. <p> state variable slope, in the situation or state s, we would proceed as follows: In the situation calculus we would apply the fluent slope to the situation s. slope s In slightly different variants of the situation calculus, such as the ones used by Elkan in [Elkan96] and Pinto in <ref> [Pinto94] </ref>, a special function Holds is used. It takes a fluent and a situation as arguments. However, as the name suggests, Holds gives access only to propositional fluents, by telling us whether or not a proposition holds in a situation. <p> We therefore limit ourselves to a brief comparison of the approaches, which should make the main difficulties apparent. The modifications we have made previously to the formalisms should not prevent the implementation of any of these approaches. A variant of the situation calculus has been introduced by Pinto in <ref> [Pinto94] </ref> which includes a treatment of time and concurrency. Pinto also covers the integration of the complex actions of GOLOG in this variant, but only for the time aspect.
Reference: [Reiter91] <author> Raymond Reiter. </author> <title> "The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression", </title> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <editor> Vladimir Lifschitz (Ed.), </editor> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1991, </year> <pages> pp. 359-380. </pages>
Reference-contexts: Other variants [Pinto94] [Reiter96] allow the simultaneous execution of many primitive actions, and introduce the concept of time in the situation calculus. A variant also includes the notion of agent [Lesperance96]. Later, when we refer to the situation calculus, it should be understood to mean the variant used in <ref> [Reiter91] </ref>, which does not include the special features of the variants mentioned above. 8 Chapter 3 Comparison of the Two Formalisms 3.1 Logic and Syntax To some extent, the differences between the two formalisms are due to their different logics and syntax.
Reference: [Reiter96] <author> Raymond Reiter, </author> <title> "Natural actions, concurrency and continuous time in the situation calculus", </title> <booktitle> Principles of Knowledge Representation and Rea 55 soning: Proceedings of the Fifth International Conference (KR'96), </booktitle> <address> Cam--bridge, Massachusetts, U.S.A., </address> <month> November </month> <year> 1996. </year>
Reference-contexts: For example in [Elkan96] fluents are not treated as functions but are given a first class status. They become objects on which functions may be applied and quantification may be performed within first-order logic; they are reified. Other variants [Pinto94] <ref> [Reiter96] </ref> allow the simultaneous execution of many primitive actions, and introduce the concept of time in the situation calculus. A variant also includes the notion of agent [Lesperance96].
Reference: [Shapiro95] <author> S. Shapiro, Y. Lesperance, and H. Levesque, </author> <title> "Goals and Rational Action in the Situation Calculus | A Preliminary Report", </title> <booktitle> Working Notes of the AAAI Fall Symposium on Rational Agency: Concepts, Theories, Models, and Applications, </booktitle> <address> Cambridge, MA, </address> <month> November </month> <year> 1995. </year> <month> 56 </month>
Reference-contexts: Rational communication between agents Some work has been done to derive variants of the situation calculus which allow interactions between rational agents. In this context, rational agents are processes which obtain, maintain, and act on rational knowledge about the world. A formalization of this is presented in <ref> [Shapiro95] </ref>. The communication of knowledge, treated in [Marcu95] and [Lesperance96], may involve the transmission of complex logical sentences about the world. Modal operators are used to operate on these sentences.
References-found: 15

