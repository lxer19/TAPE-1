URL: http://www.prolangs.rutgers.edu/refs/docs/fse96.ps
Refering-URL: http://www.csd.uu.se/~thomasl/wpo/alias-papers.html
Root-URL: 
Email: fxxzhang,ryderg@cs.rutgers.edu  wlandi@scr.siemens.com  
Title: Program Decomposition for Pointer Aliasing: A Step toward Practical Analyses  
Author: Sean Zhang Barbara G. Ryder William Landi 
Address: Piscataway, NJ 08855  755 College Rd. East Princeton, NJ 08540  
Affiliation: Department of Computer Science Rutgers University Hill Center, Busch Campus  Siemens Corporate Research Inc  
Abstract: Pointer aliasing analysis is crucial to compile-time analyses for languages with general-purpose pointer usage (such as C), but many aliasing methods have proven quite costly. We present a technique that partitions the statements of a program to allow separate, and therefore possibly different, pointer aliasing analysis methods to be used on independent parts of the program. This decomposition enables exploration of tradeoff between algorithm efficiency and precision. We also present a new, efficient flow-insensitive pointer aliasing algorithm, which is used together with an existing flow-sensitive aliasing algorithm in our experiments. We demonstrate our technique in the context of determining side effects and variable fetches through names containing pointer dereferences (Thru-deref MOD/REF). Initial empirical results using a combination of a flow-sensitive and a flow-insensitive aliasing analysis on the same program, demonstrate that the resulting analysis is much faster than solely using the flow-sensitive method, and obtains similar precision for the Thru-deref MOD/REF problems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> Data Structures and Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Analysis information is also essential for data-flow-based testing [10, 12, 13, 18, 29, 31], semantic change analysis [5, 28, 33, 34, 35, 42, 43], integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision <ref> [1] </ref> (e.g., verifying that variables are initialized before they are used). In languages with general-purpose pointer usage, two names may access the same location during execution; they are called aliases. For example, the assignment p = &x fl This research was supported, in part, by NSF grants CCR95-01761 and GER90-23628.
Reference: [2] <author> Rita Altucher and William Landi. </author> <type> Personal communication. </type> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: The problem is also proved P-space hard for finite-level ( 2) pointer dereferences [19] and undecidable for recursive data structures [20, 30]. The FA relation is similar to the points-to relation [37] and the PWA relation <ref> [2, 24] </ref>. The approach in [37] is based on a non-standard type inference technique; it handles type casting and indirect calls through function pointers, but does not allow structure types as in C. The approach in [2, 24] is to calculate a program-wide alias relation, which is reflexive, symmetric, transitive and <p> The FA relation is similar to the points-to relation [37] and the PWA relation <ref> [2, 24] </ref>. The approach in [37] is based on a non-standard type inference technique; it handles type casting and indirect calls through function pointers, but does not allow structure types as in C. The approach in [2, 24] is to calculate a program-wide alias relation, which is reflexive, symmetric, transitive and weakly right-regular. It handles programs with function pointers and type casting, but relies on type information for structure assignments. <p> The idea of program decomposition for pointer aliasing analysis was motivated by the work on constructing call graphs for programs with calls through function pointers <ref> [2] </ref>. G FA for a program can be perceived as a storage shape graph [6, 26] although it may be quite approximate when there are recursive data structures. 7 Conclusions and Future Work We have presented a program decomposition technique for pointer aliasing analysis on well-typed C programs.
Reference: [3] <author> Lars Ole Andersen. </author> <title> Program analysis and specialization for the C programming language. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Copenhagen, </institution> <month> may </month> <year> 1994. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations [6, 8, 11, 14, 15, 26, 36]; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion <ref> [3, 4, 7, 22, 27, 32, 37, 40] </ref>. All of these methods vary in the precision of the aliasing information calculated and their cost. For compile-time pointer aliasing analysis, a program can be considered a sequence of assignments having effects on pointer aliasing; we call them pointer-related assignments.
Reference: [4] <author> Michael Burke, Paul Carini, Jong-Deok Choi, and Michael Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> number No. 892, </volume> <pages> pages 234-250. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <booktitle> Proceedings from the 7th International Workshop on Languages and Compilers for Parallel Computing. </booktitle>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations [6, 8, 11, 14, 15, 26, 36]; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion <ref> [3, 4, 7, 22, 27, 32, 37, 40] </ref>. All of these methods vary in the precision of the aliasing information calculated and their cost. For compile-time pointer aliasing analysis, a program can be considered a sequence of assignments having effects on pointer aliasing; we call them pointer-related assignments.
Reference: [5] <author> M. D. Carroll and B. G. Ryder. </author> <title> Incremental data flow analysis via dominator and attribute updates. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 274-284, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing [10, 12, 13, 18, 29, 31], semantic change analysis <ref> [5, 28, 33, 34, 35, 42, 43] </ref>, integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [6] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Many techniques for compile-time pointer aliasing analysis have been proposed [3, 4, 6, 7, 8, 9, 11, 14, 15, 22, 26, 27, 32, 36, 37, 39, 40]. Some of them are more appropriate for aliases involving accesses to heap locations <ref> [6, 8, 11, 14, 15, 26, 36] </ref>; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion [3, 4, 7, 22, 27, 32, 37, 40]. All of these methods vary in the precision of the aliasing information calculated and their cost. <p> The idea of program decomposition for pointer aliasing analysis was motivated by the work on constructing call graphs for programs with calls through function pointers [2]. G FA for a program can be perceived as a storage shape graph <ref> [6, 26] </ref> although it may be quite approximate when there are recursive data structures. 7 Conclusions and Future Work We have presented a program decomposition technique for pointer aliasing analysis on well-typed C programs. We also provide an algorithm for calculating safe flow-insensitive aliasing solution for a program.
Reference: [7] <author> J. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive in-terprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of te 20th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations [6, 8, 11, 14, 15, 26, 36]; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion <ref> [3, 4, 7, 22, 27, 32, 37, 40] </ref>. All of these methods vary in the precision of the aliasing information calculated and their cost. For compile-time pointer aliasing analysis, a program can be considered a sequence of assignments having effects on pointer aliasing; we call them pointer-related assignments.
Reference: [8] <author> Alain Deutsch. </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting. </title> <booktitle> In Proceedings of SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 230-241, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Many techniques for compile-time pointer aliasing analysis have been proposed [3, 4, 6, 7, 8, 9, 11, 14, 15, 22, 26, 27, 32, 36, 37, 39, 40]. Some of them are more appropriate for aliases involving accesses to heap locations <ref> [6, 8, 11, 14, 15, 26, 36] </ref>; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion [3, 4, 7, 22, 27, 32, 37, 40]. All of these methods vary in the precision of the aliasing information calculated and their cost.
Reference: [9] <author> Maryam Emami, Rakesh Ghiya, and Laurie Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations [6, 8, 11, 14, 15, 26, 36]; others for aliases involving accesses to stack locations <ref> [9, 39] </ref>. Still others handle both in a similar fashion [3, 4, 7, 22, 27, 32, 37, 40]. All of these methods vary in the precision of the aliasing information calculated and their cost. <p> Any of these algorithms can be employed for individual weakly connected components in our program decomposition as our decomposition enables a sparse program representation for each component with only the pointer-related assignments associated with that component. The work by the research group at McGill University <ref> [9, 11] </ref> is particularly related. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. They first perform a stack-base analysis [9], which identifies pointers to the heap, and then they apply a heap-based analysis [11] for these heap-directed pointers. <p> The work by the research group at McGill University [9, 11] is particularly related. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. They first perform a stack-base analysis <ref> [9] </ref>, which identifies pointers to the heap, and then they apply a heap-based analysis [11] for these heap-directed pointers. Our approach of program decomposition is more general than their decou-pling.
Reference: [10] <author> P. Frankl and E. Weyuker. </author> <title> An applicable family of data flow testing criteria. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(10) </volume> <pages> 1483-1498, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing <ref> [10, 12, 13, 18, 29, 31] </ref>, semantic change analysis [5, 28, 33, 34, 35, 42, 43], integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [11] <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Is it a tree, a dag, or a cyclic graph? a shape analysis for heap-directed pointers in c. </title> <booktitle> In Conference Record of te 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Many techniques for compile-time pointer aliasing analysis have been proposed [3, 4, 6, 7, 8, 9, 11, 14, 15, 22, 26, 27, 32, 36, 37, 39, 40]. Some of them are more appropriate for aliases involving accesses to heap locations <ref> [6, 8, 11, 14, 15, 26, 36] </ref>; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion [3, 4, 7, 22, 27, 32, 37, 40]. All of these methods vary in the precision of the aliasing information calculated and their cost. <p> Any of these algorithms can be employed for individual weakly connected components in our program decomposition as our decomposition enables a sparse program representation for each component with only the pointer-related assignments associated with that component. The work by the research group at McGill University <ref> [9, 11] </ref> is particularly related. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. They first perform a stack-base analysis [9], which identifies pointers to the heap, and then they apply a heap-based analysis [11] for these heap-directed pointers. <p> The work by the research group at McGill University [9, 11] is particularly related. Their approach is to decouple the stack-based aliasing analysis and heap-based aliasing analysis. They first perform a stack-base analysis [9], which identifies pointers to the heap, and then they apply a heap-based analysis <ref> [11] </ref> for these heap-directed pointers. Our approach of program decomposition is more general than their decou-pling. First, not all pointers to the heap require sophisticated analysis; our approach can identify statements related to recursive data structures, on which a heap-based aliasing analysis may be focused.
Reference: [12] <author> M. J. Harrold and M. L. Soffa. </author> <title> Interprocedural data flow testing. </title> <booktitle> In Proceedings of the Third Testing, Analysis, and Verification Symposium, </booktitle> <pages> pages 158-167, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing <ref> [10, 12, 13, 18, 29, 31] </ref>, semantic change analysis [5, 28, 33, 34, 35, 42, 43], integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [13] <author> M. J. Harrold and M. L. Soffa. </author> <title> Efficient computation of interpro-cedural definition-use chains. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(2) </volume> <pages> 175-204, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing <ref> [10, 12, 13, 18, 29, 31] </ref>, semantic change analysis [5, 28, 33, 34, 35, 42, 43], integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [14] <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transaction on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <year> 1990. </year>
Reference-contexts: Many techniques for compile-time pointer aliasing analysis have been proposed [3, 4, 6, 7, 8, 9, 11, 14, 15, 22, 26, 27, 32, 36, 37, 39, 40]. Some of them are more appropriate for aliases involving accesses to heap locations <ref> [6, 8, 11, 14, 15, 26, 36] </ref>; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion [3, 4, 7, 22, 27, 32, 37, 40]. All of these methods vary in the precision of the aliasing information calculated and their cost.
Reference: [15] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of SIGPLAN'89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Many techniques for compile-time pointer aliasing analysis have been proposed [3, 4, 6, 7, 8, 9, 11, 14, 15, 22, 26, 27, 32, 36, 37, 39, 40]. Some of them are more appropriate for aliases involving accesses to heap locations <ref> [6, 8, 11, 14, 15, 26, 36] </ref>; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion [3, 4, 7, 22, 27, 32, 37, 40]. All of these methods vary in the precision of the aliasing information calculated and their cost.
Reference: [16] <author> S. Horwitz, J. Prins, and T Reps. </author> <title> Integrating non-interfering versions of programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <year> 1989. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing [10, 12, 13, 18, 29, 31], semantic change analysis [5, 28, 33, 34, 35, 42, 43], integration of program versions <ref> [16, 17, 41] </ref> and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used). In languages with general-purpose pointer usage, two names may access the same location during execution; they are called aliases.
Reference: [17] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1), </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing [10, 12, 13, 18, 29, 31], semantic change analysis [5, 28, 33, 34, 35, 42, 43], integration of program versions <ref> [16, 17, 41] </ref> and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used). In languages with general-purpose pointer usage, two names may access the same location during execution; they are called aliases.
Reference: [18] <author> M. Hutchins, H. Foster, T. Goradia, and T. </author> <title> Ostrand. Experiments on the effectiveness of dataflow- and controlflow-based test adequacy criteria. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Software Engineering, </booktitle> <year> 1994. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing <ref> [10, 12, 13, 18, 29, 31] </ref>, semantic change analysis [5, 28, 33, 34, 35, 42, 43], integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [19] <author> William Landi. </author> <title> Interprocedural aliasing in the presence of pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: The may aliasing problem is proved polynomial for single-level pointers [21] and NP-hard for multiple-level pointers [21, 25]. The problem is also proved P-space hard for finite-level ( 2) pointer dereferences <ref> [19] </ref> and undecidable for recursive data structures [20, 30]. The FA relation is similar to the points-to relation [37] and the PWA relation [2, 24].
Reference: [20] <author> William Landi. </author> <title> Undecidability of static analysis. </title> <journal> ACM letters on programming languages and systems, </journal> <volume> 1 </volume> <pages> 323-337, </pages> <year> 1992. </year>
Reference-contexts: The may aliasing problem is proved polynomial for single-level pointers [21] and NP-hard for multiple-level pointers [21, 25]. The problem is also proved P-space hard for finite-level ( 2) pointer dereferences [19] and undecidable for recursive data structures <ref> [20, 30] </ref>. The FA relation is similar to the points-to relation [37] and the PWA relation [2, 24]. The approach in [37] is based on a non-standard type inference technique; it handles type casting and indirect calls through function pointers, but does not allow structure types as in C.
Reference: [21] <author> William Landi and Barbara G. Ryder. </author> <title> Pointer-induced aliasing: a problem classification. </title> <booktitle> In Conference Record of the 18th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: The may aliasing problem is proved polynomial for single-level pointers <ref> [21] </ref> and NP-hard for multiple-level pointers [21, 25]. The problem is also proved P-space hard for finite-level ( 2) pointer dereferences [19] and undecidable for recursive data structures [20, 30]. The FA relation is similar to the points-to relation [37] and the PWA relation [2, 24]. <p> The may aliasing problem is proved polynomial for single-level pointers [21] and NP-hard for multiple-level pointers <ref> [21, 25] </ref>. The problem is also proved P-space hard for finite-level ( 2) pointer dereferences [19] and undecidable for recursive data structures [20, 30]. The FA relation is similar to the points-to relation [37] and the PWA relation [2, 24].
Reference: [22] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of 1992 ACM Symposium on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992. </year> <month> 11 </month>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations [6, 8, 11, 14, 15, 26, 36]; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion <ref> [3, 4, 7, 22, 27, 32, 37, 40] </ref>. All of these methods vary in the precision of the aliasing information calculated and their cost. For compile-time pointer aliasing analysis, a program can be considered a sequence of assignments having effects on pointer aliasing; we call them pointer-related assignments. <p> Specifically, we use the flow-insensitive aliasing algorithm for pointer-related assignments involving recursive data structures in the program and a more precise, but more costly, flow-sensitive aliasing algorithm <ref> [22] </ref> for other pointer-related assignments. We are interested in determining which variables experience side effects indirectly through a pointer dereference (Thru-deref MOD) [23] and which values are fetched indirectly (Thru-deref REF). <p> Statements have IDs associated with them, where an ID is in the range of 1..(# of statements). Goto statements use statement IDs for their destinations. This representation can be depicted in a graphical form such as the interprocedural control flow graph (ICFG) <ref> [22] </ref>. Object Names In the intermediate representation, we refer to memory locations and addresses of these locations through object names. <p> 2 S, then (o 0 0 * If (o 1 ,o 2 ) 2 R, o 1 = apply (o 1 ,f ield) 2 S and o 0 apply (o 2 ,f ield) 2 S, then (o 0 0 This property is characteristic of relations such as the alias relation <ref> [22] </ref>. Suppose two object names are aliased. If both are of pointer type, their dereferences will be aliased; if both are of structure type, their corresponding fields will be aliased. Let S be the set f p, flp, p!g, &x, x, x.g g. <p> The decomposition technique, however, is generic in the sense that other aliasing analysis algorithms and other criteria can be used. For our experiment, we used two pointer aliasing analysis algorithms: one is Landi and Ryder's flow-sensitive algorithm <ref> [22] </ref> and another is the calculation of the partial FA relation (Section 4), which gives us safe flow-insensitive aliasing information.
Reference: [23] <author> William Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interpro--cedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of SIGPLAN'93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 56-67, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Specifically, we use the flow-insensitive aliasing algorithm for pointer-related assignments involving recursive data structures in the program and a more precise, but more costly, flow-sensitive aliasing algorithm [22] for other pointer-related assignments. We are interested in determining which variables experience side effects indirectly through a pointer dereference (Thru-deref MOD) <ref> [23] </ref> and which values are fetched indirectly (Thru-deref REF). Our initial empirical experiments show that the resulting analysis is faster than a completely flow-sensitive analysis, but demonstrates similar accuracy with respect to Thru-deref MOD/REF solutions. Thus, we have achieved acceptable precision at reasonable cost. <p> Second, we do not require these recursive data structures to involve only heap-directed pointers; they may involve pointers from or to stack locations. 5 loc here is the sum of loc and nv in <ref> [23] </ref>. 10 Theoretical classification of the compile-time pointer alias-ing problem supports, to some extent, the use of different analysis methods. The may aliasing problem is proved polynomial for single-level pointers [21] and NP-hard for multiple-level pointers [21, 25].
Reference: [24] <author> William Landi, Barbara G. Ryder, Sean Zhang, Phil Stocks, and Rita Altucher. </author> <title> Interprocedural modification side effect analysis for c programs. </title> <type> Technical report, </type> <institution> Laboratory for Computer Science Research, Rutgers University, </institution> <month> July </month> <year> 1996. </year> <note> In preparation. </note>
Reference-contexts: The problem is also proved P-space hard for finite-level ( 2) pointer dereferences [19] and undecidable for recursive data structures [20, 30]. The FA relation is similar to the points-to relation [37] and the PWA relation <ref> [2, 24] </ref>. The approach in [37] is based on a non-standard type inference technique; it handles type casting and indirect calls through function pointers, but does not allow structure types as in C. The approach in [2, 24] is to calculate a program-wide alias relation, which is reflexive, symmetric, transitive and <p> The FA relation is similar to the points-to relation [37] and the PWA relation <ref> [2, 24] </ref>. The approach in [37] is based on a non-standard type inference technique; it handles type casting and indirect calls through function pointers, but does not allow structure types as in C. The approach in [2, 24] is to calculate a program-wide alias relation, which is reflexive, symmetric, transitive and weakly right-regular. It handles programs with function pointers and type casting, but relies on type information for structure assignments.
Reference: [25] <author> J. R. Larus. </author> <title> Restructuring Symbolic Programs for Concurrent Execution on Multiprocessors. </title> <type> PhD thesis, </type> <institution> University of Cali-fornia Berkeley, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: The may aliasing problem is proved polynomial for single-level pointers [21] and NP-hard for multiple-level pointers <ref> [21, 25] </ref>. The problem is also proved P-space hard for finite-level ( 2) pointer dereferences [19] and undecidable for recursive data structures [20, 30]. The FA relation is similar to the points-to relation [37] and the PWA relation [2, 24].
Reference: [26] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Many techniques for compile-time pointer aliasing analysis have been proposed [3, 4, 6, 7, 8, 9, 11, 14, 15, 22, 26, 27, 32, 36, 37, 39, 40]. Some of them are more appropriate for aliases involving accesses to heap locations <ref> [6, 8, 11, 14, 15, 26, 36] </ref>; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion [3, 4, 7, 22, 27, 32, 37, 40]. All of these methods vary in the precision of the aliasing information calculated and their cost. <p> The idea of program decomposition for pointer aliasing analysis was motivated by the work on constructing call graphs for programs with calls through function pointers [2]. G FA for a program can be perceived as a storage shape graph <ref> [6, 26] </ref> although it may be quite approximate when there are recursive data structures. 7 Conclusions and Future Work We have presented a program decomposition technique for pointer aliasing analysis on well-typed C programs. We also provide an algorithm for calculating safe flow-insensitive aliasing solution for a program.
Reference: [27] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. D. Choi, M. G. Burke, and P. Carini. </author> <title> Pointer-induced aliasing: a clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9) </volume> <pages> 67-70, </pages> <year> 1993. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations [6, 8, 11, 14, 15, 26, 36]; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion <ref> [3, 4, 7, 22, 27, 32, 37, 40] </ref>. All of these methods vary in the precision of the aliasing information calculated and their cost. For compile-time pointer aliasing analysis, a program can be considered a sequence of assignments having effects on pointer aliasing; we call them pointer-related assignments.
Reference: [28] <author> T. J. Marlowe and B. G. Ryder. </author> <title> An efficient hybrid algorithm for incremental data flow analysis. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 184-196, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing [10, 12, 13, 18, 29, 31], semantic change analysis <ref> [5, 28, 33, 34, 35, 42, 43] </ref>, integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [29] <author> Thomas J. </author> <title> Ostrand. Data-flow testing with pointers and function calls. </title> <booktitle> In Proceedings of the Pacific Northwest Software Quality Conference, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing <ref> [10, 12, 13, 18, 29, 31] </ref>, semantic change analysis [5, 28, 33, 34, 35, 42, 43], integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [30] <author> G. Ramalingam. </author> <title> The undecidability of aliasing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1467-1471, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: The may aliasing problem is proved polynomial for single-level pointers [21] and NP-hard for multiple-level pointers [21, 25]. The problem is also proved P-space hard for finite-level ( 2) pointer dereferences [19] and undecidable for recursive data structures <ref> [20, 30] </ref>. The FA relation is similar to the points-to relation [37] and the PWA relation [2, 24]. The approach in [37] is based on a non-standard type inference technique; it handles type casting and indirect calls through function pointers, but does not allow structure types as in C.
Reference: [31] <author> S. Rapps and E. Weyuker. </author> <title> Selecting software test data using data flow information. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(4):367-375, </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing <ref> [10, 12, 13, 18, 29, 31] </ref>, semantic change analysis [5, 28, 33, 34, 35, 42, 43], integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [32] <author> Erik Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <month> june </month> <year> 1995. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations [6, 8, 11, 14, 15, 26, 36]; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion <ref> [3, 4, 7, 22, 27, 32, 37, 40] </ref>. All of these methods vary in the precision of the aliasing information calculated and their cost. For compile-time pointer aliasing analysis, a program can be considered a sequence of assignments having effects on pointer aliasing; we call them pointer-related assignments.
Reference: [33] <author> B. G. Ryder. </author> <title> Ismm: Incremental software maintenance manager. </title> <booktitle> In Proceedings of the IEEE Computer Society Conference on Software Maintenance, </booktitle> <pages> pages 142-164, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing [10, 12, 13, 18, 29, 31], semantic change analysis <ref> [5, 28, 33, 34, 35, 42, 43] </ref>, integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [34] <author> B. G. Ryder, W. Landi, and H. Pande. </author> <title> Profiling an incremental data flow analysis algorithm. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(2) </volume> <pages> 129-140, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing [10, 12, 13, 18, 29, 31], semantic change analysis <ref> [5, 28, 33, 34, 35, 42, 43] </ref>, integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [35] <author> B. G. Ryder and M. C. Paull. </author> <title> Incremental data flow analysis algorithms. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(1) </volume> <pages> 1-50, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing [10, 12, 13, 18, 29, 31], semantic change analysis <ref> [5, 28, 33, 34, 35, 42, 43] </ref>, integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [36] <author> Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> In Conference Record of te 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 16-31, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Many techniques for compile-time pointer aliasing analysis have been proposed [3, 4, 6, 7, 8, 9, 11, 14, 15, 22, 26, 27, 32, 36, 37, 39, 40]. Some of them are more appropriate for aliases involving accesses to heap locations <ref> [6, 8, 11, 14, 15, 26, 36] </ref>; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion [3, 4, 7, 22, 27, 32, 37, 40]. All of these methods vary in the precision of the aliasing information calculated and their cost.
Reference: [37] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Conference Record of te 23rd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations [6, 8, 11, 14, 15, 26, 36]; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion <ref> [3, 4, 7, 22, 27, 32, 37, 40] </ref>. All of these methods vary in the precision of the aliasing information calculated and their cost. For compile-time pointer aliasing analysis, a program can be considered a sequence of assignments having effects on pointer aliasing; we call them pointer-related assignments. <p> The may aliasing problem is proved polynomial for single-level pointers [21] and NP-hard for multiple-level pointers [21, 25]. The problem is also proved P-space hard for finite-level ( 2) pointer dereferences [19] and undecidable for recursive data structures [20, 30]. The FA relation is similar to the points-to relation <ref> [37] </ref> and the PWA relation [2, 24]. The approach in [37] is based on a non-standard type inference technique; it handles type casting and indirect calls through function pointers, but does not allow structure types as in C. <p> The problem is also proved P-space hard for finite-level ( 2) pointer dereferences [19] and undecidable for recursive data structures [20, 30]. The FA relation is similar to the points-to relation <ref> [37] </ref> and the PWA relation [2, 24]. The approach in [37] is based on a non-standard type inference technique; it handles type casting and indirect calls through function pointers, but does not allow structure types as in C. The approach in [2, 24] is to calculate a program-wide alias relation, which is reflexive, symmetric, transitive and weakly right-regular.
Reference: [38] <author> Robert E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <year> 1983. </year>
Reference-contexts: The cost of each call to INIT-EQUIV-CLASS () is a small constant; the cost of N calls to FIND () or UNION () is almost linear in N if a fast union/find algorithm is used <ref> [38] </ref>. Given a program and its B 0 set, the algorithm for calculating the PE relation is given in Figure 7. The algorithm has two phases. In Phase 1, an equivalence class is created for each object name in B 0 . <p> Therefore there are no more than N 0 calls to MERGE () and the number of calls to FIND () will be O (N 0 ). If we use a fast union/find algorithm such as the one in <ref> [38] </ref>, the cost of all calls to UNION () and FIND () in Phase 2 is O (N 0 fi ff (N 0 ,N 0 )), where ff is the inverse of the Acker-mann's function; the cost of calls to MERGE () is (O (N 0 fi ff (N 0 ,N
Reference: [39] <author> W. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <booktitle> In Conference Record of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> Jan. </month> <year> 1980. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations [6, 8, 11, 14, 15, 26, 36]; others for aliases involving accesses to stack locations <ref> [9, 39] </ref>. Still others handle both in a similar fashion [3, 4, 7, 22, 27, 32, 37, 40]. All of these methods vary in the precision of the aliasing information calculated and their cost.
Reference: [40] <author> Robert Wilson and Monica Lam. </author> <title> Efficient context-sensitive pointer analysis for c programs. </title> <booktitle> In Proceedings of SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> june </month> <year> 1995. </year>
Reference-contexts: Some of them are more appropriate for aliases involving accesses to heap locations [6, 8, 11, 14, 15, 26, 36]; others for aliases involving accesses to stack locations [9, 39]. Still others handle both in a similar fashion <ref> [3, 4, 7, 22, 27, 32, 37, 40] </ref>. All of these methods vary in the precision of the aliasing information calculated and their cost. For compile-time pointer aliasing analysis, a program can be considered a sequence of assignments having effects on pointer aliasing; we call them pointer-related assignments.
Reference: [41] <author> W. Yang, S. Horwitz, and T. Reps. </author> <title> A program integration algorithm that accomodates semantics preserving transformations. </title> <booktitle> In Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 133-143, </pages> <month> December </month> <year> 1990. </year> <note> also available as SIGSOFT Notes, vol 15, no 6, </note> <month> December </month> <year> 1990. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing [10, 12, 13, 18, 29, 31], semantic change analysis [5, 28, 33, 34, 35, 42, 43], integration of program versions <ref> [16, 17, 41] </ref> and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used). In languages with general-purpose pointer usage, two names may access the same location during execution; they are called aliases.
Reference: [42] <author> J. Yur and B.G. Ryder. </author> <title> Incremental anlaysis of the mod problem for c. </title> <institution> Laboratory for Computer Science Research Technical Report LCSR-TR-254, Department of Computer Science, Rutgers University, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing [10, 12, 13, 18, 29, 31], semantic change analysis <ref> [5, 28, 33, 34, 35, 42, 43] </ref>, integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [43] <author> F. K. Zadeck. </author> <title> Incremental data flow analysis in a structured program editor. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 132-143, </pages> <month> June </month> <year> 1984. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 19, No 6. </volume>
Reference-contexts: Compile-time analysis provides potentially useful information which can be utilized to insure the safety of program optimizations and transformations. Analysis information is also essential for data-flow-based testing [10, 12, 13, 18, 29, 31], semantic change analysis <ref> [5, 28, 33, 34, 35, 42, 43] </ref>, integration of program versions [16, 17, 41] and various other optimizations, such as run-time check elision [1] (e.g., verifying that variables are initialized before they are used).
Reference: [44] <author> Sean Zhang, Barbara G. Ryder, and William Landi. </author> <title> Program decomposition for pointer-induced aliasing analysis. </title> <type> Technical report, </type> <institution> Laboratory for Computer Science Research, Rutgers University, </institution> <month> July </month> <year> 1996. </year> <note> In preparation. An early report of the work is in LCSR-TR-259. 12 </note>
Reference-contexts: Intuitively, a tuple (o 0 0 2 ) is in the FA relation if the two object names are aliased, assuming pointer-related assignments are considered symmetric and the control flow in the program is not taken into account. We prove in <ref> [44] </ref> that the FA relation defined above is weakly right-regular. <p> For instance, for the example program in Figure 4, the FA relation can be partitioned into two subrelations. We prove in <ref> [44] </ref> that the FA relation for a program contains the run-time aliases at any program point on an execution path of the program. <p> We call the graph G FA . In Figure 9, we show G FA for the example program in Figure 4. We prove in <ref> [44] </ref> that G FA satisfies conditions (1), (2) and (3) proposed earlier; that is, G FA represents the FA relation. As defined, the FA relation can be partitioned according to weakly connected components of G PE .
References-found: 44

