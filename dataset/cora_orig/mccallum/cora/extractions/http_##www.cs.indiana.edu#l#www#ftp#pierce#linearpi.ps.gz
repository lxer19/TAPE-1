URL: http://www.cs.indiana.edu/l/www/ftp/pierce/linearpi.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Title: Linearity and the Pi-Calculus  
Author: Naoki Kobayashi Benjamin C. Pierce David N. Turner 
Date: July 18, 1995  
Address: Cambridge  
Affiliation: University of Tokyo  University of  University of Glasgow  
Abstract: A static type system with "use-once" channel types, inspired by linear logic, is applied to a pure calculus of processes and message passing. Applications of this type system include static detection of errors in concurrent programs, compiler optimizations, and more natural program equivalences. After developing standard results such as soundness of typing, we focus on equivalences, adapting the standard notion of barbed bisimulation to the linear setting and showing how reductions on linear channels induce a useful "partial confluence" of process behaviors.
Abstract-found: 1
Intro-found: 1
Reference: [Abr93] <author> Samson Abramsky. </author> <title> Computational interpretations of linear logic. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 111(1-2):3-57, </address> <month> April 12 </month> <year> 1993. </year>
Reference-contexts: 1 ); : : : ; x n :Rem (T n ). 3 Typing The technical intuitions underlying linear channel types are based on Girard's linear logic [Gir87, GLT89], a "resource conscious" refinement of classical logic, and on numerous proposals for functional and logic-programming languages based on linear logic (e.g. <ref> [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95] </ref>). A crucial element in all of these systems is the careful treatment of the typing environments under which expressions are judged to be well typed. <p> (plusone![j; r 1 ] j r 1 ?[k]: (plusone![k; r 2 ] j r 2 ?[l]: s![l])) plustwo? fl [j; s]: (-r:l 1 [Num]) (plusone![j; r] j r?[k]: plusone![k; s]): 6 Related Work Our type system shares a great deal with linear type systems for lambda-calculi and related programming languages <ref> [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95] </ref>. The main differences here are the extra technicalities of dealing with linear channels (which essentially comprise two linear capabilities), and our results about behavioral equivalences. 12 In the world of process calculi, there have been several papers on analyzing channel usage using effect systems.
Reference: [Agh86] <author> Gul A. Agha. </author> <title> Actors: a Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: 1 Introduction A long line of formal systems, from Hewitt's Actors <ref> [Hew77, Agh86] </ref> to modern process calculi such as Milner, Parrow, and Walker's pi-calculus [MPW92, Mil91], have popularized the idea that a wide range of concurrent programming idioms can be modeled by simple processes exchanging messages on channels.
Reference: [Bak92] <author> Henry G. Baker. </author> <title> Lively linear lisp look ma, </title> <journal> no garbage! ACM Sigplan Notices, </journal> <volume> 27(8) </volume> <pages> 89-98, </pages> <year> 1992. </year>
Reference-contexts: 1 ); : : : ; x n :Rem (T n ). 3 Typing The technical intuitions underlying linear channel types are based on Girard's linear logic [Gir87, GLT89], a "resource conscious" refinement of classical logic, and on numerous proposals for functional and logic-programming languages based on linear logic (e.g. <ref> [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95] </ref>). A crucial element in all of these systems is the careful treatment of the typing environments under which expressions are judged to be well typed. <p> (plusone![j; r 1 ] j r 1 ?[k]: (plusone![k; r 2 ] j r 2 ?[l]: s![l])) plustwo? fl [j; s]: (-r:l 1 [Num]) (plusone![j; r] j r?[k]: plusone![k; s]): 6 Related Work Our type system shares a great deal with linear type systems for lambda-calculi and related programming languages <ref> [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95] </ref>. The main differences here are the extra technicalities of dealing with linear channels (which essentially comprise two linear capabilities), and our results about behavioral equivalences. 12 In the world of process calculi, there have been several papers on analyzing channel usage using effect systems.
Reference: [Car86] <author> Luca Cardelli. </author> <title> Amber. </title> <editor> In Guy Cousineau, Pierre-Louis Curien, and Bernard Robi-net, editors, </editor> <booktitle> Combinators and Functional Programming Languages, </booktitle> <pages> pages 21-47. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> Lecture Notes in Computer Science No. 242. </note>
Reference-contexts: Besides the applications of such calculi in specification and verification of concurrent systems, they have been used as the basis for concurrency features in numerous programming languages (e.g. <ref> [Car86, GMP89, Rep91] </ref>), as foundations for theoretical study of language features like concurrent objects (e.g. [Jon93, Wal95, HT91, Vas94]), and more recently as core programming languages in their own right [PT95a, PT95b].
Reference: [dB72] <author> Nicolas G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year> <month> 13 </month>
Reference-contexts: This view (which amounts to regarding named variables as shorthand for an underlying "deBruijn-indexed" calculus <ref> [dB72] </ref>) requires some notational work to maintain, but helps avoid confusion.
Reference: [Gay93] <author> Simon J. Gay. </author> <title> A sort inference algorithm for the polyadic -calculus. </title> <booktitle> In Proceed--ings of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: This type system can be extended in many ways, for instance by adding polymorphism <ref> [Gay93, VH93, Tur95] </ref>. Of more interest here, however, is the possibility of refining it so that the types of channels carry more information about how they are used.
Reference: [Gir87] <author> Jean-Yves Girard. </author> <title> Linear logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 50 </volume> <pages> 1-102, </pages> <year> 1987. </year>
Reference-contexts: x 1 :T 1 ; : : : ; x n :T n of its bindings by their remnants x 1 :Rem (T 1 ); : : : ; x n :Rem (T n ). 3 Typing The technical intuitions underlying linear channel types are based on Girard's linear logic <ref> [Gir87, GLT89] </ref>, a "resource conscious" refinement of classical logic, and on numerous proposals for functional and logic-programming languages based on linear logic (e.g. [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95]).
Reference: [GLT89] <author> Jean-Yves Girard, Yves Lafont, and Paul Taylor. </author> <title> Proofs and Types, </title> <booktitle> volume 7 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1989. </year>
Reference-contexts: x 1 :T 1 ; : : : ; x n :T n of its bindings by their remnants x 1 :Rem (T 1 ); : : : ; x n :Rem (T n ). 3 Typing The technical intuitions underlying linear channel types are based on Girard's linear logic <ref> [Gir87, GLT89] </ref>, a "resource conscious" refinement of classical logic, and on numerous proposals for functional and logic-programming languages based on linear logic (e.g. [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95]).
Reference: [GMP89] <author> Alessandro Giacalone, Prateek Mishra, and Sanjiva Prasad. </author> <title> Facile: A Symmetric Integration of Concurrent and Functional Programming. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 18(2) </volume> <pages> 121-160, </pages> <year> 1989. </year>
Reference-contexts: Besides the applications of such calculi in specification and verification of concurrent systems, they have been used as the basis for concurrency features in numerous programming languages (e.g. <ref> [Car86, GMP89, Rep91] </ref>), as foundations for theoretical study of language features like concurrent objects (e.g. [Jon93, Wal95, HT91, Vas94]), and more recently as core programming languages in their own right [PT95a, PT95b].
Reference: [Hew77] <author> C. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Artificial Intelligence, </journal> <volume> 8 </volume> <pages> 323-364, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction A long line of formal systems, from Hewitt's Actors <ref> [Hew77, Agh86] </ref> to modern process calculi such as Milner, Parrow, and Walker's pi-calculus [MPW92, Mil91], have popularized the idea that a wide range of concurrent programming idioms can be modeled by simple processes exchanging messages on channels.
Reference: [Hod92] <author> J. S. Hodas. </author> <title> Lolli: An extension of Prolog with linear context management. </title> <editor> In D. Miller, editor, </editor> <booktitle> Workshop on the Prolog Programming Language, </booktitle> <pages> pages 159-168, </pages> <address> Philadelphia, Pennsylvania, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: 1 ); : : : ; x n :Rem (T n ). 3 Typing The technical intuitions underlying linear channel types are based on Girard's linear logic [Gir87, GLT89], a "resource conscious" refinement of classical logic, and on numerous proposals for functional and logic-programming languages based on linear logic (e.g. <ref> [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95] </ref>). A crucial element in all of these systems is the careful treatment of the typing environments under which expressions are judged to be well typed. <p> (plusone![j; r 1 ] j r 1 ?[k]: (plusone![k; r 2 ] j r 2 ?[l]: s![l])) plustwo? fl [j; s]: (-r:l 1 [Num]) (plusone![j; r] j r?[k]: plusone![k; s]): 6 Related Work Our type system shares a great deal with linear type systems for lambda-calculi and related programming languages <ref> [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95] </ref>. The main differences here are the extra technicalities of dealing with linear channels (which essentially comprise two linear capabilities), and our results about behavioral equivalences. 12 In the world of process calculi, there have been several papers on analyzing channel usage using effect systems.
Reference: [HT91] <author> Kohei Honda and Mario Tokoro. </author> <title> An object calculus for asynchronous communication. </title> <editor> In Pierre America, editor, </editor> <booktitle> Proceedings of the European Conference on Object-Oriented Programming (ECOOP), volume 512 of Lecture Notes in Computer Science, </booktitle> <address> Geneva CH, 1991. </address> <publisher> Springer-Verlag , Berlin, </publisher> <address> Heidelberg, New York, Tokyo. </address>
Reference-contexts: Besides the applications of such calculi in specification and verification of concurrent systems, they have been used as the basis for concurrency features in numerous programming languages (e.g. [Car86, GMP89, Rep91]), as foundations for theoretical study of language features like concurrent objects (e.g. <ref> [Jon93, Wal95, HT91, Vas94] </ref>), and more recently as core programming languages in their own right [PT95a, PT95b]. The encoding of functions as processes in the pi-calculus (cf. [Mil90]) illustrates the "feel" of a pure message-passing calculus. <p> the polyadic pi-calculus [Mil91] lacking the choice and matching operators (like Milner's mini pi-calculus [Mil90]) and in which communication is asynchronous in the sense that an output expression is a bare message with no "body" to be executed after the message has been sent (as in Honda and Tokoro's --calculus <ref> [HT91] </ref>).
Reference: [Jon93] <author> Cliff B. Jones. </author> <title> A pi-calculus semantics for an object-based design notation. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings of CONCUR'93, </booktitle> <volume> LNCS 715, </volume> <pages> pages 158-172. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Besides the applications of such calculi in specification and verification of concurrent systems, they have been used as the basis for concurrency features in numerous programming languages (e.g. [Car86, GMP89, Rep91]), as foundations for theoretical study of language features like concurrent objects (e.g. <ref> [Jon93, Wal95, HT91, Vas94] </ref>), and more recently as core programming languages in their own right [PT95a, PT95b]. The encoding of functions as processes in the pi-calculus (cf. [Mil90]) illustrates the "feel" of a pure message-passing calculus.
Reference: [KNY95] <author> Naoki Kobayashi, Motoki Nakade, and Akinori Yonezawa. </author> <title> Static analysis of communication for asynchrnous concurrent programming languages. </title> <booktitle> to appear in Proceedings of International Static Analysis Symposium, </booktitle> <publisher> Springer LNCS, </publisher> <year> 1995. </year>
Reference-contexts: Nielson and Nielson [NN94] proposed a method for inferring the maximum usages of channels, while Kobayashi, Nakade, and Yonezawa <ref> [KNY95] </ref> proposed a method for approximating how many receivers can try to read from a channel at the same time, which in particular can be used to detect channels whose maximum queue length is 1. Our type-based analysis and these effect-based analysis both seem to have advantages and disadvantages.
Reference: [LW95] <author> Xinxin Liu and David Walker. </author> <title> Confluence of processes and systems of objects. </title> <booktitle> In Proceedings of CAAP'95, </booktitle> <pages> pages 217-231. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: The same problem has also been tackled by Liu and Walker, using purely semantic techniques <ref> [LW95] </ref>. The immediate spur for our work came from a paper by Takeuchi, Honda, and Kubo [THK94] describing a modified pi-calculus whose syntax guarantees that certain channels can only be shared between two processes.
Reference: [Mac94] <author> Ian Mackie. </author> <title> Lilac: A functional programming language based on linear logic. </title> <journal> JFP, </journal> <volume> 4(4) </volume> <pages> 395-433, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: 1 ); : : : ; x n :Rem (T n ). 3 Typing The technical intuitions underlying linear channel types are based on Girard's linear logic [Gir87, GLT89], a "resource conscious" refinement of classical logic, and on numerous proposals for functional and logic-programming languages based on linear logic (e.g. <ref> [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95] </ref>). A crucial element in all of these systems is the careful treatment of the typing environments under which expressions are judged to be well typed. <p> (plusone![j; r 1 ] j r 1 ?[k]: (plusone![k; r 2 ] j r 2 ?[l]: s![l])) plustwo? fl [j; s]: (-r:l 1 [Num]) (plusone![j; r] j r?[k]: plusone![k; s]): 6 Related Work Our type system shares a great deal with linear type systems for lambda-calculi and related programming languages <ref> [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95] </ref>. The main differences here are the extra technicalities of dealing with linear channels (which essentially comprise two linear capabilities), and our results about behavioral equivalences. 12 In the world of process calculi, there have been several papers on analyzing channel usage using effect systems.
Reference: [Mil90] <author> Robin Milner. </author> <title> Functions as processes. </title> <type> Research Report 1154, </type> <institution> INRIA, Sofia Antipolis, </institution> <year> 1990. </year> <note> Final version in Journal of Mathematical Structures in Computer Science 2(2) 119-141, </note> <year> 1992. </year>
Reference-contexts: The encoding of functions as processes in the pi-calculus (cf. <ref> [Mil90] </ref>) illustrates the "feel" of a pure message-passing calculus. <p> This refinement is not only useful for preventing programming mistakes; it also yields more powerful techniques for reasoning about programs. For example, in an early version of <ref> [Mil90] </ref>, 2 Milner had proposed two encodings of the call-by-value lambda-calculus into the pi-calculus. Unfortunately, the simpler of the two encodings turned out not to preserve beta-equivalence. <p> Section 6 discussed related work. We omit proofs in this summary. 2 Notational Preliminaries The operators introduced in the examples above constitute a fragment of the polyadic pi-calculus [Mil91] lacking the choice and matching operators (like Milner's mini pi-calculus <ref> [Mil90] </ref>) and in which communication is asynchronous in the sense that an output expression is a bare message with no "body" to be executed after the message has been sent (as in Honda and Tokoro's --calculus [HT91]).
Reference: [Mil91] <author> Robin Milner. </author> <title> The polyadic -calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh, UK, </institution> <month> October </month> <year> 1991. </year> <booktitle> Proceedings of the International Summer School on Logic and Algebra of Specification, Marktoberdorf, </booktitle> <month> August </month> <year> 1991. </year> <title> Reprinted in Logic and Algebra of Specification, </title> <editor> ed. F. L. Bauer, W. Brauer, and H. Schwichtenberg, </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 14 </month>
Reference-contexts: 1 Introduction A long line of formal systems, from Hewitt's Actors [Hew77, Agh86] to modern process calculi such as Milner, Parrow, and Walker's pi-calculus <ref> [MPW92, Mil91] </ref>, have popularized the idea that a wide range of concurrent programming idioms can be modeled by simple processes exchanging messages on channels. <p> A more radical approach | the one we are exploring here | is to program in the pure pi-calculus and recover information about special "modes of usage" by static typing. The simplest type systems for the pi-calculus <ref> [Mil91] </ref> just track the arities of channels, so as to prevent situations where the tuple of arguments provided by a sender is not the same width as the tuple of bound variables in the receiver, as in x![y; z] j x?[a; b; c]: P . <p> In Section 5, we adapt the standard notion of barbed congruence to the present setting. Section 6 discussed related work. We omit proofs in this summary. 2 Notational Preliminaries The operators introduced in the examples above constitute a fragment of the polyadic pi-calculus <ref> [Mil91] </ref> lacking the choice and matching operators (like Milner's mini pi-calculus [Mil90]) and in which communication is asynchronous in the sense that an output expression is a bare message with no "body" to be executed after the message has been sent (as in Honda and Tokoro's --calculus [HT91]). <p> Instead of "guessing" how to split the capabilities in the environment in rules like E-Par, we pass the whole environment to the lefthand premise, "crossing off" capabilities as they are used up and passing whatever is left to the right-hand premise. 7 4 Operational Semantics Following <ref> [Mil91] </ref>, the operational semantics of processes is presented in two steps. First, we define a structural congruence relation P Q, capturing the fact that, for example, the order of the branches in a parallel composition has no effect on its behavior.
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes (Parts I and II). </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction A long line of formal systems, from Hewitt's Actors [Hew77, Agh86] to modern process calculi such as Milner, Parrow, and Walker's pi-calculus <ref> [MPW92, Mil91] </ref>, have popularized the idea that a wide range of concurrent programming idioms can be modeled by simple processes exchanging messages on channels.
Reference: [MS92] <author> R. Milner and D. Sangiorgi. </author> <title> Barbed bisimulation. </title> <editor> In W. Kuich, editor, </editor> <booktitle> 19th ICALP, volume 623 of Lecture Notes in Computer Science, </booktitle> <pages> pages 685-695. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Moreover, ` P 1;x ! R. 5 Bisimilarity Our last job is to formalize process equivalence in the presence of linear types, so that we can check that equivalences like those claimed in the introduction really hold. We adapt Milner and Sangiorgi's notion of barbed bisimilulation <ref> [MS92, San92] </ref>, which we find suited to the job for several reasons. First, it is naturally a relation on typed processes, which is crucial here.
Reference: [NN94] <author> Hanne Riis Nielson and Flemming Nielson. </author> <title> Higher-order concurrent programs with finite communication topology. </title> <booktitle> In Proceedings of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Portland, Oregon, </booktitle> <pages> pages 84-97, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: The main differences here are the extra technicalities of dealing with linear channels (which essentially comprise two linear capabilities), and our results about behavioral equivalences. 12 In the world of process calculi, there have been several papers on analyzing channel usage using effect systems. Nielson and Nielson <ref> [NN94] </ref> proposed a method for inferring the maximum usages of channels, while Kobayashi, Nakade, and Yonezawa [KNY95] proposed a method for approximating how many receivers can try to read from a channel at the same time, which in particular can be used to detect channels whose maximum queue length is 1.
Reference: [NS95] <author> Uwe Nestmann and Martin Steffen. </author> <title> Typing confluence, </title> <month> July </month> <year> 1995. </year> <type> Draft technical report. </type>
Reference-contexts: Although Kobayashi et al. tried to overcome this defect to some degree, the resulting analysis is difficult, and some algorithmic aspects (especially time complexity) are left open. Finally, a type system reminiscent of ours, though not explicitly incorporating the notion of linearity, has been developed by Nestmann and Steffen <ref> [NS95] </ref> for the purpose of analyzing confluence in pi-calculus processes arising in the semantics of concurrent object-oriented programs. The same problem has also been tackled by Liu and Walker, using purely semantic techniques [LW95].
Reference: [Ode95] <author> Martin Odersky. </author> <title> Polarized name passing. </title> <type> Draft technical report, </type> <year> 1995. </year>
Reference-contexts: context) can only be used to send tuples of type [T 1 ; : : : ; T n ], and #[T 1 ; : : : ; T n ] for channels that can only be used to receive [T 1 ; : : : ; T n ]-tuples <ref> [PS95, Ode95] </ref>.
Reference: [PS95] <author> Benjamin Pierce and Davide Sangiorgi. </author> <title> Typing and subtyping for mobile processes. </title> <note> Mathematical Structures in Computer Science, 1995. To appear. A summary was presented at LICS '93. </note>
Reference-contexts: context) can only be used to send tuples of type [T 1 ; : : : ; T n ], and #[T 1 ; : : : ; T n ] for channels that can only be used to receive [T 1 ; : : : ; T n ]-tuples <ref> [PS95, Ode95] </ref>. <p> Pierce and Sangiorgi <ref> [PS95] </ref> showed how the validity of beta-equivalence could be established by typing the encoding using input-only and output-only channels. In essence, refining the type system reduces the number of contexts in which a given process can correctly be placed, thus making it easier for two processes to be equivalent.
Reference: [PT95a] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Concurrent objects in a process calculus. </title> <editor> In Takayasu Ito and Akinori Yonezawa, editors, </editor> <booktitle> Theory and Practice of Parallel Programming (TPPP), Sendai, </booktitle> <address> Japan (Nov. </address> <year> 1994), </year> <booktitle> number 907 in Lecture Notes in Computer Science, </booktitle> <pages> pages 187-215. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1995. </year>
Reference-contexts: and verification of concurrent systems, they have been used as the basis for concurrency features in numerous programming languages (e.g. [Car86, GMP89, Rep91]), as foundations for theoretical study of language features like concurrent objects (e.g. [Jon93, Wal95, HT91, Vas94]), and more recently as core programming languages in their own right <ref> [PT95a, PT95b] </ref>. The encoding of functions as processes in the pi-calculus (cf. [Mil90]) illustrates the "feel" of a pure message-passing calculus. <p> Work is underway on exploring these optimizations in a compiler for a linear variant of the Pict programming language <ref> [PT95a, PT95b] </ref>. Linear channel types can also help detect programming mistakes. <p> We have argued elsewhere for the pragmatic virtues of this calculus <ref> [PT95a] </ref>, but the techniques we develop should be applicable to any similar system. (The details of the behavioral properties will vary with the choice of calculus, of course.) We also provide booleans and conditional expressions as primitives, since their typing behavior interacts with linearity information in a slightly special way. 4
Reference: [PT95b] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Pict: A programming language based on the pi-calculus. </title> <note> Technical report in preparation; available electronically, </note> <year> 1995. </year>
Reference-contexts: and verification of concurrent systems, they have been used as the basis for concurrency features in numerous programming languages (e.g. [Car86, GMP89, Rep91]), as foundations for theoretical study of language features like concurrent objects (e.g. [Jon93, Wal95, HT91, Vas94]), and more recently as core programming languages in their own right <ref> [PT95a, PT95b] </ref>. The encoding of functions as processes in the pi-calculus (cf. [Mil90]) illustrates the "feel" of a pure message-passing calculus. <p> Work is underway on exploring these optimizations in a compiler for a linear variant of the Pict programming language <ref> [PT95a, PT95b] </ref>. Linear channel types can also help detect programming mistakes.
Reference: [Rep91] <author> John Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In Programming Language Design and Implementation, </booktitle> <pages> pages 293-259. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Besides the applications of such calculi in specification and verification of concurrent systems, they have been used as the basis for concurrency features in numerous programming languages (e.g. <ref> [Car86, GMP89, Rep91] </ref>), as foundations for theoretical study of language features like concurrent objects (e.g. [Jon93, Wal95, HT91, Vas94]), and more recently as core programming languages in their own right [PT95a, PT95b].
Reference: [San92] <author> Davide Sangiorgi. </author> <title> Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Ed-inburgh, </institution> <year> 1992. </year>
Reference-contexts: Moreover, ` P 1;x ! R. 5 Bisimilarity Our last job is to formalize process equivalence in the presence of linear types, so that we can check that equivalences like those claimed in the introduction really hold. We adapt Milner and Sangiorgi's notion of barbed bisimilulation <ref> [MS92, San92] </ref>, which we find suited to the job for several reasons. First, it is naturally a relation on typed processes, which is crucial here.
Reference: [THK94] <author> Kaku Takeuchi, Kohei Honda, and Makoto Kubo. </author> <title> An interaction-based language and its typing system. </title> <booktitle> In Proceedings of PARLE'94, </booktitle> <pages> pages 398-413. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <booktitle> Lecture Notes in Computer Science number 817. </booktitle>
Reference-contexts: The same problem has also been tackled by Liu and Walker, using purely semantic techniques [LW95]. The immediate spur for our work came from a paper by Takeuchi, Honda, and Kubo <ref> [THK94] </ref> describing a modified pi-calculus whose syntax guarantees that certain channels can only be shared between two processes. This suggested that one might try to achieve the same effect in a standard pi-calculus by refining the type system. Acknowledgements Pierce is supported by the EPSRC.
Reference: [Tur95] <author> David N. Turner. </author> <title> The -calulus: Types, polymorphism and implementation, 1995. </title> <type> Ph.D. thesis, </type> <institution> LFCS, University of Edinburgh. </institution> <note> In preparation. </note>
Reference-contexts: This type system can be extended in many ways, for instance by adding polymorphism <ref> [Gay93, VH93, Tur95] </ref>. Of more interest here, however, is the possibility of refining it so that the types of channels carry more information about how they are used.
Reference: [TWM95] <author> David N Turner, Philip Wadler, and Christian Mossin. </author> <title> Once upon a type. </title> <booktitle> In FPCA, </booktitle> <address> San Diego, California, </address> <year> 1995. </year>
Reference-contexts: 1 ); : : : ; x n :Rem (T n ). 3 Typing The technical intuitions underlying linear channel types are based on Girard's linear logic [Gir87, GLT89], a "resource conscious" refinement of classical logic, and on numerous proposals for functional and logic-programming languages based on linear logic (e.g. <ref> [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95] </ref>). A crucial element in all of these systems is the careful treatment of the typing environments under which expressions are judged to be well typed. <p> (plusone![j; r 1 ] j r 1 ?[k]: (plusone![k; r 2 ] j r 2 ?[l]: s![l])) plustwo? fl [j; s]: (-r:l 1 [Num]) (plusone![j; r] j r?[k]: plusone![k; s]): 6 Related Work Our type system shares a great deal with linear type systems for lambda-calculi and related programming languages <ref> [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95] </ref>. The main differences here are the extra technicalities of dealing with linear channels (which essentially comprise two linear capabilities), and our results about behavioral equivalences. 12 In the world of process calculi, there have been several papers on analyzing channel usage using effect systems.
Reference: [Vas94] <author> Vasco T. Vasconcelos. </author> <title> Typed concurrent objects. </title> <booktitle> In Proceedings of the Eighth Euro-pean Conference on Object-Oriented Programming (ECOOP), volume 821 of Lecture Notes in Computer Science, </booktitle> <pages> pages 100-117. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1994. </year>
Reference-contexts: Besides the applications of such calculi in specification and verification of concurrent systems, they have been used as the basis for concurrency features in numerous programming languages (e.g. [Car86, GMP89, Rep91]), as foundations for theoretical study of language features like concurrent objects (e.g. <ref> [Jon93, Wal95, HT91, Vas94] </ref>), and more recently as core programming languages in their own right [PT95a, PT95b]. The encoding of functions as processes in the pi-calculus (cf. [Mil90]) illustrates the "feel" of a pure message-passing calculus.
Reference: [VH93] <author> Vasco T. Vasconcelos and Kohei Honda. </author> <title> Principal typing schemes in a polyadic pi-calculus. </title> <booktitle> In Proceedings of CONCUR '93, </booktitle> <month> July </month> <year> 1993. </year> <note> Also available as Keio University Report CS-92-004. 15 </note>
Reference-contexts: This type system can be extended in many ways, for instance by adding polymorphism <ref> [Gay93, VH93, Tur95] </ref>. Of more interest here, however, is the possibility of refining it so that the types of channels carry more information about how they are used.
Reference: [Wad91] <editor> Philip Wadler. </editor> <booktitle> Is there a use for linear logic? In Proceedings of ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 255-273, </pages> <year> 1991. </year>
Reference-contexts: 1 ); : : : ; x n :Rem (T n ). 3 Typing The technical intuitions underlying linear channel types are based on Girard's linear logic [Gir87, GLT89], a "resource conscious" refinement of classical logic, and on numerous proposals for functional and logic-programming languages based on linear logic (e.g. <ref> [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95] </ref>). A crucial element in all of these systems is the careful treatment of the typing environments under which expressions are judged to be well typed. <p> (plusone![j; r 1 ] j r 1 ?[k]: (plusone![k; r 2 ] j r 2 ?[l]: s![l])) plustwo? fl [j; s]: (-r:l 1 [Num]) (plusone![j; r] j r?[k]: plusone![k; s]): 6 Related Work Our type system shares a great deal with linear type systems for lambda-calculi and related programming languages <ref> [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95] </ref>. The main differences here are the extra technicalities of dealing with linear channels (which essentially comprise two linear capabilities), and our results about behavioral equivalences. 12 In the world of process calculi, there have been several papers on analyzing channel usage using effect systems.
Reference: [Wal95] <author> David Walker. </author> <title> Objects in the -calculus. </title> <journal> Information and Computation, </journal> <volume> 116 </volume> <pages> 253-271, </pages> <year> 1995. </year>
Reference-contexts: Besides the applications of such calculi in specification and verification of concurrent systems, they have been used as the basis for concurrency features in numerous programming languages (e.g. [Car86, GMP89, Rep91]), as foundations for theoretical study of language features like concurrent objects (e.g. <ref> [Jon93, Wal95, HT91, Vas94] </ref>), and more recently as core programming languages in their own right [PT95a, PT95b]. The encoding of functions as processes in the pi-calculus (cf. [Mil90]) illustrates the "feel" of a pure message-passing calculus.
References-found: 35

