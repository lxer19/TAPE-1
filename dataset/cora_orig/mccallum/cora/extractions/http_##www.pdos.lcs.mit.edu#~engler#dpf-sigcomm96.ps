URL: http://www.pdos.lcs.mit.edu/~engler/dpf-sigcomm96.ps
Refering-URL: http://www.pdos.lcs.mit.edu/~engler/dpf.html
Root-URL: 
Email: fengler,kaashoekg@lcs.mit.edu  
Title: DPF: Fast, Flexible Message Demultiplexing using Dynamic Code Generation  
Author: Dawson R. Engler, and M. Frans Kaashoek 
Address: Cambridge, MA 02139, U.S.A.  
Affiliation: M.I.T. Laboratory for Computer Science  
Abstract: Fast and flexible message demultiplexing are well-established goals in the networking community [1, 18, 22]. Currently, however, network architects have had to sacrifice one for the other. We present a new packet-filter system, DPF (Dynamic Packet Filters), that provides both the traditional flexibility of packet filters [18] and the speed of hand-crafted demultiplexing routines [3]. DPF filters run 10-50 times faster than the fastest packet filters reported in the literature [1, 17, 18, 27]. DPF's performance is either equivalent to or, when it can exploit runtime information, superior to hand-coded demultiplexors. DPF achieves high performance by using a carefully-designed declarative packet-filter language that is aggressively optimized using dynamic code generation. The contributions of this work are: (1) a detailed description of the DPF design, (2) discussion of the use of dynamic code generation and quantitative results on its performance impact, (3) quantitative results on how DPF is used in the Aegis kernel to export network devices safely and securely to user space so that UDP and TCP can be implemented efficiently as user-level libraries, and (4) the unrestricted release of DPF into the public domain. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. L. Bailey, B. Gopal, M. A. Pagels, L. L. Peterson, and P. Sarkar. PATHFINDER: </author> <title> A pattern-based packet classifier. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 115-123, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Rapid demultiplexing is important in order to neither waste processing cycles nor add latency to end-to-end message time <ref> [1] </ref>. Application-specific demultiplexing is important so that applications can explore new protocols without kernel modification [18]. Previously, networking architects have had to trade flexibility for performance to demultiplex messages efficiently. For example, the packet-filter model [18] is flexible, but its cost has precluded its use in high-performance networking systems. <p> DPF filters run 13-26 times faster than PATHFINDER filters, the fastest numbers This work was supported in part by the Advanced Research Projects Agency under contract N00014-94-1-0985 and by a NSF National Young Investigator Award. reported in the literature <ref> [1, 17, 18, 27] </ref>. DPF's performance is equivalent to, and in some situations can even exceed, the performance of hand-coded demultiplexors. Message demultiplexing is the process of determining which application a message is for. Like other packet demultiplexors, DPF uses packet filters to demultiplex messages. <p> Packet filters are interpreted, which entails a high computational cost. This cost is sufficiently high that, to the best of our knowledge, all high-performance networking systems except for the x-kernel project <ref> [1, 12] </ref> avoid them completely. For example, the Pere-grine RPC system [13], the remote read/write model of Thekkath et al. [23], and the Active message model [26] all use hard-wired in-kernel demultiplexing routines. <p> A contribution of our work is to show that dynamic code generation can be used in a straightforward manner. We have designed, implemented, and tested DPF. User-level measurements show that DPF demultiplexes messages 25-50 faster than MPF [27] and 13-26 faster than PATHFINDER <ref> [1] </ref>, the fastest packet filter demultiplexor in the literature. In addition, DPF scales better with the length of a filter than PATHFINDER, making it better suited for deep protocol stacks. We have also integrated DPF with Aegis, an exokernel operating system [10]. <p> Section 6 relates DPF to other work. In Section 7 we conclude. 2 Dynamic Packet Filter DPF's packet filter language is a declarative language that is used by protocols to describe the message headers that they are looking for. Similarly to the languages used in MPF [27] and PATHFINDER <ref> [1] </ref>, it can handle a wide range of possible protocols and supports fragmentation. A DPF packet filter is composed of a sequence of boolean comparisons (or atoms) linked by conjunctions. <p> We intend to investigate this alternative as we scale DPF to support environments with tens of thousands of filters, 3.2 Optimizations Packet filter optimizations can be either intra-filter [17] (within a filter) or inter-filter <ref> [27, 1] </ref> (between filters). Dynamic code generation is an intra-filter optimization. In this paper, we are interested in isolating the effects of dynamic code generation. <p> Finally, the use of dynamic code generation can be a simplifying mechanism, since it removes the need for a packet-filter expression evaluator. 4 Performance In this section we evaluate DPF's performance. Our experiments are based on those of PATHFINDER <ref> [1] </ref>. The PATHFINDER and MPF numbers were taken from the literature [1] (we were able to independently verify those for MPF). To ensure meaningful comparisons between the systems, we ran our experiments on the same hardware (a DECstation 5000/200) and in user space. <p> Our experiments are based on those of PATHFINDER <ref> [1] </ref>. The PATHFINDER and MPF numbers were taken from the literature [1] (we were able to independently verify those for MPF). To ensure meaningful comparisons between the systems, we ran our experiments on the same hardware (a DECstation 5000/200) and in user space. <p> Classification overhead Figure 3 presents the time to classify packets destined for one of ten TCP/IP filters for each of the three systems. The numbers for MPF and PATHFINDER were taken from <ref> [1] </ref>. To ensure a meaningful comparision, we have been careful to use equivalent filters. Because interpretation is expensive, both MPF and PATHFINDER maintain a cache of recently recognized filters; on message arrival, this cache is checked first. Given DPF's filter classification speed, our current implementation does not use caching. <p> of the good performance is due to Aegis's efficiency [10], but from these numbers it is clear that DPF does not form a bottleneck for achieving high performance communication while maintaining a high degree of flexibility. 6 Related work There have been four packet filter systems described in the literature <ref> [1, 17, 18, 27] </ref>. All of these systems use interpretation; additionally, PATHFINDER considers the effect of hardware assistance [1]. To the best of our knowledge, previous systems have not used the optimizations we describe in this paper. In the context of language design, DPF shares many similarities with PATHFINDER. <p> All of these systems use interpretation; additionally, PATHFINDER considers the effect of hardware assistance <ref> [1] </ref>. To the best of our knowledge, previous systems have not used the optimizations we describe in this paper. In the context of language design, DPF shares many similarities with PATHFINDER.
Reference: [2] <author> C. Chambers and D. Ungar. </author> <title> Customization: Optimizing compiler technology for SELF, a dynamically-typed object-oriented programming language. </title> <booktitle> In Proceedings of PLDI '89, </booktitle> <pages> pages 146-160, </pages> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: The general use of dynamic code generation to speed up language execution has a venerable tradition. Deutsch used it to implement Smalltalk [5]; it was later used in Self <ref> [2] </ref>. We were also influenced by Massalin's use of dynamic code generation in the context of operating system calls [16]. Recent work has concentrated on improving language-level support for dynamic code generation.
Reference: [3] <author> D. D. Clark, V. Jacobson, J. Romkey, and H. Salwen. </author> <title> An analysis of TCP processing overhead. </title> <journal> IEEE Communications Magazine, </journal> <volume> 27(6) </volume> <pages> 23-29, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: While we intend to improve these times, we believe that the current overhead is an acceptable tradeoff for an order-of-magnitude performance improvement in packet recognition, since it is repaid with just a handful of packet classifications. times are in microseconds. Comparison to hand coded Clark et al. <ref> [3] </ref> give an instruction count of 57 instructions for an optimized hand-coded IP demulti-plexor. Without disjunctions, our implementation requires approximately 18 instructions. The main reason for this is that DPF can aggressively exploit runtime constants.
Reference: [4] <author> C. Consel and F. Noel. </author> <title> A general approach for run-time specialization and its application to C. </title> <booktitle> In Proceedings of the 23th Annual Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg, FL, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Fortunately, compiler technology has reached the threshold where portable dynamic code generation systems are beginning to be made freely available. For instance, DPF uses the public-domain VCODE dynamic code generation system [8]. Language support for dynamic code generation has even been added to high-level languages such as C <ref> [4, 9] </ref> making the generation code code at runtime no more complex than the implementation of statically generated code. <p> Leone et al. [14] describe language support for dynamic code generation in the context of a restricted functional language. VCODE [8] and `C [9] provide a portable, efficient means of generating machine code on the fly (both systems are available publicly). Consel and No el <ref> [4] </ref> describe a technique for specializing programs with respect to run-time invariants. 7 Conclusion We have presented a packet filter system, DPF, that uses dynamic code generation to improve the performance of its packet-classifier engine by 13-26 times that of the best numbers presented in the literature.
Reference: [5] <author> P. Deutsch and A.M. Schiffman. </author> <title> Efficient implementation of the Smalltalk-80 system. </title> <booktitle> In Proceedings of 11th POPL, </booktitle> <pages> pages 297-302, </pages> <address> Salt Lake City, UT, </address> <month> January </month> <year> 1984. </year>
Reference-contexts: The general use of dynamic code generation to speed up language execution has a venerable tradition. Deutsch used it to implement Smalltalk <ref> [5] </ref>; it was later used in Self [2]. We were also influenced by Massalin's use of dynamic code generation in the context of operating system calls [16]. Recent work has concentrated on improving language-level support for dynamic code generation.
Reference: [6] <author> P. Druschel, L. L. Peterson, and B. S. Davie. </author> <title> Experiences with a high-speed network adaptor: A software perspective. </title> <booktitle> In ACM Communication Architectures, Protocols, and Applications (SIGCOMM) 1994, </booktitle> <pages> pages 2-13, </pages> <address> London, UK, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: This allows protocols to be implemented as user-level libraries, which can be tailored to application needs. As pointed out by many others, such user-level protocols have many benefits <ref> [6, 7, 15, 21, 25] </ref>. The design of the DPF was heavily influenced by the pervasive reliance Aegis places on application use of library operating sys Protocol Latency Throughput UDP 309 1.03 Table 4: Latency and throughput for UDP and TCP over Ethernet. Latency in microseconds. Throughput in Mbyte/s. tems.
Reference: [7] <author> A. Edwards, G. Watson, J. Lumley, D. Banks, C. Clamvokis, and C. Dalton. </author> <title> User-space protocols deliver high performance to applications on a low-cost Gb/s LAN. </title> <booktitle> In ACM Communication Architectures, Protocols, and Applications (SIGCOMM) 1994, </booktitle> <pages> pages 14-24, </pages> <address> London, UK, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: This allows protocols to be implemented as user-level libraries, which can be tailored to application needs. As pointed out by many others, such user-level protocols have many benefits <ref> [6, 7, 15, 21, 25] </ref>. The design of the DPF was heavily influenced by the pervasive reliance Aegis places on application use of library operating sys Protocol Latency Throughput UDP 309 1.03 Table 4: Latency and throughput for UDP and TCP over Ethernet. Latency in microseconds. Throughput in Mbyte/s. tems.
Reference: [8] <author> D. R. Engler. </author> <title> VCODE: a retargetable, extensible, very fast dynamic code generation system. </title> <booktitle> In Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year> <note> http://www.pdos.lcs.mit.edu/engler/ vcode.html. </note>
Reference-contexts: For portability, DPF uses the machine-independent VCODE dynamic code generation system <ref> [8] </ref>. Because an atom represents a single comparison, the code generated for it is mapped to a basic block of machine instructions: i.e., control enters from the top of an atom and leaves at the bottom (via a branch). <p> Fortunately, compiler technology has reached the threshold where portable dynamic code generation systems are beginning to be made freely available. For instance, DPF uses the public-domain VCODE dynamic code generation system <ref> [8] </ref>. Language support for dynamic code generation has even been added to high-level languages such as C [4, 9] making the generation code code at runtime no more complex than the implementation of statically generated code. <p> Recent work has concentrated on improving language-level support for dynamic code generation. Leone et al. [14] describe language support for dynamic code generation in the context of a restricted functional language. VCODE <ref> [8] </ref> and `C [9] provide a portable, efficient means of generating machine code on the fly (both systems are available publicly).
Reference: [9] <author> D. R. Engler, W. C. Hsieh, and M. F. Kaashoek. </author> <title> `C: A language for high-level, efficient, and machine-independent dynamic code generation. </title> <booktitle> In Proceedings of the 22th Annual Symposium on Principles of Programming Languages, </booktitle> <year> 1995. </year>
Reference-contexts: Fortunately, compiler technology has reached the threshold where portable dynamic code generation systems are beginning to be made freely available. For instance, DPF uses the public-domain VCODE dynamic code generation system [8]. Language support for dynamic code generation has even been added to high-level languages such as C <ref> [4, 9] </ref> making the generation code code at runtime no more complex than the implementation of statically generated code. <p> Recent work has concentrated on improving language-level support for dynamic code generation. Leone et al. [14] describe language support for dynamic code generation in the context of a restricted functional language. VCODE [8] and `C <ref> [9] </ref> provide a portable, efficient means of generating machine code on the fly (both systems are available publicly).
Reference: [10] <author> D. R. Engler, M. F. Kaashoek, and J. O'Toole Jr. Exoker-nel: </author> <title> an operating system architecture for application-specific resource management. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 251-266, </pages> <address> Copper Mountain Resort, Colorado, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: In addition, DPF scales better with the length of a filter than PATHFINDER, making it better suited for deep protocol stacks. We have also integrated DPF with Aegis, an exokernel operating system <ref> [10] </ref>. DPF allows Aegis to export the Ethernet interface safely and efficiently to applications; this structure allows all protocols to be implemented completely as libraries in user space. <p> DPF generated code is as fast as hand-crafted demultiplexors even when it cannot use runtime information: given the restricted domain in which filters are written, DPF can perform the same optimizations that current compilers do for packet filter expressions. 5 Using DPF We have integrated DPF with the Aegis exokernel <ref> [10] </ref>. Although our implementation is for an exokernel, DPF is mostly independent of the operating system. For example, adding DPF to a standard run-of-the-mill UNIX kernel should be relatively straightforward. DPF allows Aegis to export the Ethernet interface securely and efficiently to applications. <p> Part of the good performance is due to Aegis's efficiency <ref> [10] </ref>, but from these numbers it is clear that DPF does not form a bottleneck for achieving high performance communication while maintaining a high degree of flexibility. 6 Related work There have been four packet filter systems described in the literature [1, 17, 18, 27].
Reference: [11] <author> D.R. Engler and T.A. Proebsting. </author> <title> DCG: An efficient, re-targetable dynamic code generation system. </title> <booktitle> Proceedings of ASPLOS-VI, </booktitle> <pages> pages 263-272, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: filters as well, but did not implement it. 1 Recently, Minshall and collegues have experimented with the use of dynamic code generation in BPF but have not reported on any results. 2 The system we developed was first mentioned in Engler and Proebsting as a motivation for dynamic code generation <ref> [11] </ref>. We hope that the performance improvements we demonstrate are a vindication of the packet filter model for efficient demultiplexing, allowing packet filters to be as useful in the context of Gb/sec networks as they are on Mb/sec Ethernets.
Reference: [12] <author> N.C. Hutchinson and L.L. Peterson. </author> <title> The x-kernel: an architecture for implementing network protocols. </title> <journal> IEEE Trans. on Soft. Eng., </journal> <volume> 17(1), </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: Packet filters are interpreted, which entails a high computational cost. This cost is sufficiently high that, to the best of our knowledge, all high-performance networking systems except for the x-kernel project <ref> [1, 12] </ref> avoid them completely. For example, the Pere-grine RPC system [13], the remote read/write model of Thekkath et al. [23], and the Active message model [26] all use hard-wired in-kernel demultiplexing routines.
Reference: [13] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> The Peregrine high-performance RPC system. </title> <type> Technical Report TR91-151, </type> <institution> Rice University, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: For example, the packet-filter model [18] is flexible, but its cost has precluded its use in high-performance networking systems. Instead, networking systems use hand-crafted demultiplexing routines that can only be extended or altered by kernel architects <ref> [13, 23, 26] </ref>. The packet filter system described in this paper, Dynamic Packet Filters (DPF), achieves these twin goals of flexibility and performance by using a carefully-designed declarative packet-filter language that is amenable to aggressive dynamic code generation. <p> Packet filters are interpreted, which entails a high computational cost. This cost is sufficiently high that, to the best of our knowledge, all high-performance networking systems except for the x-kernel project [1, 12] avoid them completely. For example, the Pere-grine RPC system <ref> [13] </ref>, the remote read/write model of Thekkath et al. [23], and the Active message model [26] all use hard-wired in-kernel demultiplexing routines.
Reference: [14] <author> M. Leone and P. Lee. </author> <title> Lightweight run-time code generation. </title> <booktitle> In Proceedings of the Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 97-106, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Deutsch used it to implement Smalltalk [5]; it was later used in Self [2]. We were also influenced by Massalin's use of dynamic code generation in the context of operating system calls [16]. Recent work has concentrated on improving language-level support for dynamic code generation. Leone et al. <ref> [14] </ref> describe language support for dynamic code generation in the context of a restricted functional language. VCODE [8] and `C [9] provide a portable, efficient means of generating machine code on the fly (both systems are available publicly).
Reference: [15] <author> C. Maeda and B. N. Bershad. </author> <title> Protocol service decomposition for high-performance networking. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 244-255, </pages> <year> 1993. </year>
Reference-contexts: This allows protocols to be implemented as user-level libraries, which can be tailored to application needs. As pointed out by many others, such user-level protocols have many benefits <ref> [6, 7, 15, 21, 25] </ref>. The design of the DPF was heavily influenced by the pervasive reliance Aegis places on application use of library operating sys Protocol Latency Throughput UDP 309 1.03 Table 4: Latency and throughput for UDP and TCP over Ethernet. Latency in microseconds. Throughput in Mbyte/s. tems. <p> The performance of the user-level implementations of UDP and TCP using DPF are as good as hard-coded in-kernel implementations and better than other user-level implementations of the internet protocols in user space over Ethernet <ref> [25, 15] </ref>. In fact, our user-level implementations perform close to the possible limits; Thekkath and Levy measure 340 microseconds between 25-MHz DECstation 5000/200s for a user-level reliable raw RPC protocol [22], while we are measuring 309 microseconds on a faster machine (40-MHz) but using IP and UDP with checksumming.
Reference: [16] <author> H. Massalin. </author> <title> Synthesis: an efficient implementation of fundamental operating system services. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: The general use of dynamic code generation to speed up language execution has a venerable tradition. Deutsch used it to implement Smalltalk [5]; it was later used in Self [2]. We were also influenced by Massalin's use of dynamic code generation in the context of operating system calls <ref> [16] </ref>. Recent work has concentrated on improving language-level support for dynamic code generation. Leone et al. [14] describe language support for dynamic code generation in the context of a restricted functional language.
Reference: [17] <author> S. McCanne and V. Jacobson. </author> <title> The BSD packet filter: A new architecture for user-level packet capture. </title> <booktitle> In USENIX Technical Conference Proceedings, </booktitle> <pages> pages 259-269, </pages> <address> San Diego, CA, </address> <booktitle> Winter 1993. USENIX. </booktitle>
Reference-contexts: DPF filters run 13-26 times faster than PATHFINDER filters, the fastest numbers This work was supported in part by the Advanced Research Projects Agency under contract N00014-94-1-0985 and by a NSF National Young Investigator Award. reported in the literature <ref> [1, 17, 18, 27] </ref>. DPF's performance is equivalent to, and in some situations can even exceed, the performance of hand-coded demultiplexors. Message demultiplexing is the process of determining which application a message is for. Like other packet demultiplexors, DPF uses packet filters to demultiplex messages. <p> We intend to investigate this alternative as we scale DPF to support environments with tens of thousands of filters, 3.2 Optimizations Packet filter optimizations can be either intra-filter <ref> [17] </ref> (within a filter) or inter-filter [27, 1] (between filters). Dynamic code generation is an intra-filter optimization. In this paper, we are interested in isolating the effects of dynamic code generation. <p> of the good performance is due to Aegis's efficiency [10], but from these numbers it is clear that DPF does not form a bottleneck for achieving high performance communication while maintaining a high degree of flexibility. 6 Related work There have been four packet filter systems described in the literature <ref> [1, 17, 18, 27] </ref>. All of these systems use interpretation; additionally, PATHFINDER considers the effect of hardware assistance [1]. To the best of our knowledge, previous systems have not used the optimizations we describe in this paper. In the context of language design, DPF shares many similarities with PATHFINDER.
Reference: [18] <author> J.C. Mogul, R.F. Rashid, and M.J. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Rapid demultiplexing is important in order to neither waste processing cycles nor add latency to end-to-end message time [1]. Application-specific demultiplexing is important so that applications can explore new protocols without kernel modification <ref> [18] </ref>. Previously, networking architects have had to trade flexibility for performance to demultiplex messages efficiently. For example, the packet-filter model [18] is flexible, but its cost has precluded its use in high-performance networking systems. <p> Application-specific demultiplexing is important so that applications can explore new protocols without kernel modification <ref> [18] </ref>. Previously, networking architects have had to trade flexibility for performance to demultiplex messages efficiently. For example, the packet-filter model [18] is flexible, but its cost has precluded its use in high-performance networking systems. Instead, networking systems use hand-crafted demultiplexing routines that can only be extended or altered by kernel architects [13, 23, 26]. <p> DPF filters run 13-26 times faster than PATHFINDER filters, the fastest numbers This work was supported in part by the Advanced Research Projects Agency under contract N00014-94-1-0985 and by a NSF National Young Investigator Award. reported in the literature <ref> [1, 17, 18, 27] </ref>. DPF's performance is equivalent to, and in some situations can even exceed, the performance of hand-coded demultiplexors. Message demultiplexing is the process of determining which application a message is for. Like other packet demultiplexors, DPF uses packet filters to demultiplex messages. <p> Message demultiplexing is the process of determining which application a message is for. Like other packet demultiplexors, DPF uses packet filters to demultiplex messages. Packet filters are predicates written in a small safe language <ref> [18] </ref>. Logically, a packet filter examines all incoming network packets; those messages that satisfy its predicate are delivered to its associated application. This approach allows new protocols to be implemented outside of the kernel and then downloaded into the packet filter driver, greatly increasing flexibility [18]. <p> in a small safe language <ref> [18] </ref>. Logically, a packet filter examines all incoming network packets; those messages that satisfy its predicate are delivered to its associated application. This approach allows new protocols to be implemented outside of the kernel and then downloaded into the packet filter driver, greatly increasing flexibility [18]. Packet filters are interpreted, which entails a high computational cost. This cost is sufficiently high that, to the best of our knowledge, all high-performance networking systems except for the x-kernel project [1, 12] avoid them completely. <p> Dynamic code generation can be used to compile a packet filter specification down to actual machine code. While dynamic code generation has been considered a possible mechanism for improving the performance of packet filters since their inception <ref> [18] </ref>, it has been deemed too complicated to implement [18]. A contribution of our work is to show that dynamic code generation can be used in a straightforward manner. We have designed, implemented, and tested DPF. <p> Dynamic code generation can be used to compile a packet filter specification down to actual machine code. While dynamic code generation has been considered a possible mechanism for improving the performance of packet filters since their inception <ref> [18] </ref>, it has been deemed too complicated to implement [18]. A contribution of our work is to show that dynamic code generation can be used in a straightforward manner. We have designed, implemented, and tested DPF. <p> of the good performance is due to Aegis's efficiency [10], but from these numbers it is clear that DPF does not form a bottleneck for achieving high performance communication while maintaining a high degree of flexibility. 6 Related work There have been four packet filter systems described in the literature <ref> [1, 17, 18, 27] </ref>. All of these systems use interpretation; additionally, PATHFINDER considers the effect of hardware assistance [1]. To the best of our knowledge, previous systems have not used the optimizations we describe in this paper. In the context of language design, DPF shares many similarities with PATHFINDER. <p> This is the first paper to systematically use and investigate the effects of dynamic code generation on packet filter performance. The idea of using dynamic code generation to improve packet filter performance is an old one: Mogul et al. <ref> [18] </ref> mentioned dynamic code generation as a possibility for improving packet filter performance, but considered it too complicated.
Reference: [19] <author> T. A. Proebsting and C. N. Fischer. </author> <title> Linear-time optimal code scheduling for delayed-load architectures. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Code generation is done with one pass over the atom's expression tree. This pass performs register allocation, simple delay slot scheduling, and instruction selection and emission. Register allocation and delay slot scheduling are modeled on Proebsting <ref> [19] </ref>. Instruction selection is a matter of translating the operators of the atom's expression tree to the instructions supplied by the underlying hardware. There is a direct mapping between these operations and machine instructions (e.g., & maps to and); as a result, instruction selection is simple.
Reference: [20] <author> N. Ramsey and M. F. Fernandez. </author> <title> The New Jersey machine-code toolkit. </title> <booktitle> In 1995 Winter USENIX, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: Our initial implementation of DPF took such an approach. Not including the instruction macros themselves (which are freely available in systems such as the New Jersey Toolkit <ref> [20] </ref>), it was a few hundred lines of machine-dependent source. Compared to the overall effort required in other parts of the kernel, this is a rather small amount of code to write and, in our experience, can take as little as one to two days to construct.
Reference: [21] <author> V. Buch T. von Eicken, A. Basu and W. Vogels. U-Net: </author> <title> A user-level network interface for parallel and distributed computing. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <year> 1995. </year>
Reference-contexts: This allows protocols to be implemented as user-level libraries, which can be tailored to application needs. As pointed out by many others, such user-level protocols have many benefits <ref> [6, 7, 15, 21, 25] </ref>. The design of the DPF was heavily influenced by the pervasive reliance Aegis places on application use of library operating sys Protocol Latency Throughput UDP 309 1.03 Table 4: Latency and throughput for UDP and TCP over Ethernet. Latency in microseconds. Throughput in Mbyte/s. tems.
Reference: [22] <author> C. A. Thekkath and H. M. Levy. </author> <title> Limits to low-latency communication on high-speed networks. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(2) </volume> <pages> 179-203, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: In fact, our user-level implementations perform close to the possible limits; Thekkath and Levy measure 340 microseconds between 25-MHz DECstation 5000/200s for a user-level reliable raw RPC protocol <ref> [22] </ref>, while we are measuring 309 microseconds on a faster machine (40-MHz) but using IP and UDP with checksumming.
Reference: [23] <author> C. A. Thekkath, H. M. Levy, and E. D. Lazowska. </author> <title> Separating data and control transfer in distributed operating systems. </title> <booktitle> In Sixth International Conference on Architecture Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 2-11, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: For example, the packet-filter model [18] is flexible, but its cost has precluded its use in high-performance networking systems. Instead, networking systems use hand-crafted demultiplexing routines that can only be extended or altered by kernel architects <ref> [13, 23, 26] </ref>. The packet filter system described in this paper, Dynamic Packet Filters (DPF), achieves these twin goals of flexibility and performance by using a carefully-designed declarative packet-filter language that is amenable to aggressive dynamic code generation. <p> This cost is sufficiently high that, to the best of our knowledge, all high-performance networking systems except for the x-kernel project [1, 12] avoid them completely. For example, the Pere-grine RPC system [13], the remote read/write model of Thekkath et al. <ref> [23] </ref>, and the Active message model [26] all use hard-wired in-kernel demultiplexing routines. <p> (is optimized away) # Check protocol: TCP is 6 # (9:8 == 6) && lbu t1,9+14 (a0) # 9:8 after propogating ethernet header size li t0,6 # load 6 bne t1,t0,$next # Branch to next filter if not equal atoms of an Ethernet/IP/TCP header (after optimization). as Thekkath et al. <ref> [23] </ref>) is small, since the handler must only save and restore a handful of registers to classify a packet.
Reference: [24] <author> C.A. Thekkath, H.M. Levy, and E.D. Lazowska. </author> <title> Efficient support for multicomputing on ATM networks. </title> <type> Technical Report TR93-04-03, </type> <institution> University of Washington, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: The idea of using dynamic code generation to improve packet filter performance is an old one: Mogul et al. [18] mentioned dynamic code generation as a possibility for improving packet filter performance, but considered it too complicated. Thekkath et al. <ref> [24] </ref> mentioned the use of dynamic code generation for packet filters as well, but did not implement it. 1 Recently, Minshall and collegues have experimented with the use of dynamic code generation in BPF but have not reported on any results. 2 The system we developed was first mentioned in Engler
Reference: [25] <author> C.A. Thekkath, T.D. Nguyen, E. Moy, and E. Lazowska. </author> <title> Implementing network protocols at user level. </title> <booktitle> In ACM Communication Architectures, Protocols, and Applications (SIG-COMM) 1993, </booktitle> <pages> pages 64-73, </pages> <address> San Francisco, California, </address> <month> Octo-ber </month> <year> 1993. </year>
Reference-contexts: This allows protocols to be implemented as user-level libraries, which can be tailored to application needs. As pointed out by many others, such user-level protocols have many benefits <ref> [6, 7, 15, 21, 25] </ref>. The design of the DPF was heavily influenced by the pervasive reliance Aegis places on application use of library operating sys Protocol Latency Throughput UDP 309 1.03 Table 4: Latency and throughput for UDP and TCP over Ethernet. Latency in microseconds. Throughput in Mbyte/s. tems. <p> The performance of the user-level implementations of UDP and TCP using DPF are as good as hard-coded in-kernel implementations and better than other user-level implementations of the internet protocols in user space over Ethernet <ref> [25, 15] </ref>. In fact, our user-level implementations perform close to the possible limits; Thekkath and Levy measure 340 microseconds between 25-MHz DECstation 5000/200s for a user-level reliable raw RPC protocol [22], while we are measuring 309 microseconds on a faster machine (40-MHz) but using IP and UDP with checksumming.
Reference: [26] <author> T. von Eicken, A. Basu, and V. </author> <title> Buch. Low-latency communication over ATM networks using active messages. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 46-53, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: For example, the packet-filter model [18] is flexible, but its cost has precluded its use in high-performance networking systems. Instead, networking systems use hand-crafted demultiplexing routines that can only be extended or altered by kernel architects <ref> [13, 23, 26] </ref>. The packet filter system described in this paper, Dynamic Packet Filters (DPF), achieves these twin goals of flexibility and performance by using a carefully-designed declarative packet-filter language that is amenable to aggressive dynamic code generation. <p> This cost is sufficiently high that, to the best of our knowledge, all high-performance networking systems except for the x-kernel project [1, 12] avoid them completely. For example, the Pere-grine RPC system [13], the remote read/write model of Thekkath et al. [23], and the Active message model <ref> [26] </ref> all use hard-wired in-kernel demultiplexing routines.
Reference: [27] <author> M. Yahara, B. Bershad, C. Maeda, and E. Moss. </author> <title> Efficient packet demultiplexing for multiple endpoints and large messages. </title> <booktitle> In Proceedings of the Winter 1994 USENIX Conference, </booktitle> <year> 1994. </year>
Reference-contexts: DPF filters run 13-26 times faster than PATHFINDER filters, the fastest numbers This work was supported in part by the Advanced Research Projects Agency under contract N00014-94-1-0985 and by a NSF National Young Investigator Award. reported in the literature <ref> [1, 17, 18, 27] </ref>. DPF's performance is equivalent to, and in some situations can even exceed, the performance of hand-coded demultiplexors. Message demultiplexing is the process of determining which application a message is for. Like other packet demultiplexors, DPF uses packet filters to demultiplex messages. <p> A contribution of our work is to show that dynamic code generation can be used in a straightforward manner. We have designed, implemented, and tested DPF. User-level measurements show that DPF demultiplexes messages 25-50 faster than MPF <ref> [27] </ref> and 13-26 faster than PATHFINDER [1], the fastest packet filter demultiplexor in the literature. In addition, DPF scales better with the length of a filter than PATHFINDER, making it better suited for deep protocol stacks. We have also integrated DPF with Aegis, an exokernel operating system [10]. <p> Section 6 relates DPF to other work. In Section 7 we conclude. 2 Dynamic Packet Filter DPF's packet filter language is a declarative language that is used by protocols to describe the message headers that they are looking for. Similarly to the languages used in MPF <ref> [27] </ref> and PATHFINDER [1], it can handle a wide range of possible protocols and supports fragmentation. A DPF packet filter is composed of a sequence of boolean comparisons (or atoms) linked by conjunctions. <p> We intend to investigate this alternative as we scale DPF to support environments with tens of thousands of filters, 3.2 Optimizations Packet filter optimizations can be either intra-filter [17] (within a filter) or inter-filter <ref> [27, 1] </ref> (between filters). Dynamic code generation is an intra-filter optimization. In this paper, we are interested in isolating the effects of dynamic code generation. <p> of the good performance is due to Aegis's efficiency [10], but from these numbers it is clear that DPF does not form a bottleneck for achieving high performance communication while maintaining a high degree of flexibility. 6 Related work There have been four packet filter systems described in the literature <ref> [1, 17, 18, 27] </ref>. All of these systems use interpretation; additionally, PATHFINDER considers the effect of hardware assistance [1]. To the best of our knowledge, previous systems have not used the optimizations we describe in this paper. In the context of language design, DPF shares many similarities with PATHFINDER.
References-found: 27

