URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/FT-SR.ps
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/printed/
Root-URL: http://www.cs.berkeley.edu
Title: FT-SR: A Programming Language for Constructing Fault-Tolerant Distributed Systems  
Author: Richard D. Schlichting Vicraj T. Thomas 
Note: TR 92-31  
Abstract-found: 0
Intro-found: 1
Reference: [AD76] <author> Peter A. Alsberg and John D. Day. </author> <title> A principle for resilient sharing of distributed resources. </title> <booktitle> In Proceedings of Second International Conference on Software Engg., </booktitle> <pages> pages 562-570, </pages> <month> October </month> <year> 1976. </year> <month> 19 </month>
Reference-contexts: A resource group can also be configured to work according to a primary-backup scheme <ref> [AD76] </ref>. In this scenario, invocations to the group are delivered only to a replica designated as the primary by the language runtime, with the other replicas being passive.
Reference: [AO93] <author> Gregory R. Andrews and Ronald A. Olsson. </author> <title> The SR Programming Language. </title> <publisher> The Ben--jamin/Cummings Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: In this paper, we focus on a third area related to simplifying the construction of fault-tolerant distributed programs, that of providing adequate programming language support. Specifically, we describe the design and implementation of FT-SR, a programming language based on SR <ref> [AOC + 88, AO93] </ref> that is oriented towards writing fault-tolerant distributed systems. FT-SR is unique in that it has been designed to be a multi-paradigm language, that is, a language that can support equally well any of the multiple programming paradigms that have been developed for this type of system. <p> Since our extensions are based on existing SR mechanisms, a short overview of the language is provided in Appendix A; for further details, see <ref> [AOC + 88, AO93] </ref>. 3.1 Simple FS Atomic Objects Realizing much of the functionality of a simple FS atomic objecti.e., one not composed of other objects or using any other fault-tolerance techniquesin SR is straightforward since a resource instance is essentially an object in its own right.
Reference: [AOC + 88] <author> Gregory R. Andrews, Ronald A. Olsson, Michael A. Coffin, Irving Elshoff, Kelvin Nilsen, Ti-tus Purdin, and Gregg Townsend. </author> <title> An overview of the SR language and implementation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(1) </volume> <pages> 51-86, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: In this paper, we focus on a third area related to simplifying the construction of fault-tolerant distributed programs, that of providing adequate programming language support. Specifically, we describe the design and implementation of FT-SR, a programming language based on SR <ref> [AOC + 88, AO93] </ref> that is oriented towards writing fault-tolerant distributed systems. FT-SR is unique in that it has been designed to be a multi-paradigm language, that is, a language that can support equally well any of the multiple programming paradigms that have been developed for this type of system. <p> Since our extensions are based on existing SR mechanisms, a short overview of the language is provided in Appendix A; for further details, see <ref> [AOC + 88, AO93] </ref>. 3.1 Simple FS Atomic Objects Realizing much of the functionality of a simple FS atomic objecti.e., one not composed of other objects or using any other fault-tolerance techniquesin SR is straightforward since a resource instance is essentially an object in its own right.
Reference: [Bal91] <author> Henri E. Bal. </author> <title> A comparative study of five parallel programming languages. </title> <booktitle> In Proceedings of EurOpen Conference on Open Distributed Systems, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: Support for a single paradigm has been shown to be constraining in many situations <ref> [Bal91] </ref>, and is particularly inappropriate for constructing systems, where different paradigms may be used at different levels of abstraction.
Reference: [BD88] <author> A. Burns and G. Davies. </author> <title> Pascal-FC: A language for teaching concurrent programming. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(1) </volume> <pages> 58-66, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: development of such a multi-paradigm language for fault-tolerant programming can be viewed as analogous to the evolution of standard distributed programming languages, which have progressed from languages such as CSP [Hoa78] and Concurrent Pascal [BH75] that support only a single synchronization paradigm to those such as SR, Dislang [LL81], Pascal-FC <ref> [BD88] </ref>, and StarMod [Coo80] that support multiple approaches. This paper is organized as follows. In Section 2, we first describe fail-stop atomic objects and the programming model that results from considering these as the primary abstraction.
Reference: [BH75] <author> Per Brinch Hansen. </author> <title> The programming language Concurrent Pascal. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1(2):199-206, </volume> <month> June </month> <year> 1975. </year>
Reference-contexts: Moreover, the development of such a multi-paradigm language for fault-tolerant programming can be viewed as analogous to the evolution of standard distributed programming languages, which have progressed from languages such as CSP [Hoa78] and Concurrent Pascal <ref> [BH75] </ref> that support only a single synchronization paradigm to those such as SR, Dislang [LL81], Pascal-FC [BD88], and StarMod [Coo80] that support multiple approaches. This paper is organized as follows.
Reference: [BHG87] <author> Philip A. Bernstein, Vassos Hadzilacos, and Nathan Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley Series in Computer Science. Addison-Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: These properties have also been called totality and serializability [Wei89], and recoverability and indivisibility [Lis85]. In the database literature, atomic actions are known as transactions <ref> [BHG87] </ref>. A system built using the object/action paradigm may be implemented using FS atomic objects. Objects in the system correspond to FS atomic objects. An action corresponds to an abstract thread realized by the combination of concrete threads in the FS atomic objects. <p> To implement the atomic update of the data items, the data manager uses the standard technique of maintaining two versions of each data item on stable storage together with an indicator of which is current <ref> [BHG87] </ref>. To simplify our implementation, we maintain this indicator and the two versions in contiguous stable storage locations, with the indicator being an offset and the address of the indicator used as the logical address of the item.
Reference: [BMZ92] <author> Peter A. Buhr, Hamish I. MacDonald, and C. Robert Zarnke. </author> <title> Synchronous and asynchronous handling of abnormal events in the System. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 22(9) </volume> <pages> 735-776, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: cap: : : monitor client cap send rel lock (client cap, lock id) return lock id [] rel lock (client cap, lock id) -&gt; : : : release lock if held by client cap: : : monitorend client cap return ni end lock server end lock manager 7 of contexts <ref> [CGR88, SCP91, BMZ92] </ref> and is in keeping with the inherently asynchronous nature of failures themselves. 3.2 Higher-Level FS Atomic Objects FT-SR provides mechanisms for supporting the construction of more fault-tolerant, higher-level FS atomic objects using replication, and for increasing the resilience of objects to failures using recovery techniques.
Reference: [BSS91] <author> Kenneth Birman, Andre Schiper, and Pat Stephenson. </author> <title> Lightweight causal and atomic group multi-cast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The language has been implemented using the x-kernel, an operating system designed for experimenting with communication protocols [HP91], and runs standalone on a network of Sun workstations. The orientation towards supporting multiple paradigms distinguishes FT-SR from other languages [Lis85, EFH82, LW85], language extensions [SCP91, CGR88, KU87] and language libraries <ref> [BSS91, Coo85, PS88, HW87] </ref> related to fault-tolerance, which are typically oriented around a particular paradigm. Support for a single paradigm has been shown to be constraining in many situations [Bal91], and is particularly inappropriate for constructing systems, where different paradigms may be used at different levels of abstraction.
Reference: [CAS85] <author> Flaviu Cristian, Houtan Aghili, and Ray Strong. </author> <title> Atomic broadcast: From simple message diffusion to Byzantine agreement. </title> <booktitle> In Digest of Papers, The Fifteenth International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 200-206. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1985. </year>
Reference-contexts: The combination of the atomicity and consistent ordering properties means that an invocation using a resource group capability is equivalent to an atomic broadcast <ref> [CAS85, MSMA90] </ref>. The results of a multicast call invocation are collected by the runtime system, with only a single result being returned to the caller; since FT-SR assumes processors with fail-silent semantics, returning the first result is sufficient in this case.
Reference: [CGR88] <author> R.F. Cmelik, N.H. Gehani, and W. D. Roome. </author> <title> Fault tolerant concurrent C: A tool for writing fault tolerant distributed programs. </title> <booktitle> In Digest of Papers, The Eighteenth International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 55-61. </pages> <publisher> IEEE Computer Society, IEEE Computer Society Press, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: The language has been implemented using the x-kernel, an operating system designed for experimenting with communication protocols [HP91], and runs standalone on a network of Sun workstations. The orientation towards supporting multiple paradigms distinguishes FT-SR from other languages [Lis85, EFH82, LW85], language extensions <ref> [SCP91, CGR88, KU87] </ref> and language libraries [BSS91, Coo85, PS88, HW87] related to fault-tolerance, which are typically oriented around a particular paradigm. <p> cap: : : monitor client cap send rel lock (client cap, lock id) return lock id [] rel lock (client cap, lock id) -&gt; : : : release lock if held by client cap: : : monitorend client cap return ni end lock server end lock manager 7 of contexts <ref> [CGR88, SCP91, BMZ92] </ref> and is in keeping with the inherently asynchronous nature of failures themselves. 3.2 Higher-Level FS Atomic Objects FT-SR provides mechanisms for supporting the construction of more fault-tolerant, higher-level FS atomic objects using replication, and for increasing the resilience of objects to failures using recovery techniques. <p> For example, languages like Argus [Lis85], Avalon [HW87], Plits [EFH82], TABS [SDD + 85] and Hops [Mad86] support the object/action model, languages like Fault-Tolerant Concurrent C <ref> [CGR88] </ref> support the replicated state machine approach, and numerous operating systems like UNICOS [KK89] support the restartable action paradigm. To illustrate how the different programming paradigms are typically supported, we describe a representative example from each category: Fault-Tolerant Concurrent C, UNICOS and Argus. Fault-Tolerant Concurrent C.
Reference: [CM84] <author> Jo-Mei Chang and N.F. Maxemchuk. </author> <title> Reliable broadcast protocols. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 251-273, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: For replication, the most interesting aspect of the implementation is managing group communication, since messages sent to a resource group as a result of invocations have to be multicast and delivered to all replicas in a consistent total order. The technique we use is similar to <ref> [CM84, KTHB89, GMS89] </ref>, where one of the replicas is a primary through which all messages are funneled. Another max sf replicas are designated as primary-group members, with the remaining being considered ordinary members.
Reference: [Coo80] <author> Robert P. Cook. </author> <title> *MODa language for distributed programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(6):563-571, </volume> <month> November </month> <year> 1980. </year>
Reference-contexts: a multi-paradigm language for fault-tolerant programming can be viewed as analogous to the evolution of standard distributed programming languages, which have progressed from languages such as CSP [Hoa78] and Concurrent Pascal [BH75] that support only a single synchronization paradigm to those such as SR, Dislang [LL81], Pascal-FC [BD88], and StarMod <ref> [Coo80] </ref> that support multiple approaches. This paper is organized as follows. In Section 2, we first describe fail-stop atomic objects and the programming model that results from considering these as the primary abstraction.
Reference: [Coo85] <author> Eric C. Cooper. </author> <title> Replicated distributed programs. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-78. </pages> <publisher> ACM SIGOPS, </publisher> <month> December </month> <year> 1985. </year>
Reference-contexts: The language has been implemented using the x-kernel, an operating system designed for experimenting with communication protocols [HP91], and runs standalone on a network of Sun workstations. The orientation towards supporting multiple paradigms distinguishes FT-SR from other languages [Lis85, EFH82, LW85], language extensions [SCP91, CGR88, KU87] and language libraries <ref> [BSS91, Coo85, PS88, HW87] </ref> related to fault-tolerance, which are typically oriented around a particular paradigm. Support for a single paradigm has been shown to be constraining in many situations [Bal91], and is particularly inappropriate for constructing systems, where different paradigms may be used at different levels of abstraction.
Reference: [Cri91] <author> Flaviu Cristian. </author> <title> Understanding fault-tolerant distributed systems. </title> <journal> Communications of the ACM, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: For instance, failure models have been developed as a means for precisely specifying assumptions made about the possible effect of failures. Examples of popular failure models include fail-stop [SS83], timing <ref> [Cri91] </ref>, fail-silent [PVB + 88], and Byzantine [LSP82]. Another area has been the development of programming paradigms, which simplify the development of certain types of fault-tolerant distributed programs by providing canonical organization techniques and abstractions. <p> For example, an FS atomic object implementing the services of a transaction manager may use the operations exported by another FS atomic object implementing the abstraction of stable storage [Lam81]. These dependencies can be defined more formally using the depends relation given in <ref> [Cri91] </ref>. In particular, an FS atomic object u is said to depend on another object v if the correctness of u's behavior depends on the correctness of v's behavior.
Reference: [EFH82] <author> C.S. Ellis, J.A. Feldman, and J.E. Heliotis. </author> <title> Language constructs and support systems for distributed computing. </title> <booktitle> In ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 1-9. </pages> <publisher> ACM SIGACT-SIGOPS, </publisher> <month> August </month> <year> 1982. </year>
Reference-contexts: The language has been implemented using the x-kernel, an operating system designed for experimenting with communication protocols [HP91], and runs standalone on a network of Sun workstations. The orientation towards supporting multiple paradigms distinguishes FT-SR from other languages <ref> [Lis85, EFH82, LW85] </ref>, language extensions [SCP91, CGR88, KU87] and language libraries [BSS91, Coo85, PS88, HW87] related to fault-tolerance, which are typically oriented around a particular paradigm. <p> For example, languages like Argus [Lis85], Avalon [HW87], Plits <ref> [EFH82] </ref>, TABS [SDD + 85] and Hops [Mad86] support the object/action model, languages like Fault-Tolerant Concurrent C [CGR88] support the replicated state machine approach, and numerous operating systems like UNICOS [KK89] support the restartable action paradigm.
Reference: [GMS89] <author> Hector Garcia-Molina and Annemarie Spauster. </author> <title> Message ordering in a multicast environment. </title> <booktitle> In Proceedings of the 9th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 354-361, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: For replication, the most interesting aspect of the implementation is managing group communication, since messages sent to a resource group as a result of invocations have to be multicast and delivered to all replicas in a consistent total order. The technique we use is similar to <ref> [CM84, KTHB89, GMS89] </ref>, where one of the replicas is a primary through which all messages are funneled. Another max sf replicas are designated as primary-group members, with the remaining being considered ordinary members.
Reference: [GR89] <author> N. H. Gehani and W.D. Roome. </author> <title> The Concurrent C Programming Language. </title> <publisher> Silicon Press, Summit, </publisher> <address> NJ, </address> <year> 1989. </year>
Reference-contexts: To illustrate how the different programming paradigms are typically supported, we describe a representative example from each category: Fault-Tolerant Concurrent C, UNICOS and Argus. Fault-Tolerant Concurrent C. Fault-Tolerant Concurrent C (FTCC) is a collection of extensions to Concurrent C <ref> [GR89] </ref> that allows the programmer to build replicated state machines using multiple processes. This is done by extending the Concurrent C process creation statement to create multiple copies of a process on one or more processors.
Reference: [Gra79] <author> James N. Gray. </author> <title> Notes on data base operating systems. </title> <editor> In R. Bayer, R.M. Graham, and G. Seegmuller, editors, </editor> <booktitle> Operating Systems, An Advanced Course, chapter 3.F, </booktitle> <pages> pages 393-481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: The user interacts with the transaction manager, which in turn uses the data managers and a stable storage object to implement transactions. The transaction manager acts as the coordinator of the system; it decides if and when a transaction is to be committed and coordinates the two-phase commit protocol <ref> [Gra79] </ref> that is used to ensure that all data managers involved agree on the outcome of the transaction. Associated with the transaction manager is a stable storage object, which it uses to log the progress of transactions in the system.
Reference: [Gra86] <author> James N. Gray. </author> <title> An approach to decentralized computer systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(6):684-692, </volume> <month> June </month> <year> 1986. </year>
Reference-contexts: Another area has been the development of programming paradigms, which simplify the development of certain types of fault-tolerant distributed programs by providing canonical organization techniques and abstractions. Examples of popular programming paradigms include the object/action model <ref> [Gra86] </ref>, the restartable action paradigm [Lam81], and the replicated state machine approach [Sch90]. In this paper, we focus on a third area related to simplifying the construction of fault-tolerant distributed programs, that of providing adequate programming language support.
Reference: [Hoa78] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: Moreover, the development of such a multi-paradigm language for fault-tolerant programming can be viewed as analogous to the evolution of standard distributed programming languages, which have progressed from languages such as CSP <ref> [Hoa78] </ref> and Concurrent Pascal [BH75] that support only a single synchronization paradigm to those such as SR, Dislang [LL81], Pascal-FC [BD88], and StarMod [Coo80] that support multiple approaches. This paper is organized as follows.
Reference: [HP91] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Here, we concentrate on processors with fail-silent semanticsthat is, where the only failures are assumed to be a complete cessation of execution activityalthough the approach generalizes to other failure models as well. The language has been implemented using the x-kernel, an operating system designed for experimenting with communication protocols <ref> [HP91] </ref>, and runs standalone on a network of Sun workstations. The orientation towards supporting multiple paradigms distinguishes FT-SR from other languages [Lis85, EFH82, LW85], language extensions [SCP91, CGR88, KU87] and language libraries [BSS91, Coo85, PS88, HW87] related to fault-tolerance, which are typically oriented around a particular paradigm. <p> It consists of 9600 lines of code and is implemented using version 3.1 of the x-kernel, a stand-alone operating system kernel that runs on Sun 3s <ref> [HP91] </ref>. The major advantage of such a bare machine implementation is that it gives us the ability to use FT-SR to build realistic fault-tolerant systems and experiment with these systems by actually crashing and restarting processors. This is in contrast to experimental systems built, for example, on top of Unix.
Reference: [HW87] <author> Maurice P. Herlihy and Jeannette M. Wing. </author> <title> Avalon: Language support for reliable distributed systems. </title> <booktitle> In Digest of Papers, The Seventeenth International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 89-94. </pages> <publisher> IEEE Computer Society, IEEE Computer Society Press, </publisher> <month> July </month> <year> 1987. </year>
Reference-contexts: The language has been implemented using the x-kernel, an operating system designed for experimenting with communication protocols [HP91], and runs standalone on a network of Sun workstations. The orientation towards supporting multiple paradigms distinguishes FT-SR from other languages [Lis85, EFH82, LW85], language extensions [SCP91, CGR88, KU87] and language libraries <ref> [BSS91, Coo85, PS88, HW87] </ref> related to fault-tolerance, which are typically oriented around a particular paradigm. Support for a single paradigm has been shown to be constraining in many situations [Bal91], and is particularly inappropriate for constructing systems, where different paradigms may be used at different levels of abstraction. <p> For example, languages like Argus [Lis85], Avalon <ref> [HW87] </ref>, Plits [EFH82], TABS [SDD + 85] and Hops [Mad86] support the object/action model, languages like Fault-Tolerant Concurrent C [CGR88] support the replicated state machine approach, and numerous operating systems like UNICOS [KK89] support the restartable action paradigm.
Reference: [KK89] <author> Brent A. Kingsbury and John T. Kline. </author> <title> Job and process recovery in a UNIX-based operating system. </title> <booktitle> In Proceedings of the 1989 Winter USENIX Technical Conference, </booktitle> <pages> pages 355-364, </pages> <year> 1989. </year>
Reference-contexts: For example, languages like Argus [Lis85], Avalon [HW87], Plits [EFH82], TABS [SDD + 85] and Hops [Mad86] support the object/action model, languages like Fault-Tolerant Concurrent C [CGR88] support the replicated state machine approach, and numerous operating systems like UNICOS <ref> [KK89] </ref> support the restartable action paradigm. To illustrate how the different programming paradigms are typically supported, we describe a representative example from each category: Fault-Tolerant Concurrent C, UNICOS and Argus. Fault-Tolerant Concurrent C.
Reference: [KTHB89] <author> M. Frans Kaashoek, Andrew S. Tanenbaum, Susan Flynn Hummel, and Henri E. Bal. </author> <title> An efficient reliable broadcast protocol. </title> <journal> Operating Systems Review, </journal> <volume> 23(4) </volume> <pages> 5-19, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: For replication, the most interesting aspect of the implementation is managing group communication, since messages sent to a resource group as a result of invocations have to be multicast and delivered to all replicas in a consistent total order. The technique we use is similar to <ref> [CM84, KTHB89, GMS89] </ref>, where one of the replicas is a primary through which all messages are funneled. Another max sf replicas are designated as primary-group members, with the remaining being considered ordinary members.
Reference: [KU87] <author> John C. Knight and John I. A. Urquhart. </author> <title> On the implementation and use of Ada on fault-tolerant distributed systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(5):553-563, </volume> <month> May </month> <year> 1987. </year>
Reference-contexts: The language has been implemented using the x-kernel, an operating system designed for experimenting with communication protocols [HP91], and runs standalone on a network of Sun workstations. The orientation towards supporting multiple paradigms distinguishes FT-SR from other languages [Lis85, EFH82, LW85], language extensions <ref> [SCP91, CGR88, KU87] </ref> and language libraries [BSS91, Coo85, PS88, HW87] related to fault-tolerance, which are typically oriented around a particular paradigm.
Reference: [Lam81] <author> Butler W. Lampson. </author> <title> Atomic transactions. </title> <editor> In B.W. Lampson, M. Paul, and H.J. Seigert, editors, </editor> <booktitle> Distributed SystemsArchitecture and Implementation, chapter 11, </booktitle> <pages> pages 246-265. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year> <note> Originally vol. 105 of Lecture Notes in Computer Science. </note>
Reference-contexts: Another area has been the development of programming paradigms, which simplify the development of certain types of fault-tolerant distributed programs by providing canonical organization techniques and abstractions. Examples of popular programming paradigms include the object/action model [Gra86], the restartable action paradigm <ref> [Lam81] </ref>, and the replicated state machine approach [Sch90]. In this paper, we focus on a third area related to simplifying the construction of fault-tolerant distributed programs, that of providing adequate programming language support. <p> When invoked, an operation exported by an FS atomic object normally executes as an atomic action that is both unitaryall or nothing despite failuresand serializableexecuted relative to other atomic actions such that the result is equivalent to some serial schedule <ref> [Lam81] </ref>. However, as is always the case with fault-tolerance, these properties can only be approximated by an implementation; that is, they can be only guaranteed relative to some set of assumptions concerning the number and type of failures. <p> For example, an FS atomic object implementing the services of a transaction manager may use the operations exported by another FS atomic object implementing the abstraction of stable storage <ref> [Lam81] </ref>. These dependencies can be defined more formally using the depends relation given in [Cri91]. In particular, an FS atomic object u is said to depend on another object v if the correctness of u's behavior depends on the correctness of v's behavior. <p> Idempotent actions are actions that can be restarted if interrupted by failure without the need to restore the initial state; for example, writing to stable storage can be implemented in this way using an intentions list <ref> [Lam81] </ref>.
Reference: [Lap91] <author> Jean-Claude Laprie. </author> <title> Dependability: Basic Concepts and Terminology, volume 4 of Dependable Computing and Fault-Tolerant Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [Lis85] <author> Barbara Liskov. </author> <title> The Argus language and system. </title> <editor> In M. Paul and H.J. Siegert, editors, </editor> <title> Distributed Systems: Methods and Tools for Specification, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 190, chapter 7, </volume> <pages> pages 343-430. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: The language has been implemented using the x-kernel, an operating system designed for experimenting with communication protocols [HP91], and runs standalone on a network of Sun workstations. The orientation towards supporting multiple paradigms distinguishes FT-SR from other languages <ref> [Lis85, EFH82, LW85] </ref>, language extensions [SCP91, CGR88, KU87] and language libraries [BSS91, Coo85, PS88, HW87] related to fault-tolerance, which are typically oriented around a particular paradigm. <p> An action is both unitary and serializable, which guarantees the atomicity of its execution with respect to both failures and the concurrent execution of other actions. These properties have also been called totality and serializability [Wei89], and recoverability and indivisibility <ref> [Lis85] </ref>. In the database literature, atomic actions are known as transactions [BHG87]. A system built using the object/action paradigm may be implemented using FS atomic objects. Objects in the system correspond to FS atomic objects. <p> For example, languages like Argus <ref> [Lis85] </ref>, Avalon [HW87], Plits [EFH82], TABS [SDD + 85] and Hops [Mad86] support the object/action model, languages like Fault-Tolerant Concurrent C [CGR88] support the replicated state machine approach, and numerous operating systems like UNICOS [KK89] support the restartable action paradigm.
Reference: [LL81] <author> C.-M. Li and M.T. Liu. Dislang: </author> <title> A distributed programming language/system. </title> <booktitle> In Proceedings of the 2nd International Conference on Distributed Computing Systems, </booktitle> <pages> pages 162-172, </pages> <year> 1981. </year>
Reference-contexts: Moreover, the development of such a multi-paradigm language for fault-tolerant programming can be viewed as analogous to the evolution of standard distributed programming languages, which have progressed from languages such as CSP [Hoa78] and Concurrent Pascal [BH75] that support only a single synchronization paradigm to those such as SR, Dislang <ref> [LL81] </ref>, Pascal-FC [BD88], and StarMod [Coo80] that support multiple approaches. This paper is organized as follows. In Section 2, we first describe fail-stop atomic objects and the programming model that results from considering these as the primary abstraction.
Reference: [LSP82] <author> Leslie Lamport, Robert Shostak, and Marshall Pease. </author> <title> The Byzantine generals problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 382-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: For instance, failure models have been developed as a means for precisely specifying assumptions made about the possible effect of failures. Examples of popular failure models include fail-stop [SS83], timing [Cri91], fail-silent [PVB + 88], and Byzantine <ref> [LSP82] </ref>. Another area has been the development of programming paradigms, which simplify the development of certain types of fault-tolerant distributed programs by providing canonical organization techniques and abstractions. Examples of popular programming paradigms include the object/action model [Gra86], the restartable action paradigm [Lam81], and the replicated state machine approach [Sch90].
Reference: [LW85] <author> Richard J. LeBlanc and C. Thomas Wilkes. </author> <title> Systems programming with objects and actions. </title> <booktitle> In The 5th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 132-139, </pages> <address> Denver, Colorado, </address> <month> May </month> <year> 1985. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: The language has been implemented using the x-kernel, an operating system designed for experimenting with communication protocols [HP91], and runs standalone on a network of Sun workstations. The orientation towards supporting multiple paradigms distinguishes FT-SR from other languages <ref> [Lis85, EFH82, LW85] </ref>, language extensions [SCP91, CGR88, KU87] and language libraries [BSS91, Coo85, PS88, HW87] related to fault-tolerance, which are typically oriented around a particular paradigm.
Reference: [Mad86] <author> Hari Madduri. </author> <title> Fault-tolerant distributed computing. </title> <booktitle> Scientific Honeyweller, Winter 1986-87:1-10, </booktitle> <year> 1986. </year>
Reference-contexts: For example, languages like Argus [Lis85], Avalon [HW87], Plits [EFH82], TABS [SDD + 85] and Hops <ref> [Mad86] </ref> support the object/action model, languages like Fault-Tolerant Concurrent C [CGR88] support the replicated state machine approach, and numerous operating systems like UNICOS [KK89] support the restartable action paradigm.
Reference: [MS92] <author> Shivakant Mishra and Richard D. Schlichting. </author> <title> Abstractions for constructing dependable distributed systems. </title> <type> Technical Report TR 92-19, </type> <institution> Department of Computer Science, University of Arizona, </institution> <address> Tucson, AZ 85721, </address> <year> 1992. </year>
Reference-contexts: The relationship between the abstractions used for a particular paradigm and the mechanisms provided by FT-SR can be illustrated by arranging them in a hierarchy based on the dependency relationship <ref> [MS92] </ref>. Figure 9 shows such a hierarchy for the object/action model. In this figure, the circles represent abstractions, the rectangles represent mechanisms provided by FT-SR, and the labeled boxes at the bottom represent the portions of the FT-SR runtime system that implement these language mechanisms.
Reference: [MSMA90] <author> P.M. Melliar-Smith, Louise E. Moser, and Vivek Agrawala. </author> <title> Broadcast protocols for distributed systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 17-25, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The combination of the atomicity and consistent ordering properties means that an invocation using a resource group capability is equivalent to an atomic broadcast <ref> [CAS85, MSMA90] </ref>. The results of a multicast call invocation are collected by the runtime system, with only a single result being returned to the caller; since FT-SR assumes processors with fail-silent semantics, returning the first result is sufficient in this case.
Reference: [PS88] <author> Fabio Panzieri and Santosh K. Shrivastava. Rajdoot: </author> <title> A remote procedure call mechanism supporting orphan detection and killing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(1) </volume> <pages> 30-37, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: The language has been implemented using the x-kernel, an operating system designed for experimenting with communication protocols [HP91], and runs standalone on a network of Sun workstations. The orientation towards supporting multiple paradigms distinguishes FT-SR from other languages [Lis85, EFH82, LW85], language extensions [SCP91, CGR88, KU87] and language libraries <ref> [BSS91, Coo85, PS88, HW87] </ref> related to fault-tolerance, which are typically oriented around a particular paradigm. Support for a single paradigm has been shown to be constraining in many situations [Bal91], and is particularly inappropriate for constructing systems, where different paradigms may be used at different levels of abstraction.
Reference: [PVB + 88] <author> D. Powell, P. Verissimo, G. Bonn, F. Waeselynck, and D. Seaton. </author> <title> The Delta-4 approach to dependability in open distributed computing systems. </title> <booktitle> In Digest of Papers, The Eighteenth International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 246-251, </pages> <month> June </month> <year> 1988. </year> <month> 21 </month>
Reference-contexts: For instance, failure models have been developed as a means for precisely specifying assumptions made about the possible effect of failures. Examples of popular failure models include fail-stop [SS83], timing [Cri91], fail-silent <ref> [PVB + 88] </ref>, and Byzantine [LSP82]. Another area has been the development of programming paradigms, which simplify the development of certain types of fault-tolerant distributed programs by providing canonical organization techniques and abstractions.
Reference: [Sch90] <author> Fred B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Another area has been the development of programming paradigms, which simplify the development of certain types of fault-tolerant distributed programs by providing canonical organization techniques and abstractions. Examples of popular programming paradigms include the object/action model [Gra86], the restartable action paradigm [Lam81], and the replicated state machine approach <ref> [Sch90] </ref>. In this paper, we focus on a third area related to simplifying the construction of fault-tolerant distributed programs, that of providing adequate programming language support.
Reference: [SCP91] <author> Richard D. Schlichting, Flaviu Cristian, and Titus D. M. Purdin. </author> <title> A linguistic approach to failure-handling in distributed systems. </title> <editor> In Algirdas Avi zienis and Jean-Claude Laprie, editors, </editor> <booktitle> Dependable Computing and Fault-Tolerant Systems, </booktitle> <volume> Vol. 4: </volume> <booktitle> Dependable Computing for Critical Applications, </booktitle> <pages> pages 387-409. </pages> <publisher> Springer-Verlag, </publisher> <address> Wien and New York, </address> <year> 1991. </year>
Reference-contexts: The language has been implemented using the x-kernel, an operating system designed for experimenting with communication protocols [HP91], and runs standalone on a network of Sun workstations. The orientation towards supporting multiple paradigms distinguishes FT-SR from other languages [Lis85, EFH82, LW85], language extensions <ref> [SCP91, CGR88, KU87] </ref> and language libraries [BSS91, Coo85, PS88, HW87] related to fault-tolerance, which are typically oriented around a particular paradigm. <p> To this end, the language has provisions for encapsulation based on SR resources, resource replication, recovery protocols, synchronous failure notification when performing interprocess communication, and a mechanism for asynchronous failure notification based on a previous scheme for SR <ref> [SCP91] </ref>. <p> cap: : : monitor client cap send rel lock (client cap, lock id) return lock id [] rel lock (client cap, lock id) -&gt; : : : release lock if held by client cap: : : monitorend client cap return ni end lock server end lock manager 7 of contexts <ref> [CGR88, SCP91, BMZ92] </ref> and is in keeping with the inherently asynchronous nature of failures themselves. 3.2 Higher-Level FS Atomic Objects FT-SR provides mechanisms for supporting the construction of more fault-tolerant, higher-level FS atomic objects using replication, and for increasing the resilience of objects to failures using recovery techniques.
Reference: [SDD + 85] <author> Alfred Z. Spector, Dean Daniels, Daniel Duchamp, Jeffrey L. Eppinger, and Randy Pausch. </author> <title> Distributed transactions for reliable systems. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 127-146, </pages> <year> 1985. </year>
Reference-contexts: For example, languages like Argus [Lis85], Avalon [HW87], Plits [EFH82], TABS <ref> [SDD + 85] </ref> and Hops [Mad86] support the object/action model, languages like Fault-Tolerant Concurrent C [CGR88] support the replicated state machine approach, and numerous operating systems like UNICOS [KK89] support the restartable action paradigm.
Reference: [SS83] <author> Richard D. Schlichting and Fred B. Schneider. </author> <title> Fail-stop processors: An approach to designing fault-tolerant computing systems. </title> <journal> IEEE Transactions on Computing Systems, </journal> <volume> 1(3) </volume> <pages> 222-238, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: For instance, failure models have been developed as a means for precisely specifying assumptions made about the possible effect of failures. Examples of popular failure models include fail-stop <ref> [SS83] </ref>, timing [Cri91], fail-silent [PVB + 88], and Byzantine [LSP82]. Another area has been the development of programming paradigms, which simplify the development of certain types of fault-tolerant distributed programs by providing canonical organization techniques and abstractions.
Reference: [Wei89] <author> William E. Weihl. </author> <title> Using transactions in distributed applications. </title> <editor> In Sape Mullender, editor, </editor> <booktitle> Distributed Systems, </booktitle> <pages> pages 215-235. </pages> <publisher> Addison-Wesley Publishing Company, ACM Press, </publisher> <address> New York, New York, </address> <year> 1989. </year> <month> 22 </month>
Reference-contexts: An action is both unitary and serializable, which guarantees the atomicity of its execution with respect to both failures and the concurrent execution of other actions. These properties have also been called totality and serializability <ref> [Wei89] </ref>, and recoverability and indivisibility [Lis85]. In the database literature, atomic actions are known as transactions [BHG87]. A system built using the object/action paradigm may be implemented using FS atomic objects. Objects in the system correspond to FS atomic objects.
References-found: 42

