URL: ftp://ftp.cc.gatech.edu/pub/people/bill/papers/fb-hardware.ps
Refering-URL: http://www.cs.gatech.edu/people/home/bill/
Root-URL: 
Title: Future Branches Beyond Speculative Execution  
Author: Bill Appelbe, Reid Harmon, Maurizio Vitale, and Sri Doddapaneni -Phil May and Scott Wills 
Address: Atlanta, GA 30332  
Affiliation: College of Computing  School of Electrical and Computer Engineering Georgia Institute of Technology,  
Abstract: The performance and hardware complexity of superscalar architectures is hindered by conditional branch instructions. When conditional branches are encountered in a program, the instruction fetch unit must rapidly predict the branch predicate and begin speculatively fetching instructions with no loss of instruction throughput. Speculative execution increases hardware cost, since speculative instructions must be cleanly aborted if the branch is mis-predicted. Speculative execution also does not scale well for increasingly superscalar architectures, since mis-prediction probabilities and penalties grow as more branches are encountered. The future branch is an additional instruction that helps overcome the performance bottleneck of conditional branches. A future branch separates the specification of a impending branch (and the conditional predicate) from the actual branch location. The future branch instruction includes a branch source address (the location of the impending conditional branch) in addition to the branch target. It begins computing the branch predicate immediately, prior to the branch source address being reached. If a future branch is scheduled early enough, the branch predicate can be resolved before the actual branch is encountered, thus avoiding speculative execution. This papers includes a detailed hardware design and cost evaluation for an implementation of the future branch for the Power PC 604. In addition, we describe the compiler algorithms and technology needed to generate future branch instructions. Further, we provide preliminary results, using a micro-architecture simulator, showing the performance gains obtained by using future branches.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bill Appelbe, Reid Harmon, Phil May, Scott Wills, and Maurizio Vitale. </author> <title> Hoisting branch conditions improving super-scalar processor performance. </title> <booktitle> In Eighth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <year> 1995. </year>
Reference-contexts: The branch condition may need to be hoisted to more than one place if there is more than one path to the branch source. The complete compiler algorithms we have developed for hoisting branch conditions are given in <ref> [1] </ref>. We are basing our implementation of a compiler to generate future branch instructions upon gcc. Our reason for doing so is the support that gcc provides for targeting almost all commercial microprocessors (including the DLX). Using gcc gives us portability should we obtain a commercial micro-architecture simulator.
Reference: 2. <author> Sreeram Duvvuru and Siamak Arya. </author> <title> Evaluation of a Branch Target Address Cache. </title>
Reference-contexts: 1 Introduction Studies have shown that from 22% to 1.6% of instruction executed are branches or conditional branches <ref> [2] </ref>, with most non-scientific programs much closer to 22%. A branch instruction interrupts the instruction pipeline unless the branch target address is known before the branch instruction is decoded, and the direction of a conditional branch is known.
Reference: 3. <author> J. Hennessy, N. Jouppi, F. Baskett, and J. Gill. </author> <title> MIPS: A VLSI Processor Architecture. </title> <booktitle> In Proceedings of the Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> page 191, </pages> <month> October </month> <year> 1991. </year> <title> need to look up complete reference. </title>
Reference-contexts: Another approach that has been used to improve performance of branches is the use of delay slots: instructions after a branch that are always executed. Early RISC processors used one delay slot <ref> [3] </ref>, but more recent processors have made less use of them for the following reasons: 1. Superscalar processors without speculative execution would need many delay slots to keep the instruction pipeline full. 2. It is difficult to consistently fill delay slots with useful work.
Reference: 4. <author> John L. Hennessy and David A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, California, </address> <year> 1990. </year>
Reference-contexts: Superscalar processors without speculative execution would need many delay slots to keep the instruction pipeline full. 2. It is difficult to consistently fill delay slots with useful work. Typical percentages are 50% are TeX, 45% for Spice, and 48% for gcc <ref> [4] </ref>. Some instruction sets contain specialized loop branch instructions [5] that can be executed faster, or whose outcome can be predicted on a previous iteration, but these have limited applicability. Nevertheless, the idea of moving the branch decision earlier in the code stream is a good one. <p> We anticipate that code generation for future branches will be available fairly soon. We have obtained a reconfigurable superscalar micro-architecture simulator, called SuperDLX, from McGill University, and have extended it to support future branch instructions. SuperDLX is a superscalar simulator for the DLX architecture <ref> [4] </ref>, which incorporates features such as: reconfigurable units and cycle times for fetch, decode, and execute sophisticated branch prediction and speculative execution We have extended the SuperDLX architecture and implementation in several ways, primarily by including support for future branches.
Reference: 5. <author> S. Peter Song and Marvin Denman. </author> <title> The PowerPC 604 Microprocessor. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 8-17, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: A branch instruction interrupts the instruction pipeline unless the branch target address is known before the branch instruction is decoded, and the direction of a conditional branch is known. Branch caches enable the branch target address to be determined with fairly high probability at a modest hardware cost <ref> [5] </ref>. By contrast, determining the direction of a conditional branch is far more difficult. The most common technique is speculative execution, in which the direction of the branch is predicted either statically (a bit in the branch instruction) or dynamically (using a cache of previous branch directions). <p> However, this comes at a high hardware cost for speculative execution and recoverer when branches are incorrectly predicted. Studies of the prediction accuracy of processors with sophisticated dynamic branch prediction show prediction accuracy of around 90% (e.g., Ultra SPARC [8]: SPECint 88%, SPECfloat 94% [8]; Power 620 <ref> [5] </ref>: SPEC composite 90% [7]). Aside from its high hardware cost and imprecision, another fundamental problem with speculative execution is that it does not scale well with increasingly superscalar processors. To determine this, we modeled superscalar processors with no resource conflicts and synthetic benchmarks with no data dependencies. <p> It is difficult to consistently fill delay slots with useful work. Typical percentages are 50% are TeX, 45% for Spice, and 48% for gcc [4]. Some instruction sets contain specialized loop branch instructions <ref> [5] </ref> that can be executed faster, or whose outcome can be predicted on a previous iteration, but these have limited applicability. Nevertheless, the idea of moving the branch decision earlier in the code stream is a good one. <p> This includes all the hardware needed to implement the Future Branch, cache and the additional hardware in the pipeline stages. We estimate that these transistors would occupy 6.5 mm 2 using a .5 micron process. As a comparison, we used data on the Power PC 604 die <ref> [5] </ref> size (approximately 196 mm 2 , our future branch implementation would amount to 3.3% of the existing 604 die area.
Reference: 6. <author> Mark R. Thistle and Burton J. Smith. </author> <title> "a processor architecture for horizon". </title> <booktitle> In Proceedings of Supercomputer '88, </booktitle> <pages> pages 35-41, </pages> <year> 1988. </year>
Reference-contexts: Looked at another way, a branch with a variable number of delay slots must be in the same basic block as the original branch. However, in practice, basic blocks are far too short to make this practical. Another related idea is the Horizon <ref> [6] </ref> project: encoding in each instruction the number of subsequent instructions which are independent of the results of this instruction. Like future branches, the Horizon project relies upon compiler technology to determine data dependencies.
Reference: 7. <author> Tom Thompson and Bob Ryan. </author> <title> PowerPC 620 Soars. </title> <journal> BYTE, </journal> <pages> pages 113-120, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Studies of the prediction accuracy of processors with sophisticated dynamic branch prediction show prediction accuracy of around 90% (e.g., Ultra SPARC [8]: SPECint 88%, SPECfloat 94% [8]; Power 620 [5]: SPEC composite 90% <ref> [7] </ref>). Aside from its high hardware cost and imprecision, another fundamental problem with speculative execution is that it does not scale well with increasingly superscalar processors. To determine this, we modeled superscalar processors with no resource conflicts and synthetic benchmarks with no data dependencies.
Reference: 8. <author> Peter Wayner. </author> <title> SPARC Strikes Back. </title> <journal> BYTE, </journal> <pages> pages 105-112, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: However, this comes at a high hardware cost for speculative execution and recoverer when branches are incorrectly predicted. Studies of the prediction accuracy of processors with sophisticated dynamic branch prediction show prediction accuracy of around 90% (e.g., Ultra SPARC <ref> [8] </ref>: SPECint 88%, SPECfloat 94% [8]; Power 620 [5]: SPEC composite 90% [7]). Aside from its high hardware cost and imprecision, another fundamental problem with speculative execution is that it does not scale well with increasingly superscalar processors. <p> However, this comes at a high hardware cost for speculative execution and recoverer when branches are incorrectly predicted. Studies of the prediction accuracy of processors with sophisticated dynamic branch prediction show prediction accuracy of around 90% (e.g., Ultra SPARC <ref> [8] </ref>: SPECint 88%, SPECfloat 94% [8]; Power 620 [5]: SPEC composite 90% [7]). Aside from its high hardware cost and imprecision, another fundamental problem with speculative execution is that it does not scale well with increasingly superscalar processors.
References-found: 8

