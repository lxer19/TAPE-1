URL: ftp://cse.ogi.edu/pub/tech-reports/1996/96-001.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Email: fegaras@cse.ogi.edu  
Title: Fusion for Free! OGI, Tech-report #96-001  
Author: Leonidas Fegaras 
Date: January 9, 1996  
Address: 20000 N.W. Walker Road P.O. Box 91000 Portland, OR 97291-1000  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Abstract: Program fusion techniques have long been proposed as an effective means of improving program performance and of eliminating unnecessary intermediate data structures. This paper proposes a new approach on program fusion that is based entirely on the type signatures of programs. First, for each function, a recursive skeleton is extracted that captures its pattern of recursion. Then, the parametricity theorem of this skeleton is derived, which provides a rule for fusing this function with any function. This method generalizes other approaches that use fixed parametricity theorems to fuse programs.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Burstall and J. Darlington. </author> <title> A Transformation System for Developing Recursive Programs. </title> <journal> Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: The parametricity theorem for this type with ff = () is: 8f fi ; f; f 0 ; g : f fi ffi (f g) = f 0 (f fi ffi g) ) f fi ffi (Y f ) = Y f 0 (2) which is actually the unfold-simplify-fold law <ref> [1] </ref>. 3 Expressing the Parametricity Theorem using Bifunctors A bifunctor is a generalization of a functor. In contrast to regular functors, bifunctors can capture types with contravariant type variables [3].
Reference: [2] <author> W. Chin. </author> <title> Safe Fusion of Functional Expressions. </title> <booktitle> Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <address> San Francisco, California, </address> <pages> pp 11-20, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction There is much work recently on using higher-order operators, such as fold [9] and build [6, 5], to automate program fusion <ref> [2] </ref> and deforestation [11]. Even though these methods do a good job on fusing programs, they are only effective if programs are expressed in terms of these operators. This limits their applicability to conventional functional languages.
Reference: [3] <author> L. Fegaras and T. Sheard. </author> <title> Revisiting Catamorphisms over Datatypes with Embedded Functions. </title> <booktitle> In 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year> <note> To Appear. </note>
Reference-contexts: In contrast to regular functors, bifunctors can capture types with contravariant type variables <ref> [3] </ref>. Definition 1 (Bifunctor) Let 8ff 1 ; : : : ; a n : t be a type and let f = f 1 ; : : : ; f n and g = g 1 ; : : : ; g n .
Reference: [4] <author> L. Fegaras, T. Sheard, and T. Zhou. </author> <title> Improving Programs which Recurse over Multiple Inductive Structures. </title> <booktitle> In ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> Orlando, Florida, </address> <pages> pp 21-32, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: This results into an asymmetry: the fold fusion law can only be used for fusing one argument only. An alternative, symmetric, definition of zip is given elsewhere <ref> [4] </ref> but it requires a more general traversal scheme than fold. 8 len (zip (x,y)) = len ( zip'( (a,b,r). (a,b):r, (). [ ] )(x,y) ) = zip'( c', (). 0 )(x,y) The premise of the zip' fusion law gives us a value for c': c'(x,y,len z) = len (c (x,y,z))
Reference: [5] <author> A. Gill, J. Launchbury, and S. Peyton Jones. </author> <title> A Short Cut to Deforestation. </title> <booktitle> Sixth Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pp 223-232, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction There is much work recently on using higher-order operators, such as fold [9] and build <ref> [6, 5] </ref>, to automate program fusion [2] and deforestation [11]. Even though these methods do a good job on fusing programs, they are only effective if programs are expressed in terms of these operators. This limits their applicability to conventional functional languages.
Reference: [6] <author> J. Launchbury and T. Sheard. </author> <title> Warm Fusion. </title> <booktitle> Seventh Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> La Jolla, California, </address> <pages> pp 314-323, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: 1 Introduction There is much work recently on using higher-order operators, such as fold [9] and build <ref> [6, 5] </ref>, to automate program fusion [2] and deforestation [11]. Even though these methods do a good job on fusing programs, they are only effective if programs are expressed in terms of these operators. This limits their applicability to conventional functional languages. <p> Even though these methods do a good job on fusing programs, they are only effective if programs are expressed in terms of these operators. This limits their applicability to conventional functional languages. To ameliorate this problem, some researchers proposed methods to translate regular functional programs into folds <ref> [6] </ref>. These methods had a moderate success so far, and only for simple functions. The main reason for using these higher-order operators is that they satisfy some powerful theorems, which facilitate program optimization. But there is nothing special about these theorems. <p> Unfortunately, not all functions can be expressed as folds. Even though there are methods for translating a number of recursive functions into folds <ref> [6] </ref>, these methods usually fail for complex functions. One solution to this problem is to use a list traversal scheme that is more flexible and maybe more expressive than fold. Some researchers have suggested hylomorphisms as a possible solution [7].
Reference: [7] <author> E. Meijer, M. Fokkinga, and R. Paterson. </author> <title> Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire. </title> <booktitle> In Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, Massachusetts, </address> <pages> pp 124-144. </pages> <publisher> Springer-Verlag, LNCS 523, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: One solution to this problem is to use a list traversal scheme that is more flexible and maybe more expressive than fold. Some researchers have suggested hylomorphisms as a possible solution <ref> [7] </ref>. It remains an open issue of how easy it is to translate functions into hylomorphisms.
Reference: [8] <author> S. Peyton Jones and J. Launchbury. </author> <title> Unboxed Values as First Class Citizens in a Non-strict Functional Language. </title> <booktitle> Fifth Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, MA, </address> <pages> pp 636-665, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Function zip can be computed in terms of zip': zip = zip'( (a,b,r). (a,b):r, (). [ ] ) In a way, zip' is a worker and the above definition of zip is a wrapper <ref> [8] </ref>.
Reference: [9] <author> T. Sheard and L. Fegaras. </author> <title> A Fold for All Seasons. </title> <booktitle> Sixth Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pp 233-242, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction There is much work recently on using higher-order operators, such as fold <ref> [9] </ref> and build [6, 5], to automate program fusion [2] and deforestation [11]. Even though these methods do a good job on fusing programs, they are only effective if programs are expressed in terms of these operators. This limits their applicability to conventional functional languages. <p> we set f ff = id, where id = x:x, we get: 8f fi ; x; y : x (f fi y) = f fi (x y) ) fold () (f fi x) y = f fi (fold () x y) (1) which is the fusion law for list fold <ref> [9] </ref>. Binding the function f ff , which corresponds to the type variable ff, to id is something that we will do often in this paper. <p> This is quite useful because we know that fold satisfies a powerful parametricity theorem (Eq. 1). In fact, we have shown elsewhere <ref> [9] </ref> that there is an automated method for fusing a function composed with a fold. Suppose, for example that we want to fuse len (inc x), where len computes the length of a list, so that the intermediate list produced by inc and consumed by len is eliminated. <p> The only things that need to be computed are the g 0 i functions. In a previous work <ref> [9] </ref>, we describe a method for solving a similar set of equations for fusing folds. <p> Then, INV (h) b is defined to be one of these a i . The method described in <ref> [9] </ref> and also used in this paper, does not actually derive a function INV (h) from h. It only assumes that such function exists and uses the property h ffi INV (h) = id to eliminate it.
Reference: [10] <editor> P. Wadler. </editor> <booktitle> Theorems for Free! Fourth Conference on Functional Programming Languages and Computer Architecture, </booktitle> <institution> Imperial College, </institution> <address> London, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: These methods had a moderate success so far, and only for simple functions. The main reason for using these higher-order operators is that they satisfy some powerful theorems, which facilitate program optimization. But there is nothing special about these theorems. They are parametricity theorems <ref> [10] </ref> that are derived exclusively from the types of these operators. Any function satisfies a parametricity theorem. The difference is that most functions are not sufficiently polymorphic and, thus, their parametricity theorems are usually trivial. This paper proposes a new approach on fusing programs. <p> We also believe that it can be useful for proving equational theorems about functions. 2 Background: The Parametricity Theorem Any function f of type t satisfies a parametricity theorem (also called theorem for free <ref> [10] </ref>), which is derived directly from the type t . For first-order functions, this theorem states that any polymorphic function is a natural transformation. <p> in some way the elements of the nested list, then the type of flat would not be the polymorphic type given above. (We assume that all functions are strict here, as they would be if they were defined in a non-lazy language.) The proof of this theorem comes directly from <ref> [10] </ref>): Theorem 1 (Parametricity Theorem) Any expression e : t satisfies P [[t ]](e; e) , where: P [[basic]](r; s) ! r = s P [[ff]](r; s) ! r = (ff)(s) P [[t 1 fi t 2 ]](r; s) ! P [[t 1 ]]( 1 (r); 1 (s)) ^ P [[t
Reference: [11] <author> P. Wadler. </author> <title> Deforestation: Transforming Programs to Eliminate Trees. </title> <booktitle> Proceedings of the 2nd European Symposium on Programming, Nancy, France, </booktitle> <pages> pp 344-358, </pages> <month> March </month> <year> 1988. </year> <month> 16 </month>
Reference-contexts: 1 Introduction There is much work recently on using higher-order operators, such as fold [9] and build [6, 5], to automate program fusion [2] and deforestation <ref> [11] </ref>. Even though these methods do a good job on fusing programs, they are only effective if programs are expressed in terms of these operators. This limits their applicability to conventional functional languages. To ameliorate this problem, some researchers proposed methods to translate regular functional programs into folds [6].
References-found: 11

