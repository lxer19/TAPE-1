URL: http://www.cs.wisc.edu/~shatdal/papers/apads93.ps
Refering-URL: http://www.cs.wisc.edu/~shatdal/shatdal.html
Root-URL: 
Title: Join Query Optimization in Parallel Database Systems  
Author: Anant Jhingran Sriram Padmanabhan Ambuj Shatdal 
Address: Yorktown Heights, NY 10598 Yorktown Heights, NY 10598  
Affiliation: IBM T. J. Watson Research Center IBM T. J. Watson Research Center Computer Sciences Department  University of Wisconsin-Madison  
Abstract: In this paper we present a new framework for studying parallel query optimization. We first note that scheduling and optimization must go together in a parallel environment. We introduce the concept of response time envelopes which integrates scheduling and optimization. We show that it can be used effectively to develop parallel query optimization algorithms which have same order of complexity as the traditional sequential query optimization algorithms and produce provably optimal or near optimal join plans. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ming-Syan Chen, Philip S. Yu, and Kun-Lung Wu. </author> <title> Scheduling and processor allocation for parallel execution of multi-join queries. </title> <booktitle> In 8th Int'l Conference on Data Engineering, </booktitle> <pages> pages 58-67, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: Recognizing this complexity, past work on this topic has focused on finding heuristic algorithms [2, 7], or on outlining a general algorithm with high complexity [3]. Also, there has been work on scheduling and processor allocation of query tasks assuming a optimal query plan has already been generated <ref> [1] </ref>. Yu et al [9] review some aspects of parallel query processing but have not studied the optimization problem in detail. Lanzelotte et al [5] have studied some trade-offs in cost of optimization and the quality of plans obtained in a parallel environment. <p> In other words, we build in the scheduling into our optimization phase to get optimal response time solutions. This is in contrast with a two-step approach (optimization followed by scheduling the optimal plan) <ref> [1, 7] </ref> which unfortunately does not yield to optimal solutions. We make several assumptions that simplify our presentation somewhat. Most of these are either not very restrictive, or relatively easy to relax.
Reference: [2] <author> Ming-Syan Chen, Philip S. Yu, and Kun-Lung Wu. </author> <title> Optimization of parallel execution for multi-join queries. </title> <type> Internal Report, </type> <year> 1993. </year>
Reference-contexts: Thus, the complexity of the query optimization problem is harder in a parallel RDBMS than in a single-site RDBMS, which is already an NP-Hard problem. Recognizing this complexity, past work on this topic has focused on finding heuristic algorithms <ref> [2, 7] </ref>, or on outlining a general algorithm with high complexity [3]. Also, there has been work on scheduling and processor allocation of query tasks assuming a optimal query plan has already been generated [1]. <p> In parallel environments, conventional wisdom says that DP is too expensive [3] and hence a lot of researchers have gone straight onto heuristic algorithms, mostly based on some kind of greedy approach <ref> [2] </ref>. The question we attempt to answer is: Is it possible to extend the DP approach to optimize parallel queries? And if so, then how? Ganguly et al [3] show that, in general, the ability to prune the search space decreases in the parallel environment.
Reference: [3] <author> Sumit Ganguly, Waqar Hasan, and Ravi Krishna-murthy. </author> <title> Query optimization for parallel execution. </title> <booktitle> In 1992 ACM SIGMOD Conference, </booktitle> <pages> pages 9-18, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Query optimization in single-site Relational Database Management Systems (RDBMS) is a well studied problem <ref> [8, 3] </ref>. <p> Recognizing this complexity, past work on this topic has focused on finding heuristic algorithms [2, 7], or on outlining a general algorithm with high complexity <ref> [3] </ref>. Also, there has been work on scheduling and processor allocation of query tasks assuming a optimal query plan has already been generated [1]. Yu et al [9] review some aspects of parallel query processing but have not studied the optimization problem in detail. <p> This can be relaxed by keeping a set of plans for every plan that we keep. In the exposition below, we also ignore the other interesting orders <ref> [3] </ref> that even a serial optimizer has to keep. Both these multiply the complexity by only a constant number, and hence are not pertinent to the discussion below. <p> In parallel environments, conventional wisdom says that DP is too expensive <ref> [3] </ref> and hence a lot of researchers have gone straight onto heuristic algorithms, mostly based on some kind of greedy approach [2]. The question we attempt to answer is: Is it possible to extend the DP approach to optimize parallel queries? And if so, then how? Ganguly et al [3] show <p> expensive <ref> [3] </ref> and hence a lot of researchers have gone straight onto heuristic algorithms, mostly based on some kind of greedy approach [2]. The question we attempt to answer is: Is it possible to extend the DP approach to optimize parallel queries? And if so, then how? Ganguly et al [3] show that, in general, the ability to prune the search space decreases in the parallel environment. We show that in some cases, that is not necessarily so and that we can use efficient, single-site like, DP algorithm. <p> For other join methods and strategies, see [4] for details. The algorithm 3.1 shows the dynamic programming outline. Except for initialization in steps 1-4 and step 10 which involves the scheduling of the join, the steps are identical to the single-site left deep query optimization <ref> [3] </ref>.
Reference: [4] <author> Anant Jhingran, Sriram Padmanabhan, and Ambuj Shatdal. </author> <title> Query optimization for parallel database systems. </title> <note> In Preparation, </note> <year> 1993. </year>
Reference-contexts: This assumption is easy to relax (see <ref> [4] </ref> for further details). Thus a single step in our query optimization step is the following: When we decide to schedule a join J , we figure out what the resource consumption of that join is. We also figure out when is the earliest that the join can be scheduled. <p> On each node of N j , the inner stream is merged, the outer stream is merged, and a merge-sort join between the two streams is then performed. For other join methods and strategies, see <ref> [4] </ref> for details. The algorithm 3.1 shows the dynamic programming outline. Except for initialization in steps 1-4 and step 10 which involves the scheduling of the join, the steps are identical to the single-site left deep query optimization [3]. <p> But this error is bounded. Theorem 3.3 The solution obtained by basic bushy DP will be at most n1 2 times as expensive as the opti mal (bushy) solution where n is the number of relation. Proof: In full paper <ref> [4] </ref>. 2 4 Conclusion and Future Work Query optimization in a Shared-Nothing parallel Relational DBMS is a hard problem.
Reference: [5] <author> Rosana S.G. Lanzelotte, Patrick Valduriez, and Mo-hamed Zait. </author> <title> On the effectiveness of optimization search strategies for parallel execution spaces. </title> <booktitle> In 19th VLDB Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Also, there has been work on scheduling and processor allocation of query tasks assuming a optimal query plan has already been generated [1]. Yu et al [9] review some aspects of parallel query processing but have not studied the optimization problem in detail. Lanzelotte et al <ref> [5] </ref> have studied some trade-offs in cost of optimization and the quality of plans obtained in a parallel environment.
Reference: [6] <author> Lothar F. Mackert and Guy M. Lohman. </author> <title> R* optimizer validation and performance evaluation for distributed queries. </title> <booktitle> In 12th VLDB Conference, </booktitle> <year> 1986. </year>
Reference-contexts: We make a simplifying assumption here that by increasing the degree of parallelism, we only decrease the response time and do not 1 In some distributed environments <ref> [6] </ref>, weighted message costs are added to the overall costs in order to evaluate a plan. change the resource consumption. This assumption is easy to relax (see [4] for further details).
Reference: [7] <author> Donovan A. Schneider. </author> <title> Complex Query Processing in Multiprocessor Database Machines. </title> <type> PhD thesis, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1990. </year>
Reference-contexts: Thus, the complexity of the query optimization problem is harder in a parallel RDBMS than in a single-site RDBMS, which is already an NP-Hard problem. Recognizing this complexity, past work on this topic has focused on finding heuristic algorithms <ref> [2, 7] </ref>, or on outlining a general algorithm with high complexity [3]. Also, there has been work on scheduling and processor allocation of query tasks assuming a optimal query plan has already been generated [1]. <p> In other words, we build in the scheduling into our optimization phase to get optimal response time solutions. This is in contrast with a two-step approach (optimization followed by scheduling the optimal plan) <ref> [1, 7] </ref> which unfortunately does not yield to optimal solutions. We make several assumptions that simplify our presentation somewhat. Most of these are either not very restrictive, or relatively easy to relax.
Reference: [8] <author> Pat Selinger, M. M. Astrhan, D. D. Chamberlin, R. A. Lorie, and T. G. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In 1979 ACM SIGMOD Conference, </booktitle> <year> 1979. </year>
Reference-contexts: 1 Introduction Query optimization in single-site Relational Database Management Systems (RDBMS) is a well studied problem <ref> [8, 3] </ref>. <p> The join order can be represented by a binary join tree, which may be of several types such as left-deep, bushy, or right-deep. Since there are an exponential number of binary join trees for n relations, finding the optimal join order is a hard problem. Selinger et al <ref> [8] </ref> have described a Dynamic Programming (DP) algorithm for finding the optimal left-deep join order plan based on the total cost (I/O and CPU utilization costs) of the query. <p> This search space must be pruned in order to make efficient optimization feasible. The approach presented in System R <ref> [8] </ref>, prunes this search space by limiting the search space to left deep trees and by using DP with the observation that once i relations have been joined, how they were joined is irrelevant to any future join.
Reference: [9] <author> Philip S. Yu, Ming-Syan Chen, Joel L. Wolf, and John J. Turek. </author> <title> Parallel query processing. </title> <type> Research Report RC 18903, </type> <institution> IBM T. J. Watson Research Center, </institution> <year> 1993. </year>
Reference-contexts: Also, there has been work on scheduling and processor allocation of query tasks assuming a optimal query plan has already been generated [1]. Yu et al <ref> [9] </ref> review some aspects of parallel query processing but have not studied the optimization problem in detail. Lanzelotte et al [5] have studied some trade-offs in cost of optimization and the quality of plans obtained in a parallel environment.
References-found: 9

