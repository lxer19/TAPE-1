URL: http://www.cs.utexas.edu/users/lorenzo/papers/tr98-572.ps
Refering-URL: 
Root-URL: 
Email: kbhatia@cs.ucsd.edu  marzullo@cs.ucsd.edu  lorenzo@cs.utexas.edu  
Title: The Relative Overhead of Piggybacking in Causal Message Logging Protocols  
Author: Karan Bhatia Keith Marzullo Lorenzo Alvisi 
Affiliation: University of California, San Diego Dept. of Computer Science and Eng.  University of California, San Diego Dept. of Computer Science and Eng.  University of Texas, Austin Dept. of Computer Sciences  
Abstract: In order to restore crashed processes to a consistent state, message logging protocols ensure that these processes, when recovering, make the same choices when re-executing nondeterministic events. Causal message logging protocols ensure this by piggybacking the results of these choices (called determinants) on the ambient message traffic. By doing so, causal message logging protocols do not create orphan processes nor introduce reliability-generated blocking in failure-free runs of a distributed program. Family-based logging is a set of causal message logging protocols. These protocols use different techniques to determine when a determinant should be piggybacked on an application message. Given an application's pattern of communication, however, it is not obvious which family-based logging protocol is more efficient. In this paper, we examine the efficiency of family-based logging protocols under different application and environmental assumptions. This paper contains approximately 5,000 words. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Lorenzo Alvisi, Bruce Hoppe, and Keith Marzullo. </author> <title> Nonblocking and orphan-free message logging protocols. </title> <booktitle> In Proceedings of the 23rd Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 145-154, </pages> <address> Toulouse, France, </address> <month> August </month> <year> 1993. </year> <month> 17 </month>
Reference-contexts: Message logging protocols save information about received messages so that when a process crashes, it can be restarted from a checkpoint, re-sent the same sequence of messages it had previously received after the checkpoint, and have any regenerated messages captured and discarded. Examples of message logging protocols include <ref> [1, 5, 7, 9, 10, 12, 15, 16, 17] </ref> A difficulty in message logging protocols is avoiding the creation of orphan processes. Orphan processes are correct processes whose state is inconsistent with the recovered state of a crashed process. <p> We generate different communications patterns within this parameter space and compare the relative performance of the causal message logging protocols as a function of the coordinates in this space. The communications model we use is similar to other models that have been proposed (for example, <ref> [1, 6, 14] </ref>). The model posits n processes communicating through point-to-point messages. Messages are given to some underlying communication system that is reliable and enforces FIFO order.
Reference: [2] <author> L. Alvisi and K. Marzullo. </author> <title> Message Logging: Pessimistic, Optimistic, Causal and Opti--mal. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> February </month> <year> 1998, </year> <note> to appear. </note>
Reference: [3] <author> L. Alvisi. </author> <title> Understanding the Message Logging Paradigm for Masking Process Crashes. </title> <type> PhD thesis, </type> <institution> Cornell University Department of Computer Science, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: Family-based logging (FBL) is a family of causal message logging protocols that use different techniques for computing Log p (m) and jLog (m)j p . The five FBL protocols presented in <ref> [3, 4] </ref> differ in how accurately they compute Log p (m) and jLog (m)j p . They also differ in the amount of information they piggyback on messages: roughly speaking, the more information that is piggybacked, the more accurate the estimates are. <p> This matrix is a vector of vector clocks [13] based on receive sequence numbers, and therefore encodes exactly Log (m) restricted to the causal past of p. Further details of protcols P 1 through P 5 can be found in <ref> [3, 4] </ref>. Table 1 summarizes the piggybacking overhead of the six family-based logging protocols. In this table, W is the number of bits needed to represent a "word" that can hold an entry in the stability matrix, a component of a vector clock, a send sequence number, and so on.
Reference: [4] <author> L. Alvisi and K. Marzullo. </author> <title> Tradeoffs in implementing optimal message logging protocols. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 58-67. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: Family-based logging (FBL) is a family of causal message logging protocols that use different techniques for computing Log p (m) and jLog (m)j p . The five FBL protocols presented in <ref> [3, 4] </ref> differ in how accurately they compute Log p (m) and jLog (m)j p . They also differ in the amount of information they piggyback on messages: roughly speaking, the more information that is piggybacked, the more accurate the estimates are. <p> We consider all the family-based protocols described in <ref> [4] </ref> after making a few small modifications in order to remove some obvious inefficiencies. 3 We also consider two other protocols: a new family-based logging protocol that proves to be efficient in part of the space that we examine, and Manetho [7], a causal message logging protocol that is built explicitly <p> This matrix is a vector of vector clocks [13] based on receive sequence numbers, and therefore encodes exactly Log (m) restricted to the causal past of p. Further details of protcols P 1 through P 5 can be found in <ref> [3, 4] </ref>. Table 1 summarizes the piggybacking overhead of the six family-based logging protocols. In this table, W is the number of bits needed to represent a "word" that can hold an entry in the stability matrix, a component of a vector clock, a send sequence number, and so on.
Reference: [5] <author> Anita Borg, J. Baumbach, and S. Glazer. </author> <title> A message system supporting fault tolerance. </title> <booktitle> In Proceedings of the Symposium on Operating Systems Principles, </booktitle> <pages> pages 90-99. </pages> <publisher> ACM SIGOPS, </publisher> <month> October </month> <year> 1983. </year>
Reference-contexts: Message logging protocols save information about received messages so that when a process crashes, it can be restarted from a checkpoint, re-sent the same sequence of messages it had previously received after the checkpoint, and have any regenerated messages captured and discarded. Examples of message logging protocols include <ref> [1, 5, 7, 9, 10, 12, 15, 16, 17] </ref> A difficulty in message logging protocols is avoiding the creation of orphan processes. Orphan processes are correct processes whose state is inconsistent with the recovered state of a crashed process.
Reference: [6] <author> S. Chodnekar, V. Srinivasan, A. S. Vaidya, A. Sivasubramaniam, and C. R. Das. </author> <title> Towards a communications characterization methodology for parallel applications. </title> <booktitle> In Proceedings Third International Symposium on High-Performance Compuoptcentraljzter Architecture, </booktitle> <pages> pages 310-319, </pages> <address> San Antonio, TX, </address> <month> February </month> <year> 1997. </year>
Reference-contexts: We generate different communications patterns within this parameter space and compare the relative performance of the causal message logging protocols as a function of the coordinates in this space. The communications model we use is similar to other models that have been proposed (for example, <ref> [1, 6, 14] </ref>). The model posits n processes communicating through point-to-point messages. Messages are given to some underlying communication system that is reliable and enforces FIFO order.
Reference: [7] <author> E. N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(5) </volume> <pages> 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Message logging protocols save information about received messages so that when a process crashes, it can be restarted from a checkpoint, re-sent the same sequence of messages it had previously received after the checkpoint, and have any regenerated messages captured and discarded. Examples of message logging protocols include <ref> [1, 5, 7, 9, 10, 12, 15, 16, 17] </ref> A difficulty in message logging protocols is avoiding the creation of orphan processes. Orphan processes are correct processes whose state is inconsistent with the recovered state of a crashed process. <p> We consider all the family-based protocols described in [4] after making a few small modifications in order to remove some obvious inefficiencies. 3 We also consider two other protocols: a new family-based logging protocol that proves to be efficient in part of the space that we examine, and Manetho <ref> [7] </ref>, a causal message logging protocol that is built explicitly for the case in which total failures are possible. The paper is organized as follows. Section 2 reviews the system model and the family-based message logging protocols we consider in this paper. <p> Table 1 summarizes the piggybacking overhead of the six family-based logging protocols. In this table, W is the number of bits needed to represent a "word" that can hold an entry in the stability matrix, a component of a vector clock, a send sequence number, and so on. Manetho <ref> [7] </ref> is a variation of protocol P 1 . Manetho assumes that total failures are possible, which means that a message is stable only when its determinant is logged in every process' volatile memory.
Reference: [8] <author> E.N. Elnozahy. </author> <title> Private correspondence, </title> <month> 12 September </month> <year> 1997. </year>
Reference-contexts: In Manetho, a process piggybacks #m on a message m 0 to q when p has a copy of #m and q 62 Log p (m). Process p computes Log p (m) as in P 1 and no additional information is piggybacked on messages <ref> [8] </ref>. 5 protocol per determinant per message information bits information bits 1 #m 2 log (n) + 2W 2 f#m; jLog (m)j p g 2 log (n) + 2W + log (f ) 3 f#m; Log p (m)g 2 log (n) + 2W + n 4 #m 2 log (n) +
Reference: [9] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Sender-based message logging. </title> <booktitle> In Digest of Papers: 17 Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 14-19. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Message logging protocols save information about received messages so that when a process crashes, it can be restarted from a checkpoint, re-sent the same sequence of messages it had previously received after the checkpoint, and have any regenerated messages captured and discarded. Examples of message logging protocols include <ref> [1, 5, 7, 9, 10, 12, 15, 16, 17] </ref> A difficulty in message logging protocols is avoiding the creation of orphan processes. Orphan processes are correct processes whose state is inconsistent with the recovered state of a crashed process.
Reference: [10] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Recovery in distributed systems using optimistic message logging and checkpointing. </title> <journal> Journal of Algorithms, </journal> <volume> 11 </volume> <pages> 462-491, </pages> <year> 1990. </year>
Reference-contexts: Message logging protocols save information about received messages so that when a process crashes, it can be restarted from a checkpoint, re-sent the same sequence of messages it had previously received after the checkpoint, and have any regenerated messages captured and discarded. Examples of message logging protocols include <ref> [1, 5, 7, 9, 10, 12, 15, 16, 17] </ref> A difficulty in message logging protocols is avoiding the creation of orphan processes. Orphan processes are correct processes whose state is inconsistent with the recovered state of a crashed process.
Reference: [11] <author> G. Perlman and F. L. Horan. </author> <title> Report on the UNIX/STAT release 5.1: Data analysis programs for UNIX and MSDOS. </title> <booktitle> In Proceedings of the Fifteenth Annual Meeting of the Society for Computers in Psychology, </booktitle> <pages> pages 168-176, </pages> <address> Boston, MA, </address> <month> 21 November </month> <year> 1985. </year>
Reference-contexts: We conclude that the value of the extra few bits is well worth their price. For further examination, we therefore only concentrate on protocols P 2 , P 3 , and P 6 . 4.2 Regression Analysis Using the UnixStat <ref> [11] </ref> statistics package, we performed regression analysis on the remaining protocols to determine the effects of different factors on the total communication overhead. The results are summarized in Table 5.
Reference: [12] <author> M.L. Powell and D.L. Presotto. </author> <title> Publishing: A reliable broadcast communication mechanism. </title> <booktitle> In Proceedings of the Ninth Symposium on Operating System Principles, </booktitle> <pages> pages 100-109. </pages> <publisher> ACM SIGOPS, </publisher> <month> October </month> <year> 1983. </year> <month> 18 </month>
Reference-contexts: Message logging protocols save information about received messages so that when a process crashes, it can be restarted from a checkpoint, re-sent the same sequence of messages it had previously received after the checkpoint, and have any regenerated messages captured and discarded. Examples of message logging protocols include <ref> [1, 5, 7, 9, 10, 12, 15, 16, 17] </ref> A difficulty in message logging protocols is avoiding the creation of orphan processes. Orphan processes are correct processes whose state is inconsistent with the recovered state of a crashed process.
Reference: [13] <author> R. Schwarz and F. Mattern. </author> <title> Detecting causal relationships in distributed computations: In search of the holy grail. </title> <booktitle> Distributed Computing 7(3) </booktitle> <pages> 149-174, </pages> <year> 1994. </year>
Reference-contexts: Protocol P 6 , a novel causal protocol, differs from P 4 in that it only sends the n-word stability vector. Finally, protocol P 5 extends P 3 by piggybacking a dependency matrix of size n fi n. This matrix is a vector of vector clocks <ref> [13] </ref> based on receive sequence numbers, and therefore encodes exactly Log (m) restricted to the causal past of p. Further details of protcols P 1 through P 5 can be found in [3, 4]. Table 1 summarizes the piggybacking overhead of the six family-based logging protocols.
Reference: [14] <author> J. P. Singh, E. Rothberg, and A. Gupta. </author> <title> Modelling communications in parallel algorithms: </title> <booktitle> A fruitful interaction between theory and systems? In Proceedings of the Sixth ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 189-199, </pages> <address> Cape May, NJ, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: We generate different communications patterns within this parameter space and compare the relative performance of the causal message logging protocols as a function of the coordinates in this space. The communications model we use is similar to other models that have been proposed (for example, <ref> [1, 6, 14] </ref>). The model posits n processes communicating through point-to-point messages. Messages are given to some underlying communication system that is reliable and enforces FIFO order.
Reference: [15] <author> A.P. Sistla and J.L. Welch. </author> <title> Efficient distributed recovery using message logging. </title> <booktitle> In Proceedings of the Eighth Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 223-238. </pages> <publisher> ACM SIGACT/SIGOPS, </publisher> <month> August </month> <year> 1989. </year>
Reference-contexts: Message logging protocols save information about received messages so that when a process crashes, it can be restarted from a checkpoint, re-sent the same sequence of messages it had previously received after the checkpoint, and have any regenerated messages captured and discarded. Examples of message logging protocols include <ref> [1, 5, 7, 9, 10, 12, 15, 16, 17] </ref> A difficulty in message logging protocols is avoiding the creation of orphan processes. Orphan processes are correct processes whose state is inconsistent with the recovered state of a crashed process.
Reference: [16] <author> R. E. Strom, D. F. Bacon, and S. A. Yemini. </author> <title> Volatile logging in n-fault-tolerant distributed systems. </title> <booktitle> In Proceedings of the Eighteenth Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 44-49, </pages> <year> 1988. </year>
Reference-contexts: Message logging protocols save information about received messages so that when a process crashes, it can be restarted from a checkpoint, re-sent the same sequence of messages it had previously received after the checkpoint, and have any regenerated messages captured and discarded. Examples of message logging protocols include <ref> [1, 5, 7, 9, 10, 12, 15, 16, 17] </ref> A difficulty in message logging protocols is avoiding the creation of orphan processes. Orphan processes are correct processes whose state is inconsistent with the recovered state of a crashed process.
Reference: [17] <author> R. B. Strom and S. Yemeni. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> April </month> <year> 1985. </year> <month> 19 </month>
Reference-contexts: Message logging protocols save information about received messages so that when a process crashes, it can be restarted from a checkpoint, re-sent the same sequence of messages it had previously received after the checkpoint, and have any regenerated messages captured and discarded. Examples of message logging protocols include <ref> [1, 5, 7, 9, 10, 12, 15, 16, 17] </ref> A difficulty in message logging protocols is avoiding the creation of orphan processes. Orphan processes are correct processes whose state is inconsistent with the recovered state of a crashed process.
References-found: 17

