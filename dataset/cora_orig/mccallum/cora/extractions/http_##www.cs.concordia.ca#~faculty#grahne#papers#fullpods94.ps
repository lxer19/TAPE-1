URL: http://www.cs.concordia.ca/~faculty/grahne/papers/fullpods94.ps
Refering-URL: http://www.cs.concordia.ca/~faculty/grahne/papers/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fGosta.Grahne,Matti.Nykanen,Esko.Ukkoneng@cs.helsinki.fi  
Title: Reasoning about Strings in Databases  
Author: Gosta Grahne Matti Nykanen Esko Ukkonen 
Address: P.O. Box 26, FIN-00014 University of Helsinki, Finland  
Affiliation: Department of Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. Collado-Vides. </author> <title> The search for a grammatical theory of gene regulation is formally justified by showing the inadequacy of context-free grammars. </title> <booktitle> Computer Applications in the Biosciences, </booktitle> <volume> 7(3) </volume> <pages> 321-326, </pages> <year> 1991. </year>
Reference-contexts: For instance, the theory of gene regulation explores the combinatorial or grammatical structure inherent in genetic sequences, as opposed to their statistical properties. This structure can be quite complex, since gene regulation involves non-context-free dependencies between different parts of a string <ref> [1] </ref>. These dependencies should be explicitly expressible, as they constitute knowledge about the family of strings that the current database represents. Representing this kind of knowledge is in turn becoming increasingly important when operational models of genetic phenomena [14] are being sought. <p> List all tuples of R 2 that are of the form (a + b) fl , and whose second half is a translation of the first half obtained by replacing each a by b, and each b by a. This type of problem occurs for example in <ref> [1] </ref>. xj9y; z: R 2 (x)^([x; y] l x = y) fl :([y] l y = ?):([x; z] l x = z) fl :([z] l z = ?) The formula states that x is of the form yz where z is the translation of y. <p> The query asks for the strings that are a concatenation of a string from db (R 1 ) and another string from db (R 3 ), as was mentioned before. Its translation to Alignment Algebra is literally E = <ref> [1] </ref> [1;2] ((R 1 Z hf1gi fi R 3 Z hf1gi) Z hf1g ; f2gi fi which can be simplified into [1] A ( fl fi R 1 fi R 3 ). Note how fl is needed in the algebraic expression to implement the generation of these new strings. <p> Its translation to Alignment Algebra is literally E = <ref> [1] </ref> [1;2] ((R 1 Z hf1gi fi R 3 Z hf1gi) Z hf1g ; f2gi fi which can be simplified into [1] A ( fl fi R 1 fi R 3 ). Note how fl is needed in the algebraic expression to implement the generation of these new strings. <p> The function W (db) = max (R 1 ; db)+max (R 3 ; db), where `max' was defined in Eq. (2), is evidently a limit function for this query. Therefore given any database db it is sufficient to evaluate db (e W (db)) = db ( <ref> [1] </ref> A ( max (R 1 ;db)+max (R 3 ;db) fi R 1 fi R 3 )) to yield the correct result, and this is indeed a finitary operation. 4 Safety Analysis In the previous section we assumed that the alignment formulae were semantically safe.
Reference: [2] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 16, </booktitle> <pages> pages 994-1072. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: fi Z! such that for all i 2 N there exists a contiguous interval K A i 2 Zfor which A (i; j) = a for some a 2 if j 2 K A i undefined otherwise. 2 abc cacd abc cacd abc cacd abc cacd [0] l [0] l <ref> [0 ; 2 ] </ref> r We further require either that K A i = ; (denoting the empty string ") or that K A i " f1; 0; 1g 6= ; so that the window column 0 is always at either end or in the middle of the defined area. <p> The inner level of string formulae only deals with aligning given sequences to each other via character comparisons, the outer level of relational calculus only deals with sequences as indivisible entities. This is in contrast with conventional First-Order Linear Temporal Logic <ref> [2, Chapter 3.3] </ref> where modalities, connectives and quantifiers are allowed to mix freely. Note that the truth definitions 1-9 do not depend on a particular database. <p> In that approach, computability is attained via explicit recursion, while in ours it surfaces as a by-product of an expressive language for describing string relations. The following result follows from the fact that extended temporal logic has the expressive power of regular expressions <ref> [2, Theorem 6.5 and Chapter 6.6.1] </ref>. Theorem 5.3 Every set definable in extended temporal logic is definable in pure Alignment Calculus.
Reference: [3] <author> M. Escobar-Molano, R. Hull, and D. Jacobs. </author> <title> Safety and translation of calculus queries with scalar functions (extended abstract). </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 253-264, </pages> <year> 1993. </year>
Reference-contexts: The right transposes are denoted [i 1 ; : : : ; i k ] r and are defined similarly to the left ones, except that the rows mentioned in the expression are transposed one position to the right, instead of to the left (e.g. <ref> [3; 5] </ref> r A (3; j) = A (3; j 1), and [3; 5] r A (5; j) = A (5; j 1), and all the other rows remain unchanged). In Fig. 2 we show some transposes of the alignment in Fig. 1. <p> ; : : : ; i k ] r and are defined similarly to the left ones, except that the rows mentioned in the expression are transposed one position to the right, instead of to the left (e.g. <ref> [3; 5] </ref> r A (3; j) = A (3; j 1), and [3; 5] r A (5; j) = A (5; j 1), and all the other rows remain unchanged). In Fig. 2 we show some transposes of the alignment in Fig. 1. <p> safety, and limit functions W , of the embedded string formulae into the safety, and limit function W , of the whole Alignment Calculus query in which they appear, if we are to evaluate [[]] db in the manner put forth in Theorem 3.5; one such method was developed in <ref> [3] </ref>.
Reference: [4] <author> Z. Galil and J. Seiferas. </author> <title> Time-space optimal string matching. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 26 </volume> <pages> 280-294, </pages> <year> 1983. </year>
Reference-contexts: The components of our logic corresponding to the aforementioned acceptors are called string formulae. The string formulae as such have the same expressive power as the multitape two-way automata. This alone is enough for string matching <ref> [4] </ref>, among other things. The string formulae together with one projection operator yield the power of full Turing computability.
Reference: [5] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: The right transposes are denoted [i 1 ; : : : ; i k ] r and are defined similarly to the left ones, except that the rows mentioned in the expression are transposed one position to the right, instead of to the left (e.g. <ref> [3; 5] </ref> r A (3; j) = A (3; j 1), and [3; 5] r A (5; j) = A (5; j 1), and all the other rows remain unchanged). In Fig. 2 we show some transposes of the alignment in Fig. 1. <p> ; : : : ; i k ] r and are defined similarly to the left ones, except that the rows mentioned in the expression are transposed one position to the right, instead of to the left (e.g. <ref> [3; 5] </ref> r A (3; j) = A (3; j 1), and [3; 5] r A (5; j) = A (5; j 1), and all the other rows remain unchanged). In Fig. 2 we show some transposes of the alignment in Fig. 1. <p> For k = 1 this nonemptiness problem equals the acceptance problem for the "nondeterministic checking stack automata with an empty input" which is known to be PSPACE-complete <ref> [5, Problem AL5] </ref>.
Reference: [6] <author> S. Ginsburg and H. Spanier. </author> <title> Mappings of languages by two-tape devices. </title> <journal> Journal of the ACM, </journal> <volume> 12 </volume> <pages> 423-434, </pages> <year> 1965. </year>
Reference-contexts: We note that the programming paradigms underlying our Alignment Calculus and the logic Ginsburg and Wang propose are different. The basic string processing construct in sequence logic is the transducer mapping. Since regular sets are closed under transducer mappings <ref> [6] </ref>, computational power is obtained by resorting to features outside the string processing machinery, such as first order logic. In Alignment Calculus, on the other hand, full Turing computability is available already when using unquantified string formulae on three variables and a projection operator, as in Theorem 5.2.
Reference: [7] <author> S. Ginsburg and X. Wang. </author> <title> Pattern matching by rs-operations: Towards a unified approach to querying sequenced data (extended abstract). </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 293-300, </pages> <year> 1992. </year>
Reference-contexts: This partially solves the data extraction problem but does not support restructuring operations very well. On the other hand, one can add a restructuring operator, based for example on transducers <ref> [7, 15, 26] </ref>. This gives good data restructuring abilities, but the resulting data extraction features are often rather implicit. Then there is the declarative approach. The idea is to design a language for expressing properties of strings. <p> Hence, we try to determine the ways in which a given string acceptance device can be used safely as a string production device in this particular query, rather than forcing the database programmer to work with explicit string production devices as in <ref> [7, 15, 26] </ref>. (Related transducer problems have been studied by Weber [27, 28].) We defer, however, further discussion of the limitation problem to Section 4. In Fig. 6 we show an example of a string formula and a corresponding finite state acceptor drawn as a graph. <p> The safety concept of Ginsburg and Wang <ref> [7] </ref>, for example, falls short in this respect. <p> instead of the left ones in the list above, e.g. along x 1 ; : : : ; x k since df ([x 1 ; : : : ; x k ] r ) fl :([x 1 ; : : : ; x k ] r ): Ginsburg and Wang <ref> [7, 26] </ref> have proposed an extension of Relational Calculus for dealing with sequences or lists of items drawn from an infinite alphabet U of atomic constants (or atoms for brevity). For example, [Peter,Paul,Mary] is a sequence of atoms `Peter', `Paul', and `Mary'. Relations are in turn defined over these sequences. <p> In Alignment Calculus, on the other hand, full Turing computability is available already when using unquantified string formulae on three variables and a projection operator, as in Theorem 5.2. As pointed out by Ginsburg and Wang <ref> [7] </ref>, it is of course always possible to increase the expressive power of sequence logic by strengthening the language used to specify the transducers; this approach was taken by Mecca and Bonner [15] whose sequence manipulation symbols represent generalized transducers capable of invoking other transducers as subroutines.
Reference: [8] <author> R.R. Goldberg. </author> <title> Finite state automata from regular expression trees. </title> <journal> The Computer Journal, </journal> <volume> 36(7) </volume> <pages> 623-630, </pages> <year> 1993. </year>
Reference-contexts: This is the FSA version of the well-known technique for not generating "-transitions when converting a regular expression into a traditional Nondeterministic Finite Automaton (NFA) <ref> [8] </ref>. Note also that bypassing preserves Property (5). Property (3) can be enforced by removing every state without 12 p q r b 1 d 1 : : : b k d k incoming transitions except s. Atomic string formulae transposing right are handled similarly; details are omitted.
Reference: [9] <author> G. Grahne, M. Nykanen, and E. Ukkonen. </author> <title> Reasoning about strings in databases. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 303-312, </pages> <year> 1994. </year>
Reference-contexts: This alone is enough for string matching [4], among other things. The string formulae together with one projection operator yield the power of full Turing computability. An extended abstract of this work has been presented in <ref> [9] </ref>. 2 Alignment Calculus This section introduces formally Alignment Calculus, our logic for expressing string properties, and its interpretation as a string database query language. In the world of strings we distinguish as state an alignment of the strings.
Reference: [10] <author> C. Helgesen and P.R. Sibbald. </author> <title> PALM a pattern language for molecular biology. </title> <booktitle> In International Conference on Intelligent Systems in Molecular Biology, </booktitle> <pages> pages 172-180, </pages> <year> 1993. </year>
Reference-contexts: However, in applications such as the aforementioned gene regulation, the language needs to have expressive power beyond regular sets; such suggestions include <ref> [10, 21] </ref>. In addition to data extraction features, the string language needs also data restructuring constructs. <p> How should one build a database language having such features? From the literature we find the following types of proposals. On the one hand, one can add, say to relational algebra, a selection predicate <ref> [10, 16, 21] </ref> for testing membership in a set specified by, for instance, a regular expression. This partially solves the data extraction problem but does not support restructuring operations very well. On the other hand, one can add a restructuring operator, based for example on transducers [7, 15, 26].
Reference: [11] <author> J.E. Hopcroft and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The limitation problem is to determine the existence (and preferably even a method of computing the values) of f A given A, k and l. Intuitively the limitation problem is, "Consider A no longer an acceptor but a kind of a generalized Mealy machine <ref> [11, Chapter 2.7] </ref> with input tapes 1; : : : ; k, output tapes k + 1; : : : ; k + l, nodeterministic control and no requirement to consume input while producing output. <p> Proof: Let G = n 1 : : : a r 1 : : : b r o be an unrestricted grammar <ref> [11, Chapter 9.2] </ref> with start symbol S and ] a new separator not in G (or use a doubling technique to encode this extended alphabet into the original one). <p> In other words, we can safely disregard the unidirectional tapes of A to get a bidirectional 1-FSA which can naturally be reinterpreted as a two-way nondeterministic finite automaton with endmarkers A 0 <ref> [11, Chapter 2.6] </ref>. Then we can use an extension of the classical crossing sequence construction [11, Theorem 2.5 and Exercises 2.18-2.20] to get the corresponding nondeterministic finite automaton A 00 , and in this way eliminate the paths that make contradictory assumptions from A . <p> In other words, we can safely disregard the unidirectional tapes of A to get a bidirectional 1-FSA which can naturally be reinterpreted as a two-way nondeterministic finite automaton with endmarkers A 0 [11, Chapter 2.6]. Then we can use an extension of the classical crossing sequence construction <ref> [11, Theorem 2.5 and Exercises 2.18-2.20] </ref> to get the corresponding nondeterministic finite automaton A 00 , and in this way eliminate the paths that make contradictory assumptions from A . <p> This does not, however, suffice for PSPACE-completeness: the k-FSAs A arising from string formulae have a far more uniform structure than arbitrary k-FSAs A. Therefore we reduce the acceptance problem for Linear Bounded Automata (LBAs) <ref> [11, Chapter 9.3] </ref> to the truth of formulae : 9x 1 . (We essentially follow the construction of Theorem 4.1 for the Context-Sensitive Grammars (CSGs) [11, Chapter 9.3]. <p> Therefore we reduce the acceptance problem for Linear Bounded Automata (LBAs) <ref> [11, Chapter 9.3] </ref> to the truth of formulae : 9x 1 . (We essentially follow the construction of Theorem 4.1 for the Context-Sensitive Grammars (CSGs) [11, Chapter 9.3].
Reference: [12] <author> R. Hull and J. Su. </author> <title> Domain independence and the relational calculus (2nd revision). </title> <type> Technical Report 88-64, </type> <institution> University of Southern California, Computer Science Department, </institution> <month> November </month> <year> 1993. </year> <month> 43 </month>
Reference-contexts: This concept of (semantic) safety corresponds to the full semantics of Section 2 where quantification ranges over the entire fl , making it the Alignment Calculus counterpart for the (output-restricted) unlimited interpretation of the traditional relational calculus <ref> [12] </ref>. In our framework this definition is unrealistic, however. For example, the formula ! : 8x9y:(x = y) fl (x = ? ^ y 6= ?) states that there exist arbitrarily long strings. <p> In other words, the query ! itself adds an infinite set of constants into the active domain. This means that, although in the relational calculus one can use essentially any semantics for finite queries (with perhaps an exponential blowup in formula length) <ref> [12, Theorem 3.1] </ref>, this is no longer the case in Alignment Calculus. Hence, we 18 restrict ourselves to formulae whose validation needs only a finite amount of information, although we might not a priori know how much.
Reference: [13] <author> H.V. Jagadish, A.O. Mendelzon, and T. Milo. </author> <title> Similarity-based queries. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 36-45, </pages> <year> 1995. </year>
Reference-contexts: An insertion into x is taken into account by transposing only x, and a deletion from x by transposing only y. Edit distance is an example of a measure of similarity useful in sequence database queries <ref> [13, page 36] </ref>[21, Section 3]. Compared with the very general domain-independent framework studied in [13], Alignment Calculus lacks essentially a means to express numerical degrees of similarity, as witnessed by the fact that k is a constant and not a parameter in the query above. <p> Edit distance is an example of a measure of similarity useful in sequence database queries [13, page 36][21, Section 3]. Compared with the very general domain-independent framework studied in <ref> [13] </ref>, Alignment Calculus lacks essentially a means to express numerical degrees of similarity, as witnessed by the fact that k is a constant and not a parameter in the query above.
Reference: [14] <author> H.H. McAdams and L. Shapiro. </author> <title> Circuit simulation of genetic networks. </title> <journal> Science, </journal> <volume> 269 </volume> <pages> 650-656, </pages> <year> 1995. </year>
Reference-contexts: These dependencies should be explicitly expressible, as they constitute knowledge about the family of strings that the current database represents. Representing this kind of knowledge is in turn becoming increasingly important when operational models of genetic phenomena <ref> [14] </ref> are being sought. We extend the relational model to include finite strings over some finite alphabet as primary objects of information.
Reference: [15] <author> G. Mecca and A.J. Bonner. </author> <title> Sequences, Datalog and transducers. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 23-35, </pages> <year> 1995. </year>
Reference-contexts: This partially solves the data extraction problem but does not support restructuring operations very well. On the other hand, one can add a restructuring operator, based for example on transducers <ref> [7, 15, 26] </ref>. This gives good data restructuring abilities, but the resulting data extraction features are often rather implicit. Then there is the declarative approach. The idea is to design a language for expressing properties of strings. <p> Hence, we try to determine the ways in which a given string acceptance device can be used safely as a string production device in this particular query, rather than forcing the database programmer to work with explicit string production devices as in <ref> [7, 15, 26] </ref>. (Related transducer problems have been studied by Weber [27, 28].) We defer, however, further discussion of the limitation problem to Section 4. In Fig. 6 we show an example of a string formula and a corresponding finite state acceptor drawn as a graph. <p> Hence, the same effect can also be obtained with a conjunction like in Example 9 of Section 2 as well. 2 A different approach to computational aspects of sequence queries was taken in <ref> [15] </ref>, which extended classical Datalog [24, Chapter 3.2] with new interpreted function symbols for manipulating sequences. In that approach, computability is attained via explicit recursion, while in ours it surfaces as a by-product of an expressive language for describing string relations. <p> As pointed out by Ginsburg and Wang [7], it is of course always possible to increase the expressive power of sequence logic by strengthening the language used to specify the transducers; this approach was taken by Mecca and Bonner <ref> [15] </ref> whose sequence manipulation symbols represent generalized transducers capable of invoking other transducers as subroutines. However, in Alignment Calculus it is not necessary to go beyond regular expressions in the syntax of the string formulae, or to employ complex computational devices.
Reference: [16] <author> P. Pistor and R. Traunmuller. </author> <title> A database language for sets, lists and tables. </title> <journal> Information Systems, </journal> <volume> 11 </volume> <pages> 323-336, </pages> <year> 1986. </year>
Reference-contexts: How should one build a database language having such features? From the literature we find the following types of proposals. On the one hand, one can add, say to relational algebra, a selection predicate <ref> [10, 16, 21] </ref> for testing membership in a set specified by, for instance, a regular expression. This partially solves the data extraction problem but does not support restructuring operations very well. On the other hand, one can add a restructuring operator, based for example on transducers [7, 15, 26].
Reference: [17] <author> R. Ramakhrisnan, F. Bancilhon, and A. Silberschatz. </author> <title> Safety of recursive Horn clauses with infinite relations (extended abstract). </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 328-339, </pages> <year> 1987. </year>
Reference-contexts: In other words, we are interested in inferring the finiteness constraints : fx 1 ; : : : ; x k g ; fx k+1 ; : : : ; x k+l g proposed by Ramakrishnan et al <ref> [17] </ref>.
Reference: [18] <author> J. Richardson. </author> <title> Supporting lists in a data model (a timely approach). </title> <booktitle> In Very Large Data Bases Conference, </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: This gives good data restructuring abilities, but the resulting data extraction features are often rather implicit. Then there is the declarative approach. The idea is to design a language for expressing properties of strings. One such proposal can be found in <ref> [18] </ref>, which essentially suggests using the modalities of temporal logic for this purpose. Each successive position in a string is seen to be the timewise "next" instance of that string. The temporal modalities lend themselves naturally to reasoning about strings.
Reference: [19] <author> H. Rogers. </author> <title> Theory of Recursive Functions and Effective Computability. </title> <publisher> McGraw-Hill, </publisher> <year> 1967. </year>
Reference-contexts: As checking whether A accepts a given input hu; v; wi or not is decidable by Theorem 3.3, the search for such v and w for a given u is recursively enumerable. 2 Theorem 5.2 implies that the abstract definitional power of pure Alignment Calculus equals the Arithmetical Hierarchy <ref> [19, Chapter 14] </ref> (on strings instead of N). In fact, even a stronger version of Theorem 5.2 can be given, which also justifies the layered structure of our language.
Reference: [20] <author> D. Sankoff and J.B. Kruskal, </author> <title> editors. Time Warps, String Edits and Macromolecules: The Theory and Practice of Sequence Comparison. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Each step can consist of replacing one symbol by another, or of inserting or deleting a symbol, see for example <ref> [20] </ref>.) The formula requires that x and y must match character by character, except that in at most k places the characters need not match. A replacement can be allowed by relaxing the window formula x = y to &gt;.
Reference: [21] <author> D.B. </author> <title> Searls. String Variable Grammar: A logic grammar formalism for the biological language of DNA. </title> <journal> Journal of Logic Programming, </journal> <pages> pages 73-102, </pages> <year> 1995. </year>
Reference-contexts: However, in applications such as the aforementioned gene regulation, the language needs to have expressive power beyond regular sets; such suggestions include <ref> [10, 21] </ref>. In addition to data extraction features, the string language needs also data restructuring constructs. <p> How should one build a database language having such features? From the literature we find the following types of proposals. On the one hand, one can add, say to relational algebra, a selection predicate <ref> [10, 16, 21] </ref> for testing membership in a set specified by, for instance, a regular expression. This partially solves the data extraction problem but does not support restructuring operations very well. On the other hand, one can add a restructuring operator, based for example on transducers [7, 15, 26].
Reference: [22] <author> S. Sippu and E. Soisalon-Soininen. </author> <title> Parsing Theory, volume I: Languages and Parsing. </title> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Let now the states of the normalized A be numbered 1; : : : ; n so that the start state is assigned number 1 and the final one n (in addition, n 2). Following <ref> [22, Theorem 3.17] </ref> we define inductively the formulae E ijk to express the paths from state i to state j not going through any of the states k + 1; : : : ; n: initially E ij0 = t 1 + : : : + t a where t 1
Reference: [23] <author> L.J. Stockmeyer. </author> <title> The polynomial-time hierarchy. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 1-22, </pages> <year> 1977. </year>
Reference-contexts: However, in Alignment Calculus it is not necessary to go beyond regular expressions in the syntax of the string formulae, or to employ complex computational devices. We have also been able to obtain a correspondence between a subclass of pure Alignment Calculus and the polynomial-time hierarchy <ref> [23] </ref>. For this correspondence we need the class of quantifier limited formulae. <p> k m k Q 1 X 1 m 1 given as the input x 1 , where the propositional formula on X 1 1 ; : : : ; X k m k is in the proper normal form: conjunctive (CNF) if Q 1 = 9 and disjunctive (DNF) otherwise <ref> [23, The orem 4.1 (2)] </ref>.
Reference: [24] <author> J.D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, volume I. </title> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: It is also worth noting that we constructed here the natural join E 1 E <ref> [24, pp. 59-60] </ref> by considering the ordered free variables as column attributes (with the addition that we also ordered the columns of the result as well). <p> An important question is whether semantic safety can be syntactically determined. It is well known that safety is undecidable for purely relational formulae <ref> [24] </ref>. Thus there is no hope that safety would be decidable for alignment formulae. We shall, however, first look into the possibility of determining safety for string formulae alone, continuing the thread begun in Definition 3.1 above. <p> Hence, the same effect can also be obtained with a conjunction like in Example 9 of Section 2 as well. 2 A different approach to computational aspects of sequence queries was taken in [15], which extended classical Datalog <ref> [24, Chapter 3.2] </ref> with new interpreted function symbols for manipulating sequences. In that approach, computability is attained via explicit recursion, while in ours it surfaces as a by-product of an expressive language for describing string relations.
Reference: [25] <author> M. Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> In ACM Symposium on Theory of Computing, </booktitle> <pages> pages 137-145, </pages> <year> 1982. </year>
Reference-contexts: Furthermore, we assume for simplicity that x 1 is the only free variable. We then say that defines the language [[]]. By the data complexity <ref> [25] </ref> of a set defined by a formula we mean the complexity of the decision problem "w 2 [[]]?" measured as a function of jwj; expression complexity is in turn measured as a function of the length jj of (that is, the number of symbol occurrences in) the formula .
Reference: [26] <author> X. Wang. </author> <title> Pattern Matching by Rs-Operations: Towards a Unified Approach to Querying Sequenced Data. </title> <type> PhD thesis, </type> <institution> University of Southern Carolina, </institution> <year> 1992. </year>
Reference-contexts: This partially solves the data extraction problem but does not support restructuring operations very well. On the other hand, one can add a restructuring operator, based for example on transducers <ref> [7, 15, 26] </ref>. This gives good data restructuring abilities, but the resulting data extraction features are often rather implicit. Then there is the declarative approach. The idea is to design a language for expressing properties of strings. <p> Hence, we try to determine the ways in which a given string acceptance device can be used safely as a string production device in this particular query, rather than forcing the database programmer to work with explicit string production devices as in <ref> [7, 15, 26] </ref>. (Related transducer problems have been studied by Weber [27, 28].) We defer, however, further discussion of the limitation problem to Section 4. In Fig. 6 we show an example of a string formula and a corresponding finite state acceptor drawn as a graph. <p> instead of the left ones in the list above, e.g. along x 1 ; : : : ; x k since df ([x 1 ; : : : ; x k ] r ) fl :([x 1 ; : : : ; x k ] r ): Ginsburg and Wang <ref> [7, 26] </ref> have proposed an extension of Relational Calculus for dealing with sequences or lists of items drawn from an infinite alphabet U of atomic constants (or atoms for brevity). For example, [Peter,Paul,Mary] is a sequence of atoms `Peter', `Paul', and `Mary'. Relations are in turn defined over these sequences. <p> For example x 3 2 [[ff fl 2 ]](x 1 ; x 2 ) declares x 3 to be the concatenation of x 1 and x 2 . Details can be found in <ref> [26, Chapter 2.1] </ref>. To compare the power of sequence predicates in the infinite U and string formulae in the finite we choose a translation injection e: U ! fl mapping atoms to strings.
Reference: [27] <author> A. Weber. </author> <title> On the valuedness of finite transducers. </title> <journal> Acta Informatica, </journal> <volume> 27 </volume> <pages> 749-780, </pages> <year> 1990. </year>
Reference-contexts: to determine the ways in which a given string acceptance device can be used safely as a string production device in this particular query, rather than forcing the database programmer to work with explicit string production devices as in [7, 15, 26]. (Related transducer problems have been studied by Weber <ref> [27, 28] </ref>.) We defer, however, further discussion of the limitation problem to Section 4. In Fig. 6 we show an example of a string formula and a corresponding finite state acceptor drawn as a graph. The alphabet is for simplicity assumed to be fa; bg.
Reference: [28] <author> A. Weber. </author> <title> On the lengths of values in a finite transducer. </title> <journal> Acta Informatica, </journal> <volume> 29 </volume> <pages> 663-687, </pages> <year> 1992. </year>
Reference-contexts: to determine the ways in which a given string acceptance device can be used safely as a string production device in this particular query, rather than forcing the database programmer to work with explicit string production devices as in [7, 15, 26]. (Related transducer problems have been studied by Weber <ref> [27, 28] </ref>.) We defer, however, further discussion of the limitation problem to Section 4. In Fig. 6 we show an example of a string formula and a corresponding finite state acceptor drawn as a graph. The alphabet is for simplicity assumed to be fa; bg.
Reference: [29] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <journal> Information and Control, </journal> <volume> 56:72--99, </volume> <year> 1983. </year>
Reference-contexts: Each successive position in a string is seen to be the timewise "next" instance of that string. The temporal modalities lend themselves naturally to reasoning about strings. But as shown by Wolper <ref> [29] </ref>, using only the modalities next and until, the language cannot express that a property holds in every even position of the string. Using Wolper's extended temporal logic would be a step in the right direction.
References-found: 29

