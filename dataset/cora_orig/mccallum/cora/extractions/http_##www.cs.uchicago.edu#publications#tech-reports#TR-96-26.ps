URL: http://www.cs.uchicago.edu/publications/tech-reports/TR-96-26.ps
Refering-URL: http://cs-www.uchicago.edu/publications/tech-reports/
Root-URL: 
Title: Indistinguishability  
Author: Sophie Laplante John Rogers 
Date: December 4, 1996  
Affiliation: University of Chicago  DePaul University  
Abstract: In this paper, we introduce the formal definitions for indistinguishability, and prove some basic properties. Indistinguishability is compelling notion, and we illustrate this by showing that our framework provides a "dual" perspective on nondeterministic communication complexity. We do this by giving a tight upper and lower bound on nondeterministic communication complexity in terms of distinguisha bility.
Abstract-found: 1
Intro-found: 1
Reference: [BD87] <author> Book, R. V., and D.-Z. Du, </author> <title> "The Existence and Density of Generalized Complexity Cores," </title> <journal> Journal of the ACM , Vol. </journal> <volume> 34, No. 3, </volume> <month> July </month> <year> 1987, </year> <pages> pp. 718 - 730. </pages>
Reference-contexts: Introduction How hard is it to decide an instance of a language A? This question has always been at the center of complexity theory. Complexity cores, defined by Lynch [Ly75] and studied by several other authors <ref> [OS86, BD87, etc.] </ref> provided complexity theorists with a new angle: Are there particular instances which make a language hard to decide, independently of the algorithm chosen to solve it? Instance complexity was defined [OKSW94] and studied [BO94, FK95, K95] with a somewhat similar intention: quantifying the hardness of individual instances with
Reference: [BFS86] <author> Babai, L., P. Frankl, and J. Simon, </author> <title> "Complexity classes in communication complexity theory", </title> , <booktitle> 1986, </booktitle> <pages> pp. 337 - 347. </pages>
Reference-contexts: Babai, Frankl and Simon <ref> [BFS86] </ref> defined the analogue of the polynomial-time hierarchy for communication complexity. Several separation results are known for the first and second levels of the communication complexity hierarchy, but it is as yet unknown if the entire hierarchy is proper.
Reference: [BO94] <author> Buhrman, H., and P. Orponen, </author> <title> "Random Strings Make Hard Instances", </title> <booktitle> Proceedings, Structures in Complexity Theory, </booktitle> <year> 1994, </year> <pages> pp. 217 - 222 </pages>
Reference-contexts: Complexity cores, defined by Lynch [Ly75] and studied by several other authors [OS86, BD87, etc.] provided complexity theorists with a new angle: Are there particular instances which make a language hard to decide, independently of the algorithm chosen to solve it? Instance complexity was defined [OKSW94] and studied <ref> [BO94, FK95, K95] </ref> with a somewhat similar intention: quantifying the hardness of individual instances with respect to a set, independently of the algorithm chosen to solve it.
Reference: [FK95] <author> Fortnow, L., and M. Kummer, </author> <title> "Resource-bounded instance complexity", </title> <booktitle> Proceedings of the 12th Symposium on Theoretical Aspects of Computer Science, </booktitle> <publisher> LNCS, Springer, </publisher> <year> 1995. </year> <month> 9 </month>
Reference-contexts: Complexity cores, defined by Lynch [Ly75] and studied by several other authors [OS86, BD87, etc.] provided complexity theorists with a new angle: Are there particular instances which make a language hard to decide, independently of the algorithm chosen to solve it? Instance complexity was defined [OKSW94] and studied <ref> [BO94, FK95, K95] </ref> with a somewhat similar intention: quantifying the hardness of individual instances with respect to a set, independently of the algorithm chosen to solve it.
Reference: [K95] <author> Kummer, M., </author> <title> "Instance Complexity", </title> <booktitle> Proceedings of 10 Annual IEEE Conference on Structure in Complexity Theory, </booktitle> <year> 1995, </year> <pages> pp. 111 - 124. </pages>
Reference-contexts: Complexity cores, defined by Lynch [Ly75] and studied by several other authors [OS86, BD87, etc.] provided complexity theorists with a new angle: Are there particular instances which make a language hard to decide, independently of the algorithm chosen to solve it? Instance complexity was defined [OKSW94] and studied <ref> [BO94, FK95, K95] </ref> with a somewhat similar intention: quantifying the hardness of individual instances with respect to a set, independently of the algorithm chosen to solve it.
Reference: [LV93] <author> Li, M., and Vitanyi, P. </author> <year> (1993), </year> <title> "An Introduction to Kolmogorov Complexity and Applications", </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: When y = *, the empty string, we simply write C (x). Proposition 1.1 For every n, there is a string x of length n with C (x) n. A string x with this property is called incompressible. The reader is referred to the textbook by Li and Vitanyi <ref> [LV93] </ref> for further background on Kolmogorov complexity. 2 1.3 CD complexity In the context of time-bounded computation, it makes sense to make the distinction between programs that print out a string x and those that accept exactly the string x. <p> Proof: This is a standard argument, based on efficient simulation of multi-tape Turing machines by a two-tape Turing machine <ref> [LV93, page 378] </ref>. Let M 1 ; M 2 ; : : : be a standard enumeration of multitape Turing machines, and let 1 ; 2 ; : : : be the corresponding partial recursive functions.
Reference: [LS81] <author> Lipton, R., and R. Sedgewick, </author> <title> "Lower bounds for VLSI", </title> <booktitle> Proceeding of the 13 ACM Symposium on the Theory of Computing, </booktitle> <year> 1981, </year> <pages> pp. 300 - 307. </pages>
Reference-contexts: a lower bound on the communication complexity, and it is noteworthy that these bounds are tight in the sense that there are functions which meet the upper and lower bounds we provide. 5.1 Communication complexity model First we present the model of nondeterministic communication complexity, introduced by Lipton and Sedgewick <ref> [LS81] </ref>. We recommend the survey paper by Lovasz [Lo90] for more background on communication complexity. The setting is the following: 2 players, A and B, want to evaluate a boolean function f : f0; 1g n fi f0; 1g n ! f0; 1g on 2 arguments, x and y.
Reference: [Lo90] <author> Lovasz, L., </author> <title> "Communication Complexity: A Survey", Paths, Flows, and VLSI-layout, </title> <publisher> Springer-Verlag 1990, </publisher> <pages> pp. 235 - 266. </pages>
Reference-contexts: We recommend the survey paper by Lovasz <ref> [Lo90] </ref> for more background on communication complexity. The setting is the following: 2 players, A and B, want to evaluate a boolean function f : f0; 1g n fi f0; 1g n ! f0; 1g on 2 arguments, x and y. A has x and B has y.
Reference: [Ly75] <author> Lynch, N., </author> <title> "On reducibility to complex or sparse sets," </title> <journal> Journal of the ACM , Vol. </journal> <volume> 22, </volume> <year> 1975, </year> <pages> pp. 341 - 345. </pages>
Reference-contexts: Introduction How hard is it to decide an instance of a language A? This question has always been at the center of complexity theory. Complexity cores, defined by Lynch <ref> [Ly75] </ref> and studied by several other authors [OS86, BD87, etc.] provided complexity theorists with a new angle: Are there particular instances which make a language hard to decide, independently of the algorithm chosen to solve it? Instance complexity was defined [OKSW94] and studied [BO94, FK95, K95] with a somewhat similar intention:
Reference: [OKSW94] <author> Orponen, P., K.-I Ko, U. Schoning, and O. Watanabe, </author> <title> "Instance Complexity", </title> <journal> Journal of the ACM , Jan. </journal> <year> 1994. </year>
Reference-contexts: Complexity cores, defined by Lynch [Ly75] and studied by several other authors [OS86, BD87, etc.] provided complexity theorists with a new angle: Are there particular instances which make a language hard to decide, independently of the algorithm chosen to solve it? Instance complexity was defined <ref> [OKSW94] </ref> and studied [BO94, FK95, K95] with a somewhat similar intention: quantifying the hardness of individual instances with respect to a set, independently of the algorithm chosen to solve it. <p> For any pair of strings x; y 2 f0; 1g fl , the t-time-bounded Kolmogorov distinguishing complexity of x relative to y is defined as CD t (xjy) = Minfjpj : (p; y; z) = 1 iff z = xg: 1.4 Instance complexity Instance complexity <ref> [OKSW94] </ref> studies the complexity of solving specific instances of a language A. The measure used is the length of the shortest "special-purpose" program which determines correctly whether the given instance is, or is not, in A. <p> By "special-purpose", we mean that the only programs considered are the ones which always output one of 0,1, or ?, and are consistent with A, meaning when the output is not ? ("I don't know!"), the answer must be correct. A formal definition follows. Definition 1.3 <ref> [OKSW94] </ref> Fix a universal Turing machine M with output symbols f0; 1; ?g, which com putes the partial recursive function . Fix also a recursive set A. 1.
Reference: [OS86] <author> Orponen, P., and Schoning, U., </author> <title> "The density and complexity of polynomial cores for intractable sets", </title> <journal> Information and Control , Vol. </journal> <volume> 70, </volume> <year> 1986, </year> <pages> pp. 54 - 68. 10 </pages>
Reference-contexts: Introduction How hard is it to decide an instance of a language A? This question has always been at the center of complexity theory. Complexity cores, defined by Lynch [Ly75] and studied by several other authors <ref> [OS86, BD87, etc.] </ref> provided complexity theorists with a new angle: Are there particular instances which make a language hard to decide, independently of the algorithm chosen to solve it? Instance complexity was defined [OKSW94] and studied [BO94, FK95, K95] with a somewhat similar intention: quantifying the hardness of individual instances with
References-found: 11

