URL: ftp://ftp.eecs.umich.edu/groups/gasm/parlog.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/proglang.html
Root-URL: http://www.eecs.umich.edu
Email: boerger@di.unipi.it  riccobene@mathct.cineca.it  
Title: A formal specification of PARLOG  
Author: Egon Borger Elvinia Riccobene V.le Andrea Doria 
Note: In: M.Droste and Y.Gurevich (Eds.): Semantics of Programming Languages and Model Theory, Gordon and Breach, 1993, 1-42. Also: TR 1/93,  
Address: C.so Italia 40 I-56100 PISA  
Affiliation: Dip. di Informatica  Dip. di Matematica  CATANIA  Dipartimento di Informatica, Universita di Pisa, pp.42.  
Pubnum: I-95125  
Abstract: We provide a complete mathematical semantics for the parallel logic programming language PARLOG. This semantics is abstract but nevertheless simple and supports the intuitive operational understanding of programs. It is based on Gurevich's notion of Evolving Algebras ([20]) and is obtained adapting ideas from the description of full (Sequential) Standard PROLOG in [5] and the specification of imperative parallel computation phenomena of OCCAM developed in [24]. We develope a complete specification of the core of PARLOG which governs the computation of goals by user defined predicates. The built-in predicates can be described as for Standard PROLOG (see [4]-[6]) and are therefore omitted here. We give an explicit formalization of the two kinds of parallelism occurring in PARLOG: the AND-Parallelism and the (orthogonal) OR-Parallelism. Our description uses an abstract notion of PARLOG terms and PARLOG substitutions which is unburdened by representation details and implementation constraints. fl Part of this work was done when the first author was guest scientist at the Scientific Center of IBM Germany GmbH in Heidelberg, on sabbatical from University of Pisa, and when the second author from July 1990 till November 1990 worked at the Institut fur Logik, Komplexitat und Deduktionssysteme of University of Karlsruhe (Germany). The second author has been partially supported by "Progetto Finalizzato Sistemi Informatici e Calcolo Parallelo" of CNR, under Grant n.90.00671.69. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L.Beckmann, </author> <title> 1986 Towards a Formal Semantics for Concurrent Logic Programming Languages, </title> <booktitle> 3rd International Conference on Logic Programming, </booktitle> <publisher> Springer LNCS 225, </publisher> <pages> pp. 335-349. </pages>
Reference-contexts: In the appendix we list all thus obtained transition rules for the semantics of Parlog. 32 5 Conclusion Let us conclude by a comparison of our approach to related work in the literature. The interesting approach in <ref> [1] </ref> which is based on Milner's CCS has difficulties with a precise description of the commit-operator.
Reference: [2] <author> C.Beierle & E.Borger, </author> <year> 1992, </year> <title> Correctness Proof for the WAM with types, </title> <booktitle> CSL'91 5th Workshop on Computer Science Logic (Eds. </booktitle> <address> E.Borger, H.Kleine Buning, G.Jaeger, M.M.Richter), </address> <note> Springer LNCS (to appear). </note>
Reference-contexts: This specification together with the correctness proof has been extended to type-constraint logic programming for the case of Protos-L by Beierle & Borger in <ref> [2] </ref>. In this paper we provide a complete mathematical semantics, based on Evolving Algebras, for the parallel logic programming language Parlog. This seems to be the first attempt of a complete, formal (machine independent) specification of Parlog in the literature. In the conclusion we relate our result to other approaches.
Reference: [3] <author> R.Blakley, </author> <year> 1991, </year> <type> Ph.D. Thesis, </type> <institution> University of Michigan. </institution>
Reference-contexts: 1 Introduction Gurevich's notion of Evolving Algebras, initially developed to provide operational semantics for programs and programming languages by improving on Church's thesis (see [21], [22]), has since been shown to apply as formal specification method for real programming languages like Modula2 [23], Smalltalk <ref> [3] </ref>, Occam [24], Standard (Sequential) Prolog ([4], [5], [6], [12]), Prolog III [14], an object-oriented data base language [18]. In [13] and [7] it has allowed a systematic analysis of Prolog database views and their implementation.
Reference: [4] <author> E.Borger, </author> <title> 1990 A Logic Operational Semantics of full Prolog. Part I. Selection Core and Control, </title> <booktitle> CSL'89 3rd Workshop on Computer Science Logic, </booktitle> <publisher> Springer LNCS 440, </publisher> <pages> pp. 36-64. </pages>
Reference-contexts: We develope a complete specification of the core of Parlog which governs the computation of goals by user defined predicates. The built-in predicates occurring in Parlog (see [16]), can be treated in a similar way as already shown for (Standard) Prolog (see in particular <ref> [4] </ref>, [5], [6]). We give an explicit formalization of the two kinds of parallelism occurring in Parlog: the AND-Parallelism and the (orthogonal) OR-Parallelism. It turned out that the AND-Parallelism and the OR-Parallelism of Parlog can be specified almost independently one from the other. <p> Note. We will not use universe contraction rules which were considered in [21]. For Parlog their application would in most cases correspond to garbage collection, which need not be part of the formal description of the semantics of programming languages. This practice was already adopted in <ref> [4] </ref>. A function update has the form: f (t 1 ; t 2 ; ; t n ) := t where f is a function symbol and t 1 ; t 2 ; ; t n ; t are terms in the signature of the language.
Reference: [5] <author> E.Borger, </author> <title> 1990 A Logic Operational Semantics of full Prolog. Part II. Built-in Predicates for Database Manipulations, </title> <institution> MFCS'90 Mathematical Foundation of Computer Science (Ed. </institution> <address> B.Rovan), </address> <publisher> Springer LNCS 452, </publisher> <pages> pp. 1-14. </pages>
Reference-contexts: Introduction Gurevich's notion of Evolving Algebras, initially developed to provide operational semantics for programs and programming languages by improving on Church's thesis (see [21], [22]), has since been shown to apply as formal specification method for real programming languages like Modula2 [23], Smalltalk [3], Occam [24], Standard (Sequential) Prolog ([4], <ref> [5] </ref>, [6], [12]), Prolog III [14], an object-oriented data base language [18]. In [13] and [7] it has allowed a systematic analysis of Prolog database views and their implementation. In [10] and [11] a series of Evolving Algebras extensions, starting from the Prolog algebras of [5] and proved to be correct <p> [24], Standard (Sequential) Prolog ([4], <ref> [5] </ref>, [6], [12]), Prolog III [14], an object-oriented data base language [18]. In [13] and [7] it has allowed a systematic analysis of Prolog database views and their implementation. In [10] and [11] a series of Evolving Algebras extensions, starting from the Prolog algebras of [5] and proved to be correct w.r.t. the latter, has been developed which yields an entirely mathematical but transparent specification of Warren's Abstract Machine for executing Prolog. <p> This seems to be the first attempt of a complete, formal (machine independent) specification of Parlog in the literature. In the conclusion we relate our result to other approaches. We start from the Evolving Algebras description of (Standard) Prolog given by Borger (see <ref> [5] </ref>) and combine it with basic ideas developed by Gurevich and Moss for an Evolving Algebras specification of functional parallel computation phenomena of Occam (see [24]). We develope a complete specification of the core of Parlog which governs the computation of goals by user defined predicates. <p> We develope a complete specification of the core of Parlog which governs the computation of goals by user defined predicates. The built-in predicates occurring in Parlog (see [16]), can be treated in a similar way as already shown for (Standard) Prolog (see in particular [4], <ref> [5] </ref>, [6]). We give an explicit formalization of the two kinds of parallelism occurring in Parlog: the AND-Parallelism and the (orthogonal) OR-Parallelism. It turned out that the AND-Parallelism and the OR-Parallelism of Parlog can be specified almost independently one from the other. <p> The paper is organized as follows: 2 in Section 2 we adapt Gurevich's [20] definition of Evolving Algebras to our purposes; in Section 3 we define universes and functions of Parlog Algebras (extending Borger's <ref> [5] </ref> definitions for Sequential Prolog) and give the Transition Rules for AND-Parallelism in Parlog; in Section 4 we extend the previous Parlog Algebras (introducing new universes and functions and modifying the existing ones) to formalize OR-Parallelism in Parlog and give the Transition Rules for it; in the Appendix the complete Transition <p> defined on it. (Note that in absence of discard rules Node will never shrink.) 3.1.1 Universes and functions adapted from Standard (Sequen tial) Prolog Since a Parlog computation can be seen, in a certain way, as parallel computation of different Prolog computations, some of the universes and functions introduced in <ref> [5] </ref> to describe Standard (Sequential) Prolog can be used to define Parlog Algebras. In this section we list those universes and functions which we have adapted to Parlog Algebras from Borger's Prolog Algebras. <p> Var is the universe of variables and -(Var) is its powerset. From Sequential (Standard) Prolog Algebras (see <ref> [5] </ref>), we take the following functions adapting their definition to Parlog Algebras: 18 c) unify : Term fi Term ! Sub [ nil; where Term is the set of (Parlog) terms. We suppose Goal Term.
Reference: [6] <author> E.Borger, </author> <title> 1991 A Logic Operational Semantics of full Prolog. Part III. Built-in Predicates for Files, Terms, In-Output and Arithmetic, </title> <booktitle> Proc. Workshop Logic for Computer Science (Ed. Y.Moschovakis), Berkeley November 1989, MSRI Proceedings, </booktitle> <publisher> Springer Verlag (to appear). </publisher>
Reference-contexts: Gurevich's notion of Evolving Algebras, initially developed to provide operational semantics for programs and programming languages by improving on Church's thesis (see [21], [22]), has since been shown to apply as formal specification method for real programming languages like Modula2 [23], Smalltalk [3], Occam [24], Standard (Sequential) Prolog ([4], [5], <ref> [6] </ref>, [12]), Prolog III [14], an object-oriented data base language [18]. In [13] and [7] it has allowed a systematic analysis of Prolog database views and their implementation. <p> We develope a complete specification of the core of Parlog which governs the computation of goals by user defined predicates. The built-in predicates occurring in Parlog (see [16]), can be treated in a similar way as already shown for (Standard) Prolog (see in particular [4], [5], <ref> [6] </ref>). We give an explicit formalization of the two kinds of parallelism occurring in Parlog: the AND-Parallelism and the (orthogonal) OR-Parallelism. It turned out that the AND-Parallelism and the OR-Parallelism of Parlog can be specified almost independently one from the other.
Reference: [7] <author> E.Borger & B.Demoen, </author> <year> 1991, </year> <title> A Framework to specify Database Update Views for Prolog, </title> <booktitle> PLILP'91 3rd International Symposium on Programming Languages Implementation and Logic Programming (Eds. </booktitle> <address> J.Maluszynski & M.Wirsing), </address> <publisher> Springer LNCS 528, </publisher> <pages> pp. 147-158. </pages>
Reference-contexts: In [13] and <ref> [7] </ref> it has allowed a systematic analysis of Prolog database views and their implementation.
Reference: [8] <author> E.Borger & E.Riccobene, </author> <year> 1991, </year> <title> Logical Operational Semantics of Parlog. Part I: And-Parallelism, </title> <editor> in: H.Boley & M.M.Richter (Eds.), </editor> <booktitle> Processing Declarative Knowledge, </booktitle> <publisher> Springer LNAI 567, </publisher> <year> 1991, </year> <pages> pp. 191-198. </pages>
Reference-contexts: A preliminary version of this paper has appeared in <ref> [8] </ref>, [9]. Indeed in [8] we have given a formalization of the AND-Parallelism of Parlog which uses an abstract notion of OR-Parallelism and therefore can be applied mutatis mutandis to other parallel logic programming languages like Concurrent Pro-log or GHC. <p> A preliminary version of this paper has appeared in <ref> [8] </ref>, [9]. Indeed in [8] we have given a formalization of the AND-Parallelism of Parlog which uses an abstract notion of OR-Parallelism and therefore can be applied mutatis mutandis to other parallel logic programming languages like Concurrent Pro-log or GHC.
Reference: [9] <author> E.Borger & E.Riccobene, </author> <year> 1992, </year> <title> Logical Operational Semantics of Par-log. Part II: Or-Parallelism, </title> <booktitle> in: A.Voronkov (Ed.),Logic Programming, </booktitle> <publisher> Springer LNAI 592, </publisher> <year> 1992, </year> <pages> 27-34 </pages>
Reference-contexts: A preliminary version of this paper has appeared in [8], <ref> [9] </ref>. Indeed in [8] we have given a formalization of the AND-Parallelism of Parlog which uses an abstract notion of OR-Parallelism and therefore can be applied mutatis mutandis to other parallel logic programming languages like Concurrent Pro-log or GHC. In [9] we have made this abstraction explicit by a system of <p> A preliminary version of this paper has appeared in [8], <ref> [9] </ref>. Indeed in [8] we have given a formalization of the AND-Parallelism of Parlog which uses an abstract notion of OR-Parallelism and therefore can be applied mutatis mutandis to other parallel logic programming languages like Concurrent Pro-log or GHC. In [9] we have made this abstraction explicit by a system of rules for the OR-Parallelism, thus showing that it is orthogonal to the AND-Parallelism. We correct here the candidate clause search of [9] which turned out to be unnecessary complicated. (For details see sections 4.2.3 - 4.2.6). <p> In <ref> [9] </ref> we have made this abstraction explicit by a system of rules for the OR-Parallelism, thus showing that it is orthogonal to the AND-Parallelism. We correct here the candidate clause search of [9] which turned out to be unnecessary complicated. (For details see sections 4.2.3 - 4.2.6). <p> This clause transformation presents a subtlety of Parlog implementation by which the need for multiple environments for "local" substitutions is avoided. Since it has a semantical consequence we have to take it into consideration here. In <ref> [9] </ref> we had given a formalization which was inspired by some features in the JAM [17], creating "local" substitutions which became transparent to the main system only after commitment.
Reference: [10] <author> E.Borger & D.Rosenzweig, </author> <year> 1991, </year> <title> From Prolog Algebras Towards WAM </title>
Reference-contexts: In [13] and [7] it has allowed a systematic analysis of Prolog database views and their implementation. In <ref> [10] </ref> and [11] a series of Evolving Algebras extensions, starting from the Prolog algebras of [5] and proved to be correct w.r.t. the latter, has been developed which yields an entirely mathematical but transparent specification of Warren's Abstract Machine for executing Prolog. <p> Both phenomena are described using an abstract notion of Parlog terms and Parlog substitutions which is unburdened by representation details and implementation constraints. This is similar to what has been done for the conjunctive and disjunctive components of the WAM in <ref> [10] </ref> and we believe that a natural extension of the term algebras developed in [11] for the WAM can be defined to obtain a Parlog JAM from our present Parlog specification. <p> Furthermore it is to be expected that the present high-level formal specification of Parlog can be transformed naturally into an implementation of the WAM-like machine model underlying the Parlog implementation, along the lines of the corresponding way for sequential Prolog in <ref> [10, 11] </ref>. Our description of Parlog semantics is a complete specification of the core of Parlog which governs the computation of goals by user defined predicates. The model can be easily extended to the usual built-in predicates using the evolving algebras based methods developed for Sequential (Standard) Pro-log in [4]-[6].
References-found: 10

