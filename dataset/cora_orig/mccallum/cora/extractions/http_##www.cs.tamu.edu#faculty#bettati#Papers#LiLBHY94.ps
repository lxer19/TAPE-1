URL: http://www.cs.tamu.edu/faculty/bettati/Papers/LiLBHY94.ps
Refering-URL: http://www.cs.tamu.edu/faculty/bettati/selected_papers.html
Root-URL: http://www.cs.tamu.edu
Title: Published in: "Foundations of Dependable Computing: Paradigms for Dependable Applications," Koob and Lau, Use of
Author: Jane W. S. Liu, Kwei-Jay Lin, Riccardo Bettati, David Hull and Albert Yu W. S. Liu, Riccardo Bettati, and David Hull Albert Yu 
Address: Urbana, Illinois 61801.  Irvine, Irvine, California.  Los Angeles, California 90009.  
Affiliation: Department of Computer Science, University of Illinois at Urbana-Champaign,  Department of Electrical and Computer Engineering, University of California,  Radar Systems Group,  
Date: 1994  3.1  
Note: ed., Kluwer,  3.1.1 Introduction Jane  are at the  Kwei-Jay Lin is at the  is at Hughes Aircraft,  This work was partially supported by the U. S. Navy ONR contracts No. NVY N00014 89-J-1181 and No. NVY N00014 89-J-1146.  
Pubnum: SECTION  
Abstract: In a system based on the imprecise-computation technique, each time-critical task is designed in such a way that it can produce a usable, approximate result in time whenever a failure or overload prevents it from producing the desired, precise result. This section describes ways to use this technique together with traditional fault-tolerance methods to reduce the costs of providing fault tolerance and enhancedavailability. Specifically, an imprecise mechanism for the generation and use of approximate results can be integrated in a natural way with traditional checkpointing and replication mechanisms. Algorithms and process structures for this integration and rules for determining when approximate results can be used in place of the desired results are discussed. The imprecise computation technique was proposed as a way to handle transient overloads in real-time systems [1-3]. Here, by real-time system, we mean a computing and communication system in which a significant portion of the tasks have deadlines. The term task refers to a unit of work to be scheduled and executed. A task may be the computation of a control law, the transmission of an operator command, the 
Abstract-found: 1
Intro-found: 0
Reference: [1] <author> Liu, J. W. S., K. J. Lin and C. L. Liu, </author> <title> A position paper for the IEEE 1987 Workshop on Real-Time Operating Systems, </title> <address> Cambridge, Mass, </address> <month> May, </month> <year> 1987. </year>
Reference: [2] <author> Lin, K. J., S. Natarajan, J. W. S. Liu, </author> <title> Imprecise results: utilizing partial computations in real-time systems, </title> <booktitle> Proceedings of the IEEE 8th Real-Time Systems Symposium, </booktitle> <address> San Jose, California, </address> <month> December </month> <year> 1987. </year>
Reference: [3] <author> Liu, J. W. S., S. Natarajan, and K. J. Lin, </author> <title> Scheduling real-time, periodic jobs using imprecise results, </title> <booktitle> Proceedings of Eighth Real-Time Systems Symposium, </booktitle> <pages> pp. 252-260, </pages> <address> San Jose, CA, </address> <month> December </month> <year> 1987. </year>
Reference: [4] <author> Dean, T. and M. Boddy, </author> <title> An analysis of time dependent planning, </title> <booktitle> Proceedings of Conference of the AAAI, </booktitle> <year> 1988. </year> <title> [5] del Val, A., Approximate belief update, Proceedings of Workshop on Imprecise and Approximate Computations, </title> <address> Phoenix, Arizona, </address> <month> December </month> <year> 1993. </year>
Reference: [6] <author> Decker, K., V. Lesser, and R. Whitehair, </author> <title> Extending a blackboard architecture for approximate processing, </title> <journal> Real-Time Systems Journal, </journal> <volume> 2, </volume> <year> 1990. </year>
Reference: [7] <author> Leung, J. Y-T., T. W. Tam, C. S. Wong, and G. H. Wong, </author> <title> Minimizing mean flow time with error constraints, </title> <booktitle> Proceedings of the 10th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1989. </year>
Reference: [8] <author> Chung, J. Y., J. W. S. Liu, and K. J. Lin, </author> <title> Scheduling periodic jobs that allow imprecise results, </title> <journal> IEEE Transactions on Computer, </journal> <volume> Vol. 39, No. 9, </volume> <pages> pp. 1156-1174, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Because it is difficult to work with discontinuous functions, we typically approximate them by the continuous error functions. The continuous error functions were found to be good approximations except when the error decreases to zero in very few (e.g., two or three) steps <ref> [8] </ref>. Figure 3.1.2 (a) shows three types of error functions that characterize the general behavior of different monotone computations. When the scheduler works correctly, it allows every mandatory task to complete.
Reference: [9] <author> Leung, J. Y-T. and C. S. Wong, </author> <title> Minimizing the number of late tasks with error constraints, </title> <booktitle> Proceedings of the 11th Real-Time Systems Symposium, </booktitle> <address> Orlando, Florida, </address> <month> December </month> <year> 1990. </year>
Reference: [10] <author> Liu, J. W. S., K. J. Lin, W. K. Shih, A. C. Yu, J. Y. Chung, and W. Zhao, </author> <title> Algorithms for scheduling imprecise computations, </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 58-68, </pages> <month> May </month> <year> 1991. </year>
Reference: [11] <author> Shih, W. K., J. W. S. Liu and J. Y. Chung, </author> <title> Algorithms for scheduling tasks to minimize total error, </title> <journal> SIAM Journal of Computing, </journal> <volume> Vol. 20, No. 3, </volume> <pages> pp. 537-552, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: When the optional tasks have identical processing times and weights, tasks with the 0/1 constraint can be optimally scheduled in O (n log n) time or O (n 2 ) time depending on whether the tasks have identical or different release times. These algorithms can be found in <ref> [11] </ref>. Future Work in Scheduling Again, all existing algorithms for scheduling imprecise computations assume that tasks have zero input errors. Moreover, the release times and deadlines of individual tasks are given. Both these assumptions are often not valid.
Reference: [12] <author> Zhao, W., S. Vrbsky and J. W. S. Liu, </author> <title> An analytical model for multi-server imprecise systems", </title> <booktitle> Proceedings of the 5th International Conference on Parallel and Distributed Computing and Systems, </booktitle> <address> Pittsburgh, PA, </address> <month> September </month> <year> 1992. </year>
Reference: [13] <author> Ho, K. I. J., J. Y. T. Leung and W. D. Wei, </author> <title> Minimizing maximum weighted error of imprecise computation tasks, </title> <type> Technical Report, </type> <institution> Department of Computer Science and Engineering, University of Nebraska, </institution> <year> 1992. </year>
Reference: [14] <author> Ho, K. I, J., J. Y. T. Leung, and W. D. Wei, </author> <title> Scheduling imprecise computation tasks with 0/1 constraints, </title> <type> Technical Report, </type> <institution> Department of Computer Science and Engineering, University of Nebraska, </institution> <year> 1992. </year>
Reference-contexts: The general problem of scheduling to meet the 0/1 constraint and timing constraints, while minimizing the total error is NP-complete when the optional tasks have arbitrary processing times. Approximate algorithms with reasonably good worst-case performance can be found in <ref> [14] </ref>. When the optional tasks have identical processing times and weights, tasks with the 0/1 constraint can be optimally scheduled in O (n log n) time or O (n 2 ) time depending on whether the tasks have identical or different release times. These algorithms can be found in [11].
Reference: [15] <author> Shih, W. K. and J. W. S. Liu, </author> <title> On-line scheduling of imprecise computations to minimize total error, </title> <booktitle> Proceedings of the 13th IEEE Real-Time Systems Symposium, Phoenix, Arizona, </booktitle> <pages> pp. 280-289, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: system is off-line when the release times, deadlines and processing times of all the tasks in it are known before the processor begins to execute any task.) The version described below assumes that the tasks are on-line; the algorithm is optimal only when the system satisfies the feasible mandatory constraint <ref> [15] </ref>. Similar to the NORA algorithm for scheduling on-line imprecise tasks which are ready for execution at their arrival times [15], Algorithm C OL maintains a reservation list of time intervals for all tasks that have been released but are not yet completed. <p> the processor begins to execute any task.) The version described below assumes that the tasks are on-line; the algorithm is optimal only when the system satisfies the feasible mandatory constraint <ref> [15] </ref>. Similar to the NORA algorithm for scheduling on-line imprecise tasks which are ready for execution at their arrival times [15], Algorithm C OL maintains a reservation list of time intervals for all tasks that have been released but are not yet completed.
Reference: [16] <author> Cheong, I., </author> <title> Heuristic algorithms for scheduling error-cumulative, periodic jobs, </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, University of Illinois, </institution> <month> January </month> <year> 1993. </year>
Reference: [17] <author> Shih, W. K. and J. W. S. Liu, </author> <title> Minimization of the maximum error of imprecise computations. </title> <note> submitted. </note>
Reference: [18] <author> Ho, K. I. J, V. K. M. Yu, and W. D. Wei, </author> <title> Minimizing the weighted number of tardy tasks units, </title> <note> to appear in Discrete Applied Math. </note>
Reference: [19] <author> Obradovic, M. and P. Berman, </author> <title> Voting as the optimal static pessimistic scheme for managing replicated data, </title> <booktitle> Proceedings of the 9th IEEE Symposium on Reliable Distributed Systems, </booktitle> <month> October </month> <year> 1990. </year>
Reference: [20] <author> Koo, B. and S. Toueg, </author> <title> Checkpointing and rollback-recovery for distributed systems, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> January </month> <year> 1987. </year>
Reference: [21] <author> Wallace, G. K., </author> <title> Overview of the JPEG (ISO/CCITT) still image compression standard, Visual Communication and Image Processing, </title> <booktitle> '89, SPIE, </booktitle> <address> Philadelphia, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: This method for returning approximate results is called the milestone method. Clearly, the milestone method relies on the use of monotone computational algorithms. Such algorithms exist in many application domains, including numerical computation, statistical estimation and prediction, sorting, facsimile transmission <ref> [21] </ref>, video and voice transmission [22,23], and database query processing [24,25]. Monotone tasks can be easily implemented in most existing programming languages; an example illustrating how to implement monotone tasks in Ada 9x can be found in [26]. <p> This problem is essentially one of scheduling. In addition to some numerical computations and monotone database query processing [24,25], image transmission is an example of this type. Suppose that a progressive built-up method is used for the transmission of still images <ref> [21] </ref>. The data encoding each image frame is divided into four blocks; each additional block gives a clearer image. The input data encoding the image presented to each transmission task contain all four blocks.
Reference: [22] <author> Wood, J. and S. O'Neil, </author> <title> Sub-band coding of images, </title> <journal> IEEE Transactions on Acoustic Speech Signal Communications, </journal> <volume> 34, </volume> <month> October </month> <year> 1986. </year>
Reference: [23] <author> Suzuki, J. and M. Taka, </author> <title> Missing packet recovery techniques for low-bit-rate coded speech, </title> <journal> IEEE Journal of Selected Areas in Communications, </journal> <volume> 9(7), </volume> <month> Septem-ber </month> <year> 1991. </year>
Reference: [24] <author> Buneman, P., S. Davidson, and A. Watters, </author> <title> A semantics for complex objects and approximate queries, </title> <booktitle> Proceedings of the Seventh Symposium on the Principles of Database Systems, </booktitle> <pages> pp. 305-314, </pages> <month> March </month> <year> 1988. </year>
Reference: [25] <author> Vrbsky, S. and J. W. S. Liu, </author> <title> Approximate: a monotone query processing, </title> <journal> em IEEE Transactions on Knowledge and Data Engineering, </journal> <month> October </month> <year> 1993. </year>
Reference: [26] <author> Ada 9X Mapping, </author> <title> Version 3.1, Ada 9X Mapping/Revision Team, </title> <publisher> Intermetric, Inc., </publisher> <address> Cambridge, Mass., </address> <month> August </month> <year> 1991. </year>
Reference-contexts: Monotone tasks can be easily implemented in most existing programming languages; an example illustrating how to implement monotone tasks in Ada 9x can be found in <ref> [26] </ref>. When tasks are monotone, the decision on which optional task and how much of the optional task to schedule at any time can be made dynamically.
Reference: [27] <author> Liestman, A. L. and R. H. Campbell, </author> <title> A fault-tolerant scheduling problem, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-12, No. 10., </volume> <pages> pp. 1089-1095, </pages> <month> October </month> <year> 1986. </year>
Reference: [28] <author> Gopinath, P. and R. Gupta, </author> <title> Applying compiler techniques to scheduling in real-time systems, </title> <booktitle> Proceedings of the 11th IEEE Real-Time Systems Symposium, </booktitle> <address> Orlando, Florida, </address> <month> December </month> <year> 1990. </year>
Reference: [29] <author> Kim, B. and D. Towsley, </author> <title> Dynamic flow control protocols for packet-switching multiplexers serving real-time multipacket messages, </title> <journal> IEEE Transactions on Communications, </journal> <volume> Vol. COM-34, No. 4, </volume> <month> April </month> <year> 1986. </year>
Reference: [30] <author> Yemini, Y., </author> <title> A bang-bang principle for real-time transport protocols, </title> <booktitle> Proc. SIGCOMM '83 Symp. Commun. Architect. Protocols, </booktitle> <pages> pp. 262-268, </pages> <month> May </month> <year> 1983. </year>
Reference: [31] <author> Zhao, W. and E. K. P. Chong, </author> <title> Performance evaluation of scheduling algorithms for dynamic imprecise soft real-time computer systems", </title> <journal> Australian Computer Science Communications, </journal> <volume> Vol. 11, No. 1, </volume> <pages> pp 329-340, </pages> <year> 1989. </year>
Reference: [32] <author> Lopez-Millan, V., W. Feng, and J. W. S. Liu, </author> <title> A congestion control scheme for real-time traffic switching element using the imprecise computation technique, </title> <booktitle> submitted to the 1994 International Conference on Distributed Computing Systems. </booktitle>
Reference: [33] <author> Bettati, R., N. S. Bowen, and J. Y. Chung, </author> <title> On-Line Scheduling for Checkpointing Imprecise Computation, </title> <booktitle> Proceedings of Euromicro 93 Workshop on Real-Time Systems, Oulu, </booktitle> <address> Finland, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: When tasks are statically bound to processors and tasks on each processor are scheduled as in a uniprocessor system, the algorithm called Algorithm C OL in <ref> [33] </ref>, can be used for this purpose. <p> The performance of this algorithm for scheduling on-line transactions that have bounded-response-time and high-availability requirements has been evaluated and performance data can be found in <ref> [33] </ref>. The ICS System We are implementing the ICS (Imprecise Computation Server) system based on the architecture described above. ICS runs on top of the Mach operating system and is integrated with the Mach Interface Generator (MIG) [34].
Reference: [34] <institution> Mach 3 Server Writer's Guide, edited by K. Loepere, Open Software Foundation and Carnegie Mellon University, </institution> <year> 1990. </year>
Reference-contexts: The ICS System We are implementing the ICS (Imprecise Computation Server) system based on the architecture described above. ICS runs on top of the Mach operating system and is integrated with the Mach Interface Generator (MIG) <ref> [34] </ref>. MIG takes an interface description for a service and generates interface code for the client and the server. This interface hides the call to the remote server from the client, making it appear to be a local procedure call.
Reference: [35] <author> Hull, D. and J. W. S Liu, </author> <title> ICS: A System for Imprecise Computations, </title> <booktitle> Proceedings of AIAA Conference, </booktitle> <month> October </month> <year> 1993, </year> <note> also technical report in preparation. </note>
Reference-contexts: The routines and their classifications are listed in Table 3.1.1. Details on these routines and their usage can be found in <ref> [35] </ref>. The client interface routine is the client's interface to a server and is called by the client when it wishes to make use of a service. The server interface routine is the corresponding interface on the server side.
Reference: [36] <author> Yu, A., </author> <title> Scheduling parallel real-time tasks that allow imprecise computations, </title> <type> Ph.D. thesis, Technical Report UIUCDCS-R-92-1738, </type> <institution> University of Illinois, </institution> <year> 1992. </year>
Reference: [37] <author> Yu, A. and K. J. Lin, </author> <title> A scheduling algorithm for replicated real-time tasks," </title> <booktitle> Proc. Phoenix Conference on Computers and Communications, </booktitle> <pages> pp. 395-402, </pages> <month> April </month> <year> 1992. </year>
Reference: [38] <author> Yu, A. and K. J. Lin, </author> <title> Recovery manager for replicated real-time imprecise computations, </title> <booktitle> Proceedings of IEEE Workshop on Parallel and Distributed Real-Time Systems, </booktitle> <address> Newport Beach, CA, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: The number of clones and the allocated utilizations of the clones are changed in such a way that the number of clones of every task T i on non-faulty processors is never less than c i (j) when the system is in mode j <ref> [38] </ref>. In particular, according to the clone reconfiguration scheme described in [38], the repair server is monotone. Therefore, if another processor fails while a repair server is carrying out clone reconfiguration, we can terminate the ongoing repair service. <p> the allocated utilizations of the clones are changed in such a way that the number of clones of every task T i on non-faulty processors is never less than c i (j) when the system is in mode j <ref> [38] </ref>. In particular, according to the clone reconfiguration scheme described in [38], the repair server is monotone. Therefore, if another processor fails while a repair server is carrying out clone reconfiguration, we can terminate the ongoing repair service.
References-found: 37

