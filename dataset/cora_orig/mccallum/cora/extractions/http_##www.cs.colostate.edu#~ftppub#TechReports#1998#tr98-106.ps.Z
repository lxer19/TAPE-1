URL: http://www.cs.colostate.edu/~ftppub/TechReports/1998/tr98-106.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Phone: Phone: (970) 491-5792 Fax: (970) 491-2466  
Title: Mutual Exclusion Between Neighboring Nodes in a Tree That Stabilizes Using Read/Write Atomicity  
Author: Gheorghe Antonoiu and Pradip K. Srimani 
Note: A somewhat abridged version will appear in he Proceedings of Euro-Par-98, Soutampton, UK,  
Web: WWW: http://www.cs.colostate.edu  
Address: Fort Collins, CO 80523-1873  
Affiliation: Computer Science Department Colorado State University  
Date: May 27, 1998  1-4 September 1998  
Pubnum: Technical Report CS-98-106  
Abstract: Computer Science Technical Report 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Mizuno and H. Kakugawa. </author> <title> A timestamp based transformation of self-stabilizing programs for distributed computing environments. </title> <booktitle> In Proceedings of the 10th International Workshop on Distributed Algorithms (WDAG'96), </booktitle> <volume> volume 304-321, </volume> <year> 1996. </year>
Reference-contexts: This approach was used in <ref> [1] </ref> and can be compared with the layered approach use in networks protocol stacks. <p> Our purpose in this paper is to propose a new protocol that can be used to run a serial model self stabilizing algorithm in a distributed environment that accepts as atomic operations only send a message, receive a message an update a state. Unlike the scheme in <ref> [1] </ref>, our protocol does not use time-stamps (which are basically unbounded integers); our algorithm uses only bounded integers (actually, the integers can assume values only 0, 1, 2 and 3) and can be easily implemented. Our algorithm is applicable for distributed systems whose underlying topology is a tree. <p> self-stabilizing distributed mutual exclusion protocols, see [3, 4]), the objective is to ensure that only one node in the system can execute its critical section at any given time (i.e., critical section execution is mutually exclusive from all other nodes in the system; the objective in our protocol, as in <ref> [1] </ref>, is to ensure that a node executes its critical section mutually exclusive from its neighbors in the system graph (as opposed to all nodes in the system), i.e., multiple nodes can execute their critical sections concurrently as long as they are not neighbors to each other; in the critical section <p> Execution of a move by a processor may be interleaved with moves by other nodes in this case the moves are concurrent. We use the notation N (x) = fn x <ref> [1] </ref>; : : : :n x [d x ]g to denote the set of neighbors of node x. <p> We use the notation d x for the degree of node x, n x [j] for the j-th neighbor of the node x, N (x) = fn x <ref> [1] </ref>; : : : :n x [d x ]g for the set of neighbors of node x, C (x) for the set of children of x and P x for the parent of node x; since the topology is a tree each node x knows its parent P x and for <p> Our protocol is based on read/write atomicity of operations like [2] and operates under a distributed demon. To compare our algorithm with that of <ref> [1] </ref>, we do not use any time stamp to implement the scheme; one immediate improvement is that we use only bounded integers (in fact, the variables in our scheme can have only values 0, 1, 2 and 3) while time stamps in [1] are essentially unbounded integers. <p> To compare our algorithm with that of <ref> [1] </ref>, we do not use any time stamp to implement the scheme; one immediate improvement is that we use only bounded integers (in fact, the variables in our scheme can have only values 0, 1, 2 and 3) while time stamps in [1] are essentially unbounded integers. It'd be interesting to extend the concepts developed in this paper to an arbitrary system graph.
Reference: 2. <author> S. Dolev, A. Israeli, and S. Moran. </author> <title> Self-stabilization of dynamic systems assuming only read/write atomicity. </title> <journal> Distributed Computing, </journal> <volume> 7 </volume> <pages> 3-16, </pages> <year> 1993. </year>
Reference-contexts: It is interesting to note that the proposed protocol can be viewed as a special class of self-stabilizing distributed mutual exclusion protocol. In traditional distributed mutual exclusion protocols, self-stabilizing or non self-stabilizing (for references in self-stabilizing distributed mutual exclusion protocols, see <ref> [2] </ref> and for non self-stabilizing distributed mutual exclusion protocols, see [3, 4]), the objective is to ensure that only one node in the system can execute its critical section at any given time (i.e., critical section execution is mutually exclusive from all other nodes in the system; the objective in our <p> section the node executes an atomic step of a serial model self-stabilizing algorithm. ? A somewhat abridged version will appear in he Proceedings of Euro-Par-98, Soutampton, UK, 1-4 September 1998 In section 2 we describe our model precisely while in section 3 we show that the balance unbalance protocol of <ref> [2] </ref> is not self-stabilizing and describe an alternative scheme to make it self-stabilizing to motivate the development of our self-stabilizing protocol for a tree graph in section 3. <p> A configuration of the entire system or a system state is defined to be the vector of local states of all nodes. Next, our model assumes read/write atomicity of <ref> [2] </ref> (as opposed to the composite read/write atomicity as in [5, 6]). <p> its critical section, the other node cannot execute its critical section, or in other words, if the predicate is true at one node, the predicate at other node is not true or cannot be true until the first node completes execution of its critical section. 3.1 The Balance Unbalance Protocol <ref> [2] </ref> is not Self-Stabilizing The well known algorithms [7-9, 3, 4] for mutual exclusion between two processes are not applicable in our case since each of them either uses a shared variable or is not self-stabilizing. <p> The balance-unbalance algorithm, <ref> [10, 2] </ref>, does not use any shared variable, does ensure mutual exclusion, but is not self-stabilizing. <p> The balance-unbalance algorithm, [10, 2], does not use any shared variable, does ensure mutual exclusion, but is not self-stabilizing. The two processes in the algorithm <ref> [2] </ref> roughly execute the following loops: Process A: R a : LS a (b) = S b ; CS a : if (S a = LS a (b)) then Execute Critical Section W a : if (LS a (b) = S a ) then S a = (S a + 1) <p> self-stabilizing, i.e., there is no proper subset of states such that for any initial state the system reaches that subset after a finite number of moves. 3.2 Self-Stabilizing Balance Unbalance Protocol for a Pair of Processes One possible approach to make the above balance unbalance protocol self-stabilizing is presented in <ref> [2] </ref>; this approach uses shared variables. We present an alternative approach without using any shared variables. <p> The proposed protocol can be readily used to provide a suitable run time or execution time environment to run self stabilizing algorithms developed for serial model. Our protocol is id-based and does not use any shared variable as opposed to the self-stabilizing traditional mutual exclusion algorithm <ref> [2] </ref> which is anonymous and does use shared link registers. Our protocol is based on read/write atomicity of operations like [2] and operates under a distributed demon. <p> Our protocol is id-based and does not use any shared variable as opposed to the self-stabilizing traditional mutual exclusion algorithm <ref> [2] </ref> which is anonymous and does use shared link registers. Our protocol is based on read/write atomicity of operations like [2] and operates under a distributed demon.
Reference: 3. <author> M. Raynal. </author> <title> Algorithms for Mutual Exclusion. </title> <publisher> MIT Press, </publisher> <address> Cambridge MA, </address> <year> 1986. </year>
Reference-contexts: In traditional distributed mutual exclusion protocols, self-stabilizing or non self-stabilizing (for references in self-stabilizing distributed mutual exclusion protocols, see [2] and for non self-stabilizing distributed mutual exclusion protocols, see <ref> [3, 4] </ref>), the objective is to ensure that only one node in the system can execute its critical section at any given time (i.e., critical section execution is mutually exclusive from all other nodes in the system; the objective in our protocol, as in [1], is to ensure that a node <p> its critical section, or in other words, if the predicate is true at one node, the predicate at other node is not true or cannot be true until the first node completes execution of its critical section. 3.1 The Balance Unbalance Protocol [2] is not Self-Stabilizing The well known algorithms <ref> [7-9, 3, 4] </ref> for mutual exclusion between two processes are not applicable in our case since each of them either uses a shared variable or is not self-stabilizing. The balance-unbalance algorithm, [10, 2], does not use any shared variable, does ensure mutual exclusion, but is not self-stabilizing.
Reference: 4. <author> P. K. Srimani and S. R. Das, </author> <title> editors. Distributed Mutual Exclusion Algorithms. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1992. </year>
Reference-contexts: In traditional distributed mutual exclusion protocols, self-stabilizing or non self-stabilizing (for references in self-stabilizing distributed mutual exclusion protocols, see [2] and for non self-stabilizing distributed mutual exclusion protocols, see <ref> [3, 4] </ref>), the objective is to ensure that only one node in the system can execute its critical section at any given time (i.e., critical section execution is mutually exclusive from all other nodes in the system; the objective in our protocol, as in [1], is to ensure that a node <p> its critical section, or in other words, if the predicate is true at one node, the predicate at other node is not true or cannot be true until the first node completes execution of its critical section. 3.1 The Balance Unbalance Protocol [2] is not Self-Stabilizing The well known algorithms <ref> [7-9, 3, 4] </ref> for mutual exclusion between two processes are not applicable in our case since each of them either uses a shared variable or is not self-stabilizing. The balance-unbalance algorithm, [10, 2], does not use any shared variable, does ensure mutual exclusion, but is not self-stabilizing.
Reference: 5. <author> M. Flatebo, A. K. Datta, and A. A. Schoone. </author> <title> Self-stabilizing multi-token rings. </title> <journal> Distributed Computing, </journal> <volume> 8 </volume> <pages> 133-142, </pages> <year> 1994. </year>
Reference-contexts: A configuration of the entire system or a system state is defined to be the vector of local states of all nodes. Next, our model assumes read/write atomicity of [2] (as opposed to the composite read/write atomicity as in <ref> [5, 6] </ref>).
Reference: 6. <author> S. T. Huang and N. S. Chen. </author> <title> Self-stabilizing depth-first token circulation on net works. </title> <booktitle> Distributed Computing, </booktitle> <year> 1993. </year>
Reference-contexts: A configuration of the entire system or a system state is defined to be the vector of local states of all nodes. Next, our model assumes read/write atomicity of [2] (as opposed to the composite read/write atomicity as in <ref> [5, 6] </ref>).
Reference: 7. <author> E. W. Dijkstra. </author> <title> Solution of a problem in concurent programming control. </title> <booktitle> Com munication of the ACM, </booktitle> <address> 8(9):569, </address> <month> September </month> <year> 1965. </year>
Reference: 8. <author> L. Lamport. </author> <title> A new solution of Dijkstra's concurrent programming problem. </title> <journal> Com munications of the ACM, </journal> <volume> 17(8) </volume> <pages> 107-118, </pages> <month> August </month> <year> 1974. </year>
Reference: 9. <author> L. Lamport. </author> <title> The mutual exclusion problem: Part II statement and solutions. </title> <journal> Journal of the ACM, </journal> <volume> 33(2) </volume> <pages> 327-348, </pages> <year> 1986. </year>
Reference: 10. <author> H. S. M. Kruijer. </author> <title> Self-stabilization (in spite of distributed control) in tree structured systems. </title> <journal> Inf. Processing Letters, </journal> <volume> 8(2) </volume> <pages> 91-95, </pages> <year> 1979. </year>
Reference-contexts: The balance-unbalance algorithm, <ref> [10, 2] </ref>, does not use any shared variable, does ensure mutual exclusion, but is not self-stabilizing.
References-found: 10

