URL: http://www.cs.wustl.edu/~schmidt/PDCP.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: http://www.cs.wustl.edu
Email: fjxh,irfan,schmidtg@cs.wustl.edu  
Title: The Object-Oriented Design and Performance of JAWS A High-performance Web Server Optimized for High-speed Networks
Author: James C. Hu, Irfan Pyarali, Douglas C. Schmidt 
Note: This work was supported in part by grants from OTI, Kodak, and Siemens. should be adaptive, i.e.,  
Address: St. Louis, Missouri  
Affiliation: Department of Computer Science Washington University,  
Abstract: This paper has been submitted to the Parallel and Distributed Computing Practices journal, special issue on Distributed Object-Oriented Systems, edited by Maria Cobb. Abstract This paper provides two contributions to the study of high-performance object-oriented (OO) Web servers. First, it outlines the design principles and optimizations necessary to develop efficient and scalable Web servers and illustrates how we have applied these principles and optimizations to create JAWS. JAWS is a high-performance Web server that is explicitly designed to alleviate overheads incurred by existing Web servers on high-speed networks. In addition to its highly extensible OO design, it is also highly efficient and consistently outperforms existing Web servers (such as Apache, Java Server, PHTTPD, Zeus, and Netscape Enterprise) over 155 Mbps ATM networks on UNIX platforms. Second, this paper describes how we have customized the JAWS OO design to leverage advanced features of Windows NT for multi-processor platforms linked by high-speed ATM networks. The Windows NT features used in JAWS include asynchronous mechanisms for connection establishment and data transfer. Our previous benchmarking studies demonstrate that once the overhead of disk I/O is reduced to a negligible constant factor (e.g., via memory caches), the primary determinants of Web server performance are the concurrency and event dispatching strategies. Our performance results over a 155 Mbps ATM network indicate that certain Windows NT asynchronous I/O mechanisms (i.e., TransmitFile) provide superior performance for large file transfers compared with conventional synchronous multi-threaded servers. On the other hand, synchronous event dispatching performed better for files less than 50 Kbytes. Thus, to provide optimal performance, a Web server design 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Frank Buschmann, Regine Meunier, Hans Rohnert, Peter Som-merlad, and Michael Stal. </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: Protocol Pipeline: This framework allows filter operations to be incorporated easily with the data being processed by the Protocol Handler. This integration is achieved by employing the Adapter pattern. Pipelines follow the Pipes and Filters pattern <ref> [1] </ref> for input processing. Pipeline components can be linked dynamically at run-time using the Service Configurator pattern, as shown in Figure 6. Cached Virtual Filesystem: This component improves Web server performance by reducing the overhead of filesystem access.
Reference: [2] <author> Alexander Carlton. </author> <title> An Explanation of the SPECweb96 Benchmark. Standard Performance Evaluation Corporation whitepa-per, </title> <note> 1996. www.specbench.org/. </note>
Reference-contexts: The file access pattern used in the tests is shown in Table 1. This table represents actual load conditions on popular servers, based on a study of file access patterns conducted by SPEC <ref> [2] </ref>. 9 Document Size Frequency 500 bytes 35% 5 Kbytes 50% 50 Kbytes 14% 5 Mbytes 1% Table 1: File Access Patterns 4.3 Experimental Results The results presented below compare the performance of several different adaptations of the JAWS Web server. <p> The growing number of Web servers has prompted the need for assessing their relative performance. The current standard benchmarks available are WebStone [5] (by SGI) and SPECweb96 <ref> [2] </ref> (by SPEC), both heavily influenced by the design of LADDIS [31]. WebStone and SPECweb96 attempt to measure overall performance. They rate the performance of a server with a single number (a higher number indicates better performance).
Reference: [3] <author> Zubin D. Dittia, Guru M. Parulkar, and Jr. Jerome R. Cox. </author> <title> The APIC Approach to High Performance Network Interface Design: Protected DMA and Other Techniques. </title> <booktitle> In Proceedings of INFOCOM '97, </booktitle> <address> Kobe, Japan, </address> <month> April </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: For example, different OS platforms may provide specialized I/O mechanisms (such as asynchronous I/O or bulk data transfer) or specialized devices (such as high-speed ATM network interfaces <ref> [3] </ref>). Therefore, simply porting a Web server to use common OS mechanisms and APIs (such as BSD sockets, select, and POSIX threads) is not sufficient to achieve maximal performance on different OS platforms.
Reference: [4] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlis-sides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: As events are processed, they are dispatched to the Protocol Handler, which is parameterized by an I/O strategy. JAWS ability to dynamically bind to a particular concurrency strategy and I/O strategy from a range of alternatives follows the Strategy pattern <ref> [4] </ref>. snmp_request () dispatch () Resource Representation Protocol Pipeline ftp_request () for (;;) - m = aq-&gt;remove (); dispatch (m); http_request () Scheduler aq-&gt;insert (http) Protocol Handler http_request () snmp_request () ftp_request () Activation Queue insert () remove () Method Object delegates Concurrency Strategy: This framework implements con-currency mechanisms (such as <p> (); dispatch (m); http_request () Scheduler aq-&gt;insert (http) Protocol Handler http_request () snmp_request () ftp_request () Activation Queue insert () remove () Method Object delegates Concurrency Strategy: This framework implements con-currency mechanisms (such as single-threaded, thread-per-request, or thread pool) that can be selected adaptively at run-time using the State pattern <ref> [4] </ref> or pre-determined at initialization-time. The Service Configurator pattern [10] is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [12]. This is illustrated in Figure 4. <p> Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Asyn chronous Completion Token [19] pattern and Proactor [6] pattern, as illustrated in Figure 5. Reactive I/O is accomplished through the Reactor pattern [24]. Reactive I/O utilizes the Memento pattern <ref> [4] </ref> to capture and externalize the state of a request so that it can be restored at a later time. schedule_timer (h) Timer Queue cancel_timer (h) IO Handle expire_timers (h) Proactor Completion Dispatcher handle_events () register_handler (h) remove_handler (h) send_file () recv_file () send_data () recv_data () Proactive IO Handler handle_read_file <p> A Protocol Handler is parameterized by a con-currency strategy and an I/O strategy. These strategies are de-coupled from the protocol handler using the Adapter <ref> [4] </ref> pattern. In JAWS, this component implements the parsing and handling of HTTP/1.0 request methods. The abstraction allows for other protocols (such as HTTP/1.1, DICOM, and SFP [18]) to be incorporated easily into JAWS. <p> Cached Virtual Filesystem: This component improves Web server performance by reducing the overhead of filesystem access. Various caching strategies, such as LRU, LFU, Hinted, and Structured, can be selected following the Strategy pattern <ref> [4] </ref>. This allows different caching strategies to be profiled and selected based on their performance. Moreover, optimal strategies to be configured statically or dynamically using the Service Configurator pattern, as shown in Figure 6. The cache for each Web server is instantiated using the Singleton pattern [4]. 4 Service Repository services <p> following the Strategy pattern <ref> [4] </ref>. This allows different caching strategies to be profiled and selected based on their performance. Moreover, optimal strategies to be configured statically or dynamically using the Service Configurator pattern, as shown in Figure 6. The cache for each Web server is instantiated using the Singleton pattern [4]. 4 Service Repository services LRU Strategy LFU Strategy Protocol Pipeline Filter Repository Cache Strategy Repository Service init () fini () suspend () resume () info () Filecache Protocol Handler ... FilterRead Request Parse Request Log Request DLL Cache Strategy ... <p> (2) utilizing concurrency and event dispatching processing routines that are customized to the OS platform in order to reduce server load and improve end-to-end quality of service. 6.3 Web Server Design and Implementation Design patterns are re-usable software abstractions that have been observed to occur many times in actual solutions <ref> [4] </ref>. A design pattern is intended to solve a general design problem for a specific context. Many patterns have been observed in the context of concurrent, parallel and distributed systems. Many of these ideas are applicable to Web server design.
Reference: [5] <author> Gene Trent and Mark Sake. WebSTONE: </author> <title> The First Generation in HTTP Server Benchmarking. Silicon Graphics, </title> <publisher> Inc. </publisher> <address> whitepa-per, </address> <month> February </month> <year> 1995. </year> <month> ww.sgi.com/. </month>
Reference-contexts: The two workstations were connected via an ATM network running through a FORE Systems ASX-200BX, with a maximum bandwidth of 622 Mbps. However, due to limitations of LAN emulation mode, the peak bandwidth of our testbed is approximately 120 Mbps. 4.2 Software Request Generator We used the WebSTONE <ref> [5] </ref> v2.0 benchmarking software to collect client- and server-side metrics. These metrics included average server throughput, and average client latency. Web-STONE is a standard benchmarking utility, capable of generating load requests that simulate typical Web server file access patterns. <p> The growing number of Web servers has prompted the need for assessing their relative performance. The current standard benchmarks available are WebStone <ref> [5] </ref> (by SGI) and SPECweb96 [2] (by SPEC), both heavily influenced by the design of LADDIS [31]. WebStone and SPECweb96 attempt to measure overall performance. They rate the performance of a server with a single number (a higher number indicates better performance).
Reference: [6] <author> Tim Harrison, Irfan Pyarali, Douglas C. Schmidt, and Thomas Jordan. </author> <title> Proactor An Object Behavioral Pattern for Dispatching Asynchronous Event Handlers. </title> <booktitle> In The 4 th Pattern Languages of Programming Conference (Washington University technical report #WUCS-97-34), </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: For example, an optimized file I/O system that automatically caches open files in main memory helps to reduce latency. Likewise, support for asynchronous event dispatching <ref> [6] </ref> and the Proactor pattern [9] can increase server throughput by reducing context switching and synchronization overhead incurred from multi-threading. This paper presents two complementary strategies for developing optimized Web servers. <p> This is illustrated in Figure 4. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. In JAWS, asynchronous I/O is implemented using the Asyn chronous Completion Token [19] pattern and Proactor <ref> [6] </ref> pattern, as illustrated in Figure 5. Reactive I/O is accomplished through the Reactor pattern [24].
Reference: [7] <author> James Hu, Sumedh Mungee, and Douglas C. Schmidt. </author> <title> Principles for Developing and Measuring High-performance Web Servers over ATM. </title> <booktitle> In Proceeedings of INFOCOM '98, </booktitle> <month> March/April </month> <year> 1998. </year>
Reference-contexts: dispatching models; Section 4 analyzes our performance measurements of JAWS-NT over an ATM network; Section 5 compares a highly optimized JAWS implementation against Netscape Enterprise and Microsoft Internet Information Server (IIS); and Section 7 presents concluding remarks. 2 The Object-Oriented Design of JAWS The UNIX version of JAWS (described in <ref> [7] </ref>) consistently outperforms other servers in our test suite of Web servers over 155 Mbps ATM networks. <p> JAWS is both a Web server and an OO framework [26] written in C++ that facilitates the development of flexible and adaptive high-performance Web systems. The optimizations, OO design principles, and patterns used in JAWS are guided by results from our empirical analysis <ref> [7, 8, 9] </ref> of Web server performance bottlenecks over high-speed ATM networks.
Reference: [8] <author> James Hu, Irfan Pyarali, and Douglas C. Schmidt. </author> <title> Measuring the Impact of Event Dispatching and Concurrency Models on Web Server Performance Over High-speed Networks. </title> <booktitle> In Proceedings of the 2 nd Global Internet Conference. IEEE, </booktitle> <month> Novem-ber </month> <year> 1997. </year>
Reference-contexts: JAWS is both a Web server and an OO framework [26] written in C++ that facilitates the development of flexible and adaptive high-performance Web systems. The optimizations, OO design principles, and patterns used in JAWS are guided by results from our empirical analysis <ref> [7, 8, 9] </ref> of Web server performance bottlenecks over high-speed ATM networks.
Reference: [9] <author> James Hu, Irfan Pyarali, and Douglas C. Schmidt. </author> <title> Applying the Proactor Pattern to High-Performance Web Servers. </title> <booktitle> In Proceedings of the 10th International Conference on Parallel and Distributed Computing and Systems. IASTED, </booktitle> <month> October </month> <year> 1998. </year>
Reference-contexts: For example, an optimized file I/O system that automatically caches open files in main memory helps to reduce latency. Likewise, support for asynchronous event dispatching [6] and the Proactor pattern <ref> [9] </ref> can increase server throughput by reducing context switching and synchronization overhead incurred from multi-threading. This paper presents two complementary strategies for developing optimized Web servers. <p> JAWS is both a Web server and an OO framework [26] written in C++ that facilitates the development of flexible and adaptive high-performance Web systems. The optimizations, OO design principles, and patterns used in JAWS are guided by results from our empirical analysis <ref> [7, 8, 9] </ref> of Web server performance bottlenecks over high-speed ATM networks. <p> Servers programmed to use I/O completion ports directly require extra data structures in addition to the run-time stack. These data structures are used to save and restore state explicitly when event completions are dispatched occur asynchronously. This complexity can be alleviated by applying the Proactor pattern <ref> [9] </ref>. This pattern supports both efficient and flexible event dispatching strategies for high-performance concurrent applications. In general, applying this pattern enables developers to leverage the performance benefits of executing operations concurrently, without exposing the complexity of I/O completion ports and asynchronous I/O directly.
Reference: [10] <editor> Prashant Jain and Douglas C. Schmidt. </editor> <publisher> Service Configurator: </publisher>
Reference-contexts: The Service Configurator pattern <ref> [10] </ref> is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [12]. This is illustrated in Figure 4.
References-found: 10

