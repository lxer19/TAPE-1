URL: http://elysium.cs.ucdavis.edu/~benson/publications/oskit-sosp16.ps
Refering-URL: http://elysium.cs.ucdavis.edu/~benson/publications/publications.html
Root-URL: http://www.cs.ucdavis.edu
Title: The Flux OSKit: A Substrate for Kernel and Language Research  
Author: Bryan Ford Godmar Back Greg Benson Jay Lepreau Albert Lin Olin Shivers 
Affiliation: University of Utah University of California, Davis Massachusetts Institute of Technology  
Abstract: Implementing new operating systems is tedious, costly, and often impractical except for large projects. The Flux OSKit addresses this problem in a novel way by providing clean, well-documented OS components designed to be reused in a wide variety of other environments, rather than defining a new OS structure. The OSKit uses unconventional techniques to maximize its usefulness, such as intentionally exposing implementation details and platform-specific facilities. Further, the OSKit demonstrates a technique that allows unmodified code from existing mature operating systems to be incorporated quickly and updated regularly, by wrapping it with a small amount of carefully designed glue code to isolate its dependencies and export well-defined interfaces. The OSKit uses this technique to incorporate over 230,000 lines of stable code including device drivers, file systems, and network protocols. Our experience demonstrates that this approach to component software structure and reuse has a surprisingly large impact in the OS implementation domain. Four real-world examples show how the OSKit is catalyzing research and development in operating systems and programming languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In Proc. of the Summer 1986 USENIX Conf., </booktitle> <pages> pages 93-112, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Section 6 presents our experience with the OSKit through several case studies. Finally, in sections 7 and 8 we present status, future work, and conclusions. 2 Related Work Many OS research projects have taken code from other existing, stable systems to reduce the startup cost of OS research: Mach <ref> [1] </ref> used device drivers from BSD and hardware vendors, the x86 port of SPIN [10] uses device drivers from FreeBSD, and VINO [30] takes its device drivers, bootstrap code, and low-level support for virtual memory from NetBSD.
Reference: [2] <author> G. R. Andrews. </author> <type> Personal communication, </type> <month> Feb. </month> <year> 1997. </year>
Reference-contexts: Later, during the Saguaro distributed operating system project, an SR im 10 plementation on the bare hardware was again considered, but aban-doned due to the lack of good development tools <ref> [2] </ref>. 6.1.4 Java Finally, in a project to create a Java [19] environment on the raw hardware, we started with Kaffe [34], a freely available and portable Java virtual machine and just-in-time compiler.
Reference: [3] <author> G. R. Andrews and R. A. Olsson. </author> <title> The SR Programming Language: Concurrency in Practice. </title> <publisher> The Benjamin/Cummings Publishing Co., </publisher> <address> Redwood City, California, </address> <year> 1993. </year>
Reference-contexts: By implementing Standard ML [26] directly on the hardware using the OSKit, we are able to model hardware resources with the constructs of a functional programming language. Our port of SR (Synchronizing Resources) <ref> [3] </ref>, a parallel language intended for systems-level programming but never extensively used for this purpose, allows us to investigate the effectiveness of using a communication-oriented language for implementing OS functionality. <p> But the details of doing so have been sufficiently forbidding as to prevent these efforts from ever being completed. 6.1.3 SR SR is a language designed for writing concurrent programs, both parallel and distributed <ref> [3] </ref>, for both application and systems software. It offers a flexible concurrency model, and includes as inherent parts of the language entities such as threads, synchronization, and communication mechanisms.
Reference: [4] <author> A. W. Appel. </author> <title> A Runtime System. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(4) </volume> <pages> 343-380, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: The trickery involved is considered sufficiently clever as to be worth reporting in the literature <ref> [4] </ref>. Since in our case the hardware is exposed in a documented manner, we just did it. No Unix; no trickery. Java provided other examples of leveraging the exposed imple 11 mentation and hardware.
Reference: [5] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: In contrast to this experience, strong groups of advanced programming language researchers have been intending, for years, to implement a sophisticated functional language directly on a raw hardware platform. For example, the Fox project at CMU <ref> [5, page 214] </ref> and the Programming Principles group at Bell Labs have at different times begun efforts to port SML/NJ to run on bare hardware.
Reference: [6] <author> A. W. Appel and D. B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <booktitle> In Third International Symp. on Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 1-13. </pages> <publisher> Springer-Verlag LNCS 528, </publisher> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: We built our system, called ML/OS, by porting the Standard ML of New Jersey (SML/NJ) implementation <ref> [6] </ref> to run on a PC using the OSKit. SML/NJ is a complex, Unix-based system comprising about 144,000 lines of code, in over 1000 source files.
Reference: [7] <author> A. Baird-Smith. </author> <title> Jigsaw An Object-Oriented Web Server in Java. </title> <address> http://www.w3.org/pub/WWW/Jigsaw/. </address>
Reference-contexts: Less than three weeks later he had built a usable system that ran complex applications such as the Jigsaw Web Server <ref> [7] </ref>, making extensive use of threads, timers, and file and network I/O. The resulting system is similar in function to Sun's JavaOS [33] but with a dramatically different implementation.
Reference: [8] <author> F. J. Ballesteros and L. L. Fernandez. </author> <title> The Network Hardware is the Operating System. </title> <booktitle> In Proc. of the Sixth Workshop on Hot Topics in Operating Systems, </booktitle> <pages> pages 32-36, </pages> <address> Cape Cod, MA, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: A few of the sites that have retrieved the OSKit have informed us of their use. Among these are researchers at the University of Car-los III in Spain who have built their Off distributed adaptable mi-crokernel <ref> [8] </ref> on top of the OSKit, and the bits and pieces microker-nel (bpmk), developed in Finland. A company, Network Storage Solutions, is using the OSKit to provide the base hardware support for a network appliance-style server.
Reference: [9] <author> G. D. Benson and R. A. Olsson. </author> <title> A Portable Run-Time System for the SR Concurrent Programming Language. </title> <booktitle> In Proceedings of the Workshop on Run-Time Systems for Parallel Processing. </booktitle> <institution> IR-417, Department of Mathematics and Computer Science, Vrije Universiteit, </institution> <address> Ams-terdam, The Netherlands, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: The standard SR implementation [31] is tightly coupled to Unix I/O and Unix sockets, thus for the work described in this paper we started with a previously developed, more platform-neutral version of SR <ref> [9] </ref>. That version removes many Unix dependencies and isolates system-dependent functionality such as threads, synchronization, and network communication. Our research goal in porting SR to the raw hardware is to investigate the effectiveness of a communication-oriented language for implementing OS functionality.
Reference: [10] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. E. Fiuczyn-ski, D. Becker, C. Chambers, and S. Eggers. </author> <title> Extensibility, Safety, and Performance in the SPIN Operating System. </title> <booktitle> In Proc. of the 15th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 267-284, </pages> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: in sections 7 and 8 we present status, future work, and conclusions. 2 Related Work Many OS research projects have taken code from other existing, stable systems to reduce the startup cost of OS research: Mach [1] used device drivers from BSD and hardware vendors, the x86 port of SPIN <ref> [10] </ref> uses device drivers from FreeBSD, and VINO [30] takes its device drivers, bootstrap code, and low-level support for virtual memory from NetBSD.
Reference: [11] <author> A. B. Brown and M. Seltzer. </author> <title> Operating System Benchmarking in the Wake of Lmbench: A Case Study of the Performance of NetBSD on the Intel x86 Architecture. </title> <booktitle> In Proc. of the 1997 ACM SIGMETRICS Conf. on Measurement and Modeling of Computer Systems, </booktitle> <address> Seattle, WA, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: We implemented a second benchmark to measure latency, similar to hbench's <ref> [11] </ref> lat tcp, called rtcp, which measures the time required for a 1-byte round trip.
Reference: [12] <author> R. Campbell, N. Islam, P. Madany, and D. Raila. </author> <title> Designing and Implementing Choices: An Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: Other VxWorks components require this thread's presence, so cannot easily be used in other environments. Several object-oriented operating systems have been created, such as Choices <ref> [12] </ref>, which provides a full operating system, and the Taligent [27] system, which provides OS services above an underlying microkernel. Like the OSKit, these systems attempt to provide an extensible OS structure built from customizable, replaceable components.
Reference: [13] <institution> Chesapeake Computer Consultants, Inc. </institution> <note> Test TCP (TTCP). http://www.ccci.com/tools/ttcp, 1997. </note>
Reference-contexts: constant when accessing physical memory in this way; this constant can simply be changed into a variable initialized by the BSD glue code on startup to point to a region of mapped physical memory. 5 Example OSKit-Based Systems The examples distributed with the OSKit include Chesapeake's Test TCP (ttcp) benchmark <ref> [13] </ref> which measures TCP send/receive bandwidth. We implemented a second benchmark to measure latency, similar to hbench's [11] lat tcp, called rtcp, which measures the time required for a 1-byte round trip.
Reference: [14] <author> D. R. Engler, M. F. Kaashoek, and J. O'Toole Jr. Exokernel: </author> <title> An Operating System Architecture for Application-Level Resource Management. </title> <booktitle> In Proc. of the 15th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 251-266, </pages> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: The OSKit allows the developer to save more time by providing common components in a convenient form, already separated out and documented. Recent research projects such as the exokernel <ref> [14] </ref>, SPIN, and VINO focus on creating extensible systems which allow applications to modify the behavior of the core OS to suit their particular needs. <p> However, these systems still define a particular, fixed set of core functionality and a set of policies by which the core can be used and extended. As the exokernel authors state, mechanism is policy, albeit with one less layer of indirection <ref> [14] </ref>. The OSKit, in contrast, makes no attempt to be a useful OS in itself and does not define any particular set of core functionality, but merely provides a suite of components from which real OS's can be built.
Reference: [15] <author> B. Ford. MOSS: </author> <title> A DOS extender based on the Flux OS Toolkit. </title> <note> Available as http://www.cs.utah.edu/projects/flux/moss/, 1996. </note>
Reference-contexts: Whereas almost all components in our system reuse existing C-based components provided by the OSKit, Sun's was primarily written anew in Java and took much longer to build. 6.1.5 Other Uses of the OSKit We used an early version of the OSKit in a DOS extender <ref> [15] </ref>, a small OS kernel that runs on MS-DOS and creates a more complete process environment for 32-bit applications; this DOS extender is now being used in commercial products.
Reference: [16] <author> B. Ford and E. S. Boleyn. </author> <title> MultiBoot Standard. </title> <note> Available as ftp://- flux.cs.utah.edu/flux/multiboot, </note> <year> 1996. </year>
Reference-contexts: To solve this problem, the OSKit directly supports the MultiBoot standard <ref> [16] </ref> which was cooperatively designed by members of several OS projects to provide a simple but general interface between boot loaders and OS kernels, allowing any compliant boot loader to load any compliant OS.
Reference: [17] <author> B. Ford, M. Hibler, J. Lepreau, P. Tullmann, G. Back, and S. Clawson. </author> <title> Microkernels Meet Recursive Virtual Machines. </title> <booktitle> In Proc. of the Second Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 137-151, </pages> <address> Seattle, WA, Oct. 1996. </address> <publisher> USENIX Assoc. </publisher>
Reference-contexts: The OSKit can be used to bootstrap unconventional operating systems quickly, such as those for embedded systems and network computers. The OSKit is heavily used in at least three OS kernels under ongoing development at different institutions. Our own microkernel-based OS, Fluke <ref> [17] </ref>, puts almost all of the OSKit to use. Over half of the Fluke kernel is OSKit code, and many of the servers and user-level utilities that run on top of this kernel also rely heavily on parts of the OSKit. <p> OSKit, and the overall experience of using the OSKit in each case; the next section will describe in more detail specific aspects of the OSKit that proved to be particularly useful in these research projects. 6.1.1 The Fluke OS In 1996 we developed an entirely new microkernel-based system called Fluke <ref> [17] </ref> to explore numerous ideas in fundamental kernel structuring, including scheduling mechanisms, execution models, IPC, and virtual memory.
Reference: [18] <author> S. Goel and D. Duchamp. </author> <title> Linux Device Driver Emulation in Mach. </title> <booktitle> In Proc. of the Annual USENIX 1996 Technical Conf., </booktitle> <pages> pages 65-73, </pages> <address> San Diego, CA, </address> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: This approach generalizes the technique explored by Goel at Columbia and Utah, in which Linux device drivers were used unchanged in the Mach 3.0 kernel <ref> [18] </ref>.
Reference: [19] <author> J. Gosling and H. McGilton. </author> <title> The Java Language Environment: </title>
Reference-contexts: Our port of SR (Synchronizing Resources) [3], a parallel language intended for systems-level programming but never extensively used for this purpose, allows us to investigate the effectiveness of using a communication-oriented language for implementing OS functionality. Finally, using a Java <ref> [19] </ref> virtual machine running on the OSKit, we have prototyped a small network computer supporting a Java-based web server and other applications, as well as an active network router that dynamically executes Java bytecode embedded in network packets. <p> Besides the obvious advantages of making the OSKit's interfaces more consistent with each other and with those widely used in component-oriented applications, COM also brings several technical advantages described below. 4.4.1 Implementation Hiding COM is founded on the notion of interfaces, which are comparable to Java <ref> [19] </ref> interfaces: they define a set of methods that can be invoked on an object without providing any direct access to the object's internal state. <p> Later, during the Saguaro distributed operating system project, an SR im 10 plementation on the bare hardware was again considered, but aban-doned due to the lack of good development tools [2]. 6.1.4 Java Finally, in a project to create a Java <ref> [19] </ref> environment on the raw hardware, we started with Kaffe [34], a freely available and portable Java virtual machine and just-in-time compiler. Kaffe is written for a standard POSIX environment, requiring support for file I/O calls such as open and read, as well as BSD's socket API.
References-found: 19

