URL: http://cs.utep.edu/gelfond/papers/priorities.ps
Refering-URL: http://cs.utep.edu/gelfond/gelfond.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: mgelfond,tson@cs.utep.edu  
Title: Reasoning with Prioritized Defaults  
Author: Michael Gelfond and Tran Cao Son 
Address: El Paso, Texas 79968  
Affiliation: Computer Science Department University of Texas at El Paso  
Abstract: The purpose of this paper is to investigate the methodology of reasoning with prioritized defaults in the language of logic programs under the answer set semantics. We present a domain independent system of axioms, written as an extended logic program, which defines reasoning with prioritized defaults. These axioms are used in conjunction with a description of a particular domain encoded in a simple language allowing representation of defaults and their priorities. Such domain descriptions are of course domain dependent and should be specified by the users. We give sufficient conditions for consistency of domain descriptions and illustrate the use of our system by formalizing various examples from the literature. Unlike many other approaches to formalizing reasoning with priorities ours does not require development of the new semantics of the language. Instead, the meaning of statements in the domain description is given by the system of (domain independent) axioms. We believe that in many cases this leads to simpler and more intuitive formalization of reasoning examples. We also present some discussion of differences between various formalizations.
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Baader, F. and Hollunder, B,: </editor> <title> Priorities on Defaults with Prerequisite and their Application in Treating Specificity in Terminological Default Logic, </title> <journal> Journal of Automated Reasoning, </journal> <volume> 15 </volume> <pages> 41-68, </pages> <year> 1995. </year> <month> 52 </month>
Reference-contexts: All these examples suggest that it may be useful to consider knowledge representation languages capable of describing defaults and preferences between them. There is a sizeable body of literature devoted to design and investigation of such languages <ref> [1, 4, 5, 6, 10, 19, 26, 28, 29, 32] </ref>. The work is too diverse and our knowledge of 1 it is not sufficient to allow a good classification but we will try to mention several important differences in approaches taken by the different authors. <p> Different choices made by the authors of default languages are expressed in their semantics given by defining the entailment and/or the derivability relation for the language. The corresponding new logics can often be viewed as "prioritized" versions of the existing general purpose non-monotonic formalisms <ref> [1, 4, 5, 6, 28, 24] </ref> with new level of complexity added in fixpoint (or other) constructions defining the semantics. <p> These defaults are represented in his formalism by a program bird: swims: (d 1 ) :f lies not f lies; penguin: (d 2 ) f lies not :f lies; bird: (d 3 ) penguin not :penguin; bird; swims: According to Brewka, the prioritized default theories from <ref> [1, 4, 24] </ref> are applicable to this case and produce single extension E 1 =fswims, bird, flies, penguing which seems contrary to intuition. <p> By construction of R (D) this is possible iff c6. def ault (d 1 ; l 0 ; [; ]); def ault (d 2 ; :l 0 ; <ref> [ 1 ; 1 ] </ref>) 2 D for some U (D), 1 U (D) and 1 consisting of -literals not belonging to U (D); l 0 ; :l 0 62 U (D), and pref er (d 1 ; d 2 ) 2 D. <p> It follows from definition of D fl that (c6) holds iff c7. def ault (d 1 ; l 0 ; []) 2 D fl , def ault (d 2 ; :l 0 ; <ref> [ 1 ] </ref>) 2 D fl and pref er (d 1 ; d 2 ) 2 D fl . which holds iff c8. r 2 R (D fl ). From (c1), (c5) and (c8) we have that R (D) and R (D fl ) are identical.
Reference: [2] <author> Baral, C. and Gelfond M.: </author> <title> Logic Programming and Knowledge Representation, </title> <journal> Journal of Logic Programming, </journal> <volume> 19,20: </volume> <pages> 73-148, </pages> <year> 1994. </year>
Reference-contexts: Many authors argued for a need for so called weak exceptions statements of the form "do not apply default d to objects satisfying property p". (For the discussion of the difference between weak and strong exceptions see, for instance, <ref> [2] </ref>.) Weak exceptions of this type can be easily incorporated in our language.
Reference: [3] <author> Brass, S. and Dix, J.: </author> <title> A Characterization of the Stable Semantics by Partial Evaluation, </title> <booktitle> Proc. of the 10th Workshop on Logic Programming, </booktitle> <address> Zuerich, </address> <month> Oct. </month> <year> 1994, 1994. </year>
Reference-contexts: rules of the form p 1 ; q; 2 by the set of rules p 1 ; 1 ; 2 : : : is equivalent to P, i.e., P and Q have the same consistent answer sets. 2 This is a well-know property of logic programs called "partial evaluation" in <ref> [3] </ref>. We were, however, unable to find a proof of it for an infinite P . 20 Proof. Let us denote the set of all rules removed from P by S and let R = Q [ S.
Reference: [4] <author> Brewka, G.: </author> <title> Reasoning about Priorities in Default Logic, </title> <booktitle> Proc. AAAI-94, </booktitle> <address> Seattle, </address> <year> 1994 </year>
Reference-contexts: All these examples suggest that it may be useful to consider knowledge representation languages capable of describing defaults and preferences between them. There is a sizeable body of literature devoted to design and investigation of such languages <ref> [1, 4, 5, 6, 10, 19, 26, 28, 29, 32] </ref>. The work is too diverse and our knowledge of 1 it is not sufficient to allow a good classification but we will try to mention several important differences in approaches taken by the different authors. <p> Different choices made by the authors of default languages are expressed in their semantics given by defining the entailment and/or the derivability relation for the language. The corresponding new logics can often be viewed as "prioritized" versions of the existing general purpose non-monotonic formalisms <ref> [1, 4, 5, 6, 28, 24] </ref> with new level of complexity added in fixpoint (or other) constructions defining the semantics. <p> The next example (from <ref> [4] </ref>, which attributes it to [20]) is more sophisticated: Not only does it require the ability to apply preferences to resolve conflicts between defaults, but also the ability of using defaults to reason about such preferences. Brewka in [4] argues that the ability to reason about preferences between defaults in the <p> The next example (from <ref> [4] </ref>, which attributes it to [20]) is more sophisticated: Not only does it require the ability to apply preferences to resolve conflicts between defaults, but also the ability of using defaults to reason about such preferences. Brewka in [4] argues that the ability to reason about preferences between defaults in the same language in which defaults are stated is important for various applications. In legal 11 reasoning similar arguments were made by Gordon, Prakken, and Sartor [20, 28]. <p> In legal 11 reasoning similar arguments were made by Gordon, Prakken, and Sartor [20, 28]. On the other hand, many formalisms developed for reasoning with prioritized defaults treat preferences as something statically given and specified separately from the corresponding default theory. Example 3.2 (Legal Reasoning <ref> [4] </ref>) Assume that a person wants to find out if her security interest in a certain ship is perfected. She currently has possession of the ship. According to the Uniform Commercial Code a security interest in goods may be perfected by taking possession of the collateral. <p> In our case the SMA has higher authority since it is federal law. Let us build the domain description D 5 which represents the above information. We will follow the formalization from <ref> [4] </ref> which uses symbols possession for "ship is a possession of the lady from the above story", perf ected for "the ownership of the ship is perfected", and f iled for "financial statement about possession of the ship is filed". <p> Thus, neither (i) nor (ii) is entailed by P (D 5 ). This is also Brewka's result in <ref> [4] </ref>. <p> This is again the desired behavior, according to <ref> [4] </ref>. It may be worth noticing that the closed world assumptions d 5 ; d 6 and d 7 have no role in the above arguments and could be removed from the domain description. They are important, however, for its general correctness. <p> These defaults are represented in his formalism by a program bird: swims: (d 1 ) :f lies not f lies; penguin: (d 2 ) f lies not :f lies; bird: (d 3 ) penguin not :penguin; bird; swims: According to Brewka, the prioritized default theories from <ref> [1, 4, 24] </ref> are applicable to this case and produce single extension E 1 =fswims, bird, flies, penguing which seems contrary to intuition.
Reference: [5] <author> Brewka, G.: </author> <title> Adding Priorities and Specificity to Default Logic, </title> <booktitle> Proc. JELIA 94, </booktitle> <publisher> Springer LNAI 838, </publisher> <pages> 247-260, </pages> <year> 1994 </year>
Reference-contexts: All these examples suggest that it may be useful to consider knowledge representation languages capable of describing defaults and preferences between them. There is a sizeable body of literature devoted to design and investigation of such languages <ref> [1, 4, 5, 6, 10, 19, 26, 28, 29, 32] </ref>. The work is too diverse and our knowledge of 1 it is not sufficient to allow a good classification but we will try to mention several important differences in approaches taken by the different authors. <p> Different choices made by the authors of default languages are expressed in their semantics given by defining the entailment and/or the derivability relation for the language. The corresponding new logics can often be viewed as "prioritized" versions of the existing general purpose non-monotonic formalisms <ref> [1, 4, 5, 6, 28, 24] </ref> with new level of complexity added in fixpoint (or other) constructions defining the semantics.
Reference: [6] <author> Brewka, G.: </author> <title> Preferred Answer Sets, </title> <booktitle> Proc. ILPS'97 Postconference Workshop, </booktitle> <pages> 76-88, </pages> <year> 1997. </year>
Reference-contexts: All these examples suggest that it may be useful to consider knowledge representation languages capable of describing defaults and preferences between them. There is a sizeable body of literature devoted to design and investigation of such languages <ref> [1, 4, 5, 6, 10, 19, 26, 28, 29, 32] </ref>. The work is too diverse and our knowledge of 1 it is not sufficient to allow a good classification but we will try to mention several important differences in approaches taken by the different authors. <p> Different choices made by the authors of default languages are expressed in their semantics given by defining the entailment and/or the derivability relation for the language. The corresponding new logics can often be viewed as "prioritized" versions of the existing general purpose non-monotonic formalisms <ref> [1, 4, 5, 6, 28, 24] </ref> with new level of complexity added in fixpoint (or other) constructions defining the semantics. <p> Consistency result can be easily expanded to rule-consistent domains representing simple hierarchies. We use the next example from Brewka <ref> [6] </ref> to illustrate differences between our theory and several other formalisms dealing with prioritized defaults. <p> According to the semantics from <ref> [6] </ref> the corresponding program has one prioritized answer set, E 2 = fswims; bird ; penguin; :fliesg which is a more intuitive result. <p> er (d 1 ; d 3 ): The program P (D 8 ) has only one answer set which contains S 1 = fholds by def ault (bird); holds by def ault (swim); holds by def ault (penguin); :holds by def ault (f lies)g: which coincides with the approach from <ref> [6] </ref>. This happens because the default d 3 is in conflict with neither d 1 nor d 2 and therefore its application is not influenced by the preference relation. <p> Therefore, in what follows, we will refer to the program Q (D) as the defeasible counterpart of D. 28 6 Relationship With Prioritized Logic Programs In this section we discuss the relationship between our theory of prioritized defaults and the prioritized logic programs recently introduced by G. Brewka <ref> [6] </ref>. In Brewka's approach, a domain description is represented by a prioritized logic program (P; &lt;) where P is a logic program with the answer set semantics representing the domain without preferences and &lt; is a preference relation among rules of P . <p> Definition 6.1 (Brewka <ref> [6] </ref>) * Let (P; &lt;) be a prioritized logic program where P is a prerequisite free program and &lt; is a total order among rules of P , we define C &lt; (P ) = S 1 i=1 S i as follows. <p> Brewka in <ref> [6] </ref>. This work can be extended in several directions. First, the results presented in the paper can be generalized to much broader classes of theories of L.
Reference: [7] <author> Covington M.A., Nute D., and Vellino A.: </author> <title> Prolog Programming in Depth, </title> <publisher> Prentice Hall, </publisher> <address> NJ, </address> <year> 1997. </year>
Reference: [8] <author> Chen, W. and Warren, </author> <title> D.S.: Query Evaluation under the Well-Founded Semantics, </title> <booktitle> The Twelfth ACM Symposium on Principles of Database System, </booktitle> <year> 1993. </year>
Reference-contexts: The resulting formalisms however 3 are quite different technically. The precise relationship between the two is not yet fully investigated. The use of the language will be illustrated by various examples from the literature. All the examples were run using the SLG inference engine <ref> [8, 9] </ref>. We believe that the study of the class of logic programs described by P and its variants can complement the existing work and help to understand reasoning with prioritized defaults. The paper is organized as follows.
Reference: [9] <author> Chen, W.: </author> <title> Extending Prolog with Nonmonotonic Reasoning, </title> <journal> Journal of LP, </journal> <pages> 169-183, </pages> <year> 1996. </year>
Reference-contexts: The resulting formalisms however 3 are quite different technically. The precise relationship between the two is not yet fully investigated. The use of the language will be illustrated by various examples from the literature. All the examples were run using the SLG inference engine <ref> [8, 9] </ref>. We believe that the study of the class of logic programs described by P and its variants can complement the existing work and help to understand reasoning with prioritized defaults. The paper is organized as follows.
Reference: [10] <author> Delgrande , J.P., Schaub, T.H.: </author> <title> Compiling Reasoning with and about Preferences into Default Logic, </title> <address> IJCAi'97, </address> <year> (1997). </year>
Reference-contexts: All these examples suggest that it may be useful to consider knowledge representation languages capable of describing defaults and preferences between them. There is a sizeable body of literature devoted to design and investigation of such languages <ref> [1, 4, 5, 6, 10, 19, 26, 28, 29, 32] </ref>. The work is too diverse and our knowledge of 1 it is not sufficient to allow a good classification but we will try to mention several important differences in approaches taken by the different authors. <p> In other words, we say that a domain description D entails a query q if q is entailed by the logic program P [ D. This approach appears to be similar in principle to the one suggested recently in <ref> [10] </ref> (which was not yet published when this work was completed). The resulting formalisms however 3 are quite different technically. The precise relationship between the two is not yet fully investigated. The use of the language will be illustrated by various examples from the literature.
Reference: [11] <author> Dix, J.: </author> <title> Classifying Semantics of Logics Programs. </title> <booktitle> In Proc. of the International Workshop in Logic Programming and Nonmonotonic Reasoning, </booktitle> <pages> 166-180, </pages> <address> Washington, DC, </address> <year> 1991. </year>
Reference: [12] <author> Dung, </author> <title> P.M.: On the Relations Between Stable and Well-Founded Semantics of Logic Programming, </title> <booktitle> Theoretical Computer Science 105 </booktitle> <month> 7-25 </month> <year> (1992). </year>
Reference-contexts: Since d 1 and d 2n+1 are conflicting their heads must be different. Hence our program has no odd cycles. As was shown by Fages [14] (see also <ref> [12] </ref>), call consistent programs with dependency graphs without positive cycles have an answer set. 26 To show consistency of the program T (a; b) consisting of rules (a) and (b) of T it suffices to take an arbitrary answer set of program T (a) and use the splitting set theorem.
Reference: [13] <author> Dung, </author> <title> P.M.: On the Acceptability of Arguments and its Fundamental Role in Non-monotonic Reasoning and Logic Programming and N-person game. </title> <booktitle> AI (77) 2 </booktitle> <month> 321-357 </month> <year> (1995). </year>
Reference: [14] <author> Fages, F.: </author> <title> Consistency of Clark's Completion and Existence of Stable Models, </title> <type> Technical Report 90-15, </type> <institution> Ecole Normale Superieure, </institution> <year> 1990. </year>
Reference-contexts: Since d 1 and d 2n+1 are conflicting their heads must be different. Hence our program has no odd cycles. As was shown by Fages <ref> [14] </ref> (see also [12]), call consistent programs with dependency graphs without positive cycles have an answer set. 26 To show consistency of the program T (a; b) consisting of rules (a) and (b) of T it suffices to take an arbitrary answer set of program T (a) and use the splitting
Reference: [15] <author> Fishburn, </author> <title> P.C.: Nonlinear Preference and Utility Theory (Johns Hopkins University Press, </title> <address> Baltimore, </address> <year> 1988). </year>
Reference-contexts: Notice, that our minimal requirements on the preference relation does not include transitivity. On the discussion of nontransitive preference relations see <ref> [15] </ref>, [21].
Reference: [16] <author> Gabbay, D.: </author> <title> Theoretical Foundation for Nonmonotonic Reasoning in Experts System. </title> <editor> In K. Apt, editor, </editor> <booktitle> Logics and models of Concurrent Systems, </booktitle> <pages> 439-457, </pages> <publisher> Springer Verlag, </publisher> <address> NY, </address> <year> 1985. </year>
Reference-contexts: We also plan a more systematic study of the class of logic programs defined by P (i.e., programs of the form P [ D). It may be interesting and useful to check if cautious monotony <ref> [16] </ref> or other general properties of defeasible inference ([22, 11]) hold for this class of programs. Another interesting class of questions is related to investigating the relationship between various versions of P.
Reference: [17] <author> Gelfond, M., Gabaldon, A.: </author> <title> From Functional Specifications to Logic Programs, 355-370, </title> <booktitle> Proc. of ILPS'97, </booktitle> <year> 1997. </year> <month> 53 </month>
Reference-contexts: The simple hierarchy is used in conjunction with a collection of statements is in (x; c) read as "x is an elements of a class c". For simplicity we assume completeness of information about relations subclass and is in. (For discussion of hierarchies with incomplete information, see <ref> [17] </ref>). The encoding of simple hierarchies will consists of two parts: the first representing a particular graph and the second containing general properties of a hierarchy together with the inheritance principle. Notice, that the second part is common to all simple hierarchies.
Reference: [18] <author> Gelfond, M., Lifschitz, V.: </author> <title> Classical Negation in Logic Programs and Disjunctive Databases, New Generation of Computing 365-387, </title> <year> 1991. </year>
Reference-contexts: We achieve these goals by mapping theories of L (also called domain descriptions) into a class of extended logic programs under the answer sets semantics <ref> [18] </ref>. <p> From (3) and lemma 5.2 we have that 4. P 2 (D) j= holds by def ault (l) iff Q p (D) j= l. As was shown in <ref> [18] </ref> answer sets of Q (D) coincide with answer sets (stable models) of Q p (D) which do not contain pairs of atoms of the form l, l. Let us show that no answer set A of Q p (D) contains such literals. <p> Then, :l 2 A. Proof. First notice that, since D is normalized, it is hierarchical. Therefore, in virtue of theorem 5.1, D is consistent. By Lemmas 5.6 and 6.1 this implies that R (D) is consistent. As was shown in <ref> [18] </ref> every answer set of consistent program is consistent which implies consistency of A.
Reference: [19] <author> Grosof, </author> <title> B.N: Prioritized Conflict Handling for Logic Programs, 197-212, </title> <booktitle> Proc. of ILPS'97, </booktitle> <year> 1997. </year>
Reference-contexts: All these examples suggest that it may be useful to consider knowledge representation languages capable of describing defaults and preferences between them. There is a sizeable body of literature devoted to design and investigation of such languages <ref> [1, 4, 5, 6, 10, 19, 26, 28, 29, 32] </ref>. The work is too diverse and our knowledge of 1 it is not sufficient to allow a good classification but we will try to mention several important differences in approaches taken by the different authors.
Reference: [20] <author> Gordon, T.: </author> <title> The Pleadings Game: An Artificial Intelligence Model of Procedural Justice. </title> <type> Ph.D. Dissertation, </type> <institution> TU Darmstadt. </institution>
Reference-contexts: The next example (from [4], which attributes it to <ref> [20] </ref>) is more sophisticated: Not only does it require the ability to apply preferences to resolve conflicts between defaults, but also the ability of using defaults to reason about such preferences. <p> Brewka in [4] argues that the ability to reason about preferences between defaults in the same language in which defaults are stated is important for various applications. In legal 11 reasoning similar arguments were made by Gordon, Prakken, and Sartor <ref> [20, 28] </ref>. On the other hand, many formalisms developed for reasoning with prioritized defaults treat preferences as something statically given and specified separately from the corresponding default theory.
Reference: [21] <author> Kosheleva, O.M. and Kreinovich, V.Ya.: </author> <title> Algorithm Problems of Nontransitive (SSB) Utilities, </title> <note> Mathematical Social Sciences 21 (1991) 95-100. </note>
Reference-contexts: Notice, that our minimal requirements on the preference relation does not include transitivity. On the discussion of nontransitive preference relations see [15], <ref> [21] </ref>.
Reference: [22] <author> Lehnmann, D., Kraus, S., and Magidor, M.: </author> <title> Nonmonotonic Reasoning, Preferential Models and Cumulative Logics, </title> <booktitle> AI (44) 1: </booktitle> <pages> 167-207, </pages> <year> 1990. </year>
Reference: [23] <author> Lifschitz, V., Turner, H.: </author> <title> Splitting a Logic Program, </title> <booktitle> Proc. of ICLP, </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Obviously, Q (D) is equivalent to Q 1 . To prove consistency of Q 1 we construct its splitting sequence and use the splitting sequence theorem from <ref> [23] </ref>. 25 Since D is hierarchical it has a rank function rank. Let be the smallest ordinal number such that rank (l) &lt; for every l from the domain of rank.
Reference: [24] <author> Marek, W. and Truszczynski, M.: </author> <title> Nonmonotonic Logic: Context-Dependent Reasoning, </title> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: Different choices made by the authors of default languages are expressed in their semantics given by defining the entailment and/or the derivability relation for the language. The corresponding new logics can often be viewed as "prioritized" versions of the existing general purpose non-monotonic formalisms <ref> [1, 4, 5, 6, 28, 24] </ref> with new level of complexity added in fixpoint (or other) constructions defining the semantics. <p> These defaults are represented in his formalism by a program bird: swims: (d 1 ) :f lies not f lies; penguin: (d 2 ) f lies not :f lies; bird: (d 3 ) penguin not :penguin; bird; swims: According to Brewka, the prioritized default theories from <ref> [1, 4, 24] </ref> are applicable to this case and produce single extension E 1 =fswims, bird, flies, penguing which seems contrary to intuition.
Reference: [25] <editor> Nelson, D.: Constructible Falsity, </editor> <volume> JSL 14(1949), </volume> <pages> 16-26. </pages>
Reference-contexts: R can be viewed as a union of P and the set of new rules obtain from P by the application of the cut inference rule. Since the cut is sound w.r.t. constructive logic N 2 [27] which is an extension of the logic N from <ref> [25] </ref>, P and R are equivalent in N 2 . As shown in [27], programs equivalent in N 2 have the same consistent answer sets, i.e., (a) programs P and R are equivalent. This means that to prove our lemma it suffices to show equivalence of R and Q.
Reference: [26] <author> Nute, D.: </author> <title> A Decidable Quantified Defeasible Logic. </title> <editor> In Prawitz, D., Skyrms, B., and Westerstahl, D. (eds): </editor> <booktitle> Logic, Methodology and Philosophy of Science IX. </booktitle> <publisher> Elsevier Science B.V., </publisher> <pages> 263-284, </pages> <year> 1994. </year>
Reference-contexts: All these examples suggest that it may be useful to consider knowledge representation languages capable of describing defaults and preferences between them. There is a sizeable body of literature devoted to design and investigation of such languages <ref> [1, 4, 5, 6, 10, 19, 26, 28, 29, 32] </ref>. The work is too diverse and our knowledge of 1 it is not sufficient to allow a good classification but we will try to mention several important differences in approaches taken by the different authors.
Reference: [27] <author> Pearce, D.: </author> <title> A New Logical Characterization of Stable Models and Answer Sets, </title> <publisher> NMELP'96, Springer, </publisher> <pages> 57-70, </pages> <year> 1997. </year>
Reference-contexts: R can be viewed as a union of P and the set of new rules obtain from P by the application of the cut inference rule. Since the cut is sound w.r.t. constructive logic N 2 <ref> [27] </ref> which is an extension of the logic N from [25], P and R are equivalent in N 2 . As shown in [27], programs equivalent in N 2 have the same consistent answer sets, i.e., (a) programs P and R are equivalent. <p> Since the cut is sound w.r.t. constructive logic N 2 <ref> [27] </ref> which is an extension of the logic N from [25], P and R are equivalent in N 2 . As shown in [27], programs equivalent in N 2 have the same consistent answer sets, i.e., (a) programs P and R are equivalent. This means that to prove our lemma it suffices to show equivalence of R and Q.
Reference: [28] <author> Prakken, H. and Sartor, G,: </author> <title> On the relation between legal language and legal argument: assumptions, applicability and dynamic priorities. </title> <booktitle> Proc. of the Fifth International Conference on AI and Law, </booktitle> <address> Maryland, College Park, MD USA, 1-10, </address> <year> 1995. </year>
Reference-contexts: All these examples suggest that it may be useful to consider knowledge representation languages capable of describing defaults and preferences between them. There is a sizeable body of literature devoted to design and investigation of such languages <ref> [1, 4, 5, 6, 10, 19, 26, 28, 29, 32] </ref>. The work is too diverse and our knowledge of 1 it is not sufficient to allow a good classification but we will try to mention several important differences in approaches taken by the different authors. <p> Different choices made by the authors of default languages are expressed in their semantics given by defining the entailment and/or the derivability relation for the language. The corresponding new logics can often be viewed as "prioritized" versions of the existing general purpose non-monotonic formalisms <ref> [1, 4, 5, 6, 28, 24] </ref> with new level of complexity added in fixpoint (or other) constructions defining the semantics. <p> Brewka in [4] argues that the ability to reason about preferences between defaults in the same language in which defaults are stated is important for various applications. In legal 11 reasoning similar arguments were made by Gordon, Prakken, and Sartor <ref> [20, 28] </ref>. On the other hand, many formalisms developed for reasoning with prioritized defaults treat preferences as something statically given and specified separately from the corresponding default theory. <p> The following example, taken from <ref> [28] </ref>, illustrates the use of the new language. Example 4.1 [29] Consider the following two legal default rules from [29]: 1. Normally, a person who cannot be shown to be a minor has the capacity to perform legal acts. 2.
Reference: [29] <author> Prakken, H. and Sartor, G.: </author> <title> Argument-based extended logic programming with defea-sible priorities. </title> <journal> Journal of applied non-classical logics, </journal> <volume> 1,2 (7), </volume> <pages> 25-77, </pages> <year> 1997. </year>
Reference-contexts: All these examples suggest that it may be useful to consider knowledge representation languages capable of describing defaults and preferences between them. There is a sizeable body of literature devoted to design and investigation of such languages <ref> [1, 4, 5, 6, 10, 19, 26, 28, 29, 32] </ref>. The work is too diverse and our knowledge of 1 it is not sufficient to allow a good classification but we will try to mention several important differences in approaches taken by the different authors. <p> The following example, taken from [28], illustrates the use of the new language. Example 4.1 <ref> [29] </ref> Consider the following two legal default rules from [29]: 1. Normally, a person who cannot be shown to be a minor has the capacity to perform legal acts. 2. In order to exercise the right to vote the person has to demonstrate that he is not a minor. <p> The following example, taken from [28], illustrates the use of the new language. Example 4.1 <ref> [29] </ref> Consider the following two legal default rules from [29]: 1. Normally, a person who cannot be shown to be a minor has the capacity to perform legal acts. 2. In order to exercise the right to vote the person has to demonstrate that he is not a minor.
Reference: [30] <author> Reiter, R.: </author> <title> On closed world data bases. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and data bases, </booktitle> <pages> 55-76, </pages> <year> 1978. </year>
Reference-contexts: the informal description will be represented by the collection F of facts: student (mary): dept (cs): is in (mary; cs): student (mike): dept (art): is in (mike; art): student (sam): dept (cis): is in (sam; cis): : : : : : : : : : and the closed world assumption <ref> [30] </ref> for is in, written as the default def ault (d3 (S; D); :is in (S; D); [ ]): Relations student and dept are, of course, not necessary.
Reference: [31] <author> Reiter R.: </author> <title> A Logic for Default Reasoning in Readings in Nonmonotonic Reasoning, Edited by M. </title> <editor> L. Ginsberg, </editor> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, California (1987) 68-93 </address>
Reference-contexts: We show how to extend the language and the corresponding collection of axioms to allow the representation of more powerful defaults and default defeaters. 4.1 Beyond normal defaults So far, our language L 0 allowed only the representation of normal defaults <ref> [31] </ref>. In this section we expand the language and the corresponding system of axioms to make it capable of representing more general types of defaults.
Reference: [32] <author> Zhang, Y. and Foo , N.Y.: </author> <title> Answer Sets for Prioritized Logic Programs, 69-84, </title> <booktitle> Proc. of ILPS'97, </booktitle> <year> 1997. </year> <month> 54 </month>
Reference-contexts: All these examples suggest that it may be useful to consider knowledge representation languages capable of describing defaults and preferences between them. There is a sizeable body of literature devoted to design and investigation of such languages <ref> [1, 4, 5, 6, 10, 19, 26, 28, 29, 32] </ref>. The work is too diverse and our knowledge of 1 it is not sufficient to allow a good classification but we will try to mention several important differences in approaches taken by the different authors.
References-found: 32

