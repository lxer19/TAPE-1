URL: ftp://wilma.cs.brown.edu/u/mfc/proposal.ps.Z
Refering-URL: http://www.cs.brown.edu/software/cokokola/
Root-URL: http://www.cs.brown.edu
Title: Building Query Optimizers with Combinators:  
Author: Mitch Cherniack 
Degree: Dissertation Proposal  
Abstract: Query optimizers generate plans to retrieve data specified by queries. Query optimization for object databases (i.e., object-oriented and object-relational databases) is an immature field, and stands to benefit from adaptation of techniques that have proved useful for relations. One technique uses query-to-query transformations to rewrite queries into queries that are potentially more amenable to plan generation. For transformations to be useful, they must preserve the semantics of the queries they rewrite (correctness) and usually result in queries that generate better plans (effectiveness). Object databases complicate the expression of correct and effective transformations. Transformation correctness is problematic even for relational queries. Especially error-prone are transformations that rewrite complex nested queries (queries containing other queries) or queries that return duplicates. Objects make correctness more difficult because object queries can be far more complex than relational queries. The effectiveness of a relational transformation typically depends on the syntax of a query rather than the semantics of of its data or functions. On the other hand, the lack of uniformity in data functions and collections in an object query makes effectiveness more subtle. The effectiveness of a transformation for object queries may depend on the semantics of data functions, and may vary from object to object in a collection. Therefore, optimizers may have to perform sophisticated reasoning and apply transformations on a per object basis to ensure that they are used only when appropriate. This thesis considers the correctness and effectiveness of optimizer transformations. To address correctness, we propose a formally specified query algebra and two-tiered language (COKO-KOLA) for expressing transformations that can be verified with a theorem prover. To address effectiveness, we propose semantic and dynamic extensions to the traditional optimizer architecture. The high-level contribution of the thesis is the observation that the choice of query representation impacts the quality of the optimizer. Specifically, a combinator-based (variable-free) query representation simplifies the query manipulations that are required to make transformations correct and effective.
Abstract-found: 1
Intro-found: 1
Reference: [AF95] <author> Karl Aberer and Gisela Fischer. </author> <title> Semantic query optimization for methods in object-oriented database systems. </title> <editor> In P. S. Yu and A. L. P. Chen, editors, </editor> <booktitle> Proceedings of the 11th International Conference on Data Engineering, </booktitle> <pages> pages 70-79, </pages> <address> Taipei, Taiwan, </address> <year> 1995. </year>
Reference-contexts: about: * Opt++ [KD] 7.3 Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer <ref> [AF95] </ref> * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] *
Reference: [AFTU96] <author> Laurent Amsaleg, Michael J. Franklin, Anthony Tomasic, and Tolga Urhan. </author> <title> Scrambling query plans to cope with unexpected delays. </title> <booktitle> In 4th International Conference on Parallel and Distributed Information Systems (PDIS 96), </booktitle> <address> Miami Beach, FL, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query Scrambling <ref> [AFTU96] </ref> 133 8 Future Work The proposed thesis will have the following structure: * Section 1: Introduction (from Section 1 of proposal) * Section 2: Motivation (from Section 2 of proposal) * Section 3: KOLA (from Section 3 of proposal) * Section 4: COKO (from Section 4 of proposal) * Section
Reference: [Ant96] <author> Gennady Antoshenkov. </author> <title> Dynamic optimization of index scans restricted by booleans. </title> <editor> In Stanley Y. W. Su, editor, </editor> <booktitle> Twelfth International Conference on Data Engineering, </booktitle> <pages> pages 430-440, </pages> <address> New Orleans, LA, </address> <month> February </month> <year> 1996. </year> <title> IEEE, </title> <publisher> IEEE Computer Science Press. </publisher>
Reference-contexts: * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov <ref> [Ant96, AZ96] </ref> * Query Scrambling [AFTU96] 133 8 Future Work The proposed thesis will have the following structure: * Section 1: Introduction (from Section 1 of proposal) * Section 2: Motivation (from Section 2 of proposal) * Section 3: KOLA (from Section 3 of proposal) * Section 4: COKO (from Section
Reference: [AZ96] <author> Gennady Antoshenkov and Mohamed Ziauddin. </author> <title> Query processing and optimization in Oracle Rdb. </title> <journal> VLDB Journal, </journal> <volume> 5(4) </volume> <pages> 229-237, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov <ref> [Ant96, AZ96] </ref> * Query Scrambling [AFTU96] 133 8 Future Work The proposed thesis will have the following structure: * Section 1: Introduction (from Section 1 of proposal) * Section 2: Motivation (from Section 2 of proposal) * Section 3: KOLA (from Section 3 of proposal) * Section 4: COKO (from Section
Reference: [Bac78] <author> J. W. Backus. </author> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 613-641, </pages> <month> August </month> <year> 1978. </year>
Reference: [BF79] <author> Peter Buneman and Robert E. Frankel. </author> <title> FQL a functional query language. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <year> 1979. </year>
Reference-contexts: The work of this thesis will include a translator from OQL to KOLA and a proof of its correctness. <ref> [BF79] </ref> and [BK90] both propose an FP-style language to be used as an internal algebra of queries manipulated by an optimizer. Like [BG84], neither [BF79] nor [BK90] describe translation techniques to map queries expressed in query languages with variables into their formalism. <p> The work of this thesis will include a translator from OQL to KOLA and a proof of its correctness. <ref> [BF79] </ref> and [BK90] both propose an FP-style language to be used as an internal algebra of queries manipulated by an optimizer. Like [BG84], neither [BF79] nor [BK90] describe translation techniques to map queries expressed in query languages with variables into their formalism. Since Turner's seminal paper [Tur79], combinators have been used within functional language compilers as internal representations of -expressions.
Reference: [BFKM85] <author> Lee Brownston, Robert Farrell, Elaine Kant, and Nancy Martin. </author> <title> Programming Expert Systems in OPS5: An Introduction to Rule-Based Programming. </title> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: Below, we describe how other systems express algebraic-level query rewrites. Expressing Complex Query Rewrites with Code In most rule-based systems, complex query rewrites are expressed with rules. However, the rules of these systems are not declarative rewrite rules. Starburst [PHH92] fire production rules (as in expert systems such as <ref> [BFKM85] </ref>) during the query rewriting phase of optimization. These rules consist of two code routines (loosely corresponding to the lhs and rhs of a rewrite rule) written in C.
Reference: [BG84] <author> A. Bossi and C. Ghezzi. </author> <title> Using FP as a query language for relational data-bases. </title> <journal> Computer Languages, </journal> <volume> 9(1) </volume> <pages> 25-37, </pages> <year> 1984. </year>
Reference-contexts: But combinator-style languages are difficult for users to master and thus ill-suited as query languages. <ref> [BG84] </ref> consider the benefits of FP-style languages with respect to formalization but provide no means of mapping query expressions into their FP-style algebra. <p> The work of this thesis will include a translator from OQL to KOLA and a proof of its correctness. [BF79] and [BK90] both propose an FP-style language to be used as an internal algebra of queries manipulated by an optimizer. Like <ref> [BG84] </ref>, neither [BF79] nor [BK90] describe translation techniques to map queries expressed in query languages with variables into their formalism. Since Turner's seminal paper [Tur79], combinators have been used within functional language compilers as internal representations of -expressions.
Reference: [BG92] <author> Ludger Becker and Ralf Hartmut Guting. </author> <title> Rule-based optimization and query processing in an extensible geometric database system. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(2) </volume> <pages> 247-303, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Exodus [CDG + 90] (and its successors, Volcano [GM93] and Cascades [Gra95]) and ESL [FG94] use rules that resemble rewrite rules, but that can have code supplements. Code supplements make rewrite rules more expressive, but at the expense of understandability. 130 Of the rule-based systems, Gral <ref> [BG92] </ref> comes closest to ours in its effort to make rules declara-tive by avoiding code. Gral also expands the expressive power of a rewrite rule, but not by adding code supplements as in Exodus of ESL. <p> Still to write about: * Cascades [Gra95, ONK + 95] (in more detail) * CROQUE [HK96] * Steenhagen [SABd94] Expressing Complex Query Rewrites with Rule Groups or Modules Many systems (e.g. [PHH92], <ref> [BG92] </ref>, [FG94], [MDZ93] [LV91], [SSJ90]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. Rule groups can be associated with search strategies that indicate how the rules in a group should be fired. <p> Thus, whereas COKO groups rules to cooperatively specify a query rewrite, other systems group rules to "face-off" against one another. The search strategies that are provided by these systems reflect this objective. Most (e.g., [PHH92], <ref> [BG92] </ref>, [FG94]) include exhaustive search (fire everything everywhere until firing no longer has any effect), with the goal of generating all possible alternatives before comparing them. <p> Other systems provide pruning strategies so that only some alternatives are generated (e.g, [SSJ90] provide such strategies as branch-and-bound and simulated annealing). Some systems permit an evaluation of rules (e.g., [PHH92], [MDZ93] and [CDG + 90]) or of algebraic operators (e.g., <ref> [BG92] </ref>) to decide on a rule that should be fired next, so that poor alternatives aren't generated. COKO groups KOLA rules, not to generate alternatives, but to modularize the expression of a single complex query rewrite. There is no search involved.
Reference: [Bis93] <author> Kurt M. Bischoff. </author> <title> Ox: An attribute-grammar compiling system based on yacc, lex and c: User reference manual. User Manual, </title> <year> 1993. </year>
Reference-contexts: Like the present translator, the translator that will be built for the final thesis will be built with the Ox <ref> [Bis93] </ref> attribute-grammar based compiler generator.
Reference: [BK90] <author> Catriel Beeri and Yoram Kornatzky. </author> <title> Algebraic optimization of object-oriented query languages. </title> <editor> In S. Abiteboul and P. C. Kanellakis, editors, </editor> <booktitle> Proceedings of the Third International Conference on Database Theory, number 470 in Lecture Notes in Computer Science, </booktitle> <pages> pages 72-88, </pages> <address> Paris, France, </address> <month> December </month> <year> 1990. </year> <title> EATCS, </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The work of this thesis will include a translator from OQL to KOLA and a proof of its correctness. [BF79] and <ref> [BK90] </ref> both propose an FP-style language to be used as an internal algebra of queries manipulated by an optimizer. Like [BG84], neither [BF79] nor [BK90] describe translation techniques to map queries expressed in query languages with variables into their formalism. <p> The work of this thesis will include a translator from OQL to KOLA and a proof of its correctness. [BF79] and <ref> [BK90] </ref> both propose an FP-style language to be used as an internal algebra of queries manipulated by an optimizer. Like [BG84], neither [BF79] nor [BK90] describe translation techniques to map queries expressed in query languages with variables into their formalism. Since Turner's seminal paper [Tur79], combinators have been used within functional language compilers as internal representations of -expressions.
Reference: [BTBW92] <author> Val Breazu-Tannen, Peter Buneman, and Limsoon Wong. </author> <title> Naturally embedded query languages. </title> <editor> In J. Biskup and R. Hull, editors, </editor> <booktitle> Database Theory - ICDT'92, 4th International Conference, volume 646 of LNCS. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Still to write about: * Naturally Embedded Query Languages <ref> [BTBW92] </ref> * Complexity of Translations [JRSB85] 7.2 Comparing COKO with Query Rewrites of Rule-Based Optimizers Many rule-based systems (e.g. [Loh88], [FMS93]) use rules to map algebraic operators to plan-level implementations.
Reference: [Cat93] <author> R.G.G. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <address> Morgan-Kaufman, </address> <year> 1993. </year>
Reference-contexts: Traditional architectures follow the "assembly line" approach to processing queries illustrated in Figure 1: * Translation preceeds Optimization. Translation takes a query posed in a user-level query language (such as SQL or OQL <ref> [Cat93] </ref>) and translates it into a query representation understood by the optimizer. * Algebraic Optimization preceeds Plan Generation.
Reference: [CDG + 90] <author> Michael J. Carey, David J. DeWitt, Goetz Graefe, David M. Haight, Joel E. Richardson, Daniel T. Schuh, Eugene J. Shekita, and Scott L. Vandenberg. </author> <title> The EXODUS extensible 140 DBMS project: An overview. </title> <editor> In Stanley B. Zdonik and David Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 474-499. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, California, </address> <year> 1990. </year>
Reference-contexts: KOLA is a query representation for rule-based optimizers <ref> [CDG + 90, Fre87] </ref>: optimizers that express query transformations incrementally in terms of rules. <p> Different rule-based systems express these components differently. Starburst [HFLP89] expresses each part algorithmically with C code that performs the matching and modification. Exodus and Volcano <ref> [CDG + 90, GM93] </ref> also use code, but as supplements to rewrite rules which specify both matching and modification. Rewrite rules are declarative expressions of transformations. The left-hand side of a rule (its head) consists of a pattern with unification variables. <p> This was the intended purpose of rules when first proposed ([Fre87]), and also characterizes one of the two kinds of rules used in Exodus <ref> [CDG + 90] </ref> and Starburst [HFLP89]. KOLA and COKO express query rewrites (i.e., query-to-query mappings) rather than query-to-plan mappings, and hence are incomparable to the rules of these systems. Below, we describe how other systems express algebraic-level query rewrites. <p> However, Starburst rules are difficult to understand and reason about, requiring a detailed understanding of the underlying graph-based query representation (QGM). Exodus <ref> [CDG + 90] </ref> (and its successors, Volcano [GM93] and Cascades [Gra95]) and ESL [FG94] use rules that resemble rewrite rules, but that can have code supplements. <p> Other systems provide pruning strategies so that only some alternatives are generated (e.g, [SSJ90] provide such strategies as branch-and-bound and simulated annealing). Some systems permit an evaluation of rules (e.g., [PHH92], [MDZ93] and <ref> [CDG + 90] </ref>) or of algebraic operators (e.g., [BG92]) to decide on a rule that should be fired next, so that poor alternatives aren't generated. COKO groups KOLA rules, not to generate alternatives, but to modularize the expression of a single complex query rewrite. There is no search involved. <p> [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano <ref> [CDG + 90, GM93] </ref> * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query Scrambling [AFTU96] 133 8 Future Work The proposed thesis will have the following structure: * Section 1: Introduction (from Section 1 of proposal)
Reference: [cen] <institution> United States Census Bureau web site. </institution> <note> Located at http:nnwww.census.gov. </note>
Reference-contexts: Each congressional committee is also represented, including such information as its topic, chair and membership. Thomas also includes links to related sites such as the United States Census Bureau <ref> [cen] </ref> which maintains information about each state and district such as the largest university each is home to. Thomas is not a database but a file system with hyperlinks.
Reference: [CG94] <author> Richard L. Cole and Goetz Graefe. </author> <title> Optimization of dynamic query execution plans. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 150-160, </pages> <address> Minneapolis, MN, </address> <year> 1994. </year>
Reference-contexts: * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward <ref> [GW89, CG94] </ref> * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query Scrambling [AFTU96] 133 8 Future Work The proposed thesis will have the following structure: * Section 1: Introduction (from Section 1 of proposal) * Section 2: Motivation (from Section 2 of proposal) * Section 3:
Reference: [Che95] <author> Mitch Cherniack. </author> <title> Form(ers) over function(s): The KOLA query algebra. </title> <type> Technical report, </type> <institution> Brown University Department of Computer Science, </institution> <month> May </month> <year> 1995. </year> <note> In preparation. </note>
Reference-contexts: An informal description of the object types supported by the KOLA data model follows. <ref> [Che95] </ref> presents formal Larch [GHG + 92] specifications of the objects described. * Base Types The base types supported in KOLA are the immutable types Bool (booleans), Int (integers), Char (characters), Float (floats) and String (strings). <p> These tables are intended to provide a brief summary of KOLA, and therefore express KOLA's semantics somewhat informally. A formal semantics of a set-based version of KOLA expressed in Larch [GHG + 92] is described briefly in Section 3.4 and fully in <ref> [Che95] </ref>. Table 2: KOLA's Primitives: KOLA's primitives functions and predicates are listed in Table 2. Primitive functions include the identity function (id) defined over all types, and projection functions ( 1 and 2 ) defined over all pair types. <p> This completes the second proof, and therefore the proof as a whole. Well over 300 rules over the set-based version of KOLA have been verified with LP (these are presented in <ref> [Che95] </ref>). <p> Completed work thus far includes a formal LSL specification of a set-based version of KOLA (with all operators defined over and returning sets), and theorem prover scripts for over 300 rewrite rules over this version of the algebra. This work is described in <ref> [Che95] </ref>. Thus, KOLA's formal specification must yet be extended to account for bags. OQL ! KOLA Translation: The final thesis will include an implementation for a translator from a set and bag-based subset of OQL into KOLA.
Reference: [Che96] <author> Mitch Cherniack. </author> <title> Translating queries into combinators. </title> <type> Technical Report CS-96-40, </type> <institution> Brown University Department of Computer Science, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: free algebra over which one could translate all of the -calculus. (It was even shown later that I was superfluous!) Within the context of querying, the rich expressivity of KOLA has been established via a design, correctness proof and prototype implementation of a translator from OQL to KOLA (presented in <ref> [Che96] </ref>). 8 3.6.3 Addressing The Downsides of KOLA KOLA Query Representations Are Larger than Variable-Based Representations: KOLA query representations tend to be larger than their variable-based counterparts (as measured in parse tree nodes).
Reference: [CM93] <author> Sophie Cluet and Guido Moerkotte. </author> <title> Nested queries in object bases. </title> <booktitle> In Proc. 4th Int'l Workshop on Database Programming Languages, </booktitle> <address> NY, NY, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: Still to write about: * Opt++ [KD] 7.3 Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte <ref> [CM95, CM93] </ref> * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG
Reference: [CM95] <author> Sophie Cluet and Guido Moerkotte. </author> <title> Efficient evaluation of aggregates on bulk types. </title> <booktitle> In Proc. 5th Int'l Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Umbria, Italy, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: Still to write about: * Opt++ [KD] 7.3 Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte <ref> [CM95, CM93] </ref> * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG
Reference: [CS93] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Query optimization in the presence of foreign functions. </title> <booktitle> In Proceedings of the 19th VLDB Conference, </booktitle> <pages> pages 529-542, </pages> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim <ref> [CS96, CS93] </ref> * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 *
Reference: [CS96] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Optimization of queries with user-defined predicates. </title> <booktitle> In Proceedings of the 22nd VLDB Conference, </booktitle> <pages> pages 87-110, </pages> <address> Bombay, India, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim <ref> [CS96, CS93] </ref> * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 *
Reference: [Cur93] <author> Pierre-Louis Curien. </author> <title> Categorical Combinators, Sequential Algorithms, and Functional Programming. </title> <publisher> Birkhauser, </publisher> <year> 1993. </year>
Reference-contexts: This translator resembles combinator translators for the -calculus, and especially (because of some similarities in the combinator sets) the translator for the -calculus into Curien's set of categorical combinators <ref> [Cur93] </ref>. Like the present translator, the translator that will be built for the final thesis will be built with the Ox [Bis93] attribute-grammar based compiler generator.
Reference: [CZ96] <author> Mitch Cherniack and Stanley B. Zdonik. </author> <title> Rule languages and internal algebras for rule-based optimizers. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <address> Montreal, Quebec, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Aside from these, we have also implemented (and generalized) the query unnesting transformations of [Kim82] (modulo their bug fixes) and the nested object query transformation presented in <ref> [CZ96] </ref>. Though COKO is evolving, this is not to say that it is immature. We believe that COKO already provides most of the useful idioms required to express query rewriting.
Reference: [CZN95] <author> Mitch Cherniack, Stanley B. Zdonik, and Marian H. Nodine. </author> <title> To form a more perfect union (intersection, difference). </title> <booktitle> In Proc. 5th Int'l Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Italy, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: KOLA differs from AQUA primarily in form rather than spirit, with a few exceptions as presented in <ref> [CZN95] </ref>. <p> On the other hand, mutable objects should not be compared on the basis of their mutable states as this makes their identities ephemeral and provokes unintuitive behaviors in any collections that contain them <ref> [CZN95] </ref>. Rather, mutable objects are assumed 24 to be implemented with object identifiers (OID's) which are not queryable, and are used by the runtime system to decide if two objects are equal.
Reference: [Day87] <author> Umeshwar Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested subqueries, aggregates and quantifiers. </title> <editor> In Peter M. Stocker, William Kent, and Peter Hammersley, editors, </editor> <booktitle> Proceedings if the 13th International Conference on Very Large Databases, </booktitle> <pages> pages 197-208, </pages> <address> Brighton, England, </address> <month> September </month> <year> 1987. </year> <month> Morgan-Kaufman. </month>
Reference-contexts: This provides many performance benefits, speeding up the process of query rewriting and freeing up more time for an optimizer to perform its search. Still to write about: * Opt++ [KD] 7.3 Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal <ref> [Day87] </ref> * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost
Reference: [DGK + 91] <author> Scott Daniels, Goetz Graefe, Thomas Keller, David Maier, Duri Schmidt, and Bennet Vance. </author> <title> Query optimization in Revelation, an overview. </title> <journal> Quarterly Bulletin of the IEEE Computer Society technical committee on Data Engineering, </journal> <volume> 14(2) </volume> <pages> 58-62, </pages> <month> June </month> <year> 1991. </year> <month> 141 </month>
Reference-contexts: Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA <ref> [DGK + 91, Gra95] </ref> * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query Scrambling [AFTU96] 133 8 Future Work The proposed thesis will have the following structure: * Section 1: Introduction (from Section 1 of proposal) * Section 2: Motivation (from Section
Reference: [EL91] <author> Martin Erwig and Udo W. Lipeck. </author> <title> A functional DBPL revealing high level optimiza-tions. </title> <editor> In Paris Kanellakis and Joachim W. Schmidt, editors, </editor> <title> Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, pages 306-, </booktitle> <address> Nafplion, Greece, August 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: Still to write about: * AQUA [LMS + 93] * EXTRA [VD91] * OFL [GMP95] * GOM [KMP87] * Fegaras and Maier [FM95] * CROQUE [GKG + 97] * Steenhagen [SABd94] 7.1.2 Combinator-Based Query Algebras We are not the first to suggest that a combinator-style for queries facilitates optimizer formalization. <ref> [EL91] </ref> consider the benefits of an FP-style ([Bac78]) query language from the perspective of optimization, but by proposing an FP-style query language.
Reference: [FG94] <author> Beatrice Finance and Georges Gardarin. </author> <title> A rule-based query optimizer with multiple search strategies. </title> <journal> Data and Knowledge Engineering, </journal> <volume> 13 </volume> <pages> 1-29, </pages> <year> 1994. </year>
Reference-contexts: However, Starburst rules are difficult to understand and reason about, requiring a detailed understanding of the underlying graph-based query representation (QGM). Exodus [CDG + 90] (and its successors, Volcano [GM93] and Cascades [Gra95]) and ESL <ref> [FG94] </ref> use rules that resemble rewrite rules, but that can have code supplements. Code supplements make rewrite rules more expressive, but at the expense of understandability. 130 Of the rule-based systems, Gral [BG92] comes closest to ours in its effort to make rules declara-tive by avoiding code. <p> Still to write about: * Cascades [Gra95, ONK + 95] (in more detail) * CROQUE [HK96] * Steenhagen [SABd94] Expressing Complex Query Rewrites with Rule Groups or Modules Many systems (e.g. [PHH92], [BG92], <ref> [FG94] </ref>, [MDZ93] [LV91], [SSJ90]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. Rule groups can be associated with search strategies that indicate how the rules in a group should be fired. <p> Thus, whereas COKO groups rules to cooperatively specify a query rewrite, other systems group rules to "face-off" against one another. The search strategies that are provided by these systems reflect this objective. Most (e.g., [PHH92], [BG92], <ref> [FG94] </ref>) include exhaustive search (fire everything everywhere until firing no longer has any effect), with the goal of generating all possible alternatives before comparing them. Some systems permit some variations on exhaustive search (such as prioritizing rules [PHH92] or binding the number of passes over the query in advance [FG94]). <p> [BG92], <ref> [FG94] </ref>) include exhaustive search (fire everything everywhere until firing no longer has any effect), with the goal of generating all possible alternatives before comparing them. Some systems permit some variations on exhaustive search (such as prioritizing rules [PHH92] or binding the number of passes over the query in advance [FG94]). Other systems provide pruning strategies so that only some alternatives are generated (e.g, [SSJ90] provide such strategies as branch-and-bound and simulated annealing).
Reference: [FH88] <author> Anthony J. Field and Peter G. Harrison. </author> <title> Functional Programming. </title> <publisher> International Computer Science Press. Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Since Turner's seminal paper [Tur79], combinators have been used within functional language compilers as internal representations of -expressions. The purpose of this is to make evaluation by graph reduction more efficient, as -expressions with free variables force unnecessary copying of potentially large function bodies <ref> [FH88] </ref>. Approaches to combinator translations can be classified according to whether the combinator set is fixed or variable. Fixed combinator sets consist of a finite set of combinators that are used as the target for all -expression translations.
Reference: [FM95] <author> Leonidas Fegaras and David Maier. </author> <title> Towards an effective calculus for object query languages. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 47-58, </pages> <year> 1995. </year>
Reference-contexts: The literature review is divided by category. 7.1 Comparing KOLA with Query Algebras 7.1.1 Object Query Algebras Still to write about: * AQUA [LMS + 93] * EXTRA [VD91] * OFL [GMP95] * GOM [KMP87] * Fegaras and Maier <ref> [FM95] </ref> * CROQUE [GKG + 97] * Steenhagen [SABd94] 7.1.2 Combinator-Based Query Algebras We are not the first to suggest that a combinator-style for queries facilitates optimizer formalization. [EL91] consider the benefits of an FP-style ([Bac78]) query language from the perspective of optimization, but by proposing an FP-style query language.
Reference: [FMS93] <author> Leonidas Fegaras, David Maier, and Tim Sheard. </author> <title> Specifying rule-based query opti-mizers in a reflective framework. In Stefano Ceri, Katsumi Tanaka, </title> <editor> and Shalom Tsur, editors, </editor> <booktitle> Proceedings of the International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 146-168, </pages> <year> 1993. </year>
Reference-contexts: Still to write about: * Naturally Embedded Query Languages [BTBW92] * Complexity of Translations [JRSB85] 7.2 Comparing COKO with Query Rewrites of Rule-Based Optimizers Many rule-based systems (e.g. [Loh88], <ref> [FMS93] </ref>) use rules to map algebraic operators to plan-level implementations. This was the intended purpose of rules when first proposed ([Fre87]), and also characterizes one of the two kinds of rules used in Exodus [CDG + 90] and Starburst [HFLP89].
Reference: [Fre87] <author> Johann Christoph Freytag. </author> <title> A rule-based view of query optimization. </title> <editor> In Umeshwar Dayal and Irv Traiger, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 173-180, </pages> <address> San Francisco, California, </address> <month> May </month> <year> 1987. </year> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press. </publisher>
Reference-contexts: KOLA is a query representation for rule-based optimizers <ref> [CDG + 90, Fre87] </ref>: optimizers that express query transformations incrementally in terms of rules.
Reference: [GHG + 92] <author> J.V. Guttag, J.J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specifications. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A full translator of OQL into KOLA is currently under development. 2. Algebraic Optimizer Generator: A COKO compiler has been implemented that generates C++ classes from COKO transformations. As well, over 300 KOLA rules that could be used in COKO transformations have been verified with the Larch <ref> [GHG + 92] </ref> theorem prover (LP) with respect to a Larch specification of KOLA. 3. Evaluator: Presently under development is a KOLA query evaluator (SODA) that can be configured to call any set of optimizer modules generated by the COKO compiler. <p> An informal description of the object types supported by the KOLA data model follows. [Che95] presents formal Larch <ref> [GHG + 92] </ref> specifications of the objects described. * Base Types The base types supported in KOLA are the immutable types Bool (booleans), Int (integers), Char (characters), Float (floats) and String (strings). <p> A standard interface for these types is assumed, as is described formally in the library traits Boolean, Integer, Char, FloatingPoint and String) of Larch <ref> [GHG + 92] </ref>. * Class Types KOLA permits queries over collections of objects that are instances of class types. It is assumed that a class definition defines an interface to which queries have access. <p> These tables are intended to provide a brief summary of KOLA, and therefore express KOLA's semantics somewhat informally. A formal semantics of a set-based version of KOLA expressed in Larch <ref> [GHG + 92] </ref> is described briefly in Section 3.4 and fully in [Che95]. Table 2: KOLA's Primitives: KOLA's primitives functions and predicates are listed in Table 2. <p> Reason About KOLA Rewrite Rules 3.4.1 Specifying KOLA with LSL Set-based versions of the KOLA data model and algebra have been formally specified with the Larch algebraic specification language, LSL. 6 Basic traits such as Char, Int, Bool, FloatingPoint and String adhere to the traits defined in the Larch library <ref> [GHG + 92] </ref>. <p> As we showed in the previous section, this can be done with help from a theorem prover <ref> [GHG + 92] </ref>. At the same time, COKO firing algorithms make transformations capable of expressing a wide variety of efficient query rewrites, as we show in this section. COKO generalizes and extends KOLA. <p> Therefore, CNF-NE is semantics-preserving if both rewrite rules are semantics-preserving. dist1 and dist2 are proved to be semantics preserving by execution of the LP <ref> [GHG + 92] </ref> theorem prover scripts of Appendix A. 2 Lemma 4.1 Let p be a KOLA predicate tree lacking negations, and whose child subtrees are in CNF. Then CNFAux (p) is in CNF. Proof: (By induction on the height, h (p) of the highest &-node in p. <p> Therefore, SNF is semantics-preserving if these rules are semantics-preserving. CNF's rules are proven to be semantics-preserving by execution of the LP <ref> [GHG + 92] </ref> theorem prover scripts of Appendix A. All other rules are proven to be semantics-preserving by execution of the LP [GHG + 92] theorem prover scripts of Appendix B. 2 4.4.2 Behavior Correctness Behavior correctness for SNF is tricky, as it is difficult to specify what is reasonable behavior <p> Therefore, SNF is semantics-preserving if these rules are semantics-preserving. CNF's rules are proven to be semantics-preserving by execution of the LP <ref> [GHG + 92] </ref> theorem prover scripts of Appendix A. All other rules are proven to be semantics-preserving by execution of the LP [GHG + 92] theorem prover scripts of Appendix B. 2 4.4.2 Behavior Correctness Behavior correctness for SNF is tricky, as it is difficult to specify what is reasonable behavior of an SNF transformation.
Reference: [GKG + 97] <author> Torsten Grust, Joachim Krger, Dieter Gluche, Andreas Heuer, and Marc H. Scholl. </author> <title> Query evaluation in CROQUE calculus and algebra coincide. </title> <editor> In C. Small, P. Douglas, R. Johnson, P. King, and N. Martin, editors, </editor> <booktitle> Proceedings of the 15th British National Conference on Databases (BNCOD15), </booktitle> <volume> LNCS 1271, </volume> <pages> pages 84-100, </pages> <address> London, UK, </address> <month> July </month> <year> 1997. </year>
Reference-contexts: The literature review is divided by category. 7.1 Comparing KOLA with Query Algebras 7.1.1 Object Query Algebras Still to write about: * AQUA [LMS + 93] * EXTRA [VD91] * OFL [GMP95] * GOM [KMP87] * Fegaras and Maier [FM95] * CROQUE <ref> [GKG + 97] </ref> * Steenhagen [SABd94] 7.1.2 Combinator-Based Query Algebras We are not the first to suggest that a combinator-style for queries facilitates optimizer formalization. [EL91] consider the benefits of an FP-style ([Bac78]) query language from the perspective of optimization, but by proposing an FP-style query language.
Reference: [GM93] <author> Goetz Graefe and Willam J. McKenna. </author> <title> The Volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proceedings of the Ninth International Conference on Data Engineering, </booktitle> <pages> pages 209-218, </pages> <address> Vienna, Austria, </address> <month> April </month> <year> 1993. </year> <note> IEEE. </note>
Reference-contexts: Different rule-based systems express these components differently. Starburst [HFLP89] expresses each part algorithmically with C code that performs the matching and modification. Exodus and Volcano <ref> [CDG + 90, GM93] </ref> also use code, but as supplements to rewrite rules which specify both matching and modification. Rewrite rules are declarative expressions of transformations. The left-hand side of a rule (its head) consists of a pattern with unification variables. <p> However, Starburst rules are difficult to understand and reason about, requiring a detailed understanding of the underlying graph-based query representation (QGM). Exodus [CDG + 90] (and its successors, Volcano <ref> [GM93] </ref> and Cascades [Gra95]) and ESL [FG94] use rules that resemble rewrite rules, but that can have code supplements. <p> [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano <ref> [CDG + 90, GM93] </ref> * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query Scrambling [AFTU96] 133 8 Future Work The proposed thesis will have the following structure: * Section 1: Introduction (from Section 1 of proposal)
Reference: [GMP95] <author> Georges Gardarin, Fernando Machuca, and Phillipe Pucheral. OFL: </author> <title> A functional execution model for object query languages. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 59-70, </pages> <year> 1995. </year>
Reference-contexts: The literature review is divided by category. 7.1 Comparing KOLA with Query Algebras 7.1.1 Object Query Algebras Still to write about: * AQUA [LMS + 93] * EXTRA [VD91] * OFL <ref> [GMP95] </ref> * GOM [KMP87] * Fegaras and Maier [FM95] * CROQUE [GKG + 97] * Steenhagen [SABd94] 7.1.2 Combinator-Based Query Algebras We are not the first to suggest that a combinator-style for queries facilitates optimizer formalization. [EL91] consider the benefits of an FP-style ([Bac78]) query language from the perspective of optimization,
Reference: [Gra95] <author> Goetz Graefe. </author> <title> The Cascades framework for query optimization. </title> <journal> Data Engineering Bulletin, </journal> <volume> 18(3) </volume> <pages> 19-29, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: One such technique 1 is the use of query-to-query transformations to express query equivalences. Transformations are used in a variety of ways in optimizers: * Some optimizers (e.g., Cascades <ref> [Gra95] </ref>) use transformations during plan generation to generate a set of queries that are equivalent to a given query, and then generate plans for each query in this set so that a "best" can be chosen. * Many optimizers include an algebraic (also called query rewriting ([PHH92])) phase of optimization during <p> However, Starburst rules are difficult to understand and reason about, requiring a detailed understanding of the underlying graph-based query representation (QGM). Exodus [CDG + 90] (and its successors, Volcano [GM93] and Cascades <ref> [Gra95] </ref>) and ESL [FG94] use rules that resemble rewrite rules, but that can have code supplements. Code supplements make rewrite rules more expressive, but at the expense of understandability. 130 Of the rule-based systems, Gral [BG92] comes closest to ours in its effort to make rules declara-tive by avoiding code. <p> Normalizations require the ability to fire rules repeatedly and to control of the manner in which a query representation is traversed. Such control is not provided with Gral rules and instead must be expressed using its meta-rule language as discussed below. Still to write about: * Cascades <ref> [Gra95, ONK + 95] </ref> (in more detail) * CROQUE [HK96] * Steenhagen [SABd94] Expressing Complex Query Rewrites with Rule Groups or Modules Many systems (e.g. [PHH92], [BG92], [FG94], [MDZ93] [LV91], [SSJ90]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. <p> Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA <ref> [DGK + 91, Gra95] </ref> * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query Scrambling [AFTU96] 133 8 Future Work The proposed thesis will have the following structure: * Section 1: Introduction (from Section 1 of proposal) * Section 2: Motivation (from Section
Reference: [GW87] <author> Richard A. Ganski and Harry K. T. Wong. </author> <title> Optimization of nested SQL queries revisited. </title> <editor> In Umeshwar Dayal and Irv Traiger, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 23-33, </pages> <address> San Francisco, California, </address> <month> May </month> <year> 1987. </year> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press. </publisher>
Reference-contexts: This provides many performance benefits, speeding up the process of query rewriting and freeing up more time for an optimizer to perform its search. Still to write about: * Opt++ [KD] 7.3 Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong <ref> [GW87] </ref> * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] *
Reference: [GW89] <author> Goetz Graefe and Karen Ward. </author> <title> Dynamic query evaluation plans. </title> <editor> In James Clifford, Bruce Lindsay, and David Maier, editors, </editor> <booktitle> Proceedings of the SIGMOD International 142 Conference on Management of Data, </booktitle> <pages> pages 358-366, </pages> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press. </publisher>
Reference-contexts: * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward <ref> [GW89, CG94] </ref> * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query Scrambling [AFTU96] 133 8 Future Work The proposed thesis will have the following structure: * Section 1: Introduction (from Section 1 of proposal) * Section 2: Motivation (from Section 2 of proposal) * Section 3:
Reference: [Hel94] <author> Joseph M. Hellerstein. </author> <title> Practical predicate placement. </title> <editor> In Richard T. Snodgrass and Marianne Winslett, editors, </editor> <booktitle> 1994 ACM SIGMOD International Conference on Management of Data, </booktitle> <address> Minneapolis, Minnesota, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates <ref> [HS93, Hel94, LMS94] </ref> * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query
Reference: [HFLP89] <author> Laura M. Haas, J. C. Freytag, G. M. Lohman, and H. Pirahesh. </author> <title> Extensible query processing in Starburst. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 377-388, </pages> <year> 1989. </year>
Reference-contexts: Every rule has two parts: * a matching component that identifies a class of queries for which the transformation is safe, and * a modification component that describes how to transform matched queries. Different rule-based systems express these components differently. Starburst <ref> [HFLP89] </ref> expresses each part algorithmically with C code that performs the matching and modification. Exodus and Volcano [CDG + 90, GM93] also use code, but as supplements to rewrite rules which specify both matching and modification. Rewrite rules are declarative expressions of transformations. <p> This was the intended purpose of rules when first proposed ([Fre87]), and also characterizes one of the two kinds of rules used in Exodus [CDG + 90] and Starburst <ref> [HFLP89] </ref>. KOLA and COKO express query rewrites (i.e., query-to-query mappings) rather than query-to-plan mappings, and hence are incomparable to the rules of these systems. Below, we describe how other systems express algebraic-level query rewrites.
Reference: [HK96] <author> Andreas Heuer and Joachim Krger. </author> <title> Query optimization in the CROQUE project. </title> <booktitle> In Proceedings of the 7th International Conference on Database and Expert Systems Applications (DEXA 96), </booktitle> <volume> LNCS 1134, </volume> <pages> pages 489-499, </pages> <address> Zurich, Switzerland, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Such control is not provided with Gral rules and instead must be expressed using its meta-rule language as discussed below. Still to write about: * Cascades [Gra95, ONK + 95] (in more detail) * CROQUE <ref> [HK96] </ref> * Steenhagen [SABd94] Expressing Complex Query Rewrites with Rule Groups or Modules Many systems (e.g. [PHH92], [BG92], [FG94], [MDZ93] [LV91], [SSJ90]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing.
Reference: [HKL92] <author> Jieh Hsiang, Helene Kirchner, and Pierre Lescanne. </author> <title> The term rewriting approach to automated theorem proving. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 71-99, </pages> <year> 1992. </year>
Reference-contexts: Rewrite rule correctness can be established with the help of a theorem prover because theorem provers are special-purpose term rewriting engines <ref> [HKL92] </ref>. On the other hand, rules expressed fully or partially with code are much harder to prove correct, and especially difficult to verify with a theorem prover. It should be pointed out that the intended purpose of Starburst and Exodus was to make optimizers extensible rather than verifiable.
Reference: [HS93] <author> Joseph M. Hellerstein and Michael Stonebraker. </author> <title> Predicate migration: Optimizing queries with expensive predicates. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 267-276, </pages> <year> 1993. </year>
Reference-contexts: write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates <ref> [HS93, Hel94, LMS94] </ref> * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query
Reference: [Hug84] <author> R. J. M. Hughes. </author> <title> The design and implementation of programming languages. </title> <type> PhD thesis, </type> <institution> University of Oxford, </institution> <year> 1984. </year>
Reference-contexts: One solution applied to this problem is to add combinators to the representation language at the expense of redundancy. Also, a solution has been proposed that has special-purpose combinators (supercombinators) generated on-the-fly <ref> [Hug84] </ref>. The supercombinator approach has little practical benefit for querying given that algebraic optimization relies on the existence of a fixed set of query operators. But queries tend to be smaller than programs, and thus such drastic solutions may not be required. <p> we found described in the literature, KOLA most closely resembles Curien's combinator set, but adjusted to account for sets and bags rather than lists, and avoiding the overly powerful combinators (App and fl) that are expressive but difficult to optimize prior to their application to arguments. -lifting [Joh85] and supercombinators <ref> [Hug84] </ref> are translation techniques that use variable sets of combinators. These techniques construct new combinators during each translation. The goal of this technique is to keep the number of combinators in the result small (the combinators generated tend to be fairly complicated).
Reference: [HZ80] <author> M. Hammer and S. B. Zdonik. </author> <title> Knowledge-based query processing. </title> <booktitle> In Proceedings if the 6th International Conference on Very Large Databases, </booktitle> <address> Montreal, Canada, </address> <month> October </month> <year> 1980. </year> <month> Morgan-Kaufman. </month>
Reference-contexts: Still to write about: * Opt++ [KD] 7.3 Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik <ref> [HZ80] </ref> * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] *
Reference: [INSS92] <author> Yannis E. Ioannidis, Raymond T. Ng, Kyuseok Shim, and Timos K. Sellis. </author> <title> Parametric query optimization. </title> <booktitle> In Proceedings if the 18th International Conference on Very Large Databases, </booktitle> <pages> pages 103-114, </pages> <year> 1992. </year>
Reference-contexts: Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis <ref> [INSS92] </ref> * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query Scrambling [AFTU96] 133 8 Future Work The proposed thesis will have the following structure: * Section 1: Introduction (from Section 1 of proposal) * Section 2: Motivation (from Section 2 of proposal) * Section 3: KOLA (from Section 3
Reference: [Joh85] <author> T. Johnsson. </author> <title> Lambda lifting: transforming programs to recursive equations. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architecture, </booktitle> <publisher> LNCS. Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: the combinator translations we found described in the literature, KOLA most closely resembles Curien's combinator set, but adjusted to account for sets and bags rather than lists, and avoiding the overly powerful combinators (App and fl) that are expressive but difficult to optimize prior to their application to arguments. -lifting <ref> [Joh85] </ref> and supercombinators [Hug84] are translation techniques that use variable sets of combinators. These techniques construct new combinators during each translation. The goal of this technique is to keep the number of combinators in the result small (the combinators generated tend to be fairly complicated).
Reference: [JRSB85] <author> M.S. Joy, V.J. Rayward-Smith, and F.W. Burton. </author> <title> Efficient combinator code. </title> <journal> Computer Languages, </journal> <volume> 10 </volume> <pages> 211-224, </pages> <year> 1985. </year>
Reference-contexts: It has been shown that this small set is sufficient to translate all of -calculus (in fact I is superfluous), but the size of the resulting code is too large to be of practical use <ref> [JRSB85] </ref>. Variations of the SKI combinator sets add additional, redundant combinators (e.g. B and Y) to reduce the size of the translated code. Curien proposed a set of Category Theory-inspired 129 Combinators ([Cur93]) which he used to provide an alternative semantics for the -calculus. <p> Still to write about: * Naturally Embedded Query Languages [BTBW92] * Complexity of Translations <ref> [JRSB85] </ref> 7.2 Comparing COKO with Query Rewrites of Rule-Based Optimizers Many rule-based systems (e.g. [Loh88], [FMS93]) use rules to map algebraic operators to plan-level implementations.
Reference: [KD] <author> Navin Kabra and David DeWitt. </author> <title> Opt++: An object-oriented design for extensible database query optimization. </title>
Reference-contexts: Firing algorithms needn't be generic nor exhaustive and instead can be customized to specific, fixed sets of rules. This provides many performance benefits, speeding up the process of query rewriting and freeing up more time for an optimizer to perform its search. Still to write about: * Opt++ <ref> [KD] </ref> 7.3 Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and
Reference: [Kie84] <author> W. Kiessling. </author> <title> SQL-like and QUEL-like correlation queries with aggregates revisited. </title> <type> UCB/ERL Memo 84/75, </type> <institution> Electronics Research Laboratory, Univ. California, Berkeley, </institution> <year> 1984. </year>
Reference-contexts: Correctness then requires ensuring that the transformation is safe for each query in its associated class. For complex transformations, identification of this class can be difficult, even if queries are confined to queries over relations. [Kim82] proposed transformations to unnest four different classes of nested queries over relations. <ref> [Kie84] </ref> later showed that the classes of queries proposed contained some whose semantics were changed by their corresponding transformations. (The most famous example of this is the well-known "COUNT bug".) For transformations whose associated class of queries can include object queries (i.e., queries over object databases), correctness is even more difficult
Reference: [Kim82] <author> Won Kim. </author> <title> On optimizing an SQL-like nested query. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(3) </volume> <pages> 443-469, </pages> <month> September </month> <year> 1982. </year> <month> 143 </month>
Reference-contexts: Correctness then requires ensuring that the transformation is safe for each query in its associated class. For complex transformations, identification of this class can be difficult, even if queries are confined to queries over relations. <ref> [Kim82] </ref> proposed transformations to unnest four different classes of nested queries over relations. [Kie84] later showed that the classes of queries proposed contained some whose semantics were changed by their corresponding transformations. (The most famous example of this is the well-known "COUNT bug".) For transformations whose associated class of queries can <p> Thus, Rep. Sanders will fail to satisfy the join predicate with all entries in Temp and will be excluded from the second query's result. This discrepancy in query results is very similar to that which led to the "COUNT bug" of <ref> [Kim82] </ref>. In fact, the transformation demonstrated in Figure 5 generalizes the faulty Type JA transformation which contains the bug. The subtlety of this bug illustrates the difficulty of determining the conditions that are required for queries to be safely transformed. <p> Thus, this rule generalizes the Type N and Type J query transformations of <ref> [Kim82] </ref>. Rule 3 is the most complex rule in this rule set. It applies to queries of the form, set ! (join ((eq (f fi g)) & p; h ffi 1 ) ! [A; B]) that remove duplicates from a join whose join predicate includes an equality subpredicate. <p> In this paper, we have presented some of the transformations that we have generated with COKO including CNF (exhaustive and non-exhaustive versions), SNF, Pushdown, Commute and Associate. Aside from these, we have also implemented (and generalized) the query unnesting transformations of <ref> [Kim82] </ref> (modulo their bug fixes) and the nested object query transformation presented in [CZ96]. Though COKO is evolving, this is not to say that it is immature. We believe that COKO already provides most of the useful idioms required to express query rewriting. <p> This provides many performance benefits, speeding up the process of query rewriting and freeing up more time for an optimizer to perform its search. Still to write about: * Opt++ [KD] 7.3 Transforming Nested Queries Still to write about: * Kim <ref> [Kim82] </ref> * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding <p> to normalize predicates into SNF: ( k 1 ) & ( k 2 ) & t 3. a transformation to normalize predicates into SNF2: ( k (id fi 1 )) & ( k (id fi 2 )) & t 4. transformations to unnest nested queries in the manner described in <ref> [Kim82] </ref>, 5. transformations to unnest nested queries using the magic sets transformations of [MP92, SHP + 96b, SPL96], and 6. semantics-based transformations such as those described in Section 5 The COKO component of this thesis is largely complete.
Reference: [KMP87] <author> Alfons Kemper, Guido Moerkotte, and Klaus Peithner. </author> <title> A blackboard architecture for query optimization in object bases. </title> <editor> In Rakesh Agrawal, Sean Baker, and David Bell, editors, </editor> <booktitle> Proceedings if the 19th International Conference on Very Large Databases, </booktitle> <pages> pages 543-554, </pages> <address> Dublin, Ireland, </address> <month> August </month> <year> 1987. </year> <month> Morgan-Kaufman. </month>
Reference-contexts: The literature review is divided by category. 7.1 Comparing KOLA with Query Algebras 7.1.1 Object Query Algebras Still to write about: * AQUA [LMS + 93] * EXTRA [VD91] * OFL [GMP95] * GOM <ref> [KMP87] </ref> * Fegaras and Maier [FM95] * CROQUE [GKG + 97] * Steenhagen [SABd94] 7.1.2 Combinator-Based Query Algebras We are not the first to suggest that a combinator-style for queries facilitates optimizer formalization. [EL91] consider the benefits of an FP-style ([Bac78]) query language from the perspective of optimization, but by proposing
Reference: [LKC96] <author> Joon-Suk Lee, Kee-Eung Kim, and Mitch Cherniack. </author> <title> A COKO compiler. </title> <note> Available at http://www.cs.brown.edu/software/cokokola/coko.tar.Z, 1996. </note>
Reference-contexts: Thus, the definition of a new COKO transformation extends the language, even at the level of the implementation. The current version of the compiler was built using the Lex and Yacc Unix tools, and is available from <ref> [LKC96] </ref>. 4.3 A Complex Normalization: "Separated Normal Form" In this section we describe a novel normalization and show its expression in COKO. The normalization is of binary predicates, (in KOLA, predicates on pairs) and involves isolating those subpredicates that act as unary predicates on just one argument.
Reference: [LLOW91] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinreb. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: To support the conceptual contributions of this thesis, a prototype query processor for the ObjectStore object-oriented database <ref> [LLOW91] </ref> is currently being developed. This implementation includes the following components: 1. Translator: A translator has been designed that translates a set-based subset of OQL into KOLA, and that has been proven correct with respect to a denotational semantics of OQL. <p> Section 6.1 begins with a description of the Objectstore <ref> [LLOW91] </ref> objects that can be probed and constructed with KOLA queries. KOLA's plan language is described in Section 6.2. SODA's query evaluator is described in Section 6.3.
Reference: [LMS + 93] <author> Theodore W. Leung, Gail Mitchell, Bharathi Subramanian, Bennet Vance, Scott L. Vandenberg, and Stanley B. Zdonik. </author> <title> The AQUA data model and algebra. </title> <booktitle> In Proc. 4th Int'l Workshop on Database Programming Languages, </booktitle> <address> New York, New York, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: The KOLA query of Figure 11b includes: * the primitive identity function, id, which maps every object to itself, * the complex predicate, C p (eq; ``Republican'') (pty ffi chair) 5 KOLA was developed in response to difficulties faced when attempting to formulate declarative rules over the variable-based algebra, AQUA <ref> [LMS + 93] </ref>. KOLA differs from AQUA primarily in form rather than spirit, with a few exceptions as presented in [CZN95]. <p> The literature review is divided by category. 7.1 Comparing KOLA with Query Algebras 7.1.1 Object Query Algebras Still to write about: * AQUA <ref> [LMS + 93] </ref> * EXTRA [VD91] * OFL [GMP95] * GOM [KMP87] * Fegaras and Maier [FM95] * CROQUE [GKG + 97] * Steenhagen [SABd94] 7.1.2 Combinator-Based Query Algebras We are not the first to suggest that a combinator-style for queries facilitates optimizer formalization. [EL91] consider the benefits of an FP-style
Reference: [LMS94] <author> Alon Y. Levy, Inderpal Singh Mumick, and Yehoshua Sagiv. </author> <title> Query optimization by predicate move-around. </title> <booktitle> In Proceedings of the 20th VLDB Conference, </booktitle> <pages> pages 96-107, </pages> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates <ref> [HS93, Hel94, LMS94] </ref> * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query
Reference: [Loh88] <author> Guy Lohman. </author> <title> Grammar-like functional rules for representing query optimization alternatives. </title> <booktitle> In Proceedings of ACM SIGMOD, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: Still to write about: * Naturally Embedded Query Languages [BTBW92] * Complexity of Translations [JRSB85] 7.2 Comparing COKO with Query Rewrites of Rule-Based Optimizers Many rule-based systems (e.g. <ref> [Loh88] </ref>, [FMS93]) use rules to map algebraic operators to plan-level implementations. This was the intended purpose of rules when first proposed ([Fre87]), and also characterizes one of the two kinds of rules used in Exodus [CDG + 90] and Starburst [HFLP89].
Reference: [LTD96] <author> Hongjun Lu, Kian-Lee Tan, and Son Dao. </author> <title> Fittest survives: An adaptive approach to query optimization. </title> <booktitle> In Proceedings of the 22nd VLDB Conference, </booktitle> <pages> pages 251-262, </pages> <address> Bombay, India, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization <ref> [LTD96] </ref> 132 * Antoshenkov [Ant96, AZ96] * Query Scrambling [AFTU96] 133 8 Future Work The proposed thesis will have the following structure: * Section 1: Introduction (from Section 1 of proposal) * Section 2: Motivation (from Section 2 of proposal) * Section 3: KOLA (from Section 3 of proposal) * Section
Reference: [LV91] <author> Rosana S. G. Lanzelotte and Patrick Valduriez. </author> <title> Extending the search strategy in a query optimizer. </title> <editor> In Guy M. Lohman, Amlcar Sernadas, and Rafael Camps, editors, </editor> <booktitle> 17th International Conference on Very Large Data Bases, </booktitle> <pages> pages 363-373, </pages> <address> Barcelona, Catalonia, Spain, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Still to write about: * Cascades [Gra95, ONK + 95] (in more detail) * CROQUE [HK96] * Steenhagen [SABd94] Expressing Complex Query Rewrites with Rule Groups or Modules Many systems (e.g. [PHH92], [BG92], [FG94], [MDZ93] <ref> [LV91] </ref>, [SSJ90]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. Rule groups can be associated with search strategies that indicate how the rules in a group should be fired.
Reference: [MDZ93] <author> Gail Mitchell, Umeshwar Dayal, and Stanley B. Zdonik. </author> <title> Control of and extensible query optimizer: A planning-based approach. </title> <booktitle> In Proc. 19th Int'l Conference on Very Large Data Bases, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: Still to write about: * Cascades [Gra95, ONK + 95] (in more detail) * CROQUE [HK96] * Steenhagen [SABd94] Expressing Complex Query Rewrites with Rule Groups or Modules Many systems (e.g. [PHH92], [BG92], [FG94], <ref> [MDZ93] </ref> [LV91], [SSJ90]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. Rule groups can be associated with search strategies that indicate how the rules in a group should be fired. <p> Other systems provide pruning strategies so that only some alternatives are generated (e.g, [SSJ90] provide such strategies as branch-and-bound and simulated annealing). Some systems permit an evaluation of rules (e.g., [PHH92], <ref> [MDZ93] </ref> and [CDG + 90]) or of algebraic operators (e.g., [BG92]) to decide on a rule that should be fired next, so that poor alternatives aren't generated. COKO groups KOLA rules, not to generate alternatives, but to modularize the expression of a single complex query rewrite.
Reference: [MFPR90] <author> Inderpal Singh Mumick, Sheldon J. Finkelstein, Hamid Pirahesh, and Raghu Ramakr-ishnan. </author> <title> Magic is relevant. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 247-258, </pages> <year> 1990. </year>
Reference-contexts: Applications of SNF In this section, we present four COKO transformations that depend on prior normalization by SNF: predicate pushdown (Section 4.5.1), join reordering (Section 4.5.2), the transformation of the "Conflict of Interests" query (COI 2 k ) from Section 3.5.2 (Section 4.5.3), and the Magic Sets transformation presented in <ref> [MFPR90] </ref> (Section 4.5.4). 75 TRANSFORMATION Pushdown USES push: join ((p 1 ) & (q 2 ) & r; f) ! [A; B] ! join (r; f) ! [iterate (p; id) ! A; iterate (q; id) ! B] SNF, simplify: iterate (K p (true); id) ! A ! BEGIN GIVEN join (p; <p> However, SimpLits would have to first be extended to handle quantification predicates (by adding rules 6a and 6b for example). 4.5.4 Magic Sets The idea behind the Magic Sets transformation presented in <ref> [MFPR90] </ref> is to restrict inputs to joins by filtering those that cannot possibly satisfy the join predicate. Therefore, this transformation is in the spirit of predicate pushdown, but passing filter predicates "sideways" from one join input to another, rather than "down" from the join predicate. <p> And like CSet, CSet k determines the set of committee chairs for committees in MCs k (MCs). The transformation illustrated by Figure 29 deviates from the Magic Sets transformation presented in <ref> [MFPR90] </ref> in that original transformation, MCs would have returned committee attributes, topic, chair, and mems rather than entire committees as is done in views MCs and MCs k . <p> The transformations demonstrated by these examples evoke the spirit of the magic sets transformations presented in <ref> [MFPR90] </ref> and [SHP + 96a].
Reference: [MP92] <author> Inderpal Singh Mumick and Hamid Pirahesh. </author> <title> Implementation of magic-sets in a relational database system. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 39-48, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Still to write about: * Opt++ [KD] 7.3 Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets <ref> [MP92, SPL96, SHP + 96b] </ref> * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan <p> ) & t 3. a transformation to normalize predicates into SNF2: ( k (id fi 1 )) & ( k (id fi 2 )) & t 4. transformations to unnest nested queries in the manner described in [Kim82], 5. transformations to unnest nested queries using the magic sets transformations of <ref> [MP92, SHP + 96b, SPL96] </ref>, and 6. semantics-based transformations such as those described in Section 5 The COKO component of this thesis is largely complete. The compiler is now in its second revision, and is available on the web.
Reference: [NCN97] <author> Marian H. Nodine, Mitch Cherniack, and Mark H. Nodine. </author> <title> Semantic cardinality estimation for queries over objects. In Persistent Object Systems: </title> <booktitle> Principles and Practice. The Seventh Int'l Workshop on Persistent Object Systems, </booktitle> <address> Cape May, NJ, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation <ref> [NCN97] </ref> 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query Scrambling [AFTU96] 133 8 Future Work The proposed thesis will have the
Reference: [ONK + 95] <author> Fatma Ozcan, Sena Nural, Pinar Koksal, Mehmet Altinel, and Asuman Dogac. </author> <title> A region based query optimizer through Cascades query optimizer framework. </title> <journal> Data Engineering Bulletin, </journal> <volume> 18(3) </volume> <pages> 30-40, </pages> <month> September </month> <year> 1995. </year> <month> 144 </month>
Reference-contexts: Normalizations require the ability to fire rules repeatedly and to control of the manner in which a query representation is traversed. Such control is not provided with Gral rules and instead must be expressed using its meta-rule language as discussed below. Still to write about: * Cascades <ref> [Gra95, ONK + 95] </ref> (in more detail) * CROQUE [HK96] * Steenhagen [SABd94] Expressing Complex Query Rewrites with Rule Groups or Modules Many systems (e.g. [PHH92], [BG92], [FG94], [MDZ93] [LV91], [SSJ90]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing.
Reference: [PHH92] <author> Hamid Pirahesh, Joseph M. Hellerstein, and Waqar Hasan. </author> <title> Extensible/rule based query rewrite optimization in Starburst. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 39-48, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Below, we describe how other systems express algebraic-level query rewrites. Expressing Complex Query Rewrites with Code In most rule-based systems, complex query rewrites are expressed with rules. However, the rules of these systems are not declarative rewrite rules. Starburst <ref> [PHH92] </ref> fire production rules (as in expert systems such as [BFKM85]) during the query rewriting phase of optimization. These rules consist of two code routines (loosely corresponding to the lhs and rhs of a rewrite rule) written in C. <p> These rules consist of two code routines (loosely corresponding to the lhs and rhs of a rewrite rule) written in C. Because they are expressed in C, Starburst's query rewriting rules are able to express a wide variety of transformations including view merging, nested query unnesting (both discussed in <ref> [PHH92] </ref>) and magic sets transformations ([MFPR90, SPL96]). However, Starburst rules are difficult to understand and reason about, requiring a detailed understanding of the underlying graph-based query representation (QGM). <p> Still to write about: * Cascades [Gra95, ONK + 95] (in more detail) * CROQUE [HK96] * Steenhagen [SABd94] Expressing Complex Query Rewrites with Rule Groups or Modules Many systems (e.g. <ref> [PHH92] </ref>, [BG92], [FG94], [MDZ93] [LV91], [SSJ90]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. Rule groups can be associated with search strategies that indicate how the rules in a group should be fired. <p> Thus, whereas COKO groups rules to cooperatively specify a query rewrite, other systems group rules to "face-off" against one another. The search strategies that are provided by these systems reflect this objective. Most (e.g., <ref> [PHH92] </ref>, [BG92], [FG94]) include exhaustive search (fire everything everywhere until firing no longer has any effect), with the goal of generating all possible alternatives before comparing them. Some systems permit some variations on exhaustive search (such as prioritizing rules [PHH92] or binding the number of passes over the query in advance <p> Most (e.g., <ref> [PHH92] </ref>, [BG92], [FG94]) include exhaustive search (fire everything everywhere until firing no longer has any effect), with the goal of generating all possible alternatives before comparing them. Some systems permit some variations on exhaustive search (such as prioritizing rules [PHH92] or binding the number of passes over the query in advance [FG94]). Other systems provide pruning strategies so that only some alternatives are generated (e.g, [SSJ90] provide such strategies as branch-and-bound and simulated annealing). Some systems permit an evaluation of rules (e.g., [PHH92], [MDZ93] and [CDG + 90]) or of <p> on exhaustive search (such as prioritizing rules <ref> [PHH92] </ref> or binding the number of passes over the query in advance [FG94]). Other systems provide pruning strategies so that only some alternatives are generated (e.g, [SSJ90] provide such strategies as branch-and-bound and simulated annealing). Some systems permit an evaluation of rules (e.g., [PHH92], [MDZ93] and [CDG + 90]) or of algebraic operators (e.g., [BG92]) to decide on a rule that should be fired next, so that poor alternatives aren't generated. COKO groups KOLA rules, not to generate alternatives, but to modularize the expression of a single complex query rewrite.
Reference: [Ram96] <author> Raghu Ramakrishnan. </author> <title> Database Management Systems. </title> <publisher> McGraw-Hill, </publisher> <year> 1996. </year>
Reference-contexts: KOLA qualification predicates are translation of SQL and OQL qualification predicates, defined in <ref> [Ram96] </ref> as an SQL predicate that is: a Boolean combination (i.e., an expression using the logical connectives AND, OR and NOT) of conditions of the form expression op expression, where op is one of the comparison operators f&lt;, &lt;=, =, &lt;&gt;, &gt;=, &gt;g, [and an] expression is a column name, a
Reference: [SABd94] <author> Hennie J. Steenhagen, Peter M.G. Apers, Henk M. Blanken, and Rolf A. deBy. </author> <title> From nested-loop to join queries in OODB. </title> <booktitle> In 20th International Conference on Very Large Data Bases, </booktitle> <pages> pages 618-629, </pages> <address> Santago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: The literature review is divided by category. 7.1 Comparing KOLA with Query Algebras 7.1.1 Object Query Algebras Still to write about: * AQUA [LMS + 93] * EXTRA [VD91] * OFL [GMP95] * GOM [KMP87] * Fegaras and Maier [FM95] * CROQUE [GKG + 97] * Steenhagen <ref> [SABd94] </ref> 7.1.2 Combinator-Based Query Algebras We are not the first to suggest that a combinator-style for queries facilitates optimizer formalization. [EL91] consider the benefits of an FP-style ([Bac78]) query language from the perspective of optimization, but by proposing an FP-style query language. <p> Such control is not provided with Gral rules and instead must be expressed using its meta-rule language as discussed below. Still to write about: * Cascades [Gra95, ONK + 95] (in more detail) * CROQUE [HK96] * Steenhagen <ref> [SABd94] </ref> Expressing Complex Query Rewrites with Rule Groups or Modules Many systems (e.g. [PHH92], [BG92], [FG94], [MDZ93] [LV91], [SSJ90]) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. <p> Still to write about: * Opt++ [KD] 7.3 Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen <ref> [SABd94] </ref> 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] *
Reference: [Sch24] <author> M. Schonfinkel. </author> <title> Uber die bausteine der mathematischen logik. </title> <journal> Math. Annalen, </journal> <volume> 92 </volume> <pages> 305-316, </pages> <year> 1924. </year>
Reference-contexts: Combinators can appear to lack expressivity to those who first use them, but the right set of combinators can have rich expressive power. For example, 48 Schoenfinkel <ref> [Sch24] </ref> established that three combinators (S, K and I) were all that were required as an alphabet for a free algebra over which one could translate all of the -calculus. (It was even shown later that I was superfluous!) Within the context of querying, the rich expressivity of KOLA has been <p> Fixed combinator sets consist of a finite set of combinators that are used as the target for all -expression translations. The best known of the fixed sets of combinators are the SKI combinator set, first introduced by Schonfinkel <ref> [Sch24] </ref>. It has been shown that this small set is sufficient to translate all of -calculus (in fact I is superfluous), but the size of the resulting code is too large to be of practical use [JRSB85]. Variations of the SKI combinator sets add additional, redundant combinators (e.g.
Reference: [Sci96] <institution> Swedish Institute Of Computer Science. </institution> <note> SICStus prolog user's manual. Release 3, # 5, </note> <year> 1996. </year>
Reference-contexts: The operation of COKO that supports this reasoning is described below. 5.2 The Design of COKO's Semantic Component Presently, COKO's design is being extended to use the Sicstus Prolog interpreter <ref> [Sci96] </ref> as a reasoning engine. The metadata of a database instance is used to generate a set of Prolog facts and rules. COKO Properties are compiled into additional Prolog facts and rules.
Reference: [SHP + 96a] <author> Praveen Seshadri, Joseph M. Hellerstein, Hamid Pirahesh, T.Y. Cliff Leung, Raghu Ramakrishnan, Divesh Srivastava, Peter J. Stuckey, and S. Sudarshan. </author> <title> Cost-based optimization for magic: Algebra and implementation. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <address> Montreal, Quebec, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: The transformations demonstrated by these examples evoke the spirit of the magic sets transformations presented in [MFPR90] and <ref> [SHP + 96a] </ref>.
Reference: [SHP + 96b] <author> Praveen Seshadri, Joseph M. Hellerstein, Hamid Pirahesh, T.Y. Cliff Leung, Raghu Ramakrishnan, Divesh Srivastava, Peter J. Stuckey, and S. Sudarshan. </author> <title> Cost-based optimization for magic: Algebra and implementation. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <address> Montreal, Quebec, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Still to write about: * Opt++ [KD] 7.3 Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets <ref> [MP92, SPL96, SHP + 96b] </ref> * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan <p> ) & t 3. a transformation to normalize predicates into SNF2: ( k (id fi 1 )) & ( k (id fi 2 )) & t 4. transformations to unnest nested queries in the manner described in [Kim82], 5. transformations to unnest nested queries using the magic sets transformations of <ref> [MP92, SHP + 96b, SPL96] </ref>, and 6. semantics-based transformations such as those described in Section 5 The COKO component of this thesis is largely complete. The compiler is now in its second revision, and is available on the web.
Reference: [Som89] <author> Ian Somerville. </author> <title> Software Engineering. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: fg (p; f) ! insert (a; A) = insert (f ! a, iterate fg (p; f) ! A) 6 A formal specification of the bag version of KOLA presented in Section 3 is ongoing work. 33 which is more typical of algebraic specifications found in software engineering textbooks such as <ref> [Som89] </ref>. Both specifications meet the intended specification of iterate fg , and one set of axioms could be used to prove the other. But a choice must be made as to which will lend itself to simpler theorem proving.
Reference: [SPL96] <author> Praveen Seshadri, Hamid Pirahesh, and T.Y. Cliff Leung. </author> <title> Complex query decorrelation. </title> <editor> In Stanley Y. W. Su, editor, </editor> <booktitle> Twelfth International Conference on Data Engineering, </booktitle> <pages> pages 450-458, </pages> <address> New Orleans, LA, </address> <month> February </month> <year> 1996. </year> <title> IEEE, </title> <publisher> IEEE Computer Science Press. </publisher>
Reference-contexts: Still to write about: * Opt++ [KD] 7.3 Transforming Nested Queries Still to write about: * Kim [Kim82] * Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets <ref> [MP92, SPL96, SHP + 96b] </ref> * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting [SSM96] * Semantics and Cost Estimation [NCN97] 7.5 Plan <p> ) & t 3. a transformation to normalize predicates into SNF2: ( k (id fi 1 )) & ( k (id fi 2 )) & t 4. transformations to unnest nested queries in the manner described in [Kim82], 5. transformations to unnest nested queries using the magic sets transformations of <ref> [MP92, SHP + 96b, SPL96] </ref>, and 6. semantics-based transformations such as those described in Section 5 The COKO component of this thesis is largely complete. The compiler is now in its second revision, and is available on the web. <p> For example, the current transformation challenge under consideration is the "magic set"-inspired complex query decorrelation transformation described in <ref> [SPL96] </ref>. SODA: A prototype implementation of the SODA query processing system for the Objectstore database is presently under development, and will be completed as part of the work for this thesis. This implementation will provide OQL query evaluation that is presently lacking in Objectstore.
Reference: [SSJ90] <author> Edward Sciore and John Sieg Jr. </author> <title> A modular query optimizer generator. </title> <booktitle> In Proceedings of the 6th International Conference on Data Engineering, </booktitle> <pages> pages 146-153, </pages> <address> Los Angeles, USA, </address> <year> 1990. </year>
Reference-contexts: Still to write about: * Cascades [Gra95, ONK + 95] (in more detail) * CROQUE [HK96] * Steenhagen [SABd94] Expressing Complex Query Rewrites with Rule Groups or Modules Many systems (e.g. [PHH92], [BG92], [FG94], [MDZ93] [LV91], <ref> [SSJ90] </ref>) provide some form of meta-control language for rules that includes rule grouping and sometimes sequencing. Rule groups can be associated with search strategies that indicate how the rules in a group should be fired. <p> Some systems permit some variations on exhaustive search (such as prioritizing rules [PHH92] or binding the number of passes over the query in advance [FG94]). Other systems provide pruning strategies so that only some alternatives are generated (e.g, <ref> [SSJ90] </ref> provide such strategies as branch-and-bound and simulated annealing). Some systems permit an evaluation of rules (e.g., [PHH92], [MDZ93] and [CDG + 90]) or of algebraic operators (e.g., [BG92]) to decide on a rule that should be fired next, so that poor alternatives aren't generated.
Reference: [SSM96] <author> David Simmen, Eugene Shekita, and Timothy Malkemus. </author> <title> Fundamental techniques for order optimization. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <address> Montreal, Quebec, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Ganski-Wong [GW87] * Dayal [Day87] * Magic Sets [MP92, SPL96, SHP + 96b] * Cluet and Moerkotte [CM95, CM93] * Steenhagen [SABd94] 7.4 Semantic Optimization and Handling "Foreign Functions" * Zdonik [HZ80] * Aberer [AF95] * Chaudhuri and Kim [CS96, CS93] * Conjunctive Predicates [HS93, Hel94, LMS94] * Avoiding sorting <ref> [SSM96] </ref> * Semantics and Cost Estimation [NCN97] 7.5 Plan Languages, Partial Evaluation and Dynamic Optimization * Exodus/Volcano [CDG + 90, GM93] * OPA [DGK + 91, Gra95] * Graefe/Cole/Ward [GW89, CG94] * Ioannidis [INSS92] * Adaptive Optimization [LTD96] 132 * Antoshenkov [Ant96, AZ96] * Query Scrambling [AFTU96] 133 8 Future Work
Reference: [tho] <author> THOMAS: </author> <title> United States Congressional web site. </title> <note> Located at http:nnthomas.loc.gov. </note>
Reference-contexts: In Section 2, an object database application is proposed that would benefit from the contributions made in this thesis. The proposed application is based on the Thomas <ref> [tho] </ref> website of the United States Congress. Two example queries over Thomas are presented as motivation. Section 3 argues that optimizer correctness is easier to guarantee given a combinator-based representation for queries, and introduces KOLA. <p> Section 8 describes the proposed body of work that will comprise the thesis. Section 7 presents related work. Conclusions follow in Section 9. 8 2 Motivation A potential application of the work in this thesis is presented. The application is based on the Thomas web site <ref> [tho] </ref> which describes the activities of the United States Congress. After describing how Thomas could be modeled with an object database, two example queries are presented to illustrate the challenges and opportunities for object query optimization.
Reference: [Tur79] <author> D. A. Turner. </author> <title> A new implementation technique for applicative languages. </title> <journal> Software - Practice and Experience, </journal> <volume> 9 </volume> <pages> 31-49, </pages> <year> 1979. </year>
Reference-contexts: Like [BG84], neither [BF79] nor [BK90] describe translation techniques to map queries expressed in query languages with variables into their formalism. Since Turner's seminal paper <ref> [Tur79] </ref>, combinators have been used within functional language compilers as internal representations of -expressions. The purpose of this is to make evaluation by graph reduction more efficient, as -expressions with free variables force unnecessary copying of potentially large function bodies [FH88].
Reference: [VD91] <author> Scott L. Vandenberg and David J. DeWitt. </author> <title> Algebraic support for complex objects with arrays, identity, and inheritance. </title> <editor> In James Clifford and Roger King, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 158-167, </pages> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press. </publisher> <pages> 145 </pages>
Reference-contexts: The literature review is divided by category. 7.1 Comparing KOLA with Query Algebras 7.1.1 Object Query Algebras Still to write about: * AQUA [LMS + 93] * EXTRA <ref> [VD91] </ref> * OFL [GMP95] * GOM [KMP87] * Fegaras and Maier [FM95] * CROQUE [GKG + 97] * Steenhagen [SABd94] 7.1.2 Combinator-Based Query Algebras We are not the first to suggest that a combinator-style for queries facilitates optimizer formalization. [EL91] consider the benefits of an FP-style ([Bac78]) query language from the
References-found: 80

