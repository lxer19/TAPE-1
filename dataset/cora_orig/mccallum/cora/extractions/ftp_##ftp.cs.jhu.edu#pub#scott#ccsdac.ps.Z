URL: ftp://ftp.cs.jhu.edu/pub/scott/ccsdac.ps.Z
Refering-URL: http://www.cs.jhu.edu/tech-report/reports93.html
Root-URL: http://www.cs.jhu.edu
Title: Formal Methods in System Design,  Correct Compilation of Specifications to Deterministic Asynchronous Circuits  
Author: SCOTT F. SMITH AND AMY E. ZWARICO fscott, 
Keyword: Asynchronous circuits, speed-independent circuits, verification, concurrency, compilation  
Address: Baltimore, MD 21218 USA  
Affiliation: Department of Computer Science, The Johns Hopkins University,  
Note: c 1995 Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.  
Pubnum: 9,  
Email: amyg@cs.jhu.edu  
Date: 1-73 (1995)  
Abstract: Powerful methods have been developed by A. Martin and others whereby asynchronous circuits may be automatically constructed by starting from high-level specifications and incrementally transforming them into asynchronous circuits. In this paper we make the informal arguments for the correctness of this compilation process mathematically rigorous. With rigorously justified transformations, specifications may be translated into circuits that provably meet their specification. A full proof of the correctness of the circuit compiler is given. Other results of independent interest include: the process model takes fairness of gates into account, hazard-freeness is formally defined, and all hazard-free circuits constructed solely of and, or, not gates and C elements are proven to behave deterministically to any outside observer. A novel notion of equivalence is used to justify the correctness of the compiler. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J.A. Bergstra and J.W. Klop. </author> <title> Process Algebra for Synchronous Communication. </title> <journal> Information and Control, </journal> <volume> 60 </volume> <pages> 109-137, </pages> <year> 1984. </year>
Reference-contexts: For a more complete verification effort, a logic (including quantification) could be developed and used to specify and prove high-level properties of the CSP-style specifications. Numerous such logics have been constructed [13], [21], [12], [11], <ref> [1] </ref>, so this is an eminently feasible task. The advantage of this approach as opposed to a post-hoc verification methodology is the high-level specification is relatively simple in comparison with an actual circuit, making it easier to reason about.
Reference: 2. <author> Erik Brunvand and Robert F. Sproull. </author> <title> Translating concurrent programs into delay-insensitive circuits. </title> <booktitle> In Proceedings of ICCAD-89, </booktitle> <pages> pages 262-265. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: 1. Introduction A large number of research projects have developed methods for the automatic synthesis of asynchronous circuits from high-level specifications [17], [18], [28], <ref> [2] </ref>, [20]. These methods are a significant departure from the traditional design methodologies used in circuit development in they are automatic or semi-automatic techniques for synthesizing asynchronous circuits from high-level specifications. All of the above projects excepting [20] use the same basic methodology, described as follows.
Reference: 3. <author> R.E. Bryant. </author> <title> On the complexity of VLSI Implementations and Graph Representation of Boolean Functions with Application to Integer Multiplication. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(2), </volume> <year> 1986. </year>
Reference-contexts: Another important problem to solve is the development of decision procedures to automatically test for semantic well-formedness of S-CSP components. Because specifications may be quite large, it may be useful to use BDD's <ref> [3] </ref> to increase efficiency of the decision procedure. This approach has been used successfully in [4].
Reference: 4. <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and J. Hwang. </author> <title> Symbolic Model Checking: 10 20 States and Beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: Another important problem to solve is the development of decision procedures to automatically test for semantic well-formedness of S-CSP components. Because specifications may be quite large, it may be useful to use BDD's [3] to increase efficiency of the decision procedure. This approach has been used successfully in <ref> [4] </ref>.
Reference: 5. <author> Steven M. Burns. </author> <title> Automated compilation of concurrent programs into self-timed circuits. </title> <type> Technical Report Caltech-CS-TR-88-2, </type> <institution> California Institute of Technology, </institution> <year> 1988. </year>
Reference-contexts: The specification then undergoes a series of transformations that in the end results in an asynchronous circuit. Our work is based on the asynchronous design method of Martin et al. [17], [18], [14], [15], [19]. Burns and Martin have described and implemented a circuit compiler [6], <ref> [5] </ref> that uses this method to automatically translate specifications into circuits. This paper is concerned with rigorously establishing the correctness of asynchronous circuit compilers. There have been multiple efforts in this area, including [25], [29], [27]. This paper is a complete presentation of preliminary work described in [24], [25]. <p> Compilation of C-CSP Specifications to Circuits We now define a family of five rewrite systems for incrementally translating C-CSP process specifications to circuit implementations. Our translation roughly follows that of <ref> [5] </ref>, though many changes were necessary to define a provably correct translation process. To their credit we did not find any significant errors in their work, only ambiguities. <p> Additionally, (1 : GD) simplifies each guard into disjunctive normal form, strengthens the disjuncts so that they are mutually exclusive, and creates a separate guarded process for each of the strengthened disjuncts. The algorithm used to strengthen the disjuncts is identical to that described in <ref> [5] </ref> and is presented below. algorithm: disjoint-guards Let F = 1in f i (where each f i is a conjunction of literals) Let C = ff i j 1 i ng while 9i 1; j n, i 6= j such that f i ^ f j is satisfiable do C := <p> One important extension is the incorporation of n-bit data paths via dual-rail encodings. Another is the implementation of non-mutually-exclusive guarded commands. The transformation process we have presented is also minimal in that it incorporates no optimizations. Burns presents some simple optimizations in <ref> [5] </ref> and we expect that these optimizations as well as others can be incorporated into our framework.
Reference: 6. <author> Steven M. Burns and Alain J. Martin. </author> <title> Synthesis of self-timed circuits by program transformation. </title> <editor> In G.J. Milne, editor, </editor> <booktitle> The Fusion of Hardware Design and Verification, </booktitle> <pages> pages 99-116. </pages> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <year> 1988. </year> <month> 36 </month>
Reference-contexts: The specification then undergoes a series of transformations that in the end results in an asynchronous circuit. Our work is based on the asynchronous design method of Martin et al. [17], [18], [14], [15], [19]. Burns and Martin have described and implemented a circuit compiler <ref> [6] </ref>, [5] that uses this method to automatically translate specifications into circuits. This paper is concerned with rigorously establishing the correctness of asynchronous circuit compilers. There have been multiple efforts in this area, including [25], [29], [27]. This paper is a complete presentation of preliminary work described in [24], [25].
Reference: 7. <editor> N. Dershowitz and J.-P. Jouannaud. </editor> <booktitle> Rewriting systems. In Handbook of theoretical computer science. </booktitle> <address> MIT/Elsevier, </address> <year> 1990. </year>
Reference-contexts: Before we define transformation equivalence, a digression into the general structure of the translation process is given. 4.2. Rewriting and Equivalences We divide the translation process into five phases and implement each phase using a distinct term rewriting system (see <ref> [7] </ref> for background and references on rewriting). These systems are presented in Section 5. Rewrite systems are simple rule-based systems for replacing one subterm by another. One additional feature we use is to rewrite with respect to a set of equations (equational rewriting).
Reference: 8. <author> David L. Dill. </author> <title> Trace theory for automatic hierarchical verification of speed-independent circuits. </title> <editor> In Jonathan Allen and F. Thomson Leighton, editors, </editor> <booktitle> Advanced Research in VLSI: Proceedings of the Fifth MIT Conference, </booktitle> <pages> pages 51-65. </pages> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: The disadvantage of our approach is the need to prove that no ERROR states arise during execution, for each specification. Key to proving the correctness of the transformation process is defining a reasonable notion of "equivalence" between processes. Many useful notions of equivalence have been defined. Trace equivalence [27], <ref> [8] </ref>, [9] and bisimulation equivalence [29] have both been effectively used for reasoning about asynchronous circuits. Our approach is based on a third variety, testing equivalence. Two processes are testing equivalent if they pass the same set of infinitely many tests.
Reference: 9. <author> Jo C. Ebergen. </author> <title> A formal approach to designing delay-insensitive circuits. </title> <booktitle> Computing Science Notes 88/10, </booktitle> <institution> Dept. of Math. and C.S., Eindhoven Univ. of Technology, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: Key to proving the correctness of the transformation process is defining a reasonable notion of "equivalence" between processes. Many useful notions of equivalence have been defined. Trace equivalence [27], [8], <ref> [9] </ref> and bisimulation equivalence [29] have both been effectively used for reasoning about asynchronous circuits. Our approach is based on a third variety, testing equivalence. Two processes are testing equivalent if they pass the same set of infinitely many tests.
Reference: 10. <author> M. Felleisen, D. Friedman, and E. Kohlbecker. </author> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Computer Science, </journal> <volume> 52 </volume> <pages> 205-237, </pages> <year> 1987. </year>
Reference-contexts: Configurations are defined to be closed because computations are restricted to closed terms only. One important notational convenience is the context, a term with a hole "*" poked in it where another term may be placed. We define a subclass of contexts, the reduction contexts. This notion comes from <ref> [10] </ref> (and is called there an evaluation context) to simplify the presentation of operational semantics. A reduction context is a syntactic means of isolating the next computation step to be performed. Definition 8 1. A context C is a term containing numbered holes "* i ", i 2 N .
Reference: 11. <author> M. Hennessy. </author> <title> Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: Circuit Testing and Equivalence Having defined the operational semantics and semantic well-formedness, we can now define notions of equivalence on C-CSP terms that will be used to prove the compiler correct. The equivalences we define are in the spirit of the testing equivalence of [22], <ref> [11] </ref>, with some ideas taken from Morris/Plotkin operational equivalence [23]. Testing equivalence is a precise formalization of exhaustive testing, so if two processes are testing-equivalent, no difference will be ever be able to be ascertained between the two by a tester. <p> For a more complete verification effort, a logic (including quantification) could be developed and used to specify and prove high-level properties of the CSP-style specifications. Numerous such logics have been constructed [13], [21], [12], <ref> [11] </ref>, [1], so this is an eminently feasible task. The advantage of this approach as opposed to a post-hoc verification methodology is the high-level specification is relatively simple in comparison with an actual circuit, making it easier to reason about.
Reference: 12. <author> Matthew Hennessy. </author> <title> Synchronous and asynchronous experiments on processes. </title> <journal> Inform. and Control, </journal> <volume> 59 </volume> <pages> 36-83, </pages> <year> 1983. </year>
Reference-contexts: For a more complete verification effort, a logic (including quantification) could be developed and used to specify and prove high-level properties of the CSP-style specifications. Numerous such logics have been constructed [13], [21], <ref> [12] </ref>, [11], [1], so this is an eminently feasible task. The advantage of this approach as opposed to a post-hoc verification methodology is the high-level specification is relatively simple in comparison with an actual circuit, making it easier to reason about.
Reference: 13. <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: All of the above projects excepting [20] use the same basic methodology, described as follows. The circuit is specified in a CSP-like language <ref> [13] </ref> as a set of concurrently executing processes that can communicate via fixed channels. A specification is constructed from simple programming language constructs that include variables x and assignments x := a, conditional branching, looping, parallel execution, and sequencing. <p> Neither of these works incorporates a fairness assumption as we do, fairness is notoriously difficult to deal with and is generally not taken into account for this reason. 2. The Circuit Language|C-CSP In this section we introduce C-CSP (Circuit-CSP), a variation of the CSP language <ref> [13] </ref> based on the version of CSP designed by Martin [17] for specifying asynchronous circuits. We have removed some syntactic sugar to make the correctness task more feasible and added refined scoping constructs needed to guarantee correctness. <p> This is a standard approach taken by process algebra researchers <ref> [13] </ref>, [21]. Since the circuits we are synthesizing are asynchronous, this approximation cannot lead to any timing errors in the final circuit. We next define those configurations that violate mutual exclusion principles, and thus should not arise in computing. <p> Since CSP is only a programming language, some high-level specifications cannot be expressed concisely in this language. For a more complete verification effort, a logic (including quantification) could be developed and used to specify and prove high-level properties of the CSP-style specifications. Numerous such logics have been constructed <ref> [13] </ref>, [21], [12], [11], [1], so this is an eminently feasible task. The advantage of this approach as opposed to a post-hoc verification methodology is the high-level specification is relatively simple in comparison with an actual circuit, making it easier to reason about.
Reference: 14. <author> Alain J. Martin. </author> <title> The design of a self-timed circuit for distributed mutual exclusion. </title> <booktitle> In 1985 Chapel Nill Conference on VLSI, </booktitle> <pages> pages 245-260, </pages> <year> 1985. </year>
Reference-contexts: The specification then undergoes a series of transformations that in the end results in an asynchronous circuit. Our work is based on the asynchronous design method of Martin et al. [17], [18], <ref> [14] </ref>, [15], [19]. Burns and Martin have described and implemented a circuit compiler [6], [5] that uses this method to automatically translate specifications into circuits. This paper is concerned with rigorously establishing the correctness of asynchronous circuit compilers. There have been multiple efforts in this area, including [25], [29], [27]. <p> Similarly, P p is the set of passive port names, and S?; P ?; : : : range over P p . The boolean expressions e are the usual ones plus the probe P ? <ref> [14] </ref>, by which a passive port may test to see if the corresponding active port is enabled without causing a synchronization to occur. The commands are similar to those of CSP. skip does nothing. Assignment, x := e, assigns the value of e to the boolean variable x.
Reference: 15. <author> Alain J. Martin. </author> <title> Compiling communicating processes into delay-insensitive VLSI circuits. </title> <journal> Distributed Computing, </journal> <volume> 1(4) </volume> <pages> 226-234, </pages> <year> 1986. </year>
Reference-contexts: The specification then undergoes a series of transformations that in the end results in an asynchronous circuit. Our work is based on the asynchronous design method of Martin et al. [17], [18], [14], <ref> [15] </ref>, [19]. Burns and Martin have described and implemented a circuit compiler [6], [5] that uses this method to automatically translate specifications into circuits. This paper is concerned with rigorously establishing the correctness of asynchronous circuit compilers. There have been multiple efforts in this area, including [25], [29], [27].
Reference: 16. <author> Alain J. Martin. </author> <title> The limitations to delay-insensitivity in asynchronous circuits. </title> <editor> In William J. Dally, editor, </editor> <booktitle> Sixth MIT Conference on Advanced Research in VLSI, </booktitle> <pages> pages 263-278. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Isochronic forks are imaginary objects, so it is up to the circuit layout and fabrication process to guarantee isochronicity. There has been some debate about the appropriateness of the isochronic forks assumption [26], <ref> [16] </ref>. Fairness Unlike most other formal models for circuits in the literature, we make explicit assumptions that gate delay cannot be infinite: if a gate is continuously enabled to switch, it will eventually switch (weak fairness assumption). Since gates are in practice fair, this is an important assumption.
Reference: 17. <author> Alain J. Martin. </author> <title> Programming in VLSI: From communicating processes to delay-insensitive circuits. </title> <editor> In C. A. R. Hoare, editor, </editor> <title> Developments in Concurrency and Communication. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year> <booktitle> UT Year of Programming Institute on Concurrent Programming. </booktitle>
Reference-contexts: 1. Introduction A large number of research projects have developed methods for the automatic synthesis of asynchronous circuits from high-level specifications <ref> [17] </ref>, [18], [28], [2], [20]. These methods are a significant departure from the traditional design methodologies used in circuit development in they are automatic or semi-automatic techniques for synthesizing asynchronous circuits from high-level specifications. All of the above projects excepting [20] use the same basic methodology, described as follows. <p> The specification then undergoes a series of transformations that in the end results in an asynchronous circuit. Our work is based on the asynchronous design method of Martin et al. <ref> [17] </ref>, [18], [14], [15], [19]. Burns and Martin have described and implemented a circuit compiler [6], [5] that uses this method to automatically translate specifications into circuits. This paper is concerned with rigorously establishing the correctness of asynchronous circuit compilers. <p> The Circuit Language|C-CSP In this section we introduce C-CSP (Circuit-CSP), a variation of the CSP language [13] based on the version of CSP designed by Martin <ref> [17] </ref> for specifying asynchronous circuits. We have removed some syntactic sugar to make the correctness task more feasible and added refined scoping constructs needed to guarantee correctness. Unlike Martin, we use the same language as the specification language, the intermediate language, and to express circuits.
Reference: 18. <author> Alain J. Martin. </author> <title> Synthesis of asynchronous VLSI circuits. </title> <editor> In J. Straunstrup, editor, </editor> <booktitle> Formal Methods for VLSI Design, </booktitle> <pages> pages 237-283. </pages> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: 1. Introduction A large number of research projects have developed methods for the automatic synthesis of asynchronous circuits from high-level specifications [17], <ref> [18] </ref>, [28], [2], [20]. These methods are a significant departure from the traditional design methodologies used in circuit development in they are automatic or semi-automatic techniques for synthesizing asynchronous circuits from high-level specifications. All of the above projects excepting [20] use the same basic methodology, described as follows. <p> The specification then undergoes a series of transformations that in the end results in an asynchronous circuit. Our work is based on the asynchronous design method of Martin et al. [17], <ref> [18] </ref>, [14], [15], [19]. Burns and Martin have described and implemented a circuit compiler [6], [5] that uses this method to automatically translate specifications into circuits. This paper is concerned with rigorously establishing the correctness of asynchronous circuit compilers.
Reference: 19. <author> Alain J. Martin, Steven M. Burns, T.K. Lee, Drazen Borkovic, and Pieter J. Hazewindus. </author> <title> The design of an asynchronous microprocessor. </title> <editor> In Charles L. Seitz, editor, </editor> <booktitle> Advanced Research in VLSI: Proc. of the Decennial Caltech Conference on VLSI, </booktitle> <pages> pages 351-373, </pages> <year> 1989. </year>
Reference-contexts: The specification then undergoes a series of transformations that in the end results in an asynchronous circuit. Our work is based on the asynchronous design method of Martin et al. [17], [18], [14], [15], <ref> [19] </ref>. Burns and Martin have described and implemented a circuit compiler [6], [5] that uses this method to automatically translate specifications into circuits. This paper is concerned with rigorously establishing the correctness of asynchronous circuit compilers. There have been multiple efforts in this area, including [25], [29], [27].
Reference: 20. <author> Teresa H.-Y. Meng, Robert W. Brodersen, and David G. Messerschmitt. </author> <title> Automatic synthesis of asynchronous circuits from high-level specifications. </title> <journal> IEEE Trans. on CAD, </journal> <volume> 8(11) </volume> <pages> 1185-1205, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: 1. Introduction A large number of research projects have developed methods for the automatic synthesis of asynchronous circuits from high-level specifications [17], [18], [28], [2], <ref> [20] </ref>. These methods are a significant departure from the traditional design methodologies used in circuit development in they are automatic or semi-automatic techniques for synthesizing asynchronous circuits from high-level specifications. All of the above projects excepting [20] use the same basic methodology, described as follows. <p> for the automatic synthesis of asynchronous circuits from high-level specifications [17], [18], [28], [2], <ref> [20] </ref>. These methods are a significant departure from the traditional design methodologies used in circuit development in they are automatic or semi-automatic techniques for synthesizing asynchronous circuits from high-level specifications. All of the above projects excepting [20] use the same basic methodology, described as follows. The circuit is specified in a CSP-like language [13] as a set of concurrently executing processes that can communicate via fixed channels.
Reference: 21. <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: This is a standard approach taken by process algebra researchers [13], <ref> [21] </ref>. Since the circuits we are synthesizing are asynchronous, this approximation cannot lead to any timing errors in the final circuit. We next define those configurations that violate mutual exclusion principles, and thus should not arise in computing. <p> Since CSP is only a programming language, some high-level specifications cannot be expressed concisely in this language. For a more complete verification effort, a logic (including quantification) could be developed and used to specify and prove high-level properties of the CSP-style specifications. Numerous such logics have been constructed [13], <ref> [21] </ref>, [12], [11], [1], so this is an eminently feasible task. The advantage of this approach as opposed to a post-hoc verification methodology is the high-level specification is relatively simple in comparison with an actual circuit, making it easier to reason about.
Reference: 22. <author> R. De Nicola and M.C.B. Hennessy. </author> <title> Testing Equivalences for Processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 83-133, </pages> <year> 1983. </year>
Reference-contexts: Circuit Testing and Equivalence Having defined the operational semantics and semantic well-formedness, we can now define notions of equivalence on C-CSP terms that will be used to prove the compiler correct. The equivalences we define are in the spirit of the testing equivalence of <ref> [22] </ref>, [11], with some ideas taken from Morris/Plotkin operational equivalence [23]. Testing equivalence is a precise formalization of exhaustive testing, so if two processes are testing-equivalent, no difference will be ever be able to be ascertained between the two by a tester.
Reference: 23. <author> G. Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-255, </pages> <year> 1977. </year>
Reference-contexts: The equivalences we define are in the spirit of the testing equivalence of [22], [11], with some ideas taken from Morris/Plotkin operational equivalence <ref> [23] </ref>. Testing equivalence is a precise formalization of exhaustive testing, so if two processes are testing-equivalent, no difference will be ever be able to be ascertained between the two by a tester. Testing is an internal or self-consistent notion of equivalence, processes are tested by other processes only.
Reference: 24. <author> Scott F. Smith and Amy E. Zwarico. </author> <title> Provably correct synthesis of asynchronous circuits. </title> <editor> In Jtrgen Staunstrup and Robin Sharp, editors, </editor> <booktitle> 2nd Workshop on Designing Correct Circuits, Lyngby, </booktitle> <pages> pages 237-260. </pages> <publisher> Elsevier, North Holland, </publisher> <year> 1992. </year>
Reference-contexts: This paper is concerned with rigorously establishing the correctness of asynchronous circuit compilers. There have been multiple efforts in this area, including [25], [29], [27]. This paper is a complete presentation of preliminary work described in <ref> [24] </ref>, [25]. We first present an overview of our method, and conclude this section by contrasting with related work. 2 1.1. Our method The results in this paper are based on a mathematical circuit model described as follows. Speed-Independent We work under the assumption of speed-independence.
Reference: 25. <author> Scott F. Smith and Amy E. Zwarico. </author> <title> Correct compilation of specifications to deterministic asynchronous circuits. </title> <editor> In George Milne, editor, </editor> <title> Correct Hardware Design and Verification Methods (CHARME), </title> <booktitle> volume 683 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Burns and Martin have described and implemented a circuit compiler [6], [5] that uses this method to automatically translate specifications into circuits. This paper is concerned with rigorously establishing the correctness of asynchronous circuit compilers. There have been multiple efforts in this area, including <ref> [25] </ref>, [29], [27]. This paper is a complete presentation of preliminary work described in [24], [25]. We first present an overview of our method, and conclude this section by contrasting with related work. 2 1.1. <p> This paper is concerned with rigorously establishing the correctness of asynchronous circuit compilers. There have been multiple efforts in this area, including <ref> [25] </ref>, [29], [27]. This paper is a complete presentation of preliminary work described in [24], [25]. We first present an overview of our method, and conclude this section by contrasting with related work. 2 1.1. Our method The results in this paper are based on a mathematical circuit model described as follows. Speed-Independent We work under the assumption of speed-independence.
Reference: 26. <author> C. H. van Berkel. </author> <title> Beware the isochronic fork. </title> <institution> Nat. Lab. Unclassified Report UR 003/91, Philips Research Lab., Eindhoven, </institution> <address> The Netherlands, </address> <year> 1991. </year>
Reference-contexts: Isochronic forks are imaginary objects, so it is up to the circuit layout and fabrication process to guarantee isochronicity. There has been some debate about the appropriateness of the isochronic forks assumption <ref> [26] </ref>, [16]. Fairness Unlike most other formal models for circuits in the literature, we make explicit assumptions that gate delay cannot be infinite: if a gate is continuously enabled to switch, it will eventually switch (weak fairness assumption). Since gates are in practice fair, this is an important assumption.
Reference: 27. <author> Kees van Berkel. </author> <title> Handshake Circuits: an Asynchronous Architecture for VLSI Programming, </title> <booktitle> volume 5 of International Series on Parallel Computation. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Burns and Martin have described and implemented a circuit compiler [6], [5] that uses this method to automatically translate specifications into circuits. This paper is concerned with rigorously establishing the correctness of asynchronous circuit compilers. There have been multiple efforts in this area, including [25], [29], <ref> [27] </ref>. This paper is a complete presentation of preliminary work described in [24], [25]. We first present an overview of our method, and conclude this section by contrasting with related work. 2 1.1. Our method The results in this paper are based on a mathematical circuit model described as follows. <p> Real asynchronous circuits do not contain gates that starve, so this assumption is critical in accurately modeling asynchronous circuits. Second, the semantics provides a mechanism for reasoning about potential mutual exclusion problems. This differs from other researchers [29], <ref> [27] </ref> who prevent all violations of mutual exclusion from occurring by placing syntactic restrictions on the sharing of variables. One such restriction others impose is to disallow two processes executing in parallel to share a variable. <p> The disadvantage of our approach is the need to prove that no ERROR states arise during execution, for each specification. Key to proving the correctness of the transformation process is defining a reasonable notion of "equivalence" between processes. Many useful notions of equivalence have been defined. Trace equivalence <ref> [27] </ref>, [8], [9] and bisimulation equivalence [29] have both been effectively used for reasoning about asynchronous circuits. Our approach is based on a third variety, testing equivalence. Two processes are testing equivalent if they pass the same set of infinitely many tests. <p> There is no production rule phase. A somewhat different compilation method is used for guards and synchronizations. 1.3. Related Work on Correctness of Asynchronous Circuit Compilers Two papers address the same general problem of proving correctness of asynchronous circuit compilers [29], <ref> [27] </ref>. These two papers are more closely related CORRECT COMPILATION OF SPECIFICATIONS TO ASYNCHRONOUS CIRCUITS 5 to each other than either are to our work. Some comparisons are as follows. Weber, Bloom, and Brown define a process language Joy and show how it may be compiled to asynchronous circuitry. <p> The two different equivalences give rise to two significantly different proof techniques. It is not clear if bisimulation could be used to prove our compilation method correct, the more liberal nature of C-CSP requires a more "context-dependent" analysis achievable through testing but not bisimulation. Kees van Berkel <ref> [27] </ref> gives a correctness proof for compiling the CSP-based specification language Tangram to handshake circuits. Tangram can only have single uses of each port. The compilation process goes through an intermediate language, handshake circuits. His book focuses on many other important issues such as initialization and optimization.
Reference: 28. <author> Kees van Berkel, Joep Kessels, Marly Roncken, Ronald Saeijs, and Frits Schalij. </author> <title> The VLSI-programming language Tangram and its translation into handshake circuits. </title> <booktitle> In Proceedings of the European Design Automation Conference, </booktitle> <pages> pages 384-389, </pages> <year> 1991. </year>
Reference-contexts: 1. Introduction A large number of research projects have developed methods for the automatic synthesis of asynchronous circuits from high-level specifications [17], [18], <ref> [28] </ref>, [2], [20]. These methods are a significant departure from the traditional design methodologies used in circuit development in they are automatic or semi-automatic techniques for synthesizing asynchronous circuits from high-level specifications. All of the above projects excepting [20] use the same basic methodology, described as follows.
Reference: 29. <author> S. Weber, B. Bloom, and G. Brown. </author> <title> Compiling Joy to silicon. </title> <booktitle> In Advanced research in VLSI and parallel systems : proceedings of the 1992 Brown/MIT conference. </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year> <title> CORRECT COMPILATION OF SPECIFICATIONS TO ASYNCHRONOUS CIRCUITS 37 </title>
Reference-contexts: Burns and Martin have described and implemented a circuit compiler [6], [5] that uses this method to automatically translate specifications into circuits. This paper is concerned with rigorously establishing the correctness of asynchronous circuit compilers. There have been multiple efforts in this area, including [25], <ref> [29] </ref>, [27]. This paper is a complete presentation of preliminary work described in [24], [25]. We first present an overview of our method, and conclude this section by contrasting with related work. 2 1.1. <p> First, we need to define executions so only fair computations are allowed. Real asynchronous circuits do not contain gates that starve, so this assumption is critical in accurately modeling asynchronous circuits. Second, the semantics provides a mechanism for reasoning about potential mutual exclusion problems. This differs from other researchers <ref> [29] </ref>, [27] who prevent all violations of mutual exclusion from occurring by placing syntactic restrictions on the sharing of variables. One such restriction others impose is to disallow two processes executing in parallel to share a variable. <p> Key to proving the correctness of the transformation process is defining a reasonable notion of "equivalence" between processes. Many useful notions of equivalence have been defined. Trace equivalence [27], [8], [9] and bisimulation equivalence <ref> [29] </ref> have both been effectively used for reasoning about asynchronous circuits. Our approach is based on a third variety, testing equivalence. Two processes are testing equivalent if they pass the same set of infinitely many tests. <p> There is no production rule phase. A somewhat different compilation method is used for guards and synchronizations. 1.3. Related Work on Correctness of Asynchronous Circuit Compilers Two papers address the same general problem of proving correctness of asynchronous circuit compilers <ref> [29] </ref>, [27]. These two papers are more closely related CORRECT COMPILATION OF SPECIFICATIONS TO ASYNCHRONOUS CIRCUITS 5 to each other than either are to our work. Some comparisons are as follows. Weber, Bloom, and Brown define a process language Joy and show how it may be compiled to asynchronous circuitry.
References-found: 29

