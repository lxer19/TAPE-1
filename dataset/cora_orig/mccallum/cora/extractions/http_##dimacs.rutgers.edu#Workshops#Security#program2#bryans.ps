URL: http://dimacs.rutgers.edu/Workshops/Security/program2/bryans.ps
Refering-URL: http://dimacs.rutgers.edu/Workshops/Security/program2/program.html
Root-URL: http://www.cs.rutgers.edu
Title: CSP, PVS and a Recursive Authentication Protocol  
Author: Jeremy Bryans and Steve Schneider 
Address: Egham, Surrey, TW20 0EX  
Affiliation: Department of Computer Science Royal Holloway and Bedford New College  
Abstract-found: 0
Intro-found: 1
Reference: [BO97] <author> J. Bull and D. J. Otway. </author> <title> The Authentication Protocol. </title> <type> Technical Report DRA/CIS3/PROJ/CORBA/SC/1/CSM/436-04/03, </type> <institution> DRA, </institution> <month> Feb </month> <year> 1997. </year>
Reference-contexts: However, even with mechanical support the construction of proofs is far from easy, because of the inherent complexity involved in modelling all the possibilities of malicious action. In this paper, we consider a novel authentication protocol, proposed in <ref> [BO97] </ref>. The protocol can be used in various ways: we take the purpose to be that of establishing an uncompromised chain of session keys between adjacent pairs of agents involved in the protocol run. <p> In the traces model, if traces (Q ) traces (P ) then we say that Q is a refinement of P , written P v Q . 3 The protocol In <ref> [BO97] </ref> an authentication protocol is proposed, which is further explained in [Pau97]. This protocol operates over an arbitrarily long chain of protocol agents, terminating with a key-server. We set out to verify that a run of the protocol establishes an uncompromised chain of session keys between adjacent pairs of agents.
Reference: [BS97] <author> J. W. Bryans and S. A. Schneider. </author> <title> Mechanical Verification of the full Needham-Schroeder Public-Key Protocol. </title> <type> Technical Report CSD-TR-97-11, </type> <institution> Royal Holloway, University of London, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: For this reason, the CSP traces theory has been embedded within PVS [DS97a, SOR93], and this description has been successfully used to mechanise several proofs of authentication properties <ref> [DS97b, BS97] </ref>. However, even with mechanical support the construction of proofs is far from easy, because of the inherent complexity involved in modelling all the possibilities of malicious action. In this paper, we consider a novel authentication protocol, proposed in [BO97]. <p> Since a process P satisfies a predicate E iff all its traces satisfy E , a satisfaction operator `|&gt;' can be defined, so that P |&gt; E provided P is a subset of E . The Dolev-Yao framework has already been translated into PVS <ref> [DS97a, BS97] </ref>, so all that was required was to define the message space and the protocol agents.
Reference: [DS97a] <author> B. Dutertre and S. A. Schneider. </author> <title> Embedding CSP in PVS. An application to Authentication Protocols. </title> <type> Technical Report CSD-TR-97-12, </type> <institution> Royal Holloway, University of London, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: However, proving authentication is still an arduous task. The principal problem is in the complexity of the message space, which gives rise to a mass of detail in proofs, requiring a significant amount of detailed housekeeping. For this reason, the CSP traces theory has been embedded within PVS <ref> [DS97a, SOR93] </ref>, and this description has been successfully used to mechanise several proofs of authentication properties [DS97b, BS97]. However, even with mechanical support the construction of proofs is far from easy, because of the inherent complexity involved in modelling all the possibilities of malicious action. <p> There may be an arbitrary number of agents, and consequently there may be an arbitrary number of messages, which may grow to arbitrary lengths. Despite the extra complexity of the protocol, adapting the techniques developed in <ref> [DS97a] </ref> to prove that the session keys are uncompromised turned out to be relatively straightforward, and the proofs of authentication were not significantly more complex. We present the rank function used, and show how PVS uses the rank function to prove the authentication property. <p> Those used in this paper are given in Figure 2. The soundness of the rules follows from the trace semantics of the operators, and the formal definition of T authenticates R. They have been proven in PVS <ref> [DS97a] </ref>. We may give informal justification of their soundness by considering that occurrence of an event from T is intended to provide evidence that some event from R previously occurred. <p> The problem for any particular protocol, and a particular authentication property expressed in terms of R and T , is to find an appropriate rank function which makes C 1 to C 4 all true, and to verify this fact. 5 Translating to PVS notation In <ref> [DS97a] </ref>, an embedding of CSP in PVS is presented, precisely for mecha-nising the proofs necessary with this approach. CSP traces are represented as lists, a pre-defined notion in PVS. Processes are described as sets of traces. The CSP operators are then defined as trace combinators. <p> Since a process P satisfies a predicate E iff all its traces satisfy E , a satisfaction operator `|&gt;' can be defined, so that P |&gt; E provided P is a subset of E . The Dolev-Yao framework has already been translated into PVS <ref> [DS97a, BS97] </ref>, so all that was required was to define the message space and the protocol agents. <p> Proving that each of the processes maintains rank is very straightforward. The proof consists mainly of PVS macro steps developed specifically for authentication protocols, and presented in <ref> [DS97a] </ref>. The run times (on a Sparc 5) to check the proofs once they were developed were: userA took 25 seconds, userB took 91 seconds and server took 223 seconds. 6 Incorrect Implementation In [RS97], an attack on an implementation of the recursive authentication protocol is described.
Reference: [DS97b] <author> B. Dutertre and S. A. Schneider. </author> <title> Using a PVS Embedding of CSP to verify Authentication Protocols. </title> <booktitle> In Proceedings of TPHOLS, </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: For this reason, the CSP traces theory has been embedded within PVS [DS97a, SOR93], and this description has been successfully used to mechanise several proofs of authentication properties <ref> [DS97b, BS97] </ref>. However, even with mechanical support the construction of proofs is far from easy, because of the inherent complexity involved in modelling all the possibilities of malicious action. In this paper, we consider a novel authentication protocol, proposed in [BO97].
Reference: [DY83] <author> D. Dolev and A. C. Yao. </author> <title> On the Security of Public Key Protocols. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> 29(2), </volume> <year> 1983. </year>
Reference-contexts: The protocol operates in a hostile environment. This is also modelled within CSP in order to facilitate analysis. The approach taken is to provide a CSP description of the Dolev-Yao model <ref> [DY83] </ref>. In this model, it is assumed that the medium is under the complete control of the enemy, which can block, re-address, duplicate and fake messages.
Reference: [Hoa85] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: 1 Introduction In this paper we consider the nature of machine proofs used in the CSP approach to the verification of authentication protocols. In [Sch96], a general method is presented for the analysis and verification of authentication protocols using the process algebra CSP <ref> [Hoa85] </ref>. The CSP syntax provides a natural and precise way to describe such protocols in terms of the messages accepted and transmitted by the individual protocol participants. The CSP traces model provides a formal framework for reasoning about these protocols.
Reference: [Pau97] <author> L. Paulson. </author> <title> Mechanized proofs for a recursive authentication protocol. </title> <type> unpublished, </type> <year> 1997. </year>
Reference-contexts: In the traces model, if traces (Q ) traces (P ) then we say that Q is a refinement of P , written P v Q . 3 The protocol In [BO97] an authentication protocol is proposed, which is further explained in <ref> [Pau97] </ref>. This protocol operates over an arbitrarily long chain of protocol agents, terminating with a key-server. We set out to verify that a run of the protocol establishes an uncompromised chain of session keys between adjacent pairs of agents.
Reference: [RS97] <author> P. Y. A. Ryan and S. A. Schneider. </author> <title> An Attack on a Recursive Authentication Protocol: A cautionary tale. </title> <type> DRA report, </type> <month> May </month> <year> 1997. </year>
Reference-contexts: We present the rank function used, and show how PVS uses the rank function to prove the authentication property. In <ref> [RS97] </ref>, an attack is described on an implementation of this protocol and a correction is proposed. We go on to identify where the particular implementation decisions made compromised the protocol, and how the proof of authentication for the original definition of the protocol fails when applied to the faulty implementation. <p> The run times (on a Sparc 5) to check the proofs once they were developed were: userA took 25 seconds, userB took 91 seconds and server took 223 seconds. 6 Incorrect Implementation In <ref> [RS97] </ref>, an attack on an implementation of the recursive authentication protocol is described. The implementation decision which leads to the attack is straightforward. The server computes the certificates as K ab L Hash K a fNag, where ` L ' represents the bitwise XOR of two bit strings. <p> Other rank functions could be tried, in which case the proof would fail at some other stage. 6.2 Corrected Implementation The corrected implementation proposed in <ref> [RS97] </ref> is a very simple extension of the incorrect version. They suggest that the server return certificates of the form K ab Hash Kb fNb; Ag; K bc L Hash Kb fNb; C g which does indeed provide secure session keys between pairs of honest agents.
Reference: [Sch96] <author> S. A. Schneider. </author> <title> Using CSP for protocol analysis: the Needham-Schroeder Public-Key Protocol. </title> <type> Technical Report CSD-TR-96-14, </type> <institution> Royal Holloway, University of London, </institution> <month> October </month> <year> 1996. </year>
Reference-contexts: 1 Introduction In this paper we consider the nature of machine proofs used in the CSP approach to the verification of authentication protocols. In <ref> [Sch96] </ref>, a general method is presented for the analysis and verification of authentication protocols using the process algebra CSP [Hoa85]. The CSP syntax provides a natural and precise way to describe such protocols in terms of the messages accepted and transmitted by the individual protocol participants. <p> In the CSP method, authentication is considered to be message-oriented: m2 authenticates m1 if the receipt of m2 guarantees the previous transmission of m1, even in a hostile environment. To facilitate proofs, a notion of a rank function is developed in <ref> [Sch96] </ref>. This is an integer-valued function on the message space, such that all messages apart from m1 which could possibly circulate in the network have a rank greater than zero, and the message which provides authentication (m2 above) has a rank of zero or below. <p> We also provide an analysis of the corrected protocol, and verify that the attack is no longer possible. Finally, we speculate on how failed proofs may lead us to discover attacks. 2 CSP In <ref> [Sch96] </ref> a general framework for analysing security properties within the process algebra CSP is presented. Only a limited number of CSP operators are necessary. <p> The hiding operator P n A hides the events in set A, which means that no other process can participate in occurrences of these events. The atomic process Stop marks the termination of a process. 2.1 Traces In <ref> [Sch96] </ref>, the traces model is used as the basis for the proof rules presented. In this model, the semantics of a process P is defined to be the set of traces (sequences of events) that it may possibly perform. <p> We will use CSP processes to describe the behaviour of each of the participating agents. For simplicity, we will consider in this paper a single run of the protocol, though the approach extends naturally to multiple concurrent runs, as discussed in <ref> [Sch96] </ref>. <p> The network description consists of a set of user processes which execute the protocol, an intruder process and a medium which carries all the messages. As is pointed out in <ref> [Sch96] </ref>, the medium and intruder can be rewritten as a single process ENEMY : ENEMY (S ) = trans?i?j ?m ! ENEMY (S [ fmg) 2 2 i;j 2USER;S`m rec:i!j !m ! ENEMY (S ) This is the description we shall use through this paper: ENEMY = ENEMY (INIT ), where
Reference: [SOR93] <author> N. Shankar, S. Owre, and J. M. Rushby. </author> <title> The PVS Proof Checker: </title>
Reference-contexts: However, proving authentication is still an arduous task. The principal problem is in the complexity of the message space, which gives rise to a mass of detail in proofs, requiring a significant amount of detailed housekeeping. For this reason, the CSP traces theory has been embedded within PVS <ref> [DS97a, SOR93] </ref>, and this description has been successfully used to mechanise several proofs of authentication properties [DS97b, BS97]. However, even with mechanical support the construction of proofs is far from easy, because of the inherent complexity involved in modelling all the possibilities of malicious action.
References-found: 10

