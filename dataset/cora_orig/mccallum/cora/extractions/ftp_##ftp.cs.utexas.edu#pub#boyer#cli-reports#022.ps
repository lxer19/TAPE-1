URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/022.ps
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/index.html
Root-URL: 
Title: Piton: A Verified Assembly Level Language  
Author: by J Strother Moore 
Address: 1717 West Sixth Street, Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic, Inc.  
Date: September, 1988  
Pubnum: Technical Report 22  
Abstract: This work was supported in part at Computational Logic, Inc., by the Defense Advanced Research Projects Agency, ARPA Orders 6082 and 9151. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency or the U.S. Government. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> W. Bevier. </author> <title> A Verified Operating System Kernel. </title> <type> Ph.D. </type> <institution> Th., University of Texas at Austin, </institution> <year> 1987. </year>
Reference-contexts: Properties of the machine code programs would be proved directly from the FM8502 definition. This view of an assembler level language is exactly that taken by Bevier in <ref> [1] </ref>. If the machine code programs thus produced can overwrite themselves, as is possible with all conventional assemblers, this is the only view possible. The instructions of the program must be bit vectors rather than symbolic expressions since data can be treated as instructions.
Reference: 2. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: The FM8501 is a 16-bit, 8 register general purpose processor implementing a machine language with a conventional orthogonal instruction set. Hunt formally described the instruction set of the FM8501 by defining an interpreter for it in the computational logic designed by Boyer and Moore <ref> [2, 4] </ref>. Hunt also formally described the combinational logic and a register-transfer model that he claimed implemented the instruction set. The Boyer-Moore theorem prover was then used to prove that the register-transfer model correctly 2 implemented the machine code interpreter. <p> This was an inevitable suggestion since FM8501 was developed in the same laboratory responsible for the Gypsy Verification Environment [9] and the Boyer-Moore theorem prover <ref> [2, 4] </ref>, two of the most widely used program verification systems. But, unless one wants to build such tools in machine language, it is necessary to implement higher-level languages on FM8501.
Reference: 3. <author> R. S. Boyer and J S. Moore. </author> <title> A Verification Condition Generator for FORTRAN. In The Correctness Problem in Computer Science, </title> <editor> R. S. Boyer and J S. Moore, Eds., </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: Some verification work addresses ``code proofs,'' where traditionally the line has been drawn at the definition of a high-level programming language like Gypsy [7, 8, 9], Pascal [20], Fortran <ref> [3] </ref>, and others [21, 6, 13, 17, 5]. There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified. Finally, there has been some recent work closer to the bottom of the system stack.
Reference: 4. <author> R. S. Boyer and J S. Moore. </author> <title> A User's Manual for A Computational Logic. </title> <type> Tech. Rept. Technical Report 18, </type> <institution> Computational Logic, Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703, </address> <year> 1988. </year>
Reference-contexts: The FM8501 is a 16-bit, 8 register general purpose processor implementing a machine language with a conventional orthogonal instruction set. Hunt formally described the instruction set of the FM8501 by defining an interpreter for it in the computational logic designed by Boyer and Moore <ref> [2, 4] </ref>. Hunt also formally described the combinational logic and a register-transfer model that he claimed implemented the instruction set. The Boyer-Moore theorem prover was then used to prove that the register-transfer model correctly 2 implemented the machine code interpreter. <p> This was an inevitable suggestion since FM8501 was developed in the same laboratory responsible for the Gypsy Verification Environment [9] and the Boyer-Moore theorem prover <ref> [2, 4] </ref>, two of the most widely used program verification systems. But, unless one wants to build such tools in machine language, it is necessary to implement higher-level languages on FM8501. <p> The index indicates the page number on which each function symbol is defined and lists all of the page numbers in Chapters 7-10 on which each function is used. 1.6. Notation This report assumes a basic familiarity with the Boyer-Moore logic <ref> [4] </ref>. In examples of Piton syntax, states and data all of which are explicit values in the logic we frequently omit the quotation mark required to distinguish constants from formulas. <p> An Example Piton Program We begin our presentation of Piton with a simple example. Below we exhibit a Piton program named DEMO. The program is a list constant in the computational logic of Boyer and Moore <ref> [4] </ref> and is displayed in the traditional Lisp-like notation. Comments are written in the right-hand column, bracketed by the comment delimiters semi-colon and end-of-line. <p> Primitive Functions The following primitive function symbols are used in this document: ADD1, AND, APPEND, ASSOC, CAR, CDR, CONS, DIFFERENCE, EQUAL, IF, IMPLIES, LESSP, LISTP, LITATOM, MEMBER, MINUS, NEGATIVE-GUTS, NEGATIVEP, NLISTP, NOT, NUMBERP, OR, PACK, PAIRLIST, PLUS, QUOTIENT, REMAINDER, STRIP-CARS, SUB1, TIMES, TRUEP, UNPACK, ZERO and ZEROP. See <ref> [4] </ref> for the axioms defining these functions. Appendix II. Statistics II.1. History of the Project The project originally started in September, 1986. <p> These invariants primarily concern resource hiding. 238 The total time taken to reproduce the proofs on a 12 megabyte Sun 3/60 running the Austin Kyoto Common Lisp implementation of the Boyer-Moore theorem prover <ref> [4] </ref> is 16 hours. 239
Reference: 5. <author> Dan Craigen. </author> <title> A Description of m-Verdi [Working Draft]. </title> <editor> I. P. </editor> <publisher> Sharp Associates, Ltd., </publisher> <year> 1986. </year>
Reference-contexts: Some verification work addresses ``code proofs,'' where traditionally the line has been drawn at the definition of a high-level programming language like Gypsy [7, 8, 9], Pascal [20], Fortran [3], and others <ref> [21, 6, 13, 17, 5] </ref>. There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified. Finally, there has been some recent work closer to the bottom of the system stack.
Reference: 6. <author> S. L. Gerhart, D. R. Musser, D. H. Thompson, D. A. Baker, R. L. Bates, R. W. Erickson, R. L. London, D. G. Taylor and D. S. Wile. </author> <title> An Overview of AFFIRM: A Specification and Verification System. Information Processing 80, </title> <editor> S. H. Lavington (Ed.), </editor> <month> October, </month> <year> 1980, </year> <pages> pp. 343-348. </pages> <publisher> North Holland Publishing Company. </publisher>
Reference-contexts: Some verification work addresses ``code proofs,'' where traditionally the line has been drawn at the definition of a high-level programming language like Gypsy [7, 8, 9], Pascal [20], Fortran [3], and others <ref> [21, 6, 13, 17, 5] </ref>. There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified. Finally, there has been some recent work closer to the bottom of the system stack.
Reference: 7. <author> Donald I. </author> <title> Good. Mechanical Proofs about Computer Programs. </title> <editor> In C. A. R. Hoare and J. C. Shepherdson, Ed., </editor> <booktitle> Mathematical Logic and Programming Languages, Prentice-Hall International Series in Computer Science., </booktitle> <year> 1985, </year> <pages> pp. 55-75. </pages>
Reference-contexts: Some verification work addresses ``code proofs,'' where traditionally the line has been drawn at the definition of a high-level programming language like Gypsy <ref> [7, 8, 9] </ref>, Pascal [20], Fortran [3], and others [21, 6, 13, 17, 5]. There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified.
Reference: 8. <author> Donald I. Good, Robert L. Akers, Lawrence M. Smith. </author> <note> Report on Gypsy 2.05 - January 1986. Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703., </address> <year> 1986. </year>
Reference-contexts: Some verification work addresses ``code proofs,'' where traditionally the line has been drawn at the definition of a high-level programming language like Gypsy <ref> [7, 8, 9] </ref>, Pascal [20], Fortran [3], and others [21, 6, 13, 17, 5]. There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified.
Reference: 9. <author> Michael K. Smith, Donald I. Good, Benedetto L. DiVito. </author> <title> Using the Gypsy Methodology. Computational Logic, </title> <publisher> Inc., </publisher> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703., </address> <year> 1988. </year> <note> Revised January 1988. </note>
Reference-contexts: Some verification work addresses ``code proofs,'' where traditionally the line has been drawn at the definition of a high-level programming language like Gypsy <ref> [7, 8, 9] </ref>, Pascal [20], Fortran [3], and others [21, 6, 13, 17, 5]. There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified. <p> This was an inevitable suggestion since FM8501 was developed in the same laboratory responsible for the Gypsy Verification Environment <ref> [9] </ref> and the Boyer-Moore theorem prover [2, 4], two of the most widely used program verification systems. But, unless one wants to build such tools in machine language, it is necessary to implement higher-level languages on FM8501.
Reference: 10. <author> Mike Gordon. </author> <title> Proving a Computer Correct. </title> <type> Tech. Rept. TR 42, </type> <institution> University of Cambridge, Computer Laboratory, </institution> <year> 1983. </year>
Reference-contexts: There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified. Finally, there has been some recent work closer to the bottom of the system stack. For example, Gordon <ref> [10] </ref> and Hunt [11] draw the line essentially at the register-transfer level and offer mechanically certified designs for digital hardware. But the research underlying the construction of the first fully verified system must address more than just the verification of the individual components.
Reference: 11. <author> Warren A. Hunt, Jr. FM8501: </author> <title> A Verified Microprocessor. </title> <type> Ph.D. </type> <institution> Th., University of Texas at Austin, </institution> <year> 1985. </year>
Reference-contexts: There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified. Finally, there has been some recent work closer to the bottom of the system stack. For example, Gordon [10] and Hunt <ref> [11] </ref> draw the line essentially at the register-transfer level and offer mechanically certified designs for digital hardware. But the research underlying the construction of the first fully verified system must address more than just the verification of the individual components. <p> While it is not important to Piton, the reader may well wonder in what sense FM8502 is verified. FM8502 is verified in exactly the same sense that FM8501 is verified in Hunt's dissertation <ref> [11] </ref>. We will briefly discuss Hunt's FM8501 work and then return to FM8502. Hunt described FM8501 by defining a function called SOFT (for ``software''). SOFT is an interpreter for the machine code of a 16-bit wide general purpose computer. <p> In summary, Hunt defined two machines, SOFT and a register transfer model, and proved them equivalent. ``FM8501'' (which is a term not formally defined in <ref> [11] </ref>) can be thought of as the machine these two functions describe. ``FM8502'' has been produced in a similar fashion. <p> FM8502 then uses SOFT to determine the values of the six components of the final state. Finally, FM8502-&gt;M is used to package up the six values into a single m-state again. Our SOFT is so similar to Hunt's, which is explained in detail in <ref> [11] </ref>, that we do not further elaborate. We do include the entire tree of definitions in this report. We did so for three reasons. First, we thus enter it into the historical record.
Reference: 12. <author> P. M. Melliar-Smith and R. Schwartz. </author> <title> Hierarchical Specification of the SIFT Fault-Tolerant Flight Control System. </title> <type> Tech. </type> <institution> Rept. CSL-123, Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, Ca., </address> <year> 1981. </year>
Reference-contexts: We have in mind specifically the work related to the SRI Hierarchical Design Methodology [16] and its use in the Provably Secure Operating System (PSOS) [14] and the Software Implemented Fault Tolerant (SIFT) operating system <ref> [12, 19] </ref>. While virtually all of the issues are correctly intuited, we personally find great joy in seeing their formalization. The commitment to stacking has had several effects. The desire to implement Piton forced into its design such practical considerations as the finite resources of the host machine.
Reference: 13. <author> David R. Musser and David A. Cyrluk. </author> <title> AFFIRM-85 Installation Guide and Reference Manual Update. General Electric Corporate Research and Development, </title> <year> 1985. </year>
Reference-contexts: Some verification work addresses ``code proofs,'' where traditionally the line has been drawn at the definition of a high-level programming language like Gypsy [7, 8, 9], Pascal [20], Fortran [3], and others <ref> [21, 6, 13, 17, 5] </ref>. There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified. Finally, there has been some recent work closer to the bottom of the system stack.
Reference: 14. <author> P. G. Neumann, L. Robinson, K. Levitt, R. Boyer, A. Saxena. </author> <title> A Provably Secure Operating System. </title> <type> Tech. </type> <institution> Rept. CSL-116, Computer Science Laboratory, SRI International, </institution> <year> 1977. </year>
Reference-contexts: Much has been written about this classic problem but the previous attempts to deal with it formally and mechanically have been unsatisfactory. We have in mind specifically the work related to the SRI Hierarchical Design Methodology [16] and its use in the Provably Secure Operating System (PSOS) <ref> [14] </ref> and the Software Implemented Fault Tolerant (SIFT) operating system [12, 19]. While virtually all of the issues are correctly intuited, we personally find great joy in seeing their formalization. The commitment to stacking has had several effects.
Reference: 15. <author> W. Polak. </author> <title> Compiler Specification and Verification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: There has been some work on compiler verification, notably the work of Polak <ref> [15] </ref> in which a compiler for a Pascal subset is verified. Finally, there has been some recent work closer to the bottom of the system stack. For example, Gordon [10] and Hunt [11] draw the line essentially at the register-transfer level and offer mechanically certified designs for digital hardware.
Reference: 16. <author> L. Robinson and K. Levitt. </author> <title> "Proof Techniques for Hierarchically Structured Programs". </title> <journal> Comm. ACM 20, </journal> <month> 4 (April </month> <year> 1977). </year>
Reference-contexts: Much has been written about this classic problem but the previous attempts to deal with it formally and mechanically have been unsatisfactory. We have in mind specifically the work related to the SRI Hierarchical Design Methodology <ref> [16] </ref> and its use in the Provably Secure Operating System (PSOS) [14] and the Software Implemented Fault Tolerant (SIFT) operating system [12, 19]. While virtually all of the issues are correctly intuited, we personally find great joy in seeing their formalization. The commitment to stacking has had several effects.
Reference: 17. <author> Mark Saaltink. </author> <title> The Verdi Logic [Working Draft]. </title> <editor> I. P. </editor> <publisher> Sharp Associates, Ltd., </publisher> <year> 1986. </year>
Reference-contexts: Some verification work addresses ``code proofs,'' where traditionally the line has been drawn at the definition of a high-level programming language like Gypsy [7, 8, 9], Pascal [20], Fortran [3], and others <ref> [21, 6, 13, 17, 5] </ref>. There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified. Finally, there has been some recent work closer to the bottom of the system stack.
Reference: 18. <author> Richard M. Stallman. </author> <title> GNU Emacs Manual. Free Software Foundation, </title> <address> 1000 Massachusetts Avenue, Cambridge, MA 02138, </address> <year> 1987. </year>
Reference-contexts: In addition, because of the wonders of GNU Emacs key board macros <ref> [18] </ref>, many of the characters allegedly typed were not actually typed at all but were generated from previous type-in. For readers unfamiliar with text editing we give two examples.
Reference: 19. <author> D.F. Stanat, T.A. Thomas, and J.R. Dunham. </author> <title> Proceedings of a Formal Verification/Design Proof Peer Review. </title> <type> Tech. </type> <institution> Rept. RTI/2094/13-01F, Research Triangle Institute, </institution> <address> P.O. Box 12194, Research Triangle Park, N.C., 27709, </address> <year> 1984. </year>
Reference-contexts: We have in mind specifically the work related to the SRI Hierarchical Design Methodology [16] and its use in the Provably Secure Operating System (PSOS) [14] and the Software Implemented Fault Tolerant (SIFT) operating system <ref> [12, 19] </ref>. While virtually all of the issues are correctly intuited, we personally find great joy in seeing their formalization. The commitment to stacking has had several effects. The desire to implement Piton forced into its design such practical considerations as the finite resources of the host machine.
Reference: 20. <institution> Stanford Verification Group. Stanford Pascal Verifier User Manual. Stanford University, </institution> <year> 1979. </year>
Reference-contexts: Some verification work addresses ``code proofs,'' where traditionally the line has been drawn at the definition of a high-level programming language like Gypsy [7, 8, 9], Pascal <ref> [20] </ref>, Fortran [3], and others [21, 6, 13, 17, 5]. There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified. Finally, there has been some recent work closer to the bottom of the system stack.

Reference: 1. <author> Introduction and Background 1 1.1. </author> <title> Motivation 1 1.2. System Verification 1 1.3. The Piton Project 2 1.4. Achievements 3 1.5. Outline of the Presentation 4 1.6. Notation 5 1.7. </title> <type> Acknowledgements 5 </type>
Reference-contexts: Properties of the machine code programs would be proved directly from the FM8502 definition. This view of an assembler level language is exactly that taken by Bevier in <ref> [1] </ref>. If the machine code programs thus produced can overwrite themselves, as is possible with all conventional assemblers, this is the only view possible. The instructions of the program must be bit vectors rather than symbolic expressions since data can be treated as instructions.
Reference: 2. <author> An Informal Sketch of Piton 7 2.1. </author> <title> An Example Piton Program 7 2.2. Piton States 8 2.3. Type Checking 9 2.4. Data Types 10 2.4.1. Integers 10 2.4.2. Natural Numbers 10 2.4.3. Booleans 11 2.4.4. Bit Vectors 11 2.4.5. Data Addresses 11 2.4.6. Program Addresses 11 2.4.7. Subroutines 12 2.5. The Data Segment 12 2.6. The Program Segment 13 2.7. Instructions 14 2.8. The Piton Interpreter 22 2.9. </title> <booktitle> Erroneous States 22 </booktitle>
Reference-contexts: The FM8501 is a 16-bit, 8 register general purpose processor implementing a machine language with a conventional orthogonal instruction set. Hunt formally described the instruction set of the FM8501 by defining an interpreter for it in the computational logic designed by Boyer and Moore <ref> [2, 4] </ref>. Hunt also formally described the combinational logic and a register-transfer model that he claimed implemented the instruction set. The Boyer-Moore theorem prover was then used to prove that the register-transfer model correctly 2 implemented the machine code interpreter. <p> This was an inevitable suggestion since FM8501 was developed in the same laboratory responsible for the Gypsy Verification Environment [9] and the Boyer-Moore theorem prover <ref> [2, 4] </ref>, two of the most widely used program verification systems. But, unless one wants to build such tools in machine language, it is necessary to implement higher-level languages on FM8501.

Reference: 4. <institution> A Sketch of FM8502 51 </institution>
Reference-contexts: The FM8501 is a 16-bit, 8 register general purpose processor implementing a machine language with a conventional orthogonal instruction set. Hunt formally described the instruction set of the FM8501 by defining an interpreter for it in the computational logic designed by Boyer and Moore <ref> [2, 4] </ref>. Hunt also formally described the combinational logic and a register-transfer model that he claimed implemented the instruction set. The Boyer-Moore theorem prover was then used to prove that the register-transfer model correctly 2 implemented the machine code interpreter. <p> This was an inevitable suggestion since FM8501 was developed in the same laboratory responsible for the Gypsy Verification Environment [9] and the Boyer-Moore theorem prover <ref> [2, 4] </ref>, two of the most widely used program verification systems. But, unless one wants to build such tools in machine language, it is necessary to implement higher-level languages on FM8501. <p> The index indicates the page number on which each function symbol is defined and lists all of the page numbers in Chapters 7-10 on which each function is used. 1.6. Notation This report assumes a basic familiarity with the Boyer-Moore logic <ref> [4] </ref>. In examples of Piton syntax, states and data all of which are explicit values in the logic we frequently omit the quotation mark required to distinguish constants from formulas. <p> An Example Piton Program We begin our presentation of Piton with a simple example. Below we exhibit a Piton program named DEMO. The program is a list constant in the computational logic of Boyer and Moore <ref> [4] </ref> and is displayed in the traditional Lisp-like notation. Comments are written in the right-hand column, bracketed by the comment delimiters semi-colon and end-of-line. <p> Primitive Functions The following primitive function symbols are used in this document: ADD1, AND, APPEND, ASSOC, CAR, CDR, CONS, DIFFERENCE, EQUAL, IF, IMPLIES, LESSP, LISTP, LITATOM, MEMBER, MINUS, NEGATIVE-GUTS, NEGATIVEP, NLISTP, NOT, NUMBERP, OR, PACK, PAIRLIST, PLUS, QUOTIENT, REMAINDER, STRIP-CARS, SUB1, TIMES, TRUEP, UNPACK, ZERO and ZEROP. See <ref> [4] </ref> for the axioms defining these functions. Appendix II. Statistics II.1. History of the Project The project originally started in September, 1986. <p> These invariants primarily concern resource hiding. 238 The total time taken to reproduce the proofs on a 12 megabyte Sun 3/60 running the Austin Kyoto Common Lisp implementation of the Boyer-Moore theorem prover <ref> [4] </ref> is 16 hours. 239


Reference: 7. <institution> The Formal Definition of Piton 91 7.1. </institution> <note> A Guide to the Formal Definition of Piton 91 7.1.1. Proper P-States 91 7.1.2. The Piton Interpreter 94 7.2. Alphabetical Listing of the Piton Definition 95 </note>
Reference-contexts: Some verification work addresses ``code proofs,'' where traditionally the line has been drawn at the definition of a high-level programming language like Gypsy <ref> [7, 8, 9] </ref>, Pascal [20], Fortran [3], and others [21, 6, 13, 17, 5]. There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified.
Reference: 8. <institution> The Formal Definition of FM8502 155 8.1. </institution> <note> A Guide to the Formal Definition of FM8502 155 8.2. Alphabetical Listing of the FM8502 Definitions 156 iii </note>
Reference-contexts: Some verification work addresses ``code proofs,'' where traditionally the line has been drawn at the definition of a high-level programming language like Gypsy <ref> [7, 8, 9] </ref>, Pascal [20], Fortran [3], and others [21, 6, 13, 17, 5]. There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified.
Reference: 9. <author> The Formal Implementation 169 9.1. </author> <title> A Guide to the Formal Implementation 169 9.1.1. The Formal Definition of Resource Representation 169 9.1.2. </title> <booktitle> The Formal Definition of the Compiler 171 9.1.3. The Formal Definition of the Link-Assembler 174 9.2. Alphabetical Listing of the Implementation 176 </booktitle>
Reference-contexts: Some verification work addresses ``code proofs,'' where traditionally the line has been drawn at the definition of a high-level programming language like Gypsy <ref> [7, 8, 9] </ref>, Pascal [20], Fortran [3], and others [21, 6, 13, 17, 5]. There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified. <p> This was an inevitable suggestion since FM8501 was developed in the same laboratory responsible for the Gypsy Verification Environment <ref> [9] </ref> and the Boyer-Moore theorem prover [2, 4], two of the most widely used program verification systems. But, unless one wants to build such tools in machine language, it is necessary to implement higher-level languages on FM8501.
Reference: 10. <institution> The Formal Correctness Theorem 205 </institution>
Reference-contexts: There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified. Finally, there has been some recent work closer to the bottom of the system stack. For example, Gordon <ref> [10] </ref> and Hunt [11] draw the line essentially at the register-transfer level and offer mechanically certified designs for digital hardware. But the research underlying the construction of the first fully verified system must address more than just the verification of the individual components.
Reference: 11. <institution> Proof of the Correctness Theorem 211 11.1. </institution> <note> The R Machine 211 11.2. The I Machine 214 11.3. The M Machine 218 11.4. The One-Way Correspondence Lemmas 218 11.4.1. P-&gt;R 218 11.4.3. I-&gt;M 226 11.5. The Correctness Proof 228 </note>
Reference-contexts: There has been some work on compiler verification, notably the work of Polak [15] in which a compiler for a Pascal subset is verified. Finally, there has been some recent work closer to the bottom of the system stack. For example, Gordon [10] and Hunt <ref> [11] </ref> draw the line essentially at the register-transfer level and offer mechanically certified designs for digital hardware. But the research underlying the construction of the first fully verified system must address more than just the verification of the individual components. <p> While it is not important to Piton, the reader may well wonder in what sense FM8502 is verified. FM8502 is verified in exactly the same sense that FM8501 is verified in Hunt's dissertation <ref> [11] </ref>. We will briefly discuss Hunt's FM8501 work and then return to FM8502. Hunt described FM8501 by defining a function called SOFT (for ``software''). SOFT is an interpreter for the machine code of a 16-bit wide general purpose computer. <p> In summary, Hunt defined two machines, SOFT and a register transfer model, and proved them equivalent. ``FM8501'' (which is a term not formally defined in <ref> [11] </ref>) can be thought of as the machine these two functions describe. ``FM8502'' has been produced in a similar fashion. <p> FM8502 then uses SOFT to determine the values of the six components of the final state. Finally, FM8502-&gt;M is used to package up the six values into a single m-state again. Our SOFT is so similar to Hunt's, which is explained in detail in <ref> [11] </ref>, that we do not further elaborate. We do include the entire tree of definitions in this report. We did so for three reasons. First, we thus enter it into the historical record.
References-found: 28

