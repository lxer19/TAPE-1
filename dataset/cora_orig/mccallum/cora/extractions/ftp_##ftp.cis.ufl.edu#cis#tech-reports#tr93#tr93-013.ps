URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr93/tr93-013.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr93-abstracts.html
Root-URL: http://www.cis.ufl.edu
Abstract-found: 0
Intro-found: 1
Reference: [Anw92a] <author> E. Anwar. </author> <title> Supporting complex events and rules in an oodbms: A seamless approach. </title> <type> Master's thesis, </type> <institution> Database Systems R&D Center, CIS Department, University of Florida, </institution> <address> E470-CSE, Gainesville, FL 32611, </address> <month> November </month> <year> 1992. </year>
Reference: [Anw92b] <author> E. Anwar. </author> <title> Supporting complex events and rules in an oodbms: A seamless approach. </title> <type> Master's thesis, </type> <institution> Database Systems R&D Center, CIS Department, University of Florida, </institution> <address> E470-CSE, Gainesville, FL 32611, </address> <month> November </month> <year> 1992. </year>
Reference: [AU79] <author> A. Aho and J. Ullman. </author> <title> Universality of data retrieval languages. </title> <booktitle> In Proc. of the 6th ACM Symposium on Principles oof Programming Languages, </booktitle> <year> 1979. </year>
Reference-contexts: The optimization is performed to make the rules to be evaluated more efficiently. Rules or queries are transformed into equivalent rules or queries by rewriting rules or introducing new rules. For example, The Aho-Ullman algorithm rewrites recursive queries by commuting selections with the least fixpoint operator <ref> [AU79] </ref>; the Magic Sets algorithm reduces the number of potentially relevant facts by the introduction of new rules [B + 86]. In active databases, efficient management of event-condition-action (ECA) rules is the main concern.
Reference: [B + 86] <editor> F. Bancilhon et al. </editor> <title> Magic sets: Algorithms and examples. </title> <type> Unpublished manuscript, </type> <year> 1986. </year>
Reference-contexts: For example, The Aho-Ullman algorithm rewrites recursive queries by commuting selections with the least fixpoint operator [AU79]; the Magic Sets algorithm reduces the number of potentially relevant facts by the introduction of new rules <ref> [B + 86] </ref>. In active databases, efficient management of event-condition-action (ECA) rules is the main concern. This translates into efficient detection of events as well as evaluation of the query (condition) and the action (transaction) associated with that event.
Reference: [Bat88] <author> D. Batory. </author> <title> GENESIS: An Extensible Database Management System. </title> <journal> IEEE Transactions on Software Eng, </journal> <month> Nov. </month> <year> 1988. </year>
Reference-contexts: Three basic approaches have been used for developing extensible query optimizers: the generator approach [GD87, Mck92], the building block approach <ref> [Bat88] </ref>, and the modular approach [Loh88, M + 89, SR86]. Some approaches use rules for expressing transformations and user-definable cost estimates for the purpose of pruning the search space.
Reference: [BMG92] <author> Jose A. Blakeley, William J. Mckenna, and Gectz Graefe. </author> <title> Experiences building the open oodb query optimizer. </title> <type> Technical report, </type> <institution> Texas Instruments INC., </institution> <year> 1992. </year>
Reference-contexts: We intend to concentrate on the open architecture and the issues mentioned above and plan on using available tools where possible. Our short immediate term goal is to use the Volcano <ref> [Mck92, BMG92] </ref> optimizer generator (by modifying it where necessary) to move towards the open architecture. Initially, we will try to group rules into modules that roughly correspond to local experts. This requires modifications to relevant parts of Volcano to match our requirements.
Reference: [BR86] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An Amateur's Introduction to Recursive Query Processing Strategies. </title> <booktitle> In Proceedings ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 16-52, </pages> <year> 1986. </year>
Reference-contexts: The input query is first modified using the compiled (intensional) database, and then optimized using conventional query optimization techniques. As 3 for recursive query processing in deductive database, numerous strategies have been proposed <ref> [BR86, LV89, Sto90, WF90] </ref>. In general,a recursive query is evaluated in the following way [BR86]: 1. Generate the intermediate result set, 2. Expand the set by evaluating the sentences within it, 3. Check the termination Condition at each step. <p> The input query is first modified using the compiled (intensional) database, and then optimized using conventional query optimization techniques. As 3 for recursive query processing in deductive database, numerous strategies have been proposed [BR86, LV89, Sto90, WF90]. In general,a recursive query is evaluated in the following way <ref> [BR86] </ref>: 1. Generate the intermediate result set, 2. Expand the set by evaluating the sentences within it, 3. Check the termination Condition at each step. According to the way in which the language is generated,the strategies can be categorized into: bottom-up and top-down.
Reference: [C + 89] <author> S. Chakravarthy et al. HiPAC: </author> <title> A Research Project in Active, Time-Constrained Database Management, </title> <type> Final Report. Technical Report XAIT-89-02, </type> <institution> Xerox Advanced Information Technology, </institution> <address> Cambridge, MA, </address> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: Functionally, an active database management system monitors conditions triggered by events and if the condition evaluates to true then the action is executed. Events have been broadly classified <ref> [C + 89] </ref> into: database events (database operations, such as insert, delete), temporal events (absolute, and relative time events), external or abstract events (e.g., report arrives, start-chip-test), and complex/composite events that are constructed from primitive events (the previous 3 categories) and a set of event operators (e.g., disjunction, sequence, one-or-more). <p> Second, rules used for some applications are likely to have priorities or timing requirements associated with their execution. Optimization of such rules requires different techniques, such as exhaustive optimization, novel buffering strategies, use of main memory, and appropriate processing techniques (e.g., use of parallelism). In HiPAC <ref> [RCBB89, C + 89] </ref>, incremental operators, a chain rule (which was generalized in [CG91]), and a signal graph was proposed for optimizing situations.
Reference: [CG91] <author> S. Chakravarthy and S. Garg. </author> <title> Extended relational algebra (era): for optimizing situations in active databases. </title> <type> Technical Report UF-CIS TR-91-24, </type> <institution> Database Systems R&D 10 Center, CIS Department, University of Florida, </institution> <address> E470-CSE, Gainesville, FL 32611, </address> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Optimization of such rules requires different techniques, such as exhaustive optimization, novel buffering strategies, use of main memory, and appropriate processing techniques (e.g., use of parallelism). In HiPAC [RCBB89, C + 89], incremental operators, a chain rule (which was generalized in <ref> [CG91] </ref>), and a signal graph was proposed for optimizing situations. The chain rule and incremental forms are similar to the transformations performed by a conventional query optimizer (e.g., 4 commuting the selection with join) but on new operators.
Reference: [CGM88] <author> S. Chakravarthy, J. Grant, and J. Minker. </author> <title> Foundations of semantic query optimization for deductive databases. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 243-273. </pages> <publisher> Morgan Kaufmann Publications, </publisher> <year> 1988. </year>
Reference-contexts: For processing queries in nonrecursive deductive databases, conventional query optimization need only be augmented with a compilation phase to transform intensional relations in terms of extensional relations <ref> [CGM88, CGM90] </ref>. The input query is first modified using the compiled (intensional) database, and then optimized using conventional query optimization techniques. As 3 for recursive query processing in deductive database, numerous strategies have been proposed [BR86, LV89, Sto90, WF90].
Reference: [CGM90] <author> S. Chakravarthy, J. Grant, and J. Minker. </author> <title> Logic-based approach to semantic query optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(2) </volume> <pages> 162-207, </pages> <year> 1990. </year>
Reference-contexts: For processing queries in nonrecursive deductive databases, conventional query optimization need only be augmented with a compilation phase to transform intensional relations in terms of extensional relations <ref> [CGM88, CGM90] </ref>. The input query is first modified using the compiled (intensional) database, and then optimized using conventional query optimization techniques. As 3 for recursive query processing in deductive database, numerous strategies have been proposed [BR86, LV89, Sto90, WF90].
Reference: [Cha89] <author> S. Chakravarthy. Hipac: </author> <title> A research project in active,time-constrained database management. </title> <type> Technical report, </type> <institution> Xerox Advanced Information Technology, </institution> <year> 1989. </year>
Reference-contexts: Recent work on active databases [C + 89, SHP88, WF90, DB90, Int90b, GJS92a, GJ91a, DPG91, MP90, SKL89, CHS93, Anw92a, CN90, Mau92, DUHK93, GrD93] and the need for supporting situation monitoring in the form of event-condition-action rules has prompted a fresh look at the architecture of database systems <ref> [DB90, CN90, Cha89, CNG + 90, KDM88] </ref>. The need for integrating active functionality with traditional databases has resulted in the identification of new components (e.g., situation monitor), extensions to existing components (e.g., transaction manager) as well as new results on several issues.
Reference: [Cha91] <author> S. Chakravarthy. </author> <title> Divide and Conquer: A Basis for Augmenting a Conventional Query Optimizer with Multiple Query Processing Capabilities. </title> <booktitle> In Proc. of the 7th Int'l Conf. on Data Engineering, </booktitle> <address> Kobe, Japan, </address> <pages> pages 482-490, </pages> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: First, ECA rules are temporally persistent. That is, they have a longer life-span and as a result are likely to be evaluated many times. This suggests that several rules can be optimized simultaneously in a group, possibly using some of the techniques developed for multiple query optimization <ref> [Fin82, CM86, RC88, Sel86, Cha91] </ref>. The effect of multiple query optimization can be further enhanced by materializing intermediate results (e.g., common subexpressions) judiciously. Second, rules used for some applications are likely to have priorities or timing requirements associated with their execution.
Reference: [CHS93] <author> S. Chakravarthy, E. Hanson, and S.Y.W. Su. </author> <title> Active Database Research at the University of Florida. </title> <journal> To appear in IEEE Quarterly Bulletin on Data Engineering, </journal> <month> January </month> <year> 1993. </year>
Reference: [CM86] <author> U. S. Chakravarthy and J. Minker. </author> <title> Multiple Query Processing in Deductive Databases Using Query Graphs. </title> <booktitle> In Proceedings of International Conference of Very Large Data Bases, </booktitle> <pages> pages 384-391, </pages> <year> 1986. </year>
Reference-contexts: First, ECA rules are temporally persistent. That is, they have a longer life-span and as a result are likely to be evaluated many times. This suggests that several rules can be optimized simultaneously in a group, possibly using some of the techniques developed for multiple query optimization <ref> [Fin82, CM86, RC88, Sel86, Cha91] </ref>. The effect of multiple query optimization can be further enhanced by materializing intermediate results (e.g., common subexpressions) judiciously. Second, rules used for some applications are likely to have priorities or timing requirements associated with their execution.
Reference: [CM91] <author> S. Chakravathy and D. Mishra. </author> <title> An event specification language (snoop) for active databases and its detection. </title> <type> Technical Report UF-CIS TR-91-23, </type> <institution> Database Systems R&D Center, CIS Department, University of Florida, </institution> <address> E470-CSE, Gainesville, FL 32611, </address> <month> Sep. </month> <year> 1991. </year>
Reference: [CN90] <author> U. S. Chakravarthy and S. Nesson. </author> <title> Making an Object-Oriented DBMS Active: Design, Implementation and Evaluation of a Prototype. </title> <booktitle> In Proc. of Int'l Conf. on Extended Database Technology (EDBT), </booktitle> <address> Kobe, Japan, </address> <pages> pages 482-490, </pages> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: Recent work on active databases [C + 89, SHP88, WF90, DB90, Int90b, GJS92a, GJ91a, DPG91, MP90, SKL89, CHS93, Anw92a, CN90, Mau92, DUHK93, GrD93] and the need for supporting situation monitoring in the form of event-condition-action rules has prompted a fresh look at the architecture of database systems <ref> [DB90, CN90, Cha89, CNG + 90, KDM88] </ref>. The need for integrating active functionality with traditional databases has resulted in the identification of new components (e.g., situation monitor), extensions to existing components (e.g., transaction manager) as well as new results on several issues.
Reference: [CNG + 90] <author> S. Chakravarthy, S. B. Navathe, S. Garg, D. Mishra, and A. Sharma. </author> <title> An evaluation of active dbms developments. </title> <type> Technical Report UF-CIS TR-90-23, </type> <institution> Database Systems R&D Center, CIS Department, University of Florida, </institution> <address> E470-CSE, Gainesville, FL 32611, </address> <month> Sep. </month> <year> 1990. </year>
Reference-contexts: Recent work on active databases [C + 89, SHP88, WF90, DB90, Int90b, GJS92a, GJ91a, DPG91, MP90, SKL89, CHS93, Anw92a, CN90, Mau92, DUHK93, GrD93] and the need for supporting situation monitoring in the form of event-condition-action rules has prompted a fresh look at the architecture of database systems <ref> [DB90, CN90, Cha89, CNG + 90, KDM88] </ref>. The need for integrating active functionality with traditional databases has resulted in the identification of new components (e.g., situation monitor), extensions to existing components (e.g., transaction manager) as well as new results on several issues.
Reference: [DB90] <author> M. Darnovsky and J. Bowman. </author> <title> TRANSACT-SQL USER'S GUIDE, Release 4.2. Document 3231-2.1, </title> <publisher> Sybase Inc., </publisher> <month> May </month> <year> 1990. </year>
Reference-contexts: Recent work on active databases [C + 89, SHP88, WF90, DB90, Int90b, GJS92a, GJ91a, DPG91, MP90, SKL89, CHS93, Anw92a, CN90, Mau92, DUHK93, GrD93] and the need for supporting situation monitoring in the form of event-condition-action rules has prompted a fresh look at the architecture of database systems <ref> [DB90, CN90, Cha89, CNG + 90, KDM88] </ref>. The need for integrating active functionality with traditional databases has resulted in the identification of new components (e.g., situation monitor), extensions to existing components (e.g., transaction manager) as well as new results on several issues.
Reference: [DBAB + 88] <author> U. Dayal, B. Blaustein, S. Chakravarthy A. Buchmann, et al. </author> <title> The HiPAC project: Combining active databases and timing constraints. Special Issue of Real Time Data Base Systems, </title> <booktitle> SIGMOD Record, </booktitle> <volume> 17(1) </volume> <pages> 51-70, </pages> <month> Mar. </month> <year> 1988. </year>
Reference: [dMS88] <author> C. de Mairdreville and E. Simon. </author> <title> Modelling queries and updates in deductive databases. </title> <booktitle> In proc. of the 14th Int'l Conf. on VLDB,, </booktitle> <address> Los Angles, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: They also provide a theory that supports both declarative and procedural semantics. Logic programming, on the other hand, has concentrated on exploring efficient techniques for various classes of theories and queries. Various approaches (loosely coupled,tightly coupled, and integrated) have been proposed to combine deductive rules with relational systems <ref> [dMS88, Min88, VCJ, SHP87] </ref>. Efforts such as Megalog, LDL, RDL1 and LDL++, Coral have endeavored to integrate rule processing and traditional database functionality (and object-oriented paradigm as in LDL++ and Coral++).
Reference: [DPG91] <author> O. Diaz, N. Paton, and P. Gray. </author> <title> Rule Management in Object-Oriented Databases: A Unified Approach. </title> <booktitle> In Proceedings 17th International Conference on Very Large Data Bases, </booktitle> <address> Barcelona (Catalonia, Spain), </address> <month> Sept. </month> <year> 1991. </year> <month> 11 </month>
Reference: [DUHK93] <author> S. W. Dietrich, S. D. Urban, J. V. Harrison, and A. P. Karadimce. </author> <title> A DOOD RANCH at ASU: Integrating Active, Deductive and Object-Oriented Databases. </title> <journal> To appear in IEEE Quarterly Bulletin on Data Engineering, </journal> <month> January </month> <year> 1993. </year>
Reference: [Fin82] <author> S. Finkelstein. </author> <title> Common Expression Analysis in Database applications. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <address> Orlando, </address> <month> Jun. </month> <year> 1982. </year>
Reference-contexts: First, ECA rules are temporally persistent. That is, they have a longer life-span and as a result are likely to be evaluated many times. This suggests that several rules can be optimized simultaneously in a group, possibly using some of the techniques developed for multiple query optimization <ref> [Fin82, CM86, RC88, Sel86, Cha91] </ref>. The effect of multiple query optimization can be further enhanced by materializing intermediate results (e.g., common subexpressions) judiciously. Second, rules used for some applications are likely to have priorities or timing requirements associated with their execution.
Reference: [GD87] <author> G. Graefe and D. DeWitt. </author> <title> The Exodus Optimizer Generator. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <pages> pages 160-172, </pages> <year> 1987. </year>
Reference-contexts: Three basic approaches have been used for developing extensible query optimizers: the generator approach <ref> [GD87, Mck92] </ref>, the building block approach [Bat88], and the modular approach [Loh88, M + 89, SR86]. Some approaches use rules for expressing transformations and user-definable cost estimates for the purpose of pruning the search space.
Reference: [GJ91a] <author> N. H. Gehani and H. V. Jagadish. </author> <title> Ode as an Active Database: Constraints and Triggers. </title> <booktitle> In Proceedings 17th International Conference on Very Large Data Bases, </booktitle> <pages> pages 327-336, </pages> <address> Barcelona (Catalonia, Spain), </address> <month> Sep. </month> <year> 1991. </year>
Reference: [GJ91b] <author> N. H. Gehani and H. V. Jagadish. </author> <title> Ode as an Active Database: Constraints and Triggers. </title> <booktitle> In Proceedings 17th International Conference on Very Large Data Bases, </booktitle> <pages> pages 327-336, </pages> <address> Barcelona (Catalonia, Spain), </address> <month> Sep. </month> <year> 1991. </year>
Reference: [GJS92a] <author> N. H. Gehani, H. V. Jagadish, and O. Shmueli. </author> <title> Event Specification in an Object-Oriented Database. </title> <booktitle> In Proceedings International Conference on Management of Data, </booktitle> <pages> pages 81-90, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference: [GJS92b] <author> N. H. Gehani, H. V. Jagadish, and O. Shmueli. </author> <title> Event Specification in an Object-Oriented Database. </title> <booktitle> In Proceedings International Conference on Management of Data, </booktitle> <pages> pages 81-90, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year>
Reference: [GrD93] <author> S. Gatziu and K. r. Dittrich. SAMOS: </author> <title> an Active, Object-Oriented Database System. </title> <journal> To appear in IEEE Quarterly Bulletin on Data Engineering, </journal> <month> January </month> <year> 1993. </year>
Reference: [Han89] <author> Eric N. Hanson. </author> <title> An Initial Report on the Design of Ariel: a DBMS with an integrated production rule system. </title> <journal> ACM SIGMOD RECORD, </journal> <volume> 18(3) </volume> <pages> 12-19, </pages> <month> Sep. </month> <year> 1989. </year>
Reference: [Int90a] <institution> Interbase Software Corporation, </institution> <address> 209 Burlington Road, Bedford, MA 01730. DDL Reference, </address> <month> February </month> <year> 1990. </year>
Reference: [Int90b] <institution> InterBase Software Corporation, Bedford, </institution> <address> MA. </address> <note> InterBase DDL Reference Manual, InterBase Version 3.0, </note> <year> 1990. </year>
Reference: [KDM88] <author> A. M. Kotz, K. R. Dittrich, and J. A. Mulle. </author> <title> Supporting Semantic Rules by a Generalized Event/Trigger Mechanism. </title> <booktitle> In Proceedings International Conference on Extended Data Base Technology, </booktitle> <address> Venice, </address> <month> Mar. </month> <year> 1988. </year>
Reference-contexts: Recent work on active databases [C + 89, SHP88, WF90, DB90, Int90b, GJS92a, GJ91a, DPG91, MP90, SKL89, CHS93, Anw92a, CN90, Mau92, DUHK93, GrD93] and the need for supporting situation monitoring in the form of event-condition-action rules has prompted a fresh look at the architecture of database systems <ref> [DB90, CN90, Cha89, CNG + 90, KDM88] </ref>. The need for integrating active functionality with traditional databases has resulted in the identification of new components (e.g., situation monitor), extensions to existing components (e.g., transaction manager) as well as new results on several issues.
Reference: [Loh88] <author> G. M. Lohman. </author> <title> Grammer-like functional rules for representing query optimizational-ternatives. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <pages> pages 18-27, </pages> <year> 1988. </year>
Reference-contexts: Three basic approaches have been used for developing extensible query optimizers: the generator approach [GD87, Mck92], the building block approach [Bat88], and the modular approach <ref> [Loh88, M + 89, SR86] </ref>. Some approaches use rules for expressing transformations and user-definable cost estimates for the purpose of pruning the search space. Although conceptually it is useful to think of strategy space generation and search as separate problems, efficiency aspects of optimization dictate that they be considered together.
Reference: [LV89] <author> A Lefebvre L Vieille. </author> <title> Deductive database systems and the dedgin query evaluator. </title> <booktitle> In proc. of the 7th British National Conference on Database, </booktitle> <institution> Heriot-Watt University, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: The input query is first modified using the compiled (intensional) database, and then optimized using conventional query optimization techniques. As 3 for recursive query processing in deductive database, numerous strategies have been proposed <ref> [BR86, LV89, Sto90, WF90] </ref>. In general,a recursive query is evaluated in the following way [BR86]: 1. Generate the intermediate result set, 2. Expand the set by evaluating the sentences within it, 3. Check the termination Condition at each step.
Reference: [M + 89] <author> L. M.Haas et al. </author> <title> Extensible query processing in starburst. </title> <booktitle> ACM-SIGMOD, </booktitle> <pages> pages 377-388, </pages> <year> 1989. </year>
Reference-contexts: Three basic approaches have been used for developing extensible query optimizers: the generator approach [GD87, Mck92], the building block approach [Bat88], and the modular approach <ref> [Loh88, M + 89, SR86] </ref>. Some approaches use rules for expressing transformations and user-definable cost estimates for the purpose of pruning the search space. Although conceptually it is useful to think of strategy space generation and search as separate problems, efficiency aspects of optimization dictate that they be considered together.
Reference: [Mau92] <author> L. Maugis. </author> <title> Adequacy of active oodbms to flight data processing servers. </title> <type> Master's the-sis, </type> <institution> National School of Civil Aviation / University of Florida, </institution> <address> E470-CSE, Gainesville, FL 32611, </address> <month> August </month> <year> 1992. </year>
Reference: [Mck92] <author> Bill Mckenna. </author> <title> Vocano query optimizer generator manual. </title> <type> Technical report, </type> <institution> University of Colorado,Boulder, </institution> <year> 1992. </year>
Reference-contexts: Three basic approaches have been used for developing extensible query optimizers: the generator approach <ref> [GD87, Mck92] </ref>, the building block approach [Bat88], and the modular approach [Loh88, M + 89, SR86]. Some approaches use rules for expressing transformations and user-definable cost estimates for the purpose of pruning the search space. <p> We intend to concentrate on the open architecture and the issues mentioned above and plan on using available tools where possible. Our short immediate term goal is to use the Volcano <ref> [Mck92, BMG92] </ref> optimizer generator (by modifying it where necessary) to move towards the open architecture. Initially, we will try to group rules into modules that roughly correspond to local experts. This requires modifications to relevant parts of Volcano to match our requirements.
Reference: [Min88] <editor> Jack Minker, editor. </editor> <booktitle> Foundations of Deductive Databases and Logic Programming. </booktitle> <publisher> Morgan Kaufmann Publishers,INC, </publisher> <year> 1988. </year>
Reference-contexts: They also provide a theory that supports both declarative and procedural semantics. Logic programming, on the other hand, has concentrated on exploring efficient techniques for various classes of theories and queries. Various approaches (loosely coupled,tightly coupled, and integrated) have been proposed to combine deductive rules with relational systems <ref> [dMS88, Min88, VCJ, SHP87] </ref>. Efforts such as Megalog, LDL, RDL1 and LDL++, Coral have endeavored to integrate rule processing and traditional database functionality (and object-oriented paradigm as in LDL++ and Coral++).
Reference: [MP90] <author> C. B. Medeiros and P. Pfeffer. </author> <title> A Mechanism for Managing Rules in an Object-oriented Database. </title> <type> Technical report, </type> <institution> GIP Altair, </institution> <month> Sept. </month> <year> 1990. </year>
Reference: [RC88] <author> A. Rosenthal and U. Chakravarthy. </author> <title> Anatomy of a Modular Multiple Query Optimizer. </title> <booktitle> In Proceedings 14th International Conference on Very Large Data Bases, </booktitle> <pages> pages 230-239, </pages> <address> Los Angeles, CA, </address> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: First, ECA rules are temporally persistent. That is, they have a longer life-span and as a result are likely to be evaluated many times. This suggests that several rules can be optimized simultaneously in a group, possibly using some of the techniques developed for multiple query optimization <ref> [Fin82, CM86, RC88, Sel86, Cha91] </ref>. The effect of multiple query optimization can be further enhanced by materializing intermediate results (e.g., common subexpressions) judiciously. Second, rules used for some applications are likely to have priorities or timing requirements associated with their execution. <p> The optimizing engine should preferably use an efficient and expressive representation (e.g., AND/OR graphs) and a search strategy that can be readily combined with the generation of the strategy space (e.g., heuristic state space search) which can be fine-tuned <ref> [RC88] </ref>. It should also be possible to specify the optimization parameters in a general fashion (such as CPU cost, I/O cost, the number of processors that can be used for processing a query, special purpose processors available etc.). <p> Some of them are discussed below: Interface: As discussed in <ref> [RC88] </ref>, an expressive canonical intermediate representation is critical for the success of this approach. In the absence of it, transformations have to be performed from one representation to the other incurring substantial overhead and difficulty in sharing partial results.
Reference: [RCBB89] <author> A. Rosenthal, U. S. Chakravarthy, B. Blaustein, and J. Blakeley. </author> <title> Situation Monitoring in Active Databases. </title> <booktitle> In Proc. of the 15th Int'l Conf. on Very Large Databases, </booktitle> <pages> pages 455-464, </pages> <address> Amsterdam, </address> <month> Aug. </month> <year> 1989. </year>
Reference-contexts: Second, rules used for some applications are likely to have priorities or timing requirements associated with their execution. Optimization of such rules requires different techniques, such as exhaustive optimization, novel buffering strategies, use of main memory, and appropriate processing techniques (e.g., use of parallelism). In HiPAC <ref> [RCBB89, C + 89] </ref>, incremental operators, a chain rule (which was generalized in [CG91]), and a signal graph was proposed for optimizing situations.
Reference: [Sel86] <author> T. Sellis. </author> <title> Global Query Optimization. </title> <booktitle> In Proceedings of SIGMOD, </booktitle> <pages> pages 191-205, </pages> <year> 1986. </year>
Reference-contexts: First, ECA rules are temporally persistent. That is, they have a longer life-span and as a result are likely to be evaluated many times. This suggests that several rules can be optimized simultaneously in a group, possibly using some of the techniques developed for multiple query optimization <ref> [Fin82, CM86, RC88, Sel86, Cha91] </ref>. The effect of multiple query optimization can be further enhanced by materializing intermediate results (e.g., common subexpressions) judiciously. Second, rules used for some applications are likely to have priorities or timing requirements associated with their execution.
Reference: [SHP87] <author> M. Stonebraker, M. Hanson, and S. Potamianos. </author> <title> A Rule manager for Relational database Systems. </title> <type> Technical report, </type> <institution> Dept. of Electrical Engineering and Computer Science, Univ. of California, Berkeley, </institution> <year> 1987. </year>
Reference-contexts: They also provide a theory that supports both declarative and procedural semantics. Logic programming, on the other hand, has concentrated on exploring efficient techniques for various classes of theories and queries. Various approaches (loosely coupled,tightly coupled, and integrated) have been proposed to combine deductive rules with relational systems <ref> [dMS88, Min88, VCJ, SHP87] </ref>. Efforts such as Megalog, LDL, RDL1 and LDL++, Coral have endeavored to integrate rule processing and traditional database functionality (and object-oriented paradigm as in LDL++ and Coral++).
Reference: [SHP88] <author> M. Stonebraker, M. Hanson, and S. Potamianos. </author> <title> The POSTGRES rule manager. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(7) </volume> <pages> 897-907, </pages> <month> Jul. </month> <year> 1988. </year>
Reference: [SKL89] <author> S. Y. W. Su, V. Krishnamurthy, and H. Lam. </author> <title> "An Object-Oriented Semantic Association Model (OSAM*)". </title> <booktitle> Theoretical Issues and Applications in Industrial Engineering and Manufacturing, </booktitle> <pages> pages 242-251, </pages> <year> 1989. </year>
Reference: [SR86] <author> M. Stonebraker and L. Rowe. </author> <title> The Design of POSTGRES. </title> <booktitle> In Proceedings of ACM-SIGMOD, </booktitle> <pages> pages 340-355, </pages> <year> 1986. </year>
Reference-contexts: Three basic approaches have been used for developing extensible query optimizers: the generator approach [GD87, Mck92], the building block approach [Bat88], and the modular approach <ref> [Loh88, M + 89, SR86] </ref>. Some approaches use rules for expressing transformations and user-definable cost estimates for the purpose of pruning the search space. Although conceptually it is useful to think of strategy space generation and search as separate problems, efficiency aspects of optimization dictate that they be considered together.
Reference: [Sto90] <author> M. Stonebraker. </author> <title> On rules,procedures,caching and views in database systems. </title> <booktitle> In proc. of the ACM SIGMOD, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: The input query is first modified using the compiled (intensional) database, and then optimized using conventional query optimization techniques. As 3 for recursive query processing in deductive database, numerous strategies have been proposed <ref> [BR86, LV89, Sto90, WF90] </ref>. In general,a recursive query is evaluated in the following way [BR86]: 1. Generate the intermediate result set, 2. Expand the set by evaluating the sentences within it, 3. Check the termination Condition at each step.
Reference: [VCJ] <author> Yannis Vassiliou, Jim Clifford, and Matthias Jarke. </author> <title> Data access requirements of knowledge -based systems. </title>
Reference-contexts: They also provide a theory that supports both declarative and procedural semantics. Logic programming, on the other hand, has concentrated on exploring efficient techniques for various classes of theories and queries. Various approaches (loosely coupled,tightly coupled, and integrated) have been proposed to combine deductive rules with relational systems <ref> [dMS88, Min88, VCJ, SHP87] </ref>. Efforts such as Megalog, LDL, RDL1 and LDL++, Coral have endeavored to integrate rule processing and traditional database functionality (and object-oriented paradigm as in LDL++ and Coral++).
Reference: [WBT92] <author> D. Wells, J. A. Blakeley, and C. W. Thompson. </author> <title> Architecture of an open object-oriented database management system. </title> <journal> IEEE Computer, </journal> <volume> 25(10), </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: The conceptual architecture of an optimizer that supports the above is shown in figure 2. The architecture presented in this paper is similar to the philosophy of open systems (e.g., Open OODB Toolkit of Texas Instruments, Dallas <ref> [WBT92] </ref>). Our approach to extensible query processor consisting of: an expert/intelligent coordinator, a set of domain experts each responsible for transforming a query using their domain specific expertise, and a global optimizer/assemble that integrates individual optimizations performed on the query or fine tunes the resulting query produced by the optimizer. <p> We are using the Open OODB Toolkit (Alpha release from texas Instruments, Dallas <ref> [WBT92] </ref>) as the underlying platform for this effort. We intend to concentrate on the open architecture and the issues mentioned above and plan on using available tools where possible.
Reference: [WCB91] <author> J. Widom, R. J. Cochrane, and . Lindsay B, G. </author> <title> Implemented Set-Oriented Production Rules as an Extension of Starburst. </title> <booktitle> In Proceedings 17th International Conference on Very Large Data Bases, </booktitle> <pages> pages 275-286, </pages> <address> Barcelona (Catalonia, Spain), </address> <month> Sep. </month> <year> 1991. </year>
Reference: [WF90] <author> J. Widom and S. Finkelstein. </author> <title> Set-Oriented Production Rules in Relational Database Systems. </title> <booktitle> In Proc. of ACM-SIGMOD, </booktitle> <pages> pages 259-270, </pages> <month> May </month> <year> 1990. </year> <month> 13 </month>
Reference-contexts: The input query is first modified using the compiled (intensional) database, and then optimized using conventional query optimization techniques. As 3 for recursive query processing in deductive database, numerous strategies have been proposed <ref> [BR86, LV89, Sto90, WF90] </ref>. In general,a recursive query is evaluated in the following way [BR86]: 1. Generate the intermediate result set, 2. Expand the set by evaluating the sentences within it, 3. Check the termination Condition at each step.
References-found: 53

