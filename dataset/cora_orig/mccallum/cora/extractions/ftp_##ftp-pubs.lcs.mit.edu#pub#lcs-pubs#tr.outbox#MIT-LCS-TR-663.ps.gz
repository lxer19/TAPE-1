URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-663.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr600.html
Root-URL: 
Title: Restricted Branching Programs and Hardware Verification  
Author: by Stephen John Ponzio 
Degree: Bachelor of Science in Electrical Engineering Bachelor of Science in Mathematics Master of Science in Electrical Engineering and Computer Science  (1991) Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Doctor of Philosophy in  All rights reserved. Signature of Author  Certified by Professor Mauricio Karchmer Thesis Supervisor Accepted by Frederic R. Morgenthaler Chairman, Departmental Committee on Graduate Students  
Date: August 1995  August 1995  
Affiliation: Massachusetts Institute of Technology  Computer Science and Mathematics at the MASSACHUSETTS INSTITUTE OF TECHNOLOGY  c Massachusetts Institute of Technology, 1995.  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [AM88] <author> N. Alon and W. Maass. </author> <title> Meanders and their applications in lower bounds arguments. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 37, </volume> <year> 1988, </year> <pages> pp. 118-129. </pages>
Reference-contexts: We will have more to say about these lower bounds in Sections 2.4.2, 2.5, and 2.6. Of course, all other lower bounds mentioned below for stronger models imply a fortiori equally strong lower bounds for OBDD's. Also, in a very different vein, Alon and Maass <ref> [AM88] </ref> prove lower bounds for arbitrary oblivious programs of linear length, which do not obey any restriction on the number of times a variable is read. Their lower bound is discussed in Section 2.5.3. <p> In similar spirit, Krause and Waack [KW91] show that any oblivious program of linear length for the problem of directed s-t connectivity requires exponential size; in [KMW92], similar lower bounds are proved for such programs with nondeterminism added. Using a lemma from <ref> [AM88] </ref>, and the communication complexity arguments outlined in Section 2.5.1, Gergov [Ge94] proves that computing MULT requires size 2 (n) for arbitrary oblivious programs of linear length, even with nondeterministic AND, OR, or PARITY nodes. 2.3.2 For read-once programs There has also been great success in proving lower bounds on the <p> Krause [Kr91, Remark 5.4] gives a different function which separates C-OBDD from READ-1. The separation READ-1 6 C-OBDD is subsumed by the following result: READ-1 6 OBLIV-LINEAR. This very strong separation is shown using the powerful technique of Alon and Maass <ref> [AM88] </ref>. They exhibit a function SEQ of 4n bits th at is easily in READ-1, but cannot be computed by any oblivious program of length O (n) (see Section 2.5.3). This result exhibits most strongly how severe a computational restriction obliviousness is. <p> of the variables, this may be exponentially less than the case of OR nodes: the function EQUAL?(x; y) with respect to the partition X _ [ Y requires nondeterministic complexity jxj = jyj whereas its complement has nondeterministic complexity 2 lg jxj. 2.5.3 For arbitrary oblivious programs Alon and Maass <ref> [AM88] </ref> prove strong lower bounds for arbitrary 3-way oblivious programs by analyzing the sequence S in which the variables are read by the levels of the program. <p> It follows that MULT requires exponential-size OBDD's and k-OBDD's even if OR, PARITY, or AND nodes are present. Gergov [Ge94] further generalizes Bryant's lower bound for MULT to arbitrary oblivious programs of linear length by using the main lemma from <ref> [AM88] </ref>. For any program of length kn, the lemma implies the existence of two "large" disjoint subsets of X (size n=k2 2k ) such that there are few (O (k)) levels where the program changes from reading variables of one set to reading variables of the other set.
Reference: [AGD91] <author> P. Ashar, A. Ghosh, and S. Devadas. </author> <title> Boolean satisfiability and equivalence checking using general binary decision diagrams. </title> <booktitle> Proc. Int'l. Conference on Computer Design, </booktitle> <year> 1991, </year> <pages> pp. 259-264. </pages>
Reference-contexts: ACH is easily seen to be in READ-1, but a standard lower bound argument shows ACH is not in k-OBDD for any constant k <ref> [AGD91, BSSW93] </ref>. Krause [Kr91, Remark 5.4] gives a different function which separates C-OBDD from READ-1. The separation READ-1 6 C-OBDD is subsumed by the following result: READ-1 6 OBLIV-LINEAR. This very strong separation is shown using the powerful technique of Alon and Maass [AM88].
Reference: [BHST87] <author> L. Babai, A. Hajnal, E. Szemeredi, and G. Turan. </author> <title> A lower bound for read-once branching programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> No. 37 (1988), </volume> <pages> pp. 153-162. </pages>
Reference-contexts: Note that none of these bounds is fully exponential, since the number of input variables, one for each edge, is n . Babai, Hajnal, Szemeredi and Turan <ref> [BHST87] </ref> proved an asymptotically optimal lower bound of 2 (n 2 ) for computing the parity of the number of triangles in a graph on n nodes; Simon and Szegedy [SS93] simplify and refine their analysis, improving the constant in the exponent. 2.3.3 For nondeterministic programs, read-once and read-k-times Exponential lower <p> This technique appears implicitly in the read-once lower bounds of [We88, Za84] and explicitly in those of [Ju88, Kr88, Du85]; the generalization in [SS93] enables an easier proof of the lower bound of <ref> [BHST87] </ref> and others [We87, Du85, Ju88]. Simon and Szegedy use this technique to reprove a theorem of Babai et. al. [BHST87], that read-once programs require size 2 (n 2 ) to count modulo 2 the number of triangles in an n-node graph. <p> implicitly in the read-once lower bounds of [We88, Za84] and explicitly in those of [Ju88, Kr88, Du85]; the generalization in [SS93] enables an easier proof of the lower bound of <ref> [BHST87] </ref> and others [We87, Du85, Ju88]. Simon and Szegedy use this technique to reprove a theorem of Babai et. al. [BHST87], that read-once programs require size 2 (n 2 ) to count modulo 2 the number of triangles in an n-node graph. They also give a simple proof that size 2 n=10 is required to tell whether an n-node graph is n 2 -regular. <p> It is curious that many of the lower bounds for read-once programs achieve only 2 ( p n is the number of input bits|only the lower bound of <ref> [BHST87] </ref> achieves a fully exponential lower bound of 2 (n) . This limitation is most likely an artifact of the proofs, but it is not well understood.
Reference: [BNS92] <author> L. Babai, N. Nisan, and M. Szegedy. </author> <title> Multiparty protocols, pseudorandom generators for logspace, and time-space tradeoffs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 45 (1992), </volume> <pages> pp. 204-232. </pages>
Reference-contexts: At the same time, a simple co-nondeterministic oblivious program (with AND nodes) of linear length is given, showing that as for read-once programs (Section 2.2.2), the two types of nondeterminism give different computational power. Babai, Nisan, and Szegedy <ref> [BNS92] </ref> in the same spirit improve this length/width tradeoff, using their lower bound for multiparty communication complexity to raise the lower bound on the length of polynomial-size oblivious programs (for a different function) by a factor of lg n. 2.5.4 For read-once programs Note first that the lower bound method for
Reference: [BCW80] <author> M. Blum, A. Chandra, and M. Wegman. </author> <title> Equivalence of free boolean graphs can be decided probabilistically in polynomial time. </title> <journal> Information Processing Letters, </journal> <volume> Vol. 10, No. 2, </volume> <month> March </month> <year> 1980, </year> <pages> pp. 80-82. </pages>
Reference-contexts: Also, testing equivalence is reasonably tractable: although it is not known how to do so in deterministic polynomial time, there is a randomized polynomial-time algorithm with one-sided error due to Blum, Chandra, and Wegman <ref> [BCW80] </ref>. The synthesis operations, however, are provably not tractable: there exist functions f and g that each have polynomial-size read-once programs but whose conjunction f ^ g requires exponential x1.2 Restricted branching programs 13 size read-once programs. <p> It is not known how to determine the equivalence of two read-once programs in polynomial time. Blum, Chandra, and Wegman <ref> [BCW80] </ref> give a co-RP algorithm (that is, it may say "equivalent" when in fact the programs are not, but never vice versa) which relies on randomly assigning to the literals values from a finite field and then computing the value of the DNF polynomial of the function. 20 Related models 2.2.2 <p> The case of OR nodes is trivially as least as hard as determining the satisfiability of a deterministic read-once program, which is not known to be in P. In the case of PARITY nodes, the algorithm of <ref> [BCW80] </ref> works as long as the field used has characteristic 2 [SDG94]. In [SDG94], simple but very restrictive conditions on the use of AND and OR gates are given so that the correctness of the algorithm of [BCW80] is retained. 2.2.3 k-OBDD's By restricting the order to be the same permutation <p> In the case of PARITY nodes, the algorithm of <ref> [BCW80] </ref> works as long as the field used has characteristic 2 [SDG94]. In [SDG94], simple but very restrictive conditions on the use of AND and OR gates are given so that the correctness of the algorithm of [BCW80] is retained. 2.2.3 k-OBDD's By restricting the order to be the same permutation repeated k times, we retain the property that two programs with obeying the same ordering are easily combined|the usual product construction works as before for OBDD's. k-OBDD's are also testable for satisfiability though with a little more
Reference: [BSSW93] <author> B. Bollig, M. Sauerhoff, D. Sieling, and I. Wegener. </author> <title> Read-k-times ordered binary decision diagrams|efficient algorithms in the presence of null chains. </title> <type> Technical Report 474, </type> <institution> Univ. Dortmund, </institution> <year> 1993. </year> <note> 71 72 Bibliography </note>
Reference-contexts: are proved for nondeterministic programs in which each path obeys a bound on the number of alternations between sets of variables. 2.1.1 Reading each variable k times There are essentially three models of branching programs in which each variable may be read multiple times: 1. k-OBDD's (also known as k-BDD's <ref> [BSSW93] </ref>). On each path the variables appear at most k times each in an order that is the same permutation repeated k times. 2. k-IBDD's. On each path the variables appear at most k times each in an order that is the concatenation of k (possibly different) permutations. 3. <p> Thus, to determine whether the k-OBDD is satisfiable, we sequentially check whether any of these sequences is traversable. Other operations on k-OBDD's are considered in detail in <ref> [BSSW93] </ref>. 2.2.4 k-IBDD's and read-k-times programs Unlike for k-OBDD's, testing the satisfiability of even 2-IBDD's, and hence read-2-times programs, is NP-complete. <p> HWB is computable in READ-1 by a clever algorithm that works its way in from the outermost bits of x; it is also easily computed in 2-OBDD. A standard lower bound argument shows that HWB 62 OBDD ([Br91], see Section 2.5.1). Also, it is shown in [BHR95] (see also <ref> [BSSW93] </ref>) that ISA 62 OBDD, where ISA (x; y) : f0; 1g fi f0; 1g ! f0; 1g is the "Indirect-Storage-Access" function which returns x i , where i is the integer represented by the y'th block of lg n bits of x if 0 y &lt; n= lg n, and <p> In the other direction, we have READ-1 6 C-OBDD. In <ref> [BSSW93] </ref>, an exponential lower bound is proved for the size of k-OBDD's for the function ACH ("Achilles-Heel"), defined on 2n + lg n Boolean variables as ACH (x 0 ; : : : ; x n1 ; y 0 ; : : : ; y n1 ; z 1 ; : <p> ACH is easily seen to be in READ-1, but a standard lower bound argument shows ACH is not in k-OBDD for any constant k <ref> [AGD91, BSSW93] </ref>. Krause [Kr91, Remark 5.4] gives a different function which separates C-OBDD from READ-1. The separation READ-1 6 C-OBDD is subsumed by the following result: READ-1 6 OBLIV-LINEAR. This very strong separation is shown using the powerful technique of Alon and Maass [AM88]. <p> For completeness as well as for demonstration, we supply a proof of Theorem 1, announced in [Kr91] without proof, and also prove Theorem 2, extending in a simple way the result of <ref> [BSSW93] </ref>. We compare these methods with lower bounds for non-oblivious programs, but defer a detailed description of the latter until the presentation of our own lower bound in Chapter 3. <p> To demonstrate, we give an easy lower bound which has not appeared in the literature. The proof is very similar to the lower bounds of [BSSW95] and [Ge94]. Recall x2.5 Lower bound techniques 33 that <ref> [BSSW93] </ref> showed ACH 62 C-OBDD; we will show that ACH 62 C-IBDD. Theorem 2 ACH 62 C-IBDD. Proof: Consider a k-IBDD G computing ACH. We will show that G has size at least 2 n=k2 k .
Reference: [BSSW95] <author> B. Bollig, M. Sauerhoff, D. Sieling, and I. Wegener. </author> <title> On the power of different types of restricted branching programs. </title> <note> Submitted to Theoretical Computer Science. Also published in the Electronic Colloquium on Computational Complexity, Report No. TR94-026 (1994), available via http://www.eccc.uni-trier.de/eccc/. </note>
Reference-contexts: C-OBDD C-IBDD OBLIV-LINEAR: The results presented in this section are summarized in Figure 2.1, which gives the inclusion relations of these various classes. 2.4.1 Hierarchies in k It is known that the hierarchy over k of functions computable by k-OBDD's of polynomial size is strict: k-OBDD ( (k + 1)-OBDD <ref> [BSSW95] </ref>. For the case k = 1, we may refer to the function HWB, described below, which is in 2-OBDD but not OBDD. For k-IBDD's the hierarchy is also strict: k-IBDD ( (k + 1)-IBDD [BSSW95]. <p> of functions computable by k-OBDD's of polynomial size is strict: k-OBDD ( (k + 1)-OBDD <ref> [BSSW95] </ref>. For the case k = 1, we may refer to the function HWB, described below, which is in 2-OBDD but not OBDD. For k-IBDD's the hierarchy is also strict: k-IBDD ( (k + 1)-IBDD [BSSW95]. These lower bounds are based on the well-known "rounds hierarchy" for communication complexity exhibited by the "k-pointer-chasing" function, k-PTR, on bipartite graphs [PS82, DGS84, Mc86, HR88, NW91] (in particular the result of [NW91]). <p> Accept only if in each segment, each of the i rows is found to contain exactly one 1. For k-IBDD's The only lower bound that is proved specifically for IBDD's (i.e., which does not apply to linear length oblivious programs more generally) is the lower bound of <ref> [BSSW95] </ref>. They reduce the problem to one of communication complexity in the following manner. Given an IBDD, they construct two disjoint subsets of the variables by considering the levels of the IBDD one at a time. <p> To demonstrate, we give an easy lower bound which has not appeared in the literature. The proof is very similar to the lower bounds of <ref> [BSSW95] </ref> and [Ge94]. Recall x2.5 Lower bound techniques 33 that [BSSW93] showed ACH 62 C-OBDD; we will show that ACH 62 C-IBDD. Theorem 2 ACH 62 C-IBDD. Proof: Consider a k-IBDD G computing ACH. We will show that G has size at least 2 n=k2 k .
Reference: [BW95] <author> B. Bollig and I. Wegener. </author> <title> Improving the variable ordering of OBDD's is NP-complete. Dagstuhl Seminar on Computer-Aided Design and Testing, Febru-ary 1995. Available via http://www.informatik.uni-trier.de:80/ Design and Test/, </title> <institution> FB Informatik, LS II, Univ. </institution> <address> Dortmund, 44221 Dortmund, Germany. </address>
Reference-contexts: The decision problem is: Given an OBDD and an integer k, determine whether there is an OBDD (possibly obeying a different ordering of the variables) with fewer than k nodes that computes the same function. This problem was recently proved to be NP-complete in <ref> [BW95] </ref>, extending the work of [BW95, THY93], via a nice reduction to OPTIMAL-LINEAR-ARRANGEMENT [GJ79]. It would be useful to find an efficient algorithm to determine an approximately optimal ordering. Many heuristics for improving an ordering can be found in the literature (see [BW95]). <p> The decision problem is: Given an OBDD and an integer k, determine whether there is an OBDD (possibly obeying a different ordering of the variables) with fewer than k nodes that computes the same function. This problem was recently proved to be NP-complete in [BW95], extending the work of <ref> [BW95, THY93] </ref>, via a nice reduction to OPTIMAL-LINEAR-ARRANGEMENT [GJ79]. It would be useful to find an efficient algorithm to determine an approximately optimal ordering. Many heuristics for improving an ordering can be found in the literature (see [BW95]). <p> problem was recently proved to be NP-complete in <ref> [BW95] </ref>, extending the work of [BW95, THY93], via a nice reduction to OPTIMAL-LINEAR-ARRANGEMENT [GJ79]. It would be useful to find an efficient algorithm to determine an approximately optimal ordering. Many heuristics for improving an ordering can be found in the literature (see [BW95]). It is worth mentioning that the use of randomization has not been explored, either in helping to determine good variable orderings or in the verification strategy more generally. 2.7.2 The Fourier spectrum The Fourier spectrum of Boolean functions has been widely studied over the past few years.
Reference: [BRS93] <author> A. Borodin, A. Razborov, and R. Smolensky. </author> <title> On lower bounds for read-k-times branching programs. Computational Complexity, </title> <type> 3, </type> <year> 1993, </year> <pages> pp. 1-18. </pages>
Reference-contexts: Defining nondeterminism in this manner immediately gives (nonuniform) NP for polynomial-size programs, since NP is characterized by polynomial-size nondeterministic formulas. We mention that Borodin, Razborov and Smolensky <ref> [BRS93] </ref> use a different definition of nondeterminism: Nodes are unlabeled and each edge is either unlabeled or labeled with a variable and a value. <p> There is another model of nondeterministic branching programs, called rectifier-and-switching networks, which is preferred by Razborov because of the combinatorial characterization its size measure affords (see [Ra91, Ra90]). A rectifier-and-switching network is essentially a nondeterministic branching program as <ref> [BRS93] </ref> defines them, except that the (directed) graph may contain cycles. There is no "rejecting sink" and the program accepts exactly when there exists at least one path from the source to the (accepting) sink. The measure of size is the number of labeled edges. <p> At most E copies are needed since any path contains at most E edges and an extra copy of the graph is needed only for each back edge in the path. Thus at a cost of squaring the size, we obtain a nondeterministic program in the sense of <ref> [BRS93] </ref>. <p> Krause, Meinel, and Waack [KMW91] (see also [Ju89]) give a lower bound of n!= n 2 = 2 (n) for the function -MATRIX. (It was known earlier that this function required exponential-size deterministic read-once programs; see [Kr91, p. 10] and [Ju86].) Also, Borodin, Razborov and Smolensky <ref> [BRS93] </ref> prove a lower bound of 2 (n) for the functions n 2 CLIQUE and n 2 CLIQUE-ONLY. Note that the complement of n 2 CLIQUE-ONLY can be computed by nondeterministic read-once programs of polynomial size. <p> Note that the complement of n 2 CLIQUE-ONLY can be computed by nondeterministic read-once programs of polynomial size. Okolnishnikova [Ok91] proves that computing the characteristic function of the Bose-Chaudhuri codes requires deterministic read-k-times programs of size exponential in ( n=k k ). Borodin et. al. <ref> [BRS93] </ref> exhibit for any k, a function that requires nondeterministic read-k-times programs of size exponential in (n=k4 k ). Jukna [Ju92] extends the results of [BRS93] and [Ok91] to show that the function from [Ok91] requires nondeterministic read-k-times programs of size exponential in ( p n=k 2k ) even though its <p> Borodin et. al. <ref> [BRS93] </ref> exhibit for any k, a function that requires nondeterministic read-k-times programs of size exponential in (n=k4 k ). Jukna [Ju92] extends the results of [BRS93] and [Ok91] to show that the function from [Ok91] requires nondeterministic read-k-times programs of size exponential in ( p n=k 2k ) even though its complement can be computed by nondeterministic read-once programs of polynomial size. <p> We compare these methods with lower bounds for non-oblivious programs, but defer a detailed description of the latter until the presentation of our own lower bound in Chapter 3. The technique of <ref> [BRS93] </ref> for proving lower bound for read-k-times programs will bemention only briefly in Chapter 4, when we outline approaches to some open problems. 2.5.1 For OBDD's, k-OBDD's, and k-IBDD's Lower bounds for OBDD's follow a simple strategy: Show that for any Y X of some fixed size (say m = m <p> Since we can test the satisfiability of a read-once program in polynomial time, the entire procedure can be executed in polynomial time. Jukna [Ju94] proves a lower bound of 2 n 1=4 =k 2k for DMULT on non-deterministic read-k-times branching programs. His lower bound follows the framework of <ref> [BRS93] </ref>, and gives a simple reduction of DMULT to the problem of recognizing codewords of a linear code, for which a lower bound of 2 p is proved in [Ju92]. 2.7 Related issues 2.7.1 The ordering problem for OBDD's When using OBDD's for verification, it is naturally desired to minimize their <p> Here is a possible strategy for showing it is not computable 68 Discussion and further work with polynomial-size read-2-times programs. According to Theorem 1 in <ref> [BRS93] </ref>, a read-2-times program for -CUBE enables us to express the function as -CUBE = poly (BP size) _ i=1 where each X ij is a subset of half the n 3 variables and each variable appears in at most two of X i1 ; X i2 ; X i3 ;
Reference: [BHR95] <author> Y. Breitbart, H. B. Hunt III and D. Rosenkrantz. </author> <title> On the size of binary decision diagrams representing Boolean functions. </title> <booktitle> Theoretical Computer Science, 145 (1995), </booktitle> <pages> pp. 45-69. </pages>
Reference-contexts: HWB is computable in READ-1 by a clever algorithm that works its way in from the outermost bits of x; it is also easily computed in 2-OBDD. A standard lower bound argument shows that HWB 62 OBDD ([Br91], see Section 2.5.1). Also, it is shown in <ref> [BHR95] </ref> (see also [BSSW93]) that ISA 62 OBDD, where ISA (x; y) : f0; 1g fi f0; 1g ! f0; 1g is the "Indirect-Storage-Access" function which returns x i , where i is the integer represented by the y'th block of lg n bits of x if 0 y &lt; n= <p> MHWB has a natural read-twice algorithm where the variables may be read in order each time, so MHWB 2 2-OBDD. In <ref> [BHR95] </ref>, it is shown that MHWB 62 READ-1.
Reference: [BF85] <author> F. Brglez and H. Fujiwara. </author> <title> A neutral netlist of 10 combinational circuits. </title> <booktitle> Proc. 1985 IEEE Int'l. Symposium on Circuits and Systems. </booktitle>
Reference: [BS90] <author> J. Bruck and R. Smolensky. </author> <title> Polynomial threshold functions, AC 0 functions and spectral norms. </title> <booktitle> Proceedings of the 31st Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1990, </year> <pages> pp. 632-641. </pages>
Reference-contexts: Since OBDD's are such a constrained model of computation, perhaps interesting and useful properties can be derived about the spectrum of the functions in OBDD they compute. Some negative results are known: Bruck and Smolensky <ref> [BS90] </ref> demonstrate 42 Related models a function in AC 0 that has exponential L 1 -norm; this function is easily computed by polynomial-size OBDD's.
Reference: [Br91] <author> R. Bryant. </author> <title> On the complexity of VLSI implementations and graph representations of boolean functions with applications to integer multiplication. </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 40, No. 2, </volume> <month> February </month> <year> 1991. </year> <pages> pp. 205-213. </pages>
Reference-contexts: The answer is yes, for the most part|OBDD's can compute in polynomial size such functions as integer addition, symmetric Boolean functions, and many of the benchmark functions used by the verification community [BF85]|but with a very important exception: exponential size is required to compute integer multiplication <ref> [Br91] </ref>. This is an serious setback to the viability of OBDD's, since the hardware to be tested typically contains circuits that perform multiplication. <p> If the program has w nodes at the level immediately following the nodes of Y , then the message has lg w bits. Thus, if the one-way communication complexity is linear for every Y of size m, then the function requires OBDD's of exponential size. Bryant <ref> [Br91] </ref> uses a simple argument of this form to prove that HWB requires exponential-size OBDD's. Commonly, it is proved that in fact the unlimited-round, two-way communication complexity of the function is linear for any Y of size m. <p> The middle bit is the "hardest" bit, in the sense that if it can be computed by read-once branching programs (or most any computational model) of size s (n), then any other bit can be computed with size at most s (2n). 2.6.1 Bryant's lower bound Bryant <ref> [Br91] </ref> gives the following lower bound for MULT; Gergov [Ge94] notices that the proof holds also for nondeterministic OBDD's, as noted the end of the proof below. 38 Related models Theorem 3 MULT 62 OBDD.
Reference: [Br92] <author> R. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 24, No. 3, </volume> <month> September </month> <year> 1992. </year> <pages> pp. 293-318. </pages>
Reference-contexts: The central problem of verification is to check whether a combinational hardware circuit has been correctly designed. One approach commonly employed today is to convert independently the circuit description and the function specification to a common intermediate representation and then test whether the two representations are equivalent (e.g., <ref> [Br92, We94] </ref>). The use of restricted forms of branching programs for the intermediate representation has made this approach feasible and very popular| several software packages are available for implementing this very strategy [Kr94, Br92]. <p> The use of restricted forms of branching programs for the intermediate representation has made this approach feasible and very popular| several software packages are available for implementing this very strategy <ref> [Kr94, Br92] </ref>. This application raises several issues of computational complexity, renewing interest in the low-level complexity of branching programs.
Reference: [BC94] <author> Randal Bryant and Yirng-An Chen. </author> <title> Verification of arithmetic functions with binary moment diagrams. </title> <type> Technical Report CMU-CS-94-160, </type> <institution> Carnegie Mel-lon University, </institution> <month> May 31, </month> <year> 1994. </year> <note> Bibliography 73 </note>
Reference-contexts: Two recently proposed models, which we shall not consider here, are "graph-driven BDD's" [SW95] and "binary moment diagrams" <ref> [BC94] </ref>. The latter are not branching programs, and do not compute a function, but they do allow polynomial-size representation of multiplication. Also, in [S95] lower bounds are proved on branching programs in which for each path, the number of variables appearing more than once is bounded by k.
Reference: [Bu92] <author> S. Buss. </author> <title> The graph of multiplication is equivalent to counting. </title> <journal> Information Processing Letters, </journal> <month> 41 (18 March </month> <year> 1992), </year> <pages> pp. 199-201. </pages>
Reference-contexts: Note that it is not readily apparent which problem is "harder", MULT or DMULT. On the one hand, DMULT seems to require practically computing all the bits of xy; however, an algorithm for DMULT has the advantage of inspecting all the bits of z, the putative product. Buss <ref> [Bu92] </ref> proves that DMULT 62 AC 0 by reducing it to counting the number of 1's in the input (and therefore to MULT and to PARITY by results of [CSV84]); for comparison, [FSS84] gives an easy reduction of MULT to PARITY to show MULT 62 AC 0 .
Reference: [CSV84] <author> A. Chandra, L. Stockmeyer, and U. Vishkin. </author> <title> Constant depth reducibility. </title> <journal> SIAM Journal of Computing, </journal> <volume> 13 (1984), </volume> <pages> pp. 423-439. </pages>
Reference-contexts: Buss [Bu92] proves that DMULT 62 AC 0 by reducing it to counting the number of 1's in the input (and therefore to MULT and to PARITY by results of <ref> [CSV84] </ref>); for comparison, [FSS84] gives an easy reduction of MULT to PARITY to show MULT 62 AC 0 . A simple argument [We94] shows that computing DMULT with read-once programs is as hard as factoring. <p> In order to preserve read-once complexity, we will consider a very restrictive type of problem reduction. We begin with the notion of projection reductions [SV81], as defined in <ref> [CSV84] </ref>: Definition 5 A function f = ff n g n2N is projection reducible to a function g = fg n g n2N , written f proj g, if there is a mapping : fy 1 ; : : : ; y p (n) g ! f0; 1; x 1 ; <p> These reductions were used by Chandra, Stockmeyer, and Vishkin <ref> [CSV84] </ref> in their study of constant-depth reducibility|clearly, given that f proj g, if g 2 AC 0 then f 2 AC 0 . We would like a reduction 0 that allows us to deduce that if f 0 g and g 2 READ-1 then f 2 READ-1.
Reference: [CS88] <author> V. Chvatal and E. Szemeredi. </author> <title> Many hard examples for resolution. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 35, No. </volume> <month> 4 (October </month> <year> 1988), </year> <pages> pp. 759-768. </pages>
Reference-contexts: problem and RRES () is the fewest number of steps in a regular resolution proof of . x2.7 Related issues 43 In general, an arbitrary resolution proof for yields a branching program for this search problem, but not vice-versa: in fact, there are formulas for which RES () is exponential <ref> [CS88, e.g.] </ref>, even though there is always a branching program of size O (jj) for the search problem. 44 Related models C h a p t e r 3 A lower bound for multiplication with read-once programs This chapter describes a lower bound of 2 ( p n) on the size
Reference: [Du85] <author> P. E. Dunne. </author> <title> Lower bounds on the complexity of 1-time only branching programs. </title> <booktitle> Proceedings of the FCT, </booktitle> <publisher> Springer-Verlag LNCS No. </publisher> <month> 199 </month> <year> (1985), </year> <pages> pp. 90-99. </pages>
Reference-contexts: n nodes contains a clique of size n=2, and also for the function n 2 CLIQUE-ONLY, of determining whether a graph on n nodes contains an n=2-clique and no further edges. (For comparison, there is a simple read-twice program for n 2 CLIQUE-ONLY of size O (n 3 ).) Dunne <ref> [Du85] </ref> proved a lower bound of 2 (n) for the problems of determining whether a graph on n nodes contains a hamiltonian cycle and determining whether it contains a perfect matching. <p> Simon and Szegedy [SS93] distill this idea into a lemma which may be considered a paradigm for proving read-once lower bounds. This technique appears implicitly in the read-once lower bounds of [We88, Za84] and explicitly in those of <ref> [Ju88, Kr88, Du85] </ref>; the generalization in [SS93] enables an easier proof of the lower bound of [BHST87] and others [We87, Du85, Ju88]. <p> This technique appears implicitly in the read-once lower bounds of [We88, Za84] and explicitly in those of [Ju88, Kr88, Du85]; the generalization in [SS93] enables an easier proof of the lower bound of [BHST87] and others <ref> [We87, Du85, Ju88] </ref>. Simon and Szegedy use this technique to reprove a theorem of Babai et. al. [BHST87], that read-once programs require size 2 (n 2 ) to count modulo 2 the number of triangles in an n-node graph.
Reference: [DGS84] <author> P. Duris, Z. Galil, and G. Schnitger. </author> <title> Lower bounds of communication complexity. </title> <booktitle> Proceedings of the 16th ACM Symposium on Theory of Computing, </booktitle> <year> (1984), </year> <pages> pp. 81-91. </pages>
Reference-contexts: For k-IBDD's the hierarchy is also strict: k-IBDD ( (k + 1)-IBDD [BSSW95]. These lower bounds are based on the well-known "rounds hierarchy" for communication complexity exhibited by the "k-pointer-chasing" function, k-PTR, on bipartite graphs <ref> [PS82, DGS84, Mc86, HR88, NW91] </ref> (in particular the result of [NW91]).
Reference: [FHS78] <author> S. Fortune, J. Hopcroft, and E. M. Schmidt. </author> <title> The complexity of equivalence and containment for free single variable program schemes. </title> <publisher> Springer-Verlag LNCS No. </publisher> <address> 62, </address> <year> 1978, </year> <pages> pp. 227-240. </pages>
Reference-contexts: There is a polynomial-time algorithm due to Fortune, Hopcroft, and Schmidt <ref> [FHS78] </ref> for testing whether an OBDD is equivalent to a read-once program, which can be used in this case. 2.2.1 Read-once programs Read-once programs do not enjoy quite the same degree of manipulability as their oblivious version, OBDD's. <p> Further work There are many open questions surrounding the topics of this thesis, some of which have already been mentioned. We will describe some of these problems that we consider to be the most important, interesting, or tractable. The oldest of these problems, open since <ref> [FHS78] </ref>, is 65 66 Discussion and further work Open Question 1 Is there a deterministic polynomial-time algorithm for determining the equivalence of two read-once programs? The answer to this question loses some practical significance in light of the lower bound for multiplication and the intractability of the synthesis operations, which make
Reference: [FSS84] <author> M. Furst, J. B. Saxe, and M. Sipser. </author> <title> Parity, circuits, and the polynomial-time hierarchy. </title> <journal> Mathematical Systems Theory, </journal> <volume> 17 (1984), </volume> <pages> pp. 13-27. </pages>
Reference-contexts: Buss [Bu92] proves that DMULT 62 AC 0 by reducing it to counting the number of 1's in the input (and therefore to MULT and to PARITY by results of [CSV84]); for comparison, <ref> [FSS84] </ref> gives an easy reduction of MULT to PARITY to show MULT 62 AC 0 . A simple argument [We94] shows that computing DMULT with read-once programs is as hard as factoring. <p> It was originally proved in [HMPST93] that INNER-PRODUCT-MODULO-2 cannot be computed in polynomial-size by threshold circuits of depth 2. It was also noted there that the projection reduction to multiplication (first given in <ref> [FSS84] </ref>, from PARITY to MULT) shows that MULT obeys the same lower bound. Wegener [We93] gives projection reductions from MULT to squaring and inversion in order to show that these functions also require depth 3 polynomial-size threshold circuits.
Reference: [GJ79] <author> M. Garey and D. Johnson. </author> <title> Computers and Intractability. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York. </address> <year> 1979. </year>
Reference-contexts: This problem was recently proved to be NP-complete in [BW95], extending the work of [BW95, THY93], via a nice reduction to OPTIMAL-LINEAR-ARRANGEMENT <ref> [GJ79] </ref>. It would be useful to find an efficient algorithm to determine an approximately optimal ordering. Many heuristics for improving an ordering can be found in the literature (see [BW95]).
Reference: [Ge94] <author> J. Gergov. </author> <title> Time-space tradeoffs for integer multiplication on various types of input-oblivious sequential machines. </title> <journal> Information Processing Letters, </journal> <volume> 51 (1994), </volume> <pages> pp. 265-269. </pages>
Reference-contexts: Using a lemma from [AM88], and the communication complexity arguments outlined in Section 2.5.1, Gergov <ref> [Ge94] </ref> proves that computing MULT requires size 2 (n) for arbitrary oblivious programs of linear length, even with nondeterministic AND, OR, or PARITY nodes. 2.3.2 For read-once programs There has also been great success in proving lower bounds on the size of read-once programs. <p> To demonstrate, we give an easy lower bound which has not appeared in the literature. The proof is very similar to the lower bounds of [BSSW95] and <ref> [Ge94] </ref>. Recall x2.5 Lower bound techniques 33 that [BSSW93] showed ACH 62 C-OBDD; we will show that ACH 62 C-IBDD. Theorem 2 ACH 62 C-IBDD. Proof: Consider a k-IBDD G computing ACH. We will show that G has size at least 2 n=k2 k . <p> bit, in the sense that if it can be computed by read-once branching programs (or most any computational model) of size s (n), then any other bit can be computed with size at most s (2n). 2.6.1 Bryant's lower bound Bryant [Br91] gives the following lower bound for MULT; Gergov <ref> [Ge94] </ref> notices that the proof holds also for nondeterministic OBDD's, as noted the end of the proof below. 38 Related models Theorem 3 MULT 62 OBDD. <p> It thus has full rank over B and over GF (2), and so does its complement. It follows that MULT requires exponential-size OBDD's and k-OBDD's even if OR, PARITY, or AND nodes are present. Gergov <ref> [Ge94] </ref> further generalizes Bryant's lower bound for MULT to arbitrary oblivious programs of linear length by using the main lemma from [AM88].
Reference: [GM94] <author> J. Gergov and C. Meinel. </author> <title> Efficient boolean manipulations with OBDD's can be extended to FBDD's. </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 43, No. 10, </volume> <month> (October </month> <year> 1994), </year> <pages> pp. 1197-1209. </pages>
Reference-contexts: Despite their relative recalcitrance, read-once programs have been considered by some researchers for possible use in hardware verification <ref> [GM94] </ref>. Until now, however, very little was known about the complexity of multiplication with any non-oblivious programs. In this thesis, we prove that multiplication requires (non-oblivious) read-once branching programs of size 2 ( p n) . This is the first superpolynomial lower bound for multiplication on non-oblivious branching programs.
Reference: [HMPST93] <author> A. Hajnal, W. Maass, P. Pudlak, M. Szegedy, and G. Turan. </author> <title> Threshold circuits of bounded depth. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 46(2) 1993, </volume> <pages> pp. 129-154. 74 Bibliography </pages>
Reference-contexts: It was originally proved in <ref> [HMPST93] </ref> that INNER-PRODUCT-MODULO-2 cannot be computed in polynomial-size by threshold circuits of depth 2. It was also noted there that the projection reduction to multiplication (first given in [FSS84], from PARITY to MULT) shows that MULT obeys the same lower bound.
Reference: [HR88] <author> B. Halstenberg and R. Reischuk. </author> <title> On different modes of communication. </title> <booktitle> Proceedings of the 20th ACM Symposium on Theory of Computing (1988), </booktitle> <pages> pp. 162-172. </pages>
Reference-contexts: For k-IBDD's the hierarchy is also strict: k-IBDD ( (k + 1)-IBDD [BSSW95]. These lower bounds are based on the well-known "rounds hierarchy" for communication complexity exhibited by the "k-pointer-chasing" function, k-PTR, on bipartite graphs <ref> [PS82, DGS84, Mc86, HR88, NW91] </ref> (in particular the result of [NW91]).
Reference: [Im88] <author> N. Immerman. </author> <title> Nondeterministic space is closed under complementation. </title> <journal> SIAM Journal of Computing, </journal> <volume> Vol. 17, No. </volume> <month> 5 (October </month> <year> 1988), </year> <pages> pp. 935-938. </pages>
Reference-contexts: Meinel [Me89] explores the range of all possibilities and concludes that allowing nodes of other binary Boolean functions does not give classes different from L, NL, P, or L. 1 It is easy to see that the proof of <ref> [Im88] </ref> yields the same result in the non-uniform case: Given a polynomial-size branching program with OR nodes, that proof constructs another polynomial-size branching program with OR nodes that accepts exactly when the original program rejects.
Reference: [JABFA92] <author> J. Jain, M. Abadir, J. Bitner, D. Fussell, and J. Abraham. IBDD's: </author> <title> An efficient functional representation for digital circuits. </title> <booktitle> European Design Automation Conference (1992), </booktitle> <pages> pp. 440-446. </pages>
Reference: [Ju86] <author> S. Jukna. </author> <title> Lower bounds on the complexity of local circuits. </title> <booktitle> Proceedings of the MFCS, </booktitle> <publisher> Springer-Verlag LNCS 233 (1986), </publisher> <pages> pp. 440-448. </pages>
Reference-contexts: Krause, Meinel, and Waack [KMW91] (see also [Ju89]) give a lower bound of n!= n 2 = 2 (n) for the function -MATRIX. (It was known earlier that this function required exponential-size deterministic read-once programs; see [Kr91, p. 10] and <ref> [Ju86] </ref>.) Also, Borodin, Razborov and Smolensky [BRS93] prove a lower bound of 2 (n) for the functions n 2 CLIQUE and n 2 CLIQUE-ONLY. Note that the complement of n 2 CLIQUE-ONLY can be computed by nondeterministic read-once programs of polynomial size.
Reference: [Ju88] <author> S. Jukna. </author> <title> Entropy of contact circuits and lower bounds on their complexity. </title> <booktitle> Theoretical Computer Science, 47:2 (1988), </booktitle> <pages> pp. 113-129. </pages>
Reference-contexts: Simon and Szegedy [SS93] distill this idea into a lemma which may be considered a paradigm for proving read-once lower bounds. This technique appears implicitly in the read-once lower bounds of [We88, Za84] and explicitly in those of <ref> [Ju88, Kr88, Du85] </ref>; the generalization in [SS93] enables an easier proof of the lower bound of [BHST87] and others [We87, Du85, Ju88]. <p> This technique appears implicitly in the read-once lower bounds of [We88, Za84] and explicitly in those of [Ju88, Kr88, Du85]; the generalization in [SS93] enables an easier proof of the lower bound of [BHST87] and others <ref> [We87, Du85, Ju88] </ref>. Simon and Szegedy use this technique to reprove a theorem of Babai et. al. [BHST87], that read-once programs require size 2 (n 2 ) to count modulo 2 the number of triangles in an n-node graph.
Reference: [Ju89] <author> S. Jukna. </author> <title> The effect of null-chains on the complexity of contact schemes. </title> <booktitle> Proceedings of the FCT (1989), </booktitle> <publisher> Springer-Verlag LNCS No. </publisher> <pages> 380, pp. 246-256. </pages>
Reference-contexts: Krause, Meinel, and Waack [KMW91] (see also <ref> [Ju89] </ref>) give a lower bound of n!= n 2 = 2 (n) for the function -MATRIX. (It was known earlier that this function required exponential-size deterministic read-once programs; see [Kr91, p. 10] and [Ju86].) Also, Borodin, Razborov and Smolensky [BRS93] prove a lower bound of 2 (n) for the functions n
Reference: [Ju92] <author> S. Jukna. </author> <title> A note on read-k-times branching programs. </title> <type> Technical report 448, </type> <institution> Universitat Dortmund, </institution> <year> 1992. </year> <note> RAIRO Theoretical Computer Science, to appear. Also published in the Electronic Colloquium on Computational Complexity, Report No. TR94-027 (1994), available via http://www.eccc.uni-trier.de/eccc/. </note>
Reference-contexts: Okolnishnikova [Ok91] proves that computing the characteristic function of the Bose-Chaudhuri codes requires deterministic read-k-times programs of size exponential in ( n=k k ). Borodin et. al. [BRS93] exhibit for any k, a function that requires nondeterministic read-k-times programs of size exponential in (n=k4 k ). Jukna <ref> [Ju92] </ref> extends the results of [BRS93] and [Ok91] to show that the function from [Ok91] requires nondeterministic read-k-times programs of size exponential in ( p n=k 2k ) even though its complement can be computed by nondeterministic read-once programs of polynomial size. <p> His lower bound follows the framework of [BRS93], and gives a simple reduction of DMULT to the problem of recognizing codewords of a linear code, for which a lower bound of 2 p is proved in <ref> [Ju92] </ref>. 2.7 Related issues 2.7.1 The ordering problem for OBDD's When using OBDD's for verification, it is naturally desired to minimize their size.
Reference: [Ju94] <author> S. Jukna. </author> <title> The graph of multiplication is hard for read-k-times networks. </title> <type> Manuscript, </type> <month> April </month> <year> 1994. </year>
Reference-contexts: If the only successful instantiations for x are 1 and z, then z is prime; otherwise, a nontrivial factor is determined. Since we can test the satisfiability of a read-once program in polynomial time, the entire procedure can be executed in polynomial time. Jukna <ref> [Ju94] </ref> proves a lower bound of 2 n 1=4 =k 2k for DMULT on non-deterministic read-k-times branching programs.
Reference: [KW93] <author> M. Karchmer and A. Wigderson. </author> <title> On span programs. </title> <booktitle> Proceedings of the 8th Structure in Complexity Theory, </booktitle> <year> (1993), </year> <pages> pp. 102-111. </pages>
Reference-contexts: Allowing both AND nodes and OR nodes enables polynomial-size programs to recognize alternating logspace, which is equal to P. By allowing parity nodes, polynomial programs recognize L, a logspace analogue to P <ref> [KW93] </ref>.
Reference: [Kr88] <author> M. Krause. </author> <title> Exponential lower bounds on the complexity of real time and local branching programs. </title> <journal> Journal of Information Processing and Cybernetics (EIK), </journal> <month> 24:3 </month> <year> (1988), </year> <pages> pp. 99-110. </pages>
Reference-contexts: Simon and Szegedy [SS93] distill this idea into a lemma which may be considered a paradigm for proving read-once lower bounds. This technique appears implicitly in the read-once lower bounds of [We88, Za84] and explicitly in those of <ref> [Ju88, Kr88, Du85] </ref>; the generalization in [SS93] enables an easier proof of the lower bound of [BHST87] and others [We87, Du85, Ju88].
Reference: [Kr91] <author> M. Krause. </author> <title> Lower bounds for depth-restricted branching programs. </title> <journal> Information and Computation, </journal> <volume> Vol. 91, </volume> <year> 1991. </year> <pages> pp. 1-14. Bibliography 75 </pages>
Reference-contexts: Krause <ref> [Kr91] </ref> proves lower bounds for other functions. We will have more to say about these lower bounds in Sections 2.4.2, 2.5, and 2.6. Of course, all other lower bounds mentioned below for stronger models imply a fortiori equally strong lower bounds for OBDD's. <p> Krause, Meinel, and Waack [KMW91] (see also [Ju89]) give a lower bound of n!= n 2 = 2 (n) for the function -MATRIX. (It was known earlier that this function required exponential-size deterministic read-once programs; see <ref> [Kr91, p. 10] </ref> and [Ju86].) Also, Borodin, Razborov and Smolensky [BRS93] prove a lower bound of 2 (n) for the functions n 2 CLIQUE and n 2 CLIQUE-ONLY. Note that the complement of n 2 CLIQUE-ONLY can be computed by nondeterministic read-once programs of polynomial size. <p> MHWB has a natural read-twice algorithm where the variables may be read in order each time, so MHWB 2 2-OBDD. In [BHR95], it is shown that MHWB 62 READ-1. Krause <ref> [Kr91, Remark 5.3] </ref> gives a different function which separates 2-OBDD from READ-1. 26 Related models 4-IBDD 3-IBDD 2-IBDD ( SEQ) ( SEQ) TRIX) ( -MA TRIX) OBDD 4-OBDD 3-OBDD 3 SEQ 62 4-PTR READ-4 READ-3 READ-2 READ-1 2-OBDD 3-PTR OBLIVIOUS LINEAR-LENGTH 3 ACH 62 3 MHWB 62 3-PTR READ-C C-IBDD C-OBDD <p> ACH is easily seen to be in READ-1, but a standard lower bound argument shows ACH is not in k-OBDD for any constant k [AGD91, BSSW93]. Krause <ref> [Kr91, Remark 5.4] </ref> gives a different function which separates C-OBDD from READ-1. The separation READ-1 6 C-OBDD is subsumed by the following result: READ-1 6 OBLIV-LINEAR. This very strong separation is shown using the powerful technique of Alon and Maass [AM88]. <p> Clearly, k-OBDD k-IBDD for each k; conversely, however, 2-IBDD 6 C-OBDD. Again, the separating function is -MATRIX: -MATRIX 2 2-IBDD easily, but -MATRIX 62 C-OBDD. This lower bound is claimed in <ref> [Kr91, Remark 5.5] </ref>, but 28 Related models to the best of our knowledge no proof has appeared, so we give one in Section 2.5.1 (Theorem 1). <p> For completeness as well as for demonstration, we supply a proof of Theorem 1, announced in <ref> [Kr91] </ref> without proof, and also prove Theorem 2, extending in a simple way the result of [BSSW93]. We compare these methods with lower bounds for non-oblivious programs, but defer a detailed description of the latter until the presentation of our own lower bound in Chapter 3. <p> all-1's minors, the communication complexity is at least lg jF j. 30 Related models For k-OBDD's If, for any set Y of size m, there exists a fooling set of size 2 (n) , then it is also easy to see that the function requires k-OBDD's of size 2 (n)=2k <ref> [Kr91] </ref>. A k-OBDD gives a communication protocol of 2k rounds; the total communication is 2k lg (width), which must be at least (n), giving the desired bound on the width and hence the size. For example, we give a simple proof that -MATRIX 62 k-OBDD for any constant k.
Reference: [KMW91] <author> M. Krause, C. Meinel, and S. Waack. </author> <title> Separating the eraser Turing machine classes L e , NL e , co-NL e , and P e . Theoretical Computer Science, </title> <booktitle> 86 (1991), </booktitle> <pages> pp. 267-275. </pages>
Reference-contexts: This result may be contrasted with NL = co-NL, which says that polynomial-size branching programs with OR nodes are equivalent to polynomial-size branching programs with AND nodes. We now see that if we restrict the programs to be read-once, OR nodes and AND nodes give different computational power <ref> [KMW91] </ref>. The same phenomenon occurs for linear-length oblivious programs [KMW92]. Determining the satisfiability of a program with AND nodes is NP-complete by the example in Section 2.2.4. <p> Krause, Meinel, and Waack <ref> [KMW91] </ref> (see also [Ju89]) give a lower bound of n!= n 2 = 2 (n) for the function -MATRIX. (It was known earlier that this function required exponential-size deterministic read-once programs; see [Kr91, p. 10] and [Ju86].) Also, Borodin, Razborov and Smolensky [BRS93] prove a lower bound of 2 (n) for
Reference: [KMW92] <author> M. Krause, C. Meinel, and S. Waack. </author> <title> Separating complexity classes related to certain input-oblivious logarithmic space-bounded Turing machines. </title> <journal> Theoretical Informatics and Applications, </journal> <volume> 26 (4) (1992), </volume> <pages> pp. 345-362. </pages>
Reference-contexts: We now see that if we restrict the programs to be read-once, OR nodes and AND nodes give different computational power [KMW91]. The same phenomenon occurs for linear-length oblivious programs <ref> [KMW92] </ref>. Determining the satisfiability of a program with AND nodes is NP-complete by the example in Section 2.2.4. The case of OR nodes is trivially as least as hard as determining the satisfiability of a deterministic read-once program, which is not known to be in P. <p> Their lower bound is discussed in Section 2.5.3. In similar spirit, Krause and Waack [KW91] show that any oblivious program of linear length for the problem of directed s-t connectivity requires exponential size; in <ref> [KMW92] </ref>, similar lower bounds are proved for such programs with nondeterminism added. <p> This implies, for instance, that SEQ 62 C-IBDD. For comparison, SEQ has very easy read-once programs, which are non-oblivious, of length n. In <ref> [KMW92] </ref>, this lower bound for SEQ is extended to nondeterministic oblivious programs of linear length. At the same time, a simple co-nondeterministic oblivious program (with AND nodes) of linear length is given, showing that as for read-once programs (Section 2.2.2), the two types of nondeterminism give different computational power.
Reference: [KW91] <author> M. Krause and S. Waack. </author> <title> On oblivious branching programs of linear length. </title> <booktitle> Information and Computation, 94:2 (1991), </booktitle> <pages> pp. 232-249. </pages>
Reference-contexts: Also, in a very different vein, Alon and Maass [AM88] prove lower bounds for arbitrary oblivious programs of linear length, which do not obey any restriction on the number of times a variable is read. Their lower bound is discussed in Section 2.5.3. In similar spirit, Krause and Waack <ref> [KW91] </ref> show that any oblivious program of linear length for the problem of directed s-t connectivity requires exponential size; in [KMW92], similar lower bounds are proved for such programs with nondeterminism added.
Reference: [Kr94] <author> S. Krischer. </author> <note> FANCY|new version (1.1). Theorynet-A announcement from krischer@ti.uni-trier.de, </note> <editor> U. </editor> <address> Trier, Germany, Nov. 17, </address> <year> 1994. </year>
Reference-contexts: The use of restricted forms of branching programs for the intermediate representation has made this approach feasible and very popular| several software packages are available for implementing this very strategy <ref> [Kr94, Br92] </ref>. This application raises several issues of computational complexity, renewing interest in the low-level complexity of branching programs.
Reference: [KM91] <author> E. Kushilevitz and Y. Mansour. </author> <title> Learning decision trees using the Fourier spectrum. </title> <booktitle> Proceedings of the 23d Annual ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1991, </year> <pages> pp. 455-464. </pages>
Reference-contexts: Properties of the Fourier spectrum have been used in a variety of applications, perhaps most strikingly in deriving efficient algorithms for learning (e.g., <ref> [KM91] </ref>). Two properties of the spectrum that have proven useful for this purpose are small L 1 -norm (that is, the sum of the absolute values of the coefficients) and a knowledge of which coefficients are the largest. For example, [KM91] gives an efficient algorithm for functions whose spectrum is either <p> perhaps most strikingly in deriving efficient algorithms for learning (e.g., <ref> [KM91] </ref>). Two properties of the spectrum that have proven useful for this purpose are small L 1 -norm (that is, the sum of the absolute values of the coefficients) and a knowledge of which coefficients are the largest. For example, [KM91] gives an efficient algorithm for functions whose spectrum is either sparse or has polynomial L 1 -norm.
Reference: [LMN89] <author> N. Linial, Y. Mansour, and N. Nisan. </author> <title> Constant-depth circuits, Fourier transform, and learnability. </title> <booktitle> Proceedings of the 30th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1989, </year> <pages> pp. 574-579. </pages>
Reference-contexts: It is easy to show that the L 1 -norm of a function is bounded by the number of leaves in any decision tree for that function, even if the nodes may query the parity of arbitrary subsets of the variables. And <ref> [LMN89] </ref> proves that functions in AC 0 have most of the weight of their spectrum in the coefficients of small sets. These results are used to derive efficient learning algorithms for functions in AC 0 and functions with shallow decision trees.
Reference: [LNNW95] <author> L. Lovasz, M. Naor, I. Newman, and A. Wigderson. </author> <title> Search problems in the decision tree model. </title> <journal> SIAM Journal of Discrete Mathematics, </journal> <volume> Vol. 8, No. </volume> <month> 1 (February </month> <year> 1995), </year> <pages> pp. 119-132. </pages>
Reference-contexts: We may consider a branching program for an unsatisfiable CNF formula that solves the following "search" problem: given an assignment x, find a clause of that is not satisfied. It is an observation of Chvatal and Szemeredi (see <ref> [LNNW95] </ref>) that read-once programs for this problem are isomorphic to regular resolution proofs. Taken together with the fact that a decision tree is a read-once branching program, [LNNW95] notes that D () lg RRES (), where D () is the depth of the shallowest decision tree for this search problem and <p> It is an observation of Chvatal and Szemeredi (see <ref> [LNNW95] </ref>) that read-once programs for this problem are isomorphic to regular resolution proofs. Taken together with the fact that a decision tree is a read-once branching program, [LNNW95] notes that D () lg RRES (), where D () is the depth of the shallowest decision tree for this search problem and RRES () is the fewest number of steps in a regular resolution proof of . x2.7 Related issues 43 In general, an arbitrary resolution proof for yields
Reference: [Ma76] <author> W. Masek. </author> <title> A Fast Algorithm for the String-Editing Problem and Decision Graph Complexity. </title> <type> SM Thesis, </type> <institution> MIT, </institution> <year> 1976. </year>
Reference-contexts: Many of the functions that require exponential size are very simple; some are easily computed with mere read-twice programs. Masek <ref> [Ma76] </ref> was the first to consider read-once programs, proving a lower bound of (m 2 ) on the size of any program determining whether P n later Wegener [We88, We87] proved lower bounds of 2 (n) for the function n 2 CLIQUE of determining whether a graph on n nodes contains
Reference: [Mc86] <author> L. McGeoch. </author> <title> A strong separation between k and k 1 round communication complexity for a constructive language. </title> <note> Carnegie Mellon University technical report CMU-CS-86-157 (1986). </note>
Reference-contexts: For k-IBDD's the hierarchy is also strict: k-IBDD ( (k + 1)-IBDD [BSSW95]. These lower bounds are based on the well-known "rounds hierarchy" for communication complexity exhibited by the "k-pointer-chasing" function, k-PTR, on bipartite graphs <ref> [PS82, DGS84, Mc86, HR88, NW91] </ref> (in particular the result of [NW91]).
Reference: [Me89] <author> C. Meinel. </author> <title> Modified Branching Programs and Their Computational Power. </title> <publisher> Springer-Verlag LNCS No. </publisher> <address> 370, </address> <year> 1989. </year>
Reference-contexts: Allowing both AND nodes and OR nodes enables polynomial-size programs to recognize alternating logspace, which is equal to P. By allowing parity nodes, polynomial programs recognize L, a logspace analogue to P [KW93]. Meinel <ref> [Me89] </ref> explores the range of all possibilities and concludes that allowing nodes of other binary Boolean functions does not give classes different from L, NL, P, or L. 1 It is easy to see that the proof of [Im88] yields the same result in the non-uniform case: Given a polynomial-size branching
Reference: [MW95] <author> C. Meinel and S. Waack. </author> <title> Separating complexity classes related to bounded alternating !-branching programs. </title> <journal> Mathematical Systems Theory, </journal> <volume> 28 (1995), </volume> <pages> pp. 21-39. 76 Bibliography </pages>
Reference-contexts: The latter are not branching programs, and do not compute a function, but they do allow polynomial-size representation of multiplication. Also, in [S95] lower bounds are proved on branching programs in which for each path, the number of variables appearing more than once is bounded by k. In <ref> [MW95] </ref>, lower bounds are proved for nondeterministic programs in which each path obeys a bound on the number of alternations between sets of variables. 2.1.1 Reading each variable k times There are essentially three models of branching programs in which each variable may be read multiple times: 1. k-OBDD's (also known <p> Jukna [Ju92] extends the results of [BRS93] and [Ok91] to show that the function from [Ok91] requires nondeterministic read-k-times programs of size exponential in ( p n=k 2k ) even though its complement can be computed by nondeterministic read-once programs of polynomial size. Also, in <ref> [MW95] </ref>, lower bounds are proved for nondeterministic programs in which each path obeys a bound on the number of alternations between sets of variables. 2.4 Comparing the models: classes and structural results In this section, we will compare the classes of functions that are computable by polynomial-size programs of the various
Reference: [Ne66] <author> E. I. Neciporuk. </author> <title> A boolean function. </title> <journal> Soviet Mathematis Doklady, </journal> <month> 7:4 </month> <year> (1966), </year> <pages> pp. 999-1000. </pages>
Reference: [NW91] <author> N. Nisan and A. Wigderson. </author> <title> Rounds in communication complexity revisited. </title> <booktitle> Proceedings of the 23d ACM Symposium on Theory of Computing (1991), </booktitle> <pages> pp. 419-429. </pages>
Reference-contexts: For k-IBDD's the hierarchy is also strict: k-IBDD ( (k + 1)-IBDD [BSSW95]. These lower bounds are based on the well-known "rounds hierarchy" for communication complexity exhibited by the "k-pointer-chasing" function, k-PTR, on bipartite graphs <ref> [PS82, DGS84, Mc86, HR88, NW91] </ref> (in particular the result of [NW91]). <p> For k-IBDD's the hierarchy is also strict: k-IBDD ( (k + 1)-IBDD [BSSW95]. These lower bounds are based on the well-known "rounds hierarchy" for communication complexity exhibited by the "k-pointer-chasing" function, k-PTR, on bipartite graphs [PS82, DGS84, Mc86, HR88, NW91] (in particular the result of <ref> [NW91] </ref>). It is not known whether the corresponding hierarchy for read-k-times programs is strict, except for the case k = 1, where we have seen that -MATRIX 62 READ-1 x2.4 Comparing the models: classes and structural results 25 but -MATRIX 2 2-IBDD READ-2.
Reference: [Ok91] <author> E. A. Okolnishnikova. </author> <title> Lower bounds for branching programs computing characteristic functions of binary codes. </title> <journal> Metody discretnogo analiza. </journal> <volume> 51 (1991), </volume> <pages> pp. 61-83. </pages> <note> In Russian. </note>
Reference-contexts: Note that the complement of n 2 CLIQUE-ONLY can be computed by nondeterministic read-once programs of polynomial size. Okolnishnikova <ref> [Ok91] </ref> proves that computing the characteristic function of the Bose-Chaudhuri codes requires deterministic read-k-times programs of size exponential in ( n=k k ). Borodin et. al. [BRS93] exhibit for any k, a function that requires nondeterministic read-k-times programs of size exponential in (n=k4 k ). <p> Borodin et. al. [BRS93] exhibit for any k, a function that requires nondeterministic read-k-times programs of size exponential in (n=k4 k ). Jukna [Ju92] extends the results of [BRS93] and <ref> [Ok91] </ref> to show that the function from [Ok91] requires nondeterministic read-k-times programs of size exponential in ( p n=k 2k ) even though its complement can be computed by nondeterministic read-once programs of polynomial size. <p> Borodin et. al. [BRS93] exhibit for any k, a function that requires nondeterministic read-k-times programs of size exponential in (n=k4 k ). Jukna [Ju92] extends the results of [BRS93] and <ref> [Ok91] </ref> to show that the function from [Ok91] requires nondeterministic read-k-times programs of size exponential in ( p n=k 2k ) even though its complement can be computed by nondeterministic read-once programs of polynomial size.
Reference: [PS82] <author> C. Papadimitriou and M. Sipser. </author> <title> Communication complexity. </title> <booktitle> Proceedings of the 14th ACM Symposium on Theory of Computing (1982), </booktitle> <pages> pp. 330-337. </pages>
Reference-contexts: For k-IBDD's the hierarchy is also strict: k-IBDD ( (k + 1)-IBDD [BSSW95]. These lower bounds are based on the well-known "rounds hierarchy" for communication complexity exhibited by the "k-pointer-chasing" function, k-PTR, on bipartite graphs <ref> [PS82, DGS84, Mc86, HR88, NW91] </ref> (in particular the result of [NW91]).
Reference: [Ra90] <author> A. A. Razborov. </author> <title> Lower bounds on the size of switching-and-rectifier networks for symmetric Boolean functions. </title> <journal> Mathematical Notes of the Academy of Sciences of the USSR, </journal> <volume> 48(6): </volume> <pages> 79-91, </pages> <year> 1990. </year>
Reference-contexts: There is another model of nondeterministic branching programs, called rectifier-and-switching networks, which is preferred by Razborov because of the combinatorial characterization its size measure affords (see <ref> [Ra91, Ra90] </ref>). A rectifier-and-switching network is essentially a nondeterministic branching program as [BRS93] defines them, except that the (directed) graph may contain cycles. There is no "rejecting sink" and the program accepts exactly when there exists at least one path from the source to the (accepting) sink.
Reference: [Ra91] <author> A. A. Razborov. </author> <title> Lower bounds for deterministic and nondeterministic branching programs. </title> <booktitle> Proceedings of the 8th FCT, </booktitle> <publisher> Springer-Verlag LNCS 529, </publisher> <year> 1991. </year> <pages> pp. 47-60. </pages>
Reference-contexts: There is another model of nondeterministic branching programs, called rectifier-and-switching networks, which is preferred by Razborov because of the combinatorial characterization its size measure affords (see <ref> [Ra91, Ra90] </ref>). A rectifier-and-switching network is essentially a nondeterministic branching program as [BRS93] defines them, except that the (directed) graph may contain cycles. There is no "rejecting sink" and the program accepts exactly when there exists at least one path from the source to the (accepting) sink. <p> Thus at a cost of squaring the size, we obtain a nondeterministic program in the sense of [BRS93]. It is not known if this measure is within a constant factor of the other two <ref> [Ra91, Open Question #1] </ref>. x2.2 Manipulating branching programs 19 2.2 Manipulating branching programs As explained in Chapter 1, OBDD's have the useful property that they are easily manipulated: Given OBDD's for f and g that obey the same ordering of the variables, it is easy to construct an OBDD for f
Reference: [SS71] <author> A. Schonhage and V. Strassen. Schelle multiplikation grosser zahlen. </author> <title> (Fast multipication of large numbers.) </title> <journal> Computing (Arch. Elektron. Rechen), </journal> <volume> 7 (1971), </volume> <pages> pp. 281-292. </pages>
Reference: [SDG94] <author> A. Shen, S. Devadas, and A. Ghosh. </author> <title> Probabilistic manipulation of boolean functions using free boolean diagrams. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> Volume 14, Number 1 (January 1995), </volume> <pages> pp. 87-95. </pages>
Reference-contexts: Thus, despite the success of this approach, there has also been great effort expended to find another model that is likewise manipulated, but with greater computational power <ref> [SDG94, SW95, e.g.] </ref>. Most of these models|k-OBDD's, k-IBDD's, nondeterministic OBDD's|have proven too weak to compute multiplication in polynomial size (see Chapter 2). A common feature of these models is that they are all oblivious branching programs. <p> The case of OR nodes is trivially as least as hard as determining the satisfiability of a deterministic read-once program, which is not known to be in P. In the case of PARITY nodes, the algorithm of [BCW80] works as long as the field used has characteristic 2 <ref> [SDG94] </ref>. In [SDG94], simple but very restrictive conditions on the use of AND and OR gates are given so that the correctness of the algorithm of [BCW80] is retained. 2.2.3 k-OBDD's By restricting the order to be the same permutation repeated k times, we retain the property that two programs with <p> In the case of PARITY nodes, the algorithm of [BCW80] works as long as the field used has characteristic 2 <ref> [SDG94] </ref>. In [SDG94], simple but very restrictive conditions on the use of AND and OR gates are given so that the correctness of the algorithm of [BCW80] is retained. 2.2.3 k-OBDD's By restricting the order to be the same permutation repeated k times, we retain the property that two programs with obeying the
Reference: [S95] <author> D. Sieling. </author> <title> New lower bounds and hierarchy results for restricted branching programs. Electronic Colloquium on Computational Complexity, </title> <note> TR95-002 (January 1995), available via http://www.eccc.uni-trier.de/eccc/. </note>
Reference-contexts: Two recently proposed models, which we shall not consider here, are "graph-driven BDD's" [SW95] and "binary moment diagrams" [BC94]. The latter are not branching programs, and do not compute a function, but they do allow polynomial-size representation of multiplication. Also, in <ref> [S95] </ref> lower bounds are proved on branching programs in which for each path, the number of variables appearing more than once is bounded by k.
Reference: [SW95] <author> D. Sieling and I. Wegener. </author> <title> Graph driven BDD's|a new data structure for boolean functions. </title> <booktitle> Theoretical Computer Science 141 (1995), </booktitle> <pages> pp. 283-310. </pages>
Reference-contexts: Thus, despite the success of this approach, there has also been great effort expended to find another model that is likewise manipulated, but with greater computational power <ref> [SDG94, SW95, e.g.] </ref>. Most of these models|k-OBDD's, k-IBDD's, nondeterministic OBDD's|have proven too weak to compute multiplication in polynomial size (see Chapter 2). A common feature of these models is that they are all oblivious branching programs. <p> Two recently proposed models, which we shall not consider here, are "graph-driven BDD's" <ref> [SW95] </ref> and "binary moment diagrams" [BC94]. The latter are not branching programs, and do not compute a function, but they do allow polynomial-size representation of multiplication.
Reference: [SS93] <author> J. Simon and M. Szegedy. </author> <title> A new lower bound theorem for read-only-once branching programs and its applications. Advances in Computational Com Bibliography 77 plexity Theory (J. Cai, editor), </title> <journal> DIMACS Series, </journal> <volume> Vol. 13, </volume> <pages> AMS (1993) pp. 183-193. </pages>
Reference-contexts: Simon and Szegedy <ref> [SS93] </ref>, in order to demonstrate their lower bound technique, proved a lower bound of 2 (n) x2.4 Comparing the models: classes and structural results 23 for the problem of determining whether a graph on n nodes is (n=2)-regular. <p> Babai, Hajnal, Szemeredi and Turan [BHST87] proved an asymptotically optimal lower bound of 2 (n 2 ) for computing the parity of the number of triangles in a graph on n nodes; Simon and Szegedy <ref> [SS93] </ref> simplify and refine their analysis, improving the constant in the exponent. 2.3.3 For nondeterministic programs, read-once and read-k-times Exponential lower bounds for explicit functions have also been proved for nondeterministic read-once branching programs. <p> It is not known whether the corresponding hierarchy for read-k-times programs is strict, except for the case k = 1, where we have seen that -MATRIX 62 READ-1 x2.4 Comparing the models: classes and structural results 25 but -MATRIX 2 2-IBDD READ-2. Simon and Szegedy <ref> [SS93] </ref> conjecture that the problem of testing the regularity of hypergraphs, which (for the case of ordinary graphs) they showed separates READ-1 from READ-2, will separate the levels of this hierarchy. <p> In order to prove lower bounds for read-once programs, we must show that not only are there many subfunctions, but that each arises in very few ways. Simon and Szegedy <ref> [SS93] </ref> distill this idea into a lemma which may be considered a paradigm for proving read-once lower bounds. This technique appears implicitly in the read-once lower bounds of [We88, Za84] and explicitly in those of [Ju88, Kr88, Du85]; the generalization in [SS93] enables an easier proof of the lower bound of <p> Simon and Szegedy <ref> [SS93] </ref> distill this idea into a lemma which may be considered a paradigm for proving read-once lower bounds. This technique appears implicitly in the read-once lower bounds of [We88, Za84] and explicitly in those of [Ju88, Kr88, Du85]; the generalization in [SS93] enables an easier proof of the lower bound of [BHST87] and others [We87, Du85, Ju88]. <p> This result demonstrates that relaxing the ordering restriction of OBDD's is insufficient to gain the computational power desired for the purpose of hardware verification. The lower bound for multiplication is motivated by the work of Simon and Szegedy <ref> [SS93] </ref>, who give a basic lemma for proving lower bounds on the size of read-once branching programs. The lemma involves Neciporuk's method of counting the subfunc-tions that are possible when some subset of input bits is fixed. We begin by describing this lemma in Section 3.1. <p> By setting the values of B = X n B, we naturally induce a function on B. The lemma is stated below in the form we will need it; it appears in <ref> [SS93] </ref> in slightly more generalized form. Lemma 1 (Simon and Szegedy) If for any B in the boundary of F , at most 2 jBj =L settings to B induce the same subfunction on B, then any read-once branching program computing f has size at least L. <p> The read-k-times hierarchy As mentioned in Section 2.4.1, it is not known whether the read-k-times hierarchy is strict: Open Question 3 For some k &gt; 2, is there a function computable by polynomial-size read-k-times programs but not computable by polynomial-size read (k 1)-times programs? In <ref> [SS93] </ref>, it is conjectured that such a function is the problem of determining whether a k-dimensional hypergraph on n nodes is r-regular for, say, r = n=2. (Re call that [SS93] proves that this problem on ordinary graphs (k = 2), while easily computed by read-2-times programs, requires read-once programs of <p> 2, is there a function computable by polynomial-size read-k-times programs but not computable by polynomial-size read (k 1)-times programs? In <ref> [SS93] </ref>, it is conjectured that such a function is the problem of determining whether a k-dimensional hypergraph on n nodes is r-regular for, say, r = n=2. (Re call that [SS93] proves that this problem on ordinary graphs (k = 2), while easily computed by read-2-times programs, requires read-once programs of size 2 (n) .) The function -MATRIX may be regarded as a special case of this problem: it is the case of determining whether a bipartite n fi n graph
Reference: [SV81] <author> S. Skyum and L. Valiant. </author> <title> A complexity theory based on Boolean algebra. </title> <booktitle> Proceedings of the 22nd Annual Symposium on Foundations of Computer Science, (1981) pp. </booktitle> <pages> 244-253, </pages>
Reference-contexts: In order to preserve read-once complexity, we will consider a very restrictive type of problem reduction. We begin with the notion of projection reductions <ref> [SV81] </ref>, as defined in [CSV84]: Definition 5 A function f = ff n g n2N is projection reducible to a function g = fg n g n2N , written f proj g, if there is a mapping : fy 1 ; : : : ; y p (n) g ! f0;
Reference: [THY93] <author> S. Tani, K. Hamaguchi, and S. Yajima. </author> <title> The complexity of the optimal variable-ordering problem of shared binary decision diagrams. </title> <booktitle> Proceedings of the 4th Int'l. ISAAC, </booktitle> <publisher> (1993) Springer-Verlag LNCS 762, </publisher> <pages> pp. 389-398. </pages>
Reference-contexts: The decision problem is: Given an OBDD and an integer k, determine whether there is an OBDD (possibly obeying a different ordering of the variables) with fewer than k nodes that computes the same function. This problem was recently proved to be NP-complete in [BW95], extending the work of <ref> [BW95, THY93] </ref>, via a nice reduction to OPTIMAL-LINEAR-ARRANGEMENT [GJ79]. It would be useful to find an efficient algorithm to determine an approximately optimal ordering. Many heuristics for improving an ordering can be found in the literature (see [BW95]).
Reference: [We87] <author> I. Wegener. </author> <title> The Complexity of Boolean Functions. </title> <booktitle> Wiley-Teubner Series in Computer Science. </booktitle> <address> New York/Stuggart, </address> <year> 1987. </year>
Reference-contexts: Many of the functions that require exponential size are very simple; some are easily computed with mere read-twice programs. Masek [Ma76] was the first to consider read-once programs, proving a lower bound of (m 2 ) on the size of any program determining whether P n later Wegener <ref> [We88, We87] </ref> proved lower bounds of 2 (n) for the function n 2 CLIQUE of determining whether a graph on n nodes contains a clique of size n=2, and also for the function n 2 CLIQUE-ONLY, of determining whether a graph on n nodes contains an n=2-clique and no further edges. <p> This technique appears implicitly in the read-once lower bounds of [We88, Za84] and explicitly in those of [Ju88, Kr88, Du85]; the generalization in [SS93] enables an easier proof of the lower bound of [BHST87] and others <ref> [We87, Du85, Ju88] </ref>. Simon and Szegedy use this technique to reprove a theorem of Babai et. al. [BHST87], that read-once programs require size 2 (n 2 ) to count modulo 2 the number of triangles in an n-node graph.
Reference: [We88] <author> I. Wegener. </author> <title> On the complexity of branching programs and decision trees for clique functions. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) (1988), </volume> <pages> pp. 461-471. </pages>
Reference-contexts: Many of the functions that require exponential size are very simple; some are easily computed with mere read-twice programs. Masek [Ma76] was the first to consider read-once programs, proving a lower bound of (m 2 ) on the size of any program determining whether P n later Wegener <ref> [We88, We87] </ref> proved lower bounds of 2 (n) for the function n 2 CLIQUE of determining whether a graph on n nodes contains a clique of size n=2, and also for the function n 2 CLIQUE-ONLY, of determining whether a graph on n nodes contains an n=2-clique and no further edges. <p> Simon and Szegedy [SS93] distill this idea into a lemma which may be considered a paradigm for proving read-once lower bounds. This technique appears implicitly in the read-once lower bounds of <ref> [We88, Za84] </ref> and explicitly in those of [Ju88, Kr88, Du85]; the generalization in [SS93] enables an easier proof of the lower bound of [BHST87] and others [We87, Du85, Ju88].
Reference: [We93] <author> I. Wegener. </author> <title> Optimal lower bounds on the depth of polynomial-size threshold circuits for some arithmetic functions. </title> <journal> Information Processing Letters, </journal> <volume> Vol. 46, No. 2, </volume> <pages> pp. 85-87, </pages> <month> May 17, </month> <year> 1993. </year>
Reference-contexts: It was originally proved in [HMPST93] that INNER-PRODUCT-MODULO-2 cannot be computed in polynomial-size by threshold circuits of depth 2. It was also noted there that the projection reduction to multiplication (first given in [FSS84], from PARITY to MULT) shows that MULT obeys the same lower bound. Wegener <ref> [We93] </ref> gives projection reductions from MULT to squaring and inversion in order to show that these functions also require depth 3 polynomial-size threshold circuits. The lower bound for the middle bit of multiplication implies a lower bound for the appropriate bit of these two functions. We phrase the reductions in [We93] <p> <ref> [We93] </ref> gives projection reductions from MULT to squaring and inversion in order to show that these functions also require depth 3 polynomial-size threshold circuits. The lower bound for the middle bit of multiplication implies a lower bound for the appropriate bit of these two functions. We phrase the reductions in [We93] in terms of the following Boolean functions: * SQUARING : f0; 1g n ! f0; 1g; computes "the" middle bit (here, bit n rather than bit n 1 which we chose for MULT) in the square of an n-bit integer: SQUARING (z) = (z 2 ) n : * INVERSION <p> This gives the following corollaries to Theorem 5: x3.4 Problem reductions 63 Corollary 1 Any read-once branching program for computing the function SQUARING has size at least 2 ( p Proof: We verify that the reduction in <ref> [We93] </ref> shows MULT r-o SQUARING with a polynomial p (n) = 3n + 2. In addition to verifying p (n), we must also check that the reduction is indeed between these two Boolean functions and also that the mapping is injective. <p> &gt; &lt; y i if 0 i &lt; n; x i2 (n+1) if 2 (n + 1) i &lt; 2 (n + 1) + n: Corollary 2 Any read-once branching program for computing the function INVERSION has size at least 2 ( p Proof: We verify that the reduction in <ref> [We93] </ref> shows SQUARING r-o INVERSION with polynomial p (n) = 17n + 1. <p> The proof in <ref> [We93] </ref> shows that the product m 2 lies in bit positions 6n 1 through 8n in 1=(1 x), its middle bit being in position 7n. By instead computing the inverse of 2 7n (1 x), a 17n-bit number, we find the middle bit of m 2 in position 0.
Reference: [We94] <author> I. Wegener. </author> <title> Efficient data structures for boolean functions. </title> <journal> Discrete Mathematics, </journal> <volume> 136, </volume> <year> (1994), </year> <pages> pp. 347-372. </pages>
Reference-contexts: The central problem of verification is to check whether a combinational hardware circuit has been correctly designed. One approach commonly employed today is to convert independently the circuit description and the function specification to a common intermediate representation and then test whether the two representations are equivalent (e.g., <ref> [Br92, We94] </ref>). The use of restricted forms of branching programs for the intermediate representation has made this approach feasible and very popular| several software packages are available for implementing this very strategy [Kr94, Br92]. <p> A simple argument <ref> [We94] </ref> shows that computing DMULT with read-once programs is as hard as factoring. Given a polynomial-size read-once program for DMULT and any integer n, the following procedure will either factor n or determine that it is prime.
Reference: [Za84] <author> S. Zak. </author> <title> An exponential lower bound for one-time-only branching programs. </title> <booktitle> Proceedings of the 11th MFCT, </booktitle> <publisher> Springer-Verlag LNCS No. </publisher> <month> 176 </month> <year> (1984), </year> <pages> pp. 562-566. </pages>
Reference-contexts: Simon and Szegedy [SS93] distill this idea into a lemma which may be considered a paradigm for proving read-once lower bounds. This technique appears implicitly in the read-once lower bounds of <ref> [We88, Za84] </ref> and explicitly in those of [Ju88, Kr88, Du85]; the generalization in [SS93] enables an easier proof of the lower bound of [BHST87] and others [We87, Du85, Ju88].
References-found: 66

