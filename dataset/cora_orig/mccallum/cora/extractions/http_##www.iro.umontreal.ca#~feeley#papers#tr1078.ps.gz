URL: http://www.iro.umontreal.ca/~feeley/papers/tr1078.ps.gz
Refering-URL: http://www.iro.umontreal.ca/~feeley/
Root-URL: http://www.iro.umontreal.ca
Title: Compiling Higher-Order Languages into Fully Tail-Recursive Portable C  
Author: Marc Feeley James S. Miller Guillermo J. Rozas Jason A. Wilson 
Date: August 18, 1997  
Abstract: Note: This paper was written in 1993 and has not been modified since then. It is therefore out of sync with the current implementations of Gambit and MIT-Scheme. Abstract Two independently developed implementations of Scheme have been extended to compile into portable C code that implements full tail-recursion. Like other compilers for higher-order languages that implement full tail-recursion, measurements of these systems indicate a performance degradation of a factor between two and three compared to the native code emitted by the same compilers. We describe the details of the compilation technique for a non-statically typed language (Scheme) and show that the performance difficulty arises largely from the cost of C function calls. In theory, these expensive calls can be eliminated. In practice, however, they are required to avoid excessively long compilation times by modern C compilers, and to support separate compilation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Joel Bartlett. </author> <title> Scheme-&gt;C a portable Scheme-to-C compiler. </title> <type> Technical report, </type> <institution> Digital Equipment Corp. Western Research Lab., </institution> <year> 1989. </year>
Reference-contexts: Because of its ubiquity, the language C has become a popular target language for these compilers <ref> [13, 20, 1, 14, 19] </ref>. But there are difficulties that arise from the choice of C as a target language: 1. Fully tail-recursive languages (e.g. <p> file in the MIT Scheme runtime system using this technique required over 120 megabytes of swap space and took about five hours using a (roughly) 40 SPECint92 HPPA processor. 3 Related Work There has been a good deal of work in compiling higher-order languages to C, starting with Bartlett's work <ref> [1] </ref> on a compiler from Scheme to C in 1989 and including the more recent work on compiling Haskell [13], SML [20], and the Bigloo [14] and Hobbit [19] implementations of Scheme.
Reference: [2] <author> William Clinger, Anne Hartheimer, and Eric Ost. </author> <title> Implementation strategies for continuations. </title> <booktitle> In Proc. ACM Symp. LISP and Functional Progr., </booktitle> <pages> pages 124-131, </pages> <year> 1988. </year>
Reference-contexts: The translation is straightforward and most C compilers optimize this kind of array and pointer arithmetic. Once this decision has been made, it is simple to implement call-with-current-continuation portably using any one of several well-known techniques <ref> [2, 8] </ref>. Both systems distribute the program's executable C code among a set of C procedures called host procedures. Each host procedure contains a set of control points: places in its code that can be the target of a control transfer (i.e. procedure entry points and return points).
Reference: [3] <author> Apple Computer. </author> <title> Dylan tm An Object-Oriented Dynamic Language. </title> <institution> Apple Computer, Inc., Cupertino, </institution> <address> CA, </address> <year> 1992. </year>
Reference-contexts: Because of its ubiquity, the language C has become a popular target language for these compilers [13, 20, 1, 14, 19]. But there are difficulties that arise from the choice of C as a target language: 1. Fully tail-recursive languages (e.g. Scheme, ML, and Dylan <ref> [3] </ref>) consider procedure call to be "goto statements that happen to pass arguments,"[16] while C implementations are free to treat procedure call and goto completely separately.
Reference: [4] <author> Marc Feeley and James S. Miller. </author> <title> A parallel virtual machine for efficient Scheme compilation. </title> <booktitle> In Proc. ACM Symp. LISP and Functional Progr., </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Two independently-developed Scheme systems (MIT Scheme [7] and Gambit <ref> [4] </ref>) have been extended to produce portable C output code. The projects were undertaken completely independently with different design goals, yet have ultimately resorted to the same mechanisms.
Reference: [5] <author> Richard P. Gabriel. </author> <title> Performance and Evaluation of LISP Systems. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: We report here only the simplest measurements, and we have based them on the Gabriel benchmarks <ref> [5] </ref> initially written in CommonLisp and directly translated into Scheme. To this set of benchmarks we've added two large programs originally written in Scheme, conform and peval.
Reference: [6] <author> Chris Hanson. </author> <title> Efficient stack allocation for tail-recursive languages. </title> <booktitle> In Conference on Lisp and Functional Programming, </booktitle> <address> Nice, France, </address> <month> June </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: Host procedures never call other host procedures directly. Instead, they return a value to the 1 Gambit uses a variation on lambda-lifting [10] to flatten the environment structure so that lexical chains are often of depth one. MIT Scheme uses a combination of static analysis and runtime conditionals <ref> [6] </ref> to preserve the invariant. 4 void dispatcher () - descr *pc = initial_pc; while (1) pc = pc-&gt;host ( pc ); - Gambit void dispatcher () - descr *pc = initial_pc; while (1) host *h = &global_host_table [ pc-&gt;index ]; pc = h-&gt;host ( pc, h-&gt;start ); - MIT Scheme
Reference: [7] <editor> Chris Hanson et al. </editor> <title> MIT Scheme reference manual. </title> <type> Technical Report 1281, </type> <institution> Mass. Inst. of Technology, Artificial Intelligence Laboratory, </institution> <address> Cambridge, MA, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Two independently-developed Scheme systems (MIT Scheme <ref> [7] </ref> and Gambit [4]) have been extended to produce portable C output code. The projects were undertaken completely independently with different design goals, yet have ultimately resorted to the same mechanisms.
Reference: [8] <author> Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proc. ACM Prog. Lang. Design and Impl., </booktitle> <pages> pages 66-77, </pages> <year> 1990. </year> <month> 11 </month>
Reference-contexts: The translation is straightforward and most C compilers optimize this kind of array and pointer arithmetic. Once this decision has been made, it is simple to implement call-with-current-continuation portably using any one of several well-known techniques <ref> [2, 8] </ref>. Both systems distribute the program's executable C code among a set of C procedures called host procedures. Each host procedure contains a set of control points: places in its code that can be the target of a control transfer (i.e. procedure entry points and return points).
Reference: [9] <editor> IEEE Std 1178-1990. </editor> <title> IEEE Standard for the Scheme Programming Language. </title> <publisher> Institute of Electrical and Electronic Engineers, Inc., </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: We describe a series of measurements which help illuminate the source of this difficulty. To our knowledge, there is no generally accepted definition of "fully tail-recursive." For clarity, we adopt the definition from the Scheme standard <ref> [9] </ref>: In a tail-recursive implementation, iterative processes can be expressed by means of procedure calls. (The process described by a program is iterative if and only if the order of its space growth is constant, aside from that used for the values of the program's variables.) Note that, under this definition,
Reference: [10] <editor> Simon L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: The execute caches and other structures described in [11] are also accessed in this way. Host procedures never call other host procedures directly. Instead, they return a value to the 1 Gambit uses a variation on lambda-lifting <ref> [10] </ref> to flatten the environment structure so that lexical chains are often of depth one.
Reference: [11] <author> James Miller and Guillermo Rozas. </author> <title> Free variables and first-class environments. </title> <journal> Journal of Lisp and Symbolic Computation, </journal> <year> 1991. </year>
Reference-contexts: In the case of MIT Scheme, some free variables are accessed using compile-time known offsets from pc. The execute caches and other structures described in <ref> [11] </ref> are also accessed in this way. Host procedures never call other host procedures directly. Instead, they return a value to the 1 Gambit uses a variation on lambda-lifting [10] to flatten the environment structure so that lexical chains are often of depth one.
Reference: [12] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: In both cases we find that the performance of our C code is between a factor of two and three slower than the native code generators for our compilers. In addition, recent work on compiling SML <ref> [12, 20] </ref> has yielded similar performance results, despite the fact that the SML compiler uses static typing information to overcome the overhead of encoding data type information at runtime.
Reference: [13] <author> Simon L Peyton-Jones, Cordy Hall, Kevin Hammond, Will Partain, and Phil Wadler. </author> <title> The glasgow haskell compiler: a technical overview. </title> <booktitle> In Proc. UK Joint Framework for Information Technology, </booktitle> <year> 1992. </year>
Reference-contexts: Because of its ubiquity, the language C has become a popular target language for these compilers <ref> [13, 20, 1, 14, 19] </ref>. But there are difficulties that arise from the choice of C as a target language: 1. Fully tail-recursive languages (e.g. <p> about five hours using a (roughly) 40 SPECint92 HPPA processor. 3 Related Work There has been a good deal of work in compiling higher-order languages to C, starting with Bartlett's work [1] on a compiler from Scheme to C in 1989 and including the more recent work on compiling Haskell <ref> [13] </ref>, SML [20], and the Bigloo [14] and Hobbit [19] implementations of Scheme. <p> It is hardly a surprise, then, that their C back-end is also roughly a factor of two slower than their native code generator. Perhaps the most interesting comparison is to the work on Haskell reported in <ref> [13] </ref>.
Reference: [14] <author> Manuel Serrano. </author> <note> Bigloo user's manual version 1.4. INRIA-Rocquencourt, </note> <month> August </month> <year> 1993. </year>
Reference-contexts: Because of its ubiquity, the language C has become a popular target language for these compilers <ref> [13, 20, 1, 14, 19] </ref>. But there are difficulties that arise from the choice of C as a target language: 1. Fully tail-recursive languages (e.g. <p> 40 SPECint92 HPPA processor. 3 Related Work There has been a good deal of work in compiling higher-order languages to C, starting with Bartlett's work [1] on a compiler from Scheme to C in 1989 and including the more recent work on compiling Haskell [13], SML [20], and the Bigloo <ref> [14] </ref> and Hobbit [19] implementations of Scheme.
Reference: [15] <author> Guy Lewis Steele Jr. </author> <title> Debunking the `expensive procedure call' myth. AI Memo 443, </title> <address> Mass. </address> <institution> Inst. of Technology, Artificial Intelligence Laboratory, </institution> <address> Cambridge, MA, </address> <month> October </month> <year> 1977. </year>
Reference-contexts: appearing in tail position must remove their frame from the stack and then jump to the destination. 2 Compilation Issues There have been compilers capable of converting a source language with higher-order procedures and requiring a tail-recursive implementation into another language lacking both of these features since at least 1976 <ref> [15, 16] </ref>. Because of its ubiquity, the language C has become a popular target language for these compilers [13, 20, 1, 14, 19]. But there are difficulties that arise from the choice of C as a target language: 1. Fully tail-recursive languages (e.g.
Reference: [16] <author> Guy Lewis Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Master's thesis, </type> <institution> Mass. Inst. of Technology, </institution> <year> 1978. </year>
Reference-contexts: appearing in tail position must remove their frame from the stack and then jump to the destination. 2 Compilation Issues There have been compilers capable of converting a source language with higher-order procedures and requiring a tail-recursive implementation into another language lacking both of these features since at least 1976 <ref> [15, 16] </ref>. Because of its ubiquity, the language C has become a popular target language for these compilers [13, 20, 1, 14, 19]. But there are difficulties that arise from the choice of C as a target language: 1. Fully tail-recursive languages (e.g. <p> To enable the selection of the correct control point within a host procedure, a pointer to the descriptor of the first control point in host procedure "i" is kept in start i . As in Steele's Rabbit system <ref> [16] </ref>, there is a driver loop (the dispatcher) which is responsible for transferring control between host procedures. The dispatcher maintains in pc (a C variable local to the host procedure) the control point to be jumped to.
Reference: [17] <author> Guy Lewis Steele Jr. </author> <title> Common LISP The Language. </title> <note> Digital Press, second edition, </note> <year> 1990. </year>
Reference-contexts: This powerful technique cannot be used when compiling to C because there is no portable way to control the relative placement of the code and data areas. This particular difficulty arises, ultimately, only in dynamically typed languages (such as Scheme, CommonLisp <ref> [17] </ref>, and Dylan), where the compiler cannot in general decide when 2 an object being manipulated is a procedure. In a statically typed language (e.g.
Reference: [18] <author> P. Steenkiste and J. Hennessy. </author> <title> Tags and type checking in lisp: Hardware and software approaches. </title> <booktitle> In 2nd Int. Conf. Architectural Support for Programming Languages and Operating Systems (ASPLOS II), </booktitle> <pages> pages 50-59, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: This can be compared to the figures of an average of 2% and a maximum of 8% in <ref> [18] </ref>.
Reference: [19] <author> Tanel Tammet. </author> <note> Documentation for Hobbit version 2. </note> <institution> Department of Computer Sciences, Chalmers University of Technology, </institution> <year> 1993. </year>
Reference-contexts: Because of its ubiquity, the language C has become a popular target language for these compilers <ref> [13, 20, 1, 14, 19] </ref>. But there are difficulties that arise from the choice of C as a target language: 1. Fully tail-recursive languages (e.g. <p> processor. 3 Related Work There has been a good deal of work in compiling higher-order languages to C, starting with Bartlett's work [1] on a compiler from Scheme to C in 1989 and including the more recent work on compiling Haskell [13], SML [20], and the Bigloo [14] and Hobbit <ref> [19] </ref> implementations of Scheme.
Reference: [20] <author> David Tarditi, Anunrag Acharya, and Peter Lee. </author> <title> No assembly required: Compiling standard ML to C. </title> <type> Technical report, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> November </month> <year> 1990. </year> <note> CMU-CS-90-187. 12 </note>
Reference-contexts: In both cases we find that the performance of our C code is between a factor of two and three slower than the native code generators for our compilers. In addition, recent work on compiling SML <ref> [12, 20] </ref> has yielded similar performance results, despite the fact that the SML compiler uses static typing information to overcome the overhead of encoding data type information at runtime. <p> Because of its ubiquity, the language C has become a popular target language for these compilers <ref> [13, 20, 1, 14, 19] </ref>. But there are difficulties that arise from the choice of C as a target language: 1. Fully tail-recursive languages (e.g. <p> hours using a (roughly) 40 SPECint92 HPPA processor. 3 Related Work There has been a good deal of work in compiling higher-order languages to C, starting with Bartlett's work [1] on a compiler from Scheme to C in 1989 and including the more recent work on compiling Haskell [13], SML <ref> [20] </ref>, and the Bigloo [14] and Hobbit [19] implementations of Scheme. <p> The work on Haskell and SML are both closer to our own work. The mechanisms developed for the SML-to-C translator described in <ref> [20] </ref> are similar to our own, although done in the context of a statically typed language. It is hardly a surprise, then, that their C back-end is also roughly a factor of two slower than their native code generator.
References-found: 20

