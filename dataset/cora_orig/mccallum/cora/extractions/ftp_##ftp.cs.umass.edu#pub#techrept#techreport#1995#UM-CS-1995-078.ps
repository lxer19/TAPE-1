URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1995/UM-CS-1995-078.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/95-078.html
Root-URL: 
Title: An Analysis of Process Languages  
Author: Stanley M. Sutton, Jr., Peri L. Tarr, Leon J. Osterweil 
Note: This work was supported by the Advanced Research Projects Agency under grant F30602-94-C-0137.  
Address: Amherst, Massachusetts 01003  
Affiliation: Laboratory for Advanced Software Engineering Research Computer Science Department University of Massachusetts  
Abstract: CMPSCI Technical Report 95-78 August 1995 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Robert Balzer. </author> <title> Tolerating inconsistency. </title> <booktitle> In Proc. of the 13th International Conference on Software Engineering, </booktitle> <pages> pages 158 - 165, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: These capabilities are used, for example, to reason about the states of artifacts and to plan modifications to them accordingly. AP5 [8] takes a meta-data approach to the dynamic accommodation of artifact inconsistencies <ref> [1] </ref>. AP5 and Merlin [22] define rules as data, enabling them to be manipulated reflectively and dynamically. SLANG [3] and EPOS [10] also define manipulable data representations for process models. These are especially intended to support process evolution. Support for meta-data, reflectivity, and dynamism are requirements on most software processes.
Reference: [2] <author> Sergio Bandinelli, Elisabetta Di Nitto, and Alfonso Fuggetta. </author> <title> Policies and mechanisms to support process evolution in PSEEs. </title> <booktitle> In Proc. of the Third International Conference on the Software Process, </booktitle> <pages> pages 9-20, </pages> <year> 1994. </year>
Reference-contexts: Software processes must accommodate human development activities. These are characterized by creativity, judgement, tentativeness, incompleteness, informality, and lack of struc 4 ture, and by activities that are either partially or not at all supported by automated tools (e.g., meetings, negotiation, etc.) (see <ref> [2] </ref>). Contrast this with the goals of process languages, which are to facilitate the definition of well engineered, high-quality software processes to which the software engineering discipline can be applied. Such software processes must be characterized by formality, rigor, completeness, well-formedness, and semantic depth.
Reference: [3] <author> Sergio Bandinelli and Alfonso Fuggetta. </author> <title> Computational reflection in software process modeling: the SLANG approach. </title> <booktitle> In Proc. of the 15th International Conference on Software Engineering, </booktitle> <pages> pages 144-154, </pages> <year> 1993. </year>
Reference-contexts: Despite the differences between process goals and process-language goals, process-language researchers have tended to treat process requirements as process language requirements, with the end result that many process languages include support directly (in the form of language constructs) for features required of processes (e.g., <ref> [3, 10] </ref>). This often leads to the problem of proliferating language features ("kitchen sink" languages), which are difficult to use, analyze, and apply to multiple domains. It may also result in process languages that have characteristics that make them less well suited to the application of rigorous software engineering. <p> The ProcessWall [18] defines a process state service that can be used by processes where the process language does not provide built-in support for state reification. In SLANG <ref> [3, 5] </ref>, the execution state of Petri nets is maintained in language-defined data structures, which may be accessed by executing processes, for example, for purposes of process modification. <p> AP5 [8] takes a meta-data approach to the dynamic accommodation of artifact inconsistencies [1]. AP5 and Merlin [22] define rules as data, enabling them to be manipulated reflectively and dynamically. SLANG <ref> [3] </ref> and EPOS [10] also define manipulable data representations for process models. These are especially intended to support process evolution. Support for meta-data, reflectivity, and dynamism are requirements on most software processes. Many different kinds of meta-data may be useful in software processes. <p> This is a particular application of the general principles enunciated in Section 2.1 and elaborated in Section 2.8. 2.8 Meta-Processes An important distinction in software processes is between production processes and meta-processes <ref> [3, 9, 35] </ref>. Production processes, which are the focus of this paper, support the development and maintenance of software products. Meta-processes are essential to production processes, since meta-processes effect the creation, execution, management, and evolution of production processes.
Reference: [4] <author> Sergio Bandinelli, Alfonso Fuggetta, Carlo Ghezzi, and Luigi Lavazza. SPADE: </author> <title> An Environment for Software Process Analysis, Design, </title> <editor> and Enactment. In Anthony Finkel-stein, Jeff Kramer, and Bashar Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, chapter 9, </booktitle> <pages> pages 223-248. </pages> <publisher> Research Studies Press, Ltd., </publisher> <address> Taunton, Somerset, England, </address> <year> 1994. </year>
Reference-contexts: For example, rule-based systems, such as Marvel [23] and Merlin, support reactive control well, but they can only simulate proactive control via appropriate programmer-defined pre- and post-conditions, which is difficult and 7 awkward. State-based and net-based languages, such as Teamware [37], Process Weaver [13], and SLANG <ref> [4] </ref>, support proactive control, but they do not readily support reactive control. As a result, they are awkward to use for describing reactions to contingencies. Resources: Production processes make use of many different kinds of resources. <p> For example, ProSLCSE [26] supports activity decomposition to any level of detail, but the decompositions have limited semantics, so few of the benefits of including detailed information (e.g., analysis, planning) can be realized. SLANG <ref> [4] </ref> supports decomposition down to the level where tools are invoked, but it cannot describe tools and their effects, so it does not provide deep enough semantics to elaborate activities fully and must, consequently, include an "escape" mechanism to invoke tools that are defined elsewhere. <p> A similar phenomenon is noted in the use of Petri nets, which have become a fixture for clearly depicting flow and synchronization of activities. In systems such as SLANG <ref> [4] </ref> we see that Petri nets function very successfully in depicting these aspects of software processes. In SLANG, however, we also see that, as the basic Petri net vehicle is elaborated (e.g., by 11 adding colored tokens and specialized transitions), the result is increasing complexity but decreasing comprehensibility. <p> Examples of this approach are EPOS [10], in which production processes are represented as a combination of task networks and rules, SLANG <ref> [4] </ref>, which represents production processes as modified Petri nets, GRAPPLE [20], which represents production processes as plans, and Merlin [22], which represents processes as mutable rules. For our purposes, the approach of combining representation of production processes and meta-processes complicates the representation of production processes.
Reference: [5] <author> Sergio Bandinelli, Alfonso Fuggetta, and Sandro Grigolli. </author> <title> Process modeling in-the-large with SLANG. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 75-83, </pages> <year> 1993. </year>
Reference-contexts: The ProcessWall [18] defines a process state service that can be used by processes where the process language does not provide built-in support for state reification. In SLANG <ref> [3, 5] </ref>, the execution state of Petri nets is maintained in language-defined data structures, which may be accessed by executing processes, for example, for purposes of process modification.
Reference: [6] <author> Noureddine Belkhatir, Jacky Estublier, and Walcelio Melo. ADELE-TEMPO: </author> <title> An Environment to Support Process Modelling and Enaction. </title> <editor> In Anthony Finkelstein, Jeff Kramer, and Bashar Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, chapter 8, </booktitle> <pages> pages 187-222. </pages> <publisher> Research Studies Press, Ltd., </publisher> <address> Taunton, Somerset, England, </address> <year> 1994. </year>
Reference-contexts: In fact, all of these features can be found in some process languages, and many languages attempt to provide at least minimal support for most of these capabilities. For example, Adele <ref> [6] </ref>, AP5 [8], APPL/A [34], EPOS [10], and Merlin [22] provide at least some support for most or all of the capabilities. This supports the assertion that all of these aspects must be addressed to obtain a complete production process description. <p> The processes cannot themselves access the actual artifact, except through invoked 9 tools, and tools cannot access the proxies. This approach has been adopted in Marvel, Merlin, SLANG, and GRAPPLE [20]. Other languages support the definition of artifacts at any level of granularity. For example, APPL/A, Adele <ref> [6] </ref>, AP5 [8], and Pleiades [36] are based on general-purpose programming languages, and they provide rich type models that support the fine-grained definition and manipulation of artifacts. Treatment of connections among higher- and lower-levels of activity descriptions has been variable. <p> They require the ability to support a broad range of functionality, with semantics sufficiently deep to enable execution. Their level of abstraction is generally low to moderately high, though Adele-TEMPO, which also supports executable process programs, combines a low-level and high-level language <ref> [6] </ref>. <p> Other techniques include, for example, type and data evolution (e.g., [24]), late and dynamic binding, dynamic linking, tool buses [31], object request broker architectures [12], and programming techniques, such as subjectivity [16], object roles in Adele <ref> [6] </ref>, and program design techniques to support evolution, like intermittent execution [34]. All of these techniques have benefits and may be 3 "Separation of concerns is a common-sense practice that we try to follow in our everyday life to master the difficulties we encounter.
Reference: [7] <author> Noureddine Belkhatir, Jacky Estublier, and Melo L. Walcelio. </author> <title> Software Process Model and Workspace Control in the Adele System. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 2 - 11, </pages> <year> 1993. </year>
Reference-contexts: These aspects must be addressed through process languages. In this section we discuss alternative approaches that provide support using one or more languages. One Semantically-Broad Language: One approach to supporting software processes is through a single, semantically broad language. Examples of such languages include APPL/A [34], Merlin [22], Adele <ref> [7] </ref>, and AP5 [8]. This approach has several benefits. The use of a single language provides comprehensive and integrated syntax and semantics across multiple process aspects and subdomains. In turn, one language is usually easier to learn, understand, analyze, and use than multiple languages.
Reference: [8] <author> Don Cohen. </author> <title> AP5 Manual. </title> <institution> Univ. of Southern California, Information Sciences Institute, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: In fact, all of these features can be found in some process languages, and many languages attempt to provide at least minimal support for most of these capabilities. For example, Adele [6], AP5 <ref> [8] </ref>, APPL/A [34], EPOS [10], and Merlin [22] provide at least some support for most or all of the capabilities. This supports the assertion that all of these aspects must be addressed to obtain a complete production process description. No existing system supports all of the required capabilities sufficiently, however. <p> The processes cannot themselves access the actual artifact, except through invoked 9 tools, and tools cannot access the proxies. This approach has been adopted in Marvel, Merlin, SLANG, and GRAPPLE [20]. Other languages support the definition of artifacts at any level of granularity. For example, APPL/A, Adele [6], AP5 <ref> [8] </ref>, and Pleiades [36] are based on general-purpose programming languages, and they provide rich type models that support the fine-grained definition and manipulation of artifacts. Treatment of connections among higher- and lower-levels of activity descriptions has been variable. <p> In this section we discuss alternative approaches that provide support using one or more languages. One Semantically-Broad Language: One approach to supporting software processes is through a single, semantically broad language. Examples of such languages include APPL/A [34], Merlin [22], Adele [7], and AP5 <ref> [8] </ref>. This approach has several benefits. The use of a single language provides comprehensive and integrated syntax and semantics across multiple process aspects and subdomains. In turn, one language is usually easier to learn, understand, analyze, and use than multiple languages. <p> Pleiades [36] provides dynamic information about artifact type and instance definitions, and dynamic control over several object management capabilities, including persistence and the enforcement of constraints on artifacts. These capabilities are used, for example, to reason about the states of artifacts and to plan modifications to them accordingly. AP5 <ref> [8] </ref> takes a meta-data approach to the dynamic accommodation of artifact inconsistencies [1]. AP5 and Merlin [22] define rules as data, enabling them to be manipulated reflectively and dynamically. SLANG [3] and EPOS [10] also define manipulable data representations for process models. These are especially intended to support process evolution.
Reference: [9] <author> Reidar Conradi, Christer Fernstrom, and Alfonso Fuggetta. </author> <title> Concepts for Evolving Software Processes. </title> <editor> In Anthony Finkelstein, Jeff Kramer, and Bashar Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, chapter 2, </booktitle> <pages> pages 9-31. </pages> <publisher> Research Studies Press, Ltd., </publisher> <address> Taunton, Somerset, England, </address> <year> 1994. </year> <month> 22 </month>
Reference-contexts: This is a particular application of the general principles enunciated in Section 2.1 and elaborated in Section 2.8. 2.8 Meta-Processes An important distinction in software processes is between production processes and meta-processes <ref> [3, 9, 35] </ref>. Production processes, which are the focus of this paper, support the development and maintenance of software products. Meta-processes are essential to production processes, since meta-processes effect the creation, execution, management, and evolution of production processes.
Reference: [10] <author> Reidar Conradi, Marianne Hagaseth, Jens-Otto Larsen, Minh Ngoc Nguyen, Bjorn P. Munch, Per H. Westby, Weicheng Zhu, M. Letizia Jaccheri, and Chunnian Liu. EPOS: </author> <title> Object-Oriented Cooperative Process Modelling. </title> <editor> In Anthony Finkelstein, Jeff Kramer, and Bashar Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, chapter 3, </booktitle> <pages> pages 33-70. </pages> <publisher> Research Studies Press, Ltd., </publisher> <address> Taunton, Somerset, England, </address> <year> 1994. </year>
Reference-contexts: Despite the differences between process goals and process-language goals, process-language researchers have tended to treat process requirements as process language requirements, with the end result that many process languages include support directly (in the form of language constructs) for features required of processes (e.g., <ref> [3, 10] </ref>). This often leads to the problem of proliferating language features ("kitchen sink" languages), which are difficult to use, analyze, and apply to multiple domains. It may also result in process languages that have characteristics that make them less well suited to the application of rigorous software engineering. <p> In fact, all of these features can be found in some process languages, and many languages attempt to provide at least minimal support for most of these capabilities. For example, Adele [6], AP5 [8], APPL/A [34], EPOS <ref> [10] </ref>, and Merlin [22] provide at least some support for most or all of the capabilities. This supports the assertion that all of these aspects must be addressed to obtain a complete production process description. No existing system supports all of the required capabilities sufficiently, however. <p> Treatment of connections among higher- and lower-levels of activity descriptions has been variable. Several languages support "is-composed-of" and other types of structural or dependency relationships among artifacts (e.g., Adele, EPOS <ref> [10] </ref>, Marvel, and Merlin). The type models in APPL/A, AP5, and Pleiades support arbitrarily complex composition and decomposition of data types. <p> It necessarily has a high semantic level, medium semantic breadth, and shallow semantic depth, and it is not intended to support execution. * APPL/A [34], Merlin [22], Marvel [23], and EPOS <ref> [10] </ref> are intended to produce fully executable process programs. They require the ability to support a broad range of functionality, with semantics sufficiently deep to enable execution. <p> AP5 [8] takes a meta-data approach to the dynamic accommodation of artifact inconsistencies [1]. AP5 and Merlin [22] define rules as data, enabling them to be manipulated reflectively and dynamically. SLANG [3] and EPOS <ref> [10] </ref> also define manipulable data representations for process models. These are especially intended to support process evolution. Support for meta-data, reflectivity, and dynamism are requirements on most software processes. Many different kinds of meta-data may be useful in software processes. <p> A typical technique for supporting process evolution in these languages is to represent the production process fundamentally in the form of data, and then effect process evolution by modifying the data representations. Examples of this approach are EPOS <ref> [10] </ref>, in which production processes are represented as a combination of task networks and rules, SLANG [4], which represents production processes as modified Petri nets, GRAPPLE [20], which represents production processes as plans, and Merlin [22], which represents processes as mutable rules.
Reference: [11] <author> Reidar Conradi and Chunnian Liu. </author> <title> Process Modelling Languages: One or Many? In Wilhelm Schafer, editor, </title> <booktitle> Proceedings of the 4th European Workshop on Software Process Technology, </booktitle> <pages> pages 98-118. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <note> Published as Lecture Notes in Computer Science, number 913. </note>
Reference-contexts: Although several researchers have proposed capabilities for this purpose, there has been little agreement on what capabilities the core should include. For example, Conradi and Liu <ref> [11] </ref> suggest that this set should contain activities, artifacts, roles, users and groups, production tools, and support for evolution. Junkermann et al. [22] explicitly define the set to include activities, roles, artifacts, and resources, but also implicitly include support for artifact interrelationships. <p> When multiple languages are used, however, the issue of their uniformity, understandability, and analyzability as a group is an issue. Additionally, the interoperability of the different languages and their respective models for control, data, consistency, etc., becomes a problem. Core Languages with Extensions: Conradi and Liu <ref> [11] </ref> identify a third alternative, that is, the use of a common "core" language extended with higher-level and more specialized languages. This approach should be flexible enough in principle to support special process needs or domains in a relatively straightforward manner. <p> However, defining the core language is a problem on the order of defining a single, broad process language. It also raises ongoing questions about whether each capability belongs in the core or in an extension. As observed in <ref> [11] </ref>, for example, putting support for meta-processes into the core can be inefficient (since the execution of a core-level meta-process requires translation to affect the various extensions); however, putting it into the extensions means that capabilities may be repeated among the extensions and more difficult to coordinate and maintain.
Reference: [12] <institution> Digital Equipment Corporation, Hewlett-Packard Company, HyperDesk Corporation, NCR Corporation, </institution> <note> Object Design, </note> <author> Inc., and SunSoft, Inc. </author> <title> The Common Object Request Broker: Architecture and Specification. </title> <booktitle> Object Management Group and X/Open, 1993. Revision 1.2. </booktitle>
Reference-contexts: While this technique may be suitable in some cases, it is only one of several that may be used to support process evolution. Other techniques include, for example, type and data evolution (e.g., [24]), late and dynamic binding, dynamic linking, tool buses [31], object request broker architectures <ref> [12] </ref>, and programming techniques, such as subjectivity [16], object roles in Adele [6], and program design techniques to support evolution, like intermittent execution [34].
Reference: [13] <author> Christer Fernstrom. </author> <title> PROCESS WEAVER: Adding process support to UNIX. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 12 - 26, </pages> <year> 1993. </year>
Reference-contexts: For example, rule-based systems, such as Marvel [23] and Merlin, support reactive control well, but they can only simulate proactive control via appropriate programmer-defined pre- and post-conditions, which is difficult and 7 awkward. State-based and net-based languages, such as Teamware [37], Process Weaver <ref> [13] </ref>, and SLANG [4], support proactive control, but they do not readily support reactive control. As a result, they are awkward to use for describing reactions to contingencies. Resources: Production processes make use of many different kinds of resources. <p> Changes must be carefully considered and well supported by good insights and intuitions. Thus, superior pictorial visualizations of such processes may be important assets for process modification. One common approach to process visualization, which was taken in IDEF0 [32], Process Weaver <ref> [13] </ref>, and Teamware [37], is to use a single pictorial representation to define software processes. Most of these representations depict process activities and their interrelationships as graphs with nodes (activities) and edges (interrelationships). Some representations provide different depictions to show different kinds of process activities and interrelationships. <p> A variety of positions in the semantic space are taken by current process languages. Some representative examples are: * ProSLCSE [26], IDEF-0 [32], Process Weaver <ref> [13] </ref>, and Teamware [37] help to orchestrate, and may partially automate, process tasks and tools. They have a high semantic level, but their breadth is narrow, even in describing process activities.
Reference: [14] <author> Carlo Ghezzi, Medhi Jazayeri, and Dino Mandrioli. </author> <title> Fundamentals of Software Engineering. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1991. </year>
Reference: [15] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot. STATEMATE: </author> <title> A working environment for the development of complex reactive systems. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 16(4):403 - 414, </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: One attack on the self-defeating clutter of overly elaborate diagrams has been to present process visualizations as coordinated sets of diagrams. Thus, systems such as Statemate <ref> [15] </ref> and Oikos [28] represent processes using multiple diagrams, each presenting a different view of the process. With such systems users can browse a variety of different diagrams, each of which represents a focused view. A major problem with such approaches is the need to maintain consistency among multiple views.
Reference: [16] <author> William Harrison and Harold Ossher. </author> <title> Subject-oriented programming (a critique of pure objects). </title> <booktitle> In Proceedings of the 8th ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 411-428, </pages> <year> 1993. </year>
Reference-contexts: Other techniques include, for example, type and data evolution (e.g., [24]), late and dynamic binding, dynamic linking, tool buses [31], object request broker architectures [12], and programming techniques, such as subjectivity <ref> [16] </ref>, object roles in Adele [6], and program design techniques to support evolution, like intermittent execution [34]. All of these techniques have benefits and may be 3 "Separation of concerns is a common-sense practice that we try to follow in our everyday life to master the difficulties we encounter.
Reference: [17] <author> Dennis Heimbigner. </author> <title> Experiences with an Object-Manager for A Process-Centered Environment. </title> <booktitle> In Proceedings of the Eighteenth International Conf. on Very Large Data Bases, </booktitle> <address> Vancouver, B.C., </address> <month> 24-27 August </month> <year> 1992. </year>
Reference-contexts: To demonstrate why separation of process and language requirements is desirable, consider the issue of support for process state reification, which entails the representation of process execution state in the form of meta-data. Researchers generally impose this as a requirement that software processes support reflective behavior <ref> [17] </ref>. Yet several distinct realizations of state reification have been described in the literature. Process state is reified in APPL/A process programs by relations that are defined and maintained by the process itself [34].
Reference: [18] <author> Dennis Heimbigner. </author> <title> The ProcessWall: A Process State Server Approach to Process Programming. </title> <booktitle> In Proc. Fifth ACM SIGSOFT/SIGPLAN Symposium on Software Development Environments, </booktitle> <address> Washington, D.C., </address> <month> 9-11 December </month> <year> 1992. </year>
Reference-contexts: Process state is reified in APPL/A process programs by relations that are defined and maintained by the process itself [34]. Providing this support imposes an extra burden on process programmers, but it allows state reification to be tailored precisely to particular process needs. The ProcessWall <ref> [18] </ref> defines a process state service that can be used by processes where the process language does not provide built-in support for state reification.
Reference: [19] <author> George T. Heineman, Gail E. Kaiser, Naser S. Barghouti, and Israel Z. Ben-Shaul. </author> <title> Rule Chaining in Marvel: Dynamic Binding of Parameters. </title> <journal> IEEE Expert, </journal> <volume> 7(6) </volume> <pages> 26-32, </pages> <month> December </month> <year> 1992. </year> <month> 23 </month>
Reference-contexts: Connections among higher- and lower-levels of activity descriptions have also received varying treatment. Some languages, like MVP-L [33], HFSP [35], SLANG, and APPL/A [34], support explicit activity decomposition, and thus, it is relatively straightforward to move between levels of granularity. Other languages, particularly rule-based formalisms like Marvel <ref> [19] </ref> and Merlin [22], allow activities to be described in detail and define deep semantics for those definitions, but the activity hierarchy must be extracted from the rule base, which is non-trivial. Existing process languages have tended to be fairly bi-polar on the issue of granularity of artifact descriptions.
Reference: [20] <author> Karen E. Huff and Victor Lesser. </author> <title> A plan-based intelligent assistant that supports the software development process. </title> <booktitle> In ACM Symposium on Practical Software Development Environments, </booktitle> <pages> pages 97 - 106, </pages> <year> 1988. </year>
Reference-contexts: The processes cannot themselves access the actual artifact, except through invoked 9 tools, and tools cannot access the proxies. This approach has been adopted in Marvel, Merlin, SLANG, and GRAPPLE <ref> [20] </ref>. Other languages support the definition of artifacts at any level of granularity. For example, APPL/A, Adele [6], AP5 [8], and Pleiades [36] are based on general-purpose programming languages, and they provide rich type models that support the fine-grained definition and manipulation of artifacts. <p> Examples of this approach are EPOS [10], in which production processes are represented as a combination of task networks and rules, SLANG [4], which represents production processes as modified Petri nets, GRAPPLE <ref> [20] </ref>, which represents production processes as plans, and Merlin [22], which represents processes as mutable rules. For our purposes, the approach of combining representation of production processes and meta-processes complicates the representation of production processes.
Reference: [21] <author> H. Iida, K.-I. Mimura, K. Inoue, and K. Torii. Hakoniwa: </author> <title> Monitor and Navigation System for Cooperative Development Based on Activity Sequence Model. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 64 - 74, </pages> <year> 1993. </year>
Reference-contexts: Although resources are a very important part of production process description and execution, few systems support their definition explicitly. For example, AP5, APPL/A, Hakoniwa <ref> [21] </ref>, HFSP [35], Marvel, Pleiades [36], and SLANG provide no predefined mechanisms for resource definition (beyond their artifact and activity definition formalisms). The few systems that do provide some degree of support typically provide descriptions only of human resources and tools (e.g., Teamware and EPOS).
Reference: [22] <author> G. Junkermann, B. Peuschel, W. Schafer, and S. Wolf. Merlin: </author> <title> Supporting cooperation in software development through a knowledge-based environment. </title> <editor> In Anthony Finkelstein, Jeff Kramer, and Bashar Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, chapter 4, </booktitle> <pages> pages 103-129. </pages> <publisher> Research Studies Press, Ltd., </publisher> <address> Taunton, Somerset, England, </address> <year> 1994. </year>
Reference-contexts: Although several researchers have proposed capabilities for this purpose, there has been little agreement on what capabilities the core should include. For example, Conradi and Liu [11] suggest that this set should contain activities, artifacts, roles, users and groups, production tools, and support for evolution. Junkermann et al. <ref> [22] </ref> explicitly define the set to include activities, roles, artifacts, and resources, but also implicitly include support for artifact interrelationships. Lonchamp [25] indicates that activities, artifacts, agents, roles, tools, and constraints are the "classical" process concepts. <p> This set seems to satisfy most of the requirements we have seen other researchers impose; for example, it supports roles as special kinds of relations among activities, and users and tools as special kinds of resources (as suggested in <ref> [22] </ref>). In fact, all of these features can be found in some process languages, and many languages attempt to provide at least minimal support for most of these capabilities. For example, Adele [6], AP5 [8], APPL/A [34], EPOS [10], and Merlin [22] provide at least some support for most or all <p> tools as special kinds of resources (as suggested in <ref> [22] </ref>). In fact, all of these features can be found in some process languages, and many languages attempt to provide at least minimal support for most of these capabilities. For example, Adele [6], AP5 [8], APPL/A [34], EPOS [10], and Merlin [22] provide at least some support for most or all of the capabilities. This supports the assertion that all of these aspects must be addressed to obtain a complete production process description. No existing system supports all of the required capabilities sufficiently, however. <p> Some languages, like MVP-L [33], HFSP [35], SLANG, and APPL/A [34], support explicit activity decomposition, and thus, it is relatively straightforward to move between levels of granularity. Other languages, particularly rule-based formalisms like Marvel [19] and Merlin <ref> [22] </ref>, allow activities to be described in detail and define deep semantics for those definitions, but the activity hierarchy must be extracted from the rule base, which is non-trivial. Existing process languages have tended to be fairly bi-polar on the issue of granularity of artifact descriptions. <p> These aspects must be addressed through process languages. In this section we discuss alternative approaches that provide support using one or more languages. One Semantically-Broad Language: One approach to supporting software processes is through a single, semantically broad language. Examples of such languages include APPL/A [34], Merlin <ref> [22] </ref>, Adele [7], and AP5 [8]. This approach has several benefits. The use of a single language provides comprehensive and integrated syntax and semantics across multiple process aspects and subdomains. In turn, one language is usually easier to learn, understand, analyze, and use than multiple languages. <p> It necessarily has a high semantic level, medium semantic breadth, and shallow semantic depth, and it is not intended to support execution. * APPL/A [34], Merlin <ref> [22] </ref>, Marvel [23], and EPOS [10] are intended to produce fully executable process programs. They require the ability to support a broad range of functionality, with semantics sufficiently deep to enable execution. <p> These capabilities are used, for example, to reason about the states of artifacts and to plan modifications to them accordingly. AP5 [8] takes a meta-data approach to the dynamic accommodation of artifact inconsistencies [1]. AP5 and Merlin <ref> [22] </ref> define rules as data, enabling them to be manipulated reflectively and dynamically. SLANG [3] and EPOS [10] also define manipulable data representations for process models. These are especially intended to support process evolution. Support for meta-data, reflectivity, and dynamism are requirements on most software processes. <p> Examples of this approach are EPOS [10], in which production processes are represented as a combination of task networks and rules, SLANG [4], which represents production processes as modified Petri nets, GRAPPLE [20], which represents production processes as plans, and Merlin <ref> [22] </ref>, which represents processes as mutable rules. For our purposes, the approach of combining representation of production processes and meta-processes complicates the representation of production processes. It yields process representations that combine code and data for meta-process activities with code and data that represent production-process activities. the software product.
Reference: [23] <author> Gail E. Kaiser, Naser S. Barghouti, and Michael H. Sokolsky. </author> <title> Experience with Process Modeling in the Marvel Software Development Environment Kernel. </title> <editor> In Bruce Shriver, editor, </editor> <booktitle> 23rd Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 131-140, </pages> <address> Kona HI, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: Both reactive and proactive control are essential for production processes, yet many process languages focus on only one kind of control. For example, rule-based systems, such as Marvel <ref> [23] </ref> and Merlin, support reactive control well, but they can only simulate proactive control via appropriate programmer-defined pre- and post-conditions, which is difficult and 7 awkward. <p> It necessarily has a high semantic level, medium semantic breadth, and shallow semantic depth, and it is not intended to support execution. * APPL/A [34], Merlin [22], Marvel <ref> [23] </ref>, and EPOS [10] are intended to produce fully executable process programs. They require the ability to support a broad range of functionality, with semantics sufficiently deep to enable execution. <p> Design, architectures, requirements, and evaluative material are essential as well. This variety of artifacts is necessary to assure that needs other than the need to execute on a computer can be met. The same seems to be true in the process domain. Process code (such as APPL/A [34], Marvel <ref> [23] </ref>, etc.) supports process execution, but there are other needs as well (e.g., group coordination) that are better met by design artifacts such as process models. Thus, the steady growth of interest in process modelling, process architecture, and process measurement tools and technologies seems expectable.
Reference: [24] <author> Barbara Staudt Lerner. </author> <title> Type Evolution Support for Complex Type Changes. </title> <type> Technical Report TR-94-71, </type> <institution> University of Massachusetts, Computer Science Department, </institution> <address> Amherst, MA, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: While this technique may be suitable in some cases, it is only one of several that may be used to support process evolution. Other techniques include, for example, type and data evolution (e.g., <ref> [24] </ref>), late and dynamic binding, dynamic linking, tool buses [31], object request broker architectures [12], and programming techniques, such as subjectivity [16], object roles in Adele [6], and program design techniques to support evolution, like intermittent execution [34].
Reference: [25] <author> Jacques Lonchamp. </author> <title> An assessment exercise. </title> <editor> In Anthony Finkelstein, Jeff Kramer, and Bashar Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, chapter 13, </booktitle> <pages> pages 335-356. </pages> <publisher> Research Studies Press, Ltd., </publisher> <address> Taunton, Somerset, England, </address> <year> 1994. </year>
Reference-contexts: For example, Conradi and Liu [11] suggest that this set should contain activities, artifacts, roles, users and groups, production tools, and support for evolution. Junkermann et al. [22] explicitly define the set to include activities, roles, artifacts, and resources, but also implicitly include support for artifact interrelationships. Lonchamp <ref> [25] </ref> indicates that activities, artifacts, agents, roles, tools, and constraints are the "classical" process concepts. While there is some agreement on the inclusion of activities and resources, clearly, there is less consensus on other capabilities.
Reference: [26] <author> James Milligan. </author> <title> The process-oriented software life cycle support environment (ProSLCSE). </title> <address> briefing slides, </address> <year> 1994. </year> <title> Rome Laboratory/C3CB, Griffiss Air Force Base, </title> <editor> N. Y. </editor> <month> 13441-4505. </month>
Reference-contexts: They also require connections among different levels of granularity, to facilitate "zoom-in" and "zoom-out" as necessary. Most existing process languages support both coarse- and finer-grained descriptions of activities, though the treatment varies. For example, ProSLCSE <ref> [26] </ref> supports activity decomposition to any level of detail, but the decompositions have limited semantics, so few of the benefits of including detailed information (e.g., analysis, planning) can be realized. <p> Points throughout the space add value for some aspects of process representation and execution and help to distinguish the uses for which particular languages are appropriate. A variety of positions in the semantic space are taken by current process languages. Some representative examples are: * ProSLCSE <ref> [26] </ref>, IDEF-0 [32], Process Weaver [13], and Teamware [37] help to orchestrate, and may partially automate, process tasks and tools. They have a high semantic level, but their breadth is narrow, even in describing process activities.
Reference: [27] <author> C. Montangero. </author> <title> In favor of a coherent process coding language. </title> <editor> In Wilhelm Schafer, editor, </editor> <booktitle> Proceedings of the 4th European Workshop on Software Process Technology, </booktitle> <pages> pages 94-97. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <note> Published as Lecture Notes in Computer Science, number 913. </note>
Reference-contexts: Each of the three approaches described above seems plausible in principle, and experience has already shown that each also suffers from limitations of one sort or another. Approaches based on a core language do not seem to be essential, but neither should they be excluded. Montangero <ref> [27] </ref> argues that the multiple-language approach should be pursued over the shorter term to identify requirements on suitable core languages for the longer term. There seems to be no single correct answer to the question of how linguistic support for software processes should be structured.
Reference: [28] <author> Carlo Montangero and Vincenzo Ambriola. OIKOS: </author> <title> Constructing process-centered sdes. </title> <editor> In Anthony Finkelstein, Jeff Kramer, and Bashar Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, </booktitle> <pages> pages 33 - 70. </pages> <publisher> John Wiley & Sons Inc., </publisher> <year> 1994. </year> <month> 24 </month>
Reference-contexts: One attack on the self-defeating clutter of overly elaborate diagrams has been to present process visualizations as coordinated sets of diagrams. Thus, systems such as Statemate [15] and Oikos <ref> [28] </ref> represent processes using multiple diagrams, each presenting a different view of the process. With such systems users can browse a variety of different diagrams, each of which represents a focused view. A major problem with such approaches is the need to maintain consistency among multiple views.
Reference: [29] <author> Leon J. Osterweil. </author> <title> Software Processes are Software Too. </title> <booktitle> In Proceedings of the Ninth International Conference of Software Engineering, </booktitle> <pages> pages 2-13, </pages> <address> Monterey CA, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: These beliefs have served to focus attention on the problem of creating and exploiting superior software processes. As an alternative to developing an entire new discipline of process development, it was suggested that process development might be viewed as a type of software development <ref> [29] </ref>. This suggestion seemed attractive as it suggested that much existing software technology might be exploited to support the development of processes.
Reference: [30] <author> Leon J. Osterweil and Dennis Heimbigner. </author> <title> An Alternative to Software Process Languages. </title> <editor> In C. Ghezzi, editor, </editor> <booktitle> Proceedings of the Ninth International Software Process Workshop, </booktitle> <address> Airlie, VA, </address> <year> 1994. </year>
Reference-contexts: Alternatively, generality may be achieved by taking the "union" of a variety of high-level abstractions, which can lead to further complexity and interoperability problems without guaranteeing generality. Multiple, Independent, Special-Purpose Languages: An alternative to one broad language is the use of multiple, semantically specialized languages <ref> [30] </ref>.
Reference: [31] <author> James M. Purtilo. </author> <title> The Polylith Software Bus. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <year> 1992. </year>
Reference-contexts: While this technique may be suitable in some cases, it is only one of several that may be used to support process evolution. Other techniques include, for example, type and data evolution (e.g., [24]), late and dynamic binding, dynamic linking, tool buses <ref> [31] </ref>, object request broker architectures [12], and programming techniques, such as subjectivity [16], object roles in Adele [6], and program design techniques to support evolution, like intermittent execution [34].
Reference: [32] <author> Richard J. Mayer, et al. </author> <title> IDEF Family of Methods for Concurrent Engineering and Business Re-engineering Applications. </title> <type> Technical report, </type> <institution> Knowledge Based Systems, Inc., </institution> <year> 1992. </year>
Reference-contexts: Changes must be carefully considered and well supported by good insights and intuitions. Thus, superior pictorial visualizations of such processes may be important assets for process modification. One common approach to process visualization, which was taken in IDEF0 <ref> [32] </ref>, Process Weaver [13], and Teamware [37], is to use a single pictorial representation to define software processes. Most of these representations depict process activities and their interrelationships as graphs with nodes (activities) and edges (interrelationships). Some representations provide different depictions to show different kinds of process activities and interrelationships. <p> Points throughout the space add value for some aspects of process representation and execution and help to distinguish the uses for which particular languages are appropriate. A variety of positions in the semantic space are taken by current process languages. Some representative examples are: * ProSLCSE [26], IDEF-0 <ref> [32] </ref>, Process Weaver [13], and Teamware [37] help to orchestrate, and may partially automate, process tasks and tools. They have a high semantic level, but their breadth is narrow, even in describing process activities.
Reference: [33] <author> H. D. Rombach and M. Verlage. </author> <title> How to assess a software process modeling formalism from a project member's point of view. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 147 - 159, </pages> <year> 1993. </year>
Reference-contexts: Connections among higher- and lower-levels of activity descriptions have also received varying treatment. Some languages, like MVP-L <ref> [33] </ref>, HFSP [35], SLANG, and APPL/A [34], support explicit activity decomposition, and thus, it is relatively straightforward to move between levels of granularity. <p> They have a high semantic level, but their breadth is narrow, even in describing process activities. Their depth ranges from shallow to moderate, since they admit few formal analyses and, if they support process execution, it is to a limited extent. * MVP-L <ref> [33] </ref> is intended specifically for process modeling. It necessarily has a high semantic level, medium semantic breadth, and shallow semantic depth, and it is not intended to support execution. * APPL/A [34], Merlin [22], Marvel [23], and EPOS [10] are intended to produce fully executable process programs. <p> Their level of abstraction is generally low to moderately high, though Adele-TEMPO, which also supports executable process programs, combines a low-level and high-level language [6]. An analysis of language suitability for various users and roles in a software process <ref> [33] </ref> supports the contention that the appropriate applications of process languages are determined by characteristics related to semantic level and breadth. 15 This semantic space provides a framework for analyzing the suitability of languages for par-ticular sorts of roles in support of process representation and execution.
Reference: [34] <author> Stanley M. Sutton, Jr., Dennis Heimbigner, and Leon J. Osterweil. APPL/A: </author> <title> A language for software-process programming. </title> <journal> ACM Trans. on Software Engineering and Methodology, </journal> <volume> 4(3), </volume> <month> July </month> <year> 1995. </year> <note> to appear. </note>
Reference-contexts: Researchers generally impose this as a requirement that software processes support reflective behavior [17]. Yet several distinct realizations of state reification have been described in the literature. Process state is reified in APPL/A process programs by relations that are defined and maintained by the process itself <ref> [34] </ref>. Providing this support imposes an extra burden on process programmers, but it allows state reification to be tailored precisely to particular process needs. The ProcessWall [18] defines a process state service that can be used by processes where the process language does not provide built-in support for state reification. <p> In fact, all of these features can be found in some process languages, and many languages attempt to provide at least minimal support for most of these capabilities. For example, Adele [6], AP5 [8], APPL/A <ref> [34] </ref>, EPOS [10], and Merlin [22] provide at least some support for most or all of the capabilities. This supports the assertion that all of these aspects must be addressed to obtain a complete production process description. No existing system supports all of the required capabilities sufficiently, however. <p> Connections among higher- and lower-levels of activity descriptions have also received varying treatment. Some languages, like MVP-L [33], HFSP [35], SLANG, and APPL/A <ref> [34] </ref>, support explicit activity decomposition, and thus, it is relatively straightforward to move between levels of granularity. <p> These aspects must be addressed through process languages. In this section we discuss alternative approaches that provide support using one or more languages. One Semantically-Broad Language: One approach to supporting software processes is through a single, semantically broad language. Examples of such languages include APPL/A <ref> [34] </ref>, Merlin [22], Adele [7], and AP5 [8]. This approach has several benefits. The use of a single language provides comprehensive and integrated syntax and semantics across multiple process aspects and subdomains. In turn, one language is usually easier to learn, understand, analyze, and use than multiple languages. <p> It necessarily has a high semantic level, medium semantic breadth, and shallow semantic depth, and it is not intended to support execution. * APPL/A <ref> [34] </ref>, Merlin [22], Marvel [23], and EPOS [10] are intended to produce fully executable process programs. They require the ability to support a broad range of functionality, with semantics sufficiently deep to enable execution. <p> See Section 2.8 for a discussion. 16 Meta-data, reflectivity, and dynamism have been supported in various ways and for different purposes. APPL/A <ref> [34] </ref> programs typically include some programmed representation of activity and artifact state, defined using more general-purpose constructs. These are typically used for dynamic process control. <p> Other techniques include, for example, type and data evolution (e.g., [24]), late and dynamic binding, dynamic linking, tool buses [31], object request broker architectures [12], and programming techniques, such as subjectivity [16], object roles in Adele [6], and program design techniques to support evolution, like intermittent execution <ref> [34] </ref>. All of these techniques have benefits and may be 3 "Separation of concerns is a common-sense practice that we try to follow in our everyday life to master the difficulties we encounter. <p> Design, architectures, requirements, and evaluative material are essential as well. This variety of artifacts is necessary to assure that needs other than the need to execute on a computer can be met. The same seems to be true in the process domain. Process code (such as APPL/A <ref> [34] </ref>, Marvel [23], etc.) supports process execution, but there are other needs as well (e.g., group coordination) that are better met by design artifacts such as process models. Thus, the steady growth of interest in process modelling, process architecture, and process measurement tools and technologies seems expectable.
Reference: [35] <author> Masato Suzuki and Takuya Katayama. </author> <title> Meta-operations in the process model HFSP for the dynamics and flexibility of software processes. </title> <booktitle> In Proc. of the First International Conference on the Software Process, </booktitle> <pages> pages 202 - 217, </pages> <address> 1991. Redondo Beach, California, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: Although resources are a very important part of production process description and execution, few systems support their definition explicitly. For example, AP5, APPL/A, Hakoniwa [21], HFSP <ref> [35] </ref>, Marvel, Pleiades [36], and SLANG provide no predefined mechanisms for resource definition (beyond their artifact and activity definition formalisms). The few systems that do provide some degree of support typically provide descriptions only of human resources and tools (e.g., Teamware and EPOS). <p> Connections among higher- and lower-levels of activity descriptions have also received varying treatment. Some languages, like MVP-L [33], HFSP <ref> [35] </ref>, SLANG, and APPL/A [34], support explicit activity decomposition, and thus, it is relatively straightforward to move between levels of granularity. <p> This is a particular application of the general principles enunciated in Section 2.1 and elaborated in Section 2.8. 2.8 Meta-Processes An important distinction in software processes is between production processes and meta-processes <ref> [3, 9, 35] </ref>. Production processes, which are the focus of this paper, support the development and maintenance of software products. Meta-processes are essential to production processes, since meta-processes effect the creation, execution, management, and evolution of production processes.
Reference: [36] <author> Peri L. Tarr and Lori A. Clarke. PLEIADES: </author> <title> An Object Management System for Software Engineering Environments. </title> <booktitle> In ACM SIGSOFT '93 Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 56-70, </pages> <address> Los Angeles, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Although resources are a very important part of production process description and execution, few systems support their definition explicitly. For example, AP5, APPL/A, Hakoniwa [21], HFSP [35], Marvel, Pleiades <ref> [36] </ref>, and SLANG provide no predefined mechanisms for resource definition (beyond their artifact and activity definition formalisms). The few systems that do provide some degree of support typically provide descriptions only of human resources and tools (e.g., Teamware and EPOS). <p> This approach has been adopted in Marvel, Merlin, SLANG, and GRAPPLE [20]. Other languages support the definition of artifacts at any level of granularity. For example, APPL/A, Adele [6], AP5 [8], and Pleiades <ref> [36] </ref> are based on general-purpose programming languages, and they provide rich type models that support the fine-grained definition and manipulation of artifacts. Treatment of connections among higher- and lower-levels of activity descriptions has been variable. <p> See Section 2.8 for a discussion. 16 Meta-data, reflectivity, and dynamism have been supported in various ways and for different purposes. APPL/A [34] programs typically include some programmed representation of activity and artifact state, defined using more general-purpose constructs. These are typically used for dynamic process control. Pleiades <ref> [36] </ref> provides dynamic information about artifact type and instance definitions, and dynamic control over several object management capabilities, including persistence and the enforcement of constraints on artifacts. These capabilities are used, for example, to reason about the states of artifacts and to plan modifications to them accordingly.
Reference: [37] <author> Patrick S. Young. </author> <title> Customizable Process Specification and Enactment for Technical and Non-Technical Users. </title> <type> PhD thesis, </type> <institution> University of California at Irvine, </institution> <year> 1994. </year> <month> 25 </month>
Reference-contexts: For example, rule-based systems, such as Marvel [23] and Merlin, support reactive control well, but they can only simulate proactive control via appropriate programmer-defined pre- and post-conditions, which is difficult and 7 awkward. State-based and net-based languages, such as Teamware <ref> [37] </ref>, Process Weaver [13], and SLANG [4], support proactive control, but they do not readily support reactive control. As a result, they are awkward to use for describing reactions to contingencies. Resources: Production processes make use of many different kinds of resources. <p> Changes must be carefully considered and well supported by good insights and intuitions. Thus, superior pictorial visualizations of such processes may be important assets for process modification. One common approach to process visualization, which was taken in IDEF0 [32], Process Weaver [13], and Teamware <ref> [37] </ref>, is to use a single pictorial representation to define software processes. Most of these representations depict process activities and their interrelationships as graphs with nodes (activities) and edges (interrelationships). Some representations provide different depictions to show different kinds of process activities and interrelationships. <p> A variety of positions in the semantic space are taken by current process languages. Some representative examples are: * ProSLCSE [26], IDEF-0 [32], Process Weaver [13], and Teamware <ref> [37] </ref> help to orchestrate, and may partially automate, process tasks and tools. They have a high semantic level, but their breadth is narrow, even in describing process activities.
References-found: 37

