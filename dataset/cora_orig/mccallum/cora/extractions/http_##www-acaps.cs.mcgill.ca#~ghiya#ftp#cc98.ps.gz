URL: http://www-acaps.cs.mcgill.ca/~ghiya/ftp/cc98.ps.gz
Refering-URL: http://www.csd.uu.se/~thomasl/wpo/alias-papers.html
Root-URL: 
Email: fghiya,hendren,yingg@cs.mcgill.ca  
Title: Detecting Parallelism in C Programs with Recursive Data Structures  
Author: Rakesh Ghiya, Laurie J. Hendren and Yingchun Zhu 
Address: Montreal, CANADA H3A 2A7  
Affiliation: School of Computer Science, McGill University  
Abstract: In this paper we present techniques to detect three common patterns of parallelism in C programs that use recursive data structures. These patterns include, function calls that access disjoint sub-pieces of tree-like data structures, pointer-chasing loops that traverse list-like data structures, and array-based loops which operate on an array of pointers pointing to disjoint data structures. We design dependence tests using a family of three existing pointer analyses, namely points-to, connection and shape analyses, with special emphasis on shape analysis. To identify loop parallelism, we introduce special tests for detecting loop-carried dependences in the context of recursive data structures. We have implemented the tests in the framework of our McCAT C compiler, and we present some preliminary experimental results. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive inter-procedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Thus, our approach uses the results of the family of pointer analyses that have been implemented in the McCAT optimizing/parallelizing C compiler: points-to analysis <ref> [1] </ref>, connection analysis [2] and shape analysis [3]. Points-to analysis is used to detect dependences due to scalars and stack-directed pointers, while connection and shape analysis are used to detect dependences due to heap-directed pointers. <p> The test depTest proceeds in a hierarchical fashion. Given two statements, stmtS and stmtT, and the type of dependence to be detected (flow, anti or output), it first applies the stackTest to disambiguate direct/indirect references to the stack. This test uses the results of points-to analysis <ref> [1] </ref>, which estimates targets of stack-directed pointers as points-to triples of the form (ptr, target, possible/definite). If the dependence cannot be disproved, the test then checks if the dependence is only due to heap accesses. In this case, heap analysis information is used. First, the test connectionTest is applied.
Reference: 2. <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Connection Analysis: A practical interpro-cedural heap analysis for C. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 24(6), </volume> <pages> pages 547-578, </pages> <year> 1996. </year>
Reference-contexts: Thus, our approach uses the results of the family of pointer analyses that have been implemented in the McCAT optimizing/parallelizing C compiler: points-to analysis [1], connection analysis <ref> [2] </ref> and shape analysis [3]. Points-to analysis is used to detect dependences due to scalars and stack-directed pointers, while connection and shape analysis are used to detect dependences due to heap-directed pointers. <p> In this case, heap analysis information is used. First, the test connectionTest is applied. This test uses connection-based heap read/write sets to identify if the two statements access heap locations be-longing to disjoint heap data structures <ref> [2, 4] </ref>. If the test succeeds, statements are reported independent. Otherwise the test shapeTest is invoked to further identify if the statements access disjoint sub-pieces of a data structure. This is the focus of this paper.
Reference: 3. <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Is it a tree, a DAG, or a cyclic graph? a shape analysis for heap-directed pointers in C. </title> <booktitle> In Conference Record of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <address> St. Petersburg, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Thus, our approach uses the results of the family of pointer analyses that have been implemented in the McCAT optimizing/parallelizing C compiler: points-to analysis [1], connection analysis [2] and shape analysis <ref> [3] </ref>. Points-to analysis is used to detect dependences due to scalars and stack-directed pointers, while connection and shape analysis are used to detect dependences due to heap-directed pointers. <p> Checking if two Statements are Dependent The test shapeTest uses shape analysis information <ref> [3] </ref>. Shape analysis estimates the shape of the data structure accessible from a given heap-directed pointer: is it tree-like, DAG-like or a general graph containing cycles? Knowledge about the shape of the data structure accessible from a heap-directed pointer, provides crucial information for disambiguating heap accesses originating from it.
Reference: 4. <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Putting Pointer Analysis to Work. </title> <booktitle> In Conference Record of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, </address> <month> January </month> <year> 1998. </year>
Reference-contexts: In this case, heap analysis information is used. First, the test connectionTest is applied. This test uses connection-based heap read/write sets to identify if the two statements access heap locations be-longing to disjoint heap data structures <ref> [2, 4] </ref>. If the test succeeds, statements are reported independent. Otherwise the test shapeTest is invoked to further identify if the statements access disjoint sub-pieces of a data structure. This is the focus of this paper. <p> If the test succeeds, statements are reported independent. Otherwise the test shapeTest is invoked to further identify if the statements access disjoint sub-pieces of a data structure. This is the focus of this paper. Detailed description of the first two tests can be found in <ref> [4, 5] </ref>. fun depTest (stmtS, stmtT, depType) = if (stackTest (stmtS, stmtT, depType) == NoDep) return NoDep; /* no dependence */ /* use heap analyses if dependence only due to heap */ else if (stackTest (stmtS, stmtT, depType) == OnlyHeap) if (connectionTest (stmtS, stmtT, depType) == NoDep) return NoDep; /* access <p> To identify it as a real foreach loop, we use existing tests implemented in the McCAT C compiler to check against LCDs induced by accesses to scalar variables, array references [11, 12], and stack-based indirect references <ref> [4] </ref>. If the only LCD detected is with respect to the navigator, the loop is flagged as a real foreach loop.
Reference: 5. <author> Rakesh Ghiya. </author> <title> Putting Pointer Analysis to Work. </title> <type> PhD Thesis, </type> <institution> School of Computer Science, McGill University, Montreal, Canada. </institution> <month> February </month> <year> 1998. </year> <title> Expected. </title>
Reference-contexts: If the test succeeds, statements are reported independent. Otherwise the test shapeTest is invoked to further identify if the statements access disjoint sub-pieces of a data structure. This is the focus of this paper. Detailed description of the first two tests can be found in <ref> [4, 5] </ref>. fun depTest (stmtS, stmtT, depType) = if (stackTest (stmtS, stmtT, depType) == NoDep) return NoDep; /* no dependence */ /* use heap analyses if dependence only due to heap */ else if (stackTest (stmtS, stmtT, depType) == OnlyHeap) if (connectionTest (stmtS, stmtT, depType) == NoDep) return NoDep; /* access <p> Definition chains are constructed by recursively traversing the reaching definitions of the given pointers, as illustrated by the following example. The complete algorithm is presented in <ref> [5] </ref>. Consider the construction of the definition chain for the use of pointer tr at the function call statement N: treeAdd (tr) in Figure 1 (a). The definition that reaches this use is from the statement M: tr = t-&gt;right. So this statement is put in the definition chain. <p> In general, the definition chain traversal stops when either it has reached the function header, or it cannot find a unique definition that definitely reaches the given use <ref> [5] </ref>. This ensures that we construct only one definite access path for a given pointer, and not a set of possible paths. This is done for efficiency reasons, as comparing a set of paths can be expensive and further is less likely to disprove a dependence. <p> The detailed algorithms for finding the anchor and constructing the access paths can be found in <ref> [5] </ref>. Comparing Access Paths for Dependence Detection The access paths are given to the function checkPathExprs, which detects if they definitely lead to disjoint parts of the data structure. <p> However, it only considers the definitions that arise from a statement within the given loop (loop-resident definitions). It terminates when either it cannot find a unique loop-resident definition that definitely reaches the given use, or it encounters a loop-resident definition for the second time <ref> [5] </ref>. In the latter case a recurrence is reported. If the traversal terminates without finding a recurrence, it returns Null, indicating that a navigator cannot be detected. <p> Here, since the navigator is identical to the loop test variable, the navigator expression is same as the test expression. More detailed examples for navigator identification can be found in <ref> [5] </ref>. 4.2 Verifying the Navigator Once a navigator is identified, and a navigator expression is constructed, the next step is to verify if the navigator visits a distinct node in the data structure in each iteration. <p> Thus, the function findNavigator checks that none of the fields in the navigator expression (navigator fields) are updated inside the loop. For this purpose connection-based heap read/write sets are used <ref> [5] </ref>. This check ensures that the navigator advances in a regular fashion from one iteration to the next iteration, i.e., the fields along which the data structure is navigated remain static through the loop execution. <p> We are presently working on analyzing and collecting runtime performance improvement statistics for a larger set of benchmarks. 6 Related Work A considerable amount of work has been done on the problem of pointer analysis itself, and a detailed discussion can be found in <ref> [5] </ref>. More directly related to this paper are methods that use the results of heap pointer analysis in the context of dependence analysis and parallelization.
Reference: 6. <author> Vincent A. Guarna, Jr. </author> <title> A technique for analyzing pointer and structure references in parallel restructuring compilers. </title> <booktitle> In Proceedings of the 1988 International Conference on Parallel Processing, </booktitle> <volume> volume II, </volume> <pages> pages 212-220, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: More directly related to this paper are methods that use the results of heap pointer analysis in the context of dependence analysis and parallelization. The approaches include: techniques using path expressions to name locations [13], using syntax trees to name locations <ref> [6] </ref>, extending k-limited graphs with location names [9]; and dependence analysis based on shape information and path expressions [8]. The focus of these techniques is on identifying function-call parallelism for recursive data structures, and the heap analyses used are substantially more complex than our connection and shape analyses.
Reference: 7. <author> Joseph Hummel, Laurie J. Hendren, and Alexandru Nicolau. </author> <title> A general data dependence test for dynamic, pointer-based data structures. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 218-229, </pages> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Further, they do not consider the detection of loop parallelism, and also do not consider the presence of stack-directed pointers. In contrast to the above techniques which are based on automatic heap analysis, Hummel et al. <ref> [7] </ref> use a language-based approach. They rely on the programmer to provide the information about the shape of the data structure via aliasing axioms. To compute dependence between two statements, they collect access paths with respect to an anchor.
Reference: 8. <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The approaches include: techniques using path expressions to name locations [13], using syntax trees to name locations [6], extending k-limited graphs with location names [9]; and dependence analysis based on shape information and path expressions <ref> [8] </ref>. The focus of these techniques is on identifying function-call parallelism for recursive data structures, and the heap analyses used are substantially more complex than our connection and shape analyses. Further, they do not consider the detection of loop parallelism, and also do not consider the presence of stack-directed pointers.
Reference: 9. <author> Susan Horwitz, Phil Pfeiffer, and Thomas Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: More directly related to this paper are methods that use the results of heap pointer analysis in the context of dependence analysis and parallelization. The approaches include: techniques using path expressions to name locations [13], using syntax trees to name locations [6], extending k-limited graphs with location names <ref> [9] </ref>; and dependence analysis based on shape information and path expressions [8]. The focus of these techniques is on identifying function-call parallelism for recursive data structures, and the heap analyses used are substantially more complex than our connection and shape analyses.
Reference: 10. <author> Laurie J. Hendren, Xinan Tang, Yingchun Zhu, Guang R. Gao, Xun Xue, Haiying Cai, and Pierre Ouellet. </author> <title> Compiling C for the EARTH multithreaded architecture. </title> <booktitle> In Proceedings of the 1996 Conference on Parallel Architectures and Compilation Techniques (PACT '96), </booktitle> <pages> pages 12-23, </pages> <address> Boston, Massachusetts, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: The benchmarks pug and circuit use cyclic data structures, but perform majority of their computation inside acyclic list-traversing loops, which are detected as foreach loops by the heapLCD test. Finally, the hand-written Earth-C <ref> [10] </ref> versions of the benchmarks treeadd and power, that only use the parallelism detected by our dependence tests, respectively obtain speed-up by factors of 16 and 12 on the EARTH-MANNA multithreaded machine [10] using 16 processors. <p> Finally, the hand-written Earth-C <ref> [10] </ref> versions of the benchmarks treeadd and power, that only use the parallelism detected by our dependence tests, respectively obtain speed-up by factors of 16 and 12 on the EARTH-MANNA multithreaded machine [10] using 16 processors. We are presently working on analyzing and collecting runtime performance improvement statistics for a larger set of benchmarks. 6 Related Work A considerable amount of work has been done on the problem of pointer analysis itself, and a detailed discussion can be found in [5].
Reference: 11. <author> Justiani. </author> <title> An array dependence testing framework for the McCAT compiler. </title> <type> Master's thesis, </type> <institution> McGill University, </institution> <address> Montreal, Quebec, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: To identify it as a real foreach loop, we use existing tests implemented in the McCAT C compiler to check against LCDs induced by accesses to scalar variables, array references <ref> [11, 12] </ref>, and stack-based indirect references [4]. If the only LCD detected is with respect to the navigator, the loop is flagged as a real foreach loop. <p> Further, if it needs to compare access paths of the form list arr [i + j] and list arr [i + k], it uses subscript tests from array dependence testing <ref> [11, 12] </ref>, to identify LCDs. 5 Experimental Results We have implemented the dependence tests described in sections 3 and 4 in the framework of our McCAT C compiler. We have done a preliminary study of their effectiveness on a set of four recursive data structure based C benchmark programs.
Reference: 12. <author> Christopher Lapkowski. </author> <title> A practical symbolic array dependence analysis framework for C. </title> <type> Master's thesis, </type> <institution> McGill University, </institution> <address> Montreal, Quebec, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: To identify it as a real foreach loop, we use existing tests implemented in the McCAT C compiler to check against LCDs induced by accesses to scalar variables, array references <ref> [11, 12] </ref>, and stack-based indirect references [4]. If the only LCD detected is with respect to the navigator, the loop is flagged as a real foreach loop. <p> Further, if it needs to compare access paths of the form list arr [i + j] and list arr [i + k], it uses subscript tests from array dependence testing <ref> [11, 12] </ref>, to identify LCDs. 5 Experimental Results We have implemented the dependence tests described in sections 3 and 4 in the framework of our McCAT C compiler. We have done a preliminary study of their effectiveness on a set of four recursive data structure based C benchmark programs.
Reference: 13. <author> James R. Larus and Paul N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <address> Atlanta, Georgia, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: More directly related to this paper are methods that use the results of heap pointer analysis in the context of dependence analysis and parallelization. The approaches include: techniques using path expressions to name locations <ref> [13] </ref>, using syntax trees to name locations [6], extending k-limited graphs with location names [9]; and dependence analysis based on shape information and path expressions [8].
Reference: 14. <author> Bhama Sridharan. </author> <title> An analysis framework for the McCAT compiler. </title> <type> Master's thesis, </type> <institution> McGill University, </institution> <address> Montreal, Quebec, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: The overall algorithm for the test depTest is outlined in Figure 3. It has been implemented at the high level Simple intermediate representation of the McCAT C compiler <ref> [14] </ref>. The test depTest proceeds in a hierarchical fashion. Given two statements, stmtS and stmtT, and the type of dependence to be detected (flow, anti or output), it first applies the stackTest to disambiguate direct/indirect references to the stack.
Reference: 15. <author> Xinan Tang, Rakesh Ghiya, L. J. Hendren, and G. R. Gao. </author> <title> Heap analysis and optimizations for threaded programs. </title> <booktitle> In Proceedings of the 1997 Conference on Parallel Architectures and Compilation Techniques, </booktitle> <address> San Franc., Calif., </address> <month> Nov. </month> <year> 1997. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Above, we have described our overall strategy for detecting dependence between two given statements in a function, and discussed in detail how to use shape information for dependence testing. We use the test (depTest) during the DDG (data dependence graph) construction phase of the EARTH-McCAT compiler <ref> [15] </ref>. The DDG is then used to identify statements/function calls that can be executed in parallel, and to partition the program into threads. 4 Loop Parallelism In this section, we present techniques to identify loop-level parallelism, in the form of forall and foreach loops traversing recursive heap data structures.
References-found: 15

