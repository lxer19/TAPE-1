URL: http://www.cs.colostate.edu/~ftppub/TechReports/1997/tr97-114.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Email: fmathew, dahlman, guptag@cs.colostate.edu  
Phone: Phone: (970) 491-5792 Fax: (970) 491-2466  
Title: Compiling Java to SUIF: Incorporating Support for Object-Oriented Languages  
Author: Sumith Mathew, Eric Dahlman and Sandeep Gupta 
Web: WWW: http://www.cs.colostate.edu  
Date: July 1997  
Address: Fort Collins, CO 80523  Fort Collins, CO 80523-1873  
Affiliation: Computer Science Department Colorado State University,  Computer Science Department Colorado State University  
Pubnum: Technical Report CS-97-114  
Abstract: Computer Science Technical Report 
Abstract-found: 1
Intro-found: 1
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers. Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Heavy use of the feature of dynamic dispatch and the fact that methods tend to be small in size impose performance penalties when the programs are compiled using traditional intraprocedural techniques <ref> [ASU86] </ref>. Optimization techniques [Dea96, DDG + 96, Ple96, Cha92] have been proposed which have a direct benefit of eliminating the overhead of dynamic dispatch by statically determining the receiver of a method call. Moreover greater indirect benefits are obtained by enabling inlining and hence further intraprocedural optimizations.
Reference: [Bot97] <author> Per Bothner. </author> <title> A gcc-based java implementation. </title> <booktitle> In IEEE Compcon '97, </booktitle> <year> 1997. </year>
Reference-contexts: All the information for the class meta-data is available in the constant pool. This is implemented in the form of annotations to the file symbol table in the SUIF representation. The SUIF compiler pass would have to collect this information and statically allocate and initialize these internal data structures <ref> [Bot97] </ref>. 3.6 Static/Class Methods and Fields One of way of maintaining static or per-class information is by creating static data structures and having an appropriate naming scheme to identify the different structures. Static or class methods and fields can also be supported by the presence of a meta-class.
Reference: [Cha92] <author> Craig Chambers. </author> <title> The design and implementation of the SELF compiler. an optimizing compiler for object-oriented languages. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Heavy use of the feature of dynamic dispatch and the fact that methods tend to be small in size impose performance penalties when the programs are compiled using traditional intraprocedural techniques [ASU86]. Optimization techniques <ref> [Dea96, DDG + 96, Ple96, Cha92] </ref> have been proposed which have a direct benefit of eliminating the overhead of dynamic dispatch by statically determining the receiver of a method call. Moreover greater indirect benefits are obtained by enabling inlining and hence further intraprocedural optimizations.
Reference: [DDG + 96] <author> J. Dean, G. DeFouw, D. Grove, V. Litvinov, and C. Chambers. </author> <title> Vortex: An optimizing compiler for object-oriented languages. </title> <booktitle> In OOPSLA '96, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Heavy use of the feature of dynamic dispatch and the fact that methods tend to be small in size impose performance penalties when the programs are compiled using traditional intraprocedural techniques [ASU86]. Optimization techniques <ref> [Dea96, DDG + 96, Ple96, Cha92] </ref> have been proposed which have a direct benefit of eliminating the overhead of dynamic dispatch by statically determining the receiver of a method call. Moreover greater indirect benefits are obtained by enabling inlining and hence further intraprocedural optimizations.
Reference: [Dea96] <author> Jeffery Dean. </author> <title> Whole-program optimization of object-oriented languages. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <address> Seattle, </address> <year> 1996. </year>
Reference-contexts: Heavy use of the feature of dynamic dispatch and the fact that methods tend to be small in size impose performance penalties when the programs are compiled using traditional intraprocedural techniques [ASU86]. Optimization techniques <ref> [Dea96, DDG + 96, Ple96, Cha92] </ref> have been proposed which have a direct benefit of eliminating the overhead of dynamic dispatch by statically determining the receiver of a method call. Moreover greater indirect benefits are obtained by enabling inlining and hence further intraprocedural optimizations.
Reference: [DMM96] <author> Amer Diwan, J. Eliot B. Moss, and Kathryn S. McKinley. </author> <title> Simple and effective analysis of statically-typed object-oriented programs. </title> <booktitle> In OOPSLA '96, </booktitle> <year> 1996. </year>
Reference-contexts: This is the starting point for most optimizations based on static type analysis and propagation <ref> [DMM96] </ref>. Therefore object creation instructions need to be represented as a high-level construct in the intermediate code. 3.3 Method Invocation Method invocation constructs are necessary as they are the primary targets of optimization in object-oriented languages.
Reference: [Gro94] <institution> Stanford Compiler Group. </institution> <address> The SUIF Library. Stanford University, </address> <year> 1994. </year> <month> 9 </month>
Reference-contexts: Also, the framework needs to be language-independent so that programs of different object-oriented languages can get comparable treatment. An intermediate representation can act as the interface between different language front-ends and the optimizing back-end. SUIF <ref> [Gro94] </ref> is a compiler infrastructure that allows easy experimentation and incremental optimization through multiple passes. The feature of extensibility [Smi96] makes it possible for SUIF to support many user-defined constructs. Also, SUIF has built in support for interprocedural optimizations [Pan96] and parallelization. <p> The store instructions in the bytecode generally denote the end of an expression tree. Instructions 4-9 in the bytecode are translated to instructions 5-8 in SUIF. 2.3 Annotations for Object-Oriented Features Annotations are used to provide flexibility and extensibility to the intermediate representation <ref> [Gro94] </ref>. We use annotations to record information that is specific to object-oriented languages extensively. tree instructions. The various elements of the Java program that are represented or enhanced by annotations are: * Class Hierarchy: The superclass of each class is represented by an annotation to the file symbol table. <p> These are implemented by function calls that lookup the information in the meta-class object. 3 SUIF Support for Object-Oriented Features Current versions of SUIF do not support object-oriented constructs. The intermediate representation is a mixed-level representation <ref> [Gro94] </ref> for procedural languages. The only high-level constructs supported are loops, conditional statements and array accesses. This section deals with the various object-oriented constructs and other features that are present in Java that need to be supported for the purposes of optimization.
Reference: [LY97] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison Wesley, </publisher> <year> 1997. </year>
Reference-contexts: The stand alone approach would require a run-time environment that duplicates many of the services that are provided by the Virtual Machine. 2.2 Converting Stack-Based Instructions to Three Address Code A Java Virtual Machine instruction <ref> [LY97] </ref> consists of a one-byte opcode specifying the operation followed by zero or more operands supplying the arguments. The bytecode instructions are stack-based instructions. The translation procedure converts it to three-address code (SUIF expression tree). The inner loop of the translation procedure is given in Figure 2. <p> The process of loading a string literal from the constant pool requires the creation of a new String object. 2.5 Handling Object-Oriented Constructs In the interpreted version, Java classes and interfaces are dynamically loaded, linked and initialized <ref> [LY97] </ref>. During the process of loading the class, the meta-data or Class object (see section 3.6) for the class is created from the binary file. The loaded binary class files are then linked to the Virtual Machine.
Reference: [OSU] <institution> OSUIF. http://www.cs.ucsb.edu/~osuif. OSUIF Home Page at UCSB. </institution>
Reference-contexts: The development of the j2s tool is part of a larger project to implement a new optimization scheme for object-oriented languages. There are other efforts at extending SUIF to support object-oriented languages. A notable project is the OSUIF project being undertaken at the University of California, Santa Barbara <ref> [OSU] </ref>. They are developing a scheme to add support for class representation, dynamic dispatch and exceptions to SUIF.
Reference: [Pan96] <author> Hemant Pande. </author> <title> Compile time analysis of C and C++ programs. </title> <type> PhD thesis, </type> <institution> Rutgers, The State University of New Jersey, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: SUIF [Gro94] is a compiler infrastructure that allows easy experimentation and incremental optimization through multiple passes. The feature of extensibility [Smi96] makes it possible for SUIF to support many user-defined constructs. Also, SUIF has built in support for interprocedural optimizations <ref> [Pan96] </ref> and parallelization.
Reference: [Ple96] <author> J. B. Plevyak. </author> <title> Optimization of object-oriented and concurrent programs. </title> <type> PhD thesis, </type> <institution> University of Illinois, Urbana-Champaign, </institution> <year> 1996. </year>
Reference-contexts: Heavy use of the feature of dynamic dispatch and the fact that methods tend to be small in size impose performance penalties when the programs are compiled using traditional intraprocedural techniques [ASU86]. Optimization techniques <ref> [Dea96, DDG + 96, Ple96, Cha92] </ref> have been proposed which have a direct benefit of eliminating the overhead of dynamic dispatch by statically determining the receiver of a method call. Moreover greater indirect benefits are obtained by enabling inlining and hence further intraprocedural optimizations.
Reference: [Smi96] <author> Michael D. Smith. </author> <title> Extending SUIF for machine-dependant optimizations. </title> <booktitle> In First SUIF Compiler Workshop, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: An intermediate representation can act as the interface between different language front-ends and the optimizing back-end. SUIF [Gro94] is a compiler infrastructure that allows easy experimentation and incremental optimization through multiple passes. The feature of extensibility <ref> [Smi96] </ref> makes it possible for SUIF to support many user-defined constructs. Also, SUIF has built in support for interprocedural optimizations [Pan96] and parallelization.
Reference: [WM95] <author> Reinhard Willhelm and Dieter Maurer. </author> <title> Compiler Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Java has three different kinds of reference data types: * Objects: Object manipulation instructions are translated into operations that are supported by SUIF. Object references are pointers to a handle. However, the object layout is an implementation issue. This translator uses the C++ object model <ref> [WM95] </ref>. All field and method accesses to objects are handled via a process of constant pool resolution which is detailed later in this section. * Arrays: Unlike in C, Java arrays are objects. All array operations are performed through method dispatch.
Reference: [Yel96] <author> Frank Yellin. </author> <title> The JIT compiler API. </title> <publisher> Sun Microsystems Inc., </publisher> <month> October </month> <year> 1996. </year> <note> White paper. </note>
Reference-contexts: In either case all the component bytecode files are required to be available at compile time. Dynamic loading is not currently supported. There are two ways of interfacing compiled code with Sun's Java Virtual Machine using the Native Method Interface or the JIT (Just-In-Time) 2 API <ref> [Yel96] </ref>.
Reference: [ZCG94] <author> B. Zorn, B. Calder, and D. Grunwald. </author> <title> Quantifying differences between C and C++ programs. </title> <type> Technical Report CU-CS-698-94, </type> <institution> University of Colorado, Boulder, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: However, the use of these features results in code that is quite different in structure from procedural code. Object-oriented programs tend to have smaller method sizes, data-dependent control flow due to dynamic dispatch and a large number of potential aliases <ref> [ZCG94] </ref>. Heavy use of the feature of dynamic dispatch and the fact that methods tend to be small in size impose performance penalties when the programs are compiled using traditional intraprocedural techniques [ASU86].
References-found: 15

