URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1993/GIT-CC-93-32.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.93.html
Root-URL: 
Email: hernan@cc.gatech.edu shilling@cc.gatech.edu  
Title: Reorganizing Split Objects  
Author: Hernan Astudillo R. John J. Shilling 
Date: 2, 1993  
Note: July  
Abstract: Technical Report GIT-CS-93/32 College of Computing Georgia Institute of Technology Atlanta, Georgia 30332-0280 Abstract Object-based (i.e. classless) models are very effective for elucidating requirements from users, and they support exploratory programming and rapid prototyping. On the other hand, class-based models are preferred to perform design and implementation, providing descriptive power and some types of error checking. We consider the evolution of object-based models into class-based production systems. One of the most difficult problems of this transition is the change from explicit description of individuals to implicit description of class instances. Reorganization support aims to make the system structures and properties evident and enforceable. Structural properties are useful to organize the code regardless of its meaning, and automated support can be enlisted to identify potential structures and properties, leaving the programmer with choice of alternative workspace organizations. We analyze the organization and management of classless objects, regarding the goals of redundancy elimination and consistency maintenance, and how these goals are complicated by the existence of two mechanisms of object creation, cloning and extension (split objects). We present a classification of sharing and extension patterns in terms of the two basic mechanisms, and examine their interaction and effect. 
Abstract-found: 1
Intro-found: 1
Reference: [Boo90] <author> Grady Booch. </author> <title> Object-Oriented Design with Appications. </title> <booktitle> Benjamin/Cummings series in Ada and software engineering. </booktitle> <address> Benjamin/Cummings, Redwood City, CA, </address> <year> 1990. </year>
Reference-contexts: Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; [BS84, Gom83]; and provide the flexible development needed for rapid prototyping [GS81]. Other experiences have shown <ref> [MP92, WBJ90, Boo90, Mey88] </ref> that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability. Classes [GR89] turn the explicit description of individual objects into an intensional description of groups of objects; this simplifies the system description, allows code reuse, and supports change propagation.
Reference: [BS84] <author> Reinhard Budde and K. Sylla. </author> <title> From application domain modelling to target system. </title> <editor> In Reinhard Budde, K. Kuhlenkamp, L. Mathiassen, and H. Zullighoven, editors, </editor> <title> Approaches to Prototyping: </title> <booktitle> Proceedings of the Working Conference on Prototyping, </booktitle> <pages> pages 31-48, </pages> <address> Berlin & New York, Namur, Belgium, </address> <year> 1983 1984. </year> <institution> Gesellschaft fur Mathematik und Datenverarbeitung mbH, Springer-Verlag. </institution>
Reference-contexts: Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; <ref> [BS84, Gom83] </ref>; and provide the flexible development needed for rapid prototyping [GS81]. Other experiences have shown [MP92, WBJ90, Boo90, Mey88] that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability.
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> Dec </month> <year> 1985. </year>
Reference-contexts: The above mentioned approaches can be used to implement this one, as in fact Self [UCCH91] uses "maps" to support sharing among clones. * Implicit: the issue of sharing is abstracted into membership in a group denoted by a common description of features. This is the case in class-based <ref> [CW85] </ref> languages like Smalltalk [GR89] and C ++ [Str86], where "classes" hold both shared members and an implicit prototype.
Reference: [DMC92] <author> Christophe Dony, Jacques Malenfant, and Pierre Cointe. </author> <title> Prototype-based languages: From a new taxonomy to constructive proposals and their validation. </title> <editor> In Andreas Paepcke, editor, OOPSLA'92, </editor> <booktitle> 7th annual conference on object-oriented programming systems, languages, and applications, </booktitle> <pages> pages 201-217. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <address> Vancouver, British Columbia, Canada, </address> <month> 18-22 Oct </month> <year> 1992. </year>
Reference-contexts: Several representation options exist: * Delegation: an extended object is implemented as if having "components" [NGT92]: the new features are defined into an object, and the original object (s) become parents, remaining 4 5 untouched. Dony et al: call these split objects <ref> [DMC92] </ref>.
Reference: [Gom83] <author> H. Gomaa. </author> <title> The impact of rapid prototyping on specifying user requirements. </title> <journal> Software Engineering Notes, </journal> <volume> 8(2) </volume> <pages> 17-28, </pages> <year> 1983. </year>
Reference-contexts: Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; <ref> [BS84, Gom83] </ref>; and provide the flexible development needed for rapid prototyping [GS81]. Other experiences have shown [MP92, WBJ90, Boo90, Mey88] that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability.
Reference: [GR89] <author> Adele Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language. </title> <publisher> Addison-Wesley series in computer science. Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Other experiences have shown [MP92, WBJ90, Boo90, Mey88] that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability. Classes <ref> [GR89] </ref> turn the explicit description of individual objects into an intensional description of groups of objects; this simplifies the system description, allows code reuse, and supports change propagation. We believe that formalization of structure and classification is necessary if a development effort is to result in an industrial-strength system. <p> This is the case in class-based [CW85] languages like Smalltalk <ref> [GR89] </ref> and C ++ [Str86], where "classes" hold both shared members and an implicit prototype.
Reference: [GS81] <author> H. Gomaa and D. B. H. Scott. </author> <title> Prototyping as a tool in the specification of user requirements. </title> <editor> In ICSE, editor, </editor> <booktitle> 5th International Conference of Software Engineering, </booktitle> <pages> pages 333-342. </pages> <booktitle> IEEE and ACM SIGSOFT, IEEE Computer Society, </booktitle> <year> 1981. </year>
Reference-contexts: Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; [BS84, Gom83]; and provide the flexible development needed for rapid prototyping <ref> [GS81] </ref>. Other experiences have shown [MP92, WBJ90, Boo90, Mey88] that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability.
Reference: [HH82] <author> J. W. Hooper and P. Hsia. </author> <title> Scenario-based prototyping of requirements identification. </title> <journal> Software Engineering Notes, </journal> <volume> 7(5) </volume> <pages> 88-93, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction Recent research and practice have shown that object-oriented analysis (OOA) is a powerful tool for capturing system requirements in the early stages of development (for example, see [MP92, SM88, WBWW90, RBP + 91] for some assessment of several OOA techniques). Some of these techniques (e.g. <ref> [Ner92, HH82] </ref>) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements.
Reference: [Lie86] <author> Henry Lieberman. </author> <title> Using prototypical objects to implement shared behavior in object oriented systems. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <pages> pages 214-223. </pages> <publisher> ACM, ACM Press, </publisher> <address> Portland, Oregon, USA, </address> <month> Sept 29 - Oct 2 </month> <year> 1986. </year>
Reference-contexts: Some of these techniques (e.g. [Ner92, HH82]) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements. Object-based models allow the representation of concepts without a priori classifications; <ref> [Lie86] </ref>; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; [BS84, Gom83]; and provide the flexible development needed for rapid prototyping [GS81].
Reference: [MBK86] <author> Sanjay Mittal, Daniel G. Bobrow, and Kenneth M. Kahn. </author> <title> Virtual copies: At the boundary between classes and instances. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <pages> pages 159-166. </pages> <publisher> ACM, ACM Press, </publisher> <address> Portland, Oregon, USA, </address> <month> Sept 29 - Oct 2 </month> <year> 1986. </year>
Reference-contexts: This includes the Kevo language [Tai92], which provides sharing between apparently self-sufficient objects, and the "virtual copies" proposed by Mittal et al <ref> [MBK86] </ref>. * Via delegation: the sharing is explicit and visible to the programmer, who must determine what is shared and what is individual among clones.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Ciffs, NJ 07632, USA, </address> <year> 1988. </year>
Reference-contexts: Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; [BS84, Gom83]; and provide the flexible development needed for rapid prototyping [GS81]. Other experiences have shown <ref> [MP92, WBJ90, Boo90, Mey88] </ref> that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability. Classes [GR89] turn the explicit description of individual objects into an intensional description of groups of objects; this simplifies the system description, allows code reuse, and supports change propagation.
Reference: [MP92] <author> David E. Monarchi and Gretchen I. Puhr. </author> <title> A research typology for object-oriented analysis and design. </title> <journal> Communications of the ACM, </journal> <volume> 35(9) </volume> <pages> 35-47, </pages> <month> Sep </month> <year> 1992. </year> <month> 10 </month>
Reference-contexts: 1 Introduction Recent research and practice have shown that object-oriented analysis (OOA) is a powerful tool for capturing system requirements in the early stages of development (for example, see <ref> [MP92, SM88, WBWW90, RBP + 91] </ref> for some assessment of several OOA techniques). Some of these techniques (e.g. [Ner92, HH82]) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements. <p> Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; [BS84, Gom83]; and provide the flexible development needed for rapid prototyping [GS81]. Other experiences have shown <ref> [MP92, WBJ90, Boo90, Mey88] </ref> that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability. Classes [GR89] turn the explicit description of individual objects into an intensional description of groups of objects; this simplifies the system description, allows code reuse, and supports change propagation.
Reference: [Ner92] <author> Jean-Marc Nerson. </author> <title> Applying object-oriented analysis and design. </title> <journal> Communications of the ACM, </journal> <volume> 35(9) </volume> <pages> 63-74, </pages> <month> Sep </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Recent research and practice have shown that object-oriented analysis (OOA) is a powerful tool for capturing system requirements in the early stages of development (for example, see [MP92, SM88, WBWW90, RBP + 91] for some assessment of several OOA techniques). Some of these techniques (e.g. <ref> [Ner92, HH82] </ref>) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements.
Reference: [NGT92] <author> Oscar Nierstrasz, Simon Gibbs, and Dennis Tsichritzis. </author> <title> Component-oriented software development. </title> <journal> Communications of the ACM, </journal> <volume> 35(9) </volume> <pages> 160-165, </pages> <month> Sep </month> <year> 1992. </year>
Reference-contexts: The extended object is composed of the desired object (s), plus a new object containing any additional features (see Figure 3). Several representation options exist: * Delegation: an extended object is implemented as if having "components" <ref> [NGT92] </ref>: the new features are defined into an object, and the original object (s) become parents, remaining 4 5 untouched. Dony et al: call these split objects [DMC92].
Reference: [RBP + 91] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Ciffs, NJ 07632, USA, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Recent research and practice have shown that object-oriented analysis (OOA) is a powerful tool for capturing system requirements in the early stages of development (for example, see <ref> [MP92, SM88, WBWW90, RBP + 91] </ref> for some assessment of several OOA techniques). Some of these techniques (e.g. [Ner92, HH82]) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements.
Reference: [SM88] <author> S. Shlaer and S. J. Mellor. </author> <title> Object-Oriented Systems Analysis: Modeling the World in Data. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Ciffs, NJ 07632, USA, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Recent research and practice have shown that object-oriented analysis (OOA) is a powerful tool for capturing system requirements in the early stages of development (for example, see <ref> [MP92, SM88, WBWW90, RBP + 91] </ref> for some assessment of several OOA techniques). Some of these techniques (e.g. [Ner92, HH82]) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements.
Reference: [Ste87] <author> Lynn Andrea Stein. </author> <title> Delegation is inheritance. </title> <booktitle> In OOPSLA, editor, OOPSLA '87: Conference on Object Oriented Programming, Systems, Languages and Applications, </booktitle> <pages> pages 138-146. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <address> Orlando, FL, USA, </address> <month> 4-8 Oct </month> <year> 1987. </year>
Reference-contexts: This means that a traits extending another one must replicate it; however, this will not produce as much replication as the previous cases. The propagation of changes from the originally extended traits must be done 4 Not unlike the "cut-and-paste" paradigm. 5 In fact, Stein has shown <ref> [Ste87] </ref> that inheritance is subsumed by delegation. 6 Unless the system itself implements one of the other models beneath the programmer's interface, like Self's "maps" [UCCH91]. 6 7 immutable monolithic prototype split prototype part location (extension by concatenation) (extension by delegation) individual Figure 2 (a) Figure 2 (b) shared monolithic Figure
Reference: [Str86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley series in computer science. Addison-Wesley, </publisher> <address> 1st edition, </address> <year> 1986. </year>
Reference-contexts: This is the case in class-based [CW85] languages like Smalltalk [GR89] and C ++ <ref> [Str86] </ref>, where "classes" hold both shared members and an implicit prototype. <p> The first one is the way that C ++ objects are implemented <ref> [Str86] </ref>: a large table referencing the class members, and instances with inherited members as sub-parts. The third row considers object models which allow sharing of traits and that the traits itself be a split object. These two cases provide minimal replication for all immutable features in the object workspace.
Reference: [Tai92] <author> Antero Taivalsaari. </author> <title> Kevo a prototype-based object-oriented language based on concatenation and module operartions. </title> <type> Technical Report DCS-197-1R, </type> <institution> University of Victoria,, Victoria, British Columbia, CANADA, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: This alternative is mostly academic, since real systems would quickly suffer the effects of indiscriminate replication of essentially identical material. * System-simulated: the problem is acknowledged, but is is considered just an implementation issue underlying a programmer's vision of objects as fully autonomous. This includes the Kevo language <ref> [Tai92] </ref>, which provides sharing between apparently self-sufficient objects, and the "virtual copies" proposed by Mittal et al [MBK86]. * Via delegation: the sharing is explicit and visible to the programmer, who must determine what is shared and what is individual among clones. <p> avoids redundancy and facilitates change propagation, In Self, objects extended this way are called data-parents of their extensions. * Concatenation: a new object is built by copying the object to be extended and then modifying it to satisfy the required extension. 4 This is the extension paradigm used in Kevo <ref> [Tai92] </ref>. This model is conceptual cleaner than delegation, since it supports self-sufficient objects by avoiding dependencies; on the other hand, it suffers of possible inconsistencies and certainly of replication. <p> The programmer is not aware of object extension, but class extension can take its place. Smalltalk and C++ provide "subclassing", by which the implicit class-held prototypes are actually extended; instances created from a sub-class are themselves monolithic, even though classes themselves are both viewed and implemented as split objects <ref> [Tai92] </ref>. Implicit object extension can also be implemented using split objects or concatenation. 5 6 Interaction of policies Let's consider how the interaction of mechanism for redundancy elimination and for objects extension affects object organization modes.
Reference: [UCCH91] <author> David Ungar, Craig Chambers, Bay-Wei Chang, and Urs Holzle. </author> <title> Organizing programs without classes. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4(3), </volume> <month> Jun </month> <year> 1991. </year>
Reference-contexts: The above mentioned approaches can be used to implement this one, as in fact Self <ref> [UCCH91] </ref> uses "maps" to support sharing among clones. * Implicit: the issue of sharing is abstracted into membership in a group denoted by a common description of features. <p> The propagation of changes from the originally extended traits must be done 4 Not unlike the "cut-and-paste" paradigm. 5 In fact, Stein has shown [Ste87] that inheritance is subsumed by delegation. 6 Unless the system itself implements one of the other models beneath the programmer's interface, like Self's "maps" <ref> [UCCH91] </ref>. 6 7 immutable monolithic prototype split prototype part location (extension by concatenation) (extension by delegation) individual Figure 2 (a) Figure 2 (b) shared monolithic Figure 4 (c) Figure 4 (d) (traits) spli Figure 4 (a) Figure 4 (b) Table 1: Combining extension and factorization either separately (e.g. by a mechanism
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In OOPSLA, editor, OOPSLA '87: Conference on Object Oriented Programming, Systems, Languages and Applications, </booktitle> <pages> pages 227-241. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <address> Orlando, FL, USA, </address> <month> 4-8 Oct </month> <year> 1987. </year>
Reference-contexts: the model used in the Self 2 Sets created by description rather than enumeration. 3 We would like to remark here that the distinction between mutable/immutable traits is orthogonal to the one between data/methods; for example, callbacks and error handlers are certainly mutable features even in conventional programming. 3 language <ref> [US87] </ref>, where "traits" objects hold shared slots, and "prototypes" and their clones hold individual state.
Reference: [WBJ90] <author> Rebecca J. Wirfs-Brock and Ralph E. Johnson. </author> <title> Surveying current research in object-oriented design. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 105-124, </pages> <month> Sep </month> <year> 1990. </year>
Reference-contexts: Object-based models allow the representation of concepts without a priori classifications; [Lie86]; support a customer dialog in which similarities to and differences from concrete objects can be detected and discussed; [BS84, Gom83]; and provide the flexible development needed for rapid prototyping [GS81]. Other experiences have shown <ref> [MP92, WBJ90, Boo90, Mey88] </ref> that development stages after requirements analysis instead benefit greatly of structural and behavioral formalization and predictability. Classes [GR89] turn the explicit description of individual objects into an intensional description of groups of objects; this simplifies the system description, allows code reuse, and supports change propagation.
Reference: [WBWW90] <author> Rebecca J. Wirfs-Brock, B. Wilkerson, and L. Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Ciffs, NJ 07632, USA, </address> <year> 1990. </year> <month> 11 </month>
Reference-contexts: 1 Introduction Recent research and practice have shown that object-oriented analysis (OOA) is a powerful tool for capturing system requirements in the early stages of development (for example, see <ref> [MP92, SM88, WBWW90, RBP + 91] </ref> for some assessment of several OOA techniques). Some of these techniques (e.g. [Ner92, HH82]) make use of object-based models (i.e. with objects but no classes) due to their usefulness in representing real-world knowledge about the user's and system's domain and requirements.
References-found: 23

