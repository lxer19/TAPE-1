URL: http://www.tns.lcs.mit.edu/~djw/library/tr96-05.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/
Root-URL: 
Title: Making Paths Explicit in the Scout Operating System  
Author: David Mosberger and Larry L. Peterson 
Address: Tucson, AZ 85721  
Affiliation: Department of Computer Science The University of Arizona  
Date: TR 96-05  
Abstract: This paper makes a case for paths as an explicit abstraction in operating system design. Paths provide a unifying infrastructure for several OS mechanisms that have been introduced in the last several years, including fbufs, integrated layer processing, packet classifiers, code specialization, and migrating threads. This paper articulates the potential advantages of a path-based OS structure, describes the specific path architecture implemented in the Scout OS, and demonstrates the advantages in a particular application domainreceiving, decoding, and displaying MPEG-compressed video. 
Abstract-found: 1
Intro-found: 1
Reference: [AP93] <author> Mark B. Abbott and Larry L. Peterson. </author> <title> Increasing network throughput by integrating protocol layers. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5), </volume> <month> October </month> <year> 1993. </year>
Reference-contexts: Consider the following examples. * Fbufs [DP93] are a path-oriented buffer management mechanism designed to efficiently move data across a sequence of protection domains. 1 Fbufs depend on being able to identify the path through the system over which the data will flow. * Integrated layer processing (ILP) <ref> [CT90, AP93] </ref> is a technique for fusing the data manipulation loops of multiple protocol layers.
Reference: [BCS94] <author> Robert Braden, David Clark, and Scott Shenker. RFC-1633: </author> <title> Internet architecture: An overview. </title> <note> Available via ftp from ftp.nisc.sri.com, </note> <month> July </month> <year> 1994. </year>
Reference-contexts: A complete analysis is beyond the scope of this paper. In general, bounding the size of this queue requires cooperation with admission control and would typically employ a network reservation system, such as RSVP <ref> [BCS94] </ref>. The current implementation leaves this parameter under user control to facilitate experimentation. 4.3 Scheduling Since each video path has its own input queue and since the packet classifier is run at interrupt time, newly arriving packets are immediately placed in the correct queue.
Reference: [BGP + 94] <author> Mary L. Bailey, Burra Gopal, Michael A. Pagels, Larry L. Peterson, and Prasenjit Sarkar. PathFinder: </author> <title> A pattern-based packet classifier. </title> <booktitle> In Proceedings of the First Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 115-123, </pages> <year> 1994. </year>
Reference-contexts: It depends on knowing exactly what sequence of protocol modules a network packet will traverse. * Packet classifiers <ref> [YBMM93, MJ93, BGP + 94] </ref> distinguish among incoming network packets based on certain fields found in their headers. In a sense, a packet classifier pre-computes the path that a given message will follow. * Specialization is sometimes used to optimize common path code sequences [PAB + 95, MPBO96]. <p> Variable length and extension headers in particular need to be accommodated since they will become increasingly common with the adoption of IPv6 [PD96]. Many packet classifiers have been proposed (e.g., <ref> [YBMM93, MJ93, BGP + 94] </ref>), but none of them address all of Scout's requirements satisfactorily.
Reference: [CT90] <author> David Clark and David Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In Proceedings of SIGCOMM '90 Symposium, </booktitle> <month> September </month> <year> 1990. </year>
Reference-contexts: Consider the following examples. * Fbufs [DP93] are a path-oriented buffer management mechanism designed to efficiently move data across a sequence of protection domains. 1 Fbufs depend on being able to identify the path through the system over which the data will flow. * Integrated layer processing (ILP) <ref> [CT90, AP93] </ref> is a technique for fusing the data manipulation loops of multiple protocol layers. <p> The MPEG router accepts messages from MFLOW, applies the MPEG decompression algorithm to them, and sends the decoded images to the DISPLAY router. There, the images are queued for display at the appropriate time. The MPEG router uses application-level framing (ALF) <ref> [CT90] </ref> to avoid internal buffering. That is, the MPEG source sends Ethernet MTU-sized packets that contain an integral number of work-units (MPEG macroblocks).
Reference: [DP93] <author> Peter Druschel and Larry L. Peterson. Fbufs: </author> <title> A high-bandwidth cross-domain transfer facility. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Paths can also be loosely understood by considering specific OS mechanisms that have been proposed over the last few years. Consider the following examples. * Fbufs <ref> [DP93] </ref> are a path-oriented buffer management mechanism designed to efficiently move data across a sequence of protection domains. 1 Fbufs depend on being able to identify the path through the system over which the data will flow. * Integrated layer processing (ILP) [CT90, AP93] is a technique for fusing the data
Reference: [FL94] <author> Bryan Ford and Jay Lepreau. </author> <title> Evolving Mach 3.0 to a migrating thread model. </title> <booktitle> In Proc. of the Winter 1994 USENIX Conference, </booktitle> <pages> pages 97-114, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Specialization, in turn, depends on the existence of invariants that constrain the path through the code that is likely to be executed. * Spring defines a shuttle [HK93], which is an environment that allows a thread to migrate across a sequence of protection domains; others have defined similar mechanisms <ref> [FL94] </ref>. Like the previous examples, such mechanisms recognize that programs often follow the same path through the system more than once, and so establish some state that subsequent invocations can exploit.
Reference: [GYT96] <author> James Gosling, Frank Yellin, </author> <title> and The Java Team. The Java Application Programming Interface. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: However, it is possible to configure an interpreter into the router graph, thereby supporting extensibility. For example, we are currently implementing the Java API (and interpreter) in Scout <ref> [GYT96] </ref>. This will make it possible to download Java applications into Scout at runtime. 4 Demonstration Application This section demonstrates the use and benefits of paths with a simple, but realistic application implemented in Scout. The application consists of receiving, decoding, and displaying MPEG encoded video streams.
Reference: [HFC76] <author> A.N. Habermann, Lawrence Flon, and Lee Cooprider. </author> <title> Modularization and hierarchy in a family of operating systems. </title> <journal> Communications of the ACM, </journal> <volume> 19(5) </volume> <pages> 266-272, </pages> <month> May </month> <year> 1976. </year>
Reference-contexts: 1 Introduction Layering is a fundamental structuring technique with a long history in system design. From early work on layered operating systems and network architectures <ref> [HFC76, Zim80] </ref>, to more recent advances in stackable systems [Rit84, HP91, HP94, RBF + 95], layering has played a central role in managing complexity, isolating failure, and enhancing configurability. This paper describes a complementary, but equally fundamental structuring technique, which we call paths.
Reference: [HK93] <author> Graham Hamilton and Panos Kougiouris. </author> <title> The Spring nucleus: a microkernel for objects. </title> <booktitle> In Proc. of the Summer 1993 USENIX Conference, </booktitle> <pages> pages 147-159, </pages> <address> Cincinnati, OH, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Specialization, in turn, depends on the existence of invariants that constrain the path through the code that is likely to be executed. * Spring defines a shuttle <ref> [HK93] </ref>, which is an environment that allows a thread to migrate across a sequence of protection domains; others have defined similar mechanisms [FL94].
Reference: [HP91] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Layering is a fundamental structuring technique with a long history in system design. From early work on layered operating systems and network architectures [HFC76, Zim80], to more recent advances in stackable systems <ref> [Rit84, HP91, HP94, RBF + 95] </ref>, layering has played a central role in managing complexity, isolating failure, and enhancing configurability. This paper describes a complementary, but equally fundamental structuring technique, which we call paths.
Reference: [HP94] <author> John S. Heidemann and Gerald J. Popek. </author> <title> File-system development with stackable layers. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(1) </volume> <pages> 58-89, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Layering is a fundamental structuring technique with a long history in system design. From early work on layered operating systems and network architectures [HFC76, Zim80], to more recent advances in stackable systems <ref> [Rit84, HP91, HP94, RBF + 95] </ref>, layering has played a central role in managing complexity, isolating failure, and enhancing configurability. This paper describes a complementary, but equally fundamental structuring technique, which we call paths.
Reference: [LL73] <author> Liu and Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> Journal of the ACM, </journal> <year> 1973. </year>
Reference-contexts: Scout supports an arbitrary number of scheduling policies, and allocates a percentage of CPU time to each. The minimum share that each policy gets is determined by a system-tunable parameter. Two scheduling policies have been implemented to date: (1) fixed-priority round-robin, and (2) earliest-deadline first (EDF) <ref> [LL73] </ref>. The reason for implementing the EDF policy is that 6 for many soft realtime applications it is most natural to express a path's priority in terms of a deadline. We present an example of this in the next section.
Reference: [MJ93] <author> Steven McCanne and Van Jacobson. </author> <title> The BSD packet filter: A new architecture for user-level packet capture. </title> <booktitle> In 1993 Winter USENIX Conference, </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1993. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: It depends on knowing exactly what sequence of protocol modules a network packet will traverse. * Packet classifiers <ref> [YBMM93, MJ93, BGP + 94] </ref> distinguish among incoming network packets based on certain fields found in their headers. In a sense, a packet classifier pre-computes the path that a given message will follow. * Specialization is sometimes used to optimize common path code sequences [PAB + 95, MPBO96]. <p> Variable length and extension headers in particular need to be accommodated since they will become increasingly common with the adoption of IPv6 [PD96]. Many packet classifiers have been proposed (e.g., <ref> [YBMM93, MJ93, BGP + 94] </ref>), but none of them address all of Scout's requirements satisfactorily.
Reference: [MMO + 94] <author> A. B. Montz, D. Mosberger, S. W. O'Malley, L. L. Peterson, T. A. Proebsting, and J. H. Hartman. </author> <title> Scout: A communications-oriented operating system. </title> <type> Technical Report 94/20, </type> <institution> University of Arizona, </institution> <address> Tucson, AZ 85721, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: In other words, while the idea of a path running through a layered system is widely recognized, to date, paths have only been implicitly defined. The main contribution of this paper is to show how paths are explicitly implemented in the Scout operating system <ref> [MMO + 94] </ref>, and to demonstrate some of the advantages of this implementation by means of an example application. Scout is an experimental framework that provides the means to easily produce small, highly efficient, stand-alone kernels that are targeted at a particular I/O-intensive application domain.
Reference: [MPBO96] <author> David Mosberger, Larry Peterson, Patrick Bridges, and Sean O'Malley. </author> <title> Analysis of techniques to improve protocol latency. </title> <booktitle> In Proceedings of SIGCOMM '96 Symposium, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: In a sense, a packet classifier pre-computes the path that a given message will follow. * Specialization is sometimes used to optimize common path code sequences <ref> [PAB + 95, MPBO96] </ref>. <p> This paper focuses on the first set of advantages, that is, those that have to do with improvements in resource allocation and scheduling. A companion paper demonstrates the code-related improvements attributable to paths <ref> [MPBO96] </ref>. That earlier paper shows that paths permit code optimizations that improve node-to-node network processing latency by 21-186%. While the companion paper postulates the existence of paths, it does not explicitly define the requisite path architecture. <p> A transformation rule should be thought of as a pair consisting of a pattern and a transformation that takes a path as an argument and returns a transformed path. A companion paper describes a set of code transformations that can be applied to a path <ref> [MPBO96] </ref>. In Section 4 we will discuss some transformations that improve resource management. As implemented in Scout, paths are light-weight. For example, a path to transmit and receive UDP packets consists of six stages. Creating such a path on a 300MHz Alpha takes on the order of 200s.
Reference: [Ous96] <author> John K. Ousterhout. </author> <title> Why threads are a bad idea (for most purposes). </title> <booktitle> In 1996 Winder USENIX Conference, </booktitle> <year> 1996. </year> <type> Invited talk. </type>
Reference-contexts: We present an example of this in the next section. Scout uses a non-preemptive scheduler because it meets our needs and is easy to use. Programming preemptively scheduled threads that share memory is error-prone <ref> [Ous96] </ref>. More importantly, there are only two good reasons for using preemptive scheduling: (1) to exploit true concurrency, and (2) to guarantee fairness or timeliness in an environment where uncooperative threads share the CPU. Scout is designed to be a uniprocessor OS, so true concurrency is not an issue.
Reference: [PAB + 95] <author> C. Pu, T. Autrey, A. Black, C. Consel, C. Cowan, J. Inouye, L. Kethana, J. Walpole, and K. Zhang. </author> <title> Optimistic incremental specialization: Streamlining a commercial operating system. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 314-324. </pages> <institution> Association for Computing Machinery SIGOPS, </institution> <month> December </month> <year> 1995. </year> <month> 13 </month>
Reference-contexts: In a sense, a packet classifier pre-computes the path that a given message will follow. * Specialization is sometimes used to optimize common path code sequences <ref> [PAB + 95, MPBO96] </ref>.
Reference: [PD96] <author> Larry L. Peterson and Bruce S. Davie. </author> <title> Computer Networks: A Systems Approach. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Francisco, CA, </address> <year> 1996. </year>
Reference-contexts: Variable length and extension headers in particular need to be accommodated since they will become increasingly common with the adoption of IPv6 <ref> [PD96] </ref>. Many packet classifiers have been proposed (e.g., [YBMM93, MJ93, BGP + 94]), but none of them address all of Scout's requirements satisfactorily.
Reference: [RBF + 95] <author> Robbert Van Renesse, Ken Birman, Roy Friedman, Mark Hayden, and David Karr. </author> <title> A framework for protocol composition in horus. </title> <booktitle> In Proc. of the Fourteenth ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 80-89, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Layering is a fundamental structuring technique with a long history in system design. From early work on layered operating systems and network architectures [HFC76, Zim80], to more recent advances in stackable systems <ref> [Rit84, HP91, HP94, RBF + 95] </ref>, layering has played a central role in managing complexity, isolating failure, and enhancing configurability. This paper describes a complementary, but equally fundamental structuring technique, which we call paths.
Reference: [Rit84] <author> D. M. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 311-324, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: 1 Introduction Layering is a fundamental structuring technique with a long history in system design. From early work on layered operating systems and network architectures [HFC76, Zim80], to more recent advances in stackable systems <ref> [Rit84, HP91, HP94, RBF + 95] </ref>, layering has played a central role in managing complexity, isolating failure, and enhancing configurability. This paper describes a complementary, but equally fundamental structuring technique, which we call paths.
Reference: [WLAG93] <author> Robert Wahbe, Steven Lucco, Tom Anderson, and Susan Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 203-216. </pages> <institution> Association for Computing Machinery SIGOPS, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: This greatly reduces the risk of introducing errors due to inconsistencies. 3.5 Other Issues There are many other aspects of Scout that space does not permit us to describe; most of them are orthogonal to paths. For example, software-based fault isolation <ref> [WLAG93] </ref> can be imposed on top of paths by defining each router to be in a separate fault domain. Similarly, hardware-enforced protection can be imposed between paths.
Reference: [YBMM93] <author> Masanobu Yuhara, Brian N. Bershad, Chris Maeda, and J. Eliot B. Moss. </author> <title> Efficient packet demultiplexing for multiple endpoints and large messages. </title> <month> July </month> <year> 1993. </year>
Reference-contexts: It depends on knowing exactly what sequence of protocol modules a network packet will traverse. * Packet classifiers <ref> [YBMM93, MJ93, BGP + 94] </ref> distinguish among incoming network packets based on certain fields found in their headers. In a sense, a packet classifier pre-computes the path that a given message will follow. * Specialization is sometimes used to optimize common path code sequences [PAB + 95, MPBO96]. <p> Variable length and extension headers in particular need to be accommodated since they will become increasingly common with the adoption of IPv6 [PD96]. Many packet classifiers have been proposed (e.g., <ref> [YBMM93, MJ93, BGP + 94] </ref>), but none of them address all of Scout's requirements satisfactorily.
Reference: [Zim80] <author> Hubert Zimmermann. </author> <title> OSI reference modelthe ISO model of architecture for open systems interconnection. </title> <journal> IEEE Transactions on Communications, </journal> <volume> COM-28(4):425-432, </volume> <month> April </month> <year> 1980. </year> <month> 14 </month>
Reference-contexts: 1 Introduction Layering is a fundamental structuring technique with a long history in system design. From early work on layered operating systems and network architectures <ref> [HFC76, Zim80] </ref>, to more recent advances in stackable systems [Rit84, HP91, HP94, RBF + 95], layering has played a central role in managing complexity, isolating failure, and enhancing configurability. This paper describes a complementary, but equally fundamental structuring technique, which we call paths.
References-found: 23

