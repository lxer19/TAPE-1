URL: http://www.cs.tamu.edu/faculty/bettati/Papers/rtss92.paper.ps
Refering-URL: http://www.cs.tamu.edu/faculty/bettati/selected_papers.html
Root-URL: http://www.cs.tamu.edu
Title: Checkpointing Imprecise Computation  
Author: Riccardo Bettati Nicholas S. Bowen, Jen-Yao Chung 
Address: P.O. Box 704 Urbana, Illinois 61801 Yorktown Heights, NY 10598  
Affiliation: Department of Computer Science IBM T. J. Watson Research Center University of Illinois at Urbana-Champaign  
Date: Dec. 1992, pages 45-49.  
Note: Appeared in: Proceedings of the IEEE Workshop on Imprecise and Approximate Computation, Phoenix, AZ,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Liu, J. W. S., K. J. Lin and C. L. Liu, </author> <title> "A position paper for the IEEE 1987 Workshop on Real-Time Operating Systems," </title> <address> Cambridge, Mass., </address> <month> May </month> <year> 1987. </year>
Reference-contexts: 1 Introduction The imprecise-computation model has been proposed in <ref> [1, 2, 3] </ref> as a means to provide flexibility in scheduling time-critical tasks. In this model, tasks are composed of a mandatory part, where an acceptable result is made available, and an optional part, where this initial result is improved monotonically to reach the desired accuracy.
Reference: [2] <author> Lin, K. J., S. Natarajan, J. W. S. Liu, </author> <title> "Imprecise results: utilizing partial computations in real-time systems," </title> <booktitle> Proceedings of the IEEE 8th Real-Time Systems Symposium, </booktitle> <address> San Jose, California, </address> <month> December </month> <year> 1987. </year>
Reference-contexts: 1 Introduction The imprecise-computation model has been proposed in <ref> [1, 2, 3] </ref> as a means to provide flexibility in scheduling time-critical tasks. In this model, tasks are composed of a mandatory part, where an acceptable result is made available, and an optional part, where this initial result is improved monotonically to reach the desired accuracy.
Reference: [3] <author> Chung, J. Y. and J. W. S. Liu, </author> <title> "Algorithms for scheduling periodic jobs to minimize average error," </title> <booktitle> Proceedings of the 9th IEEE Real-Time Systems Symposium, </booktitle> <address> Huntsville, Alabama, </address> <month> Decem-ber </month> <year> 1988. </year>
Reference-contexts: 1 Introduction The imprecise-computation model has been proposed in <ref> [1, 2, 3] </ref> as a means to provide flexibility in scheduling time-critical tasks. In this model, tasks are composed of a mandatory part, where an acceptable result is made available, and an optional part, where this initial result is improved monotonically to reach the desired accuracy.
Reference: [4] <author> Muppala, J. K., S. P. Woolet and K. S. Trivedi, </author> <title> "Real-Time-Systems Performance in the Presence of Failures," </title> <booktitle> IEEE Computer, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: Checkpointing can therefore be viewed as another method to reduce the temporary overload caused by failures. Due to its limited rollback and its predictable recovery behavior, checkpointing is besides various parallel redundancy and replication schemes <ref> [4, 5] </ref> a widely used technique for fault tolerance in real-time systems. Traditionally, checkpointing in real-time systems was considered from a task-oriented view [6, 7]. Once a task acquires a computational resource, it is supposed to run until it finishes, or until a failure occurs.
Reference: [5] <author> Ramamritham, K. and J. A. Stankovic, </author> <title> "Dynamic Task Scheduling in Distributed Hard Real-Time Systems," </title> <journal> IEEE Software, </journal> <volume> Vol. 1, No. 3, </volume> <year> 1984. </year>
Reference-contexts: Checkpointing can therefore be viewed as another method to reduce the temporary overload caused by failures. Due to its limited rollback and its predictable recovery behavior, checkpointing is besides various parallel redundancy and replication schemes <ref> [4, 5] </ref> a widely used technique for fault tolerance in real-time systems. Traditionally, checkpointing in real-time systems was considered from a task-oriented view [6, 7]. Once a task acquires a computational resource, it is supposed to run until it finishes, or until a failure occurs.
Reference: [6] <author> Shin, K. G., T.-H. Lin and Y.-H. Lee, </author> <title> "Optimal Checkpointing of Real-Time Tasks," </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C-36, No. 11, </volume> <month> Novem-ber </month> <year> 1987. </year>
Reference-contexts: Due to its limited rollback and its predictable recovery behavior, checkpointing is besides various parallel redundancy and replication schemes [4, 5] a widely used technique for fault tolerance in real-time systems. Traditionally, checkpointing in real-time systems was considered from a task-oriented view <ref> [6, 7] </ref>. Once a task acquires a computational resource, it is supposed to run until it finishes, or until a failure occurs. No multiprogramming is therefore assumed in this model.
Reference: [7] <author> Grassi, V., L. Donatiello and S. Tucci, </author> <title> "On the Optimal Checkpointing of Critical Tasks and Transaction-Oriented Systems," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 18, No. 1, </volume> <month> January </month> <year> 1992. </year>
Reference-contexts: Due to its limited rollback and its predictable recovery behavior, checkpointing is besides various parallel redundancy and replication schemes [4, 5] a widely used technique for fault tolerance in real-time systems. Traditionally, checkpointing in real-time systems was considered from a task-oriented view <ref> [6, 7] </ref>. Once a task acquires a computational resource, it is supposed to run until it finishes, or until a failure occurs. No multiprogramming is therefore assumed in this model. <p> The problem of deriving optimal checkpoint intervals has been extensively discussed under a variety of assumptions, for example by Young [8], Gelenbe [9], Coffman and Gilbert [10], Nicola et al. [11], and Grassi et al. <ref> [7] </ref>. Most previous research assumes stochastic failure occurrences, mostly in form of Poisson processes.
Reference: [8] <author> Young, J. W., </author> <title> "A first order approximation to the optimum checkpoint interval," </title> <journal> Commun. ACM, </journal> <volume> Vol. 17, No. 9, </volume> <year> 1974. </year>
Reference-contexts: No multiprogramming is therefore assumed in this model. The problem of devising a checkpointing scheme for real-time tasks typically reduces to determining the optimal inter-checkpoint interval to minimize the expected execution time of tasks, a problem that has found broad attention in the literature <ref> [8, 9] </ref>. However, most of todays real-time operating systems are multiprogrammed. The execution of a task can be preempted by other tasks. In such systems, minimizing the expected execution time of tasks is still an important means to meet timing constraints. <p> The problem of deriving optimal checkpoint intervals has been extensively discussed under a variety of assumptions, for example by Young <ref> [8] </ref>, Gelenbe [9], Coffman and Gilbert [10], Nicola et al. [11], and Grassi et al. [7]. Most previous research assumes stochastic failure occurrences, mostly in form of Poisson processes.
Reference: [9] <author> Gelenbe, E., </author> <title> "On the optimum checkpoint interval," </title> <journal> J. ACM, </journal> <volume> Vol. 26, No. 2, </volume> <year> 1979. </year>
Reference-contexts: No multiprogramming is therefore assumed in this model. The problem of devising a checkpointing scheme for real-time tasks typically reduces to determining the optimal inter-checkpoint interval to minimize the expected execution time of tasks, a problem that has found broad attention in the literature <ref> [8, 9] </ref>. However, most of todays real-time operating systems are multiprogrammed. The execution of a task can be preempted by other tasks. In such systems, minimizing the expected execution time of tasks is still an important means to meet timing constraints. <p> The problem of deriving optimal checkpoint intervals has been extensively discussed under a variety of assumptions, for example by Young [8], Gelenbe <ref> [9] </ref>, Coffman and Gilbert [10], Nicola et al. [11], and Grassi et al. [7]. Most previous research assumes stochastic failure occurrences, mostly in form of Poisson processes.
Reference: [10] <author> Coffman, E. G. and E. N. Gilbert, </author> <title> "Optimal Strategies for Scheduling Checkpoints and Preventive Maintenance," </title> <journal> IEEE Transactions on Reliability, </journal> <volume> Vol. 39, No. 1, </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: The problem of deriving optimal checkpoint intervals has been extensively discussed under a variety of assumptions, for example by Young [8], Gelenbe [9], Coffman and Gilbert <ref> [10] </ref>, Nicola et al. [11], and Grassi et al. [7]. Most previous research assumes stochastic failure occurrences, mostly in form of Poisson processes.
Reference: [11] <author> Nicola, V. F. and J. M. van Spanje, </author> <title> "Comparative Analysis of Different Models of Checkpoint-ing and Recovery," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 16, No. 8, </volume> <month> August </month> <year> 1990. </year>
Reference-contexts: The problem of deriving optimal checkpoint intervals has been extensively discussed under a variety of assumptions, for example by Young [8], Gelenbe [9], Coffman and Gilbert [10], Nicola et al. <ref> [11] </ref>, and Grassi et al. [7]. Most previous research assumes stochastic failure occurrences, mostly in form of Poisson processes.
Reference: [12] <author> Shih, W.K., J. Y. Chung, J. W. S. Liu, and D. W. Gillies, </author> <title> "Scheduling tasks with ready times and deadlines to minimize average error," </title> <journal> ACM Operating Systems Review, </journal> <month> July </month> <year> 1989. </year>
Reference-contexts: Shih et al. <ref> [12, 13] </ref> have developed several scheduling algorithms that address this problem. In [12] they formulate it as a network-flow problem. <p> Shih et al. [12, 13] have developed several scheduling algorithms that address this problem. In <ref> [12] </ref> they formulate it as a network-flow problem. <p> We assume the total error e of a schedule to be the weighted sum of the amount of computation that has been discarded, that is, e = P n This definition of a total error is said to define a linear error behavior. Shih et al <ref> [12, 13] </ref> distinguished two cases of linear error behavior. In the simpler case, called the unweighted case, all weights in the total error are identical. In the more general weighted case, they may vary. optimally schedule k-tolerant checkpointed-imprecise computations.
Reference: [13] <author> Shih, W. K., J. W. S. Liu and J. Y. Chung, </author> <title> "Algorithms for scheduling tasks to minimize total error," </title> <journal> SIAM Journal of Computing, </journal> <note> 1991. 0% 10% 20% 30% Miss Rate 0.4 0.6 0.8 1.0 Arrival Rate * * * * * * * * * * * * * ? ? ? ? ? ? ? ? ? ? ? ? ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi ffi = 0; c = 0 * s = 0:1 ffi s = 0:4 </note>
Reference-contexts: Shih et al. <ref> [12, 13] </ref> have developed several scheduling algorithms that address this problem. In [12] they formulate it as a network-flow problem. <p> Shih et al. [12, 13] have developed several scheduling algorithms that address this problem. In [12] they formulate it as a network-flow problem. In <ref> [13] </ref> much faster algorithms are found, that are based on a variation of the traditional earliest-deadline-first algorithm.) If we want to generate a k-tolerant schedule for a checkpointed-imprecise-computation system, on the other hand, we have to consider one additional goal; (3) for every task T i , enough time h i <p> We assume the total error e of a schedule to be the weighted sum of the amount of computation that has been discarded, that is, e = P n This definition of a total error is said to define a linear error behavior. Shih et al <ref> [12, 13] </ref> distinguished two cases of linear error behavior. In the simpler case, called the unweighted case, all weights in the total error are identical. In the more general weighted case, they may vary. optimally schedule k-tolerant checkpointed-imprecise computations. <p> In the simpler case, called the unweighted case, all weights in the total error are identical. In the more general weighted case, they may vary. optimally schedule k-tolerant checkpointed-imprecise computations. The following argument shows that Algorithm C is optimal in the way we defined earlier: As shown in <ref> [13] </ref>, Step 2 either generates a feasible schedule for the mandatory part or declares failure. Goal (1) is therefore met. Since we included the recover time in the mandatory part in Step 1, goal (3) is also met. <p> Since Step 2 minimizes the total error for T k (the task set T with all K failures occurring,) it minimizes the total error for the case where all K failures occur, and hence satisfies goal (2). If one of the fast algorithms described in <ref> [13] </ref> is used, Algorithm C has a complexity of O (n 2 logn) and Algorithm C: Input: Task set T defined by mandatory parts m i , optional parts o i , a vector k, recovery time h i and timing constraints r i and d i .
References-found: 13

