URL: http://www.cs.washington.edu/homes/douglas/publish/CTL97d/LETTER.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/douglas/publish/CTL97d/index.html
Root-URL: http://www.cs.washington.edu
Email: fcollberg,cthombor,dlow001g@cs.auckland.ac.nz  
Title: Breaking Abstractions and Unstructuring Data Structures a tool which through the application of code transformations
Author: Christian Collberg Clark Thomborson Douglas Low 
Note: Code obfuscation is one of several techniques which has been proposed to alleviate this situation. An obfuscator is  
Address: Private Bag 92019, Auckland, New Zealand.  
Affiliation: Department of Computer Science, The University of Auckland,  
Abstract: In a previous paper [5] we have described the design of a control flow obfuscator for Java. In this paper we extend the design with transformations that obfuscate data structures and abstractions. In particular, we show how to obfuscate classes, arrays, procedural abstractions and built-in data types like strings, integers, and booleans. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David Aucsmith. </author> <title> Tamper resistant software. </title> <booktitle> In Information Hiding, </booktitle> <pages> pages 317334, </pages> <note> May/June 1986. LNCS 1174. </note>
Reference-contexts: This is of particular concern to small software developers who can ill afford to protect their software secrets through legal [17] means against larger and more powerful competitors [12]. As an alternative, several forms of technical <ref> [1, 7] </ref> protection against theft of software secrets have been suggested: Server-Side Execution The user connects to the software developer's site to run the program remotely, paying a small amount of electronic money every time.
Reference: [2] <author> Shyam R. Chidamber and Chris F. Kemerer. </author> <title> A metrics suite for object oriented design. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6):476493, </volume> <month> June </month> <year> 1994. </year>
Reference-contexts: Given such a statement, we can attempt to construct a transformation which adds more of the q-property to a program, knowing that this is likely to increase its obscurity. Of particular interest to us are the Henry [10], Chi-damber <ref> [2] </ref>, and Munson [14] metrics. The Munson metric states that the complexity of a program P increases with the complexity of the static data structures declared in P .
Reference: [3] <author> Cristina Cifuentes and K. John Gough. </author> <title> Decompilation of binary programs. </title> <journal> Software Practice & Experience, </journal> <volume> 25(7):811829, </volume> <month> July </month> <year> 1995. </year>
Reference-contexts: Native Code When down-loading the application, the user's site identifies its architecture, and the corre sponding native code version of the application is transmitted. Digital signatures should be attached to the code to assure authenticity and harmlessness. De-compilation of the native code is still possible <ref> [3] </ref>, but much more difficult, if, as is usual, symbol naming and type information is suppressed. Encryption Encrypting [11, 21] the application will only protect against theft if the entire decryption/execution process takes place in hardware.
Reference: [4] <author> Christian Collberg, Clark Thomborson, and Douglas Low. </author> <title> A taxonomy of obfuscating transformations. </title> <type> Technical Report 148, </type> <institution> Department of Computer Science, University of Auckland, </institution> <month> July </month> <year> 1997. </year> <note> http://www.cs.auckland. ac.nz/~collberg/Research/Publications/ CollbergThomborsonLow97a/index.html. </note>
Reference-contexts: In this paper we have shown that data structures and abstractions can also be obfuscated, in many cases with only minor impact on execution time/space cost. The transformations presented in this paper are only a few of a large catalogue <ref> [4] </ref> of obfuscations which target every aspect of a program. The extra complexity that an obfuscator adds to a program will depend on the complex interaction between all the different types of transformations which have been applied to it.
Reference: [5] <author> Christian Collberg, Clark Thomborson, and Douglas Low. </author> <title> Manufacturing cheap, resilient, and stealthy opaque constructs. </title> <booktitle> In SIGPLAN-SIGACT POPL'98. </booktitle> <publisher> ACM Press, </publisher> <address> San Diego, CA, </address> <month> January </month> <year> 1998. </year> <note> http://www.cs.auckland. ac.nz/~collberg/Research/Publications/ CollbergThomborsonLow98a/index.html. </note>
Reference-contexts: Finally, the ob-fuscator generates a new version of the application; obfuscated but functionally equivalent to the original one. 3 Obfuscating transformations Obfuscating transformations were first introduced in Collberg <ref> [5] </ref>. <p> Note that we do not require P and P 0 to equally efficient. In fact, many of our transformations will result in P 0 being slower or using more memory than P . 3.1 Transformation quality Collberg <ref> [5] </ref> also introduces the concept of quality of an obfuscating transformation T , a combination of four measures: potency The potency of T measures how much more obscure (or complex or unreadable) T renders the application. resilience The resilience of T measures how well the transformation holds up under attack from <p> Being able to create opaque predicates which are difficult for an obfuscator to crack is a major challenge to a creator of obfuscation tools, and the key to many highly resilient obfuscating transformations. Collberg <ref> [5] </ref> shows how it is possible to manufacture cheap and resilient opaque predicates based on intractable problems such as alias analysis. 4 Obfuscating data abstractions In this section we will discuss transformations that obscure the data abstractions used in the source application. <p> present transformations that obscure the basic data types (such as integers and strings) (1) int A [10]; (3) int B [10],C [20]; (5) C [i] = ; (6) int D [10]; D [i]=2*D [i+1]; (8) int E [3,3]; for (j=0;i&lt;=2;i++) swap (E [i,j], E [j,i]); T (1') int A1 <ref> [5] </ref>,A2 [5]; else A2 [i/2]= ; (4') BC [3*i] = ; (7') for (j=0;j&lt;=1;j++) if (k==4) else D1 [j,k]=2*D1 [j,k+1]; (8') int E1 [9]; swap (E [i], E [3*(i%3)+i/3]); 0 1 2 3 4 5 9 0 1 2 3 4 5 9 0 1 2 3 4 5 19 0 1 <p> In the example in Figure 10 (b) we could insert operations that appear to merge Z's two halves, for example by bitwise rotation: pif (P F ) Z = rotate (Z,5)q. 7 Summary In a previous paper <ref> [5] </ref> we showed that it is possible to obfuscate the control flow of an application with a high degree of resilience (resistance to attack by automatic de-obfuscators) and at low time/space cost.
Reference: [6] <author> Jeffrey Dean. </author> <title> Whole-Program Optimization of Object-Oriented Languages. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <year> 1996. </year>
Reference-contexts: Consider a method invocation m:P (). The actual procedure called will depend on the run-time type of m. In cases when more than one method can be invoked at a particular call site, we have to inline all possible methods <ref> [6] </ref> and select the appropriate code by branching on the type of m.
Reference: [7] <author> James R. Gosler. </author> <title> Software protection: </title> <booktitle> Myth or reality? In CRYPTO'85 Advances in Cryptology, </booktitle> <pages> pages 140157, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: This is of particular concern to small software developers who can ill afford to protect their software secrets through legal [17] means against larger and more powerful competitors [12]. As an alternative, several forms of technical <ref> [1, 7] </ref> protection against theft of software secrets have been suggested: Server-Side Execution The user connects to the software developer's site to run the program remotely, paying a small amount of electronic money every time.
Reference: [8] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year> <note> ISBN 0-201-63451-1. </note>
Reference-contexts: 1 Introduction Mobile programs are distributed in architecture-neutral formats (such as Java bytecode <ref> [8] </ref>) that contain much of the same information as the original source code. While this achieves platform independence, it also makes programs easy to decompile and reverse engineer.
Reference: [9] <author> Warren A. Harrison and Kenneth I. Magel. </author> <title> A complexity measure based on nesting level. </title> <journal> SIGPLAN Notices, </journal> <volume> 16(3):6374, </volume> <year> 1981. </year>
Reference-contexts: Other metrics express that the complexity of a program grows with the number of predicates it contains (Mc-Cabe [13]) and with the nesting level of conditional and looping constructs (Harrison <ref> [9] </ref>). 3.3 Classifying transformations There are some aspects of program understandability that are not covered directly by software metrics. For example, it should be obvious that there is much valuable information about a program in comments, strings, and identifiers, although these do not enter into any metrics formula. <p> (5) C [i] = ; (6) int D [10]; D [i]=2*D [i+1]; (8) int E [3,3]; for (j=0;i&lt;=2;i++) swap (E [i,j], E [j,i]); T (1') int A1 [5],A2 [5]; else A2 [i/2]= ; (4') BC [3*i] = ; (7') for (j=0;j&lt;=1;j++) if (k==4) else D1 [j,k]=2*D1 [j,k+1]; (8') int E1 <ref> [9] </ref>; swap (E [i], E [3*(i%3)+i/3]); 0 1 2 3 4 5 9 0 1 2 3 4 5 9 0 1 2 3 4 5 19 0 1 2 3 4 5 9 0 1 2 1 E 1;0 E 1;1 E 1;2 T 0 1 2 3 4 0
Reference: [10] <author> Sallie Henry and Dennis Kafura. </author> <title> Software structure metrics based on information flow. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 7(5):510518, </volume> <month> September </month> <year> 1981. </year>
Reference-contexts: Given such a statement, we can attempt to construct a transformation which adds more of the q-property to a program, knowing that this is likely to increase its obscurity. Of particular interest to us are the Henry <ref> [10] </ref>, Chi-damber [2], and Munson [14] metrics. The Munson metric states that the complexity of a program P increases with the complexity of the static data structures declared in P . <p> We use method dispatch to select between the different versions at runtime. 6 Obfuscating built-in data types In this section we will present transformations that obscure the basic data types (such as integers and strings) (1) int A <ref> [10] </ref>; (3) int B [10],C [20]; (5) C [i] = ; (6) int D [10]; D [i]=2*D [i+1]; (8) int E [3,3]; for (j=0;i&lt;=2;i++) swap (E [i,j], E [j,i]); T (1') int A1 [5],A2 [5]; else A2 [i/2]= ; (4') BC [3*i] = ; (7') for (j=0;j&lt;=1;j++) if (k==4) else D1 <p> method dispatch to select between the different versions at runtime. 6 Obfuscating built-in data types In this section we will present transformations that obscure the basic data types (such as integers and strings) (1) int A <ref> [10] </ref>; (3) int B [10],C [20]; (5) C [i] = ; (6) int D [10]; D [i]=2*D [i+1]; (8) int E [3,3]; for (j=0;i&lt;=2;i++) swap (E [i,j], E [j,i]); T (1') int A1 [5],A2 [5]; else A2 [i/2]= ; (4') BC [3*i] = ; (7') for (j=0;j&lt;=1;j++) if (k==4) else D1 [j,k]=2*D1 [j,k+1]; (8') int E1 [9]; swap (E [i], E [3*(i%3)+i/3]); 0 1 2
Reference: [11] <author> Amir Herzberg and Shlomit S. Pinter. </author> <title> Public protection of software. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(4):371393, </volume> <month> November </month> <year> 1987. </year>
Reference-contexts: Digital signatures should be attached to the code to assure authenticity and harmlessness. De-compilation of the native code is still possible [3], but much more difficult, if, as is usual, symbol naming and type information is suppressed. Encryption Encrypting <ref> [11, 21] </ref> the application will only protect against theft if the entire decryption/execution process takes place in hardware. If the code is executed in software by a virtual machine interpreter it will always be possible to intercept and decompile the decrypted code.
Reference: [12] <author> Apple's QuickTime lawsuit. </author> <note> http://www. macworld.com/pages/june.95/News.848.html and may.95/News.705.html, MayJune 1995. </note>
Reference-contexts: While this achieves platform independence, it also makes programs easy to decompile and reverse engineer. This is of particular concern to small software developers who can ill afford to protect their software secrets through legal [17] means against larger and more powerful competitors <ref> [12] </ref>. As an alternative, several forms of technical [1, 7] protection against theft of software secrets have been suggested: Server-Side Execution The user connects to the software developer's site to run the program remotely, paying a small amount of electronic money every time.
Reference: [13] <author> T. J. McCabe. </author> <title> A complexity measure. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 2(4):308320, </volume> <month> December </month> <year> 1976. </year>
Reference-contexts: Other metrics express that the complexity of a program grows with the number of predicates it contains (Mc-Cabe <ref> [13] </ref>) and with the nesting level of conditional and looping constructs (Harrison [9]). 3.3 Classifying transformations There are some aspects of program understandability that are not covered directly by software metrics.
Reference: [14] <author> John C. Munson and Taghi M. Kohshgoftaar. </author> <title> Measurement of data structure complexity. </title> <journal> Journal of Systems Software, </journal> <volume> 20:217225, </volume> <year> 1993. </year>
Reference-contexts: Given such a statement, we can attempt to construct a transformation which adds more of the q-property to a program, knowing that this is likely to increase its obscurity. Of particular interest to us are the Henry [10], Chi-damber [2], and Munson <ref> [14] </ref> metrics. The Munson metric states that the complexity of a program P increases with the complexity of the static data structures declared in P .
Reference: [15] <author> William F. Opdyke and Ralph E. Johnson. </author> <title> Creating abstract superclasses by refactoring. </title> <editor> In Stan C. Kwasny and John F. Buck, editors, </editor> <booktitle> Proceedings of the 21st Annual Conference on Computer Science, </booktitle> <pages> pages 6673, </pages> <address> New York, NY, USA, </address> <month> February </month> <year> 1993. </year> <note> ACM Press. ftp://st.cs.uiuc.edu/pub/papers/ refactoring/refactoring-superclasses.ps. </note>
Reference-contexts: False refactoring. Figure 2 (c) shows a variant of class insertion, called false refactoring. Refactoring is a (sometimes automatic) technique for restructuring object-oriented programs whose structure has deteriorated <ref> [15] </ref>. Refactoring is a two-step process.
Reference: [16] <author> Todd Proebsting. </author> <title> Optimizing ANSI C with superoperators. In POPL'96. </title> <publisher> ACM Press, </publisher> <month> January </month> <year> 1996. </year>
Reference-contexts: This is akin to Proebsting's superoperators <ref> [16] </ref>. To increase the resilience of this transformation, Sum is first obfuscated by inserting a bogus if-statement whose opaque predicate (which depends on two un-aliased pointer variables p and q) will always evaluate to True. Even after deobfuscating the interpreter, the resulting code is still obfuscated.
Reference: [17] <author> Pamela Samuelson. </author> <title> Reverse-engineering someone else's software: </title> <booktitle> Is it legal? IEEE Software, </booktitle> <pages> pages 9096, </pages> <month> Janu-ary </month> <year> 1990. </year>
Reference-contexts: While this achieves platform independence, it also makes programs easy to decompile and reverse engineer. This is of particular concern to small software developers who can ill afford to protect their software secrets through legal <ref> [17] </ref> means against larger and more powerful competitors [12].
Reference: [18] <author> Antero Taivalsaari. </author> <title> On the notion of inheritance. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(3):438479, </volume> <month> September </month> <year> 1996. </year>
Reference-contexts: Borrowing the notation used in <ref> [18] </ref>, we write inheritance as C 2 = C 1 C 2 . C 2 is said to inherit from C 1 , its super- or parent class. The operator is the function that combines the parent class with the new properties defined in C 2 .
Reference: [19] <author> Robert Tolksdorf. </author> <title> Programming languages for the Java virtual machine, </title> <note> 1997. http://grunge.cs.tu-berlin. de/~tolk/vmlanguages.html. </note>
Reference-contexts: In fact, our obfuscator (which targets Java class files) is already able to obfuscate programs written in a variety of languages. The reason, of course, is the existence of translators from many languages (including Ada and Scheme) into Java source or bytecode <ref> [19] </ref>. Acknowledgments We thank the anonymous referees for their insightful comments on a draft of this paper.
Reference: [20] <author> Hans Peter Van Vliet. </author> <title> Crema The Java obfuscator. </title> <address> http: //web.inter.nl.net/users/H.P.van.Vliet, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: With this in mind we can attempt to classify obfuscating transformations according to the kind of information they target. Layout transformations are typical of current Java obfuscators such as Crema <ref> [20] </ref>. They remove source code formatting and scramble identifiers. Control transformations increase the McCabe and Harrison metrics by introducing predicated branches. Data transformations increase the Munson, Henry, or Chidamber metrics. Abstraction transformations remove programmer-defined abstractions or introduce spurious ones. <p> We use method dispatch to select between the different versions at runtime. 6 Obfuscating built-in data types In this section we will present transformations that obscure the basic data types (such as integers and strings) (1) int A [10]; (3) int B [10],C <ref> [20] </ref>; (5) C [i] = ; (6) int D [10]; D [i]=2*D [i+1]; (8) int E [3,3]; for (j=0;i&lt;=2;i++) swap (E [i,j], E [j,i]); T (1') int A1 [5],A2 [5]; else A2 [i/2]= ; (4') BC [3*i] = ; (7') for (j=0;j&lt;=1;j++) if (k==4) else D1 [j,k]=2*D1 [j,k+1]; (8') int E1 <p> () f String S1,S2,S3,S4; S1 = "AAA"; S2 = "BAAA"; S3 = "CCB"; g ) main () f String S1,S2,S3,S4,S5; S1 = G (1); S3 = G (3); if (P F ) S5 = G (9); static String G (int n) f int i=0; char [] S = new char <ref> [20] </ref>; while (true) f L1: if (n==1) fS [i++]='A'; k=0; goto L6g; L2: if (n==2) fS [i++]='B'; k=-2; goto L6g; L3: if (n==3) fS [i++]='C'; goto L9g; L4: if (n==4) fS [i++]='X'; goto L9g; L5: if (n==5) fS [i++]='C'; goto L11g; if (n&gt;12) goto L1; L6: if (k++&lt;=2) fS [i++]='A'; goto
Reference: [21] <author> Uwe G. Wilhelm. </author> <title> Cryptographically protected objects. </title> <note> http://lsewww.epfl.ch/~wilhelm/CryPO. html, </note> <year> 1997. </year>
Reference-contexts: Digital signatures should be attached to the code to assure authenticity and harmlessness. De-compilation of the native code is still possible [3], but much more difficult, if, as is usual, symbol naming and type information is suppressed. Encryption Encrypting <ref> [11, 21] </ref> the application will only protect against theft if the entire decryption/execution process takes place in hardware. If the code is executed in software by a virtual machine interpreter it will always be possible to intercept and decompile the decrypted code.
References-found: 21

