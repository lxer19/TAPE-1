URL: ftp://ftp.cs.brown.edu/pub/techreports/92/cs92-43.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-92-43.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Aggoun and N. Beldiceanu. </author> <title> Extending CHIP To Solve Complex Scheduling and Packing Problems. In Journees Francophones De Programmation Logique, </title> <address> Lille, France, </address> <year> 1992. </year>
Reference-contexts: This problem and its variations have attracted much attention in the CLP community. Colmerauer [6] presents a program to fill a rectangle with squares of different sizes using linear equations, inequalities, and disequations over rational numbers. Aggoun and Beldiceanu <ref> [1] </ref> present a finite domain program which can solve large instances (e.g. 21 and 24) of the perfect square problem when the sizes of the squares are given. The program uses a specialized cumulative constraint and exploits the link between cumulative constraints and packing in two dimensions. <p> We use the idea of <ref> [1] </ref> for the labeling, exploiting the fact that no empty space is allowed. At each step, the program identifies the smallest possible coordinate and select a square to be placed at this position. On backtracking, another square is selected for the same position. <p> Both applications illustrate the potential benefit of constraint languages such as cc (FD). Acknowledgements Michel Van Caneghem and Alain Colmerauer suggested the perfect square application and the approach taken in the cc (FD) program and pointed out the reference <ref> [1] </ref>. Gerald Karam provided the DSP applications and gave us the benchmarks to test our programs. We would like to thank them as well as Yves Deville and Vijay Saraswat for the work on the design of cc (FD).
Reference: [2] <author> W. Buttner and H. Simonis. </author> <title> Embedding Boolean Expressions into Logic Programming. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 4 </volume> <pages> 191-205, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: The CLP scheme can be instantiated to produce a specific language by defining a constraint system (i.e. defining a set of primitive constraints and providing a constraint solver for the constraints). For instance, CHIP contains constraint systems over finite domains [23], Booleans <ref> [2] </ref> and rational numbers [11, 26], Prolog III [6] is endowed with constraint systems over Booleans, rational numbers, and lists, while CLP (&lt;) [13] solves constraints over real numbers.
Reference: [3] <author> J. Carlier and E. Pinson. </author> <title> Une Methode Arborescente pour Optimiser la Duree d'un JOB-SHOP. </title> <type> Technical Report ISSN 0294-2755, I.M.A, </type> <year> 1986. </year> <month> 24 </month>
Reference-contexts: These approaches are orthogonal and complementary. The global search paradigm has been used successfully to solve a large variety of combinatorial search problems with reasonable efficiency (e.g. scheduling <ref> [3] </ref>, graph coloring [14], Hamiltonian circuits [5], microcode labeling [10]) and provides, at the same time, the basis for exact methods as well as approximate solutions (giving rise to the so-called "anytime algorithms" [7]).
Reference: [4] <author> J.W. Chinneck, R.A. Goubran, G.M. Karam, and M Lavoie. </author> <title> A Design Approach For Real-Time Multiprocessor DSP Applications. </title> <type> Report sce-90-05, </type> <institution> Carleton University, </institution> <address> Ottawa, Canada, </address> <month> February </month> <year> 1990. </year>
Reference-contexts: Moreover, the design of multiprocessor DSP systems has emerged as one of the most promising directions. Recently, Chinneck and al. <ref> [4, 15] </ref> have proposed a new approach to the design of DSP applications, that couples an extensible architecture with an automatic task to processor scheduling method. <p> In addition, it provides a real-time simulation tool for systems that will eventually be implemented on a VLSI chip. In the rest of this section, we review the key ideas behind the architecture and introduce the main combinatorial search problems. The presentation is based on <ref> [4, 15] </ref> where complete information on the approach can be found. 4.1.1 The Architecture The extensible architecture is depicted in Figure 4 from [15]. It captures two common paradigms of DSP applications: pipelined processing and master-slave processing. <p> Consider for instance the computation step where the program tries to assign a processor to a task. If there are several processors unused at this computation step, it would be convenient to restrict attention to only one of them. It turns out <ref> [4] </ref> that this idea is only applicable under restricted circumstances, namely when all tasks which are on a parallel pipeline with the task being considered have been assigned already.
Reference: [5] <author> N. Christofides. </author> <title> Graph Theory: An Algorithmic Approach. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: These approaches are orthogonal and complementary. The global search paradigm has been used successfully to solve a large variety of combinatorial search problems with reasonable efficiency (e.g. scheduling [3], graph coloring [14], Hamiltonian circuits <ref> [5] </ref>, microcode labeling [10]) and provides, at the same time, the basis for exact methods as well as approximate solutions (giving rise to the so-called "anytime algorithms" [7]).
Reference: [6] <author> A. Colmerauer. </author> <title> An Introduction to Prolog III. </title> <journal> CACM, </journal> <volume> 28(4) </volume> <pages> 412-418, </pages> <year> 1990. </year>
Reference-contexts: For instance, CHIP contains constraint systems over finite domains [23], Booleans [2] and rational numbers [11, 26], Prolog III <ref> [6] </ref> is endowed with constraint systems over Booleans, rational numbers, and lists, while CLP (&lt;) [13] solves constraints over real numbers. <p> Placing 21 squares in a master square is of particular interest since 21 is the smallest number of squares that can fit in a square. This problem and its variations have attracted much attention in the CLP community. Colmerauer <ref> [6] </ref> presents a program to fill a rectangle with squares of different sizes using linear equations, inequalities, and disequations over rational numbers.
Reference: [7] <author> T. Dean and M. Boddy. </author> <title> An Analysis of Time-dependent Planning. </title> <booktitle> In Proceedings of the Seventh National Conference On Artificial Intelligence, </booktitle> <pages> pages 49-54, </pages> <address> Minneapolis, Minnesota, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: been used successfully to solve a large variety of combinatorial search problems with reasonable efficiency (e.g. scheduling [3], graph coloring [14], Hamiltonian circuits [5], microcode labeling [10]) and provides, at the same time, the basis for exact methods as well as approximate solutions (giving rise to the so-called "anytime algorithms" <ref> [7] </ref>). The purpose of this paper is to demonstrate the use of CLP languages for solving discrete combinatorial search problems such as assignment, scheduling and packing problems by showing the solutions of two problems.
Reference: [8] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving a Cutting-Stock Problem in Constraint Logic Programming. </title> <booktitle> In Fifth International Conference on Logic Programming, </booktitle> <address> Seattle, WA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: We show a cc (FD) program which is about 4 pages long and compares well with a specific branch and bound algorithm especially designed for the task. Other applications of CLP languages over finite domains to similar problems can be found in <ref> [9, 8, 10, 23, 22] </ref>. The rest of the paper is organized as follows. The next section gives an overview of the features of cc (FD) used in the applications. Each feature is illustrated on scheduling examples and provide the necessary background for the two applications.
Reference: [9] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving the Car Sequencing Problem in Constraint Logic Programming. </title> <booktitle> In European Conference on Artificial Intelligence (ECAI-88), </booktitle> <address> Munich, </address> <publisher> W. </publisher> <address> Germany, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: We show a cc (FD) program which is about 4 pages long and compares well with a specific branch and bound algorithm especially designed for the task. Other applications of CLP languages over finite domains to similar problems can be found in <ref> [9, 8, 10, 23, 22] </ref>. The rest of the paper is organized as follows. The next section gives an overview of the features of cc (FD) used in the applications. Each feature is illustrated on scheduling examples and provide the necessary background for the two applications.
Reference: [10] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck. </author> <title> Solving Large Combinatorial Problems in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 8(1-2):75-93, </volume> <year> 1990. </year>
Reference-contexts: These approaches are orthogonal and complementary. The global search paradigm has been used successfully to solve a large variety of combinatorial search problems with reasonable efficiency (e.g. scheduling [3], graph coloring [14], Hamiltonian circuits [5], microcode labeling <ref> [10] </ref>) and provides, at the same time, the basis for exact methods as well as approximate solutions (giving rise to the so-called "anytime algorithms" [7]). <p> We show a cc (FD) program which is about 4 pages long and compares well with a specific branch and bound algorithm especially designed for the task. Other applications of CLP languages over finite domains to similar problems can be found in <ref> [9, 8, 10, 23, 22] </ref>. The rest of the paper is organized as follows. The next section gives an overview of the features of cc (FD) used in the applications. Each feature is illustrated on scheduling examples and provide the necessary background for the two applications. <p> Example 7 In scheduling applications, disjunctive constraints arise when two tasks cannot be scheduled at the same time because, for instance, they use the same resource. In <ref> [23, 10] </ref>, disjunctive constraints were expressed through a non-deterministic procedure as follows: disjunctive (S1,D1,S2,D2) :- S1 S2 + D2. disjunctive (S1,D1,S2,D2) :- S2 S1 + D1. where S1,S2 are the starting dates of two tasks and D1,D2 their respective durations. <p> The indomain predicate is a nondeterministic predicate trying all possible values for the variable. Note that, in the above program, cc (FD) finds the optimal solution without any backtracking. For disjunctive scheduling, the labeling generally contains also a procedure to choose the ordering between the tasks <ref> [10, 23] </ref>. 3 The Perfect Square Problem 3.1 Problem Statement The problem amounts to packing a number of squares, all of different sizes, in a larger square, called the master square, in such a way that the squares do not overlap and leave no empty space.
Reference: [11] <author> T. Graf. </author> <title> Extending Constraint Handling in Logic Programming to Rational Arithmetic. </title> <type> Internal Report, </type> <institution> ECRC, Munich, </institution> <month> Septembre </month> <year> 1987. </year>
Reference-contexts: The CLP scheme can be instantiated to produce a specific language by defining a constraint system (i.e. defining a set of primitive constraints and providing a constraint solver for the constraints). For instance, CHIP contains constraint systems over finite domains [23], Booleans [2] and rational numbers <ref> [11, 26] </ref>, Prolog III [6] is endowed with constraint systems over Booleans, rational numbers, and lists, while CLP (&lt;) [13] solves constraints over real numbers.
Reference: [12] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In POPL-87, </booktitle> <address> Munich, FRG, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Constraint Logic Programming (CLP) is a new class of declarative programming languages combining nondeterminism and constraint solving. The fundamental idea behind these languages, to use constraint solving instead of unification as the kernel operation of the language, was elegantly captured in the CLP scheme <ref> [12] </ref>. The CLP scheme can be instantiated to produce a specific language by defining a constraint system (i.e. defining a set of primitive constraints and providing a constraint solver for the constraints).
Reference: [13] <author> J. Jaffar and S. Michaylov. </author> <title> Methodology and Implementation of a CLP System. </title> <booktitle> In Fourth International Conference on Logic Programming, </booktitle> <address> Melbourne, Australia, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: For instance, CHIP contains constraint systems over finite domains [23], Booleans [2] and rational numbers [11, 26], Prolog III [6] is endowed with constraint systems over Booleans, rational numbers, and lists, while CLP (&lt;) <ref> [13] </ref> solves constraints over real numbers. The CLP scheme was further generalized into the cc framework of concurrent constraint programming [19, 20, 21] to accommodate additional constraint operations (e.g. constraint entailment [17]) and new ways of combining them (e.g. implication or blocking ask [19] and cardinality [24]).
Reference: [14] <author> M. Kubale and D. Jackowski. </author> <title> A Generalized Implicit Enumeration Algorithm for Graph Coloring. </title> <journal> CACM, </journal> <volume> 28(4) </volume> <pages> 412-418, </pages> <year> 1985. </year>
Reference-contexts: These approaches are orthogonal and complementary. The global search paradigm has been used successfully to solve a large variety of combinatorial search problems with reasonable efficiency (e.g. scheduling [3], graph coloring <ref> [14] </ref>, Hamiltonian circuits [5], microcode labeling [10]) and provides, at the same time, the basis for exact methods as well as approximate solutions (giving rise to the so-called "anytime algorithms" [7]).
Reference: [15] <author> Marco Lavoie. </author> <title> Task Assignment In A DSP Multiprocessor Environment. </title> <type> Master Thesis, </type> <institution> Department of Systems and Computer Engineering, Carleton University, </institution> <address> Ottawa, Ontario, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Moreover, the design of multiprocessor DSP systems has emerged as one of the most promising directions. Recently, Chinneck and al. <ref> [4, 15] </ref> have proposed a new approach to the design of DSP applications, that couples an extensible architecture with an automatic task to processor scheduling method. <p> In addition, it provides a real-time simulation tool for systems that will eventually be implemented on a VLSI chip. In the rest of this section, we review the key ideas behind the architecture and introduce the main combinatorial search problems. The presentation is based on <ref> [4, 15] </ref> where complete information on the approach can be found. 4.1.1 The Architecture The extensible architecture is depicted in Figure 4 from [15]. It captures two common paradigms of DSP applications: pipelined processing and master-slave processing. <p> In the rest of this section, we review the key ideas behind the architecture and introduce the main combinatorial search problems. The presentation is based on [4, 15] where complete information on the approach can be found. 4.1.1 The Architecture The extensible architecture is depicted in Figure 4 from <ref> [15] </ref>. It captures two common paradigms of DSP applications: pipelined processing and master-slave processing. The master (processor 1) has a direct communication link with all processors in the pipeline whereas processor i in the pipeline can read from its predecessor (processor i 1) and write to its successor (processor i+1). <p> The programming task consisted of stating the constraints and coming with a suitable labeling procedure. Note also the adequacy of the cardinality operator to express sophisticated constraints such as the capacity and delay constraints. Table 1 presents a description of actual DSP applications taken from <ref> [15] </ref>. The first column describes the name of the applications, the second column the size of the task graph, the third column the number of processors available and the last column the topology of the applications. The first problems are small, the last one being already much larger. <p> the total delay of the optimal solution, the third column the times of the cc (FD) program with the depth-first labeling strategy, the fourth column the times of the cc (FD) program with the breath-first labeling strategy, and the fifth column the times of the specialized branch and bound of <ref> [15] </ref>. All times are given in seconds for a SUN 4/60. On these actual applications, the cc (FD) program behaves much better in general with the depth-first strategy than with the breath-first strategy. In particular, it is about 14, 2230, 59 times faster on RDAD04, RDAD08, and RDAD40.
Reference: [16] <author> A.K. Mackworth. </author> <title> Consistency in Networks of Relations. </title> <journal> Artificial Intelligence, </journal> <volume> 8(1) </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: Once again, the semantics of the relations is the standard one. 2 Several combinators of cc (FD) permit more sophisticated search procedures. 6 Since deciding FD-constraints is NP-complete, the constraint solver in cc (FD) is in-complete and enforces arc-consistency <ref> [16] </ref> on the constraints (instead of full consistency). Intuitively, arc-consistency reduces the domains of the variables by removing values which are not locally consistent. Definition 3 Let x 1 ; . . . ; x n be variables with domains D 1 ; . . . ; D n . <p> The constraint solver of cc (FD) is based on AC-5 [25], a generic arc-consistency algorithm which can be specialized to AC-4 [18] and AC-3 <ref> [16] </ref>. In addition, AC-5 can be instantiated to produce an O (cd) algorithm, where c is the number of constraints and d is the size of the largest domain, for many classes of binary constraints, including functional and monotone constraints and their piecewise generalizations.
Reference: [17] <author> M.J. Maher. </author> <title> Logic Semantics for a Class of Committed-Choice Programs. </title> <booktitle> In Fourth International Conference on Logic Programming, </booktitle> <pages> pages 858-876, </pages> <address> Melbourne, Australia, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: The CLP scheme was further generalized into the cc framework of concurrent constraint programming [19, 20, 21] to accommodate additional constraint operations (e.g. constraint entailment <ref> [17] </ref>) and new ways of combining them (e.g. implication or blocking ask [19] and cardinality [24]).
Reference: [18] <author> R. Mohr and T.C. Henderson. </author> <title> Arc and Path Consistency Revisited. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 225-233, </pages> <year> 1986. </year> <month> 25 </month>
Reference-contexts: The constraint solver of cc (FD) is based on AC-5 [25], a generic arc-consistency algorithm which can be specialized to AC-4 <ref> [18] </ref> and AC-3 [16]. In addition, AC-5 can be instantiated to produce an O (cd) algorithm, where c is the number of constraints and d is the size of the largest domain, for many classes of binary constraints, including functional and monotone constraints and their piecewise generalizations.
Reference: [19] <author> V.A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie--Mellon University, </institution> <year> 1989. </year>
Reference-contexts: The CLP scheme was further generalized into the cc framework of concurrent constraint programming <ref> [19, 20, 21] </ref> to accommodate additional constraint operations (e.g. constraint entailment [17]) and new ways of combining them (e.g. implication or blocking ask [19] and cardinality [24]). <p> The CLP scheme was further generalized into the cc framework of concurrent constraint programming [19, 20, 21] to accommodate additional constraint operations (e.g. constraint entailment [17]) and new ways of combining them (e.g. implication or blocking ask <ref> [19] </ref> and cardinality [24]). CLP languages 1 support, in a declarative way, the solving of combinatorial search prob 1 In the following, we use the term CLP languages generically to denote both CLP and cc languages. 1 lems using the global search paradigm.
Reference: [20] <author> V.A. Saraswat and M. Rinard. </author> <title> Concurrent Constraint Programming. </title> <booktitle> In Proceedings of Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: The CLP scheme was further generalized into the cc framework of concurrent constraint programming <ref> [19, 20, 21] </ref> to accommodate additional constraint operations (e.g. constraint entailment [17]) and new ways of combining them (e.g. implication or blocking ask [19] and cardinality [24]).
Reference: [21] <author> V.A. Saraswat, M. Rinard, and P. Panangaden. </author> <title> Semantic Foundations of Concurrent Constraint Programming. </title> <booktitle> In Proceedings of Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Orlando, FL, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: The CLP scheme was further generalized into the cc framework of concurrent constraint programming <ref> [19, 20, 21] </ref> to accommodate additional constraint operations (e.g. constraint entailment [17]) and new ways of combining them (e.g. implication or blocking ask [19] and cardinality [24]).
Reference: [22] <author> P. Van Hentenryck. </author> <title> A Logic Language for Combinatorial Optimization. </title> <journal> Annals of Operations Research, </journal> <volume> 21 </volume> <pages> 247-274, </pages> <year> 1989. </year>
Reference-contexts: We show a cc (FD) program which is about 4 pages long and compares well with a specific branch and bound algorithm especially designed for the task. Other applications of CLP languages over finite domains to similar problems can be found in <ref> [9, 8, 10, 23, 22] </ref>. The rest of the paper is organized as follows. The next section gives an overview of the features of cc (FD) used in the applications. Each feature is illustrated on scheduling examples and provide the necessary background for the two applications.
Reference: [23] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. Logic Programming Series, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: The CLP scheme can be instantiated to produce a specific language by defining a constraint system (i.e. defining a set of primitive constraints and providing a constraint solver for the constraints). For instance, CHIP contains constraint systems over finite domains <ref> [23] </ref>, Booleans [2] and rational numbers [11, 26], Prolog III [6] is endowed with constraint systems over Booleans, rational numbers, and lists, while CLP (&lt;) [13] solves constraints over real numbers. <p> We show a cc (FD) program which is about 4 pages long and compares well with a specific branch and bound algorithm especially designed for the task. Other applications of CLP languages over finite domains to similar problems can be found in <ref> [9, 8, 10, 23, 22] </ref>. The rest of the paper is organized as follows. The next section gives an overview of the features of cc (FD) used in the applications. Each feature is illustrated on scheduling examples and provide the necessary background for the two applications. <p> Example 7 In scheduling applications, disjunctive constraints arise when two tasks cannot be scheduled at the same time because, for instance, they use the same resource. In <ref> [23, 10] </ref>, disjunctive constraints were expressed through a non-deterministic procedure as follows: disjunctive (S1,D1,S2,D2) :- S1 S2 + D2. disjunctive (S1,D1,S2,D2) :- S2 S1 + D1. where S1,S2 are the starting dates of two tasks and D1,D2 their respective durations. <p> The indomain predicate is a nondeterministic predicate trying all possible values for the variable. Note that, in the above program, cc (FD) finds the optimal solution without any backtracking. For disjunctive scheduling, the labeling generally contains also a procedure to choose the ordering between the tasks <ref> [10, 23] </ref>. 3 The Perfect Square Problem 3.1 Problem Statement The problem amounts to packing a number of squares, all of different sizes, in a larger square, called the master square, in such a way that the squares do not overlap and leave no empty space.
Reference: [24] <author> P. Van Hentenryck and Y. Deville. </author> <title> The Cardinality Operator: A new Logical Connective and its Application to Constraint Logic Programming. </title> <booktitle> In Eighth International Conference on Logic Programming (ICLP-91), </booktitle> <address> Paris (France), </address> <month> June </month> <year> 1991. </year>
Reference-contexts: The CLP scheme was further generalized into the cc framework of concurrent constraint programming [19, 20, 21] to accommodate additional constraint operations (e.g. constraint entailment [17]) and new ways of combining them (e.g. implication or blocking ask [19] and cardinality <ref> [24] </ref>). CLP languages 1 support, in a declarative way, the solving of combinatorial search prob 1 In the following, we use the term CLP languages generically to denote both CLP and cc languages. 1 lems using the global search paradigm.
Reference: [25] <author> P. Van Hentenryck, Y. Deville, </author> <title> and C.M. Teng. A Generic Arc Consistency Algorithm and its Specializations. </title> <journal> Artificial Intelligence, </journal> <note> 1992. Accepted for publication. </note>
Reference-contexts: The constraint solver of cc (FD) is based on AC-5 <ref> [25] </ref>, a generic arc-consistency algorithm which can be specialized to AC-4 [18] and AC-3 [16].
Reference: [26] <author> P. Van Hentenryck and T. Graf. </author> <title> Standard Forms for Rational Linear Arithmetics in Constraint Logic Programming. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <note> 1992. To Appear. A preliminary version was presented at The International Symposium on Artificial Intelligence and Mathematics, </note> <institution> Fort Lauderdale, </institution> <address> Fl, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: The CLP scheme can be instantiated to produce a specific language by defining a constraint system (i.e. defining a set of primitive constraints and providing a constraint solver for the constraints). For instance, CHIP contains constraint systems over finite domains [23], Booleans [2] and rational numbers <ref> [11, 26] </ref>, Prolog III [6] is endowed with constraint systems over Booleans, rational numbers, and lists, while CLP (&lt;) [13] solves constraints over real numbers.
Reference: [27] <author> P. Van Hentenryck, H. Simonis, and M. Dincbas. </author> <title> Constraint Satisfaction Using Constraint Logic Programming. </title> <journal> Artificial Intelligence, </journal> <note> 1992. (Special Issue on Constraint-Based Reasoning), accepted for publication. 26 </note>
Reference-contexts: More sophisticated handlings of disjunctions, taking for instance several tasks simultaneously, are possible in cc (FD) using, for instance, the cardinality combinator in conjunction with the implication combinator <ref> [27] </ref>. Note also that, in the perfect square problem, the above handling of disjunctions is generalized to 2 dimensions. Example 8 The cardinality combinator also enables to link Boolean variables (i.e. 0-1 domain variables) with a constraint in the following way: B 2 0..1, #( B, [C], B ).
References-found: 27

