URL: http://www.cs.unc.edu/~zhangh/technotes/shadow/shadow.ps
Refering-URL: http://www.cs.unc.edu/~zhangh/research.html
Root-URL: http://www.cs.unc.edu
Email: zhangh@cs.unc.edu  
Title: Forward Shadow Mapping  
Author: Hansong Zhang 
Address: Chapel Hill  
Affiliation: Department of Computer Science University of North Carolina at  
Pubnum: TR98-003  
Abstract: Forward shadow mapping is a new approach to real-time shadow generation. The traditional shadow map algorithm maps the pixels in the eye's view backward into the depth buffers of light sources (i.e. shadow maps), which is similiar to and often implemented as an extension to texture mapping. Our algorithm reverses this process by using 3-D image warping techniques to transform shadow map pixels forward into the eye's view to directly indicate which pixels are lit; it does not interfere with normal texture mapping and easily supports anti-aliased shadow edges and projective textures. Access to shadow maps and projective textures is in pixel-sequential order. This algorithm has advantages when speed of texture mapping becomes the performance bottleneck, which is often the case in visual simulation and game applications. CR Categories and Subject Descriptors: I.3.5 [Computer Graphics]: Picture/Image Generation; I.3.7 [Computer Graphics]: Three Dimensional Graphics and Realism color, shading, shadowing, and texture Key Words and Phrases: Shadow, lighting, image based rendering, 3D image warping, texture mapping 
Abstract-found: 1
Intro-found: 1
Reference: [Ake93] <author> Kurt Akeley. </author> <title> RealityEngine graphics. </title> <booktitle> In Computer Graphics (SIG-GRAPH '93 Proceedings), </booktitle> <volume> volume 27, </volume> <pages> pages 109-116, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: These improvements alleviate aliasing and produce soft shadow edges. [SKW + 92] recognizes that projective textures and shadow maps are both a simple extension to perspective-correct texture mapping; as a result, graphics systems such as the RealityEngine 2 <ref> [Ake93] </ref> have sucessfully supported real-time shadows. The implementation of shadow maps on the PixelFlow [EMP + 97], a very different architecture, is also a variation of texture mapping. Extensive sharing of texture mapping hardware makes shadow maps easier and less expensive to implement.
Reference: [App68] <author> A. Appel. </author> <title> Some techniques for shading machine renderings of solids. </title> <booktitle> In IFIP, </booktitle> <volume> volume 32, </volume> <pages> pages 37-45, </pages> <year> 1968. </year>
Reference-contexts: However, speed of texture mapping is often the limiting factor in modern graphics applications, and sharing of critical resources can lead to severe system imbalance. Many other shadow algorithms have been developed. Compared to depth-buffer-based algorithms, they have limitations in generality, scalability and speed. Scanline shadow algorithms <ref> [App68, BK70] </ref> requires significant pre-processing and are thus not suitable for moving objects and lights.
Reference: [AWG78] <author> P. Atherton, K. Weiler, and D. Greenberg. </author> <title> Polygon shadow generation. </title> <booktitle> In Computer Graphics (SIGGRAPH '78 Proceedings), </booktitle> <volume> volume 12, </volume> <pages> pages 275-281, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: Many other shadow algorithms have been developed. Compared to depth-buffer-based algorithms, they have limitations in generality, scalability and speed. Scanline shadow algorithms [App68, BK70] requires significant pre-processing and are thus not suitable for moving objects and lights. Polygon subdivision <ref> [AWG78, NN85] </ref>, shadow volume algorithms [Cro77, BB84, TN85, Ber86, Max86, FGH + 85, Hei91], and the BSP-tree shadow volume method [CF89, CF92] are restricted to polygonal models and inefficient for scenes with a large number of polygons. Polygon subdivision algorithms algorithm is also difficult to implement robustly.
Reference: [BB84] <author> L. S. Brotman and N. I. Badler. </author> <title> Generating soft shadows with a depth buffer algorithm. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 4(10) </volume> <pages> 71-81, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: Many other shadow algorithms have been developed. Compared to depth-buffer-based algorithms, they have limitations in generality, scalability and speed. Scanline shadow algorithms [App68, BK70] requires significant pre-processing and are thus not suitable for moving objects and lights. Polygon subdivision [AWG78, NN85], shadow volume algorithms <ref> [Cro77, BB84, TN85, Ber86, Max86, FGH + 85, Hei91] </ref>, and the BSP-tree shadow volume method [CF89, CF92] are restricted to polygonal models and inefficient for scenes with a large number of polygons. Polygon subdivision algorithms algorithm is also difficult to implement robustly.
Reference: [Ber86] <author> P. Bergeron. </author> <title> A general version of crow'S shadow volumes. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 6(9) </volume> <pages> 17-28, </pages> <year> 1986. </year>
Reference-contexts: Many other shadow algorithms have been developed. Compared to depth-buffer-based algorithms, they have limitations in generality, scalability and speed. Scanline shadow algorithms [App68, BK70] requires significant pre-processing and are thus not suitable for moving objects and lights. Polygon subdivision [AWG78, NN85], shadow volume algorithms <ref> [Cro77, BB84, TN85, Ber86, Max86, FGH + 85, Hei91] </ref>, and the BSP-tree shadow volume method [CF89, CF92] are restricted to polygonal models and inefficient for scenes with a large number of polygons. Polygon subdivision algorithms algorithm is also difficult to implement robustly.
Reference: [BK70] <author> W. J. Bouknight and K. C. Kelly. </author> <title> An algorithm for producing halftone computer graphics presentations with shadows and movable light sources. </title> <booktitle> In Proc. AFIPS JSCC, </booktitle> <volume> volume 36, </volume> <pages> pages 1-10, </pages> <year> 1970. </year>
Reference-contexts: However, speed of texture mapping is often the limiting factor in modern graphics applications, and sharing of critical resources can lead to severe system imbalance. Many other shadow algorithms have been developed. Compared to depth-buffer-based algorithms, they have limitations in generality, scalability and speed. Scanline shadow algorithms <ref> [App68, BK70] </ref> requires significant pre-processing and are thus not suitable for moving objects and lights.
Reference: [CF89] <author> Norman Chin and Steven Feiner. </author> <title> Near real-time shadow generation using BSP trees. </title> <booktitle> In Computer Graphics (SIGGRAPH '89 Proceedings), </booktitle> <volume> volume 23, </volume> <pages> pages 99-106, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Scanline shadow algorithms [App68, BK70] requires significant pre-processing and are thus not suitable for moving objects and lights. Polygon subdivision [AWG78, NN85], shadow volume algorithms [Cro77, BB84, TN85, Ber86, Max86, FGH + 85, Hei91], and the BSP-tree shadow volume method <ref> [CF89, CF92] </ref> are restricted to polygonal models and inefficient for scenes with a large number of polygons. Polygon subdivision algorithms algorithm is also difficult to implement robustly. For a survey of some of the algorithms see [WPF90].
Reference: [CF92] <author> Norman Chin and Steven Feiner. </author> <title> Fast object-precision shadow generation for areal light sources using BSP trees. </title> <booktitle> In Computer Graphics (1992 Symposium on Interactive 3D Graphics), </booktitle> <volume> volume 25, </volume> <pages> pages 21-30, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Scanline shadow algorithms [App68, BK70] requires significant pre-processing and are thus not suitable for moving objects and lights. Polygon subdivision [AWG78, NN85], shadow volume algorithms [Cro77, BB84, TN85, Ber86, Max86, FGH + 85, Hei91], and the BSP-tree shadow volume method <ref> [CF89, CF92] </ref> are restricted to polygonal models and inefficient for scenes with a large number of polygons. Polygon subdivision algorithms algorithm is also difficult to implement robustly. For a survey of some of the algorithms see [WPF90].
Reference: [CG85] <author> Michael F. Cohen and Donald P. Greenberg. </author> <title> The Hemi-Cube: A radiosity solution for complex environments. </title> <booktitle> In Computer Graphics (SIGGRAPH '85 Proceedings), </booktitle> <volume> volume 19, </volume> <pages> pages 31-40, </pages> <month> August </month> <year> 1985. </year> <month> 9 </month>
Reference-contexts: Polygon subdivision algorithms algorithm is also difficult to implement robustly. For a survey of some of the algorithms see [WPF90]. Ray-tracing [Whi79, Kay79] and radiosity algorithms <ref> [GTGB84, CG85] </ref> produce high-quality shadows, but are still too expensive for real-time purposes. Another area of research to which our work is related is image based rendering (IBR).
Reference: [Cro77] <author> Franklin C. Crow. </author> <title> Shadow algorithms for computer graphics. </title> <booktitle> In Com--puter Graphics (SIGGRAPH '77 Proceedings), </booktitle> <volume> volume 11, </volume> <pages> pages 242-248, </pages> <month> July </month> <year> 1977. </year>
Reference-contexts: Many other shadow algorithms have been developed. Compared to depth-buffer-based algorithms, they have limitations in generality, scalability and speed. Scanline shadow algorithms [App68, BK70] requires significant pre-processing and are thus not suitable for moving objects and lights. Polygon subdivision [AWG78, NN85], shadow volume algorithms <ref> [Cro77, BB84, TN85, Ber86, Max86, FGH + 85, Hei91] </ref>, and the BSP-tree shadow volume method [CF89, CF92] are restricted to polygonal models and inefficient for scenes with a large number of polygons. Polygon subdivision algorithms algorithm is also difficult to implement robustly.
Reference: [CW93] <author> Shenchang Eric Chen and Lance Williams. </author> <title> View interpolation for image synthesis. </title> <booktitle> In Computer Graphics (SIGGRAPH '93 Proceedings), </booktitle> <volume> volume 27, </volume> <pages> pages 279-288, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: The goal of IBR is to generate an image for a view (the destination image) directly from existing images for other views (source images), without an explicit geometric representation of the scene. The basic operation is the transformation of source image pixels to the destination image. <ref> [CW93] </ref> proposed a view interpolation method based on pre-computed per-pixel optical flow information. [MB95] points out that with per-pixel disparity values (which actually make pixels 3-D entities), source pixels can be re-projected directly into the destination image.
Reference: [DSV97] <author> Lucia Darsa, Bruno C. Silva, and Amitabh Varshney. </author> <title> Navigating static environments using image-space simplification and morphing. </title> <booktitle> In 1997 Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 7-16, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: Another way of generating a destination image from source images is to first reconstruct geometry from source images, and then render them for the destination view <ref> [DSV97, SDB97] </ref>. For scenes with large near-planar structures, this can be faster than per-pixel 3-D warping. On the other hand, it requires substantial computation in reconstruction, and thus is not applicable when source images change frequently. 1 It is often unclear whether a "depth" image has disparity or Z values.
Reference: [DWS + 88] <author> Michael Deering, Stephanie Winner, Bic Schediwy, Chris Duffy, and Neil Hunt. </author> <title> The triangle processor and normal vector shader: A VLSI system for high performance graphics. </title> <booktitle> In Computer Graphics (SIG-GRAPH '88 Proceedings), </booktitle> <volume> volume 22, </volume> <pages> pages 21-30, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: In many applications, speed of texturing has become the bottleneck even without shadow maps. The use of a shadow map, which is equivalent to applying a texture map to all geometry in the scene (or all visible geometry, for deferred shading architectures <ref> [DWS + 88] </ref>) aggravates the situation. Shadow maps also compete with ordinary textures in the scene for texture memory.
Reference: [EMP + 97] <author> John Eyles, Steven Molnar, John Poulton, Trey Greer, Anselmo Lastra, Nick England, and Lee Westover. PixelFlow: </author> <title> The realization. </title> <booktitle> In 1997 SIGGRAPH / Eurographics Workshop on Graphics Hardware, </booktitle> <pages> pages 57-68. </pages> <publisher> ACM SIGGRAPH / Eurographics, ACM Press, </publisher> <month> August </month> <year> 1997. </year>
Reference-contexts: The implementation of shadow maps on the PixelFlow <ref> [EMP + 97] </ref>, a very different architecture, is also a variation of texture mapping. Extensive sharing of texture mapping hardware makes shadow maps easier and less expensive to implement.
Reference: [FGH + 85] <author> Henry Fuchs, Jack Goldfeather, Jeff P. Hultquist, Susan Spach, John D. Austin, Frederick P. Brooks, Jr., John G. Eyles, and John Poulton. </author> <title> Fast spheres, shadows, textures, transparencies, and image enhancements in Pixel-Planes. </title> <booktitle> In Computer Graphics (SIGGRAPH '85 Proceedings), </booktitle> <volume> volume 19, </volume> <pages> pages 111-120, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: Many other shadow algorithms have been developed. Compared to depth-buffer-based algorithms, they have limitations in generality, scalability and speed. Scanline shadow algorithms [App68, BK70] requires significant pre-processing and are thus not suitable for moving objects and lights. Polygon subdivision [AWG78, NN85], shadow volume algorithms <ref> [Cro77, BB84, TN85, Ber86, Max86, FGH + 85, Hei91] </ref>, and the BSP-tree shadow volume method [CF89, CF92] are restricted to polygonal models and inefficient for scenes with a large number of polygons. Polygon subdivision algorithms algorithm is also difficult to implement robustly.
Reference: [GHC97] <author> Steven Gortler, Liwei He, and Michael F. Cohen. </author> <title> Rendering layered depth images. </title> <type> Technical Report MSR-TR-97-09, </type> <institution> Microsoft Research, </institution> <year> 1997. </year>
Reference: [GTGB84] <author> Cindy M. Goral, Kenneth E. Torrance, Donald P. Greenberg, and Bennett Battaile. </author> <title> Modelling the interaction of light between diffuse surfaces. </title> <booktitle> In Computer Graphics (SIGGRAPH '84 Proceedings), </booktitle> <volume> volume 18, </volume> <pages> pages 212-22, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Polygon subdivision algorithms algorithm is also difficult to implement robustly. For a survey of some of the algorithms see [WPF90]. Ray-tracing [Whi79, Kay79] and radiosity algorithms <ref> [GTGB84, CG85] </ref> produce high-quality shadows, but are still too expensive for real-time purposes. Another area of research to which our work is related is image based rendering (IBR).
Reference: [Hei91] <author> Tim Heidmann. </author> <title> Real shadows, real time. </title> <journal> Iris Universe, </journal> <volume> 18 </volume> <pages> 28-31, </pages> <year> 1991. </year>
Reference-contexts: Many other shadow algorithms have been developed. Compared to depth-buffer-based algorithms, they have limitations in generality, scalability and speed. Scanline shadow algorithms [App68, BK70] requires significant pre-processing and are thus not suitable for moving objects and lights. Polygon subdivision [AWG78, NN85], shadow volume algorithms <ref> [Cro77, BB84, TN85, Ber86, Max86, FGH + 85, Hei91] </ref>, and the BSP-tree shadow volume method [CF89, CF92] are restricted to polygonal models and inefficient for scenes with a large number of polygons. Polygon subdivision algorithms algorithm is also difficult to implement robustly.
Reference: [HH97] <author> Paul S. Heckbert and Michael Herf. </author> <title> Simulating soft shadows with graphics hardware. </title> <type> Technical Report CMU-CS-97-104, </type> <institution> School of Computer Sciene, Carnegie Mellon University, </institution> <year> 1997. </year>
Reference: [HN85] <author> J. C. Hourcade and A. Nicolas. </author> <title> Algorithms for antialiased cast shadows. </title> <journal> Computers and Graphics, </journal> <volume> 9(3) </volume> <pages> 259-265, </pages> <year> 1985. </year>
Reference-contexts: The image-space nature of this algorithm makes it simple to implement, applicable to any kind of primitives, 2 easy to accelerate with hardware, and efficient enough to be used with complex scenes. To solve the aliasing problem of the original shadow map algorithm, <ref> [HN85] </ref> proposed the use of per-pixel object identifiers and [RSC87] introduced percentage closer filtering.
Reference: [Kay79] <author> Douglas S. Kay. </author> <title> Transparency, refraction, and ray tracing for computer synthesized images. </title> <type> Master's thesis, </type> <institution> Cornell U., </institution> <month> January </month> <year> 1979. </year>
Reference-contexts: Polygon subdivision algorithms algorithm is also difficult to implement robustly. For a survey of some of the algorithms see [WPF90]. Ray-tracing <ref> [Whi79, Kay79] </ref> and radiosity algorithms [GTGB84, CG85] produce high-quality shadows, but are still too expensive for real-time purposes. Another area of research to which our work is related is image based rendering (IBR).
Reference: [Max86] <author> Nelson L. Max. </author> <title> Atmospheric illumination and shadows. </title> <booktitle> In Computer Graphics (SIGGRAPH '86 Proceedings), </booktitle> <volume> volume 20, </volume> <pages> pages 117-24, </pages> <month> August </month> <year> 1986. </year> <month> 10 </month>
Reference-contexts: Many other shadow algorithms have been developed. Compared to depth-buffer-based algorithms, they have limitations in generality, scalability and speed. Scanline shadow algorithms [App68, BK70] requires significant pre-processing and are thus not suitable for moving objects and lights. Polygon subdivision [AWG78, NN85], shadow volume algorithms <ref> [Cro77, BB84, TN85, Ber86, Max86, FGH + 85, Hei91] </ref>, and the BSP-tree shadow volume method [CF89, CF92] are restricted to polygonal models and inefficient for scenes with a large number of polygons. Polygon subdivision algorithms algorithm is also difficult to implement robustly.
Reference: [MB95] <author> Leonard McMillan and Gary Bishop. </author> <title> Plenoptic modeling: An image--based rendering system. </title> <booktitle> In Computer Graphics (SIGGRAPH '95 Proceedings), </booktitle> <pages> pages 39-46. </pages> <publisher> ACM SIGGRAPH, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: The basic operation is the transformation of source image pixels to the destination image. [CW93] proposed a view interpolation method based on pre-computed per-pixel optical flow information. <ref> [MB95] </ref> points out that with per-pixel disparity values (which actually make pixels 3-D entities), source pixels can be re-projected directly into the destination image. This technique is also called 3-D image warping [MMB97], which is the term we use in this paper. <p> Blur the modulation image for antialiased shadow edges. 6. Apply the modulation image. It modulates the normally rendered, eye's image for shadows and lighting effects defined by the projective texture. 3.3 Transforming the Shadow Map We use existing 3-D warping techniques <ref> [MB95, Zha97] </ref> to warp the shadow map pixels to the eye's view. These techniques take advantage of the incremental nature of pixel-by-pixel computation, which results in much less operations than full (non-incremental) 3-D warping per pixel.
Reference: [McR96] <author> Organizer: Tom McReynolds. </author> <title> Programming with opengl: </title> <booktitle> Advanced rendering. SIGGRAPH'96 Course Notes, </booktitle> <pages> pages 27-28, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: Shadow maps also compete with ordinary textures in the scene for texture memory. It is often desirable to use a projective texture <ref> [McR96] </ref> (an image projected by the light) to model a light's variation in intensities, in order to achieve effects like spotlights with gradual fall-off or lights shining through stained glass; this means more textures for the scene. <p> This is an approximation to real shading, but in practice produces realistic-looking images. Modulation has been used for spotlight effects in <ref> [McR96] </ref>. It is also possible to draw modulation pixels directly into the framebuffer as soon as a shadow map pixel is warped. But, as will be discussed later, antialiasing can be easily done if we have the whole modulation image. 5 Steps of the algorithm are listed below.
Reference: [MMB97] <author> William R. Mark, Leonard McMillan, and Gary Bishop. </author> <title> Post-rendering 3d warping. </title> <booktitle> In 1997 Symposium on Interactive 3D Graphics, </booktitle> <pages> pages 7-16, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: This technique is also called 3-D image warping <ref> [MMB97] </ref>, which is the term we use in this paper. An image with per-pixel disparity or Z value is often called a depth image. 1 [Zha97] discusses 3-D image warp using the OpenGL [WND85] graphics model.
Reference: [NN85] <author> Tomoyuki Nishita and Eihachiro Nakamae. </author> <title> Continuous tone representation of three-dimensional objects taking account of shadows and interreflection. </title> <booktitle> In Computer Graphics (SIGGRAPH '85 Proceedings), </booktitle> <volume> volume 19, </volume> <pages> pages 23-30, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: Many other shadow algorithms have been developed. Compared to depth-buffer-based algorithms, they have limitations in generality, scalability and speed. Scanline shadow algorithms [App68, BK70] requires significant pre-processing and are thus not suitable for moving objects and lights. Polygon subdivision <ref> [AWG78, NN85] </ref>, shadow volume algorithms [Cro77, BB84, TN85, Ber86, Max86, FGH + 85, Hei91], and the BSP-tree shadow volume method [CF89, CF92] are restricted to polygonal models and inefficient for scenes with a large number of polygons. Polygon subdivision algorithms algorithm is also difficult to implement robustly.
Reference: [RSC87] <author> William T. Reeves, David H. Salesin, and Robert L. Cook. </author> <title> Rendering antialiased shadows with depth maps. </title> <booktitle> In Computer Graphics (SIG-GRAPH '87 Proceedings), </booktitle> <volume> volume 21, </volume> <pages> pages 283-291, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: To solve the aliasing problem of the original shadow map algorithm, [HN85] proposed the use of per-pixel object identifiers and <ref> [RSC87] </ref> introduced percentage closer filtering. These improvements alleviate aliasing and produce soft shadow edges. [SKW + 92] recognizes that projective textures and shadow maps are both a simple extension to perspective-correct texture mapping; as a result, graphics systems such as the RealityEngine 2 [Ake93] have sucessfully supported real-time shadows. <p> The bigger the filter kernel, the softer the edges appear, and the less precise the edge positions. It is interesting to note that the effect of blurring is analogous to the percentage closer sampling for antialiasing <ref> [RSC87] </ref> in the traditional shadow map algorithm, but enjoys better memory access behavior. <p> In hardware implementations, BSM borrows the random look-up capacity built into texturing mapping hardware and adds depth comparisons as a shadow map 2 Note that it is the results of depth comparison, not the depth values themselves, that are interpolated <ref> [RSC87] </ref>. 7 specific extension. 3 FSM, on the other hand, shares hardware with an ordinary framebuffer (the color and Z buffers), which provides random memory access needed by the warped pixels for depth comparisons and accumulation of light intensities. No special-purpose extension is needed.
Reference: [SDB97] <author> Fran~cois Sillion, George Drettakis, and Benoit Bodelet. </author> <title> Efficient impostor manipulation for real-time visualization of urban scenery. </title> <booktitle> In Computer Graphics Forum (Proc. of Eurographics '97), </booktitle> <volume> volume 16, </volume> <pages> pages 207-218, </pages> <address> Budapest, Hungary, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: Another way of generating a destination image from source images is to first reconstruct geometry from source images, and then render them for the destination view <ref> [DSV97, SDB97] </ref>. For scenes with large near-planar structures, this can be faster than per-pixel 3-D warping. On the other hand, it requires substantial computation in reconstruction, and thus is not applicable when source images change frequently. 1 It is often unclear whether a "depth" image has disparity or Z values.
Reference: [SKW + 92] <author> Mark Segal, Carl Korobkin, Rolf van Widenfelt, Jim Foran, and Paul E. Haeberli. </author> <title> Fast shadows and lighting effects using texture mapping. </title> <booktitle> In Computer Graphics (SIGGRAPH '92 Proceedings), </booktitle> <volume> volume 26, </volume> <pages> pages 249-252, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: To solve the aliasing problem of the original shadow map algorithm, [HN85] proposed the use of per-pixel object identifiers and [RSC87] introduced percentage closer filtering. These improvements alleviate aliasing and produce soft shadow edges. <ref> [SKW + 92] </ref> recognizes that projective textures and shadow maps are both a simple extension to perspective-correct texture mapping; as a result, graphics systems such as the RealityEngine 2 [Ake93] have sucessfully supported real-time shadows.
Reference: [TN85] <author> E. Nakamae T. Nishita, I. Okamura. </author> <title> Continuous tone representation of three-dimensional objects taking account of shadows and interreflec-tion. </title> <journal> ACM Transaction on Graphics, </journal> <volume> 20(2) </volume> <pages> 123-146, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Many other shadow algorithms have been developed. Compared to depth-buffer-based algorithms, they have limitations in generality, scalability and speed. Scanline shadow algorithms [App68, BK70] requires significant pre-processing and are thus not suitable for moving objects and lights. Polygon subdivision [AWG78, NN85], shadow volume algorithms <ref> [Cro77, BB84, TN85, Ber86, Max86, FGH + 85, Hei91] </ref>, and the BSP-tree shadow volume method [CF89, CF92] are restricted to polygonal models and inefficient for scenes with a large number of polygons. Polygon subdivision algorithms algorithm is also difficult to implement robustly.
Reference: [Wes90] <author> Lee Westover. </author> <title> Footprint evaluation for volume rendering. </title> <booktitle> In Computer Graphics (SIGGRAPH '90 Proceedings), </booktitle> <volume> volume 24, </volume> <pages> pages 367-376, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Similar to texture mapping, BSM resamples by interpolating the nearby samples for a new sampling location 2 . FSM resembles splatting <ref> [Wes90] </ref>, in which each light-space sample leaves a "footprint" (i.e. area covered by the warped pixel) on the eye's image. In this paper we have assumed simple footprints to reduce amount of computation.
Reference: [Whi79] <author> T. Whitted. </author> <title> An improved illumination model for shaded display. </title> <journal> In Computer Graphics (Special SIGGRAPH '79 Issue), </journal> <volume> volume 13, </volume> <pages> pages 1-14, </pages> <month> August </month> <year> 1979. </year>
Reference-contexts: Polygon subdivision algorithms algorithm is also difficult to implement robustly. For a survey of some of the algorithms see [WPF90]. Ray-tracing <ref> [Whi79, Kay79] </ref> and radiosity algorithms [GTGB84, CG85] produce high-quality shadows, but are still too expensive for real-time purposes. Another area of research to which our work is related is image based rendering (IBR).
Reference: [Wil78] <author> Lance Williams. </author> <title> Casting curved shadows on curved surfaces. </title> <booktitle> In Computer Graphics (SIGGRAPH '78 Proceedings), </booktitle> <volume> volume 12, </volume> <pages> pages 270-274, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: Our algorithm show its advantages when graphics performance is bound by texture mapping; it also easily supports anti-aliased shadow edges and integrates projective textures into the shadow generation process. 2 Related Work Shadow map algorithms originated in <ref> [Wil78] </ref>, which proposed an algorithm that renders the scene in two passes with depth-buffering. The first pass is from the light sources and generates the shadow maps.
Reference: [WND85] <author> Mason Woo, Jackie Neider, and Tom Davis. </author> <title> OpenGL Programming Guide, 2nd Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: This technique is also called 3-D image warping [MMB97], which is the term we use in this paper. An image with per-pixel disparity or Z value is often called a depth image. 1 [Zha97] discusses 3-D image warp using the OpenGL <ref> [WND85] </ref> graphics model. Another way of generating a destination image from source images is to first reconstruct geometry from source images, and then render them for the destination view [DSV97, SDB97]. For scenes with large near-planar structures, this can be faster than per-pixel 3-D warping.
Reference: [WPF90] <author> Andrew Woo, Pierre Poulin, and Alain Fournier. </author> <title> A survey of shadow algorithms. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 10(6) </volume> <pages> 13-32, </pages> <month> November </month> <year> 1990. </year> <title> 11 texture is the same as in Figure 2. The modulation image is blurred for (a) and not blurred for (b). </title>
Reference-contexts: Polygon subdivision algorithms algorithm is also difficult to implement robustly. For a survey of some of the algorithms see <ref> [WPF90] </ref>. Ray-tracing [Whi79, Kay79] and radiosity algorithms [GTGB84, CG85] produce high-quality shadows, but are still too expensive for real-time purposes. Another area of research to which our work is related is image based rendering (IBR).
Reference: [Zha97] <author> Hansong Zhang. </author> <title> A traditionalist view of 3-d image warping. </title> <type> Technical Report 97-043, </type> <institution> Department of Computer Sciene, UNC-Chapel Hill, </institution> <month> September </month> <year> 1997. </year> <title> 12 texture is the same as in Figure 2. The modulation image is blurred for (a) and not blurred for (b). walking robot in a spotlight) 13 </title>
Reference-contexts: This technique is also called 3-D image warping [MMB97], which is the term we use in this paper. An image with per-pixel disparity or Z value is often called a depth image. 1 <ref> [Zha97] </ref> discusses 3-D image warp using the OpenGL [WND85] graphics model. Another way of generating a destination image from source images is to first reconstruct geometry from source images, and then render them for the destination view [DSV97, SDB97]. <p> Blur the modulation image for antialiased shadow edges. 6. Apply the modulation image. It modulates the normally rendered, eye's image for shadows and lighting effects defined by the projective texture. 3.3 Transforming the Shadow Map We use existing 3-D warping techniques <ref> [MB95, Zha97] </ref> to warp the shadow map pixels to the eye's view. These techniques take advantage of the incremental nature of pixel-by-pixel computation, which results in much less operations than full (non-incremental) 3-D warping per pixel. <p> These techniques take advantage of the incremental nature of pixel-by-pixel computation, which results in much less operations than full (non-incremental) 3-D warping per pixel. The method described in <ref> [Zha97] </ref> is especially suited to our purpose since it deals directly with z-values from the depth buffer and uses the same coordinate systems as in conventional 3-D graphics.
References-found: 36

