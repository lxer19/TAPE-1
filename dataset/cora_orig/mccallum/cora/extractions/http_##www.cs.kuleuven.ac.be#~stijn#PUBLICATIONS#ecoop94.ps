URL: http://www.cs.kuleuven.ac.be/~stijn/PUBLICATIONS/ecoop94.ps
Refering-URL: http://www.cs.kuleuven.ac.be/~henk/DPS/publications.html
Root-URL: 
Email: e-mail: Stijn.Bijnens@cs.kuleuven.ac.be  
Title: Sender-initiated and Receiver-initiated Coordination in a Global Object Space  
Author: Stijn Bijnens, Wouter Joosen and Pierre Verbaeten 
Address: Belgium  
Affiliation: Department of Computer Science KULeuven  
Abstract: This paper features a case study of a complex parallel application (in the area of Molecular Dynamics Simulation) modelled in a concurrent object-oriented language. In this computational model, application objects can exhibit some autonomous behaviour and reside in a global object space. At runtime, this object space can physically be mapped on a distributed memory machine. The case study indicates the pitfalls of pure name-based object interaction. We show that due to the dynamic nature of the interaction schemes between the application objects, coordination primitives are necessary to achieve expressive lucidity within a programming language. As a result, two kinds of semantics exist for coordination in the object space: 1. Sender-initiated coordination by means of pattern-based group com 
Abstract-found: 1
Intro-found: 1
Reference: [AC93] <author> Gul Agha and Christian Callsen. ActorSpace: </author> <title> An Open Distributed Programming Paradigm. </title> <booktitle> In PPOPP'93: Principles and Practice of Parallel Programming, </booktitle> <pages> pages 23-32. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1993. </year> <month> 14 </month>
Reference-contexts: In this paper we introduced a classification scheme and we will give an example of every class. 1. Sender-Initiated Coordination : ActorSpaces. In the ActorSpace Model <ref> [AC93] </ref>, communication is based on destination patterns. An actorSpace is a computational passive container of actors which acts as a context for pattern matching. ActorSpaces may overlap or can be hierarchically structured. Messages may be sent to one or all members of a group defined by a pattern (broadcast).
Reference: [Agh86] <author> G. Agha. </author> <title> ACTORS: A Model of Concurrent Computation in Distributed Systems. </title> <booktitle> The MIT Press series in artificial intelligence, </booktitle> <year> 1986. </year>
Reference-contexts: Section 6 presents related work and we summarize in section 7. 2 Computational Model Programming languages that support concurrency favour a specific computational model. Some models keep the concept of a "process" as a separate entity (like in Emerald [RTL91] or Ada [ANSI83]); other models (like Pool-T [Ame87], Actors <ref> [Agh86] </ref>, and ABCL [Yon90]) integrate objects and processes into one concept: active objects. This is a natural approach since objects and processes have a lot in common: encapsulation, communication through message passing, protection of private data, etc. Our computational model favors autonomous active objects. <p> Asynchronous object invocation. In order to maximise concurrency, the model support asynchronous object invocation (by avoiding the sender to wait for the completion of the invocation). Many of the concurrent object-oriented computational models state asynchronous message passing 1 as the funda mental communication model (Actors <ref> [Agh86] </ref>). Synchronisation is needed to manage concurrent activities -that is acceptance and computation of requests- within an object. A concurrent object interface can be considered as a set of correlated operations with only a subset available for execution at a particular moment [Nie93].
Reference: [Ame87] <author> Pierre America. Pool-T: </author> <title> A Parallel Object-Oriented Language. </title> <editor> In M. Tokoro and A. Yonezawa, editors, </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pages 199-220. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: Section 6 presents related work and we summarize in section 7. 2 Computational Model Programming languages that support concurrency favour a specific computational model. Some models keep the concept of a "process" as a separate entity (like in Emerald [RTL91] or Ada [ANSI83]); other models (like Pool-T <ref> [Ame87] </ref>, Actors [Agh86], and ABCL [Yon90]) integrate objects and processes into one concept: active objects. This is a natural approach since objects and processes have a lot in common: encapsulation, communication through message passing, protection of private data, etc. Our computational model favors autonomous active objects.
Reference: [ANSI83] <author> Inc. </author> <title> American National Standards Institute. The Programming Language Ada Reference Manual. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 155, </volume> <year> 1983. </year>
Reference-contexts: Section five briefly describes the implementation. Section 6 presents related work and we summarize in section 7. 2 Computational Model Programming languages that support concurrency favour a specific computational model. Some models keep the concept of a "process" as a separate entity (like in Emerald [RTL91] or Ada <ref> [ANSI83] </ref>); other models (like Pool-T [Ame87], Actors [Agh86], and ABCL [Yon90]) integrate objects and processes into one concept: active objects. This is a natural approach since objects and processes have a lot in common: encapsulation, communication through message passing, protection of private data, etc.
Reference: [Bij94] <author> S. Bijnens. </author> <title> The Correlate Language Definition and Architecture. </title> <type> Technical Report 94-4SB, </type> <institution> Dept. of Computer Science, KULeuven, </institution> <year> 1994. </year>
Reference-contexts: We have defined some language extensions for C++ to integrate concurrency into an existing object-oriented language. The resulting language framework is called Correlate <ref> [Bij94] </ref> which stands for Concurrent Object-oriented REflective LAnguage TEchnology. The extensions are summarized: Autonomous operations: An active object can have one or more autonomous operations. These operations are spontaneously executed 2 (when the concurrency control specifications are satisfied).
Reference: [BJB + 94] <author> Bob Bywater, Wouter Joosen, Stijn Bijnens, Pierre Verbaeten, Thomas Larsen, and John Perram. </author> <title> Parallel Simulation Software for Drug Design. </title> <booktitle> In HPCN Europe 94, </booktitle> <pages> pages 189-196. </pages> <booktitle> Lecture Notes in Computer Science 796, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The design of our language constructs does not approach the coordination problem from a theoretical or formal point of view, but the design is application driven. A complex application in the area of molecular dynamic simulation <ref> [BJB + 94] </ref> is the driving force of our language design concerning coordination. Indeed, this application domain is an excellent example: particles are modelled as autonomous objects and the interaction patterns between these application objects change dynamically. <p> This is done by numerically solving the Newtonian equations of motion to obtain the time evolution of the molecular trajectories. A challenging molecular dynamics application is the simulation of protein molecules (for example in the context of drug design <ref> [BJB + 94] </ref>). A protein molecule can be thought of as a complex flexible mechanical system subject to a number of forces between parts of itself and the environment. For each type of force, specific force calculation algorithms have been developed by application domain experts. <p> This will finally result in unreadable code which will most likely contain bugs. This study indicates that coordination primitives are required. Moreover, the implementation of other types of forces are even more complicated. For example, in protein simulation, atoms make chemical bonds. Typically, in drug design <ref> [BJB + 94] </ref> such molecules can consist of thousands of atoms. Chemical bonds are modelled as constraint forces between atoms. A large molecule can curl (folding) dynamically during simulation. This results in an enormous change in the members of a neighbour-list.
Reference: [BJOV94] <author> Stijn Bijnens, Wouter Joosen, Johan Van Oeyen, and Pierre Verbaeten. </author> <title> The XENOOPS Object-Oriented Framework for Dynamic Resource Management. </title> <note> 1994. Submitted for Publication. </note>
Reference-contexts: Figure 5 revisits our example in the area of molecular dynamics simulation. 5 Implementation In this section, we will only focus on the realisation of the language constructs for coordination 4 . An efficient implementation of coordination constructs is the 4 The Correlate language run-time uses the Xenoops <ref> [BJOV94] </ref> execution environment for issues like distribution and load balancing. Xenoops is an object-oriented run-time 9 Cardinality ( &lt; T ype &gt; "[" &lt; P attern &gt; "]" )). &lt; identif ier &gt;! AbstractState Fig. 4.
Reference: [BJV94] <author> Stijn Bijnens, Wouter Joosen, and Pierre Verbaeten. </author> <title> A Reflective Invocation Scheme to Realise Advanced Object Management. </title> <editor> In R. Guerraoui, O Nierstrasz, and M. Riveill, editors, </editor> <booktitle> Object-Based Distributed Programming, Lecture Notes in Computer Science 791, </booktitle> <pages> pages 139-151. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: At the meta-level all computations about other computations can be specified. For example, the membership computation of a pattern is a meta-computation. The problem domain of the membership-computation is the (application) object-computation itself. Basically, the implementation is based on the concepts presented in <ref> [BJV94] </ref>. In this paper a class hierarchy of Reference objects was presented. These reference objects reify the interaction [Fer89] between objects and reside in the meta-level of the run-time system.
Reference: [Car93] <author> D. Caromel. </author> <title> Towards a Method of Object-Oriented Concurrent Programming. </title> <journal> Communications of the ACM, </journal> <volume> 36(9) </volume> <pages> 90-102, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: A common technique is the use of Futures (e.g. in ABCL/1 [Yon90]) or Continuations (e.g. in Concurrent Aggregates [Chi93] for handling the result. An implicit approach is Wait-by-Necessity. This technique is proposed by Caromel <ref> [Car93] </ref> and is applied in Eiffel//. A caller object which has performed an asynchronous invocation with a reply, will only wait when it attempts to use the result that has not been returned yet. The semantics define that a reference to such a reply object can be used. <p> However, since the language has an open implementation, intra-object concurrency can be specified at the meta-level as long as the object's state machine is not violated. 3 for asynchronous invocation (the @ operator). Correlate features the Wait- by-Necessity technique <ref> [Car93] </ref> for handling replies. State based concurrency control: An active object behaves like a finite state machine. Dependent on the current value of the state, a specific operation may be executed (precondition). After the execution of the operation (postaction), the abstract state can change.
Reference: [CG89] <author> Nicholas Carriero and David Gelernter. </author> <title> Linda in Context. </title> <journal> Communications of the ACM, </journal> <volume> 32(4) </volume> <pages> 444-458, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Synchronisers [FA93] are objects for expressing multi-object synchronisation. A synchroniser specifies a pattern and can be bound to a group of objects (receiver initiated). An invocation towards an object in this group is only accepted if the invocation matches this pattern. 3. Symmetrically-Initiated Coordination : Linda. Linda <ref> [CG89] </ref> defines a communication abstraction based on a Tuple Space. The semantics of Linda require explicit read operations by recipients. Thus, to realize an interaction both the sender and the receiver must perform an action.
Reference: [Chi93] <author> Andrew Chien. </author> <title> Concurrent Aggregates: Supporting Modularity in Massively Parallel Programs. </title> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The reflective facilities even allow to change the scheduling policies dynamically.) Asynchronous object invocation: A new invocation operator is defined 1 Some language models support asynchronous invocation with reply. A common technique is the use of Futures (e.g. in ABCL/1 [Yon90]) or Continuations (e.g. in Concurrent Aggregates <ref> [Chi93] </ref> for handling the result. An implicit approach is Wait-by-Necessity. This technique is proposed by Caromel [Car93] and is applied in Eiffel//. A caller object which has performed an asynchronous invocation with a reply, will only wait when it attempts to use the result that has not been returned yet.
Reference: [FA93] <author> Svend Frolund and Gul Agha. </author> <title> A Language Framework for Multi-Object Coordination. </title> <booktitle> In ECOOP'93, </booktitle> <pages> pages 346-360. </pages> <booktitle> Lecture Notes in Computer Science Vol. </booktitle> <volume> 707, </volume> <publisher> Springer Verlag, </publisher> <month> July </month> <year> 1993. </year>
Reference-contexts: Messages may be sent to one or all members of a group defined by a pattern (broadcast). This provides an abstraction that allows replication of services (gathered in an ActorSpace), for example to enhance reliability or increase performance. 2. Receiver-Initiated Coordination : Synchronisers. Synchronisers <ref> [FA93] </ref> are objects for expressing multi-object synchronisation. A synchroniser specifies a pattern and can be bound to a group of objects (receiver initiated). An invocation towards an object in this group is only accepted if the invocation matches this pattern. 3. Symmetrically-Initiated Coordination : Linda.
Reference: [Fer89] <author> Jacques Ferber. </author> <title> Computational Reflection in class-based object-oriented languages. </title> <booktitle> In Proceedings of OOPSLA'89, </booktitle> <pages> pages 317-326. </pages> <booktitle> ACM Sigplan Notices, </booktitle> <month> October </month> <year> 1989. </year>
Reference-contexts: The problem domain of the membership-computation is the (application) object-computation itself. Basically, the implementation is based on the concepts presented in [BJV94]. In this paper a class hierarchy of Reference objects was presented. These reference objects reify the interaction <ref> [Fer89] </ref> between objects and reside in the meta-level of the run-time system. In other words, these reference objects intercept all object invocations and realise: location independent invocation, transparent group invocation, transparent object migration and replication. An application programmer can specialise the reference class hierarchy to add new resource management functionality.
Reference: [Ish92] <author> Yutaka Ishikawa. </author> <title> Communication Mechanism on Autonomous Objects. </title> <booktitle> In Proceedings of OOPSLA'92, </booktitle> <pages> pages 303-314. </pages> <booktitle> ACM Sigplan Notices, </booktitle> <year> 1992. </year>
Reference-contexts: Another pitfall of state-of-the-art concurrent object-oriented programming models is the fact that they are very suitable for expressing autonomous components that are competing for resources, but it is very hard to express autonomous components that are cooperating <ref> [Ish92] </ref>. In parallel applications the last scenario is often the case. In this paper we propose some coordination constructs for solving the above mentioned problems.
Reference: [Mil91] <author> Robin Milner. </author> <title> The Polyadic Calculus: a tutorial. </title> <type> Technical report, </type> <institution> ECS-LFCS-91-180, Comp. Science Dept. University of Edinburgh, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: In order to express these application specific knowledge our open language architecture has a meta-level. Knowing the precise semantics of our coordination primitives is very important. One of the current and future research tracks is the specification of our constructs in a processor object calculus: the -calculus <ref> [Mil91] </ref> seems to be very suitable. Acknowledgements The authors would like to thank J.W. Perram at Odense University for the fruitful discussions on the research area of molecular dynamics simulation and multi-agent systems.
Reference: [MWY91] <author> Satoshi Matsuoka, Takuo Watanabe, and Akinori Yonezawa. </author> <title> Hybrid group reflective architecture for object-oriented concurrent reflective programming. </title> <booktitle> In Proceedings of ECOOP'91, </booktitle> <pages> pages 231-250. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Our language framework and the realisation of the coordination primitives are based on the technique of an open implementation. The meta-level architecture of our language can be described in terms of the Hybrid Group Architecture 13 in ABCL/R2 <ref> [MWY91] </ref>. A LocalReference object corresponds to a meta-object in the individual reflective tower: it controls the message queue and the object's individual behaviour. On the other hand, a RegionReference object is responsible for managing the collective behaviour of its member objects.
Reference: [Nie93] <author> Oscar Nierstrasz. </author> <title> Regular Types for Active Objects. </title> <booktitle> In Proceedings of OOP-SLA'93, </booktitle> <pages> pages 1-15. </pages> <booktitle> ACM Sigplan Notices, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: Synchronisation is needed to manage concurrent activities -that is acceptance and computation of requests- within an object. A concurrent object interface can be considered as a set of correlated operations with only a subset available for execution at a particular moment <ref> [Nie93] </ref>. In a sequential environment, the sequence of operation invocations is under the programmer's control. In a parallel environment, an object may be operated upon by different active objects, which may invoke arbitrary operations at arbitrary times. In this context, simple sequential control becomes inadequate.
Reference: [PdLP90] <author> J.W. Perram, S.W. de Leeuw, and H.G. Petersen. </author> <title> Hamilton's Equations for Constrained Dynamical Systems. </title> <journal> J. Stat. Phys., </journal> <volume> 61 </volume> <pages> 1203-1222, </pages> <year> 1990. </year>
Reference-contexts: Constraint dynamics is a set of mathematical techniques which reduce the problem of simulating complicated mechanical systems to a set of standard numerical algorithms. Two mathematical formalisms have been applied to describe the forces of constraint in a complex molecule, i.e. the Lagrangian formalism and the Hamiltonian formalism <ref> [PdLP90] </ref>. 4 3. Electrostatic forces: These forces are caused by the interaction between charge distributions. Electrostatic forces between pairs of particles are proportional to 1 r 2 and thus exist between a pair of particles with a relatively long distance.
Reference: [RTL91] <author> Rajendra K. Ray, Ewan Tempero, and Henry M. Levy. </author> <title> Emerald: A General-Purpose Programming Language. </title> <journal> Software: Practice and Experience, </journal> <volume> 21(1) </volume> <pages> 91-92, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Section five briefly describes the implementation. Section 6 presents related work and we summarize in section 7. 2 Computational Model Programming languages that support concurrency favour a specific computational model. Some models keep the concept of a "process" as a separate entity (like in Emerald <ref> [RTL91] </ref> or Ada [ANSI83]); other models (like Pool-T [Ame87], Actors [Agh86], and ABCL [Yon90]) integrate objects and processes into one concept: active objects. This is a natural approach since objects and processes have a lot in common: encapsulation, communication through message passing, protection of private data, etc.
Reference: [Weg87] <author> Peter Wegner. </author> <title> Dimensions of Object-Based Language Design. </title> <booktitle> In Proceedings of OOPSLA'87, </booktitle> <pages> pages 168-182. </pages> <booktitle> ACM Sigplan Notices, </booktitle> <month> December </month> <year> 1987. </year> <month> 15 </month>
Reference-contexts: The important difference with the future approach is that the wait-by-necessity technique is automatic, reflected by the absence of any syntactical construction. This has a strong impact on reusability. 2 The language favors a sequential computational model <ref> [Weg87] </ref>. However, since the language has an open implementation, intra-object concurrency can be specified at the meta-level as long as the object's state machine is not violated. 3 for asynchronous invocation (the @ operator). Correlate features the Wait- by-Necessity technique [Car93] for handling replies.
Reference: [Yon90] <author> A. Yonezawa. </author> <title> ABCL: An Object Oriented Concurrent System. </title> <booktitle> The MIT Press series in artificial intelligence, </booktitle> <year> 1990. </year> <month> 16 </month>
Reference-contexts: Some models keep the concept of a "process" as a separate entity (like in Emerald [RTL91] or Ada [ANSI83]); other models (like Pool-T [Ame87], Actors [Agh86], and ABCL <ref> [Yon90] </ref>) integrate objects and processes into one concept: active objects. This is a natural approach since objects and processes have a lot in common: encapsulation, communication through message passing, protection of private data, etc. Our computational model favors autonomous active objects. <p> The reflective facilities even allow to change the scheduling policies dynamically.) Asynchronous object invocation: A new invocation operator is defined 1 Some language models support asynchronous invocation with reply. A common technique is the use of Futures (e.g. in ABCL/1 <ref> [Yon90] </ref>) or Continuations (e.g. in Concurrent Aggregates [Chi93] for handling the result. An implicit approach is Wait-by-Necessity. This technique is proposed by Caromel [Car93] and is applied in Eiffel//.
References-found: 21

