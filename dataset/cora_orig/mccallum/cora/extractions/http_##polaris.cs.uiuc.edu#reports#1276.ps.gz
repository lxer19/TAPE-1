URL: http://polaris.cs.uiuc.edu/reports/1276.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Title: Practical Tools for Optimizing Parallel Programs  
Author: Rudolf Eigenmann Patrick McClaughry 
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  
Abstract: This paper describes a set of tools that help a programmer to be more efficient in optimizing scientific programs for a parallel computer. The design of these tools emerged from experience gained during a successful optimization effort on a set of representative supercomputer application codes. We have developed a number of utilities that complement available Unix tools. Additional tools offer a higher degree of inter-activity; they are currently built into the Emacs editor. The new tools mainly facilitate two development phases that were identified as time-consuming in the parallel programming project: The process of creating and maintaining a consistent set of experimental program variants and the analysis and interpretation of compilation and performance results. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Eigenmann, </author> <title> Toward a Methodology of Optimizing Programs for High-Performance Computers, </title> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <note> Report No. 1178, </note> <month> August </month> <year> 1992. </year>
Reference-contexts: Perhaps one reason for this is the lack of measures to assess tools and programming environments. Some concrete issues resulted from our program optimization project. An overview of the program optimization cycle and the applied methodology is described in <ref> [1] </ref>. Our major findings are, that there is a need for facilities for two development phases that fl This work was supported in part by the U.S. Department of Energy under grant no. <p> Examples of such factors are the loop speedup and the globalization penalty (i.e., the performance loss when putting data in global instead of in local memory). The methodology of analyzing these data is described in <ref> [1] </ref>. PTOPP provides many facilities to support this phase of the development process. The INGRES database is used for managing the large amount of program result data. <p> Optionally the user can re 4 quest a graphical display of the timing information in various styles. A number of questions recur with each program analysis session, and they have been put together as a methodology of performance analysis <ref> [1] </ref>. A simple one of these questions is "what is the resulting loop speedup". The profile display can give an answer by adding a new column that divides two given columns. <p> For example, if loops are not (yet) parallel, the user has to find out whether they can be transformed into parallel forms. Most useful for this purpose is the hit list of most effective transformations found in our project so far. This process is described more detailed in <ref> [1] </ref>. 2.5 Editing transformations The process of editing the program transformations was comparably fast, although errors introduced in this phase have caused extra debugging sessions in our experiments. It is mentioned in [1] that transformation-directed editors could be of some help. <p> This process is described more detailed in <ref> [1] </ref>. 2.5 Editing transformations The process of editing the program transformations was comparably fast, although errors introduced in this phase have caused extra debugging sessions in our experiments. It is mentioned in [1] that transformation-directed editors could be of some help. Some of these transformations are not difficult to edit, but they require a careful interprocedural analysis of the program. Examples of such transformations are privatizing of arrays and turning a loop into a concurrent loop.
Reference: [2] <author> R. Eigenmann, J. Hoeflinger, G. Jaxon, Z. Li, and D. Padua, </author> <title> Restructuring Fortran Programs for Cedar, </title> <booktitle> Proceedings of ICPP'91, </booktitle> <address> St. Charles, IL, </address> <month> 1 (August 12-16, </month> <year> 1991), </year> <pages> pp. 57-66. </pages>
Reference-contexts: The goal of the project was to optimize a large set of real applications for the Alliant FX/8 and the Cedar machine, including the Perfect Benchmarks R fl programs [3]. Initially, our tools consisted of the parallelizing compiler Kap/Cedar <ref> [2] </ref> and ordinary Unix utilities for manually improving the parallel Fortran code generated by Kap. Additional motivation came from the many open issues in tool design. <p> The user is assumed to be comfortable with the notions of parallel architectures and the types of transformations useful on programs for such architectures. This work complements other projects of our research group that develop parallelizing compilers <ref> [2, 3] </ref> capable of optimizing sequential programs automatically for parallel machines. <p> You seem to ignore parallelizing and interactive restructurers. Are they not important? They are! Our tool project is complementing our primary project of creating parallelizing restructurers <ref> [2, 3, 5] </ref>. That's why little is said about such tools in this paper. In Section 2.5 we mentioned the potential benefit users can expect from interactive restructurers.
Reference: [3] <author> R. Eigenmann, J. Hoeflinger, G. Jaxon, and D. Padua, </author> <title> The Cedar Fortran Project, </title> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomp. Res. & Dev., </institution> <note> Report No. 1262, </note> <year> 1992. </year>
Reference-contexts: The goal of the project was to optimize a large set of real applications for the Alliant FX/8 and the Cedar machine, including the Perfect Benchmarks R fl programs <ref> [3] </ref>. Initially, our tools consisted of the parallelizing compiler Kap/Cedar [2] and ordinary Unix utilities for manually improving the parallel Fortran code generated by Kap. Additional motivation came from the many open issues in tool design. <p> The user is assumed to be comfortable with the notions of parallel architectures and the types of transformations useful on programs for such architectures. This work complements other projects of our research group that develop parallelizing compilers <ref> [2, 3] </ref> capable of optimizing sequential programs automatically for parallel machines. <p> You seem to ignore parallelizing and interactive restructurers. Are they not important? They are! Our tool project is complementing our primary project of creating parallelizing restructurers <ref> [2, 3, 5] </ref>. That's why little is said about such tools in this paper. In Section 2.5 we mentioned the potential benefit users can expect from interactive restructurers.
Reference: [4] <author> P. E. McClaughry, </author> <title> PTOPP A Practical Toolset for the Optimization of Parallel Programs, </title> <type> Master's thesis, </type> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: A simple one of these questions is "what is the resulting loop speedup". The profile display can give an answer by adding a new column that divides two given columns. The PTOPP facilities provide a flexible mechanism to generate such derived columns and switch between a range of displays <ref> [4] </ref> Discussion The analysis of the program and performance data and the derivation of the potential transformations were among the most time-consuming parts of the development process.
Reference: [5] <author> P. M. Petersen, </author> <title> Evaluation of Programs and Parallelizing Compilers Using Dynamic Analysis Techniques, </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: Other transformations are easier to analyze but more tedious to edit. They may be the primary candidates for support in transformation tools. Examples are stripmining and loop coalescing. Such tools are also being designed in related projects <ref> [5] </ref>. 3 Questions and Answers Assessing the usefulness of new tools is difficult without hands-on experience. <p> You seem to ignore parallelizing and interactive restructurers. Are they not important? They are! Our tool project is complementing our primary project of creating parallelizing restructurers <ref> [2, 3, 5] </ref>. That's why little is said about such tools in this paper. In Section 2.5 we mentioned the potential benefit users can expect from interactive restructurers.
Reference: [6] <author> S. Sharma, R. Bramley, P. Sinvahl-Sharma, J. Bruner, and G. Cybenko, P3S: </author> <title> Portable, Parallel Program Performance Evaluation System, </title> <institution> Univ. of Illinois at Urbana-Champaign, Center for Supercomputing Res. & Dev., </institution> <note> Report No. 1170, </note> <month> September </month> <year> 1992. </year> <month> 6 </month>
Reference-contexts: Functionality that is not yet available and that we sometimes wished for is combined inclusive and exclusive profiling, the display of the dynamic call tree, and the full record of original trace information. 2 Some of this functionality is available from a related tool project <ref> [6] </ref>. 2.2 Generation and execution of program variants The program instrumentation step is followed by the generation and execution of multiple program variants, each corresponding to a set of compiler options plus a set of files that contain individually optimized program sections.
References-found: 6

