URL: ftp://ftp.cs.utexas.edu/pub/predator/sigsoft-94.ps
Refering-URL: http://www.cs.utexas.edu/users/jthomas/publications.html
Root-URL: 
Title: Abstract a production system compiler that produces the fastest sequential executables of OPS5 rule sets.
Note: LEAPS is  
Abstract: P2 is a scalable compiler for collection data structures. High-level abstractions insulate P2 users from data structure implementation details. By specifying a target data structure as a composition of components from a reuse library, the P2 compiler replaces abstract operations with their concrete implementations. In this paper, we present some of our experimental results and experiences in this reengineering exercise. We show that P2 scaled to this complex application, substantially increased productivity, and provided unexpected performance gains. 
Abstract-found: 1
Intro-found: 1
Reference: [ACM91] <institution> Association for Computing Machinery, Next Generation Database Systems, Communications of the ACM, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: P2 components offer different implementations of these abstractions. In the following sections, we explain the features of P2 that were used in the reengineering of LEAPS. Readers may recognize the inuence of database abstractions on the P2 domain model <ref> [ACM91] </ref>. 2.1 Cursors and Containers Collection data structuresarrays, binary trees, ordered lists implement the container abstraction. A container is a sequence of elements, where all the elements are instances of a single data type.
Reference: [Bat88] <author> D. Batory, et al. </author> <title> Genesis: An Extensible Database Management System, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> November </month> <year> 1988. </year>
Reference-contexts: The GenVoca approach standardizes fundamental abstractions of a domain; Gen-Voca components implement standardized interfaces and thus are plug-compatible, interchangeable, and interoperable. GenVoca has been applied to independently built generators for the domains of databases (Genesis <ref> [Bat88] </ref>), communication networks (Avoca/x-kernel [Hut91]), distributed file systems (Ficus [Hei93]), and avionics software (ADAGE [Cog93]). Our work on P2 extends the diverse list of disparate domains for which GenVoca generators have been constructed.
Reference: [Bat92] <author> D. Batory and S. OMalley, </author> <title> The Design and Implementation of Hierarchical Software Systems with Reusable Components, </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: It is this scalable approach to data structure construction that we have taken in developing the P2 data structure compiler [Sir93]. More specifically, the P2 compiler is based on GenVoca, a model of scalable software construction <ref> [Bat92, Bat94b] </ref>. The GenVoca approach standardizes fundamental abstractions of a domain; Gen-Voca components implement standardized interfaces and thus are plug-compatible, interchangeable, and interoperable.
Reference: [Bat93] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas, </author> <title> Scalable Software Libraries, </title> <booktitle> Proc. ACM SIGSOFT, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Adding more components to contemporary libraries is not the answer. It has been observed that no finite library of conventionally-designed components could ever encompass the enormous spectrum of data structures that arise in practice. In short, conventional libraries are inherently unscalable <ref> [Bat93, Big94] </ref>. Scalable libraries will offer primitive building blocks and will be accompied by a compiler that generates target data structures from specified compositions of blocks. <p> The key to the success of P2 will be determined primarily on its ability to scale to a variety of applications, deliver increased programmer productivity, and make minimal concessions to run-time efficiency. In <ref> [Bat93] </ref> we described the GenVoca model, how P2 implements the model, and presented some experimental results for a simple application. As our next attempt to evaluate P2, we felt that a complicated, hand-coded data structure application had to be reengineered using P2. The application that we chose was LEAPS. <p> P2 code generation relies on sophisticated macro expansion and partial evaluation techniques <ref> [Bat93] </ref>. A type expression is a high level declarative specification of the implementation of cursors and containers. Minor changes to a type expression can generate substantially different code. Usually, a P2 program includes only a few type expressions and each type expression itself is at most a few lines long. <p> We have learned that abstracting away the voluminous and complex data structure implementation details of an application promotes clean and efficient designs. In short, this is an issue of the scalability of software design; organizing fewer details often leads to better and more maintainable products. 5 Conclusions In <ref> [Bat93] </ref>, we presented results that showed that for a simple application, the performance of P2 generated code was at least as good as components in popular template libraries.
Reference: [Bat94a] <author> D. Batory, </author> <title> The LEAPS Algorithms, </title> <type> unpublished report, </type> <month> May </month> <year> 1994. </year>
Reference-contexts: Actions may specify element creation, deletion, modification, and calls to external routines. A more complete discussion of the capabilities of OPS5 can be found in [McD78, For81]. We will use the print-sequence rule to illustrate the translations performed by RL. A full explanation of RL translation is given in <ref> [Bat94a] </ref>. Forward-chaining inference engines, including LEAPS, use a match-select-action cycle. Rules that can be matched (i.e., tuples found to satisfy their qualification) are determined, one n-tuple is selected, and its corresponding action is fired. This cycle continues until a fix-point has been reached (i.e., no more rules can be fired). <p> First, there are two more translation steps when rule qualifications involve negated CEs. These steps are no more complicated than the four defined in the previous section <ref> [Bat94a] </ref>. Second, when an element is inserted in LEAPS, it is pushed onto a wait-list stack for subsequent seeding. Composite cursors, whose execution was suspended, are placed on a join-stack.
Reference: [Bat94b] <author> Don Batory, Vivek Singhal, Jeff Thomas, Sankar Dasari, Bart Geraci, and Marty Sirkin. </author> <title> The GenVoca Model of Software System Generators. </title> <journal> IEEE Software, </journal> <month> September </month> <year> 1994. </year>
Reference-contexts: It is this scalable approach to data structure construction that we have taken in developing the P2 data structure compiler [Sir93]. More specifically, the P2 compiler is based on GenVoca, a model of scalable software construction <ref> [Bat92, Bat94b] </ref>. The GenVoca approach standardizes fundamental abstractions of a domain; Gen-Voca components implement standardized interfaces and thus are plug-compatible, interchangeable, and interoperable.
Reference: [Big94] <author> T. Biggerstaff. </author> <title> The Library Scaling Problem and the Limits of Concrete Component Reuse, </title> <booktitle> IEEE International Conference on Software Reuse, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: Adding more components to contemporary libraries is not the answer. It has been observed that no finite library of conventionally-designed components could ever encompass the enormous spectrum of data structures that arise in practice. In short, conventional libraries are inherently unscalable <ref> [Bat93, Big94] </ref>. Scalable libraries will offer primitive building blocks and will be accompied by a compiler that generates target data structures from specified compositions of blocks.
Reference: [Bra91] <author> D. Brant, T. Grose, B Lofaso, and D. Miranker, </author> <title> Effects of Database Size on Rule System Performance: Five Case Studies, </title> <booktitle> Proceedings of the 17th International Conference on Very Large Data Bases (VLDB), </booktitle> <year> 1991. </year>
Reference-contexts: These benchmarks have been used for years to measure the performance of rule execution engines, and are typical of LEAPS applications <ref> [Bra91] </ref>. Further, these benchmarks were particularly useful because (unlike some OPS5 rule sets) they required an input file.
Reference: [Bra93] <author> D. Brant and D. Miranker, </author> <title> Index Support for Rule Activiation, </title> <booktitle> Proc. ACM SIGMOD, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Maintenance. Altering typex statements allowed us to implement enhanced versions of LEAPS (e.g., with persistent containers) in days [Sir94]. Comparable changes to LEAPS <ref> [Bra93, Bro94] </ref> required months of effort. Design Scalability. Interviews of the LEAPS development team indicated that debugging LEAPS was very difficult and that all of the major problems were caused by errors in data structures. Developing LEAPS without P2 is a monumental undertaking.
Reference: [Bro94] <editor> J. Browne, et al. </editor> <title> A New Approach to Modularity in Rule-Based Programming, </title> <institution> Department of Computer Sciences, University of Texas at Austin, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: Maintenance. Altering typex statements allowed us to implement enhanced versions of LEAPS (e.g., with persistent containers) in days [Sir94]. Comparable changes to LEAPS <ref> [Bra93, Bro94] </ref> required months of effort. Design Scalability. Interviews of the LEAPS development team indicated that debugging LEAPS was very difficult and that all of the major problems were caused by errors in data structures. Developing LEAPS without P2 is a monumental undertaking.
Reference: [Cog93] <author> L. Coglianese and R. Szymanski, </author> <title> DSSA-ADAGE: An Environment for Architecture-based Avionics Development, </title> <booktitle> Proc. </booktitle> <address> AGARD, </address> <year> 1993. </year> <note> Also, Technical Report ADAGE-IBM-93-04, </note> <institution> IBM Owego, </institution> <address> New York, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The GenVoca approach standardizes fundamental abstractions of a domain; Gen-Voca components implement standardized interfaces and thus are plug-compatible, interchangeable, and interoperable. GenVoca has been applied to independently built generators for the domains of databases (Genesis [Bat88]), communication networks (Avoca/x-kernel [Hut91]), distributed file systems (Ficus [Hei93]), and avionics software (ADAGE <ref> [Cog93] </ref>). Our work on P2 extends the diverse list of disparate domains for which GenVoca generators have been constructed.
Reference: [For81] <author> C. Forgy, </author> <title> OPS5 Users Manual, </title> <type> Technical Report CMU-CS-81-135, </type> <institution> Carnegie Mellon University, </institution> <year> 1981. </year>
Reference-contexts: Thus, tuning and maintaining a P2 program is often a matter of changing a few lines of type expressions. 3 Reengineering the LEAPS Algorithms OPS5 is a forward-chaining expert system <ref> [McD78, For81] </ref>. LEAPS (Lazy Evaluation Algorithm for Production Systems) is a compiler that translates OPS5 rule sets into C programs. LEAPS produces the fastest sequential executables of OPS5 rule sets, sometimes outperforming OPS5 interpreters by several orders of magnitude [Mir90, Mir91]. <p> OPS5 rule actions can also be more complex. Actions may specify element creation, deletion, modification, and calls to external routines. A more complete discussion of the capabilities of OPS5 can be found in <ref> [McD78, For81] </ref>. We will use the print-sequence rule to illustrate the translations performed by RL. A full explanation of RL translation is given in [Bat94a]. Forward-chaining inference engines, including LEAPS, use a match-select-action cycle.
Reference: [Hei93] <author> J. Heidemann and G. Popek, </author> <title> File System Development with Stackable Layers, </title> <type> Technical Report CSD-930019, </type> <institution> Department of Computer Science, UCLA, </institution> <month> July </month> <year> 1993. </year> <note> To appear in ACM Transactions on Computer Systems. </note>
Reference-contexts: The GenVoca approach standardizes fundamental abstractions of a domain; Gen-Voca components implement standardized interfaces and thus are plug-compatible, interchangeable, and interoperable. GenVoca has been applied to independently built generators for the domains of databases (Genesis [Bat88]), communication networks (Avoca/x-kernel [Hut91]), distributed file systems (Ficus <ref> [Hei93] </ref>), and avionics software (ADAGE [Cog93]). Our work on P2 extends the diverse list of disparate domains for which GenVoca generators have been constructed.
Reference: [Hut91] <author> N. Hutchinson and L. Peterson, </author> <title> The x-kernel: An Architecture for Implementing Network Protocols, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> January </month> <year> 1991. </year>
Reference-contexts: The GenVoca approach standardizes fundamental abstractions of a domain; Gen-Voca components implement standardized interfaces and thus are plug-compatible, interchangeable, and interoperable. GenVoca has been applied to independently built generators for the domains of databases (Genesis [Bat88]), communication networks (Avoca/x-kernel <ref> [Hut91] </ref>), distributed file systems (Ficus [Hei93]), and avionics software (ADAGE [Cog93]). Our work on P2 extends the diverse list of disparate domains for which GenVoca generators have been constructed.
Reference: [McD78] <author> J. McDermott, A. Newall, and J. Moore, </author> <title> The Efficiency of Certain Production Systems, Pattern Directed Inference Systems, </title> <editor> Waterman, Hayes, Roth (ed), </editor> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Thus, tuning and maintaining a P2 program is often a matter of changing a few lines of type expressions. 3 Reengineering the LEAPS Algorithms OPS5 is a forward-chaining expert system <ref> [McD78, For81] </ref>. LEAPS (Lazy Evaluation Algorithm for Production Systems) is a compiler that translates OPS5 rule sets into C programs. LEAPS produces the fastest sequential executables of OPS5 rule sets, sometimes outperforming OPS5 interpreters by several orders of magnitude [Mir90, Mir91]. <p> OPS5 rule actions can also be more complex. Actions may specify element creation, deletion, modification, and calls to external routines. A more complete discussion of the capabilities of OPS5 can be found in <ref> [McD78, For81] </ref>. We will use the print-sequence rule to illustrate the translations performed by RL. A full explanation of RL translation is given in [Bat94a]. Forward-chaining inference engines, including LEAPS, use a match-select-action cycle.
Reference: [Mir90] <author> D. Miranker, D. Brant, B. Lofaso, and D. Gadbois, </author> <title> On the Performance of Lazy Matching in Production Systems, </title> <booktitle> Proc. National Conference on Artificial Intelligence, </booktitle> <year> 1990. </year>
Reference-contexts: Don Batory, Jeff Thomas, and Marty Sirkin Department of Computer Sciences The University of Texas at Austin Austin, Texas 78712-1188 -batory, jthomas, marty-@cs.utexas.edu To be presented at the 1994 ACM SIGSOFT Conference, New Orleans LEAPS is a production system compiler that produces the fastest sequential executables of OPS5 rule sets <ref> [Mir90, Mir91] </ref>. LEAPS is a hand-written, highly-tuned, performance-driven application that heavily relies on complex and unusual collection data structures, none of which are found in conventional libraries. <p> LEAPS (Lazy Evaluation Algorithm for Production Systems) is a compiler that translates OPS5 rule sets into C programs. LEAPS produces the fastest sequential executables of OPS5 rule sets, sometimes outperforming OPS5 interpreters by several orders of magnitude <ref> [Mir90, Mir91] </ref>. Besides the expected performance gains made by compilation, LEAPS relies on special search algorithms and sophisticated data structures to make rule processing efficient. by the P2 compiler, thus effectively accomplishing in two translation steps what the LEAPS compiler does in one.
Reference: [Mir91] <author> D. Miranker and B. Lofaso, </author> <title> The Organization and Performance of a TREAT Based Production System Compiler, </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1991. </year>
Reference-contexts: Don Batory, Jeff Thomas, and Marty Sirkin Department of Computer Sciences The University of Texas at Austin Austin, Texas 78712-1188 -batory, jthomas, marty-@cs.utexas.edu To be presented at the 1994 ACM SIGSOFT Conference, New Orleans LEAPS is a production system compiler that produces the fastest sequential executables of OPS5 rule sets <ref> [Mir90, Mir91] </ref>. LEAPS is a hand-written, highly-tuned, performance-driven application that heavily relies on complex and unusual collection data structures, none of which are found in conventional libraries. <p> LEAPS (Lazy Evaluation Algorithm for Production Systems) is a compiler that translates OPS5 rule sets into C programs. LEAPS produces the fastest sequential executables of OPS5 rule sets, sometimes outperforming OPS5 interpreters by several orders of magnitude <ref> [Mir90, Mir91] </ref>. Besides the expected performance gains made by compilation, LEAPS relies on special search algorithms and sophisticated data structures to make rule processing efficient. by the P2 compiler, thus effectively accomplishing in two translation steps what the LEAPS compiler does in one.
Reference: [Sir93] <author> M. Sirkin, D. Batory, and V. Singhal, </author> <title> Software Components in a Data Structure Precompiler, </title> <booktitle> Proc. 15th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Thus the domain of data structures that can be generated grows geometrically as each new block is added. It is this scalable approach to data structure construction that we have taken in developing the P2 data structure compiler <ref> [Sir93] </ref>. More specifically, the P2 compiler is based on GenVoca, a model of scalable software construction [Bat92, Bat94b]. The GenVoca approach standardizes fundamental abstractions of a domain; Gen-Voca components implement standardized interfaces and thus are plug-compatible, interchangeable, and interoperable. <p> declared in a typex (type expression) declaration: typex - simple_typex = top2ds [qualify [dlist [ malloc [transient]]]]; - simple_typex is a composition of five P2 components, where each component encapsulates a consistent data and operation refinement of the cursor-container abstraction and is responsible for generating the code for this refinement <ref> [Sir93] </ref>.
Reference: [Sir94] <author> M. Sirkin, </author> <title> A Software System Generator for Data Structures, </title> <type> Ph.D. dissertation, </type> <institution> Dept. of Computer Science, University of Washington, </institution> <year> 1994. </year>
Reference-contexts: Maintenance. Altering typex statements allowed us to implement enhanced versions of LEAPS (e.g., with persistent containers) in days <ref> [Sir94] </ref>. Comparable changes to LEAPS [Bra93, Bro94] required months of effort. Design Scalability. Interviews of the LEAPS development team indicated that debugging LEAPS was very difficult and that all of the major problems were caused by errors in data structures. Developing LEAPS without P2 is a monumental undertaking.
References-found: 19

