URL: http://www.it.kth.se/docs/Reports/TELEINFORMATICS/TRITA-IT-9410.ps.Z
Refering-URL: http://www.it.kth.se/docs/Reports/TELEINFORMATICS/
Root-URL: http://www.it.kth.se
Title: Tree Constraints  
Author: Torbjorn Keisu 
Degree: A Dissertation submitted in partial fulfillment for the Degree of Doctor of Technology  
Date: May 1994  1994  
Address: Stockholm, Sweden  S-164 40 Kista, Sweden Box 1263 S-164 28 Kista, Sweden  
Affiliation: Department of Teleinformatics The Royal Institute of Technology  The Royal Institute of Technology (KTH) Department of Teleinformatics Swedish Institute Electrum 204 of Computer Science  
Note: ISBN 91-7170-875-8 ISRN SICS/D--16--SE  c flTorbjorn Keisu,  TRITA-IT 94:10 SICS Dissertation Series 16 ISSN 1103-534X ISSN 1101-1335  
Abstract-found: 0
Intro-found: 1
Reference: [AAB + 93] <author> J. Andersson, S. Andersson, K. Boortz, M. Carlsson, H. Nilsson, T. Sjoland, and J. Widen. </author> <title> SICStus Prolog User's Manual, version 2.1. </title> <type> Technical Report T93:01, </type> <institution> Swedish Institute of Computer Science (SICS), </institution> <month> January </month> <year> 1993. </year>
Reference: [AK86] <author> H. Ait-Kaci. </author> <title> An algebraic semantics approach to the effective resolution of type equations. </title> <journal> Theoretical Computer Science, </journal> <volume> 45(3) </volume> <pages> 293-351, </pages> <year> 1986. </year>
Reference-contexts: Constraints in concurrent constraint programming languages are also discussed in [Smo93] where a general calculus is discussed using a parameterized constraint system. The system is based on rewrites and simplifications. As precursors of feature structures we have the work on -terms <ref> [AK86] </ref>. Feature structures have been further developed for use in the CCP type languages Life (an early description in [AKL88]) [AKP93b] and Oz [HSW93], also see [AKPS92, AKP93a]. Another early precursor are feature descriptions found originally in linguistics. Mukai has described them using a record algebra model [Muk91].
Reference: [AKL88] <author> H. Ait-Kaci and P. Lincoln. </author> <title> LIFE a natural language for natural language. </title> <type> Technical Report ACA-ST-074-88, </type> <institution> Microelectronics and Computer Technology Corporation, MCC, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: The system is based on rewrites and simplifications. As precursors of feature structures we have the work on -terms [AK86]. Feature structures have been further developed for use in the CCP type languages Life (an early description in <ref> [AKL88] </ref>) [AKP93b] and Oz [HSW93], also see [AKPS92, AKP93a]. Another early precursor are feature descriptions found originally in linguistics. Mukai has described them using a record algebra model [Muk91]. In [ST92] an algorithm for constraint simplification in feature trees is presented.
Reference: [AKP93a] <author> H. Ait-Kaci and A. </author> <title> Podelski. Entailment and disentailment of order-sorted feature constraints. </title> <type> Draft, </type> <month> January 26 </month> <year> 1993. </year>
Reference-contexts: The system is based on rewrites and simplifications. As precursors of feature structures we have the work on -terms [AK86]. Feature structures have been further developed for use in the CCP type languages Life (an early description in [AKL88]) [AKP93b] and Oz [HSW93], also see <ref> [AKPS92, AKP93a] </ref>. Another early precursor are feature descriptions found originally in linguistics. Mukai has described them using a record algebra model [Muk91]. In [ST92] an algorithm for constraint simplification in feature trees is presented.
Reference: [AKP93b] <author> H. Ait-Kaci and A. </author> <title> Podelski. Towards a meaning of LIFE. </title> <journal> Journal of Logic Programming, </journal> <volume> 16(3 </volume> & 4):195-234, July & August 1993. 
Reference-contexts: The system is based on rewrites and simplifications. As precursors of feature structures we have the work on -terms [AK86]. Feature structures have been further developed for use in the CCP type languages Life (an early description in [AKL88]) <ref> [AKP93b] </ref> and Oz [HSW93], also see [AKPS92, AKP93a]. Another early precursor are feature descriptions found originally in linguistics. Mukai has described them using a record algebra model [Muk91]. In [ST92] an algorithm for constraint simplification in feature trees is presented.
Reference: [AKPS92] <author> H. Ait-Kaci, A. Podelski, and G. Smolka. </author> <title> A feature-based constraint system for logic programming with entailment. </title> <booktitle> In Proceedings on the International Conference on Fifth Generation Computer Systems FGCS-92. </booktitle> <publisher> ICOT, </publisher> <year> 1992. </year>
Reference-contexts: The system is based on rewrites and simplifications. As precursors of feature structures we have the work on -terms [AK86]. Feature structures have been further developed for use in the CCP type languages Life (an early description in [AKL88]) [AKP93b] and Oz [HSW93], also see <ref> [AKPS92, AKP93a] </ref>. Another early precursor are feature descriptions found originally in linguistics. Mukai has described them using a record algebra model [Muk91]. In [ST92] an algorithm for constraint simplification in feature trees is presented.
Reference: [ASS + 88] <author> A. Aiba, K. Sakai, Y. Sato, D. J. Hawley, and R. Hasegawa. </author> <title> Constraint logic programming language CAL. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems (FGCS-88), </booktitle> <publisher> ICOT, </publisher> <address> Tokyo, </address> <pages> pages 263-276, </pages> <month> December </month> <year> 1988. </year>
Reference: [Bry86] <author> Randal E. Bryant. </author> <title> Graph-based algorithms for Boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8), </volume> <month> August </month> <year> 1986. </year>
Reference: [BS87] <author> W. Buttner and H. Simonis. </author> <title> Embedding Boolean expressions into logic programming. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 4 </volume> <pages> 191-205, </pages> <month> October </month> <year> 1987. </year> <title> BIBLIOGRAPHY </title>
Reference: [BSar] <author> F. Baader and J.H. Siekmann. </author> <title> Unification theory. </title> <editor> In C.J. Hogger D.M. Gabbay and J.A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming. </booktitle> <institution> Oxford University Press, </institution> <note> (to appear). </note>
Reference: [Buc70] <author> Bruno Buchberger. </author> <title> Ein algorithmisches Kriterium fur die Losbarkeit eines algebraischen Gleichungssystems. </title> <journal> AEQ. MATH., </journal> <volume> 4, </volume> <year> 1970. </year>
Reference: [Buc87] <author> Bruno Buchberger. </author> <title> History and basic features of the critical-pair/completion procedure. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3, </volume> <year> 1987. </year>
Reference: [Bur88] <author> Hans-Jurgen Burckert. </author> <title> Solving disequations. </title> <booktitle> In Proceedings of the 9th Conference on Automated Deduction, </booktitle> <volume> LNCS 310, </volume> <pages> pages 517-526. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: This would correspond to a simpler form of a solution in our terminology. Since this method is similar to Maher's it also lacks support for our requirements. Solving combinations of equations and disequations has also been addressed by Kirchner and Lescanne in [KL87]. Burckert discusses in <ref> [Bur88] </ref> the problem of 157 CHAPTER 14. RELATED WORK solving disequations in arbitrary equational theories. In this paper he introduces a more general notion of solutions as a substitution with exceptions, where the exceptions represent values not allowed.
Reference: [Cha88] <author> David Chan. </author> <title> Constructive negation based on the completed database. </title> <booktitle> In Logic Programming: Proceedings of the Fifth International Conference and Symposium (Seattle), </booktitle> <pages> pages 111-125. </pages> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: The paper presents algorithms with better complexity than the decision procedure used by Colmerauer. Decision procedures for finite trees with respect to Prolog are also discussed in [Kun87b, Kun87a]. The notion of constructive negation in Prolog is introduced by Chan in <ref> [Cha88] </ref>. This work uses the completed database and in order to handle negation reasonably efficiently, disjunctions of equations and inequalities are handled through backtracking. There is also a problem in a system where constraints are maintained as disjunctions and new constraints are added. <p> He also uses a form of negation where the result from a Prolog computation (disjunctions of systems in simple form) may be negated and where disjunctions are not replaced by backtracking as in <ref> [Cha88] </ref>. In comparison with these we supply a complete decision procedure that we believe will execute comparably since using the lazy approach to solving we will delay work until it is necessary.
Reference: [CL89] <author> Hubert Comon and Pierre Lescanne. </author> <title> Equational problems and dis-unification. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 7 </volume> <pages> 371-425, </pages> <year> 1989. </year>
Reference-contexts: A general decision procedure for finite trees are also discussed in [Mal71]. An arbitrary formula is rewritten into an equivalent standard form, which consists of a boolean combination of quantified equations and inequations. The quantifier elimination method has further been used by Comon and Les-canne in <ref> [CL89] </ref>. Their motivation is to generalize the unification algorithm to handle first-order equational problems, considering only finite signatures. They use a set of rewrite rules to transform a problem into an equivalent solved form, from which solutions may straightforwardly be extracted.
Reference: [CLP86] <author> T.Y. Chen, J-L Lassez, and G.S. </author> <title> Port. Maximal unifiable subsets and minimal non-unifiable subsets. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 133-152, </pages> <year> 1986. </year>
Reference-contexts: In particular if a program is not experiencing any thrashing the overhead for intelligent backtracking may be too much. A method for collecting information about failures and successes while unifying systems of equations has been suggested in <ref> [CLP86] </ref>. The method is based on collecting information about the maximal unifiable subset and the minimal nonunifiable subset of a set of equations. This information is collected in conjunction with the unification process and may therefore be cheaper to implement.
Reference: [Coh90] <author> J. Cohen. </author> <title> Constraint logic programming languages. </title> <journal> Communications of the ACM, </journal> <volume> 33(7) </volume> <pages> 52-68, </pages> <month> July </month> <year> 1990. </year>
Reference: [Col82] <author> Alain Colmerauer. </author> <title> Prolog and infinite trees. In K.L. </title> <editor> Clark and S. A. Tarnlund, editors, </editor> <booktitle> Logic Programming, APIC Studies in Data Processing (16). </booktitle> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: Colmerauer in [Col84]. He discusses both finite and infinite trees and gives algorithms for solving systems of equations and disequations. In this paper the problems occur as a conjunction of equations and disequations. The simpler case of just solving equations was discussed in an earlier paper <ref> [Col82] </ref>. Recently we have been made aware of a paper by Ramachandran and van Hentenryck [Rv93] that describes incremental algorithms for satisfiability and entailment tests over rational trees. The constraints handled here are systems of equations and inequations like those considered by Colmerauer.
Reference: [Col84] <author> Alain Colmerauer. </author> <title> Equations and inequations on finite and infinite trees. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems (FGCS-84), </booktitle> <publisher> ICOT, </publisher> <address> Tokyo, </address> <pages> pages 85-99, </pages> <year> 1984. </year>
Reference-contexts: In AKL this is called choice splitting and is handled by copying. The execution is separated from the constraint solvers the way unification is separated from the execution of definite clauses in for instance <ref> [Col84] </ref>, where constraints are collected and submitted to a constraint solver which determines if the set obtained by adding these new constraints to the environment has a solution. If none exists failure will occur and backtracking with respect to the corresponding program clause will take place. <p> Using these methods as intended, i.e. statically, is not acceptable either from the programming point of view. In this sense our approach is different from these. The problem of solving equations and disequations in the logic programming framework was originally discussed by A. Colmerauer in <ref> [Col84] </ref>. He discusses both finite and infinite trees and gives algorithms for solving systems of equations and disequations. In this paper the problems occur as a conjunction of equations and disequations. The simpler case of just solving equations was discussed in an earlier paper [Col82].
Reference: [Dec90] <author> Rina Dechter. </author> <title> Enhancement schemes for constraint processing: Back-jumping, learning, and cutset decomposition. </title> <journal> Artificial Intelligence, </journal> <volume> 41(3) </volume> <pages> 273-312, </pages> <year> 1990. </year>
Reference: [DP88] <author> Rina Dechter and Judea Pearl. </author> <title> Network-based heuristics for constraint-satisfaction problems. </title> <journal> Artificial Intelligence, </journal> <volume> 34(1) </volume> <pages> 1-38, </pages> <year> 1988. </year> <title> BIBLIOGRAPHY </title>
Reference: [dRT94] <author> Marques del Real Tesoro. </author> <title> RT: Real Tesoro Jerez, </title> <editor> Amontillado. In Systembolagets prislista, </editor> <volume> volume 1, </volume> <pages> page 35, </pages> <month> January 4 </month> <year> 1994. </year>
Reference: [DvS + 88] <author> M. Dincbas, P. van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> In Proceedings on the International Conference on Fifth Generation Computer Systems FGCS-88, </booktitle> <address> Tokyo, Japan, </address> <month> December </month> <year> 1988. </year>
Reference: [Fra94] <author> Torkel Franzen. </author> <title> Some Formal Aspects of AKL. </title> <institution> Research Report R:9410, Swedish Institute of Computer Science (SICS), Stockholm, Sweden, </institution> <year> 1994. </year>
Reference-contexts: 2 ) Y = g (2)): p (X; Y ) : true ! Y = h (X): Such constructions may be useful if the execution of q (X) is very time consuming and rewriting it into several clauses is less readable. 7.2.2 Elimination of Conditional Deadlocks In the terminology of <ref> [Fra94] </ref> a normal execution of an AKL program is an execution where all guard computations terminate. As explained earlier, a set of noisy guards (as opposed to quiet guards) in conditional guarded clauses must be suspended pending further constraints to be added to the environment.
Reference: [HJL + 86] <author> Nevin C. Heintze, Joxan Jaffar, Chean Shen Lim, Spiro Michaylov, Peter J. Stuckey, Roland Yap, and Chut Gneow Yee. </author> <title> The CLP(R) programmers manual version 1. </title> <type> Technical Report 59, </type> <institution> Department of Computer Science, Monash University, </institution> <month> June </month> <year> 1986. </year>
Reference: [HSW93] <author> M. Hentz, G. Smolka, and J. Wurtz. </author> <title> Oz a programming language for multi-agent systems. </title> <booktitle> In Proceedings of the 13th IJCAI. AAAI, </booktitle> <year> 1993. </year>
Reference-contexts: The system is based on rewrites and simplifications. As precursors of feature structures we have the work on -terms [AK86]. Feature structures have been further developed for use in the CCP type languages Life (an early description in [AKL88]) [AKP93b] and Oz <ref> [HSW93] </ref>, also see [AKPS92, AKP93a]. Another early precursor are feature descriptions found originally in linguistics. Mukai has described them using a record algebra model [Muk91]. In [ST92] an algorithm for constraint simplification in feature trees is presented.
Reference: [Hyv92] <author> Eero Hyvonen. </author> <title> Constraint reasoning based on interval arithmetic: The tolerance propagation approach. </title> <journal> Artificial Intelligence, </journal> <volume> 58(1-3):71-112, </volume> <year> 1992. </year>
Reference: [ILO93] <author> ILOG S.A. </author> <title> ILOG SOLVER, Reference Manual, </title> <note> 1993. Version 1.2. </note>
Reference: [Jan94] <author> Sverker Janson. </author> <title> AKL amultiparadigm programming language, 1994. </title> <type> thesis proposal, </type> <institution> Uppsala University/SICS. </institution>
Reference: [JH91] <author> Sverker Janson and Seif Haridi. </author> <title> Programming paradigms of the An-dorra Kernel Language. </title> <booktitle> In Logic Programming: Proceedings of the 1991 International Logic Programming Symposium. </booktitle> <publisher> MIT Press, </publisher> <month> Octo-ber </month> <year> 1991. </year>
Reference: [JL87] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Principles of Programming Languages, </booktitle> <address> Munich, Germany, </address> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1987. </year>
Reference-contexts: The problem of solving equations in the finite tree theory is handled by D. Smith in CLP (F T ), [Smi91], in this case in the general setting of the constraint logic programming (CLP) scheme, cf. <ref> [JL87] </ref>. In CLP (F T ) the domain is restricted to conjunctions of equations and disequations between finite trees.
Reference: [JMar] <author> J. Jaffar and M.J. Maher. </author> <title> Constraint logic programming: A survey. </title> <journal> Journal of Logic Programming, </journal> <note> 1994 to appear. </note>
Reference: [KB70] <author> D.E. Knuth and P.B. Bendix. </author> <title> Simple word problems in universal algebras. </title> <editor> In J. Leech, editor, </editor> <booktitle> Computational Algebra. </booktitle> <publisher> Pergamon Press, </publisher> <address> N.Y., </address> <year> 1970. </year> <title> BIBLIOGRAPHY </title>
Reference: [KL87] <author> C. Kirchner and P. Lescanne. </author> <title> Solving disequations. </title> <booktitle> In Proceedings of the 2nd IEEE Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <pages> pages 347-352, </pages> <year> 1987. </year>
Reference-contexts: This would correspond to a simpler form of a solution in our terminology. Since this method is similar to Maher's it also lacks support for our requirements. Solving combinations of equations and disequations has also been addressed by Kirchner and Lescanne in <ref> [KL87] </ref>. Burckert discusses in [Bur88] the problem of 157 CHAPTER 14. RELATED WORK solving disequations in arbitrary equational theories. In this paper he introduces a more general notion of solutions as a substitution with exceptions, where the exceptions represent values not allowed.
Reference: [Kun87a] <author> K. Kunen. </author> <title> Answer sets and negation as failure. </title> <booktitle> In Logic Programming: Proceedings of the 4th International Conference (Melbourne), </booktitle> <pages> pages 219-228, </pages> <year> 1987. </year>
Reference-contexts: Maher [Mah88], where he presents complete axiomatizations for finite, rational and infinite trees, both for finite and infinite signatures. In that paper he also presents a decision procedure for such equational problems based on quantifier elimination. This quantifier elimination method was suggested by proofs in <ref> [Kun87a] </ref>, in relation to the finite tree theory with infinite signature. The quantifier elimination process involves putting a set of equations into prenex disjunctive normal form and then carrying out a set of operations for each quantifier. <p> The constraints handled here are systems of equations and inequations like those considered by Colmerauer. The paper presents algorithms with better complexity than the decision procedure used by Colmerauer. Decision procedures for finite trees with respect to Prolog are also discussed in <ref> [Kun87b, Kun87a] </ref>. The notion of constructive negation in Prolog is introduced by Chan in [Cha88]. This work uses the completed database and in order to handle negation reasonably efficiently, disjunctions of equations and inequalities are handled through backtracking.
Reference: [Kun87b] <author> K. Kunen. </author> <title> Negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 289-308, </pages> <year> 1987. </year>
Reference-contexts: The constraints handled here are systems of equations and inequations like those considered by Colmerauer. The paper presents algorithms with better complexity than the decision procedure used by Colmerauer. Decision procedures for finite trees with respect to Prolog are also discussed in <ref> [Kun87b, Kun87a] </ref>. The notion of constructive negation in Prolog is introduced by Chan in [Cha88]. This work uses the completed database and in order to handle negation reasonably efficiently, disjunctions of equations and inequalities are handled through backtracking.
Reference: [Lau78] <author> Jean-Louis Lauriere. </author> <title> A language and a program for stating and solving combinatorial problems. </title> <journal> Artificial Intelligence, </journal> <volume> 10 </volume> <pages> 29-127, </pages> <year> 1978. </year>
Reference: [Llo87] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: One way of doing this is as is that of Chap. 12 where we use a method described by Lloyd <ref> [Llo87] </ref>. The idea is that arbitrary quantified first-order goals are rewritten using a series of transformations, where we eventually end up with a series of clauses that include negated goals. To handle negated goals we use the approach described above using conditionals and conditional elimination. <p> In the following examples we will be using program statements where the body may contain an arbitrary first order logical formula. We use a method described by Lloyd <ref> [Llo87] </ref> on the source code to transform such programs into normal programs. In Lloyd's description SLDNF resolution is used, thus allowing negated goals. In our case we simply rewrite these into conditional clauses as described above. This source code transformation is not part of the constraint system.
Reference: [LM88] <author> J.L. Lassez and M. J. Maher. </author> <title> On Fourier's algorithm for linear arithmetic constraints. </title> <type> Technical report, </type> <institution> IBM - T.J. Watson Research Center, </institution> <year> 1988. </year>
Reference: [LMM88] <author> Jean-Louis Lassez, Michael J. Maher, and Kimbal G. Marriott. </author> <title> Unification revisited. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 587-625. </pages> <address> Morgan-Kauffman, </address> <year> 1988. </year>
Reference-contexts: The idea is after all to prune the search space as soon as possible. 9.1.2 Lifting Equations In the case of tree equality constraints it is not hard to see that the strongest common feature is the least common anti-instance (lca). The lca may be obtained through anti-unification <ref> [LMM88] </ref>.
Reference: [LMY87] <author> Catherine Lassez, Ken McAloon, and Roland Yap. </author> <title> Constraint logic programming and options trading. </title> <journal> IEEE Expert, Special Issue on Financial Software, </journal> <volume> 2(3) </volume> <pages> 42-50, </pages> <month> August </month> <year> 1987. </year>
Reference: [Mac77] <author> Alan K. Mackworth. </author> <title> Consistency in networks of relations. </title> <journal> Artificial Intelligence, </journal> <volume> 8(1) </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference: [Mah87] <author> Michael J. Maher. </author> <title> Logic Semantics for a Class of Committed-Choice Programs. </title> <booktitle> In Logic Programming: Proceedings of the 4th International Conference (Melbourne), </booktitle> <pages> pages 858-876, </pages> <year> 1987. </year>
Reference-contexts: Constraints over Herbrand terms in the context of concurrent constraint programming have been dealt with by V. Saraswat [Sar93]. Many of the ideas in concurrent constraint programming are presented in that book. The idea of using constraint entailment as means of program control is also recognized by Maher in <ref> [Mah87] </ref>, in discussing a class of flat committed-choice languages called ALPS. The idea is that atoms are to be selected only when no backtracking can occur. This is ensured either by determinate clauses or by constraint entailment, Maher uses the term validation.
Reference: [Mah88] <author> Michael J. Maher. </author> <title> Complete axiomatizations of the algebra of finite, rational and infinite trees. </title> <type> Technical report, </type> <institution> IBM - T.J. Watson Research Center, </institution> <year> 1988. </year>
Reference-contexts: In this work we have used some of the basic results and definitions found in a paper by M.J. Maher <ref> [Mah88] </ref>, where he presents complete axiomatizations for finite, rational and infinite trees, both for finite and infinite signatures. In that paper he also presents a decision procedure for such equational problems based on quantifier elimination.
Reference: [Mal71] <author> A. Mal'cev. </author> <title> Axiomatizable classes of locally free algebras of various types. The Metamathematics of Algebraic Systems: </title> <booktitle> Collected Papers, Chapter 23, </booktitle> <pages> pages 262-281, </pages> <year> 1971. </year> <note> 166 BIBLIOGRAPHY </note>
Reference-contexts: This method is very general and not at all aimed at high throughput. Considering the requirements of a concurrent constraint programming language, Maher's method does not support any of these. A general decision procedure for finite trees are also discussed in <ref> [Mal71] </ref>. An arbitrary formula is rewritten into an equivalent standard form, which consists of a boolean combination of quantified equations and inequations. The quantifier elimination method has further been used by Comon and Les-canne in [CL89].
Reference: [MM82] <author> Alberto Martelli and Ugo Montanari. </author> <title> An efficient unification algorithm. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(2) </volume> <pages> 258-282, </pages> <month> April </month> <year> 1982. </year>
Reference: [Mor78] <author> F. Lockwood Morris. </author> <title> On List Structures and Their use in the Programming of Unification. </title> <type> Research report, </type> <institution> School of Computer and Information Science, Syracuse University, Syracuse, </institution> <address> New York, </address> <year> 1978. </year>
Reference: [Muk91] <author> K. Mukai. </author> <title> Record algebra model for feature structures. </title> <type> Technical Report TR-655, </type> <institution> ICOT, </institution> <year> 1991. </year>
Reference-contexts: Feature structures have been further developed for use in the CCP type languages Life (an early description in [AKL88]) [AKP93b] and Oz [HSW93], also see [AKPS92, AKP93a]. Another early precursor are feature descriptions found originally in linguistics. Mukai has described them using a record algebra model <ref> [Muk91] </ref>. In [ST92] an algorithm for constraint simplification in feature trees is presented. The algorithm provides for incremental entailment and disentailment tests of simple constraints, i.e. atomic feature constraints closed under conjunction and existential quantification.
Reference: [Nai86] <author> Lee Naish. </author> <title> Negation and quantifiers in NU-Prolog. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> volume 225, </volume> <pages> pages 624-634. </pages> <publisher> Springer Verlag, </publisher> <year> 1986. </year>
Reference-contexts: This approach does not take into account that we 92 7.2. TREES IN AKL have special support for constraints on terms. Another approach taken to handle quantifiers and negation in Prolog is found in NU-Prolog by Lee Naish <ref> [Nai86] </ref>. Comparing with NU-Prolog we see that we need to handle existential quantification of goals, in order to hide variables, as well as negating goals. As described above we express negation of goals through conditionals together with the conditional elimination rule.
Reference: [Nak87] <author> H. Nakagawa. </author> <title> A prolog program transformation system. </title> <editor> In L.G.L.T. Meertens, editor, </editor> <booktitle> Program Specification and Transformation, </booktitle> <pages> pages 21-29. </pages> <publisher> Elsevier, </publisher> <year> 1987. </year>
Reference-contexts: utilized in our constraint system. 9.1 Constraint Lifting After an introduction to constraint lifting we will discuss how it may be utilized in the constraint system described in this thesis. 9.1.1 Introduction The term constraint lifting was originally coined in [SH90], although some of the basic ideas were present in <ref> [Nak87] </ref>, but then called common feature extraction. The idea found in Nakagawas work, which concerned Prolog program transformations, was to lift common equalities from clauses in a predicate definition and use them in the caller's definition, the point being an early pruning of the search space.
Reference: [NO80] <author> Greg Nelson and Derek C. Oppen. </author> <title> Fast decision procedure based on congruence closure. </title> <journal> JACM, </journal> <volume> 27(2) </volume> <pages> 356-364, </pages> <month> April </month> <year> 1980. </year>
Reference-contexts: A constraint system limited to equational and membership constraints over infinite trees is presented in [NTP93]. Intended for a CCP system the system has both tests for satisfiability and entailment. On the subject of combining constraint systems, Nelson and Oppen <ref> [NO80] </ref> have discussed adding a few interpreted function symbols to a quantifier-free theory of equality to handle lists of uninterpreted function symbols. 159 CHAPTER 14.
Reference: [NTP93] <author> Joachim Niehren, Ralf Treinen, and Andreas Podelski. </author> <title> Equational and Membership Constraints for Infinite Trees. </title> <institution> Research Report RR-93-14, Deutsches Forschungszentrum fur Kunstliche Intelligenz GmbH, (DFKI), Saabrucken, Germany, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: An aspect of the algorithm is that it uses simplification of the constraint to be checked for entailment. A constraint system limited to equational and membership constraints over infinite trees is presented in <ref> [NTP93] </ref>. Intended for a CCP system the system has both tests for satisfiability and entailment. On the subject of combining constraint systems, Nelson and Oppen [NO80] have discussed adding a few interpreted function symbols to a quantifier-free theory of equality to handle lists of uninterpreted function symbols. 159 CHAPTER 14.
Reference: [Pro90] <author> PrologIA. </author> <title> Prolog III, Reference Manual, </title> <note> 1990. Version 1.2. </note>
Reference: [Rv93] <author> Viswanath Ramachandran and Pascal van Hentenryck. </author> <title> Incremental Algorithms for Constraint Solving and Entailment over Rational Trees. </title> <booktitle> In Proc. 13th Conf. Foundations of Software Technology and Theoretical Computer Science, Bombay, </booktitle> <volume> LNCS 761, </volume> <pages> pages 205-217. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In this paper the problems occur as a conjunction of equations and disequations. The simpler case of just solving equations was discussed in an earlier paper [Col82]. Recently we have been made aware of a paper by Ramachandran and van Hentenryck <ref> [Rv93] </ref> that describes incremental algorithms for satisfiability and entailment tests over rational trees. The constraints handled here are systems of equations and inequations like those considered by Colmerauer. The paper presents algorithms with better complexity than the decision procedure used by Colmerauer.
Reference: [Sah91] <author> Dan Sahlin. </author> <title> An Automatic Partial Evaluator for Full Prolog. </title> <type> PhD thesis, </type> <institution> Royal Institute of Technology/SICS, </institution> <month> March </month> <year> 1991. </year> <title> SICS Dissertation Series 04, </title> <publisher> ISRN SICS/D--91/04--SE. </publisher>
Reference-contexts: In both cases, the motivation for using the technique was simply to transform (not at runtime) a program into an equivalent but hopefully faster program. This process is also known as partial evaluation described in for instance <ref> [Sah91] </ref>.
Reference: [Sar93] <author> Vijay A. Saraswat. </author> <title> Concurrent Constraint Programming. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: This also includes only using the full power of the solver when the alternative is to suspend execution (floundering). Constraints over Herbrand terms in the context of concurrent constraint programming have been dealt with by V. Saraswat <ref> [Sar93] </ref>. Many of the ideas in concurrent constraint programming are presented in that book. The idea of using constraint entailment as means of program control is also recognized by Maher in [Mah87], in discussing a class of flat committed-choice languages called ALPS.
Reference: [Sch86] <author> Alexander Schrijver. </author> <title> Theory of Linear and Integer Programming. </title> <address> Wi-ley, </address> <year> 1986. </year> <note> 167 BIBLIOGRAPHY </note>
Reference: [SH90] <author> D. S. Smith and T. J. Hickey. </author> <title> Partial evaluation of a CLP language. </title> <booktitle> In Logic Programming: Proceedings of the North American Conference, </booktitle> <address> Austin, Texas, </address> <pages> pages 119-138. </pages> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: techniques that may improve computations and how they can be utilized in our constraint system. 9.1 Constraint Lifting After an introduction to constraint lifting we will discuss how it may be utilized in the constraint system described in this thesis. 9.1.1 Introduction The term constraint lifting was originally coined in <ref> [SH90] </ref>, although some of the basic ideas were present in [Nak87], but then called common feature extraction. <p> CONSTRAINT LIFTING 9.1.3 Lifting Inequations As mentioned, in constraint lifting the common feature extraction is generalized to also include inequations. The presentation in <ref> [SH90] </ref> as well as in [Smi91] is somewhat involved and complicated. Intuitively when extracting common in-equations the inequations disallowing the least number of possible term instan-tiations must be used. An easily understood analogy is to consider inequations over an n-dimensional space.
Reference: [Sie86] <author> Jorg H. Siekmann. </author> <title> Unification theory. </title> <booktitle> In The 7th European Conf. on AI, ECAI86, </booktitle> <volume> volume II, </volume> <pages> pages vi-xxxv, </pages> <year> 1986. </year>
Reference: [Smi91] <author> Donald A. Smith. </author> <title> Constraint operations for CLP(FT). </title> <booktitle> In Logic Programming: Proceedings of the 8th International Conference (Paris), </booktitle> <pages> pages 760-774, </pages> <year> 1991. </year>
Reference-contexts: CONSTRAINT LIFTING 9.1.3 Lifting Inequations As mentioned, in constraint lifting the common feature extraction is generalized to also include inequations. The presentation in [SH90] as well as in <ref> [Smi91] </ref> is somewhat involved and complicated. Intuitively when extracting common in-equations the inequations disallowing the least number of possible term instan-tiations must be used. An easily understood analogy is to consider inequations over an n-dimensional space. <p> The problem of solving equations in the finite tree theory is handled by D. Smith in CLP (F T ), <ref> [Smi91] </ref>, in this case in the general setting of the constraint logic programming (CLP) scheme, cf. [JL87]. In CLP (F T ) the domain is restricted to conjunctions of equations and disequations between finite trees.
Reference: [Smi92] <author> Donald A. Smith. Multi-CLP: </author> <title> Disjunctive constraints in logic programming. </title> <type> Draft, </type> <year> 1992. </year>
Reference-contexts: Smith also introduces a notation for explicit quantification of variables in dise-quations. An application of disequations in CLP (F T ) is to avoid using cuts by instead explicitly adding disequations to clauses. The ideas in CLP (F T ) have been taken further by D. Smith in MultiLog <ref> [Smi92] </ref>, where constraints may be disjunctions. This is exemplified using finite trees. The main idea in the paper is 158 to allow the search for solutions to a disjunctive constraint to replace backtrack-ing.
Reference: [Smo93] <author> Gert Smolka. </author> <title> A Calculus for Higher-order Concurrent Constraint Programming. </title> <type> Research report, </type> <institution> Deutsches Forschungszentrum fur Kunstliche Intelligenz GmbH, (DFKI), Saabrucken, Germany, </institution> <month> July 18 </month> <year> 1993. </year>
Reference-contexts: He also uses the idea of local computations that update a global shared store. Maher also briefly mentions that the execution model allows for sound negation with non-ground goals. Constraints in concurrent constraint programming languages are also discussed in <ref> [Smo93] </ref> where a general calculus is discussed using a parameterized constraint system. The system is based on rewrites and simplifications. As precursors of feature structures we have the work on -terms [AK86].
Reference: [SS90] <author> K. Sakai and Y. Sato. </author> <title> Application of ideal theory to Boolean constraint solving. </title> <booktitle> In Proceedings of the Pacific Rim International Conference on Artificial Intelligence (PRICAI-90), </booktitle> <year> 1990. </year>
Reference: [ST92] <author> Gert Smolka and Ralf Treinen. </author> <title> Records for Logic Programming. </title> <institution> Research Report RR-93-23, Deutsches Forschungszentrum fur Kunstliche Intelligenz GmbH, (DFKI), Saabrucken, Germany, </institution> <month> Aug </month> <year> 1992. </year>
Reference-contexts: Feature structures have been further developed for use in the CCP type languages Life (an early description in [AKL88]) [AKP93b] and Oz [HSW93], also see [AKPS92, AKP93a]. Another early precursor are feature descriptions found originally in linguistics. Mukai has described them using a record algebra model [Muk91]. In <ref> [ST92] </ref> an algorithm for constraint simplification in feature trees is presented. The algorithm provides for incremental entailment and disentailment tests of simple constraints, i.e. atomic feature constraints closed under conjunction and existential quantification.
Reference: [Stu91] <author> Peter J. Stuckey. </author> <title> Constructive negation for constraint logic programming. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 328-339, </pages> <month> July </month> <year> 1991. </year>
Reference: [Tri78] <author> Wolfgang Trinks. Uber B. </author> <title> Buchbergers Verfahren, Systeme algebrais-cher Gleichungen zu losen. </title> <journal> Journal of Number Theory, </journal> <volume> 10 </volume> <pages> 475-488, </pages> <year> 1978. </year>
Reference: [van89] <author> Pascal van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. Logic Programming Series. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: This information is available anyway and thus should not prove to be a costly overhead. 104 8.4. INTELLIGENT BACKTRACKING We will elaborate further on this subject in the part covering the implementa-tional aspects. It is argued in <ref> [van89] </ref>, that lookahead schemes perform better than methods such as intelligent backtracking. In our case a few measures can be taken to handle the constraints more efficiently (at runtime). Consider the following: * Whenever possible we could order constraints at compile time. <p> Description Time (ms) choice splits RT 12 0 Another well-known puzzle is the zebra puzzle <ref> [van89] </ref>. The idea is to determine given a number of items, persons and attributes how they relate. The puzzle results in constraints using disjunctions, inequalities and a few equalities. The following version is used with RT. This version builds on an adaptation to AKL by Johan Montelius (SICS).

References-found: 67

