URL: http://www.cis.ohio-state.edu/~fridella/papers/icsr98.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~fridella/papers.html
Root-URL: 
Title: Inheritance: From Code Reuse to Reasoning Reuse  
Author: Neelam Soundarajan and Stephen Fridella 
Address: Columbus, OH 43210  
Affiliation: Computer and Information Science The Ohio State University  
Abstract: In the Object-Oriented approach a designer can, given an existing base class, use inheritance to build a derived class that extends, or that slightly differs from the base class. But in order to exploit the full potential of inheritance to build systems incrementally, the designer must also be able to reason about the derived class incrementally. This paper presents a specification notation and verification procedure that allows such incremental reasoning out; the approach makes important use of the concrete specification of a class, in addition to the usual abstract specification. The reasoning reuse that the approach enables is illustrated by applying it to a simple example. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. </author> <title> America. Designing an object oriented programming language with behavioral subtyping. </title> <booktitle> In Foundations of Object-Oriented Languages, REX School/Workshop, </booktitle> <volume> LNCS 489, </volume> <pages> pages 69-90. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: that we are not asking the question `Given a base class B and a derived class D, under what conditions can a client program use objects that are instances of D in place of instances of B?' The answer to that question is provided by the work on behavioral subtyping <ref> [1, 7, 8] </ref>. Informally, a class A is a behavioral subtype of another class B if the behavior exhibited by objects that are instances of A is in some sense consistent with behaviors allowed by the class B.
Reference: [2] <author> K.K. Dhara and G.T. Leavens. </author> <title> Forcing behavioral subtyping through specification inheritance. </title> <booktitle> In ICSE-18, </booktitle> <pages> pages 27-51. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: This is a remarkable degree of specification reuse that handily matches the code reuse. One might be tempted to argue that the reason for this is that BetterAccount is a (weak) behavioral subtype <ref> [2] </ref> of BankAccount. 11 But we will shortly mention another equally simple example which is not a behavioral subtype, strong or weak, of BankAccount for which also we will be able to inherit much of the base class spec 11 BetterAccount is not a behavioral subtype of BankAccount according to the <p> BankAccount for which also we will be able to inherit much of the base class spec 11 BetterAccount is not a behavioral subtype of BankAccount according to the definition of Liskov and Wing [7, 8], but it is a weak behavioral subtype, as per the definition of Dhara and Leavens <ref> [2] </ref>. ification. Next let us consider the verification task. As we saw in the last section, there are three steps in the verification task. Here again we will be able to inherit almost all of the work done in the base class. <p> This is perhaps the most important difference between behavioral subtyping <ref> [7, 3, 2] </ref> and our work; whereas the work on behavioral subtyping focuses on the relation between the abstract specifications of classes, our work shows how the derived class designer can use the concrete specification of the base class to build derived classes that are similar to but not (necessarily) behavioral <p> But note that in general there is no guarantee that (the abstract specification of) D will be a behavioral subtype of (the abstract specification of) B, so this line may or may not be present. Dhara and Leavens <ref> [2] </ref> consider re-strictions on how inheritance is used to ensure that the behavioral subtype relation holds. Our work shows that even if these restrictions are not satisfied, we have considerable specification and verification reuse, represented by the two intermediate horizontal lines.
Reference: [3] <author> S. Edwards. </author> <title> Representation inheritance: A safe form of `white box' code inheritance. </title> <booktitle> In ICSR4. IEEE, </booktitle> <year> 1996. </year>
Reference-contexts: This is perhaps the most important difference between behavioral subtyping <ref> [7, 3, 2] </ref> and our work; whereas the work on behavioral subtyping focuses on the relation between the abstract specifications of classes, our work shows how the derived class designer can use the concrete specification of the base class to build derived classes that are similar to but not (necessarily) behavioral <p> Dhara and Leavens [2] consider re-strictions on how inheritance is used to ensure that the behavioral subtype relation holds. Our work shows that even if these restrictions are not satisfied, we have considerable specification and verification reuse, represented by the two intermediate horizontal lines. Ed-wards <ref> [3] </ref> considers a somewhat intermediate situation; he considers the reasoning reuse that may be achieved if the derived class is not necessarily a behavioral subtype of the base class, but the conceptual model, the abstraction function, and the invariant are required to be the same in the derived class as they
Reference: [4] <author> J. Guttag, J. Horning, and J. Wing. </author> <title> The larch family of specification languages. </title> <journal> IEEE Software, </journal> <volume> 2, </volume> <year> 1985. </year>
Reference-contexts: But these other classes themselves are not visible outside so it should be possible to extend our approach to deal with this case. concrete specification of B. A will be the usual ADT--type specification <ref> [4] </ref>, consisting of a conceptual model of B, and the specifications of the methods of B in terms of pre- and post-conditions in this model.
Reference: [5] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: The idea of concrete specifications is of course not new; see, for instance, <ref> [5, 6] </ref>. What is new is that in keeping with the spirit of reuse, the concrete specification of a class B is serving double duty in our approach, once to help in verifying the class B, and a second time to help the derived class designer in reasoning about D.
Reference: [6] <author> C. Jones. </author> <title> Systematic Software Development Using VDM. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: The idea of concrete specifications is of course not new; see, for instance, <ref> [5, 6] </ref>. What is new is that in keeping with the spirit of reuse, the concrete specification of a class B is serving double duty in our approach, once to help in verifying the class B, and a second time to help the derived class designer in reasoning about D.
Reference: [7] <author> B. Liskov and J. Wing. </author> <title> A new definition of the subtype relation. </title> <booktitle> In ECOOP, </booktitle> <volume> LNCS 707, </volume> <pages> pages 118-141. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: that we are not asking the question `Given a base class B and a derived class D, under what conditions can a client program use objects that are instances of D in place of instances of B?' The answer to that question is provided by the work on behavioral subtyping <ref> [1, 7, 8] </ref>. Informally, a class A is a behavioral subtype of another class B if the behavior exhibited by objects that are instances of A is in some sense consistent with behaviors allowed by the class B. <p> will shortly mention another equally simple example which is not a behavioral subtype, strong or weak, of BankAccount for which also we will be able to inherit much of the base class spec 11 BetterAccount is not a behavioral subtype of BankAccount according to the definition of Liskov and Wing <ref> [7, 8] </ref>, but it is a weak behavioral subtype, as per the definition of Dhara and Leavens [2]. ification. Next let us consider the verification task. As we saw in the last section, there are three steps in the verification task. <p> This is perhaps the most important difference between behavioral subtyping <ref> [7, 3, 2] </ref> and our work; whereas the work on behavioral subtyping focuses on the relation between the abstract specifications of classes, our work shows how the derived class designer can use the concrete specification of the base class to build derived classes that are similar to but not (necessarily) behavioral <p> If further, we abide by the requirement that the derived class must be a behavioral subtype, then the abstract specifications of B and D will have the relation described by, for instance, Liskov and Wing <ref> [7, 8] </ref>; this is represented by the top most horizontal line in the figure, joining the boxes corresponding to the abstract specifications of B and D.
Reference: [8] <author> B. Liskov and J. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM TOPLAS, </journal> <volume> 16 </volume> <pages> 1811-1841, </pages> <year> 1994. </year>
Reference-contexts: that we are not asking the question `Given a base class B and a derived class D, under what conditions can a client program use objects that are instances of D in place of instances of B?' The answer to that question is provided by the work on behavioral subtyping <ref> [1, 7, 8] </ref>. Informally, a class A is a behavioral subtype of another class B if the behavior exhibited by objects that are instances of A is in some sense consistent with behaviors allowed by the class B. <p> will shortly mention another equally simple example which is not a behavioral subtype, strong or weak, of BankAccount for which also we will be able to inherit much of the base class spec 11 BetterAccount is not a behavioral subtype of BankAccount according to the definition of Liskov and Wing <ref> [7, 8] </ref>, but it is a weak behavioral subtype, as per the definition of Dhara and Leavens [2]. ification. Next let us consider the verification task. As we saw in the last section, there are three steps in the verification task. <p> If further, we abide by the requirement that the derived class must be a behavioral subtype, then the abstract specifications of B and D will have the relation described by, for instance, Liskov and Wing <ref> [7, 8] </ref>; this is represented by the top most horizontal line in the figure, joining the boxes corresponding to the abstract specifications of B and D.
Reference: [9] <author> R. Martin. </author> <title> Designing object oriented C++ applications using the Booch method. </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: Despite the distinction between behavioral subtyp-ing and inheritance, it is often claimed, and in this context this requirement is often called the Liskov Substitution Principle (LSP), that the derived class must be a behavioral subtype of the base class (see, for instance, <ref> [9] </ref>). The reason for this seems to be the concern that unless this requirement is imposed, inheritance will be no more than mere code reuse (terms such as `code scavenging' or `code hack' are often used to describe inheritance in the absence of behavioral subtyping).
Reference: [10] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: Thus even if the invariant of the base class is not maintained by the derived class, one or more of the operations defined in the base class may be inherited by D. This is different from the kind of invariant that, for instance, <ref> [10] </ref> uses. consider in section 4; in that example the abstraction function in the derived class is the same as in the base class. Before concluding this section it may be worth noting that the specification reuse is mainly at the concrete level.
Reference: [11] <author> N. Soundarajan and S. Fridella. </author> <title> Inheriting and modifying behavior. </title> <booktitle> In TOOLS23, </booktitle> <pages> pages 148-162. </pages> <publisher> IEEE, </publisher> <year> 1998. </year>
Reference-contexts: Further, in order to simplify the discussion we will assume that there are no private members. 4 The specification hA; Ci of B consists of two components, A, the abstract specification of B, and C, the 4 We consider private members in <ref> [11] </ref>. Eiffel has no private members, only public and protected; thus all members of a class are accessible in derived classes. Java allows not only derived classes, but all other classes that are in the same `package' as B to access all members of B except those declared private.
Reference: [12] <author> R. Stata and J.V. Guttag. </author> <title> Modular reasoning in the presence of subclassing. </title> <booktitle> In OOPSLA. </booktitle> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: If the redefined g's behavior matches its specification in B (and this is what <ref> [12] </ref> requires) then there would be no need to reverify f but this seems an unlikely scenario; why redefine g if its new behavior is going to match its old specification? 9 If g's redefined behavior does not match its specification in B then there are two possibilities: First, we could
References-found: 12

