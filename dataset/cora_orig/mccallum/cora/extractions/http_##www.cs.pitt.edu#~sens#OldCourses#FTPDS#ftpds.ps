URL: http://www.cs.pitt.edu/~sens/OldCourses/FTPDS/ftpds.ps
Refering-URL: http://www.cs.pitt.edu/~sens/courses.html
Root-URL: http://www.cs.pitt.edu
Title: Fault Tolerant Preemptive Real-Time Scheduling Algorithms Term Paper CS3420 Fault Tolerance in Parallel and Distributed Systems  
Author: Instructor Prof. Rami Melhem Joydeep Sen Sarma 
Date: December 10,1997  
Abstract-found: 0
Intro-found: 1
Reference: [GS78] <author> Teofilo Gonzalez and Sartaj Sahni. </author> <title> Preemptive scheduling of uniform processor systems. </title> <journal> Journal of the ACM, </journal> <volume> 25(1) </volume> <pages> 92-101, </pages> <month> January </month> <year> 1978. </year>
Reference-contexts: Horn [Hor74] showed that the problem of scheduling tasks with release times and deadlines on identical processors can be reduced to the network flow problem which can be solved in O (n 3 ) time. Gonzalez and Sahni <ref> [GS78] </ref> have an O (n + m log n) algorithm when all release times and deadlines are equal but the processors have different speeds while Sahni and Cho [SC80] give a O (n log n + mn) algorithm for the same problem while also allowing variable deadlines.
Reference: [Hor74] <author> W. A. Horn. </author> <title> Some simple scheduling algorithms. </title> <journal> Naval Research Logistics Quarterly, </journal> <volume> 21 </volume> <pages> 177-185, </pages> <year> 1974. </year>
Reference-contexts: Earliest deadline first (EDF) is well known to be optimal scheduling algorithm for tasks with deadlines on a uniprocessor system. Horn <ref> [Hor74] </ref> showed that the problem of scheduling tasks with release times and deadlines on identical processors can be reduced to the network flow problem which can be solved in O (n 3 ) time. <p> Martel [Mar82] extends the solution given in <ref> [Hor74] </ref> to the case where the processors are not identical. It may be noted that the case of fixed release times and variable deadlines is symmetrical to the case of variable release times and a fixed common deadline.
Reference: [Mar82] <author> Charles Martel. </author> <title> Preemptive scheduling with release times, deadlines, and due times. </title> <journal> Journal of the ACM, </journal> <month> July </month> <year> 1982. </year>
Reference-contexts: Martel <ref> [Mar82] </ref> extends the solution given in [Hor74] to the case where the processors are not identical. It may be noted that the case of fixed release times and variable deadlines is symmetrical to the case of variable release times and a fixed common deadline.
Reference: [OS92] <author> Yingfeng Oh and S. H. Son. </author> <title> Fault-tolerant real time multiprocessor scheduling. </title> <type> Technical Report CS-92-09, </type> <institution> Department of Computer Science, University of Virginia, </institution> <month> April 9 </month> <year> 1992. </year>
Reference-contexts: Any algorithm for the former can be used to generate schedules for the latter and vice versa. Fault tolerance has been studied for the case of periodic preemptive real-time tasks. <ref> [OS92] </ref> and [SGS] discuss fault tolerance for the rate-monotonic scheduling algorithm. [SGM97] discusses fault tolerant scheduling for non-preemptive real-time tasks.
Reference: [SC80] <author> S. Sahni and Y. Cho. </author> <title> Scheduling independent tasks with due times on uniform processor system. </title> <journal> Journal of the ACM, </journal> <volume> 27 </volume> <pages> 550-563, </pages> <year> 1980. </year>
Reference-contexts: Gonzalez and Sahni [GS78] have an O (n + m log n) algorithm when all release times and deadlines are equal but the processors have different speeds while Sahni and Cho <ref> [SC80] </ref> give a O (n log n + mn) algorithm for the same problem while also allowing variable deadlines. Martel [Mar82] extends the solution given in [Hor74] to the case where the processors are not identical. <p> Fill p m from D S to D with slack space S. The processor set can now be considered as being composed of processors with variable speeds as in <ref> [SC80] </ref>. p 1 through p m1 have constant speed s while p m has a speed of s from time 0 to D S and a speed of 0 thereafter. The set of tasks have identical release times but different deadlines. <p> on this new processor set then the resulting schedule can tolerate a single fault. (Task t i will finish by time D c i and if it detects failure at end of computation then it can re-execute for c i time on processor p n .) Sahni and Cho in <ref> [SC80] </ref> show how to solve such a scheduling problem optimally and their scheduling algorithm takes time O (n log n + mn). Thus it is possible to come up with a fault tolerant schedule for the case of identical release times and deadlines in this time.
Reference: [SGM97] <author> R. Melhem S. Ghosh and D. Mosse'. </author> <title> Fault-tolerance through scheduling of aperiodic tasks in hard real-time multiprocessor systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <month> March </month> <year> 1997. </year>
Reference-contexts: Any algorithm for the former can be used to generate schedules for the latter and vice versa. Fault tolerance has been studied for the case of periodic preemptive real-time tasks. [OS92] and [SGS] discuss fault tolerance for the rate-monotonic scheduling algorithm. <ref> [SGM97] </ref> discusses fault tolerant scheduling for non-preemptive real-time tasks.
Reference: [SGS] <author> D. Mosse' S. Ghosh, R. Melhem and J. Sen Sarma. </author> <title> Fault tolerant rate monotonic scheduling. </title> <note> Journal of Real-Time Systems to appear. </note>
Reference-contexts: Any algorithm for the former can be used to generate schedules for the latter and vice versa. Fault tolerance has been studied for the case of periodic preemptive real-time tasks. [OS92] and <ref> [SGS] </ref> discuss fault tolerance for the rate-monotonic scheduling algorithm. [SGM97] discusses fault tolerant scheduling for non-preemptive real-time tasks. <p> presented earlier for EDF. 2.2 Proof of Correctness While FTEDF test does reserve enough slack within the window of each task in actual EDF execution this slack is going to be used by the task with the earliest deadline and is going to be swapped forward in time as in <ref> [SGS] </ref>. We have to prove that passing the FTEDF test indeed implies that the task set is schedulable and can tolerate faults under the given fault model.
References-found: 7

