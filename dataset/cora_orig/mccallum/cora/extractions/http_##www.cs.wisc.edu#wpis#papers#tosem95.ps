URL: http://www.cs.wisc.edu/wpis/papers/tosem95.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Program Integration for Languages with Procedure Calls  
Author: DAVID BINKLEY, SUSAN HORWITZ, and THOMAS REPS David Binkley, Susan Horwitz, and Thomas Reps. 
Note: Authors' address:  Copyright 1993 by  All rights reserved.  
Address: Wisconsin Madison  1210 W. Dayton St., Madison, WI 53706.  
Affiliation: University of  Computer Sciences Department, University of Wisconsin-Madison,  
Abstract: Given a program Base and two variants, A and B, each created by modifying separate copies of Base, the goal of program integration is to determine whether the modifications interfere, and if they do not, to create an integrated program that incorporates both sets of changes as well as the portions of Base preserved in both variants. Text-based integration techniques, such as the one used by the UNIX diff3 utility, are obviously unsatisfactory because one has no guarantees about how the execution behavior of the integrated program relates to the behaviors of Base, A, and B. The first program-integration algorithm to provide such guarantees was developed by Horwitz, Prins, and Reps. However, a limitation of that algorithm is that it only applies to programs written in a restricted languagein particular, the algorithm does not handle programs with procedures. This paper describes a generalization of the Horwitz-Prins-Reps algorithm that handles programs that consist of multiple (and possibly mutually recursive) procedures. We show that two straightforward generalizations of the Horwitz-Prins-Reps algorithm yield unsatisfactory results. The key issue in developing a satisfactory algorithm is how to take into account different calling contexts when determining what has changed in the variants A and B. Our solution to this problem involves identifying two different kinds of affected components of A and B: those affected regardless of how the procedure is called, and those affected by a changed or new calling context. The algorithm makes use of interprocedural program slicing to identify these components, as well as components in Base, A, and B with the same behavior. CR Categories and Subject Descriptors: D.2.2 [Software Engineering]: Tools and Techniquesprogrammer workbench; D.2.3 [Software Engineering]: Codingprogram editors; D.2.6 [Software Engineering]: Programming Environments; D.2.7 [Software Engineering]: Distribution and Maintenanceenhancement, restructuring, version control; D.2.9 [Software Engineering]: Managementprogramming teams, software configuration management; D.3.3 [Programming Languages]: Language Constructscontrol structures, procedures, functions, and subroutines; D.3.4 [Programming Languages]: Processorscompilers, interpreters, optimization; E.1 [Data Structures] graphs. hhhhhhhhhhhhhhhhhhhhhhhhhhhhh This work was supported in part by a David and Lucile Packard Fellowship for Science and Engineering, by the National Science Foundation under grants DCR-8552602, CCR-8958530, and CCR 91-00424, by the Defense Advanced Research Projects Agency under ARPA Order Nos. 6378 and 8856, monitored by the Office of Naval Research under contracts N00014-88-K-0590 and N00014-92-J-1937, as well as by grants from IBM, DEC, HP, Xerox, 3M, Eastman Kodak, and the Cray Research Foundation. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Ball, T., Horwitz, S., and Reps, T., </author> <title> Correctness of an algorithm for reconstituting a program from a dependence graph, </title> <institution> TR-947, Computer Sciences Department, University of Wisconsin, Madison, </institution> <address> WI (July 1990). </address>
Reference-contexts: call statement is represented using a call-site vertex; parameter passing is represented using four kinds of parameter vertices: on the calling side, parameter passing is represented by two kinds of vertices, called actual-in and actual-out vertices, which are control hhhhhhhhhhhhhhhhhhhhhhhhhhhhh **A minor correction to the program-reconstitution algorithm is given in <ref> [1] </ref>. 9 Because the term program dependence graph is associated with graphs that represent single procedure programs, we introduced the term system dependence graph for the dependence graphs that represent multi-procedure programs [8].
Reference: 2. <author> Binkley, D., </author> <title> Multi-procedure program integration, </title> <type> Ph.D. </type> <institution> dissertation and Technical Report TR-1038, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (August 1991). </note>
Reference-contexts: First we describe the specific problem meeting-point vertices and edges solve and why this problem exists only in the presence of dead code. Then we present a formal definition of meeting-point vertices and edges. An algorithm for the efficient computation of meeting-point vertices and edges can be found in <ref> [2] </ref> The problem meeting-point vertices solve arises when the value of more than one actual parameter affects a dead computation in a (transitively) called procedure. When computing D S , if the actual-in vertex of one of these parameters is an affected point then the dead computation is also affected. <p> A. Bricker for their role in the implementation of Integrate S as part of the Wisconsin Program Integration System. In addition, we wish to acknowledge Genevieve Rosay for devising the Type III interference test, which replaces a related, but more compli cated test presented in <ref> [2] </ref>.
Reference: 3. <author> Binkley, D., Horwitz, S., and Reps, T., </author> <title> The Theory of Multi-Procedure Integration, </title> <note> Technical Report (in preparation), </note> <institution> Computer Sciences Department, University of Wisconsin, Madison, WI (1993). </institution>
Reference-contexts: A few words about the Standard Instantiation are in order at this point: (i) The pair (Integrate , Integrate S ) satisfies the Revised Model of Program Integration <ref> [3] </ref>. The proof follows from three results outlined below. First, the integration and slicing theorems for single-procedure programs extend to sets of infinite programs. Thus, M satisfies Part 1 of the model. <p> It does, however, simplify the argument, given in <ref> [3] </ref>, that Integrate S satisfies the Revised Model of Program Integration. <p> This is accomplished using b2 slices; a vertex with the same b2 slice exhibits the same behavior when the procedure containing the vertex is called with the same initial argument values in Base, A, and B <ref> [3] </ref>. Thus, we define Pre S as follows: Pre S (Base, A, B) = df (Base, - v V (Base) | b2 (A, v) = b2 (Base, v ) = b2 (B, v ) -). 4.1.3. <p> Step 3: Forming the merged graph The merged graph is formed as follows: G M = D S (A, Base) D S (B, Base) Pre S (Base, A, B). In <ref> [3] </ref> it is shown that this construction is a true generalization of the one used in the HPR algorithm; that is, for systems that consist of only a single procedure (i.e., with no calls to auxiliary procedures), G M is identical to the merged graph constructed by the HPR algorithm. 4.1.4.
Reference: 4. <author> Cooper, K.D. and Kennedy, K., </author> <title> Interprocedural side-effect analysis in linear time, </title> <booktitle> Proceedings of the ACM SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <address> (Atlanta, GA, </address> <month> June 22-24, </month> <year> 1988), </year> <journal> ACM SIGPLAN Notices 23(7) pp. </journal> <month> 57-66 (July </month> <year> 1988). </year>
Reference-contexts: and formal-in vertices are included for every global variable that may be used or modified as a result of the call and for every parameter; formal-out and actual-out vertices are included only for global variables and parameters that may be modified as a result of the call. (Interprocedural side-effect analysis <ref> [4] </ref> is used to determine which global variables need to be represented by parameter vertices.) Summary edges are added from actual-in vertices to actual-out vertices to represent transitive data dependences due to called procedures. These edges are defined as follows. DEFINITION.
Reference: 5. <author> Donzeau-Gouge, V., Huet, G., Kahn, G., and Lang, B., </author> <title> Programming environments based on structured editors: The MENTOR experience, pp. 128-140 in Interactive Programming Environments, </title> <editor> ed. - 30 - D. Barstow, E. Sandewall, and H. Shrobe,McGraw-Hill, </editor> <address> New York, NY (1984). </address>
Reference-contexts: fail to terminate normally on some initial state: (1) the program contains a non-terminating loop, or (2) a fault occurs, such as division by zero. 4 A tagging facility meeting these requirements can be supported by language-based editors, such as those that can be created by such systems as MENTOR <ref> [5] </ref>, GANDALF [11], and the Synthesizer Generator [13]. - 6 - Component tags furnish the means for identifying how the program-dependence-graph vertices in different versions correspond. It is the tags that are used to determine identical vertices when operations are performed using vertices from different program dependence graphs. 2.1.1.
Reference: 6. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Transactions on Programming Languages and Systems 9(3) pp. </journal> <month> 319-349 (July </month> <year> 1987). </year>
Reference-contexts: To determine this information, the HPR algorithm employs a program representation that is similar to the program dependence graphs used previously in vectorizing and parallelizing compilers <ref> [6, 9] </ref>. The HPR algorithm also makes use of Weiser's notion of a program slice [12, 21] to find the statements of a program that contribute to the computation of the program elements with changed behavior.
Reference: 7. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: Determining any non-trivial property of a program's execution behavior is undecidable; thus, a semantics-based integration tool must use techniques that provide safe approximations to undecidable problems. The first algorithm for semantics-based program integration was formulated by Horwitz, Prins, and Reps <ref> [7] </ref>. This algorithm will be referred to hereafter as the HPR algorithm. A limitation of the HPR algorithm is that it applies only to a restricted programming languageone that does not include procedures and procedure calls. <p> respect to A (or if the analogous condition holds for B); that is, Type I interference exists iff D hpr (A, Base) DAP hpr (G M , A) or D hpr (B, Base) DAP hpr (G M , B) . (A different definition of Type I interference was used in <ref> [7] </ref>; the two definitions are shown to be equivalent in [15].) The final step of the HPR algorithm involves reconstituting a program from G M . <p> However, it is possible that no such program existsthe merged graph can be an infeasible PDG; this is Type II interference. (The crux of program reconstitution is to determine whether it is possible to order the program components so as to preserve the dependences represented by the PDG edges; see <ref> [7] </ref> for a discussion of program hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 7 Given directed graphs G 1 = (V 1 , E 1 ) and G 2 = (V 2 , E 2 ), the graph union, G 1 G 2 , is defined as: (V 1 V 2 , E 1 E 2 ). <p> Second, even if all of the SDG's PDGs are feasible, G M may be SDG-infeasible (i.e., G M may still be infeasible due to procedure linkage constraints). PDG-infeasibility is tested for by applying the program-reconstitution algorithm from <ref> [7] </ref> to each PDG in G M (a few straightforward modifications to the reconstitution algorithm are needed to accommodate the additional kinds of vertices that represent call statements). <p> The exception is the reconstitution of a procedure from a PDG. This is in general an NP-complete problem; however, in practice we do not expect this phase to exhibit exponential worst-case behavior <ref> [7] </ref>, and so we expect that the cost of Integrate S will be polynomial in the sizes of Base, A, and B. The cost of adding meeting point vertices and edges is bounded by O (P E TotalSites Params 4 ). <p> regions in any procedure's PDG. iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c c If no backtracking is required, the cost of reconstituting a single procedure from a PDG is O (R N 2 (N 2 + Var G 2 SP)) <ref> [7] </ref>. The cost of reconstituting M is the cost of reconstituting the PDGs in G M (i.e., O (P (R N 2 (N 2 + Var G 2 SP)))).
Reference: 8. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: These extensions were defined in <ref> [8] </ref>; summaries are given below. 2.2.1. The system dependence graph The system dependence graph (SDG) extends previous dependence representations to accommodate collections of procedures (with procedure calls) rather than just monolithic programs. <p> actual-in and actual-out vertices, which are control hhhhhhhhhhhhhhhhhhhhhhhhhhhhh **A minor correction to the program-reconstitution algorithm is given in [1]. 9 Because the term program dependence graph is associated with graphs that represent single procedure programs, we introduced the term system dependence graph for the dependence graphs that represent multi-procedure programs <ref> [8] </ref>. Similarly, we use systemrather than programto mean a program with multiple procedures. 10 Techniques for handling parameters passed by reference and for dealing with aliasing are discussed in [8]. - 11 - dependent on the call vertex; in the called procedure, parameter passing is represented by two kinds of vertices, <p> graphs that represent single procedure programs, we introduced the term system dependence graph for the dependence graphs that represent multi-procedure programs <ref> [8] </ref>. Similarly, we use systemrather than programto mean a program with multiple procedures. 10 Techniques for handling parameters passed by reference and for dealing with aliasing are discussed in [8]. - 11 - dependent on the call vertex; in the called procedure, parameter passing is represented by two kinds of vertices, called formal-in and formal-out vertices, which are control dependent on the procedure's entry vertex. <p> Summary edges can be computed using a variation on the technique used to compute the subordinate-characteristic graphs of an attribute grammar's nonterminals. The computation of summary edges is described in <ref> [8] </ref>. - 12 - Procedure dependence graphs are connected to form an SDG using three new kinds of edges: (1) a call edge is added from each call-site vertex to the corresponding procedure-entry vertex; (2) a parameter-in edge is added from each actual-in vertex at a call site to the corresponding
Reference: 9. <author> Kuck, D.J., Kuhn, R.H., Leasure, B., Padua, D.A., and Wolfe, M., </author> <title> Dependence graphs and compiler optimizations, pp. </title> <booktitle> 207-218 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1981). </address>
Reference-contexts: To determine this information, the HPR algorithm employs a program representation that is similar to the program dependence graphs used previously in vectorizing and parallelizing compilers <ref> [6, 9] </ref>. The HPR algorithm also makes use of Weiser's notion of a program slice [12, 21] to find the statements of a program that contribute to the computation of the program elements with changed behavior.
Reference: 10. <author> Landi, W. and Ryder, B., </author> <title> Pointer-induced aliasing: A problem classification, pp. </title> <booktitle> 93-103 in Conference Record of the Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Orlando, FL, </address> <month> January 21-23, </month> <year> 1991), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1991). </address>
Reference-contexts: The traversal in Pass 2 starts from all vertices reached in Pass 1 and goes backwards along flow edges, control edges, summary edges, and hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 11 A similar concern with non-executable paths arises in the context of interprocedural dataflow analysis <ref> [10, 20] </ref>. - 13 - parameter-out edges, but not along def-order, call, or parameter-in edges. The result of an interprocedural slice consists of the sets of vertices encountered during Pass 1 and Pass 2, and the set of edges induced by this vertex set.
Reference: 11. <author> Notkin, D., Ellison, R.J., Staudt, B.J., Kaiser, G.E., Kant, E., Habermann, A.N., Ambriola, V., and Montangero, C., </author> <title> Special issue on the GANDALF project, </title> <journal> Journal of Systems and Software 5(2)(May 1985). </journal>
Reference-contexts: terminate normally on some initial state: (1) the program contains a non-terminating loop, or (2) a fault occurs, such as division by zero. 4 A tagging facility meeting these requirements can be supported by language-based editors, such as those that can be created by such systems as MENTOR [5], GANDALF <ref> [11] </ref>, and the Synthesizer Generator [13]. - 6 - Component tags furnish the means for identifying how the program-dependence-graph vertices in different versions correspond. It is the tags that are used to determine identical vertices when operations are performed using vertices from different program dependence graphs. 2.1.1.
Reference: 12. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May </month> <year> 1984). </year>
Reference-contexts: To determine this information, the HPR algorithm employs a program representation that is similar to the program dependence graphs used previously in vectorizing and parallelizing compilers [6, 9]. The HPR algorithm also makes use of Weiser's notion of a program slice <ref> [12, 21] </ref> to find the statements of a program that contribute to the computation of the program elements with changed behavior. The HPR algorithm assumes that program components are tagged so that corresponding components can be identified in Base, A, and B.
Reference: 13. <author> Reps, T. and Teitelbaum, T., </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors, </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1988). </address>
Reference-contexts: state: (1) the program contains a non-terminating loop, or (2) a fault occurs, such as division by zero. 4 A tagging facility meeting these requirements can be supported by language-based editors, such as those that can be created by such systems as MENTOR [5], GANDALF [11], and the Synthesizer Generator <ref> [13] </ref>. - 6 - Component tags furnish the means for identifying how the program-dependence-graph vertices in different versions correspond. It is the tags that are used to determine identical vertices when operations are performed using vertices from different program dependence graphs. 2.1.1.
Reference: 14. <author> Reps, T. and Yang, W., </author> <title> The semantics of program slicing, </title> <institution> TR-777, Computer Sciences Department, University of Wisconsin, Madison, </institution> <address> WI (June 1988). </address>
Reference-contexts: Step 1: Determining changed slices If the slice of variant A with respect to vertex v differs from the slice of Base with respect to v, then A and Base may compute a different sequence of values at v <ref> [14] </ref>. In other words, vertex v is a site that potentially exhibits changed behavior in the two programs. <p> Step 2: Determining preserved slices A vertex that has the same slice in all three programs is guaranteed to exhibit the same behavior <ref> [14] </ref>.
Reference: 15. <author> Reps, T. and Bricker, T., </author> <title> Illustrating interference in interfering versions of programs, </title> <booktitle> Proceedings of the 2nd International Workshop on Software Configuration Management, </booktitle> <address> (Princeton, NJ, </address> <month> Oct. </month> <pages> 24-27, </pages> <year> 1989), </year> <booktitle> ACM SIGSOFT Software Engineering Notes 17(7) pp. </booktitle> <month> 46-55 (November </month> <year> 1989). </year>
Reference-contexts: B); that is, Type I interference exists iff D hpr (A, Base) DAP hpr (G M , A) or D hpr (B, Base) DAP hpr (G M , B) . (A different definition of Type I interference was used in [7]; the two definitions are shown to be equivalent in <ref> [15] </ref>.) The final step of the HPR algorithm involves reconstituting a program from G M .
Reference: 16. <author> Reps, T., </author> <title> Demonstration of a prototype tool for program integration, </title> <institution> TR-819, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (January 1989). </note>
Reference-contexts: Recap of Integrate S Putting all the pieces together, a complete algorithm for multi-procedure integration appears in Figure 12. This algorithm has been implemented in a prototype system, called the Wisconsin Program Integration System <ref> [16, 17] </ref>. This system can be obtained by contacting the second or third authors. It is being distributed under license by the Computer Sciences Department at the University of Wisconsin-Madison.
Reference: 17. <author> Reps, T., </author> <title> The Wisconsin program-integration system reference manual: Release 2.0, </title> <type> Unpublished report, </type> <institution> Computer Sciences Department, University of Wisconsin, Madison, </institution> <address> WI (July 1993). </address> - <month> 31 </month> - 
Reference-contexts: Recap of Integrate S Putting all the pieces together, a complete algorithm for multi-procedure integration appears in Figure 12. This algorithm has been implemented in a prototype system, called the Wisconsin Program Integration System <ref> [16, 17] </ref>. This system can be obtained by contacting the second or third authors. It is being distributed under license by the Computer Sciences Department at the University of Wisconsin-Madison.
Reference: 18. <author> Reps, T., Sagiv, M., and Horwitz, S., </author> <title> Interprocedural dataflow via graph reachability, </title> <type> Unpublished report, </type> <institution> Datalogisk Institut, University of Coopenhagen, Copenhagen, </institution> <address> Denmark (April 1994). </address>
Reference-contexts: The cost of adding call, parameter-in, and parameter-out edges is bounded by O (TotalSites Params). The cost of adding summary edges is bounded by O ((E TotalSites Params) + (TotalSites Params 3 )) <ref> [18] </ref>. Thus, the total cost of building the SDG is bounded by O ((P CE Assign) + (E TotalSites Params) + (TotalSites Params 3 )).
Reference: 19. <author> Rice, H.G., </author> <title> Classes of recursively enumerable sets and their decision problems, </title> <journal> Trans. </journal> <pages> AMS 89 pp. </pages> <month> 25-59 </month> <year> (1953). </year> <title> (as cited in Hopcroft and Ullman, Introduction to Automata theory, Languages, and Computation, </title> <publisher> Addison-Wesley, </publisher> <year> 1979) </year>
Reference-contexts: However, the problem of whether a program exists that satisfies Property (2) is not decidable, even under the restrictions given by Properties (1) and (3) <ref> [19] </ref>; consequently, to be safe any program-integration algorithm must sometimes report interferenceand consequently fail to produce an integrated programeven though there is actually no interference (i.e., even when there is some program that meets the criteria given above).
Reference: 20. <author> Sharir, M. and Pnueli, A., </author> <title> Two approaches to interprocedural data flow analysis, pp. 189-233 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: The traversal in Pass 2 starts from all vertices reached in Pass 1 and goes backwards along flow edges, control edges, summary edges, and hhhhhhhhhhhhhhhhhhhhhhhhhhhhh 11 A similar concern with non-executable paths arises in the context of interprocedural dataflow analysis <ref> [10, 20] </ref>. - 13 - parameter-out edges, but not along def-order, call, or parameter-in edges. The result of an interprocedural slice consists of the sets of vertices encountered during Pass 1 and Pass 2, and the set of edges induced by this vertex set.
Reference: 21. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: To determine this information, the HPR algorithm employs a program representation that is similar to the program dependence graphs used previously in vectorizing and parallelizing compilers [6, 9]. The HPR algorithm also makes use of Weiser's notion of a program slice <ref> [12, 21] </ref> to find the statements of a program that contribute to the computation of the program elements with changed behavior. The HPR algorithm assumes that program components are tagged so that corresponding components can be identified in Base, A, and B. <p> Interprocedural slicing Interprocedural slicing can be defined as a reachability problem using the SDG, just as intraprocedural slicing is defined as a reachability problem using the PDG. The slices obtained using this approach are the same as those obtained using Weiser's interprocedural-slicing method <ref> [21] </ref>. However, this approach does not produce slices that are as precise as possible, because it considers paths in the graph that are not possible execution paths.

References-found: 21

