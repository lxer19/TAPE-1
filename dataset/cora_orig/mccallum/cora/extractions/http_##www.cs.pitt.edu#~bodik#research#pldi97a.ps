URL: http://www.cs.pitt.edu/~bodik/research/pldi97a.ps
Refering-URL: http://www.cs.pitt.edu/~bodik/research/pldi97a.html
Root-URL: 
Email: fbodik,gupta,soffag@cs.pitt.edu  
Title: Interprocedural Conditional Branch Elimination  
Author: Rastislav Bodk Rajiv Gupta Mary Lou Soffa 
Keyword: interprocedural data flow analysis, conditional branch correlation, path-sensitive optimization, optimization of object-oriented languages.  
Address: Pittsburgh Pittsburgh, PA 15260  
Affiliation: Dept. of Computer Science University of  
Abstract: The existence of statically detectable correlation among conditional branches enables their elimination, an optimization that has a number of benefits. This paper presents techniques to determine whether an interprocedural execution path leading to a conditional branch exists along which the branch outcome is known at compile time, and then to eliminate the branch along this path through code restructuring. The technique consists of a demand driven interprocedural analysis that determines whether a specific branch outcome is correlated with prior statements or branch outcomes. The optimization is performed using a code restructuring algorithm that replicates code to separate out the paths with correlation. When the correlated path is affected by a procedure call, the restructuring is based on procedure entry splitting and exit splitting. The entry splitting transformation creates multiple entries to a procedure, and the exit splitting transformation allows a procedure to return control to one of several return points in the caller. Our technique is efficient in that the correlation detection is demand driven, thus avoiding exhaustive analysis of the entire program, and the restructuring never increases the number of operations along a path through an interprocedural control flow graph. We describe the benefits of our interprocedural branch elimination optimization (ICBE). Our experimental results show that, for the same amount of code growth, the estimated reduction in executed conditional branches is about 2.5 times higher with the ICBE optimization than when only intrapro-cedural conditional branch elimination is applied. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ole Agesen and Urs Holzle. </author> <title> Type feedback vs. type inference: A comparison of optimization techniques for object-oriented languages. </title> <booktitle> In OOPSLA'95 Conference Proceedings, </booktitle> <pages> pages 91-107, </pages> <address> Austin, TX, </address> <year> 1995. </year>
Reference-contexts: Since such call sites require expensive dynamic dispatching, methods for their elimination through concrete type inference have been developed <ref> [1, 20, 21] </ref>. In these methods, demand-driven interprocedural analysis determines for each call site the set of "reaching concrete types." Subsequent program restructuring separates out paths and clones procedures with the goal of creating call sites reached by a single type of the receiver.
Reference: [2] <author> Andrew Ayers, Robert Gottlieb, and Richard Schooler. </author> <title> Aggressive inlining. </title> <booktitle> SIGPLAN Notices, 1997. Proceedings of the ACM SIGPLAN '97 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: We present an alternative approach that incurs less code growth than inlining because only paths with correlation are duplicated. Another advantage of our algorithm is that it enables optimizations of call sites where inlining is not possible <ref> [2] </ref>. The algorithm is based upon procedure entry splitting and exit splitting. The entry splitting transformation creates multiple entries to a procedure through which the procedure can be entered from different call sites. <p> Regardless of the exact ICBE scenario, the correlation analysis produces an upper bound on the code growth required to eliminate the conditional and, if profile information is available, provides also a profile-based estimate of the cost-effectiveness of the optimization before it is applied. The inlining algorithm in <ref> [2] </ref> inlines procedures one by one based on their execution rate until a code growth budget is exhausted. Our correlation analysis can be used in the inliner to give procedures that generate correlation a higher priority so that correlated branches can be removed after 11 inlining [6, 8].
Reference: [3] <author> Thomas Ball and James R. Larus. </author> <title> Efficient path profiling. </title> <booktitle> In 29th Annual IEEE/ACM International Symposium on Microarchitecture, </booktitle> <address> Paris, France, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction Recent research in branch prediction [16, 24, 25], profiling <ref> [3] </ref>, and the elimination of conditional branches [19] has reported the existence of significant amounts of correlation among conditional branches, presenting opportunities for optimizations.
Reference: [4] <author> Rastislav Bodk and Rajiv Gupta. </author> <title> Partial dead code elimination using slicing transformations. </title> <booktitle> SIGPLAN Notices, 1997. Proceedings of the ACM SIGPLAN '97 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The ICBE optimization can be used to optimize array bounds checks [15, 11] which typically exhibit correlation. Finally, branch elimination can be used as a component of aggressive program transformations, such as slicing-based partial dead code elimination <ref> [4] </ref>. 6 Acknowledgement We want to thank Mooly Sagiv for his help with preparing the final version of this paper. The comments of the anonymous referees aided the presentation of this paper. 12
Reference: [5] <author> Preston Briggs and Keith D. Cooper. </author> <title> Effective partial redundancy elimination. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 159-170, </pages> <month> June </month> <year> 1994. </year> <booktitle> Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: These procedures often perform correlated tests on the propagated values. With our optimization, the repeated testing can be eliminated. Conditional branch elimination is a form of partial redundancy elimination (PRE). However, the code motion techniques useful for PRE of assignments <ref> [14, 5] </ref> do not suffice for removing conditional branches. To eliminate a conditional, the control flow graph must be restructured in order to separate the correlated path from the rest of the paths [19].
Reference: [6] <author> Paul R. Carini. </author> <title> Automatic inlining. </title> <type> Technical Report IBM research Report RC-20286, </type> <institution> IBM T.J. Watson Research Center, </institution> <month> November </month> <year> 1995. </year>
Reference-contexts: Our correlation analysis can be used in the inliner to give procedures that generate correlation a higher priority so that correlated branches can be removed after 11 inlining <ref> [6, 8] </ref>. Our restructuring algorithm can be used to eliminate correlated branches after the code growth budget for inlining has been exhausted because its code growth demands are smaller than those of inlining. Richardson and Ganapathi [23] observed that the benefit of inlining comes mainly from eliminated procedure call overhead.
Reference: [7] <author> Keith D. Cooper and Ken Kennedy. </author> <title> Interprocedural side-effect analysis in linear time. </title> <journal> SIGPLAN Notices, </journal> <volume> 23(7) </volume> <pages> 57-66, </pages> <month> July </month> <year> 1988. </year> <booktitle> Proceedings of the ACM SIG-PLAN '88 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: We implemented both an intraprocedural optimization, which used MOD and USE <ref> [7] </ref> procedure summary information at call sites, and the ICBE optimization that considered both intra- and interprocedural correlations. The analysis recognized two sources of correlation: constant assignments and conditional branches. Benchmarks. The experiments were performed on the integer SPEC95 suite.
Reference: [8] <author> Jack. W. Davidson and Anne. M. Holler. </author> <title> A study of a C function inliner. </title> <journal> Software, Practice and Experience, </journal> <volume> 18(8) </volume> <pages> 775-790, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Our correlation analysis can be used in the inliner to give procedures that generate correlation a higher priority so that correlated branches can be removed after 11 inlining <ref> [6, 8] </ref>. Our restructuring algorithm can be used to eliminate correlated branches after the code growth budget for inlining has been exhausted because its code growth demands are smaller than those of inlining. Richardson and Ganapathi [23] observed that the benefit of inlining comes mainly from eliminated procedure call overhead.
Reference: [9] <author> Evelyn Duesterwald, Rajiv Gupta, and Mary Lou Soffa. </author> <title> Demand-driven computation of interprocedural data flow. </title> <booktitle> In Conference Record of POPL '95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 37-48, </pages> <address> San Francisco, Cal-ifornia, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: We implemented the optimization and experimentally investigated the amount of interprocedural correlation detected and the benefits and costs of conditional branch elimination. Demand-driven interprocedural correlation analysis. Using the demand-driven data flow framework for distributed data flow problems <ref> [9] </ref>, we developed a demand-driven correlation detection analysis algorithm. The analysis is in-terprocedural and thus considers correlated paths spanning procedural boundaries, as well as correlations that occur within the same procedure. <p> Such a conditional has full correlation. The demand-driven framework of <ref> [9] </ref> computes procedure summary nodes on demand to improve the efficiency of interprocedural analysis.
Reference: [10] <author> Christopher W. Fraser and David R. Hanson. </author> <title> A retar-getable C compiler: design and implementation. </title> <address> Ben-jamin/Cummings, </address> <year> 1995. </year> <note> ISBN 0-8053-1670-1. </note>
Reference-contexts: We implemented the analysis and restructuring algorithms in our interprocedural compiler that is based on the retargetable compiler lcc described in <ref> [10] </ref>. Our implementation considered the correlation of those conditionals that compared a scalar variable (not a structure member) with a constant.
Reference: [11] <author> Rajiv Gupta. </author> <title> A fresh look at optimizing array bound checking. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 272-282, </pages> <month> June </month> <year> 1990. </year> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: As a result, other optimizations, such as procedure cloning, partial redundancy and dead code elimination, may be more effective following interprocedural restructuring. The ICBE optimization can be used to optimize array bounds checks <ref> [15, 11] </ref> which typically exhibit correlation. Finally, branch elimination can be used as a component of aggressive program transformations, such as slicing-based partial dead code elimination [4]. 6 Acknowledgement We want to thank Mooly Sagiv for his help with preparing the final version of this paper.
Reference: [12] <author> Richard E. Hank, Wen-mei W. Hwu, and B. Ramakr-ishna Rau. </author> <title> Region-based compilation: An introduction and motivation. </title> <booktitle> In 28th Annual IEEE/ACM International Symposium on Microarchitecture, </booktitle> <address> Ann Arbor, Michigan, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Such a solution to ICBE may be desirable in an existing compiler where inlining and intraprocedural branch elimination are already supported. The code growth of post-analysis inlin-ing may be further lowered by performing full ICBE (with interprocedural restructuring), followed by partial inlining <ref> [12] </ref>, in which only frequently executed paths through the optimized procedure are inlined. However, inlining of recursive, virtual, or library procedures may not be feasible. In this case, our interprocedural restructuring can be applied to carry out ICBE.
Reference: [13] <author> William Johnson. </author> <title> Superscalar Microprocessor Design. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year> <note> ISBN 0-13-875634-1. </note>
Reference-contexts: With increasing processor parallelism, branch density in the stream of instructions is becoming critical because expensive mechanisms are required to predict and issue multiple conditional branches in a single cycle <ref> [13] </ref>. Our experiments have shown that between 3% and 18% of executed conditionals can be eliminated by ICBE, reducing branch density. A mispredicted branch stalls the processor for many cycles and pollutes the instruction cache.
Reference: [14] <author> Jens Knoop, Oliver Ruthing, and Bernhard Steffen. </author> <title> Lazy code motion. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(7) </volume> <pages> 224-234, </pages> <month> July </month> <year> 1992. </year> <booktitle> Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: These procedures often perform correlated tests on the propagated values. With our optimization, the repeated testing can be eliminated. Conditional branch elimination is a form of partial redundancy elimination (PRE). However, the code motion techniques useful for PRE of assignments <ref> [14, 5] </ref> do not suffice for removing conditional branches. To eliminate a conditional, the control flow graph must be restructured in order to separate the correlated path from the rest of the paths [19].
Reference: [15] <author> Priyadarshan Kolte and Michael Wolfe. </author> <title> Elimination of redundant array subscript range checks. </title> <journal> SIGPLAN Notices, </journal> <volume> 30(6) </volume> <pages> 270-278, </pages> <month> June </month> <year> 1995. </year> <booktitle> Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: As a result, other optimizations, such as procedure cloning, partial redundancy and dead code elimination, may be more effective following interprocedural restructuring. The ICBE optimization can be used to optimize array bounds checks <ref> [15, 11] </ref> which typically exhibit correlation. Finally, branch elimination can be used as a component of aggressive program transformations, such as slicing-based partial dead code elimination [4]. 6 Acknowledgement We want to thank Mooly Sagiv for his help with preparing the final version of this paper.
Reference: [16] <author> Andreas Krall. </author> <title> Improving semi-static branch prediction by code replication. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 97-106, </pages> <month> June </month> <year> 1994. </year> <booktitle> Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: 1 Introduction Recent research in branch prediction <ref> [16, 24, 25] </ref>, profiling [3], and the elimination of conditional branches [19] has reported the existence of significant amounts of correlation among conditional branches, presenting opportunities for optimizations. <p> In addition, in our technique, the analysis cost and the code growth incurred due to program restructuring can be controlled. Mueller and Whalley [18] also investigated avoiding unconditional jumps by code replication. Krall <ref> [16] </ref> developed code replication techniques to improve the accuracy of semi-static branch prediction to the accuracy of dynamic prediction. This paper is organized as follows. The next section presents an example to motivate the technique and gives the overview of ICBE.
Reference: [17] <author> Daniel M. Lavery and Wen-mei W. Hwu. </author> <title> Modulo scheduling of loops in control-intensive non-numeric programs. </title> <booktitle> In Proceedings of the 29th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 126-137, </pages> <address> Paris, France, </address> <month> December 2-4, </month> <year> 1996. </year>
Reference-contexts: Nevertheless, the test is correlated with the conditional that tests the return value in the caller. Optimization of unpredictable branches has an especially high payoff. ICBE can also be used to improve the effectiveness of software pipelining <ref> [17, 22] </ref> by reducing the number of conditionals and other statements in the loop body, as illustrated by the example in Figure 2. Elimination of branches can significantly speed-up the loop schedule when conditionals that form recurrent cycles of control dependencies are eliminated.
Reference: [18] <author> Frank Mueller and David B. Whalley. </author> <title> Avoiding unconditional jumps by code replication. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(7) </volume> <pages> 322-330, </pages> <month> July </month> <year> 1992. </year> <booktitle> Proceedings of the ACM SIG-PLAN '92 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: In addition, in our technique, the analysis cost and the code growth incurred due to program restructuring can be controlled. Mueller and Whalley <ref> [18] </ref> also investigated avoiding unconditional jumps by code replication. Krall [16] developed code replication techniques to improve the accuracy of semi-static branch prediction to the accuracy of dynamic prediction. This paper is organized as follows.
Reference: [19] <author> Frank Mueller and David B. Whalley. </author> <title> Avoiding conditional branches by code replication. </title> <journal> SIGPLAN Notices, </journal> <volume> 30(6) </volume> <pages> 56-66, </pages> <month> June </month> <year> 1995. </year> <booktitle> Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: 1 Introduction Recent research in branch prediction [16, 24, 25], profiling [3], and the elimination of conditional branches <ref> [19] </ref> has reported the existence of significant amounts of correlation among conditional branches, presenting opportunities for optimizations. <p> Elimination of conditional branches has a number of benefits, which are discussed in Section 5, including * enhancing instruction scheduling and software pipelin ing, * improving speculative execution and hardware branch prediction, and * optimizing C++/Java virtual functions. Previous work on conditional branch elimination through static correlation <ref> [19] </ref> demonstrated substantial performance improvements despite its restricted focus on eliminating conditionals within loops. Experimentally, we show that substantially more static correlation is detected at compile time when programs are analyzed interprocedurally. <p> However, the code motion techniques useful for PRE of assignments [14, 5] do not suffice for removing conditional branches. To eliminate a conditional, the control flow graph must be restructured in order to separate the correlated path from the rest of the paths <ref> [19] </ref>. After code replication isolates the correlated path, the conditional on this path becomes fully redundant and can be removed. Procedures are traditionally viewed as inherently single-entry/single-exit regions of code which means that all paths through the procedure must pass through the unique entry and exit points. <p> After exit splitting, additional return addresses may need to be passed during a procedure call. Within the scope of a procedure, our restructuring algorithm is similar to that of Mueller and Whalley <ref> [19] </ref>, except that our restructuring techniques takes advantage of correlation that spans nested loops. Our algorithm is able to create two versions of a loop, one for each known outcome of the conditional, enabling the elimination of the conditional in each loop version. Experimental evaluation. <p> We show that for the same code growth, ICBE removes significantly more executed conditional branches than what is possible with the intraproce-dural conditional branch elimination optimization. Intraprocedural elimination of conditional branches in loops was developed by Mueller and Whalley <ref> [19] </ref>. We extend their technique in several respects. First, we can detect and eliminate partial redundancy of branches in loop nests and across procedure boundaries. <p> The resulting exit splitting of fillbuf enables the complete elimination of conditional P0, shown in Figure 1 (c). In the original loop, during each loop iteration five conditional branches are executed. After the optimization, only one conditional remains. This optimization cannot be carried out by intraprocedural branch elimination <ref> [19] </ref>. The overhead of the optimization is passing two return addresses to fgetc. However, the additional instructions related to argument passing can be freely scheduled ahead of the procedure call because they have no incoming data dependencies. <p> Intraprocedural Restructuring. Restructuring, when the correlation is not affected by a procedure call or return, is similar to that proposed by Mueller and Whalley <ref> [19] </ref> except that we handle correlations that cut across loop iterations. Restructuring proceeds in the forward direction starting from each node that hosts multiple answers to a query and at least on one of its predecessors hosts only a single answer. <p> In this section we discuss how both the correlation analysis and the interprocedural restructuring can be applied in other areas of compiler optimization. Procedure inlining. Most interprocedurally-visible opportunities for branch elimination can be exploited by inlin-ing and subsequent application of intraprocedural elimination of conditionals <ref> [19] </ref>. However, without the knowledge of correlated paths in the call graph, the pre-pass inlining process must resort to exhaustive inlining, at least in the critical program regions.
Reference: [20] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise concrete type inference for object-oriented languages. </title> <journal> OOP-SLA'94, ACM SIGPLAN Notices, </journal> <volume> 29(10) </volume> <pages> 324-335, </pages> <year> 1994. </year>
Reference-contexts: Since such call sites require expensive dynamic dispatching, methods for their elimination through concrete type inference have been developed <ref> [1, 20, 21] </ref>. In these methods, demand-driven interprocedural analysis determines for each call site the set of "reaching concrete types." Subsequent program restructuring separates out paths and clones procedures with the goal of creating call sites reached by a single type of the receiver.
Reference: [21] <author> John Plevyak and Andrew A. Chien. </author> <title> Type directed cloning for object-oriented programs. </title> <booktitle> In Eighth Annual Workshop on Languages and Compilers for Parallel Computing, Lecture Notes in Computer Science, </booktitle> <volume> volume 1033, </volume> <pages> pages 566-580, </pages> <address> Columbus, Ohio, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: Since such call sites require expensive dynamic dispatching, methods for their elimination through concrete type inference have been developed <ref> [1, 20, 21] </ref>. In these methods, demand-driven interprocedural analysis determines for each call site the set of "reaching concrete types." Subsequent program restructuring separates out paths and clones procedures with the goal of creating call sites reached by a single type of the receiver.
Reference: [22] <author> B. Ramakrishna Rau and C. D. Glaeser. </author> <title> Some scheduling techniques and an easily schedulable horizontal architecture for high performance scientific computing. </title> <booktitle> In Proc. 14th Annual Workshop on Microprogramming, </booktitle> <pages> pages 183-198, </pages> <year> 1981. </year>
Reference-contexts: Nevertheless, the test is correlated with the conditional that tests the return value in the caller. Optimization of unpredictable branches has an especially high payoff. ICBE can also be used to improve the effectiveness of software pipelining <ref> [17, 22] </ref> by reducing the number of conditionals and other statements in the loop body, as illustrated by the example in Figure 2. Elimination of branches can significantly speed-up the loop schedule when conditionals that form recurrent cycles of control dependencies are eliminated.
Reference: [23] <author> Stephen Richardson and Mahadevan Ganapathi. </author> <title> Inter-procedural analysis versus procedure integration. </title> <journal> Information Processing Letters, </journal> <volume> 32(3) </volume> <pages> 137-142, </pages> <year> 1989. </year>
Reference-contexts: Our restructuring algorithm can be used to eliminate correlated branches after the code growth budget for inlining has been exhausted because its code growth demands are smaller than those of inlining. Richardson and Ganapathi <ref> [23] </ref> observed that the benefit of inlining comes mainly from eliminated procedure call overhead. Our analysis is able to identify procedures whose inlining will create intraprocedural optimization opportunities for branch removal. Dynamic dispatching of virtual procedures.
Reference: [24] <author> Stuart Sechrest, Chih-Chieh Lee, and Trevor Mudge. </author> <title> Correlation and aliasing in dynamic branch predictors. </title> <booktitle> In Proceedings of the 23rd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 22-32, </pages> <address> Philadel-phia, Pennsylvania, </address> <month> May 22-24, </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Recent research in branch prediction <ref> [16, 24, 25] </ref>, profiling [3], and the elimination of conditional branches [19] has reported the existence of significant amounts of correlation among conditional branches, presenting opportunities for optimizations. <p> Branches testing a flag whose value is assigned within the loop are examples of such conditionals. Assisting hardware branch prediction. Run-time prediction schemes have been proposed that predict the outcome of a branch using its correlation with the last k branches <ref> [24] </ref>. Since the exact source of the correlation is not known, all k outcomes are maintained and used for prediction, slowing down the learning process of the predictor.
Reference: [25] <author> Cliff Young, Nicolas Gloy, and Michael D. Smith. </author> <title> A comparative analysis of schemes for correlated branch prediction. </title> <booktitle> In Intl. Symposium on Computer Architecture, </booktitle> <address> Italy, </address> <year> 1995. </year> <month> 13 </month>
Reference-contexts: 1 Introduction Recent research in branch prediction <ref> [16, 24, 25] </ref>, profiling [3], and the elimination of conditional branches [19] has reported the existence of significant amounts of correlation among conditional branches, presenting opportunities for optimizations. <p> Our experiments have shown that between 3% and 18% of executed conditionals can be eliminated by ICBE, reducing branch density. A mispredicted branch stalls the processor for many cycles and pollutes the instruction cache. Research in correlation-based hardware branch prediction <ref> [25] </ref> shows that unpredictable branches exhibit correlation with earlier branches. Some unpredictable branches can arguably be eliminated by ICBE. Consider, for example, a procedure that removes an element from a linked list. When the average list length is low, the conditional that tests for an empty list is unpredictable.
References-found: 25

