URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR507.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: sbalasub@cs.indiana.edu  pierce@cs.indiana.edu  
Title: What is a File Synchronizer?  
Author: S. Balasubramaniam Benjamin C. Pierce 
Date: April 22, 1998  
Affiliation: Indiana University  Indiana University  Indiana University  
Pubnum: CSCI Technical Report #507  
Abstract: Mobile computing devices intended for disconnected operation, such as laptops and personal organizers, must employ optimistic replication strategies for user files. Unlike traditional distributed systems, such devices do not attempt to present a "single filesystem" semantics: users are aware that their filesystems are replicated, and that updates to one replica will not be seen in another until some point of synchronization is reached (often under the user's explicit control). A variety of tools, collectively called file synchronizers, support this mode of operation. Unfortunately, present-day synchronizers seldom give the user enough information to predict how they will behave under all circumstances. Simple slogans like "Non-conflicting updates are propagated to other replicas" ignore numerous subtleties|e.g., Precisely what constitutes a conflict between updates in different replicas? What does the synchronizer do if updates conflict? What happens when files are renamed? What if the directory structure is reorganized in one replica? Our goal is to offer a simple, concrete, and precise framework for describing the behavior of file synchronizers. To this end, we divide the synchronization task into two conceptually distinct phases: update detection and reconciliation. We discuss each phase in detail and develop a straightforward specification of each. We sketch our own prototype implementation of these specifications and discuss how they apply to some existing synchronization tools.
Abstract-found: 1
Intro-found: 1
Reference: [Bri98] <institution> Microsoft Windows 95: Vision for mobile computing, </institution> <year> 1998. </year> <note> http://www.microsoft.com/ windows95/info/w95mobile.htm. </note>
Reference-contexts: We do not attempt to provide a complete survey, just a few representative examples. 6.1 Briefcase Microsoft's Briefcase synchronizer <ref> [Bri98, Sch96] </ref> is part of Windows 95/NT. Its fundamental goals seem to match those embodied in our specification ("propagate updates unless they conflict, in which case do nothing by default")|indeed, even its user interface is fairly similar to ours.
Reference: [Dav84] <author> S. B. Davidson. </author> <title> Optimism and consistency in partitioned distributed databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(3), </volume> <month> Sep. </month> <year> 1984. </year>
Reference-contexts: Related concepts also have a long history in distributed databases (e.g., <ref> [Dav84] </ref>). These systems differ from user-level file synchronizers|and from each other|along numerous dimensions, such as continuous reconciliation vs. discrete points of synchronization, distinguishing or not between client and server machines, eager vs. lazy reconciliation, use of transaction logs vs. immediate update propagation, etc. <p> This line of research has long been pursued in distributed database systems <ref> [Dav84] </ref>) and has resulted in products like Oracle's Symmetric Replication [DDD + 94].
Reference: [DDD + 94] <author> D. Daniels, L. B. Doo, A. Downing, C. Elsbernd, G. Hallmark, S. Jain, Bob Jenkins, P. Lim, G. Smith, B. Souder, and J. Stamos. </author> <title> Oracle's symmetric replication technology and implications for application design. </title> <booktitle> In Proceedings of SIGMOD Conference, </booktitle> <year> 1994. </year>
Reference-contexts: Indeed, these issues are closely related to replication and synchronization (while recovering from a partition) in mainstream distributed systems [DGMS85, Kis96, GPJ93, DPS + 94, etc.]. Ultimately, we hope to extend our specification to encompass a wider range of replication mechanisms, from data synchronizers <ref> [Puma, DDD + 94, etc.] </ref> to those of distributed filesystems and databases. In our model a file synchronizer is invoked explicitly by an action of the user (issuing a synchronization command, dropping a PDA into a docking cradle, etc.). <p> This line of research has long been pursued in distributed database systems [Dav84]) and has resulted in products like Oracle's Symmetric Replication <ref> [DDD + 94] </ref>.
Reference: [DGMS85] <author> S. B. Davidson, H. Garcia-Molina, and D. Skeen. </author> <title> Consistency in partitioned networks. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(3), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: But some of the fundamental issues raised here are relevant for 1 both file and data synchronization. Indeed, these issues are closely related to replication and synchronization (while recovering from a partition) in mainstream distributed systems <ref> [DGMS85, Kis96, GPJ93, DPS + 94, etc.] </ref>. Ultimately, we hope to extend our specification to encompass a wider range of replication mechanisms, from data synchronizers [Puma, DDD + 94, etc.] to those of distributed filesystems and databases.
Reference: [DPS + 94] <author> Alan Demers, Karin Petersen, Mike Spreitzer, Douglas Terry, Marvin Theimer, and Brent Welch. </author> <title> The Bayou architecture: Support for data sharing among mobile users. </title> <booktitle> In Proceedings of the Workshop on Mobile Computing Systems and Applications, </booktitle> <address> Santa Cruz, California, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: But some of the fundamental issues raised here are relevant for 1 both file and data synchronization. Indeed, these issues are closely related to replication and synchronization (while recovering from a partition) in mainstream distributed systems <ref> [DGMS85, Kis96, GPJ93, DPS + 94, etc.] </ref>. Ultimately, we hope to extend our specification to encompass a wider range of replication mechanisms, from data synchronizers [Puma, DDD + 94, etc.] to those of distributed filesystems and databases. <p> conflict, even if they result in equal contents), and a recursive merge resolver for directories. 6.4 Distributed Filesystems Not surprisingly, our model of synchronization has some striking similarities to the replication models underlying mainstream distributed filesystems such as Coda [Kis96, Kum94], Ficus [RHR + 94, PJG + 97], and Bayou <ref> [DPS + 94, TTP + 95] </ref>. Related concepts also have a long history in distributed databases (e.g., [Dav84]).
Reference: [FM82] <author> Michael J. Fischer and Alan Michael. </author> <title> Sacrificing serializability to attain high availability of data in an unreliable network. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <month> March </month> <year> 1982. </year>
Reference-contexts: Suppose, instead, that the new filesystems A and B are obtained from O by adding a file in A and deleting one in B: This is an instance of the classic insert/delete ambiguity <ref> [FM82, GPJ93, PST + 97] </ref> faced by any synchronization mechanism: if the reconciler could see only the current states A and B, there would be no way for it to know that c had been added in A, as opposed to having been deleted from B (and having existed on both
Reference: [GPJ93] <author> R. G. Guy, G. J. Popek, and T. W. Page Jr. </author> <title> Consistency algorithms for optimisic replication. </title> <booktitle> In Proceedings of the First International Conference on Network Protocols, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: But some of the fundamental issues raised here are relevant for 1 both file and data synchronization. Indeed, these issues are closely related to replication and synchronization (while recovering from a partition) in mainstream distributed systems <ref> [DGMS85, Kis96, GPJ93, DPS + 94, etc.] </ref>. Ultimately, we hope to extend our specification to encompass a wider range of replication mechanisms, from data synchronizers [Puma, DDD + 94, etc.] to those of distributed filesystems and databases. <p> Suppose, instead, that the new filesystems A and B are obtained from O by adding a file in A and deleting one in B: This is an instance of the classic insert/delete ambiguity <ref> [FM82, GPJ93, PST + 97] </ref> faced by any synchronization mechanism: if the reconciler could see only the current states A and B, there would be no way for it to know that c had been added in A, as opposed to having been deleted from B (and having existed on both <p> Although its capabilities go beyond what our specification is presently able to describe, Rumor (nearly) satisfies our specification in the two-replica case. Rumor's model of synchronization originates from the Ficus replicated filesystem; much of our discussion regarding Rumor also applies to the synchronization mechanisms of Ficus <ref> [RPG + 96, RHR + 94, GPJ93] </ref>. In Rumor, reconciliation is performed by a local process in each replica, which works to ensure that the most recent updates to each file are eventually reflected in the local state of this replica.
Reference: [HH95] <author> L. B. Huston and P. Honeyman. </author> <title> Disconnected Operation for AFS. </title> <booktitle> In Proceedings of the USENIX Symposium on Mobile and Location Independent Computing, </booktitle> <month> Spring </month> <year> 1995. </year>
Reference-contexts: But this presupposes the ability to track arbitrary user actions that affect the filesystem and hence is a preferred strategy for distributed filesystems of various kinds, for instance, Coda [Kis96, Kum94], Ficus [RHR + 94, PJG + 97], Bayou [TTP + 95, PST + 97], and LittleWorks <ref> [HH95] </ref>. 4 Reconciliation We now turn our attention to the other major component of the synchronizer, the reconciler. We begin by developing a set of simple requirements that any implementation should satisfy (Section 4.1).
Reference: [Kis96] <author> James Jay Kistler. </author> <title> Disconnected Operation in a Distributed File System. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1996. </year>
Reference-contexts: But some of the fundamental issues raised here are relevant for 1 both file and data synchronization. Indeed, these issues are closely related to replication and synchronization (while recovering from a partition) in mainstream distributed systems <ref> [DGMS85, Kis96, GPJ93, DPS + 94, etc.] </ref>. Ultimately, we hope to extend our specification to encompass a wider range of replication mechanisms, from data synchronizers [Puma, DDD + 94, etc.] to those of distributed filesystems and databases. <p> But it will normally get close, and may be cheaper to implement than the exact detector. But this presupposes the ability to track arbitrary user actions that affect the filesystem and hence is a preferred strategy for distributed filesystems of various kinds, for instance, Coda <ref> [Kis96, Kum94] </ref>, Ficus [RHR + 94, PJG + 97], Bayou [TTP + 95, PST + 97], and LittleWorks [HH95]. 4 Reconciliation We now turn our attention to the other major component of the synchronizer, the reconciler. <p> considers updates to the same file in different replicas as a conflict, even if they result in equal contents), and a recursive merge resolver for directories. 6.4 Distributed Filesystems Not surprisingly, our model of synchronization has some striking similarities to the replication models underlying mainstream distributed filesystems such as Coda <ref> [Kis96, Kum94] </ref>, Ficus [RHR + 94, PJG + 97], and Bayou [DPS + 94, TTP + 95]. Related concepts also have a long history in distributed databases (e.g., [Dav84]).
Reference: [Kum94] <author> Puneet Kumar. </author> <title> Mitigating the effects of Optimistic Replication in a Distributed File System. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: But it will normally get close, and may be cheaper to implement than the exact detector. But this presupposes the ability to track arbitrary user actions that affect the filesystem and hence is a preferred strategy for distributed filesystems of various kinds, for instance, Coda <ref> [Kis96, Kum94] </ref>, Ficus [RHR + 94, PJG + 97], Bayou [TTP + 95, PST + 97], and LittleWorks [HH95]. 4 Reconciliation We now turn our attention to the other major component of the synchronizer, the reconciler. <p> considers updates to the same file in different replicas as a conflict, even if they result in equal contents), and a recursive merge resolver for directories. 6.4 Distributed Filesystems Not surprisingly, our model of synchronization has some striking similarities to the replication models underlying mainstream distributed filesystems such as Coda <ref> [Kis96, Kum94] </ref>, Ficus [RHR + 94, PJG + 97], and Bayou [DPS + 94, TTP + 95]. Related concepts also have a long history in distributed databases (e.g., [Dav84]). <p> Coda has a certification mechanism which ensures that reconciliation is safe to proceed. Kumar <ref> [Kum94, pages 58-61] </ref> proves that, if certification succeeds at all servers, then for each data item d, either (i) d is not modified in any partition, (ii) the final value of d in each partition is equal to the pre-partition value, or (iii) d is modified in exactly one partition.
Reference: [PJG + 97] <author> T. W. Page, Jr., R. G.. Guy, J. S. Heidemann, D. H. Ratner, P. L. Reiher, A. Goel, G. H. Kuenning, and G. Popek. </author> <title> Perspectives on optimistically replicated peer-to-peer filing. </title> <journal> Software Practice and Experience, </journal> <volume> 11(1), </volume> <month> December </month> <year> 1997. </year>
Reference-contexts: But it will normally get close, and may be cheaper to implement than the exact detector. But this presupposes the ability to track arbitrary user actions that affect the filesystem and hence is a preferred strategy for distributed filesystems of various kinds, for instance, Coda [Kis96, Kum94], Ficus <ref> [RHR + 94, PJG + 97] </ref>, Bayou [TTP + 95, PST + 97], and LittleWorks [HH95]. 4 Reconciliation We now turn our attention to the other major component of the synchronizer, the reconciler. We begin by developing a set of simple requirements that any implementation should satisfy (Section 4.1). <p> the same file in different replicas as a conflict, even if they result in equal contents), and a recursive merge resolver for directories. 6.4 Distributed Filesystems Not surprisingly, our model of synchronization has some striking similarities to the replication models underlying mainstream distributed filesystems such as Coda [Kis96, Kum94], Ficus <ref> [RHR + 94, PJG + 97] </ref>, and Bayou [DPS + 94, TTP + 95]. Related concepts also have a long history in distributed databases (e.g., [Dav84]).
Reference: [Pow98] <institution> PowerMerge software (Leader Technologies), </institution> <year> 1998. </year> <note> http://www.leadertech.com/merge.htm. </note>
Reference-contexts: This would appear to be a case of a system having been built without a clear specification in mind. The effect is that users are discouraged from trusting the system, since they cannot understand its behavior. 6.2 PowerMerge According to the manufacturer's advertising <ref> [Pow98] </ref>, the PowerMerge synchronizer from Leader Technologies is "used by virtually every large Macintosh organization and is the highest rated file synchronization program on the market today." We tested the "light" version of the program, which is freely downloadable for evaluation.
Reference: [PST + 97] <author> Karin Petersen, Mike J. Spreitzer, Douglas B. Terry, Marvin M. Theimer, and Alan J. Demers. </author> <title> Flexible update propagation for weakly consistent replication. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Operating SystemsPrinciples (SOSP-16), </booktitle> <address> Saint Malo, France, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: But this presupposes the ability to track arbitrary user actions that affect the filesystem and hence is a preferred strategy for distributed filesystems of various kinds, for instance, Coda [Kis96, Kum94], Ficus [RHR + 94, PJG + 97], Bayou <ref> [TTP + 95, PST + 97] </ref>, and LittleWorks [HH95]. 4 Reconciliation We now turn our attention to the other major component of the synchronizer, the reconciler. We begin by developing a set of simple requirements that any implementation should satisfy (Section 4.1). <p> Suppose, instead, that the new filesystems A and B are obtained from O by adding a file in A and deleting one in B: This is an instance of the classic insert/delete ambiguity <ref> [FM82, GPJ93, PST + 97] </ref> faced by any synchronization mechanism: if the reconciler could see only the current states A and B, there would be no way for it to know that c had been added in A, as opposed to having been deleted from B (and having existed on both
Reference: [Puma] <institution> Designing effective synchronization solutions: </institution> <note> A White Paper on Synchronization from Puma Technology. http://www.pumatech.com/syncwp.html. </note>
Reference-contexts: Indeed, these issues are closely related to replication and synchronization (while recovering from a partition) in mainstream distributed systems [DGMS85, Kis96, GPJ93, DPS + 94, etc.]. Ultimately, we hope to extend our specification to encompass a wider range of replication mechanisms, from data synchronizers <ref> [Puma, DDD + 94, etc.] </ref> to those of distributed filesystems and databases. In our model a file synchronizer is invoked explicitly by an action of the user (issuing a synchronization command, dropping a PDA into a docking cradle, etc.). <p> To describe the intended behavior in this case, we would need to refine the above specification along the lines described in the previous subsection. 18 7.3 Synchronizing Within Files Much of the engineering effort in commercial synchronizers (see for instance Intellisync <ref> [Puma, Pumb] </ref>) goes into merging updates to the same file in different replicas using specific knowledge of the structure of the file based on its type (address book, calendar, etc.).
Reference: [Pumb] <institution> A white paper on DSX tm Technology Data Synchronization Extensions from Puma Technology. </institution> <note> http://www.pumatech.com/dsxwp.html. </note>
Reference-contexts: To describe the intended behavior in this case, we would need to refine the above specification along the lines described in the previous subsection. 18 7.3 Synchronizing Within Files Much of the engineering effort in commercial synchronizers (see for instance Intellisync <ref> [Puma, Pumb] </ref>) goes into merging updates to the same file in different replicas using specific knowledge of the structure of the file based on its type (address book, calendar, etc.).
Reference: [Rei97] <author> Peter Reiher. </author> <note> Rumor 1.0 User's Manual., 1997. http://fmg-www.cs.ucla.edu/rumor. </note>
Reference-contexts: For example, deleting a file on one side and then resynchronizing would lead to the file being re-created, not 16 deleted. Also, when both copies of a file have been modified, the most recent copy is propagated, discarding the update in the other copy. 6.3 Rumor UCLA's Rumor project <ref> [Rei97, RPG + 96] </ref> has built a user-level file synchronizer for Unix filesystems| probably the closest cousin to our own implementation. Although its capabilities go beyond what our specification is presently able to describe, Rumor (nearly) satisfies our specification in the two-replica case.
Reference: [RHR + 94] <author> P. Reiher, J. S. Heidemann, D. Ratner, G. Skinner, and G. J. Popek. </author> <title> Resolving file conflicts in the Ficus file system. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: But it will normally get close, and may be cheaper to implement than the exact detector. But this presupposes the ability to track arbitrary user actions that affect the filesystem and hence is a preferred strategy for distributed filesystems of various kinds, for instance, Coda [Kis96, Kum94], Ficus <ref> [RHR + 94, PJG + 97] </ref>, Bayou [TTP + 95, PST + 97], and LittleWorks [HH95]. 4 Reconciliation We now turn our attention to the other major component of the synchronizer, the reconciler. We begin by developing a set of simple requirements that any implementation should satisfy (Section 4.1). <p> Although its capabilities go beyond what our specification is presently able to describe, Rumor (nearly) satisfies our specification in the two-replica case. Rumor's model of synchronization originates from the Ficus replicated filesystem; much of our discussion regarding Rumor also applies to the synchronization mechanisms of Ficus <ref> [RPG + 96, RHR + 94, GPJ93] </ref>. In Rumor, reconciliation is performed by a local process in each replica, which works to ensure that the most recent updates to each file are eventually reflected in the local state of this replica. <p> the same file in different replicas as a conflict, even if they result in equal contents), and a recursive merge resolver for directories. 6.4 Distributed Filesystems Not surprisingly, our model of synchronization has some striking similarities to the replication models underlying mainstream distributed filesystems such as Coda [Kis96, Kum94], Ficus <ref> [RHR + 94, PJG + 97] </ref>, and Bayou [DPS + 94, TTP + 95]. Related concepts also have a long history in distributed databases (e.g., [Dav84]).
Reference: [RPG + 96] <author> P. Reiher, J. Popek, M. Gunter, J. Salomone, and D. Ratner. </author> <title> Peer-to-peer reconciliation based replication for mobile computers. </title> <booktitle> In European Conference on Object Oriented Programming '96 Second Workshop on Mobility and Replication, </booktitle> <month> June </month> <year> 1996. </year> <month> 20 </month>
Reference-contexts: For example, deleting a file on one side and then resynchronizing would lead to the file being re-created, not 16 deleted. Also, when both copies of a file have been modified, the most recent copy is propagated, discarding the update in the other copy. 6.3 Rumor UCLA's Rumor project <ref> [Rei97, RPG + 96] </ref> has built a user-level file synchronizer for Unix filesystems| probably the closest cousin to our own implementation. Although its capabilities go beyond what our specification is presently able to describe, Rumor (nearly) satisfies our specification in the two-replica case. <p> Although its capabilities go beyond what our specification is presently able to describe, Rumor (nearly) satisfies our specification in the two-replica case. Rumor's model of synchronization originates from the Ficus replicated filesystem; much of our discussion regarding Rumor also applies to the synchronization mechanisms of Ficus <ref> [RPG + 96, RHR + 94, GPJ93] </ref>. In Rumor, reconciliation is performed by a local process in each replica, which works to ensure that the most recent updates to each file are eventually reflected in the local state of this replica.
Reference: [Sch96] <author> Stu Schwartz. </author> <title> The Briefcase|in brief. Windows 95 Professional, </title> <month> May </month> <year> 1996. </year> <note> http:// www.cobb.com/w9p/9605/w9p9651.htm. </note>
Reference-contexts: We do not attempt to provide a complete survey, just a few representative examples. 6.1 Briefcase Microsoft's Briefcase synchronizer <ref> [Bri98, Sch96] </ref> is part of Windows 95/NT. Its fundamental goals seem to match those embodied in our specification ("propagate updates unless they conflict, in which case do nothing by default")|indeed, even its user interface is fairly similar to ours.
Reference: [TTP + 95] <author> Douglas B. Terry, Marvin M. Theimer, Karin Petersen, Alan J. Demers, Mike J. Spreitzer, and Carl H. Hauser. </author> <title> Managing update conflicts in Bayou, a weakly connected replicated storage system. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles (SOSP-15), </booktitle> <address> Copper Mountain Resort, Colorado, </address> <month> December </month> <year> 1995. </year> <month> 21 </month>
Reference-contexts: But this presupposes the ability to track arbitrary user actions that affect the filesystem and hence is a preferred strategy for distributed filesystems of various kinds, for instance, Coda [Kis96, Kum94], Ficus [RHR + 94, PJG + 97], Bayou <ref> [TTP + 95, PST + 97] </ref>, and LittleWorks [HH95]. 4 Reconciliation We now turn our attention to the other major component of the synchronizer, the reconciler. We begin by developing a set of simple requirements that any implementation should satisfy (Section 4.1). <p> conflict, even if they result in equal contents), and a recursive merge resolver for directories. 6.4 Distributed Filesystems Not surprisingly, our model of synchronization has some striking similarities to the replication models underlying mainstream distributed filesystems such as Coda [Kis96, Kum94], Ficus [RHR + 94, PJG + 97], and Bayou <ref> [DPS + 94, TTP + 95] </ref>. Related concepts also have a long history in distributed databases (e.g., [Dav84]).
References-found: 20

