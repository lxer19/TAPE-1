URL: http://www.daimi.aau.dk/~grobauer/MSc_thesis/master.ps.gz
Refering-URL: http://www.daimi.aau.dk/~grobauer/MSc_thesis/MSc_thesis.html
Root-URL: http://www.daimi.aau.dk
Title: A Verified Unification Algorithm for Higher-Order Patterns  
Author: Bernd Grobauer 
Date: Diplomarbeit  
Address: F UR INFORMATIK  
Affiliation: TECHNISCHE UNIVERSIT AT M UNCHEN FAKULT AT  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Henk Barendregt. </author> <title> The Lambda Calculus: its Syntax and Semantics. </title> <journal> North-Holland, </journal> <note> 1981 (1st ed) revised 84. </note>
Reference: [2] <author> Nachum Dershowitz and Jean-Pierre Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Methods and Semantics, chapter 6, </booktitle> <pages> pages 243-320. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference: [3] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference: [4] <author> David King and John Launchbury. </author> <title> Lazy depth-first search and linear graph algorithms in haskell. </title> <type> Technical report, </type> <institution> University of Glasgow, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: New variables are created by a function reading the parameter and calculating a new variable name. In the development of the algorithm there will be no explicit notation of this parameter (which is consistent with a monadic style of programming in Haskell (see for example <ref> [13, 4] </ref>), where such a parameter would be hidden in a state-monad). Often it suffices to consider in which context a new variable H was introduced: Obviously H is distinct from any variable already in use in that context.
Reference: [5] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <editor> In P. Schroeder-Heisler, editor, </editor> <booktitle> Extensions of Logic Programming, number 475 in LNCS, </booktitle> <pages> pages 253-281, </pages> <year> 1991. </year>
Reference: [6] <author> Tobias Nipkow. </author> <title> Higher-order critical pairs. </title> <editor> In G. Kahn, editor, </editor> <booktitle> Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 342-349, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference: [7] <author> Tobias Nipkow. </author> <title> Functional unification of higher-order patterns. </title> <booktitle> In Proceedings, Eighth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 64-74. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: f to the head of xxs if xxs is not empty. head ap f xxs = case xxs of j [] ! [] 9 Chapter 2 The unification algorithm | presentation and proof of correctness 2.1 The algorithm The following unification algorithm is a modification of the algorithm presented in <ref> [7] </ref>. 2.1.1 Reducing a single unification problem The function cases 1 will try to solve a single unification problem. It is used together with the functions otf j and tw. <p> The easiest (and probably least efficient) option is to use the isomorphisms between the two representations. Nipkow <ref> [7] </ref> uses a function called strip which gives access to the top-level functor-arguments form of a term in lterm b representation.
Reference: [8] <author> Tobias Nipkow. </author> <title> More Church-Rosser proofs (in Isabelle/HOL). </title> <editor> In M. A. McRobbie and J. K. Slaney, editors, </editor> <booktitle> Proceedings of the Thirteenth International Conference on Automated Deduction (CADE-96), volume 1104 of LNAI, </booktitle> <pages> pages 733-747, </pages> <address> Berlin, July 30 -August 3 1996. </address> <publisher> Springer. </publisher>
Reference-contexts: this case the few auxilliary functions based on lterm b representation would be adapted for lterm f 0 representation, thus avoiding transformations altogether. 52 Lambda terms Appendix A Lambda terms A.1 A theory of lambda terms The following theory about lambda terms is a modification of the theory presented in <ref> [8] </ref>. A.1.1 Datatypes, functions and relations The theory of lambda terms is based on the representation lterm b : datatype lterm b = BVar nat j Var nat j lterm b j lterm b @ lterm b fi-reduction For fi-reduction a notion of substitution of bound variables is needed.
Reference: [9] <author> Tobias Nipkow. </author> <title> Private communication. </title> <year> 1997. </year>
Reference-contexts: Like in the case of first order unification, this practice may lead to exponentially large representations of the substitution <ref> [9] </ref>. In order to avoid this, one tries to partially instantiate and fi-reduce a unification problem. The function devar will carry out such a partial substitution. After defining devar, two lemmas will clarify the relation between devar and full substitution.
Reference: [10] <author> Lawrence C. Paulson. </author> <title> Designing a theorem prover. </title> <editor> In S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 2, </volume> <pages> pages 415-475. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference: [11] <author> Lawrence C. Paulson. </author> <title> Isabelle: a generic theorem prover, </title> <booktitle> volume 828 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag Inc., </publisher> <address> New York, NY, USA, </address> <year> 1994. </year>
Reference: [12] <author> J. Peterson[editor], K. Hammond[editor], L. Augustsson, B. Boutel, W. Burton, J. Fasel, A. Gordon, J. Hughes, P. Hudak, T. Johnsson, M. Jones, S. Peyton Jones, A. Reid, and P. Wadler. </author> <title> Haskell 1.3, A non-strict, purely functional language. </title> <institution> Report YALEU / DCS / RR-1106, Department of Computer Science, Yale University, </institution> <month> May </month> <year> 1996. </year>

References-found: 12

