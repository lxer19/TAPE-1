URL: http://www.cc.gatech.edu/home/sumeerb/papers/live_dcs.ps.gz
Refering-URL: http://www.cs.gatech.edu/people/home/sumeerb/
Root-URL: 
Title: Flexible Batching and Consistency Mechanisms for Building Interactive Groupware Applications  
Author: Sumeer Bhola Bodhi Mukherjee Sri Doddapaneni Mustaque Ahamad 
Abstract: This paper presents our state sharing support for building object-oriented interactive groupware in wide-area distributed environments. We motivate and present an asynchronous model for updating replicated state, which supports atomicity of updates across multiple shared objects. Coupled with our flexible marshalling framework, this model allows existing application data-structure classes to be easily extended and made shareable. To solve the problem of replica consistency we use a novel combination of three mechanisms, (1) global locks, (2) detection of incorrect update ordering, and (3) cloning a subset of the shared objects and state reinitialization. Finally, to reduce network load due to fine-grain user interaction, we provide a framework for application specified event batching called Late Event Modification. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bamba. </author> <note> www.alphaworks.ibm.com/Bamba. </note>
Reference-contexts: This work was done in the context of the VILLA project whose goal is to provide a framework for building complex object-oriented interactive groupware. The current prototype is implemented in Java and provides state sharing, event sharing and realtime audio and video support (using the Bamba <ref> [1] </ref> system). The authentication and access control framework can support implementation of electronic commerce applications like collaborative banking. It provides highlevel collaboration establishment metaphors like Rooms, and can run both inside a web browser (as an applet) and as a standalone application.
Reference: [2] <institution> Java Remote Method Invocation. java.sun.com/ products/jdk/rmi/index.html. </institution>
Reference-contexts: The two facets of such systems that are important to us are (1) the programming model, and (2) the algorithms used for state consistency or message ordering. Java RMI <ref> [2] </ref> provides transparent invocation of remote objects using local proxies. This is similar to the CORBA [6] invocation model. Though the basic RMI and CORBA specifications do not deal with replication, they can be extended to deal with replicated objects in a transparent manner [8].
Reference: [3] <author> Kenneth Birman, Andre Schiper, and Pat Stephen-son. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3):272 314, </volume> <month> August </month> <year> 1991. </year>
Reference-contexts: Also, as most collaborations happen between a small group of people, scalability is not a major issue. By using replicated servers and reliable group communication algorithms utilizing virtual synchrony <ref> [3] </ref>, fault-tolerance can be provided.
Reference: [4] <author> C. A. Ellis and S. J. Gibbs. </author> <title> Concurrency control in groupware systems. </title> <booktitle> In Proceedings of the ACM SIG-MOD'89, </booktitle> <pages> pages 399407, </pages> <year> 1989. </year>
Reference-contexts: Each replica of a shared object has a proxy object which is used to capture method invocations. Shared objects can have references to other shared objects through these proxies. An invocation on a shared object can invoke other shared objects, and consistency is maintained using pessimistic locking. Grove <ref> [4] </ref>, ORESTE [7], COAST [11] and DECAF [12] use optimistic concurrency control with system guaranteed state consistency. The ORESTE algorithm considers a shared document consisting of a set of objects, which are fully replicated at all the participating processes. Each event modifies exactly one shared object.
Reference: [5] <author> Saul Greenberg and David Marwood. </author> <title> Real time groupware as a distributed system: Concurrency control and its effect on the interface. </title> <type> Technical Report 94/534/03, </type> <institution> Department of Computer Science, University of Calgary, Calgary, Alberta, Canada, </institution> <year> 1994. </year>
Reference-contexts: The second approach has the problem of not allowing enough freedom of interaction. It has been observed that strict locking is usually not necessary for collaborative applications because of implicit social protocols <ref> [5] </ref> employed by collaborating users.
Reference: [6] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification. </title> <editor> 2.0 ed., </editor> <year> 1995. </year>
Reference-contexts: The two facets of such systems that are important to us are (1) the programming model, and (2) the algorithms used for state consistency or message ordering. Java RMI [2] provides transparent invocation of remote objects using local proxies. This is similar to the CORBA <ref> [6] </ref> invocation model. Though the basic RMI and CORBA specifications do not deal with replication, they can be extended to deal with replicated objects in a transparent manner [8].
Reference: [7] <author> Alain Karsenty and Michel Beaudouin-Lafon. </author> <title> An algorithm for distributed groupware applications. </title> <booktitle> In Proceedings of the 13th ICDCS, </booktitle> <pages> pages 195202, </pages> <year> 1993. </year>
Reference-contexts: Shared objects can have references to other shared objects through these proxies. An invocation on a shared object can invoke other shared objects, and consistency is maintained using pessimistic locking. Grove [4], ORESTE <ref> [7] </ref>, COAST [11] and DECAF [12] use optimistic concurrency control with system guaranteed state consistency. The ORESTE algorithm considers a shared document consisting of a set of objects, which are fully replicated at all the participating processes. Each event modifies exactly one shared object.
Reference: [8] <author> R. Kordale, M. Ahamad, and M. Devarakonda. </author> <title> Object caching in a corba compliant system. </title> <journal> USENIX Computing Systems Journal, </journal> <volume> 9(4), </volume> <year> 1996. </year>
Reference-contexts: Java RMI [2] provides transparent invocation of remote objects using local proxies. This is similar to the CORBA [6] invocation model. Though the basic RMI and CORBA specifications do not deal with replication, they can be extended to deal with replicated objects in a transparent manner <ref> [8] </ref>. The advantage of such an approach is that it hides most of the complexity of dealing with replicated objects, by preserving the synchronous invocation mechanism used for most applications.
Reference: [9] <author> Bodhi Mukherjee, Sumeer Bhola, and Sri Doddapa-neni. Villa: </author> <title> An event based middleware for real-time collaboration on the internet. </title> <booktitle> In Proceedings of the Fourth IEEE International Workshop on Community Networking, </booktitle> <year> 1997. </year>
Reference-contexts: After users fix the errors, reinitialization is done of the single object in error. Secondly, it can use the atomicity property of update events, to translate a group of objects. 7 Implementation Our current implementation <ref> [9] </ref> uses a central server (for a given collaborative session), and client processes logically arranged in a star configuration. Both the server and the clients are implemented in Java.
Reference: [10] <author> Atul Prakash and Hyong Sop Shim. Distview: </author> <title> Support for building efficient collaborative applications using replicated objects. </title> <booktitle> In Proceedings of the 5th CSCW, </booktitle> <year> 1994. </year>
Reference-contexts: However it does not permit changes in the concurrency control policy without effecting the invocation response time, and it does not allow atomic updates across a group of objects. DistView <ref> [10] </ref> provides support for object replication while permitting some objects to choose not to be replicated. Each replica of a shared object has a proxy object which is used to capture method invocations. Shared objects can have references to other shared objects through these proxies.
Reference: [11] <author> Christian Schuckmann, Lutz Kirchner, Jan Schum-mer, and Jorg M. Haake. </author> <title> Designing object-oriented synchronous groupware with COAST. </title> <booktitle> In ACM CSCW'96, </booktitle> <year> 1996. </year>
Reference-contexts: Shared objects can have references to other shared objects through these proxies. An invocation on a shared object can invoke other shared objects, and consistency is maintained using pessimistic locking. Grove [4], ORESTE [7], COAST <ref> [11] </ref> and DECAF [12] use optimistic concurrency control with system guaranteed state consistency. The ORESTE algorithm considers a shared document consisting of a set of objects, which are fully replicated at all the participating processes. Each event modifies exactly one shared object.
Reference: [12] <author> Robert Strom, Guruduth Banavar, Kevan Miller, Atul Prakash, and Michael Ward. </author> <title> Concurrency control and view notification algorithms for collaborative replicated objects. </title> <booktitle> In Proceedings of the 17th ICDCS, </booktitle> <year> 1997. </year>
Reference-contexts: Shared objects can have references to other shared objects through these proxies. An invocation on a shared object can invoke other shared objects, and consistency is maintained using pessimistic locking. Grove [4], ORESTE [7], COAST [11] and DECAF <ref> [12] </ref> use optimistic concurrency control with system guaranteed state consistency. The ORESTE algorithm considers a shared document consisting of a set of objects, which are fully replicated at all the participating processes. Each event modifies exactly one shared object.
References-found: 12

