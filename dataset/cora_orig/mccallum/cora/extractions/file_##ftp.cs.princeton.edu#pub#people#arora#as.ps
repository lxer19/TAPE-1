URL: file://ftp.cs.princeton.edu/pub/people/arora/as.ps
Refering-URL: http://www.cs.princeton.edu/~arora/publist.html
Root-URL: http://www.cs.princeton.edu
Title: Probabilistic Checking of Proofs: A New Characterization of NP  
Author: Sanjeev Arora Shmuel Safra 
Keyword: categories and subject descriptors: F.1.2 (Modes of Computation); F.1.3 (Complexity Classes); F.2.1 (Numerical Algorithms); F.2.2 (Nonnumerical Algorithms); F.4.1 (Mathematical Logic).  
Abstract: We give a new characterization of NP: the class NP contains exactly those languages L for which membership proofs (a proof that an input x is in L) can be verified probabilistically in polynomial time using logarithmic number of random bits and by reading sub-logarithmic number of bits from the proof. We discuss implications of this characterization; specifically, we show that approximating Clique and Independent Set, even in a very weak sense, is NP-hard. 
Abstract-found: 1
Intro-found: 1
Reference: [AKS87] <author> M. Ajtai, J. Komos, and E. Szemeredi. </author> <title> Deterministic simulation in logspace. </title> <booktitle> In Proc. 19th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 132-140, </pages> <year> 1987. </year>
Reference-contexts: Proof: We show that the hypothesis implies a polynomial-time algorithm for SAT. We use a reduction from PCP to clique described in [FGL + 91] (see Theorem 26 in the Appendix), and an error-amplification technique from <ref> [AKS87] </ref> (the idea of using this technique in the context of proof checking is from [Zuc91]). Since NP = PCP (log n; log 0:5+*=2 n), there is a (log n; log 0:5+*=2 n)-restricted verifier that checks membership proofs for SAT. The randomness-efficient error amplification in [AKS87] allows us to change the <p> and an error-amplification technique from <ref> [AKS87] </ref> (the idea of using this technique in the context of proof checking is from [Zuc91]). Since NP = PCP (log n; log 0:5+*=2 n), there is a (log n; log 0:5+*=2 n)-restricted verifier that checks membership proofs for SAT. The randomness-efficient error amplification in [AKS87] allows us to change the verifier into one that is (log n; log n)-restricted and has the following property. If x 2 SAT , there is a proof x that the verifier accepts with probability 1.
Reference: [AGHP92] <author> N. Alon, O. Goldreich, J. Hastad, R. Peralta. </author> <title> Simple constructions of almost k-wise independent random variables. </title> <booktitle> Random Structures and Algorithms, </booktitle> <pages> 3:3 pp 289-304. </pages> <year> 1992. </year>
Reference: [ABSS93] <author> S. Arora, L. Babai, J. Stern, and Z. Sweedyk. </author> <title> The hardness of approximate optima in lattices, codes and linear equations. </title> <booktitle> In Proc. 34th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 724-733, </pages> <year> 1993. </year>
Reference-contexts: Problems other than Clique and MAX-SNP problems have also been shown hard to approximate. These include Chromatic-Number and Set-Cover (Lund and Yannakakis [LY94]; see also [BGLR93, KLS93]) and problems on lattices, codes, and linear systems (Arora, Babai, Stern and Sweedyk <ref> [ABSS93] </ref>). Independently of these works, other hardness results for a variety of approximation problems were obtained by Bellare [Bel93], Bellare and Rogaway [BR93], and Zuckerman ([Zuc93]). We refer the reader to [AL96] for a survey. The NP-hardness result for approximating clique has been steadily improved.
Reference: [AL96] <author> S. Arora and C. Lund. </author> <title> Hardness of approximations. Chapter 10 in Approximation Algorithms for NP-hard Problems, </title> <editor> Dorit Hochbaum, editor. </editor> <publisher> PWS Publishing, </publisher> <year> 1996. </year>
Reference-contexts: Independently of these works, other hardness results for a variety of approximation problems were obtained by Bellare [Bel93], Bellare and Rogaway [BR93], and Zuckerman ([Zuc93]). We refer the reader to <ref> [AL96] </ref> for a survey. The NP-hardness result for approximating clique has been steadily improved. A consequence of NP = PCP (log n; 1) is that approximating clique number within a factor n * is NP-hard, for some fixed * &gt; 0.
Reference: [ALM + 92] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and intractability of approximation problems. </title> <booktitle> In Proc. 33rd IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 13-22, </pages> <year> 1992. </year>
Reference-contexts: Soon after the initial circulation of the draft of this paper, it was noticed [AMS + 92] that the techniques of this paper actually show NP = PCP (log n; (log log n) 2 ). Then Arora, Lund, Motwani, Sudan and Szegedy <ref> [ALM + 92] </ref> showed that NP PCP (log n; 1). (See Section 6.) Our new characterization of NP also allows us to prove the NP-hardness of approximating the clique problem, thus resolving an open question in [FGL + 91]. <p> more careful analysis of our composition technique and Theorem 6, it is possible to show that NP = PCP (log n; (log log n) 2 ): We omit this (very complicated) proof from this paper, since the result has been superseded by the result NP = PCP (log n; 1) <ref> [ALM + 92] </ref> anyway. 15 4 Proof of Theorem 6 In this section we prove Theorem 6. The proof is largely based upon that in [BFLS91, FGL + 91], with ingredients dating back to [LFKN92, BFL91]. <p> If jFj = (h 3 m 2 ), then f is 1=9-close. Note: This lemma has subsequently found important applications in the work of <ref> [ALM + 92] </ref>. The relevant case there is m = 2, for which simpler proofs have been found [Sud92, PS94]. Currently, our proof is the only one known for general m. <p> Our proof of Theorem 2 implies that NP is contained in this weaker subclass. Hence their reduction | a precursor of the reduction that later appears in <ref> [ALM + 92] </ref> | shows the hardness of approximating MAX-3SAT within a factor (1 + *), where * depends upon the decision time of the verifier in our result. <p> This reduction was reported in [AMS + 92], alongwith the result that approximating any MAX-SNP-complete problem to within a factor of 1 1 (log log n) O (1) is NP-hard. Shortly afterwards, it was shown in <ref> [ALM + 92] </ref> that NP = PCP (log n; 1). Note that this characterization of NP in terms of PCP is optimal up to constant factors if P 6= NP (see our remarks following Theorem 1). 39 The techniques of [ALM + 92] are similar to ours and rely heavily on <p> Shortly afterwards, it was shown in <ref> [ALM + 92] </ref> that NP = PCP (log n; 1). Note that this characterization of NP in terms of PCP is optimal up to constant factors if P 6= NP (see our remarks following Theorem 1). 39 The techniques of [ALM + 92] are similar to ours and rely heavily on our Composition Lemma (Lemma 5). <p> Another important idea is that of parallelization, introduced in the work of Lapidot and Shamir [LS91] and Feige and Lovasz [FL92]. The second step in <ref> [ALM + 92] </ref> is to compose the verifier of the first step with itself. This gives a verifier that reads O (1) entries from the proof, but now the entries are of size O (log log n). <p> This new verifier is inefficient in the number of random bits it uses (this number is polynomial in the proof size), but it queries only O (1) bits from the proof. The verifier obtained through the above composition is (log n; 1)-restricted. Since <ref> [ALM + 92] </ref> a sequence of papers [PS, BGLR93, BS94, BGS95, H96] have constructed more and more efficient (in terms of constant factors) (log n; 1)-restricted verifiers for SAT. <p> of our ideas from Section 4.4 regarding the "concatenation property" were useful in achieving some of this efficiency.) In a different direction, a recent paper [PS94] improves existing verifiers by reducing the size of the proof required by this verifier to n 1+* . (This had not been achieved in <ref> [ALM + 92] </ref> because of the huge field size required by our Lemma 16, which is crucial to [ALM + 92]. <p> In a different direction, a recent paper [PS94] improves existing verifiers by reducing the size of the proof required by this verifier to n 1+* . (This had not been achieved in <ref> [ALM + 92] </ref> because of the huge field size required by our Lemma 16, which is crucial to [ALM + 92].
Reference: [AMS + 92] <author> S. Arora, R. Motwani, M. Safra, M. Sudan, and M. Szegedy. </author> <title> PCP and approximation problems. </title> <type> Manuscript, </type> <year> 1992. </year>
Reference-contexts: Soon after the initial circulation of the draft of this paper, it was noticed <ref> [AMS + 92] </ref> that the techniques of this paper actually show NP = PCP (log n; (log log n) 2 ). <p> Further, this * becomes a constant if the decision time could be reduced to a constant (equivalently, when the number of query bits is constant). This reduction was reported in <ref> [AMS + 92] </ref>, alongwith the result that approximating any MAX-SNP-complete problem to within a factor of 1 1 (log log n) O (1) is NP-hard. Shortly afterwards, it was shown in [ALM + 92] that NP = PCP (log n; 1).
Reference: [AS92] <author> S. Arora and S. Safra. </author> <title> Probabilistic checking of proofs: A new characterization of NP. </title> <booktitle> In Proc. 33rd IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 2-12, </pages> <year> 1992. </year>
Reference-contexts: In all these cases, one might conjecture that approximation is NP-hard, but demonstrating this |even for very small factors| has proved difficult. The clique problem is a good example. The best polynomial-time algorithm fl A preliminary version of this paper <ref> [AS92] </ref> appeared in the Proceedings of the 33rd IEEE Foundations of Computer Science, pages 2-12, 1992. y This work was done while the author was at CS Division, UC Berkeley, under support from NSF PYI Grant CCR 8896202 and an IBM graduate fellowship. <p> Now we prove Theorem 2. Proof: (of Theorem 2) For any positive fraction *, we show that 3SAT has a (log n; log 0:5+* n)- restricted verifier. 5 This lemma is a fleshed-out version of the original lemma in <ref> [AS92] </ref>. The concept of a normal-form verifier was not made very explicit in that paper. 11 Let V 1 be the verifier whose existence is guaranteed in Theorem 6 when we choose h +1 = 2 log n , and m = O ( log n).
Reference: [ASu97] <author> S. Arora and M. Sudan. </author> <title> Improved low degree testing and its applications. </title> <booktitle> In Proc. 29th Annual ACM Symp. on Theory of Computing, </booktitle> <pages> pages 496-505, </pages> <year> 1997 </year>
Reference-contexts: The paper shows how to construct such verifiers for a log 1* n. It also generalizes our low degree test in an important way (see also <ref> [ASu97] </ref>). Problems other than Clique and MAX-SNP problems have also been shown hard to approximate. These include Chromatic-Number and Set-Cover (Lund and Yannakakis [LY94]; see also [BGLR93, KLS93]) and problems on lattices, codes, and linear systems (Arora, Babai, Stern and Sweedyk [ABSS93]).
Reference: [Bab85] <author> L. Babai. </author> <title> Trading group theory for randomness. </title> <booktitle> In Proc. 17th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 421-429, </pages> <year> 1985. </year>
Reference-contexts: Interactive Proofs The model of interactive proofs was introduced by Goldwasser, Micali and Rackoff [GMR89] for cryptographic applications, and by Babai <ref> [Bab85] </ref> as a game-theoretic extension of NP. The model consists of a probabilistic polynomial-time verifier V communicating with a prover P who tries to convince V that the input x is in a language L.
Reference: [Bel93] <author> M. Bellare. </author> <title> Interactive Proofs and approximation: Reductions from two provers in one round. </title> <booktitle> In Proceedings of the 2nd Israel Symposium on Theory and Computing Systems. </booktitle> <publisher> IEEE Computer Press, </publisher> <year> 1993. </year> <note> Preliminary version: IBM Research Report RC 17969 (May 1992). </note>
Reference-contexts: These include Chromatic-Number and Set-Cover (Lund and Yannakakis [LY94]; see also [BGLR93, KLS93]) and problems on lattices, codes, and linear systems (Arora, Babai, Stern and Sweedyk [ABSS93]). Independently of these works, other hardness results for a variety of approximation problems were obtained by Bellare <ref> [Bel93] </ref>, Bellare and Rogaway [BR93], and Zuckerman ([Zuc93]). We refer the reader to [AL96] for a survey. The NP-hardness result for approximating clique has been steadily improved.
Reference: [BFL91] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Non-deterministic exponential time has two-prover interactive protocols. </title> <journal> Computational Complexity, </journal> <volume> 1 </volume> <pages> 3-40, </pages> <year> 1991. </year> <note> (Preliminary version in Proc. 31st IEEE Symp. on Foundations of Computer Science, </note> <year> 1990.) </year>
Reference-contexts: It therefore came as a surprise when Lund, Fortnow, Karloff, and Nisan [LFKN92] and Shamir [Sha92] showed, using techniques developed for program checking [BK89, BLR90, Lip89], that that IP = PSPACE. (The class PSPACE is believed to be quite larger than NP and co-NP.) Shortly afterwards, Babai, Fortnow and Lund <ref> [BFL91] </ref> introduced even more powerful techniques to show that MIP = NEXPTIME. Note that NEXPTIME is the set of languages that can be decided by nondeterministic exponential-time Turing machines. <p> Note that NEXPTIME is the set of languages that can be decided by nondeterministic exponential-time Turing machines. Scaling Down MIP = NEXPTIME Since NEXPTIME can be characterized as the set of languages that have exponential-size membership proofs, the result MIP = NEXPTIME <ref> [BFL91] </ref>, combined with the oracle formulation of MIP [FRS88], shows that if a language has membership proofs of exponential size, then some probabilistic polynomial-time verifier can check those membership proofs. <p> This technique has played a pivotal role in all subsequent works in this area. Our starting point is the verifier of <ref> [BFL91] </ref> in its scaled-down form [BFLS91, FGL + 91]. This verifier, because of its reliance on a special error-correcting code, has certain strong properties, some of which were earlier noted in [BFLS91]. We will use such properties to compose verifiers. <p> The essential ingredients of this proof are the Composition Lemma (Lemma 5), which we will prove in this section, and Theorem 6, which we will prove in Section 4. As already mentioned, our starting point are the verifiers for 3SAT that were constructed in <ref> [BFL91, BFLS91, FGL + 91] </ref>. Now we mention some of their properties that will be of interest. 1) The proof can be viewed as a string over a non-binary alphabet. The verifier has an associated sequence of alphabets f n : n = 1; 2; 3; : : :g. <p> The proof is largely based upon that in [BFLS91, FGL + 91], with ingredients dating back to <ref> [LFKN92, BFL91] </ref>. The only new parts are our improved analysis of the low degree test, and our technique for showing that the verifier is in normal form (in particular, that it can check split-encoded assignments). Underlying the description of the verifier is an algebraic representation of a 3SAT formula. <p> The proof of Theorem 6 is split in two parts, which are proved in Sections 4.3 and Section 4.4. 4.2.1 Algebraic Representation of 3SAT In Lemma 9, we give an algebraic characterization of satisfying polynomials. This lemma is similar in spirit to a lemma in <ref> [BFL91] </ref>, although the precise formulation given here is due to [BFLS91].
Reference: [BFLS91] <author> L. Babai, L. Fortnow, L. Levin, and M. Szegedy. </author> <title> Checking computations in poly-logarithmic time. </title> <booktitle> In Proc. 23rd ACM Symp. on Theory of Computing, </booktitle> <pages> pages 21-31, </pages> <year> 1991. </year>
Reference-contexts: Note that membership proofs for NP have polynomial size, so a straightforward meaning of "scaling-down" would require the running time of the verifier to be polylogarithmic. But this cannot be, since the verifier must take linear time simply to read the input. Babai, Fortnow, Levin, and Szegedy <ref> [BFLS91] </ref> nevertheless obtained a scale-down result (including a scale-down in the running time of the verifier) by changing the model of computation: in the new model, the input has to be provided to the verifier in an encoded form using a specific error-correcting code. <p> The notion becomes even more intriguing in light of the possible trade-offs, hinted at in the results of <ref> [FGL + 91, BFLS91] </ref>, between the verifier's running time, random bits, and query bits. If these trade-offs can be improved, improved nonapproximability results for the clique problem follow, as we will soon see. <p> Lemma, our most important lemma, relies crucially on verifiers being nonadaptive. 5 M O (log n log log n) is sandwiched between NP and Ntime (n O (log log n) ). (We note that NP PCP (poly (log n); poly (log n)), a slightly weaker result, was also implicit in <ref> [BFLS91] </ref>.) 1.2.2 A New Characterization of NP and its Applications As mentioned above, NP = PCP (0; poly (n)). An interesting open question arising from the "sandwich" result implicit in [FGL + 91] was whether NP has an exact characterization in terms of PCP. Our main theorem settles this question. <p> This technique has played a pivotal role in all subsequent works in this area. Our starting point is the verifier of [BFL91] in its scaled-down form <ref> [BFLS91, FGL + 91] </ref>. This verifier, because of its reliance on a special error-correcting code, has certain strong properties, some of which were earlier noted in [BFLS91]. We will use such properties to compose verifiers. <p> Our starting point is the verifier of [BFL91] in its scaled-down form [BFLS91, FGL + 91]. This verifier, because of its reliance on a special error-correcting code, has certain strong properties, some of which were earlier noted in <ref> [BFLS91] </ref>. We will use such properties to compose verifiers. Composition 2 , when done correctly, improves efficiency (the resulting verifier reads very few bits from the proof). However, it requires that the verifiers have certain properties, and that one of the verifiers be in normal form. <p> We will later describe how to construct such verifiers. In addition to verifier composition, we also develop some other techniques to prove our main results. Chief among them is our improved analysis of the efficiency of the verifiers in <ref> [BFLS91, FGL + 91] </ref>, specifically, of a procedure called the low degree test. (This improved analysis becomes possible through our Lemma 16.) The rest of the paper is organized as follows. <p> The essential ingredients of this proof are the Composition Lemma (Lemma 5), which we will prove in this section, and Theorem 6, which we will prove in Section 4. As already mentioned, our starting point are the verifiers for 3SAT that were constructed in <ref> [BFL91, BFLS91, FGL + 91] </ref>. Now we mention some of their properties that will be of interest. 1) The proof can be viewed as a string over a non-binary alphabet. The verifier has an associated sequence of alphabets f n : n = 1; 2; 3; : : :g. <p> The formal definition below clarifies this.) Now we give a formal definition of "normal form verifiers." We slightly deviate from the rough sketch in that we define this notion using 3CNF formulae instead of circuits. We also remark at this point that the "encoded inputs" idea of <ref> [BFLS91] </ref> was a simpler version of this definition (specifically, they used p = 2 and didn't characterize the verifier using as many parameters). Definition 5 (Normal Form Verifiers.) Let functions r; s; q; t be defined on the positive integers. <p> The proof is largely based upon that in <ref> [BFLS91, FGL + 91] </ref>, with ingredients dating back to [LFKN92, BFL91]. The only new parts are our improved analysis of the low degree test, and our technique for showing that the verifier is in normal form (in particular, that it can check split-encoded assignments). <p> Polynomials are useful to us as encoding objects. We define below a canonical way (due to <ref> [BFLS91] </ref>) to encode a sequence of bits with a polynomial. For convenience, we describe a more general method that encodes a sequence of field elements with a polynomial. Encoding a sequence of bits is a sub-case of this method, since 0; 1 2 F. <p> This lemma is similar in spirit to a lemma in [BFL91], although the precise formulation given here is due to <ref> [BFLS91] </ref>. <p> We give its proof in the Appendix. Lemma 10 ["Zero-tester" Polynomials, <ref> [BFLS91, FGL + 91] </ref>] Let F = GF (q) and integers m; h satisfy 32mh &lt; q. <p> = NEXPTIME, which are also nonrelativizing. (We note that in fact, IP = PSPACE is false with probability 1 with respect to a random oracle [CC+94].) Note in this connection that the characterization NP = PCP (log n; log 0:5+* n) can be strengthened further by using an idea of <ref> [BFLS91] </ref>. Namely, if we change the model a little and ask that the input be provided in an encoded form (using a specific error-correcting code) to the verifier, then our (log n; log 0:5+* n)-restricted verifier runs in polylogarithmic time. <p> This stronger characterization might be useful in any attempts to separate complexity classes using our new characterization of NP. Another application of our ideas is to mechanical checking of formal mathematical proofs. Babai et al. <ref> [BFLS91] </ref> observed earlier that since the language f (T; 1 n ) : T is a theorem of Peano arithmetic with a proof of size n.g is NP-complete, their main theorem implies that proofs for mathematical statements can be checked by reading only poly (logn) bits in them. (Note that above
Reference: [BGKW88] <author> M. Ben-or, S. Goldwasser, J. Kilian, and A. Wigderson. </author> <title> Multi prover interactive proofs: How to remove intractability assumptions. </title> <booktitle> In Proc. 20th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 113-121, </pages> <year> 1988. </year>
Reference-contexts: The model of multi-prover interactive proofs was introduced by Ben-Or, Goldwasser, Kilian, and Wigderson <ref> [BGKW88] </ref>. The model consists of a random polynomial-time verifier V communicating with two infinitely powerful provers who cannot communicate with each other during the protocol. The provers try to convince the verifier that the input x is in a language L.
Reference: [BGLR93] <author> M. Bellare, S. Goldwasser, C. Lund, and A. Russell. </author> <title> Efficient multi-prover interactive proofs with applications to approximation problems. </title> <booktitle> In Proc. 25th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 113-131, </pages> <year> 1993. </year>
Reference-contexts: The verifier obtained through the above composition is (log n; 1)-restricted. Since [ALM + 92] a sequence of papers <ref> [PS, BGLR93, BS94, BGS95, H96] </ref> have constructed more and more efficient (in terms of constant factors) (log n; 1)-restricted verifiers for SAT. <p> It also generalizes our low degree test in an important way (see also [ASu97]). Problems other than Clique and MAX-SNP problems have also been shown hard to approximate. These include Chromatic-Number and Set-Cover (Lund and Yannakakis [LY94]; see also <ref> [BGLR93, KLS93] </ref>) and problems on lattices, codes, and linear systems (Arora, Babai, Stern and Sweedyk [ABSS93]). Independently of these works, other hardness results for a variety of approximation problems were obtained by Bellare [Bel93], Bellare and Rogaway [BR93], and Zuckerman ([Zuc93]). We refer the reader to [AL96] for a survey.
Reference: [BGS95] <author> M. Bellare, O. Goldreich, and M. Sudan. </author> <title> Free bits and nonapproximability. </title> <booktitle> In Proc. 27th ACM Symp. on Theory of Computing, </booktitle> <year> 1995. </year> <note> to appear. </note>
Reference-contexts: The verifier obtained through the above composition is (log n; 1)-restricted. Since [ALM + 92] a sequence of papers <ref> [PS, BGLR93, BS94, BGS95, H96] </ref> have constructed more and more efficient (in terms of constant factors) (log n; 1)-restricted verifiers for SAT.
Reference: [BH92] <author> R. Boppana and M. Halldorsson. </author> <title> Approximating maximum independent sets by excluding subgraphs. </title> <journal> BIT, </journal> <volume> 32 </volume> <pages> 180-196, </pages> <year> 1992. </year>
Reference-contexts: Current email and address: arora@cs.princeton.edu. 35 Olden St., Princeton NJ 08544. z This work was done while the author was with Stanford University and IBM Almaden. Current email and address: safra@math.tau.ac.il., Math Dept., Tel Aviv University, Israel. 1 approximates clique number within a factor O (n= log 2 n) <ref> [BH92] </ref>, whereas, until recently, it was not known even if approximating within a factor 1 + *, for any fixed * &gt; 0, is NP-hard.
Reference: [BK89] <author> M. Blum and S. Kannan. </author> <title> Designing programs that check their work. </title> <booktitle> In Proc. 21st ACM Symp. on Theory of Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1989. </year>
Reference-contexts: It therefore came as a surprise when Lund, Fortnow, Karloff, and Nisan [LFKN92] and Shamir [Sha92] showed, using techniques developed for program checking <ref> [BK89, BLR90, Lip89] </ref>, that that IP = PSPACE. (The class PSPACE is believed to be quite larger than NP and co-NP.) Shortly afterwards, Babai, Fortnow and Lund [BFL91] introduced even more powerful techniques to show that MIP = NEXPTIME.
Reference: [BLR90] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-testing/correcting with applications to numerical problems. </title> <booktitle> In Proc. 22nd ACM Symp. on Theory of Computing, </booktitle> <pages> pages 73-83, </pages> <year> 1990. </year>
Reference-contexts: It therefore came as a surprise when Lund, Fortnow, Karloff, and Nisan [LFKN92] and Shamir [Sha92] showed, using techniques developed for program checking <ref> [BK89, BLR90, Lip89] </ref>, that that IP = PSPACE. (The class PSPACE is believed to be quite larger than NP and co-NP.) Shortly afterwards, Babai, Fortnow and Lund [BFL91] introduced even more powerful techniques to show that MIP = NEXPTIME. <p> This gives a verifier that reads O (1) entries from the proof, but now the entries are of size O (log log n). The third step is to compose the verifier of the second step with a new verifier, whose construction used some ideas in <ref> [BLR90] </ref>. This new verifier is inefficient in the number of random bits it uses (this number is polynomial in the proof size), but it queries only O (1) bits from the proof. The verifier obtained through the above composition is (log n; 1)-restricted.
Reference: [BR93] <author> M. Bellare and P. Rogaway. </author> <title> The complexity of approximating non-linear programs. In P.M. </title> <editor> Pardalos, editor, </editor> <title> Complexity of Numerical Optimization. </title> <publisher> World Scientific, </publisher> <year> 1993. </year> <note> Preliminary version: IBM Research Report RC 17831 (March 1992). 41 </note>
Reference-contexts: These include Chromatic-Number and Set-Cover (Lund and Yannakakis [LY94]; see also [BGLR93, KLS93]) and problems on lattices, codes, and linear systems (Arora, Babai, Stern and Sweedyk [ABSS93]). Independently of these works, other hardness results for a variety of approximation problems were obtained by Bellare [Bel93], Bellare and Rogaway <ref> [BR93] </ref>, and Zuckerman ([Zuc93]). We refer the reader to [AL96] for a survey. The NP-hardness result for approximating clique has been steadily improved. A consequence of NP = PCP (log n; 1) is that approximating clique number within a factor n * is NP-hard, for some fixed * &gt; 0.
Reference: [BS94] <author> M. Bellare and M. Sudan. </author> <title> Improved non-approximability results. </title> <booktitle> In Proc. 26th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 184-193, </pages> <year> 1994. </year>
Reference-contexts: The verifier obtained through the above composition is (log n; 1)-restricted. Since [ALM + 92] a sequence of papers <ref> [PS, BGLR93, BS94, BGS95, H96] </ref> have constructed more and more efficient (in terms of constant factors) (log n; 1)-restricted verifiers for SAT.
Reference: [BW] <author> E. Berlekamp and L. Welch. </author> <title> Error correction of algebraic block codes. </title> <type> US Patent Number 4,633,470. </type>
Reference-contexts: In a good row ~ b, the set of pairs n o is well-described by the row polynomial g ~ b (x 1 ). The next lemma makes explicit the algebraic object that underlies well-described sets of pairs: an overconstrained linear system. Lemma 19 (Berlekamp-Welch <ref> [BW] </ref>) Let (a 1 ; p 1 ); : : : ; (a 10h ; p 10h ) be well-described in F h [x]. Then 1.
Reference: [CC+94] <author> R. Chang, B. Chor, O. Goldreich, J. Hartmanis, J. Hastad, D. Ranjan, and P. Rohatgi. </author> <title> The random oracle hypothesis is false. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 49:1, </volume> <year> 1994. </year>
Reference-contexts: Of course, similar tanta-lizing possibilities were raised by recent results like IP = PSPACE or MIP = NEXPTIME, which are also nonrelativizing. (We note that in fact, IP = PSPACE is false with probability 1 with respect to a random oracle <ref> [CC+94] </ref>.) Note in this connection that the characterization NP = PCP (log n; log 0:5+* n) can be strengthened further by using an idea of [BFLS91].
Reference: [CG89] <author> B. Chor and O. Goldreich. </author> <title> On the power of two-point based sampling. </title> <journal> Journal of Complexity, </journal> <volume> 5 </volume> <pages> 96-106, </pages> <year> 1989. </year>
Reference-contexts: As we pointed out, Lemma 13 shows that if g 1 is not ffi=2-close, then the fraction of inconsistent checkpoints in the decomposition is at least ffi 4m . Hence, by sampling in a pairwise independent fashion (see <ref> [CG89] </ref> for example), the verifier can choose a set of O (m=ffi) checkpoints such that with probability 3 4 , at least one of them is inconsistent. This sampling uses only O (m log (jFj)) random bits when ffi is a constant.
Reference: [CFLS93] <author> A. Condon, J. Feigenbaum, C. Lund, and P. Shor. </author> <title> Random debaters and the hardness of approximating stochastic functions. </title> <booktitle> In Proc. of the 9th Structure in Complexity Theory Conference, </booktitle> <pages> pages 280-293, </pages> <year> 1993. </year> <note> Also available as DIMACS Techreport TR 93-79. </note>
Reference-contexts: A sequence of improvements culminating in Hastad [H96] shows that even approximating within a factor n 1* is hard if NP 6 BP P . Lastly, we mention that PCP-style characterizations have been provided for other complexity classes as well, such as PSPACE (Condon et al., <ref> [CFLS93] </ref>) and PH (Kiwi et al., [KLR + 94]). Acknowledgments We thank Mike Luby for many discussions in the early stages of this work; specifically, his lower bound on the complexity of the protocol as presented in [FGL + 91] is what started this work.
Reference: [CL89] <author> A. Condon and R. Ladner. </author> <title> On the complexity of space bounded interactive proofs. </title> <booktitle> In Proc. 30th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 462-467, </pages> <year> 1989. </year>
Reference-contexts: It is easily seen that this is another exact characterization of NP. Lipton's work has recently been extended by Condon and Ladner <ref> [CL89] </ref> to give a somewhat stronger result. In these characterizations, the verifier, though very restricted, at least receives a polynomial number of bits of information about the proof. Condon [Con93] used the bounded-away probability in such characterizations of NP to show the NP-hardness of approximating the Max-Word problem.
Reference: [Con93] <author> A. Condon. </author> <title> The complexity of the max-word problem and the power of one-way interactive proof systems. </title> <journal> Computational Complexity, </journal> <volume> 3 </volume> <pages> 292-305, </pages> <year> 1993. </year>
Reference-contexts: Lipton's work has recently been extended by Condon and Ladner [CL89] to give a somewhat stronger result. In these characterizations, the verifier, though very restricted, at least receives a polynomial number of bits of information about the proof. Condon <ref> [Con93] </ref> used the bounded-away probability in such characterizations of NP to show the NP-hardness of approximating the Max-Word problem. This largely-unknown result was independent of (and slightly predated) the [FGL + 91] result.
Reference: [Coo71] <author> S. Cook. </author> <title> The complexity of theorem-proving procedures. </title> <booktitle> In Proc. 3rd ACM Symp. on Theory of Computing, </booktitle> <pages> pages 151-158, </pages> <year> 1971. </year>
Reference-contexts: 1 Introduction Problems involving combinatorial optimization arise naturally in many applications. For many problems, no polynomial-time algorithms are known. The work of Cook, Karp, and Levin <ref> [Coo71, Kar72, Lev73] </ref> provides a good reason why: many of these problems are NP-hard. If they were to have polynomial-time algorithms, then so would every NP decision problem, and so P = NP.
Reference: [Fag74] <author> R. Fagin. </author> <title> Generalized first-order spectra and polynomial-time recognizable sets. </title> <editor> In Richard Karp, editor, </editor> <booktitle> Complexity of Computer Computations, </booktitle> <pages> pages 43-73. </pages> <publisher> AMS, </publisher> <year> 1974. </year>
Reference-contexts: Fagin <ref> [Fag74] </ref> gave a characterization in terms of spectra of second order formulae.
Reference: [FGL + 91] <author> U. Feige, S. Goldwasser, L. Lovasz, S. Safra, and M. Szegedy. </author> <title> Approximating clique is almost NP-complete. </title> <booktitle> In Proc. 32nd IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 2-12, </pages> <year> 1991. </year>
Reference-contexts: Feige, Goldwasser, Lovasz, Safra, and Szegedy <ref> [FGL + 91] </ref> recently provided a breakthrough, by showing that if the clique number can be approximated within any constant factor in polynomial time, then every NP problem can be solved deterministically in time n O (log log n) . <p> Since some NP problems (SAT, for example) are widely believed to have no subexponential-time algorithms, this result provides a strong reason to believe that the clique number has no good approximation algorithms. (The authors therefore proclaimed clique approximation "almost" NP-hard.) At the core of the <ref> [FGL + 91] </ref> result is a new technique for doing reductions, which uses recent results from the theory of interactive proofs. The use of this radically new technique (not to mention the fact that it shows the problem is "almost"-NP-hard instead of NP-hard), suggests that the [FGL + 91] result, though <p> the core of the <ref> [FGL + 91] </ref> result is a new technique for doing reductions, which uses recent results from the theory of interactive proofs. The use of this radically new technique (not to mention the fact that it shows the problem is "almost"-NP-hard instead of NP-hard), suggests that the [FGL + 91] result, though impressive, is not the end of the story. The results in this paper confirm this. <p> We use techniques derived from those in <ref> [FGL + 91] </ref> and some earlier papers. Second, we provide a new, and surprising, characterization of the class NP. As we will describe soon, this characterization is the logical culmination of recent results about interactive proofs, which have provided new characterizations for traditional complexity classes such as PSPACE and NEXPTIME. <p> This approach was suggested by Feige, Goldwasser, Lovasz, Safra, and Szegedy <ref> [FGL + 91] </ref>, who showed that there exist verifiers for NP that run in polynomial time, but use only O (log n log log n) random bits and query bits. MIP and the Hardness of Approximation The above-mentioned developments were exciting. <p> Szegedy <ref> [FGL + 91] </ref>, who showed that there exist verifiers for NP that run in polynomial time, but use only O (log n log log n) random bits and query bits. MIP and the Hardness of Approximation The above-mentioned developments were exciting. Even more exciting was a connection, discovered in [FGL + 91], between their scaled-down version of MIP = NEXPTIME and the hardness of approximating the clique number. We will describe this connection in greater detail later, but briefly stated, the two results shown were as follows. <p> The notion becomes even more intriguing in light of the possible trade-offs, hinted at in the results of <ref> [FGL + 91, BFLS91] </ref>, between the verifier's running time, random bits, and query bits. If these trade-offs can be improved, improved nonapproximability results for the clique problem follow, as we will soon see. <p> If x 62 L, then for all proofs , Pr [M (x; t ) = 1] &lt; 2 (In both cases, the probability is over the choice of the random string t .) 4 to which the verifier M has random access. In <ref> [FGL + 91] </ref>, a new twist was introduced in this setting: there is a (startlingly low) limit on the number of random bits used by the verifier, and the number of bits it can read in the proof. <p> Thus every language in PCP (r (n); q (n)) is in Ntime (2 O (r (n)) q (n)). The above-mentioned paper <ref> [FGL + 91] </ref> implicitly defined a hierarchy of complexity classes similar to PCP. The hierarchy was unnamed there, so for sake of discussion we give it the name M O (for "memoryless oracle," a term used in that paper). <p> For every integer-valued function c such that c (n) poly (n), the class M O (c (n)) is the same as our PCP (c (n); c (n)). The <ref> [FGL + 91] </ref> paper showed that NP M O (log n log log n). <p> An interesting open question arising from the "sandwich" result implicit in <ref> [FGL + 91] </ref> was whether NP has an exact characterization in terms of PCP. Our main theorem settles this question. <p> Our main theorem settles this question. Theorem 1 (Main) NP = PCP (log n; log n): Theorem 1 is probably optimal, in the following sense: if NP PCP (o (log n); o (log n)), then NP = P. This implication is a consequence of a reduction in <ref> [FGL + 91] </ref> (see Theorem 26 in the Appendix), which reduces every language in L 2 PCP (o (log n); o (log n)) to sublinear instances of the clique problem; that is, it reduces the membership problem for inputs of size n to clique instances of size n o (1) . <p> Then Arora, Lund, Motwani, Sudan and Szegedy [ALM + 92] showed that NP PCP (log n; 1). (See Section 6.) Our new characterization of NP also allows us to prove the NP-hardness of approximating the clique problem, thus resolving an open question in <ref> [FGL + 91] </ref>. Corollary 3 For any positive constants c; *, if a polynomial-time algorithm approximates the clique problem within a ratio 2 c log 0:5* n , then P = NP. Proof: We show that the hypothesis implies a polynomial-time algorithm for SAT. <p> Proof: We show that the hypothesis implies a polynomial-time algorithm for SAT. We use a reduction from PCP to clique described in <ref> [FGL + 91] </ref> (see Theorem 26 in the Appendix), and an error-amplification technique from [AKS87] (the idea of using this technique in the context of proof checking is from [Zuc91]). <p> If x 2 SAT , there is a proof x that the verifier accepts with probability 1. But if x 62 SAT , the verifier accepts every proof with probability less than p = 2 log n 2 log 0:5*=2 n . Now apply the reduction from <ref> [FGL + 91] </ref> (see Theorem 26 in the appendix) to this new verifier. Given a boolean formula of size n, the reduction produces graphs of size 2 O (log n) = n O (1) . Let N denote this size. <p> Condon [Con93] used the bounded-away probability in such characterizations of NP to show the NP-hardness of approximating the Max-Word problem. This largely-unknown result was independent of (and slightly predated) the <ref> [FGL + 91] </ref> result. <p> This technique has played a pivotal role in all subsequent works in this area. Our starting point is the verifier of [BFL91] in its scaled-down form <ref> [BFLS91, FGL + 91] </ref>. This verifier, because of its reliance on a special error-correcting code, has certain strong properties, some of which were earlier noted in [BFLS91]. We will use such properties to compose verifiers. <p> We will later describe how to construct such verifiers. In addition to verifier composition, we also develop some other techniques to prove our main results. Chief among them is our improved analysis of the efficiency of the verifiers in <ref> [BFLS91, FGL + 91] </ref>, specifically, of a procedure called the low degree test. (This improved analysis becomes possible through our Lemma 16.) The rest of the paper is organized as follows. <p> The essential ingredients of this proof are the Composition Lemma (Lemma 5), which we will prove in this section, and Theorem 6, which we will prove in Section 4. As already mentioned, our starting point are the verifiers for 3SAT that were constructed in <ref> [BFL91, BFLS91, FGL + 91] </ref>. Now we mention some of their properties that will be of interest. 1) The proof can be viewed as a string over a non-binary alphabet. The verifier has an associated sequence of alphabets f n : n = 1; 2; 3; : : :g. <p> The proof is largely based upon that in <ref> [BFLS91, FGL + 91] </ref>, with ingredients dating back to [LFKN92, BFL91]. The only new parts are our improved analysis of the low degree test, and our technique for showing that the verifier is in normal form (in particular, that it can check split-encoded assignments). <p> We give its proof in the Appendix. Lemma 10 <ref> ["Zero-tester" Polynomials, [BFLS91, FGL + 91] </ref>] Let F = GF (q) and integers m; h satisfy 32mh &lt; q. <p> We give its proof in the Appendix. Lemma 10 ["Zero-tester" Polynomials, <ref> [BFLS91, FGL + 91] </ref>] Let F = GF (q) and integers m; h satisfy 32mh &lt; q. <p> It accepts every polynomial in F h [x 1 ; : : : ; x m ] with probability 1 and rejects every function that is not ffi-close with probability at least 3=4. The procedure described here is an obvious modification of the ones in <ref> [FGL + 91, She91] </ref> (which were described for degree h = 1 and were called multilinearity tests). We improve its analysis to show that it needs to examine only O (m) entries in the proof, instead of the O (mh) entries required by the earlier analysis. <p> We suspect that this result is largely of theoretical (as opposed to practical) interest. As mentioned in the introduction, the initial motivation for our work was to show the NP-hardness of approximating clique, thereby solving an open problem of <ref> [FGL + 91] </ref> (namely, how to change "almost"NP-hard in their main result to NP-hard). Indeed, by showing that NP = PCP (log n; log n), and applying the reduction to Clique approximation [FGL + 91], we get that approximating Clique to within a constant factor is NP-hard. <p> motivation for our work was to show the NP-hardness of approximating clique, thereby solving an open problem of <ref> [FGL + 91] </ref> (namely, how to change "almost"NP-hard in their main result to NP-hard). Indeed, by showing that NP = PCP (log n; log n), and applying the reduction to Clique approximation [FGL + 91], we get that approximating Clique to within a constant factor is NP-hard. We were surprised to find out that our technique enables us to show an even better chracterization of NP in terms of PCP, with a sub-logarithmic number of queries. <p> Acknowledgments We thank Mike Luby for many discussions in the early stages of this work; specifically, his lower bound on the complexity of the protocol as presented in <ref> [FGL + 91] </ref> is what started this work. We also thank Ron Fagin, Oded Goldreich, Noam Nisan, Madhu Sudan, Steven Phillips, Mario Szegedy, Umesh Vazirani and Moshe Vardi for many insightful discussions.
Reference: [FL92] <author> U. Feige and L. Lovasz. </author> <title> Two-prover one-round proof systems: Their power and their problems. </title> <booktitle> In Proc. 24th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 733-741, </pages> <year> 1992. </year>
Reference-contexts: One crucial component in constructing such a verifier is an efficient low-degree test based upon our main technical lemma (Lemma 16) and the work of Rubinfeld and Sudan [RS92]. Another important idea is that of parallelization, introduced in the work of Lapidot and Shamir [LS91] and Feige and Lovasz <ref> [FL92] </ref>. The second step in [ALM + 92] is to compose the verifier of the first step with itself. This gives a verifier that reads O (1) entries from the proof, but now the entries are of size O (log log n).
Reference: [FRS88] <author> L. Fortnow, J. Rompel, and M. Sipser. </author> <title> On the power of multi-prover interactive protocols. </title> <booktitle> In Proceedings of the 3rd Conference on Structure in Complexity Theory, </booktitle> <pages> pages 156-161, </pages> <year> 1988. </year>
Reference-contexts: if there exists a V that is always convinced when x 2 L and, but if x =2 L, then the provers have only a small probability of convincing V to the contrary. 2 Proof Verification An equivalent formulation of the class MIP was suggested by Fortnow, Rompel and Sipser <ref> [FRS88] </ref>. In this model, a random polynomial-time Turing machine M is interacting with an oracle O x that is trying to convince M that x 2 L. <p> Both contain NP, but were not even thought to contain co-NP. Some evidence to this effect was provided by the relativization results of <ref> [FS88, FRS88] </ref>, which show the existence of a language O such that if Turing machines are given access to a membership oracle for O, then co-NP is not contained in MIP (or IP). <p> Scaling Down MIP = NEXPTIME Since NEXPTIME can be characterized as the set of languages that have exponential-size membership proofs, the result MIP = NEXPTIME [BFL91], combined with the oracle formulation of MIP <ref> [FRS88] </ref>, shows that if a language has membership proofs of exponential size, then some probabilistic polynomial-time verifier can check those membership proofs. There were two efforts to "scale down" the above result, i.e., to show efficient verification procedures for checking membership proofs for smaller nondeterministic classes, such as NP. <p> For an input x, random string t and proof string , define M (x; t ) to be 1 if M accepts x using t after examining proof string . Otherwise M (x; t ) is 0. The next definition formalizes a concept dating back to <ref> [FRS88] </ref>. Definition 1 Let L be a language. A verifier M checks membership proofs for L if it behaves as follows for every input x. 1.
Reference: [FS88] <author> L. Fortnow and M. Sipser. </author> <title> Are there interactive protocols for co-np languages? Information Processing Letters, </title> <booktitle> 28 </booktitle> <pages> 249-251, </pages> <year> 1988. </year>
Reference-contexts: Both contain NP, but were not even thought to contain co-NP. Some evidence to this effect was provided by the relativization results of <ref> [FS88, FRS88] </ref>, which show the existence of a language O such that if Turing machines are given access to a membership oracle for O, then co-NP is not contained in MIP (or IP).
Reference: [GMR89] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The knowledge complexity of interactive proofs. </title> <journal> SIAM J. of Computation, </journal> <volume> 18 </volume> <pages> 186-208, </pages> <year> 1989. </year> <note> (Preliminary version in Proc. ACM Symposium on Theory of Computing, </note> <year> 1985.) </year>
Reference-contexts: Two of these are verifier composition and an improved low degree test. 1.1 Context of this work We briefly discuss recent results in complexity theory and where our work fits in relation to them. Interactive Proofs The model of interactive proofs was introduced by Goldwasser, Micali and Rackoff <ref> [GMR89] </ref> for cryptographic applications, and by Babai [Bab85] as a game-theoretic extension of NP. The model consists of a probabilistic polynomial-time verifier V communicating with a prover P who tries to convince V that the input x is in a language L.
Reference: [H96] <author> J. Hastad. </author> <title> Clique is hard to approximate within n 1* . In Proc. </title> <booktitle> 37th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 627-636, </pages> <year> 1996. </year>
Reference-contexts: The verifier obtained through the above composition is (log n; 1)-restricted. Since [ALM + 92] a sequence of papers <ref> [PS, BGLR93, BS94, BGS95, H96] </ref> have constructed more and more efficient (in terms of constant factors) (log n; 1)-restricted verifiers for SAT. <p> The NP-hardness result for approximating clique has been steadily improved. A consequence of NP = PCP (log n; 1) is that approximating clique number within a factor n * is NP-hard, for some fixed * &gt; 0. A sequence of improvements culminating in Hastad <ref> [H96] </ref> shows that even approximating within a factor n 1* is hard if NP 6 BP P . Lastly, we mention that PCP-style characterizations have been provided for other complexity classes as well, such as PSPACE (Condon et al., [CFLS93]) and PH (Kiwi et al., [KLR + 94]).
Reference: [H97] <author> J. Hastad. </author> <title> Some optimal inapproximability results. </title> <booktitle> In Proc. 29th Annual ACM Symp. on Theory of Computing, </booktitle> <pages> pages 1-10, </pages> <year> 1997 </year>
Reference-contexts: The verifier obtained through the above composition is (log n; 1)-restricted. Since [ALM + 92] a sequence of papers [PS, BGLR93, BS94, BGS95, H96] have constructed more and more efficient (in terms of constant factors) (log n; 1)-restricted verifiers for SAT. The latest verifier <ref> [H97] </ref> needs only 3 query bits 8 . (Some of our ideas from Section 4.4 regarding the "concatenation property" were useful in achieving some of this efficiency.) In a different direction, a recent paper [PS94] improves existing verifiers by reducing the size of the proof required by this verifier to n
Reference: [Kar72] <author> R. M. Karp. </author> <title> Reducibility among combinatorial problems. </title> <editor> In Miller and Thatcher, editors, </editor> <booktitle> Complexity of Computer Computations, </booktitle> <pages> pages 85-103. </pages> <publisher> Plenum Press, </publisher> <year> 1972. </year>
Reference-contexts: 1 Introduction Problems involving combinatorial optimization arise naturally in many applications. For many problems, no polynomial-time algorithms are known. The work of Cook, Karp, and Levin <ref> [Coo71, Kar72, Lev73] </ref> provides a good reason why: many of these problems are NP-hard. If they were to have polynomial-time algorithms, then so would every NP decision problem, and so P = NP.
Reference: [KLR + 94] <author> M. Kiwi, C. Lund, A. Russell, D. Spielman, and R. Sundaram. </author> <title> Interaction and alternation. </title> <booktitle> In Proceedings of the 9th Structure in Complexity Theory Conference, </booktitle> <year> 1994. </year>
Reference-contexts: Lastly, we mention that PCP-style characterizations have been provided for other complexity classes as well, such as PSPACE (Condon et al., [CFLS93]) and PH (Kiwi et al., <ref> [KLR + 94] </ref>). Acknowledgments We thank Mike Luby for many discussions in the early stages of this work; specifically, his lower bound on the complexity of the protocol as presented in [FGL + 91] is what started this work.
Reference: [KLS93] <author> S. Khanna, N. Linial, and S. Safra. </author> <title> On the hardness of approximating the chromatic number. </title> <booktitle> In Proceedings of the 2nd Israel Symposium on Theory and Computing Systems, ISTCS, </booktitle> <pages> pages 250-260. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year>
Reference-contexts: It also generalizes our low degree test in an important way (see also [ASu97]). Problems other than Clique and MAX-SNP problems have also been shown hard to approximate. These include Chromatic-Number and Set-Cover (Lund and Yannakakis [LY94]; see also <ref> [BGLR93, KLS93] </ref>) and problems on lattices, codes, and linear systems (Arora, Babai, Stern and Sweedyk [ABSS93]). Independently of these works, other hardness results for a variety of approximation problems were obtained by Bellare [Bel93], Bellare and Rogaway [BR93], and Zuckerman ([Zuc93]). We refer the reader to [AL96] for a survey.
Reference: [Lev73] <author> L. Levin. </author> <title> Universal'nye perebornye zadachi (universal search problems : in Russian). </title> <journal> Problemy Peredachi Informatsii, </journal> <volume> 9(3) </volume> <pages> 265-266, </pages> <year> 1973. </year>
Reference-contexts: 1 Introduction Problems involving combinatorial optimization arise naturally in many applications. For many problems, no polynomial-time algorithms are known. The work of Cook, Karp, and Levin <ref> [Coo71, Kar72, Lev73] </ref> provides a good reason why: many of these problems are NP-hard. If they were to have polynomial-time algorithms, then so would every NP decision problem, and so P = NP.
Reference: [LFKN92] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan. </author> <title> Algebraic methods for interactive proof systems. </title> <journal> Journal of the ACM, </journal> <volume> 39(4) </volume> <pages> 859-868, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: It therefore came as a surprise when Lund, Fortnow, Karloff, and Nisan <ref> [LFKN92] </ref> and Shamir [Sha92] showed, using techniques developed for program checking [BK89, BLR90, Lip89], that that IP = PSPACE. (The class PSPACE is believed to be quite larger than NP and co-NP.) Shortly afterwards, Babai, Fortnow and Lund [BFL91] introduced even more powerful techniques to show that MIP = NEXPTIME. <p> The proof is largely based upon that in [BFLS91, FGL + 91], with ingredients dating back to <ref> [LFKN92, BFL91] </ref>. The only new parts are our improved analysis of the low degree test, and our technique for showing that the verifier is in normal form (in particular, that it can check split-encoded assignments). Underlying the description of the verifier is an algebraic representation of a 3SAT formula. <p> But if e f is not a satisfying polynomial, then with high probability, P e f does not sum to 0 on S. Now the verifier can use a simple algebraic procedure from <ref> [LFKN92] </ref>, called the Sum-Check (Procedure 1) to verify that P e f indeed sums to 0 on S. Further details are provided below. Section 4.2.1 describes the algebraic conditions that a satisfying polynomial must obey. Section 4.2.2 describes some algebraic procedures that the verifier will use. <p> Therefore we have trivially 1 But we proved above that e f i = e f j ~ x 1 =i . Hence the second half of the concatenation property, Condition (22), now follows. 2 4.5 The Sum-Check We describe Procedure 1, the Sum-Check. The procedure is due to <ref> [LFKN92] </ref>; we include it here chiefly for completeness, and to point out that the procedure can query the proof nonadapatively (this fact is not clear in existing descriptions).
Reference: [Lip89] <author> R. Lipton. </author> <title> Efficient checking of computations. </title> <booktitle> In Proceedings of 6th STACS, </booktitle> <year> 1989. </year> <month> 42 </month>
Reference-contexts: It therefore came as a surprise when Lund, Fortnow, Karloff, and Nisan [LFKN92] and Shamir [Sha92] showed, using techniques developed for program checking <ref> [BK89, BLR90, Lip89] </ref>, that that IP = PSPACE. (The class PSPACE is believed to be quite larger than NP and co-NP.) Shortly afterwards, Babai, Fortnow and Lund [BFL91] introduced even more powerful techniques to show that MIP = NEXPTIME. <p> Recent work in program checking and interactive proof systems has resulted in other characterizations of NP. For instance, Lipton <ref> [Lip89] </ref> showed that membership proofs for NP can be checked by probabilistic logspace verifiers that have one-way access to the proof and use O (log n) random bits. It is easily seen that this is another exact characterization of NP.
Reference: [LS91] <author> D. Lapidot and A. Shamir. </author> <title> Fully parallelized multi prover protocols for NEXPTIME. </title> <booktitle> In Proc. 32nd IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 13-18, </pages> <year> 1991. </year>
Reference-contexts: One crucial component in constructing such a verifier is an efficient low-degree test based upon our main technical lemma (Lemma 16) and the work of Rubinfeld and Sudan [RS92]. Another important idea is that of parallelization, introduced in the work of Lapidot and Shamir <ref> [LS91] </ref> and Feige and Lovasz [FL92]. The second step in [ALM + 92] is to compose the verifier of the first step with itself. This gives a verifier that reads O (1) entries from the proof, but now the entries are of size O (log log n).
Reference: [LY94] <author> C. Lund and M. Yannakakis. </author> <title> On the hardness of approximating minimization problems. </title> <journal> Journal of the ACM, </journal> <volume> 41(5) </volume> <pages> 960-981, </pages> <year> 1994. </year>
Reference-contexts: The paper shows how to construct such verifiers for a log 1* n. It also generalizes our low degree test in an important way (see also [ASu97]). Problems other than Clique and MAX-SNP problems have also been shown hard to approximate. These include Chromatic-Number and Set-Cover (Lund and Yannakakis <ref> [LY94] </ref>; see also [BGLR93, KLS93]) and problems on lattices, codes, and linear systems (Arora, Babai, Stern and Sweedyk [ABSS93]). Independently of these works, other hardness results for a variety of approximation problems were obtained by Bellare [Bel93], Bellare and Rogaway [BR93], and Zuckerman ([Zuc93]).
Reference: [NN93] <author> J. Naor and M. Naor. </author> <title> Small-bias probability spaces: efficient constructions and applications. </title> <journal> Siam J. Computing, </journal> <volume> 22 </volume> <pages> 838-856, </pages> <year> 1993. </year>
Reference: [Pap94] <author> C. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Furthermore, this decision is arrived in time T . Thus by using a standard transformation from a time T computation to a size O (T 2 ) size circuit <ref> [Pap94] </ref>, we can think of the third stage as being represented by a circuit C r of size O (T 2 ) (see Figure 2) whose input 3 is a bit string of size Q dlog e. <p> Then V 1 accepts proof using w as a random string iff C w ( [i 1 (w)] ffi [i 2 (w)] ffi ffi [i Q (w)] ) = accept: (7) The Cook-Levin theorem for circuits (see <ref> [Pap94] </ref> for a description) gives an effective way to change this circuit C w into a 3SAT formula w of size O (T ) such that V 1 accepts using random string w iff 9y w : [i 1 (w)] ffi [i 2 (w)] ffi ffi [i Q (w)] ffi y
Reference: [PS] <author> S. Phillips and S. Safra. </author> <title> PCP and tighter bounds for approximating MAX-SNP. </title> <type> Manuscript, </type> <month> April </month> <year> 1992. </year>
Reference-contexts: The verifier obtained through the above composition is (log n; 1)-restricted. Since [ALM + 92] a sequence of papers <ref> [PS, BGLR93, BS94, BGS95, H96] </ref> have constructed more and more efficient (in terms of constant factors) (log n; 1)-restricted verifiers for SAT.
Reference: [PS94] <author> A. Polishchuk and D. Spielman. </author> <title> Nearly linear size holographic proofs. </title> <booktitle> In Proc. 26th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 194-203, </pages> <year> 1994. </year>
Reference-contexts: If jFj = (h 3 m 2 ), then f is 1=9-close. Note: This lemma has subsequently found important applications in the work of [ALM + 92]. The relevant case there is m = 2, for which simpler proofs have been found <ref> [Sud92, PS94] </ref>. Currently, our proof is the only one known for general m. The mathematical facts used in our proof will include some very basic linear algebra, specifically, how to solve systems of linear equations. All assumed facts appear in the appendix. <p> The latest verifier [H97] needs only 3 query bits 8 . (Some of our ideas from Section 4.4 regarding the "concatenation property" were useful in achieving some of this efficiency.) In a different direction, a recent paper <ref> [PS94] </ref> improves existing verifiers by reducing the size of the proof required by this verifier to n 1+* . (This had not been achieved in [ALM + 92] because of the huge field size required by our Lemma 16, which is crucial to [ALM + 92]. A centerpiece of [PS94] is <p> paper <ref> [PS94] </ref> improves existing verifiers by reducing the size of the proof required by this verifier to n 1+* . (This had not been achieved in [ALM + 92] because of the huge field size required by our Lemma 16, which is crucial to [ALM + 92]. A centerpiece of [PS94] is a better proof for Lemma 16 | more correctly, of the subcase of the lemma when m, the number of variables, is 2.) In another, even more recent work, Raz and Safra [RS97] prove an important generalization of NP = PCP (log n; 1) in which the proof is
Reference: [PY91] <author> C. Papadimitriou and M. Yannakakis. </author> <title> Optimization, approximation and complexity classes. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 425-440, </pages> <year> 1991. </year>
Reference-contexts: Fagin [Fag74] gave a characterization in terms of spectra of second order formulae. This characterization has become the focus of renewed interest since the work of Papadimitriou and Yannakakis <ref> [PY91] </ref>, in which they use Fagin's ideas to define restricted subclasses of NP optimization problems and define a notion of completeness (with respect to approximability) within the subclasses. Recent work in program checking and interactive proof systems has resulted in other characterizations of NP. <p> So, in an earlier draft of this paper, we posed this as an open problem. Soon, the open problem acquired even more importance, since it was realized that decreasing the number of queries would have important consequences for MAX-SNP problems. The class MAX-SNP was introduced by Papadimitriou and Yannakakis <ref> [PY91] </ref>, as a framework for classifying approximation problems according to their difficulty.
Reference: [RS97] <author> R. Raz and S. Safra. </author> <title> A sub-constant error-probability low-degree test and a sub-constant error-probability PCP. </title> <booktitle> In Proc. 29th Annual ACM Symp. on Theory of Computing, </booktitle> <pages> pages 475-484, </pages> <year> 1997 </year>
Reference-contexts: A centerpiece of [PS94] is a better proof for Lemma 16 | more correctly, of the subcase of the lemma when m, the number of variables, is 2.) In another, even more recent work, Raz and Safra <ref> [RS97] </ref> prove an important generalization of NP = PCP (log n; 1) in which the proof is no longer a bit string but a string over an alphabet of size 2 a (i.e., each symbol is represented using a bits).
Reference: [RS92] <author> R. Rubinfeld and M. Sudan. </author> <title> Testing polynomial functions efficiently and over rational domains. </title> <booktitle> In Proc. 3rd Annual ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 23-32, </pages> <year> 1992. </year>
Reference-contexts: One crucial component in constructing such a verifier is an efficient low-degree test based upon our main technical lemma (Lemma 16) and the work of Rubinfeld and Sudan <ref> [RS92] </ref>. Another important idea is that of parallelization, introduced in the work of Lapidot and Shamir [LS91] and Feige and Lovasz [FL92]. The second step in [ALM + 92] is to compose the verifier of the first step with itself.
Reference: [Sha92] <author> A. Shamir. </author> <title> IP = PSPACE. </title> <journal> Journal of the ACM, </journal> <volume> 39(4) </volume> <pages> 869-877, </pages> <month> October </month> <year> 1992. </year> <title> Prelim. </title> <booktitle> version in 1990 FOCS, </booktitle> <pages> pages 11-15. </pages>
Reference-contexts: It therefore came as a surprise when Lund, Fortnow, Karloff, and Nisan [LFKN92] and Shamir <ref> [Sha92] </ref> showed, using techniques developed for program checking [BK89, BLR90, Lip89], that that IP = PSPACE. (The class PSPACE is believed to be quite larger than NP and co-NP.) Shortly afterwards, Babai, Fortnow and Lund [BFL91] introduced even more powerful techniques to show that MIP = NEXPTIME.
Reference: [She91] <author> A. Shen. </author> <title> Multilinearity test made easy. </title> <type> Manuscript, </type> <year> 1991. </year>
Reference-contexts: It accepts every polynomial in F h [x 1 ; : : : ; x m ] with probability 1 and rejects every function that is not ffi-close with probability at least 3=4. The procedure described here is an obvious modification of the ones in <ref> [FGL + 91, She91] </ref> (which were described for degree h = 1 and were called multilinearity tests). We improve its analysis to show that it needs to examine only O (m) entries in the proof, instead of the O (mh) entries required by the earlier analysis.
Reference: [Sud92] <author> M. Sudan. </author> <title> Efficient checking of polynomials and proofs and the hardness of approximation problems. </title> <type> PhD thesis, </type> <institution> U.C. Berkeley, </institution> <year> 1992. </year>
Reference-contexts: If jFj = (h 3 m 2 ), then f is 1=9-close. Note: This lemma has subsequently found important applications in the work of [ALM + 92]. The relevant case there is m = 2, for which simpler proofs have been found <ref> [Sud92, PS94] </ref>. Currently, our proof is the only one known for general m. The mathematical facts used in our proof will include some very basic linear algebra, specifically, how to solve systems of linear equations. All assumed facts appear in the appendix.
Reference: [Zuc91] <author> D. Zuckerman. </author> <title> Simulating BPP using a general weak random source. </title> <booktitle> In Proc. 32nd IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 79-89, </pages> <year> 1991. </year>
Reference-contexts: We use a reduction from PCP to clique described in [FGL + 91] (see Theorem 26 in the Appendix), and an error-amplification technique from [AKS87] (the idea of using this technique in the context of proof checking is from <ref> [Zuc91] </ref>). Since NP = PCP (log n; log 0:5+*=2 n), there is a (log n; log 0:5+*=2 n)-restricted verifier that checks membership proofs for SAT. The randomness-efficient error amplification in [AKS87] allows us to change the verifier into one that is (log n; log n)-restricted and has the following property.
Reference: [Zuc93] <author> D. Zuckerman. </author> <title> NP-complete problems have a version that's hard to approximate. </title> <booktitle> In 8th Structure in Complexity Theory Conf., </booktitle> <pages> pages 305-312, </pages> <year> 1993. </year>
References-found: 55

