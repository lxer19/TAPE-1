URL: http://www.cs.tamu.edu/research/ADEPT/DIST/adept_jxa.ps
Refering-URL: http://www.cs.tamu.edu/research/ADEPT/
Root-URL: http://www.cs.tamu.edu
Title: Interoperation of Ada and Java using  
Author: ADEPT/JxA Gargaro, Smith, Theriault, Volz Waldrop 
Date: April 10, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Ada 9X Mapping/Revision Team. </author> <title> ISO/IEC 8652:1995(E) Ada reference manual language and st andard libraries, </title> <note> Version 6.0, </note> <month> 21 December </month> <year> 1994. </year>
Reference-contexts: By focusing on the interoperability of just two languages with complementary as well as similar features, we hope to expand the domain of applications that can receive the benefits of distributed object technology. Both the Ada <ref> [1] </ref> and Java [2] languages include support for distributed object technology. In Ada this support is specified in Annex E and in Java it is provided by the Java Remote Method Invocation (RMI) API [5].
Reference: [2] <author> K. Arnold and J. Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: By focusing on the interoperability of just two languages with complementary as well as similar features, we hope to expand the domain of applications that can receive the benefits of distributed object technology. Both the Ada [1] and Java <ref> [2] </ref> languages include support for distributed object technology. In Ada this support is specified in Annex E and in Java it is provided by the Java Remote Method Invocation (RMI) API [5].
Reference: [3] <editor> DEC, HP, and et al. </editor> <title> The common object request broker : architecture and specification. </title> <type> Technical Report OMG 91-12-1, </type> <institution> Object Management Group and X Open, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Because of this, distributed object technology is currently principally evolving under the auspices of architectures and frameworks such as CORBA <ref> [3] </ref> and DCOM [6], which can combine objects (or programs) written in any language providing interfaces satisfying their specifications. Typically this involves binding to the CORBA IDL or using variations of remote procedure call as provided by DCE [4].
Reference: [4] <author> Open Software Foundation. </author> <title> OSF DCE User's Guide and Reference: Revision 1.0. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Typically this involves binding to the CORBA IDL or using variations of remote procedure call as provided by DCE <ref> [4] </ref>. By focusing on the interoperability of just two languages with complementary as well as similar features, we hope to expand the domain of applications that can receive the benefits of distributed object technology. Both the Ada [1] and Java [2] languages include support for distributed object technology.
Reference: [5] <author> Sun Microsystems Inc. </author> <title> Java Remote Method Invocation Specification, Revision 0.9, </title> <year> 1996. </year>
Reference-contexts: Both the Ada [1] and Java [2] languages include support for distributed object technology. In Ada this support is specified in Annex E and in Java it is provided by the Java Remote Method Invocation (RMI) API <ref> [5] </ref>. While publication of the Annex E specification preceded the RMI specification by some four years, there is a remarkable similarity between the underlying objectives and semantic models of the two specifications.
Reference: [6] <author> Microsoft. </author> <title> Distributed Common Object Model. </title>
Reference-contexts: Because of this, distributed object technology is currently principally evolving under the auspices of architectures and frameworks such as CORBA [3] and DCOM <ref> [6] </ref>, which can combine objects (or programs) written in any language providing interfaces satisfying their specifications. Typically this involves binding to the CORBA IDL or using variations of remote procedure call as provided by DCE [4].
Reference: [7] <author> Gargaro Kermarrec Nana Pautet Smith Tardieu Theriault Volz & Waldrop. </author> <type> Adept technical report. Technical report, </type> <institution> Texas A&M University, </institution> <year> 1995. </year> <note> 93 94 BIBLIOGRAPHY </note>
Reference-contexts: Return results must be unmarshaled, again in the same manner as an Ada calling stub. In effect, the JxStubs mimic Ada calling stubs. A further discussion of GNAT Ada calling stubs, can be found in the ADEPT Users Guide: <ref> [7] </ref>. In this subsection, a more detailed example of a Java Exchange Stub is given and described. A discussion of design issues related to JxStub stub design is also presented. More complicated examples of JxStub classes are given in Chapter 5. <p> Run the distributed Ada program. Additional details are described below, relating to how the Ada program can gain accessibility to the JxAgent. 3. Run a Java client application or applet. Each step is described in more detail below. 1 See the ADEPT Users' Guide <ref> [7] </ref> 7.4. USAGE 79 Run the JxAgent The most efficient location to run the JxAgent on is a host which is also running the most frequently called Ada partition, though this is not necessary. <p> PROTOTYPE CAPABILITIES Note that the ADEPT/GNAT PCS library supports this facility, but that other PCS implementations may not. The information supplied by the JxAgent variable will be put into the address table on the lead partition <ref> [7] </ref>, but otherwise not used until a JxPost call is made. Since JxPost calls are usually made during elaboration however, this means that the JxAgent should be started before the Ada application.
References-found: 7

