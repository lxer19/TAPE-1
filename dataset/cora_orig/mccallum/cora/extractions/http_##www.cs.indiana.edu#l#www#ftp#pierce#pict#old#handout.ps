URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pict/old/handout.ps
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/pict/old/
Root-URL: http://www.cs.indiana.edu
Email: benjamin.pierce@cl.cam.ac.uk  
Title: Programming in the Pi-Calculus An Experiment in Concurrent Language Design Tutorial Notes for Pict Version 3.6b  
Author: Benjamin C. Pierce 
Date: November 13, 1995  
Address: New Museums Site Pembroke Street Cambridge CB2 3QG United Kingdom  
Affiliation: Computer Laboratory  
Abstract-found: 0
Intro-found: 0
Reference: [AC93] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> A preliminary version appeared in POPL '91 (pp. 104-118), and as DEC Systems Research Center Research Report number 62, </note> <month> August </month> <year> 1990. </year>
Reference: [Agh86] <author> Gul A. Agha. </author> <title> Actors: a Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference: [AP90] <author> M Abadi and G. D. Plotkin. </author> <title> A PER model of polymorphism and recursive types. </title> <booktitle> In Proc. IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 355-365, </pages> <year> 1990. </year>
Reference: [BM92] <author> Kim Bruce and John Mitchell. </author> <title> PER models of subtyping, recursive types and higher-order polymorphism. </title> <booktitle> In Proceedings of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albequerque, NM, </address> <month> January </month> <year> 1992. </year>
Reference: [Bou92] <author> Gerard Boudol. </author> <title> Asynchrony and the -calculus (note). </title> <institution> Rapporte de Recherche 1702, INRIA Sofia-Antipolis, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: For example: run print!"peering" | print!"absorbing" | print!"translating" peering translating 1 Readers familiar with the theoretical literature will notice that the language presented here is not precisely the usual formulation of the -calculus. The primary differences are: (1) like the systems of Honda and Tokoro [HT91] and Boudol <ref> [Bou92] </ref>, output in this fragment is asynchronous: the sender cannot tell when it has actually occurred; (2) channels are typed; and (3) the polyadic -calculus is slightly generalized to allow the communication not only of tuples of channels, but of tuples of tuples, etc.
Reference: [Bru94] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design, static typing and semantics. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2), </volume> <month> April </month> <year> 1994. </year> <title> A preliminary version appeared in POPL 1993 under the title "Safe Type Checking in a Statically Typed Object-Oriented Programming Language". </title>
Reference-contexts: The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog [NM88], and in Cardelli's implementation of F [Car93]). The treatment of subtyping and higher-order polymorphism is based on recent papers on static type systems for object-oriented languages <ref> [Car84, Bru94, CCH + 89, CHC90, PT94, FM94, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS95b, Com94]. The rules for channel types come from Pierce and Sangiorgi's type system for the pure -calculus [PS95a].
Reference: [Car84] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In G. Kahn, D. MacQueen, and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <note> Full version in Information and Computation </note> 76(2/3):138-164, 1988. 
Reference-contexts: The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog [NM88], and in Cardelli's implementation of F [Car93]). The treatment of subtyping and higher-order polymorphism is based on recent papers on static type systems for object-oriented languages <ref> [Car84, Bru94, CCH + 89, CHC90, PT94, FM94, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS95b, Com94]. The rules for channel types come from Pierce and Sangiorgi's type system for the pure -calculus [PS95a].
Reference: [Car86] <author> Luca Cardelli. </author> <title> Amber. </title> <editor> In Guy Cousineau, Pierre-Louis Curien, and Bernard Robinet, editors, </editor> <booktitle> Combinators and Functional Programming Languages, </booktitle> <pages> pages 21-47. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> Lecture Notes in Computer Science No. 242. </note>
Reference-contexts: 5 Core Type System The type system of Pict has its roots in the theoretical literature on type systems for the - calculus [Mil91, Tur95, PS95a, Gay93] and for functional languages, among which the most immediate predecessors to Pict are ml [GMW79, MTH90, WAL + 89], quest [Car91], and amber <ref> [Car86] </ref>. The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog [NM88], and in Cardelli's implementation of F [Car93]).
Reference: [Car89] <author> Felice Cardone. </author> <title> Relational semantics for recursive types and bounded quantification. </title> <booktitle> In Proceedings of the Sixteenth International Colloquium on Automata, Languages, and Programming, volume 372 of Lecture Notes in Computer Science, </booktitle> <pages> pages 164-178, </pages> <address> Stresa, Italy, July 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference: [Car90] <author> Luca Cardelli. </author> <title> Notes about F ! &lt;: </title> . <type> Unpublished manuscript, </type> <month> October </month> <year> 1990. </year>
Reference-contexts: The treatment of subtyping and higher-order polymorphism is based on recent papers on static type systems for object-oriented languages [Car84, Bru94, CCH + 89, CHC90, PT94, FM94, etc.] and the -calculus F ! <ref> [Car90, Mit90, PS95b, Com94] </ref>. The rules for channel types come from Pierce and Sangiorgi's type system for the pure -calculus [PS95a]. The rules for records are new, but may be regarded as a simplified fragment of the systems described by Cardelli and Mitchell [CM91].
Reference: [Car91] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> An earlier version appeared as DEC Systems Research Center Research Report #45, </note> <month> February </month> <year> 1989. </year>
Reference-contexts: 107.] 45 Chapter 5 Core Type System The type system of Pict has its roots in the theoretical literature on type systems for the - calculus [Mil91, Tur95, PS95a, Gay93] and for functional languages, among which the most immediate predecessors to Pict are ml [GMW79, MTH90, WAL + 89], quest <ref> [Car91] </ref>, and amber [Car86]. The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog [NM88], and in Cardelli's implementation of F [Car93]).
Reference: [Car93] <author> Luca Cardelli. </author> <title> An implementation of F &lt;: </title> . <type> Research report 97, </type> <institution> DEC Systems Research Center, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog [NM88], and in Cardelli's implementation of F <ref> [Car93] </ref>). The treatment of subtyping and higher-order polymorphism is based on recent papers on static type systems for object-oriented languages [Car84, Bru94, CCH + 89, CHC90, PT94, FM94, etc.] and the -calculus F ! [Car90, Mit90, PS95b, Com94].
Reference: [CC91] <author> Felice Cardone and Mario Coppo. </author> <title> Type inference with recursive types. Syntax and semantics. </title> <journal> Information and Computation, </journal> <volume> 92(1) </volume> <pages> 48-80, </pages> <year> 1991. </year> <month> 115 </month>
Reference: [CCH + 89] <author> Peter Canning, William Cook, Walter Hill, Walter Olthoff, and John Mitchell. </author> <title> F-bounded quan-tification for object-oriented programming. </title> <booktitle> In Fourth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog [NM88], and in Cardelli's implementation of F [Car93]). The treatment of subtyping and higher-order polymorphism is based on recent papers on static type systems for object-oriented languages <ref> [Car84, Bru94, CCH + 89, CHC90, PT94, FM94, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS95b, Com94]. The rules for channel types come from Pierce and Sangiorgi's type system for the pure -calculus [PS95a].
Reference: [CG92] <author> Pierre-Louis Curien and Giorgio Ghelli. </author> <title> Coherence of subsumption: Minimum typing and type-checking in F . Mathematical Structures in Computer Science, </title> <booktitle> 2 </booktitle> <pages> 55-91, </pages> <year> 1992. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference: [CHC90] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog [NM88], and in Cardelli's implementation of F [Car93]). The treatment of subtyping and higher-order polymorphism is based on recent papers on static type systems for object-oriented languages <ref> [Car84, Bru94, CCH + 89, CHC90, PT94, FM94, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS95b, Com94]. The rules for channel types come from Pierce and Sangiorgi's type system for the pure -calculus [PS95a].
Reference: [Chu41] <author> Alonzo Church. </author> <title> The Calculi of Lambda Conversion. </title> <publisher> Princeton University Press, </publisher> <year> 1941. </year>
Reference-contexts: the Computer Laboratory, University of Cambridge, with support from Confer and from the British Science and Engineering Research Council. 5 Chapter 1 Processes and Channels The -calculus of Milner, Parrow, and Walker [MPW92] can be compared to the -calculus developed by Church and his students in the 1920's and 30's <ref> [Chu41] </ref>. Though it predates computer science itself, the -calculus has come to be regarded as a canonical calculus capturing the notion of sequential computation in a clean, mathematically tractable presentation.
Reference: [CM91] <author> Luca Cardelli and John Mitchell. </author> <title> Operations on records. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 1 </volume> <pages> 3-48, </pages> <year> 1991. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design (MIT Press, </title> <note> 1994); available as DEC Systems Research Center Research Report #48, </note> <month> August, </month> <year> 1989, </year> <booktitle> and in the proceedings of MFPS '89, </booktitle> <publisher> Springer LNCS volume 442. </publisher>
Reference-contexts: The rules for channel types come from Pierce and Sangiorgi's type system for the pure -calculus [PS95a]. The rules for records are new, but may be regarded as a simplified fragment of the systems described by Cardelli and Mitchell <ref> [CM91] </ref>. An early version of the Pict type system was described in [PRT93]. 5.1 Notation Since a value may contain free variables, its type may depend on the types of these variables. For example, the value [x,y] has the type [^[],^[]] if x and y both have type ^[].
Reference: [CMMS94] <author> Luca Cardelli, Simone Martini, John C. Mitchell, and Andre Scedrov. </author> <title> An extension of system F with subtyping. </title> <journal> Information and Computation, </journal> <note> 109(1-2):4-56, 1994. A preliminary version appeared in TACS '91 (Sendai, Japan, pp. 750-770). </note>
Reference: [Com94] <author> Adriana B. Compagnoni. </author> <title> Subtyping in F ! ^ is decidable. </title> <type> Technical Report ECS-LFCS-94-281, </type> <institution> LFCS, University of Edinburgh, </institution> <month> January </month> <year> 1994. </year> <note> To appear in the proceedings of Computer Science Logic, </note> <month> September </month> <year> 1994, </year> <title> under the title "Decidability of Higher-Order Subtyping with Intersection Types". </title>
Reference-contexts: The treatment of subtyping and higher-order polymorphism is based on recent papers on static type systems for object-oriented languages [Car84, Bru94, CCH + 89, CHC90, PT94, FM94, etc.] and the -calculus F ! <ref> [Car90, Mit90, PS95b, Com94] </ref>. The rules for channel types come from Pierce and Sangiorgi's type system for the pure -calculus [PS95a]. The rules for records are new, but may be regarded as a simplified fragment of the systems described by Cardelli and Mitchell [CM91].
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4), </volume> <month> December </month> <year> 1985. </year>
Reference: [dB72] <author> Nicolas G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5):381 392, </volume> <year> 1972. </year>
Reference-contexts: Technically, these conventions can be captured by transforming an abstract syntax tree to a nameless form in which free occurrences of variables are replaced by direct pointers to the corresponding binding occurrences <ref> [dB72] </ref>. We shall not perform this translation formally, though, since it would result in unwieldy notation. We use the notation FV (e) for the set of variables appearing free in an expression e.
Reference: [DM82] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <year> 1982. </year>
Reference: [FM94] <author> Kathleen Fisher and John Mitchell. </author> <booktitle> Notes on typed object-oriented programming. In Proceedings of Theoretical Aspects of Computer Software, Sendai, Japan, </booktitle> <pages> pages 844-885. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year> <note> LNCS 789. </note>
Reference-contexts: The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog [NM88], and in Cardelli's implementation of F [Car93]). The treatment of subtyping and higher-order polymorphism is based on recent papers on static type systems for object-oriented languages <ref> [Car84, Bru94, CCH + 89, CHC90, PT94, FM94, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS95b, Com94]. The rules for channel types come from Pierce and Sangiorgi's type system for the pure -calculus [PS95a].
Reference: [Gay93] <author> Simon J. Gay. </author> <title> A sort inference algorithm for the polyadic -calculus. </title> <booktitle> In Proceedings of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference-contexts: Worker 2 working Worker 2 working Worker 2 finished Worker 1 starting Worker 1 working Worker 1 working Worker 1 finished [Solution on page 107.] 45 Chapter 5 Core Type System The type system of Pict has its roots in the theoretical literature on type systems for the - calculus <ref> [Mil91, Tur95, PS95a, Gay93] </ref> and for functional languages, among which the most immediate predecessors to Pict are ml [GMW79, MTH90, WAL + 89], quest [Car91], and amber [Car86].
Reference: [Ghe93] <author> Giorgio Ghelli. </author> <title> Recursive types are not conservative over F . In Typed Lambda Calculus and Applications, </title> <month> March </month> <year> 1993. </year>
Reference: [Ghe95] <author> Giorgio Ghelli. </author> <title> Divergence of F type checking. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 139(1,2):131-162, </address> <year> 1995. </year>
Reference: [GMW79] <author> Michael J. Gordon, Robin Milner, and Christopher P. </author> <title> Wadsworth. </title> <publisher> Edinburgh LCF. Springer Verlag LNCS 78, </publisher> <year> 1979. </year>
Reference-contexts: Worker 1 finished [Solution on page 107.] 45 Chapter 5 Core Type System The type system of Pict has its roots in the theoretical literature on type systems for the - calculus [Mil91, Tur95, PS95a, Gay93] and for functional languages, among which the most immediate predecessors to Pict are ml <ref> [GMW79, MTH90, WAL + 89] </ref>, quest [Car91], and amber [Car86]. The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog [NM88], and in Cardelli's implementation of F [Car93]).
Reference: [GP95] <author> Giorgio Ghelli and Benjamin Pierce. </author> <title> Bounded existentials and minimal typing. </title> <note> Submitted for publication, </note> <month> March </month> <year> 1995. </year> <month> 116 </month>
Reference: [Hew77] <author> C. Hewitt. </author> <title> Viewing control structures as patterns of passing messages. </title> <journal> Artificial Intelligence, </journal> <volume> 8 </volume> <pages> 323-364, </pages> <year> 1977. </year> <title> Influential description of a method for implementing distributed control structures: the ACTOR paradigm. </title>
Reference: [HP95] <author> Martin Hofmann and Benjamin Pierce. </author> <title> A unifying type-theoretic framework for objects. </title> <journal> Journal of Functional Programming, </journal> <note> 1995. To appear. Previous versions appeared in the Symposium on Theoretical Aspects of Computer Science, </note> <year> 1994, </year> <title> (pages 251-262) and, under the title "An Abstract View of Objects and Subtyping (Preliminary Report)," as University of Edinburgh, </title> <type> LFCS technical report ECS-LFCS-92-226, </type> <year> 1992. </year>
Reference: [HT91] <author> Kohei Honda and Mario Tokoro. </author> <title> An object calculus for asynchronous communication. </title> <editor> In Pierre America, editor, </editor> <booktitle> Proceedings of the European Conference on Object-Oriented Programming (ECOOP), volume 512 of Lecture Notes in Computer Science, </booktitle> <address> Geneva CH, 1991. </address> <publisher> Springer-Verlag , Berlin, </publisher> <address> Heidelberg, New York, Tokyo. </address>
Reference-contexts: For example: run print!"peering" | print!"absorbing" | print!"translating" peering translating 1 Readers familiar with the theoretical literature will notice that the language presented here is not precisely the usual formulation of the -calculus. The primary differences are: (1) like the systems of Honda and Tokoro <ref> [HT91] </ref> and Boudol [Bou92], output in this fragment is asynchronous: the sender cannot tell when it has actually occurred; (2) channels are typed; and (3) the polyadic -calculus is slightly generalized to allow the communication not only of tuples of channels, but of tuples of tuples, etc.
Reference: [Jon93] <author> Cliff B. Jones. </author> <title> A pi-calculus semantics for an object-based design notation. </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings of CONCUR'93, </booktitle> <volume> LNCS 715, </volume> <pages> pages 158-172. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: [KPS93] <author> Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Efficient recursive subtyping. </title> <booktitle> In Proceedings POPL '93, </booktitle> <pages> pages 419-428, </pages> <year> 1993. </year>
Reference: [Lan66] <author> P. J. Landin. </author> <title> The next 700 programming languages. </title> <journal> Communications of the ACM, </journal> <volume> 9(3) </volume> <pages> 157-166, </pages> <month> March </month> <year> 1966. </year>
Reference-contexts: Many of the fundamental issues of sequential programming languages can be studied by considering them in the more abstract setting of the -calculus. Conversely, the -calculus has influenced the design of numerous programming languages, notably Landin's ISWIM <ref> [Lan66] </ref> and McCarthy's LISP [McC78]. The -calculus represents a synthesis and generalization of many years of work on CCS and its relatives [Mil80, Mil89, etc.]. In the concurrency community, the -calculus and similar "modern process calculi" are widely studied, and a substantial body of theoretical work has been accumulated.
Reference: [McC78] <author> John McCarthy. </author> <title> History of Lisp. </title> <booktitle> In Proceedings of the first ACM conference on History of Programming Languages, </booktitle> <pages> pages 217-223, </pages> <year> 1978. </year> <journal> ACM Sigplan Notices, </journal> <volume> Vol. 13, No 8, </volume> <month> August </month> <year> 1978. </year>
Reference-contexts: Many of the fundamental issues of sequential programming languages can be studied by considering them in the more abstract setting of the -calculus. Conversely, the -calculus has influenced the design of numerous programming languages, notably Landin's ISWIM [Lan66] and McCarthy's LISP <ref> [McC78] </ref>. The -calculus represents a synthesis and generalization of many years of work on CCS and its relatives [Mil80, Mil89, etc.]. In the concurrency community, the -calculus and similar "modern process calculi" are widely studied, and a substantial body of theoretical work has been accumulated.
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <month> August </month> <year> 1978. </year>
Reference: [Mil80] <author> Robin Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1980. </year>
Reference-contexts: Conversely, the -calculus has influenced the design of numerous programming languages, notably Landin's ISWIM [Lan66] and McCarthy's LISP [McC78]. The -calculus represents a synthesis and generalization of many years of work on CCS and its relatives <ref> [Mil80, Mil89, etc.] </ref>. In the concurrency community, the -calculus and similar "modern process calculi" are widely studied, and a substantial body of theoretical work has been accumulated.
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Conversely, the -calculus has influenced the design of numerous programming languages, notably Landin's ISWIM [Lan66] and McCarthy's LISP [McC78]. The -calculus represents a synthesis and generalization of many years of work on CCS and its relatives <ref> [Mil80, Mil89, etc.] </ref>. In the concurrency community, the -calculus and similar "modern process calculi" are widely studied, and a substantial body of theoretical work has been accumulated. <p> These structures can be added, yielding a somewhat more complex system that nevertheless remains theoretically tractable <ref> [Mil89] </ref>. But value-passing CCS lacks another fundamental property: the ability to perform higher-order programming. For example the fundamental operation of constructing process networks by connecting processes and channels cannot be expressed in CCS, with or without values.
Reference: [Mil90] <author> Robin Milner. </author> <title> Functions as processes. </title> <type> Research Report 1154, </type> <institution> INRIA, Sofia Antipolis, </institution> <year> 1990. </year> <note> Final version in Journal of Mathematical Structures in Computer Science 2(2) 119-141, </note> <year> 1992. </year>
Reference-contexts: Basic algebraic datatypes like numbers, queues, and trees can be encoded as processes, using techniques reminiscent of Church's encodings in the -calculus. Indeed, the -calculus itself can be encoded fairly straightforwardly by considering fi-reduction as a kind of communication <ref> [Mil90] </ref>.
Reference: [Mil91] <author> Robin Milner. </author> <title> The polyadic -calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> October </month> <year> 1991. </year> <booktitle> Proceedings of the International Summer School on Logic and Algebra of Specification, Marktoberdorf, </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: Worker 2 working Worker 2 working Worker 2 finished Worker 1 starting Worker 1 working Worker 1 working Worker 1 finished [Solution on page 107.] 45 Chapter 5 Core Type System The type system of Pict has its roots in the theoretical literature on type systems for the - calculus <ref> [Mil91, Tur95, PS95a, Gay93] </ref> and for functional languages, among which the most immediate predecessors to Pict are ml [GMW79, MTH90, WAL + 89], quest [Car91], and amber [Car86].
Reference: [Mil92] <author> Robin Milner. </author> <title> Action structures. </title> <type> Technical Report ECS-LFCS-92-249, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: Milner himself is now considering much more refined systems <ref> [Mil92] </ref>, and heated discussion continues in the concurrency community as to what should constitute a general theory of concurrency. Nevertheless, it seems we've reached a good point to begin experimenting.
Reference: [Mit90] <author> John C. Mitchell. </author> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Proceedings of the 17th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-124, </pages> <month> January </month> <year> 1990. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year>
Reference-contexts: The treatment of subtyping and higher-order polymorphism is based on recent papers on static type systems for object-oriented languages [Car84, Bru94, CCH + 89, CHC90, PT94, FM94, etc.] and the -calculus F ! <ref> [Car90, Mit90, PS95b, Com94] </ref>. The rules for channel types come from Pierce and Sangiorgi's type system for the pure -calculus [PS95a]. The rules for records are new, but may be regarded as a simplified fragment of the systems described by Cardelli and Mitchell [CM91].
Reference: [MP88] <author> John Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <month> July </month> <year> 1988. </year>
Reference: [MPS86] <author> David MacQueen, Gordon Plotkin, and Ravi Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> <volume> 71 </volume> <pages> 95-130, </pages> <year> 1986. </year>
Reference: [MPW92] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes (Parts I and II). </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year> <month> 117 </month>
Reference-contexts: Work has continued at the University of Edinburgh and, later, at the Computer Laboratory, University of Cambridge, with support from Confer and from the British Science and Engineering Research Council. 5 Chapter 1 Processes and Channels The -calculus of Milner, Parrow, and Walker <ref> [MPW92] </ref> can be compared to the -calculus developed by Church and his students in the 1920's and 30's [Chu41]. Though it predates computer science itself, the -calculus has come to be regarded as a canonical calculus capturing the notion of sequential computation in a clean, mathematically tractable presentation.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: For example: run printi!'a' 97 4.2 Derived Forms for Declarations In this section, we extend the syntactic category of declarations with a number of handy constructs. (Readers familiar with Standard ML <ref> [MTH90] </ref> will recognize our debt to its designers here.) 4.2.1 Declaration Sequences First, to avoid writing long sequences of let ... in let ... in ..., we allow a Dec to consist of two Decs in sequence: Dec = ... <p> Worker 1 finished [Solution on page 107.] 45 Chapter 5 Core Type System The type system of Pict has its roots in the theoretical literature on type systems for the - calculus [Mil91, Tur95, PS95a, Gay93] and for functional languages, among which the most immediate predecessors to Pict are ml <ref> [GMW79, MTH90, WAL + 89] </ref>, quest [Car91], and amber [Car86]. The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog [NM88], and in Cardelli's implementation of F [Car93]).
Reference: [Nie92] <author> Oscar Nierstrasz. </author> <title> Towards an object calculus. </title> <editor> In M. Tokoro, O. Nierstrasz, and P. Wegner, editors, </editor> <booktitle> Proceedings of the ECOOP '91 Workshop on Object-Based Concurrent Computing, Lecture Notes in Computer Science number 612, </booktitle> <pages> pages 1-20. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [NM88] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Robert A. Kowalski and Ken-neth A. Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <volume> Volume 1, </volume> <pages> pages 810-827, </pages> <address> Cambridge, Massachusetts, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog <ref> [NM88] </ref>, and in Cardelli's implementation of F [Car93]). The treatment of subtyping and higher-order polymorphism is based on recent papers on static type systems for object-oriented languages [Car84, Bru94, CCH + 89, CHC90, PT94, FM94, etc.] and the -calculus F ! [Car90, Mit90, PS95b, Com94].
Reference: [Pap91] <author> M. Papathomas. </author> <title> A unifying framework for process calculus semantics of concurrent object-based languages and features. </title> <editor> In Dennis Tsichritzis, editor, </editor> <booktitle> Object composition Composition d'objets, </booktitle> <pages> pages 205-224. </pages> <institution> Centre Universitaire d'Informatique, Universite de Geneve, </institution> <month> [6] </month> <year> 1991. </year>
Reference: [PDM89] <author> Benjamin Pierce, Scott Dietzen, and Spiro Michaylov. </author> <title> Programming in higher-order typed lambda-calculi. </title> <type> Technical Report CMU-CS-89-111, </type> <institution> Carnegie Mellon University, </institution> <month> March </month> <year> 1989. </year>
Reference: [Pie94] <author> Benjamin C. Pierce. </author> <title> Bounded quantification is undecidable. </title> <journal> Information and Computation, </journal> <volume> 112(1) </volume> <pages> 131-165, </pages> <month> July </month> <year> 1994. </year> <editor> Also in Carl A. Gunter and John C. Mitchell, editors, </editor> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, </title> <publisher> and Language Design (MIT Press, </publisher> <year> 1994). </year> <note> A preliminary version appeared in POPL '92. </note>
Reference: [PRT93] <author> Benjamin C. Pierce, Didier Remy, and David N. Turner. </author> <title> A typed higher-order programming language based on the pi-calculus. In Workshop on Type Theory and its Application to Computer Systems, </title> <publisher> Kyoto University, </publisher> <month> July </month> <year> 1993. </year>
Reference-contexts: Didier Remy helped build the original Pic compiler (on which the first version of the present Pict compiler was based <ref> [PRT93] </ref>) and joined in many discussions about the integration of processes and functions. Uwe Nestmann's research on proof techniques for compilations between concurrent calculi sharpened our ideas about the formal foundations of Pict. Martin Steffen helped study the formal foundations of the core subtyping algorithm. <p> The rules for records are new, but may be regarded as a simplified fragment of the systems described by Cardelli and Mitchell [CM91]. An early version of the Pict type system was described in <ref> [PRT93] </ref>. 5.1 Notation Since a value may contain free variables, its type may depend on the types of these variables. For example, the value [x,y] has the type [^[],^[]] if x and y both have type ^[].
Reference: [PS95a] <author> Benjamin Pierce and Davide Sangiorgi. </author> <title> Typing and subtyping for mobile processes. </title> <note> Mathematical Structures in Computer Science, 1995. To appear. A summary was presented at LICS '93. </note>
Reference-contexts: From Davide Sangiorgi, we learned about the higher-order -calculus and the many ways of encoding -calculi in the -calculus; we also did a lot of thinking together about static type systems for the -calculus <ref> [PS95a] </ref>. Didier Remy helped build the original Pic compiler (on which the first version of the present Pict compiler was based [PRT93]) and joined in many discussions about the integration of processes and functions. <p> Worker 2 working Worker 2 working Worker 2 finished Worker 1 starting Worker 1 working Worker 1 working Worker 1 finished [Solution on page 107.] 45 Chapter 5 Core Type System The type system of Pict has its roots in the theoretical literature on type systems for the - calculus <ref> [Mil91, Tur95, PS95a, Gay93] </ref> and for functional languages, among which the most immediate predecessors to Pict are ml [GMW79, MTH90, WAL + 89], quest [Car91], and amber [Car86]. <p> The rules for channel types come from Pierce and Sangiorgi's type system for the pure -calculus <ref> [PS95a] </ref>. The rules for records are new, but may be regarded as a simplified fragment of the systems described by Cardelli and Mitchell [CM91].
Reference: [PS95b] <author> Benjamin Pierce and Martin Steffen. </author> <title> Higher-order subtyping. </title> <note> Submitted for publication. A preliminary version appeared in IFIP Working Conference on Programming Concepts, Methods and Calculi (PROCOMET), June 1994, and as University of Edinburgh technical report ECS-LFCS-94-280 and Universitat Erlangen-Nurnberg Interner Bericht IMMD7-01/94, </note> <month> January </month> <year> 1994., 1995. </year>
Reference-contexts: The treatment of subtyping and higher-order polymorphism is based on recent papers on static type systems for object-oriented languages [Car84, Bru94, CCH + 89, CHC90, PT94, FM94, etc.] and the -calculus F ! <ref> [Car90, Mit90, PS95b, Com94] </ref>. The rules for channel types come from Pierce and Sangiorgi's type system for the pure -calculus [PS95a]. The rules for records are new, but may be regarded as a simplified fragment of the systems described by Cardelli and Mitchell [CM91].
Reference: [PT94] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> April </month> <year> 1994. </year> <note> A preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Programming Without Recursive Types". </title>
Reference-contexts: The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog [NM88], and in Cardelli's implementation of F [Car93]). The treatment of subtyping and higher-order polymorphism is based on recent papers on static type systems for object-oriented languages <ref> [Car84, Bru94, CCH + 89, CHC90, PT94, FM94, etc.] </ref> and the -calculus F ! [Car90, Mit90, PS95b, Com94]. The rules for channel types come from Pierce and Sangiorgi's type system for the pure -calculus [PS95a].
Reference: [PT95] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Concurrent objects in a process calculus. </title> <editor> In Takayasu Ito and Akinori Yonezawa, editors, </editor> <booktitle> Theory and Practice of Parallel Programming (TPPP), Sendai, </booktitle> <address> Japan (Nov. </address> <year> 1994), </year> <booktitle> number 907 in Lecture Notes in Computer Science, </booktitle> <pages> pages 187-215. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1995. </year>
Reference: [Rep88] <author> John Reppy. </author> <title> Synchronous operations as first-class values. </title> <booktitle> In Programming Language Design and Implementation, </booktitle> <pages> pages 250-259. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <year> 1988. </year>
Reference: [Rep90] <author> John Reppy. </author> <title> Concurrent Programming with Events. </title> <institution> Cornell University, </institution> <month> November </month> <year> 1990. </year> <note> the Concurrent ML Manual (Version 0.9). </note>
Reference: [Rep91] <author> John Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In Programming Language Design and Implementation, </booktitle> <pages> pages 293-259. </pages> <booktitle> SIGPLAN, ACM, </booktitle> <month> June </month> <year> 1991. </year>
Reference: [Rep92] <author> John Reppy. </author> <title> Higher-Order Concurrency. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> June </month> <year> 1992. </year> <type> Technical Report TR 92-1285. </type>
Reference: [Rep95] <author> John H. Reppy. </author> <title> First-class synchronous operations. </title> <editor> In Takayasu Ito and Akinori Yonezawa, editors, </editor> <booktitle> Theory and Practice of Parallel Programming (TPPP), Sendai, </booktitle> <address> Japan (Nov. </address> <year> 1994), </year> <booktitle> number 907 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1995. </year> <month> 118 </month>
Reference: [Tur95] <author> David N. Turner, </author> <year> 1995. </year> <type> Ph.D. thesis, </type> <institution> LFCS, University of Edinburgh. </institution> <note> In preparation. </note>
Reference-contexts: Worker 2 working Worker 2 working Worker 2 finished Worker 1 starting Worker 1 working Worker 1 working Worker 1 finished [Solution on page 107.] 45 Chapter 5 Core Type System The type system of Pict has its roots in the theoretical literature on type systems for the - calculus <ref> [Mil91, Tur95, PS95a, Gay93] </ref> and for functional languages, among which the most immediate predecessors to Pict are ml [GMW79, MTH90, WAL + 89], quest [Car91], and amber [Car86].
Reference: [TW93] <author> Jerzy Tiuryn and Mitchell Wand. </author> <title> Type reconstruction with recursive types and atomic subtyping. </title> <booktitle> In Proceedings of TAPSOFT '93, </booktitle> <pages> pages 686-701, </pages> <year> 1993. </year>
Reference: [Vas94] <author> Vasco T. Vasconcelos. </author> <title> Typed concurrent objects. </title> <booktitle> In Proceedings of the Eighth European Conference on Object-Oriented Programming (ECOOP), volume 821 of Lecture Notes in Computer Science, </booktitle> <pages> pages 100-117. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1994. </year>
Reference: [WAL + 89] <author> Pierre Weis, Mara-Virginia Aponte, Alain Laville, Michel Mauny, and Ascander Suarez. </author> <title> The CAML reference manual, Version 2.6. </title> <type> Technical report, </type> <institution> Projet Formel, INRIA-ENS, </institution> <year> 1989. </year>
Reference-contexts: Worker 1 finished [Solution on page 107.] 45 Chapter 5 Core Type System The type system of Pict has its roots in the theoretical literature on type systems for the - calculus [Mil91, Tur95, PS95a, Gay93] and for functional languages, among which the most immediate predecessors to Pict are ml <ref> [GMW79, MTH90, WAL + 89] </ref>, quest [Car91], and amber [Car86]. The type inference technique introduced in Chapter 9 is similar to the ones used in lego [?], -prolog [NM88], and in Cardelli's implementation of F [Car93]).
Reference: [Wal94] <author> David Walker. </author> <title> Algebraic proofs of properties of objects. </title> <booktitle> In Proceedings of European Symposium on Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [Wan87] <author> Mitchell Wand. </author> <title> Complete type inference for simple objects. </title> <booktitle> In Proceedings of the IEEE Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <month> June </month> <year> 1987. </year> <month> 119 </month>
References-found: 68

