URL: http://http.cs.berkeley.edu/~neefe/netram.ps
Refering-URL: http://http.cs.berkeley.edu/~neefe/class_proj.html
Root-URL: 
Title: An Exploration of Network RAM  
Author: Eric A. Anderson Jeanna M. Neefe 
Keyword: network RAM, remote memory paging, reliability, user-level implementation  
Address: Berkeley, CA 94720  
Affiliation: Computer Science Division University of California at Berkeley  
Email: eanders,neefe@cs.berkeley.edu  
Phone: 1-510-642-8284  
Date: February 4, 1995  
Abstract: The goal of network RAM is to improve the performance of memory intensive workloads by paging to idle memory over the network rather than to disk. In this paper, we reexamine common assumptions about network RAM, compare possible implementations, describe the structure and performance of our user-level implementation and investigate various methods for providing reliability.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anderson, T.E.; Culler, D.E.; Patterson, D.A et al.; </author> <title> "A Case for NOW (Networks of Workstations)", </title> <month> November </month> <year> 1994. </year>
Reference-contexts: Until achievable network bandwidths get much faster, the time to bring pages into the network will limit the types of programs that can effectively use network RAM. 1.3 Most machines have free memory One goal for network RAM is to use it in a NOW <ref> [1] </ref>. While right now most of the workstations on a network are idle, it is unclear that once a parallel work 3 load, and a file system which caches on client nodes are added to the sequential workload that there will still be sufficient free workstations and therefore free memory.
Reference: [2] <author> Asami, S., </author> <title> "Evaluating Network RAM via Paging", </title> <journal> NOW Retreat Presen tation slides, </journal> <month> June </month> <year> 1994. </year>
Reference: [3] <author> Carter, L.; Ferrante, J.; Hummel S. </author> <title> "Hierarchical Tiling: A Framework for Multi-level parallelism and Locality." </title>
Reference-contexts: This implementation would require user code to explicitly move data back and forth from either the disk or 4 the network. This idea requires substantial code modification, but it is being explored as a possible technique for compilers. Carter <ref> [3] </ref> shows that substantial speedup can be achieved by considering all levels of the memory hierarchy from registers to disk. This solution is likely to have the best performance because it deals with the entire memory hierarchy and has the most high level knowledge about data use patterns.
Reference: [4] <author> Chan, T. and Hsu, W., </author> <title> "PRIME: Paging to Remote Idle MEmory", </title> <address> SCAMD, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: After examining these choices, we decided to do a user-level implementation. We believed that explicit program management would be to hard to convince people to use, and that modifying the kernel or building a network interface would not be practical during a single semester. Two other groups <ref> [7, 4] </ref> were already doing implementations as device drivers, so a user level implementation would allow for comparisons. We felt that the portability advantages, and the lower risk to 6 the operating system made our solution attractive for both experimentation and use. <p> We attempted to compare our non-communication overhead with the measurements of other groups. Mainwaring, Wright and Yoshikawa [7] measured an overhead of about 1 ms for their implementation of a device driver plus process for Solaris 2.3. Chan and Hsu <ref> [4] </ref> measured a total time of about 3 ms to retrieve a page in their implementation on Solaris 2.3. Because they used active messages, their time was smaller than other groups. Unfortunately, they have not yet had a chance to measure their minimal overhead.
Reference: [5] <author> Iftode, L., Li, K., and Petersen, K., </author> <title> "Memory Servers for Multicomputers", </title> <year> 1993. </year>
Reference: [6] <author> Felten, E.W. and Zahorjan, J., </author> <title> "Issues in the Implementation of a Remote Memory Paging System", </title> <month> March </month> <year> 1991. </year>
Reference: [7] <author> Mainwaring, A., Wright, K., Yoshikawa, C., </author> <title> "The Design and Implementa tion of a Network RAM Prototype", </title> <month> November </month> <year> 1994. </year>
Reference-contexts: After examining these choices, we decided to do a user-level implementation. We believed that explicit program management would be to hard to convince people to use, and that modifying the kernel or building a network interface would not be practical during a single semester. Two other groups <ref> [7, 4] </ref> were already doing implementations as device drivers, so a user level implementation would allow for comparisons. We felt that the portability advantages, and the lower risk to 6 the operating system made our solution attractive for both experimentation and use. <p> We expect the time for the faster machines will drop once a more efficient protocol than TCP is used. We attempted to compare our non-communication overhead with the measurements of other groups. Mainwaring, Wright and Yoshikawa <ref> [7] </ref> measured an overhead of about 1 ms for their implementation of a device driver plus process for Solaris 2.3. Chan and Hsu [4] measured a total time of about 3 ms to retrieve a page in their implementation on Solaris 2.3. <p> At the device driver level there is no notion of what pages are being sent out, so Mainwaring, et. al <ref> [7] </ref> had trouble with OS code being paged out.
Reference: [8] <author> Mc Namee, D.; Armstrong, K. </author> <title> "Extending the Mach external pager inter face to accomodate user-level page replaceemnt policies." </title> <booktitle> USENIX Workshop Proceedings: Mach. </booktitle> <year> 1990. </year>
Reference-contexts: This solution is possible in the operating system Mach <ref> [8] </ref>, which allows a user level program to handle moving pages to and from second-level storage. The dependence on Mach makes this solution rather un-portable. This solution's overhead is probably similar to the overhead of the device driver and user-level process solution. * Device Driver.
Reference: [9] <author> Nguyen, G. and Oza N., </author> <title> "On the Use of Network DRAM in LAPACK Programs", </title> <month> November </month> <year> 1994. </year>
Reference: [10] <author> Nitzberg, B. and Lo, V., </author> <title> "Distributed Shared Memory: A Survey of Issues and Algorithms", </title> <month> August </month> <year> 1991. </year>
Reference: [11] <author> Shi, J.; Xi, J. </author> <title> "Paging across network: a study of queuing effect", </title> <month> November </month> <year> 1994. </year>
References-found: 11

