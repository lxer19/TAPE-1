URL: http://http.icsi.berkeley.edu/~luby/PAPERS/selftestcorrect.ps
Refering-URL: http://http.icsi.berkeley.edu/~luby/self.html
Root-URL: http://http.icsi.berkeley.edu
Title: Self-Testing/Correcting with Applications to Numerical Problems  
Author: Manuel Blum Michael Luby Ronitt Rubinfeld 
Abstract: Suppose someone gives us an extremely fast program P that we can call as a black box to compute a function f. Should we trust that P works correctly? A self-testing/correcting pair for f allows us to: (1) estimate the probability that P (x) 6= f(x) when x is randomly chosen; (2) on any input x, compute f(x) correctly as long as P is not too faulty on average. Furthermore, both (1) and (2) take time only slightly more than the original running time of P . We present general techniques for constructing simple to program self-testing/correcting pairs for a variety of numerical functions, including integer multiplication, modular multiplication, matrix multiplication, inverting matrices, computing the determinant of a matrix, computing the rank of a matrix, integer division, modular exponentiation and polynomial multiplication. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Adleman, L., Huang, M., Kompella, K., </author> <title> "Efficient Checkers for Number-Theoretic Computations", </title> <note> Submitted to Information and Computation. </note>
Reference-contexts: A result checker for f implies a self-tester for f , but it is not known whether a result checker also implies a self-corrector. Previous to our work, [23, Kaminski] gives result checkers for integer and polynomial multiplication. Independently of our work, <ref> [1, Adleman Huang Kompella] </ref> give result checkers for integer multiplication and modular exponentiation. Both of these papers use very different techniques than ours. Previous to our work, [20, Freivalds] introduces a result checker for matrix multiplication over a finite field. <p> PROOF: Similar to the proof of Theorem 11 (page 35). The incremental and total time of Mod Expon Bootstrap Self-Test are linear in the incremental and total time of Mod ExpSC (n; R; fi= log (n)), respectively. <ref> [1, Adleman Huang Kompella] </ref> have independently discovered a method of result checking the exponentiation function without the restriction that a and R be relatively prime. Their method uses similar ideas of testing by bootstrapping.
Reference: [2] <author> Aho, A., Hopcroft, J., Ullman, J., </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachussetts, </address> <year> 1974. </year>
Reference-contexts: The notion of libraries is useful for another reason as well: Consider again the problem of designing a self-testing/correcting pair for the determinant. Many of the proposed solutions require matrix multiplication. However, matrix multiplication and determinant are equivalent problems with respect to asymptotic running times <ref> [2, Aho Hopcroft Ullman] </ref>. Therefore, a determinant self-testing/correcting pair using matrix multiplication will not be quantifiably different from a program for the determinant.
Reference: [3] <author> Babai, L., </author> <title> "Trading Group Theory for Randomness", </title> <booktitle> proceedings of the 17 th ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 421-429, </pages> <year> 1985. </year>
Reference-contexts: The techniques in this paper have been applied to the theory of interactive proofs (see [22, Gold-wasser Micali Rackoff], <ref> [3, Babai] </ref> and [9, Ben-Or Goldwasser Kilian Wigderson] for the discussion of interactive proofs). [27, Nisan] uses the self-testing/correcting technique based on bootstrapping developed in Section 7 and the observation about the permanent problem in [26, Lipton] (which is based on [6, Beaver Feigenbaum]) to construct a two-prover interactive proof system
Reference: [4] <author> Babai, L., </author> <title> "E-mail and the power of interaction", </title> <booktitle> proceedings of the 5 th Structures in Complexity Theory Conference, </booktitle> <year> 1990. </year>
Reference-contexts: bootstrapping developed in Section 7 and the observation about the permanent problem in [26, Lipton] (which is based on [6, Beaver Feigenbaum]) to construct a two-prover interactive proof system for the permanent problem, which led to the eventual discovery that IP = PSPACE ([19, Fortnow Karloff Lund Nisan], [37, Shamir], <ref> [4, Babai] </ref>). The results in this paper are related to those in [5, Babai Fortnow Lund].
Reference: [5] <author> Babai, L., Fortnow, L., Lund, K., </author> <title> "Non-Deterministic Exponential Time has Two-Prover Interactive Protocols", </title> <booktitle> proceedings of the 31 st IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: The results in this paper are related to those in <ref> [5, Babai Fortnow Lund] </ref>. In order to show that the multi-prover version of IP is equal to NEXPTIME, [5, Babai Fortnow Lund] give a test for verifying that a given program P , which depends on n input variables, computes a function which is usually equal to some multi-linear function f <p> The results in this paper are related to those in <ref> [5, Babai Fortnow Lund] </ref>. In order to show that the multi-prover version of IP is equal to NEXPTIME, [5, Babai Fortnow Lund] give a test for verifying that a given program P , which depends on n input variables, computes a function which is usually equal to some multi-linear function f of the n variables.
Reference: [6] <author> Beaver, D., Feigenbaum, J., </author> <title> "Hiding Instance in Multioracle Queries", </title> <booktitle> proceedings of Symposium of Theoretical Aspects of Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: theory of interactive proofs (see [22, Gold-wasser Micali Rackoff], [3, Babai] and [9, Ben-Or Goldwasser Kilian Wigderson] for the discussion of interactive proofs). [27, Nisan] uses the self-testing/correcting technique based on bootstrapping developed in Section 7 and the observation about the permanent problem in [26, Lipton] (which is based on <ref> [6, Beaver Feigenbaum] </ref>) to construct a two-prover interactive proof system for the permanent problem, which led to the eventual discovery that IP = PSPACE ([19, Fortnow Karloff Lund Nisan], [37, Shamir], [4, Babai]). The results in this paper are related to those in [5, Babai Fortnow Lund]. <p> Work in <ref> [6, Beaver Feigenbaum] </ref> and [26, Lipton] and [21, Gemmell Lipton Rubinfeld Sudan Wigderson] has extended this to functions which compute polynomials over finite fields and this has been extended in [34, Rubinfeld Sudan] to work over rational domains. A variety of other problems, have result checkers, and thus also self-testers.
Reference: [7] <author> Beigel, R., Feigenbaum, J., </author> <title> "On the Complexity of Coherent Sets", </title> <type> AT&T Technical Memorandum, </type> <month> February 19, </month> <year> 1990. </year>
Reference-contexts: It would be interesting to find self-correctors for such problems. An example is sorting. * Is it possible to show that some functions are not going to have a self-testing/correcting pair? Some progress can be found in [18, Feigenbaum Kannan Nisan], [39, Yao], <ref> [7, Beigel Feigenbaum] </ref>. * Are there applications of the combinatorial theorems introduced in this paper in other areas? We suggest the development of more probabilistic tools long these lines.
Reference: [8] <author> Ben-Or, M., Coppersmith, D., Luby, M., Rubinfeld, R., </author> <title> "Convolutions on Groups", </title> <note> in preparation. </note>
Reference-contexts: If, for all i = 1; ; c, ffi i &lt; 1=2, then ffi 2 =9. The specific proofs we give of Theorems 3 and 4, due largely to Don Coppersmith, are simpler than our original proofs. A full exposition of some related general probability results will appear in <ref> [8, Ben-Or Coppersmith Luby Rubinfeld] </ref>. We now introduce some more notation and prove some intermediate lemmas that are used in the proofs of Theorems 3 and 4.
Reference: [9] <author> Ben-Or, M., Goldwasser, S., Kilian, J., and Wigderson, A., </author> <title> "Multi-Prover Interactive Proofs: How to Remove Intractability", </title> <booktitle> proceedings of the 20 th ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 113-131, </pages> <year> 1988. </year>
Reference-contexts: The techniques in this paper have been applied to the theory of interactive proofs (see [22, Gold-wasser Micali Rackoff], [3, Babai] and <ref> [9, Ben-Or Goldwasser Kilian Wigderson] </ref> for the discussion of interactive proofs). [27, Nisan] uses the self-testing/correcting technique based on bootstrapping developed in Section 7 and the observation about the permanent problem in [26, Lipton] (which is based on [6, Beaver Feigenbaum]) to construct a two-prover interactive proof system for the permanent
Reference: [10] <author> Blum, M., </author> <title> "Designing programs to check their work", </title> <type> ICSI technical report TR-88-009. </type>
Reference-contexts: CCR 88-13632. 1 The theory of result checking, introduced in <ref> [10, Blum] </ref>, provides an attractive supplement to traditional approaches for verifying that a program is correct (see also [12, Blum Kannan], [11, Blum Raghavan], [24, Kannan]). <p> We extend the theory 3 proposed in <ref> [10, Blum] </ref> to allow the use of several programs, or a library, to aid in self-testing and self-correcting. We show that the library approach allows one to construct self-testing/correcting pairs for functions which did not previously have efficient self-testing or self-correcting programs, or even result checkers. <p> It is reasonable therefore to use programs in these packages to help test and correct each other. We extend the theory proposed in <ref> [10, Blum] </ref> to allow the use of several programs, or a library, to aid in testing and correcting. We show that this allows one to construct self-testing/correcting pairs for functions which did not previously have efficient self-testing or self-correcting programs, or even result checkers.
Reference: [11] <author> Blum, M., Raghavan, </author> <title> P, "Program correctness: can one test for it?", Information Processing 89, </title> <editor> G.X. Ritter (ed.), </editor> <publisher> Elsevier Science Publishers B.V. (North-Holland), IFIP 1989, </publisher> <pages> pp. 127-134. </pages>
Reference-contexts: CCR 88-13632. 1 The theory of result checking, introduced in [10, Blum], provides an attractive supplement to traditional approaches for verifying that a program is correct (see also [12, Blum Kannan], <ref> [11, Blum Raghavan] </ref>, [24, Kannan]). Informally, the idea is to write a very simple program C, called the result checker, which is to be run in conjunction with P to verify that P (x) = f (x) in the following sense.
Reference: [12] <author> Blum, M., Kannan, S., </author> <title> "Designing programs that check their work," </title> <booktitle> proceedings of the 21 st ACM Symposium on Theory of Computing, </booktitle> <year> 1989. </year>
Reference-contexts: CCR 88-13632. 1 The theory of result checking, introduced in [10, Blum], provides an attractive supplement to traditional approaches for verifying that a program is correct (see also <ref> [12, Blum Kannan] </ref>, [11, Blum Raghavan], [24, Kannan]). Informally, the idea is to write a very simple program C, called the result checker, which is to be run in conjunction with P to verify that P (x) = f (x) in the following sense.
Reference: [13] <author> Blum, M., Luby, M., Rubinfeld, R., </author> <title> "Program Result Checking Against Adaptive Programs and in Cryptographic Settings", </title> <booktitle> presented in Distributed Computing and Cryptography workshop, 1989, paper appears in DIMACS Series on Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> vol. 2, </volume> <year> 1991. </year>
Reference-contexts: In this paper, we assume that the program's answer on a particular input does not depend on previous inputs. <ref> [13, Blum Luby Rubinfeld] </ref> considers the case when the program adaptively decides its answer based on previous inputs.
Reference: [14] <author> Blum, M., Luby, M., Rubinfeld, R., </author> <title> "Self-Testing/Correcting with Applications to Numerical Problems," </title> <booktitle> proceedings of 22 nd ACM Symposium on Theory of Computing, </booktitle> <year> 1990. </year>
Reference-contexts: imply that C has to correctly compute f (x) on its own without any calls to P , which is clearly not in the spirit of allowing C to be a much simpler program than any correct program for f . 2 A preliminary version of this paper appeared in <ref> [14, Blum, Luby, Rubinfeld] </ref>. 2 We call the running time of T f , counting the time for calls to the program P , the total time of T f .
Reference: [15] <author> Blum, M., and Micali, S., </author> <title> "How to Generate Cryptographically Strong Sequences of PseudoRandom Bits", </title> <note> preliminary version appears in proceedings of 23 rd IEEE Symposium on Foundations of Computer Science, 1982, journal paper appears in SIAM J. on Computing, Vol. 13, </note> <year> 1984, </year> <pages> pp. 850-864, </pages>
Reference-contexts: The properties are that if either P or P 0 is too faulty, then one of T 0 or T will output "FAIL", whereas if both P and P 0 are not too faulty, then C correctly computes f on all inputs with high probability. 1.3 Related Work and Extensions <ref> [15, Blum Micali] </ref> construct a pseudo-random generator, where a crucial ingredient of the construction can be thought of as a self-correcting program for the discrete log function. [31, Rubinfeld] introduces result checking for parallel programs, and uses self-testing to design a constant depth circuit to check the majority function.
Reference: [16] <author> Cleve, R., Luby, M., </author> <title> "A Note on Self-Testing/Correcting Methods for Trigonometric Func--tions", </title> <type> ICSI technical report TR-90-032, </type> <year> 1990. </year>
Reference-contexts: In this paper, we assume that the program's answer on a particular input does not depend on previous inputs. [13, Blum Luby Rubinfeld] considers the case when the program adaptively decides its answer based on previous inputs. Recently, <ref> [16, Cleve Luby] </ref> have shown how to use these techniques to design a self-testing/- correcting pair for the trigonometric functions sin and cosin. [21, Gemmell Lipton Rubinfeld Sudan Wigderson] extend these results to design a self-testing/correcting pair for any polynomial function over finite fields and [34, Rubinfeld Sudan] extend this to
Reference: [17] <author> Coppersmith, D., Winograd, S., </author> <title> "Matrix Multiplication via Arithmetic Progressions", </title> <booktitle> proceedings of the 19 th ACM Symposium on Theory of Computing, </booktitle> <year> 1987. </year>
Reference: [18] <author> Feigenbaum, J., Kannan, S., Nisan, N., </author> <title> "Lower Bounds on Random Self-Reducibility", </title> <booktitle> proceedings of the 5 th Structures in Complexity Theory Conference, </booktitle> <year> 1990. </year>
Reference-contexts: A variety of other problems, have result checkers, and thus also self-testers. It would be interesting to find self-correctors for such problems. An example is sorting. * Is it possible to show that some functions are not going to have a self-testing/correcting pair? Some progress can be found in <ref> [18, Feigenbaum Kannan Nisan] </ref>, [39, Yao], [7, Beigel Feigenbaum]. * Are there applications of the combinatorial theorems introduced in this paper in other areas? We suggest the development of more probabilistic tools long these lines.
Reference: [19] <author> Fortnow, L., Karloff, H., Lund, K., Nisan, N., </author> <title> "The Polynomial Hierarchy has Interactive Proofs", </title> <booktitle> proceedings of the 31 st IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1990. </year>
Reference: [20] <author> Freivalds, R., </author> <title> "Fast Probabilistic Algorithms", </title> <publisher> Springer Verlag Lecture Notes in CS No. </publisher> <pages> 74, </pages> <note> Mathematical Foundations of CS, </note> <month> 57-69 </month> <year> (1979). </year>
Reference-contexts: Previous to our work, [23, Kaminski] gives result checkers for integer and polynomial multiplication. Independently of our work, [1, Adleman Huang Kompella] give result checkers for integer multiplication and modular exponentiation. Both of these papers use very different techniques than ours. Previous to our work, <ref> [20, Freivalds] </ref> introduces a result checker for matrix multiplication over a finite field. <p> The self-testing/correcting pairs that we present are all different and efficient. Program Freivalds Checker described below is due to <ref> [20, Freivalds] </ref>. Specifications of Matrix Mult Self-Correct (n; A; B; fi): If error (f; P; U M nfin [F ] fi U M nfin [F ] ) 1=8 then the probability that the output is equal to A B is at least 1 fi.
Reference: [21] <author> Gemmell, P., Lipton, R., Rubinfeld, R., Sudan, M., Wigderson, A., </author> <title> "Self-Testing/Correcting for Polynomials and for Approximate Functions", </title> <booktitle> proceedings of the 23 rd ACM Symposium on Theory of Computing, </booktitle> <year> 1991. </year>
Reference-contexts: Thus f is still essentially a linear function. <ref> [21, Gemmell Lipton Rubinfeld Sudan Wigderson] </ref> shows that a similar property and relaxation holds for polynomials. <p> Recently, [16, Cleve Luby] have shown how to use these techniques to design a self-testing/- correcting pair for the trigonometric functions sin and cosin. <ref> [21, Gemmell Lipton Rubinfeld Sudan Wigderson] </ref> extend these results to design a self-testing/correcting pair for any polynomial function over finite fields and [34, Rubinfeld Sudan] extend this to polynomial functions over rational domain. [33, Rubinfeld] introduces an extension of this theory to the case when the program's answer is considered correct <p> Work in [6, Beaver Feigenbaum] and [26, Lipton] and <ref> [21, Gemmell Lipton Rubinfeld Sudan Wigderson] </ref> has extended this to functions which compute polynomials over finite fields and this has been extended in [34, Rubinfeld Sudan] to work over rational domains. A variety of other problems, have result checkers, and thus also self-testers. <p> Significant progress in this direction has been made in a series of papers by <ref> [21, Gemmell Lipton Rubinfeld Sudan Wigderson] </ref>. * One area of practical concern for self-testing/correcting pairs is the overhead incurred by running the self-tester and self-corrector.
Reference: [22] <author> Goldwasser, S., Micali, S. and Rackoff, C., </author> <title> "The Knowledge Complexity of Interactive Proof Systems," </title> <note> a preliminary version appeared in 17 th ACM Symposium on Theory of Computing, 1985. final version appears in SIAM J. on Computing, Vol. 18, No. 1, </note> <year> 1989, </year> <pages> pp. 186-208. </pages>
Reference-contexts: The techniques in this paper have been applied to the theory of interactive proofs (see <ref> [22, Gold-wasser Micali Rackoff] </ref>, [3, Babai] and [9, Ben-Or Goldwasser Kilian Wigderson] for the discussion of interactive proofs). [27, Nisan] uses the self-testing/correcting technique based on bootstrapping developed in Section 7 and the observation about the permanent problem in [26, Lipton] (which is based on [6, Beaver Feigenbaum]) to construct a
Reference: [23] <author> Kaminski, Michael, </author> <title> "A note on probabilistically verifying integer and polynomial products," </title> <journal> JACM, </journal> <volume> Vol. 36, No. 1, </volume> <month> January </month> <year> 1989, </year> <month> pp.142-149. </month>
Reference-contexts: A self-testing/correcting pair for a function f implies a result checker for f . A result checker for f implies a self-tester for f , but it is not known whether a result checker also implies a self-corrector. Previous to our work, <ref> [23, Kaminski] </ref> gives result checkers for integer and polynomial multiplication. Independently of our work, [1, Adleman Huang Kompella] give result checkers for integer multiplication and modular exponentiation. Both of these papers use very different techniques than ours.
Reference: [24] <author> Kannan, S., </author> <title> "Program Result Checking with Applications", </title> <type> Ph.D. thesis, </type> <institution> U.C. Berkeley, </institution> <year> 1990. </year>
Reference-contexts: CCR 88-13632. 1 The theory of result checking, introduced in [10, Blum], provides an attractive supplement to traditional approaches for verifying that a program is correct (see also [12, Blum Kannan], [11, Blum Raghavan], <ref> [24, Kannan] </ref>). Informally, the idea is to write a very simple program C, called the result checker, which is to be run in conjunction with P to verify that P (x) = f (x) in the following sense. <p> This requires a different assumption for each distinct modulus R. Our self-testing algorithm for the mod function on input R can be used to efficiently either validate or refute this assumption. Previously, <ref> [24, Kannan] </ref> provides an elegant result checker for computing the determinant of a matrix, but it is not efficient.
Reference: [25] <author> Karp, R., Luby, M., Madras, N., </author> <title> "Monte-Carlo Approximation Algorithms for Enumeration Problems," </title> <journal> J. of Algorithms, </journal> <volume> Vol. 10, No. 3, </volume> <month> Sept. </month> <year> 1989, </year> <pages> pp. 429-448. </pages>
Reference-contexts: This proposition can be proved using standard techniques from an inequality due to Bernstein cited in [29, Renyi]. For a proof of this proposition, see for example <ref> [25, Karp Luby Madras] </ref>. Proposition 15 Let Y 1 ; Y 2 ; : : : be independent identically distributed 0/1-valued random variables with mean . Let 2.
Reference: [26] <author> Lipton, R., </author> <title> "New directions in testing", </title> <booktitle> presented in Distributed Computing and Cryptography workshop, 1989, paper appears in DIMACS Series on Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> vol. 2, </volume> <year> 1991, </year> <pages> pp. 191-202. </pages>
Reference-contexts: Both of these papers use very different techniques than ours. Previous to our work, [20, Freivalds] introduces a result checker for matrix multiplication over a finite field. We make use of this result checker when designing the self-testing/correcting pair for matrix multiplication over a finite field. <ref> [26, Lipton] </ref>, independently of our work, discusses the concept of self-correcting programs and for several functions uses it to construct a testing program with respect to any distribution assuming that the programs are not too faulty with respect to a particular distribution. <p> To highlight the importance of being able to self-test, consider the mod function. To self-correct on input x and 4 modulus R, the assumption in <ref> [26, Lipton] </ref> and here is that the program is correct for most inputs x with respect to the particular modulus R. This requires a different assumption for each distinct modulus R. <p> paper have been applied to the theory of interactive proofs (see [22, Gold-wasser Micali Rackoff], [3, Babai] and [9, Ben-Or Goldwasser Kilian Wigderson] for the discussion of interactive proofs). [27, Nisan] uses the self-testing/correcting technique based on bootstrapping developed in Section 7 and the observation about the permanent problem in <ref> [26, Lipton] </ref> (which is based on [6, Beaver Feigenbaum]) to construct a two-prover interactive proof system for the permanent problem, which led to the eventual discovery that IP = PSPACE ([19, Fortnow Karloff Lund Nisan], [37, Shamir], [4, Babai]). <p> All of these self-correcting programs follow the same outline and rely on the random self-reducibility property (defined in the preceding subsection) of the given function. In Subsection 3.8 we give a self-correcting program that works for any random self-reducible function. <ref> [26, Lipton] </ref> uses the same basic outline to develop a self-correcting program for any polynomial over a finite field. 3.1 Mod Function We consider computing an integer modR for a positive number R. In this case, f (x; R) = x mod R. <p> Work in [6, Beaver Feigenbaum] and <ref> [26, Lipton] </ref> and [21, Gemmell Lipton Rubinfeld Sudan Wigderson] has extended this to functions which compute polynomials over finite fields and this has been extended in [34, Rubinfeld Sudan] to work over rational domains. A variety of other problems, have result checkers, and thus also self-testers.
Reference: [27] <author> Nisan, N., </author> <title> "Co-SAT Has Multi-Prover Interactive Proofs", </title> <type> e-mail announcement, </type> <month> November </month> <year> 1989. </year>
Reference-contexts: The techniques in this paper have been applied to the theory of interactive proofs (see [22, Gold-wasser Micali Rackoff], [3, Babai] and [9, Ben-Or Goldwasser Kilian Wigderson] for the discussion of interactive proofs). <ref> [27, Nisan] </ref> uses the self-testing/correcting technique based on bootstrapping developed in Section 7 and the observation about the permanent problem in [26, Lipton] (which is based on [6, Beaver Feigenbaum]) to construct a two-prover interactive proof system for the permanent problem, which led to the eventual discovery that IP = PSPACE
Reference: [28] <author> Randall, D., </author> <title> "Efficient Random Generation of Nonsingular Matrices", </title> <type> U.C. Berkeley Technical Report, </type> <institution> Computer Science Department, </institution> <note> No. 91/658, </note> <year> 1991. </year>
Reference-contexts: We use program Gen Inv Matrix (n) as a subroutine in our code to choose A 2 U M n nfin [F ]. Gen Inv Matrix (n) is due to <ref> [28, Randall] </ref>, and a description of it can be found there. The incremental time of Gen Inv Matrix (n) is O (n 2 ), excluding the time for computing the one required matrix multiplication. We assume that Gen Inv Matrix (n) calls MMSC in order to compute the matrix multiplication. <p> We assume that Gen Inv Matrix (n) calls MMSC in order to compute the matrix multiplication. Thus, Gen Inv Matrix (n) has a small probability of error, which we ignore for purposes of clarity. Gen Inv Matrix/Det (n), also due to <ref> [28, Randall] </ref>, in addition to outputting A 2 U M n nfin [F ], also outputs det (A).
Reference: [29] <author> Renyi, A., </author> <year> (1970), </year> <title> Probability Theory, </title> <publisher> North-Holland, Amsterdam. </publisher>
Reference-contexts: The following proposition is used to quantify the number of random samples needed to guarantee good estimates of ffi and ffi 1 ; : : : ; ffi c with high probability. This proposition can be proved using standard techniques from an inequality due to Bernstein cited in <ref> [29, Renyi] </ref>. For a proof of this proposition, see for example [25, Karp Luby Madras]. Proposition 15 Let Y 1 ; Y 2 ; : : : be independent identically distributed 0/1-valued random variables with mean . Let 2.
Reference: [30] <author> Rosser, J.B., Schoenfeld, L., </author> <title> "Approximate formulas for some functions of prime numbers", </title> <journal> Illinois J. Math, </journal> <volume> 6, </volume> <year> 1962, </year> <month> pp.64-94. </month>
Reference-contexts: We can easily estimate this probability by randomly choosing several independent x 2 U Z R and computing the fraction of these x that satisfy P (x; R) R x = 1. For all R &gt; 3, (R) = jZ fl 6 ln (n) <ref> [30, Rosser, Schoenfeld] </ref>, and thus if P is correct for a constant fraction ffi of the x 2 Z fl R then the above condition is true with c = 6=ffi.
Reference: [31] <author> Rubinfeld, R., </author> <title> "Designing Checkers for Programs that Run in Parallel", </title> <type> ICSI technical report TR-90-040. </type>
Reference-contexts: and P 0 are not too faulty, then C correctly computes f on all inputs with high probability. 1.3 Related Work and Extensions [15, Blum Micali] construct a pseudo-random generator, where a crucial ingredient of the construction can be thought of as a self-correcting program for the discrete log function. <ref> [31, Rubinfeld] </ref> introduces result checking for parallel programs, and uses self-testing to design a constant depth circuit to check the majority function. A self-testing/correcting pair for a function f implies a result checker for f .
Reference: [32] <author> Rubinfeld, R. </author> <title> "Batch Checking Linear Functions", </title> <type> manuscript, </type> <year> 1990. </year>
Reference-contexts: Recently a batch self-corrector for any function with the linearity property has been designed which reduces the overhead to a small additive factor if it is infrequent that P answers incorrectly for some input in a batch <ref> [32, Rubinfeld] </ref>. We would like to design batch self-correctors for other important functions. 9 Acknowledgements We thank Silvio Micali for pointing out the general applicability of our methods, for his enthusiastic support and for numerous illuminating technical discussions.
Reference: [33] <author> Rubinfeld, R. </author> <title> "A Mathematical Theory of Self-Checking, Self-Testing and Self-Correcting Programs", </title> <type> Ph.D. thesis, </type> <institution> Computer Science Department, U.C. Berkeley,, </institution> <year> 1990. </year> <month> 42 </month>
Reference-contexts: to use these techniques to design a self-testing/- correcting pair for the trigonometric functions sin and cosin. [21, Gemmell Lipton Rubinfeld Sudan Wigderson] extend these results to design a self-testing/correcting pair for any polynomial function over finite fields and [34, Rubinfeld Sudan] extend this to polynomial functions over rational domain. <ref> [33, Rubinfeld] </ref> introduces an extension of this theory to the case when the program's answer is considered correct when it is a good approximation to the actual value of the function, and designs a self-testing/correcting pair for the quotient function.
Reference: [34] <author> Rubinfeld, R., Sudan, M., </author> <title> "Self-Testing Polynomial Functions Efficiently and over Rational Domains", </title> <booktitle> proceedings of ACM SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1992. </year>
Reference-contexts: Recently, [16, Cleve Luby] have shown how to use these techniques to design a self-testing/- correcting pair for the trigonometric functions sin and cosin. [21, Gemmell Lipton Rubinfeld Sudan Wigderson] extend these results to design a self-testing/correcting pair for any polynomial function over finite fields and <ref> [34, Rubinfeld Sudan] </ref> extend this to polynomial functions over rational domain. [33, Rubinfeld] introduces an extension of this theory to the case when the program's answer is considered correct when it is a good approximation to the actual value of the function, and designs a self-testing/correcting pair for the quotient function. <p> Work in [6, Beaver Feigenbaum] and [26, Lipton] and [21, Gemmell Lipton Rubinfeld Sudan Wigderson] has extended this to functions which compute polynomials over finite fields and this has been extended in <ref> [34, Rubinfeld Sudan] </ref> to work over rational domains. A variety of other problems, have result checkers, and thus also self-testers. It would be interesting to find self-correctors for such problems.
Reference: [35] <author> Schonhage, A., </author> <type> personal communication through Michael Fischer. </type>
Reference-contexts: For example, integer multiplication and matrix multiplication are commonly used functions for which fast but complicated programs have been written and implemented ([17, Coppersmith Winograd], [38, Strassen], <ref> [35, Schonhage] </ref>, [36, Schonhage Strassen]). Thus, the self-testing/correcting pairs we develop may be useful in practice. We develop general techniques for constructing simple to program self-testing/correcting pairs for a variety of numerical functions.
Reference: [36] <author> Schonhage, A., Strassen, V., "Schnelle Multiplikation grosser Zahlen," </author> <booktitle> Computing 7, </booktitle> <pages> 281-292. </pages>
Reference-contexts: For example, integer multiplication and matrix multiplication are commonly used functions for which fast but complicated programs have been written and implemented ([17, Coppersmith Winograd], [38, Strassen], [35, Schonhage], <ref> [36, Schonhage Strassen] </ref>). Thus, the self-testing/correcting pairs we develop may be useful in practice. We develop general techniques for constructing simple to program self-testing/correcting pairs for a variety of numerical functions.
Reference: [37] <author> Shamir, A., </author> <title> "IP = PSPACE", </title> <booktitle> proceedings of the 31 st IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: based on bootstrapping developed in Section 7 and the observation about the permanent problem in [26, Lipton] (which is based on [6, Beaver Feigenbaum]) to construct a two-prover interactive proof system for the permanent problem, which led to the eventual discovery that IP = PSPACE ([19, Fortnow Karloff Lund Nisan], <ref> [37, Shamir] </ref>, [4, Babai]). The results in this paper are related to those in [5, Babai Fortnow Lund].
Reference: [38] <author> Strassen, V., </author> <title> "Gaussian Elimination is not Optimal", </title> <journal> Numerische Mathematik, </journal> <volume> 13, </volume> <year> 1969, </year> <pages> pp. 354-356. </pages>
Reference-contexts: For example, integer multiplication and matrix multiplication are commonly used functions for which fast but complicated programs have been written and implemented ([17, Coppersmith Winograd], <ref> [38, Strassen] </ref>, [35, Schonhage], [36, Schonhage Strassen]). Thus, the self-testing/correcting pairs we develop may be useful in practice. We develop general techniques for constructing simple to program self-testing/correcting pairs for a variety of numerical functions.
Reference: [39] <author> Yao, A., </author> <title> "Coherent Functions and Program Checking", </title> <booktitle> proceedings of the 22 nd ACM Symposium on Theory of Computing, </booktitle> <year> 1990. </year> <month> 43 </month>
Reference-contexts: It would be interesting to find self-correctors for such problems. An example is sorting. * Is it possible to show that some functions are not going to have a self-testing/correcting pair? Some progress can be found in [18, Feigenbaum Kannan Nisan], <ref> [39, Yao] </ref>, [7, Beigel Feigenbaum]. * Are there applications of the combinatorial theorems introduced in this paper in other areas? We suggest the development of more probabilistic tools long these lines.
References-found: 39

