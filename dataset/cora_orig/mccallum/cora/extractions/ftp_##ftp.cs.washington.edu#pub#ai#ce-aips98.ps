URL: ftp://ftp.cs.washington.edu/pub/ai/ce-aips98.ps
Refering-URL: http://www.cs.washington.edu/homes/corin/
Root-URL: http://www.cs.washington.edu
Email: corin@cs.washington.edu, de2smith@ptolemy.arc.nasa.gov, weld@cs.washington.edu  
Title: Conditional Effects in Graphplan  
Author: Corin R. Anderson David E. Smith Daniel S. Weld 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Note: Appearing in AIPS-98 1  
Abstract: Graphplan has attracted considerable interest because of its extremely high performance, but the algorithm's inability to handle action representations more expressive than STRIPS is a major limitation. In particular, extending Graphplan to handle conditional effects is a surprisingly subtle enterprise. In this paper, we describe the space of possible alternatives, and then concentrate on one particular approach we call factored expansion. Factored expansion splits an action with conditional effects into several new actions called components, one for each conditional effect. Because these action components are not independent, factored expansion complicates both the mutual exclusion and backward chaining phases of Graphplan. As compensation, factored expansion often produces dramatically smaller domain models than does the more obvious full-expansion into exclusive STRIPS actions. We present experimental results showing that factored expansion dominates full expansion on large problems. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Blum, A., and Furst, M. </author> <year> 1995. </year> <title> Fast planning through planning graph analysis. </title> <booktitle> In Proc. 14th Int. Joint Conf. AI, </booktitle> <pages> 1636-1642. </pages>
Reference-contexts: Introduction Since Graphplan <ref> (Blum & Furst 1995) </ref> appears to outperform all known STRIPS 1 planners, attention is now fl David Smith's current address is Nasa Ames Research Center, Mail Stop 269-2, Moffett Field, CA 94035. We thank Mark Peot who provided an initial Lisp implementation of basic Graphplan. <p> Negated and Disjunctive Preconditions Although methods for handling negated and disjunctive preconditions were not presented in <ref> (Blum & Furst 1995) </ref>, they are both straightforward and essential prerequisites for handling conditional effects. Clearly proposition p and :p are mutually exclusive in any given level.
Reference: <author> Blum, A., and Furst, M. </author> <year> 1997. </year> <title> Fast planning through planning graph analysis. </title> <journal> J. Artificial Intelligence 90(1-2):281-300. </journal>
Reference: <author> Ernst, M.; Millstein, T.; and Weld, D. </author> <year> 1997. </year> <title> Automatic sat-compilation of planning problems. </title> <booktitle> In Proc. 15th Int. Joint Conf. AI. </booktitle>
Reference: <author> Gazen, B., and Knoblock, C. </author> <year> 1997. </year> <title> Combining the ex-pressivity of UCPOP with the efficiency of Graphplan. </title> <booktitle> In Proc. 4th European Conference on Planning. </booktitle>
Reference-contexts: Figure 1 illustrates how conditional effects allow one to define a single action schema that accounts for moving a briefcase that may possibly contain a paycheck and/or keys. The Full Expansion Approach One possible way of dealing with conditional effects in Graphplan, and the way adopted by <ref> (Gazen & Knoblock 1997) </ref>, is essentially to expand such actions to Graphplan performance (Kautz, McAllester, & Selman 1996; Ernst, Millstein, & Weld 1997). move-briefcase (?loc ?new) :prec (and (at briefcase ?loc) (location ?new) (not (= ?loc ?new))) :effect (and (at briefcase ?new) (not (at briefcase ?loc)) (when (in paycheck briefcase) (and <p> The worst case comes about if all nm propositions are distinct in which case all combinations must be enumerated. The 2 nm number can actually be reduced to n m as explained in <ref> (Gazen & Knoblock 1997) </ref>, however this is still very large. expansion yields dramatic speedup. <p> A third optimization removes inertia, facts that are true at all graph levels. In domains that have static attributes associated with objects, removing inertia greatly improves performance these static facts don't have to be considered when extending the planning graph or when searching backwards through the graph. In <ref> (Gazen & Knoblock 1997) </ref>, a preprocessor has been defined and implemented to convert UCPOP-style domains into simpler STRIPS style domains. This preprocessor allows Graphplan to solve problems whose definitions are given in the full expressiveness of ADL. <p> The principle ideas behind factored expansion are 1) breaking the action into its components, 2) modifying the rules for mutual exclusion by adding the notion of mutexes from induced components, and 3) modifying the rules for backchaining to incorporate confrontation. We compared factored expansion to full expansion <ref> (Gazen & Knoblock 1997) </ref> and the IP 2 method (Koehler et al. 1997a). There appear to be two potential forms of combinatorial explosion: * Instantiation Explosion. As illustrated in Figure 2, the full expansion approach can compile an action containing conditional effects into an exponential number of STRIPS actions.
Reference: <author> Kambhampati, R.; Lambrecht, E.; and Parker, E. </author> <year> 1997. </year> <title> Understanding and extending graphplan. </title> <booktitle> In Proc. 4th Eu-ropean Conference on Planning. </booktitle>
Reference-contexts: Second, the Briefcase World problems show that the time to extend the planning graph is sometimes as important, if not more so, than the time to search the planning graph. 5 In the 5 See <ref> (Kambhampati, Lambrecht, & Parker 1997) </ref> for Briefcase World problems, the time is heavily dominated by graph expansion. IP 2 is highly optimized for this task, while our factored expansion implementation doesn't have any such optimizations. <p> This preprocessor allows Graphplan to solve problems whose definitions are given in the full expressiveness of ADL. In this work, conditional effects are handled by a compile-time full-expansion of each operator. Kambhampati's group has considered several extensions to Graphplan. For example, <ref> (Kambhampati, Lambrecht, & Parker 1997) </ref> describes how to implement negated and disjunctive preconditions in Graph-plan, and also sketches the full expansion strategy for handling conditional effects.
Reference: <author> Kautz, H., and Selman, B. </author> <year> 1996. </year> <title> Pushing the envelope: Planning, propositional logic, and stochastic search. </title> <booktitle> In Proc. 13th Nat. Conf. AI, </booktitle> <pages> 1194-1201. </pages>
Reference-contexts: Copyright c fl 1998, American Association for Artificial Intelligence (www.aaai.org). All rights reserved. 1 Another promising approach is compilation to SAT <ref> (Kautz & Selman 1996) </ref>, but the only times reported to be competitive with Graphplan were from hand-generated SAT problems run with a stochastic solver whose noise parameters were carefully tuned to the problem at hand.
Reference: <author> Kautz, H.; McAllester, D.; and Selman, B. </author> <year> 1996. </year> <title> Encoding plans in propositional logic. </title> <booktitle> In Proc. 5th Int. Conf. Principles of Knowledge Representation and Reasoning. </booktitle>
Reference-contexts: Copyright c fl 1998, American Association for Artificial Intelligence (www.aaai.org). All rights reserved. 1 Another promising approach is compilation to SAT <ref> (Kautz & Selman 1996) </ref>, but the only times reported to be competitive with Graphplan were from hand-generated SAT problems run with a stochastic solver whose noise parameters were carefully tuned to the problem at hand.
Reference: <author> Koehler, J.; Nebel, B.; Hoffmann, J.; and Dimopoulos, Y. </author> <year> 1997a. </year> <title> Extending planning graphs to an ADL subset. </title> <booktitle> In Proc. 4th European Conference on Planning. </booktitle>
Reference-contexts: We compared factored expansion to full expansion (Gazen & Knoblock 1997) and the IP 2 method <ref> (Koehler et al. 1997a) </ref>. There appear to be two potential forms of combinatorial explosion: * Instantiation Explosion. As illustrated in Figure 2, the full expansion approach can compile an action containing conditional effects into an exponential number of STRIPS actions.
Reference: <author> Koehler, J.; Nebel, B.; Hoffmann, J.; and Di-mopoulos, Y. </author> <year> 1997b. </year> <title> Extending planning graphs to an ADL subset. </title> <type> TR 88, </type> <institution> Institute for Computer Science, University of Freiburg. </institution> <note> See http://www.informatik.uni-freiburg.de/~ koehler/ipp.html. </note>
Reference-contexts: The IP 2 Approach A third possible method for handling conditional effects is employed by the IP 2 planner <ref> (Koehler et al. 1997b) </ref>. The IP 2 system sits halfway between the full and factored expansion methods, using techniques similar to both. A more thorough discussion of the IP 2 system is made in the empirical results section, after the requisite Graphplan background is discussed. <p> Empirical Results We conducted two experiments to evaluate methods of handling conditional effects in Graphplan. In the first experiment, we compared full expansion to factored expansion in our implementation of Graphplan. In the second experiment, we compared factored expansion to IP 2 <ref> (Koehler et al. 1997b) </ref>. Full Expansion vs. Factored Expansion In our comparison of full vs. factored expansion, the full expansion was done at run-time while the factored expansion was performed at compile-time. Both methods are part of the same implementation, written in Common Lisp. <p> Related Work Since publication of the original Graphplan papers (Blum & Furst 1995; 1997), several researchers have investigated means for extending the algorithm to handle more expressive action languages. As discussed earlier, IP 2 <ref> (Koehler et al. 1997b) </ref> is a Graph-plan derivative that uses a technique similar to factored expansion, although induced mutex relationships are not discovered. IP 2 also includes a number of optimizations that greatly improve its performance. One optimization precalculates all the ground instances of the operators in the input domain.
Reference: <author> Nebel, B.; Dimopoulos, Y.; and Koehler, J. </author> <year> 1997. </year> <title> Ignoring irrelevant facts and operators in plan generation. </title> <booktitle> In Proc. 4th European Conference on Planning. </booktitle>
Reference-contexts: One optimization precalculates all the ground instances of the operators in the input domain. By generating a complete set of legal instantiations of operators, no type checks or unifications are necessary during graph expansion. Another optimization removes facts and operators that are deemed irrelevant to the goal <ref> (Nebel, Dimopoulos, & Koehler 1997) </ref>. A third optimization removes inertia, facts that are true at all graph levels.
Reference: <author> Pednault, E. </author> <year> 1989. </year> <title> ADL: Exploring the middle ground between STRIPS and the situation calculus. </title> <booktitle> In Proc. 1st Int. Conf. Principles of Knowledge Representation and Reasoning, </booktitle> <pages> 324-332. </pages>
Reference-contexts: For example, (Gazen & Knoblock 1997; Koehler et al. 1997a; 1997b) describe Graphplan-derivative planners that handle disjunction, quantification, and conditional effects. This endeavor is important because the expressive power of ADL <ref> (Pednault 1989) </ref> provides a much more convenient way to model complex worlds. In this paper, we describe a new method for handling conditional effects in Graphplan, and compare this method to previous work (Gazen & Knoblock 1997; Koehler et al. 1997a; 1997b). <p> and a consequent; execution of the action will have the consequent's effect just in the case that the antecedent is true immediately before execution (i.e., much like the action's precondition determines if execution itself is legal | for this reason the antecedent is sometimes referred to as a secondary precondition <ref> (Pednault 1989) </ref>). Note also that, like an action precondition, the antecedent part refers to the world before the action is executed while the consequent refers to the world after execution. In this paper, we restrict the consequent to be a conjunction of positive or negative literals.
Reference: <author> Penberthy, J., and Weld, D. </author> <year> 1992. </year> <title> UCPOP: A sound, complete, partial order planner for ADL. </title> <booktitle> In Proc. 3rd Int. Conf. Principles of Knowledge Representation and Reasoning, </booktitle> <pages> 103-114. </pages> <note> See also http://www.cs.washington.edu/research/projects/ ai/www/ucpop.html. </note>
Reference-contexts: Formally, a component is a pair consisting of a consequent (conjunction of literals) and an antecedent (disjunction or conjunction is allowed). An action has one component per effect (where effect is defined in <ref> (Penberthy & Weld 1992, Section 2.3) </ref>). A component's antecedent is simply the action's primary precondition conjoined with the antecedent of the corresponding conditional effect; a component's consequent is simply the consequent of the corresponding conditional effect. 3 Using this approach, every ordinary STRIPS action would have only one component.
Reference: <author> Weld, D. </author> <year> 1994. </year> <title> An introduction to least-commitment planning. </title> <journal> AI Magazine 27-61. </journal> <note> Available at ftp://ftp.- cs.washington.edu/pub/ai/. </note>
References-found: 13

