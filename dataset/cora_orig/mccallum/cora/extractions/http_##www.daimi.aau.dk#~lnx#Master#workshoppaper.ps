URL: http://www.daimi.aau.dk/~lnx/Master/workshoppaper.ps
Refering-URL: http://www.daimi.aau.dk/~lnx/
Root-URL: http://www.daimi.aau.dk
Email: lnx@daimi.aau.dk  apaipi@daimi.aau.dk  
Title: Implementing GoF Design Patterns in BETA Position Paper, ECOOP'97 Workshop on Language Support for Design
Author: Ellen Agerbo Aino Cornils 
Date: February 3, 1998  
Address: Denmark.  Denmark.  
Affiliation: Dept of Computer Science Aarhus University,  Dept of Computer Science Aarhus University,  
Abstract: In this paper it is investigated how well the implementation language BETA supports the design patterns that are presented in [GoF 95]. The design patterns are categorised into those that dioeer signiocantly when using BETA and those that remain the same. Furthermore it is investigated which constructs in BETA prove especially useful when implementing the design patterns. It is a fact that several of the Design Patterns found in [GoF 95] can be implemented in a simpler and more straightforward way in BETA than in ordinary OO-languages. This leads us to consider whether it is true that the more advanced OO-language one uses, the more of these Design Patterns are included directly in the language constructs. 
Abstract-found: 1
Intro-found: 1
Reference: [Cornils97] <author> Ellen Agerbo and Aino Cornils (1997): </author> <title> PreThesis on Design Patterns in Beta. </title> <address> http://www.daimi.aau.dk/flapaipi/workshop/gof.ps </address>
Reference-contexts: In this paper we will focus on the patterns that belong in the category of 'Language Constructs', and for those who are interested in seeing the details for the rest of the patterns we refer to <ref> [Cornils97] </ref>. 2.1 Factory Method The purpose of this pattern is to create objects whose exact classes are unknown until runtime. This is in [GoF 95] done by instantiating the objects in virtual methods, that can be bound at runtime.
Reference: [GoF 95] <author> Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides (1995): </author> <title> Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley Publishing Company. </publisher>
Reference-contexts: 1 Introduction In this paper we investigate how Beta 1 supports the Design Patterns described in <ref> [GoF 95] </ref>. Comparing our implementation solutions with the Design Pattern descriptions from [GoF 95], we discovered that most of the Design Patterns would be implemented in the same way in Beta as in C ++ while some Design Patterns work better in Beta and some worse. <p> 1 Introduction In this paper we investigate how Beta 1 supports the Design Patterns described in <ref> [GoF 95] </ref>. Comparing our implementation solutions with the Design Pattern descriptions from [GoF 95], we discovered that most of the Design Patterns would be implemented in the same way in Beta as in C ++ while some Design Patterns work better in Beta and some worse. In this paper we have split the Design Patterns from [GoF 95] into two parts; the ones <p> with the Design Pattern descriptions from <ref> [GoF 95] </ref>, we discovered that most of the Design Patterns would be implemented in the same way in Beta as in C ++ while some Design Patterns work better in Beta and some worse. In this paper we have split the Design Patterns from [GoF 95] into two parts; the ones that are implemented in the same way in Beta as in other OO-languages, and the ones that are implemented in a fundamentally dioeerent way. <p> At orst we implemented the Design Patterns in Beta following the OMT-diagrams as depicted in <ref> [GoF 95] </ref>. Then we tried to implement the idea of the Design Pattern by using the Beta language constructs instead of blindly following the implementation suggestions. <p> Finally we wore our Beta glasses trying to ond a Beta solution to each of the problems and the application domains accompanying the descriptions of the Design Patterns in <ref> [GoF 95] </ref>. This work led to the following categorisation of the patterns from [GoF 95]. <p> Finally we wore our Beta glasses trying to ond a Beta solution to each of the problems and the application domains accompanying the descriptions of the Design Patterns in <ref> [GoF 95] </ref>. This work led to the following categorisation of the patterns from [GoF 95]. <p> C ++ , which is the language from which most of the Design Patterns in <ref> [GoF 95] </ref> have been built. <p> <ref> [GoF 95] </ref> have been built. Thus, assuming that iordinaryj OO-languages support virtual procedures, implementing these Design Patterns in Beta is nothing out of the ordinary. 3 The patterns marked y are dioeerent from the rest of this category in that they are implemented in a dioeerent way than proposed by [GoF 95] while still achieving the same goals. Dioeerent from other OO-languages In this category we include Design Patterns that are inAEuenced by being implemented in Beta instead of C ++ or Smalltalk, where the patterns originated from. <p> The category of 'Lacking Support' contains the few Design Patterns that either can not be implemented in Beta or where the implementation is noticeably harder than the solutions proposed in <ref> [GoF 95] </ref> due to the lack of some language constructs in Beta. <p> This is in <ref> [GoF 95] </ref> done by instantiating the objects in virtual methods, that can be bound at runtime. FactoryMethod () Operation () FactoryMethod () ConcreteCreatorB ConcreteCreatorA FactoryMethod () product = FactoryMethod ..... <p> In the case where there are more than one hook method (the multiple hook Template Method) the implementation in Beta will follow that of <ref> [GoF 95] </ref>. To implement the single hook Template Method, a simple solution is to make the template method a virtual procedure: AbstractClass: - TemplateMethod:&lt; - functionality_1 inner functionality_2 - 3 These concepts are introduced and discussed in detail in [Pree95] 7 . . . <p> This division is motivated in the 'Applicability' section of the Singleton Pattern in <ref> [GoF 95] </ref>, where there are two cases: 8 1. When there must be exactly one instance of a class, and it must be accessible to clients from a well-known access point. 2. <p> The version of Singleton classioed in the 'Language Construct' category covers case 1. whereas the specialisable Singleton covers both 1. and 2.. The structure of Singleton as presented in <ref> [GoF 95] </ref> is shown in Figure 6. o static uniqueInstance singletonData static Instance () GetSingletonData () SingletonOperation () return uniqueInstance Singleton This Design Pattern relies heavily upon the possibility of redeoning the constructor of a class, which is possible in C ++ as well as in Smalltalk, but not in Beta. <p> When trying to circumvent this and implement the Design Pattern in Beta one onds that it is not possible to meet all the requirements of the Design Pattern as described in <ref> [GoF 95] </ref>; that is it is not possible to implement specialisable Singleton. However, the motivation behind the Design Pattern leads us to believe that in most cases it will be suOEcient to solve the problem behind the nonspecialisable Singleton. <p> Declaring a singular object ensures that there are no other instances of the same pattern; which is exactly the purpose of the nonspecialisable Singleton Design Pattern. 3 Conclusion When using Beta as implementation language the Design Patterns suggested in <ref> [GoF 95] </ref> are for the most part easily implemented, and to some extent Beta supports these Design Patterns better than other OO-languages. <p> When as many as four of the Design Patterns in <ref> [GoF 95] </ref> come this close to be considered language constructs in Beta, with additionally four Design Patterns 9 being so well supported that the complexity of each of these is considerably reduced, this indicates that several of the Design Patterns found in [GoF 95] are solutions to shortcomings of the C <p> many as four of the Design Patterns in <ref> [GoF 95] </ref> come this close to be considered language constructs in Beta, with additionally four Design Patterns 9 being so well supported that the complexity of each of these is considerably reduced, this indicates that several of the Design Patterns found in [GoF 95] are solutions to shortcomings of the C ++ language, and perhaps the greatest part of them solutions to shortcomings of OO-languages in general.
Reference: [Beta 93] <author> Ole Lehrmann Madsen, Birger Moller-Pedersen, </author> <title> Kristen Nygaard (1993): Object-Oriented Programming in the Beta Programming Language. </title> <publisher> Addison-Wesley Publishing Company. </publisher> <address> [JAVA] http://www.javasoft.com:80/products/JDK/1.1/docs/guide/innerclasses </address>
Reference-contexts: It seems obvious now though, that when working with OO-languages, these constructs are considered fundamental and will certainly be found in any new OO-language. But what about the Design Patterns of today? Will they continue being considered 1 The Beta language as described in <ref> [Beta 93] </ref> has been developed in Scandinavia as a successor to Simula 1 Design Patterns or will they eventually be known as natural language constructs in every OO-language? In the following section we will brieAEy outline some of the constructs in Beta that sets it apart from other OO-languages, and later <p> This is referred to as a further extension or further binding of a virtual procedure. It is the responsibility of the superclass designer to insert inner where the subclasses may need to extend the behaviour. 2 <ref> [Beta 93] </ref> 2 The motivation for this is to ensure that all properties that hold for the superclass should also hold for the subclasses, which is ideal from a modelling point of view. * Pattern variables: Patterns in Beta are orst-class values, which means that they can be assigned to variables
Reference: [Pree95] <author> Wolfgang Pree (1995): </author> <title> Design Patterns for Object-Oriented Software Development. </title> <publisher> Addison-Wesley Publishing Company. </publisher> <pages> 10 </pages>
Reference-contexts: To implement the single hook Template Method, a simple solution is to make the template method a virtual procedure: AbstractClass: - TemplateMethod:&lt; - functionality_1 inner functionality_2 - 3 These concepts are introduced and discussed in detail in <ref> [Pree95] </ref> 7 . . .
References-found: 4

