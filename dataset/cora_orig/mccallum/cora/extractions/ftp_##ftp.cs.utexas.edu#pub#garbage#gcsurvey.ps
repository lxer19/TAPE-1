URL: ftp://ftp.cs.utexas.edu/pub/garbage/gcsurvey.ps
Refering-URL: http://www.cs.utexas.edu/users/oops/papers.html
Root-URL: 
Email: (wilson@cs.utexas.edu)  
Title: Uniprocessor Garbage Collection Techniques  
Author: Paul R. Wilson 
Address: Austin, Texas 78712-1188 USA  
Affiliation: University of Texas  
Abstract: We survey basic garbage collection algorithms, and variations such as incremental and generational collection. The basic algorithms include reference counting, mark-sweep, mark-compact, copying, and treadmill collection. Incremental techniques can keep garbage collection pause times short, by interleaving small amounts of collection work with program execution. Generational schemes improve efficiency and locality by garbage collecting a smaller area more often, while exploiting typical lifetime characteristics to avoid undue overhead from long-lived objects.
Abstract-found: 1
Intro-found: 1
Reference: [AEL88] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time concurrent garbage collection on stock multiprocessors. </title> <booktitle> In Proceedings of SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 11-20. </pages> <publisher> SIGPLAN ACM Press, </publisher> <month> June </month> <year> 1988. </year> <institution> Atlanta, Georgia. </institution>
Reference-contexts: The choice of a read- or write-barrier scheme is likely to be made on the basis of the available hardware. Without specialized hardware support, a write barrier appears to be easier to implement efficiently, because heap pointer writes are much less common than pointer traversals. Appel, Ellis and Li <ref> [AEL88] </ref> use virtual memory (pagewise) access protection facilities as a coarse approximation of Baker's read barrier [AEL88, AL91, Wil91]. Rather than checking each load to see if a pointer to fromspace is being loaded, the mutator is simply not allowed to see any page that might contain such a pointer. <p> Without specialized hardware support, a write barrier appears to be easier to implement efficiently, because heap pointer writes are much less common than pointer traversals. Appel, Ellis and Li [AEL88] use virtual memory (pagewise) access protection facilities as a coarse approximation of Baker's read barrier <ref> [AEL88, AL91, Wil91] </ref>. Rather than checking each load to see if a pointer to fromspace is being loaded, the mutator is simply not allowed to see any page that might contain such a pointer. Pointers in the scanned area of tospace are guaranteed to contain only pointers into tospace. <p> Features also interact in important ways. Fine-grained incremental collection is unnecessary in most systems without hard real-time constraints. Coarser incremental techniques may be sufficient, because the modest pause times are acceptable <ref> [AEL88, BDS91] </ref>, and the usually-short pauses of a stop-and-collect generational system may be acceptable enough for many systems [Ung84, WM89]. (On the other hand, the write barrier support for generational garbage collection could also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it <p> hand, the write barrier support for generational garbage collection could also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it might support fine-grained real-time collection at little cost.) In this introductory survey, we have not addressed the increasingly important areas of parallel <ref> [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] </ref> and distributed [LQP92, RMA92, JJ92, PS92] collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection [BW88, Bar88, Ede90, Wen90, WH91].
Reference: [AL91] <author> Andrew W. Appel and Kai Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (AS-PLOS IV), </booktitle> <pages> pages 96-107, </pages> <address> April 1991. Santa Clara, CA. </address>
Reference-contexts: Without specialized hardware support, a write barrier appears to be easier to implement efficiently, because heap pointer writes are much less common than pointer traversals. Appel, Ellis and Li [AEL88] use virtual memory (pagewise) access protection facilities as a coarse approximation of Baker's read barrier <ref> [AEL88, AL91, Wil91] </ref>. Rather than checking each load to see if a pointer to fromspace is being loaded, the mutator is simply not allowed to see any page that might contain such a pointer. Pointers in the scanned area of tospace are guaranteed to contain only pointers into tospace.
Reference: [And86] <author> David L. Andre. </author> <title> Paging in Lisp programs. </title> <type> Master's thesis, </type> <institution> University of Maryland, College Park, Maryland, </institution> <year> 1986. </year>
Reference-contexts: In a tracing collector, the traversal of live objects may have an important impact on locality. In a copying collector, objects are also reordered in memory as they are reached by the copy collector. What affect does this have on locality, and what traversal yields the best results <ref> [Bla83, Sta84, And86, WLM91] </ref>? 4. Collection scheduling. For a non-incremental collector, how might we avoid or mitigate the effect of disruptive pauses, especially in interactive applications [Ung84, WM89]? Can we improve efficiency by careful "opportunistic"scheduling [WM89, Hay91]? Can this be adapted to incremental schemes to reduce floating garbage? 5.
Reference: [App87] <author> Andrew W. Appel. </author> <title> Garbage collection can be faster than stack allocation. </title> <journal> Information Processing Letters, </journal> <volume> 25(4) </volume> <pages> 275-279, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: This ensures that each live object is transported exactly once, and that all pointers to the object are updated to refer to the new copy. Efficiency of Copying Collection. A copying garbage collector can be made arbitrarily efficient if sufficient memory is available <ref> [Lar77, App87] </ref>. The work done at each collection is proportional to the amount of live data at the time of garbage collection. <p> What is the best way to do this [WM89, BDS91, App89b, Wil90]? 5 Conclusions Recent advances in garbage collection technology make automatic storage reclamation affordable for use in high-performance systems. Even relatively simple garbage collectors' performance is often competitive with conventional explicit storage management <ref> [App87, Zor92] </ref>. Generational techniques reduce the basic costs and disruptiveness of collection by exploiting the empirically observed tendency of objects to die young; stock hardware incremental techniques may even make this relatively inexpensive for hard real-time systems.
Reference: [App89a] <author> Andrew W. Appel. </author> <title> Runtime tags aren't necessary. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2 </volume> <pages> 153-162, </pages> <year> 1989. </year>
Reference-contexts: For a purely statically-typed language, no per-object runtime type information is actually necessary, except the types of the root set variables. 4 Once those are known, the types of their referents are known, and their fields can be decoded <ref> [App89a, Gol91] </ref>. This process continues transitively, allowing types to be determined at every pointer traversal.
Reference: [App89b] <author> Andrew W. Appel. </author> <title> Simple generational garbage collection and fast allocation. </title> <journal> Software Practice and Experience, </journal> <volume> 19(2) </volume> <pages> 171-183, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Intergenerational references. Since it must be possible to scavenge younger generations without scavenging the older ones, we must be able to find the live pointers from older generations into the ones we're scavenging. What is the best way to do this <ref> [WM89, BDS91, App89b, Wil90] </ref>? 5 Conclusions Recent advances in garbage collection technology make automatic storage reclamation affordable for use in high-performance systems. Even relatively simple garbage collectors' performance is often competitive with conventional explicit storage management [App87, Zor92].
Reference: [App91] <author> Andrew W. Appel. </author> <title> Garbage collection. </title> <editor> In Peter Lee, editor, </editor> <booktitle> Topics in Advanced Language Implementation, </booktitle> <pages> pages 89-100. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: 1 Automatic Storage Reclamation Garbage collection is the automatic reclamation of computer storage <ref> [Knu69, Coh81, App91] </ref>. While in many systems programmers must explicitly reclaim heap memory at some point in the program, by using a "free" or "dispose" statement, garbage collected systems free the programmer from this burden.
Reference: [Bak78] <author> Henry G. Baker, Jr. </author> <title> List processing in real time on a serial computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: The best-known real-time garbage collector is Baker's incremental copying scheme <ref> [Bak78] </ref>. It is an adaptation of the simple copy collection scheme described in Sect. 2.5, and uses a read barrier for coordination with the 18 Fig. 7. A violation of the coloring invariant. mutator.
Reference: [Bak92] <author> Henry G. Baker, Jr. </author> <title> The Treadmill: Real-time garbage collection without motion sickness. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(3) </volume> <pages> 66-70, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: This will force garbage collections a third as often, or about 3 or 4 times during the run. This straightforwardly reduces the cost of garbage collection by more than half, as shown in the bottom part of Fig. 6. 2.5 Non-Copying Implicit Collection Recently, Baker <ref> [Bak92] </ref> has proposed a new kind of non-copying collector that with some of the efficiency advantages of a copying scheme. Baker's insight is that in a copying collector, the "spaces" of the collector are really just a particular implementation of sets.
Reference: [Bar88] <author> Joel F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Technical Report 88/2, </type> <institution> Digital Equipment Corporation Western Research Laboratory, Palo Alto, California, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: A major point in favor of in-place collectors (such as mark-sweep and treadmill schemes) is the ability to make them conservative with respect to data values that may be pointers or may not. This allows them to be used for languages like C, or off-the-shelf optimizing compilers <ref> [BW88, Bar88, BDS91] </ref>, which can make it difficult or impossible to unambiguously identify all pointers at run time. A non-moving collector can be conservative because anything that looks like a pointer object can be left where it is, and the (possible) pointer to it doesn't need to be changed. <p> In this introductory survey, we have not addressed the increasingly important areas of parallel [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] and distributed [LQP92, RMA92, JJ92, PS92] collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection <ref> [BW88, Bar88, Ede90, Wen90, WH91] </ref>.
Reference: [BDS91] <author> Hans-J. Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 157-164, </pages> <month> June </month> <year> 1991. </year> <institution> Toronto, </institution> <address> Ontario, Canada. </address>
Reference-contexts: reference to an object is eliminated, the count is decremented. (See Fig. 1.) The memory occupied by an object may be reclaimed when the object's count equals zero, since that indicates that no pointers to the object exist and the running program could not reach it. 4 Conservative garbage collectors <ref> [BW88, Wen90, BDS91, WH91] </ref> are usable with little or no cooperation from the compiler|not even the types of named variables|but we will not discuss them here. 5 Some authors use the term "garbage collection" in a narrower sense, which excludes reference counting and/or copy collection systems; we prefer the more inclusive <p> A major point in favor of in-place collectors (such as mark-sweep and treadmill schemes) is the ability to make them conservative with respect to data values that may be pointers or may not. This allows them to be used for languages like C, or off-the-shelf optimizing compilers <ref> [BW88, Bar88, BDS91] </ref>, which can make it difficult or impossible to unambiguously identify all pointers at run time. A non-moving collector can be conservative because anything that looks like a pointer object can be left where it is, and the (possible) pointer to it doesn't need to be changed. <p> This cost might be reduced by carefully choosing the ordering of root traversal, traversing the most stable structures first to avoid having the collector's work undone by mutator changes. Careful attention should be paid to write barrier implementation. Boehm, Demers and Shenker's <ref> [BDS91, Boe91] </ref> incremental update algorithm uses virtual memory dirty bits as a coarse pagewise write barrier. <p> Intergenerational references. Since it must be possible to scavenge younger generations without scavenging the older ones, we must be able to find the live pointers from older generations into the ones we're scavenging. What is the best way to do this <ref> [WM89, BDS91, App89b, Wil90] </ref>? 5 Conclusions Recent advances in garbage collection technology make automatic storage reclamation affordable for use in high-performance systems. Even relatively simple garbage collectors' performance is often competitive with conventional explicit storage management [App87, Zor92]. <p> Features also interact in important ways. Fine-grained incremental collection is unnecessary in most systems without hard real-time constraints. Coarser incremental techniques may be sufficient, because the modest pause times are acceptable <ref> [AEL88, BDS91] </ref>, and the usually-short pauses of a stop-and-collect generational system may be acceptable enough for many systems [Ung84, WM89]. (On the other hand, the write barrier support for generational garbage collection could also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it
Reference: [Bla83] <author> Ricki Blau. </author> <title> Paging on an object-oriented personal computer for Smalltalk. </title> <booktitle> In Proceedings of the ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <month> August </month> <year> 1983. </year> <institution> Minneapolis, MN. </institution> <note> Also appears as Technical Report UCB/CSD 83/125, </note> <institution> University of California at Berkeley, Computer Science Division (EECS), Berkeley, California, </institution> <month> August </month> <year> 1983. </year>
Reference-contexts: In a tracing collector, the traversal of live objects may have an important impact on locality. In a copying collector, objects are also reordered in memory as they are reached by the copy collector. What affect does this have on locality, and what traversal yields the best results <ref> [Bla83, Sta84, And86, WLM91] </ref>? 4. Collection scheduling. For a non-incremental collector, how might we avoid or mitigate the effect of disruptive pauses, especially in interactive applications [Ung84, WM89]? Can we improve efficiency by careful "opportunistic"scheduling [WM89, Hay91]? Can this be adapted to incremental schemes to reduce floating garbage? 5.
Reference: [Bob80] <author> Daniel G. Bobrow. </author> <title> Managing reentrant structures using reference counts. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(3) </volume> <pages> 269-273, </pages> <month> July </month> <year> 1980. </year>
Reference-contexts: The Efficiency Problem. The efficiency problem with reference counting is that its cost is generally proportional to the amount of work done by the running program, with a fairly large constant of proportionality. 6 <ref> [Bob80] </ref> describes modifications to reference counting to allow it to handle some special cases of cyclic structures, but this restricts the programmer to certain stereotyped patterns. 5 Fig. 2. Reference counting with unreclaimable cycle.
Reference: [Boe91] <author> Hans-Juergen Boehm. </author> <title> Hardware and operating system support for conservative garbage collection. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <pages> pages 61-67, </pages> <address> Palo Alto, California, </address> <month> October </month> <year> 1991. </year> <note> IEEE Press. </note>
Reference-contexts: Depending on the details of the garbage collector, this may require slight changes to the code generator, to emit certain extra information at compile time, and perhaps execute different instruction sequences at run time <ref> [Boe91, WH91, DMH92] </ref>. (Contrary to widespread misconceptions, there is no conflict between using a compiled language and garbage collection; state-of-the art implementations of garbage-collected languages use sophisticated optimizing compilers.) 1.2 The Two-Phase Abstraction Garbage collection automatically reclaims the space occupied by data objects that the running program can never access again. <p> This cost might be reduced by carefully choosing the ordering of root traversal, traversing the most stable structures first to avoid having the collector's work undone by mutator changes. Careful attention should be paid to write barrier implementation. Boehm, Demers and Shenker's <ref> [BDS91, Boe91] </ref> incremental update algorithm uses virtual memory dirty bits as a coarse pagewise write barrier.
Reference: [Bro84] <author> Rodney A. Brooks. </author> <title> Trading data space for reduced time and code space in real-time collection on stock hardware. </title> <booktitle> In Proceedings of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 108-113, </pages> <month> August </month> <year> 1984. </year> <institution> Austin, Texas. </institution>
Reference-contexts: Brooks has proposed a variation on Baker's scheme, where objects are always referred to via an indirection field embedded in the object itself <ref> [Bro84] </ref>. If an object is valid, its indirection field points to itself. If it's an obsolete version in tospace, its indirection pointer points to the new version. <p> For example, Brooks' collector <ref> [Bro84] </ref> is actually a write barrier algorithm, even though Brooks describes it as an optimization of Baker's scheme. 17 Similarly, Dawson's [Daw82] copy collection scheme is cast as a variant of Baker's, but it is actually an incremental update scheme, similar to Dijkstra et al.'s; objects are allocated in fromspace, i.e.,
Reference: [BW88] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: reference to an object is eliminated, the count is decremented. (See Fig. 1.) The memory occupied by an object may be reclaimed when the object's count equals zero, since that indicates that no pointers to the object exist and the running program could not reach it. 4 Conservative garbage collectors <ref> [BW88, Wen90, BDS91, WH91] </ref> are usable with little or no cooperation from the compiler|not even the types of named variables|but we will not discuss them here. 5 Some authors use the term "garbage collection" in a narrower sense, which excludes reference counting and/or copy collection systems; we prefer the more inclusive <p> A major point in favor of in-place collectors (such as mark-sweep and treadmill schemes) is the ability to make them conservative with respect to data values that may be pointers or may not. This allows them to be used for languages like C, or off-the-shelf optimizing compilers <ref> [BW88, Bar88, BDS91] </ref>, which can make it difficult or impossible to unambiguously identify all pointers at run time. A non-moving collector can be conservative because anything that looks like a pointer object can be left where it is, and the (possible) pointer to it doesn't need to be changed. <p> In this introductory survey, we have not addressed the increasingly important areas of parallel [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] and distributed [LQP92, RMA92, JJ92, PS92] collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection <ref> [BW88, Bar88, Ede90, Wen90, WH91] </ref>.
Reference: [CG77] <author> Douglas W. Clark and C. Cordell Green. </author> <title> An empirical study of list structure in LISP. </title> <journal> Communications of the ACM, </journal> <volume> 20(2) </volume> <pages> 78-87, </pages> <month> February </month> <year> 1977. </year>
Reference-contexts: In addition, the garbage spaces are simply "squeezed out," without disturbing the original ordering of objects in memory. This can ameliorate locality problems, because the allocation ordering is usually more similar to subsequent access orderings than an arbitrary ordering imposed by a garbage collector <ref> [CG77, Cla79] </ref>. While the locality that results from sliding compaction is advantageous, the collection process itself shares the mark-sweep's unfortunate property that several passes over the data are required. After the initial marking phase, sliding compactors make two or three more passes over the live objects [CN83].
Reference: [Cha92] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for an Object-Oriented Programming Language. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: The Explorer used exit tables, indirecting the pointers out of each generation; for each generation, there is a separate exit table for pointers into each younger generation [Cou88]. 22 Ungar and Chambers' improvement <ref> [Cha92] </ref>, of our "card marking" scheme [WM89, Wil90] decreases the cost per heap write by using whole bytes as dirty bits.
Reference: [Che70] <author> C. J. </author> <title> Cheney. A nonrecursive list compacting algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 13(11) </volume> <pages> 677-678, </pages> <month> November </month> <year> 1970. </year> <month> 31 </month>
Reference-contexts: A Simple Copying Collector: "Stop-and-Copy" Using Semispaces. A very common kind of copying garbage collector is the semispace collector [FY69] using the Cheney algorithm for the copying traversal <ref> [Che70] </ref>. We will use this collector as a reference model for much of this paper. 9 In this scheme, the space devoted to the heap is subdivided into two contiguous semispaces. During normal program execution, only one of these semispaces is in use, as shown in Fig. 3. <p> Once the copying is completed, the tospace semispace is made the "current" semispace, and program execution is resumed. Thus the roles of the two spaces are reversed each time the garbage collector is invoked. (See Fig. 4.) Perhaps the simplest form of copying traversal is the Cheney algorithm <ref> [Che70] </ref>. The immediately-reachable objects form the initial queue of objects for a breadth-first traversal. A "scan" pointer is advanced through the first object, location by location.
Reference: [Cla79] <author> Douglas W. Clark. </author> <title> Measurements of dynamic list structure use in Lisp. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(1) </volume> <pages> 51-59, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: In addition, the garbage spaces are simply "squeezed out," without disturbing the original ordering of objects in memory. This can ameliorate locality problems, because the allocation ordering is usually more similar to subsequent access orderings than an arbitrary ordering imposed by a garbage collector <ref> [CG77, Cla79] </ref>. While the locality that results from sliding compaction is advantageous, the collection process itself shares the mark-sweep's unfortunate property that several passes over the data are required. After the initial marking phase, sliding compactors make two or three more passes over the live objects [CN83].
Reference: [CN83] <author> Jacques Cohen and Alexandru Nicolau. </author> <title> Comparison of compacting algorithms for garbage collection. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(4) </volume> <pages> 532-553, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: While the locality that results from sliding compaction is advantageous, the collection process itself shares the mark-sweep's unfortunate property that several passes over the data are required. After the initial marking phase, sliding compactors make two or three more passes over the live objects <ref> [CN83] </ref>. One pass computes the new locations that objects will be moved to; subsequent passes must update pointers to refer to objects' new locations, and actually move the objects. These algorithms may be therefore be significantly slower than mark-sweep if a large percentage of data survives to be compacted. <p> live objects, and the other scans upward from the bottom, looking for a hole to put it in. (Many variations of this algorithm are possible, to deal with multiple areas holding different-sized objects, and to avoid intermingling objects from widely-dispersed areas.) For a more complete treatment of compacting algorithms, see <ref> [Knu69, CN83] </ref>. 2.4 Copying Garbage Collection Like mark-compact (but unlike mark-sweep), copying garbage collection does not really "collect" garbage.
Reference: [Coh81] <author> Jacques Cohen. </author> <title> Garbage collection of linked data structures. </title> <journal> Computing Surveys, </journal> <volume> 13(3) </volume> <pages> 341-367, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: 1 Automatic Storage Reclamation Garbage collection is the automatic reclamation of computer storage <ref> [Knu69, Coh81, App91] </ref>. While in many systems programmers must explicitly reclaim heap memory at some point in the program, by using a "free" or "dispose" statement, garbage collected systems free the programmer from this burden. <p> This paper is intended to be an introductory survey of garbage collectors for uniprocessors, especially those developed in the last decade. For a more thorough treatment of older techniques, see <ref> [Knu69, Coh81] </ref>. 1.1 Motivation Garbage collection is necessary for fully modular programming, to avoid introducing unnecessary inter-module dependencies. A routine operating on a data structure should not have to know what other routines may be operating on the same structure, unless there is some good reason to coordinate their activities.
Reference: [Col60] <author> George E. Collins. </author> <title> A method for overlapping and erasure of lists. </title> <journal> Communications of the ACM, </journal> <volume> 2(12) </volume> <pages> 655-657, </pages> <month> December </month> <year> 1960. </year>
Reference-contexts: distinguishing live objects from garbage, may be done in several ways: by reference counting, marking, or copying. 5 Because each scheme has a major influence on the second part (reclamation) and on reuse techniques, we will introduce reclamation methods as we go. 2.1 Reference Counting In a reference counting system <ref> [Col60] </ref>, each object has an associated count of the references (pointers) to it. Each time a reference to the object is created, e.g., when a pointer is copied from one place to another by an assignment, the object's count is incremented.
Reference: [Cou88] <author> Robert Courts. </author> <title> Improving locality of reference in a garbage-collecting memory management system. </title> <journal> Communications of the ACM, </journal> <volume> 31(9) </volume> <pages> 1128-1138, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Such indirections are transparent to the user program. This technique was implemented on Lisp machines such as the MIT machines [Gre84] and Texas Instruments Explorer <ref> [Cou88] </ref>. (There are minor differences between the two, but the principles are the same. 21 ) Note that other techniques are often more appropriate, especially on stock hardware. Using indirection tables introduces overhead similar to that of Baker's read barrier. A pointer recording technique can be used instead. <p> The Explorer used exit tables, indirecting the pointers out of each generation; for each generation, there is a separate exit table for pointers into each younger generation <ref> [Cou88] </ref>. 22 Ungar and Chambers' improvement [Cha92], of our "card marking" scheme [WM89, Wil90] decreases the cost per heap write by using whole bytes as dirty bits.
Reference: [CWB86] <author> Patrick J. Caudill and Allen Wirfs-Brock. </author> <title> A third-generation Smalltalk-80 implementation. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> ACM SIGPLAN 1986 Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA '86), </booktitle> <pages> pages 119-130, </pages> <month> September </month> <year> 1986. </year> <note> Also published as ACM SIGPLAN Notices 21(11) 119-130, </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Further, real high-performance systems often use hybrid techniques to adjust tradeoffs for different categories of objects. Many high-performance copy collectors use a separate large object area <ref> [CWB86, UJ88] </ref>, to avoid copying large objects from space to space. The large objects are kept "off to the side" and usually managed in-place by some variety of marking traversal and free list technique. <p> to scale|the younger generation is typically several times smaller than the older one.) The number of generations may be greater than two, with each successive generation holding older objects and being scavenged considerably less often. (Tektronix 4406 Smalltalk is such a generational system, using semispaces for each of eight generations <ref> [CWB86] </ref>.) 4.2 Detecting Intergenerational References In order for this scheme to work, it must be possible to scavenge the younger generation (s) without scavenging the older one (s).
Reference: [Daw82] <author> Jeffrey L. Dawson. </author> <title> Improved effectiveness from a real-time LISP garbage collector. </title> <booktitle> In SIGPLAN Symposium on LISP and Functional Programming, </booktitle> <pages> pages 159-167, </pages> <month> August </month> <year> 1982. </year>
Reference-contexts: For example, Brooks' collector [Bro84] is actually a write barrier algorithm, even though Brooks describes it as an optimization of Baker's scheme. 17 Similarly, Dawson's <ref> [Daw82] </ref> copy collection scheme is cast as a variant of Baker's, but it is actually an incremental update scheme, similar to Dijkstra et al.'s; objects are allocated in fromspace, i.e., white.
Reference: [DB76] <author> L. Peter Deutsch and Daniel G. Bobrow. </author> <title> An efficient, incremental, automatic garbage collector. </title> <journal> Communications of the ACM, </journal> <volume> 19(9) </volume> <pages> 522-526, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: It is desirable to optimize away most of these increments and decrements that cancel each 6 other out. Deferred Reference Counting. Much of this cost can be optimized away by special treatment of local variables <ref> [DB76] </ref>. Rather than always adjusting reference counts and reclaiming objects whose counts become zero, references from the local variables are not included in this bookkeeping most of the time. Usually, reference counts are only adjusted to reflect pointers from one heap object to another. <p> The interval between these phases is generally chosen to be short enough that garbage is reclaimed often and quickly, yet still long enough that the cost of periodically updating counts (for stack references) is not high. This deferred reference counting <ref> [DB76] </ref> avoids adjusting reference counts for most short-lived pointers from the stack, and greatly reduces the overhead of reference counting. When pointers from one heap object to another are created or destroyed, however, the reference counts must still be adjusted.
Reference: [DeT90] <author> John DeTreville. </author> <title> Experience with concurrent garbage collectors for Modula-2+. </title> <type> Technical Report 64, </type> <institution> Digital Equipment Corporation Systems Research Center, Palo Alto, California, </institution> <month> August </month> <year> 1990. </year>
Reference-contexts: objects which can then be reclaimed. 2.2 Mark-Sweep Collection Mark-sweep garbage collectors [McC60] are named for the two phases that implement the abstract garbage collection algorithm we described earlier: 7 This can be useful for finalization, that is, performing "clean-up" actions (like closing files) when objects die [Rov85]. 8 DeTreville <ref> [DeT90] </ref> argues that the locality characteristics of reference-counting may be superior to those of other collection techniques, based on experience with the Topaz system. However, as [WLM92] shows, generational techniques can recapture some of this locality. 7 1. Distinguish the live objects from the garbage. <p> In most programs in a variety of languages, most objects live a very short time, while a small percentage of them live much longer <ref> [LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>.
Reference: [DLM + 78] <author> Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. </author> <title> On-the-fly garbage collection: An exercise in cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: The difficulty with incremental tracing is that while the collector is tracing out the graph of reachable data structures, the graph may change|the running program may mutate the graph while the collector "isn't looking." For this reason, discussions of incremental collectors typically refer to the running program as the mutator <ref> [DLM + 78] </ref>. (From the garbage collector's point of view, the actual application is merely a coroutine or concurrent process with an unfortunate tendency to modify data structures that the collector is attempting to traverse.) An incremental scheme must have some way of keeping track of the changes to the graph <p> Unfortunately, incremental update algorithms have generally been cast in terms of parallel systems, rather than as incremental schemes for serial processing; perhaps due to this, they have been largely overlooked by implementors targeting uniprocessors. Perhaps the best known of these algorithms is due to Dijkstra et al. <ref> [DLM + 78] </ref>. (This is similar to the scheme developed independently by Steele [Ste75], but simpler because it does not deal with compactification.) Rather than retaining everything that's in a snapshot of the graph at the beginning of garbage collection, it heuristically (and somewhat conservatively) attempts to retain the objects that <p> hand, the write barrier support for generational garbage collection could also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it might support fine-grained real-time collection at little cost.) In this introductory survey, we have not addressed the increasingly important areas of parallel <ref> [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] </ref> and distributed [LQP92, RMA92, JJ92, PS92] collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection [BW88, Bar88, Ede90, Wen90, WH91].
Reference: [DMH92] <author> Amer Diwan, Eliot Moss, and Richard Hudson. </author> <title> Compiler support for garbage collection in a statically-typed language. </title> <booktitle> In SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 273-282, </pages> <address> San Francisco, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Depending on the details of the garbage collector, this may require slight changes to the code generator, to emit certain extra information at compile time, and perhaps execute different instruction sequences at run time <ref> [Boe91, WH91, DMH92] </ref>. (Contrary to widespread misconceptions, there is no conflict between using a compiled language and garbage collection; state-of-the art implementations of garbage-collected languages use sophisticated optimizing compilers.) 1.2 The Two-Phase Abstraction Garbage collection automatically reclaims the space occupied by data objects that the running program can never access again.
Reference: [DWH + 90] <author> Alan Demers, Mark Weiser, Barry Hayes, Daniel Bobrow, and Scott Shenker. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Conf. Record of the Seventeeth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 261-269, </pages> <month> January </month> <year> 1990. </year> <institution> Las Vegas, Nevada. </institution>
Reference-contexts: Generational mark-sweep collectors are somewhat harder to construct, but they do exist and are quite practical <ref> [DWH + 90] </ref>. 10 Deferred reference counting, like tracing collection, also trades space for time|in giving up continual incremental reclamation to avoid spending CPU cycles in adjusting reference counts, one gives up space for objects that become garbage and are not immediately reclaimed. <p> by changing the sense of the bit patterns, rather than the patterns themselves. 16 This kind of conservatism is not to be confused with the conservative treatment of pointers that cannot be unambiguously identified. (For a more complete and formal discussion of various kinds of conservatism in garbage collection, see <ref> [DWH + 90] </ref>.) Yuasa's scheme has a large advantage over Baker's on stock hardware, because only heap pointer writes must be treated specially to preserve the garbage collector invariants. Normal pointer dereferencing and comparison does not incur any extra overhead. <p> These survivors are advanced to older status after a few scavenges, to keep copying costs down. (For historical reasons and simplicity of explanation, we will focus on generational copying collectors. The choice of copying or marking collection is essentially orthogonal to the issue of generational collection, however <ref> [DWH + 90] </ref>.) 4.1 Multiple Subheaps with Varying Scavenge Frequencies Consider a generational garbage collector based on the semispace organization: memory is divided into areas that will hold objects of different approximate ages, or generations; each generation's memory is further divided into semispaces.
Reference: [Ede90] <author> Daniel Ross Edelson. </author> <title> Dynamic storage reclamation in C++. </title> <type> Technical Report UCSC-CRL-90-19, </type> <institution> University of California at Santa Cruz, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: In this introductory survey, we have not addressed the increasingly important areas of parallel [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] and distributed [LQP92, RMA92, JJ92, PS92] collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection <ref> [BW88, Bar88, Ede90, Wen90, WH91] </ref>.
Reference: [FY69] <author> Robert R. Fenichel and Jerome C. Yochelson. </author> <title> A LISP garbage-collector for virtual-memory computer systems. </title> <journal> Communications of the ACM, </journal> <volume> 12(11) </volume> <pages> 611-612, </pages> <month> November </month> <year> 1969. </year>
Reference-contexts: The term scavenging is applied to the copying traversal, because it consists of picking out the worthwhile objects amid the garbage, and taking them away. A Simple Copying Collector: "Stop-and-Copy" Using Semispaces. A very common kind of copying garbage collector is the semispace collector <ref> [FY69] </ref> using the Cheney algorithm for the copying traversal [Che70]. We will use this collector as a reference model for much of this paper. 9 In this scheme, the space devoted to the heap is subdivided into two contiguous semispaces.
Reference: [Gol91] <author> Benjamin Goldberg. </author> <title> Tag-free garbage collection for strongly-typed programming languages. </title> <booktitle> In SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 165-176, </pages> <month> June </month> <year> 1991. </year> <institution> Toronto, </institution> <address> Ontario, Canada. </address>
Reference-contexts: For a purely statically-typed language, no per-object runtime type information is actually necessary, except the types of the root set variables. 4 Once those are known, the types of their referents are known, and their fields can be decoded <ref> [App89a, Gol91] </ref>. This process continues transitively, allowing types to be determined at every pointer traversal.
Reference: [Gre84] <author> Richard Greenblatt. </author> <title> The LISP machine. In D.R. </title> <editor> Barstow, H.E. Shrobe, and E. Sandewall, editors, </editor> <title> Interactive Programming Environments. </title> <publisher> McGraw Hill, </publisher> <year> 1984. </year>
Reference-contexts: The cost of these checks is high on conventional hardware, because they occur very frequently. Lisp Machines have special purpose hardware to detect pointers into fromspace and trap to a handler <ref> [Gre84, Moo84, Joh91] </ref>, but on conventional machines the checking overhead is in the tens of percent for a high performance system. Brooks has proposed a variation on Baker's scheme, where objects are always referred to via an indirection field embedded in the object itself [Bro84]. <p> Such indirections are transparent to the user program. This technique was implemented on Lisp machines such as the MIT machines <ref> [Gre84] </ref> and Texas Instruments Explorer [Cou88]. (There are minor differences between the two, but the principles are the same. 21 ) Note that other techniques are often more appropriate, especially on stock hardware. Using indirection tables introduces overhead similar to that of Baker's read barrier.
Reference: [Hay91] <author> Barry Hayes. </author> <title> Using key object opportunism to collect old objects. </title> <booktitle> In ACM SIGPLAN 1991 Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA '91), </booktitle> <pages> pages 33-46, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year> <note> ACM Press. </note>
Reference-contexts: The clustered survival of objects may also mitigate the locality problems of re-allocating space amid live objects; if objects tend to survive or die in groups in memory <ref> [Hay91] </ref>, the interspersing of objects used by different program phases may not be a major consideration. At this point, the technology of mark-sweep collectors (and related hybrids) is rapidly evolving. <p> In most programs in a variety of languages, most objects live a very short time, while a small percentage of them live much longer <ref> [LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>. <p> What affect does this have on locality, and what traversal yields the best results [Bla83, Sta84, And86, WLM91]? 4. Collection scheduling. For a non-incremental collector, how might we avoid or mitigate the effect of disruptive pauses, especially in interactive applications [Ung84, WM89]? Can we improve efficiency by careful "opportunistic"scheduling <ref> [WM89, Hay91] </ref>? Can this be adapted to incremental schemes to reduce floating garbage? 5. Intergenerational references. Since it must be possible to scavenge younger generations without scavenging the older ones, we must be able to find the live pointers from older generations into the ones we're scavenging.
Reference: [HMS92] <author> Antony L. Hosking, J. Eliot B. Moss, and Darko Stefanovic. </author> <title> A comparative performance evaluation of write barrier implementations. </title> <booktitle> In ACM SIGPLAN 1992 Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA '92), </booktitle> <address> Vancouver, British Columbia, Canada, </address> <month> October </month> <year> 1992. </year> <note> To appear. </note>
Reference-contexts: The write barrier may do checking at each store, or it may be as simple as maintaining dirty bits and scanning dirty areas at collection time <ref> [Sha88, Sob88, WM89, Wil90, HMS92] </ref>. 22 ; the same mechanism might support real-time incremental collection as well. The important point is that all references from old to new memory must be located at scavenge time, and used as roots for the copying traversal.
Reference: [JJ92] <author> Niels Christian Juul and Eric Jul. </author> <title> Comprehensive and robust garbage collection in a distributed system. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <booktitle> Springer-Verlag Lecture Notes in Computer Science series. </booktitle>
Reference-contexts: also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it might support fine-grained real-time collection at little cost.) In this introductory survey, we have not addressed the increasingly important areas of parallel [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] and distributed <ref> [LQP92, RMA92, JJ92, PS92] </ref> collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection [BW88, Bar88, Ede90, Wen90, WH91].
Reference: [Joh91] <author> Douglas Johnson. </author> <title> The case for a read barrier. </title> <booktitle> In Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS IV), </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, California, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: The cost of these checks is high on conventional hardware, because they occur very frequently. Lisp Machines have special purpose hardware to detect pointers into fromspace and trap to a handler <ref> [Gre84, Moo84, Joh91] </ref>, but on conventional machines the checking overhead is in the tens of percent for a high performance system. Brooks has proposed a variation on Baker's scheme, where objects are always referred to via an indirection field embedded in the object itself [Bro84].
Reference: [Joh92] <author> Ralph E. Johnson. </author> <title> Reducing the latency of a real-time garbage collector. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(1) </volume> <pages> 46-58, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The actual coordination, in terms of tricolor marking, is through a write barrier. 18 Ralph Johnson has improved on this scheme by incorporating lazier copying of objects to fromspace <ref> [Joh92] </ref>.
Reference: [Knu69] <author> Donald E. Knuth. </author> <booktitle> The Art of Computer Programming, Volume 1: Fundamental Algorithms, chapter 2.3.5, </booktitle> <pages> pages 406-422. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1969. </year> <month> 32 </month>
Reference-contexts: 1 Automatic Storage Reclamation Garbage collection is the automatic reclamation of computer storage <ref> [Knu69, Coh81, App91] </ref>. While in many systems programmers must explicitly reclaim heap memory at some point in the program, by using a "free" or "dispose" statement, garbage collected systems free the programmer from this burden. <p> This paper is intended to be an introductory survey of garbage collectors for uniprocessors, especially those developed in the last decade. For a more thorough treatment of older techniques, see <ref> [Knu69, Coh81] </ref>. 1.1 Motivation Garbage collection is necessary for fully modular programming, to avoid introducing unnecessary inter-module dependencies. A routine operating on a data structure should not have to know what other routines may be operating on the same structure, unless there is some good reason to coordinate their activities. <p> live objects, and the other scans upward from the bottom, looking for a hole to put it in. (Many variations of this algorithm are possible, to deal with multiple areas holding different-sized objects, and to avoid intermingling objects from widely-dispersed areas.) For a more complete treatment of compacting algorithms, see <ref> [Knu69, CN83] </ref>. 2.4 Copying Garbage Collection Like mark-compact (but unlike mark-sweep), copying garbage collection does not really "collect" garbage.
Reference: [KS77] <author> H.T. Kung and S.W. Song. </author> <title> An efficient parallel garbage collection system and its correctness proof. </title> <booktitle> In IEEE Symposum on Foundations of Computer Science, </booktitle> <pages> pages 120-131, </pages> <address> Providence, Rhode Island, </address> <month> October </month> <year> 1977. </year>
Reference-contexts: hand, the write barrier support for generational garbage collection could also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it might support fine-grained real-time collection at little cost.) In this introductory survey, we have not addressed the increasingly important areas of parallel <ref> [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] </ref> and distributed [LQP92, RMA92, JJ92, PS92] collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection [BW88, Bar88, Ede90, Wen90, WH91].
Reference: [Lar77] <author> R. G. Larson. </author> <title> Minimizing garbage collection as a function of region size. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6(4) </volume> <pages> 663-667, </pages> <month> December </month> <year> 1977. </year>
Reference-contexts: This ensures that each live object is transported exactly once, and that all pointers to the object are updated to refer to the new copy. Efficiency of Copying Collection. A copying garbage collector can be made arbitrarily efficient if sufficient memory is available <ref> [Lar77, App87] </ref>. The work done at each collection is proportional to the amount of live data at the time of garbage collection. <p> a high-speed processor [Ung84], and the paging caused by the copying collection itself may be tremendous, since all live data must be touched in the process.) It therefore doesn't generally pay to make the heap area larger than the available main memory. (For a mathematical treatment of this tradeoff, see <ref> [Lar77] </ref>.) Even as main memory becomes steadily cheaper, locality within cache memory becomes increasingly important, so the problem is simply shifted to a different level of the memory hierarchy [WLM92].
Reference: [LH83] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: In most programs in a variety of languages, most objects live a very short time, while a small percentage of them live much longer <ref> [LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>. <p> These objects are copied at every scavenge, over and over, and the garbage collector spends most of its time copying the same old objects repeatedly. This is the major source of inefficiency in simple garbage collectors. Generational collection <ref> [LH83] </ref> avoids much of this repeated copying by segregating objects into multiple areas by age, and scavenging areas containing older objects less often than the younger ones. Once objects have survived a small number of scavenges, they are moved to a less frequently scavenged area. <p> Either event destroys the integrity and consistency of data structures in the heap.) In the original generational collection scheme <ref> [LH83] </ref> scheme, no pointer in old memory may point directly to an object in new memory; instead it must point to a cell in an indirection table, which is used as part of the root set. Such indirections are transparent to the user program. <p> Even if new-to-old pointers are not recorded, it may still be feasible to scavenge a generation without scavenging newer ones. In this case, all data in the newer generations may be considered possible roots, and they may simply be scanned for pointers <ref> [LH83] </ref>.
Reference: [LQP92] <author> Bernard Lang, Christian Queinnec, and Jose Piquer. </author> <title> Garbage collecting the world. </title> <booktitle> In ACM Symposium on Principles of Programming, </booktitle> <pages> pages 39-50, </pages> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it might support fine-grained real-time collection at little cost.) In this introductory survey, we have not addressed the increasingly important areas of parallel [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] and distributed <ref> [LQP92, RMA92, JJ92, PS92] </ref> collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection [BW88, Bar88, Ede90, Wen90, WH91].
Reference: [McB63] <author> J. Harold McBeth. </author> <title> On the reference counter method. </title> <journal> Communications of the ACM, </journal> <volume> 6(9):575, </volume> <month> September </month> <year> 1963. </year>
Reference-contexts: If the pointers in a group of objects create a (directed) cycle, the objects' reference counts are never reduced to zero, even if there is no path to the objects from the root set <ref> [McB63] </ref>. the other, and therefore each has a reference count of one. Since no path from a root leads to either, however, the program can never reach them again. Conceptually speaking, the problem here is that reference counting really only determines a conservative approximation of true liveness.
Reference: [McC60] <author> John McCarthy. </author> <title> Recursive functions of symbolic expressions and their computation by machine. </title> <journal> Communications of the ACM, </journal> <volume> 3(4) </volume> <pages> 184-195, </pages> <month> April </month> <year> 1960. </year>
Reference-contexts: collection technique on conventional uniprocessor hardware.) For most high-performance general-purpose systems, reference counting has been abandoned in favor of tracing garbage collectors, which actually traverse (trace out) the graph of live objects, distinguishing them from the unreachable (garbage) objects which can then be reclaimed. 2.2 Mark-Sweep Collection Mark-sweep garbage collectors <ref> [McC60] </ref> are named for the two phases that implement the abstract garbage collection algorithm we described earlier: 7 This can be useful for finalization, that is, performing "clean-up" actions (like closing files) when objects die [Rov85]. 8 DeTreville [DeT90] argues that the locality characteristics of reference-counting may be superior to those
Reference: [Min63] <author> Marvin Minsky. </author> <title> A LISP garbage collector algorithm using serial secondary storage. A.I Memo 58, Project MAC, </title> <publisher> MIT, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1963. </year>
Reference-contexts: the running program demands an allocation that will not fit in the unused area of the current semispace, the program is stopped and the copying garbage collector is called to reclaim space (hence the term 9 As a historical note, the first copying collector was Minsky's collector for Lisp 1.5 <ref> [Min63] </ref>. Rather than copying data from one area of memory to another, a single heap space was used. The live data were copied out to a file, and then read back in, in a contiguous area of the heap space.
Reference: [Moo84] <author> David Moon. </author> <title> Garbage collection in a large Lisp system. </title> <booktitle> In Conference Record of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 235-246, </pages> <address> Austin, Texas, </address> <month> August </month> <year> 1984. </year>
Reference-contexts: The cost of these checks is high on conventional hardware, because they occur very frequently. Lisp Machines have special purpose hardware to detect pointers into fromspace and trap to a handler <ref> [Gre84, Moo84, Joh91] </ref>, but on conventional machines the checking overhead is in the tens of percent for a high performance system. Brooks has proposed a variation on Baker's scheme, where objects are always referred to via an indirection field embedded in the object itself [Bro84]. <p> A pointer recording technique can be used instead. Rather than indirecting pointers from old objects to young ones, normal (direct) pointers are allowed, but the locations of such pointers are noted so that they can be found at scavenge time. This requires something like a write barrier <ref> [Ung84, Moo84] </ref>; that is, the running program cannot freely modify the reachability graph by storing pointers into objects in older generation. <p> Advancement policy. How long must an object survive in one generation before it is advanced to the next? [Ung84, WM89] 2. Heap organization. How should storage space be divided and used between generations, and within a generation <ref> [Moo84, Ung84, Sha88, WM89] </ref>? How does the resulting reuse pattern affect locality at the virtual memory level [Ung84, Zor89, WM89], and at the level of high-speed cache memories [Zor91, WLM92]? 3. Traversal algorithms. In a tracing collector, the traversal of live objects may have an important impact on locality.
Reference: [Nil88] <author> Kelvin Nilsen. </author> <title> Garbage collection of strings and linked data structures in real time. </title> <journal> Software, Practice and Experience, </journal> <volume> 18(7) </volume> <pages> 613-640, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: By two occupied areas of tospace thus grow toward each other. 13 Nilsen's variant of Baker's algorithm updates the pointers without actually copying the objects|the copying is lazy, and space in tospace is simply reserved for the object before the pointer is updated <ref> [Nil88] </ref>.
Reference: [NR87] <author> S. C. North and J. H. Reppy. </author> <title> Concurrent Garbage Collection on Stock Hardware, </title> <booktitle> pages 113-133. Number 274 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1987. </year>
Reference-contexts: Unconditionally indirecting is cheaper than checking for indirections, but would still incur overheads in the tens of percent for a high-performance system. (A variant of this approach has been used by North and Reppy in a concurrent garbage collector <ref> [NR87] </ref>.) Zorn takes a different approach to reducing the read barrier overhead, using knowledge of important special cases and special compiler techniques. <p> hand, the write barrier support for generational garbage collection could also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it might support fine-grained real-time collection at little cost.) In this introductory survey, we have not addressed the increasingly important areas of parallel <ref> [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] </ref> and distributed [LQP92, RMA92, JJ92, PS92] collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection [BW88, Bar88, Ede90, Wen90, WH91].
Reference: [PS92] <author> David Plainfosse and Marc Shapiro. </author> <title> Experience with fault tolerant garbage collection in a distributed Lisp system. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <booktitle> Springer-Verlag Lecture Notes in Computer Science series. </booktitle>
Reference-contexts: also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it might support fine-grained real-time collection at little cost.) In this introductory survey, we have not addressed the increasingly important areas of parallel [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] and distributed <ref> [LQP92, RMA92, JJ92, PS92] </ref> collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection [BW88, Bar88, Ede90, Wen90, WH91].
Reference: [RMA92] <author> G. Ringwood, E. Miranda, and S. Abdullahi. </author> <title> Distributed garbage collection. </title> <booktitle> In International Workshop on Memory Management, </booktitle> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <booktitle> Springer-Verlag Lecture Notes in Computer Science series. </booktitle>
Reference-contexts: also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it might support fine-grained real-time collection at little cost.) In this introductory survey, we have not addressed the increasingly important areas of parallel [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] and distributed <ref> [LQP92, RMA92, JJ92, PS92] </ref> collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection [BW88, Bar88, Ede90, Wen90, WH91].
Reference: [Rov85] <author> Paul Rovner. </author> <title> On adding garbage collection and runtime types to a strongly-typed, statically checked, concurrent language. </title> <type> Technical Report CSL-84-7, </type> <institution> Xerox Palo Alto Research Center, Palo Alto, California, </institution> <month> July </month> <year> 1985. </year>
Reference-contexts: the unreachable (garbage) objects which can then be reclaimed. 2.2 Mark-Sweep Collection Mark-sweep garbage collectors [McC60] are named for the two phases that implement the abstract garbage collection algorithm we described earlier: 7 This can be useful for finalization, that is, performing "clean-up" actions (like closing files) when objects die <ref> [Rov85] </ref>. 8 DeTreville [DeT90] argues that the locality characteristics of reference-counting may be superior to those of other collection techniques, based on experience with the Topaz system. However, as [WLM92] shows, generational techniques can recapture some of this locality. 7 1. Distinguish the live objects from the garbage.
Reference: [Sha88] <author> Robert A. Shaw. </author> <title> Empirical Analysis of a Lisp System. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, California, </institution> <month> February </month> <year> 1988. </year> <note> Also appears as Technical Report CSL-TR-88-351, </note> <institution> Stanford University Computer Systems Laboratory, </institution> <year> 1988. </year>
Reference-contexts: In most programs in a variety of languages, most objects live a very short time, while a small percentage of them live much longer <ref> [LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>. <p> The write barrier may do checking at each store, or it may be as simple as maintaining dirty bits and scanning dirty areas at collection time <ref> [Sha88, Sob88, WM89, Wil90, HMS92] </ref>. 22 ; the same mechanism might support real-time incremental collection as well. The important point is that all references from old to new memory must be located at scavenge time, and used as roots for the copying traversal. <p> Advancement policy. How long must an object survive in one generation before it is advanced to the next? [Ung84, WM89] 2. Heap organization. How should storage space be divided and used between generations, and within a generation <ref> [Moo84, Ung84, Sha88, WM89] </ref>? How does the resulting reuse pattern affect locality at the virtual memory level [Ung84, Zor89, WM89], and at the level of high-speed cache memories [Zor91, WLM92]? 3. Traversal algorithms. In a tracing collector, the traversal of live objects may have an important impact on locality.
Reference: [Sob88] <author> Patrick G. Sobalvarro. </author> <title> A lifetime-based garbage collector for LISP systems on general-purpose computers. B.S. </title> <type> thesis, </type> <institution> Massachusetts Institute of Technology, Electrical Engineering and Computer Science Department, Cambridge, Massachusetts, </institution> <year> 1988. </year>
Reference-contexts: The write barrier may do checking at each store, or it may be as simple as maintaining dirty bits and scanning dirty areas at collection time <ref> [Sha88, Sob88, WM89, Wil90, HMS92] </ref>. 22 ; the same mechanism might support real-time incremental collection as well. The important point is that all references from old to new memory must be located at scavenge time, and used as roots for the copying traversal.
Reference: [SS91] <author> Ravi Sharma and Mary Lou Soffa. </author> <title> Parallel generational garbage collection. </title> <booktitle> In ACM SIGPLAN 1991 Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA '91), </booktitle> <pages> pages 16-32, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: hand, the write barrier support for generational garbage collection could also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it might support fine-grained real-time collection at little cost.) In this introductory survey, we have not addressed the increasingly important areas of parallel <ref> [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] </ref> and distributed [LQP92, RMA92, JJ92, PS92] collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection [BW88, Bar88, Ede90, Wen90, WH91].
Reference: [Sta84] <author> James William Stamos. </author> <title> Static grouping of small objects to enhance performance of a paged virtual memory. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(2) </volume> <pages> 155-180, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: In a tracing collector, the traversal of live objects may have an important impact on locality. In a copying collector, objects are also reordered in memory as they are reached by the copy collector. What affect does this have on locality, and what traversal yields the best results <ref> [Bla83, Sta84, And86, WLM91] </ref>? 4. Collection scheduling. For a non-incremental collector, how might we avoid or mitigate the effect of disruptive pauses, especially in interactive applications [Ung84, WM89]? Can we improve efficiency by careful "opportunistic"scheduling [WM89, Hay91]? Can this be adapted to incremental schemes to reduce floating garbage? 5.
Reference: [Ste75] <author> Guy L. Steele Jr. </author> <title> Multiprocessing compactifying garbage collection. </title> <journal> Communications of the ACM, </journal> <volume> 18(9) </volume> <pages> 495-508, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: Perhaps the best known of these algorithms is due to Dijkstra et al. [DLM + 78]. (This is similar to the scheme developed independently by Steele <ref> [Ste75] </ref>, but simpler because it does not deal with compactification.) Rather than retaining everything that's in a snapshot of the graph at the beginning of garbage collection, it heuristically (and somewhat conservatively) attempts to retain the objects that are live at the end of garbage collection. <p> a space benefit with the incremental update scheme|the majority of those objects can be reclaimed at the end of a collection, which is likely to make it worth traversing the others. (In Steele's algorithm, some objects are allocated white and some are not, depending on the colors of their referents <ref> [Ste75] </ref>. This heuristic attempts 23 to allocate short-lived objects white to reclaim their space quickly, while treating other objects conservatively to avoid traversing them. <p> hand, the write barrier support for generational garbage collection could also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it might support fine-grained real-time collection at little cost.) In this introductory survey, we have not addressed the increasingly important areas of parallel <ref> [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] </ref> and distributed [LQP92, RMA92, JJ92, PS92] collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection [BW88, Bar88, Ede90, Wen90, WH91].
Reference: [UJ88] <author> David Ungar and Frank Jackson. </author> <title> Tenuring policies for generation-based storage reclamation. </title> <booktitle> In ACM SIG-PLAN 1988 Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA '88), </booktitle> <pages> pages 1-17, </pages> <address> San Diego, California, </address> <month> September </month> <year> 1988. </year> <note> ACM. Also published as ACM SIGPLAN Notices 23(11) 1-17, </note> <month> November, </month> <year> 1988. </year>
Reference-contexts: Further, real high-performance systems often use hybrid techniques to adjust tradeoffs for different categories of objects. Many high-performance copy collectors use a separate large object area <ref> [CWB86, UJ88] </ref>, to avoid copying large objects from space to space. The large objects are kept "off to the side" and usually managed in-place by some variety of marking traversal and free list technique. <p> Thus some garbage objects may be preserved because they are referred to from objects that are floating (undetected) garbage. This appears not to be a problem in practice <ref> [Ung84, UJ88] </ref>. It would also be possible to track all pointers from new memory into old memory, allowing old memory to be scavenged independently of new memory. This is more costly, however, because there are typically many more pointers from new to old than from old to new.
Reference: [Ung84] <author> David M. Ungar. </author> <title> Generation scavenging: A non-disruptive high-performance storage reclamation algorithm. </title> <booktitle> In ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 157-167, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> April </month> <year> 1984. </year> <journal> Also distributed as ACM SIGPLAN Notices 19(5) </journal> <pages> 157-167, </pages> <month> May, </month> <year> 1987. </year>
Reference-contexts: If virtual memory is used, the poor locality of the allocation and reclamation cycle will generally cause excessive paging. (Every location in the heap is used before any location's space is reclaimed and reused.) Simply paging out the recently-allocated data is expensive for a high-speed processor <ref> [Ung84] </ref>, and the paging caused by the copying collection itself may be tremendous, since all live data must be touched in the process.) It therefore doesn't generally pay to make the heap area larger than the available main memory. (For a mathematical treatment of this tradeoff, see [Lar77].) Even as main <p> At the time scale on which memory is reused, the resulting locality characteristics must share basic performance tradeoff characteristics with generational collectors of the copying or mark-sweep varieties, which will be discussed later. 11 Slightly more complicated copying schemes appear to avoid this problem <ref> [Ung84, WM89] </ref>, but [WLM92] demonstrates that cyclic memory reuse patterns can fare poorly in hierarchical memories because of recency-based (e.g., LRU) replacement policies. <p> In most programs in a variety of languages, most objects live a very short time, while a small percentage of them live much longer <ref> [LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>. <p> A pointer recording technique can be used instead. Rather than indirecting pointers from old objects to young ones, normal (direct) pointers are allowed, but the locations of such pointers are noted so that they can be found at scavenge time. This requires something like a write barrier <ref> [Ung84, Moo84] </ref>; that is, the running program cannot freely modify the reachability graph by storing pointers into objects in older generation. <p> Thus some garbage objects may be preserved because they are referred to from objects that are floating (undetected) garbage. This appears not to be a problem in practice <ref> [Ung84, UJ88] </ref>. It would also be possible to track all pointers from new memory into old memory, allowing old memory to be scavenged independently of new memory. This is more costly, however, because there are typically many more pointers from new to old than from old to new. <p> Advancement policy. How long must an object survive in one generation before it is advanced to the next? <ref> [Ung84, WM89] </ref> 2. Heap organization. How should storage space be divided and used between generations, and within a generation [Moo84, Ung84, Sha88, WM89]? How does the resulting reuse pattern affect locality at the virtual memory level [Ung84, Zor89, WM89], and at the level of high-speed cache memories [Zor91, WLM92]? 3. <p> Advancement policy. How long must an object survive in one generation before it is advanced to the next? [Ung84, WM89] 2. Heap organization. How should storage space be divided and used between generations, and within a generation <ref> [Moo84, Ung84, Sha88, WM89] </ref>? How does the resulting reuse pattern affect locality at the virtual memory level [Ung84, Zor89, WM89], and at the level of high-speed cache memories [Zor91, WLM92]? 3. Traversal algorithms. In a tracing collector, the traversal of live objects may have an important impact on locality. <p> Heap organization. How should storage space be divided and used between generations, and within a generation [Moo84, Ung84, Sha88, WM89]? How does the resulting reuse pattern affect locality at the virtual memory level <ref> [Ung84, Zor89, WM89] </ref>, and at the level of high-speed cache memories [Zor91, WLM92]? 3. Traversal algorithms. In a tracing collector, the traversal of live objects may have an important impact on locality. In a copying collector, objects are also reordered in memory as they are reached by the copy collector. <p> What affect does this have on locality, and what traversal yields the best results [Bla83, Sta84, And86, WLM91]? 4. Collection scheduling. For a non-incremental collector, how might we avoid or mitigate the effect of disruptive pauses, especially in interactive applications <ref> [Ung84, WM89] </ref>? Can we improve efficiency by careful "opportunistic"scheduling [WM89, Hay91]? Can this be adapted to incremental schemes to reduce floating garbage? 5. Intergenerational references. <p> Features also interact in important ways. Fine-grained incremental collection is unnecessary in most systems without hard real-time constraints. Coarser incremental techniques may be sufficient, because the modest pause times are acceptable [AEL88, BDS91], and the usually-short pauses of a stop-and-collect generational system may be acceptable enough for many systems <ref> [Ung84, WM89] </ref>. (On the other hand, the write barrier support for generational garbage collection could also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it might support fine-grained real-time collection at little cost.) In this introductory survey, we have not addressed the increasingly
Reference: [Wen90] <author> E.P. Wentworth. </author> <title> Pitfalls of conservative garbage collection. </title> <journal> Software, Practice and Experience, </journal> <volume> 20(7) </volume> <pages> 719-727, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: reference to an object is eliminated, the count is decremented. (See Fig. 1.) The memory occupied by an object may be reclaimed when the object's count equals zero, since that indicates that no pointers to the object exist and the running program could not reach it. 4 Conservative garbage collectors <ref> [BW88, Wen90, BDS91, WH91] </ref> are usable with little or no cooperation from the compiler|not even the types of named variables|but we will not discuss them here. 5 Some authors use the term "garbage collection" in a narrower sense, which excludes reference counting and/or copy collection systems; we prefer the more inclusive <p> In this introductory survey, we have not addressed the increasingly important areas of parallel [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] and distributed [LQP92, RMA92, JJ92, PS92] collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection <ref> [BW88, Bar88, Ede90, Wen90, WH91] </ref>.
Reference: [WH91] <author> Paul R. Wilson and Barry Hayes. </author> <booktitle> The 1991 OOPSLA Workshop on Garbage Collection in Object Oriented Systems (organizers' report). In Addendum to the proceedings of OOPSLA '91, </booktitle> <address> Phoenix, Arizona, </address> <year> 1991. </year> <month> 33 </month>
Reference-contexts: Depending on the details of the garbage collector, this may require slight changes to the code generator, to emit certain extra information at compile time, and perhaps execute different instruction sequences at run time <ref> [Boe91, WH91, DMH92] </ref>. (Contrary to widespread misconceptions, there is no conflict between using a compiled language and garbage collection; state-of-the art implementations of garbage-collected languages use sophisticated optimizing compilers.) 1.2 The Two-Phase Abstraction Garbage collection automatically reclaims the space occupied by data objects that the running program can never access again. <p> reference to an object is eliminated, the count is decremented. (See Fig. 1.) The memory occupied by an object may be reclaimed when the object's count equals zero, since that indicates that no pointers to the object exist and the running program could not reach it. 4 Conservative garbage collectors <ref> [BW88, Wen90, BDS91, WH91] </ref> are usable with little or no cooperation from the compiler|not even the types of named variables|but we will not discuss them here. 5 Some authors use the term "garbage collection" in a narrower sense, which excludes reference counting and/or copy collection systems; we prefer the more inclusive <p> In this introductory survey, we have not addressed the increasingly important areas of parallel [Ste75, KS77, DLM + 78, NR87, AEL88, SS91] and distributed [LQP92, RMA92, JJ92, PS92] collection; we have also given insufficient coverage of conservative collectors, which can be used with systems not originally designed for garbage collection <ref> [BW88, Bar88, Ede90, Wen90, WH91] </ref>.
Reference: [Wil90] <author> Paul R. Wilson. </author> <title> Some issues and strategies in heap management and memory hierarchies. </title> <booktitle> In OOP--SLA/ECOOP '90 Workshop on Garbage Collection in Object-Oriented Systems, </booktitle> <address> Ottawa, Ontario, Canada, </address> <month> October </month> <year> 1990. </year> <note> Also in SIGPLAN Notices 23(1) 45-52, </note> <month> January </month> <year> 1991. </year>
Reference-contexts: The write barrier may do checking at each store, or it may be as simple as maintaining dirty bits and scanning dirty areas at collection time <ref> [Sha88, Sob88, WM89, Wil90, HMS92] </ref>. 22 ; the same mechanism might support real-time incremental collection as well. The important point is that all references from old to new memory must be located at scavenge time, and used as roots for the copying traversal. <p> The Explorer used exit tables, indirecting the pointers out of each generation; for each generation, there is a separate exit table for pointers into each younger generation [Cou88]. 22 Ungar and Chambers' improvement [Cha92], of our "card marking" scheme <ref> [WM89, Wil90] </ref> decreases the cost per heap write by using whole bytes as dirty bits. <p> Intergenerational references. Since it must be possible to scavenge younger generations without scavenging the older ones, we must be able to find the live pointers from older generations into the ones we're scavenging. What is the best way to do this <ref> [WM89, BDS91, App89b, Wil90] </ref>? 5 Conclusions Recent advances in garbage collection technology make automatic storage reclamation affordable for use in high-performance systems. Even relatively simple garbage collectors' performance is often competitive with conventional explicit storage management [App87, Zor92].
Reference: [Wil91] <author> Paul R. Wilson. </author> <title> Operating system support for small objects. </title> <booktitle> In International Workshop on Object Orientation in Operating Systems, </booktitle> <address> Palo Alto, California, </address> <month> October </month> <year> 1991. </year> <note> IEEE Press. Revised version to appear in Computing Systems. </note>
Reference-contexts: Without specialized hardware support, a write barrier appears to be easier to implement efficiently, because heap pointer writes are much less common than pointer traversals. Appel, Ellis and Li [AEL88] use virtual memory (pagewise) access protection facilities as a coarse approximation of Baker's read barrier <ref> [AEL88, AL91, Wil91] </ref>. Rather than checking each load to see if a pointer to fromspace is being loaded, the mutator is simply not allowed to see any page that might contain such a pointer. Pointers in the scanned area of tospace are guaranteed to contain only pointers into tospace.
Reference: [WLM91] <author> Paul R. Wilson, Michael S. Lam, and Thomas G. Moher. </author> <title> Effective static-graph reorganization to improve locality in garbage-collected systems. </title> <booktitle> In SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 177-191, </pages> <address> Toronto, Canada, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: In a tracing collector, the traversal of live objects may have an important impact on locality. In a copying collector, objects are also reordered in memory as they are reached by the copy collector. What affect does this have on locality, and what traversal yields the best results <ref> [Bla83, Sta84, And86, WLM91] </ref>? 4. Collection scheduling. For a non-incremental collector, how might we avoid or mitigate the effect of disruptive pauses, especially in interactive applications [Ung84, WM89]? Can we improve efficiency by careful "opportunistic"scheduling [WM89, Hay91]? Can this be adapted to incremental schemes to reduce floating garbage? 5.
Reference: [WLM92] <author> Paul R. Wilson, Michael S. Lam, and Thomas G. Moher. </author> <title> Caching considerations for generational garbage collection. </title> <booktitle> In SIGPLAN Symposium on LISP and Functional Programming, </booktitle> <address> San Francisco, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: However, as <ref> [WLM92] </ref> shows, generational techniques can recapture some of this locality. 7 1. Distinguish the live objects from the garbage. This is done by tracing|starting at the root set and actually traversing the graph of pointer relationships|usually by either a depth-first or breadth-first traversal. <p> generally pay to make the heap area larger than the available main memory. (For a mathematical treatment of this tradeoff, see [Lar77].) Even as main memory becomes steadily cheaper, locality within cache memory becomes increasingly important, so the problem is simply shifted to a different level of the memory hierarchy <ref> [WLM92] </ref>. In general, we can't achieve the potential efficiency of simple garbage collection; increasing the size of memory to postpone or avoid collections can only be taken so far before increased paging time negates any advantage. It is important to realize that this problem is not unique to copying collectors. <p> At the time scale on which memory is reused, the resulting locality characteristics must share basic performance tradeoff characteristics with generational collectors of the copying or mark-sweep varieties, which will be discussed later. 11 Slightly more complicated copying schemes appear to avoid this problem [Ung84, WM89], but <ref> [WLM92] </ref> demonstrates that cyclic memory reuse patterns can fare poorly in hierarchical memories because of recency-based (e.g., LRU) replacement policies. <p> Heap organization. How should storage space be divided and used between generations, and within a generation [Moo84, Ung84, Sha88, WM89]? How does the resulting reuse pattern affect locality at the virtual memory level [Ung84, Zor89, WM89], and at the level of high-speed cache memories <ref> [Zor91, WLM92] </ref>? 3. Traversal algorithms. In a tracing collector, the traversal of live objects may have an important impact on locality. In a copying collector, objects are also reordered in memory as they are reached by the copy collector.
Reference: [WM89] <author> Paul R. Wilson and Thomas G. Moher. </author> <title> Design of the opportunistic garbage collector. </title> <booktitle> In ACM SIGPLAN 1989 Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA '89), </booktitle> <pages> pages 23-35, </pages> <address> New Orleans, Louisiana, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: At the time scale on which memory is reused, the resulting locality characteristics must share basic performance tradeoff characteristics with generational collectors of the copying or mark-sweep varieties, which will be discussed later. 11 Slightly more complicated copying schemes appear to avoid this problem <ref> [Ung84, WM89] </ref>, but [WLM92] demonstrates that cyclic memory reuse patterns can fare poorly in hierarchical memories because of recency-based (e.g., LRU) replacement policies. <p> The write barrier may do checking at each store, or it may be as simple as maintaining dirty bits and scanning dirty areas at collection time <ref> [Sha88, Sob88, WM89, Wil90, HMS92] </ref>. 22 ; the same mechanism might support real-time incremental collection as well. The important point is that all references from old to new memory must be located at scavenge time, and used as roots for the copying traversal. <p> The Explorer used exit tables, indirecting the pointers out of each generation; for each generation, there is a separate exit table for pointers into each younger generation [Cou88]. 22 Ungar and Chambers' improvement [Cha92], of our "card marking" scheme <ref> [WM89, Wil90] </ref> decreases the cost per heap write by using whole bytes as dirty bits. <p> Advancement policy. How long must an object survive in one generation before it is advanced to the next? <ref> [Ung84, WM89] </ref> 2. Heap organization. How should storage space be divided and used between generations, and within a generation [Moo84, Ung84, Sha88, WM89]? How does the resulting reuse pattern affect locality at the virtual memory level [Ung84, Zor89, WM89], and at the level of high-speed cache memories [Zor91, WLM92]? 3. <p> Advancement policy. How long must an object survive in one generation before it is advanced to the next? [Ung84, WM89] 2. Heap organization. How should storage space be divided and used between generations, and within a generation <ref> [Moo84, Ung84, Sha88, WM89] </ref>? How does the resulting reuse pattern affect locality at the virtual memory level [Ung84, Zor89, WM89], and at the level of high-speed cache memories [Zor91, WLM92]? 3. Traversal algorithms. In a tracing collector, the traversal of live objects may have an important impact on locality. <p> Heap organization. How should storage space be divided and used between generations, and within a generation [Moo84, Ung84, Sha88, WM89]? How does the resulting reuse pattern affect locality at the virtual memory level <ref> [Ung84, Zor89, WM89] </ref>, and at the level of high-speed cache memories [Zor91, WLM92]? 3. Traversal algorithms. In a tracing collector, the traversal of live objects may have an important impact on locality. In a copying collector, objects are also reordered in memory as they are reached by the copy collector. <p> What affect does this have on locality, and what traversal yields the best results [Bla83, Sta84, And86, WLM91]? 4. Collection scheduling. For a non-incremental collector, how might we avoid or mitigate the effect of disruptive pauses, especially in interactive applications <ref> [Ung84, WM89] </ref>? Can we improve efficiency by careful "opportunistic"scheduling [WM89, Hay91]? Can this be adapted to incremental schemes to reduce floating garbage? 5. Intergenerational references. <p> What affect does this have on locality, and what traversal yields the best results [Bla83, Sta84, And86, WLM91]? 4. Collection scheduling. For a non-incremental collector, how might we avoid or mitigate the effect of disruptive pauses, especially in interactive applications [Ung84, WM89]? Can we improve efficiency by careful "opportunistic"scheduling <ref> [WM89, Hay91] </ref>? Can this be adapted to incremental schemes to reduce floating garbage? 5. Intergenerational references. Since it must be possible to scavenge younger generations without scavenging the older ones, we must be able to find the live pointers from older generations into the ones we're scavenging. <p> Intergenerational references. Since it must be possible to scavenge younger generations without scavenging the older ones, we must be able to find the live pointers from older generations into the ones we're scavenging. What is the best way to do this <ref> [WM89, BDS91, App89b, Wil90] </ref>? 5 Conclusions Recent advances in garbage collection technology make automatic storage reclamation affordable for use in high-performance systems. Even relatively simple garbage collectors' performance is often competitive with conventional explicit storage management [App87, Zor92]. <p> Features also interact in important ways. Fine-grained incremental collection is unnecessary in most systems without hard real-time constraints. Coarser incremental techniques may be sufficient, because the modest pause times are acceptable [AEL88, BDS91], and the usually-short pauses of a stop-and-collect generational system may be acceptable enough for many systems <ref> [Ung84, WM89] </ref>. (On the other hand, the write barrier support for generational garbage collection could also support an incremental update scheme for incremental collection; if this recording is cheap and precise enough, it might support fine-grained real-time collection at little cost.) In this introductory survey, we have not addressed the increasingly
Reference: [Yua90] <author> Taichi Yuasa. </author> <title> Real-time garbage collection on general-purpose machines. </title> <journal> Journal of Systems and Software, </journal> <volume> 11 </volume> <pages> 181-198, </pages> <year> 1990. </year>
Reference-contexts: That is, the graph of reachable objects is fixed at the moment garbage collection starts, even though the actual traversal proceeds incrementally. Perhaps the simplest and best-known snapshot collection algorithm is Yuasa's <ref> [Yua90] </ref>. If a location is written to, the overwritten value is first saved and pushed on a marking stack for later examination.
Reference: [Zor89] <author> Benjamin Zorn. </author> <title> Comparative Performance Evaluation of Garbage Collection Algorithms. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, Electrical Engineering and Computer Science Department, Berkeley, California, </institution> <month> December </month> <year> 1989. </year> <note> Also appears as Technical Report UCB/CSD 89/544, </note> <institution> University of California at Berkeley. </institution>
Reference-contexts: Still, the time overheads are on the order of twenty percent <ref> [Zor89] </ref>. 3.3 The Treadmill Recently, Baker has proposed a non-copying version of his scheme, which uses doubly-linked lists (and per-object color fields) to implement the sets of objects of each color, rather than separate memory areas. <p> Heap organization. How should storage space be divided and used between generations, and within a generation [Moo84, Ung84, Sha88, WM89]? How does the resulting reuse pattern affect locality at the virtual memory level <ref> [Ung84, Zor89, WM89] </ref>, and at the level of high-speed cache memories [Zor91, WLM92]? 3. Traversal algorithms. In a tracing collector, the traversal of live objects may have an important impact on locality. In a copying collector, objects are also reordered in memory as they are reached by the copy collector.
Reference: [Zor90] <author> Benjamin Zorn. </author> <title> Comparing mark-and-sweep and stop-and-copy garbage collection. </title> <booktitle> In 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 87-98, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: In most programs in a variety of languages, most objects live a very short time, while a small percentage of them live much longer <ref> [LH83, Ung84, Sha88, Zor90, DeT90, Hay91] </ref>.
Reference: [Zor91] <author> Benjamin Zorn. </author> <title> The effect of garbage collection on cache performance. </title> <type> Technical Report CU-CS-528-91, </type> <institution> University of Colorado at Boulder, Dept. of Computer Science, Boulder, Colorado, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Heap organization. How should storage space be divided and used between generations, and within a generation [Moo84, Ung84, Sha88, WM89]? How does the resulting reuse pattern affect locality at the virtual memory level [Ung84, Zor89, WM89], and at the level of high-speed cache memories <ref> [Zor91, WLM92] </ref>? 3. Traversal algorithms. In a tracing collector, the traversal of live objects may have an important impact on locality. In a copying collector, objects are also reordered in memory as they are reached by the copy collector.
Reference: [Zor92] <author> Benjamin Zorn. </author> <title> The measured cost of conservative garbage collection. </title> <type> Technical report, </type> <institution> University of Colorado at Boulder, Dept. of Computer Science, Boulder, Colorado, </institution> <year> 1992. </year> <title> This article was processed using the L a T E X macro package with LLNCS style 34 </title>
Reference-contexts: What is the best way to do this [WM89, BDS91, App89b, Wil90]? 5 Conclusions Recent advances in garbage collection technology make automatic storage reclamation affordable for use in high-performance systems. Even relatively simple garbage collectors' performance is often competitive with conventional explicit storage management <ref> [App87, Zor92] </ref>. Generational techniques reduce the basic costs and disruptiveness of collection by exploiting the empirically observed tendency of objects to die young; stock hardware incremental techniques may even make this relatively inexpensive for hard real-time systems.
References-found: 73

