URL: http://www.cs.cornell.edu/Info/People/weichen/research/FDpapers/TR97-1640.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/weichen/research/FDpapers.html
Root-URL: http://www.cs.brown.edu/
Email: aguilera,weichen,sam@cs.cornell.edu  
Title: On the Weakest Failure Detector for Quiescent Reliable Communication  
Author: Marcos Kawazoe Aguilera Wei Chen Sam Toueg 
Date: July 1997  
Address: Upson Hall,  Ithaca, NY 14853-7501, USA.  
Affiliation: Department of Computer Science  Cornell University  
Abstract: We consider the problem of achieving reliable communication with quiescent algorithms (i.e., algorithms that eventually stop sending messages) in asynchronous systems with process crashes and lossy links, and show that, among failure detectors with bounded output size, P is the weakest one that can be used to solve this problem. Combined with a result in [ACT97], this shows that failure detectors that are commonly used in practice, i.e., those that output lists of suspects, are not always the best ones to solve a problem.
Abstract-found: 1
Intro-found: 1
Reference: [ACT97] <author> Marcos Kawazoe Aguilera, Wei Chen, and Sam Toueg. Heartbeat: </author> <title> a timeout-free failure detector for quiescent reliable communication. </title> <type> Technical Report 97-1631, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> May </month> <year> 1997. </year>
Reference-contexts: 1 Introduction In <ref> [ACT97] </ref>, we considered the problem of achieving reliable communication with quiescent algorithms (i.e., algorithms that eventually stop sending messages) in asynchronous systems with process crashes and lossy links. <p> Thus, a failure detector with bounded output size is either (a) too weak to achieve quiescent reliable communication, or (b) not implementable. Combined with the results in <ref> [ACT97] </ref>, this shows that failure detectors that are commonly used in practice, i.e., those that output lists of suspects, are not always the best ones to solve a problem: their power or applicability is limited. <p> In this paper, we prove our result with respect to a problem that we call Single-Shot Reliable Send and Receive. This is a weaker version of the reliable communication problems considered in <ref> [ACT97] </ref>, and thus the result in this paper immediately apply to those problems as well. We assume that links can lose only a finite number of messages, and the network is completely connected. It is straightforward to verify that the result in this paper also holds for fair links [ACT97] and <p> in <ref> [ACT97] </ref>, and thus the result in this paper immediately apply to those problems as well. We assume that links can lose only a finite number of messages, and the network is completely connected. It is straightforward to verify that the result in this paper also holds for fair links [ACT97] and fair lossy links [BCBT96], and also for networks that are not completely connected as defined in [ACT97]. The paper is organized as follows. Our model is described in Section 2. In Section 3, we explain what it means for a failure detector to be weaker than another one. <p> It is straightforward to verify that the result in this paper also holds for fair links <ref> [ACT97] </ref> and fair lossy links [BCBT96], and also for networks that are not completely connected as defined in [ACT97]. The paper is organized as follows. Our model is described in Section 2. In Section 3, we explain what it means for a failure detector to be weaker than another one. Section 4 defines the reliable communication problem that we consider. <p> Note that, in general, T D!D 0 need not emulate all the failure detector histories of D 0 (in environment E); what we do require is that all the failure detector histories it emulates be histories of D 0 (in that environment). 4 Single-Shot Reliable Send and Receive <ref> [ACT97] </ref> considers four reliable communication problems: two point-to-point ones, called [quasi] reliable send and receive, and two broadcast ones, called [uniform] reliable broadcast. We prove our result with respect to a simpler problem, called Single-Shot Reliable Send and Receive. Since this problem is weaker than those in [ACT97], our result also <p> Send and Receive <ref> [ACT97] </ref> considers four reliable communication problems: two point-to-point ones, called [quasi] reliable send and receive, and two broadcast ones, called [uniform] reliable broadcast. We prove our result with respect to a simpler problem, called Single-Shot Reliable Send and Receive. Since this problem is weaker than those in [ACT97], our result also applies to these four problems. The Single-Shot Reliable Send and Receive problem is defined in terms of two communication 4 primitives, called Send and Receive 2 . <p> Since this problem is weaker than the four problems defined in <ref> [ACT97] </ref>, we conclude that to quiescently solve any of these problems using a failure detector with finite range, one needs at least P. 3 Let D be a failure detector with finite range that can be used to solve the Single-Shot Reliable Send and Receive problem with a quiescent algorithm I <p> is a limit vector for P in a history H 2 D (F ) where correct (F ) = P ). 2 The first letter is capitalized to distinguish them from the lossy send and receive provided by the system. 3 Moreover, P is sufficient to quiescently solve these problems <ref> [ACT97] </ref> thus it is the weakest. 5 Consider a failure detector history H that can occur when P is the set of all correct processes. Let f be any limit vector for P and H. Clearly, f hints that P is the set of all correct processes.
Reference: [BCBT96] <author> Anindya Basu, Bernadette Charron-Bost, and Sam Toueg. </author> <title> Simulating reliable links with unreliable links in the presence of process crashes. </title> <booktitle> In Proceedings of the 10th International Workshop on Distributed Algorithms, Lecture Notes on Computer Science, </booktitle> <pages> pages 105122. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1996. </year>
Reference-contexts: We assume that links can lose only a finite number of messages, and the network is completely connected. It is straightforward to verify that the result in this paper also holds for fair links [ACT97] and fair lossy links <ref> [BCBT96] </ref>, and also for networks that are not completely connected as defined in [ACT97]. The paper is organized as follows. Our model is described in Section 2. In Section 3, we explain what it means for a failure detector to be weaker than another one.
Reference: [CHT96] <author> Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg. </author> <title> The weakest failure detector for solving consensus. </title> <journal> Journal of the ACM, </journal> <volume> 43(4):685722, </volume> <month> July </month> <year> 1996. </year>
Reference-contexts: The system can experience both process failures and link failures. A process can fail by crashing, and a link can fail by dropping a finite number of messages. Our model, described in the rest of this section, is based on the one in <ref> [CHT96] </ref>. We assume the existence of a discrete global clock this is merely a fictional device to simplify the presentation and processes do not have access to it. <p> A solves problem P using a failure detector D in environment E if the set of all runs R = (F; H D ; I; S; T ) of A using D where F 2 E satisfies the properties required by P . 3 Failure Detector Transformations As explained in <ref> [CT96, CHT96] </ref>, failure detectors can be compared via algorithmic transformations. We now explain what it means for an algorithm T D!D 0 to transform a failure detector D into another failure detector D 0 in an environment E.
Reference: [CT96] <author> Tushar Deepak Chandra and Sam Toueg. </author> <title> Unreliable failure detectors for reliable distributed systems. </title> <journal> Journal of the ACM, </journal> <volume> 43(2):225267, </volume> <month> March </month> <year> 1996. </year>
Reference-contexts: be used to solve this problem is the Eventually Perfect failure fl Research partially supported by NSF grant CCR-9402896, by ARPA/ONR grant N00014-96-1-1014, and by an Olin Fellowship. detector P a failure detector that cannot be implemented in asynchronous systems with failures (an implementation would violate a known impossibility result <ref> [FLP85, CT96] </ref>). Thus, a failure detector with bounded output size is either (a) too weak to achieve quiescent reliable communication, or (b) not implementable. <p> Clearly, if the output of D has bounded size (it can be represented with a bounded number of bits) then the range of D is finite. We now define the eventually perfect failure detector P <ref> [CT96] </ref>. 1 Each failure detector module of P outputs a set of processes that are suspected to have crashed, i.e., R P = 2 . <p> also satisfy the following link properties for every pair of processes p and q: * Uniform Integrity: For all k 1, if q receives a message m from p exactly k times by time t, then p sent m to q at least k times before time t; 1 In <ref> [CT96] </ref>, P denotes a class of failure detectors. 3 * Finite Loss: If q is correct, the number of messages sent by p to q that are not received by q is finite. These properties model the behavior of the link from p to q. <p> A solves problem P using a failure detector D in environment E if the set of all runs R = (F; H D ; I; S; T ) of A using D where F 2 E satisfies the properties required by P . 3 Failure Detector Transformations As explained in <ref> [CT96, CHT96] </ref>, failure detectors can be compared via algorithmic transformations. We now explain what it means for an algorithm T D!D 0 to transform a failure detector D into another failure detector D 0 in an environment E.
Reference: [FLP85] <author> Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2):374382, </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: be used to solve this problem is the Eventually Perfect failure fl Research partially supported by NSF grant CCR-9402896, by ARPA/ONR grant N00014-96-1-1014, and by an Olin Fellowship. detector P a failure detector that cannot be implemented in asynchronous systems with failures (an implementation would violate a known impossibility result <ref> [FLP85, CT96] </ref>). Thus, a failure detector with bounded output size is either (a) too weak to achieve quiescent reliable communication, or (b) not implementable.
References-found: 5

