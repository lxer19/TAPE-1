URL: http://bdc2.cs.iastate.edu/~lei/research/paper-collections/counterflowarch.ps
Refering-URL: http://bdc2.cs.iastate.edu/~lei/research/research.html
Root-URL: http://www.cs.iastate.edu
Title: Counterflow Pipeline Processor Architecture  
Author: Robert F. Sproull Ivan E. Sutherland Charles E. Molnar 
Keyword: processor design, risc architecture, micropipelines, fifo, asynchronous systems  
Address: M/S 29-01 2550 Garcia Ave. Mountain View, CA 94043  
Note: CR categories: B.2.1, B.6.1, C.1.0  
Affiliation: Sun Microsystems Laboratories, Inc.  Institute for Biomedical Computing Washington University  
Pubnum: SMLI TR-94-25  
Email: email addresses: Bob.Sproull@east.sun.com Ivan.Sutherland@eng.sun.com  
Date: April 1994  
Abstract: The counterflow pipeline processor architecture (cfpp) is a proposal for a family of micro-architectures for risc processors. The architecture derives its name from its fundamental feature, namely that instructions and results flow in opposite directions within a pipeline and interact as they pass. The architecture seeks geometric regularity in processor chip layout, purely local control to avoid performance limitations of complex global pipeline stall signals, and simplicity that might lead to provably correct processor designs. Moreover, cfpp designs allow asynchronous implementations, in contrast to conventional pipeline designs where the synchronization required for operand forwarding makes asynchronous designs unattractive. This paper presents the cfpp architecture and a proposal for an asynchronous implementation. Detailed performance simulations of a complete processor design are not yet available. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Brunvand, E. L. "Parts-r-Us: </author> <title> A Chip Aparts." </title> <type> Technical Report CMU-CS-87-119, </type> <institution> Computer Science Dept., Carnegie Mellon University, </institution> <year> 1987. </year>
Reference-contexts: The asynchronous implementation proved to be quite difficult, not merely a simple composition of asynchronous modules that we had studied earlier <ref> [1, 3, 4] </ref>. Molnar, whom we enlisted to help with our design, proposed the 5-state diagram and the 5-wire signaling protocol to implement it. We have since attempted a wide variety of implementation alternatives. <p> We present here an outline of a proof, assuming a simple cfpp without memory, sidings, traps, conditional branches, or a register cache. As a "gold standard" for comparison, consider a simple sequential implementation and a numbering that indexes instructions executed, in order of execution: I [0]; I <ref> [1] </ref>; I [2]; etc. This same numbering identifies successive states of the entire register file: the age of the register file is j when it reflects execution of all instructions with index less than j.
Reference: [2] <author> Brunvand, E. L., and R. F. Sproull. </author> <title> "Translating concurrent communicating programs into delay-insensitive circuits." </title> <address> ICCAD, </address> <year> 1989. </year>
Reference-contexts: Result pipe Remarks R B <ref> [2] </ref>C [3] # Registers contain: A [14]B [2]C [3]D [21] 0 2 A [] := B [] + C [] " I P C = 102 " Fetch, send source names A, B to reg file Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C [3]D [21] 0 B [2]C [3] Mustn't swap with instruction below. 1 A [] := B [] + C [] " Mustn't swap with result above. 2 B [] := A [] + B [] " I P C = 103 Fetch delayed due to <p> Stage Instruction pipe Result pipe Remarks R A [14]B <ref> [2] </ref> Registers contain: A [14]B [2]C [3]D [21] 0 A [] := B [2] + C [3] B [2]C [3] # Garner B, C; execute 1 B [] := A [] + B [] I P C = 103 " Fetch, send source name C to reg file Stage Instruction pipe <p> Stage Instruction pipe Result pipe Remarks R A [14]B <ref> [2] </ref> Registers contain: A [14]B [2]C [3]D [21] 0 A [] := B [2] + C [3] B [2]C [3] # Garner B, C; execute 1 B [] := A [] + B [] I P C = 103 " Fetch, send source name C to reg file Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C [3]D <p> [21] 0 A [] := B <ref> [2] </ref> + C [3] B [2]C [3] # Garner B, C; execute 1 B [] := A [] + B [] I P C = 103 " Fetch, send source name C to reg file Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C [3]D [21] 0 A [5] := B [2] + C [3] " A [5] Insert result 1 B [] := A [] + B [2] " B [2]C [3] Garner B 2 D [] := C [] 1 " Literal -1 held in binding value <p> # Garner B, C; execute 1 B [] := A [] + B [] I P C = 103 " Fetch, send source name C to reg file Stage Instruction pipe Result pipe Remarks R A [14]B <ref> [2] </ref> Registers contain: A [14]B [2]C [3]D [21] 0 A [5] := B [2] + C [3] " A [5] Insert result 1 B [] := A [] + B [2] " B [2]C [3] Garner B 2 D [] := C [] 1 " Literal -1 held in binding value I P C = 104 Fetch, send source names to reg file Stage <p> = 103 " Fetch, send source name C to reg file Stage Instruction pipe Result pipe Remarks R A [14]B <ref> [2] </ref> Registers contain: A [14]B [2]C [3]D [21] 0 A [5] := B [2] + C [3] " A [5] Insert result 1 B [] := A [] + B [2] " B [2]C [3] Garner B 2 D [] := C [] 1 " Literal -1 held in binding value I P C = 104 Fetch, send source names to reg file Stage Instruction pipe Result pipe Remarks R A [5] := B [2] + C [3] " A []B <p> [] := A [] + B <ref> [2] </ref> " B [2]C [3] Garner B 2 D [] := C [] 1 " Literal -1 held in binding value I P C = 104 Fetch, send source names to reg file Stage Instruction pipe Result pipe Remarks R A [5] := B [2] + C [3] " A []B [2] Registers contain: A [5]B [2]C [3]D [21] 0 B := A [5] + B [2] " A [5] Garner A, execute 1 D := C [3] 1 " B [2]C [3] Garner C, execute 2 . . . <p> " B <ref> [2] </ref>C [3] Garner B 2 D [] := C [] 1 " Literal -1 held in binding value I P C = 104 Fetch, send source names to reg file Stage Instruction pipe Result pipe Remarks R A [5] := B [2] + C [3] " A []B [2] Registers contain: A [5]B [2]C [3]D [21] 0 B := A [5] + B [2] " A [5] Garner A, execute 1 D := C [3] 1 " B [2]C [3] Garner C, execute 2 . . . <p> -1 held in binding value I P C = 104 Fetch, send source names to reg file Stage Instruction pipe Result pipe Remarks R A [5] := B <ref> [2] </ref> + C [3] " A []B [2] Registers contain: A [5]B [2]C [3]D [21] 0 B := A [5] + B [2] " A [5] Garner A, execute 1 D := C [3] 1 " B [2]C [3] Garner C, execute 2 . . . <p> The expansion of this event into the signaling protocol used by the cop requires a delicate interplay of the state diagrams of adjoining stages and the need for arbitration. It is not the straightforward two-wire expansion of a csp event <ref> [2] </ref>. Cop internals. The cop can be implemented with a 5-wire arbiter and C elements as shown in Figure 7. When both the pass and accept signals for a communication have been presented, a C element signals a request to the arbiter. <p> We present here an outline of a proof, assuming a simple cfpp without memory, sidings, traps, conditional branches, or a register cache. As a "gold standard" for comparison, consider a simple sequential implementation and a numbering that indexes instructions executed, in order of execution: I [0]; I [1]; I <ref> [2] </ref>; etc. This same numbering identifies successive states of the entire register file: the age of the register file is j when it reflects execution of all instructions with index less than j.
Reference: [3] <author> Clark, W. A. </author> <booktitle> "Macromodular computer systems." In Proc. Spring Joint Computer Conf., AFIPS, </booktitle> <month> April </month> <year> 1967. </year>
Reference-contexts: The two source register names are transmitted to the register file, so that values can be fetched and inserted into the results pipeline. Stage Instruction pipe Result pipe Remarks R B [2]C <ref> [3] </ref> # Registers contain: A [14]B [2]C [3]D [21] 0 2 A [] := B [] + C [] " I P C = 102 " Fetch, send source names A, B to reg file Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C [3]D <p> [14]B [2]C <ref> [3] </ref>D [21] 0 2 A [] := B [] + C [] " I P C = 102 " Fetch, send source names A, B to reg file Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C [3]D [21] 0 B [2]C [3] Mustn't swap with instruction below. 1 A [] := B [] + C [] " Mustn't swap with result above. 2 B [] := A [] + B [] " I P C = 103 Fetch delayed due to cache miss. <p> Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C <ref> [3] </ref>D [21] 0 A [] := B [2] + C [3] B [2]C [3] # Garner B, C; execute 1 B [] := A [] + B [] I P C = 103 " Fetch, send source name C to reg file Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C [3]D [21] 0 A <p> Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C <ref> [3] </ref>D [21] 0 A [] := B [2] + C [3] B [2]C [3] # Garner B, C; execute 1 B [] := A [] + B [] I P C = 103 " Fetch, send source name C to reg file Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C [3]D [21] 0 A [5] := B <p> C; execute 1 B [] := A [] + B [] I P C = 103 " Fetch, send source name C to reg file Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C <ref> [3] </ref>D [21] 0 A [5] := B [2] + C [3] " A [5] Insert result 1 B [] := A [] + B [2] " B [2]C [3] Garner B 2 D [] := C [] 1 " Literal -1 held in binding value I P C = 104 Fetch, send source names to reg file Stage Instruction pipe Result <p> send source name C to reg file Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C <ref> [3] </ref>D [21] 0 A [5] := B [2] + C [3] " A [5] Insert result 1 B [] := A [] + B [2] " B [2]C [3] Garner B 2 D [] := C [] 1 " Literal -1 held in binding value I P C = 104 Fetch, send source names to reg file Stage Instruction pipe Result pipe Remarks R A [5] := B [2] + C [3] " A []B [2] Registers contain: A <p> [] + B [2] " B [2]C <ref> [3] </ref> Garner B 2 D [] := C [] 1 " Literal -1 held in binding value I P C = 104 Fetch, send source names to reg file Stage Instruction pipe Result pipe Remarks R A [5] := B [2] + C [3] " A []B [2] Registers contain: A [5]B [2]C [3]D [21] 0 B := A [5] + B [2] " A [5] Garner A, execute 1 D := C [3] 1 " B [2]C [3] Garner C, execute 2 . . . <p> send source names to reg file Stage Instruction pipe Result pipe Remarks R A [5] := B [2] + C <ref> [3] </ref> " A []B [2] Registers contain: A [5]B [2]C [3]D [21] 0 B := A [5] + B [2] " A [5] Garner A, execute 1 D := C [3] 1 " B [2]C [3] Garner C, execute 2 . . . I P C = 105 Fetch, send source names to reg file In the last snapshot, the binding for A in result stage R has been killed by rule M1. <p> file Stage Instruction pipe Result pipe Remarks R A [5] := B [2] + C <ref> [3] </ref> " A []B [2] Registers contain: A [5]B [2]C [3]D [21] 0 B := A [5] + B [2] " A [5] Garner A, execute 1 D := C [3] 1 " B [2]C [3] Garner C, execute 2 . . . I P C = 105 Fetch, send source names to reg file In the last snapshot, the binding for A in result stage R has been killed by rule M1. <p> The asynchronous implementation proved to be quite difficult, not merely a simple composition of asynchronous modules that we had studied earlier <ref> [1, 3, 4] </ref>. Molnar, whom we enlisted to help with our design, proposed the 5-state diagram and the 5-wire signaling protocol to implement it. We have since attempted a wide variety of implementation alternatives.
Reference: [4] <author> Clark, W. A., and C. E. </author> <title> Molnar. </title> <booktitle> "Macromodular computer systems." In Computers in Biomedical Research, </booktitle> <volume> Vol. 4, </volume> <editor> R. Stacy and B. Waxman, eds., </editor> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1974, </year> <pages> 45-85. </pages>
Reference-contexts: The asynchronous implementation proved to be quite difficult, not merely a simple composition of asynchronous modules that we had studied earlier <ref> [1, 3, 4] </ref>. Molnar, whom we enlisted to help with our design, proposed the 5-state diagram and the 5-wire signaling protocol to implement it. We have since attempted a wide variety of implementation alternatives.
Reference: [5] <author> Dill, D. L. </author> <title> Trace theory for automatic hierarchical verification of speed-independent circuits. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference-contexts: B [2]C [3] # Garner B, C; execute 1 B [] := A [] + B [] I P C = 103 " Fetch, send source name C to reg file Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C [3]D [21] 0 A <ref> [5] </ref> := B [2] + C [3] " A [5] Insert result 1 B [] := A [] + B [2] " B [2]C [3] Garner B 2 D [] := C [] 1 " Literal -1 held in binding value I P C = 104 Fetch, send source names to <p> B [] := A [] + B [] I P C = 103 " Fetch, send source name C to reg file Stage Instruction pipe Result pipe Remarks R A [14]B [2] Registers contain: A [14]B [2]C [3]D [21] 0 A <ref> [5] </ref> := B [2] + C [3] " A [5] Insert result 1 B [] := A [] + B [2] " B [2]C [3] Garner B 2 D [] := C [] 1 " Literal -1 held in binding value I P C = 104 Fetch, send source names to reg file Stage Instruction pipe Result pipe Remarks R <p> result 1 B [] := A [] + B [2] " B [2]C [3] Garner B 2 D [] := C [] 1 " Literal -1 held in binding value I P C = 104 Fetch, send source names to reg file Stage Instruction pipe Result pipe Remarks R A <ref> [5] </ref> := B [2] + C [3] " A []B [2] Registers contain: A [5]B [2]C [3]D [21] 0 B := A [5] + B [2] " A [5] Garner A, execute 1 D := C [3] 1 " B [2]C [3] Garner C, execute 2 . . . <p> 1 " Literal -1 held in binding value I P C = 104 Fetch, send source names to reg file Stage Instruction pipe Result pipe Remarks R A <ref> [5] </ref> := B [2] + C [3] " A []B [2] Registers contain: A [5]B [2]C [3]D [21] 0 B := A [5] + B [2] " A [5] Garner A, execute 1 D := C [3] 1 " B [2]C [3] Garner C, execute 2 . . . <p> binding value I P C = 104 Fetch, send source names to reg file Stage Instruction pipe Result pipe Remarks R A <ref> [5] </ref> := B [2] + C [3] " A []B [2] Registers contain: A [5]B [2]C [3]D [21] 0 B := A [5] + B [2] " A [5] Garner A, execute 1 D := C [3] 1 " B [2]C [3] Garner C, execute 2 . . . <p> Molnar, whom we enlisted to help with our design, proposed the 5-state diagram and the 5-wire signaling protocol to implement it. We have since attempted a wide variety of implementation alternatives. We have made constant use of software based on Dill's verifier <ref> [5] </ref>; it has detected many protocol errors and inconsistencies. We have found the asynchronous design task very hard, perhaps because we are striving for performance as well as modularity.
Reference: [6] <author> Hennessy, J. L., and D. A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufman, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: The results pipeline provides the function that in other designs is called "bypassing" or "forwarding" <ref> [6] </ref>, and does so in a way that is uniform for all stages. Result bindings flowing down may be modified by a subsequent instruction.
Reference: [7] <author> Hoare, C. A. R. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: In the 5-state diagram of Figure 5, this transaction is represented as a single event, called AI by the upper stage and PI by the lower stage. The interpretation of the event in the state diagram is like that of Communicating Sequential Processes (csp) <ref> [7] </ref> events: it requires agreement and synchronization of the two communicators. The expansion of this event into the signaling protocol used by the cop requires a delicate interplay of the state diagrams of adjoining stages and the need for arbitration.
Reference: [8] <author> Popescu, V., M. Schultz, J. Spracklen, G. Gibson, B. Lightner, and D. Isaman. </author> <booktitle> The Metaflow Architecture. IEEE Micro (June 1991): </booktitle> <pages> 10-72. </pages>
Reference-contexts: Whether this aim can be achieved awaits further simulation and implementation studies. At the opposite extreme from the cfpp is a dataflow architecture, in which a new result is broadcast to an associative memory that holds instructions waiting to be executed <ref> [8] </ref>. The new result may complete the source values required to execute one or more of these instructions; they are identified, read out of the associative memory, and routed to a suitable functional unit.
Reference: [9] <author> Seitz, C. L. </author> <title> "System Timing." </title> <editor> In C. A. Mead and L. Conway, </editor> <title> Introduction to VLSI Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1980. </year>
Reference-contexts: Figure 6 shows the interface between stages, which consists of two communication processes and a control element named a "cop." Throughout this discussion, we use transition signaling conventions (also called "two-phase" or "non return to zero") and bundled data transfer protocols, as illustrated in <ref> [10, 9] </ref>. Each stage sends signals to the cop indicating what the stage is prepared to do. The signal AI? indicates willingness to accept an instruction, PI? willingness to pass an instruction forward, AR? willingness to accept a result, and PR? readiness to pass a result forward.
Reference: [10] <author> Sutherland, I. E. </author> <title> "Micropipelines." </title> <journal> Comm. ACM 32, </journal> <volume> 6 (1989): </volume> <pages> 720-738. </pages>
Reference-contexts: Figure 6 shows the interface between stages, which consists of two communication processes and a control element named a "cop." Throughout this discussion, we use transition signaling conventions (also called "two-phase" or "non return to zero") and bundled data transfer protocols, as illustrated in <ref> [10, 9] </ref>. Each stage sends signals to the cop indicating what the stage is prepared to do. The signal AI? indicates willingness to accept an instruction, PI? willingness to pass an instruction forward, AR? willingness to accept a result, and PR? readiness to pass a result forward. <p> It moves an instruction from one stage to the next, latches it, and informs both stages that the transfer is complete (AI! and PI!). There is a clear correspondence between the cfpp structure (Figure 9a) and that of a micropipeline <ref> [10] </ref> 15 (Figure 9b). The only significant difference is the arbitration required to enable a transfer. The communication process represented by the oval can be implemented in a variety of ways, such as serial communication, purely self-timed data, etc. <p> To Sproull, the counterflow pipeline was inspired by Sutherland's playing with the idea of two asynchronous fifos running in opposite directions, itself an outgrowth of the observation that data can flow backward in the fast fifo described in <ref> [10] </ref>, although the control circuitry for the fifo seems to preclude exploiting this feature. The asynchronous implementation proved to be quite difficult, not merely a simple composition of asynchronous modules that we had studied earlier [1, 3, 4].

References-found: 10

