URL: ftp://ftp.csd.uu.se/pub/papers/theses/0020.ps.gz
Refering-URL: http://www.csd.uu.se/papers/long-theses.html
Root-URL: 
Title: SLD-Resolution with Reflection  
Author: Pierangelo Dell'Acqua UPMAIL 
Degree: Thesis for the Degree of Licentiate of Philosophy  
Address: Box 311 S-751 05 UPPSALA SwedenISSN 0283-359X  
Affiliation: Computing Science Department Uppsala University  
Date: 20/95  
Note: UPPSALA THESES IN COMPUTING SCIENCE No.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Aiello, L. C., Cecchi, C. and Sartini, D., </author> <title> Representation and Use of Metaknowl-edge, </title> <journal> Proc. of the IEEE, </journal> <volume> 74 </volume> <month> 1304-1321 </month> <year> (1986). </year>
Reference-contexts: A kind of architecture particularly suitable for metaprogramming is presented in the next section. 1 2 CHAPTER 1. INTRODUCTION 1.2 Metalevel Architectures The advantages derived from the ability to explicitly express and use metalevel knowledge have been widely recognized, especially in the AI literature. Aiello et al. <ref> [1] </ref>, for example, argues that metaknowledge and metalevel reasoning is suitable for devising proof strategies in automated deduction systems, for controlling the inference in problem solving, and for increasing the expressive power of knowledge representation languages.
Reference: [2] <author> Aiello, L. C., Nardi, D. and Schaerf, M., </author> <title> Reasoning about Knowledge and Reasoning in a Meta-Level Architecture, </title> <journal> Intl. J. of Applied Intelligence, </journal> <month> 1 </month> <year> (1991). </year>
Reference-contexts: The need to formally represent knowledge and metaknowledge has led to the study of metalevel architectures <ref> [2] </ref>, where these two kinds of knowledge are explicitly represented.
Reference: [3] <author> Aiello, L. C., Nardi, D. and Schaerf, M., </author> <title> Reasoning about Knowledge: the Meta-Level Approach, </title> <booktitle> in: Proc. Scandinavian Conf. on Artificial Intelligence, </booktitle> <publisher> IOS Press, </publisher> <address> Copenhagen, </address> <year> 1991. </year>
Reference-contexts: Among the separated approaches we mention the FOL system by Weyhrauch [67], 0 Log by Cervesato & Rossi [15] and the Godel programming language by Lloyd et al. [37] (for a survey of these approaches see reference <ref> [3] </ref>). On the one hand, amalgamated approaches may turn out to be inconsistent.
Reference: [4] <author> Apt, K. R. and van Emden, M. H., </author> <title> Contributions to the Theory of Logic Programming, </title> <journal> J. ACM, </journal> <volume> 29(3) </volume> <month> 841-862 </month> <year> (1982). </year>
Reference-contexts: Now we strengthen Corollary 7.30 by showing that, if a ground atom A has an SLD fl - refutation of length n, then (A) 2 T (P;E) "n. This is an extension of the result due to Apt & van Emden <ref> [4] </ref>.
Reference: [5] <author> Attardi, G. and M, S., </author> <title> Meta-Level Reasoning across Viewpoints, </title> <editor> in: T. O'Shea (ed.), </editor> <booktitle> Proc. European Conf. on Artificial Intelligence, </booktitle> <publisher> North-Holland, </publisher> <address> Amster-dam, </address> <year> 1984. </year>
Reference-contexts: Therefore, mixed sentences combining object level and metalevel expressions are allowed. The main amalgamated approaches in the AI literature have been established by Bowen & Kowalski [13], Attardi & Simi <ref> [5] </ref> and Costantini & Lanzarone [26]. 1 Some authors call these reflection principles upward and downward reflection, respectively; other authors, instead, use upward reflection (resp., downward reflection) to indicate the procedural shift from the object level to the metalevel (resp., from the metalevel to the object level).
Reference: [6] <author> Barklund, J., Boberg, K. and Dell'Acqua, P., </author> <title> A Basis for a Multilevel Meta-logic Programming Language, </title> <editor> in: F. Turini (ed.), </editor> <booktitle> Proc. 4th Intl. Workshop on Metaprogramming in Logic, </booktitle> <publisher> LNCS, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: However, the inference mechanism could be used without significant changes also for a system with separated theories (such as Alloy <ref> [6, 12] </ref>), if they all share the same language. (However, we have not established the semantics and properties of such a system to the same extent as we have for the amalgamated system.) It would be interesting to see if the present inference system could be generalized to be independent of
Reference: [7] <author> Barklund, J., Boberg, K., Dell'Acqua, P. and Veanes, M., </author> <title> Meta-programmming with Theory Systems, </title> <editor> in: K. Apt and F. Turini (eds.), </editor> <booktitle> Meta-programming in Logic, </booktitle> <publisher> MIT PRESS, </publisher> <address> Cambridge, Mass., </address> <year> 1995. </year>
Reference: [8] <author> Barklund, J., Costantini, S., Dell'Acqua, P. and Lanzarone, G. A., </author> <title> SLD-Resolution with Reflection, </title> <editor> in: M. Bruynooghe (ed.), </editor> <booktitle> Logic Programming - Proc. 1994 Intl. Symp., </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: Two parts of the thesis, in particular the naming rewrite system and SLD fl - resolution, are joint works with Barklund, Costantini and Lanzarone <ref> [8, 9, 11] </ref>. The main contribution of the thesis concerns the introduction of name theories, the integration of the rewrite systems for unification and naming, and the formal properties of SLD fl -resolution.
Reference: [9] <author> Barklund, J., Costantini, S., Dell'Acqua, P. and Lanzarone, G., </author> <title> Semantical Properties of SLD-Resolution with Reflection, </title> <note> Submitted to ICLP '95, </note> <year> 1994. </year>
Reference-contexts: Two parts of the thesis, in particular the naming rewrite system and SLD fl - resolution, are joint works with Barklund, Costantini and Lanzarone <ref> [8, 9, 11] </ref>. The main contribution of the thesis concerns the introduction of name theories, the integration of the rewrite systems for unification and naming, and the formal properties of SLD fl -resolution.
Reference: [10] <author> Barklund, J., </author> <title> What is a Meta-Variable in Prolog?, </title> <editor> in: H. Abramson and M. H. Rogers (eds.), </editor> <booktitle> Meta-Programming in Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: There is an on-going debate in the metalogic programming community on whether names of expressions should necessarily be ground or not <ref> [10, 36, 44, 47, 52] </ref>. In this proposal we sidestep the question, as the proposed inference system restricts reflection so only ground expressions are ever communicated between levels. Therefore only naming of ground expressions is involved.
Reference: [11] <author> Barklund, J., Costantini, S., Dell'Acqua, P. and Lanzarone, G. A., </author> <title> Integrating Reflection into SLD-Resolution, </title> <editor> in: A. Momigliano and M. Ornaghi (eds.), </editor> <booktitle> Proc. Post-Conf. W. on Proof-Theoretical Extensions of Logic Programming, </booktitle> <year> 1994. </year>
Reference-contexts: Two parts of the thesis, in particular the naming rewrite system and SLD fl - resolution, are joint works with Barklund, Costantini and Lanzarone <ref> [8, 9, 11] </ref>. The main contribution of the thesis concerns the introduction of name theories, the integration of the rewrite systems for unification and naming, and the formal properties of SLD fl -resolution.
Reference: [12] <author> Barklund, J. and Hamfelt, A., </author> <title> Hierarchical Representation of Legal Knowledge with Metaprogramming in Logic, </title> <journal> J. Logic Programming, </journal> <note> (in print). </note>
Reference-contexts: However, the inference mechanism could be used without significant changes also for a system with separated theories (such as Alloy <ref> [6, 12] </ref>), if they all share the same language. (However, we have not established the semantics and properties of such a system to the same extent as we have for the amalgamated system.) It would be interesting to see if the present inference system could be generalized to be independent of
Reference: [13] <author> Bowen, K. A. and Kowalski, R. A., </author> <title> Amalgamating Language and Metalanguage in Logic Programming, </title> <editor> in: K. L. Clark and S. A. Tarnlund (eds.), </editor> <booktitle> Logic Programming, </booktitle> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1982. </year> <note> 42 BIBLIOGRAPHY 43 </note>
Reference-contexts: Therefore, mixed sentences combining object level and metalevel expressions are allowed. The main amalgamated approaches in the AI literature have been established by Bowen & Kowalski <ref> [13] </ref>, Attardi & Simi [5] and Costantini & Lanzarone [26]. 1 Some authors call these reflection principles upward and downward reflection, respectively; other authors, instead, use upward reflection (resp., downward reflection) to indicate the procedural shift from the object level to the metalevel (resp., from the metalevel to the object level). <p> Consider, for example, the sentence "A person is innocent if he or she cannot be proved guilty" (this example is taken from reference <ref> [13] </ref>). This can be formulated as: Innocent (x) Person (x); not Demo (Facts; Guilty (x) 0 ); Relevant (Facts) Its formalization combines a metalanguage condition with an object language condition and conclusion. Here Facts names the relevant facts and assumptions which can be used in the attempt to establish guilt. <p> Although many AI systems with a metalevel architecture have implemented naming relations, the formal properties that they must satisfy have usually been assumed without motivations. Bowen & Kowalski <ref> [13] </ref>, for instance, allow the naming relation to be non-functional and require it to be injective, while Hill & Lloyd [36] define a naming relation that is total, injective and functional. 4 CHAPTER 1.
Reference: [14] <author> Brogi, A., Mancarella, P., Pedreschi, D. and Turini, F., </author> <title> Composition Operators for Logic Theories, </title> <editor> in: J. W. Lloyd (ed.), </editor> <booktitle> Computational Logic, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: Metaprogramming has been so far employed in many applications including debuggers, compilers and program transformers [34, 59, 61]. Furthermore, also applications which can be formalized using other logics, such as modal logic of knowledge and belief [22, 45], or applications for theory construction <ref> [14] </ref> are objects of metaprogram-ming. A kind of architecture particularly suitable for metaprogramming is presented in the next section. 1 2 CHAPTER 1. INTRODUCTION 1.2 Metalevel Architectures The advantages derived from the ability to explicitly express and use metalevel knowledge have been widely recognized, especially in the AI literature.
Reference: [15] <author> Cervesato, I. and Rossi, G., </author> <title> Logic Meta-Programming Facilities in 0 Log, </title> <editor> in: A. Pettorossi (ed.), </editor> <booktitle> Meta-Programming in Logic, </booktitle> <publisher> LNCS 649, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: The connection between the metatheory and the object theory is provided by the naming relation and the linking rules. Among the separated approaches we mention the FOL system by Weyhrauch [67], 0 Log by Cervesato & Rossi <ref> [15] </ref> and the Godel programming language by Lloyd et al. [37] (for a survey of these approaches see reference [3]). On the one hand, amalgamated approaches may turn out to be inconsistent. <p> Reflection principles take the role of axiom schemata of a particular form 2 The term richness is here used with the meaning of quantity of syntactic information encoded. 3 In order to have an effective and efficient implementation of 0 Log, Cervesato & Rossi introduce in this language <ref> [15] </ref> two different but related metalevel representations (i.e., quotation-mark and structural descriptive names) for each syntactic object of the language (for a further discussion see Section 8.1.) 1.5. <p> This choice, however, does not allow f 0 to be accessed through unification. 0 Log <ref> [15] </ref> provides two metarepresentations for every expression of the language: atomic names and structural descriptive names. The alphabet of 0 Log therefore contains a metaconstant for every expression of the language. <p> Similarly to Cervesato & Rossi <ref> [15] </ref>, they use delay techniques in order to solve these meta-level constraints. In the previous example, FrozenUniv is delayed until either the first or second argument is ground. <p> It is interesting to note that the naming relation he proposes is compositional, although he considers naming also of nonground (but closed) expressions. His emphasis is not on presenting a proof system, but rather a metainterpreter for the truth predicate. Cervesato & Rossi <ref> [15] </ref> present a meta-level extension of a logic programming language, called 0 Log. The extension consists of a naming scheme that associates two different meta-representations to every syntactic object of the language, and of a destructuring operator that relates these meta-representations. <p> The informal semantics <ref> [15, p.149] </ref> of the destructuring operator, represented as ,, is: a goal N , S is true if N is the name of an object and S is the structural representation of the same object.
Reference: [16] <author> Christiansen, H., </author> <title> Efficient and Complete Demo Predicates for Definite Clause Languages, Datalogiske Skrifter, </title> <type> Technical Report 51, </type> <institution> Dept. of Computer Science, Roskilde University, </institution> <year> 1994. </year>
Reference-contexts: His logic intentionally tries to remove the distinction between predicate and function symbols, etc. For ground expressions his naming scheme can be captured in our framework, by self-naming. However, he has a quite different inference system in mind. We are aware of a study by Christiansen <ref> [16] </ref>, whose idea is to use constraint tech 40 CHAPTER 8. RELATED WORK & CONCLUDING REMARKS niques to implement a binary demo predicate which is logically complete.
Reference: [17] <author> Clark, K. L., </author> <title> Negation as Failure, </title> <editor> in: H. Gallaire and J. Minker (eds.), </editor> <booktitle> Logic and Data Bases, </booktitle> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Definition 2.13 Given an L logic program (P; E), the language of (P; E) is the subset of L that is given from the alphabet of (P; E). 2.3 An Equality Theory One possible Horn clause equality theory for the language L is an extension of that proposed by Clark <ref> [17] </ref>. <p> [y 0 ; y 1 ; : : : ; y k ] x 0 = y 0 ^ x 1 = y 1 ^ : : : ^ x k = y k ) Together with the axioms, freeness axioms, that characterise the Herbrand interpre tation of function symbols <ref> [17] </ref> (6) for every function symbol f in Fs (having some arity k) 8 ([f; x 1 ; : : : ; x k ] = [f; y 1 ; : : : ; y k ] ! x 1 = y 1 ^ : : : ^ x k =
Reference: [18] <author> Clark, K. L., </author> <title> Logic-Programming Schemes and Their Implementations, </title> <editor> in: J.-L. Lassez and G. Plotkin (eds.), </editor> <booktitle> Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: systems on sets of equations have been defined, e.g, by Huet [38] 1 , Robinson [57] and Martelli & Montanari [51]. 3.1 Assignments, Herbrand Assignments and Sub stitutions In order to take into consideration the different sorts of variables of the alphabet and expression names of L, the usual definitions <ref> [18] </ref> of assignment, Herbrand assignment and substitution have to be properly modified. <p> The following result relates Herbrand assignments to substitutions. Theorem 3.7 For every Herbrand assignment H there is a substitution S such that H and S are equivalent for every interpretation. The proofs of this and the next theorem are slight modifications of the proofs given by Clark <ref> [18] </ref> in order to take into consideration the different sorts of variables and expression names of L. Given a Herbrand assignment H, we hereafter write b H to indicate the corresponding substitution. The following theorem states a semantic property of substitutions. <p> The second clause states that equivalent relations have the same extensions. 6.2 SLD -Resolution To begin with, note that it is well known how to reformulate SLD-resolution over definite clause programs in terms of sets of equations rather than substitutions (see, e.g., Clark <ref> [18] </ref>). A computation state is a pair hM; Hi, where M is a set of atoms that have to be proved and H is a Herbrand assignment. A set of equations may also contain the atom false; such a set is inconsistent.
Reference: [19] <author> Cohen, J., </author> <title> Constraint Logic Programming Languages, </title> <journal> Comm. ACM, </journal> <volume> 33 </volume> <month> 52-68 </month> <year> (1990). </year>
Reference-contexts: Furthermore, a closer connection between constraint logic programming and metaprogramming has been opened up by this essay. In the field of CLP, Jaffar & Lassez [40] have established conditions under which the basic theorems of logic programming remain valid (Cohen <ref> [19] </ref> presents a summary of the theoretical foundations of CLP ), provided that the set of axioms specifying constraints satisfies some properties.
Reference: [20] <author> Costantini, S., Dell'Acqua, P. and Lanzarone, G. A., </author> <title> Beyond Prolog, </title> <booktitle> in: Proc. AICA, Trieste, </booktitle> <year> 1989. </year>
Reference: [21] <author> Costantini, S., Dell'Acqua, P. and Lanzarone, G. A., </author> <title> Higher-order Extensions to Prolog are Needed, </title> <editor> in: A. Bossi (ed.), </editor> <booktitle> Proc. 5th Italian Conf. on Logic Programming, </booktitle> <address> Padova, </address> <year> 1990. </year>
Reference: [22] <author> Costantini, S., Dell'Acqua, P. and Lanzarone, G. A., </author> <title> Reflective Agents in Meta-logic Programming, </title> <editor> in: A. Pettorossi (ed.), </editor> <booktitle> Meta-Programming in Logic, </booktitle> <publisher> LNCS 649, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Metaprogramming has been so far employed in many applications including debuggers, compilers and program transformers [34, 59, 61]. Furthermore, also applications which can be formalized using other logics, such as modal logic of knowledge and belief <ref> [22, 45] </ref>, or applications for theory construction [14] are objects of metaprogram-ming. A kind of architecture particularly suitable for metaprogramming is presented in the next section. 1 2 CHAPTER 1.
Reference: [23] <author> Costantini, S., Dell'Acqua, P. and Lanzarone, G. A., </author> <title> Extending Horn Clause Theories by Reflection Principles, </title> <editor> in: C. MacNish, D. Pearce and L. M. Pereira (eds.), </editor> <booktitle> Logics in Artificial Intelligence, </booktitle> <publisher> LNAI 838, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: In the context of logic programming, logical reflection is a principled way to further empower the representation and reasoning capabilities of logic programming systems <ref> [23] </ref>. <p> A complete formalization of a concept of reflection that constitutes a simple way of understanding reflective programs, and a description of how reflection allows one to treat uniformly different application areas has been presented by Costantini et al. <ref> [23] </ref>. 1.5 An Overview and Outline of the Thesis This thesis presents an extension of SLD-resolution with naming of expressions and two-way reflection. <p> Such additional axioms of the form ff e 1 ; : : : ; e q ; solve (fi) are called reflection axioms. In the field of AI, a number of forms of reasoning can be modeled by means of different sets of reflection axioms <ref> [23] </ref>. In this approach, we define the reflection axioms in such a way that whenever solve (ff) is provable at the metalevel, ff is provable at the object level.
Reference: [24] <author> Costantini, S. and Lanzarone, G. A., </author> <title> A Metalogic Programming Language, </title> <editor> in: G. Levi and M. Martelli (eds.), </editor> <booktitle> Proc. 6th Intl. Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: The latter category associates with a formula a structured ground term that reflects the structure of the sentence it names. For example, the metalogical programming language Reflective Prolog <ref> [24, 26] </ref> implements a structural descriptive naming relation. The Godel programming language [37] has names as an abstract data type, but provides enough predicates for testing and constructing names, and for extracting their constituents, to also qualify as having a structural descriptive naming relation.
Reference: [25] <author> Costantini, S. and Lanzarone, G. A., </author> <title> Metalevel Negation in Non-Monotonic Reasoning, </title> <booktitle> Intl. J. of Methods of Logic in Computer Science, </booktitle> <month> 1 </month> <year> (1994). </year>
Reference-contexts: Vice versa, by considering extended E-interpretations and reflection axioms it is possible to accommodate various kinds of negation without giving rise to any problem of inconsistency <ref> [25] </ref>. 7.1. DECLARATIVE SEMANTICS 33 Definition 7.12 Let I be an extended E-interpretation of a logic program (P; E). If I reflectively E-satisfies (P; E), then (P; E) is said to be reflective E-satisfiable. (P; E) is reflective E-unsatisfiable iff there exists no extended E-interpretation that reflective E-satisfies (P; E).
Reference: [26] <author> Costantini, S. and Lanzarone, G. A., </author> <title> A Metalogical Programming Approach: Language, Semantics and Applications, </title> <journal> J. Exper. Theor. Artificial Intelligence, </journal> <month> 6 </month> <year> (1994). </year>
Reference-contexts: Therefore, mixed sentences combining object level and metalevel expressions are allowed. The main amalgamated approaches in the AI literature have been established by Bowen & Kowalski [13], Attardi & Simi [5] and Costantini & Lanzarone <ref> [26] </ref>. 1 Some authors call these reflection principles upward and downward reflection, respectively; other authors, instead, use upward reflection (resp., downward reflection) to indicate the procedural shift from the object level to the metalevel (resp., from the metalevel to the object level). <p> The latter category associates with a formula a structured ground term that reflects the structure of the sentence it names. For example, the metalogical programming language Reflective Prolog <ref> [24, 26] </ref> implements a structural descriptive naming relation. The Godel programming language [37] has names as an abstract data type, but provides enough predicates for testing and constructing names, and for extracting their constituents, to also qualify as having a structural descriptive naming relation. <p> In this regard, see Example 7.33. 1.5. AN OVERVIEW AND OUTLINE OF THE THESIS 7 metalevel part of the language. The extension is based on the work of Costantini & Lanzarone <ref> [26] </ref>. As a first immediate application, we obtain a generalization of Reflective Prolog, as the interaction between the levels does not require all the information to be available during the reflective step. <p> x 1 ; : : : ; x k ]) = function (functor (f 1 ); arity (k); arguments (y 1 ; : : : ; y k )) "x 1 = y 1 ; : : : ; "x k = y k ) Example 4.10 In Reflective Prolog <ref> [26] </ref>, we are given sets of symbols together with a naming relation on them (actually the system of sorts is somewhat more elaborate than that of L so the equality theory and the rewrite system are slightly more elaborate). <p> An L fl definite program is a finite set of L fl definite clauses. The following example (taken from Costantini & Lanzarone <ref> [26] </ref>) shows an L fl definite program. <p> The declarative semantics is an extension of that proposed by Jaffar et al. [42] covering also the metalevel part of the language. The extension is based on the work of Costantini & Lanzarone <ref> [26] </ref>. 7.1 Declarative Semantics 7.1.1 Preliminaries One of the advantages of working within the clausal form is that we can consider only Herbrand interpretations when we want to prove that a set of clauses is unsatisfiable. <p> The second reason concerns the fact that encodings influence the semantics of met-alogic languages. In fact, metalanguages that are based on formally defined encodings have clear and well-defined declarative semantics <ref> [26, 58, 60] </ref>. 8.2. DISCUSSION AND CONCLUDING REMARKS 41 In contrast, in order to give a semantic account of a metalogic programming language that employs a trivial encoding (such that "t = t for any term t), two main possibilities have been considered up to now.
Reference: [27] <author> De Schreye, D. and Martens, B., </author> <title> A Sensible Least Herbrand Semantics for Untyped Vanilla Meta-Programming and its Extension to a Limited Form of Amalgamation, </title> <editor> in: A. Pettorossi (ed.), </editor> <booktitle> Meta-Programming in Logic, </booktitle> <publisher> LNCS 649, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: DISCUSSION AND CONCLUDING REMARKS 41 In contrast, in order to give a semantic account of a metalogic programming language that employs a trivial encoding (such that "t = t for any term t), two main possibilities have been considered up to now. De Schreye & Martens <ref> [27] </ref> characterize a class of programs for which the least Herbrand model semantics still holds for the vanilla metainterpreter and a limited form of amalgamation. This is the class of language-independent programs where language independence extends both domain independence and range restrictedness.
Reference: [28] <author> Dell'Acqua, P., </author> <title> Development of the Interpreter for a Metalogic Programming Language, </title> <type> Degree thesis, </type> <institution> Univ. degli Studi di Milano, Milano, </institution> <year> 1989. </year>
Reference-contexts: We believe that the proposed extensions may be integrated easily both in the interpreter <ref> [28] </ref> and the compiler (at present under development) of the language without generating much more complexity in time or space. There are different ways to go from here.
Reference: [29] <author> Dershowitz, N. and Jouannaud, J.-P., </author> <title> Rewrite Systems, </title> <editor> in: J. van Leeuwen (ed.), </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <publisher> Elsevier, </publisher> <address> Amsterdam, </address> <year> 1990. </year> <note> 44 BIBLIOGRAPHY </note>
Reference-contexts: In the rest of the thesis, for logic programming we use the terminology of Lloyd [49] and for rewrite systems we follow that of Dershowitz & Jouannaud <ref> [29] </ref>. Chapter 2 An Abstract Metalanguage In this section we introduce the basic syntactic features of a metalogic definite clause language, called in the following L.
Reference: [30] <author> Elcock, E. W., </author> <title> PROLOG: Subsumption of Equality Axioms by the Homogeneous Form, </title> <journal> J. Logic Programming, </journal> <volume> 1 </volume> <month> 45-56 </month> <year> (1989). </year>
Reference-contexts: In fact, by the work of Elcock <ref> [30] </ref>, this axiom is not needed if we consider the homogeneous form of definite clauses; where the homogeneous form of p (t 1 ; : : : ; t n ) e 1 ; : : : ; e q ; B 1 ; : : : ; B r is
Reference: [31] <author> Eshghi, K., </author> <title> Meta-Language in Logic Programming, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computing, Imperial College, </institution> <address> London, </address> <year> 1986. </year>
Reference-contexts: This is in contrast with the approach discussed by Eshghi <ref> [31] </ref>. In fact, he argues that the purpose of the naming relation is to allow us to refer, in the metalanguage, to the relevant constructs of the object language.
Reference: [32] <author> Falaschi, M., Levi, G., Martelli, M. and Palamidessi, C., </author> <title> A new Declarative Semantics for Logic Languages, </title> <editor> in: R. A. Kowalski and K. A. Bowen (eds.), </editor> <booktitle> Proc. 5th Intl. Conf. Symp. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: Instead they point out another possibility for giving a declarative semantics to the vanilla metainterpreter and some enhanced metainter-preters by abandoning the least Herbrand semantics in favour of the S-semantics <ref> [32] </ref>. Besides resorting to a different semantics, that approach can be applied (as the authors recognize) to enhanced metainterpreters only when there exists a corresponding pure object-level solution. Again, this restricts the power of the language, undermining, in our view, the motivation for using metalevel systems altogether.
Reference: [33] <author> Feferman, S., </author> <title> Transfinite Recursive Progressions of Axiomatic Theories, </title> <journal> J. Symbolic Logic, </journal> <volume> 27 </volume> <month> 259-316 </month> <year> (1962). </year>
Reference-contexts: Non-functional naming relations are useful for defining meaningful naming relations that may employ more than one name of an expression of the object level, according to the extra information they want to encode. 1.4 Reflection Principles The idea of reflection dates back to a work by Feferman <ref> [33] </ref>.
Reference: [34] <author> Gallaire, H. and Lasserre, C., </author> <title> Metalevel Control for Logic Programs, </title> <editor> in: K. L. Clark and S. A. Tarnlund (eds.), </editor> <booktitle> Logic Programming, </booktitle> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1982. </year>
Reference-contexts: This has led to the study and development of powerful metaprogramming techniques that allow us to extend and modify the semantics of an existing object language. Metaprogramming has been so far employed in many applications including debuggers, compilers and program transformers <ref> [34, 59, 61] </ref>. Furthermore, also applications which can be formalized using other logics, such as modal logic of knowledge and belief [22, 45], or applications for theory construction [14] are objects of metaprogram-ming.
Reference: [35] <author> Heintze, N., Michaylov, S., Stuckey, P. J. and Yap, R., </author> <booktitle> On Metaprogramming in CLP(R), in: Proc. 1989 North-American Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: We are aware of a few other attempts to combine metalogic programming and constraint logic programming. Here we present a brief overview, together with some other relevant work, in chronological order. Heintze et al. <ref> [35] </ref> propose an approach that integrates metaprogramming facilities and the constraint paradigm. They extend the language CLP (R) [43] with the aim of allowing manipulations of CLP (R) programs.
Reference: [36] <author> Hill, P. M. and Lloyd, J. W., </author> <title> Analysis of Metaprograms, </title> <editor> in: H. Abramson and M. H. Rogers (eds.), </editor> <booktitle> Meta-Programming in Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: Although many AI systems with a metalevel architecture have implemented naming relations, the formal properties that they must satisfy have usually been assumed without motivations. Bowen & Kowalski [13], for instance, allow the naming relation to be non-functional and require it to be injective, while Hill & Lloyd <ref> [36] </ref> define a naming relation that is total, injective and functional. 4 CHAPTER 1. INTRODUCTION So far, the only investigation of formal properties of naming relations is that of van Harmelen [64]. He argues that naming relations should be definable and meaningful. <p> There is an on-going debate in the metalogic programming community on whether names of expressions should necessarily be ground or not <ref> [10, 36, 44, 47, 52] </ref>. In this proposal we sidestep the question, as the proposed inference system restricts reflection so only ground expressions are ever communicated between levels. Therefore only naming of ground expressions is involved. <p> This is in contrast with the approach discussed by Hill & Lloyd <ref> [36] </ref>. They introduce two basic representation schemes for the logic language of the definite clauses (object language): a non-ground typed representation and a ground representation. With respect to these representations, function and predicate symbols of the object language are represented in the metalanguage by function symbols. <p> of the form [f; x 1 ; : : : ; x k ]. (Jiang introduces an ambivalent logic [44] where he tackles this problem by making no distinction between sentences and terms.) Example 4.9 A more expressive encoding (this is reminiscent of the encoding proposed by Hill & Lloyd <ref> [36] </ref>) could be axiomatized as follows. 4.4.
Reference: [37] <author> Hill, P. M. and Lloyd, J. W., </author> <title> The Godel Programming Language, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: The connection between the metatheory and the object theory is provided by the naming relation and the linking rules. Among the separated approaches we mention the FOL system by Weyhrauch [67], 0 Log by Cervesato & Rossi [15] and the Godel programming language by Lloyd et al. <ref> [37] </ref> (for a survey of these approaches see reference [3]). On the one hand, amalgamated approaches may turn out to be inconsistent. <p> The latter category associates with a formula a structured ground term that reflects the structure of the sentence it names. For example, the metalogical programming language Reflective Prolog [24, 26] implements a structural descriptive naming relation. The Godel programming language <ref> [37] </ref> has names as an abstract data type, but provides enough predicates for testing and constructing names, and for extracting their constituents, to also qualify as having a structural descriptive naming relation. <p> In fact, in this context, metalevel variables can be used instead of names of variables (how this is done will be shown by some examples in the following chapters). In contrast, the metalevel features of languages, for example Godel <ref> [37] </ref>, developed with the primary aim of making program analysis or transformation, strictly need some sort of variable name facility. A further question is then whether it is sufficient to let ground expressions be their own names or not. <p> Since our interest here is to be as general as possible, we only introduce the types strictly needed. (Note that extensions of the language to include a more precise set of types are possible, for example, along the lines of the programming language Godel <ref> [37] </ref>.) The reason for introducing types will be clear in Chapter 6 where some distinguished predicates (that for semantical reasons are required to be typed) are introduced. <p> Since 0 Log employs also structural descriptive names, term names also include compound term names. The Godel programming language <ref> [37] </ref> has names as an abstract datatype. Names of expressions will thus always appear in metaprograms as variables of that type. The metalevel part of a program can use the predicates associated with the datatype to manipulate names. <p> Moreover, in our framework it is possible to have many levels of naming, i.e., names of expressions, names of names, etc., while, in his approach, only one level of naming is allowed. We have already discussed the Godel programming language <ref> [37] </ref>, let us just summarize that its naming relation (though being an abstract datatype) is compositional and that it seems to fit into our framework.
Reference: [38] <author> Huet, G., </author> <title> Resolution d'equations dans les langages d'ordre 1, </title> <type> 2, : : : , !, Ph.D. Thesis, </type> <institution> Universite Paris VII, Paris, </institution> <year> 1976. </year>
Reference-contexts: Unification algorithms expressed as rewrite systems on sets of equations have been defined, e.g, by Huet <ref> [38] </ref> 1 , Robinson [57] and Martelli & Montanari [51]. 3.1 Assignments, Herbrand Assignments and Sub stitutions In order to take into consideration the different sorts of variables of the alphabet and expression names of L, the usual definitions [18] of assignment, Herbrand assignment and substitution have to be properly modified.
Reference: [39] <author> Huet, G., </author> <title> Confluent Reductions: Abstract Properties and Applications to Term Rewriting Systems, </title> <journal> J. ACM, </journal> <volume> 27(4) </volume> <month> 797-821 </month> <year> (1982). </year>
Reference: [40] <author> Jaffar, J. and Lassez, J.-L., </author> <title> Constraint Logic Programming, </title> <booktitle> in: Proc. 14th ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1987. </year>
Reference-contexts: The authors claim that the underlying language extension is consistent with the constraint paradigm and is defined in a manner which is not operational. However, they do not mention how the basic results of CLP <ref> [40] </ref> still hold. Consider their predefined binary predicate coded ccs which takes a list of variables and bounds the second argument to a coding of the solved form of the current constraint with respect to those variables. <p> Furthermore, a closer connection between constraint logic programming and metaprogramming has been opened up by this essay. In the field of CLP, Jaffar & Lassez <ref> [40] </ref> have established conditions under which the basic theorems of logic programming remain valid (Cohen [19] presents a summary of the theoretical foundations of CLP ), provided that the set of axioms specifying constraints satisfies some properties.
Reference: [41] <author> Jaffar, J., Lassez, J.-L. and Maher, M. J., </author> <title> A Theory of Complete Logic Programs with Equality, </title> <journal> J. Logic Programming, </journal> <volume> 3 </volume> <month> 211-223 </month> <year> (1984). </year>
Reference-contexts: Nevertheless, by using Herbrand universe, the notion of equality can be accommodated via syntactic identity only. To overcome this problem, Jaffar et al. <ref> [41] </ref> proposed the use of quotient universes. <p> is reflectively E-unsatisfiable iff A 1 ^ : : : ^ A k is a reflective logical E-consequence of (P; E). 7.1.3 Fixpoint Semantics A least reflective E-model can be characterized as the least fixed point of a mapping T (P;E) similar to the one proposed by Jaffar et al. <ref> [41] </ref>, except that it produces both p (t 1 ; : : : ; t n ) and solve ([p 1 ; s 1 ; : : : ; s n ]), for any predicate symbol p distinct from solve, whenever one of them can be derived.
Reference: [42] <author> Jaffar, J., Lassez, J.-L. and Maher, M. J., </author> <title> A Logic Programming Language Scheme, </title> <editor> in: D. DeGroot and G. Lindstrom (eds.), </editor> <title> Logic Programming| Functions, Relations, and Equations, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1986. </year>
Reference-contexts: After having defined the declarative and fixpoint semantics, in Chapter 7 we establish results of soundness and completeness of SLD fl -resolution. The declarative semantics is an extension of that proposed by Jaffar et al. <ref> [42] </ref> covering also the 4 This is the difference with respect to Reflective Prolog mentioned above. In this regard, see Example 7.33. 1.5. AN OVERVIEW AND OUTLINE OF THE THESIS 7 metalevel part of the language. The extension is based on the work of Costantini & Lanzarone [26]. <p> The declarative semantics is an extension of that proposed by Jaffar et al. <ref> [42] </ref> covering also the metalevel part of the language. <p> Reflective E-models are clearly models in the usual sense <ref> [42] </ref>, as they are obtained by extending a given logic program with a set of definite clauses. Therefore the model intersection property still holds, and there exists a least reflective E-model of (P; E), indicated in the following as LRM (P;E) .
Reference: [43] <author> Jaffar, J. and Michaylov, S., </author> <title> Methodology and Implementation of a CLP System, </title> <editor> in: J.-L. Lassez (ed.), </editor> <booktitle> Proc. 4th Intl. Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1987. </year>
Reference-contexts: Here we present a brief overview, together with some other relevant work, in chronological order. Heintze et al. [35] propose an approach that integrates metaprogramming facilities and the constraint paradigm. They extend the language CLP (R) <ref> [43] </ref> with the aim of allowing manipulations of CLP (R) programs. The resulting language, called CLP (R + M), provides a basis for coding terms in a form which allows arbitrary structural manipulation and for converting between terms and their coded forms.
Reference: [44] <author> Jiang, Y. J., </author> <title> Ambivalent Logic as the Semantic Basis of Metalogic Programming: I, </title> <editor> in: P. V. Hentenryck (ed.), </editor> <booktitle> Proc. 11th Intl. Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: There is an on-going debate in the metalogic programming community on whether names of expressions should necessarily be ground or not <ref> [10, 36, 44, 47, 52] </ref>. In this proposal we sidestep the question, as the proposed inference system restricts reflection so only ground expressions are ever communicated between levels. Therefore only naming of ground expressions is involved. <p> Then we have an ambiguity because it could be either a name term of the form [f; x 1 ; : : : ; x k ] or the term of the form [f; x 1 ; : : : ; x k ]. (Jiang introduces an ambivalent logic <ref> [44] </ref> where he tackles this problem by making no distinction between sentences and terms.) Example 4.9 A more expressive encoding (this is reminiscent of the encoding proposed by Hill & Lloyd [36]) could be axiomatized as follows. 4.4. <p> Jiang <ref> [44] </ref> proposes a basically different approach from ours, where he takes the syntactic ambiguity of Prolog even further. His logic intentionally tries to remove the distinction between predicate and function symbols, etc. For ground expressions his naming scheme can be captured in our framework, by self-naming.
Reference: [45] <author> Kim, J. S. and Kowalski, R. A., </author> <title> A Metalogic Programming Approach to Multi-Agent Knowledge and Belief, </title> <editor> in: V. Lifschitz (ed.), </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation, </booktitle> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: Metaprogramming has been so far employed in many applications including debuggers, compilers and program transformers [34, 59, 61]. Furthermore, also applications which can be formalized using other logics, such as modal logic of knowledge and belief <ref> [22, 45] </ref>, or applications for theory construction [14] are objects of metaprogram-ming. A kind of architecture particularly suitable for metaprogramming is presented in the next section. 1 2 CHAPTER 1.
Reference: [46] <author> Konolige, K., </author> <title> An Autoepistemic Analysis of Metalevel Reasoning in Logic Programming, </title> <editor> in: A. Pettorossi (ed.), </editor> <booktitle> Meta-Programming in Logic, </booktitle> <publisher> LNCS 649, Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year> <note> BIBLIOGRAPHY 45 </note>
Reference-contexts: Definition 7.13 Let I be an extended E-interpretation of a logic program (P; E). Then I is a reflective E-model of (P; E) iff I reflectively E-satisfies (P; E). Our solution is similar to the approaches chosen for autoepistemic logics. Kono-lige <ref> [46] </ref>, for instance, given a theory T , introduces a set of interpretations for T that satisfy some properties, e.g., the principle of groundedness, and then he adds modal schemata to T in order to ensure that a unique model always exists.
Reference: [47] <author> Levi, G. and Ramundo, D., </author> <title> A Formalization of Metaprogramming for Real, </title> <editor> in: D. S. Warren (ed.), </editor> <booktitle> Logic Programming | Proc. 10th Intl. Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1993. </year>
Reference-contexts: There is an on-going debate in the metalogic programming community on whether names of expressions should necessarily be ground or not <ref> [10, 36, 44, 47, 52] </ref>. In this proposal we sidestep the question, as the proposed inference system restricts reflection so only ground expressions are ever communicated between levels. Therefore only naming of ground expressions is involved. <p> This is the class of language-independent programs where language independence extends both domain independence and range restrictedness. As already noted by Levi & Ramundo <ref> [47] </ref>, however, the class of language independent programs is too small: it includes deductive database programs, but rules out any logic program computing partially determined data structures.
Reference: [48] <author> Lim, P. and Stuckey, P. J., </author> <title> Meta Programming as Constraint Programming, </title> <editor> in: S. Debray and M. Hermenegildo (eds.), </editor> <booktitle> Proc. 1990 North-American Conf. on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: Thus the independence of the computation rule, as the previous example shows, does not hold. Lim & Stuckey <ref> [48] </ref> propose a meta-level structure of computation in order to give a logical meaning to metaprograms. In particular, they extend the theory of CLP with a metalevel structure that incorporates a method for representing object level terms 38 8.1.
Reference: [49] <author> Lloyd, J. W., </author> <title> Foundations of Logic Programming, Second Edition, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: The main contribution of the thesis concerns the introduction of name theories, the integration of the rewrite systems for unification and naming, and the formal properties of SLD fl -resolution. In the rest of the thesis, for logic programming we use the terminology of Lloyd <ref> [49] </ref> and for rewrite systems we follow that of Dershowitz & Jouannaud [29]. Chapter 2 An Abstract Metalanguage In this section we introduce the basic syntactic features of a metalogic definite clause language, called in the following L. The language is that of definite programs, as defined by Lloyd [49], except <p> Lloyd <ref> [49] </ref> and for rewrite systems we follow that of Dershowitz & Jouannaud [29]. Chapter 2 An Abstract Metalanguage In this section we introduce the basic syntactic features of a metalogic definite clause language, called in the following L. The language is that of definite programs, as defined by Lloyd [49], except that terms are defined differently in order to include names that are intended to represent the expressions of the language itself. <p> We start by presenting the definition of terms. It extends the usual one <ref> [49] </ref> to include term names and expression names. We define term names, expression names and terms by simultaneous induction. <p> Hence, this SLD fl -derivation ends with a failure state. We begin by appropriately rephrasing the Lifting lemma <ref> [49] </ref>. Lemma 7.34 (Lifting lemma) Let E be a Horn clause equality theory and R E a canonical rewrite system for E. Let (P; E) be a logic program, H a Herbrand assign ment and G a definite goal.
Reference: [50] <author> Maher, M. J., </author> <title> A Logic Programming View of CLP, </title> <booktitle> Proc. 10th Intl. Conf. on Logic Programming, </booktitle> <pages> pp. </pages> <month> 737-753 </month> <year> (1993). </year>
Reference-contexts: Furthermore, we are considering lifting some of the definitions and results of our approach into the more general CLP setting (the lift of results from the theory of logic programming to the theory of CLP has been systematized by Maher <ref> [50] </ref>) in order to obtain stronger results and simpler proofs.
Reference: [51] <author> Martelli, A. and Montanari, U., </author> <title> An Efficient Unification Algorithm, </title> <journal> ACM TOPLAS, </journal> <volume> 4 </volume> <month> 258-282 </month> <year> (1982). </year>
Reference-contexts: Unification algorithms expressed as rewrite systems on sets of equations have been defined, e.g, by Huet [38] 1 , Robinson [57] and Martelli & Montanari <ref> [51] </ref>. 3.1 Assignments, Herbrand Assignments and Sub stitutions In order to take into consideration the different sorts of variables of the alphabet and expression names of L, the usual definitions [18] of assignment, Herbrand assignment and substitution have to be properly modified. <p> The next result proves termination of the unification rewrite system. (The structure of the proof is similar to the proof given by Martelli & Montanari <ref> [51] </ref> for the unification algorithm (called algorithm1 in [51]). ) The proof of this and thse following theorems is reported in the Appendix. <p> The next result proves termination of the unification rewrite system. (The structure of the proof is similar to the proof given by Martelli & Montanari <ref> [51] </ref> for the unification algorithm (called algorithm1 in [51]). ) The proof of this and thse following theorems is reported in the Appendix.
Reference: [52] <author> Martens, B. and De Schreye, D., </author> <title> Why Untyped Non-Ground Meta-Programming Is Not (Much of) a Problem, </title> <type> CW report 159, </type> <institution> Computer Science Dept., Katholieke Univ. Leuven, </institution> <year> 1992. </year>
Reference-contexts: There is an on-going debate in the metalogic programming community on whether names of expressions should necessarily be ground or not <ref> [10, 36, 44, 47, 52] </ref>. In this proposal we sidestep the question, as the proposed inference system restricts reflection so only ground expressions are ever communicated between levels. Therefore only naming of ground expressions is involved.
Reference: [53] <author> Meier, M., Dufresne, P. and Villeneuve, D., </author> <title> SEPIA Manual, </title> <type> ECRC Technical Report TR-LP-36, </type> <institution> ECRC, Munich, </institution> <year> 1988. </year>
Reference-contexts: There are different ways to go from here. One could be that of studying techniques for developing efficient constraint solvers, starting from the ones developed for systems such as NuProlog [55] and Sepia <ref> [53] </ref>. Furthermore, a closer connection between constraint logic programming and metaprogramming has been opened up by this essay.
Reference: [54] <author> Moore, R., </author> <title> Reasoning about Knowledge and Action, </title> <booktitle> in: Proc. Fifth Intl. Joint Conf. on Artificial Intelligence, </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Calif., </address> <year> 1977. </year>
Reference-contexts: See, for example, the issues raised by Moore <ref> [54] </ref>). 1.3 Naming Relations The notion of naming relation originates in works of logic. Tarski [62], for example, defined a naming relation as a mapping from expressions in the object language to variable free terms in the metalanguage.
Reference: [55] <editor> Naish, L., Negation and Quantifiers in Nu-Prolog, in: E. Shapiro (ed.), </editor> <booktitle> Proc. 3rd Intl. Conf. on Logic Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: There are different ways to go from here. One could be that of studying techniques for developing efficient constraint solvers, starting from the ones developed for systems such as NuProlog <ref> [55] </ref> and Sepia [53]. Furthermore, a closer connection between constraint logic programming and metaprogramming has been opened up by this essay.
Reference: [56] <author> Robinson, J. A., </author> <title> A Machine-Oriented Logic Based on the Resolution Principle, </title> <journal> J. ACM, </journal> <volume> 12 </volume> <month> 23-41 </month> <year> (1965). </year>
Reference-contexts: Chapter 3 Unification The main computational step of SLD-resolution is the unification <ref> [56] </ref> of one or more pair of terms f (ff 1 ; fi 1 ); : : : ; (ff k ; fi k )g.
Reference: [57] <author> Robinson, J. A., </author> <title> Fast Unification (abstract), </title> <booktitle> in: Tagung uber Automatisches Beweisen, Mathematisches Forschungsinstitut Oberwolfach, </booktitle> <year> 1976. </year>
Reference-contexts: Unification algorithms expressed as rewrite systems on sets of equations have been defined, e.g, by Huet [38] 1 , Robinson <ref> [57] </ref> and Martelli & Montanari [51]. 3.1 Assignments, Herbrand Assignments and Sub stitutions In order to take into consideration the different sorts of variables of the alphabet and expression names of L, the usual definitions [18] of assignment, Herbrand assignment and substitution have to be properly modified.
Reference: [58] <author> Sato, T., </author> <title> Meta-Programming through a Truth Predicate, </title> <editor> in: K. Apt (ed.), </editor> <booktitle> Proc. Joint Intl. Conf. Symp. on Logic Programming 1992, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: In this case delayed constraints do not lead to floundering conditions because all constraints are defined in such a way as to manipulate frozen objects or to check the solvability of object level constraints. (Constraints, for example, cannot be used to check the satisfiability of predicates.) Sato <ref> [58] </ref> has presented a style of metaprogramming based on a truth predicate in three-valued logic. It is interesting to note that the naming relation he proposes is compositional, although he considers naming also of nonground (but closed) expressions. <p> The second reason concerns the fact that encodings influence the semantics of met-alogic languages. In fact, metalanguages that are based on formally defined encodings have clear and well-defined declarative semantics <ref> [26, 58, 60] </ref>. 8.2. DISCUSSION AND CONCLUDING REMARKS 41 In contrast, in order to give a semantic account of a metalogic programming language that employs a trivial encoding (such that "t = t for any term t), two main possibilities have been considered up to now.
Reference: [59] <author> L. Sterling and E. Y. Shapiro (eds.), </author> <title> The Art of Prolog, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: This has led to the study and development of powerful metaprogramming techniques that allow us to extend and modify the semantics of an existing object language. Metaprogramming has been so far employed in many applications including debuggers, compilers and program transformers <ref> [34, 59, 61] </ref>. Furthermore, also applications which can be formalized using other logics, such as modal logic of knowledge and belief [22, 45], or applications for theory construction [14] are objects of metaprogram-ming. <p> The encoding axiomatized by the first two axioms corresponds to the "encoding" (identity function) typically used in Prolog metainterpreters <ref> [59] </ref>. (1) For every constant c "c = c (2) For every function symbol f (having some arity k) 8x 1 ; : : : ; x k 2 T ("([f; x 1 ; : : : ; x k ]) = [f; x 1 ; : : : ; x
Reference: [60] <author> Subrahmanian, V. S., </author> <title> Foundations of Metalogic Programming, </title> <editor> in: H. Abramson and M. H. Rogers (eds.), </editor> <booktitle> Meta-Programming in Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: The second reason concerns the fact that encodings influence the semantics of met-alogic languages. In fact, metalanguages that are based on formally defined encodings have clear and well-defined declarative semantics <ref> [26, 58, 60] </ref>. 8.2. DISCUSSION AND CONCLUDING REMARKS 41 In contrast, in order to give a semantic account of a metalogic programming language that employs a trivial encoding (such that "t = t for any term t), two main possibilities have been considered up to now.
Reference: [61] <author> Takeuchi, A. and Furukawa, K., </author> <title> Partial Evaluation of Prolog Programs and its Applications to Metaprogramming, </title> <editor> in: H. J. Kugler (ed.), </editor> <booktitle> Information Processing 86, </booktitle> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: This has led to the study and development of powerful metaprogramming techniques that allow us to extend and modify the semantics of an existing object language. Metaprogramming has been so far employed in many applications including debuggers, compilers and program transformers <ref> [34, 59, 61] </ref>. Furthermore, also applications which can be formalized using other logics, such as modal logic of knowledge and belief [22, 45], or applications for theory construction [14] are objects of metaprogram-ming.

Reference: [66] <author> P. van Hentenryck (ed.), </author> <title> Constraint Satisfaction in Logic Programming, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: By using delay conditions a fast and simple constraint solver relying on a local propagation scheme can be developed <ref> [66] </ref>. Not always, however, can the constraint solver determine when a system of constraints is unsatisfiable. For example, the constraint fN , f 1 (X); N , g 1 (Y )g is unsatisfiable but this will not be detected by a delaying constraint solver, unless more information arrives.
Reference: [67] <author> Weyhrauch, R. W., </author> <title> Prolegomena to a Theory of Mechanized Formal Reasoning, </title> <booktitle> Artificial Intelligence, </booktitle> <pages> pp. </pages> <month> 133-70 </month> <year> (1980). </year>
Reference-contexts: Therefore, it is not possible to write sentences mixing object level and metalevel expressions. The connection between the metatheory and the object theory is provided by the naming relation and the linking rules. Among the separated approaches we mention the FOL system by Weyhrauch <ref> [67] </ref>, 0 Log by Cervesato & Rossi [15] and the Godel programming language by Lloyd et al. [37] (for a survey of these approaches see reference [3]). On the one hand, amalgamated approaches may turn out to be inconsistent.
Reference: [68] <author> Yalcinap, L. U., </author> <title> Meta-Programming for Knowledge Based Systems in Prolog, </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computer Engineering and Science, Case Western Reserve University, Cleveland, USA, </institution> <year> 1991. </year>
Reference-contexts: Again, this restricts the power of the language, undermining, in our view, the motivation for using metalevel systems altogether. In fact, a fully corresponding object-level solution does not exist for every metalogic program, as pointed out, for instance, by Yalcinap <ref> [68] </ref>. Therefore, in order to exploit the full potential of metalogic programming, this kind of "no naming", although simple and efficient, must give place to more expressive forms of encoding.
References-found: 64

