URL: http://www.isi.edu/isd/I-DOC/ASE-expanded.ps
Refering-URL: http://www.isi.edu/isd/I-DOC/
Root-URL: http://www.isi.edu
Title: Interactive Explanation of Software Systems  Editor:  
Author: W. LEWIS JOHNSON AND ALI ERDEM 
Keyword: software explanation, software understanding, hypertext, World Wide Web  
Address: 4676 Admiralty Way, Marina del Rey, CA 90292-6695  
Affiliation: USC Information Sciences Institute Computer Science Dept.  
Note: 1-22 c Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.  
Email: fjohnson,erdemg@isi.edu  
Web: WWW: http://www.isi.edu/isd/johnson.html, erdem.html  
Date: Received May 1, 1991  
Abstract: This paper describes an effort to provide automated support for the interactive inquiry and explanation process that is at the heart of software understanding. A hypermedia tool called I-Doc allows software engineers to post queries about a software system, and generates focused explanations in response. These explanations are task-oriented, i.e., they are sensitive to the software engineering task being performed by the user that led to the query. Task orientation leads to more effective explanations, and is particularly helpful for understanding large software systems. Empirical studies of inquiry episodes were conducted in order to investigate this claim: the kinds of questions users ask, their relation to the user's task and level of expertise. The I-Doc tool is being developed to embody these principles, employing knowledge-based techniques. The presentation mechanism employs World Wide Web (WWW) technology, making it suitable for widespread use. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. Brooks. </author> <title> Towards a theory of the comprehension of computer programs. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 18 </volume> <pages> 543-554, </pages> <year> 1983. </year>
Reference-contexts: 1. Introduction and Motivation Software engineers, and software maintainers in particular, spend significant amounts of time attempting to understand software artifacts [2]. These software understanding activities have been characterized by Brooks and Soloway <ref> [1] </ref>, [15] as being composed of inquiry episodes. According to Soloway et al., inquiry episodes involve the following steps: read some code, ask a question about the code, conjecture an answer, and search the documentation and code for confirmation of the conjecture. <p> Software engineering tasks such as design or maintenance are much broader, and the influence of such tasks on software understanding is unclear, although software understanding researchers such as Brooks have conjectured that such influences exist <ref> [1] </ref>. In order to develop tools that approach the ideal of an on-line software consultant, our work has proceeded on two thrusts.
Reference: 2. <author> T.A. Corbi. </author> <title> Program understanding: Challenge for the 1990s. </title> <journal> IBM Systems Journal, </journal> <volume> 28(2) </volume> <pages> 294-306, </pages> <year> 1990. </year>
Reference-contexts: 1. Introduction and Motivation Software engineers, and software maintainers in particular, spend significant amounts of time attempting to understand software artifacts <ref> [2] </ref>. These software understanding activities have been characterized by Brooks and Soloway [1], [15] as being composed of inquiry episodes.
Reference: 3. <author> J.H. </author> <title> Cross and T.D. Hendrix. Using generalized markup and SGML for reverse engineering graphical representations of software. </title> <booktitle> In Proceedings of the 2d Working Conference on Reengineering, </booktitle> <year> 1995. </year>
Reference-contexts: The tags are enclosed in angle brackets, and either represent the attribute values individually or serve as starting and ending delimiters surrounding the attribute value. This scheme is somewhat similar to the one used by the GRASP-ML system for annotating source code <ref> [3] </ref>. Attribute values may be text strings or collections of features used to identify the object that is the attribute value. Figure ?? shows the internal representation of the control portion of AMPSE's application programmer interface.
Reference: 4. <author> D.E. Egan. </author> <title> Individual differences in human-computer interaction. </title> <editor> In M. Helander, editor, </editor> <title> Handbook of Human-Computer Interaction, </title> <booktitle> chapter 24, </booktitle> <pages> pages 543-568. </pages> <publisher> Elsevier Science Publishers B.V. (North Holland), </publisher> <year> 1988. </year>
Reference-contexts: However this difference is not as 12 significant as the previous one, since both Tcl and Tk are interpretive languages. Egan claimed that there is some overlap in terms of the mental processes for coding and debugging in interpretive languages <ref> [4] </ref>. Programmers using interpreted languages generate a small amount of code, read it for comprehension and correct errors in a continuous fashion [4]. <p> Egan claimed that there is some overlap in terms of the mental processes for coding and debugging in interpretive languages <ref> [4] </ref>. Programmers using interpreted languages generate a small amount of code, read it for comprehension and correct errors in a continuous fashion [4]. Although most of the questions posted to this newsgroup came from program developers, we believe that similar questions will be asked by maintenance programmers when they try to understand the same programs. The bias in the data limited the observations of this study.
Reference: 5. <author> J.D. Herbsleb and E. Kuwana. </author> <title> Preserving knowledge in design projects: What designers need to know. </title> <booktitle> In INTERCHI'93, </booktitle> <year> 1993. </year>
Reference-contexts: It also gave us some data for investigating where the users look for an answer, the source code or the documentation, and under what conditions. 2.2. Data Analysis We read 1250 messages posted to the newsgroup between 2/17/95 and 4/22/95. For data analysis we followed a method similar to <ref> [5] </ref>. We considered only the messages that asked questions about Tcl/Tk. Messages asking irrelevant questions (distribution sites, FAQ location etc.), product announcements, opinions were ignored. We found 249 questions and classified them as follows: We first tried to estimate the user's expertise level. <p> Finally we identified the target for each question in order to find out the relations between question type, level of expertise and target. As in Herbsleb and Kuwana's study <ref> [5] </ref>, we defined target as the subject of the question or the task user was asking about. For example How can I pass an array from Tcl to C? had the target array. Some sample questions and their classifications are given in table 1. 7 Table 2.
Reference: 6. <author> W.C. Hill and J.R Miller. </author> <title> Justified advice: A semi-naturalistic study of advisory strategies. </title> <booktitle> In CHI'88. ACM, </booktitle> <year> 1988. </year>
Reference-contexts: Other researchers had tried to classify the user questions before. For example, Wright claimed that users' questions are either task oriented or symptom oriented [17]. Hill and Miller studied the types of questions asked by users of an experimental graphical statistics program <ref> [6] </ref> and they categorized questions as plans to subgoals; describe, identify, verify system object; describe system capability etc. After analyzing the questions, we arrived at a slightly different classification. This is partially due to the differences of user groups being studied. <p> Similarly maintenance programmers and debuggers are very interested in learning how a system works. The results of our study somewhat agrees with other researchers' results. Hill and Miller studied the types of questions asked by users of an experimental graphical statistics system <ref> [6] </ref>. They categorized questions differently like plans to subgoal, describe system object etc. When their results are converted to our categorization, goal oriented questions were 70%, system oriented questions were 22% and problem oriented questions were 4% of the total questions.
Reference: 7. <author> W.L. Johnson, M.S. Feather, and D.R. Harris. </author> <title> Representation and presentation of requirements knowledge. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 18(10) </volume> <pages> 853-869, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The AMPSE provides an alternative to next-generation, ....... For more information, please check &lt;A HREF="http://www.isi.edu/isd/i-doc.html&gt; I-Doc homepage&lt;/A&gt; &lt;</WHAT&gt;> &lt;</USER&gt;> &lt;</OBJECT&gt;&gt; &lt;<OBJECT&gt;> AMPSE.User.Process &lt;</OBJECT&gt;&gt; specification or from the package specification containing it. This capability is similar to the relation derivation mechanisms incorporated in the ARIES system <ref> [7] </ref>, although limited in that no provision exists as of yet for editing derived attributes. 5.2. Documentation repository Documentation repository is a simple frame based knowledge base where attributes and methods of software and user defined objects are stored. Data is stored in an SGML like format.
Reference: 8. <author> A. Lakhotia. </author> <title> Understanding someone else's code: Analysis of experiences. </title> <journal> Journal of Systems Software, </journal> <volume> 2 </volume> <pages> 93-100, </pages> <year> 1993. </year>
Reference-contexts: Such manuals attempt to anticipate the tasks that users might need to perform, and provide information to help achieve them. Although advocates of minimal manuals claim that novice users are in particular need of task-oriented documentation, it is reasonable to hypothesize that software professionals would benefit as well. Lakhotia <ref> [8] </ref>, for example, quotes a software developer who says that what he would like in the way of a software understanding tool is "something that helps me get the job done, fast." Unfortunately, the tasks of software professionals in general are not precisely defined.
Reference: 9. <author> A.W. Lazonder and J. van der Meij. </author> <title> The minimal manual: is less really more? Int. </title> <journal> J Man-Machine Studies, </journal> <volume> 39 </volume> <pages> 729-752, </pages> <year> 1993. </year>
Reference-contexts: Third, they should take into account the goals of the questioner. The content of the answer can depend upon what the user is trying to do with the information. Principles similar to these are already the basis for the design of certain types of user manuals, namely minimal manuals <ref> [9] </ref>. Such manuals attempt to anticipate the tasks that users might need to perform, and provide information to help achieve them. Although advocates of minimal manuals claim that novice users are in particular need of task-oriented documentation, it is reasonable to hypothesize that software professionals would benefit as well.
Reference: 10. <author> D. </author> <title> Mayhew. Principles & Guidelines in Software User Interface Design. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Similarly 51% of goal oriented questions included examples. However, the descriptions in goal oriented questions were more general than symptom oriented ones. Especially complex tasks were specified with general descriptions rather than specifics. 2.4. Implications for I-Doc Mayhew lists some of the properties of good documentation <ref> [10] </ref>. These and the results of our study suggest the following for I-Doc: 11 Table 3.
Reference: 11. <author> J.D. Moore. </author> <title> Participating in Explanatory Dialogues. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1995. </year>
Reference-contexts: Such a tool should be able to respond directly to the user's inquiry with information that helps provide an answer. Research in automating consultative dialogs has identified a number of important requirements for explanation systems <ref> [11] </ref>. First, they must of course have the necessary knowledge to provide the desired answers. Second, they must provide answers in a form that the questioner can understand, and avoid concepts that the questioner is unfamiliar with. Third, they should take into account the goals of the questioner.
Reference: 12. <author> V. Rajlich, J. Doran, and R.T.S. Gudla. </author> <title> Layered explanation of software: A methodology for program comprehension. </title> <booktitle> In Proceedings of the Workshop on Program Comprehension, </booktitle> <year> 1994. </year>
Reference-contexts: Soloway uses this technique to document delocalized plans, linking the various 2 elements of the plan together. The other method is to layer documentation, so that different types of information reside in different layers. For example, Rajlich <ref> [12] </ref> organizes information into a problem domain layer, an algorithm layer, and a representation layer. Understanders can then limit their reading and searching to particular layers. The conjecture-and-search method of obtaining answers to questions is essentially unchanged in these approaches, but the search process is made more efficient. <p> Empirical Study 2.1. Motivation In order to obtain a realistic picture of the software inquiry process, it is desirable to focus on the task of understanding large, complex systems. Most investigations of software understanding, such as Soloway's study at JPL [15] or Rajlich's study <ref> [12] </ref>, concern themselves instead with small programs, of 500 lines or less. However, the task of understanding a small program is likely to be different from that of understanding a large program.
Reference: 13. <author> P.L. Hunsaker R.E. Coffey, C.W. Cook. </author> <title> Management and Organizational Behavior. </title> <publisher> Austen Press, </publisher> <year> 1994. </year>
Reference-contexts: Research in behavioral theory supports this observation. It is known that when faced with a problem some people use just enough information to arrive at a feasible solution (satisficers) whereas some others gather as much information as they can (maximizers) <ref> [13] </ref>. Individual differences has to be taken into consideration in answering users' questions. 2.3.4. To what extent is the information available from conventional documenta tion sources? Half of the questions could have been answered by consulting the documentation or source code.
Reference: 14. <author> P.S. Selfridge. </author> <title> Integrating code knowledge with a software information system. </title> <booktitle> In Proceedings of the 5th Annual Knowledge-Based Software Assistant Conference, </booktitle> <pages> pages 183-195, </pages> <address> Syracuse, NY, </address> <year> 1990. </year>
Reference-contexts: Because of the important roles that conjecture and search play in the process, Selfridge has described software understanding as a discovery process <ref> [14] </ref>. Search in software understanding is very error-prone; people do not always know where to look for information to support their conjectures. In Soloway's studies the most successful subjects systematically scanned code and documentation from beginning to end, to make sure they found the information they required.
Reference: 15. <author> E. Soloway, J. Pinto, S.I. Letovsky, D. Littman, and R. Lampert. </author> <title> Designing documentation to compensate for delocalized plans. </title> <journal> Communications of the ACM, </journal> <volume> 31(11), </volume> <month> November </month> <year> 1988. </year>
Reference-contexts: 1. Introduction and Motivation Software engineers, and software maintainers in particular, spend significant amounts of time attempting to understand software artifacts [2]. These software understanding activities have been characterized by Brooks and Soloway [1], <ref> [15] </ref> as being composed of inquiry episodes. According to Soloway et al., inquiry episodes involve the following steps: read some code, ask a question about the code, conjecture an answer, and search the documentation and code for confirmation of the conjecture. <p> Empirical Study 2.1. Motivation In order to obtain a realistic picture of the software inquiry process, it is desirable to focus on the task of understanding large, complex systems. Most investigations of software understanding, such as Soloway's study at JPL <ref> [15] </ref> or Rajlich's study [12], concern themselves instead with small programs, of 500 lines or less. However, the task of understanding a small program is likely to be different from that of understanding a large program. <p> What does really happen in 'open' ? Is there any way out of this? Soloway et al. found that users employed two macro strategies for finding the answer to their questions, systematic and as-needed <ref> [15] </ref>. Systematic strategy users read all the documentation whereas as-needed strategy users sought information only when necessary. Research in behavioral theory supports this observation. <p> The documentation, which was structured similarly, was easy to maintain, but it didn't make finding the answer to the second question easier. Documentation that supported delocalized plans could have shortened the time to find the answer <ref> [15] </ref>. The information that needs to be delocalized depends on the task and in practice separate documentation is required for different tasks, e.g. programmer's manual, maintenance manual etc. There is considerable information overlap between these manuals, and duplicating the same information in different documents introduces the maintainability problem.
Reference: 16. <author> L. Wall and R.L. Schwartz. </author> <title> Programming perl. </title> <publisher> O'Reilly & Associates, </publisher> <address> Sebastopol, CA, </address> <year> 1991. </year>
Reference-contexts: I-Doc is designed to be an extensible open system and gives the users the ability to tailor the system to their needs. 5.3. CGI scripts Presentations are generated by scripts written in the Perl language <ref> [16] </ref>. Perl was chosen because it is a high-level language somewhat comparable to Lisp, has strong string manipulation facilities, but does not produce large binary files. The scripts can executed on demand by the HTTPD server, without delays for system initialization as in Lisp. Each script is supplied five parameters.

References-found: 16

