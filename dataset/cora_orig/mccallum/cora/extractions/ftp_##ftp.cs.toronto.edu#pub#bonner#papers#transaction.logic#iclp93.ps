URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/iclp93.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  kifer@cs.sunysb.edu  
Title: Transaction Logic Programming  
Author: Anthony J. Bonner Michael Kifer 
Date: June 21-24 1993.  
Note: Appears in Proceedings of the Tenth International Conference on Logic Programming (ICLP), pages 257-279. MIT Press. Conference held in Budapest, Hungary,  Work supported in part by an Operating Grant from the Natural Sciences and Engineering Research Council of Canada and by a Connaught Grant from the University of Toronto. Supported in part by NSF grant CCR-9102159 and a grant from New York Science and Technology Foundation. Work done during sabbatical year at the  is gratefully acknowledged.  
Address: Toronto, Ontario M5S 1A4, Canada  NY 11790, U.S.A.  
Affiliation: Department of Computer Science University of Toronto  Department of Computer Science SUNY at Stony Brook Stony Brook,  University of Toronto. Support of Computer Systems Research Institute of University of Toronto  
Abstract: An extension of predicate logic, called Transaction Logic, is proposed, which accounts in a clean and declarative fashion for the phenomenon of state changes in logic programs and databases. Transaction Logic has a natural model theory and a sound and complete proof theory, but unlike many other logics, it allows users to program transactions. The semantics leads naturally to features whose amalgamation in a single logic has proved elusive in the past. These features include both hypothetical and committed updates, dynamic constraints on transaction execution, non-determinism, and bulk updates. Finally, Transaction Logic holds promise as a logical model of hitherto non-logical phenomena, including so-called procedural knowledge in AI, and the behavior of object-oriented databases, especially methods with side effects. This paper presents the semantics of Transaction Logic coupled with a sound and complete proof theory for a Horn-like subset of the logic. This paper is available at the following URL: ftp://db.toronto.edu/pub/bonner/papers/transaction.logic/iclp93.ps.gz 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural and declarative database update languages. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 240-250, </pages> <address> New York, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: Transaction formulas combine simple transactions into complex ones. However, we also need a way to specify elementary changes to a database. One way to define such changes is to build them into the semantics as in <ref> [17, 21, 7, 1, 19] </ref>. The problem with this approach is that adding new kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to a revamping of the entire theory, including proofs of soundness and completeness. <p> Second, state changes in Process Logic are hypothetical, and there seems to be no easy to make them permanent. Abiteboul and Vianu developed a family of update languages <ref> [1] </ref>, and provided impressive results on complexity and expressibility. However, these languages lack several features that are present in T R. First, they apply only to relational databases, not to arbitrary sets of first-order formulas. Second, there is no facility for constraining transaction execution. <p> This lack of subroutines is reflected in the data complexity of some of the languages: they are in PSPACE, whereas recursive subroutines require alternating PSPACE, that is, EXPTIME. The works [22, 8] are related to <ref> [1] </ref> in that they borrow much of the syntax from deductive databases and yet their semantics is operational (although inspired by logical model theory). As such, these languages are in a different league than T R.
Reference: [2] <author> J.F. Allen. </author> <title> Towards a general theory of action and time. </title> <journal> Artificial Intelligence, </journal> <volume> 23 </volume> <pages> 123-154, </pages> <month> July </month> <year> 1984. </year> <month> 23 </month>
Reference-contexts: The repertoire of executional constraints expressible in T R is very large. It is easy to specify that transactions must overlap, start or end simultaneously, one should terminate after the other, etc. In [5] we show that the full set of temporal relationships of Allen's logic of time intervals <ref> [2] </ref> has a simple and natural representation in T R. <p> As such, these languages are in a different league than T R. We should also mention works based on Allen's logic of time intervals <ref> [2] </ref>, such as the event calculus of Kowalski and Sergot [16, 15] and the logic of Halpern and Shoham [11]. While the former present a methodology for programming Allen's time intervals in a classical setting, Halpern and Shoham develop a propositional modal logic for them.
Reference: [3] <editor> F. Bancilhon. A logic-programming/Object-oriented cocktail. </editor> <booktitle> SIGMOD Record, </booktitle> <volume> 15(3) </volume> <pages> 11-21, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: However, despite a plethora of action logics, researchers continue to complain that there is no clear declarative semantics for updates either in databases or in logic programming <ref> [4, 3, 22] </ref>. In fact|in stark contrast to classical logic|no action logic has ever become a core of databases or logic-programming, in theory or in practice. There appear to be a few simple reasons for this unsuitability of existing action logics.
Reference: [4] <author> C. Beeri. </author> <title> New data models and languages|The challenge. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 1-15, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1992. </year> <note> ACM. </note>
Reference-contexts: However, despite a plethora of action logics, researchers continue to complain that there is no clear declarative semantics for updates either in databases or in logic programming <ref> [4, 3, 22] </ref>. In fact|in stark contrast to classical logic|no action logic has ever become a core of databases or logic-programming, in theory or in practice. There appear to be a few simple reasons for this unsuitability of existing action logics.
Reference: [5] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-270, </type> <institution> University of Toronto, </institution> <month> April </month> <year> 1992. </year> <note> Revised: February 1994. ftp://csri-technical-reports/270/report.ps. </note>
Reference-contexts: It was therefore developed as a general logic, so that it could solve a wide range of update-related problems. Individual applications can be carved out of different fragments of the logic. These applications, both practical and theoretical, are discussed in great detail in <ref> [5] </ref>. For instance, T R provides a logical account of many update-related phenomena. In logic programming, this leads to a clean, logical treatment of the assert and retract operators in Prolog, which effectively extends the theory of logic programming to include updates as well as queries. <p> In this paper, we use the insertion and deletion of atomic formulas as canonical examples of elementary updates. However, other kinds of elementary updates may also be useful. For instance, relational assignment can be used to express SQL-style bulk updates <ref> [5] </ref> Elementary updates are atomic in that they cannot be decomposed into simpler updates. We therefore represent them by atomic formulas. Like all atomic formulas, elementary updates have a truth value; but in addition, they have a side effect on the database. <p> Formally, the following is true: 4 P; D; D 0 j= (ins:lost _ ins:f ound) ^ (ins:lost _ ins:won) iff D 0 = D + flostg In this way, classical conjunction reduces non-determinism and, in this particular example, yields a completely deterministic transaction. 2 In <ref> [5] </ref>, we explore the richness of T R for expressing constraints. Much of this expressiveness comes from serial conjunction, especially when combined with negation. <p> For example, the last formula can be rewritten as : . The repertoire of executional constraints expressible in T R is very large. It is easy to specify that transactions must overlap, start or end simultaneously, one should terminate after the other, etc. In <ref> [5] </ref> we show that the full set of temporal relationships of Allen's logic of time intervals [2] has a simple and natural representation in T R. <p> This drawback is quite serious, as there appears to be no small, single set of elementary transitions that is best for all purposes <ref> [5] </ref>. Thus, rather than committing T R to a fixed set of elementary transitions, we have chosen to treat these transitions as a parameter of T R. Each set of such transitions, thus, gives rise to a different version of the logic. <p> In practice, transaction bases would not be materialized, but rather generated on demand by an algorithm. The reader is referred to <ref> [5] </ref> for a more detailed discussion. 4 Model Theory Just as the syntax is based on two basic ideas|serial conjunction and elementary transitions|the semantics is also based on a few fundamental ideas: * Transaction Execution Paths: A transaction causes a sequence of database state changes; * Database States: A database state <p> In particular, top-down inference corresponds to forward execution (the normal kind), and bottom-up inference corresponds to reverse execution (i.e., starting from the current state, compute new states by executing all updates in reverse). In <ref> [5] </ref>, we also introduce a dual system, = II , which is useful for bottom-up transaction execution. Additionally, when hypothetical transactions are allowed, [5] describes = 3 |an elegant inference system that amalgamates = I and = II , and is complete even in the presence of hypothetical modal operators. <p> In <ref> [5] </ref>, we also introduce a dual system, = II , which is useful for bottom-up transaction execution. Additionally, when hypothetical transactions are allowed, [5] describes = 3 |an elegant inference system that amalgamates = I and = II , and is complete even in the presence of hypothetical modal operators. <p> Likewise, by constructing the deduction from the bottom, up, the database is systematically updated from D n to D n1 : : : to D 0 . We call this reverse execution. The process of constructing deductions and executing transactions is developed in detail in <ref> [5] </ref>. 5.3 Example: Inference with Unification As in Prolog, our inference system returns a substitution. The substitution specifies values of the free variables for which the transaction succeeds. The example here is similar to Example 2.5, in which a robot simulator moves blocks around a table top. <p> Likewise, none of them can seamlessly accommodate hypothetical state transitions with transitions that actually commit and permanently change the current database state; and, with the exception of [13], all of the works are limited to updating sets of ground atomic facts. A more extensive comparison can be found in <ref> [5] </ref>. Winslett [24] did foundational work on the meaning of updates to general logical theories. Later, Grahne, Katsuno and Mendelzon [13, 10] axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results. <p> The way parallel actions are introduced in [7] is undesirable, since it complicates the semantics greatly, making it non-monotonic even in the absence of negation. T R achieves the same effect in a much simpler, monotonic way <ref> [5] </ref>. Finally, the syntax of the calculus is not closed. For instance, negation can be applied to some formulas but not others. In particular, if is an updating transaction, then rules like p have no meaning, since this is equivalent to p _ : .
Reference: [6] <author> A.J. Bonner and M. Kifer. </author> <title> A general logic of state change. </title> <type> Technical report, </type> <institution> CSRI, University of Toronto, </institution> <year> 1995. </year> <note> In preparation. </note>
Reference-contexts: j= ff ^ fi if and only if B; P; D j= ff fi Intuitively, this lemma says that the result of evaluating a conjunctive query is the same whether the conjuncts are evaluated sequentially or in parallel. 5 Proof Theory T R has a sound and complete proof procedure <ref> [6] </ref>. This procedure, however, is relatively complex and is beyond the scope of this paper. Fortunately, like classical logic, T R has a "Horn" version|called serial-Horn T R|which has a substantially-simpler proof theory. Like classical Horn programs, serial-Horn programs have both a procedural and a declarative semantics. <p> Although serial Horn T R is a very expressive logic, some useful programs are not Horn. Such programs typically arise when the user applies constraints to the execution of programs that are serial-Horn (see Section 2.4). Although constraints can be handled by a general-purpose proof theory of T R <ref> [6] </ref>, there is a more efficient, special-purpose inference system, which will be reported elsewhere. 5.1 Inference We now develop an inference system, called = I , for checking that B; P; D 0 --- j= , i.e., that a transaction, (9) , can successfully execute starting from state D 0 .
Reference: [7] <author> W. Chen. </author> <title> Declarative specification and evaluation of database updates. </title> <booktitle> In Intl. Conference on Deductive and Object-Oriented Databases (DOOD), volume 566 of Lecture Notes in Computer Science, </booktitle> <pages> pages 147-166. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1991. </year>
Reference-contexts: Transaction formulas combine simple transactions into complex ones. However, we also need a way to specify elementary changes to a database. One way to define such changes is to build them into the semantics as in <ref> [17, 21, 7, 1, 19] </ref>. The problem with this approach is that adding new kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to a revamping of the entire theory, including proofs of soundness and completeness. <p> Chen has developed a calculus and an equivalent algebra for constructing transactions <ref> [7] </ref>. Like T R, this calculus uses logical operators to construct actions from elementary updates. There are two main differences however. First, the calculus has no analogue of T R's transition base for specifying elementary updates, so it is restricted to the insertion and deletion of single tuples. <p> However, there are several disadvantages in the way this is achieved. For one, the calculus cannot express the kind of sophisticated constraints that T R can. At the same time, sequential updates often achieve the same effect as parallel updates. The way parallel actions are introduced in <ref> [7] </ref> is undesirable, since it complicates the semantics greatly, making it non-monotonic even in the absence of negation. T R achieves the same effect in a much simpler, monotonic way [5]. Finally, the syntax of the calculus is not closed. <p> Because of his interest on deontic concepts, McCarty defines two notions of satisfaction. In one notion, called "strict satisfaction," conjunction, ^, corresponds to parallel action, as it does in Chen's work <ref> [7] </ref>. In the other notion, called "satisfaction," the same symbol corresponds to constraints, as it does in T R. However, since the focus of this work is on strict satisfaction, the development of path constraints was never considered.
Reference: [8] <author> C. de Maindreville and E. Simon. </author> <title> Non-deterministic queries and updates in deductive databases. </title> <booktitle> In Intl. Conference on Very Large Data Bases (VLDB). </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1988. </year>
Reference-contexts: This lack of subroutines is reflected in the data complexity of some of the languages: they are in PSPACE, whereas recursive subroutines require alternating PSPACE, that is, EXPTIME. The works <ref> [22, 8] </ref> are related to [1] in that they borrow much of the syntax from deductive databases and yet their semantics is operational (although inspired by logical model theory). As such, these languages are in a different league than T R.
Reference: [9] <editor> M.P. Georgeff and A.L. Lansky. </editor> <title> Procedural knowledge. </title> <booktitle> In Proc. IEEE Special Issue on Knowledge Representation, </booktitle> <volume> volume 74, </volume> <pages> pages 1384-1398, </pages> <year> 1986. </year>
Reference-contexts: Advanced features of T R, such as path constraints and nondeterministic actions, also seem difficult to formalize in the situation calculus. Georgeff and Lansky develop a formalism called Procedural Logic whose intent is very similar to that of T R <ref> [9] </ref>. However, there are important differences, both practically and philosophically. These difference arise largely because Procedural Logic is actually two separate things: An implementation (called PRS), which provides the functionality; and a formalization, which accounts for only a fraction of that functionality.
Reference: [10] <author> G. Grahne and A.O. Mendelzon. </author> <title> Updates and subjunctive queries. </title> <type> Technical Report KRR-TR-91-4, </type> <institution> CSRI, University of Toronto, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: A more extensive comparison can be found in [5]. Winslett [24] did foundational work on the meaning of updates to general logical theories. Later, Grahne, Katsuno and Mendelzon <ref> [13, 10] </ref> axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results.
Reference: [11] <author> J.Y. Halpern and Y. Shoham. </author> <title> A propositional modal logic of time intervals. </title> <booktitle> In Intl. Symposium on Logic in Computer Science (LICS), </booktitle> <pages> pages 279-292, </pages> <year> 1986. </year>
Reference-contexts: As such, these languages are in a different league than T R. We should also mention works based on Allen's logic of time intervals [2], such as the event calculus of Kowalski and Sergot [16, 15] and the logic of Halpern and Shoham <ref> [11] </ref>. While the former present a methodology for programming Allen's time intervals in a classical setting, Halpern and Shoham develop a propositional modal logic for them. <p> Although by following these approaches, one can represent some aspects of transaction programming, these approaches are not completely adequate for the task and, at least <ref> [11] </ref>, pursues a different goal. For instance, none of the features listed at the beginning of this section is supported in a straightforward way (and none of these approaches has a straightforward subroutine facility).
Reference: [12] <author> D. Harel, D. Kozen, and R. Parikh. </author> <title> Process Logic: Expressiveness, decidability, completeness. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(2) </volume> <pages> 144-170, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: Our path structures are reminiscent of the "path models" in Process Logic <ref> [12] </ref>. However, there are important differences. First, Process Logic was intended for reasoning about properties of programs, not for updating databases or for programming and executing transactions.
Reference: [13] <author> H. Katsuno and A.O. Mendelzon. </author> <title> On the difference between updating a knowledge base and revising it. </title> <booktitle> In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR), </booktitle> <pages> pages 387-394, </pages> <address> Boston, Mass., </address> <month> April </month> <year> 1991. </year>
Reference-contexts: This is sufficient for relational databases, i.e., sets of atomic formulas. For more complex databases, insertion and deletion are more complex operations <ref> [13] </ref>. Note, however, that insertion and deletion are not built into the semantics of T R. In fact, T R is not committed to any particular set of elementary updates. Thus, there is no intrinsic connection between the names p, ins:p and del:p. <p> We therefore take a more general approach. Since a database is a first-order formula, which has a set of first-order models, we 5 If D is a general first-order formula, defining insertion and deletion is more involved <ref> [13] </ref>. 10 define a state to be a set of first-order semantic structures. Each state, s, thus corresponds to a particular database|the database having precisely the models comprising s. This approach to states provides a lot of flexibility when defining elementary updates. <p> For example, what does it mean to insert an atom b into a database that entails :b, especially if :b itself is not explicitly present in the database? There is no consensus on the answer to this question, and many solutions have been proposed (see <ref> [13] </ref> for a comprehensive discussion). For these reasons, we take a general approach to elementary updates. For us, an elementary update is a mapping that takes each database D 1 to some other database D 2 , where a database is any first-order formula. <p> In particular, none of the works discussed below is capable of expressing constraints on the execution of complex transactions. Likewise, none of them can seamlessly accommodate hypothetical state transitions with transitions that actually commit and permanently change the current database state; and, with the exception of <ref> [13] </ref>, all of the works are limited to updating sets of ground atomic facts. A more extensive comparison can be found in [5]. Winslett [24] did foundational work on the meaning of updates to general logical theories. <p> A more extensive comparison can be found in [5]. Winslett [24] did foundational work on the meaning of updates to general logical theories. Later, Grahne, Katsuno and Mendelzon <ref> [13, 10] </ref> axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results.
Reference: [14] <author> M. Kifer, G. Lausen, and J. Wu. </author> <title> Logical foundations of object-oriented and frame-based languages. </title> <journal> Journal of ACM, </journal> <month> May </month> <year> 1995. </year>
Reference-contexts: In logic programming, this leads to a clean, logical treatment of the assert and retract operators in Prolog, which effectively extends the theory of logic programming to include updates as well as queries. In object-oriented databases, T R can be combined with object-oriented logics, such as F-logic <ref> [14] </ref>, to provide a logical account of methods|procedures hidden inside objects that manipulate these objects' internal states. Thus, while F-logic covers the structural aspect of object-oriented databases, its combination with T R would account for the behavioral aspect as well. In AI, T R suggests a logical account of planning.
Reference: [15] <author> R.A. Kowalski. </author> <title> Database updates in event calculus. </title> <journal> Journal of Logic Programming, </journal> 12(1&2):121-146, January 1992. 
Reference-contexts: As such, these languages are in a different league than T R. We should also mention works based on Allen's logic of time intervals [2], such as the event calculus of Kowalski and Sergot <ref> [16, 15] </ref> and the logic of Halpern and Shoham [11]. While the former present a methodology for programming Allen's time intervals in a classical setting, Halpern and Shoham develop a propositional modal logic for them.
Reference: [16] <author> R.A. Kowalski and M. Sergot. </author> <title> A logic-based calculus of events. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 67-95, </pages> <year> 1986. </year>
Reference-contexts: As such, these languages are in a different league than T R. We should also mention works based on Allen's logic of time intervals [2], such as the event calculus of Kowalski and Sergot <ref> [16, 15] </ref> and the logic of Halpern and Shoham [11]. While the former present a methodology for programming Allen's time intervals in a classical setting, Halpern and Shoham develop a propositional modal logic for them.
Reference: [17] <author> S. Manchanda and D.S. Warren. </author> <title> A logic-based language for database updates. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: Transaction formulas combine simple transactions into complex ones. However, we also need a way to specify elementary changes to a database. One way to define such changes is to build them into the semantics as in <ref> [17, 21, 7, 1, 19] </ref>. The problem with this approach is that adding new kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to a revamping of the entire theory, including proofs of soundness and completeness. <p> Later, Grahne, Katsuno and Mendelzon [13, 10] axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results. Manchanda and Warren <ref> [17] </ref> introduce Dynamic Prolog|a logic system where update transactions "work right," i.e., when failed, they do not leave a residue in the database.
Reference: [18] <author> J.M. McCarthy and P.J. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> volume 4, </volume> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1969. </year> <note> Reprinted in Readings in Artificial Intelligence, </note> <year> 1981, </year> <title> Tioga Publ. </title> <publisher> Co. </publisher> <pages> 24 </pages>
Reference-contexts: In contrast, the recent work of McCarty and Van der Meyden [20] is much more detailed, but is very different from T R and is not intended for updating databases. Many AI workers represent actions using classical predicate logic (situation calculus <ref> [18] </ref>). Much of this research focuses on general reasoning about actions and, as such, is complementary to T R, which focuses on defining transactions and executing them. In these AI formalisms, actions are usually hypothetical, while T R-actions can be both hypothetical and real.
Reference: [19] <author> L.T. McCarty. </author> <title> Permissions and obligations. </title> <booktitle> In Intl. Joint Conference on Artificial Intelligence (IJCAI), </booktitle> <pages> pages 287-294, </pages> <address> San Francisco, CA, 1983. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Transaction formulas combine simple transactions into complex ones. However, we also need a way to specify elementary changes to a database. One way to define such changes is to build them into the semantics as in <ref> [17, 21, 7, 1, 19] </ref>. The problem with this approach is that adding new kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to a revamping of the entire theory, including proofs of soundness and completeness. <p> Furthermore, the calculus itself is very limited as a programming language, since it has no mechanism for defining recursion or subroutines. 21 McCarty has outlined a logic of action as part of a larger proposal for reasoning about deontic concepts <ref> [19] </ref>. His proposal contains three distinct layers, each with its own logic: first-order predicate logic, a logic of action, and a logic of permission and obligation.
Reference: [20] <author> L.T. McCarty and R. van der Meyden. </author> <title> Reasoning about indefinite actions. </title> <booktitle> In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR), </booktitle> <pages> pages 59-70, </pages> <address> Cambridge, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: For instance, although a model theory based on sequences of partial states is presented, there is no sound-and-complete proof theory, and no mechanism is presented for executing actions or updating the database. In contrast, the recent work of McCarty and Van der Meyden <ref> [20] </ref> is much more detailed, but is very different from T R and is not intended for updating databases. Many AI workers represent actions using classical predicate logic (situation calculus [18]).
Reference: [21] <author> S. Naqvi and R. Krishnamurthy. </author> <title> Database updates in logic programming. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 251-262, </pages> <address> New York, </address> <month> March </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: Transaction formulas combine simple transactions into complex ones. However, we also need a way to specify elementary changes to a database. One way to define such changes is to build them into the semantics as in <ref> [17, 21, 7, 1, 19] </ref>. The problem with this approach is that adding new kinds of elementary transitions leads to a redefinition of the very notion of a model and thus to a revamping of the entire theory, including proofs of soundness and completeness. <p> To a certain extent, it can be said that Manchanda and Warren have managed to formalize their intuition procedurally, but not as an inference system. Naqvi and Krishnamurthy <ref> [21] </ref> extended Datalog with update operators, which were later incorporated in the LDL language. Since LDL is geared towards database applications, this extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in [21] is somewhat limited. <p> Naqvi and Krishnamurthy <ref> [21] </ref> extended Datalog with update operators, which were later incorporated in the LDL language. Since LDL is geared towards database applications, this extension has bulk updates, for which an operational semantics exists. Unfortunately, the model theory presented in [21] is somewhat limited. First, it matches the operational semantics only in the propositional case, and so does not cover bulk updates. Second, it is only defined for programs in which commutativity of elementary updates can be assumed. <p> Second, it is only defined for programs in which commutativity of elementary updates can be assumed. For sequences of updates in which this does not hold, the semantics turns out to be rather tricky and certainly does not qualify as "model theoretic." Third, the definition of "legal" programs in <ref> [21] </ref> is highly restrictive, making it difficult to build complex transactions out of simpler ones. Chen has developed a calculus and an equivalent algebra for constructing transactions [7]. Like T R, this calculus uses logical operators to construct actions from elementary updates. There are two main differences however.
Reference: [22] <author> G. Phipps, M.A. Derr, and K.A. Ross. </author> <title> Glue-Nail: A deductive database system. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <address> New York, 1991. </address> <publisher> ACM. </publisher>
Reference-contexts: However, despite a plethora of action logics, researchers continue to complain that there is no clear declarative semantics for updates either in databases or in logic programming <ref> [4, 3, 22] </ref>. In fact|in stark contrast to classical logic|no action logic has ever become a core of databases or logic-programming, in theory or in practice. There appear to be a few simple reasons for this unsuitability of existing action logics. <p> This lack of subroutines is reflected in the data complexity of some of the languages: they are in PSPACE, whereas recursive subroutines require alternating PSPACE, that is, EXPTIME. The works <ref> [22, 8] </ref> are related to [1] in that they borrow much of the syntax from deductive databases and yet their semantics is operational (although inspired by logical model theory). As such, these languages are in a different league than T R.
Reference: [23] <author> R. Reiter. </author> <title> On formalizing database updates: Preliminary report. </title> <booktitle> In Proc. 3rd Intl. Conf. on Extending Database Technology, </booktitle> <month> March </month> <year> 1992. </year>
Reference-contexts: This is possible because T R performs real updates on materialized databases, just as ordinary programs do. Finally, although the above approaches can perform very general reasoning, they have difficulty with basic database features such as views and post-conditions, especially when recursion is involved <ref> [23] </ref>. Advanced features of T R, such as path constraints and nondeterministic actions, also seem difficult to formalize in the situation calculus. Georgeff and Lansky develop a formalism called Procedural Logic whose intent is very similar to that of T R [9].
Reference: [24] <author> M. Winslett. </author> <title> A model based approach to updating databases with incomplete information. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(2) </volume> <pages> 167-196, </pages> <year> 1988. </year> <month> 25 </month>
Reference-contexts: A more extensive comparison can be found in [5]. Winslett <ref> [24] </ref> did foundational work on the meaning of updates to general logical theories. Later, Grahne, Katsuno and Mendelzon [13, 10] axiomatized various theories of state transition and studied tractable cases of what we call "elementary state transitions." Our approach to state transitions is inspired by these results.
References-found: 24

