URL: http://www.cs.indiana.edu/hyplan/dyb/guardians-pldi93.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/dswise/memory.html
Root-URL: http://www.cs.indiana.edu
Email: fdyb,bruggema,debyg@cs.indiana.edu  
Title: Guardians in a Generation-Based Garbage Collector  
Author: R. Kent Dybvig, Carl Bruggeman, and David Eby 
Address: Lindley Hall 215 Bloomington, Indiana 47405  
Affiliation: Indiana University Computer Science Department  
Abstract: This paper describes a new language feature that allows dynamically allocated objects to be saved from deallo-cation by an automatic storage management system so that clean-up or other actions can be performed using the data stored within the objects. The program has full control over the timing of clean-up actions, which eliminates several potential problems and often eliminates the need for critical sections in code that interacts with clean-up actions. Our implementation is "generation-friendly" in the sense that the additional overhead within a generation-based garbage collector is proportional to the work already done there, and the overhead within the mutator is proportional to the number of clean-up actions actually performed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martin C. Atkins. </author> <title> Implementation Techniques for Object-Oriented Systems. </title> <type> PhD thesis, </type> <institution> University of York, </institution> <year> 1989. </year>
Reference-contexts: For this reason, it is inherently unsafe, since it is possible for some part of a program to keep a pointer to the data itself even after the header has been dropped. This problem is addressed by Atkins <ref> [1] </ref>, who proposes the use of a forwarding object that causes the indirection to be performed automatically. Also, the overhead caused by the extra level of indirection is unacceptable in some cases.
Reference: [2] <author> G. E. Collins. </author> <title> A method for overlapping and erasure of lists. </title> <journal> Communications of the ACM, </journal> <volume> 3(12) </volume> <pages> 655-657, </pages> <month> December </month> <year> 1960. </year>
Reference-contexts: Most current automatic storage managers employ a garbage collector [8] to deallocate unneeded objects, although some also employ reference counting mechanisms 1 <ref> [2] </ref>. Automatic storage management is useful for several reasons. First, it simplifies the programmer's job, eliminating the burden of freeing dynamically-allocated ob 1 Although the ideas presented in this paper can be extended to reference counting systems, we limit our discussion to collector-based systems.
Reference: [3] <author> Ken Dickey. </author> <title> private communication. </title>
Reference-contexts: MultiScheme, T, and Chez Scheme (among others) use such a mechanism to finalize files. Chez Scheme also supports the elimination of unnecessary oblist entries, as proposed by Friedman and Wise [6]. Dickey <ref> [3] </ref> has proposed a user-level mechanism that allows a program to register objects for finalization. The procedure register-for-finalization accepts two arguments: an object and a thunk (zero-arity procedure). The thunk is invoked automatically during garbage collection if the object has been reclaimed.
Reference: [4] <author> R. Kent Dybvig, David Eby, and Carl Bruggeman. </author> <title> Flexible and efficient storage management using a segmented heap. </title> <note> in preparation. </note>
Reference-contexts: The segments that comprise a space or generation are generally not contiguous. This arrangement has many benefits, including the ability to segregate objects based on their characteristics, such as whether they are mutable or whether they contain pointers <ref> [4] </ref>. We use this ability in the implementation of weak pairs, which are always placed in a distinct "weak-pair" space. When pairs found in the weak-pair space are traced during the normal garbage collection, they are treated like normal pairs except that the car field is not touched.
Reference: [5] <author> R. Kent Dybvig and Robert Hieb. </author> <title> A new approach to procedures with variable arity. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(3) </volume> <pages> 229-244, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The Scheme code that packages up the tconc structure is shown below. The syntactic form case-lambda, a multi-interface, multi-body version of lambda <ref> [5] </ref>, is used to construct the procedure representing the guardian. The tconc structure is created outside of the case-lambda and is visible inside via the name tc.
Reference: [6] <author> Daniel P. Friedman and David S. Wise. </author> <title> Garbage collecting a heap which includes a scatter table. </title> <journal> Information Processing Letters, </journal> <volume> 5(6), </volume> <month> December </month> <year> 1976. </year>
Reference-contexts: MultiScheme, T, and Chez Scheme (among others) use such a mechanism to finalize files. Chez Scheme also supports the elimination of unnecessary oblist entries, as proposed by Friedman and Wise <ref> [6] </ref>. Dickey [3] has proposed a user-level mechanism that allows a program to register objects for finalization. The procedure register-for-finalization accepts two arguments: an object and a thunk (zero-arity procedure). The thunk is invoked automatically during garbage collection if the object has been reclaimed.
Reference: [7] <author> Barry Hayes. </author> <title> Finalization in the collector interface. </title> <booktitle> In Proceedings of the International Workshop on Memory Management IWMM92, </booktitle> <pages> pages 277-298, </pages> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference-contexts: A discussion of various finalization mechanisms found in other languages and operating systems such as object destructors in C++, final actions for modules in Euclid, and finalization actions for limited types in Ada 9X, can be found in <ref> [7] </ref>. None of the mechanisms described there, however, provide a general solution to the problems mentioned in Section 1. 3 Guardians Guardians are created using the zero-arity primitive make-guardian: (make-guardian) ! hguardiani A guardian is represented by a procedure that encapsulates a group of objects registered for preservation.
Reference: [8] <author> Donald E. Knuth. </author> <title> The Art of Computer Programming, Volume I: Fundamental Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <note> second edition, </note> <year> 1973. </year>
Reference-contexts: Within these systems, some form of storage manager takes responsibility for handling both requests to allocate new objects and automatic deallocation of objects that are no longer needed. Most current automatic storage managers employ a garbage collector <ref> [8] </ref> to deallocate unneeded objects, although some also employ reference counting mechanisms 1 [2]. Automatic storage management is useful for several reasons.
Reference: [9] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM, </journal> <volume> 26(6) </volume> <pages> 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: the finalization routine? If so, can it be let loose into the system again? Can objects being finalized be re registered for finalization? There is a fifth issue to consider for generation-based garbage collectors, which segregate objects based on their ages and scan older objects less frequently than newer objects <ref> [9] </ref>. A "generation-friendly" finalization mechanism must insure that the overhead for finalization is (at worst) proportional to the amount of work already done by the collector.
Reference: [10] <author> James S. Miller. MultiScheme: </author> <title> A Parallel Processing System Based on MIT Scheme. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: As a result, an object that is not accessible except by way of one or more weak sets is ultimately discarded and removed from the weak sets to which it belonged. MultiScheme <ref> [10] </ref> provides a similar, more primitive feature, weak pairs. Weak pairs are like normal pairs except that the "car" (data) field of the pair is a weak pointer. The "cdr" (link) field is a normal pointer.
Reference: [11] <author> Jonathan A. Rees, Norman I. Adams, and James R. Meehan. </author> <title> The T Manual, </title> <booktitle> fourth edition, </booktitle> <month> September </month> <year> 1988. </year>
Reference-contexts: Section 5 summarizes the paper and presents a somewhat more general interface to the same basic mechanism. 2 Background Guardians are related to the weak sets 3 provided by the T language <ref> [11] </ref>. A weak set is a data structure containing a set of objects. Operations are provided to add new objects, remove objects, and retrieve a list of the objects in the set. Weak sets are so-called since they maintain "weak" pointers to the objects in their sets.
References-found: 11

