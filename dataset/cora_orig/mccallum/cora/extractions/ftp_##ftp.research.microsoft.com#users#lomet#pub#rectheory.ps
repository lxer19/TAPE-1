URL: ftp://ftp.research.microsoft.com/users/lomet/pub/rectheory.ps
Refering-URL: http://www.research.microsoft.com/db/phoenix/
Root-URL: http://www.research.microsoft.com
Email: lomet@microsoft.com  tuttle@crl.dec.com  
Title: Redo Recovery after System Crashes  
Author: David Lomet Mark R. Tuttle 
Address: One Microsoft Way Redmond, WA 98052  One Kendall Square Cambridge, MA 02139  
Affiliation: Microsoft Corporation  Digital Equipment Corporation  
Abstract: This paper defines a framework for explaining redo recovery after a system crash. In this framework, an installation graph explains the order in which operations must be installed into the stable database if it is to remain recoverable. This installation graph is a significantly weaker ordering on operations than the conflict graph from concurrency control. We use the installation graph to devise (i) a cache management algorithm for writing data from the volatile cache to the stable database, (ii) the specification of a redo test used to choose the operations on the log to replay during recovery, and (iii) an idempotent recovery algorithm based on this test; and we prove that these cache management and recovery algorithms are correct. Most pragmatic recovery methods depend on constraining the kinds of operations that can appear in the log, but our framework allows arbitrary logged operations. We use our framework to explain pragmatic methods that constrain the logged operations to reading and writing single pages, and then using this new understanding to relax these constraints. The result is a new class of logged operations having a recovery method with practical advantages over current methods. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: These methods provide many specific techniques for ensuring transaction atomicity and durability, including write-ahead logging, the do/undo/redo paradigm, forcing log records at commit, forcing pages at commit, and so on [2, 3, 4, 5, 7, 14], and much of this work has found its way into textbooks <ref> [1, 6] </ref>. In addi tion, general methods exist for undoing nested transactions [16] and multi-level transactions [10, 17, 18]. We focus on redo recovery. This technique starts at some point in the log and reads to the end of the log. <p> Ordering updates in this way has been referred to as "careful replacement" in the recovery literature <ref> [1, 6] </ref>. Another useful ordering on updates respects both the installation graph and conflict graph orderings: we define hO; U i &lt; hP; V i iff hO; U i hP; V i or O &lt; P .
Reference: [2] <author> R. Crus. </author> <title> Data recovery in IBM Database 2. </title> <journal> IBM Systems Journal, </journal> <volume> 23(2) </volume> <pages> 178-188, </pages> <year> 1984. </year>
Reference-contexts: There are many methods for recovery that appear in the literature. These methods provide many specific techniques for ensuring transaction atomicity and durability, including write-ahead logging, the do/undo/redo paradigm, forcing log records at commit, forcing pages at commit, and so on <ref> [2, 3, 4, 5, 7, 14] </ref>, and much of this work has found its way into textbooks [1, 6]. In addi tion, general methods exist for undoing nested transactions [16] and multi-level transactions [10, 17, 18]. We focus on redo recovery. <p> Only the redo test poses a problem. One example of page-oriented operations is afterimage writes which have empty read sets and single-page write sets. This single-page write might write to the entire page [3] or to selected records or bytes on the page <ref> [2, 4] </ref>. These methods differ in the tradeoff they make between log record size and the need to access a page before replaying the operation during recovery. These operations are always applicable, and hence the redo test can always return true.
Reference: [3] <author> K. Elhardt and R. Bayer. </author> <title> A database cache for high performance and fast restart in database systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(4) </volume> <pages> 503-525, </pages> <month> December </month> <year> 1984. </year>
Reference-contexts: There are many methods for recovery that appear in the literature. These methods provide many specific techniques for ensuring transaction atomicity and durability, including write-ahead logging, the do/undo/redo paradigm, forcing log records at commit, forcing pages at commit, and so on <ref> [2, 3, 4, 5, 7, 14] </ref>, and much of this work has found its way into textbooks [1, 6]. In addi tion, general methods exist for undoing nested transactions [16] and multi-level transactions [10, 17, 18]. We focus on redo recovery. <p> Only the redo test poses a problem. One example of page-oriented operations is afterimage writes which have empty read sets and single-page write sets. This single-page write might write to the entire page <ref> [3] </ref> or to selected records or bytes on the page [2, 4]. These methods differ in the tradeoff they make between log record size and the need to access a page before replaying the operation during recovery.
Reference: [4] <author> J. Gray. </author> <title> Notes on database operating systems. </title> <editor> In R. Bayer, R. Graham, and G. Seegmuller, editors, </editor> <booktitle> Operating Systems|An Advanced Course, volume 60 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1978. </year> <note> Also appears as IBM Research Report RJ 2188, </note> <year> 1978. </year>
Reference-contexts: There are many methods for recovery that appear in the literature. These methods provide many specific techniques for ensuring transaction atomicity and durability, including write-ahead logging, the do/undo/redo paradigm, forcing log records at commit, forcing pages at commit, and so on <ref> [2, 3, 4, 5, 7, 14] </ref>, and much of this work has found its way into textbooks [1, 6]. In addi tion, general methods exist for undoing nested transactions [16] and multi-level transactions [10, 17, 18]. We focus on redo recovery. <p> Only the redo test poses a problem. One example of page-oriented operations is afterimage writes which have empty read sets and single-page write sets. This single-page write might write to the entire page [3] or to selected records or bytes on the page <ref> [2, 4] </ref>. These methods differ in the tradeoff they make between log record size and the need to access a page before replaying the operation during recovery. These operations are always applicable, and hence the redo test can always return true.
Reference: [5] <author> J. Gray, P. McJones, M. Blasgen, B. Lindsay, R. Lorie, T. Price, and F. Putzolu. </author> <title> The recovery manager of the System R database manager. </title> <journal> ACM Computing Surveys, </journal> <volume> 13(2) </volume> <pages> 223-242, </pages> <month> June </month> <year> 1981. </year>
Reference-contexts: There are many methods for recovery that appear in the literature. These methods provide many specific techniques for ensuring transaction atomicity and durability, including write-ahead logging, the do/undo/redo paradigm, forcing log records at commit, forcing pages at commit, and so on <ref> [2, 3, 4, 5, 7, 14] </ref>, and much of this work has found its way into textbooks [1, 6]. In addi tion, general methods exist for undoing nested transactions [16] and multi-level transactions [10, 17, 18]. We focus on redo recovery.
Reference: [6] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: These methods provide many specific techniques for ensuring transaction atomicity and durability, including write-ahead logging, the do/undo/redo paradigm, forcing log records at commit, forcing pages at commit, and so on [2, 3, 4, 5, 7, 14], and much of this work has found its way into textbooks <ref> [1, 6] </ref>. In addi tion, general methods exist for undoing nested transactions [16] and multi-level transactions [10, 17, 18]. We focus on redo recovery. This technique starts at some point in the log and reads to the end of the log. <p> To see that there are no write-write edges, notice that if P is in O's must redo set then P is in O's can redo set, since P 's read set is null and does not need reconstruction. Now consider the case of physiological logging <ref> [6] </ref>, where each logged operation x f (x) reads the value of a single page and writes some function of this value back to the same page. <p> Ordering updates in this way has been referred to as "careful replacement" in the recovery literature <ref> [1, 6] </ref>. Another useful ordering on updates respects both the installation graph and conflict graph orderings: we define hO; U i &lt; hP; V i iff hO; U i hP; V i or O &lt; P . <p> These methods differ in the tradeoff they make between log record size and the need to access a page before replaying the operation during recovery. These operations are always applicable, and hence the redo test can always return true. Another example is physiological operations as described in <ref> [6] </ref> and used in ARIES [14]. These are state-transition operations that require reading the before-image of a page and then computing its after-image. These operations are not always applicable, so the redo test must test for applicability. <p> This is usually implemented by storing a state identifier in the written page and associating the state identifier in some way with the operation's log record. The address of the log record (called a log sequence number or LSN) is often used as the state identifier <ref> [6] </ref>. The redo test simply compares the log record's state identifier with the state identifier stored in the page to determine applicability. 6.2 A New Method: Tree Operations Understanding installation graphs and their resulting write graphs allows us to generalize page-oriented methods with what we call tree operations.
Reference: [7] <author> T. Haerder and A. Reuter. </author> <title> Principles of transaction oriented database recovery|a taxonomy. </title> <journal> ACM Computing Surveys, </journal> <volume> 15(4) </volume> <pages> 287-318, </pages> <month> Decem-ber </month> <year> 1983. </year>
Reference-contexts: There are many methods for recovery that appear in the literature. These methods provide many specific techniques for ensuring transaction atomicity and durability, including write-ahead logging, the do/undo/redo paradigm, forcing log records at commit, forcing pages at commit, and so on <ref> [2, 3, 4, 5, 7, 14] </ref>, and much of this work has found its way into textbooks [1, 6]. In addi tion, general methods exist for undoing nested transactions [16] and multi-level transactions [10, 17, 18]. We focus on redo recovery.
Reference: [8] <author> D. Kuo. </author> <title> Model and verification of a data manager based on ARIES. </title> <booktitle> In Proceedings of the 4th International Conference on Database Theory, </booktitle> <pages> pages 231-245, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: To the best of our knowledge, this is the first treatment of crash recovery that is both formal and general. Formal treatments of recovery from aborts via transaction rollback are quite general [13], but the only formal treatment of recovery from crashes we know about <ref> [8] </ref> is specific to ARIES [14].
Reference: [9] <author> D. Lomet. </author> <title> Recovery for shared disk systems using multiple redo logs. </title> <type> Technical Report 90/4, </type> <institution> DEC Cambridge Research Lab, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: The log is typically a sequence of log records (but see <ref> [9, 15] </ref>). The head of the log is kept on disk in the stable log, the tail of the log is kept in memory, and the log manager is responsible for moving log records from memory to disk. We assume the log manager is following the write-ahead log protocol WAL.
Reference: [10] <author> D. Lomet. MLR: </author> <title> A recovery method for multilevel systems. </title> <booktitle> In Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 185-194. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: In addi tion, general methods exist for undoing nested transactions [16] and multi-level transactions <ref> [10, 17, 18] </ref>. We focus on redo recovery. This technique starts at some point in the log and reads to the end of the log. As it examines each log record, it either reinvokes the logged operation on the current state or passes it by.
Reference: [11] <author> D. Lomet and B. Salzberg. </author> <title> Access method con-currency with recovery. </title> <booktitle> In Proceedings of the 1992 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 351-360. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Splitting a node requires reading the page containing the old node and splitting its contents by writing back to the old node and a new node, as well as reading and updating the parent node. "B-link-tree" concur-rency and recovery techniques <ref> [11] </ref> link the old and new nodes together. This link preserves the accessibility of the moved data in the new node until the parent is updated. As a consequence, we can log the split of the node and the update of the parent as two separate atomic operations.
Reference: [12] <author> D. Lomet and M. Tuttle. </author> <title> Redo recovery after system crashes. </title> <type> Technical Report 95/5, </type> <institution> DEC Cam-bridge Research Lab, </institution> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: In ways like these, the installation graph gives us a graph-theoretic technique for understanding many aspects of redo recovery methods that appear in the literature. 2 Database Model We sketch our model of a database here, and give the complete statement in the technical report <ref> [12] </ref>. A state is a function mapping variables in a set V to values in a set V, and one state is chosen as the initial state. An operation is a function mapping states to states. <p> Here, we must assume that the update buffer is actually the subgraph of the installation graph induced by the updates in the update buffer. We discuss how to avoid explicitly maintaining this subgraph in the technical report <ref> [12] </ref>. A cache manager effectively partitions the volatile state into a "dirty" part and a "clean" part (which we do not discuss here). <p> This idea is used twice in computing the write graph, once to collapse intersecting updates, and again to make the write graph acyclic. In the technical report <ref> [12] </ref>, we discuss incremental methods of maintaining the write graph W so that it evolves as new updates are added to the cache. The cache manager uses the algorithm PurgeCache in Figure 8 to write to the stable state. <p> These read-write edges in the write-graph are simple to compute, since no cycles ever occur for the second "collapse" to process, so a simple incremental computation of the write graph is possible <ref> [12] </ref>. Tree operations can improve logging performance for practical problems like splitting the node of a B-tree.
Reference: [13] <author> N. Lynch, M. Merritt, W. Weihl, and A. Fekete. </author> <title> Atomic Transactions. </title> <publisher> Morgan Kaufman, </publisher> <year> 1993. </year>
Reference-contexts: To the best of our knowledge, this is the first treatment of crash recovery that is both formal and general. Formal treatments of recovery from aborts via transaction rollback are quite general <ref> [13] </ref>, but the only formal treatment of recovery from crashes we know about [8] is specific to ARIES [14].
Reference: [14] <author> C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh, and P. Schwarz. </author> <title> ARIES: A transaction recovery method supporting fine-granularity locking and partial rollbacks using write-ahead logging. </title> <journal> ACM Page 13 Transactions on Database Systems, </journal> <volume> 17(1) </volume> <pages> 94-162, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Formal treatments of recovery from aborts via transaction rollback are quite general [13], but the only formal treatment of recovery from crashes we know about [8] is specific to ARIES <ref> [14] </ref>. In the remainder of this introduction, we explain in more detail how the choice of logged operations can affect recovery, and how our framework exposes this impact. 1.1 The basics of redo recovery When a computer crashes, the contents of the memory are presumed to be lost or corrupted. <p> There are many methods for recovery that appear in the literature. These methods provide many specific techniques for ensuring transaction atomicity and durability, including write-ahead logging, the do/undo/redo paradigm, forcing log records at commit, forcing pages at commit, and so on <ref> [2, 3, 4, 5, 7, 14] </ref>, and much of this work has found its way into textbooks [1, 6]. In addi tion, general methods exist for undoing nested transactions [16] and multi-level transactions [10, 17, 18]. We focus on redo recovery. <p> Redo recovery is efficient in the sense that it does not require the cache manager to write all changes to the stable state when a transaction commits. Redo recovery also has applications in areas like word processing and file editing that are independent of the transactional setting. Furthermore, ARIES <ref> [14] </ref> suggests understanding recovery after a crash as performing redo recovery followed by undo recovery. With this, redo recovery must solve the hardest parts of recovery: making sense of the state at the time of the crash, and determining what operations in the log to reexecute to rebuild the state. <p> These operations are always applicable, and hence the redo test can always return true. Another example is physiological operations as described in [6] and used in ARIES <ref> [14] </ref>. These are state-transition operations that require reading the before-image of a page and then computing its after-image. These operations are not always applicable, so the redo test must test for applicability.
Reference: [15] <author> C. Mohan I. Narang and J. Palmer. </author> <title> A case study of problems in migrating to distributed computing: Page recovery using multiple logs in the shared disks environment. </title> <institution> Research Report RJ7343, IBM Almaden Research Center, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: The log is typically a sequence of log records (but see <ref> [9, 15] </ref>). The head of the log is kept on disk in the stable log, the tail of the log is kept in memory, and the log manager is responsible for moving log records from memory to disk. We assume the log manager is following the write-ahead log protocol WAL.
Reference: [16] <author> K. Rothermel and C. Mohan. ARIES/NT: </author> <title> A recovery method based on write-ahead logging for nested transactions. </title> <booktitle> In Proceedings of the 15th International Conference on Very Large Data Bases, </booktitle> <pages> pages 337-346, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: In addi tion, general methods exist for undoing nested transactions <ref> [16] </ref> and multi-level transactions [10, 17, 18]. We focus on redo recovery. This technique starts at some point in the log and reads to the end of the log. As it examines each log record, it either reinvokes the logged operation on the current state or passes it by.
Reference: [17] <author> G. Weikum. </author> <title> A theoretical foundation of multilevel concurrency control. </title> <booktitle> In Proceedings of the 5th Annual ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 31-42, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: In addi tion, general methods exist for undoing nested transactions [16] and multi-level transactions <ref> [10, 17, 18] </ref>. We focus on redo recovery. This technique starts at some point in the log and reads to the end of the log. As it examines each log record, it either reinvokes the logged operation on the current state or passes it by.
Reference: [18] <author> G. Weikum, C. Hasse, P. Broessler, and P. Muth. </author> <title> Multi-level recovery. </title> <booktitle> In Proceedings of the 9th Annual ACM Symposium on Principles of Database Systems, </booktitle> <month> April </month> <year> 1990. </year> <pages> Page 14 </pages>
Reference-contexts: In addi tion, general methods exist for undoing nested transactions [16] and multi-level transactions <ref> [10, 17, 18] </ref>. We focus on redo recovery. This technique starts at some point in the log and reads to the end of the log. As it examines each log record, it either reinvokes the logged operation on the current state or passes it by.
References-found: 18

