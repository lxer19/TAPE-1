URL: ftp://cse.ogi.edu/pub/pacsoft/papers/icfp98.ps
Refering-URL: http://www.cse.ogi.edu/~dick/dick.html
Root-URL: http://www.cse.ogi.edu
Email: dick@cse.ogi.edu  
Title: Taming Effects with Monadic Typing 1  
Author: Richard B. Kieburtz 
Address: Portland, Oregon, USA  
Affiliation: Oregon Graduate Institute  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [AFL95] <author> A. Aiken, M. Fahndrich, and R. Levien. </author> <title> Better static memory management: Improving region-based analysis of higher-order languages. </title> <booktitle> In SIGPLAN'95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 174-185, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The analysis requires propagating monad annotations to the call sites of functions. Monad analysis with explicit declaration blocks is no more costly than is region analysis, for which amortized algorithm techniques have been found to be effective in overcoming the asymptotic complexity barrier in many cases <ref> [AFL95] </ref>. Finally, we note that the assurance of effects containment provided by monadic typing would allow a natural relaxation of the value restriction for polymorphic let definitions that is imposed in SML.
Reference: [BTV96] <author> Lars Birkedal, Mads Tofte, and Magnus Ve-jlstrup. </author> <title> From region inference to von Neu-mann machines via region representation inference. </title> <booktitle> In Conference Record of the Twenty Third Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 171-183. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: The monadic type/effects system solves the problem of incomplete specification of effects and identifies expressions that are purely functional. It requires less ambitious analysis than does region analysis <ref> [BTV96] </ref>. Region analysis must infer a scope in which each reference defined in a program remains accessible, whereas the monadic type inference proposed here merely enforces a policy that requires effects to be restricted to a lexically defined scope.
Reference: [DGT96] <author> O. Danvy, R. Gluck, and P. Thiemann, </author> <title> editors. Partial Evaluation. </title> <address> Dagstuhl Castle, Germany, </address> <month> February </month> <year> 1996, </year> <booktitle> volume 1110 of Lecture Notes in Computer Science. </booktitle> <address> Berlin: </address> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Conventional, structural typing of expressions does not account for possible side effects. Some program transformation techniques such as type-directed partial evaluation <ref> [DGT96] </ref>, depend upon the fact that polymorphically typed expressions in the first-order lambda calculus have unique normal forms. 1 The research reported in this paper was supported by the USAF Materiel Command.
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: Notice that the typing rule for a let expression further restricts the typing interpretation of the Restore combinator with auxiliary conditions. 2 The next theorem addresses the soundness of the monadic typing of effects. It augments, but does not subsume the soundness theorem <ref> [DM82] </ref> for the underlying Hindley-Milner typing left by erasing the monad annotations from the monadic effects typing given here. Theorem 2|Soundness of Typing: Suppose an expression e at block level i has type M (t ), where for all indices j 2 0::i, M j v St.
Reference: [JD94] <author> Mark Jones and Luc Duponcheel. </author> <title> Composing monads. </title> <type> Technical Report YALEU/DCS/RR-1004, </type> <institution> Yale University, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: Note that there is no general procedure for constructng a composite monad from two given monads. Composite monads are defineable in the cases we have considered here, as in many other instances of computational monads <ref> [JD94] </ref>. 3.2 Level-stratified monad annotations Since effects actions are associated with lexical block indices memoized at the definition of a reference expression or exception, a monad annotation can be associated with each block. The monad is determined by possible effects associated with the references and exception declared in the block.
Reference: [LeR98] <author> Xavier LeRoy. </author> <title> Static debugging of uncaught exceptions in ML. </title> <type> Technical report, </type> <institution> IFIP Working Group 2.8 meeting, </institution> <month> March </month> <year> 1998. </year>
Reference-contexts: Xavier LeRoy has investigated this problem more thoroughly <ref> [LeR98] </ref>. 3.4.5 Declaration blocks Declarations bind identifiers to values. Declaration contexts are syntactically designated by let expressions.
Reference: [LP95] <author> John Launchbury and Simon Peyton Jones. </author> <title> State in Haskell. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 293-351, </pages> <year> 1995. </year>
Reference-contexts: A different approach to effects characterization is taken in Haskell, where effects-inducing operations are explicitly associated with monads. Operations on a state variable in Haskell can be restricted to a declared scope for an instance of the state monad <ref> [LP95] </ref>. Furthermore, confusion of distinct state variables can be prevented by an extended type system. Thus the uses of mutable state in Haskell can be effectively encapsulated.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: The problem was identified by Tofte [Tof87], who coined the slogan "the problem is generalization" (of effects types). He proposed a special class of reference types, whose generalization would not be defined. This solution was adopted in the original definition of SML <ref> [MTH90] </ref>, but has been abandoned in the revised language defi-nition [MTM97]. In its place, SML'97 has adopted a simpler solution which more directly addresses Tofte's slogan. This solution, called the value restriction has been advocated by Wright [Wri95] and others.
Reference: [MTM97] <author> R. Milner, M. Tofte, and D. MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: Since values of different types might be bound in separate occurrences of a reference-typed variable or of an exception constructor, a type system that permits polymorphism with effects may be unsound unless further restrictions are imposed. One such restriction limits polymorphism to expressions with manifest values <ref> [Tof87, TJ92, Wri95, MTM97, Wad98] </ref>. The value restriction assures that evaluating a polymorphic expression cannot entail effects. Monadic typing allows effects-free expressions to be distinguished through the type system and thus permits relaxation of the value restriction while maintaining soundness of typing. <p> He proposed a special class of reference types, whose generalization would not be defined. This solution was adopted in the original definition of SML [MTH90], but has been abandoned in the revised language defi-nition <ref> [MTM97] </ref>. In its place, SML'97 has adopted a simpler solution which more directly addresses Tofte's slogan. This solution, called the value restriction has been advocated by Wright [Wri95] and others. Polymorphic generalization in SML'97 is restricted to expressions that manifest values directly, requiring no computation.
Reference: [Tal93] <author> J.-P. Talpin. </author> <title> Theoretical and Practical Aspects of Type and Effect Inference. </title> <type> PhD thesis, </type> <institution> University of Paris VI, </institution> <year> 1993. </year>
Reference-contexts: These techniques cannot be applied to SML programs, for instance, because normal forms of polymorphic SML expressions cannot be inferred from their types when expressions may have side effects. To resolve questions about the scope of possible effects, Talpin and Jouvelot proposed a type-and-effects analysis for functional programming languages <ref> [TJ92, Tal93] </ref>. The result of this analysis, calculated in conjunction with type reconstruction, expresses the possible effects of evaluating an expression. Region analysis identifies dynamically allocated variables with syntactically scoped "regions" of a program, allowing potentially mutable variables to be allocated and deallocated in a stack discipline [TT97].
Reference: [TJ92] <author> J.-P. Talpin and P. Jouvelot. </author> <title> Polymorphic types, region and effect inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2 </volume> <pages> 245-271, </pages> <year> 1992. </year>
Reference-contexts: These techniques cannot be applied to SML programs, for instance, because normal forms of polymorphic SML expressions cannot be inferred from their types when expressions may have side effects. To resolve questions about the scope of possible effects, Talpin and Jouvelot proposed a type-and-effects analysis for functional programming languages <ref> [TJ92, Tal93] </ref>. The result of this analysis, calculated in conjunction with type reconstruction, expresses the possible effects of evaluating an expression. Region analysis identifies dynamically allocated variables with syntactically scoped "regions" of a program, allowing potentially mutable variables to be allocated and deallocated in a stack discipline [TT97]. <p> Since values of different types might be bound in separate occurrences of a reference-typed variable or of an exception constructor, a type system that permits polymorphism with effects may be unsound unless further restrictions are imposed. One such restriction limits polymorphism to expressions with manifest values <ref> [Tof87, TJ92, Wri95, MTM97, Wad98] </ref>. The value restriction assures that evaluating a polymorphic expression cannot entail effects. Monadic typing allows effects-free expressions to be distinguished through the type system and thus permits relaxation of the value restriction while maintaining soundness of typing.
Reference: [Tof87] <author> Mads Tofte. </author> <title> Operational semantics and polymorphic type inference. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference-contexts: Since values of different types might be bound in separate occurrences of a reference-typed variable or of an exception constructor, a type system that permits polymorphism with effects may be unsound unless further restrictions are imposed. One such restriction limits polymorphism to expressions with manifest values <ref> [Tof87, TJ92, Wri95, MTM97, Wad98] </ref>. The value restriction assures that evaluating a polymorphic expression cannot entail effects. Monadic typing allows effects-free expressions to be distinguished through the type system and thus permits relaxation of the value restriction while maintaining soundness of typing. <p> When distinct occurrences of a named entity, such as a mutable variable or an exception constructor, can bind to independent values, polymorphism allows values of different types to be bound to the same name, which can lead to nonsensical programs. The problem was identified by Tofte <ref> [Tof87] </ref>, who coined the slogan "the problem is generalization" (of effects types). He proposed a special class of reference types, whose generalization would not be defined. This solution was adopted in the original definition of SML [MTH90], but has been abandoned in the revised language defi-nition [MTM97].
Reference: [Tol98] <author> Andrew Tolmach. </author> <title> Optimizing ML using a hierarchy of monadic types. </title> <booktitle> In Proceedings of Types in Compilation '98 Workshop, </booktitle> <month> March </month> <year> 1998. </year>
Reference-contexts: It relies upon the block structure of declarations to define the scopes of variables, and thus of regions, whereas region analysis makes no such assumption. An interesting application of monadic typing for effects is described by Andrew Tolmach <ref> [Tol98] </ref>. The potential effects of evaluating each expression in an ML program are inferred in a typed intermediate language, using monad (but not region) inference.
Reference: [TT97] <author> Mads Tofte and Jean-Pierre Talpin. </author> <title> Region based memory management. </title> <journal> Information and Computation, </journal> <volume> 132(2) </volume> <pages> 109-176, </pages> <year> 1997. </year>
Reference-contexts: The result of this analysis, calculated in conjunction with type reconstruction, expresses the possible effects of evaluating an expression. Region analysis identifies dynamically allocated variables with syntactically scoped "regions" of a program, allowing potentially mutable variables to be allocated and deallocated in a stack discipline <ref> [TT97] </ref>. A different approach to effects characterization is taken in Haskell, where effects-inducing operations are explicitly associated with monads. Operations on a state variable in Haskell can be restricted to a declared scope for an instance of the state monad [LP95].
Reference: [Wad92] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: State 2 Some authors use bind as an alternative to the natural extension combinator <ref> [Wad92] </ref>. The difference is inversion of the order of the first two arguments. threading can be made explicit by -expanding these definitions.
Reference: [Wad98] <author> Philip Wadler. </author> <title> The marriage of effects and monads. </title> <booktitle> In International Conference on Functional Programming. </booktitle> <publisher> ACM Press, </publisher> <year> 1998. </year>
Reference-contexts: Furthermore, confusion of distinct state variables can be prevented by an extended type system. Thus the uses of mutable state in Haskell can be effectively encapsulated. In a contemporary paper in this conference <ref> [Wad98] </ref>, Philip Wadler shows that the effects typing of Talpin and Jouvelot can be recast in a framework of monads. He transposes their region analysis into a reconstruction algorithm for monadic types. This paper takes a different approach, constructing monadic types for effects when regions are associated with lexical scopes. <p> Since values of different types might be bound in separate occurrences of a reference-typed variable or of an exception constructor, a type system that permits polymorphism with effects may be unsound unless further restrictions are imposed. One such restriction limits polymorphism to expressions with manifest values <ref> [Tof87, TJ92, Wri95, MTM97, Wad98] </ref>. The value restriction assures that evaluating a polymorphic expression cannot entail effects. Monadic typing allows effects-free expressions to be distinguished through the type system and thus permits relaxation of the value restriction while maintaining soundness of typing.
Reference: [Wri95] <author> Andrew K. Wright. </author> <title> Simple imperative poly-morphism. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 343-355, </pages> <year> 1995. </year>
Reference-contexts: Since values of different types might be bound in separate occurrences of a reference-typed variable or of an exception constructor, a type system that permits polymorphism with effects may be unsound unless further restrictions are imposed. One such restriction limits polymorphism to expressions with manifest values <ref> [Tof87, TJ92, Wri95, MTM97, Wad98] </ref>. The value restriction assures that evaluating a polymorphic expression cannot entail effects. Monadic typing allows effects-free expressions to be distinguished through the type system and thus permits relaxation of the value restriction while maintaining soundness of typing. <p> This solution was adopted in the original definition of SML [MTH90], but has been abandoned in the revised language defi-nition [MTM97]. In its place, SML'97 has adopted a simpler solution which more directly addresses Tofte's slogan. This solution, called the value restriction has been advocated by Wright <ref> [Wri95] </ref> and others. Polymorphic generalization in SML'97 is restricted to expressions that manifest values directly, requiring no computation.
References-found: 17

