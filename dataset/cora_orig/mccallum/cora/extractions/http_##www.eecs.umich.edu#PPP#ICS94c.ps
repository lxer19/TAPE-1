URL: http://www.eecs.umich.edu/PPP/ICS94c.ps
Refering-URL: http://www.eecs.umich.edu/PPP/publist.html
Root-URL: http://www.cs.umich.edu
Email: waleed@eecs.umich.edu davidson@eecs.umich.edu  
Title: Optimal Local Register Allocation for a Multiple-Issue Machine  
Author: Waleed M. Meleis Edward S. Davidson 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Advanced Computer Architecture Lab Department of Electrical Engineering and Computer Science University of Michigan  
Abstract: This paper presents an algorithm that allocates registers optimally for straight-line code running on a generic multi-issue computer. On such a machine, an optimal register allocation is one that minimizes the number of issue slots that the code requires. Optimal spill selection and load/store placement are used to minimize the number of additional issue slots needed, given a schedule for the non-memory reference instructions and a fixed number of available physical registers. The generic multi-issue machine model closely models the operation of vector and VLIW processors, and could be extended to model super-scalar processors. The algorithm uses dynamic programming to search the state space of feasible register allocations; implicit and explicit state pruning are used to make the problem tractable without sacrificing optimality. The optimal allocation produced by the algorithm for a substantial example is presented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: Heuristic solutions to local and global register allocation problems for single-issue machines have been discussed by Chow et al., [3], and Aho et al. <ref> [1] </ref>. Chaitin et al. described the application of graph coloring to global register allocation in [5] and [6]. Algorithms based on Chaitin's work use heuristics to determine which nodes to delete and then generate spill code each time those values are referenced.
Reference: [2] <author> E. L. Boyd and E. S. Davidson. </author> <title> Hierarchical performance modeling with MACS: A case study of the Convex C-240. </title> <booktitle> In Proc. 20th Intl Symposium on Computer Architecture, </booktitle> <pages> pages 203-212, </pages> <year> 1993. </year>
Reference-contexts: The generic multi-issue machine/code model described above is based on the Convex C240 machine model described in <ref> [2] </ref>. This C240 model assumes that a set of 1 to 3 vector instructions, referred to as a chime, can be issued to different vector functional units simultaneously. Chimes are analogous to slots in the generic machine model.
Reference: [3] <author> F. C. Chow and J. L. Hennessy. </author> <title> The priority-based approach to register allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12 </volume> <pages> 503-536, </pages> <year> 1990. </year>
Reference-contexts: Heuristic solutions to local and global register allocation problems for single-issue machines have been discussed by Chow et al., <ref> [3] </ref>, and Aho et al. [1]. Chaitin et al. described the application of graph coloring to global register allocation in [5] and [6]. Algorithms based on Chaitin's work use heuristics to determine which nodes to delete and then generate spill code each time those values are referenced.
Reference: [4] <institution> CONVEX Computer Corporation. CONVEX Theory of Operation - C200, volume 081-005030-000. </institution> <year> 1990. </year>
Reference-contexts: cannot result in a less expensive final allocation than the best allocation for P 1 . 3 Optimal Allocation for the Convex C2 Vector Processor 3.1 Machine Model The multi-issue allocation algorithm has been used to improve the performance of a Fortran code running on a Convex C2 vector supercomputer <ref> [4] </ref>. The generic multi-issue machine/code model described above is based on the Convex C240 machine model described in [2]. This C240 model assumes that a set of 1 to 3 vector instructions, referred to as a chime, can be issued to different vector functional units simultaneously.
Reference: [5] <author> G. J. Chaitin et al. </author> <title> Register allocation via coloring. </title> <journal> Computer Languages, </journal> <volume> 6 </volume> <pages> 47-57, </pages> <year> 1981. </year>
Reference-contexts: Heuristic solutions to local and global register allocation problems for single-issue machines have been discussed by Chow et al., [3], and Aho et al. [1]. Chaitin et al. described the application of graph coloring to global register allocation in <ref> [5] </ref> and [6]. Algorithms based on Chaitin's work use heuristics to determine which nodes to delete and then generate spill code each time those values are referenced. Deleting the minimum number of nodes from a graph to make it k-colorable is NP-complete.
Reference: [6] <author> G. J. Chaitin et al. </author> <title> Register allocation and spilling via graph coloring. </title> <booktitle> In Proc. ACM SIGPLAN '86 Symp. Compiler Construction, </booktitle> <pages> pages 98-105, </pages> <address> New York, </address> <year> 1982. </year>
Reference-contexts: Heuristic solutions to local and global register allocation problems for single-issue machines have been discussed by Chow et al., [3], and Aho et al. [1]. Chaitin et al. described the application of graph coloring to global register allocation in [5] and <ref> [6] </ref>. Algorithms based on Chaitin's work use heuristics to determine which nodes to delete and then generate spill code each time those values are referenced. Deleting the minimum number of nodes from a graph to make it k-colorable is NP-complete.
Reference: [7] <author> L. P. Horwitz, R. M. Karp, R. E. Miller, and S. Wino-grad. </author> <title> Index register allocation. </title> <journal> Journal of the Association of Computing Machinery, </journal> <volume> 13 </volume> <pages> 43-61, </pages> <year> 1966. </year>
Reference-contexts: Deleting the minimum number of nodes from a graph to make it k-colorable is NP-complete. While register coloring can be adapted to perform local allocation, it has traditionally been used in global allocation across multiple basic blocks. Horwitz et al. <ref> [7] </ref> first addressed the problem of finding an allocation of index variables to registers that minimizes the number of load and store spills that are required for a basic block. This approach is extended in Hsu et al. [8] to handle a wider class of schedules. <p> The first memory operation inserted into a slot is free, and each subsequent operation added to that slot causes an extra slot and has a cost of one. 2 Optimal Register Allocation using Dynamic Programming Our algorithm is an extension of the algorithms described by Horwitz <ref> [7] </ref> and Hsu [8] for the minimization of loads and stores in straight-line single-issue code. <p> Both problems have efficient solutions when each data value is used at most once, but in the general multi-use case they are NP complete. We begin by summarizing the work done in <ref> [7] </ref> and [8] to efficiently solve the single-issue load/store minimization problem using dynamic programming and pruning rules. <p> Here the legality of an allocation is defined in the same way as for multi-issue allocation above; however the cost of an allocation is simply the number of loads and stores. The algorithm in <ref> [7] </ref> reduces spill selection to a graph traversal problem where each node of the graph represents the state of the values at the current point in the schedule. <p> As in our algorithm only the instructions (slots) in the original input schedule, not the load/store instructions (extra slots in our algorithm), are numbered. The rules described in <ref> [7] </ref> and [8] are slightly different because the instructions access pseudo-registers that can be written multiple times. The algorithm constructs all legal configurations for each instruction and finds a cheapest path from the initial configuration (before the first instruction) to a final configuration for the last instruction. <p> The required loads and stores are then implied by the sequence of configurations along this path. The number of configurations considered by this algorithm grows exponentially with the number of instructions. Horwitz <ref> [7] </ref> describes a set of pruning rules that eliminate configurations that cannot lie on a cheapest path and merges equivalent configurations.
Reference: [8] <author> W. Hsu, C. N. Fischer, and J. R. Goodman. </author> <title> On the minimization of loads/stores in local register allocation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15 </volume> <pages> 1252-1260, </pages> <year> 1989. </year>
Reference-contexts: Horwitz et al. [7] first addressed the problem of finding an allocation of index variables to registers that minimizes the number of load and store spills that are required for a basic block. This approach is extended in Hsu et al. <ref> [8] </ref> to handle a wider class of schedules. A single-issue machine is assumed in each case, so the goal of the algorithm is to minimize the number of loads and stores that are needed. This paper discusses the extension of the single-issue load/store minimization algorithm for a multi-issue machine. <p> The first memory operation inserted into a slot is free, and each subsequent operation added to that slot causes an extra slot and has a cost of one. 2 Optimal Register Allocation using Dynamic Programming Our algorithm is an extension of the algorithms described by Horwitz [7] and Hsu <ref> [8] </ref> for the minimization of loads and stores in straight-line single-issue code. <p> Both problems have efficient solutions when each data value is used at most once, but in the general multi-use case they are NP complete. We begin by summarizing the work done in [7] and <ref> [8] </ref> to efficiently solve the single-issue load/store minimization problem using dynamic programming and pruning rules. <p> As in our algorithm only the instructions (slots) in the original input schedule, not the load/store instructions (extra slots in our algorithm), are numbered. The rules described in [7] and <ref> [8] </ref> are slightly different because the instructions access pseudo-registers that can be written multiple times. The algorithm constructs all legal configurations for each instruction and finds a cheapest path from the initial configuration (before the first instruction) to a final configuration for the last instruction. <p> The pruning rules described below define this partial ordering so that the optimality of the resulting register allocation will not be sacrificed. Several pruning rules used in the multi-issue register allocation algorithm are similar to those described in <ref> [8] </ref>. In that work, the spill candidates are partitioned into 4 sets: dead values, live values not written to memory with a single use remaining, live values not written to memory with more than one use remaining, and live values that have been written to memory. <p> These rules are called implicit because they eliminate exclusion sets before they are actually considered by the algorithm. Rules #3, #4 and #5 bear some similarity to the 2nd, 3rd and 4th observations in <ref> [8] </ref>. Note that since we refer only to values, which are written at most once, there is no need to verify that a live value will be read before being overwritten. The other three rules, #1, #2 and #6, are new.
References-found: 8

