URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1996/1996-37.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: e-mail: ftanja, doaitseg@cs.ruu.nl, wishnup@caplin.cs.ui.ac.id  
Title: Formal methods and mechanical verification applied to the development of a convergent distributed sorting program.  
Author: T.E.J. Vos, S. D. Swierstra and I.S.W.B. Prasetya 
Keyword: convergence.  
Note: Contents  
Date: September 30, 1996  
Address: P.O. Box 80.089, 3508 TB Utrecht, The Netherlands  
Affiliation: Utrecht University, Department of Computer science  
Abstract: Gentle introductions to the programming logic UNITY, the theorem proving environment HOL, and the embedding of the first into the latter are presented. Equipped with this apparatus a methodology for designing distributed algorithms is described. Finally this methodology is used to design and proof the correctness of a convergent distributed sorting algorithm. keywords: formal methods, UNITY, theorem provers, HOL, distributed algorithms,
Abstract-found: 1
Intro-found: 1
Reference: [And92] <author> Flemming Andersen. </author> <title> A Theorem Prover for UNITY in Higher Order Logic. </title> <type> PhD thesis, </type> <institution> Technical University of Denmark, </institution> <year> 1992. </year>
Reference-contexts: A selection of libraries of the HOL system can be found on http://lal.cs.byu.edu/lal/holdoc/library.html. The UNITY embedding described in this report is an example of a library for HOL, an other UNITY library is also available <ref> [And92] </ref>. An other example is the arith library by Boulton [Bou94], the main tool of which is a partial decision procedure, ARITH_CONV, for Presburger natural number arithmetic [Coo72]. This tool enables users of the HOL system to automatically prove arithmetic lemmas in a practical amount of time.
Reference: [BBL93] <author> J.P. Bowen, P Breuer, and Kevin Lano. </author> <title> A compendium of formal techniques for software maintenance. </title> <journal> IEE/BCS Software Engineering Journal, </journal> <volume> 8(5) </volume> <pages> 253-262, </pages> <month> September </month> <year> 1993. </year>
Reference: [BGM90] <author> J. Burns, M. Gouda, and R. Miller. </author> <title> Stabilization and pseudo-stabilization. </title> <type> Technical report, </type> <institution> University of Texas, TR-90-13, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: In a sequential system the rounds are totally ordered. This, however, does not have to be the case in a distributed system, 10 This notion of convergence is what by Burns, Gouda, and Miller called pseudo-stabilisation <ref> [BGM90] </ref>. 6.4 Extended UNITY 33 Theorem 6.39 Convergence Implies Progress CON IMP REACH P; J : p q Theorem 6.40 Introduction CON ENSURES LIFT, CON IMP LIFT P; J : p; q 2 Pred:(wP ) ^ ( J) ^ ( (J ^ q)) [p ^ J ) q] _ (p ^
Reference: [BH95a] <editor> J.P. Bowen and M Hinchey. </editor> <title> Seven more myths of formal methods. </title> <journal> IEEE Software, </journal> <volume> 12(4) </volume> <pages> 34-41, </pages> <month> July </month> <year> 1995. </year>
Reference: [BH95b] <editor> J.P. Bowen and M Hinchey. </editor> <title> Ten commandments of formal methods. </title> <journal> IEEE Computer, </journal> <volume> 28(4) </volume> <pages> 56-63, </pages> <month> April </month> <year> 1995. </year>
Reference: [Bou92] <author> R. Boulton. </author> <title> The hol arith library. </title> <type> Technical report, </type> <institution> Computer Laboratory University of Cambridge, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Since mechanical verification techniques can cope with infinite state spaces, an interesting topic is to extend or combine interactive theorem provers with various automatic tools such as model checkers. <ref> [KKS91, Bou92, Bus94] </ref>. Time can not be reduced for ever, there must always be some amount of time which shall be necessary to understand the problem to be solved completely.
Reference: [Bou93] <author> Richard John Boulton. </author> <title> Efficiency in a Fully-Expansive Theorem Prover. </title> <type> PhD thesis, </type> <institution> University of Cambridge, </institution> <month> Decembre </month> <year> 1993. </year>
Reference-contexts: Often, however, the decision procedure cannot be used. For this reason there is much interest in decision procedures for combinations of theories [Bou95]. More efficiency HOL is a fully-expansive theorem prover <ref> [Bou93] </ref>, which means that proofs generated in the system are composed of applications of the primitive inference rules of the underlying logic. The advantages of a fully-expansive theorem prover are twofold. Firstly, the soundness of the system depends only on the implementations of the primitive inference rules. <p> Secondly, users are free to write their own proof procedures without the risk of making the system unsound. The disadvantage, however, is that the insistence on resolving proofs into simple primitive inferences can 10 Reflections 78 make HOL slow, and thus performance is compromised. The work of Richard Boulton <ref> [Bou93] </ref> focuses on the improvement of fully-expansive theorem provers by eliminating duplicated and unnecessary primitive inferences. Combining theorem proving with model checking. Model checking is a very successful technique for automatically verifying finite-state programs.
Reference: [Bou94] <author> R.J. Boulton. </author> <title> Efficiency in a fully-expansive theorem prover. </title> <type> Technical Report 337, </type> <institution> University of Cambridge Computer Laboratory, </institution> <year> 1994. </year>
Reference-contexts: However, for limited applications, it is often possible to provide automatic procedures. The standard HOL package is supplied with a library called arith written by Boulton <ref> [Bou94] </ref>. The library contains a decision procedure to decide the validity of a certain subset of arithmetic formulae over natural numbers. The procedure is based on the Presburger natural number arithmetic [Coo72]. <p> A selection of libraries of the HOL system can be found on http://lal.cs.byu.edu/lal/holdoc/library.html. The UNITY embedding described in this report is an example of a library for HOL, an other UNITY library is also available [And92]. An other example is the arith library by Boulton <ref> [Bou94] </ref>, the main tool of which is a partial decision procedure, ARITH_CONV, for Presburger natural number arithmetic [Coo72]. This tool enables users of the HOL system to automatically prove arithmetic lemmas in a practical amount of time. The availability of all sorts of libraries are valuable in theorem provers.
Reference: [Bou95] <author> Richard J. Boulton. </author> <title> Combining decision procedures in the HOL system. </title> <editor> In E. T. Schubert, P.J. Windley, and J. Alves-Foss, editors, </editor> <booktitle> Proceedings of the 8th International Workshop on Higher Order Logic Theorem Proving and its Applications, </booktitle> <pages> pages 75-89, </pages> <address> Aspen Grove, Utah, USA, </address> <month> September </month> <year> 1995. </year> <booktitle> Lecture Notes in Computer Science volume 971, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Often, however, the decision procedure cannot be used. For this reason there is much interest in decision procedures for combinations of theories <ref> [Bou95] </ref>. More efficiency HOL is a fully-expansive theorem prover [Bou93], which means that proofs generated in the system are composed of applications of the primitive inference rules of the underlying logic. The advantages of a fully-expansive theorem prover are twofold.
Reference: [Bow93] <author> J.P. Bowen. </author> <title> Formal methods in safety-critical standards. </title> <booktitle> In Proc. 1993 Software Engineering Standards Symposium (SESS'93), </booktitle> <pages> pages 168-177, </pages> <address> Brighton, UK, 30 August - 3 September 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [BS92] <author> J.P. Bowen and V. Stavridou. </author> <title> Formal methods and software safety. </title> <editor> In H.H. Frey, editor, </editor> <booktitle> Safety of computer control systems 1992 (SAFECOMP '92), </booktitle> <pages> pages 93-98, </pages> <address> Zurich, Switzerland, </address> <month> October </month> <year> 1992. </year> <booktitle> Proc. IFAC Symposium, </booktitle> <publisher> Pergamon Press. </publisher>
Reference: [BS93a] <author> J.P. Bowen and V Stavridou. </author> <title> The industrial take-up of formal methods in safety-critical and other areas: A perspective. </title> <editor> In J.C.P. Woodcock and P.G. Larsen, editors, FME'93: </editor> <booktitle> Industrial-Strength Formal Methods, </booktitle> <pages> pages 183-195. </pages> <publisher> Springer-Verlag, LNCS 670, </publisher> <year> 1993. </year>
Reference: [BS93b] <author> J.P. Bowen and V. Stavridou. </author> <title> Safety-critical systems, formal methods and standards. </title> <journal> IEEE Software Engineering Journal, </journal> <volume> 8(4) </volume> <pages> 189-209, </pages> <month> July </month> <year> 1993. </year> <note> REFERENCES 86 </note>
Reference: [Bus94] <author> H. Busch. </author> <title> First-order automation for higher-order-logic theorem proving. </title> <editor> In T.F. Melham and J. Camilleri, editors, </editor> <booktitle> Lecture Notes in Computer Science 859: Higher Order Theorem Proving and Its Application, </booktitle> <pages> pages 97-122. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Since mechanical verification techniques can cope with infinite state spaces, an interesting topic is to extend or combine interactive theorem provers with various automatic tools such as model checkers. <ref> [KKS91, Bou92, Bus94] </ref>. Time can not be reduced for ever, there must always be some amount of time which shall be necessary to understand the problem to be solved completely.
Reference: [But93] <author> R.W. Butler. </author> <title> Formal methods for life-critical software. </title> <booktitle> In AIAA Computing in Aerospace 9 Conference, </booktitle> <pages> pages 319-329, </pages> <address> San Diego, </address> <month> October 19-21 </month> <year> 1993. </year>
Reference: [BvW90] <author> R.J.R. Back and J. von Wright. </author> <title> Refinement concepts formalized in higher order logic. </title> <journal> Formal Aspects of Computing, </journal> (2):247-272, 1990. 
Reference-contexts: The universe of actions can be represented by Action in HOL: this new type, which is quite tedious. There is another way to represent a program, in which differently typed variables are easy to represent. But this representation has its own problems too. See for instance <ref> [BvW90, L-an94] </ref> 13 Some people prefer to use functions instead of relations.
Reference: [BW88] <author> R. Bird and Philip Wadler. </author> <title> Introduction to functional programming. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: In the new definition of assignment actions, which we are about to give, some well-known functions that stem from Functional Programming (a good introduction to which can be found in <ref> [BW88] </ref>) are used. The definitions of these functions are given below by pattern matching with [] and :.
Reference: [CG92] <author> D. Craigen and S. Gerhart. </author> <title> An international survey of industrial applications of formal methods. </title> <booktitle> In Z User Workshop, London 1992, </booktitle> <pages> pages 1-5. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [CGR93] <author> D. Craigen, S. Gerhart, and T Ralston. </author> <title> Formal methods reality check: Industrial usage. </title> <editor> In J.C.P. Woodcock and P.G. Larsen, editors, FME'93: </editor> <booktitle> Industrial-Strength Formal Methods, </booktitle> <pages> pages 250-267. </pages> <publisher> Springer-Verlag, LNCS 670, </publisher> <year> 1993. </year>
Reference: [CM88] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design A Foundation. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1988. </year>
Reference-contexts: During the execution of a program, its actions are executed in a certain order. In considering parallel or distributed executions of programs, strict orderings on when, where and how actions are executed vanish. Therefore, many distributed programming logics view programs as a collections of actions without any ordering. UNITY <ref> [CM88] </ref> consists of such a programming theory. It is invented to support the design and verification of distributed programs. An important aspect of UNITY is the separation of concerns between the core problem to be solved by an algorithm and the implementation details concerning programming languages and architectures. <p> The syntax deviates slightly from the one in <ref> [CM88] </ref> 6 . hUnity Programi ::= prog hname of programi read hset of variablesi write hset of variablesi init hpredicatei assignhactionsi hactionsi ::= hactioni j hactioni [] hactionsi hactioni ::= hsingle actioni j ([]i : i 2 V : hactionsi i ) hsingle actioni ::= hassignmenti j hguarded actioni hassignmenti ::= <p> As a result, we have the following definition: Definition 6.17 Invariant P ` flJ = (iniP ) J ^ P ` J) J Figures 6 and 5 list some interesting properties of unless , and ensures . These properties are taken from <ref> [CM88] </ref>, and there are more to be found there. <p> In UNITY parallel composition is denoted by []. In <ref> [CM88] </ref> the operator is also called program union. Definition 6.25 Parallel Composition P []Q = (aP [ aQ; iniP ^ iniQ; rP [ rQ; wP [ wQ) J Parallel composition is reflexive, commutative, and associative. <p> For example Bounded Progress, a consequence of the well-founded induction principle, is applicable to either and . This is very pleasant, since well-founded induction is a standard technique to prove termination, moreover the 7! version of the Bounded Progress law appears in <ref> [CM88] </ref> as a standard technique to prove progress. An even stronger induction principle, called Round Decomposition (Theorem 6.47), exists for convergence. The principle exploits the conjunctivity of convergence | a property which is not enjoyed by or 7!. Imagine a tree of processes. <p> Section 5 describes HOL [GM93], an interactive theorem proving environment for classical higher-order logic. Section 6 deals with UNITY, a programming logic invented to support the design and verification of distributed programs. It outlines the basic foundations of UNITY (from <ref> [CM88] </ref>), and several extensions regarding compositionality and convergence (as reported in [Pra95]). Finally section 7, considers an embedding of the programming logic UNITY within HOL, which makes it possible to represent and specify UNITY programs inside the theorem prover. <p> Furthermore it is simple and has a high level of abstraction. Refine and decompose the formal specification. Much of program development in the UNITY methodology <ref> [CM88] </ref> consists of refining specifications (i.e. adding detail to them) and decomposing specifications (i.e. splitting them up into smaller and preferably simpler specifications). Refinement and decomposition commences by proposing a general solution strategy, by means of which the program solves the specified problem. <p> Recall the Bounded Progress principle for (theorem 6.46). P; J : p q 20 There are other possible solution strategies, see for example <ref> [CM88] </ref>. 9.4 Refine and decompose the specification 53 The principle states that if A is a set of values on which a well-founded relation is defined and if m 2 A, then in a UNITY program P which will either establish q or decrease m, eventually q will hold since is
Reference: [Coo72] <author> D.C. Cooper. </author> <title> Theorem proving in arithmetic without multiplication. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence fl, chapter 5, </booktitle> <pages> pages 91-99. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1972. </year>
Reference-contexts: The standard HOL package is supplied with a library called arith written by Boulton [Bou94]. The library contains a decision procedure to decide the validity of a certain subset of arithmetic formulae over natural numbers. The procedure is based on the Presburger natural number arithmetic <ref> [Coo72] </ref>. <p> The UNITY embedding described in this report is an example of a library for HOL, an other UNITY library is also available [And92]. An other example is the arith library by Boulton [Bou94], the main tool of which is a partial decision procedure, ARITH_CONV, for Presburger natural number arithmetic <ref> [Coo72] </ref>. This tool enables users of the HOL system to automatically prove arithmetic lemmas in a practical amount of time. The availability of all sorts of libraries are valuable in theorem provers.
Reference: [DDH72] <author> J. Dahl, O, </author> <title> E.W. Dijkstra, and C.A.R. Hoare. Structured programming. </title> <publisher> Academic Press, </publisher> <address> Orlando, </address> <year> 1972. </year>
Reference: [GCR94] <author> S. Gerhart, D. Craigen, and T. Ralston. </author> <title> Experience with formal methods in critical systems. </title> <journal> IEEE Software, </journal> <pages> pages 21-28, </pages> <month> January </month> <year> 1994. </year>
Reference: [GM93] <author> Mike J.C. Gordon and Tom F. Melham. </author> <title> Introduction to HOL. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: The notation is commonly used within the UNITY community. 5 HOL For those who are familiar with HOL, this section can be skipped. The HOL system <ref> [GM93] </ref> is one of the most widely used theorem provers, both in academia and industry. It is free, comes with extensive documentation, libraries, an interactive help system, and myriad web-sites providing information and a dynamic search engine for HOL information 1 . <p> These object language types are denoted by expressions of the form ": ... ". There is a built-in function type of, which has ML type term-&gt;type and returns the logical type (i.e object language type) of a HOL term. An example taken from <ref> [GM93] </ref> may elucidate these matters. Consider for example the logical term "(1,2)" 5.2 Theorems in HOL 9 * It is a HOL term with object language type (i.e. logical type) ":num#num". * It is an ML expression with meta-language type term * Evaluating type of "(1,2)" results in ":num#num". <p> For those who skipped some or all of these sections, first a recapitulation is given. Section 5 describes HOL <ref> [GM93] </ref>, an interactive theorem proving environment for classical higher-order logic. Section 6 deals with UNITY, a programming logic invented to support the design and verification of distributed programs. It outlines the basic foundations of UNITY (from [CM88]), and several extensions regarding compositionality and convergence (as reported in [Pra95]).
Reference: [Hal90] <author> A. Hall. </author> <title> Seven myths of formal methods. </title> <journal> IEEE Software, </journal> <pages> pages 11-19, </pages> <month> September </month> <year> 1990. </year>
Reference: [Kem90] <author> R.A.. Kemmerer. </author> <title> Integrating formal methods into the development process. </title> <journal> IEEE Software, </journal> <pages> pages 37-50, </pages> <month> September </month> <year> 1990. </year>
Reference: [KKS91] <author> R. Kumar, T. Kropf, and K. Schneider. </author> <title> Integrating a first order automatic prover in the hol environment. </title> <booktitle> In Proceedings of the 1991 International Workshop on the HOL Theorem Proving System and Its Applications. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: Since mechanical verification techniques can cope with infinite state spaces, an interesting topic is to extend or combine interactive theorem provers with various automatic tools such as model checkers. <ref> [KKS91, Bou92, Bus94] </ref>. Time can not be reduced for ever, there must always be some amount of time which shall be necessary to understand the problem to be solved completely.
Reference: [L-an94] <author> T. L-angbacka. </author> <title> A hol formalization of the temporal logic of actions. </title> <editor> In T.F. Mel-ham and J. Camilleri, editors, </editor> <booktitle> Lecture Notes in Computer Science 859: Higher Order Theorem Proving and Its Application, </booktitle> <pages> pages 332-345. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> REFERENCES 87 </note>
Reference-contexts: The universe of actions can be represented by Action in HOL: this new type, which is quite tedious. There is another way to represent a program, in which differently typed variables are easy to represent. But this representation has its own problems too. See for instance <ref> [BvW90, L-an94] </ref> 13 Some people prefer to use functions instead of relations.
Reference: [Len93] <author> P.J.A. Lentfert. </author> <title> Distributed Hierarchical Algorithms. </title> <type> PhD thesis, </type> <institution> Utrecht University, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: Moreover, an induction principle is formulated for convergence which is stronger than the one for UNITY's reach-to operator. As a consequence, a powerful technique for proving convergence has become available. Third, this HOL embedding of extended UNITY was used to mechanically verify Lent-fert's Fair and Successive Approximation (FSA) algorithm <ref> [Len93] </ref>.
Reference: [LT93] <author> N.G. Leveson and C.S. Turner. </author> <title> An investigation of the Therac-25 accidents. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 18-41, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Between June 1985 and January 1987, six known accidents involved massive overdoses by this machine with resultant deaths and serious injuries. For a thorough investigation of these accidents with the Therac-25 the reader is referred to <ref> [LT93] </ref>. Formal methods, the term with which the variety of mathematical modelling techniques that are applicable to computer system design is meant, are often advocated as a way of increasing confidence in computer based systems.
Reference: [Mel90] <author> T.F. Melham. </author> <title> The HOL sets library. </title> <note> http://128.187.2.182/lal/holdoc/library.html, 1990. </note>
Reference-contexts: Note that these parameters are kept implicit in the hand definition in Figure 10. Lines 4 and 5 define the predicate which represents the set of actions of which the program Sort consists. The constant function CHF, which is defined in the library theory sets <ref> [Mel90] </ref>, is used to convert a set to a predicate which given an element returns true if this element is in the set, and false otherwise. Line 7 specifies the initial condition, which is true.
Reference: [Neu95] <author> Peter G. Neumann. </author> <title> Computer Related Risks. </title> <publisher> Addison-Wesley Publishing Com-pagny, </publisher> <year> 1995. </year>
Reference-contexts: A consequence of this ever-increasing computerisation in safety-critical environments is that serious attention must be paid to the trustworthiness of the computer systems applied. In his book <ref> [Neu95] </ref> Peter Neumann gives an extensive list of serious and less serious mishaps that have happened in computerised environments in the past few years. Deaths due to poorly designed software have occurred; for example the accidents that happened with the Therac-25, a computerised radiation therapy machine.
Reference: [Nic91] <author> J.E. </author> <title> Nicholls. Domains of application for formal methods. </title> <booktitle> In Z User Workshop, </booktitle> <address> York 1991, </address> <pages> pages 145-156. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [Pau87] <author> Lawrence C. Paulson. </author> <title> Logic and Computation:Interactive Proof with Cambridge LCF. </title> <publisher> Cambridge University Press, </publisher> <year> 1987. </year>
Reference-contexts: It is free, comes with extensive documentation, libraries, an interactive help system, and myriad web-sites providing information and a dynamic search engine for HOL information 1 . HOL is a direct descendant of the innovative LCF (Logic of Computable Functions) <ref> [Pau87] </ref> theorem prover developed by Robin Milner in the early 1970s, and is an implementation of a version of Church's simple theory of types, a formalism dating back more than 50 years. HOL is an acronym of Higher Order Logic, the logic used by the HOL system.
Reference: [Pra95] <author> Wishnu Prasetya. </author> <title> Mechanically Supported Design of Self-stabilizing Algorithms. </title> <type> PhD thesis, </type> <institution> Utrecht University, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: These are very complicated tasks. As a consequence of the increasing usage and dependence of computer networks, distributed programs have become of major importance. Accordingly, their trustworthiness must be subjected to severe tests of correctness. In his dissertation Wishnu Prasetya <ref> [Pra95] </ref> reported the results of a four-year research-project on the mechanically supported verification of distributed algorithms. The objective of this present report is to summarise his findings and to show how these can be used to verify a distributed algorithm. <p> In particular, notice how Theorem 6.28 describes the condition in which progress by ensures can be preserved by parallel composition. The theorem does not apply to progress 6.4 Extended UNITY 28 by 7! though. The extension presented in <ref> [Pra95] </ref> is a variant of 7!. It is called the reach operator, and is denoted by . In the rest of this section the reach operator is defined and the most important compositionality laws on this operator are presented. <p> A deep embedding is more trustworthy, but basically more difficult as we have to take the grammar of well-formed formulae in the logic into account. In <ref> [Pra95] </ref> a shallow embedding of the whole UNITY logic and all extensions (which were discussed in the previous section) is given in HOL. Basically, because whole UNITY is available in HOL, a program derivation can now take place entirely within HOL. <p> Section 6 deals with UNITY, a programming logic invented to support the design and verification of distributed programs. It outlines the basic foundations of UNITY (from [CM88]), and several extensions regarding compositionality and convergence (as reported in <ref> [Pra95] </ref>). Finally section 7, considers an embedding of the programming logic UNITY within HOL, which makes it possible to represent and specify UNITY programs inside the theorem prover. The process of formally designing programs can roughly be described in seven phases. <p> There are many 15 specification languages or logics, which differ most in their choice of semantic domain. The best notation to use, is the one which relates most to the characteristics of the specific product being developed and the background of the individuals involved. In this report (following <ref> [Pra95] </ref>) the UNITY logic is chosen, for we want to design distributed programs, and UNITY is explicitly developed for these purposes. Furthermore it is simple and has a high level of abstraction. Refine and decompose the formal specification. <p> The first two conditions are easy to proof. The third condition requires that the variables occurring at the left-hand sides of the assignments are collected and compared with the declared set of write variables. The fourth condition turns out to be <ref> [Pra95] </ref> very difficult to prove if a shallow embedding of the programming logic is not available. In the case study in section 9 the UNITY embedding will therefore be made deeper than the one presented in [Pra95], and a tactic shall be constructed which automatically proves this fourth condition for an <p> The fourth condition turns out to be <ref> [Pra95] </ref> very difficult to prove if a shallow embedding of the programming logic is not available. In the case study in section 9 the UNITY embedding will therefore be made deeper than the one presented in [Pra95], and a tactic shall be constructed which automatically proves this fourth condition for an arbitrary UNITY program. Proof that the program satisfies the specification. First the specification must be formalised in HOL. <p> It is obvious, though very important, that when one, say for example, is in step i and wants to go back to step j to change or add something, one also has to adjust the steps in between i and j. 9 Case study 43 9 Case study In <ref> [Pra95] </ref> a formal and mechanically verified design of Lentfert's FSA algorithm is presented, following the process described in section 8. Since the aim of this present report is to highlight the contribution to the field of formal methods and mechanical verification, this case study tackles a much simpler problem. <p> (wP rP ) ^ (8a : a 2 aP : (wP ) c 8 a) ^ (8a : a 2 aP : (rP ) c 9 a) Whereas the first three conditions are easy to prove, the last condition, from now on called the read constraint, turns out to be <ref> [Pra95] </ref> very difficult to prove if a shallow embedding 9.7 Proof that the program is well-formed 65 of the programming logic is not available. As promised in section 8 the UNITY embedding shall therefore be made deeper than the one presented in [Pra95]. <p> called the read constraint, turns out to be <ref> [Pra95] </ref> very difficult to prove if a shallow embedding 9.7 Proof that the program is well-formed 65 of the programming logic is not available. As promised in section 8 the UNITY embedding shall therefore be made deeper than the one presented in [Pra95]. Moreover, a tactic shall be presented that automatically proves the read constraint on an arbitrary syntactically correct (see page 20) UNITY program.
Reference: [Rus94] <author> J. Rushby. </author> <title> Critical system properties: Survey and taxonomy. Reliability Engineering and System Safety, </title> <booktitle> 43(2) </booktitle> <pages> 189-219, </pages> <year> 1994. </year>
Reference: [RvH93] <author> J. Rushby and F. von Henke. </author> <title> Formal verification of algorithms for critical systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(1) </volume> <pages> 13-23, </pages> <month> January </month> <year> 1993. </year>
Reference: [SB94] <author> Tom Schubert and John Biggs. </author> <title> A tree-based, graphical interface for large proof development. </title> <booktitle> In 1994 International Workshop on the HOL Theorem Proving System and its Applications, </booktitle> <year> 1994. </year>
Reference-contexts: The command line user interface to HOL does not currently provide this. Currently, the following user-interfaces are available: * a HOL and the Emacs editor. Here the Emacs editor is used as an interface to HOL. * An X Windows based graphical Interface to HOL, called xhol <ref> [SB94] </ref>. Interaction with HOL is accomplished through an emacs-style input window, a utility tool-bar, and a collection of windows that display information about the state of the proof. Featured is a graphical display of the entire proof tree.
Reference: [SKR91] <author> K. Scneider, T. Kropf, and Kumar R. </author> <title> Integrating a first-order automatic prover in the hol environment. </title> <editor> In M Archer, Joyce J.J., Levitt K.N., and Windley P.J., editors, </editor> <booktitle> Proceedings of the 1991 International Workshop on the HOL Theorem Proving System and Its Applications. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: It cannot be used to prove more sophisticated formulae from predicate logic, such as (8x :: P:x) ) (9x :: P:x) (assuming a non-empty domain of quantification). There is, however, a library called faust written by Schneider, Kropf, and Kumar <ref> [SKR91] </ref> that provides a decision procedure to check the validity of many formulae from first order predicate logic. <p> Unfortunately, the HOL system suffers from a relative lack of decision procedures, in addition to the Presburger procedure, the taut library, written by [], provides a decision procedure for propositional tautologies, the library faust, written by Schneider, Kropf, and Ku-mar <ref> [SKR91] </ref>, provides a decision procedure to check the validity of many formulae from first order predicate logic. A limitation of decision procedures is that formulae to be proved rarely conform to one theory.
Reference: [Sym95] <author> Donald Syme. </author> <title> A new interface for HOL ideas, issues and implementation. In 1995 Conference on Higher Order Logic Theorem Proving and its Applications, </title> <address> Aspen Grove, Utah, </address> <year> 1995. </year>
Reference-contexts: Some issues that have been suggested are: 10 Reflections 76 Better user interface. The obvious motivation for better user interfaces to HOL are simple: HOL is an excellent theorem proving system, but is has a crude, command-line interface. The following list of possible benefits, which is drawn from <ref> [Sym95] </ref>, indi cates how HOL users can benefit from a good graphical user interface (GUI). * Much better ways of visualising theory development. <p> TkHOL <ref> [Sym95] </ref> is an interface for HOL90 implemented using the Tk/Tcl toolkit. It is an extensible set of tools for viewing and browsing theories, searching the theory hierarchy for particular theorems, performing backward proofs and making (recursive type) definitions. The com mand line HOL interface is still available.
Reference: [TBK92] <author> Laurent Thery, Yves Bertot, and Gilles Kahn. </author> <title> Real theorem provers deserve real user-interfaces. </title> <type> Technical Report 1684, </type> <institution> Institut National de Recherche en Informatique et en Automatique., </institution> <year> 1992. </year>
Reference-contexts: CHOL offers a "better user-interface for the HOL theorem prover". It has been developed following a general approach for building user-interfaces for theorem provers <ref> [TBK92] </ref>.
Reference: [The93] <author> Laurent Thery. </author> <title> A proof development system for the HOL theorem prover. </title> <booktitle> In International Workshop on Higher Order Logic and its applications, </booktitle> <address> Vancouver, </address> <year> 1993. </year>
Reference-contexts: This display does not only presents a road map of what has and has not been proven, it also provides the user with clues about what techniques or tactics may be useful in proving the remaining unsolved subgoals. * An X-based User Interface to HOL called CHOL <ref> [The93] </ref>. CHOL offers a "better user-interface for the HOL theorem prover". It has been developed following a general approach for building user-interfaces for theorem provers [TBK92].
Reference: [Tho94a] <author> Muffy. Thomas. </author> <title> A proof of incorrectness using the lp theorem prover: the editing problem in the Therac-25. </title> <journal> High Integrity Systems Journal, </journal> <volume> 1(1) </volume> <pages> 35-48, </pages> <year> 1994. </year> <note> REFERENCES 88 </note>
Reference-contexts: If only one single human life can be spared as a result of applying formal methods and mechanical verification to the development of safety critical software, then any amount of time that is spend on mechanical formal verification is justifiable. The work of Muffy Thomas <ref> [Tho94a, Tho94b] </ref> uncovered several errors in the software which was used in the Therac-25, by using formal specification and verification techniques. Obviously, the answer to the second question is no.
Reference: [Tho94b] <author> Muffy. Thomas. </author> <title> The story of the Therac-25 in lotos. </title> <journal> High Integrity Systems Journal, </journal> <volume> 1(1) </volume> <pages> 3-15, </pages> <year> 1994. </year>
Reference-contexts: If only one single human life can be spared as a result of applying formal methods and mechanical verification to the development of safety critical software, then any amount of time that is spend on mechanical formal verification is justifiable. The work of Muffy Thomas <ref> [Tho94a, Tho94b] </ref> uncovered several errors in the software which was used in the Therac-25, by using formal specification and verification techniques. Obviously, the answer to the second question is no.

References-found: 44

