URL: http://www.cs.purdue.edu/homes/spaf/tech-reps/s79.ps
Refering-URL: http://www.cs.purdue.edu/homes/spaf/wwwpub/node6.html
Root-URL: http://www.cs.purdue.edu
Email: xnse@vm.cc.purdue.edu  spaf@cs.purdue.edu  
Title: Sequential Statistical Procedures for Approving Test Sets Using Mutation-Based Software Testing SERC TR-79-P  
Author: Mehmet S ahinoglu Eugene H. Spafford 
Note: To appear in Proceedings of the IFIP Conference on Approving Software Products (ASP-90), Garmisch-Partenkirchen, Germany,  Currently visiting  on a Fulbright Scholarship, support which is gratefully acknowledged.  
Date: 10 May 1990  17 September 1990.  
Address: Building  West Lafayette, Indiana 47907  West Lafayette, Indiana 47907  
Affiliation: Department of Statistics Mathematical Sciences  Purdue University  Software Engineering Research Center Department of Computer Science Purdue University  Purdue University from Middle East Technical University (METU), Ankara, Turkey  
Abstract: Mutation analysis is a well-studied method of measuring test-case adequacy. Mutation analysis involves the mutation of a program by introduction of a small syntactic change in the software. Existing test data sets are then executed against all these mutant programs. If the test data set is adequate for testing the original program, it will distinguish all of the incorrect mutant programs from the original program. As an ad-hoc procedure, a stopping criterion is conventionally based on a given "Y% of the mutants to be distinguished" with a certain "confidence level of X%" over a multiplicity of random test cases. Alternatively, we propose a Bayes sequential procedure for testing H 0 : p = p 1 (acceptable fraction of live mutants to demonstrate good quality) vs. H A : p = p 2 (unacceptable fraction of live mutants to demonstrate bad quality). This derives a sequential probability ratio testing (SPRT) that is the most economical sampling scheme with given prior probabilities, decision and sampling cost functions. The implementation of our proposed method on a sample program shows the cost effectiveness of the new technique as compared to the current, deterministic approach, which was not structured by statistical hypothesis testing. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. J. Anscombe. </author> <title> Tables of sequential inspection schemes to control fraction defective. </title> <journal> Journal of the Royal Statistical Society, CXII(Part II):180-206, </journal> <year> 1949. </year>
Reference-contexts: Such mutant transformations are statically defined for a language fl and designed to expose errors frequently committed by programmers using fl. For each execution of a mutant against the test set, i (t ), exactly one of two things happens: <ref> [1] </ref> The mutant i (t ) yields different results than (t ), or 1 Program mutation has been well documented in the literature and will only be summarized here. <p> Formulae for the average sample size and acceptance probability of such a scheme have been given by Burman [7] and Anscombe <ref> [1] </ref>. They are exact if b, H 1 and H 2 are integers. The error involved in rounding off is small if b is greater than 10, and this is often the case in practice.
Reference: [2] <author> S. Bai and Y. Yun. </author> <title> Optimum number of errors corrected before releasing a software system. </title> <journal> IEEE Transactions on Reliability, </journal> <volume> 37(1) </volume> <pages> 41-44, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: The reader unfamiliar with mutation testing is directed to recent references on mutation for detailed descriptions and further references, e.g. [8, 21, 13, 6, 24, 16]. 2 <ref> [2] </ref> The mutant i (t ) yield the same results as (t ). In the first case, the mutant is said to be dead since the mutant difference between i and has been distinguished by t .
Reference: [3] <author> G. A. Barnard. </author> <title> Sequential tests in industrial statistics. </title> <journal> Journal of the Royal Statistical Society, </journal> <volume> Suppl. 8 </volume> <pages> 1-27, </pages> <year> 1946. </year>
Reference-contexts: For mutation testing, where each test involves potentially expensive execution of mutated programs against large test sets, this finding is especially important. Following is the method of arriving at the optimum SPRT procedure based on the basic theory given by Barnard <ref> [3] </ref>: The optimum test procedure will be given as: * Continue inspection as long as 2 &lt; = (a 1 =a 2 )l (x; y) &lt; 1 * Stop inspection and accept the batch as soon as &gt; 1 7 * Stop inspection and reject the batch as soon as &lt; <p> 1 A (q 2 =(q 1 ); q 2 =q 1 ; q 1 ) c q 1 cS (q 2 =(q 1 ); q 2 =q 1 ; p 1 ) 7 Barnard's Score Notation for a Binomial SPRT The following derivation is from [18]: 8 According to Barnard <ref> [3] </ref>, any sequential probability ratio test procedure for a binomial popu-lation can be reduced (without much loss in accuracy) to a scoring procedure as follows: Take the logarithms on both sides of (9) and divide throughout by log (q 1 =q 2 ): log L &lt; X Y log (q 1 <p> Once is obtained, we calculate 1 and 2 from equations (10) and (12) or (11) and (12). Wald, Barnard and Bartlett <ref> [20, 3, 4] </ref> have given simple asymptotic formulae for the chance of acceptance and average sample size of an open scheme. Setting X = p (b + 1) we consider the limit p ! 0 with X constant. <p> 2 = 44; and b = 46 In this case, we accept the test set after generating 11 test cases that kill 88.4% of the live mutants using the deterministic approach, and is acceptable at the level of 99.13% with our suggested approach. 9 Summary Discussion and Conclusions As Barnard <ref> [3] </ref> has remarked, Wald's sequential procedure for testing the fraction defective of a batch of articles can be conveniently expressed in terms of a scoring system, as follows: [18] Sample the batch by drawing articles randomly from it one by one.
Reference: [4] <author> M. S. Bartlett. </author> <title> The large-sample theory of sequential tests. </title> <booktitle> Proceedings of the Cambridge Philosophy Society, </booktitle> <volume> 42, </volume> <year> 1946. </year>
Reference-contexts: Once is obtained, we calculate 1 and 2 from equations (10) and (12) or (11) and (12). Wald, Barnard and Bartlett <ref> [20, 3, 4] </ref> have given simple asymptotic formulae for the chance of acceptance and average sample size of an open scheme. Setting X = p (b + 1) we consider the limit p ! 0 with X constant. <p> Wald and Bartlett <ref> [4, 19] </ref> give a formula for the average sample size S as defined by: S = 1 X provided X 6= 1, while for X = 1 S = R 1 R 2 (23) as p ! 0, S and (b + 1) ! 1, and their ratio tends to the
Reference: [5] <author> T. A. Budd. </author> <title> Mutation Analysis of Program Test Data. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <year> 1980. </year>
Reference-contexts: The more mutants killed by a test set, the better the measured adequacy of the test set. By proper choice of mutant operators, comprehensive testing can be performed, <ref> [5] </ref> including path coverage [14] and domain analysis. [23] By examination of unkilled mutants, testers can add new test cases to better the adequacy score of the entire test set. Mutation analysis is designed to substantiate the correctness of a program .
Reference: [6] <author> C. Bullard and E. H. Spafford. </author> <title> Testing experience with Mothra. </title> <booktitle> In Proceedings of 25th Southeast ACM Conference, </booktitle> <institution> Birmingham AL, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: The reader unfamiliar with mutation testing is directed to recent references on mutation for detailed descriptions and further references, e.g. <ref> [8, 21, 13, 6, 24, 16] </ref>. 2 [2] The mutant i (t ) yield the same results as (t ). In the first case, the mutant is said to be dead since the mutant difference between i and has been distinguished by t .
Reference: [7] <author> J. P. Burman. </author> <title> Sequential sampling formulae for a binomial population. </title> <journal> Journal of the Royal Statistical Society, </journal> <volume> Suppl. 8 </volume> <pages> 98-103, </pages> <year> 1946. </year>
Reference-contexts: Formulae for the average sample size and acceptance probability of such a scheme have been given by Burman <ref> [7] </ref> and Anscombe [1]. They are exact if b, H 1 and H 2 are integers. The error involved in rounding off is small if b is greater than 10, and this is often the case in practice.
Reference: [8] <author> B. J. Choi, R. A. DeMillo, E. W. Krauser, R. J. Martin, A. P. Mathur, A. J. Offutt, H. Pan, and E. H. Spafford. </author> <title> The Mothra tools set. </title> <booktitle> In Proceedings of the 22nd Hawaii International Conference on Systems and Software, </booktitle> <pages> pages 275-284, </pages> <address> Kona, Hawaii, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: The reader unfamiliar with mutation testing is directed to recent references on mutation for detailed descriptions and further references, e.g. <ref> [8, 21, 13, 6, 24, 16] </ref>. 2 [2] The mutant i (t ) yield the same results as (t ). In the first case, the mutant is said to be dead since the mutant difference between i and has been distinguished by t . <p> The test set t can then be carried into the maintenance stage of the software life cycle. 2 On Mothra and the Stopping Rule The Mothra software testing environment <ref> [10, 9, 8] </ref> is an integrated set of tools and interfaces that support the planning, definition, preparation, execution, analysis, and evaluation of mutation-based tests of software systems.
Reference: [9] <author> R. A. DeMillo and A. J. Offutt. </author> <title> Experimental results of automatically generated adequate test sets. </title> <booktitle> In Proceedings of the Sixth Annual Pacific Northwest Software Quality Conference, </booktitle> <address> Portland, Oregon, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: The test set t can then be carried into the maintenance stage of the software life cycle. 2 On Mothra and the Stopping Rule The Mothra software testing environment <ref> [10, 9, 8] </ref> is an integrated set of tools and interfaces that support the planning, definition, preparation, execution, analysis, and evaluation of mutation-based tests of software systems.
Reference: [10] <author> Richard A. DeMillo and Eugene H. Spafford. </author> <title> The Mothra software testing environment. </title> <booktitle> In 11th Nasa Software Engineering Laboratory Workshop. </booktitle> <institution> Goddard Space Center, </institution> <month> December </month> <year> 1986. </year>
Reference-contexts: The test set t can then be carried into the maintenance stage of the software life cycle. 2 On Mothra and the Stopping Rule The Mothra software testing environment <ref> [10, 9, 8] </ref> is an integrated set of tools and interfaces that support the planning, definition, preparation, execution, analysis, and evaluation of mutation-based tests of software systems.
Reference: [11] <author> R. Govindarajalu. </author> <title> Sequential Statistical Procedures. </title> <publisher> Academic Press, </publisher> <year> 1975. </year>
Reference-contexts: ); : : :; (x 1 ; : : : ; x k ), i.e. consider the sequence: f 2 (x 1 ) ; f 1 (x 1 )f 1 (x 2 ) f 2 (x 1 ) : : : f 2 (x k ) (2) Definition: The SPRT <ref> [22, 17, 11] </ref> (Test) for testing H 0 : fi = fi 1 versus H 1 : fi = fi 2 is a rule that states: 1. if k (x) &gt;= A, stop sampling and reject H 0 (accept H 1 ). 2. if k (x) &lt;= B, stop sampling and <p> We note here that Bayesian Sequential testing also defaults to the simple sequential 6 procedure with no priors; or, if used with priors, when the sample size increases the a effect even-tually becomes negligible. <ref> [11] </ref> In a mutation-based testing environment, a sample (batch) of mutants (items) is inspected (executed against a test data set) and the mutants are classified as either dead (effective) or live (defective). Let p denote the fraction of live mutants within a selected sample of nonequivalent mutants.
Reference: [12] <author> W. E. Howden. </author> <title> Functional Program Testing and Analysis. </title> <publisher> McGraw-Hill, </publisher> <year> 1987. </year>
Reference-contexts: Mutations are simple changes introduced one at a time into the code being tested. These changes are derived empirically from studies of errors commonly made by programmers when translating requirements into code, although theoretical justification also can be found for their selection <ref> [12] </ref>. A mutant is killed if the execution of the mutated code against the test set distinguishes the behavior or output of the mutation from the unmutated code. The more mutants killed by a test set, the better the measured adequacy of the test set.
Reference: [13] <author> R. J. Martin. </author> <title> Using the Mothra software testing environment to ensure software quality. </title> <booktitle> In Proceedings of the IEEE National Aerospace and Electronics Conference, </booktitle> <address> Dayton, OH, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: The reader unfamiliar with mutation testing is directed to recent references on mutation for detailed descriptions and further references, e.g. <ref> [8, 21, 13, 6, 24, 16] </ref>. 2 [2] The mutant i (t ) yield the same results as (t ). In the first case, the mutant is said to be dead since the mutant difference between i and has been distinguished by t . <p> This would be of great utility in situations where full mutation testing would be too expensive, too time consuming, or simply beyond the capabilities of the available testing software. Conventionally, a typical mutation system user must specify test requirements of the following form: <ref> [13] </ref> "I must be X% sure that Y% of the mutants of type Z are killed in unit A." Here, X% is the degree of assurance Mothra will use to perform the random selection of mutants of type Z in unit A. <p> This program was chosen because of its widespread use in the testing literature, and because of our familiarity with it in other work (e.g., <ref> [13] </ref> and [16]). The routine contains 30 lines of Fortran-77 code. The Mothra mutation environment generates 951 mutants for this program, 107 of which are equivalent (leaving 844 non-equivalent). The smallest test set we know of that can kill 100% of non-equivalent mutants has 27 test cases.
Reference: [14] <author> G. Myers. </author> <title> The Art of Software Testing. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, NY, </address> <year> 1979. </year> <month> 13 </month>
Reference-contexts: The more mutants killed by a test set, the better the measured adequacy of the test set. By proper choice of mutant operators, comprehensive testing can be performed, [5] including path coverage <ref> [14] </ref> and domain analysis. [23] By examination of unkilled mutants, testers can add new test cases to better the adequacy score of the entire test set. Mutation analysis is designed to substantiate the correctness of a program .
Reference: [15] <author> C. V. Ramamoorthy, S. F. Ho, and W. T. Chen. </author> <title> On the automated generation of program test data. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2(4), </volume> <month> December </month> <year> 1976. </year>
Reference-contexts: X = 1 S = R 1 R 2 (23) as p ! 0, S and (b + 1) ! 1, and their ratio tends to the limit shown. 8 Illustrative Examples as Applied to Mutation To illustrate this method, we applied it to the trityp program, first presented in <ref> [15] </ref>. This program takes as input three integers representing the length of the sides of a triangle, and then determines whether sides define scalene, isosceles, equilateral, or illegal.
Reference: [16] <author> Eugene H. Spafford. </author> <title> Extending mutation testing to find environmental bugs. </title> <journal> Software Practice and Experience, </journal> <volume> 20(2) </volume> <pages> 181-189, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: The reader unfamiliar with mutation testing is directed to recent references on mutation for detailed descriptions and further references, e.g. <ref> [8, 21, 13, 6, 24, 16] </ref>. 2 [2] The mutant i (t ) yield the same results as (t ). In the first case, the mutant is said to be dead since the mutant difference between i and has been distinguished by t . <p> This program was chosen because of its widespread use in the testing literature, and because of our familiarity with it in other work (e.g., [13] and <ref> [16] </ref>). The routine contains 30 lines of Fortran-77 code. The Mothra mutation environment generates 951 mutants for this program, 107 of which are equivalent (leaving 844 non-equivalent). The smallest test set we know of that can kill 100% of non-equivalent mutants has 27 test cases.
Reference: [17] <author> Statistics Research Group. </author> <title> Sequential Analysis of Statistical Data: Applications. </title> <publisher> Columbia University Press, </publisher> <year> 1945. </year>
Reference-contexts: ); : : :; (x 1 ; : : : ; x k ), i.e. consider the sequence: f 2 (x 1 ) ; f 1 (x 1 )f 1 (x 2 ) f 2 (x 1 ) : : : f 2 (x k ) (2) Definition: The SPRT <ref> [22, 17, 11] </ref> (Test) for testing H 0 : fi = fi 1 versus H 1 : fi = fi 2 is a rule that states: 1. if k (x) &gt;= A, stop sampling and reject H 0 (accept H 1 ). 2. if k (x) &lt;= B, stop sampling and
Reference: [18] <author> M. K. Vagholkar and G. B. Wetherill. </author> <title> The most economical binomial sequential probability ratio test. </title> <journal> Biometrika, </journal> <volume> 47(1 and </volume> 2):103-109, 1960. 
Reference-contexts: Let R (U; L; p) = 1 A (U; L; p) be defined as the rejection probability. Let S (U; L; p) denote the average number of mutants required to be inspected. To obtain equations for the optimum boundaries, we proceed in the manner indicated in equation (9). <ref> [18] </ref> The decision boundary is the locus of points such that the expected cost of taking an immediate decision is equal to the expected cost of taking at least one more observation and continuing the test. <p> It is noted, in general, that the difference between the expected cost of an immediate decision and expected cost of continuing the test should decrease as the sample (mutant) size increases considerably. As a result of the optimization procedure, <ref> [18] </ref> i.e., equating the expected cost of an immediate decision to the expected cost of at least one more mutant inspected, we have the following equations as a result: For = ( 2 = 1 ) &lt; (p 1 =p 2 ), W 12 p 2 R (p 2 =p 1 <p> 1 = W 21 q 1 A (q 2 =(q 1 ); q 2 =q 1 ; q 1 ) c q 1 cS (q 2 =(q 1 ); q 2 =q 1 ; p 1 ) 7 Barnard's Score Notation for a Binomial SPRT The following derivation is from <ref> [18] </ref>: 8 According to Barnard [3], any sequential probability ratio test procedure for a binomial popu-lation can be reduced (without much loss in accuracy) to a scoring procedure as follows: Take the logarithms on both sides of (9) and divide throughout by log (q 1 =q 2 ): log L &lt; <p> After this is accomplished, we stop, and then use T to test the original, non-mutated code. For our tests, we used the prior probabilities and costs developed for the examples in <ref> [18] </ref>. The following tables illustrate our results. The first column in each table indicates the number of mutants selected in step 2 before it was necessary to generate a new testcase. <p> the deterministic approach, and is acceptable at the level of 99.13% with our suggested approach. 9 Summary Discussion and Conclusions As Barnard [3] has remarked, Wald's sequential procedure for testing the fraction defective of a batch of articles can be conveniently expressed in terms of a scoring system, as follows: <ref> [18] </ref> Sample the batch by drawing articles randomly from it one by one. Add 1 for a non-defective article, b for a defective.
Reference: [19] <author> A. Wald and J. Wolfowitz. </author> <title> Optimim character of the sequential probability ratio test. </title> <journal> Annals of Mathematical Statistics, </journal> <volume> 19 </volume> <pages> 326-339, </pages> <year> 1948. </year>
Reference-contexts: Hence, as long as the cost of inspection depends merely on the total number of mutants inspected and no extra overhead cost is involved, a sequential sampling inspection plan will be the most economical one. Wald and Wolfowitz <ref> [19] </ref> proved that when testing two simple hypotheses, the sequential probability ratio test requires, on average, the fewest observations among all tests with the same power. <p> Wald and Bartlett <ref> [4, 19] </ref> give a formula for the average sample size S as defined by: S = 1 X provided X 6= 1, while for X = 1 S = R 1 R 2 (23) as p ! 0, S and (b + 1) ! 1, and their ratio tends to the
Reference: [20] <author> Abraham Wald. </author> <title> Selected Papers in Statistics and Probability. </title> <publisher> McGraw Hill, </publisher> <year> 1945. </year>
Reference-contexts: A Type I error is mistakenly rejecting a good program as faulty. 4 k = f 1 (x 1 )f 1 (x 2 ) : : : f 1 (x k ) Wald <ref> [20] </ref> tells us to consider the sequence of ratios 1 (x 1 ); 2 (x 1 ; x 2 ); : : :; (x 1 ; : : : ; x k ), i.e. consider the sequence: f 2 (x 1 ) ; f 1 (x 1 )f 1 (x 2 <p> Once is obtained, we calculate 1 and 2 from equations (10) and (12) or (11) and (12). Wald, Barnard and Bartlett <ref> [20, 3, 4] </ref> have given simple asymptotic formulae for the chance of acceptance and average sample size of an open scheme. Setting X = p (b + 1) we consider the limit p ! 0 with X constant.
Reference: [21] <author> P. J. Walsh. </author> <title> A Measure of Test Case Completeness. </title> <type> PhD thesis, </type> <institution> Watson School of Engineering, State University of New York at Binghamton, Binghamton, </institution> <address> NY, </address> <year> 1985. </year>
Reference-contexts: The reader unfamiliar with mutation testing is directed to recent references on mutation for detailed descriptions and further references, e.g. <ref> [8, 21, 13, 6, 24, 16] </ref>. 2 [2] The mutant i (t ) yield the same results as (t ). In the first case, the mutant is said to be dead since the mutant difference between i and has been distinguished by t .
Reference: [22] <author> G. B. Wetherill and K. D. Glazebrook. </author> <title> Sequential Methods in Statistics. </title> <publisher> Chapman and Hall, </publisher> <year> 1986. </year> <note> Third edition. </note>
Reference-contexts: ); : : :; (x 1 ; : : : ; x k ), i.e. consider the sequence: f 2 (x 1 ) ; f 1 (x 1 )f 1 (x 2 ) f 2 (x 1 ) : : : f 2 (x k ) (2) Definition: The SPRT <ref> [22, 17, 11] </ref> (Test) for testing H 0 : fi = fi 1 versus H 1 : fi = fi 2 is a rule that states: 1. if k (x) &gt;= A, stop sampling and reject H 0 (accept H 1 ). 2. if k (x) &lt;= B, stop sampling and
Reference: [23] <author> Lee J. White and E. K. Cohen. </author> <title> A domain strategy for computer program testing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(3) </volume> <pages> 247-257, </pages> <month> May </month> <year> 1980. </year>
Reference-contexts: The more mutants killed by a test set, the better the measured adequacy of the test set. By proper choice of mutant operators, comprehensive testing can be performed, [5] including path coverage [14] and domain analysis. <ref> [23] </ref> By examination of unkilled mutants, testers can add new test cases to better the adequacy score of the entire test set. Mutation analysis is designed to substantiate the correctness of a program .

References-found: 23

