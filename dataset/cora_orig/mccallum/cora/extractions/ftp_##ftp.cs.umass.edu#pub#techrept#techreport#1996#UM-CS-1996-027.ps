URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1996/UM-CS-1996-027.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/96-027.html
Root-URL: 
Email: fnaumovicjclarkejljog@cs.umass.edu  
Title: Verification of Communication Protocols Using Data Flow Analysis  
Author: Gleb N. Naumovich, Lori A. Clarke, and Leon J. Osterweil 
Address: Amherst, Massachusetts 01003  
Affiliation: Laboratory for Advanced Software Engineering Research Computer Science Department University of Massachusetts  
Note: email:  This work was supported in part by the Air Force Materiel Command, Rome Laboratory, and the Advanced Research Projects Agency under Contract F30602-94-C-0137.  
Date: April 29, 1996  
Abstract: In this paper we demonstrate that data flow analysis is an effective approach for verifying requirements of communication protocols. Communication protocols are responsible for establishing the communication patterns between different processes within a distributed computer system. Data flow analysis is a static analysis method for increasing confidence in the correctness of software systems by automatically verifying that a given software artifact (e.g., design or code) must behave consistently with a specified requirement. In this case study, we apply the FLAVERS data flow analysis tool to pseudocode designs of the three way handshake connection establishment protocol and of the alternating bit protocol and prove that the behavior of the pseudocode is consistent with protocol behavioral requirement specifications. In addition, we show how assumptions about the environment in which a software system is executed can be incorporated into the analysis, using message losses as an example. We present experimental results and derive some guidelines about the classes of protocol requirement specifications that may be amenable to verification using FLAVERS. 
Abstract-found: 1
Intro-found: 1
Reference: [ABC82] <author> W. Richards Adrion, M.A. Branstad, and J.C. Cherniavski. </author> <title> Validation, Verification, and Testing of Computer Software. </title> <journal> ACM Computing Surveys, </journal> <volume> 14(2) </volume> <pages> 159-192, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: In this section we review applications of testing and formal methods to communication protocols only briefly and concentrate on reviewing static analysis approaches, as that work is closest to our own. Testing <ref> [ABC82] </ref> executes a program to determine whether its actual behaviors conform to its expected behaviors. Since the number of possible program executions is usually excessively large, it is impractical to use testing to demonstrate the absence of errors.
Reference: [ABC + 91] <author> George S. Avrunin, Ugo A. Buy, James C. Corbett, Laura K. Dillon, and Jack C. Wileden. </author> <title> Automated Analysis of Concurrent Systems with the Constrained Expression Toolset. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: These approaches significantly improve the feasibility of reachability methods, but in general are still prohibitively expensive to use with most distributed systems. The constrained expression approach is not based on reachability analysis <ref> [ABC + 91] </ref>. Given a specified pattern of program events in the form of Finite State Automata (FSA), this technique attempts to see if the regular language of an FSA corresponds to some execution of the system. <p> The given pattern of program events is also represented in the form of linear inequalities. Integer linear programming is used to solve the resulting system of inequalities. The implementation of this technique has been successfully applied to some distributed systems <ref> [ABC + 91, Cor92] </ref>. However, it also has exponential worst-case bounds. To the best of our knowledge, this approach has not been applied to the analysis of protocols.
Reference: [BB87] <author> T. Bolognesi and E. Brinksma. </author> <title> Introduction to the ISO specification language LOTOS. Computer Networks and ISDN Systems, </title> <publisher> North-Holland, </publisher> <pages> 14 25-59, </pages> <year> 1987. </year>
Reference-contexts: Figure 2 demonstrates the principle of incremental accuracy improvement. 3.2 Protocol Design Language A number of protocol specification and design languages have been proposed, the most prominent being CCS [Mil80], Z [Spi92], LOTOS <ref> [BB87] </ref>, SDL [BH89], Estelle [BD87], and Promela [Hol91]. Our choice of Ada as a protocol design language was suggested by some positive experience with it [YGH82, CDG85] and by the fact that the current implementation of FLAVERS can process only Ada.
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic Model Checking: 10 20 States and Beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: Properties can be formulated more flexibly than with other reachability approaches, but model checking still suffers from the state space explosion problem. XESAR [RRSV87] is an example of a protocol-specific tool that employs model checking. Several approaches have been suggested for decreasing reachability analysis space requirements <ref> [BCM + 90, Hol87, GW91, Val91, HGP92] </ref>. These approaches significantly improve the feasibility of reachability methods, but in general are still prohibitively expensive to use with most distributed systems. The constrained expression approach is not based on reachability analysis [ABC + 91].
Reference: [BD87] <author> S. Budkowski and P. </author> <title> Dembinski. An introduction to Estelle: A specification language for distributed systems. Computer Networks and ISDN Systems, </title> <publisher> North-Holland, </publisher> <pages> 14 3-23, </pages> <year> 1987. </year>
Reference-contexts: Figure 2 demonstrates the principle of incremental accuracy improvement. 3.2 Protocol Design Language A number of protocol specification and design languages have been proposed, the most prominent being CCS [Mil80], Z [Spi92], LOTOS [BB87], SDL [BH89], Estelle <ref> [BD87] </ref>, and Promela [Hol91]. Our choice of Ada as a protocol design language was suggested by some positive experience with it [YGH82, CDG85] and by the fact that the current implementation of FLAVERS can process only Ada.
Reference: [BH89] <author> F. Belina and D. Hogrefe. </author> <title> The CCITT-specification and description language SDL. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 16, 4 </volume> <pages> 311-341, </pages> <year> 1989. </year>
Reference-contexts: Figure 2 demonstrates the principle of incremental accuracy improvement. 3.2 Protocol Design Language A number of protocol specification and design languages have been proposed, the most prominent being CCS [Mil80], Z [Spi92], LOTOS [BB87], SDL <ref> [BH89] </ref>, Estelle [BD87], and Promela [Hol91]. Our choice of Ada as a protocol design language was suggested by some positive experience with it [YGH82, CDG85] and by the fact that the current implementation of FLAVERS can process only Ada.
Reference: [BNY86] <author> Naser Barghouti, Nihal Nounou, and Yechiam Yemini. </author> <title> An integrated protocol development environment. </title> <booktitle> Proc. 6th int. symp. on protocol specification, testing and verification, </booktitle> <month> June 10-13, </month> <year> 1986, 1986. </year>
Reference-contexts: Reif and Smolka [RS88] demonstrate the undecidability of generating all reachable states for an arbitrary distributed program. Reachability analysis has been a popular technique for statically analyzing small protocols (e.g. <ref> [VHC86, BNY86] </ref>), but we are concerned that the inherent exponential nature of this approach will prevent it from scaling up to the analysis of larger, more complex protocols.
Reference: [BP94] <author> Gregor Bochmann and Alexandre Petrenko. </author> <title> Protocol testing: Review of methods and relevance for software testing. </title> <booktitle> In Proc. 1994 International Symposium on Software Testing and Analysis, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: Testing [ABC82] executes a program to determine whether its actual behaviors conform to its expected behaviors. Since the number of possible program executions is usually excessively large, it is impractical to use testing to demonstrate the absence of errors. Testing has been extensively applied to communication protocols <ref> [SL89, BP94] </ref>, but we believe this work should be complemented by work aimed at demonstrating the absence of errors.
Reference: [BSW69] <author> K. A. Bartlett, R. A. Scantlebury, and P. T. Wilkinson. </author> <title> A note on reliable full-duplex transmission over half-duplex lines. </title> <journal> Comm. of the ACM, </journal> <volume> 12(5) </volume> <pages> 260-265, </pages> <year> 1969. </year>
Reference-contexts: In our case study, each property was checked assuming up to the maximal number of consecutive message losses in the media. 5 Experiments This section presents the experimental results of running FLAVERS on the three-way handshake connection establishment protocol (3WHS) [KY82] and the alternating bit data transfer protocol (AB) <ref> [BSW69] </ref>. We chose these case studies for a variety of reasons. Both protocols are popular and well known, and each has been the subject of numerous verification techniques.
Reference: [CDG85] <author> R. Castanet, A. Dupeux, and P. Guitton. </author> <title> Ada, a well suited language for specification and implementation of protocols. </title> <booktitle> Proc. 5th int. symp. on protocol specification, testing and verification, </booktitle> <month> June 10-13, </month> <year> 1985, 1985. </year>
Reference-contexts: Our choice of Ada as a protocol design language was suggested by some positive experience with it <ref> [YGH82, CDG85] </ref> and by the fact that the current implementation of FLAVERS can process only Ada. The protocol design pseudocode used in our case studies defines each distributed process and each communication medium as a task, thereby simulating asynchronous message passing between protocols.
Reference: [CES86] <author> E. M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: A variation of reachability analysis, called model checking, applies to programs where distributed processes can be modeled as communicating finite state automata <ref> [CES86] </ref>. With model checking, properties are formulated as temporal logic formulas and compared to the logical representation of the program, represented by a reachability graph with temporal logic propositions assigned to the nodes.
Reference: [CFI94] <author> Gerard Cece, Alain Finkel, and S. Purishothaman Iyer. </author> <title> Duplication, insertion and lossiness errors in unreliable communication. </title> <booktitle> In Proc. of the Second ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: We propose to verify that protocols will necessarily have desired properties when they communicate through unreliable media. We do this by modeling assumptions about the communication media in the form of finite state automata that constrain the data flow analysis. Cece, Finkel and Iyer <ref> [CFI94] </ref> have addressed this with reachability techniques incorporating models of assumptions about network faults into a single FSA built for a protocol.
Reference: [Cor92] <author> James C. Corbett. </author> <title> Verifying General Safety and Liveness Properties with Integer Programming. </title> <booktitle> In Proceedings of the Fourth Workshop on Computer Aided Verification, </booktitle> <pages> pages 337-348, </pages> <year> 1992. </year>
Reference-contexts: The given pattern of program events is also represented in the form of linear inequalities. Integer linear programming is used to solve the resulting system of inequalities. The implementation of this technique has been successfully applied to some distributed systems <ref> [ABC + 91, Cor92] </ref>. However, it also has exponential worst-case bounds. To the best of our knowledge, this approach has not been applied to the analysis of protocols.
Reference: [DC94] <author> Matthew Dwyer and Lori Clarke. </author> <title> Data Flow Analysis for Verifying Properties of Concurrent Programs,. </title> <booktitle> In ACM SIGSOFT'94 Software Engineering Notes, Proceedings of the Second ACM Sigsoft Symposium on Foundations of Software Engineering, v. </booktitle> <volume> 19, </volume> <editor> n. </editor> <volume> 5, </volume> <pages> pages 62-75, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: 1 Introduction In this paper we demonstrate the applicability of an incremental accuracy improving flow analysis approach <ref> [DC94] </ref> to the verification of properties of communication protocols. We undertake a small case study where we examine two protocols and verify several properties about them. <p> We demonstrate, using message losses as an example, how these network faults can be modeled and then incorporated into the data flow analysis. In this work we apply the data flow approach to communication protocol verification, using the FLAVERS (Flow Analysis for Verifying Specifications) tool <ref> [DC94] </ref>. We evaluate the ability of FLAVERS to specify protocol requirements specifications as event sequences. We then verify that proposed pseudocode designs must adhere to these requirements even in the presence of the possibility of network faults. <p> approaches for distributed systems have been used to verify both program-independent properties, such as deadlock freedom [MR91], detecting unreachable program statements and determining the values of program expressions [RS90], and concurrent def-use faults (e.g., referencing an undefined variable or defining an unused variable) [TO80], as well as program specific properties <ref> [DC94, HS96] </ref>. As noted earlier, protocol entities must inevitably communicate through unreliable communication media, which can cause messages to be lost, duplicated, inserted, or corrupted. Protocols describe only the behavior of the logical entities, and provide no information about the medium itself.
Reference: [Dwy95] <author> Matthew Dwyer. </author> <title> Data Flow Analysis for Verifying Correctness Properties of Concurrent Programs. </title> <type> PhD thesis, </type> <institution> University of Massachussetts, Amherst, </institution> <year> 1995. </year>
Reference-contexts: Although the number of requirements and protocols examined is very modest, comparing timings for different requirements suggests some interesting tendencies. For example, verifying the passive states requirement on the 3WHS protocol confirms the hypothesis that FLAVERS analysis cost is influenced by the degree to which a requirement is centralized <ref> [Dwy95] </ref>. We call a requirement centralized when it is specified in terms of events from only a small group of distributed processes in a protocol specification. Centralized requirements are usually easier to check than non-centralized ones because fewer variables have to be modeled.
Reference: [GW91] <author> Patrice Godefroid and Pierre Wolper. </author> <title> Using partial orders for the efficient verification of deadlock freedom and safety properties. </title> <booktitle> In Proceedings of the Third Workshop on Computer Aided Verification, </booktitle> <pages> pages 417-428, </pages> <month> July </month> <year> 1991. </year> <month> 16 </month>
Reference-contexts: Properties can be formulated more flexibly than with other reachability approaches, but model checking still suffers from the state space explosion problem. XESAR [RRSV87] is an example of a protocol-specific tool that employs model checking. Several approaches have been suggested for decreasing reachability analysis space requirements <ref> [BCM + 90, Hol87, GW91, Val91, HGP92] </ref>. These approaches significantly improve the feasibility of reachability methods, but in general are still prohibitively expensive to use with most distributed systems. The constrained expression approach is not based on reachability analysis [ABC + 91].
Reference: [Hec77] <author> M.S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: The implementation of this technique has been successfully applied to some distributed systems [ABC + 91, Cor92]. However, it also has exponential worst-case bounds. To the best of our knowledge, this approach has not been applied to the analysis of protocols. Data flow analysis <ref> [Hec77] </ref> captures static information about a system by computing fixed point data and control dependency information over an annotated flow graph. Data flow analyses have been formulated with low-order polynomial execution time and storage bounds [MR90].
Reference: [HGP92] <author> G. J. Holzmann, P. Godefroid, and D. Pirottin. </author> <title> Coverage preserving reduction strategies for reachabil-ity analysis. </title> <booktitle> In Proc. 12th Int. Conf on Protocol Specification, Testing, and Verification, </booktitle> <address> INWG/IFIP, Orlando, Fl., </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Properties can be formulated more flexibly than with other reachability approaches, but model checking still suffers from the state space explosion problem. XESAR [RRSV87] is an example of a protocol-specific tool that employs model checking. Several approaches have been suggested for decreasing reachability analysis space requirements <ref> [BCM + 90, Hol87, GW91, Val91, HGP92] </ref>. These approaches significantly improve the feasibility of reachability methods, but in general are still prohibitively expensive to use with most distributed systems. The constrained expression approach is not based on reachability analysis [ABC + 91].
Reference: [Hoa69] <author> C.A.R. Hoare. </author> <title> An Axiomatic Basis of Computer Programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: Testing has been extensively applied to communication protocols [SL89, BP94], but we believe this work should be complemented by work aimed at demonstrating the absence of errors. Formal verification systems <ref> [Hoa69, Pnu77] </ref> employ mathematical systems with rules of inference to prove the absence of errors by showing analytically, without actual execution of the program, that a program satisfies or contradicts a given property.
Reference: [Hol87] <author> Gerard J. Holzmann. </author> <title> On limits and possibilities of automated protocol analysis. Protocol Specification, Testing and Verification VII, </title> <booktitle> IFIP 1987, </booktitle> <pages> pages 339-344, </pages> <year> 1987. </year>
Reference-contexts: Properties can be formulated more flexibly than with other reachability approaches, but model checking still suffers from the state space explosion problem. XESAR [RRSV87] is an example of a protocol-specific tool that employs model checking. Several approaches have been suggested for decreasing reachability analysis space requirements <ref> [BCM + 90, Hol87, GW91, Val91, HGP92] </ref>. These approaches significantly improve the feasibility of reachability methods, but in general are still prohibitively expensive to use with most distributed systems. The constrained expression approach is not based on reachability analysis [ABC + 91].
Reference: [Hol91] <author> Gerard J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall Software Series, </publisher> <year> 1991. </year>
Reference-contexts: Figure 2 demonstrates the principle of incremental accuracy improvement. 3.2 Protocol Design Language A number of protocol specification and design languages have been proposed, the most prominent being CCS [Mil80], Z [Spi92], LOTOS [BB87], SDL [BH89], Estelle [BD87], and Promela <ref> [Hol91] </ref>. Our choice of Ada as a protocol design language was suggested by some positive experience with it [YGH82, CDG85] and by the fact that the current implementation of FLAVERS can process only Ada.
Reference: [HS96] <author> W. E. Howden and G. M. Shi. </author> <title> Linear and structural event sequence analysis. </title> <booktitle> In ISSTA, </booktitle> <year> 1996. </year>
Reference-contexts: approaches for distributed systems have been used to verify both program-independent properties, such as deadlock freedom [MR91], detecting unreachable program statements and determining the values of program expressions [RS90], and concurrent def-use faults (e.g., referencing an undefined variable or defining an unused variable) [TO80], as well as program specific properties <ref> [DC94, HS96] </ref>. As noted earlier, protocol entities must inevitably communicate through unreliable communication media, which can cause messages to be lost, duplicated, inserted, or corrupted. Protocols describe only the behavior of the logical entities, and provide no information about the medium itself.
Reference: [KY82] <author> James F. Kurose and Yechiam Yemini. </author> <title> The specification and verification of a connection establishment protocol using temporal logic. </title> <booktitle> Proc. 2nd int. workshop on protocol specification, testing and verification, </booktitle> <month> May 17-20, </month> <year> 1982. </year>
Reference-contexts: Examples of the application of formal verification to the analysis of communication protocols are numerous. Kurose and Yemini <ref> [KY82] </ref> use temporal logic [Pnu77] to prove properties of a reliable connection establishment protocol, Sabnani and Schwartz [SS82] build the proof of properties of a multi-destination message transfer protocol using temporal logic, and Yodaiken and Ramamritham [YR92] prove some properties of a fault-tolerant broadcast protocol using functional specifications and relations semantics. <p> This behavior causes a livelock, with one protocol entity sending messages that are always lost by the medium, causing the entity to resend them indefinitely. To exclude such worst-case scenarios from consideration, fairness assumptions about the medium are usually made. For example, Kurose and Yemini <ref> [KY82] </ref> state that a medium is fair with respect to a message m if it can lose, corrupt or duplicate m at most a finite number of times before passing it without a fault. A medium is fair if it is fair with respect to any message it receives. <p> In our case study, each property was checked assuming up to the maximal number of consecutive message losses in the media. 5 Experiments This section presents the experimental results of running FLAVERS on the three-way handshake connection establishment protocol (3WHS) <ref> [KY82] </ref> and the alternating bit data transfer protocol (AB) [BSW69]. We chose these case studies for a variety of reasons. Both protocols are popular and well known, and each has been the subject of numerous verification techniques. <p> Kurose and Yemini <ref> [KY82] </ref> verified this requirement for 3WHS design pseudocode by manually constructing a formal proof. This requirement must hold on all possible executions of the protocol.
Reference: [Mil80] <author> Robin Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> Vol.92. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year> <note> Appeared as vol. 92, Lecture Notes in Computer Science. </note>
Reference-contexts: Figure 2 demonstrates the principle of incremental accuracy improvement. 3.2 Protocol Design Language A number of protocol specification and design languages have been proposed, the most prominent being CCS <ref> [Mil80] </ref>, Z [Spi92], LOTOS [BB87], SDL [BH89], Estelle [BD87], and Promela [Hol91]. Our choice of Ada as a protocol design language was suggested by some positive experience with it [YGH82, CDG85] and by the fact that the current implementation of FLAVERS can process only Ada.
Reference: [MR90] <author> T. J. Marlowe and B. G. Ryder. </author> <title> Properties of Data Flow Frameworks. </title> <journal> Acta Informatica, </journal> (28):121-163, 1990. 
Reference-contexts: Data flow analysis [Hec77] captures static information about a system by computing fixed point data and control dependency information over an annotated flow graph. Data flow analyses have been formulated with low-order polynomial execution time and storage bounds <ref> [MR90] </ref>.
Reference: [MR91] <author> S.P. Masticola and B.G. Ryder. </author> <title> A Model of Ada Programs for Static Deadlock Detection in Polynomial Time. </title> <booktitle> In Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 97-107. </pages> <publisher> ACM, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Data flow analyses have been formulated with low-order polynomial execution time and storage bounds [MR90]. Data flow based approaches for distributed systems have been used to verify both program-independent properties, such as deadlock freedom <ref> [MR91] </ref>, detecting unreachable program statements and determining the values of program expressions [RS90], and concurrent def-use faults (e.g., referencing an undefined variable or defining an unused variable) [TO80], as well as program specific properties [DC94, HS96].
Reference: [OO90] <author> Kurt M. Olender and Leon J. Osterweil. Cecil: </author> <title> A Sequencing Constraint Language for Automatic Static Analysis Generation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 268-280, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: In addition, this section summarizes the overall results. Finally, section 6 offers some conclusions based on the results and also indicates directions for future work. 1 2 Related Work Olender and Osterweil <ref> [OO90] </ref> suggest that there are two fundamental approaches to increasing confidence in software: detection (and removal) of errors and demonstration of the absence of errors. Both entail determining if a given software artifact (e.g., design or code) is consistent with specified properties. <p> The result seemed essentially equivalent to the TFG representation of the Ada design. We believe that such equivalence would hold between Ada and Promela representations for other protocol designs as well. 3.3 Property Specification Language FLAVERS uses Quantified Regular Expressions (QRE), first used in the property specification language CECIL <ref> [OO90] </ref>, to specify the event sequences to which communication protocol designs must adhere. A QRE represents a property as a regular language over the set of events used to define the protocol design. QREs have three components: an event alphabet, a quantifier, and the regular expression. <p> A number of directions for improving the current implementation of FLAVERS have been uncovered by the experiments. The ability to handle liveness conditions would allow verification of a broader class of protocol requirements specifications. One of the ways to address this problem is to introduce anchored quantified regular expressions <ref> [OO90] </ref>, which allow the analysis to be restricted to a particular part of the TFG. Another drawback of the FLAVERS implementation is its limitation in supporting variable modeling. Only boolean variables can now be modeled automatically.
Reference: [Pac87] <author> Jan Pachl. </author> <title> Protocol description and analysis based on a state transition model with channel expressions. Protocol Specification, Testing and Verification VII, </title> <booktitle> IFIP 1987, </booktitle> <pages> pages 207-219, </pages> <year> 1987. </year>
Reference-contexts: A disadvantage of this approach is that assumptions about the protocol environment and protocol execution behaviors protocol are combined into a single model that must be rebuilt every time the assumptions about either change. Pachl <ref> [Pac87] </ref> uses state automata to model communication channels during reachability analysis with separate FSAs representing distributed processes and the assumptions about communication channels. We adopt this approach in our own data flow analysis.
Reference: [Pnu77] <author> Amir Pnueli. </author> <title> The Temporal Logic of Programs. </title> <booktitle> In Proceedings of the Eighteenth Symposium on Foundations of Computer Science, </booktitle> <address> Providence, </address> <year> 1977, </year> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: Testing has been extensively applied to communication protocols [SL89, BP94], but we believe this work should be complemented by work aimed at demonstrating the absence of errors. Formal verification systems <ref> [Hoa69, Pnu77] </ref> employ mathematical systems with rules of inference to prove the absence of errors by showing analytically, without actual execution of the program, that a program satisfies or contradicts a given property. <p> Examples of the application of formal verification to the analysis of communication protocols are numerous. Kurose and Yemini [KY82] use temporal logic <ref> [Pnu77] </ref> to prove properties of a reliable connection establishment protocol, Sabnani and Schwartz [SS82] build the proof of properties of a multi-destination message transfer protocol using temporal logic, and Yodaiken and Ramamritham [YR92] prove some properties of a fault-tolerant broadcast protocol using functional specifications and relations semantics.
Reference: [RRSV87] <author> J. L. Richier, C. Rodriguez, J. Sifakis, and J. Voiron. </author> <title> Verification in Xesar of the sliding window protocol. Protocol Specification, Testing and Verification VII, </title> <booktitle> IFIP 1987, </booktitle> <pages> pages 235-248, </pages> <year> 1987. </year>
Reference-contexts: Properties can be formulated more flexibly than with other reachability approaches, but model checking still suffers from the state space explosion problem. XESAR <ref> [RRSV87] </ref> is an example of a protocol-specific tool that employs model checking. Several approaches have been suggested for decreasing reachability analysis space requirements [BCM + 90, Hol87, GW91, Val91, HGP92].
Reference: [RS88] <author> J. Reif and S. Smolka. </author> <title> The Complexity of Reachability in Distributed Communicating Processes. </title> <journal> Acta Informatica, </journal> <volume> 25(3) </volume> <pages> 333-354, </pages> <year> 1988. </year>
Reference-contexts: Taylor [Tay83] shows that generating all reachable states for a program with a fixed number of communicating tasks is exponential in the number of tasks. Reif and Smolka <ref> [RS88] </ref> demonstrate the undecidability of generating all reachable states for an arbitrary distributed program.
Reference: [RS90] <author> John H. Reif and Scott A. Smolka. </author> <title> Data flow analysis of distributed communicating processes. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 19(1), </volume> <year> 1990. </year>
Reference-contexts: Data flow analyses have been formulated with low-order polynomial execution time and storage bounds [MR90]. Data flow based approaches for distributed systems have been used to verify both program-independent properties, such as deadlock freedom [MR91], detecting unreachable program statements and determining the values of program expressions <ref> [RS90] </ref>, and concurrent def-use faults (e.g., referencing an undefined variable or defining an unused variable) [TO80], as well as program specific properties [DC94, HS96]. As noted earlier, protocol entities must inevitably communicate through unreliable communication media, which can cause messages to be lost, duplicated, inserted, or corrupted.
Reference: [SL89] <author> Deepinder P. Sidhu and Ting-Kau Leung. </author> <title> Formal methods for protocol testing: A detailed study. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(4) </volume> <pages> 413-426, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Testing [ABC82] executes a program to determine whether its actual behaviors conform to its expected behaviors. Since the number of possible program executions is usually excessively large, it is impractical to use testing to demonstrate the absence of errors. Testing has been extensively applied to communication protocols <ref> [SL89, BP94] </ref>, but we believe this work should be complemented by work aimed at demonstrating the absence of errors.
Reference: [Spi92] <author> J. M. Spivey. </author> <title> The Z Notation A Reference Manual. Prentice Hall, </title> <booktitle> International Series in Computer Science, </booktitle> <year> 1992. </year>
Reference-contexts: Figure 2 demonstrates the principle of incremental accuracy improvement. 3.2 Protocol Design Language A number of protocol specification and design languages have been proposed, the most prominent being CCS [Mil80], Z <ref> [Spi92] </ref>, LOTOS [BB87], SDL [BH89], Estelle [BD87], and Promela [Hol91]. Our choice of Ada as a protocol design language was suggested by some positive experience with it [YGH82, CDG85] and by the fact that the current implementation of FLAVERS can process only Ada.
Reference: [SS82] <author> Krishan Sabnani and Mischa Schwartz. </author> <title> Verification of a multidestination protocol using temporal logic. </title> <booktitle> Proc. 2nd int. workshop on protocol specification, testing and verification, </booktitle> <month> May 17-20, </month> <year> 1982. </year>
Reference-contexts: Examples of the application of formal verification to the analysis of communication protocols are numerous. Kurose and Yemini [KY82] use temporal logic [Pnu77] to prove properties of a reliable connection establishment protocol, Sabnani and Schwartz <ref> [SS82] </ref> build the proof of properties of a multi-destination message transfer protocol using temporal logic, and Yodaiken and Ramamritham [YR92] prove some properties of a fault-tolerant broadcast protocol using functional specifications and relations semantics.
Reference: [Tay83] <author> Richard N. Taylor. </author> <title> Complexity of Analyzing the Synchronization Structure of Concurrent Programs. </title> <journal> Acta Informatica, </journal> <volume> 19 </volume> <pages> 57-84, </pages> <year> 1983. </year>
Reference-contexts: The number of reachable states often causes a so-called state explosion, where reachability space size exceeds the processing power or the memory capacity of the machine. Taylor <ref> [Tay83] </ref> shows that generating all reachable states for a program with a fixed number of communicating tasks is exponential in the number of tasks. Reif and Smolka [RS88] demonstrate the undecidability of generating all reachable states for an arbitrary distributed program.
Reference: [TO80] <author> Richard N. Taylor and L. J. Osterweil. </author> <title> Anomaly Detection in Concurrent Software by Static Data Flow Analysis. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(3) </volume> <pages> 265-278, </pages> <month> May </month> <year> 1980. </year>
Reference-contexts: Data flow based approaches for distributed systems have been used to verify both program-independent properties, such as deadlock freedom [MR91], detecting unreachable program statements and determining the values of program expressions [RS90], and concurrent def-use faults (e.g., referencing an undefined variable or defining an unused variable) <ref> [TO80] </ref>, as well as program specific properties [DC94, HS96]. As noted earlier, protocol entities must inevitably communicate through unreliable communication media, which can cause messages to be lost, duplicated, inserted, or corrupted. Protocols describe only the behavior of the logical entities, and provide no information about the medium itself.
Reference: [Val91] <author> A. Valmari. </author> <title> A Stubborn Attack on State Explosion. </title> <editor> In Edmund M. Clarke and R.P. Kurshan, editors, </editor> <booktitle> Computer-Aided Verification 90, </booktitle> <pages> pages 25-41. </pages> <publisher> American Mathematical Society, </publisher> <address> Providence RI, </address> <year> 1991. </year> <booktitle> Number 3 in DIMACS Series in Discrete Mathematics and Theoretical Computer Science. </booktitle>
Reference-contexts: Properties can be formulated more flexibly than with other reachability approaches, but model checking still suffers from the state space explosion problem. XESAR [RRSV87] is an example of a protocol-specific tool that employs model checking. Several approaches have been suggested for decreasing reachability analysis space requirements <ref> [BCM + 90, Hol87, GW91, Val91, HGP92] </ref>. These approaches significantly improve the feasibility of reachability methods, but in general are still prohibitively expensive to use with most distributed systems. The constrained expression approach is not based on reachability analysis [ABC + 91].
Reference: [VHC86] <author> Son T. Vuong, Daniel D. Hui, and Don D. Cowan. </author> <title> Valira | a tool for protocol validation via reachability analysis. </title> <booktitle> Proc. 6th int. symp. on protocol specification, testing and verification, </booktitle> <month> June 10-13, </month> <year> 1986, 1986. </year> <month> 17 </month>
Reference-contexts: Reif and Smolka [RS88] demonstrate the undecidability of generating all reachable states for an arbitrary distributed program. Reachability analysis has been a popular technique for statically analyzing small protocols (e.g. <ref> [VHC86, BNY86] </ref>), but we are concerned that the inherent exponential nature of this approach will prevent it from scaling up to the analysis of larger, more complex protocols.
Reference: [YGH82] <author> Larry Yelowitz, Susan Gerhart, and G. Hilborn. </author> <title> Modeling a network protocol in affirm and ada. </title> <booktitle> Proc. 2nd int. workshop on protocol specification, testing and verification, </booktitle> <month> May 17-20, </month> <year> 1982, 1982. </year>
Reference-contexts: Our choice of Ada as a protocol design language was suggested by some positive experience with it <ref> [YGH82, CDG85] </ref> and by the fact that the current implementation of FLAVERS can process only Ada. The protocol design pseudocode used in our case studies defines each distributed process and each communication medium as a task, thereby simulating asynchronous message passing between protocols.
Reference: [YR92] <author> V. Yodaiken and Krithi Ramamritham. </author> <title> Verification of a Reliable Net Protocol. In Formal Techniques in Real-Time and Fault-Tolerant Systems, </title> <booktitle> Lecture Notes in Computer Science No. </booktitle> <volume> 571, </volume> <pages> pages 193-215. </pages> <publisher> Springer-Verlag,, </publisher> <year> 1992. </year> <month> 18 </month>
Reference-contexts: Kurose and Yemini [KY82] use temporal logic [Pnu77] to prove properties of a reliable connection establishment protocol, Sabnani and Schwartz [SS82] build the proof of properties of a multi-destination message transfer protocol using temporal logic, and Yodaiken and Ramamritham <ref> [YR92] </ref> prove some properties of a fault-tolerant broadcast protocol using functional specifications and relations semantics. Static analysis, like formal verification, can demonstrate the absence of certain classes of errors from distributed systems without actually executing them.
References-found: 41

