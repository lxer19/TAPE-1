URL: http://www.dfki.uni-kl.de/~vega/relfun+/RFM-Manual/RFM-Manual.ps
Refering-URL: http://www.dfki.uni-kl.de/~vega/relfun.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: RFM Manual: Compiling RELFUN into the Relational/Functional Machine  
Author: Harold Boley, Klaus Elsbernd, Hans-Gunther Hein, Thomas Krause, Markus Perling, Michael Sintek, Werner Stein 
Date: July 1996  
Note: Third, Revised Edition  
Address: 67663 Kaiserslautern Germany  
Affiliation: DFKI Universitat Kaiserslautern Erwin-Schrodinger-Strae  
Abstract: The compilation of RELFUN programs consists of two main stages, horizontal transformations and vertical translations. The horizontal transformer performs both source-to-source steps into a subset of RELFUN and source-to-intermediate steps into a RELFUN-like language. The vertical translator is also divided into two phases, the classifier and the code generator. The classifier produces a declarative clause language; the code generator optimizes target code for underlying WAM emulators. These parts can be used incrementally-individually, as a relational/functional compilation laboratory, or batch-composed, as a complete RELFUN compiler. All intermediate steps employ explicit declarative representations, which can be displayed via RELFUN's user interface. The compiler is implemented in a subset of COMMON LISP; one emulator runs in COMMON LISP, the other in ANSI C. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> References </institution>
Reference: [AK91] <author> Hassan Ait-Kaci. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: The GWAM is built in COMMON LISP on a general implementation platform, the GAMA (General Abstract Machine [Sin95]), which contains a debugger, an assembler, and a loader. The second emulator is called RAWAM (Relfun Adapted WAM), more based on <ref> [AK91] </ref>, and built in ANSI C [Per96]. It is assumed that the reader be somewhat familiar with RELFUN (see [BAE + 96]), and with WAM architectures ([War83], [AK91], [VR94]). For further information about the RFM see [Bol92] [Kra90], [Hei89], [Els90]. <p> The second emulator is called RAWAM (Relfun Adapted WAM), more based on <ref> [AK91] </ref>, and built in ANSI C [Per96]. It is assumed that the reader be somewhat familiar with RELFUN (see [BAE + 96]), and with WAM architectures ([War83], [AK91], [VR94]). For further information about the RFM see [Bol92] [Kra90], [Hei89], [Els90]. The user interface of the RFM is described in section 2. The horizontal transformations are the subject of section 3.1.
Reference: [BAE + 96] <author> Harold Boley, Simone Andel, Klaus Elsbernd, Michael Herfert, Michael Sintek, and Werner Stein. </author> <title> RELFUN Guide: Programming with Relations and Functions Made Easy. Document D-93-12, </title> <institution> DFKI GmbH, </institution> <month> July </month> <year> 1996. </year> <note> Second, Revised Edition. </note>
Reference-contexts: The second emulator is called RAWAM (Relfun Adapted WAM), more based on [AK91], and built in ANSI C [Per96]. It is assumed that the reader be somewhat familiar with RELFUN (see <ref> [BAE + 96] </ref>), and with WAM architectures ([War83], [AK91], [VR94]). For further information about the RFM see [Bol92] [Kra90], [Hei89], [Els90]. The user interface of the RFM is described in section 2. The horizontal transformations are the subject of section 3.1.
Reference: [Bol90] <author> Harold Boley. </author> <title> A relational/functional Language and its Compilation into the WAM. </title> <type> SEKI Report SR-90-05, </type> <institution> Universitat Kaiserslautern, </institution> <year> 1990. </year>
Reference-contexts: The following subsections are ordered according to their position in the command hierarchy of section 2, where the flatten command (subsection 3.2.2) just serves to prepare the flatter command (subsection 3.2.3). Most material in subsections 3.2.2, 3.2.3, and 3.2.7 is taken from <ref> [Bol90] </ref>. 3.2.1 Untupling Untupling (command: untup) replaces both active and passive n-ary tups by corresponding binary cns nestings, where the empty tup becomes the distinguished constant nil. This transformation, similar to list parsing in LISP's read, prepares PROLOG-like list allocation in the GWAM.
Reference: [Bol92] <author> Harold Boley. </author> <title> Extended Logic-plus-Functional Programming. </title> <editor> In Lars-Henrik Eriksson, Lars Hallnas, and Peter Schroeder-Heister, editors, </editor> <booktitle> Proceedings of the 2nd International Workshop on Extensions of Logic Programming, ELP '91, Stockholm 1991, volume 596 of LNAI. </booktitle> <publisher> Springer, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction This work describes the compilation and execution environment of the Relational/Functional Machine (RFM). The RFM is a LISP/C-based implementation of RELFUN <ref> [Bol92] </ref> and consists of an interpreter, a multi-pass compiler, and two emulators. The compilation of RELFUN programs consists of two main stages, horizontal transformations and vertical translations. <p> The second emulator is called RAWAM (Relfun Adapted WAM), more based on [AK91], and built in ANSI C [Per96]. It is assumed that the reader be somewhat familiar with RELFUN (see [BAE + 96]), and with WAM architectures ([War83], [AK91], [VR94]). For further information about the RFM see <ref> [Bol92] </ref> [Kra90], [Hei89], [Els90]. The user interface of the RFM is described in section 2. The horizontal transformations are the subject of section 3.1. Sections 4 and 5 treat the classifier and code generator for vertical translations; sections 6 and 7, the GAMA and the embedded GWAM emulator.
Reference: [Els90] <author> Klaus Elsbernd. </author> <title> Effizienzvergleiche zwischen einer LISP- und C-codierten WAM. </title> <note> SEKI Working Paper SWP-90-03, </note> <institution> Universitat Kaiserslautern, Fachbereich Informatik, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: It is assumed that the reader be somewhat familiar with RELFUN (see [BAE + 96]), and with WAM architectures ([War83], [AK91], [VR94]). For further information about the RFM see [Bol92] [Kra90], [Hei89], <ref> [Els90] </ref>. The user interface of the RFM is described in section 2. The horizontal transformations are the subject of section 3.1. Sections 4 and 5 treat the classifier and code generator for vertical translations; sections 6 and 7, the GAMA and the embedded GWAM emulator. <p> This LISP-based implementation has been complemented by two WAM emulators in C: Klaus Elsbernd's rudimentary C emulator <ref> [Els90] </ref> has now been replaced by Markus Perling's complete first-order emulator. Leaving the layered compiler 48 7 THE GWAM system in LISP (for flexibility and short turnaround times), but having the emulator in C, seems to be a good combination under UNIX.
Reference: [Hei89] <author> Hans-Gunther Hein. </author> <title> Adding WAM-Instructions to Support Valued Clauses for the Relational/Functional Language RELFUN. </title> <note> SEKI Working Paper SWP-90-02, </note> <institution> Universitat Kaiserslautern, Fachbereich Informatik, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: But organizing the compiler into such steps enhances its modularity and readability, which helps in the development of optimizations of execution time, our main concern. Both emulators are extensions of the WAM (Warren Abstract Machine). The first emulator is called GWAM (Generalized WAM [Sin95]), the successor to the NyWAM <ref> [Hei89] </ref>, which originated from Nystrtm's WAM [Nys]. The GWAM is built in COMMON LISP on a general implementation platform, the GAMA (General Abstract Machine [Sin95]), which contains a debugger, an assembler, and a loader. <p> It is assumed that the reader be somewhat familiar with RELFUN (see [BAE + 96]), and with WAM architectures ([War83], [AK91], [VR94]). For further information about the RFM see [Bol92] [Kra90], <ref> [Hei89] </ref>, [Els90]. The user interface of the RFM is described in section 2. The horizontal transformations are the subject of section 3.1. Sections 4 and 5 treat the classifier and code generator for vertical translations; sections 6 and 7, the GAMA and the embedded GWAM emulator. <p> In [Sin95], it was used to integrate an existing implementation of the WAM (our development of the NyWAM [Nys], <ref> [Hei89] </ref>) with the LLAMA [Sin95]).
Reference: [Hei91] <author> Hans-Gunther Hein. </author> <title> WAM indexing and footening techniques for RELFUN | a case study on the DNF benchmark. </title> <type> ARC-TEC Discussion Paper 91-11, </type> <institution> DFKI Kaiserslautern, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: While in general this requires global analysis, for the important special case of tail-recursion optimization the analysis can be confined to individual procedures. Benchmark results for the latter case can be found in <ref> [Hei91] </ref>. 4.1 Procedure level 17 of an unordered set of procedures each consisting of an ordered set of clauses. All clauses of one procedure have the same name and arity. Name and arity yield the procedure name `name/arity'. For example, the clause foo (V,W) belongs to the procedure foo/2.
Reference: [Her92] <author> Michael Herfert. </author> <title> Parsen und Generieren der PROLOG-artigen Syntax von RELFUN. </title> <type> Technical Report D-92-23, </type> <institution> DFKI GmbH, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: The suffix of the prompt is "-p&gt;" or "-l&gt;", respectively, when the system is running in PROLOG or LISP style (see <ref> [Her92] </ref>). The code obtained is stored under the name main, the data structures for the variables in the query are created and their names and locations are memorized to get the variable names when the goal succeeds.
Reference: [Kra90] <author> Thomas Krause. Klassifizierte relational/funktionale Klauseln: </author> <title> Eine deklarative Zwischensprache zur Generierung von Register-optimierten WAM-Instruktionen. </title> <note> SEKI Working Paper SWP-90-04, </note> <institution> Universitat Kaiserslautern, Fachbereich Informatik, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: The second emulator is called RAWAM (Relfun Adapted WAM), more based on [AK91], and built in ANSI C [Per96]. It is assumed that the reader be somewhat familiar with RELFUN (see [BAE + 96]), and with WAM architectures ([War83], [AK91], [VR94]). For further information about the RFM see [Bol92] <ref> [Kra90] </ref>, [Hei89], [Els90]. The user interface of the RFM is described in section 2. The horizontal transformations are the subject of section 3.1. Sections 4 and 5 treat the classifier and code generator for vertical translations; sections 6 and 7, the GAMA and the embedded GWAM emulator. <p> The following short introduction is based on the current implementation status of the Classified Clauses. A more detailed introduction of an earlier version is presented (in German) in <ref> [Kra90] </ref>. This section briefly describes the Classified Clauses by stepwise refinement; in section 4.7 the description grammar is given in an EBNF syntax. In Classified Clauses we distinguish six levels of description, namely the database, procedure, clause, chunk, literal, and term levels.
Reference: [Kra91] <institution> Thomas Krause. Globale Datenfluanalyse und horizontale Compilation der relational-funktionalen Sprache RELFUN. Diplomarbeit, DFKI D-91-08, Universitat Kaiserslautern, FB Informatik, </institution> <address> Postfach 3049, D-6750 Kaiserslautern, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: ([],_) :- & tup (). rfi-p&gt; az listn ([L],E) :- & tup (E|listn (L,E)). rfi-p&gt; deanon rfi-p&gt; listing listn ([],_1) :- & tup (). listn ([L],E) :- & tup (E|listn (L,E)). 3.2.6 Normalizing Normalizing (command: normalize) performs several partial-evaluation-like transformations such as the propagation of passive right-hand sides of is-calls <ref> [Kra91] </ref>. For example, the constant V-binding in f (V,W) :- V is a & V. leads to f (a,W) :- & a. <p> The first step we show is the flattening and normalizing that precedes (as part of the horizon command, cf. section 3.2) the compilation before classified clauses are generated (see <ref> [Kra91] </ref> and section 2). Prolog-like source: bar (R,S). Leads after flattering and normalizing to: 28 4 THE CLASSIFIER bar (R,S).
Reference: [Nys] <author> Sven Olof Nystrtm. </author> <title> Nywam a WAM emulator written in LISP. </title>
Reference-contexts: Both emulators are extensions of the WAM (Warren Abstract Machine). The first emulator is called GWAM (Generalized WAM [Sin95]), the successor to the NyWAM [Hei89], which originated from Nystrtm's WAM <ref> [Nys] </ref>. The GWAM is built in COMMON LISP on a general implementation platform, the GAMA (General Abstract Machine [Sin95]), which contains a debugger, an assembler, and a loader. The second emulator is called RAWAM (Relfun Adapted WAM), more based on [AK91], and built in ANSI C [Per96]. <p> In [Sin95], it was used to integrate an existing implementation of the WAM (our development of the NyWAM <ref> [Nys] </ref>, [Hei89]) with the LLAMA [Sin95]). <p> 1 263896: get x variable 2 1 put y value 1 1 263897: put y value 1 1 deallocate 263898: deallocate cl-func * 2 263899: cl-func * 2 proceed 263900: proceed .end 7 The GWAM The GWAM is derived from a LISP-based emulator that was originally obtained from Sven-Olof Nystrtm <ref> [Nys] </ref>, Uppsala University; it was modified to work within our relational-functional compilation approach RFM. This LISP-based implementation has been complemented by two WAM emulators in C: Klaus Elsbernd's rudimentary C emulator [Els90] has now been replaced by Markus Perling's complete first-order emulator.
Reference: [Per96] <author> Markus Perling. </author> <title> RAWAM a Relfun Adapted WAM, 1996. </title> <type> REFERENCES 63 </type>
Reference-contexts: The GWAM is built in COMMON LISP on a general implementation platform, the GAMA (General Abstract Machine [Sin95]), which contains a debugger, an assembler, and a loader. The second emulator is called RAWAM (Relfun Adapted WAM), more based on [AK91], and built in ANSI C <ref> [Per96] </ref>. It is assumed that the reader be somewhat familiar with RELFUN (see [BAE + 96]), and with WAM architectures ([War83], [AK91], [VR94]). For further information about the RFM see [Bol92] [Kra90], [Hei89], [Els90]. The user interface of the RFM is described in section 2.
Reference: [Sin93] <author> Michael Sintek. </author> <title> Indexing PROLOG procedures into DAGs by heuristic classification. </title> <note> DFKI Technical Memo TM-93-05, </note> <institution> DFKI GmbH, </institution> <year> 1993. </year>
Reference-contexts: ) (seqind (arg 2 (info 2) (const (beta (clauses 1)) (gamma (clauses 2))) (struct) (list) (nil) ) (arg 1 (info 1) (const (alpha (clauses 1 2))) (struct) (list) (nil) (other (clauses 2)) ) ) ) ) . . .) Here we insert a more complete example from a propositional nor-malizer <ref> [Sin93] </ref>: Prolog-like source: norm (X, X) :- literal (X). norm (or [X, Y], or [X, Y]) :- literal (X), literal (Y). norm (and [X, Y], and [X, Y]) :- literal (X), literal (Y). norm (or [X, Y], or [X1, Y]) :- literal (Y), norm (X, X1). norm (or [X, or [Y, <p> 3 5 7 8 9))) ; and for norm (..,and [..]) (list) ; no list as 2nd arg (nil) ; no [] as 2nd arg (other (clauses 1 5 8)) ) ) ) ) ; variable as 2nd arg . . . ) Remark: For further information about indexing see <ref> [Ste93, Sin93, SS92] </ref>. 4.3 Clause level Syntax: clause classification ::= (clause type cut info perm var list temp var list chunk sequence) chunk sequence ::= head chunk fact j head chunk rule body chunk list cut info ::= (cut-info cut type) perm var list ::= (perm fglobal perm var descrg*) temp
Reference: [Sin95] <author> Michael Sintek. </author> <title> FLIP: Functional-plus-logic programming on an integrated platform. </title> <type> Technical Memo TM-95-02, </type> <institution> DFKI GmbH, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: But organizing the compiler into such steps enhances its modularity and readability, which helps in the development of optimizations of execution time, our main concern. Both emulators are extensions of the WAM (Warren Abstract Machine). The first emulator is called GWAM (Generalized WAM <ref> [Sin95] </ref>), the successor to the NyWAM [Hei89], which originated from Nystrtm's WAM [Nys]. The GWAM is built in COMMON LISP on a general implementation platform, the GAMA (General Abstract Machine [Sin95]), which contains a debugger, an assembler, and a loader. <p> Both emulators are extensions of the WAM (Warren Abstract Machine). The first emulator is called GWAM (Generalized WAM <ref> [Sin95] </ref>), the successor to the NyWAM [Hei89], which originated from Nystrtm's WAM [Nys]. The GWAM is built in COMMON LISP on a general implementation platform, the GAMA (General Abstract Machine [Sin95]), which contains a debugger, an assembler, and a loader. The second emulator is called RAWAM (Relfun Adapted WAM), more based on [AK91], and built in ANSI C [Per96]. <p> While the order shown in the command hierarchy of section 2 need not be obeyed totally, in the following we use it as the canonical order rather than indicating more detailed dependencies. 1 There is one additional prompt, "ll&gt;", for LISP light (see <ref> [Sin95] </ref>) 3.1 The extron transformers 7 3.1 The extron transformers These transformations principally reduce language extensions to an unextended kernel. <p> In <ref> [Sin95] </ref>, it was used to integrate an existing implementation of the WAM (our development of the NyWAM [Nys], [Hei89]) with the LLAMA [Sin95]). <p> In <ref> [Sin95] </ref>, it was used to integrate an existing implementation of the WAM (our development of the NyWAM [Nys], [Hei89]) with the LLAMA [Sin95]). <p> The following functions are defined on hash tables: 10 This chapter is completely adopted from chapter 7, "Integrating Abstract Machines: The GAMA" in <ref> [Sin95] </ref>. 11 The GAMA is implemented in COMMON LISP; in order to avoid name conflicts, function names are preceded by a prefix `mod.' indicating that a function belongs to module mod, here gmem (we did not use the COMMON LISP package system). 44 6 THE GAMA * (gmht.make-ht n) returns a
Reference: [SS92] <author> Werner Stein and Michael Sintek. </author> <title> A generalized intelligent indexing method. </title> <booktitle> In Workshop "Sprachen fur KI-Anwendungen, Konzepte - Methoden - Implementierungen" in Bad Honnef, </booktitle> <pages> 12/92-1. </pages> <institution> Institute of Applied Mathematics and Computer Science, University of Munster, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: 3 5 7 8 9))) ; and for norm (..,and [..]) (list) ; no list as 2nd arg (nil) ; no [] as 2nd arg (other (clauses 1 5 8)) ) ) ) ) ; variable as 2nd arg . . . ) Remark: For further information about indexing see <ref> [Ste93, Sin93, SS92] </ref>. 4.3 Clause level Syntax: clause classification ::= (clause type cut info perm var list temp var list chunk sequence) chunk sequence ::= head chunk fact j head chunk rule body chunk list cut info ::= (cut-info cut type) perm var list ::= (perm fglobal perm var descrg*) temp
Reference: [Ste93] <author> Werner Stein. </author> <title> Indexing Principles for Relational Languages Applied to PROLOG Code Generation. </title> <type> Technical Report Document D-92-22, </type> <institution> DFKI GmbH, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: 3 5 7 8 9))) ; and for norm (..,and [..]) (list) ; no list as 2nd arg (nil) ; no [] as 2nd arg (other (clauses 1 5 8)) ) ) ) ) ; variable as 2nd arg . . . ) Remark: For further information about indexing see <ref> [Ste93, Sin93, SS92] </ref>. 4.3 Clause level Syntax: clause classification ::= (clause type cut info perm var list temp var list chunk sequence) chunk sequence ::= head chunk fact j head chunk rule body chunk list cut info ::= (cut-info cut type) perm var list ::= (perm fglobal perm var descrg*) temp
Reference: [VR94] <author> Peter Van Roy. </author> <year> 1983-1993: </year> <title> The wonder years of sequential Prolog implementation. </title> <journal> The Journal of Logic Programming, </journal> <volume> 19,20:385-441, </volume> <year> 1994. </year>
Reference-contexts: The second emulator is called RAWAM (Relfun Adapted WAM), more based on [AK91], and built in ANSI C [Per96]. It is assumed that the reader be somewhat familiar with RELFUN (see [BAE + 96]), and with WAM architectures ([War83], [AK91], <ref> [VR94] </ref>). For further information about the RFM see [Bol92] [Kra90], [Hei89], [Els90]. The user interface of the RFM is described in section 2. The horizontal transformations are the subject of section 3.1.
Reference: [War83] <author> David. H. D. Warren. </author> <title> An Abstract Prolog Instruction Set. </title> <type> Technical Note 309, </type> <institution> SRI International, </institution> <address> Menlo Park, CA, </address> <month> October </month> <year> 1983. </year>
References-found: 19

