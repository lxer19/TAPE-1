URL: ftp://ftp.cs.brown.edu/pub/techreports/94/cs94-24.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-94-24.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. Abiteboul and C. Beeri. </author> <title> On the Power of Languages for the Manipulation of Complex Objects. </title> <note> INRIA Research Report 846, </note> <year> 1988. </year>
Reference-contexts: Complex object databases have been proposed as a significant extension of relational databases, with many practical applications; see [3] for a recent survey. Well-known languages in this area are the complex object calculus/algebra with or without powerset of <ref> [1] </ref>. We show in this thesis that all these database query languages can be "naturally embedded" into the typed -calculus with equality, and that various complexity classes of queries can be characterized by syntactic properties of their corresponding -terms. <p> Note that our third requirement for natural embeddings is important if one wishes to consider the typed -calculus as a reasonable functional database query language. Operators such as Powerset in <ref> [1] </ref> or the second order queries in [13, 18, 46] are powerful, but lead to computational overkill for lower complexity classes, because even low-order polynomial queries such as transitive closure are forced to consume exponential time. <p> Chapter 5 The Complex Ob ject Algebra 5.1 Basic Definitions We conclude our tour of relational query languages with an encoding of Abiteboul's and Beeri's complex object algebra <ref> [1] </ref>. This takes us from manipulating "flat" relations to more complicated data structures, namely arbitrary finite trees built from tuple and set constructors. The algebra under consideration is extremely powerful|in fact it expresses any generic elementary time computation on finite structures. <p> With this technique, we can express non-relational queries such as Parity and Majority. Parity: The following term computes whether a relation R contains an odd or even number of tuples. If the cardinality of R is even, the output is the singleton list <ref> [1] </ref>, otherwise CHAPTER 6. QUERY TERMS OF FIXED ORDER 45 it is the singleton list [0] (here 0 and 1 are TLC constants). The type of Eq in this example is o ! o ! o ! o ! o. <p> The task is to determine whether there are more 1's than 0's in the second column. The following term decides this, reducing to <ref> [1] </ref> if the answer is "yes" and to [0] otherwise. It uses the "labels" in the first column of R as numbers, treating the (unique) constant in the first column of the i-th tuple of R as the number i 1. <p> We assume that G is given as a binary relation R containing tuples of the form (x; Parent (x)) and that S is a binary relation containing a single tuple (u; v). The following term decides whether u is an ancestor of v in G, reducing to <ref> [1] </ref> if the answer is "yes" and to [0] otherwise. <p> What is the expressive power of TLI = k and MLI = k for k &gt; 3? In particular, is the converse of Theorem 6.3.5 true as conjectured in Section 7.5? 2. In our embeddings we use lists of tuples, which are inherently ordered. In <ref> [1, 11, 9] </ref> sets are used as basic constructs, and set iteration replaces list iteration in [11, 9].
Reference: [2] <author> S. Abiteboul and P. Kanellakis. </author> <title> Object Identity as a Query Language Primitive. </title> <booktitle> In Proceedings ACM SIGMOD, </booktitle> <pages> pp. 159-173, </pages> <year> 1989. </year> <note> (Also INRIA Technical Report 1022, </note> <year> 1989.) </year>
Reference-contexts: CHAPTER 8. METHOD SCHEMAS (MS) 80 8.2 Semantics We assume the existence of a countably infinite set of objects (o 1 ; o 2 ; : : :) disjoint from classes and methods. We use object assignments <ref> [2] </ref> to provide semantics for classes with inheritance. The semantics of base methods is defined using partial functions satisfying certain signature constraints.
Reference: [3] <author> S. Abiteboul and P. Kanellakis. </author> <title> Database Theory Column: Query Languages for Complex Object Databases. </title> <journal> SIGACT News, </journal> <volume> 21 (1990), </volume> <pages> pp. 9-18. </pages>
Reference-contexts: Complex object databases have been proposed as a significant extension of relational databases, with many practical applications; see <ref> [3] </ref> for a recent survey. Well-known languages in this area are the complex object calculus/algebra with or without powerset of [1]. <p> Interestingly, no fixpoint or looping construct is needed; the expressive power stems from the ability to create larger and larger sets using the Powerset operator. Let us briefly describe the salient features of the complex object model (for a formal definition, see <ref> [3] </ref>). Complex objects 1 are built from constants using tuple (hi) and (finite) set (fg) constructors. Thus, 1 is a complex object, as are h1; 2i, f1; 2; 3g, and f1; h1; 2i; f1; 2; 3gg.
Reference: [4] <author> S. Abiteboul, P. Kanellakis, S. Ramaswamy, and E. Waller. </author> <title> Method Schemas. </title> <institution> Brown University Technical Report CS-92-33, </institution> <year> 1992. </year> <note> (An earlier version appeared in Proceedings 9th ACM PODS, </note> <year> 1990.) </year>
Reference-contexts: The reduction strategies we employ here use the order of redexes to decide whether to evaluate them in applicative or normal order. The final topic of this thesis is a functional query language framework for object-oriented CHAPTER 1. INTRODUCTION 4 databases (OODBs): method schemas. Method schemas <ref> [4] </ref> are intended to model the object/class/method paradigm of object-oriented programming in the same way that applicative program schemas [17, 21] model traditional programming languages. <p> Chapter 8 Method Schemas (MS) Method schemas <ref> [4] </ref> are a simple programming formalism for OODBs, based on applicative program schemas with additional features such as classes, methods, inheritance, name overloading, and late binding.
Reference: [5] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog Extensions for Database Queries and Updates. </title> <journal> J. Comput. System Sci., </journal> <volume> 43 (1991), </volume> <pages> pp. 62-124. </pages>
Reference-contexts: Database query languages originated from Codd's work on relational databases [16] and have been primarily studied in the context of finite model theory, e. g., [12, 13, 14, 18, 27, 46, 48]. Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics <ref> [5, 13, 14] </ref> express practically interesting sets of database queries. <p> Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries. In addition, as shown in [27, 48], every PTIME query can be expressed using Datalog : on ordered structures; and, as shown in <ref> [5] </ref>, it suffices to use Datalog : syntax under a variety of semantics (e. g., inflationary) to express the various fixpoint logics. Complex object databases have been proposed as a significant extension of relational databases, with many practical applications; see [3] for a recent survey.
Reference: [6] <author> H. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North Holland, </publisher> <year> 1984. </year>
Reference-contexts: Theorem 2.1.2 (Strong normalization property) For each e, there exists an integer n such that if e &gt; e 0 , then the derivation involves no more than n fi-reductions. For more details, see for example <ref> [15, 6] </ref>. <p> Theorem 2.1.2 (Strong normalization property) For each e, there exists an integer n such that if e &gt; e 0 , then the derivation involves no more than n fi-reductions. For more details, see for example [15, 6]. In particular, <ref> [6, Section 15.3] </ref> discusses the Church-Rosser property for the untyped -calculus enriched with equality. 2.2 Let-Polymorphism: Core-ML Core-ML: The syntax of core-ML is the syntax of TLC augmented with one new expression construct: E x j (EE) j x: E j let x = E in E. <p> For every pair of constants o i ; o j , the normal form of (Eq o i o j ) arises from the normal form of (Eq l o i o j ) by a series of -reductions <ref> [6] </ref>. It is known that in a fi-reduction sequence, -reductions can always be pushed to the end [6, Theorem 15.1.6]. This remains true even if Eq-reductions are added, because Eq- and -reductions commute for typed terms. <p> It is known that in a fi-reduction sequence, -reductions can always be pushed to the end <ref> [6, Theorem 15.1.6] </ref>. This remains true even if Eq-reductions are added, because Eq- and -reductions commute for typed terms. Thus, the normal form of a query using Eq l instead of Eq -reduces to the normal form of the original query.
Reference: [7] <author> H. Barendregt. </author> <title> Functional Programming and Lambda Calculus. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, </volume> <pages> pp. 321-363. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: Reduction preserves types <ref> [7, Theorem 4.2.8] </ref>. We write &gt; for the reflexive, transitive closure of &gt; ff and &gt; fi .
Reference: [8] <author> S. Bellantoni and S. Cook. </author> <title> A New Recursion-Theoretic Characterization of the Poly-time Functions. </title> <booktitle> In Proceedings 24th ACM STOC, </booktitle> <pages> pp. 283-293, </pages> <year> 1992. </year>
Reference-contexts: Would it be possible to reexpress all our expressibility results in a single evaluation strategy using such transformations? 6. There are various machine-independent characterizations of PTIME (e. g., <ref> [48, 27, 22, 29, 8, 35] </ref>). Is there a way of unifying some of these characterizations using the framework of the typed -calculus, maybe with suitable extensions?
Reference: [9] <author> V. Breazu-Tannen, P. Buneman, and S. Naqvi. </author> <title> Structural Recursion as a Query Language. </title> <booktitle> In Proceedings DBPL3, </booktitle> <pages> pp. 9-19. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: After all it is called a calculus, but reductions are procedural. Similar frameworks underlie some practical work in database query languages, e. g., the early FQL language of [11] and the more recent work on structural recursion as a query language <ref> [9, 10] </ref>. An important difference from [9, 10] is that here we use the pure typed -calculus and we use no type polymorphism. The second contribution of this thesis is a study of the expressive power of fixed-order fragments of the typed -calculus. <p> After all it is called a calculus, but reductions are procedural. Similar frameworks underlie some practical work in database query languages, e. g., the early FQL language of [11] and the more recent work on structural recursion as a query language <ref> [9, 10] </ref>. An important difference from [9, 10] is that here we use the pure typed -calculus and we use no type polymorphism. The second contribution of this thesis is a study of the expressive power of fixed-order fragments of the typed -calculus. <p> What is the expressive power of TLI = k and MLI = k for k &gt; 3? In particular, is the converse of Theorem 6.3.5 true as conjectured in Section 7.5? 2. In our embeddings we use lists of tuples, which are inherently ordered. In <ref> [1, 11, 9] </ref> sets are used as basic constructs, and set iteration replaces list iteration in [11, 9]. <p> In our embeddings we use lists of tuples, which are inherently ordered. In [1, 11, 9] sets are used as basic constructs, and set iteration replaces list iteration in <ref> [11, 9] </ref>. Is it possible to eliminate the order dependence in our framework by augmenting the -calculus syntax and semantics with set iteration? One approach might also be to encode finite structures using a generic order computed by graph canonization. 3.
Reference: [10] <author> V. Breazu-Tannen, P. Buneman, and L. Wong. </author> <title> Naturally Embedded Query Languages. </title> <booktitle> In Proceedings 4th ICDT. Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year> <note> 89 BIBLIOGRAPHY 90 </note>
Reference-contexts: After all it is called a calculus, but reductions are procedural. Similar frameworks underlie some practical work in database query languages, e. g., the early FQL language of [11] and the more recent work on structural recursion as a query language <ref> [9, 10] </ref>. An important difference from [9, 10] is that here we use the pure typed -calculus and we use no type polymorphism. The second contribution of this thesis is a study of the expressive power of fixed-order fragments of the typed -calculus. <p> After all it is called a calculus, but reductions are procedural. Similar frameworks underlie some practical work in database query languages, e. g., the early FQL language of [11] and the more recent work on structural recursion as a query language <ref> [9, 10] </ref>. An important difference from [9, 10] is that here we use the pure typed -calculus and we use no type polymorphism. The second contribution of this thesis is a study of the expressive power of fixed-order fragments of the typed -calculus.
Reference: [11] <author> P. Buneman, R. Frankel, and R. Nikhil. </author> <title> An Implementation Technique for Database Query Languages. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 7 (1982), </volume> <pages> pp. 164-186. </pages>
Reference-contexts: After all it is called a calculus, but reductions are procedural. Similar frameworks underlie some practical work in database query languages, e. g., the early FQL language of <ref> [11] </ref> and the more recent work on structural recursion as a query language [9, 10]. An important difference from [9, 10] is that here we use the pure typed -calculus and we use no type polymorphism. <p> What is the expressive power of TLI = k and MLI = k for k &gt; 3? In particular, is the converse of Theorem 6.3.5 true as conjectured in Section 7.5? 2. In our embeddings we use lists of tuples, which are inherently ordered. In <ref> [1, 11, 9] </ref> sets are used as basic constructs, and set iteration replaces list iteration in [11, 9]. <p> In our embeddings we use lists of tuples, which are inherently ordered. In [1, 11, 9] sets are used as basic constructs, and set iteration replaces list iteration in <ref> [11, 9] </ref>. Is it possible to eliminate the order dependence in our framework by augmenting the -calculus syntax and semantics with set iteration? One approach might also be to encode finite structures using a generic order computed by graph canonization. 3.
Reference: [12] <author> A. Chandra and D. Harel. </author> <title> Computable Queries for Relational Databases. </title> <journal> J. Comput. System Sci., </journal> <volume> 21 (1980), </volume> <pages> pp. 156-178. </pages>
Reference-contexts: Database query languages originated from Codd's work on relational databases [16] and have been primarily studied in the context of finite model theory, e. g., <ref> [12, 13, 14, 18, 27, 46, 48] </ref>. Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries. <p> Not all database query languages can be embedded in the typed -calculus. Clearly, any computation that is not elementary is not captured by our framework. What should be added to the typed -calculus to capture exactly the more powerful database query languages such as the computable queries of <ref> [12] </ref>? 4. We use ad-hoc reduction strategies to evaluate query terms efficiently. However, there is also work on general optimal reduction strategies (e. g., [36, 34]). How do such re 87 CHAPTER 9.
Reference: [13] <author> A. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> J. Comput. System Sci., </journal> <volume> 25 (1982), </volume> <pages> pp. 99-128. </pages>
Reference-contexts: Database query languages originated from Codd's work on relational databases [16] and have been primarily studied in the context of finite model theory, e. g., <ref> [12, 13, 14, 18, 27, 46, 48] </ref>. Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries. <p> Database query languages originated from Codd's work on relational databases [16] and have been primarily studied in the context of finite model theory, e. g., [12, 13, 14, 18, 27, 46, 48]. Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics <ref> [5, 13, 14] </ref> express practically interesting sets of database queries. <p> Note that our third requirement for natural embeddings is important if one wishes to consider the typed -calculus as a reasonable functional database query language. Operators such as Powerset in [1] or the second order queries in <ref> [13, 18, 46] </ref> are powerful, but lead to computational overkill for lower complexity classes, because even low-order polynomial queries such as transitive closure are forced to consume exponential time.
Reference: [14] <author> A. Chandra and D. Harel. </author> <title> Horn Clause Queries and Generalizations. </title> <journal> J. Logic Programming, </journal> <volume> 2 (1985), </volume> <pages> pp. 1-15. </pages>
Reference-contexts: Database query languages originated from Codd's work on relational databases [16] and have been primarily studied in the context of finite model theory, e. g., <ref> [12, 13, 14, 18, 27, 46, 48] </ref>. Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries. <p> Database query languages originated from Codd's work on relational databases [16] and have been primarily studied in the context of finite model theory, e. g., [12, 13, 14, 18, 27, 46, 48]. Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics <ref> [5, 13, 14] </ref> express practically interesting sets of database queries.
Reference: [15] <author> A. Church. </author> <title> The Calculi of Lambda-Conversion. </title> <publisher> Princeton University Press, </publisher> <year> 1941. </year>
Reference-contexts: Introduction Motivation and background: Church's simply typed -calculus <ref> [15] </ref> (typed -calculus for short) is generally considered the "pure" backbone of today's functional programming languages. <p> Theorem 2.1.2 (Strong normalization property) For each e, there exists an integer n such that if e &gt; e 0 , then the derivation involves no more than n fi-reductions. For more details, see for example <ref> [15, 6] </ref>.
Reference: [16] <author> E. Codd. </author> <title> Relational Completeness of Database Sublanguages. </title> <editor> In R. Rustin, editor, </editor> <booktitle> Database Systems, </booktitle> <pages> pp. 65-98. </pages> <publisher> Prentice Hall, </publisher> <year> 1972. </year>
Reference-contexts: Our change of data representation, i. e., the framework of finite model theory instead of arithmetic on Church numerals, has some interesting consequences, because it takes us into the realm of database query languages. Database query languages originated from Codd's work on relational databases <ref> [16] </ref> and have been primarily studied in the context of finite model theory, e. g., [12, 13, 14, 18, 27, 46, 48]. Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries. <p> Database query languages originated from Codd's work on relational databases <ref> [16] </ref> and have been primarily studied in the context of finite model theory, e. g., [12, 13, 14, 18, 27, 46, 48]. Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries. <p> It is easy to see that the query terms described in the following sections work unchanged in the "pure" setting, except that the symbol Eq has to be -bound at the outermost level. Chapter 3 Coding Relational Algebra We begin by demonstrating how the relational algebra operators of <ref> [16] </ref> can be represented in the simply typed -calculus with equality. Every operator is coded as a -term that takes one or two relations in the list-of-tuples format described in Section 2.4 as input and produces another relation in the same format as output.
Reference: [17] <author> B. Courcelle. </author> <title> Recursive Applicative Program Schemes. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, </volume> <pages> pp. 459-492. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: The final topic of this thesis is a functional query language framework for object-oriented CHAPTER 1. INTRODUCTION 4 databases (OODBs): method schemas. Method schemas [4] are intended to model the object/class/method paradigm of object-oriented programming in the same way that applicative program schemas <ref> [17, 21] </ref> model traditional programming languages. Method schemas use a simple first-order calculus augmented with key object-oriented features: classes with methods and inheritance, a syntax involving method name overloading, and a semantics involving late binding. <p> They are intended to model the object/class/method paradigm of object-oriented programming in the same way that applicative program schemas <ref> [17, 21] </ref> model traditional programming languages.
Reference: [18] <author> R. Fagin. </author> <title> Generalized First-Order Spectra and Polynomial-Time Recognizable Sets. </title> <booktitle> SIAM-AMS Proceedings, 7 (1974), </booktitle> <pages> pp. 43-73. </pages>
Reference-contexts: Database query languages originated from Codd's work on relational databases [16] and have been primarily studied in the context of finite model theory, e. g., <ref> [12, 13, 14, 18, 27, 46, 48] </ref>. Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries. <p> Note that our third requirement for natural embeddings is important if one wishes to consider the typed -calculus as a reasonable functional database query language. Operators such as Powerset in [1] or the second order queries in <ref> [13, 18, 46] </ref> are powerful, but lead to computational overkill for lower complexity classes, because even low-order polynomial queries such as transitive closure are forced to consume exponential time.
Reference: [19] <author> S. Fortune, D. Leivant, and M. O'Donnell. </author> <title> The Expressiveness of Simple and Second-Order Type Structures. </title> <journal> J. of the ACM, </journal> <volume> 30 (1983), </volume> <pages> pp. 151-185. </pages>
Reference-contexts: If one allows the type t to be different in each occurrence of Int, then functions like exponentiation or predecessor also become expressible <ref> [19] </ref>. However, [19] proceeds to show (using a result of Statman) that even under these relaxed conditions, subtraction cannot be expressed. On the other hand, it is known that provably hard decision problems can be embedded into the typed -calculus. <p> If one allows the type t to be different in each occurrence of Int, then functions like exponentiation or predecessor also become expressible <ref> [19] </ref>. However, [19] proceeds to show (using a result of Statman) that even under these relaxed conditions, subtraction cannot be expressed. On the other hand, it is known that provably hard decision problems can be embedded into the typed -calculus. <p> It has long been known that there is some hyper-exponential connection between the order of -terms and their expressive power, measured either as the ability to generate long reduction sequences [44], long normal forms <ref> [19] </ref>, or simulate generic Turing machine computations [37]. <p> Unlike <ref> [19, 43] </ref>, we allow that the monomorphic types of inputs and outputs differ.
Reference: [20] <author> J.-Y. Girard. </author> <title> Interpretation Fonctionelle et Elimination des Coupures de l' Arithme-tique d' Ordre Superieur. </title> <institution> These de Doctorat d' Etat, Universite de Paris VII, </institution> <year> 1972. </year>
Reference-contexts: It is generally felt, however, that it has too little expressive power by itself, and that some sort of polymorphic extension such as the Girard-Reynolds second-order lambda calculus <ref> [20, 42] </ref> or Milner's ML [40, 41] is necessary to obtain a practically usable language. The perceived deficiency of the typed -calculus stems from various expressibility results for computations over Church numerals.
Reference: [21] <author> S. Greibach. </author> <title> Theory of Program Structures: Schemes, Semantics, </title> <booktitle> Verification. </booktitle> <volume> LNCS Vol. 36, </volume> <publisher> Springer, </publisher> <year> 1975. </year>
Reference-contexts: The final topic of this thesis is a functional query language framework for object-oriented CHAPTER 1. INTRODUCTION 4 databases (OODBs): method schemas. Method schemas [4] are intended to model the object/class/method paradigm of object-oriented programming in the same way that applicative program schemas <ref> [17, 21] </ref> model traditional programming languages. Method schemas use a simple first-order calculus augmented with key object-oriented features: classes with methods and inheritance, a syntax involving method name overloading, and a semantics involving late binding. <p> They are intended to model the object/class/method paradigm of object-oriented programming in the same way that applicative program schemas <ref> [17, 21] </ref> model traditional programming languages.
Reference: [22] <author> Y. Gurevich. </author> <title> Algebras of Feasible Functions. </title> <booktitle> In Proceedings 24th IEEE FOCS, </booktitle> <pages> pp. 210-214, </pages> <year> 1983. </year>
Reference-contexts: Would it be possible to reexpress all our expressibility results in a single evaluation strategy using such transformations? 6. There are various machine-independent characterizations of PTIME (e. g., <ref> [48, 27, 22, 29, 8, 35] </ref>). Is there a way of unifying some of these characterizations using the framework of the typed -calculus, maybe with suitable extensions?
Reference: [23] <author> G. Hillebrand, P. Kanellakis, H. Mairson, and M. Vardi. </author> <title> Tools for Datalog Bounded-ness. </title> <booktitle> In Proceedings 10th ACM PODS, </booktitle> <pages> pp. 1-12, </pages> <year> 1991. </year>
Reference-contexts: If an inconsistency is detected, the computation is aborted by "flooding" the IDB predicates, i. e., deriving all possible facts within a single step (this is a standard technique for aborting Datalog computations, see, e. g., <ref> [23] </ref> for an example of its use). It is easy to see that this encoding provides a faithful simulation of method schemas with order.
Reference: [24] <author> G. Hillebrand, P. Kanellakis, and H. Mairson. </author> <title> Database Query Languages Embedded in the Typed Lambda Calculus. </title> <booktitle> In Proceedings 8th IEEE LICS, </booktitle> <pages> pp. 332-343, </pages> <year> 1993. </year> <note> BIBLIOGRAPHY 91 </note>
Reference-contexts: : 2 n O (1) , where there is a tower of k 2's, and k-EXPSPACE is defined analogously.) (3) PTIME can also be characterized as the set of queries expressible using method schemas over ordered databases. (1) is joint work with Paris Kanellakis and Harry Mairson; it appeared in <ref> [24] </ref>. Part of (2) is joint work with Paris Kanellakis; it will appear in [26]. (3) is joint work with Paris Kanellakis and Sridhar Ramaswamy; it appeared in [25]. Overview of this thesis: We begin in Chapter 2 with a description of the main concepts used in this thesis.
Reference: [25] <author> G. Hillebrand, P. Kanellakis, and S. Ramaswamy. </author> <title> Functional Programming Formalisms for OODB Methods. </title> <booktitle> In Proceedings of the NATO ASI Summer School on OODBs, Turkey 1993. Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Part of (2) is joint work with Paris Kanellakis; it will appear in [26]. (3) is joint work with Paris Kanellakis and Sridhar Ramaswamy; it appeared in <ref> [25] </ref>. Overview of this thesis: We begin in Chapter 2 with a description of the main concepts used in this thesis. First, we briefly review the typed -calculus with equality in Section 2.1 and its polymorphic variant, core-ML, in Section 2.2. <p> This, combined with the previous reduction, allows us to deduce that method schemas express exactly the PTIME queries. We only sketch the reduction here. The details can be found in <ref> [25] </ref>. The idea is that a method p of arity k is simulated by means of a predicate P of arity k + 1.
Reference: [26] <author> G. Hillebrand and P. Kanellakis. </author> <title> Functional Database Query Languages as Typed Lambda Calculi of Fixed Order. </title> <booktitle> To appear in Proceedings 13th ACM PODS, </booktitle> <year> 1994. </year>
Reference-contexts: Part of (2) is joint work with Paris Kanellakis; it will appear in <ref> [26] </ref>. (3) is joint work with Paris Kanellakis and Sridhar Ramaswamy; it appeared in [25]. Overview of this thesis: We begin in Chapter 2 with a description of the main concepts used in this thesis.
Reference: [27] <author> N. Immerman. </author> <title> Relational Queries Computable in Polynomial Time. </title> <journal> Info. and Comp., </journal> <volume> 68 (1986), </volume> <pages> pp. 86-104. </pages>
Reference-contexts: Database query languages originated from Codd's work on relational databases [16] and have been primarily studied in the context of finite model theory, e. g., <ref> [12, 13, 14, 18, 27, 46, 48] </ref>. Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries. <p> Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries. In addition, as shown in <ref> [27, 48] </ref>, every PTIME query can be expressed using Datalog : on ordered structures; and, as shown in [5], it suffices to use Datalog : syntax under a variety of semantics (e. g., inflationary) to express the various fixpoint logics. <p> The next step is to find a way of iterating such queries in order to compute fixpoints. It suffices to perform a polynomial number of iterations using inflationary semantics to capture all PTIME-computable queries <ref> [27, 48] </ref>. Intuitively, the solution is very simple|we build a sufficiently long list from a Cartesian product of the input relations and then use that list as an iterator to repeat a relational query polynomially many times. <p> The results of Immerman <ref> [27] </ref> and Vardi [48] then imply that method schemas can compute all PTIME queries over finite ordered databases. To begin with, let us illustrate how to code simple Boolean and arithmetical functions. We represent the truth values True and False by the classes Number and Zero. <p> Would it be possible to reexpress all our expressibility results in a single evaluation strategy using such transformations? 6. There are various machine-independent characterizations of PTIME (e. g., <ref> [48, 27, 22, 29, 8, 35] </ref>). Is there a way of unifying some of these characterizations using the framework of the typed -calculus, maybe with suitable extensions?
Reference: [28] <author> N. Immerman. </author> <title> Languages that Capture Complexity Classes. </title> <journal> SIAM J. Comp., </journal> <volume> 68 (1986), </volume> <pages> pp. 86-104. </pages>
Reference-contexts: o: T : o: (Eq T v) T (Parent T )) u and (Parent v) R (x 1 : o: x 2 : o: T : o: (Eq x 1 v) x 2 T ) v It is interesting to note that deterministic graph accessibility is LOGSPACE-complete for first-order reductions <ref> [28] </ref>, but only if vertices can be labeled by tuples of constants.
Reference: [29] <author> N. Immerman, S. Patnaik, and D. Stemple. </author> <title> The Expressiveness of a Family of Finite Set Languages. </title> <booktitle> In Proceedings 10th ACM PODS, </booktitle> <pages> pp. 37-52, </pages> <year> 1991. </year>
Reference-contexts: Would it be possible to reexpress all our expressibility results in a single evaluation strategy using such transformations? 6. There are various machine-independent characterizations of PTIME (e. g., <ref> [48, 27, 22, 29, 8, 35] </ref>). Is there a way of unifying some of these characterizations using the framework of the typed -calculus, maybe with suitable extensions?
Reference: [30] <author> P. Kanellakis. </author> <title> Elements of Relational Database Theory. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, </volume> <pages> pp. 1073-1156. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: In this section, we describe a very simple way of encoding relations as interpreted base methods, and we show that under this interpretation, method schemas express exactly the PTIME queries. We assume some familiarity with Datalog terminology and notation from <ref> [30, 47] </ref>, e. g., rules, EDBs, IDBs etc. 8.3.1 I/O Conventions We consider queries over finite ordered relational databases. <p> of the output; if q (~x) reduces to an object of class Zero, then the tuple represented by ~x is not considered part of the output. 8.3.2 Expressing PTIME Queries We show that under the input/output conventions given above, method schemas can compute inflationary fixpoints of Datalog : programs (see <ref> [30] </ref> for a survey of these concepts). The results of Immerman [27] and Vardi [48] then imply that method schemas can compute all PTIME queries over finite ordered databases. To begin with, let us illustrate how to code simple Boolean and arithmetical functions.
Reference: [31] <author> P. Kanellakis, J. Mitchell, and H. Mairson. </author> <title> Unification and ML-type Reconstruction. </title> <editor> In J.-L. Lassez and G. Plotkin, editors, </editor> <booktitle> Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <pages> pp. 444-479. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year> <note> (Also in Proceedings 16th ACM POPL, </note> <year> 1989, </year> <booktitle> and Proceedings 17th ACM POPL, </booktitle> <year> 1990.) </year>
Reference-contexts: The simplest way of explaining CHAPTER 2. THE TYPED LAMBDA CALCULUS WITH EQUALITY (TLC = ) 8 ML types involves the same monomorphic types and rules (Var), (Abs), and (App) used for TLC with one additional rule that captures the polymorphism (see <ref> [31] </ref>): (Let) ` let x = e 0 in e : We call a -term E ML-typed if ` E: is derivable by the (Var), (Abs), (App), and (Let) rules, for some and . <p> Order of functionality is defined in the same way. There are two differences: (1) Type inference is no longer in linear time but EXPTIME-complete <ref> [31, 32] </ref>. (2) Arbitrary order core-ML, core-ML = , TLC, and TLC = all have the same expressive power, but for fixed order type inference allows more core-ML than TLC programs to be typed, so it might provide more expressibility. 2.3 List Iteration We briefly review how list iteration works.
Reference: [32] <author> A. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> An Analysis of ML Typability. </title> <booktitle> In Proceedings 17th Colloquium on Trees, Algebra and Programming, </booktitle> <pages> pp. 206-220. </pages> <booktitle> Lecture Notes in Computer Science 431, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Order of functionality is defined in the same way. There are two differences: (1) Type inference is no longer in linear time but EXPTIME-complete <ref> [31, 32] </ref>. (2) Arbitrary order core-ML, core-ML = , TLC, and TLC = all have the same expressive power, but for fixed order type inference allows more core-ML than TLC programs to be typed, so it might provide more expressibility. 2.3 List Iteration We briefly review how list iteration works.
Reference: [33] <author> P. Kolaitis and C. Papadimitriou. </author> <booktitle> Why Not Negation By Fixpoint? In Proceedings 7th ACM PODS, </booktitle> <pages> pp. 231-239, </pages> <year> 1988. </year>
Reference-contexts: Database query languages originated from Codd's work on relational databases [16] and have been primarily studied in the context of finite model theory, e. g., [12, 13, 14, 18, 27, 46, 48]. Relational calculus/algebra [16], Datalog : <ref> [33] </ref> and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries.
Reference: [34] <author> J. Lamping. </author> <title> An Algorithm for Optimal Lambda Calculus Reduction. </title> <booktitle> In Proceedings 17th ACM POPL, </booktitle> <pages> pp. 16-30, </pages> <year> 1990. </year>
Reference-contexts: What should be added to the typed -calculus to capture exactly the more powerful database query languages such as the computable queries of [12]? 4. We use ad-hoc reduction strategies to evaluate query terms efficiently. However, there is also work on general optimal reduction strategies (e. g., <ref> [36, 34] </ref>). How do such re 87 CHAPTER 9.
Reference: [35] <author> D. Leivant and J.-Y. Marion. </author> <title> Lambda Calculus Characterizations of Poly-Time. </title> <booktitle> In Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <address> Utrecht 1993. </address> <note> (To appear in Fundamenta Informaticae.) </note>
Reference-contexts: INTRODUCTION 2 power to bear. This situation is very different from the untyped -calculus, which is Turing-complete independent of the particular representation of inputs and outputs chosen. One way of avoiding the anomalies associated with representations over Church numerals was recently demonstrated by Leivant and Marion <ref> [35] </ref>. By augmenting the typed lambda calculus with a polymorphic pairing operator and a "bottom tier" consisting of the free algebra of words over f0; 1g with associated constructor, destructor, and discriminator functions, they obtain a calculus in which exactly the PTIME computations are expressible. <p> Would it be possible to reexpress all our expressibility results in a single evaluation strategy using such transformations? 6. There are various machine-independent characterizations of PTIME (e. g., <ref> [48, 27, 22, 29, 8, 35] </ref>). Is there a way of unifying some of these characterizations using the framework of the typed -calculus, maybe with suitable extensions?
Reference: [36] <author> J.-J. Levy. </author> <title> Optimal Reductions in the Lambda-Calculus. </title> <editor> In J. Seldin and J. Hind-ley, editors, To H. B. </editor> <booktitle> Curry: Essays in Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pp. 159-191. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year> <note> BIBLIOGRAPHY 92 </note>
Reference-contexts: What should be added to the typed -calculus to capture exactly the more powerful database query languages such as the computable queries of [12]? 4. We use ad-hoc reduction strategies to evaluate query terms efficiently. However, there is also work on general optimal reduction strategies (e. g., <ref> [36, 34] </ref>). How do such re 87 CHAPTER 9.
Reference: [37] <author> H. Mairson. </author> <title> A Simple Proof of a Theorem of Statman. </title> <journal> Theoretical Computer Sci., </journal> <volume> 103 (1992), </volume> <pages> pp. 387-394. </pages>
Reference-contexts: For example, Statman [45] shows that deciding whether two typed terms have the same normal form is at least as hard as deciding the truth of a formula in higher-order type theory, a decision problem known to be non-elementary [39]. Mairson's instructive re-proof of Statman's and Meyer's results (in <ref> [37] </ref>) actually shows how to simulate any elementary-time Turing machine computation using typed -terms. Thus, it appears that the typed -calculus can express quite powerful computations, but that the domain of Church numerals is somehow too restrictive to bring this expressive 1 CHAPTER 1. INTRODUCTION 2 power to bear. <p> It has long been known that there is some hyper-exponential connection between the order of -terms and their expressive power, measured either as the ability to generate long reduction sequences [44], long normal forms [19], or simulate generic Turing machine computations <ref> [37] </ref>. <p> First, we briefly review the typed -calculus with equality in Section 2.1 and its polymorphic variant, core-ML, in Section 2.2. Then, in Section 2.3, we introduce list iteration, one of the basic concepts of our framework. List iteration|primitive recursion on lists|was used originally in <ref> [37] </ref> to re-prove the results of Statman and Meyer mentioned above. It replaces unbounded recursion in the typed -calculus, where the type system does not allow a fixed point combinator. We use lists to represent databases as -terms; this is detailed in Section 2.4. <p> We present here a simple way of encoding these "impure" features using pure TLC terms (see <ref> [37] </ref> for another way of coding up equality on finite domains). Let O = fo 1 ; o 2 ; : : :; o N g be the set of constants occurring in a particular input.
Reference: [38] <author> J. McCarthy. </author> <title> Recursive Functions of Symbolic Expressions and Their Computation By Machine, Part I. </title> <journal> Comm. of the ACM, </journal> <volume> 3 (1960), </volume> <pages> pp. 185-195. </pages>
Reference-contexts: The proofs here use a progressively refined list iteration technology, which may be of independent interest. One may view it as a "pure" version of simply typed LISP <ref> [38] </ref>. The requirement that everything be simply typed, without even let-polymorphism, complicates some of the proofs (see for example the "type-laundering" technology in Sections 4.2 and 5.3). For all these results we can change the framework to eliminate equality, as described in Section 2.5.
Reference: [39] <author> A. Meyer. </author> <title> The Inherent Computational Complexity of Theories of Ordered Sets. </title> <booktitle> In Proceedings of the International Congress of Mathematicians, </booktitle> <pages> pp. 477-482, </pages> <year> 1975. </year>
Reference-contexts: For example, Statman [45] shows that deciding whether two typed terms have the same normal form is at least as hard as deciding the truth of a formula in higher-order type theory, a decision problem known to be non-elementary <ref> [39] </ref>. Mairson's instructive re-proof of Statman's and Meyer's results (in [37]) actually shows how to simulate any elementary-time Turing machine computation using typed -terms.
Reference: [40] <author> R. Milner. </author> <title> A Theory of Type Polymorphism in Programming. </title> <journal> J. Comput. System Sci. </journal> <volume> 17 (1978), </volume> <pages> pp. 348-375. </pages>
Reference-contexts: It is generally felt, however, that it has too little expressive power by itself, and that some sort of polymorphic extension such as the Girard-Reynolds second-order lambda calculus [20, 42] or Milner's ML <ref> [40, 41] </ref> is necessary to obtain a practically usable language. The perceived deficiency of the typed -calculus stems from various expressibility results for computations over Church numerals.
Reference: [41] <author> R. Milner. </author> <title> The Standard ML Core Language. Polymorphism, </title> <booktitle> 2 (1985), </booktitle> <pages> 28 pp. </pages> <note> (An earlier version appeared in Proceedings of the 1984 ACM Symposium on Lisp and Functional Programming.) </note>
Reference-contexts: It is generally felt, however, that it has too little expressive power by itself, and that some sort of polymorphic extension such as the Girard-Reynolds second-order lambda calculus [20, 42] or Milner's ML <ref> [40, 41] </ref> is necessary to obtain a practically usable language. The perceived deficiency of the typed -calculus stems from various expressibility results for computations over Church numerals.
Reference: [42] <author> J. Reynolds. </author> <title> Towards a Theory of Type Structure. </title> <booktitle> In Proceedings of the Paris Colloquium on Programming, </booktitle> <pages> pp. 408-425. </pages> <booktitle> Lecture Notes in Computer Science 19, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1974. </year>
Reference-contexts: It is generally felt, however, that it has too little expressive power by itself, and that some sort of polymorphic extension such as the Girard-Reynolds second-order lambda calculus <ref> [20, 42] </ref> or Milner's ML [40, 41] is necessary to obtain a practically usable language. The perceived deficiency of the typed -calculus stems from various expressibility results for computations over Church numerals.
Reference: [43] <author> H. Schwichtenberg. </author> <title> Definierbare Funktionen im -Kalkul mit Typen. </title> <journal> Archiv fur math-ematische Logik und Grundlagenforschung, </journal> <volume> 17 (1976), </volume> <pages> pp. 113-114. </pages>
Reference-contexts: The perceived deficiency of the typed -calculus stems from various expressibility results for computations over Church numerals. For example, by assuming the inputs and outputs to be Church numerals of type Int, where Int (t ! t ) ! t ! t for some fixed type t , Schwichtenberg <ref> [43] </ref> showed that the representable multi-argument functions of type (Int; : : :; Int) ! Int (or equivalently, Int ! ! Int ! Int) are exactly the extended polynomials, i. e., the functions generated by 0 and 1 using the operations addition, multiplication and conditional. <p> Unlike <ref> [19, 43] </ref>, we allow that the monomorphic types of inputs and outputs differ.
Reference: [44] <author> H. Schwichtenberg. </author> <title> An Upper Bound for Reduction Sequences in the Typed - Calculus. Archive for Mathematical Logic, </title> <booktitle> 30 (1991), </booktitle> <pages> pp. 405-408. </pages>
Reference-contexts: It has long been known that there is some hyper-exponential connection between the order of -terms and their expressive power, measured either as the ability to generate long reduction sequences <ref> [44] </ref>, long normal forms [19], or simulate generic Turing machine computations [37].
Reference: [45] <author> R. Statman. </author> <title> The Typed -Calculus is Not Elementary Recursive. </title> <journal> Theoretical Computer Sci., </journal> <volume> 9 (1979), </volume> <pages> pp. 73-81. </pages>
Reference-contexts: However, [19] proceeds to show (using a result of Statman) that even under these relaxed conditions, subtraction cannot be expressed. On the other hand, it is known that provably hard decision problems can be embedded into the typed -calculus. For example, Statman <ref> [45] </ref> shows that deciding whether two typed terms have the same normal form is at least as hard as deciding the truth of a formula in higher-order type theory, a decision problem known to be non-elementary [39].
Reference: [46] <author> L. Stockmeyer. </author> <title> The Polynomial-Time Hierarchy. </title> <journal> Theoretical Computer Sci., </journal> <volume> 3 (1977), </volume> <pages> pp. 1-22. </pages>
Reference-contexts: Database query languages originated from Codd's work on relational databases [16] and have been primarily studied in the context of finite model theory, e. g., <ref> [12, 13, 14, 18, 27, 46, 48] </ref>. Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries. <p> Note that our third requirement for natural embeddings is important if one wishes to consider the typed -calculus as a reasonable functional database query language. Operators such as Powerset in [1] or the second order queries in <ref> [13, 18, 46] </ref> are powerful, but lead to computational overkill for lower complexity classes, because even low-order polynomial queries such as transitive closure are forced to consume exponential time.
Reference: [47] <author> J. Ullman. </author> <title> Principles of Database Systems, 2nd ed. </title> <publisher> Computer Science Press, </publisher> <year> 1982. </year>
Reference-contexts: In this section, we describe a very simple way of encoding relations as interpreted base methods, and we show that under this interpretation, method schemas express exactly the PTIME queries. We assume some familiarity with Datalog terminology and notation from <ref> [30, 47] </ref>, e. g., rules, EDBs, IDBs etc. 8.3.1 I/O Conventions We consider queries over finite ordered relational databases.
Reference: [48] <author> M. Vardi. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> In Proceedings of the 14th ACM STOC, </booktitle> <pages> pp. 137-146, </pages> <year> 1982. </year>
Reference-contexts: Database query languages originated from Codd's work on relational databases [16] and have been primarily studied in the context of finite model theory, e. g., <ref> [12, 13, 14, 18, 27, 46, 48] </ref>. Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries. <p> Relational calculus/algebra [16], Datalog : [33] and various fixpoint logics [5, 13, 14] express practically interesting sets of database queries. In addition, as shown in <ref> [27, 48] </ref>, every PTIME query can be expressed using Datalog : on ordered structures; and, as shown in [5], it suffices to use Datalog : syntax under a variety of semantics (e. g., inflationary) to express the various fixpoint logics. <p> The next step is to find a way of iterating such queries in order to compute fixpoints. It suffices to perform a polynomial number of iterations using inflationary semantics to capture all PTIME-computable queries <ref> [27, 48] </ref>. Intuitively, the solution is very simple|we build a sufficiently long list from a Cartesian product of the input relations and then use that list as an iterator to repeat a relational query polynomially many times. <p> This is sufficient to evaluate any query Q of data complexity PSPACE, by just iterating a first-order representation of the transition function of a Turing machine computing Q <ref> [48] </ref>. <p> The results of Immerman [27] and Vardi <ref> [48] </ref> then imply that method schemas can compute all PTIME queries over finite ordered databases. To begin with, let us illustrate how to code simple Boolean and arithmetical functions. We represent the truth values True and False by the classes Number and Zero. <p> Would it be possible to reexpress all our expressibility results in a single evaluation strategy using such transformations? 6. There are various machine-independent characterizations of PTIME (e. g., <ref> [48, 27, 22, 29, 8, 35] </ref>). Is there a way of unifying some of these characterizations using the framework of the typed -calculus, maybe with suitable extensions?
References-found: 48

