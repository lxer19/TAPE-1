URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1993/TR40.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Email: -weide,ogden-@cis.ohio-state.edu  murali@cs.wvu.edu  
Title: Improving Reusability by Recasting Single Large-Effect Operations as Objects  
Author: Bruce W. Weide William F. Ogden Murali Sitaraman 
Date: 1993  
Note: November  Copyright 1993 by the authors.  
Address: Columbus, OH 43210  Morgantown, WV 26506  
Affiliation: Department of Computer and Information Science The Ohio State University  Department of Statistics and Computer Science West Virginia University  
Abstract: Technical Report OSU-CISRC-11/93-TR40 Department of Computer and Information Science The Ohio State University Columbus, OH Abstract Extending the objectoriented paradigm by recasting single large-effect operations as objects markedly improves reusability by increasing flexibility in terms of both functionality and performance. Two examples in this report, a Sorting_Machine and a Spanning_Forest_Machine, illustrate the recasting technique which might also be called machine-oriented programming. A version of this report was submitted for publication to a special issue of IEEE Software on Software Reuse. 
Abstract-found: 1
Intro-found: 1
Reference: [Booch 94] <author> Booch, G. </author> <title> ObjectOriented Analysis and Design with Applications, </title> <editor> 2nd ed., Benjamin/Cummings, </editor> <year> 1994. </year>
Reference: [Cormen 90] <author> Cormen, T.H., Leiserson, C.E., and Rivest, </author> <title> R.L. Introduction to Algorithms. </title> <publisher> MIT Press and McGraw-Hill Book Co., </publisher> <year> 1990. </year>
Reference-contexts: as in the proposed design scheme, an implementer is free to amortize the total cost of an algorithm among several procedures within the module and retain the same apparent functionality, then there is tremendous flexibility to employ precomputation, batch computation, deferred computation, and related data structuring and algorithm design techniques <ref> [Cormen 90] </ref>. Some applications (e.g., online and real-time systems) demand certain constrained performance profiles of individual operations in addition to or even instead of optimal performance for an entire sequence of operations that complete some task. <p> The vertices of this graph are the terminals to be interconnected, and its edges are weighted by the lengths of wire required for point-to-point connection of the corresponding pairs of terminals <ref> [Cormen 90] </ref>. Functional Design. <p> REFINING THE Find_MST OPERATION Suppose you dont consider this class of maintenance tasks and are satisfied with the original net selection program design. You might continue by refining the implementation of the Find_MST operation, which eventually should lead to something like the textbook code <ref> [Horowitz 76, Cormen 90] </ref>. Heres what might happen along the way. Sorting. Kruskals algorithm (see Sidebar C) examines the edges of the graph g in increasing order of edge weight. <p> given Coalesceable_Equivalence_Relation. (Space limits prevent us from showing the formal specification for this component here.) Because an equivalence relation partitions its domain into equivalence classes that are disjoint sets, an efficient representation of a Coalesceable_Equivalence_Relation uses the disjointset data structure with path compression that appears in most data structures texts <ref> [Horowitz 76, Cormen 90] </ref>. The code of Figure 4 is subtle in one respect. The representation of a Spanning_Forest_Machine includes a flag used to tell whether any edges have been inserted during the insertion phase, and a count of the number of spanning forest edges.
Reference: [Davidson 93] <author> Davidson, </author> <title> E.R. Monster matrices: their eigenvalues and eigenvectors. </title> <journal> Comp. in Phys. </journal> <volume> 7, 5 (Sep./Oct. </volume> <year> 1993), </year> <pages> 519-522. </pages>
Reference-contexts: There are no obvious limits in principle to extending this approach to arbitrary operations. For example, you might want a record-high machine that reports each largest-Item-so-far in a series of Items; or an eigenvalue machine that dispenses eigenvalues of a matrix in increasing order <ref> [Davidson 93] </ref>; or a compression machine or an encryption machine that works on a series of Items; etc. In practice there are several points to consider when you recast an single large-effect operation as an object.
Reference: [Harms 91] <author> Harms, D.E., and Weide, B.W. </author> <title> Copying and swapping: influences on the design of reusable software components. </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> 17, </volume> <month> 5 (May </month> <year> 1991), </year> <pages> 424-435. </pages>
Reference: [Hollingsworth 92] <author> Hollingsworth, </author> <title> J.E. Software Component Design-for-Reuse: A Language-Independent Discipline Applied to Ada. </title> <type> Ph.D. dissertation, </type> <institution> Dept. of Comp. and Inf. Sci., Ohio State Univ., Columbus, OH, </institution> <month> Aug. </month> <note> 1992; available by anonymous FTP from host ftp.cis.ohio-state.edu in directory pub/tech-report/TR1-1993. </note>
Reference: [Horowitz 76] <author> Horowitz, E. and Sahni, S. </author> <title> Fundamentals of Data Structures. </title> <publisher> Computer Science Press, </publisher> <year> 1976. </year>
Reference-contexts: REFINING THE Find_MST OPERATION Suppose you dont consider this class of maintenance tasks and are satisfied with the original net selection program design. You might continue by refining the implementation of the Find_MST operation, which eventually should lead to something like the textbook code <ref> [Horowitz 76, Cormen 90] </ref>. Heres what might happen along the way. Sorting. Kruskals algorithm (see Sidebar C) examines the edges of the graph g in increasing order of edge weight. <p> In some textbook implementations of Kruskals algorithm <ref> [Horowitz 76] </ref> this is essentially how things work. Phase (1) consists of creating a heap data structure containing the edges, and phase (2) involves removing edges one at a time from the heap. The heap organization guarantees that the edges come out in nondecreasing order of edge weight. <p> given Coalesceable_Equivalence_Relation. (Space limits prevent us from showing the formal specification for this component here.) Because an equivalence relation partitions its domain into equivalence classes that are disjoint sets, an efficient representation of a Coalesceable_Equivalence_Relation uses the disjointset data structure with path compression that appears in most data structures texts <ref> [Horowitz 76, Cormen 90] </ref>. The code of Figure 4 is subtle in one respect. The representation of a Spanning_Forest_Machine includes a flag used to tell whether any edges have been inserted during the insertion phase, and a count of the number of spanning forest edges.
Reference: [Parnas 72] <author> Parnas, </author> <title> D.L. On the criteria to be used in decomposing systems into modules. </title> <journal> Comm. ACM 15, </journal> <month> 12 (Dec. </month> <year> 1972), </year> <pages> 1053-1058. </pages>
Reference-contexts: Although this design might seem acceptable at first glance, a well-known problem with it <ref> [Parnas 72] </ref> is that the graph representation has to be visible both in the client program that calls Find_MST and in the body of Find_MST. Failure to encapsulate the graph representation design decision will produce a maintenance headache. <p> So, if Kruskals algorithm terminates before examining all the edges, the total time spent on the (partial) sorting can be substantially less than with the single Sort_List operation. Parnas has noted this advantage of breaking up sorting into (two) smaller chunks of functionality for his famous KWIC example <ref> [Parnas 72] </ref>. However, to our knowledge, this basic idea has not been touted as being as general as we believe it is, nor has it been further developed and systematically applied to the design of reusable software components.
Reference: [Sitaraman 93] <author> Sitaraman, M., Welch, </author> <title> L.R., and Harms, D.E. On specification of reusable software components. </title> <journal> Intl. J. of Software Eng. and Knowledge Eng. </journal> <volume> 3, 2 (1993), </volume> <pages> 207-219. </pages>
Reference: [Tracz 90] <author> Tracz, W. </author> <title> Where does reuse start? Software Eng. </title> <booktitle> Notes 15, </booktitle> <month> 2 (Apr. </month> <year> 1990), </year> <pages> 42-46. </pages>

References-found: 9

