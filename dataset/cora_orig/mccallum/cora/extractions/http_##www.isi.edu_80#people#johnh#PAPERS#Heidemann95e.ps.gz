URL: http://www.isi.edu:80/people/johnh/PAPERS/Heidemann95e.ps.gz
Refering-URL: http://www.isi.edu:80/people/johnh/PAPERS/Heidemann95e.html
Root-URL: http://www.isi.edu
Title: Stackable Design of File Systems  
Author: John Shelby Heidemann Gerald J. Popek, co-chair D. Stott Parker, co-chair Richard Muntz Rajive L. Bagrodia Kirby A. Baker 
Degree: A dissertation submitted in partial satisfaction of the requirements for the degree Doctor of Philosophy in Computer Science  Thesis committee:  
Date: September, 1995  
Address: Los Angeles  
Affiliation: University of California,  UCLA Computer Science Department  
Pubnum: Technical Report UCLA-CSD-950032  
Abstract-found: 0
Intro-found: 1
Reference: [ABG86] <author> Mike Accetta, Robert Baron, David Golub, Richard Rashid, Avadis Tevanian, and Mi-chael Young. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 93-113. </pages> <publisher> USENIX, </publisher> <month> June 9-13 </month> <year> 1986. </year>
Reference-contexts: While individual vendors have adopted new kernel technologies such as STREAMS [Rit84], new virtual memory approaches, and new file-systems, such additions have only come slowly and at considerable expense. Micro-kernel designs are one approach to kernel modularity. Kernels such as Mach <ref> [ABG86] </ref> and Chorus [RAA90] divide the operating system into two parts: a core of memory management, process control, and simple inter-process communication; and a server (or servers) supporting the remainder of the traditional operating system, including accounting, protection, file-system and network services, and backwards compatibility.
Reference: [And90] <author> Curtis Anderson. </author> <title> UNIX System V Extended File Attributes Feature Requirements Filesystem Dependent Attributes Issue 1 (Draft 3). </title> <booktitle> Unix International Memorandum, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: A convenient way to provide such additional storage would be through a generic extensible-attributes service. We have proto-typed such a system at UCLA [Wei95], and designs and implementations for other environments exist <ref> [And90, Dun90, Ols93] </ref>. Adoption of any one of these extended attribute services is another way to ease file-system development. Finally, we would like to move our stacking environment to a kernel with symmetric multiprocessing (SMP).
Reference: [AT90] <author> AT&T. </author> <title> Design of the Virtual File System Features for UNIX System V Release 4. Internal memorandum, </title> <month> January </month> <year> 1990. </year>
Reference-contexts: To aid future expansion of the interface, it allocates space for 32 additional operations <ref> [AT90] </ref>. (It also adds extra space in the in-memory vnode.) While these capabilities are a step towards a binary-interface standard for filing, they provide no support for third-party extensions, and they impose a significant space penalty [Ros90].
Reference: [Bac86] <author> Maurice J. Bach. </author> <title> The Design of the Unix Operating System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Madnick and Alsop [MA69], and later Madnick and Donovan [MD74] discuss modular and layered approaches to file-system design, concluding with a six-layer design. The design of Unix adopted simpler approaches, resulting in a two-layer design (file system and physical devices) <ref> [Bac86] </ref>. 11.1.2 Modular file-systems In the mid-1980s, pressure to add distributed filing systems prompted Unix vendors to develop several ab stract interfaces to filing services. The vnode interface at Sun [Kle86], the generic file-system interface at DEC [RKH86] and the file-system switch at AT&T are all examples of these interfaces.
Reference: [BB92] <author> D. S. Batory and J. R. Barnett. DaTE: </author> <title> The Genesis DBMS Software Layout Editor. </title> <editor> In Pericles Loucopoulos and Roberto Zicari, editors, </editor> <title> Conceptual modeling, databases, and CASE: an integrated view of information systems development, </title> <booktitle> chapter 8, </booktitle> <pages> pp. 201-221. </pages> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1992. </year>
Reference-contexts: Genesis decomposes the database into a number of separate services such as file storage, indexing, and data transformation. With the aid of an authoring tool <ref> [BB92] </ref>, a database implementor can create a custom database by selecting particular implementations from these services. The parallels between stackable filing and stackable databases in Genesis are strong. Both advocate the use of layers bounded by symmetric interfaces.
Reference: [BBG88] <author> D. S. Batory, J. R. Barnett, J. F. Garza, K. P. Smith, K. Tsukuda, B. C. Twichell, and T. E. Wise. </author> <title> GENESIS: An Extensible Database Management System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(11) </volume> <pages> 1711-1730, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: To our knowledge, we are the first to suggest that interesting services can be provided with only restricted kinds of state. 11.4 Extensible Databases in Genesis Genesis is a layered database management system developed at the University of Texas at Austin <ref> [BBG88] </ref>. Genesis decomposes the database into a number of separate services such as file storage, indexing, and data transformation. With the aid of an authoring tool [BB92], a database implementor can create a custom database by selecting particular implementations from these services. <p> Because our system has evolved to support cache coherence, we are able to present a before-and-after performance analysis of cache coherence. 11.8 Meta-Descriptions of Stacking Most of this chapter has discussed other systems which provide layering and stacking in some form. Inspired by their experiences with Genesis <ref> [BBG88] </ref> and Avoca [OP92] (a version of the x-kernel), Batory and O'Malley describe a meta-model for hierarchical software systems [BO92]. In their model hierarchical software systems are built from components. Each component is a member of a realm, a group of components which implement the same interface.
Reference: [BO92] <author> Don Batory and Seam O'Malley. </author> <title> The Design and Implementation of Hierarchical Software Systems with Reusable Components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <note> Oc-tober 1992. Also available as University of Texas TR-91-22. </note>
Reference-contexts: Genesis layers are distributed and managed as source code. This approach allows some performance optimizations. For example, binding of inter-layer operations can be done at compile time, implementing this binding as a standard function call <ref> [BO92] </ref>. It should be possible to use similar techniques to avoid data structure overheads (as we do with featherweight layering in a more restrictive context); it is not clear that Genesis employs this optimization. Genesis does not address the general issue of inter-layer state coherence. <p> Inspired by their experiences with Genesis [BBG88] and Avoca [OP92] (a version of the x-kernel), Batory and O'Malley describe a meta-model for hierarchical software systems <ref> [BO92] </ref>. In their model hierarchical software systems are built from components. Each component is a member of a realm, a group of components which implement the same interface. Components may be built from other components. A component is symmetric if it builds upon components from the same realm.
Reference: [Bon94] <author> Jeff Bonwick. </author> <title> The Slab Allocator: An Object-Caching Kernel Memory Allocator. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 87-98. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: This overhead represents the cost of setting up and maintaining cache-coherence data-structures. We expect that some of this cost can be avoided by internally preserving partially built data structures <ref> [Bon94] </ref>. Careful tuning and examination of fast-path opportunities could also likely improve our prototype system; we project that a production quality service is quite feasible. The cost of this overhead must also be weighed against the benefits of cache coherence. <p> A large vnode cache addresses this problem if vnodes are used repeatedly. Featherweight layers also avoid vnode creation by employing vnodes of their stacked-upon layer. Finally, when vnode allocation cannot be avoided, costs can be minimized using techniques such as those described by Bonwick <ref> [Bon94] </ref>. Bonwick suggests caching partially deallocated data structures. If such all cached objects share generic substructures requiring initialization (for example, locks in an SMP kernel), this initialization can be avoided by re-using the substructures left by the prior owner. <p> Others have suggested approaches to minimize or reduce the amount of state required in a layered sys 78 CHAPTER 11. RELATED WORK tem. Careful allocation techniques (for example, in the x-kernel [HMP89] and the slab memory allocator <ref> [Bon94] </ref>) reduce the cost of state initialization and reuse. Rosenthal [Ros90] limits the required per-vnode state to reduce vnode allocation costs. Finally, Massalin and others advocate run-time code generation to eliminate state [Mas92, KEH93].
Reference: [Cat92] <author> Vincent Cate. </author> <title> Alexa Global Filesystem. </title> <booktitle> In Proceedings of the Usenix File Systems Workshop, </booktitle> <pages> pp. 1-11, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: An approach common in the operating systems research community is to develop new services as user-level NFS servers (for example, see Deceit [SBM90], semantic filing [GJS91], and Alex <ref> [Cat92] </ref>). Because the NFS protocol is very well specified and nearly universally available, this approach is very robust to external change, but it offers no support for internal change. <p> Examples include replication in Deceit [SBM90], automatic semantic indexing [GJS91], and ftp-access through the file-system <ref> [Cat92] </ref>, among others. NFS-servers have several advantages as a development platform. The NFS protocol provides a well-defined and widely available interface to build upon, and a user-level server can build on a local disk or another NFS server for file storage.
Reference: [CBZ91] <author> John B. Carter, John K. Bennett, and Willy Zwaenepoel. </author> <title> Implementation and Performance of Munin. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Operating Systems Principles, </booktitle> <pages> pp. 152-164. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: In distributed shared memory systems software plays a larger role in coherence. Li proposes strong consistency with both centralized and distributed algorithms [LH86]. Recent work has focused on employing application-specific knowledge to relax the consistency model and obtain better performance <ref> [GLL90, CBZ91] </ref>. 11.2.3 Networking protocols We have already described early work concerning stacking of network protocols (for example, the Unix shell [PK84], the STREAMS I/O system [Rit84], and the x-kernel [HPA89]).
Reference: [DBR91] <author> Richard P. Draves, Brian N. Bershad, Rich-ard F. Rashid, and Randall W. Dean. </author> <title> Using Continuations to Implement Thread Management and Communication in Operating Systems. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Operating Systems Principles, </booktitle> <pages> pp. 122-136. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: Others have suggested that performance of layered systems is improved by avoiding a process-per-layer [Rit84, HP88] or by employing continuations <ref> [DBR91] </ref>. We improve file-system layering performance by restricting layer state. We expand on these issues in Section 11.3. 1.3 Road Map to the Dissertation The thesis of this dissertation is that stackable filing with an extensible interface improves file-system development. <p> Several groups advocate network layering without devoting a process per layer (see, for example, STREAMS [Rit84] and the x-kernel [HP88]). The x-kernel can bypass protocol layers to improve performance [OP92]. A version of Mach employs continuations to improve performance <ref> [DBR91] </ref>, again discarding the process. Proponents of such systems typically cite reduced overheads in memory usage and context-switch times. Others have suggested approaches to minimize or reduce the amount of state required in a layered sys 78 CHAPTER 11. RELATED WORK tem.
Reference: [Dij67] <author> Edsger W. Dijkstra. </author> <title> The structure of the THE multiprogramming system. </title> <booktitle> In Proceedings of the Symposium on Operating Systems Principles. ACM, </booktitle> <month> October </month> <year> 1967. </year>
Reference-contexts: Cache coherence builds upon distributed filing and distributed shared memory. In this section we briefly review research in these areas. 11.1.1 File-system structure Dijkstra describes early approaches to modular operating system design <ref> [Dij67, Dij68] </ref>. Madnick and Alsop [MA69], and later Madnick and Donovan [MD74] discuss modular and layered approaches to file-system design, concluding with a six-layer design.
Reference: [Dij68] <author> Edsger W. Dijkstra. </author> <title> Complexity controlled by hierarchical ordering of function and variability. </title> <booktitle> Working paper for the NATO conference on computer software engineering at Garmisch, </booktitle> <address> Germany, </address> <month> October </month> <year> 1968. </year>
Reference-contexts: Cache coherence builds upon distributed filing and distributed shared memory. In this section we briefly review research in these areas. 11.1.1 File-system structure Dijkstra describes early approaches to modular operating system design <ref> [Dij67, Dij68] </ref>. Madnick and Alsop [MA69], and later Madnick and Donovan [MD74] discuss modular and layered approaches to file-system design, concluding with a six-layer design.
Reference: [Dun90] <author> Ray Duncan. </author> <title> Power Programming: Using Long Filenames and Extended Attributes, Part 1. </title> <journal> PC Magazine, </journal> <volume> (April </volume> 24):317-328, 1990. 
Reference-contexts: Barring a lightweight state allocation mechanism, a general purpose layer provides an appropriate mechanism for services with private state. An extensible-attribute storage service (such as that described by Weidner [Wei95] or present in OS/2 <ref> [Dun90] </ref>) might allow on-disk private state. Full exploration of this potential is the subject of fu ture work. stacked-upon vnodes A featherweight layer is required to stack over exactly one other vnode. No fanout is possible (references to multiple stacked-upon vnodes would require private state). <p> A convenient way to provide such additional storage would be through a generic extensible-attributes service. We have proto-typed such a system at UCLA [Wei95], and designs and implementations for other environments exist <ref> [And90, Dun90, Ols93] </ref>. Adoption of any one of these extended attribute services is another way to ease file-system development. Finally, we would like to move our stacking environment to a kernel with symmetric multiprocessing (SMP).
Reference: [Flo86] <author> Rick Floyd. </author> <title> Short-Term File Reference Patterns in a UNIX Environment. </title> <type> Technical Report TR-177, </type> <institution> University of Rochester, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: As in this example, we expect that the majority of such access will be sequential. Floyd's studies of Unix applications in an academic environment suggest that 70-90% of opened files are read sequentially <ref> [Flo86] </ref>. For these cases, the sequential-update benchmark is representative. Sequential-update performance shows some system-time performance cost, but no noticeable elapsed-time performance penalty. The remaining random access case is exemplified by database applications. Recall, however, that the random-update benchmark is a stream of randomly located updates to random layers.
Reference: [GC89] <author> Cary Gray and David Cheriton. Leases: </author> <title> An Efficient Fault-Tolerant Mechanism for 99 100 APPENDIX B. CACHE-COHERENCE APPENDIX Distributed File Cache Consistency. </title> <booktitle> In Proceedings of the Twelfth Symposium on Operating Systems Principles, </booktitle> <pages> pp. 202-210. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: Later systems provide variations on the token algorithm: AFS's call-backs are essentially centrally-managed tokens [Kaz88]; Gray's leases are tokens that can time-out to simplify error recovery <ref> [GC89] </ref>. Cache coherence in stacking borrows the basic coherence approach used in these systems.
Reference: [GHM90] <author> Richard G. Guy, John S. Heidemann, Wai Mak, Thomas W. Page, Jr., Gerald J. Popek, and Dieter Rothmeier. </author> <title> Implementation of the Ficus Replicated File System. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 63 71. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: For example, a new secure remote filing service could be built by configuring encryption/decryption layers around the basic transport service. An example of the use of cooperating layers in the Ficus replicated file-system <ref> [GHM90] </ref> is shown in Figure 3.4. The logical and physical layers of the Ficus stack correspond roughly to a client and server of a replicated service. A remote access layer is placed between them when necessary. 3.5 Compatibility With Layers The flexibility stacking provides promotes rapid interface and layer evolution.
Reference: [GJS91] <author> David K. Gifford, Pierre Jouvelot, Mark A. Sheldon, and Jr. James W. O'Toole. </author> <title> Semantic File Systems. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Operating Systems Principles, </booktitle> <pages> pp. 16-25. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: An approach common in the operating systems research community is to develop new services as user-level NFS servers (for example, see Deceit [SBM90], semantic filing <ref> [GJS91] </ref>, and Alex [Cat92]). Because the NFS protocol is very well specified and nearly universally available, this approach is very robust to external change, but it offers no support for internal change. <p> Examples include replication in Deceit [SBM90], automatic semantic indexing <ref> [GJS91] </ref>, and ftp-access through the file-system [Cat92], among others. NFS-servers have several advantages as a development platform. The NFS protocol provides a well-defined and widely available interface to build upon, and a user-level server can build on a local disk or another NFS server for file storage.
Reference: [GLL90] <author> Kourosh Gharachorloo, Daniel Lenoski, James Laudon, Phillip Gibbons, Anoop Gupta, and John Hennessy. </author> <title> Memory Consistency and Event Ordering in Scalable Shared-Memory Multiprocessors. </title> <booktitle> In Proceedings of the 17th International Symposium on Computer Architecture, </booktitle> <pages> pp. 15-26. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1990. </year>
Reference-contexts: In distributed shared memory systems software plays a larger role in coherence. Li proposes strong consistency with both centralized and distributed algorithms [LH86]. Recent work has focused on employing application-specific knowledge to relax the consistency model and obtain better performance <ref> [GLL90, CBZ91] </ref>. 11.2.3 Networking protocols We have already described early work concerning stacking of network protocols (for example, the Unix shell [PK84], the STREAMS I/O system [Rit84], and the x-kernel [HPA89]).
Reference: [Gro92] <author> Unix International Stackable Files Working Group. </author> <title> Requirements for Stackable Files. </title> <booktitle> Unix International, </booktitle> <address> Parsippany, New Jersey, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: In our view a solution such as featherweight layering is required to extend stacking to exceedingly lightweight layers. 11.6.2 Skinner and Wong Skinner and Wong revised Rosenthal's stacking model [SW93] based on further experience with that model [Ros92] and prompted by Unix International's Stackable File-Systems Working Group <ref> [Gro92] </ref>. The primary innovation in their new model is to employ two kinds of file-system stacking: interposition and composition. Interposition retains the desirable features of Rosenthal's stacking mechanism.
Reference: [Hen90] <author> David Hendricks. </author> <title> A Filesystem for Software Development. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 333-340. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: None of these approaches provide explicit support for stacking or extensibility, but all provide basic modularity. 1.2.3 Stackable filing systems Sun Microsystems applied the vnode interface to build two-layer file system stacks in their loopback and translucent file-systems <ref> [Hen90] </ref>. Internal to the operating system, stacking is used to support device special files. More recently, Rosenthal [Ros90] and later Skinner and Wong [SW93] at SunSoft have experimented with a modified vnode interface to provide dynamic file-system stacking. <p> Limited file-system stacking is possible with the standard vnode interface using the mount mechanism. Sun Microsystems' NFS [SGK85], loopback, and translucent <ref> [Hen90] </ref> file-systems take this approach. Information associated with the mount command identifies the existing stack layer and where the new layer should be attached into the filing name space. 4.2 Extensibility in the UCLA Interface Accommodation of interface evolution is a critical problem with existing interfaces. <p> In Section 4.1 we briefly describe this interface, our changes, and the motivations for those changes. The standard vnode interface has been used to provide basic file-system stacking. Sun's loopback and translucent file-systems <ref> [Hen90] </ref>, and early versions of the Ficus file-system were all built with a standard vnode interface.
Reference: [HKM88] <author> John Howard, Michael Kazar, Sherri Men-ees, David Nichols andMahadev Satyanaray-ananand Robert Sidebotham, and Michael West. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 51-81, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: The first step compares a kernel supporting only the UCLA interface with a standard kernel. To do so, we consider two benchmarks: the modified Andrew benchmark <ref> [Ous90, HKM88] </ref> and the recursive copy and removal of large subdirectory trees. In addition, we examine the effect of adding multiple layers in the new interface. The Andrew benchmark has several phases, each of which examines different file-system activities.
Reference: [HMP89] <author> Norman C. Hutchinson, Shivakant Mishra, Larry L. Peterson, and Vicraj T. Thomas. </author> <title> Tools for Implementing Network Protocols. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 19(9) </volume> <pages> 895-916, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Proponents of such systems typically cite reduced overheads in memory usage and context-switch times. Others have suggested approaches to minimize or reduce the amount of state required in a layered sys 78 CHAPTER 11. RELATED WORK tem. Careful allocation techniques (for example, in the x-kernel <ref> [HMP89] </ref> and the slab memory allocator [Bon94]) reduce the cost of state initialization and reuse. Rosenthal [Ros90] limits the required per-vnode state to reduce vnode allocation costs. Finally, Massalin and others advocate run-time code generation to eliminate state [Mas92, KEH93].
Reference: [HP88] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <booktitle> Design of the x-Kernel. In Proceedings of the 1988 Symposium on Communications Architectures and Proto cols, </booktitle> <pages> pp. 65-75. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1988. </year>
Reference-contexts: ROAD MAP TO THE DISSERTATION 5 then applied these principles to kernel structure in his STREAMS I/O system [Rit84]. Such work has since been adopted in a number of versions of Unix. The x-kernel <ref> [HP88] </ref> is a new kernel designed originally to provide customized network protocols. Using a symmetric interface for all kernel services (everything is a protocol), great flexibility in protocol selection and combination is provided. <p> Others have suggested that performance of layered systems is improved by avoiding a process-per-layer <ref> [Rit84, HP88] </ref> or by employing continuations [DBR91]. We improve file-system layering performance by restricting layer state. We expand on these issues in Section 11.3. 1.3 Road Map to the Dissertation The thesis of this dissertation is that stackable filing with an extensible interface improves file-system development. <p> This concept appears many times in the literature in different forms. Several groups advocate network layering without devoting a process per layer (see, for example, STREAMS [Rit84] and the x-kernel <ref> [HP88] </ref>). The x-kernel can bypass protocol layers to improve performance [OP92]. A version of Mach employs continuations to improve performance [DBR91], again discarding the process. Proponents of such systems typically cite reduced overheads in memory usage and context-switch times.
Reference: [HP94] <author> John S. Heidemann and Gerald J. Popek. </author> <title> File-System Development with Stackable Layers. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(1) </volume> <pages> 58-89, </pages> <year> 1994. </year> <note> Preliminary version available as UCLA technical report CSD-930019. </note>
Reference: [HP95] <author> John Heidemann and Gerald Popek. </author> <title> Performance of Cache Coherence in Stackable Filing. </title> <booktitle> In Proceedings of the 15th Symposium on Operating Systems Principles. ACM, </booktitle> <month> December </month> <year> 1995. </year>
Reference: [HPA89] <author> Norman C. Hutchinson, Larry L. Peterson, Mark B. Abbott, and Sean O'Malley. </author> <title> RPC in the x-Kernel: Evaluating New Design Techniques. </title> <booktitle> In Proceedings of the Twelfth Symposium on Operating Systems Principles, </booktitle> <pages> pp. 91-101. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: Our experience shows that layers are most easily reusable and composable when each encompasses a single abstraction. This experience parallels those encountered in designing composable network protocols in the x-kernel <ref> [HPA89] </ref> and tool development with the Unix shells [PK84]. As an example of this problem in the context of filesystem layering, consider the stack presented in Figure 3.1. <p> Ritchie's conclusion is that STREAMS significantly reduces complexity and improves maintainability of this portion of the kernel. Since its development STREAMS has been widely adopted. The x-kernel is an operating system nucleus designed to simplify network protocol implementation by implementing all protocols as stackable layers <ref> [HPA89] </ref>. Key features are a uniform protocol interface, allowing arbitrary protocol composition; run-time choice of protocol stacks, allowing selection based on efficiency; and very inexpensive layer transition. The x-kernel demonstrates the effectiveness of layering in new protocol development in the network environment, and that performance need not suffer. <p> Recent work has focused on employing application-specific knowledge to relax the consistency model and obtain better performance [GLL90, CBZ91]. 11.2.3 Networking protocols We have already described early work concerning stacking of network protocols (for example, the Unix shell [PK84], the STREAMS I/O system [Rit84], and the x-kernel <ref> [HPA89] </ref>). Cache coherence is typically not an issue in networking systems since data that passes through the layers of a network stack is transient and so not suitable for caching.
Reference: [HR94] <author> Graham Hamilton and Sanjay Radia. </author> <title> Using Interface Inheritance to Address Problems in System Software Evolution. </title> <booktitle> In Proceedings of the AC Workshop on Interface Definition Languages. ACM, </booktitle> <month> January </month> <year> 1994. </year> <note> Also available as Sun Laboratories technical re port SMLI TR-93-21. </note>
Reference-contexts: Objects in Spring implement an interface specified by an interface-definition language <ref> [HR94] </ref>. Objects can be distributed transparently between the kernel, user-level servers, and remote machines. <p> However, with the exception of interposition, basic stacking in Spring is functionally similar to that provided by UCLA stacking. 11.7.2 Extensibility Spring manages interface extensibility through its object-oriented interface-definition language <ref> [HR94] </ref>. An interface is defined as a class; new versions inherit from this class to add features. Type-checking at both compile- and run-time can be used to insure that the client and provider of a service communicate with consistent interface versions.
Reference: [IEE90] <author> IEEE. </author> <title> Standard for Information technologyPortable Operating System Interface (POSIX)Part 1: System Application Programming Interface (API). </title> <note> Technical Report IEEE Std. 1003.1-1990, IEEE, 1990. Also available as ISO/IEC 9945-1: </note> <year> 1990s. </year>
Reference-contexts: By providing a common protocol between two subsystems, such an interface allows either or both systems to be replaced without change to the other. Improved modules can therefore be independently developed and added as desired, improving the computing environment. Interfaces such as POSIX.1 <ref> [IEE90] </ref> and NFS [SGK85] are examples of interfaces widely used to provide operating system and remote filing services. Because operating systems represent such a widely used service, the development of modular systems interfaces can have particularly wide impact. The best example of standard systems interfaces is probably POSIX.1.
Reference: [Joh92] <author> Michael K. Johnson. </author> <title> The Linux Kernel Hackers' Guide. </title> <note> Anonymous ftp as ftp://sunsite.unc.edu/pub/Linux/docs/linux doc-project/kernel-hackers-guide/khg 0.6.ps.gz, </note> <year> 1992. </year>
Reference-contexts: Unfortunately, there are at least three independently derived vnode interfaces in use currently (SunOS [Kle86], BSD [KM86], and Linux <ref> [Joh92] </ref>). Each system has a substantially different operation mix and collection of supporting services. Simple extensibility is insufficient to bridge these differences. Compatibility layers (see Section 3.5) offer substantial hope of addressing these differences, but technical challenges still remain.
Reference: [Kaz88] <author> Michael Leon Kazar. </author> <title> Synchronization and Caching Issues in the Andrew File System. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 31 43. </pages> <publisher> USENIX, </publisher> <month> February </month> <year> 1988. </year>
Reference-contexts: Locus provides strong coherence with a distributed token passing algorithm [PW85], while Sprite detects concurrent update at a central site and disables caching for coherence [NWO88]. Later systems provide variations on the token algorithm: AFS's call-backs are essentially centrally-managed tokens <ref> [Kaz88] </ref>; Gray's leases are tokens that can time-out to simplify error recovery [GC89]. Cache coherence in stacking borrows the basic coherence approach used in these systems.
Reference: [KEH93] <author> David Keppel, Susan J. Eggers, and Rob-ert R. Henry. </author> <title> Evaluating Runtime-Compiled Value-Specific Optimizations. B.3. </title> <type> CACHE-COHERENCE STORAGE OPTIONS 101 Technical Report 93-11-02, </type> <institution> University of Washington, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: RELATED WORK tem. Careful allocation techniques (for example, in the x-kernel [HMP89] and the slab memory allocator [Bon94]) reduce the cost of state initialization and reuse. Rosenthal [Ros90] limits the required per-vnode state to reduce vnode allocation costs. Finally, Massalin and others advocate run-time code generation to eliminate state <ref> [Mas92, KEH93] </ref>. To our knowledge, we are the first to suggest that interesting services can be provided with only restricted kinds of state. 11.4 Extensible Databases in Genesis Genesis is a layered database management system developed at the University of Texas at Austin [BBG88].
Reference: [Kim95] <author> Ted Kim. Frigate: </author> <title> An Object-oriented File-System.. </title> <type> Master's thesis, </type> <institution> University of California, </institution> <address> Los Angeles, </address> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: To divorce UCLA stacking from the mount-model of configuration, a typing layer would identify each file's configuration and then construct the corresponding vnode stack when the file is accessed. Kim's object-oriented filing system (under development at UCLA) represents approach to per-file typing <ref> [Kim95] </ref>. 4.3.3 Stack data caching When the same data is cached in different stack layers, cache incoherence becomes possible. <p> The best way to manage per-file stack configuration is less clear. A standard stack composition attribute, possibly stored in some kind of extensible attribute system, might provide a solution. One intriguing implementation of such a system in a slightly different context is contained in Kim's object-oriented filing work <ref> [Kim95] </ref>. More experience and wider deployment of such systems is required to evaluate the approach, however. Current disk-based file-systems are almost exclusively constructed as large, monolithic layers.
Reference: [Kle86] <author> S. R. Kleiman. Vnodes: </author> <title> An Architecture for Multiple File System Types in Sun Unix. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 238-247. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: Adoption of these new filing services has been slow in part because file systems are large, monolithic pieces of code with limited internal modularity. Although recent approaches to file-system modularity (such as Sun's VFS interface <ref> [Kle86] </ref>) allow easy substitution of entire file-systems, they do little to support modularity within file systems themselves. As a result, it is not easy to replace or enhance separate portions of the file system; for example, keeping the physical disk management and installing a new directory layer. <p> To provide for multiple file-systems, several file-system switch mechanisms have been developed <ref> [Kle86, RKH86, KM86] </ref>. These typically found quick use in the support of network file access [SGK85, RFH86] and have since been applied to the support of other file systems [Koe87]. <p> Sun Microsystems, for example, described their VFS architecture in the 1986 Summer Usenix proceedings <ref> [Kle86] </ref>. By many measures the VFS concept has been quite successful, but from a third-party point of view there are two major problems: * Few vendors have the same VFS inter face. * Few vendors provide release-to-release source or binary compatibility for VFS modules. <p> We describe this implementation here, beginning with a summary of the vnode interface and then examining important differences in our stackable interface. 4.1 Existing File-System Interfaces Sun's vnode interface is a good example of several filesystem switches developed for the Unix operating system <ref> [Kle86, RKH86] </ref>. All have the same goal, to support multiple file-system types in the same operating system. The vnode interface has been quite successful in this respect, providing dozens of different filing services in several versions of Unix. <p> Each sub-tree is allowed a completely separate implementation. Data encapsulation requires that these abstract data types for files and subtrees be manipulated only by a restricted set of operations. The operations supported by vnodes, the abstract data type for files, vary according to implementation (see <ref> [Kle86] </ref> and [KM86] for semantics of typical operations). To allow this generic treatment of vnodes, binding of desired function to correct implementation is delayed until kernel initialization. This is implemented by associating with each vnode type an operations vector identify 21 22 CHAPTER 4. <p> EVALUATION OF FEATHERWEIGHT LAYERING Chapter 11 Related Work File-system stacking builds on a long tradition of operating-systems research in modularity and layering. Our work at UCLA is derived directly from the vnode interface developed at Sun Microsystems <ref> [Kle86] </ref> as inspired by Ritchie's STREAMS I/O system [Rit84]. Two other groups have worked contemporaneously in file-system stacking. At SunSoft, Rosenthal and later Skinner and Wang evolved the vnode interface to support stacking [Ros90, SW93]. <p> The design of Unix adopted simpler approaches, resulting in a two-layer design (file system and physical devices) [Bac86]. 11.1.2 Modular file-systems In the mid-1980s, pressure to add distributed filing systems prompted Unix vendors to develop several ab stract interfaces to filing services. The vnode interface at Sun <ref> [Kle86] </ref>, the generic file-system interface at DEC [RKH86] and the file-system switch at AT&T are all examples of these interfaces. The primary initial motivation was networked filing, but vendors also introduced support for other physical and logical filing systems. One of these interfaces, Sun's vnode interface [Kle86], serves as a foundation <p> vnode interface at Sun <ref> [Kle86] </ref>, the generic file-system interface at DEC [RKH86] and the file-system switch at AT&T are all examples of these interfaces. The primary initial motivation was networked filing, but vendors also introduced support for other physical and logical filing systems. One of these interfaces, Sun's vnode interface [Kle86], serves as a foundation for our stackable file-systems work. In Section 4.1 we briefly describe this interface, our changes, and the motivations for those changes. The standard vnode interface has been used to provide basic file-system stacking. <p> Unfortunately, there are at least three independently derived vnode interfaces in use currently (SunOS <ref> [Kle86] </ref>, BSD [KM86], and Linux [Joh92]). Each system has a substantially different operation mix and collection of supporting services. Simple extensibility is insufficient to bridge these differences. Compatibility layers (see Section 3.5) offer substantial hope of addressing these differences, but technical challenges still remain.
Reference: [KM86] <author> Michael J. Karels and Marshall Kirk McK-usick. </author> <title> Toward a Compatible Filesystem Interface. </title> <booktitle> In Proceedings of the European Unix User's Group, </booktitle> <address> p. 15. EUUG, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: To provide for multiple file-systems, several file-system switch mechanisms have been developed <ref> [Kle86, RKH86, KM86] </ref>. These typically found quick use in the support of network file access [SGK85, RFH86] and have since been applied to the support of other file systems [Koe87]. <p> Each sub-tree is allowed a completely separate implementation. Data encapsulation requires that these abstract data types for files and subtrees be manipulated only by a restricted set of operations. The operations supported by vnodes, the abstract data type for files, vary according to implementation (see [Kle86] and <ref> [KM86] </ref> for semantics of typical operations). To allow this generic treatment of vnodes, binding of desired function to correct implementation is delayed until kernel initialization. This is implemented by associating with each vnode type an operations vector identify 21 22 CHAPTER 4. <p> Unfortunately, there are at least three independently derived vnode interfaces in use currently (SunOS [Kle86], BSD <ref> [KM86] </ref>, and Linux [Joh92]). Each system has a substantially different operation mix and collection of supporting services. Simple extensibility is insufficient to bridge these differences. Compatibility layers (see Section 3.5) offer substantial hope of addressing these differences, but technical challenges still remain.
Reference: [KN93a] <author> Yousef A. Khalidi and Michael N. Nelson. </author> <title> Extensible File Systems in Spring. </title> <booktitle> In Proceedings of the 14th Symposium on Operating Systems Principles. ACM, </booktitle> <month> Dec </month> <year> 1993. </year> <note> Also available as Sun Laboratories technical report SMLI TR-93-18. </note>
Reference-contexts: Internal to the operating system, stacking is used to support device special files. More recently, Rosenthal [Ros90] and later Skinner and Wong [SW93] at SunSoft have experimented with a modified vnode interface to provide dynamic file-system stacking. The Spring project (at Sun Laboratories) has also developed stackable filing technology <ref> [KN93a] </ref>. 1.2.4 Cache coherence Our cache-coherence protocols build upon two areas of prior research. First, we draw cache-coherence algorithms from research in the areas of hardware multiprocessing, distributed filing, and distributed shared memory. We review this work in Section 11.2. <p> First, we draw cache-coherence algorithms from research in the areas of hardware multiprocessing, distributed filing, and distributed shared memory. We review this work in Section 11.2. Second, we build upon the cache-coherent stacking work of the Spring project at Sun Laboratories <ref> [KN93a] </ref>. 1.2.5 Featherweight layering Featherweight layering is inspired by the observation that the performance of a layered system is often best when logically independent layers share implementation details. Others have suggested that performance of layered systems is improved by avoiding a process-per-layer [Rit84, HP88] or by employing continuations [DBR91]. <p> In a monolithic system such as the UFS, the same layer performs both of these operations. As first noted by the Spring project <ref> [KN93a] </ref>, successful layered caching benefits from a separation of these functions. In Spring terms, one object will serve as the pager, performing actual data I/O, while another object (the cacher) may be actively caching data. <p> Two other groups have worked contemporaneously in file-system stacking. At SunSoft, Rosenthal and later Skinner and Wang evolved the vnode interface to support stacking [Ros90, SW93]. The Spring project at Sun Laboratories instead has created a brand-new operating system supporting coherent, stackable filing <ref> [KN93a] </ref>. This chapter begins with a review of existing work in stacking and operating system modularity. We then examine recent approaches to file-system stacking, investigating their influences, similarities, and differences. 11.1 Stacking Fundamentals File-system stacking is grounded in work on file-system structure and symmetric interfaces. <p> Objects in Spring implement an interface specified by an interface-definition language [HR94]. Objects can be distributed transparently between the kernel, user-level servers, and remote machines. Notable features in Spring include a virtual memory system supporting external pagers [KN93b] and a coherent distributed filing system [NKM93] implemented with stackable layers <ref> [KN93a] </ref>. 11.7.1 Stacking Several aspects of file-system layering in Spring [KN93a] are similar to ours. In Spring, a filing service is provided by a layer which implements the Spring filing interface. An implementation of a filing layer might build upon other filing layers. <p> Objects can be distributed transparently between the kernel, user-level servers, and remote machines. Notable features in Spring include a virtual memory system supporting external pagers [KN93b] and a coherent distributed filing system [NKM93] implemented with stackable layers <ref> [KN93a] </ref>. 11.7.1 Stacking Several aspects of file-system layering in Spring [KN93a] are similar to ours. In Spring, a filing service is provided by a layer which implements the Spring filing interface. An implementation of a filing layer might build upon other filing layers. Layers are combined and configured using the Spring naming service [RNP93]. <p> Layers are combined and configured using the Spring naming service [RNP93]. In the terminology of Section 11.6.2, Spring employs composition to build layers. Section 5 of Khalidi and Nelson suggests that their object service provides a general mechanism for run-time object interposition <ref> [KN93a] </ref>, but few details of this mechanism are available. Spring also supports cache-coherence between layers; we describe this service below in Section 11.7.3. The Spring approach to stacking is aided the fact that Spring is a new operating system, built from scratch. <p> The virtual memory system includes support for distributed shared memory <ref> [KN93a] </ref>. Cache-coherent file-system stacking is a natural result of this architecture. The Spring cache-coherence work highlights two important results. First, the Spring developers recognize that separation of the data provider and the data manager is necessary for efficient, layered caching.
Reference: [KN93b] <author> Yousef A. Khalidi and Michael N. Nelson. </author> <title> The Spring Virtual Memory System. </title> <type> Technical Report SMLI TR-93-9, </type> <institution> Sun Microsys tems, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Page sharing: Allowing multiple layers to concurrently share the same physical page representation is a desirable optimization to avoid page thrashing and page duplication when two active layers have identical page contents. This optimization requires support from the VM system, like that provided by Spring <ref> [KN93b] </ref>. Unfortunately, the SunOS 4.x VM system serving as our test-bed associates each page with a single vnode, and so we were unable to explore this optimization. 7.3. APPLICATION AND OPTIMIZATIONS 43 represent layers; the figure as a whole represents a stack. <p> Objects in Spring implement an interface specified by an interface-definition language [HR94]. Objects can be distributed transparently between the kernel, user-level servers, and remote machines. Notable features in Spring include a virtual memory system supporting external pagers <ref> [KN93b] </ref> and a coherent distributed filing system [NKM93] implemented with stackable layers [KN93a]. 11.7.1 Stacking Several aspects of file-system layering in Spring [KN93a] are similar to ours. In Spring, a filing service is provided by a layer which implements the Spring filing interface.
Reference: [Koe87] <author> Matt Koehler. </author> <title> GFS Revisited or How I Lived with Four Different Local File Systems. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 291-305. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: To provide for multiple file-systems, several file-system switch mechanisms have been developed [Kle86, RKH86, KM86]. These typically found quick use in the support of network file access [SGK85, RFH86] and have since been applied to the support of other file systems <ref> [Koe87] </ref>. None of these approaches provide explicit support for stacking or extensibility, but all provide basic modularity. 1.2.3 Stackable filing systems Sun Microsystems applied the vnode interface to build two-layer file system stacks in their loopback and translucent file-systems [Hen90].
Reference: [KP84] <author> Brian W. Kernighan and Rob Pike. </author> <title> The Unix Programming Environment. </title> <publisher> Prentice-Hall, </publisher> <year> 1984. </year>
Reference-contexts: RELATED WORK 11.1.4 Symmetric interfaces Unix shell programming with pipes [RT74] is an example of a widely used symmetric interface. Pike and Kernighan describe this work for software development [PK84]; other applications are as rich as text formatting <ref> [KP84] </ref> and music processing [Lan90]. Ritchie applied these principles to one kernel subsystem with the STREAMS device I/O system [Rit84]. Ritchie's system constructs terminal and network protocols by composing stackable modules which may be added and removed during operation.
Reference: [Kue91] <author> Geoff Kuenning. </author> <title> Comments on CS239 Class Projects. </title> <type> Personal communication, </type> <month> June </month> <year> 1991. </year>
Reference-contexts: It also considered how layering can improve the file-system development by allowing code reuse and out-of-kernel development. To summarize the development environment, consider the comments of one of the students who developed a file-system layer <ref> [Kue91] </ref>: For me, the really big advantage of the stackable layers was the ease of development. Combined with the ook [out-of-kernel] development, the testing cycle was vastly shorter than other kernel work I've done.
Reference: [Kue95] <author> Geoffrey H. Kuenning. Kitrace: </author> <title> Precise Interactive Measurement of Operating Systems Kernels. </title> <journal> SoftwarePractice and Experi ence, </journal> <volume> 25(1) </volume> <pages> 1-22, </pages> <month> January </month> <year> 1995. </year>
Reference: [Lan90] <author> Peter S. Langston. </author> <title> Unix Music Tools at Bellcore. </title> <editor> SoftwarePractice and Experi ence, 20(S1):47-61, </editor> <month> June </month> <year> 1990. </year>
Reference-contexts: RELATED WORK 11.1.4 Symmetric interfaces Unix shell programming with pipes [RT74] is an example of a widely used symmetric interface. Pike and Kernighan describe this work for software development [PK84]; other applications are as rich as text formatting [KP84] and music processing <ref> [Lan90] </ref>. Ritchie applied these principles to one kernel subsystem with the STREAMS device I/O system [Rit84]. Ritchie's system constructs terminal and network protocols by composing stackable modules which may be added and removed during operation.
Reference: [LH86] <author> Kai Li and Paul Hudak. </author> <title> Memory Coherence in Shared Virtual Memory Systems. </title> <booktitle> In Proceedings of the Fifth Annual ACM Symposium on Principles of Distributed Comput ing, </booktitle> <pages> pp. 229-239. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1986. </year>
Reference-contexts: More sophisticated systems broadcast and multicast coherence information to some or all processors. The constraints of a hardware implementation limit the scale of these approaches. In distributed shared memory systems software plays a larger role in coherence. Li proposes strong consistency with both centralized and distributed algorithms <ref> [LH86] </ref>. Recent work has focused on employing application-specific knowledge to relax the consistency model and obtain better performance [GLL90, CBZ91]. 11.2.3 Networking protocols We have already described early work concerning stacking of network protocols (for example, the Unix shell [PK84], the STREAMS I/O system [Rit84], and the x-kernel [HPA89]).
Reference: [MA69] <author> Stuart E. Madnick and Joseph W. Alsop, </author> <title> II. A modular approach to file system design. </title> <booktitle> In AFIPS Conference Proceedings Spring Joint Computer Conference, </booktitle> <pages> pp. 1-13. </pages> <publisher> AFIPS Press, </publisher> <month> May </month> <year> 1969. </year>
Reference-contexts: Cache coherence builds upon distributed filing and distributed shared memory. In this section we briefly review research in these areas. 11.1.1 File-system structure Dijkstra describes early approaches to modular operating system design [Dij67, Dij68]. Madnick and Alsop <ref> [MA69] </ref>, and later Madnick and Donovan [MD74] discuss modular and layered approaches to file-system design, concluding with a six-layer design.
Reference: [Mas92] <author> Henry Massalin. </author> <title> Synthesis: An Efficient Implementation of Fundamental Operating System Services. </title> <type> PhD thesis, </type> <institution> Columbia Uni versity, </institution> <year> 1992. </year>
Reference-contexts: RELATED WORK tem. Careful allocation techniques (for example, in the x-kernel [HMP89] and the slab memory allocator [Bon94]) reduce the cost of state initialization and reuse. Rosenthal [Ros90] limits the required per-vnode state to reduce vnode allocation costs. Finally, Massalin and others advocate run-time code generation to eliminate state <ref> [Mas92, KEH93] </ref>. To our knowledge, we are the first to suggest that interesting services can be provided with only restricted kinds of state. 11.4 Extensible Databases in Genesis Genesis is a layered database management system developed at the University of Texas at Austin [BBG88].
Reference: [McK95] <author> Marshall Kirk McKusick. </author> <title> The Virtual Filesystem Interface in 4.4BSD. </title> <journal> Computing Systems, </journal> <volume> 8(1) </volume> <pages> 3-26, </pages> <month> Winter </month> <year> 1995. </year>
Reference-contexts: With multi-layer access a backup program can bypass the compression layer and directly transfer the compressed data to the backup media, saving both time and backup storage. Multi-layer access can be directly employed by users. Union-mounts in Plan 9 [PPT91] and 4.4BSD <ref> [McK95] </ref> for example, create a single unified directory from several underlying directories, yet users may need access to the underlying directories to install new software. A user 3.5. <p> CLOSING REMARKS 87 ing the vnode interface internally between UFS directory routines and the on-disk log-structured and fast filesystems <ref> [McK95] </ref>. Unfortunately it is not currently possible to separate these services into independent layers. 12.2.3 Extensibility Our approach to extensibility has worked well, both by allowing us to add to the interface and in managing interface changes from the operating-systems vendor.
Reference: [MD74] <author> Stuart E. Madnick and John J. Donovan. </author> <title> Op erating Systems. </title> <publisher> McGraw-Hill, </publisher> <year> 1974. </year>
Reference-contexts: Cache coherence builds upon distributed filing and distributed shared memory. In this section we briefly review research in these areas. 11.1.1 File-system structure Dijkstra describes early approaches to modular operating system design [Dij67, Dij68]. Madnick and Alsop [MA69], and later Madnick and Donovan <ref> [MD74] </ref> discuss modular and layered approaches to file-system design, concluding with a six-layer design.
Reference: [MGH94] <author> James G Mitchell, Jonathan J. Gibbons, Graham Hamilton, Peter B. Kessler, Yousef A. Khalidi, Panos Kougiouris, Peter W. Madany, Michael N. Nelson, Michael L. Powell, and Sanjay R. Radia. </author> <title> An Overview of the Spring System. </title> <booktitle> In Proceedings of the Spring 1994 IEEE COMPCON. IEEE, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: We agree with their analysis that future work and prototyping is required before transaction support will be widely accepted at the vnode level. 11.7 Spring The Spring operating system is an object-based, distributed operating system developed at Sun Laboratories <ref> [MGH94] </ref>. Objects in Spring implement an interface specified by an interface-definition language [HR94]. Objects can be distributed transparently between the kernel, user-level servers, and remote machines.
Reference: [MJL84] <author> Marshall McKusick, William Joy, Samuel Leffler, and R. Fabry. </author> <title> A Fast File System for UNIX. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 181-197, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Our test machine runs a modified version of SunOS 4.1.1. All data is stored in a stack-enabled version of the standard SunOS 4.1.1 file-system (UFS), a version of Berkeley's Fast Filesystem <ref> [MJL84] </ref>. For multi-layer tests we add one or more null layers.
Reference: [NKM93] <author> Michael N. Nelson, Yousef A. Khalidi, and Peter W. Madany. </author> <title> The Spring File System. </title> <type> Technical Report SMLI TR-93-10, </type> <institution> Sun Mi crosystems, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Objects in Spring implement an interface specified by an interface-definition language [HR94]. Objects can be distributed transparently between the kernel, user-level servers, and remote machines. Notable features in Spring include a virtual memory system supporting external pagers [KN93b] and a coherent distributed filing system <ref> [NKM93] </ref> implemented with stackable layers [KN93a]. 11.7.1 Stacking Several aspects of file-system layering in Spring [KN93a] are similar to ours. In Spring, a filing service is provided by a layer which implements the Spring filing interface. An implementation of a filing layer might build upon other filing layers.
Reference: [NWO88] <author> Michael N. Nelson, Brent B. Welch, and John K. Ousterhout. </author> <title> Caching in the Sprite Network File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 134-154, </pages> <month> Febru ary </month> <year> 1988. </year>
Reference-contexts: Locus provides strong coherence with a distributed token passing algorithm [PW85], while Sprite detects concurrent update at a central site and disables caching for coherence <ref> [NWO88] </ref>. Later systems provide variations on the token algorithm: AFS's call-backs are essentially centrally-managed tokens [Kaz88]; Gray's leases are tokens that can time-out to simplify error recovery [GC89]. Cache coherence in stacking borrows the basic coherence approach used in these systems.
Reference: [Ols93] <author> Michael A. Olson. </author> <title> The Design and Implementation of the Inversion File System. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pp. 205 217. </pages> <publisher> USENIX, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: A convenient way to provide such additional storage would be through a generic extensible-attributes service. We have proto-typed such a system at UCLA [Wei95], and designs and implementations for other environments exist <ref> [And90, Dun90, Ols93] </ref>. Adoption of any one of these extended attribute services is another way to ease file-system development. Finally, we would like to move our stacking environment to a kernel with symmetric multiprocessing (SMP).
Reference: [OP92] <author> Sean W. O'Malley and Larry L. </author> <note> Peterson. </note>
Reference-contexts: This concept appears many times in the literature in different forms. Several groups advocate network layering without devoting a process per layer (see, for example, STREAMS [Rit84] and the x-kernel [HP88]). The x-kernel can bypass protocol layers to improve performance <ref> [OP92] </ref>. A version of Mach employs continuations to improve performance [DBR91], again discarding the process. Proponents of such systems typically cite reduced overheads in memory usage and context-switch times. Others have suggested approaches to minimize or reduce the amount of state required in a layered sys 78 CHAPTER 11. <p> Inspired by their experiences with Genesis [BBG88] and Avoca <ref> [OP92] </ref> (a version of the x-kernel), Batory and O'Malley describe a meta-model for hierarchical software systems [BO92]. In their model hierarchical software systems are built from components. Each component is a member of a realm, a group of components which implement the same interface.
References-found: 53

