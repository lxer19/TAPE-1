URL: ftp://ftp.cse.ogi.edu/pub/tech-reports/1993/93-TH-002.ps.gz
Refering-URL: http://www.cse.ogi.edu/PacSoft/projects/SDRR/p_tools.html
Root-URL: http://www.cse.ogi.edu
Title: An Implementation of Reynolds' Defunctionalization Method for a Modern Functional Language  
Author: Jeffrey M. Bell 
Degree: A thesis submitted to the faculty of the Oregon Graduate Institute of Science Technology in partial fulfillment of the requirements for the degree Master of Science in Computer Science and Engineering  
Date: November 1993  
Abstract-found: 0
Intro-found: 1
Reference: [BJ82] <author> Dines Bjtrner and Cliff B. Jones. </author> <booktitle> Formal Specification and Software Development, </booktitle> <pages> pages 277-280. </pages> <publisher> Prentice-Hall, </publisher> <year> 1982. </year>
Reference-contexts: Motivations for this include detection of stack-based environments [Sch88], detection of global variables [Sch85a], and deriving an implementation of the specification <ref> [BJ82, Sch85b, Wan85] </ref>. Reynolds' method is more powerful than the specialization method of Chin and Darlington because it is not limited to variable-only function valued arguments. However, a defunctionalized program is only pseudo first-order [CD93] because it still mimics the runtime characteristics of the original higher order program.
Reference: [CD93] <author> Wei-Ngan Chin and John Darlington. </author> <title> Higher-order removal: A modular approach. Unpublished work, </title> <year> 1993. </year>
Reference-contexts: Defunctionalization [Rey72], firstification [Nel91], or higher-order removal <ref> [CD93] </ref> is the process of eliminating higher order functions from a program, while preserving the semantics of the program. <p> In fact, a "stronger" form of uncurrying is assumed to have been done to input programs for the defunctionalization system. This transformation ensures that each function has only one argument, which may be a tuple. 1.2 Hof Elimination via Specialization Chin and Darlington <ref> [CD93] </ref> have developed a Hof elimination algorithm based on fold/unfold rules that uses specialization. The following example demonstrates the algorithm. The program below contains a Hof called map, which applies a function to each argument in a list. <p> Reynolds' method is more powerful than the specialization method of Chin and Darlington because it is not limited to variable-only function valued arguments. However, a defunctionalized program is only pseudo first-order <ref> [CD93] </ref> because it still mimics the runtime characteristics of the original higher order program. Chin and Darlington's method produces more efficient implementations.
Reference: [MFP91] <author> Erik Meijer, Maarten Fokkinga, and Ross Patterson. </author> <title> Functional programming with bananas, lenses, envelopes, and barbed wire. </title> <booktitle> In Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, MA, </address> <month> August </month> <year> 1991. </year> <title> Springer Verlag. </title> <booktitle> Lecture Notes in Computer Science Volume 523. </booktitle>
Reference-contexts: For hh`x + yii to be well typed, x must be an erep. So if x evaluates to App (Id "f "; Id "z"), the program fragment represents the expression (f z) + y. 3.2 Control Structure A fold function (also known as a reduce function or catamorphism <ref> [MFP91] </ref>) is a useful control structure for performing computations on values in a sum-of-products datatype. There is a fold function specific to each such datatype. The arguments to a fold function include a set of accumulator functions and a value in the datatype.
Reference: [Nel91] <author> George C. Nelan. Firstification. </author> <type> PhD thesis, </type> <institution> Arizona State University, </institution> <month> Decem-ber </month> <year> 1991. </year>
Reference-contexts: Defunctionalization [Rey72], firstification <ref> [Nel91] </ref>, or higher-order removal [CD93] is the process of eliminating higher order functions from a program, while preserving the semantics of the program.
Reference: [Pau91] <author> Laurence C. Paulson. </author> <booktitle> ML for the Working Programmer, </booktitle> <pages> pages 377-381. </pages> <publisher> Cam-bridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: The least general type is determined via type unification. The unification algorithm used for this is taken from <ref> [Pau91] </ref>. This algorithm either successfully unifies a list of type representations and returns a list of substitutions or fails. If the unification succeeds, the substitutions are performed on one of the type representations, yielding the least general type of the types.
Reference: [Rey72] <author> John C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proceedings of the 25th ACM National Conference, </booktitle> <pages> pages 717-740. </pages> <publisher> ACM, </publisher> <year> 1972. </year>
Reference-contexts: Introduction 1.1 Higher Order Functions and Their Elimination Higher order functions (Hofs) are either 1. functions with arguments that are themselves functions 2. functions that return function values Fold functions are common examples of Hofs of the first sort, and curried functions are examples of the second sort. Defunctionalization <ref> [Rey72] </ref>, firstification [Nel91], or higher-order removal [CD93] is the process of eliminating higher order functions from a program, while preserving the semantics of the program. <p> Reynolds outlined a more general method for eliminating higher order functions known as defunctionalization <ref> [Rey72] </ref>. The key to this method is representing Fvps as data values. When Fvps are transformed into data values, higher order functions become first order, since they no longer have functions as arguments.
Reference: [Sch85a] <author> David A. Schmidt. </author> <title> Detecting global variables in denotational specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(2) </volume> <pages> 299-310, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Motivations for this include detection of stack-based environments [Sch88], detection of global variables <ref> [Sch85a] </ref>, and deriving an implementation of the specification [BJ82, Sch85b, Wan85]. Reynolds' method is more powerful than the specialization method of Chin and Darlington because it is not limited to variable-only function valued arguments.
Reference: [Sch85b] <author> David A. Schmidt. </author> <title> An implementation from a direct semantics definition. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 217 </volume> <pages> 222-235, </pages> <year> 1985. </year> <pages> 98 99 </pages>
Reference-contexts: Motivations for this include detection of stack-based environments [Sch88], detection of global variables [Sch85a], and deriving an implementation of the specification <ref> [BJ82, Sch85b, Wan85] </ref>. Reynolds' method is more powerful than the specialization method of Chin and Darlington because it is not limited to variable-only function valued arguments. However, a defunctionalized program is only pseudo first-order [CD93] because it still mimics the runtime characteristics of the original higher order program.
Reference: [Sch88] <author> David A. Schmidt. </author> <title> Detecting stack-based environments in denotational definitions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 11(2) </volume> <pages> 107-131, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Motivations for this include detection of stack-based environments <ref> [Sch88] </ref>, detection of global variables [Sch85a], and deriving an implementation of the specification [BJ82, Sch85b, Wan85]. Reynolds' method is more powerful than the specialization method of Chin and Darlington because it is not limited to variable-only function valued arguments.
Reference: [She93] <author> Tim Sheard. </author> <title> Guide to using CRML, Compile-Time Reflective ML. </title> <type> Technical report, </type> <institution> Oregon Graduate Institute of Science and Technology, </institution> <year> 1993. </year>
Reference-contexts: Other minor restrictions to Firstify input are listed in the final chapter of this thesis. The input and output to Firstify are in the form of Standard ML programs, expressed as lists of declarations in the CRML abstract syntax. CRML, or Compile-Time Reflective ML <ref> [She93] </ref>, is a reflective dialect of ML which allows ML declarations, expressions, patterns, and types to be represented as data. Firstify is written in CRML. 1.6 Problem Examples This section outlines problems addressed in this thesis by showing an example illustrating each problem.
Reference: [Wan85] <author> Mitchell Wand. </author> <title> From interpreter to compiler: A representational derivation. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 217 </volume> <pages> 306-324, </pages> <year> 1985. </year>
Reference-contexts: Motivations for this include detection of stack-based environments [Sch88], detection of global variables [Sch85a], and deriving an implementation of the specification <ref> [BJ82, Sch85b, Wan85] </ref>. Reynolds' method is more powerful than the specialization method of Chin and Darlington because it is not limited to variable-only function valued arguments. However, a defunctionalized program is only pseudo first-order [CD93] because it still mimics the runtime characteristics of the original higher order program.
References-found: 11

