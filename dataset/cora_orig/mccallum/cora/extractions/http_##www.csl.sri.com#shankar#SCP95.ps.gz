URL: http://www.csl.sri.com/shankar/SCP95.ps.gz
Refering-URL: http://www.csl.sri.com/shankar/
Root-URL: 
Email: shankar@csl.sri.com  
Phone: Phone: +1 (415) 859-5272 Fax: +1 (415) 859-2844  
Title: Steps Towards Mechanizing Program Transformations Using PVS  
Author: Natarajan Shankar 
Web: URL: http://www.csl.sri.com/~shankar/shankar.html  
Address: Menlo Park CA 94025 USA  
Affiliation: Computer Science Laboratory SRI International  
Abstract: PVS is a highly automated framework for specification and verification. We show how the language and deduction features of PVS can be used to formalize, mechanize, and apply some useful program transformation techniques. We examine two such examples in detail. The first is a fusion theorem due to Bird where the composition of a catamorphism (a recursive operation on the structure of a datatype) and an anamorphism (an operation that constructs instances of the datatype) is fused to eliminate the intermediate data structure. The second example is Wand's continuation-based transformation technique for deriving tail-recursive functions from non-tail-recursive ones. These examples illustrate the utility of the language and inference features of PVS in capturing these transformations in a simple, general, and useful form. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Richard S. Bird. </author> <title> Functional algorithm design. </title> <editor> In Bernhard Moller, editor, </editor> <booktitle> Mathematics of Program Construction '95, number 947 in Lecture Notes in Computer Science, </booktitle> <pages> pages 2-17. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: This research has been supported by NSF Grant CCR-930044 and ARPA under contract PR8556. Some of the work reported here was inspired by Richard Bird's talk at the conference and the related paper <ref> [1] </ref>. The feedback from the 1995 Dagstuhl workshop on induction theorem proving was also valuable. Healfdene Goguen, Bern-hard Moller, Sam Owre, Harald Ruess, John Rushby, and Mandayam Srivas supplied valuable comments on draft versions of this paper. <p> We observe that the specification language and inference mechanisms of PVS are quite effective for the task of formalizing and verifying program transformations, but are not without certain drawbacks. Richard Bird <ref> [1] </ref> makes a persuasive argument that functional programming can be used to elegantly derive reasonably efficient analogues of imperative algorithms. <p> (LAMBDA x, i, j: i + j + 1))(A) ordered?(A) : RECURSIVE bool = (IF node?(A) THEN (every ((LAMBDA y: y&lt;=val (A)), left (A)) AND every ((LAMBDA y: val (A)&lt;=y), right (A)) AND ordered?(left (A)) AND ordered?(right (A))) ELSE TRUE ENDIF) MEASURE size END obt 4 Bird's Fusion Transformation Bird <ref> [1] </ref> starts with the example of an applicative quicksort function which he shows can be obtained as a fusion of the composition of: (i) a mktree function (an anamorphism) which constructs an ordered binary tree from a given list, and (ii) a flatten function (a catamorphism) which flattens the ordered binary <p> It involved a fair amount of case analysis but the potentially laborious aspects of the proof were handled by the decision procedures. 6 Conclusions We have studied the verification of two specific forms of program transformation using PVS. The first is a fusion theorem due to Bird <ref> [1] </ref> that can be used to eliminate the intermediate data structure in the composition of two recursive functions in order to obtain a more efficient algorithm.
Reference: [2] <author> Adel Bouhoula. SPIKE: </author> <title> a system for sufficient completeness and parameterized inductive proofs (system description). </title> <editor> In A. Bundy, editor, </editor> <booktitle> Automated Deduction | CADE-12, number 814 in Lecture Notes in Computer Science, </booktitle> <pages> pages 836-840. </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: This specification makes aggressive use of sub-typing and dependent typing to constrain the fi argument to be at least ff, 7 The SPIKE theorem prover is based on first-order term-rewriting and successfully mechanizes mutual recursion and simultaneous induction <ref> [2] </ref>. 21 and the search result to lie in the subrange between ff and fi. The proof was only moderately difficult.
Reference: [3] <author> R. S. Boyer and J. S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: Similarly, the abstract datatype of stacks is generated by the constructors empty and 2 The abstract datatype mechanism of PVS is partly inspired by the shell principle used in the Boyer-Moore theorem prover <ref> [3] </ref>. Similar mechanisms exist in a number of other specification and programming languages [5, 10, 13]. 4 push.
Reference: [4] <author> Alan Bundy, Frank van Harmalen, Jane Hesketh, and Alan Smaill. </author> <title> Experiments with proof plans for induction. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 7(3) </volume> <pages> 303-324, </pages> <month> September </month> <year> 1991. </year>
Reference: [5] <author> R. L. Constable, </author> <title> et al . Implementing Mathematics with the Nuprl. </title> <publisher> Prentice-Hall, </publisher> <address> New Jersey, </address> <year> 1986. </year>
Reference-contexts: Similarly, the abstract datatype of stacks is generated by the constructors empty and 2 The abstract datatype mechanism of PVS is partly inspired by the shell principle used in the Boyer-Moore theorem prover [3]. Similar mechanisms exist in a number of other specification and programming languages <ref> [5, 10, 13] </ref>. 4 push. An unordered list or a bag is an example of a data structure that is not freely generated since two different sequences of insertions of elements into a bag can yield equivalent bags.
Reference: [6] <author> D. Cyrluk, S. Rajan, N. Shankar, and M. K. Srivas. </author> <title> Effective theorem proving for hardware verification. </title> <editor> In Ramayya Kumar and Thomas Kropf, editors, </editor> <booktitle> Theorem Provers in Circuit Design (TPCD '94), volume 910 of Lecture Notes in Computer Science, </booktitle> <pages> pages 203-222, </pages> <address> Bad Herrenalb, Germany, September 1994. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: The PVS proof checker tries to strike a careful balance between an automatic theorem prover and a low-level proof checker. Through the use of BDD-based simplification, simple PVS proof strategies can be defined for efficiently and automatically verifying simple processor designs and N-bit arithmetic circuits <ref> [6] </ref>. A useful strategy for well-founded induction (specifically, measure induction) was defined during the course of this work. This strategy is defined in terms of the existing measure-induct and induct-and-simplify strategies.
Reference: [7] <author> David Cyrluk, Patrick Lincoln, Steven Miller, Paliath Narendran, Sam Owre, Sreeranga Ragan, John Rushby, Natarajan Shankar, Jens Ulrik Skakkebk, Mandayam Srivas, and Friedrich von Henke. </author> <title> Seven papers on mechanized formal verification. </title> <type> Technical Report SRI-CSL-95-3, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: Model checking with theorem proving. The details of this are not relevant to this paper. See [16, 19] for more details. A variety of examples have been verified using PVS <ref> [7] </ref>.
Reference: [8] <author> Axel Dold. </author> <title> Representing, verifying and applying software development steps using the PVS system. </title> <editor> In V. S. Alagar and Maurice Nivat, editors, </editor> <booktitle> Algebraic Methodology and Software Technology, AMAST'95, number 936 in Lecture Notes in Computer Science, </booktitle> <pages> pages 431-445, </pages> <address> Montreal, Canada, July 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In general, the insights and techniques underlying such transformations are also useful in other domains such as hardware verification. 1 The results in this paper constitute preliminary steps towards mechanizing program transformation techniques using the general-purpose verification system PVS. Dold <ref> [8] </ref> has already verified a divide-and-conquer scheme using PVS and has instantiated it to synthesize a binary search algorithm for arrays. Ruess [18] has carried out a similar development using the type theory of LEGO [11]. Neither of these efforts achieves the level of mechanization claimed below.
Reference: [9] <author> M. J. Gordon, A. J. Milner, and C. P. Wadsworth. </author> <title> Edinburgh LCF, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1979. </year>
Reference-contexts: PVS also uses BDD-based propositional simplification so that it can combine the capability of simplifying very large propositional expressions with equality, arithmetic, induction, and rewriting. Higher-level inference steps can be defined by means of strategies (akin to LCF tactics <ref> [9] </ref>) written in a simple strategy language. Typical strategies include heuristic instantiation of quantifiers, propositional and arithmetic simplification, and induction and rewriting. The PVS proof checker tries to strike a careful balance between an automatic theorem prover and a low-level proof checker.
Reference: [10] <author> M. J. C. Gordon and T. F. Melham, </author> <title> editors. Introduction to HOL: A Theorem Proving Environment for Higher-Order Logic. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1993. </year> <month> 23 </month>
Reference-contexts: Similarly, the abstract datatype of stacks is generated by the constructors empty and 2 The abstract datatype mechanism of PVS is partly inspired by the shell principle used in the Boyer-Moore theorem prover [3]. Similar mechanisms exist in a number of other specification and programming languages <ref> [5, 10, 13] </ref>. 4 push. An unordered list or a bag is an example of a data structure that is not freely generated since two different sequences of insertions of elements into a bag can yield equivalent bags.
Reference: [11] <author> Z. Luo and R. Pollack. </author> <title> The LEGO proof development system: A user's manual. </title> <type> Technical Report ECS-LFCS-92-211, </type> <institution> University of Edinburgh, </institution> <year> 1992. </year>
Reference-contexts: Dold [8] has already verified a divide-and-conquer scheme using PVS and has instantiated it to synthesize a binary search algorithm for arrays. Ruess [18] has carried out a similar development using the type theory of LEGO <ref> [11] </ref>. Neither of these efforts achieves the level of mechanization claimed below. Most of the theorems in this paper are proved by a single PVS proof step that invokes a strategy for measure induction.
Reference: [12] <author> Steven P. Miller and Mandayam Srivas. </author> <title> Formal verification of the AAMP5 microprocessor: A case study in the industrial use of formal methods. </title> <booktitle> In WIFT '95: Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <pages> pages 2-16, </pages> <address> Boca Raton, FL, 1995. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: See [16, 19] for more details. A variety of examples have been verified using PVS [7]. The most substantial use of PVS has been in the verification of the microcode for selected instructions of a commercial-scale microprocessor called AAMP5 designed by Rockwell-Collins <ref> [12] </ref>. 3 Abstract Datatypes in PVS Like many other specification and programming language, PVS has a construct for defining (possibly) recursive abstract datatypes corresponding to data structures that are freely generated by a collection of constructor operations.
Reference: [13] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Similarly, the abstract datatype of stacks is generated by the constructors empty and 2 The abstract datatype mechanism of PVS is partly inspired by the shell principle used in the Boyer-Moore theorem prover [3]. Similar mechanisms exist in a number of other specification and programming languages <ref> [5, 10, 13] </ref>. 4 push. An unordered list or a bag is an example of a data structure that is not freely generated since two different sequences of insertions of elements into a bag can yield equivalent bags.
Reference: [14] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Many others at SRI and elsewhere have contributed to PVS in important ways. Preprint submitted to Elsevier Science 11 March 1996 using special-purpose tools such as the KIDS system [21]. This paper examines the utility of the general-purpose verification system PVS <ref> [14, 19] </ref>, for mechanizing program transformation. The main challenge is that program transformations are normally expressed and applied in metatheoretic, i.e., syntactic, form and are therefore not easily formalized in a formal specification logic. <p> Even so, several challenges remain as fodder for future research. 2 A Brief Introduction to PVS PVS (Prototype Verification System) is intended as an environment for constructing clear and precise specifications and for developing readable proofs that have been mechanically verified <ref> [14, 19] </ref>. While many of the individual ideas in the system pre-date PVS, what is new in PVS is the coherent realization of these ideas in a single system. The key elements of the PVS design are captured by the combination of features listed below.
Reference: [15] <author> Helmut A. Partsch. </author> <title> Specification and Transformation of Programs: A Formal Approach to Software Development. </title> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Correctness-preserving program transformations <ref> [15] </ref> often capture deep algorithmic insight and therefore pose interesting challenges for mechanization. <p> It will be interesting to see whether other transformational strategies <ref> [15] </ref> can also be successfully formalized.
Reference: [16] <author> S. Rajan, N. Shankar, </author> <title> and M.K. Srivas. An integration of model-checking with automated proof checking. </title> <editor> In Pierre Wolper, editor, </editor> <booktitle> Computer-Aided Verification, CAV '95, volume 939 of Lecture Notes in Computer Science, </booktitle> <pages> pages 84-97, </pages> <address> Liege, Belgium, June 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The strategy then expands the definitions of specified recursive functions and uses the case structure of these definitions to guide the remaining simplification steps. Model checking with theorem proving. The details of this are not relevant to this paper. See <ref> [16, 19] </ref> for more details. A variety of examples have been verified using PVS [7].
Reference: [17] <author> Sreeranga P. Rajan. </author> <title> Correctness of transformations in high level synthesis. </title> <editor> In Steven D. Johnson, editor, </editor> <booktitle> CHDL '95: 12th Conference on Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 597-603, </pages> <address> Chiba, Japan, </address> <month> August </month> <year> 1995. </year> <note> Proceedings published in a single volume jointly with ASP-DAC '95, CHDL '95, and VLSI '95, IEEE Catalog no. 95TH8102. </note>
Reference-contexts: Neither of these efforts achieves the level of mechanization claimed below. Most of the theorems in this paper are proved by a single PVS proof step that invokes a strategy for measure induction. This strategy was defined during the course 1 Rajan <ref> [17] </ref> describes the use of PVS in verifying hardware-oriented transformations on control data flow graphs. 2 of this work and is a straightforward combination of existing strategies. It should be emphasized that the proofs presented in this paper are among the more elementary proofs that have been checked using PVS.
Reference: [18] <author> Harald Rue. </author> <title> Towards high-level deductive program synthesis based on type theory. </title> <booktitle> In The Tenth Knowledge-Based Software Engineering Conference, </booktitle> <pages> pages 174-183. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> November </month> <year> 1995. </year>
Reference-contexts: Dold [8] has already verified a divide-and-conquer scheme using PVS and has instantiated it to synthesize a binary search algorithm for arrays. Ruess <ref> [18] </ref> has carried out a similar development using the type theory of LEGO [11]. Neither of these efforts achieves the level of mechanization claimed below. Most of the theorems in this paper are proved by a single PVS proof step that invokes a strategy for measure induction.
Reference: [19] <author> N. Shankar. </author> <title> Computer-aided computing. </title> <editor> In Bernhard Moller, editor, </editor> <booktitle> Mathematics of Program Construction '95, number 947 in Lecture Notes in Computer Science, </booktitle> <pages> pages 50-66. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction Correctness-preserving program transformations [15] often capture deep algorithmic insight and therefore pose interesting challenges for mechanization. The mechanization of program transformations has typically been carried out ? This paper is a sequel to a paper entitled Computer-Aided Computing <ref> [19] </ref> that appeared in the proceedings of the 3rd International Conference on the Mathematics of Program Construction held at Kloster Irsee, Germany, during July 1995. The author is grateful to the programme committee of that conference, especially Bernhard Moller, for the invitation to participate in a thoroughly stimulating meeting. <p> Many others at SRI and elsewhere have contributed to PVS in important ways. Preprint submitted to Elsevier Science 11 March 1996 using special-purpose tools such as the KIDS system [21]. This paper examines the utility of the general-purpose verification system PVS <ref> [14, 19] </ref>, for mechanizing program transformation. The main challenge is that program transformations are normally expressed and applied in metatheoretic, i.e., syntactic, form and are therefore not easily formalized in a formal specification logic. <p> Even so, several challenges remain as fodder for future research. 2 A Brief Introduction to PVS PVS (Prototype Verification System) is intended as an environment for constructing clear and precise specifications and for developing readable proofs that have been mechanically verified <ref> [14, 19] </ref>. While many of the individual ideas in the system pre-date PVS, what is new in PVS is the coherent realization of these ideas in a single system. The key elements of the PVS design are captured by the combination of features listed below. <p> The strategy then expands the definitions of specified recursive functions and uses the case structure of these definitions to guide the remaining simplification steps. Model checking with theorem proving. The details of this are not relevant to this paper. See <ref> [16, 19] </ref> for more details. A variety of examples have been verified using PVS [7].
Reference: [20] <author> Robert E. Shostak. </author> <title> Deciding combinations of theories. </title> <journal> Journal of the ACM, </journal> <volume> 31(1) </volume> <pages> 1-12, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: A constant or function definition has the form constant : type = definition 3 Powerful decision procedures with user interaction. PVS proofs are constructed interactively. The primitive inference steps for constructing proofs are quite powerful. They make extensive use of efficient decision procedures for equality and linear arithmetic <ref> [20] </ref>. They also exploit the tight integration between rewriting, the decision procedures, and the use of type information. PVS also uses BDD-based propositional simplification so that it can combine the capability of simplifying very large propositional expressions with equality, arithmetic, induction, and rewriting.
Reference: [21] <author> Douglas R. Smith. KIDS: </author> <title> a semiautomatic program development system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1024-1043, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Sam Owre has been, and continues to be, instrumental in the design and implementation of PVS. Many others at SRI and elsewhere have contributed to PVS in important ways. Preprint submitted to Elsevier Science 11 March 1996 using special-purpose tools such as the KIDS system <ref> [21] </ref>. This paper examines the utility of the general-purpose verification system PVS [14, 19], for mechanizing program transformation. The main challenge is that program transformations are normally expressed and applied in metatheoretic, i.e., syntactic, form and are therefore not easily formalized in a formal specification logic.
Reference: [22] <author> Philip Wadler. </author> <title> Deforestation: Transforming programs to eliminate trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 73 </volume> <pages> 231-248, </pages> <year> 1990. </year>
Reference-contexts: This transformation is closely related to deforestation <ref> [22] </ref>. We show how various features of PVS can be exploited in order to give an elegant formalization of an instance of the fusion theorem for the specific recursive datatype of binary trees.
Reference: [23] <author> Mitchell Wand. </author> <title> Continuation-based program transformation strategies. </title> <journal> Journal of the ACM, </journal> <volume> 27(1) </volume> <pages> 164-180, </pages> <month> January </month> <year> 1980. </year> <month> 24 </month>
Reference-contexts: We also apply this transformation to derive an applicative quicksort algorithm from a treesort specification, and demonstrate that this algorithm returns an ordered permutation of its input. Wand's continuation-based program transformation strategy is a powerful technique for transforming non-tail-recursive definitions into tail-recursive form <ref> [23] </ref>. In fact, a number of otherwise difficult induction arguments can be seen as simple instances of continuation-based transformations. We show how such transformations can be easily mechanized using parametric theories and the higher-order logic of PVS. <p> Wand <ref> [23] </ref> describes a powerful technique for such transformations where the non-tail-recursive part of the program is captured as a continuation, and the pattern of these continuations is used to convert the continuation into a data structure. This is perhaps one of the most ubiquitously used optimizations in algorithm design. <p> = wand [list [T], list [T], id [list [T]], (LAMBDA (x: (cons?[T])): cons (car (x), null)), append [T], cdr [T], null?[T], length [T], reverse [T]] u, x, y, z: VAR list [T] tail_reverse: LEMMA FA (x, u) = append (reverse (x), u) END reverse 5.1 Transforming Binary Recursive Schemes Wand <ref> [23] </ref> presents several extensions of the above transformation of linear recursive definitions to other nonlinear forms of recursion. We round off our presentation of continuation-based transformation in PVS by illustrating how binary tree recursion schemes can be similarly transformed into iterative form. <p> Wand <ref> [23] </ref> presents a further transformation to reduce FA to tail-recursive form. This "familiar" transformation is that of introducing a stack to save the right recursive calls. The resulting iterative definition is given by FI which takes an additional stack argument Y. <p> PVS does not admit mutually recursive definitions. Mutual recursion is useful in an informal development, but is quite unwieldy for a formal approach since it can be hard to establish the termination of mutually recursive functions, and their correctness arguments typically involve simultaneous induction. 7 Wand <ref> [23] </ref> shows how continuation-based transformations can be applied to nontrivial examples by deriving the alpha-beta form of minimax search from a naive minimax search algorithm. We did not retrace Wand's development steps but instead verified the correspondence between naive minimax search and alpha-beta search in PVS. <p> The mechanical proofs needed to justify the transformation were essentially trivial, but the functional correctness of the resulting quick-sort remained a moderately serious challenge regardless of whether the source or the target of the transformation was used. The second class of transformations (due to Wand <ref> [23] </ref>) involves the use of explicit continuation arguments to transform non-tail-recursive definitions into tail-recursive form. The mechanical proofs of these transformations were also mostly trivial.
References-found: 23

