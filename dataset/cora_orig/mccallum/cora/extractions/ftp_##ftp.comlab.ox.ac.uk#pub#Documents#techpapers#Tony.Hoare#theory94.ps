URL: ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Tony.Hoare/theory94.ps
Refering-URL: http://www.comlab.ox.ac.uk/oucl/users/tony.hoare/publications.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Unified Theories of Programming  
Author: C.A.R. Hoare 
Date: July 1994  
Abstract: Professional practice in a mature engineering discipline is based on relevant scientific theories, usually expressed in the language of mathematics. A mathematical theory of programming aims to provide a similar basis for specification, design and implementation of computer programs. The theory can be presented in a variety of styles, including 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. W. Dijkstra. </author> <title> A Discipline of Programming. </title> <booktitle> Prentice-Hall Series in Automatic Computation. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: This paper proposes a mathematical treatment of computer programming in the simple non-deterministic programming language introduced by Dijkstra <ref> [1] </ref>. The theory is well suited for use by engineers, since it supports both stepwise development of designs from specifications and hierarchical decomposition of complex systems into simpler components which can be designed and implemented separately. <p> The concept of denotational semantics is due to Strachey and Scott [5], and the particular choice of ordering of nondeterministic programs is due to Smyth [6]. The embedding of programs as predicates is due to Hehner [7]. The language is essentially the same as that of Dijkstra <ref> [1] </ref>. The denotational theory is taken from Tarski's calculus of relations [8]. The treatment of recursion in specifications is given by Tarski's fixed point theorem [8] and for programs by Plotkin [9]. The algebraic treatment of the language has already been fully covered in [10].
Reference: [2] <author> Robin Milner. </author> <title> A Calculus of Communicating Systems. </title> <publisher> Springer, </publisher> <year> 1980. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 92. </volume>
Reference-contexts: The insights described here were obtained by a study of communication and con-currency in parallel processes, where the three semantic styles have been applied individually by independent schools of research to the same class of phenomena. The operational style was used first <ref> [2] </ref> to define the Calculus of Communicating Systems (CCS); the algebraic style took precedence in the definition [3] of the Algebra of Concurrent Processes (ACP), whereas the denotational style lies at the basis of the mathematical theory [4] of Communicating Sequential Processes (CSP).
Reference: [3] <author> J.A. Bergstra and J.W. Klop. </author> <title> Algebra of communicating processes with abstraction. </title> <journal> Theoretical Computer Science, </journal> <volume> 37(1) </volume> <pages> 77-121, </pages> <year> 1985. </year>
Reference-contexts: The operational style was used first [2] to define the Calculus of Communicating Systems (CCS); the algebraic style took precedence in the definition <ref> [3] </ref> of the Algebra of Concurrent Processes (ACP), whereas the denotational style lies at the basis of the mathematical theory [4] of Communicating Sequential Processes (CSP). Many 7 of the detailed differences between these three process theories originate from their different styles of presentation.
Reference: [4] <author> S.D. Brookes, C.A.R. Hoare, and A.W. Roscoe. </author> <title> A theory of communicating sequential processes. </title> <journal> Journal of the ACM, </journal> <volume> 31 </volume> <pages> 560-599, </pages> <year> 1984. </year>
Reference-contexts: The operational style was used first [2] to define the Calculus of Communicating Systems (CCS); the algebraic style took precedence in the definition [3] of the Algebra of Concurrent Processes (ACP), whereas the denotational style lies at the basis of the mathematical theory <ref> [4] </ref> of Communicating Sequential Processes (CSP). Many 7 of the detailed differences between these three process theories originate from their different styles of presentation. This monograph attempts a synthesis by presenting the same programming language in all three styles.
Reference: [5] <author> Dana Scott and Christopher Strachey. </author> <title> Towards a mathematical semantics for computer languages. </title> <booktitle> In Proceedings, 21st Symposium on Computers and Automata, </booktitle> <pages> pages 19-46. </pages> <institution> Polytechnic Institute of Brooklyn, </institution> <year> 1971. </year> <note> Also Technical Monograph PRG 6, </note> <institution> Oxford University, Programming Research Group. </institution>
Reference-contexts: The choice of a simple sequential language may defuse some of the controversy that has accompanied research into process algebras. Not a single idea in this paper is original. The concept of denotational semantics is due to Strachey and Scott <ref> [5] </ref>, and the particular choice of ordering of nondeterministic programs is due to Smyth [6]. The embedding of programs as predicates is due to Hehner [7]. The language is essentially the same as that of Dijkstra [1]. The denotational theory is taken from Tarski's calculus of relations [8].
Reference: [6] <author> M.B. Smyth. </author> <title> Power domains. </title> <journal> JCSS, </journal> <volume> 16 </volume> <pages> 23-26, </pages> <year> 1978. </year>
Reference-contexts: Not a single idea in this paper is original. The concept of denotational semantics is due to Strachey and Scott [5], and the particular choice of ordering of nondeterministic programs is due to Smyth <ref> [6] </ref>. The embedding of programs as predicates is due to Hehner [7]. The language is essentially the same as that of Dijkstra [1]. The denotational theory is taken from Tarski's calculus of relations [8].
Reference: [7] <author> E.C.R. Hehner. </author> <title> Predicative programming parts i and ii. </title> <journal> Communications of the ACM, </journal> <volume> 27(2) </volume> <pages> 134-151, </pages> <month> Feb </month> <year> 1984. </year>
Reference-contexts: Not a single idea in this paper is original. The concept of denotational semantics is due to Strachey and Scott [5], and the particular choice of ordering of nondeterministic programs is due to Smyth [6]. The embedding of programs as predicates is due to Hehner <ref> [7] </ref>. The language is essentially the same as that of Dijkstra [1]. The denotational theory is taken from Tarski's calculus of relations [8]. The treatment of recursion in specifications is given by Tarski's fixed point theorem [8] and for programs by Plotkin [9].
Reference: [8] <author> A. Tarski. </author> <title> On the calculus of relations. </title> <journal> The Journal of Symbolic Logic, </journal> <volume> 6(3) </volume> <pages> 73-89, </pages> <month> Sep </month> <year> 1941. </year>
Reference-contexts: The embedding of programs as predicates is due to Hehner [7]. The language is essentially the same as that of Dijkstra [1]. The denotational theory is taken from Tarski's calculus of relations <ref> [8] </ref>. The treatment of recursion in specifications is given by Tarski's fixed point theorem [8] and for programs by Plotkin [9]. The algebraic treatment of the language has already been fully covered in [10]. <p> The embedding of programs as predicates is due to Hehner [7]. The language is essentially the same as that of Dijkstra [1]. The denotational theory is taken from Tarski's calculus of relations <ref> [8] </ref>. The treatment of recursion in specifications is given by Tarski's fixed point theorem [8] and for programs by Plotkin [9]. The algebraic treatment of the language has already been fully covered in [10]. Even the idea of consistent and complementary definitions of programming languages goes back at least to [11].
Reference: [9] <author> Gordon D Plotkin. </author> <title> A structural approach to Operational Semantics. Number DAIMI FN-1. </title> <institution> Computing Science Department, Aarhu, </institution> <year> 1981. </year>
Reference-contexts: The language is essentially the same as that of Dijkstra [1]. The denotational theory is taken from Tarski's calculus of relations [8]. The treatment of recursion in specifications is given by Tarski's fixed point theorem [8] and for programs by Plotkin <ref> [9] </ref>. The algebraic treatment of the language has already been fully covered in [10]. Even the idea of consistent and complementary definitions of programming languages goes back at least to [11]. The intention of this monograph is to develop these familiar ideas in a smooth progression.
Reference: [10] <author> C.A.R. Hoare, I.J. Hayes, Jifeng He, C.C. Morgan, A.W. Roscoe, J.W. Sanders, I.H. Sorensen, J.M. Spivey, and B.A. Sufrin. </author> <title> The laws of programming. </title> <journal> Communications of the ACM, </journal> <volume> 30(8) </volume> <pages> 672-687, </pages> <month> Aug </month> <year> 1987. </year> <note> See corrigenda in Communications of the ACM, 30(9): 770. </note>
Reference-contexts: The denotational theory is taken from Tarski's calculus of relations [8]. The treatment of recursion in specifications is given by Tarski's fixed point theorem [8] and for programs by Plotkin [9]. The algebraic treatment of the language has already been fully covered in <ref> [10] </ref>. Even the idea of consistent and complementary definitions of programming languages goes back at least to [11]. The intention of this monograph is to develop these familiar ideas in a smooth progression. In fact, the smoothness is the result of many laborious iterations, mercifully concealed from the reader.
Reference: [11] <author> C.A.R. Hoare and P.E. Lauer. </author> <title> Consistent and complementary formal theories of the semantics of programming languages. </title> <journal> Acta Informatica, </journal> <volume> 3(2) </volume> <pages> 135-153, </pages> <year> 1974. </year>
Reference-contexts: The treatment of recursion in specifications is given by Tarski's fixed point theorem [8] and for programs by Plotkin [9]. The algebraic treatment of the language has already been fully covered in [10]. Even the idea of consistent and complementary definitions of programming languages goes back at least to <ref> [11] </ref>. The intention of this monograph is to develop these familiar ideas in a smooth progression. In fact, the smoothness is the result of many laborious iterations, mercifully concealed from the reader. Even more, it is due to witting or unwitting inspiration, advice and assistance from many scientists, including E.W.
Reference: [12] <author> A. Tarski. </author> <title> A lattice-theoretical fixpoint theorem and its application. </title> <journal> Pacific J. of Math., </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year> <note> 57 58 BIBLIOGRAPHY </note>
Reference-contexts: Fortunately, all the combinators of our programming language are monotonic, and any formula constructed by monotonic functions is monotonic in all its free variables. Let G:X be a predicate constructed solely by monotonic operators and containing X as its only free predicate variable. Tarski's theorem <ref> [12] </ref> guarantees that the equation X = G:X has a solution for X; and this is called a fixed point of the function G. Indeed, among all the fixed points, there is a weakest one in the implication ordering.
Reference: [13] <author> C.C. Morgan. </author> <title> Programming from specifications. </title> <booktitle> Prentice-Hall International series in computer science. Prentice-Hall International, </booktitle> <address> Englewood Cliffs, N.J. ; London, </address> <year> 1990. </year>
Reference-contexts: So it is worth while to introduce a special notation (P; Q) = df (ok ^ P ) ok 0 ^ Q): This is the primitive notation used by Morgan in <ref> [13] </ref>. The clear distinction of precondition P from postcondition Q is also an advantageous feature of VDM [14]. In the interpretation of programs as single predicates, the concepts of correctness and refinement are identified with the implication ordering.
Reference: [14] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> Series in Computer Science. </booktitle> <publisher> Prentice Hall International, </publisher> <year> 1986. </year>
Reference-contexts: So it is worth while to introduce a special notation (P; Q) = df (ok ^ P ) ok 0 ^ Q): This is the primitive notation used by Morgan in [13]. The clear distinction of precondition P from postcondition Q is also an advantageous feature of VDM <ref> [14] </ref>. In the interpretation of programs as single predicates, the concepts of correctness and refinement are identified with the implication ordering.
Reference: [15] <author> Joseph Goguen and Timothy Winkler. </author> <title> Introducing OBJ3. </title> <type> Technical Report SRI-CSL-88, </type> <institution> SRI International, Computer Science Lab, </institution> <month> Aug </month> <year> 1988. </year> <note> Revised version to appear with additional authors Jos 'e Meseguer, </note> <editor> Kokichi Futatsugi and Jean-Pierre Jouannaud, </editor> <title> in em Applications of Algebraic Specification using OBJ, edited by Joseph Goguen, </title> <editor> Derek Coleman and Robin Gallimore, </editor> <address> Cambridge, </address> <year> 1992. </year>
Reference-contexts: As in more traditional forms of calculus, they are useful in calculating parameters and other design details from more general structural decisions made by engineering judgement. There are good prospects of delegating part of the symbolic calculation to a mechanised term rewriting system like OBJ3 <ref> [15] </ref>. And finally, a theory presented as a set of equations is often easier to teach and to learn than one presented as a mathematical model.
Reference: [16] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: There are a great many possible answers to these questions; but we shall concentrate on two of the first and most influential of them, which are due to Milner and Park <ref> [16] </ref>. To exclude the universal relation, it is sufficient to impose an obligation on a proposed equivalence relation ~ that it should preserve the distinctness of a certain minimum of "obviously" distinguishable states.
Reference: [17] <author> S. Andreski. </author> <title> Social Science as Sorcery. </title> <publisher> Pelican Books. </publisher>
Reference-contexts: When the mathematics of computation is equally well understood, it is very unlikely that its branches will have the same labels that they have today. Quoting from Andreski <ref> [17] </ref>, "the contours of truth never coincide with the frontiers between embattled parties and cliques". So we must hope that the investigations by various schools of programming theory will contribute to the understanding which leads to their own demise.
References-found: 17

