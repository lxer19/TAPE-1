URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-92-24.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: A Further Note on Hennessy's "Symbolic Debugging of Optimized Code"  
Author: Max Copperman Charles E. McDowell 
Address: Santa Cruz, CA 95064  
Affiliation: Board of Studies in Computer and Information Sciences University of California at Santa Cruz  
Date: April 1992  
Pubnum: UCSC-CRL-92-24 Supersedes UCSC-CRL-91-04  
Abstract: When attempting to debug optimized programs, most debuggers may give misleading information about the value of variables at breakpoints. Hennessy proposed a set of algorithms for generating optimized code and determining when, in the generated code, the reported values would be misleading, and under certain circumstances actually recovering the "expected" value of the variable (i.e., one that would not be misleading). We point out where the assumptions made by Hennessy need to be revised due to advances in compiler and debugger technology, and give references for current work on this revised problem. 
Abstract-found: 1
Intro-found: 1
Reference: [AU77] <author> Aho, A.V. and Ullman, J.D. </author> <title> Principles of Compiler Design, </title> <publisher> Addison Wesley, </publisher> <address> Menlo Park, CA, </address> <year> 1977. </year>
Reference-contexts: Wall et al [WST85] describes errors in Hennessy's algorithms and gives corrected algorithms. The code generation algorithm used in Hennessy's work (a standard algorithm from Aho and Ullman <ref> [AU77] </ref>, [AU73], [AU72]) generates code that contains only one assignment to any variable within a basic block. In the next section, we show how Hennessy's algorithms (and the modified algorithms of [WST85]) are dependent on this characteristic.
Reference: [AU73] <author> Aho, A.V. and Ullman, J.D. </author> <title> The Theory of Parsing, Translation, and Compiling, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1973. </year> <title> 6 The information is sufficient provided that assignment is considered to be an expression, and thus a mapping between assignment operators and the object code that sets the variable (the store into memory, computation into a register, or register copy operation) is provided. It is not clear from Streepy's paper that this is the case, but if not, it is clearly possible to extend the interface in this direction. </title> <type> References 9 </type>
Reference-contexts: Wall et al [WST85] describes errors in Hennessy's algorithms and gives corrected algorithms. The code generation algorithm used in Hennessy's work (a standard algorithm from Aho and Ullman [AU77], <ref> [AU73] </ref>, [AU72]) generates code that contains only one assignment to any variable within a basic block. In the next section, we show how Hennessy's algorithms (and the modified algorithms of [WST85]) are dependent on this characteristic.
Reference: [AU72] <author> Aho, A.V. and Ullman, J.D. </author> <title> "Optimization of Straightline Code," </title> <journal> Siam J. Comput. </journal> <volume> 1, 1(Jan. </volume> <year> 1972), </year> <pages> 1-19. </pages>
Reference-contexts: Wall et al [WST85] describes errors in Hennessy's algorithms and gives corrected algorithms. The code generation algorithm used in Hennessy's work (a standard algorithm from Aho and Ullman [AU77], [AU73], <ref> [AU72] </ref>) generates code that contains only one assignment to any variable within a basic block. In the next section, we show how Hennessy's algorithms (and the modified algorithms of [WST85]) are dependent on this characteristic.
Reference: [Cop92] <author> M. Copperman, </author> <title> "Debugging Optimized Code Without Being Misled," </title> <type> UCSC Technical Report UCSC-CRL-92-01, </type> <month> January </month> <year> 1992. </year> <note> Submitted for publication to ACM Transactions on Programming Languages and Systems. </note>
Reference-contexts: Data flow techniques have been successfully applied to problem of currentness determination in the presence of both local and global optimization by Copperman and McDowell <ref> [Cop92] </ref>, [CM91] and independently by Bemmerl and Wismueller [BW92]. Reaching definitions are computed before optimization is performed.
Reference: [CM91] <author> Copperman, M., McDowell, C. </author> <title> "Debugging Optimized Code Without Surprises (Extended Abstract)," </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop, </booktitle> <address> Albuquerque NM, </address> <month> November </month> <year> 1991 </year>
Reference-contexts: Data flow techniques have been successfully applied to problem of currentness determination in the presence of both local and global optimization by Copperman and McDowell [Cop92], <ref> [CM91] </ref> and independently by Bemmerl and Wismueller [BW92]. Reaching definitions are computed before optimization is performed.
Reference: [CMR88] <author> D. Coutant, S. Meloy, M. </author> <title> Ruscetta "DOC: a Practical Approach to Source-Level Debugging of Globally Optimized Code," </title> <booktitle> Proceedings of the SIGPLAN `88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 125-134, </pages> <year> 1988. </year>
Reference-contexts: In fact, it is becoming more and more common to allow a variable to be mapped to a number of locations over its lifetime <ref> [CMR88] </ref>, [Str91], [Wan91], [Sil92]. Assume that in some source code, a variable V is assigned into more than once in a basic block. Assuming that V is used after each such assignment, the code generation technique used by Hennessy would use temporaries (registers) for all but the last such assignment. <p> In Hennessy's paper, an old label represents an assignment in the unoptimized version that is not present in the optimized version, and a current label represents an assignment that appears in both unoptimized and optimized versions. 1 Coutant et al <ref> [CMR88] </ref>, Streepy [Str91], and the DWARF standardization effort [Sil92] discuss different formats whereby a debugger can be informed of such aliases. 3. <p> Algorithm 2 also relies upon the assumption that there is a single current label for a variable in the dag, particularly in the function Available. 4 Related Work Since Hennessy's paper, several groups have worked on this or related problems. Coutant et al <ref> [CMR88] </ref> describes a compiler/debugger pair modified to allow source-level debugging of optimized code. The part of their work relevant to this discussion is that the debugger reports when variables have been made noncurrent due to instruction scheduling within a basic block.
Reference: [Sil92] <editor> Personal Communication, J. Silverstein, ed., </editor> <title> "DWARF Debugging Information Format," Proposed Standard, </title> <booktitle> UNIX International Programming Languages Special Interest Group, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: In fact, it is becoming more and more common to allow a variable to be mapped to a number of locations over its lifetime [CMR88], [Str91], [Wan91], <ref> [Sil92] </ref>. Assume that in some source code, a variable V is assigned into more than once in a basic block. Assuming that V is used after each such assignment, the code generation technique used by Hennessy would use temporaries (registers) for all but the last such assignment. <p> In Hennessy's paper, an old label represents an assignment in the unoptimized version that is not present in the optimized version, and a current label represents an assignment that appears in both unoptimized and optimized versions. 1 Coutant et al [CMR88], Streepy [Str91], and the DWARF standardization effort <ref> [Sil92] </ref> discuss different formats whereby a debugger can be informed of such aliases. 3.
Reference: [Hen82] <author> Hennessy, J. </author> <title> "Symbolic Debugging of Optimized Code," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 4, No. 3, </volume> <pages> pp. 323-344, </pages> <year> 1982 </year>
Reference-contexts: 1 Introduction Hennessy's paper "Symbolic Debugging of Optimized Code" <ref> [Hen82] </ref> discusses one of the problems of source-level debugging of optimized code: how to provide information about the value of a variable that has been affected by optimization without confusing or misleading the user.
Reference: [Mel90] <institution> Personal Communication, Meloy, S., Hewlett-Packard, 3345 Mount Pleasant Rd., Lincoln, </institution> <address> CA </address>
Reference-contexts: The compiler tracks stores to user variables that have been moved across statement boundaries. As of the 1990 implementation, a variable was reported to be noncurrent after its last use, although it may still be available in a register or in memory <ref> [Mel90] </ref>. Streepy 8 5. Summary [Str91] describes a rich compiler/debugger interface designed to allow source-level debugging of optimized code.
Reference: [Hen90] <institution> Personal Communication, Hennessy, J., Center for Integrated Systems, Stanford University, Stanford, </institution> <address> CA </address>
Reference: [Str91] <author> L. Streepy, </author> <title> "CXdb A New View On Optimization," </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop , Albuquerque, </booktitle> <month> November </month> <year> 1991. </year>
Reference-contexts: In fact, it is becoming more and more common to allow a variable to be mapped to a number of locations over its lifetime [CMR88], <ref> [Str91] </ref>, [Wan91], [Sil92]. Assume that in some source code, a variable V is assigned into more than once in a basic block. Assuming that V is used after each such assignment, the code generation technique used by Hennessy would use temporaries (registers) for all but the last such assignment. <p> In Hennessy's paper, an old label represents an assignment in the unoptimized version that is not present in the optimized version, and a current label represents an assignment that appears in both unoptimized and optimized versions. 1 Coutant et al [CMR88], Streepy <ref> [Str91] </ref>, and the DWARF standardization effort [Sil92] discuss different formats whereby a debugger can be informed of such aliases. 3. <p> The compiler tracks stores to user variables that have been moved across statement boundaries. As of the 1990 implementation, a variable was reported to be noncurrent after its last use, although it may still be available in a register or in memory [Mel90]. Streepy 8 5. Summary <ref> [Str91] </ref> describes a rich compiler/debugger interface designed to allow source-level debugging of optimized code. The interface defines source units beyond subroutines and statements (it includes loops, blocks, and expressions) and includes a source range table mapping between source units and sequences of object code generated from them.
Reference: [Wan91] <editor> Personal Communication regarding Microtec Research's Xray Debugger, Wang, F., Microtec Research, </editor> <publisher> Inc., </publisher> <address> Santa Clara, CA, </address> <month> January </month> <year> 1992 </year>
Reference-contexts: In fact, it is becoming more and more common to allow a variable to be mapped to a number of locations over its lifetime [CMR88], [Str91], <ref> [Wan91] </ref>, [Sil92]. Assume that in some source code, a variable V is assigned into more than once in a basic block. Assuming that V is used after each such assignment, the code generation technique used by Hennessy would use temporaries (registers) for all but the last such assignment.
Reference: [Wis92] <institution> Personal Communication, Wismueller, R., Institut fur Informatik, Technische Universitat Munchen, Munich, Germany, </institution> <month> March </month> <year> 1992 </year>
Reference: [BW92] <author> T. Bemmerl, R. Wismueller, </author> <title> "Quellcode-Debugging von global optimierten Programmen", </title> <booktitle> Proceedings of the GI-ITG Workshop "Parallelrechner und Programmiersprachen", </booktitle> <address> Schloss Dagstuhl, Ger-many, </address> <month> Feb. </month> <year> 1992 </year>
Reference-contexts: Data flow techniques have been successfully applied to problem of currentness determination in the presence of both local and global optimization by Copperman and McDowell [Cop92], [CM91] and independently by Bemmerl and Wismueller <ref> [BW92] </ref>. Reaching definitions are computed before optimization is performed.
Reference: [WST85] <author> D. Wall, A. Srivastava, R. Templin, </author> <title> "A note on Hennessy's Symbolic Debugging of Optimized Code," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 7, No. 1, </volume> <pages> pp. 176-181, </pages> <month> Jan. </month> <year> 1985. </year>
Reference-contexts: He describes information to be used to determine which variables are noncurrent in the presence of local optimizations and algorithms that use that information to make the determination and, if possible, recover the correct values of such variables. Wall et al <ref> [WST85] </ref> describes errors in Hennessy's algorithms and gives corrected algorithms. The code generation algorithm used in Hennessy's work (a standard algorithm from Aho and Ullman [AU77], [AU73], [AU72]) generates code that contains only one assignment to any variable within a basic block. <p> The code generation algorithm used in Hennessy's work (a standard algorithm from Aho and Ullman [AU77], [AU73], [AU72]) generates code that contains only one assignment to any variable within a basic block. In the next section, we show how Hennessy's algorithms (and the modified algorithms of <ref> [WST85] </ref>) are dependent on this characteristic. Due to a decade's progress in computer architecture and compiler technology, highly optimized code may contain more than one assignment to a given variable within a basic block. <p> valid locations for variables, this construction produces assignments with old labels that appear in both unoptimized and optimized versions, contrary to the intended meaning of the old label. 2 Due to this construction, Hennessy's algorithms for determining whether a variable is current (and the modified versions of Wall et al <ref> [WST85] </ref>) will provide all current variables in programs that either: * contain no old labels, or * contain old labels, but due to optimization do not perform the assignments represented by those labels (even into temporaries), that is, programs that do not perform more than one assignment to any variable within <p> However, the augmented dag for this modified example contains an old label for F at node 1, just as in the case when no code was generated for the node. Algorithm 1 from Wall et al <ref> [WST85] </ref>, shown in Figure 3.4, therefore reports F as being noncurrent (to relate this example to Algorithm 1, let L be the label on node 1: nodepointer of L &lt; 4 (the node number of the breakpoint location), L is an old label, and F is not in Fixed). 5 2 <p> compilation and completeness of optimization. 4 A typographical error in the original figure has been corrected: the roll forward variable (RFV) is F, as is clear from the code and the text, but is shown in the original figure as A. 5 The problem addressed by Wall et al in <ref> [WST85] </ref> is orthogonal to the problem introduced by our new interpretation of the 4 3. Examples 1oldF 5F 4A cur cur Noncurrent VariablesOptimized CodeUnoptimized Code 2 0 . A := B + C 4. F := E 2.
References-found: 15

