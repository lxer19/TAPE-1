URL: http://www.research.att.com/~dalia/pubs/playground.ps.gz
Refering-URL: http://www.research.att.com/~dalia/
Root-URL: 
Email: fdalia,reiter,rubing@research.att.com  
Title: Secure Execution of Java Applets using a Remote Playground  
Author: Dahlia Malkhi Michael K. Reiter Aviel D. Rubin 
Address: Florham Park, NJ, USA  
Affiliation: AT&T Labs Research,  
Abstract: Mobile code presents a number of threats to machines that execute it. We introduce an approach for protecting machines and the resources they hold from mobile code, and describe a system based on our approach for protecting host machines from Java 1.1 applets. In our approach, each Java applet downloaded to the protected domain is rerouted to a dedicated machine (or set of machines), the playground, at which it is executed. Prior to execution the applet is transformed to use the downloading user's web browser as a graphics terminal for its input and output, and so the user has the illusion that the applet is running on her own machine. In reality, however, mobile code runs only in the sanitized environment of the playground, where user files cannot be mounted and from which only limited network connections are accepted by machines in the protected domain. Our playground thus provides a second level of defense against mobile code that circumvents language-based defenses. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Balfanz and E. W. Felten. </author> <title> A Java filter. </title> <type> Technical Report 567-97, </type> <institution> Department of Computer Science, Princeton University, </institution> <month> October </month> <year> 1997. </year>
Reference-contexts: The second general approach is to execute only mobile code that is trusted based on some criteria. For example, Balfanz and Felten proposed a Java filter that allows users to specify the servers from which to accept Java applets <ref> [1] </ref>. Here the criterion by which an applet is trusted is the server that serves it. A related approach is to determine whether to trust mobile code based on its author, which can be determined, e.g., if the code is digitally signed by the author.
Reference: [2] <author> D. Dean, E. W. Felten, and D. S. Wallach. </author> <title> Java security: From Hotjava to Netscape and beyond. </title> <booktitle> In Proceedings of the 1996 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 190-200, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Moreover, mobile code "sandboxes" intended to constrain mobile code have in many cases proven unsatisfactory, in that implementation errors enable mobile code to circumvent the sandbox's security mechanisms <ref> [2, 10] </ref>. One of the oldest ideas in security, computer or otherwise, is to physically separate the attacker from the resources of value. <p> This approach has met with mixed success, in that even small implementation errors can enable applets to entirely bypass the security restrictions enforced by the sandbox <ref> [2] </ref>. The second general approach is to execute only mobile code that is trusted based on some criteria. For example, Balfanz and Felten proposed a Java filter that allows users to specify the servers from which to accept Java applets [1]. <p> Accessing and modifying protected resources Several bugs in the type safety mechanisms of Java have provided ways for applets to bypass Java sandboxes, including some in popular browsers <ref> [2, 10] </ref>. These penetrations typically enable the applet to perform any operation that the operating system allows, including reading and writing the user's files and opening network connections to other machines to attack them. <p> Although the sandbox mechanisms of most browsers are intended to separate applets in different web pages from one another, several ways of circumventing this separation have been shown <ref> [2, 8] </ref>. This can be prevented in our system if the applets for each page run in a separate JVM on the playground under a separate user account, and hence are unable to directly affect applets from another page (except by attacking the playground itself).
Reference: [3] <author> D. Flanagan. </author> <title> Java in a Nutshell, Second edition, </title> <publisher> O'Reilly & Associates, </publisher> <year> 1997. </year>
Reference-contexts: A running Java applet consists of a collection of objects whose methods are invoked by a runtime system, and that in turn invoke one another's methods. For more information on Java see, e.g., <ref> [3] </ref>. 3.1.1 Remote AWT classes The Abstract Window Toolkit (AWT) is the standard API for implementing graphical user interfaces (GUI) in Java programs. <p> Object serialization refers to the ability to write the complete state of an object to an output stream, and then recreate that object at some later time by reading its serialized state from an input stream <ref> [13, 3] </ref>. Object serialization is central to remote method invocation|and thus to communication between the graphics server and the playground stubs|because it allows for method parameters to be passed to a remote method and the return value to be passed back. <p> However, because class loading from the network is prevented in our system (see Section 5.1.1), the load does not complete and an exception is generated. In addition, our prototype presently does not offer transparent execution for applets that invoke methods by reflection <ref> [3, Ch. 12] </ref>. At the time of this writing, however, the number of applets that cannot be supported due to these limitations does not seem significant.
Reference: [4] <author> L. Gong. </author> <title> Java security: Present and near future. </title> <booktitle> IEEE Micro 17(3) </booktitle> <pages> 14-19, </pages> <month> May/June </month> <year> 1997. </year>
Reference-contexts: This is the approach adopted for securing Microsoft's ActiveX content, and is also supported for applets in JDK 1.1. Combinations of this approach and the sandbox model are implemented in JDK 1.2 <ref> [4, 5] </ref> and Netscape Communicator (see [15]), which enforce access controls on an applet based on the signatures it possesses (or other properties). A third variation on this theme is proof-carrying code [12], where the mobile code is accompanied by a proof that it satisfies certain properties.
Reference: [5] <author> L. Gong, M. Mueller, H. Prafullchandra, and R. Schemers. </author> <title> Going beyond the sandbox: An overview of the new security architecture in the Java TM Development Kit 1.2. </title> <booktitle> In Proceedings of the USENIX Symposium on Internet Technologies and Systems, </booktitle> <month> December </month> <year> 1997. </year>
Reference-contexts: This is the approach adopted for securing Microsoft's ActiveX content, and is also supported for applets in JDK 1.1. Combinations of this approach and the sandbox model are implemented in JDK 1.2 <ref> [4, 5] </ref> and Netscape Communicator (see [15]), which enforce access controls on an applet based on the signatures it possesses (or other properties). A third variation on this theme is proof-carrying code [12], where the mobile code is accompanied by a proof that it satisfies certain properties.
Reference: [6] <author> A. Herbert. </author> <title> Secure mobile code management: Enabling Java for the enterprise. </title> <type> Manuscript, </type> <month> May </month> <year> 1997. </year>
Reference-contexts: Independently of our work, a system similar to ours has recently been marketed by Digitivity, Inc., a California-based company. While there are no descriptions of their system in the scientific literature, we have inferred several differences in our systems from their web site (http://www.digitivity.com), a white paper <ref> [6] </ref>, and discussions with company representatives. First, elements of the Digitivity system| notably the protocol for communication between the user's browser and (their analog of) the playground, and the Java Virtual Machine (JVM) running on their playground|are proprietary, whereas our system is built using only public, widely-used protocols and JVMs. <p> This may enable Digitivity to better tune its system's performance, but our approach promotes greater confidence in the security of our system by exposing it to maximum public scrutiny and understanding. Second, our system does not require trust in certain elements of the system that, according to <ref> [6] </ref>, are trusted in their architecture.
Reference: [7] <author> J. H. Howard, M. J. Kazar, S. G. Menees, D. A. Nichols, M. Satyanaraynan, R. N. Sidebotham and M. J. West. </author> <title> Scale and performance in a distributed file system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 51-81, </pages> <year> 1988. </year>
Reference-contexts: For example, if network file servers are configured to refuse requests from the playground (and if machines' requests are authenticated, as with AFS <ref> [7] </ref>), then even the total corruption of the playground does not immediately lead to the compromise of user files.
Reference: [8] <author> M. Ladue. </author> <title> Pushing the limits of Java security. In Tricks of the Java Programming Gurus, </title> <editor> G. Vanderburg, ed., </editor> <publisher> Sams.net Publishing, </publisher> <year> 1996. </year>
Reference-contexts: Denial of service In a denial of service attack, a hostile applet might disable or significantly degrade access to system resources such as the CPU, disk, network and interactive devices. Ladue <ref> [8] </ref> presents several such applets, e.g., that consume CPU even after the user clicks away from the applet origin page, that monopolize system locks, or that pop up windows on the user's screen endlessly. <p> One approach to defend against this is to configure the graphics server and/or the playground to limit the number or rate of window creations. In another type of denial of service, an applet may deny service to other applets within the JVM, e.g., by killing off others' threads <ref> [8] </ref>. Although the sandbox mechanisms of most browsers are intended to separate applets in different web pages from one another, several ways of circumventing this separation have been shown [2, 8]. <p> Although the sandbox mechanisms of most browsers are intended to separate applets in different web pages from one another, several ways of circumventing this separation have been shown <ref> [2, 8] </ref>. This can be prevented in our system if the applets for each page run in a separate JVM on the playground under a separate user account, and hence are unable to directly affect applets from another page (except by attacking the playground itself). <p> Violating privacy The Java security policy in browsers is geared towards maintaining user privacy by disallowing loaded applets access to any local information. In some cases, however, a Java applet can reveal a lot about a user whose browser executes it. For example, in <ref> [8] </ref>, Ladue presents an applet that uses a sendmail trick to send mail on the user's behalf to a sendmail daemon running on the applet's server.
Reference: [9] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification, </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: The applet that returns is in a format called Java bytecode, suitable for running in any JVM. This bytecode is subjected to a bytecode verification process, loaded into the browser's JVM, and executed (see, e.g., <ref> [9] </ref>). In our system, when a browser requests a web page, the request is sent to a proxy (Figure 1, step 1). The proxy forwards the request to the end server (step 2) and receives the requested page (step 3).
Reference: [10] <author> G. McGraw and E. W. Felten. </author> <title> Java Security: Hostile Applets, Holes, and Antidotes, </title> <publisher> John Wiley & Sons, </publisher> <year> 1997. </year>
Reference-contexts: Moreover, mobile code "sandboxes" intended to constrain mobile code have in many cases proven unsatisfactory, in that implementation errors enable mobile code to circumvent the sandbox's security mechanisms <ref> [2, 10] </ref>. One of the oldest ideas in security, computer or otherwise, is to physically separate the attacker from the resources of value. <p> The third approach to securing hosts from mobile code is simply to not run mobile code. A course-grained approach for Java is to simply disable Java in the browser. Another approach is to filter out all applets at a firewall [11] (see also <ref> [10, Chapter 5] </ref>), which has the advantage of allowing applets served from behind the firewall to be executed. Independently of our work, a system similar to ours has recently been marketed by Digitivity, Inc., a California-based company. <p> Accessing and modifying protected resources Several bugs in the type safety mechanisms of Java have provided ways for applets to bypass Java sandboxes, including some in popular browsers <ref> [2, 10] </ref>. These penetrations typically enable the applet to perform any operation that the operating system allows, including reading and writing the user's files and opening network connections to other machines to attack them.
Reference: [11] <author> D. Martin, S. Rajagopalan, and A. D. Rubin. </author> <title> Blocking Java applets at the firewall. </title> <booktitle> In Proceedings of the 1997 Internet Society Symposium on Network and Distributed System Security, </booktitle> <pages> pages 16-26, </pages> <month> February </month> <year> 1997. </year>
Reference-contexts: The third approach to securing hosts from mobile code is simply to not run mobile code. A course-grained approach for Java is to simply disable Java in the browser. Another approach is to filter out all applets at a firewall <ref> [11] </ref> (see also [10, Chapter 5]), which has the advantage of allowing applets served from behind the firewall to be executed. Independently of our work, a system similar to ours has recently been marketed by Digitivity, Inc., a California-based company. <p> In this case, the proxy must intercept the request or the incoming class, and prevent the class from reaching the browser, e.g., as in <ref> [11] </ref>. The advantage of this approach is that it works with any browser "off-the-shelf": it requires no changes to the browser beyond specifying the proxy as the browser's HTTP and SSL proxy, which can typically be done using a simple preferences menu in the browser. <p> A disadvantage, however, is that the proxy becomes part of the trusted computing base of the system, and as shown in <ref> [11] </ref>, effectively blocking classes can be costly. For this reason, the proxy must be written and maintained carefully, and we refer to this approach as the "trusted proxy" approach.
Reference: [12] <author> G. C. Necula and P. Lee. </author> <title> Safe kernel extensions without run-time checking. </title> <booktitle> In Proceedings of the 2nd Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 229-243, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Combinations of this approach and the sandbox model are implemented in JDK 1.2 [4, 5] and Netscape Communicator (see [15]), which enforce access controls on an applet based on the signatures it possesses (or other properties). A third variation on this theme is proof-carrying code <ref> [12] </ref>, where the mobile code is accompanied by a proof that it satisfies certain properties. However, these techniques have not yet been applied to languages as rich as Java (or Java bytecodes). Our approach is compatible with both of the approaches described above.
Reference: [13] <author> Sun Microsystems, Inc. </author> <title> Java Object Serialization Specification, Revision 1.2, </title> <month> December </month> <year> 1996. </year>
Reference-contexts: Object serialization refers to the ability to write the complete state of an object to an output stream, and then recreate that object at some later time by reading its serialized state from an input stream <ref> [13, 3] </ref>. Object serialization is central to remote method invocation|and thus to communication between the graphics server and the playground stubs|because it allows for method parameters to be passed to a remote method and the return value to be passed back. <p> A first step toward securing RMI is to support authenticated and encrypted transport, so that a network attacker cannot alter or eavesdrop on communication between the browser and the playground. This can also be achieved by interposing encryption at the object serialization layer (see <ref> [13] </ref>). A more troubling threat is possible vulnerabilities in the object serialization routines that are used to marshal parameters to and return values from remote method invocations.
Reference: [14] <author> Sun Microsystems, Inc. </author> <title> Java Remote Method Invocation Specification, </title> <year> 1997. </year>
Reference-contexts: Once the BrowserServer object is initialized and prepared to service requests from the playground, it binds a remote reference to itself to the address assigned by the proxy; this binding is stored in an RMI name server <ref> [14] </ref>. The proxy remembers what address it assigned to each &lt;applet&gt; tag and provides this address to the playground in a similar fashion.
Reference: [15] <author> D. S. Wallach, D. Balfanz, D. Dean, and E. W. Felten. </author> <title> Extensible security architectures for Java. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Operating Systems Principles, </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: This is the approach adopted for securing Microsoft's ActiveX content, and is also supported for applets in JDK 1.1. Combinations of this approach and the sandbox model are implemented in JDK 1.2 [4, 5] and Netscape Communicator (see <ref> [15] </ref>), which enforce access controls on an applet based on the signatures it possesses (or other properties). A third variation on this theme is proof-carrying code [12], where the mobile code is accompanied by a proof that it satisfies certain properties.
References-found: 15

