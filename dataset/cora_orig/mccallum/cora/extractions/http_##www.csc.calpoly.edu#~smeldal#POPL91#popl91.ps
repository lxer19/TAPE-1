URL: http://www.csc.calpoly.edu/~smeldal/POPL91/popl91.ps
Refering-URL: http://www.csc.calpoly.edu/~smeldal/tidbits.html
Root-URL: http://www.csc.calpoly.edu
Email: mitchell@cs.stanford.edu  sigurd@eik.ii.uib.no  madhav@cs.stanford.edu  
Title: An extension of Standard ML modules with subtyping and inheritance  
Author: John Mitchell Sigurd Meldal yz Neel Madhav 
Address: Stanford, CA 94305  Bergen, Norway  Stanford, CA 94305  
Affiliation: Dept. of Computer Science Stanford University  Dept. of Informatics University of Bergen  Dept. of Computer Science Stanford University  
Abstract: We describe a general module language integrating abstract data types, specifications and object-oriented concepts. The framework is based on the Standard ML module system, with three main extensions: subtyping, a form of object derived from ML structures, and inheritance primitives. The language aims at supporting a range of programming styles, including mixtures of object-oriented programming and programs built around specified algebraic or higher-order abstract data types. We separate specification from implementation, and provide independent inheritance mechanisms for each. In order to support binary operations on objects within this framework, we introduce internal interfaces which govern the way that function components of one structure may access components of another. The language design has been tested by writing a number of program examples; an implementation is under development in the context of a larger project. 
Abstract-found: 1
Intro-found: 1
Reference: [BHEL86] <author> A. Black, N. Hutchinson, E.Jul, and H. Levy. </author> <title> Object structure in the Emerald system. </title> <booktitle> In Proc. ACM Symp. on Object-Oriented Programming: Systems, Languages, and Applications, </booktitle> <pages> pages 78-86, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: One is the lack of support for specified algebraic data types, which are familiar to and valued by our intended user community. Another is the way that specifications (typically signature information only) and implementation are identified in a single language construct. (An exception is Emerald <ref> [BHEL86] </ref>, which has several similar features, but lacks inheritance.) We believe that the separation of specification from implementation will prove beneficial to the development of large object-oriented programs, both by allowing independent use of either specification or implementation inheritance (see [Sny86]), and by allowing multiple implementations of a single class to
Reference: [BL90] <author> F. </author> <title> Belz and D.C. Luckham. A new approach to prototyping ada-based hardware/software systems. </title> <booktitle> In Proc. ACM Tri-Ada'90 Conference, </booktitle> <month> December </month> <year> 1990. </year> <note> To appear. </note>
Reference-contexts: We therefore envision an approach to program development which involves successive refinement of working code, with substantial code reuse from one prototype to the next. Further discussion of our prototyping model may be found in <ref> [BL90] </ref>. We are unsatisfied with previous object-oriented languages for a number of reasons. One is the lack of support for specified algebraic data types, which are familiar to and valued by our intended user community.
Reference: [C 86] <editor> R.L. Constable et al. </editor> <title> Implementing Mathematics with the Nuprl Proof Development System, volume 37 of Graduate Texts in Mathematics. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: Specifications, in general, define large types. Implicit coercion from large to small types is discussed in Section 5.3. The names small and large are related to constructive type theory (see, e.g., <ref> [Mar84, C 86, Mac86, Mit90b] </ref>). subtype: A type A is a subtype of B if every expression of type A may be used in any context requiring an expression of type B, without type error.
Reference: [Car89] <author> L. Cardelli. </author> <title> Typeful programming. </title> <type> Technical Report 45, </type> <institution> DEC Systems Research Center, </institution> <year> 1989. </year> <booktitle> presented at IFIP Advanced Seminar on Formal Descriptions of Programming Concepts. </booktitle>
Reference-contexts: To keep the typing problem for this language tractable, we must change our notion of equality for type components of structures. In effect, we make use of the first class abstract data type approach of [MP88], also used in the programming language Quest <ref> [Car89] </ref>. However, this change is applied in a systematic way which coincides with Standard ML typing for top-level structures and functors (the cases allowed in Standard ML). <p> As described in [MP88], see also [CW85], existentially quantified types correspond to the programming language notion of abstract types. Like Quest <ref> [Car89] </ref>, our existential types are impredicative, so that a specification with only abstract (or, in Ada terminology, private) types may be considered a U 1 type instead of a U 2 type.
Reference: [CCH 89] <author> P. Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. </author> <title> F-bounded quantification for object-oriented programming. </title> <booktitle> In Functional Prog. and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: The need for this new construct arises in part from our separation of specification and implementation, and our flexible forms of inheritance; see Section 6.1. Finally, we allow parameterized specifications (which seem especially useful for object-oriented programming) and use bounded quantification <ref> [CW85, CCH 89, CM89] </ref> rather than unconstrained ML polymorphism. One of our language design goals is to support a range of programming styles within a single framework. One style of interest is the traditional program development by step-wise refinement, using abstract data types and specifications. <p> Finally, we provide a compile-time typing discipline which is more flexible than C , without the type insecurity of Eiffel [Coo89]. Our type system is an extension of ML polymorphism, based in part on the record calculus of [CM89], and including F-bounded quantification <ref> [CCH 89] </ref> for specifying uniform behavior over functionally similar classes of objects. An additional goal of our project, not reported here, is the integration of a form of concurrency based on objects with concurrent methods. <p> This requirement must be incorporated into the type of sort, as a restriction on the type of list elements. Based on previous investigation <ref> [CCH 89] </ref>, the appropriate way to restrict the type of list element appears to be through the introduction of a parameterized specification ordered [type t]. <p> Although the reader might see the restriction type t &lt; : orderedt on the type of list elements as recursive, it is not; see <ref> [CCH 89] </ref> for further discussion. Note that the same form of parameterization would be required if we wish to parameterize a binary search tree specification or implementation by the type of ordered records inserted into trees. <p> In particular, the separation of specification from implementation and the use of internal interfaces to allow efficient, type-safe implementation of binary operations seem useful. We have found F-bounded polymorphism, introduced in <ref> [CCH 89] </ref>, to be a useful primitive, and sufficiently expressive for describing families of classes satisfying certain axiomatic specifications. A direction we are currently exploring is an extension of objects (Standard ML structures) with concurrent methods.
Reference: [CM89] <author> L. Cardelli and J.C. Mitchell. </author> <title> Operations on records. In Math. </title> <booktitle> Foundations of Prog. Lang. Semantics, </booktitle> <year> 1989. </year> <note> To appear. Also available as DEC SRC Technical Report 48, </note> <month> August </month> <year> 1989, </year> <pages> 60 pages. </pages>
Reference-contexts: Davis Faculty Scholarship. y Supported by the Defense Advanced Research Projects Agency/Information Systems Technology Office under the Office of Naval Research contract N00014-90-J1232 and by the Air Force Office of Scientific Research under Grant AFOSR83-0255. z Supported by the Norwegian Research Council for Science and the Humanities. work, e.g., <ref> [CM89] </ref>. The primary new features of this language are the generalization of structures to encompass typed first-class objects, and inheritance primitives for specifications and structures. Our module design is a proper extension of Standard ML. <p> The need for this new construct arises in part from our separation of specification and implementation, and our flexible forms of inheritance; see Section 6.1. Finally, we allow parameterized specifications (which seem especially useful for object-oriented programming) and use bounded quantification <ref> [CW85, CCH 89, CM89] </ref> rather than unconstrained ML polymorphism. One of our language design goals is to support a range of programming styles within a single framework. One style of interest is the traditional program development by step-wise refinement, using abstract data types and specifications. <p> Finally, we provide a compile-time typing discipline which is more flexible than C , without the type insecurity of Eiffel [Coo89]. Our type system is an extension of ML polymorphism, based in part on the record calculus of <ref> [CM89] </ref>, and including F-bounded quantification [CCH 89] for specifying uniform behavior over functionally similar classes of objects. An additional goal of our project, not reported here, is the integration of a form of concurrency based on objects with concurrent methods. <p> Since the subtyping ideas we use, outside of the module system, have been proposed in previous papers [CW85, Mit84, JM88] <ref> [CM89] </ref>, we will only give a brief summary of sub-typing. More detailed discussion of subtyping for specifications and structures appears in Section 5. We use the notation A &lt;: B to indicate that A is a subtype of B. <p> Since structures have many similarities to records, it might seem natural to identify objects with ML records instead of structures. If ML typing were extended with a flexible form of record typing, as in <ref> [Wan87, R em89, CM89] </ref> for example, this would allow much of the object-oriented capability we provide. One important difference, however, is inheritance. Rather than extend ML records with inheritance, we have chosen to integrate objects into the module system. <p> In this section, we will briefly review XML and then describe an extension XML with subtyping and constructs illustrating the essential features of our extended module system. Since the basic subtyping features of XML are subsumed by the more ambitious system of <ref> [CM89] </ref>, we emphasize the modules as opposed to subtyp-ing in this document. The language XML is a typed lambda calculus with two universes of types, U 1 and U 2 , which we have referred to informally as the small and large types, respectively.
Reference: [Coo89] <author> W.R. Cook. </author> <title> A proposal for making Eiffel type-safe. </title> <booktitle> In European Conf. on Object-Oriented Programming, </booktitle> <pages> pages 57-72, </pages> <year> 1989. </year>
Reference-contexts: Finally, we provide a compile-time typing discipline which is more flexible than C , without the type insecurity of Eiffel <ref> [Coo89] </ref>. Our type system is an extension of ML polymorphism, based in part on the record calculus of [CM89], and including F-bounded quantification [CCH 89] for specifying uniform behavior over functionally similar classes of objects.
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: The need for this new construct arises in part from our separation of specification and implementation, and our flexible forms of inheritance; see Section 6.1. Finally, we allow parameterized specifications (which seem especially useful for object-oriented programming) and use bounded quantification <ref> [CW85, CCH 89, CM89] </ref> rather than unconstrained ML polymorphism. One of our language design goals is to support a range of programming styles within a single framework. One style of interest is the traditional program development by step-wise refinement, using abstract data types and specifications. <p> Since the subtyping ideas we use, outside of the module system, have been proposed in previous papers <ref> [CW85, Mit84, JM88] </ref> [CM89], we will only give a brief summary of sub-typing. More detailed discussion of subtyping for specifications and structures appears in Section 5. We use the notation A &lt;: B to indicate that A is a subtype of B. <p> One novel feature of our module system, in comparison with Standard ML, is an impredicative treatment of existential types and a related implicit coercion from U 2 to U 1 . As described in [MP88], see also <ref> [CW85] </ref>, existentially quantified types correspond to the programming language notion of abstract types. Like Quest [Car89], our existential types are impredicative, so that a specification with only abstract (or, in Ada terminology, private) types may be considered a U 1 type instead of a U 2 type.
Reference: [Dij72] <author> E.W. Dijkstra. </author> <title> Notes on structured programming. In O.J. Dahl, E.W. Dijkstra, and C.A.R. Hoare, editors, Structured Programming. </title> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference-contexts: One style of interest is the traditional program development by step-wise refinement, using abstract data types and specifications. However, it is recognized that for realistic, large-scale programs, this idealized approach is not always effective. The main drawback is that in the pure style advocated in the early 1970's <ref> [Dij72, Par72] </ref>, a significant amount of effort may be put into the design before any code is written. Therefore, program behavior cannot be used to evaluate the program design until relatively late in the development cycle.
Reference: [GR83] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The language and its implementation. </title> <publisher> Addi-son Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Thus we provide explicit language support for what is often achieved by the programming technique of so-called abstract classes <ref> [GR83, page 66-72] </ref>. In addition, our unified approach to abstract data types and objects allows object-oriented concepts to be mixed with other programming styles, and provides inheritance of specification and implementation for algebraic data types.
Reference: [HMM86] <author> R. Harper, D.B. MacQueen, and R. Milner. </author> <title> Standard ML. </title> <type> Technical Report ECS-LFCS-86-2, </type> <institution> Lab. for Foundations of Computer Science, University of Edinburgh, </institution> <month> March </month> <year> 1986. </year>
Reference-contexts: 1 Introduction This paper describes a general module system which provides approximately the same functionality as a combination of Standard ML modules (signatures, structures and functors) <ref> [HMM86] </ref>, C classes [Str86], and Ada packages [US 80], enhanced with a form of specification. Our design effort stems from a larger project to produce a pro-totyping language and programming environment. <p> Our design effort stems from a larger project to produce a pro-totyping language and programming environment. However, since our modules most closely resemble Standard ML <ref> [Mac85, HMM86] </ref>, we have chosen to present the module design as an extension of that language.
Reference: [HMM90] <author> R. Harper, J.C. Mitchell, and E. Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Proc. 17-th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 341-354, </pages> <month> Jan-uary </month> <year> 1990. </year>
Reference-contexts: For instance, ML signatures, structures and functors may only be declared at top level, and functor application is restricted to top level. This is because the type part of a functor application is required at compile-time <ref> [MTH90, HMM90] </ref>. This conflicts with our desire to support object-oriented programming, since we would like to allow arbitrary computation on structures such as the object-oriented style stacks mention in Section 2. <p> In this case, we cannot expect to test equality at compile time, if the structure is a result of an arbitrary function call or conditional expression. Using a systematic criterion which is related to the distinction between small and large types (see <ref> [Mac85, MH88, HMM90] </ref>), we identify a class of compile-time evaluable structure expressions. These include the application of a top-level functor to a top-level structure. <p> sequential conjunction of two specifications, we may define ordered by the following declaration. specification orderedtype t order sigt andthen order constraintt We also provide syntax for defining ordered and similar parameterized specifications directly. 7 Type-theoretic perspective Our extension of Standard ML may be understood within the type-theoretic framework used in <ref> [Mac86, MH88, HMM90] </ref> to explain the Standard ML module system. <p> While the indexed categorical view of <ref> [HMM90] </ref> provides some interesting insight into the distinction between compile-time and run-time, we will restrict ourselves to the simpler and more accessible framework of [MH88], based on a predica-tive typed lambda calculus XML with two universes of types (see also [Set89]).
Reference: [JM88] <author> L. Jategaonkar and J.C. Mitchell. </author> <title> ML with extended pattern matching and subtypes. </title> <booktitle> In Proc. ACM Symp. Lisp and Functional Programming Languages, </booktitle> <pages> pages 198-212, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: However, based on past experience, we do not foresee any serious obstacles in extending ML-style type inference to our language. The reader concerned with type inference and subtyping may consult <ref> [Mit84, Wan87, R em89, JM88] </ref>. In Section 2, we give an informal introduction to the module language by describing two simple stack examples. Section 3 follows with a brief glossary of basic terminology. In Section 4, we briefly outline our use of sub-typing. <p> For example, we might specify that a type of stacks with an additional operation is a subtype of the stacks implemented as above. (A similar use of subtyp-ing and ML abstract data types was presented in <ref> [JM88] </ref>, where a type inference algorithm is developed.) A pervasive difference between our module system and Standard ML is our treatment of type equality, specifically, equality of type components of structures. <p> Since the subtyping ideas we use, outside of the module system, have been proposed in previous papers <ref> [CW85, Mit84, JM88] </ref> [CM89], we will only give a brief summary of sub-typing. More detailed discussion of subtyping for specifications and structures appears in Section 5. We use the notation A &lt;: B to indicate that A is a subtype of B.
Reference: [LHM 86] <author> D. C. Luckham, D. P. Helmbold, S. Meldal, D. L. Bryan, and M. A. Haberler. </author> <title> Task sequencing language for specifying distributed ada systems. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> Number 275, </volume> <pages> pages 249-305. </pages> <publisher> Springer-Verlag, </publisher> <month> May </month> <year> 1986. </year>
Reference-contexts: In this paper, we will focus primarily on the program-structuring aspects of our language, leaving further discussion of specifications and their use to later publications. The basis for our specification language and development tools is <ref> [LvHKBO87, LHM 86] </ref>. To a large extent, when restricted to the context of Standard ML, our specifications do not differ substantially from Sanella and Tar-lecki's Extended ML [ST89].
Reference: [LvHKBO87] <author> David Luckham, Friedrich W. von Henke, Bernd Krieg-Bruckner, and Olaf Owe. </author> <title> Anna </title>
Reference-contexts: In this paper, we will focus primarily on the program-structuring aspects of our language, leaving further discussion of specifications and their use to later publications. The basis for our specification language and development tools is <ref> [LvHKBO87, LHM 86] </ref>. To a large extent, when restricted to the context of Standard ML, our specifications do not differ substantially from Sanella and Tar-lecki's Extended ML [ST89].
References-found: 15

