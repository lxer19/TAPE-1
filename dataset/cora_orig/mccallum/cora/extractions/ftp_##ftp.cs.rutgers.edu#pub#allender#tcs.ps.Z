URL: ftp://ftp.cs.rutgers.edu/pub/allender/tcs.ps.Z
Refering-URL: http://www.cs.rutgers.edu/~allender/publications/
Root-URL: http://www.cs.rutgers.edu
Title: Almost-Everywhere Complexity Hierarchies for Nondeterministic Time  
Author: Eric Allender Richard Beigel P. O. Ulrich Hertrampf Steven Homer 
Note: A preliminary version of this work appeared as [2]. Supported in part by National Science Foundation grant CCR-9000045. Some of this research was performed while the author was a visiting professor  Supported in part by the National Science Foundation grants CCR-8808949 and CCR-8958528. Work done in part while at the  Supported in part by National Science Foundation grants MIP-8608137 and CCR-8814339, National Security Agency grant MDA904-87-H, and a Fulbright-Hays research fellowship. Some of this research was performed while the author was a Guest Professor  
Address: New Brunswick, NJ, USA 08903  51 Prospect St.  Box 2158, Yale Station New Haven, CT, USA 06520-2158  D-8700 Wurzburg, Federal Republic of Germany  Boston, MA, USA 02215  D-8700 Wurzburg, Federal Republic of Germany.  Heidelberg.  
Affiliation: Department of Computer Science, Rutgers University  Department of Computer Science, Yale University  Institut fur Informatik, Universitat Wurzburg  Department of Computer Science, Boston University  at Institut fur Informatik, Universitat Wurzburg,  Johns Hopkins University.  at Mathematisches Institut, Universitat  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> E. Allender, </author> <title> Oracles vs Proof techniques that do not relativize, </title> <booktitle> in: Proc. SIGAL International Symposium on Algorithms, Lecture Notes in Computer Science 450 (Springer, </booktitle> <address> Berlin, </address> <year> 1990) </year> <month> 39-52. </month>
Reference-contexts: Thus any proof that NTIME SAT (n 3 ) contains sets a.e. complex for NTIME SAT (n 2 ) will have to make essential use of certain properties of the oracle SAT. A longer discussion along these lines may be found in <ref> [1] </ref>. In this paper we consider only time complexity. An investigation of almost-everywhere complexity hierarchies for nondeterministic space has been carried out by Geske and Kakihara [13]. They prove almost-everywhere hierarchy theorems for nondeterministic space that are quite similar to those for deterministic space.
Reference: [2] <author> E. Allender, R. Beigel, U. Hertrampf, and S. Homer, </author> <title> A note on the almost-everywhere hierarchy for nondeterministic time, </title> <booktitle> in: Proc. 7th Symposium on Theoretical Aspects of Computer Science, Lecture Notes in Computer Science 415 (Springer, </booktitle> <address> Berlin, </address> <year> 1990) </year> <month> 1-11. </month>
Reference: [3] <author> L. Babai, L. Fortnow, and C. Lund, </author> <title> Non-deterministic exponential time has two-prover interactive protocols, </title> <booktitle> in: Proc. 31st IEEE Symposium on Foundations of Computer Science (1990) 16-25. </booktitle>
Reference-contexts: It is necessary to discuss the interpretation that should be afforded our oracle con structions, in light of the fact that compelling examples of nonrelativizing proof techniques do exist <ref> [3, 19, 24] </ref>. We maintain that it is useful to know what sort of hierarchies 4 hold relative to all oracles. Note that many important complexity classes are defined in terms of relativized nondeterministic computation; the levels of the polynomial hierarchy are the most obvious examples.
Reference: [4] <author> J. Balcazar and U. Schoning, </author> <title> Bi-immune sets for complexity classes, </title> <note> Mathematical Systems Theory 18 (1985) 1-10. </note>
Reference-contexts: Then L is immune to C if L is infinite and L has no infinite subset in C. L is co-immune to C if L is immune to C. L is bi-immune to C if L is both immune and co-immune to C. In <ref> [4] </ref>, Balcazar and Schoning noted the following relationship between almost-everywhere complexity and immunity for deterministic classes. Theorem 2 [4] Let t be a time-constructible function. Then L is a.e. complex for DTIME (t (n)) iff L is bi-immune to DTIME (t (n)). <p> L is co-immune to C if L is immune to C. L is bi-immune to C if L is both immune and co-immune to C. In <ref> [4] </ref>, Balcazar and Schoning noted the following relationship between almost-everywhere complexity and immunity for deterministic classes. Theorem 2 [4] Let t be a time-constructible function. Then L is a.e. complex for DTIME (t (n)) iff L is bi-immune to DTIME (t (n)). The forward implication in this theorem is in fact true for all functions t. However we note that time-constructibility is necessary for the reverse implication.
Reference: [5] <author> R. Book, S. Greibach, and B. Wegbreit, Time- and tape-bounded Turing acceptors and AFL's, J. </author> <note> Computer and System Sciences 4 (1970) 606-621. </note>
Reference-contexts: By <ref> [5] </ref>, for every set L 2 NTIME (t (n)), there is a machine M i in this 22 enumeration such that L = L (M i ).
Reference: [6] <editor> G. Buntrock, Logarithmisch platzbeschrankte Simulationen (Doctoral Dissertation, </editor> <address> Technische Universitat Berlin, </address> <year> 1989). </year>
Reference-contexts: It would be more satisfactory if our notion of almost-everywhere complexity precluded the possibility that infinitely many inputs could be rejected easily. This section introduces consistent nondeterministic Turing machines, in order to form a more acceptable notion of a.e. complexity for nondeterministic time. Consistent NTMs were considered by Buntrock <ref> [6] </ref>. We are unaware of any earlier mention of this notion in the literature. Consistent Turing machines are very similar in some respects to the strong nondeterministic Turing machines that were defined by Long [18]. Among other uses, strong nondeterministic Turing machines provide a nice characterization of NP " coNP.
Reference: [7] <author> S. Cook, </author> <title> A hierarchy for nondeterministic time complexity, </title> <note> Journal of Computer and System Sciences 7 (1973) 343-353. </note>
Reference-contexts: Clearly the [9] result also shows that there is no tight a.e. time hierarchy for probabilistic time that holds for all oracles. An early i.o. hierarchy theorem for nondeterministic time was given by Cook <ref> [7] </ref>. The strongest such theorem that is currently known is due to [23].
Reference: [8] <author> S. Cook and R. Reckhow, </author> <title> Time-bounded random access machines, </title> <journal> Journal of Computer and System Sciences 7 (1973) 354-375. </journal> <volume> 26 </volume>
Reference-contexts: This result was later improved by Hennie and Stearns [15], who proved a similar result, with "t (n) 2 " replaced by "t (n) log t (n)". Still later, Cook and Reckhow <ref> [8] </ref> and Furer [10] proved tighter results for RAM's and Turing machines with a fixed number of tapes, respectively.
Reference: [9] <author> L. Fortnow and M. Sipser, </author> <title> Probabilistic computation and linear time, </title> <booktitle> in: Proc. 21st IEEE Symposium on Foundations of Computer Science (1989) 148-156. </booktitle>
Reference-contexts: On the other hand, a recent oracle result of Fortnow and Sipser <ref> [9] </ref> shows that it is not possible to prove a very tight time hierarchy theorem 3 for probabilistic time using relativizable techniques; they present an oracle according to which BPP = BPTIME (O (n)). Clearly the [9] result also shows that there is no tight a.e. time hierarchy for probabilistic time <p> On the other hand, a recent oracle result of Fortnow and Sipser <ref> [9] </ref> shows that it is not possible to prove a very tight time hierarchy theorem 3 for probabilistic time using relativizable techniques; they present an oracle according to which BPP = BPTIME (O (n)). Clearly the [9] result also shows that there is no tight a.e. time hierarchy for probabilistic time that holds for all oracles. An early i.o. hierarchy theorem for nondeterministic time was given by Cook [7]. The strongest such theorem that is currently known is due to [23]. <p> Up to now, the best i.o. time hierarchy for probabilistic time classes is the same as the a.e. time hierarchy mentioned after the proof of Theorem 6. It would be interesting to know if the oracle construction of <ref> [9] </ref> can be improved to show that the (i.o.) probabilistic time hierarchy given by Theorem 6 is optimal. 6 Acknowledgments We thank the authors of [12] for sharing this paper with us, and John Geske, Joel Seiferas, Alan Selman and Jie Wang for helpful discussions. 25
Reference: [10] <author> M. Furer, </author> <title> Data structures for distributed counting, </title> <note> Journal of Computer and System Sciences 28 (1984) 231-243. </note>
Reference-contexts: This result was later improved by Hennie and Stearns [15], who proved a similar result, with "t (n) 2 " replaced by "t (n) log t (n)". Still later, Cook and Reckhow [8] and Furer <ref> [10] </ref> proved tighter results for RAM's and Turing machines with a fixed number of tapes, respectively.
Reference: [11] <author> J. Geske, D. Huynh, and A. Selman, </author> <title> A hierarchy theorem for almost everywhere complex sets with application to polynomial complexity degrees, </title> <booktitle> in: Proc. 4th Symposium on Theoretical Aspects of Computer Science, Lecture Notes in Computer Science 247 (Springer, </booktitle> <address> Berlin, </address> <year> 1987) </year> <month> 125-135. </month>
Reference-contexts: For the purposes of this paper, if T is time-constructible, then T (n) n for all n. been investigated in <ref> [11, 12, 25] </ref>. The following definitions make this precise. Definitions: * For any Turing machine M , the partial function T M : fl ! N is the time function of M.
Reference: [12] <editor> J. Geske, D. Huynh, and J. Seiferas, </editor> <title> A note on almost-everywhere-complex sets and separating deterministic-time-complexity classes, </title> <note> Information and Computation 92 (1991) 97-104. </note>
Reference-contexts: For the purposes of this paper, if T is time-constructible, then T (n) n for all n. been investigated in <ref> [11, 12, 25] </ref>. The following definitions make this precise. Definitions: * For any Turing machine M , the partial function T M : fl ! N is the time function of M. <p> One of the a.e. time hierarchy theorems of <ref> [12] </ref> can now be stated: Theorem 1 [12] If T is a time-constructible function and t (n) log t (n) = o (T (n)), then there is a set in DTIME (T (n)) that is a.e. complex for DTIME (t (n)). <p> One of the a.e. time hierarchy theorems of <ref> [12] </ref> can now be stated: Theorem 1 [12] If T is a time-constructible function and t (n) log t (n) = o (T (n)), then there is a set in DTIME (T (n)) that is a.e. complex for DTIME (t (n)). <p> Geske, Huynh, and Seiferas explicitly raise the question of an a.e. hierarchy for nondeterministic time as an open problem in <ref> [12] </ref>. This paper essentially settles this question. We present an a.e. hierarchy theorem for nondeterministic time, and we present an oracle relative to which the given theorem cannot be significantly improved. <p> It would be interesting to know if the oracle construction of [9] can be improved to show that the (i.o.) probabilistic time hierarchy given by Theorem 6 is optimal. 6 Acknowledgments We thank the authors of <ref> [12] </ref> for sharing this paper with us, and John Geske, Joel Seiferas, Alan Selman and Jie Wang for helpful discussions. 25
Reference: [13] <editor> J. Geske and D. Kakihara, </editor> <title> Almost-everywhere complexity, bi-immunity, and nondeterministic space, </title> <booktitle> in: Advances in Computing and Information - ICCI '90, Lecture Notes in Computer Science 468, </booktitle> <publisher> (Springer, </publisher> <address> Berlin, </address> <year> 1990) </year> <month> 44-51. </month>
Reference-contexts: A longer discussion along these lines may be found in [1]. In this paper we consider only time complexity. An investigation of almost-everywhere complexity hierarchies for nondeterministic space has been carried out by Geske and Kakihara <ref> [13] </ref>. They prove almost-everywhere hierarchy theorems for nondeterministic space that are quite similar to those for deterministic space. The organization of the paper is as follows. In Section 2 we define precisely what we mean by almost everywhere complexity for nondeterministic time.
Reference: [14] <author> J. Hartmanis and R. Stearns, </author> <title> On the computational complexity of algorithms, </title> <note> Transactions of the AMS 117 (1965) 285-306. </note>
Reference-contexts: 1 Introduction The hierarchy theorems for time and space are among the oldest and most basic results in complexity theory. One of the very first papers in the field of complexity theory was <ref> [14] </ref>, in which it was shown that if t (n) 2 = o (T (n)), then DTIME (T (n)) properly contains DTIME (t (n)), for any time-constructible 1 functions t and T .
Reference: [15] <author> F. Hennie and R. Stearns, </author> <title> Two-tape simulation of multitape Turing machines, </title> <journal> J. </journal> <note> ACM 13 (1966) 533-546. </note>
Reference-contexts: This result was later improved by Hennie and Stearns <ref> [15] </ref>, who proved a similar result, with "t (n) 2 " replaced by "t (n) log t (n)". Still later, Cook and Reckhow [8] and Furer [10] proved tighter results for RAM's and Turing machines with a fixed number of tapes, respectively.
Reference: [16] <author> M. Karpinski and R. </author> <title> Verbeek, Randomness, provability, and the separation of Monte Carlo time and space, </title> <editor> in: E. Borger, ed, </editor> <booktitle> Computation Theory and Logic, Lecture Notes in Computer Science 270 (Springer, </booktitle> <address> Berlin, </address> <year> 1987) </year> <month> 189-207. </month>
Reference-contexts: However much less is known about hierarchies for probabilistic and nondeterministic time. The best (i.o.) time hierarchy theorem for probabilistic time that has appeared in the literature is due to Karpinski and Verbeek <ref> [16] </ref>; however they are only able to show that BPTIME (t (n)) is properly contained in BPTIME (T (n)) when T (n) grows very much more quickly than t (n). <p> In particular, Corollary 8 below strengthens the hierarchy theorem for probabilistic computation classes proved by Karpinski and Verbeek <ref> [16, Theorem 2] </ref> in two ways: it presents a set in BPTIME (T (n)) that is immune for BPTIME (t (n)), and it allows the difference in the growth rates of T and t to be smaller 2 . <p> For the particular case of NTIME, the next result and its corollaries show that the 2 We leave it as an exercise to show that if T and t are monotone increasing functions satisfying the conditions of Theorem 2 in <ref> [16] </ref>, then (T ffi t 1 ) (3) (n) 6= 2 O (n) . 13 almost-everywhere complexity hierarchy theorem given by Theorem 6 cannot be improved by any relativizable proof technique.
Reference: [17] <author> Ming Li, </author> <title> Lower Bounds in Computational Complexity, </title> <type> (Doctoral Dissertation, </type> <institution> Cor-nell University, </institution> <year> 1985). </year> <month> 27 </month>
Reference-contexts: It is shown there that if t and T are time-constructible functions such that t (n + 1) = o (T (n)), then there is a set L in NTIME (T (n)) NTIME (t (n)). (Furthermore, it is shown in <ref> [27, 17] </ref> that L can even be chosen to be a subset of 0 fl ). When t and T are bounded by polynomials, this result is even tighter than the best known results for deterministic time.
Reference: [18] <author> T. </author> <title> Long, Strong nondeterministic polynomial-time reductions, </title> <note> Theoretical Computer Science 21 (1982) 1-25. </note>
Reference-contexts: Consistent NTMs were considered by Buntrock [6]. We are unaware of any earlier mention of this notion in the literature. Consistent Turing machines are very similar in some respects to the strong nondeterministic Turing machines that were defined by Long <ref> [18] </ref>. Among other uses, strong nondeterministic Turing machines provide a nice characterization of NP " coNP. Definition: A nondeterministic Turing machine M is consistent if, on every input x, 19 either all halting computation paths are accepting or all halting computation paths are rejecting. <p> Definition: A nondeterministic Turing machine M is consistent if, on every input x, 19 either all halting computation paths are accepting or all halting computation paths are rejecting. Note that Long's strong nondeterministic Turing machines <ref> [18] </ref> are simply consistent Turing machines such that there is a halting path for each input.
Reference: [19] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan, </author> <title> Algebraic methods for interactive proof systems, </title> <booktitle> in: Proc. 31st IEEE Symposium on Foundations of Computer Science (1990) 2-10. </booktitle>
Reference-contexts: It is necessary to discuss the interpretation that should be afforded our oracle con structions, in light of the fact that compelling examples of nonrelativizing proof techniques do exist <ref> [3, 19, 24] </ref>. We maintain that it is useful to know what sort of hierarchies 4 hold relative to all oracles. Note that many important complexity classes are defined in terms of relativized nondeterministic computation; the levels of the polynomial hierarchy are the most obvious examples.
Reference: [20] <author> M. Machtey and P. Young, </author> <title> An Introduction to the General Theory of Algorithms (Elsevier North-Holland, </title> <publisher> Inc., </publisher> <address> New York, </address> <year> 1978). </year>
Reference-contexts: By the time-bounded version of the recursion theorem (see e.g. Theorem 6.1.8 in 23 <ref> [20] </ref>), there is a nondeterministic Turing machine M that executes P with parameter M, having time complexity O (T (n)). We claim that L (M) is co-immune with respect to NTIME (t (n)).
Reference: [21] <author> C. Rackoff and J. Seiferas, </author> <title> Limitations on separating nondeterministic complexity classes, </title> <journal> SIAM J. Comp. </journal> <month> 10 </month> <year> (1981) </year> <month> 742-745. </month>
Reference-contexts: However, when T and t are very large, the gap between t (n) and t (n + 1) is also quite large, and thus the nondeterministic time hierarchy seems not to be very tight. On the other hand, Rackoff and Seiferas show in <ref> [21] </ref> that the i.o. time hierarchy theorem for nondeterministic time cannot be improved significantly using relativizable techniques.
Reference: [22] <author> S. Ruby and P. Fischer, </author> <title> Translational methods and computational complexity, </title> <booktitle> in: Proc. 6th IEEE Symposium on Switching Circuit Theory and Logical Design (1965) 173-178. </booktitle>
Reference-contexts: Although this is proved using known translational methods (see, e.g. <ref> [22] </ref>), it appears to be a new result. Later on in the paper, we show that this hierarchy theorem cannot be improved substantially using relativizable techniques. Our a.e. hierarchy theorem depends on the following lemma, which extends Theorem 2 0 of [23] in several small but technically necessary ways.
Reference: [23] <author> J. Seiferas, M. Fischer, and A. Meyer, </author> <title> Separating nondeterministic time complexity classes, </title> <journal> J. </journal> <note> ACM 25 (1978) 146-167. </note>
Reference-contexts: Clearly the [9] result also shows that there is no tight a.e. time hierarchy for probabilistic time that holds for all oracles. An early i.o. hierarchy theorem for nondeterministic time was given by Cook [7]. The strongest such theorem that is currently known is due to <ref> [23] </ref>. <p> Later on in the paper, we show that this hierarchy theorem cannot be improved substantially using relativizable techniques. Our a.e. hierarchy theorem depends on the following lemma, which extends Theorem 2 0 of <ref> [23] </ref> in several small but technically necessary ways. We say that a function T is ntime-constructible on S if there is a nondeterministic Turing machine accepting S such that all accepting computations on any input x 2 S have length exactly T (jxj). <p> If i exists and i j then reject x; N i is satisfied. Otherwise accept x; P j is satisfied. The correctness of the priority argument follows by standard techniques (see <ref> [23] </ref>). Theorem 6 Let T and t be monotone nondecreasing time-constructible functions such that, for some k, (T ffi t 1 ) (k) (n) 6= 2 O (n) . Then there is a set in NTIME (T (n)) that is immune to NTIME (t (n)).
Reference: [24] <author> A. Shamir, </author> <title> IP = PSPACE, </title> <booktitle> in: Proc. 31st IEEE Symposium on Foundations of Computer Science (1990) 11-15. </booktitle>
Reference-contexts: It is necessary to discuss the interpretation that should be afforded our oracle con structions, in light of the fact that compelling examples of nonrelativizing proof techniques do exist <ref> [3, 19, 24] </ref>. We maintain that it is useful to know what sort of hierarchies 4 hold relative to all oracles. Note that many important complexity classes are defined in terms of relativized nondeterministic computation; the levels of the polynomial hierarchy are the most obvious examples.
Reference: [25] <author> C. Smith, </author> <title> A note on arbitrarily complex recursive functions, </title> <journal> Notre Dame Journal of Formal Logic 29 (1988) 198-207. </journal>
Reference-contexts: For the purposes of this paper, if T is time-constructible, then T (n) n for all n. been investigated in <ref> [11, 12, 25] </ref>. The following definitions make this precise. Definitions: * For any Turing machine M , the partial function T M : fl ! N is the time function of M.
Reference: [26] <author> R. </author> <title> Verbeek, </title> <type> personal communication. </type>
Reference-contexts: Note that in this oracle construction, we actually prove that there are oracles relative to which every infinite set in NTIME (T (n)) has an infinite subset in UTIME (t (n)). Similarly, as Rutger Verbeek <ref> [26] </ref> has suggested, the same arguments could be used to 18 produce an infinite subset in RTIME (t (n)).
Reference: [27] <author> S. Zak, </author> <title> A Turing machine hierarchy, </title> <note> Theoretical Computer Science 26 (1983) 327-333. </note>
Reference-contexts: It is shown there that if t and T are time-constructible functions such that t (n + 1) = o (T (n)), then there is a set L in NTIME (T (n)) NTIME (t (n)). (Furthermore, it is shown in <ref> [27, 17] </ref> that L can even be chosen to be a subset of 0 fl ). When t and T are bounded by polynomials, this result is even tighter than the best known results for deterministic time.
References-found: 27

