URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR405.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: Development of a Fault-Tolerant Clock Synchronization Circuit 1  
Author: Paul S. Miner Shyamsundar Pullela Steven D. Johnson 
Keyword: Interaction of Formal Design Systems  
Date: April 1994  
Address: Bloomington, IN 47405-4101  
Affiliation: Indiana University Computer Science Department  
Note: in the  
Abstract: Technical Report No. 405 1 Research reported herein was supported, in part, by the National Science Foundation under grant MIP92-08745. 2 On leave from NASA Langley Research Center, Hampton, VA 23681 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> William R. Bevier and William D. Young. </author> <title> The proof of correctness of a fault-tolerant circuit design. </title> <booktitle> In Second IFIP Conference on Dependable Computing For Critical Applications, </booktitle> <pages> pages 107-114, </pages> <address> Tucson, Arizona, </address> <month> February </month> <year> 1991. </year> <month> 15 </month>
Reference-contexts: There are a number of cases of mechanically verified fault-tolerant algorithms [11, 20, 12], as well as verified specifications of high-level system descriptions [6, 7, 16, 23]. In addition, there have been exercises demonstrating the application of mechanical theorem provers to the verification of hardware components realizing fault-tolerant algorithms <ref> [22, 1, 13] </ref>. The difficulty with these verified components is that each proof involves simplifying assumptions concerning the rest of the architecture. In particular, they assume that the redundant computing elements are operating in lock-step synchrony.
Reference: [2] <author> Bhaskar Bose. </author> <title> DDD A Transformation system for Digital Design Derivation. </title> <type> Technical Report 331, </type> <institution> Computer Science Dept. Indiana University, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Furthermore, these verifications are not robust in the face of changes. That is, a small change in the design may invalidate much of the correctness proof. A different approach is formal derivation of hardware. The Digital Design Derivation system (DDD) <ref> [2] </ref> implements a collection of behavior preserving transformations that allow a designer to realize a design that is "correct-by-construction". There have been a number of significant designs realized using DDD. <p> verification as a top-level specification for a clock synchronization circuit employing the fault-tolerant midpoint convergence function. 3 Overview of Verification Procedure This verification effort involves the use of three distinct classes of verification tools: mechanical theorem proving systems (Ehdm [17], PVS [14]), a formal Digital Design Derivation 3 system (DDD <ref> [2] </ref>), and automatic tautology checking using Ordered Binary Decision Diagrams (OBDDs [5]). is a fully mechanized proof that any system that satisfies a small collection of properties is guaranteed to provide fault-tolerant clock synchronization. <p> the source languge for the OBDDs is manual. 3.1 A brief introduction to DDD (The following description of DDD is adapted from [4]) 4 5 DDD (Digital Design Derivation System) is a transformation system which implements a basic design algebra for synthesizing digital circuit descriptions from high level functional specifications <ref> [9, 2] </ref>. DDD is much like a theorem prover in the sense that it automates the transformations needed for circuit synthesis, but requires guidance to perform a derivation. DDD is implemented in the Lisp dialect Scheme as a collection of transformations that operate on s-expressions.
Reference: [3] <author> Bhaskar Bose and Steven D. Johnson. DDD-FM9001: </author> <title> Derivation of a verified micro processor. an exercise in integrating verification with formal derivation. </title> <booktitle> In Proceedings of IFIP Conference on Correct Hardware Design and Verification Methods. </booktitle> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: The Digital Design Derivation system (DDD) [2] implements a collection of behavior preserving transformations that allow a designer to realize a design that is "correct-by-construction". There have been a number of significant designs realized using DDD. In particular, Bose has formally derived the DDD-FM9001 <ref> [3] </ref> processor from Hunt's formal specification of the mechanically verified FM9001 microprocessor [8]. Another significant derivation is the development of a Scheme Machine, which consists of a garbage-collecting memory system and a CPU that executes high-level Scheme primitives [24].
Reference: [4] <author> Bhaskar Bose, Steven D. Johnson, and Shyam Pullela. </author> <title> Integrating boolean verification with formal derivation. </title> <editor> In D. Agnew, L. Claesen, and R. Camposano, editors, </editor> <booktitle> Proceedings of IFIP Conference on Hardware Description Languages and their Applications, </booktitle> <pages> pages 127-134. </pages> <publisher> Elsevier, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: Furthermore, the translations between DDD and PVS are manual; there is no formal interface defined between the two systems. Similarly, the translation to the source languge for the OBDDs is manual. 3.1 A brief introduction to DDD (The following description of DDD is adapted from <ref> [4] </ref>) 4 5 DDD (Digital Design Derivation System) is a transformation system which implements a basic design algebra for synthesizing digital circuit descriptions from high level functional specifications [9, 2]. <p> We 13 already have efficient Actel implementations of both an adder and an incrementor. In essence, we want to replace some modules of the derived architecture with efficient implementations of the same functions. The technique we use here is similar to the one reported in <ref> [4] </ref>. Since we would like to replace the adder and incrementor modules with our own designs, these modules are factored out prior to the projection transformations.
Reference: [5] <author> R. E. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3), </volume> <month> September </month> <year> 1992. </year>
Reference-contexts: the fault-tolerant midpoint convergence function. 3 Overview of Verification Procedure This verification effort involves the use of three distinct classes of verification tools: mechanical theorem proving systems (Ehdm [17], PVS [14]), a formal Digital Design Derivation 3 system (DDD [2]), and automatic tautology checking using Ordered Binary Decision Diagrams (OBDDs <ref> [5] </ref>). is a fully mechanized proof that any system that satisfies a small collection of properties is guaranteed to provide fault-tolerant clock synchronization. The work reported in this paper begins with a state-machine that represents a generalized clock synchronization algorithm.
Reference: [6] <author> Ben L. Di Vito and Ricky W. Butler. </author> <title> Provable transient recovery for frame-based, fault tolerant computing systems. </title> <booktitle> In Real-Time Systems Symposium, </booktitle> <address> Phoenix, Az, </address> <month> December </month> <year> 1992. </year>
Reference-contexts: Even if the algorithm is formally verified, a simple bug in the realization could introduce a single point failure. There are a number of cases of mechanically verified fault-tolerant algorithms [11, 20, 12], as well as verified specifications of high-level system descriptions <ref> [6, 7, 16, 23] </ref>. In addition, there have been exercises demonstrating the application of mechanical theorem provers to the verification of hardware components realizing fault-tolerant algorithms [22, 1, 13]. The difficulty with these verified components is that each proof involves simplifying assumptions concerning the rest of the architecture.
Reference: [7] <author> Ben L. Di Vito, Ricky W. Butler, and James L. Caldwell. </author> <title> High level design proof of a reliable computing platform. In Dependable Computing for Critical Applications 2, </title> <booktitle> Dependable Computing and Fault-Tolerant Systems, </booktitle> <pages> pages 279-306. </pages> <publisher> Springer Verlag, </publisher> <address> Wien New York, </address> <year> 1992. </year>
Reference-contexts: Even if the algorithm is formally verified, a simple bug in the realization could introduce a single point failure. There are a number of cases of mechanically verified fault-tolerant algorithms [11, 20, 12], as well as verified specifications of high-level system descriptions <ref> [6, 7, 16, 23] </ref>. In addition, there have been exercises demonstrating the application of mechanical theorem provers to the verification of hardware components realizing fault-tolerant algorithms [22, 1, 13]. The difficulty with these verified components is that each proof involves simplifying assumptions concerning the rest of the architecture.
Reference: [8] <author> Warren A. Hunt. </author> <title> A formal HDL and its use in the FM9001 verification. In C.A.R. </title> <editor> Hoare and M.J.C. Gordon, editors, </editor> <title> Mechanized Reasoning in Hardware Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: There have been a number of significant designs realized using DDD. In particular, Bose has formally derived the DDD-FM9001 [3] processor from Hunt's formal specification of the mechanically verified FM9001 microprocessor <ref> [8] </ref>. Another significant derivation is the development of a Scheme Machine, which consists of a garbage-collecting memory system and a CPU that executes high-level Scheme primitives [24].
Reference: [9] <author> Steven D. Johnson, B. Bose, </author> <title> and C.D. Boyer. A tactical framework for digital design. </title> <editor> In Birtwistle and Subramanyam, editors, </editor> <booktitle> VLSI Specification, Verification and Synthesis, </booktitle> <pages> pages 349-383. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: the source languge for the OBDDs is manual. 3.1 A brief introduction to DDD (The following description of DDD is adapted from [4]) 4 5 DDD (Digital Design Derivation System) is a transformation system which implements a basic design algebra for synthesizing digital circuit descriptions from high level functional specifications <ref> [9, 2] </ref>. DDD is much like a theorem prover in the sense that it automates the transformations needed for circuit synthesis, but requires guidance to perform a derivation. DDD is implemented in the Lisp dialect Scheme as a collection of transformations that operate on s-expressions.
Reference: [10] <author> Steven D. Johnson, R.M. Wehrmeister, and B. Bose. </author> <title> On the interplay of synthesis and verification: Experiments with the FM8501 processor description. </title> <editor> In Claesen, editor, </editor> <booktitle> Applied Formal Methods for Correct VLSI Design, </booktitle> <pages> pages 385-404. </pages> <publisher> Elsevier, </publisher> <year> 1989. </year> <month> IMEC </month> <year> 1989. </year>
Reference-contexts: Another significant derivation is the development of a Scheme Machine, which consists of a garbage-collecting memory system and a CPU that executes high-level Scheme primitives [24]. During the above projects, it was recognized that a combination of DDD with mechanized proof support would be superior to either approach individually <ref> [10] </ref>. An important characteristic of DDD is that it allows the designer flexibility to explore the design space. It is fairly easy to explore a number of design possibilities in a formal manner, without committing to a particular design decision.
Reference: [11] <author> Patrick Lincoln and John Rushby. </author> <title> A formally verified algorithm for interactive consis tency under a hybrid fault model. </title> <booktitle> In Fault Tolerant Computing Symposium 23, </booktitle> <pages> pages 402-411, </pages> <address> Toulouse, France, June 1993. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: 1 Introduction Architectural components realizing fault-tolerant algorithms require effective design techniques. Even if the algorithm is formally verified, a simple bug in the realization could introduce a single point failure. There are a number of cases of mechanically verified fault-tolerant algorithms <ref> [11, 20, 12] </ref>, as well as verified specifications of high-level system descriptions [6, 7, 16, 23]. In addition, there have been exercises demonstrating the application of mechanical theorem provers to the verification of hardware components realizing fault-tolerant algorithms [22, 1, 13].
Reference: [12] <author> Paul S. Miner. </author> <title> Verification of fault-tolerant clock synchronization systems. </title> <type> Technical Paper 3349, </type> <institution> NASA, Langley Research Center, Hampton, VA, </institution> <month> November </month> <year> 1993. </year> <month> 16 </month>
Reference-contexts: 1 Introduction Architectural components realizing fault-tolerant algorithms require effective design techniques. Even if the algorithm is formally verified, a simple bug in the realization could introduce a single point failure. There are a number of cases of mechanically verified fault-tolerant algorithms <ref> [11, 20, 12] </ref>, as well as verified specifications of high-level system descriptions [6, 7, 16, 23]. In addition, there have been exercises demonstrating the application of mechanical theorem provers to the verification of hardware components realizing fault-tolerant algorithms [22, 1, 13]. <p> Schneider [19] demonstrates that many fault-tolerant clock synchronization algorithms can be treated as refinements of a general protocol. Shankar [20] and Miner <ref> [12] </ref> have provided mechanically checked proofs of Schneider's paradigm. <p> A machine checked proof of this is presented by Miner <ref> [12] </ref>.
Reference: [13] <author> J Strother Moore. </author> <title> Mechanically verified hardware implementing an 8-bit parallel io byzantine agreement processor. </title> <type> NASA Contractor Report 189588, </type> <month> April </month> <year> 1992. </year>
Reference-contexts: There are a number of cases of mechanically verified fault-tolerant algorithms [11, 20, 12], as well as verified specifications of high-level system descriptions [6, 7, 16, 23]. In addition, there have been exercises demonstrating the application of mechanical theorem provers to the verification of hardware components realizing fault-tolerant algorithms <ref> [22, 1, 13] </ref>. The difficulty with these verified components is that each proof involves simplifying assumptions concerning the rest of the architecture. In particular, they assume that the redundant computing elements are operating in lock-step synchrony.
Reference: [14] <author> S. Owre, J. M. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <editor> In Deepak Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction (CADE), volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752, </pages> <address> Saratoga, NY, June 1992. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: this paper, we will use the assumptions of Miner's verification as a top-level specification for a clock synchronization circuit employing the fault-tolerant midpoint convergence function. 3 Overview of Verification Procedure This verification effort involves the use of three distinct classes of verification tools: mechanical theorem proving systems (Ehdm [17], PVS <ref> [14] </ref>), a formal Digital Design Derivation 3 system (DDD [2]), and automatic tautology checking using Ordered Binary Decision Diagrams (OBDDs [5]). is a fully mechanized proof that any system that satisfies a small collection of properties is guaranteed to provide fault-tolerant clock synchronization.
Reference: [15] <author> Franklin P. Prosser and David E. </author> <title> Winkel. </title> <booktitle> The Art of Digital Design. Prentice/Hall International, second edition, </booktitle> <year> 1987. </year>
Reference-contexts: Ultimately, this decomposition produces a hierarchy of boolean subsystems. Logic synthesis is used to assemble the subsystems to the appropriate technology. 4 Behavioral Specification An abstract view of our behavioral specification is given in Figure 2 using the ASM chart notation from <ref> [15] </ref> . This corresponds to a top-level DDD specification. It establishes the control of the machine and identifies some of the registers, but leaves architectural components abstractly specified. In particular, we have not given an explicit representation for either or cfn.
Reference: [16] <author> John Rushby. </author> <title> Formal specification and verification of a fault-masking and transient recovery model for digital flight-control systems. In Second International Symposium on Formal Techniques in Real Time and Fault Tolerant Systems, </title> <booktitle> volume 571 of Lecture Notes in Computer Science, </booktitle> <pages> pages 237-258. </pages> <publisher> Springer Verlag, </publisher> <address> Nijmegen, The Nether-lands, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Even if the algorithm is formally verified, a simple bug in the realization could introduce a single point failure. There are a number of cases of mechanically verified fault-tolerant algorithms [11, 20, 12], as well as verified specifications of high-level system descriptions <ref> [6, 7, 16, 23] </ref>. In addition, there have been exercises demonstrating the application of mechanical theorem provers to the verification of hardware components realizing fault-tolerant algorithms [22, 1, 13]. The difficulty with these verified components is that each proof involves simplifying assumptions concerning the rest of the architecture.
Reference: [17] <author> John Rushby, Friedrich von Henke, and Sam Owre. </author> <title> An introduction to formal specifi cation and verification using ehdm. </title> <type> Technical Report SRI-CSL-91-2, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: In this paper, we will use the assumptions of Miner's verification as a top-level specification for a clock synchronization circuit employing the fault-tolerant midpoint convergence function. 3 Overview of Verification Procedure This verification effort involves the use of three distinct classes of verification tools: mechanical theorem proving systems (Ehdm <ref> [17] </ref>, PVS [14]), a formal Digital Design Derivation 3 system (DDD [2]), and automatic tautology checking using Ordered Binary Decision Diagrams (OBDDs [5]). is a fully mechanized proof that any system that satisfies a small collection of properties is guaranteed to provide fault-tolerant clock synchronization.
Reference: [18] <author> James B. Saxe, Stephen J. Garland, John V. Guttag, and James J. Horning. </author> <title> Us ing transformations and verification in circuit design. </title> <type> Research Report 78, </type> <institution> DEC-SRC, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: In particular, some transformations are only applicable within the context of a certain design. Such transformations cannot be justified on general principles. We adopt the terminology of Saxe, et al. <ref> [18] </ref> and refer to these as an ad hoc transformations. Justification of such transformations requires theorem proving support. Thus, we would like to augment the derivational approach with mechanical theorem proving support thereby enabling the effective formal development of more efficient hardware. <p> We claim without proof that this representation satisfies the appropriate assumptions of the Ehdm verification. This state machine is transformed into a structural description using DDD. This structural description is transformed into an architecture using both built-in DDD transformations and an ad hoc <ref> [18] </ref> transformation that requires external justification. Appropriate subsets of the DDD description are manually translated into the PVS logic. The PVS prover is then used to demonstrate that a particular substitution preserves behavior within the context of the rest of the design.
Reference: [19] <author> Fred B. Schneider. </author> <title> Understanding protocols for Byzantine clock synchronization. </title> <type> Tech nical Report 87-859, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, NY, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: In addition, each stage in the development maintains some generality, so the resulting circuit can be used in a variety of systems. 2 Fault-Tolerant Clock Synchronization A critical function in a fault-tolerant architecture is synchronizing the clocks of the redundant computing elements. Schneider <ref> [19] </ref> demonstrates that many fault-tolerant clock synchronization algorithms can be treated as refinements of a general protocol. Shankar [20] and Miner [12] have provided mechanically checked proofs of Schneider's paradigm. <p> For many of the published convergence functions, it would be unnecessary to alter our mechanism for capturing the readings of remote clocks in a sorted list. Any of the following convergence functions could be used instead of the fault-tolerant midpoint (the names are from Schneider <ref> [19] </ref>): Egocentric Average, Fast Convergence Algorithm, or Fault-tolerant Average. Other algorithms, such as that by Srikanth and Toueg [21], do not fit as cleanly into this specification. 8 Other portions of the algorithm depend upon our choice of convergence function.
Reference: [20] <author> Natarajan Shankar. </author> <title> Mechanical verification of a generalized protocol for byzantine fault-tolerant clock synchronization. In Second International Symposium on Formal Techniques in Real Time and Fault Tolerant Systems, </title> <booktitle> volume 571 of Lecture Notes in Computer Science, </booktitle> <pages> pages 217-236. </pages> <publisher> Springer Verlag, </publisher> <address> Nijmegen, The Netherlands, </address> <month> Jan-uary </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Architectural components realizing fault-tolerant algorithms require effective design techniques. Even if the algorithm is formally verified, a simple bug in the realization could introduce a single point failure. There are a number of cases of mechanically verified fault-tolerant algorithms <ref> [11, 20, 12] </ref>, as well as verified specifications of high-level system descriptions [6, 7, 16, 23]. In addition, there have been exercises demonstrating the application of mechanical theorem provers to the verification of hardware components realizing fault-tolerant algorithms [22, 1, 13]. <p> Schneider [19] demonstrates that many fault-tolerant clock synchronization algorithms can be treated as refinements of a general protocol. Shankar <ref> [20] </ref> and Miner [12] have provided mechanically checked proofs of Schneider's paradigm.
Reference: [21] <author> T.K. Srikanth and S. Toueg. </author> <title> Optimal clock synchronization. </title> <journal> Journal of the ACM, </journal> <volume> 34(3) </volume> <pages> 626-645, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Any of the following convergence functions could be used instead of the fault-tolerant midpoint (the names are from Schneider [19]): Egocentric Average, Fast Convergence Algorithm, or Fault-tolerant Average. Other algorithms, such as that by Srikanth and Toueg <ref> [21] </ref>, do not fit as cleanly into this specification. 8 Other portions of the algorithm depend upon our choice of convergence function.
Reference: [22] <author> Mandayam Srivas and Mark Bickford. </author> <title> Verification of the FtCayuga fault-tolerant mi croprocessor system: Volume 1: A case study in theorem prover-based verification. </title> <type> Contractor Report 4381, </type> <institution> NASA, </institution> <month> July </month> <year> 1991. </year> <institution> Authors' affiliation: ORA Corporation, </institution> <address> Ithaca, NY. </address>
Reference-contexts: There are a number of cases of mechanically verified fault-tolerant algorithms [11, 20, 12], as well as verified specifications of high-level system descriptions [6, 7, 16, 23]. In addition, there have been exercises demonstrating the application of mechanical theorem provers to the verification of hardware components realizing fault-tolerant algorithms <ref> [22, 1, 13] </ref>. The difficulty with these verified components is that each proof involves simplifying assumptions concerning the rest of the architecture. In particular, they assume that the redundant computing elements are operating in lock-step synchrony.
Reference: [23] <author> Mandayam Srivas and Mark Bickford. </author> <title> Moving formal methods into practice: Verifying the FTPP scoreboard: Phase 1 results. </title> <type> NASA Contractor Report 189607, </type> <month> May </month> <year> 1992. </year> <month> 17 </month>
Reference-contexts: Even if the algorithm is formally verified, a simple bug in the realization could introduce a single point failure. There are a number of cases of mechanically verified fault-tolerant algorithms [11, 20, 12], as well as verified specifications of high-level system descriptions <ref> [6, 7, 16, 23] </ref>. In addition, there have been exercises demonstrating the application of mechanical theorem provers to the verification of hardware components realizing fault-tolerant algorithms [22, 1, 13]. The difficulty with these verified components is that each proof involves simplifying assumptions concerning the rest of the architecture.
Reference: [24] <author> M. Esen Tuna, Steven D. Johnson, and Bob Burger. </author> <note> Continuations in hardware-software codesign, </note> <month> March </month> <year> 1994. </year> <note> submitted to ICCD. </note>
Reference-contexts: In particular, Bose has formally derived the DDD-FM9001 [3] processor from Hunt's formal specification of the mechanically verified FM9001 microprocessor [8]. Another significant derivation is the development of a Scheme Machine, which consists of a garbage-collecting memory system and a CPU that executes high-level Scheme primitives <ref> [24] </ref>. During the above projects, it was recognized that a combination of DDD with mechanized proof support would be superior to either approach individually [10]. An important characteristic of DDD is that it allows the designer flexibility to explore the design space.
Reference: [25] <author> J. Lundelius Welch and N. Lynch. </author> <title> A new fault-tolerant algorithm for clock synchro nization. </title> <journal> Information and Computation, </journal> <volume> 77(1) </volume> <pages> 1-36, </pages> <month> April </month> <year> 1988. </year> <month> 18 </month>
Reference-contexts: The fault-tolerant midpoint convergence function, cfn MID () = (F +1) + (NF ) % where (m) = the mth largest value of employed in the Welch and Lynch <ref> [25] </ref> clock synchronization algorithm, possesses the required properties of a convergence function. A machine checked proof of this is presented by Miner [12].
References-found: 25

