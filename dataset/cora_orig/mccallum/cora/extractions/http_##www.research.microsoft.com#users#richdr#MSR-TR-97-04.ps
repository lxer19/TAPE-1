URL: http://www.research.microsoft.com/users/richdr/MSR-TR-97-04.ps
Refering-URL: http://www.research.microsoft.com/users/richdr/
Root-URL: http://www.research.microsoft.com
Title: The Rialto Virtual Memory System  
Author: Richard P. Draves Gilad Odinak Scott M. Cutshall 
Address: One Microsoft Way Redmond, WA 98052  
Affiliation: Microsoft Research Advanced Technology Division Microsoft Corporation  
Date: February 15, 1997  
Abstract: Technical Report MSR-TR-97-04 
Abstract-found: 1
Intro-found: 1
Reference: [Armand 91] <author> Armand, F. </author> <title> Give a Process to your Drivers! In Proceedings of the EurOpen Autumn 1991 Conference, </title> <address> Budapest, Hungary, </address> <month> September 16-20, </month> <year> 1991. </year>
Reference-contexts: Because the call-backs may in turn make nested system calls, the call-back operation checks how much kernel stack is left unused, and if necessary allocates and wires down more pages to guarantee subsequent nested calls 8K of kernel stack. Other operating systems (for example, Chorus <ref> [Armand 91] </ref>) allow system services to be loaded at run-time into either a user process context or a kernel context. However, we are not aware of any other operating system that allows user process and kernel process components to share dynamically loaded libraries with per-process static data.
Reference: [Bala et al. 94] <author> Bala, K., Kaashoek, M. F., Weihl, W. E. </author> <title> Software Prefetching and Caching for Translation Lookaside Buffers. </title> <booktitle> In Proceedings of the First USENIX Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 243253, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Unlike our VTLB design, the pmap layer does not allow kernel mappings to be recycled. This avoids the synchronization and recursion problems that we solved. However, it means that a pmap implementation can not use a simple software TLB as its primary data structure. <ref> [Bala et al. 94] </ref> optimized the MIPS R3000 pmap implementation by adding a software TLB as a first-level cache in front of the pmaps page table pages. This achieved a useful performance improvement, but it did not address our goal of eliminating or reducing the number of page table pages.
Reference: [Bolosky et al. 96] <author> Bolosky, W. J., Joseph Barrera, J. S., Draves, R. P., Fitzgerald, R. P., Gibson, G. A., Jones, M. B., Levi, S. P., Myhrvold, N. P., Rashid, R. F. </author> <title> The Tiger Video Fileserver. </title> <booktitle> In Proceedings of the Sixth International Workshop on Network and Operating System Support for Digital Audio and Video, </booktitle> <month> April </month> <year> 1996. </year>
Reference-contexts: MiTV runs applications like Electronic Program Guide and Video on Demand on set-top boxes (STBs) connected via ATM over fiber or hybrid fiber/coax networks to servers running Windows NT and the Tiger multimedia file system <ref> [Bolosky et al. 96] </ref>. The STBs have Pentium processors, high-performance graphics boards, hardware MPEG2 decoders, and ATM network interface cards. Microsoft and NTT deployed MiTV on March 22, 1996 in a joint trial in Yokosuka, Japan. The trial started with 30 homes and has since grown to about 300 homes.
Reference: [Brockschmidt 95] <author> Brockschmidt, K. </author> <title> Inside OLE, Second Edition. </title> <publisher> Microsoft Press, </publisher> <address> Redmond, WA, </address> <year> 1995. </year>
Reference-contexts: Rialtos soft real-time model combines a coarse-grained resource reservation system with fine-grained control over scheduling behavior via scheduling constraints. Constraints allow an application to provide to the scheduler deadlines and estimates of execution time. See [Jones et al. 95] for further details. Rialto uses Microsofts Component Object Model (COM) <ref> [Brockschmidt 95] </ref> as the basis for inter-process communication, including system calls on kernel objects. In this model, objects export one or more interfaces (C++ style vtbls).
Reference: [Heilpern 94] <author> Heilpern, M. </author> <title> The OS-9 Primer. </title> <institution> Microware Systems Corporation, Des Moines, IA, </institution> <year> 1994. </year>
Reference-contexts: However, we are not aware of any other operating system that allows user process and kernel process components to share dynamically loaded libraries with per-process static data. Commercial real-time operating systems provide very little virtual memory support. For example, OS-9 <ref> [Heilpern 94] </ref> has implementations for Intel x86, Motorola 68K, and PowerPC machines. It gives the application programmer malloc and free heap-management APIs. For production use, OS-9 applications can run on a version of the kernel without MMU support. 6.
Reference: [Intel 95] <editor> Pentiumfi Processor Family Developers Manual, </editor> <volume> Volume 3. </volume> <publisher> Intel Corporation, </publisher> <address> Santa Clara, CA, </address> <year> 1995. </year>
Reference-contexts: In general we wanted the kernel to support preemptive scheduling with sub-millisecond granularity. Support for Microsofts standard APIs. Applications for the system are written to a subset of Win32 [Microsoft 93]. The Win32 memory management APIs required some special support. Portable to Intel x86 processors <ref> [Intel 95] </ref> with hardware page tables and RISC processors like MIPS [Kane 88] with software TLB miss handlers. Rialto first ran on a MIPS R3000 board and was later ported to Intel x86 PCs and set-top boxes.
Reference: [Jones et al. 95] <author> Jones, M. B., Leach, P. J., Draves, R. P., Barrera, J. S. </author> <title> Modular Real-Time Resource Management in the Rialto Operating System. </title> <booktitle> In Proceedings of the Fifth Workshop on Hot Topics in Operating Systems, </booktitle> <pages> pages 1217. </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Rialtos soft real-time model combines a coarse-grained resource reservation system with fine-grained control over scheduling behavior via scheduling constraints. Constraints allow an application to provide to the scheduler deadlines and estimates of execution time. See <ref> [Jones et al. 95] </ref> for further details. Rialto uses Microsofts Component Object Model (COM) [Brockschmidt 95] as the basis for inter-process communication, including system calls on kernel objects. In this model, objects export one or more interfaces (C++ style vtbls).
Reference: [Jones 96] <author> Jones, M. B. </author> <title> The Microsoft Interactive TV System: </title> <note> An Experience Report. Submitted for publication, </note> <year> 1996. </year>
Reference-contexts: The STBs have Pentium processors, high-performance graphics boards, hardware MPEG2 decoders, and ATM network interface cards. Microsoft and NTT deployed MiTV on March 22, 1996 in a joint trial in Yokosuka, Japan. The trial started with 30 homes and has since grown to about 300 homes. See <ref> [Jones 96] </ref> for an overview of the MiTV system and the Yokosuka trial. 2. Interfaces Rialtos virtual memory interfaces consist of two COM interfaces for kernel objects, IAddressSpace and IMemoryObject, plus several APIs for use by drivers and only available inside the kernel process.
Reference: [Khalidi and Nelson 93] <author> Khalidi, Y. A. and Nelson, M. N. </author> <title> A Flexible External Paging Interface. </title> <booktitle> In Proceedings of the USENIX conference on Microkernels and Other Architectures, </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: For example, a view object can be used to hand out an IMemoryObject that allows only read access to a particular read-write region in an address space. Unlike memory object interfaces in systems such as Mach [Young et al. 87] and Spring <ref> [Khalidi and Nelson 93] </ref>, the IMemoryObject interface does not contain the methods necessary to support external IMemoryObject implementations. The Map method fails if the supplied IMemoryObject has a foreign implementation. This technique of using an abstract interface but only supporting internal implementations greatly simplified our design.
Reference: [Kane 88] <author> Kane, G. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: Support for Microsofts standard APIs. Applications for the system are written to a subset of Win32 [Microsoft 93]. The Win32 memory management APIs required some special support. Portable to Intel x86 processors [Intel 95] with hardware page tables and RISC processors like MIPS <ref> [Kane 88] </ref> with software TLB miss handlers. Rialto first ran on a MIPS R3000 board and was later ported to Intel x86 PCs and set-top boxes. We had several reasons for supporting virtual memory in an operating system designed for consumer appliances.
Reference: [Microsoft 93] <editor> Win32 Programmers Reference. </editor> <publisher> Microsoft Press, </publisher> <address> Redmond, WA, </address> <year> 1993. </year>
Reference-contexts: We wanted the VM system to be completely interruptible, and be preemptible except for short code sections. In general we wanted the kernel to support preemptive scheduling with sub-millisecond granularity. Support for Microsofts standard APIs. Applications for the system are written to a subset of Win32 <ref> [Microsoft 93] </ref>. The Win32 memory management APIs required some special support. Portable to Intel x86 processors [Intel 95] with hardware page tables and RISC processors like MIPS [Kane 88] with software TLB miss handlers.
Reference: [Rashid et al. 87] <author> Rashid, R., Tevanian, A., Young, M., Golub, D., Baron, R., Black, D., Bolosky, W., Chew, J.. </author> <title> Machine-Independent Virtual Memory Management for Paged Uniprocessor and Multiprocessor Architectures. </title> <booktitle> In Proceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 3139, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: The fault handler protects the kernel from invalid user addresses via a scratch page and it supports auto-commit faults on kernel-mode thread stacks. 3.1 VTLB Architecture The Rialto kernel uses a virtual TLB (VTLB) to implement virtual memory. The VTLB caches virtual-physical address translations, much like Machs pmap layer <ref> [Rashid et al. 87] </ref> but with the distinction that any entry in the VTLB may be flushed at any time. The VTLB approach saves memory because it bounds the size of the machinedependent mapping data structures. <p> The average VTLB miss latency increased from 41ms to 47ms (due to the cost of recyling page table pages), so the CPU overhead for VTLB misses increased from 0.37% to 0.82%. 5. Related Work Our VTLB architecture owes a great deal to the Mach pmap layer <ref> [Rashid et al. 87] </ref>. Like the VTLB, the Mach pmap caches virtual-to-physical mappings and insulates the machine-independent VM code from the details of the hardware MMU. Unlike our VTLB design, the pmap layer does not allow kernel mappings to be recycled.
Reference: [Wahbe et al. 93] <author> Wahbe, R., Lucco, S., Anderson, T. E., Graham, S. L. </author> <title> Efficient Software-Based Fault Isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203216, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: First, virtual memory allows the operating system to protect against buggy applications. This facilitates development and makes the platform more reliable for the end-user. Furthermore, Internet-connected systems should protect against malicious applications. Alternative protection mechanisms such 2 as interpreted languages or sandboxing <ref> [Wahbe et al. 93] </ref> give up size or performance. Second, virtual memory avoids problems with fragmentation of physical memory, and problems with sizing heaps and stacks. Finally, virtual memory makes our system much more compatible with desktop operating systems.
Reference: [Young et al. 87] <author> Young, M., Tevanian, A., Rashid, R., Golub, D., Eppinger, J., Chew, J., Bolosky, W., Black, D., Baron, R.. </author> <title> The Duality of Memory and Communication in the Implementation of a Multiprocessor Operating System. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 6376, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: For example, a view object can be used to hand out an IMemoryObject that allows only read access to a particular read-write region in an address space. Unlike memory object interfaces in systems such as Mach <ref> [Young et al. 87] </ref> and Spring [Khalidi and Nelson 93], the IMemoryObject interface does not contain the methods necessary to support external IMemoryObject implementations. The Map method fails if the supplied IMemoryObject has a foreign implementation.
Reference: [Young 89] <author> Young, M. W. </author> <title> Exporting a User Interface to Memory Management from a Communication-Oriented Operating System. </title> <type> Ph.D. dissertation, </type> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: They are explicitly defined not to be failure-atomic; if they return a failure code then their operation may have been performed on part of the region. (This contrasts for example with Machs VM operations, which were all failure-atomic <ref> [Young 89] </ref>.) This simplifies the implementation with no real inconvenience for the user. Correct programs will never encounter any of the semantic errors (like trying to Protect a region that is only partially committed).
References-found: 15

