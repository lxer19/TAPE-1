URL: http://www.cs.cmu.edu/~fp/papers/dml97b.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/hwxi/www/manuscripts.html
Root-URL: 
Email: hwxi@cs.cmu.edu  fp@cs.cmu.edu  
Title: A Schema for Adding Dependent Types to ML  
Author: Hongwei Xi Frank Pfenning 
Affiliation: Department of Mathematical Sciences Carnegie Mellon University  Department of Computer Science Carnegie Mellon University  
Abstract: We present an approach to enriching the type system of ML with a form of dependent types, where index objects are restricted to constraint domains C, leading to the DML(C) language schema. Pure inference for the resulting system is no longer possible, but we show that type-checking a sufficiently annotated program can be reduced to constraint satisfaction. We prove that DML(C) is conservative over ML, but the main technical contribution of the paper lies in our language design, including its elaboration and type-checking rules which make the approach practical. This has been demonstrated in related experiments where we obtained significant speedups in many examples by statically eliminating array bound checks. There constraints are linear equalities and inequalities over integers, solved by a variant of Fourier's method.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Constable, R. L. et al. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1986, </year> <pages> x+299 pp. </pages>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML [10], CAML [19], or Haskell [6], and those for small, pure languages such as the ones underlying Coq [2], NuPrl <ref> [1] </ref>, or PX [5]. Type checking and inference in realistic languages is theoretically decidable and practically feasible without requiring large amounts of type annotations. In order to achieve this, the type systems are relatively simple and only elementary properties of programs can be expressed and thus checked by a compiler.
Reference: [2] <author> Dowek, G., Felty, A., Herbelin, H., Huet, G., Murthy, C., Parent, C., Paulin-Mohring, C., and Werner, B. </author> <title> The Coq Proof Assistant User's Guide. Rapport Techniques, no. </title> <type> 154, </type> <institution> INRIA, Rocquencourt, France, </institution> <year> 1993. </year> <note> Version 5.8. </note>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML [10], CAML [19], or Haskell [6], and those for small, pure languages such as the ones underlying Coq <ref> [2] </ref>, NuPrl [1], or PX [5]. Type checking and inference in realistic languages is theoretically decidable and practically feasible without requiring large amounts of type annotations. <p> We plan to consider a combination of these ideas in future work. Parent [15] proposed to reverse the process of extracting programs from constructive proofs in Coq <ref> [2] </ref>, synthesizing proof skeletons from annotated programs. Such proof skeletons contain "holes" corresponding to logical propositions not unlike our constraint formulas. In order to limit the verbosity of the required annotations, she also developed heuristics to reconstruct then in some cases using higher-order unification.
Reference: [3] <author> Freeman, T. and Pfenning, F. </author> <title> Refinement types for ML. </title> <booktitle> in: Proceedings of the SIGPLAN '91 Symposium on Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <month> June. </month> <year> 1991, </year> <pages> pp. 268-277. 10 </pages>
Reference-contexts: Since it extends ML conservatively, it can be used sparingly, existing ML programs will work as before (if there is no keyword conflict). When compared to traditional type systems for programming languages, perhaps the closest related work is refinement types <ref> [3] </ref>, which also aims at expressing and checking more properties of programs that are already well-typed in ML, rather than admitting more programs as type correct, which is the goal of most other research on extending type systems. <p> On the other hand, this allows a richer source language with fewer annotations and, in practice, avoids interaction with a theorem prover. Hayashi proposed a type system ATTT [4], which allows a notion of refinement types as in the type system for ML <ref> [3] </ref>, plus intersection and union of refinement types and singleton refinement types. He demonstrated the value of singleton, union and intersection types in extracting realistic programs, which is similar to our use of corresponding logical operators on constraints. <p> The critical issues are exceptions, mutable references, and module-level constructs. Since our design explicitly separates indices from ML expressions, we expect these extensions to be mostly straightforward. Another practically important extension may be the introduction of limited forms of intersection types <ref> [3] </ref>, so that more than one dependent type can be assigned to a function without code duplication. Our primary motivation is to allow the programmer to express more program properties through types and thus catch more errors at compile time.
Reference: [4] <author> Hayashi, S. </author> <title> Singleton, union and intersection types for program extraction. </title> <booktitle> in: Proceedings of the Interna--tional Conference on Theoretical Aspects of Computer Software, Sendai, </booktitle> <address> Japan, </address> <month> September, </month> <title> edited by A. </title> <editor> R. Meyer. </editor> <year> 1991. </year>
Reference-contexts: Our aims and methods are similar, but much less general in the kind of specifications we can express. On the other hand, this allows a richer source language with fewer annotations and, in practice, avoids interaction with a theorem prover. Hayashi proposed a type system ATTT <ref> [4] </ref>, which allows a notion of refinement types as in the type system for ML [3], plus intersection and union of refinement types and singleton refinement types.
Reference: [5] <author> Hayashi, S. and Nakano, H. PX: </author> <title> A Computational Logic. </title> <publisher> The MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML [10], CAML [19], or Haskell [6], and those for small, pure languages such as the ones underlying Coq [2], NuPrl [1], or PX <ref> [5] </ref>. Type checking and inference in realistic languages is theoretically decidable and practically feasible without requiring large amounts of type annotations. In order to achieve this, the type systems are relatively simple and only elementary properties of programs can be expressed and thus checked by a compiler.
Reference: [6] <editor> Hudak, P., Peyton Jones, S. L., Wadler, P., et al. </editor> <title> A Report on the Functional Language Haskell. </title> <journal> SIGPLAN Notices, </journal> <year> 1992. </year>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML [10], CAML [19], or Haskell <ref> [6] </ref>, and those for small, pure languages such as the ones underlying Coq [2], NuPrl [1], or PX [5]. Type checking and inference in realistic languages is theoretically decidable and practically feasible without requiring large amounts of type annotations.
Reference: [7] <author> Jay, C. and Sekanina, M. </author> <title> Shape checking of array programs. no. </title> <institution> 96.09, School of Computer Sciences, University of Technology, </institution> <address> Sydney, Australia, </address> <year> 1996. </year>
Reference-contexts: This embedding translates programing language constructs into type-theoretic expressions, which is a rather involved task requiring complex reasoning about the resulting expressions. We believe that our approach could be used to check some of these properties. Jay and Sekanina <ref> [7] </ref> have introduced a technique for array bounds checking based on the notion of shape types. Shape checking is a kind of partial evaluation and has very different characteristics and source language when compared to DML (C), where C consists of linear integer equality and inequality constraints.
Reference: [8] <author> Kreitz, C. </author> <title> Formal Reasoning about Communication Systems I: Embedding ML into Type Theory. </title> <institution> Cornell University, Department of Computer Science, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: Some progress has been made towards bridging this gap, for example, by extracting CAML programs from Coq proofs, by synthesizing proofs from CAML-like programs [15], or by embedding fragments of ML into NuPrl <ref> [8] </ref>. In this paper we take a different approach, conservatively refining the type system of ML by allowing some dependencies, without destroying the desirable properties of ML such as practical and unintrusive type checking. <p> We specify and check less information about functions which avoids general theorem proving. On the other hand, we currently do not address module-level issues, although we believe that our approach should extend naturally to signatures and functors without much additional machinery. Kreitz <ref> [8] </ref> embedded a subset of the OCaml programming language into NuPrl for reasoning about programs written in this subset. The objective is to develop automated tools for the verification and optimization of group communication systems.
Reference: [9] <author> MacQueen, D. B., Plotkin, G. D., and Sethi, R. </author> <title> An Ideal Model for Recursive Polymorphic Types. </title> <journal> Information and Control, </journal> <volume> vol. 71 (1986), </volume> <pages> pp. 95-130. </pages>
Reference-contexts: Note that this is quite different from the use of dependent types to analyze modular structure (as, for example, in <ref> [9] </ref>). We now present a brief example from our implementation before going into further details. A correct implementation of a reverse function on lists should return a list of the same length as its argument. Unfortunately, this property cannot be captured by the ML's type system.
Reference: [10] <author> Milner, R., Tofte, M., and Harper, R. W. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1990, </year> <pages> xi+101 pp. </pages>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML <ref> [10] </ref>, CAML [19], or Haskell [6], and those for small, pure languages such as the ones underlying Coq [2], NuPrl [1], or PX [5]. Type checking and inference in realistic languages is theoretically decidable and practically feasible without requiring large amounts of type annotations.
Reference: [11] <author> Milner, R., Tofte, M., Harper, R. W., and MacQueen, D. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: Polymorphism, on the other hand, is largely orthogonal and therefore omitted here, although it is supported in the implementation with a value restriction in order to obtain soundness as in SML'97 <ref> [11] </ref> or CAML [19]. The syntax of ML 0 is given in Figure 2. Our own source language DML (C) will have essentially the same syntax, except that there is a richer language for types.
Reference: [12] <author> Necula, G. </author> <title> Compiling with Proofs. </title> <type> Thesis Proposal, </type> <institution> Carnegie Mellon University, Department of Computer Science, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: Our primary motivation is to allow the programmer to express more program properties through types and thus catch more errors at compile time. We are also interested in using this as a front-end for a certifying compiler <ref> [12] </ref> which propagates program properties through a compiler where they can be used for optimizations or be packaged with the binaries in the form of proof-carrying code [13]. 9 Acknowledgement We thank Peter Lee and George Necula for providing us with many interesting examples We also gratefully acknowledge our discussion with
Reference: [13] <author> Necula, G. </author> <title> Proof-Carrying Code. </title> <booktitle> in: Conference Record of 24th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Paris, France, </address> <month> January, </month> <pages> 15 - 17. </pages> <year> 1997. </year>
Reference-contexts: We are also interested in using this as a front-end for a certifying compiler [12] which propagates program properties through a compiler where they can be used for optimizations or be packaged with the binaries in the form of proof-carrying code <ref> [13] </ref>. 9 Acknowledgement We thank Peter Lee and George Necula for providing us with many interesting examples We also gratefully acknowledge our discussion with Rowan Davies.
Reference: [14] <author> Owre, S., Rajan, S., Rushby, J., Shankar, N., and Srivas, M. PVS: </author> <title> Combining Specification, Proof Checking, and Model Checking. in: Computer-Aided Verification, CAV '96, edited by R. </title> <editor> Alur and T. A. Henzinger. </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 1102, </volume> <publisher> Springer-Verlag, </publisher> <address> New Brunswick, NJ, </address> <year> 1996, </year> <pages> pp. 411-414. </pages>
Reference-contexts: The theoretical analysis of elaboration for the extended type language is therefore beyond the scope of this extended abstract. We refer the interested reader to [21]. 7 Related work Our work falls in between full program verification, either in type theory or systems such as PVS <ref> [14] </ref>, and traditional type systems for programming languages. When compared to verification, our system is less expressive but more automatic when constraint domains with practical constraint satisfaction problems are chosen.
Reference: [15] <author> Parent, C. </author> <title> Synthesizing proofs from programs in the Calculus of Inductive Constructions. in: Proceedings of Mathematics for Programs Constructions. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 947, </volume> <year> 1995. </year>
Reference-contexts: Some progress has been made towards bridging this gap, for example, by extracting CAML programs from Coq proofs, by synthesizing proofs from CAML-like programs <ref> [15] </ref>, or by embedding fragments of ML into NuPrl [8]. In this paper we take a different approach, conservatively refining the type system of ML by allowing some dependencies, without destroying the desirable properties of ML such as practical and unintrusive type checking. <p> We plan to consider a combination of these ideas in future work. Parent <ref> [15] </ref> proposed to reverse the process of extracting programs from constructive proofs in Coq [2], synthesizing proof skeletons from annotated programs. Such proof skeletons contain "holes" corresponding to logical propositions not unlike our constraint formulas.
Reference: [16] <author> Pierce, B. and Turner, D. </author> <title> Local Type Inference. </title> <booktitle> in: Proceedings of the 25th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> January 19-21. </month> <year> 1998. </year>
Reference-contexts: We feel that their design is more restrictive and seems more promising for languages based on iteration schemas rather than general recursion. Finally, recent work by Pierce and Turner <ref> [16] </ref> which includes some empirical studies, is based on a similar bi-directional strategy, although they are concerned with the interaction of polymorphism and subtyping, while we are concerned with dependent types.
Reference: [17] <author> Sannella, D. and Tarlecki, A. </author> <title> Toward Formal Development of ML Programs: Foundations and Methodology. no. </title> <institution> ECS-LFCS-89-71, Laboratory for Foundations of Computer Science, Depatment of Computer Science, University of Edinburgh, The King's Buildings, Edinburgh EH9 3JZ, </institution> <month> February </month> <year> 1989. </year>
Reference-contexts: He demonstrated the value of singleton, union and intersection types in extracting realistic programs, which is similar to our use of corresponding logical operators on constraints. However, he does not address the practical problem of type checking or partial inference. Sannella and Tarlecki proposed Extended ML <ref> [17] </ref> as a framework for the formal development of programs in a pure fragment of Standard ML. The module system of Extended ML can not only declare the type of 9 a function but also the axioms it satisfies. This leads to the need of theorem proving during type checking.
Reference: [18] <author> Sulzmann, M., Odersky, M., and Wehr, M. </author> <title> Type Inference with Constrained Types. </title> <booktitle> in: Proceedings of 4th International Workshop on Foundations of Object-Oriented Languages, </booktitle> <address> Paris. </address> <year> 1997. </year>
Reference-contexts: The use of constraints for index domains is quite different from the use of constraints to model subtyping constraints (see, for example, <ref> [18] </ref>). 8 Conclusion We have designed a practical class of refinements of ML by allowing dependencies based on constraints.
Reference: [19] <author> Weis, P. and Leroy, X. </author> <title> Le langage Caml. </title> <address> InterEditions, Paris, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Type systems for functional languages can be broadly classified into those for rich, realistic languages such as Standard ML [10], CAML <ref> [19] </ref>, or Haskell [6], and those for small, pure languages such as the ones underlying Coq [2], NuPrl [1], or PX [5]. Type checking and inference in realistic languages is theoretically decidable and practically feasible without requiring large amounts of type annotations. <p> Polymorphism, on the other hand, is largely orthogonal and therefore omitted here, although it is supported in the implementation with a value restriction in order to obtain soundness as in SML'97 [11] or CAML <ref> [19] </ref>. The syntax of ML 0 is given in Figure 2. Our own source language DML (C) will have essentially the same syntax, except that there is a richer language for types. We omit the typing rules and the call-by-value natural semantics of this language, which are standard.
Reference: [20] <author> Xi, H. and Pfenning, F. </author> <title> Array Bounds Checking through Dependent Types. </title> <month> November </month> <year> 1997. </year> <note> Available as http://www.cs.cmu.edu/~hwxi/mini_papers/bounds.ps. </note>
Reference-contexts: This is the case, for example, for integer equalities and inequalities, which our implementation solves by a variant of Fourier's method. Empirical results and further references can be found in <ref> [20] </ref>. 4 ML 0 with Dependent Types We now present ML 0 (C) with dependent types, which is an extension of ML 0 . Given a domain C of constraints, the syntax of ML 0 (C) is given as follows. <p> There, elaboration rules explicitly generate constraints, thus reduce dependent type-checking to constraint satisfaction. This kind of transformation is standard and therefore omitted here. We refer the interested reader to <ref> [20] </ref> for an example on elaboration and constraint generation. 6 Existential dependent types In practice, the constraint domain must be relatively simple to permit the implementation of an effective constraint solver. Therefore there remain many properties indices which cannot be expressed.
Reference: [21] <author> Xi, H. and Pfenning, F. </author> <title> A Schema for Adding Dependent Types to ML. </title> <month> July </month> <year> 1997. </year> <note> Available as http://www.cs.cmu.edu/~hwxi/mini_papers/full.ps. 11 </note>
Reference-contexts: The third question is the interface between dependently annotated and other parts of a program or a library. For this we use existential types, although they introduce non-trivial technical complications into the elaboration procedure. For the practical treatment of existential types, see <ref> [21] </ref>. The theoretical analysis of existential types and their properties is beyond the scope of this abstract. We have implemented our design for a fragment of ML including definitions, recursion, datatypes, pattern matching and polymorphism, and experimented with different constraint domains and applications. <p> The theoretical analysis of elaboration for the extended type language is therefore beyond the scope of this extended abstract. We refer the interested reader to <ref> [21] </ref>. 7 Related work Our work falls in between full program verification, either in type theory or systems such as PVS [14], and traditional type systems for programming languages.
References-found: 21

