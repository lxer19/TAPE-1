URL: http://ftp.cs.umn.edu/pub/Linux/sunsite/utils/file/managers/mc/devel/docs/steal.ps
Refering-URL: http://ftp.cs.umn.edu/pub/Linux/sunsite/utils/file/managers/mc/devel/docs/
Root-URL: http://www.cs.umn.edu
Email: allegra,ihnp4,decvax,utai-!utzoo!henry  
Title: How To Steal Code or Inventing The Wheel Only Once  
Author: Henry Spencer 
Note: of them bad, some of them good, most of them under-appreciated and under-used.  
Address: 25 Harbord St.  Toronto, Ont. M5S 1A1 Canada  
Affiliation: Zoology Computer Systems  University of Toronto  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Brian W. Kernighan, </author> <title> The Unix System and Software Reusability, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol SE-10, No. 5, </volume> <month> Sept. </month> <year> 1984, </year> <pages> pp. 513-8. </pages>
Reference-contexts: Introduction ``Everyone knows'' that that the UNIX/C community and its programmers are the very paragons of re-use of software. In some ways this is true. Brian Kernighan <ref> [1] </ref> and others have waxed eloquent about how outstanding UNIX is as an environment for software re-use. Pipes, the shell, and the design of programs as `filters' do much to encourage programmers to build on others' work rather than starting from scratch.
Reference: [2] <author> Geoff Collyer and Henry Spencer, </author> <title> News Need Not Be Slow, </title> <booktitle> Usenix Winter 1987 Technical Conference, </booktitle> <pages> pp. 181-190. </pages>
Reference-contexts: Major applications can be, and often are, written without a line of C. Of course, there are always people who insist on doing everything themselves, often citing `efficiency' as the compelling reason why they can't possibly build on the work of others (see <ref> [2] </ref> for some commentary on this). But surely these are the lamentable exceptions, rather than the rule? Well, in a word, no. At the level of shell programming, yes, software re-use is widespread in the UNIX/C community. <p> And unless the program is well-commented [here we pause for laughter], the next person who works on it will have to study the code at length to dispel the suspicion that there is some subtle reason for the seeming re-invention. Finally, to quote <ref> [2] </ref>, if you reinvent the square wheel, you will not benefit when somebody else rounds off the corners. In short, re-inventing the wheel ought to be a rare event, occurring only for the most compelling reasons. <p> close enough to serve, and the combined benefits of code theft and standardization outweigh the minor mismatches. g ``Calling a library function is too inefficient.'' This is mostly heard from people who have never profiled their programs and hence have no reliable information about what their code's efficiency problems are <ref> [2] </ref>. g ``I didn't know about it.'' Competent programmers know the contents of their toolboxes. g ``That whole concept is ugly, and should be redesigned.'' (Often said of getopt, since the usual UNIX single-letter-option syntax that getopt implements is widely criticized as user-hostile.) How likely is it that the rest of
Reference: [3] <author> Brian W. Kernighan and P.J. Plauger, </author> <title> Software Tools, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address> <year> 1976. </year>
Reference: [4] <author> Mike O'Dell, </author> <title> UNIX: The World View, </title> <booktitle> Usenix Winter 1987 Technical Conference, </booktitle> <pages> pp. 35-45. </pages>
Reference-contexts: Faced with a wild diversity of different operating systems, they were forced to put much more emphasis on identifying clean abstractions for system services. For example, the Software Tools version of ls runs unchanged, without conditional compilation, on dozens of different operating systems <ref> [4] </ref>. By contrast, UNIX programs that read directories invariably dealt with the raw system data structures, until Berkeley turned this cozy little world upside-down with a change to those data structures.
Reference: [5] <author> IEEE, </author> <title> IEEE Trial-Use Standard 1003.1 (April 1986): Portable Operating System for Computer Environments, </title> <publisher> IEEE and Wiley-Interscience, </publisher> <address> New York, </address> <year> 1986. </year> <month> - 7 </month> - 
Reference-contexts: However, true to the UNIX pattern, they designed a library which quietly assumed (in some of its naming conventions) that the underlying system used their structures! This particular nettle has finally been grasped firmly by the IEEE POSIX project <ref> [5] </ref>, at the cost of yet another slightly-incompatible interface. The adoption of the new directory libraries is not just a matter of convenience and portability: in general the libraries are faster than the hand-cooked code they replace.
Reference: [6] <author> Ian Darwin and Geoff Collyer, </author> <title> Can't Happen or /* NOTREACHED */ or Real Programs Dump Core, </title> <booktitle> Usenix Winter 1985 Technical Conference, </booktitle> <pages> pp. 136-151. </pages>
Reference-contexts: No major variant of UNIX has a library function for either one of the following code fragments, both omnipresent (or at least, they should be omnipresent <ref> [6] </ref>) in simple* programs that use the relevant facilities: if ((f = fopen (filename, mode)) == NULL) print error message with filename, mode, and specific reason for failure, and then exit if ((p = malloc (amount)) == NULL) print error message and exit These may sound utterly trivial, but in fact
Reference: [7] <author> Bjarne Stroustrup, </author> <title> The C++ Programming Language, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address> <year> 1986. </year>
Reference-contexts: More sophisticated libraries can also be useful, especially if the language provides better support for them than C does; C++ is an example <ref> [7] </ref>. Even in C, though, there is much room for improvement. Adding library functions does have its disadvantages. The interface to a library function is important, and getting it right is hard.
References-found: 7

