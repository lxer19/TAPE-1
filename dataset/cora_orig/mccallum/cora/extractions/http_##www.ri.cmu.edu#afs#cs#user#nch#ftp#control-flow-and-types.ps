URL: http://www.ri.cmu.edu/afs/cs/user/nch/ftp/control-flow-and-types.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/nch/ftp/
Root-URL: 
Title: Control-Flow Analysis and Type Systems  
Author: Nevin Heintze 
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: We establish a series of equivalences between type systems and control-flow analyses. Specifically, we take four type systems from the literature (involving simple types, subtypes and recursion) and conservatively extend them to reason about control-flow information. Similarly, we take four standard control-flow systems and conservatively extend them to reason about type consistency. Our main result is that we can match up the resulting type and control-flow systems such that we obtain pairs of equivalent systems, where the equivalence is with respect to both type and control-flow information. In essence, type systems and control-flow analysis can be viewed as complementary approaches for addressing questions of type consistency and control-flow. Recent and independent work by Palsberg and O'Keefe has addressed the same general question. Our work differs from theirs in two respects. First, they only consider what happens when control-flow systems are used to reason about types. In contrast, we also consider the dual question: what happens when type systems are used to reason about control-flow. Hence our results establish a much closer and more symmetric notion of equivalence: Palsberg and O'Keefe's equivalence refers only to typability properties, whereas our equivalences refer to both typability and control-flow. Second, Palsberg and O'Keefe establish only one pair of equivalent systems, whereas we establish four pairs of (stronger) equivalences. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> R. Amadio and L. Cardelli, </author> <title> "Subtyping Recursive types", </title> <journal> ACM-TOPLAS, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> (Also in POPL-91, pp. 104-118). </note>
Reference-contexts: The starting point of this development is essentially Amadio and Cardelli's recursive subtype system <ref> [1] </ref> (with extensions for 0 and Succ). For definitional convenience, we shall use a formulation of recursive subtypes that differs slightly from those used previously in the literature [1, 6, 10]. We therefore begin by presenting this system without the control-flow information component. <p> The starting point of this development is essentially Amadio and Cardelli's recursive subtype system [1] (with extensions for 0 and Succ). For definitional convenience, we shall use a formulation of recursive subtypes that differs slightly from those used previously in the literature <ref> [1, 6, 10] </ref>. We therefore begin by presenting this system without the control-flow information component. Define open types as follows: ::= ff j Int j j 1 ! 2 j ff: where ff ranges over type variables. <p> Equation 1 (except if indicated otherwise). Types t are defined to be those expressions that do not contain free type variables. Next, we define an ordering between congruence classes of types. This ordering is defined by successive approximation (see <ref> [1, 6] </ref> for related constructions). Specifically, define an ordering k , k 0, as follows: 1. t 0 t 0 3. ff:ff k t 5. t 1 !t 2 k t 0 2 if t 0 2 where t and t 0 are arbitrary types.
Reference: 2. <author> A. Bondorf and J. Jorgensen, </author> <title> "Efficient Analysis for Realistic Off-Line Partial Evaluation", </title> <journal> Journal of Function Programming, </journal> <volume> 3(3), </volume> <pages> pp. 315-346, </pages> <year> 1993. </year>
Reference-contexts: F19628-91-C-0168. ?? 5000 Forbes Ave., Pittsburgh, PA 15213, USA. Email: nch@cs.cmu.edu. called from anywhere in the program. If this happens sufficiently often, then the lack of control-flow information can significantly limit compiler performance. To addresses this issue, systems for control-flow analysis <ref> [4, 5, 11, 2, 9] </ref> have been developed. The purpose of control-flow analysis is to compute an approximation of the possible functions that can be called from each program point. <p> Let control-flow (cfa ;:Y ) denote the partial mapping that maps a program e 0 into cf (cfa ;:Y ). 4.3 CFA via Equality The next system we consider essentially corresponds to the analysis considered by Bondorf and Jorgensen <ref> [2] </ref>. The only differences are that we do not consider arbitrary data-constructors, and we include Int to reason about type consistency. The definition of well-annotated programs for this system is a modification of the definition in Subsection 4.1 in which subset is replaced by equality.
Reference: 3. <author> N. Heintze, </author> <title> "Control-Flow Analysis and Type Systems", </title> <institution> Carnegie Mellon University technical report CMU-CS-94-227, 16pp, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: Can type systems be extended to compute control-flow information, and if so, does the control-flow information obtained correspond to any known control-flow system? Recent work by Palsberg and O'Keefe [10] 3 addresses the first of these ques 3 The result presented there was also independently obtained in <ref> [3] </ref>. tions. Specifically, they consider Amadio/Cardelli's type system with subtyping and recursive types, and Palsberg and Schwartzbach's safety analysis (which is essentially a control-flow analysis that has been modified to perform type checking).
Reference: 4. <author> N. Jones, </author> <title> "Flow Analysis of Lambda Expressions", </title> <booktitle> Symp. on Functional Languages and Computer Architecture, </booktitle> <pages> pp. 66-74, </pages> <year> 1981. </year>
Reference-contexts: F19628-91-C-0168. ?? 5000 Forbes Ave., Pittsburgh, PA 15213, USA. Email: nch@cs.cmu.edu. called from anywhere in the program. If this happens sufficiently often, then the lack of control-flow information can significantly limit compiler performance. To addresses this issue, systems for control-flow analysis <ref> [4, 5, 11, 2, 9] </ref> have been developed. The purpose of control-flow analysis is to compute an approximation of the possible functions that can be called from each program point. <p> Hence, we shall use annotations fl that are finite subsets of labels [fInt g. Our presentations of control-flow systems is closely related to those by Palsberg and Schwartzbach [8, 9]. 4.1 Standard CFA We begin a system that corresponds to a widely studied notion of control-flow analysis <ref> [4, 5, 11, 8, 9] </ref>, often called control-flow-0. The system we give is equivalent to the system described by Palsberg and Schwartzbach in [8, 9]. The only difference is in presentation: we directly use annotated terms instead of set variables and constraints.
Reference: 5. <author> N. Jones, </author> <title> "Flow Analysis of Lazy Higher-Order Functional Programs", in Abstract Interpretation of Declarative Languages, </title> <editor> S. Abramsky and C. Hankin (Eds.), </editor> <publisher> Ellis Horwood, </publisher> <year> 1987. </year>
Reference-contexts: F19628-91-C-0168. ?? 5000 Forbes Ave., Pittsburgh, PA 15213, USA. Email: nch@cs.cmu.edu. called from anywhere in the program. If this happens sufficiently often, then the lack of control-flow information can significantly limit compiler performance. To addresses this issue, systems for control-flow analysis <ref> [4, 5, 11, 2, 9] </ref> have been developed. The purpose of control-flow analysis is to compute an approximation of the possible functions that can be called from each program point. <p> Hence, we shall use annotations fl that are finite subsets of labels [fInt g. Our presentations of control-flow systems is closely related to those by Palsberg and Schwartzbach [8, 9]. 4.1 Standard CFA We begin a system that corresponds to a widely studied notion of control-flow analysis <ref> [4, 5, 11, 8, 9] </ref>, often called control-flow-0. The system we give is equivalent to the system described by Palsberg and Schwartzbach in [8, 9]. The only difference is in presentation: we directly use annotated terms instead of set variables and constraints.
Reference: 6. <author> D. Kozen, J. Palsberg, M. Schwartzbach, </author> <title> "Efficient Recursive Subtyping" POPL-93, </title> <journal> pp. </journal> <pages> 419-428, </pages> <year> 1993. </year>
Reference-contexts: The starting point of this development is essentially Amadio and Cardelli's recursive subtype system [1] (with extensions for 0 and Succ). For definitional convenience, we shall use a formulation of recursive subtypes that differs slightly from those used previously in the literature <ref> [1, 6, 10] </ref>. We therefore begin by presenting this system without the control-flow information component. Define open types as follows: ::= ff j Int j j 1 ! 2 j ff: where ff ranges over type variables. <p> Equation 1 (except if indicated otherwise). Types t are defined to be those expressions that do not contain free type variables. Next, we define an ordering between congruence classes of types. This ordering is defined by successive approximation (see <ref> [1, 6] </ref> for related constructions). Specifically, define an ordering k , k 0, as follows: 1. t 0 t 0 3. ff:ff k t 5. t 1 !t 2 k t 0 2 if t 0 2 where t and t 0 are arbitrary types.
Reference: 7. <author> R. Milner, </author> <title> "A Theory of Type Polymorphism in Programming", </title> <journal> Journal of Computer System Science, </journal> <volume> 17, </volume> <pages> pp. 348-375. </pages>
Reference-contexts: types, then an annotated term is essentially an explicitly typed term; such a term carries with it much of the structure of a typing derivation for jzj. 3 Type Systems for Control-Flow Analysis 3.1 Simple Types We begin by describing a type system for control-flow analysis based on simple types <ref> [7] </ref>. Consider a system of simple types where types t are constructed from the single base type Int and ! as follows: t ::= Int j t 1 ! t 2 The usual formulation of simple types uses a deductive system involving judgements of the form ` e: t .
Reference: 8. <author> J. Palsberg and M. Schwartzbach, </author> <title> "Safety Analysis versus Type Inference for Partial Types" Information Processing Letters, </title> <booktitle> Vol 43, </booktitle> <pages> pp. 175-180, </pages> <publisher> North-Holland, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: In fact it is possible to extend type systems to perform control-flow analysis [12, 13], and conversely, extend control-flow systems to perform type analysis <ref> [8, 9] </ref>. There are also informal connections between the kinds of reasoning done by type and control-flow systems. <p> Hence, we shall use annotations fl that are finite subsets of labels [fInt g. Our presentations of control-flow systems is closely related to those by Palsberg and Schwartzbach <ref> [8, 9] </ref>. 4.1 Standard CFA We begin a system that corresponds to a widely studied notion of control-flow analysis [4, 5, 11, 8, 9], often called control-flow-0. The system we give is equivalent to the system described by Palsberg and Schwartzbach in [8, 9]. <p> Hence, we shall use annotations fl that are finite subsets of labels [fInt g. Our presentations of control-flow systems is closely related to those by Palsberg and Schwartzbach [8, 9]. 4.1 Standard CFA We begin a system that corresponds to a widely studied notion of control-flow analysis <ref> [4, 5, 11, 8, 9] </ref>, often called control-flow-0. The system we give is equivalent to the system described by Palsberg and Schwartzbach in [8, 9]. The only difference is in presentation: we directly use annotated terms instead of set variables and constraints. <p> closely related to those by Palsberg and Schwartzbach <ref> [8, 9] </ref>. 4.1 Standard CFA We begin a system that corresponds to a widely studied notion of control-flow analysis [4, 5, 11, 8, 9], often called control-flow-0. The system we give is equivalent to the system described by Palsberg and Schwartzbach in [8, 9]. The only difference is in presentation: we directly use annotated terms instead of set variables and constraints.
Reference: 9. <author> J. Palsberg and M. Schwartzbach, </author> <title> "Safety Analysis versus Type Inference" Information and Computation, </title> <note> to appear. </note>
Reference-contexts: F19628-91-C-0168. ?? 5000 Forbes Ave., Pittsburgh, PA 15213, USA. Email: nch@cs.cmu.edu. called from anywhere in the program. If this happens sufficiently often, then the lack of control-flow information can significantly limit compiler performance. To addresses this issue, systems for control-flow analysis <ref> [4, 5, 11, 2, 9] </ref> have been developed. The purpose of control-flow analysis is to compute an approximation of the possible functions that can be called from each program point. <p> In fact it is possible to extend type systems to perform control-flow analysis [12, 13], and conversely, extend control-flow systems to perform type analysis <ref> [8, 9] </ref>. There are also informal connections between the kinds of reasoning done by type and control-flow systems. <p> Hence, we shall use annotations fl that are finite subsets of labels [fInt g. Our presentations of control-flow systems is closely related to those by Palsberg and Schwartzbach <ref> [8, 9] </ref>. 4.1 Standard CFA We begin a system that corresponds to a widely studied notion of control-flow analysis [4, 5, 11, 8, 9], often called control-flow-0. The system we give is equivalent to the system described by Palsberg and Schwartzbach in [8, 9]. <p> Hence, we shall use annotations fl that are finite subsets of labels [fInt g. Our presentations of control-flow systems is closely related to those by Palsberg and Schwartzbach [8, 9]. 4.1 Standard CFA We begin a system that corresponds to a widely studied notion of control-flow analysis <ref> [4, 5, 11, 8, 9] </ref>, often called control-flow-0. The system we give is equivalent to the system described by Palsberg and Schwartzbach in [8, 9]. The only difference is in presentation: we directly use annotated terms instead of set variables and constraints. <p> closely related to those by Palsberg and Schwartzbach <ref> [8, 9] </ref>. 4.1 Standard CFA We begin a system that corresponds to a widely studied notion of control-flow analysis [4, 5, 11, 8, 9], often called control-flow-0. The system we give is equivalent to the system described by Palsberg and Schwartzbach in [8, 9]. The only difference is in presentation: we directly use annotated terms instead of set variables and constraints.
Reference: 10. <author> J. Palsberg and P. O'Keefe, </author> <title> "A Type System Equivalent to Flow Analysis", </title> <booktitle> POPL-95, </booktitle> <pages> pp. 367-378, </pages> <year> 1995. </year>
Reference-contexts: Can type systems be extended to compute control-flow information, and if so, does the control-flow information obtained correspond to any known control-flow system? Recent work by Palsberg and O'Keefe <ref> [10] </ref> 3 addresses the first of these ques 3 The result presented there was also independently obtained in [3]. tions. <p> The starting point of this development is essentially Amadio and Cardelli's recursive subtype system [1] (with extensions for 0 and Succ). For definitional convenience, we shall use a formulation of recursive subtypes that differs slightly from those used previously in the literature <ref> [1, 6, 10] </ref>. We therefore begin by presenting this system without the control-flow information component. Define open types as follows: ::= ff j Int j j 1 ! 2 j ff: where ff ranges over type variables.
Reference: 11. <author> O. Shivers, </author> <title> "Control Flow Analysis in Scheme", </title> <booktitle> Proc. 1988 ACM Conf. on Programming Language Design and Implementation, Atlanta, </booktitle> <pages> pp. 164-174, </pages> <year> 1988. </year>
Reference-contexts: F19628-91-C-0168. ?? 5000 Forbes Ave., Pittsburgh, PA 15213, USA. Email: nch@cs.cmu.edu. called from anywhere in the program. If this happens sufficiently often, then the lack of control-flow information can significantly limit compiler performance. To addresses this issue, systems for control-flow analysis <ref> [4, 5, 11, 2, 9] </ref> have been developed. The purpose of control-flow analysis is to compute an approximation of the possible functions that can be called from each program point. <p> Hence, we shall use annotations fl that are finite subsets of labels [fInt g. Our presentations of control-flow systems is closely related to those by Palsberg and Schwartzbach [8, 9]. 4.1 Standard CFA We begin a system that corresponds to a widely studied notion of control-flow analysis <ref> [4, 5, 11, 8, 9] </ref>, often called control-flow-0. The system we give is equivalent to the system described by Palsberg and Schwartzbach in [8, 9]. The only difference is in presentation: we directly use annotated terms instead of set variables and constraints.
Reference: 12. <author> Y. Tang and P. Jouvelot, </author> <title> "Control-Flow Effects for Escape Analysis", </title> <address> WSA'92, Bordeaux, France, </address> <year> 1992. </year>
Reference-contexts: Hence, there is an intuitive connection between reasoning about functions (in control-flow analysis) and reasoning about the data values to which variables may be bound (in type inference). In fact it is possible to extend type systems to perform control-flow analysis <ref> [12, 13] </ref>, and conversely, extend control-flow systems to perform type analysis [8, 9]. There are also informal connections between the kinds of reasoning done by type and control-flow systems.
Reference: 13. <author> Y. Tang and P. Jouvelot, </author> <title> "Separate Abstract Interpretation for Control-Flow Analysis", </title> <publisher> TACS-94, LNCS 789, </publisher> <address> pp.224-243, </address> <year> 1994. </year>
Reference-contexts: Hence, there is an intuitive connection between reasoning about functions (in control-flow analysis) and reasoning about the data values to which variables may be bound (in type inference). In fact it is possible to extend type systems to perform control-flow analysis <ref> [12, 13] </ref>, and conversely, extend control-flow systems to perform type analysis [8, 9]. There are also informal connections between the kinds of reasoning done by type and control-flow systems.
Reference: 14. <author> S. Thatte, </author> <title> "Type Inference with Partial Types", </title> <journal> ICALP-88, </journal> <volume> LNCS 317, </volume> <pages> pp. 615-629, </pages> <year> 1988. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Let control-flow ( ` ) denote the partial mapping that maps a program e 0 into cf ( ` )(e 0 ). 3.2 Partial Types The second control-flow type system we describe is based on partial types <ref> [14] </ref> (with constants 0 : Int and Succ : Int ! Int). Partial types extend simple types with a new type that is a supertype of all other types (some papers use &gt; instead of ).
References-found: 14

