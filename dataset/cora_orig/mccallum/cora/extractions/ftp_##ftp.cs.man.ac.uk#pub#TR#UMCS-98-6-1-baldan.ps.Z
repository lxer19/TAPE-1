URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-baldan.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Email: fdba,ble,clc,ipog@info.fundp.ac.be  
Title: A Step Towards a Methodology for Mercury Program Construction: A Declarative Semantics for Mercury  
Author: Dante Baldan Baudouin Le Charlier Christophe Leclere Isabelle Pollet 
Address: Rue Grandgagnage 21 B-5000 Namur (Belgium)  
Affiliation: Institut d'Informatique Facultes Universitaires Notre-Dame de la Paix  
Abstract: Declarative methodologies for logic program construction have been proposed for Prolog. They roughly consist of 1) building a purely logical version of the program based on a clear declarative semantics and 2) performing a number of checks about modes, types and multiplicity. We plan to define a similar methodology for Mercury. This choice is motivated by the fact that type, mode, and multiplicity must be explicitly specified in Mercury, allowing the compiler to perform the second step above. In order to propose a methodology to perform the first step, we need a declarative semantics for Mercury, which has not yet been explicitly defined. The goal of the paper is to propose such a semantics pursuing simplicity and naturalness. We chose to define the semantics with respect to a unique interpretation domain, called the "universe", which is a kind of higher-order version of the Herbrand universe. Based on this simple domain, the denotation of terms and goals is naturally defined as well as the models of programs. Although the declarative semantics is primarily introduced to improve "manual" program construction by programmers, it could be used in a synthesis context. 
Abstract-found: 1
Intro-found: 1
Reference: [Apt97] <author> K. R. Apt. </author> <title> From Logic Programming to Prolog. </title> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: Declarative methodologies for logic program construction have been proposed for Prolog (see e.g., <ref> [Apt97, Dev90, HL92, Nai87] </ref>).
Reference: [Dev90] <author> Y. Deville. </author> <title> Logic Programming: Systematic Program Development. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Declarative methodologies for logic program construction have been proposed for Prolog (see e.g., <ref> [Apt97, Dev90, HL92, Nai87] </ref>). <p> As a consequence, we chose to define the semantics with respect to a unique interpretation domain, called the "universe", which is a kind of higher-order version of the Herbrand universe used in e.g., <ref> [Dev90] </ref> 1 . Based on this simple domain, the denotation of terms and goals (formulas) is naturally defined as well as the models of programs. <p> 8d 2 D : G [[g]]ffi [v=d; v=f d] = TRUE where D = T [[[[v]]]]ffi and D = T [[[[v]]]]ffi. 3 If d 62 dom (p) then pd = error . 7 6 Discussion The declarative semantics, which has just been defined, can be used to build logic descriptions <ref> [Dev90] </ref> in Deville's style, which is mainly based on structural induction and ensures |roughly speaking| that the user's intended model is the unique model of the program; the novelty is that logical descriptions can now be higher-order.
Reference: [FLO97a] <author> P. Flener, K.-K. Lau, and M. Ornaghi. </author> <title> Correct-Schema-Guided Synthesis of Steadfast Programs. </title> <editor> In M. Lowry and Y. Ledru, editors, </editor> <booktitle> Proceedings of ASE'97, </booktitle> <publisher> Computer Society Press. IEEE, </publisher> <year> 1997. </year>
Reference-contexts: Based on this simple domain, the denotation of terms and goals (formulas) is naturally defined as well as the models of programs. Notice that, although the declarative semantics is primarily introduced to improve "manual" program construction by programmers, it could also be used in a synthesis context <ref> [FLO97a, FLO97b] </ref> to automatically translate synthesized programs into equivalent Mercury programs (see Section 6). The rest of this paper is organized as follows. Section 2 introduces the notation used in the paper. Section 3 describes a simplified abstract syntax of Mercury, on which the semantics is based. <p> Further works will adapt SLDNF-resolution [Llo87] to the context of Mercury to make it possible to prove that well typed and moded Mercury programs actually compute a set of answers covering the declarative semantics. In the context of schema guided synthesis of logic programs <ref> [FLO97a, FLO97b] </ref>, we guess that it is natural to see the isoinitial models of open programs as denotations of polymorphic functions and procedures in Mercury. This would ensure that well-moded Mercury translations of correct open programs [FLO97a, FLO97b] are operationally correct. <p> In the context of schema guided synthesis of logic programs <ref> [FLO97a, FLO97b] </ref>, we guess that it is natural to see the isoinitial models of open programs as denotations of polymorphic functions and procedures in Mercury. This would ensure that well-moded Mercury translations of correct open programs [FLO97a, FLO97b] are operationally correct.
Reference: [FLO97b] <author> P. Flener, K.-K. Lau, and M. Ornaghi. </author> <title> On Correct Program Schemas. </title> <editor> In N. E. Fuchs, editor, </editor> <booktitle> Proceedings of LOPSTR'97, </booktitle> <publisher> LNCS. Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Based on this simple domain, the denotation of terms and goals (formulas) is naturally defined as well as the models of programs. Notice that, although the declarative semantics is primarily introduced to improve "manual" program construction by programmers, it could also be used in a synthesis context <ref> [FLO97a, FLO97b] </ref> to automatically translate synthesized programs into equivalent Mercury programs (see Section 6). The rest of this paper is organized as follows. Section 2 introduces the notation used in the paper. Section 3 describes a simplified abstract syntax of Mercury, on which the semantics is based. <p> Further works will adapt SLDNF-resolution [Llo87] to the context of Mercury to make it possible to prove that well typed and moded Mercury programs actually compute a set of answers covering the declarative semantics. In the context of schema guided synthesis of logic programs <ref> [FLO97a, FLO97b] </ref>, we guess that it is natural to see the isoinitial models of open programs as denotations of polymorphic functions and procedures in Mercury. This would ensure that well-moded Mercury translations of correct open programs [FLO97a, FLO97b] are operationally correct. <p> In the context of schema guided synthesis of logic programs <ref> [FLO97a, FLO97b] </ref>, we guess that it is natural to see the isoinitial models of open programs as denotations of polymorphic functions and procedures in Mercury. This would ensure that well-moded Mercury translations of correct open programs [FLO97a, FLO97b] are operationally correct.
Reference: [HL92] <author> J. Henrard and B. Le Charlier. Folon: </author> <title> An Environment for Declarative Construction of Logic Programs (Extended Abstract). </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Proc. of PLILP'92, volume 631 of LNCS, </booktitle> <address> Leuven, Belgium, </address> <month> August </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference-contexts: Declarative methodologies for logic program construction have been proposed for Prolog (see e.g., <ref> [Apt97, Dev90, HL92, Nai87] </ref>).
Reference: [LLP98] <author> B. Le Charlier, C. Leclere, and I.Pollet. </author> <title> A Declarative Semantics for Mercury (in French). </title> <type> Technical report, </type> <institution> Institute d'Informatique, FUNDP, Namur, Belgique, </institution> <year> 1998. </year>
Reference-contexts: In this paper we assume that the program is well-typed, i.e., that there exists a most general type assignment for program variables and identifiers. For space constraints, we cannot give the rules characterizing well-typed programs (such rules are given in <ref> [LLP98] </ref>). In the following, the most general type assignment for a program will be referred to as the typing (of the program).
Reference: [Llo87] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. Springer Series: </title> <journal> Symbolic Computation-Artificial Intelligence. </journal> <note> Springer-Verlag, second, extended edition edition, </note> <year> 1987. </year>
Reference-contexts: Further works will adapt SLDNF-resolution <ref> [Llo87] </ref> to the context of Mercury to make it possible to prove that well typed and moded Mercury programs actually compute a set of answers covering the declarative semantics.
Reference: [Nai87] <author> L. Naish. </author> <title> Specification = Program + Types. </title> <editor> In Kesav V. Nori, editor, </editor> <booktitle> Proceedings of the 7th Conference on Foundations of Software Technology and Theoretical Computer Science, volume 287 of LNCS, </booktitle> <pages> pages 326-339, </pages> <address> Pune, India, </address> <month> December </month> <year> 1987. </year> <pages> Springer. </pages>
Reference-contexts: Declarative methodologies for logic program construction have been proposed for Prolog (see e.g., <ref> [Apt97, Dev90, HL92, Nai87] </ref>).
Reference: [SHC96] <author> Z. Somogyi, F. Henderson, and T. Conway. </author> <title> The Execution Algorithm of Mercury, an Efficient Purely Declarative Logic Programming Language. </title> <journal> Journal of Logic Programming, 29(1-3):17-64, October-November 1996. </journal> <volume> 8 </volume>
Reference-contexts: We plan to define a similar methodology for Mercury <ref> [SHC96] </ref>. This choice is motivated by the fact that type, mode, and multiplicity information can (and must) be explicitly specified in Mercury, allowing the fl Extended Abstracts of LOPSTR'98, Eighth International Workshop on Logic-based Program Synthesis and Transformation, 15-19 June 1998, Manchester, UK.
References-found: 9

