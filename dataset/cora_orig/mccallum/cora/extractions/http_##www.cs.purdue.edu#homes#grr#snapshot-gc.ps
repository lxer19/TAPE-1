URL: http://www.cs.purdue.edu/homes/grr/snapshot-gc.ps
Refering-URL: http://www.cs.purdue.edu/people/grr/
Root-URL: http://www.cs.purdue.edu
Email: russog@cs.purdue.edu  
Title: Nonintrusive Cloning Garbage Collection with Stock Operating System Support  
Author: Gustavo Rodriguez-Rivera Vincent Russo 
Address: fgrr,  
Affiliation: Purdue University  
Abstract: It is well accepted that Garbage Collection simplifies programming, promotes modularity, and reduces development effort. However it is commonly believed that these advantages do not counteract the price that has to be paid: excesive overheads, possible long pause times, and the need of modifying existing code. Even though there exist publically available garbage collectors that can be used in existing programs, they do not guarantee short pauses, and some modification of the application using them is still required. In this paper we describe a snapshot-at-beginning concurrent garbage collector algorithm and its implementation. This algorithm is less intrusive than other garbage collecting algorithms, guarantees short pauses, and can be easily implemented in stock unix like operating systems. Our results show that our collector is faster than other implementations that use user-level dirty bits, and is very competitive with explicit deallocation. These advantages are especially true on multiprocessor machines where collector and mutator can run on different processors. Our collector has the added advantage of being nonitrusive. Using a dynamic linking technique, we have been able to run our garbage collector with success even in commercial programs where source code is not available. In this paper we describe the algorithm, the implementation, and provide a comparison with other incremental garbage collectors. 1 
Abstract-found: 1
Intro-found: 1
Reference: [AEL88] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time concurrent garbage collection on stock multiprocessors. </title> <booktitle> In Proceedings of the 1988 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 11-20, </pages> <address> Atlanta, Georgia, June 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: These techniques use read/write-barriers to keep track of pointer reads/writes and make sure that the mutator does not cause the collector to erroneously garbage collect accessible memory. Read/Write-barriers are implemented in two basic ways: compiler generated [Bro84], and virtual memory supported <ref> [AEL88, AL91] </ref>. Compiler generated read/write-barriers insert extra code at every pointer read/write operation in the program. <p> Many systems allow read/write-barriers to be implemented directly by programs using virtual memory page protection mechanisms. In such implementations, pages are read-protected (or write-protected), and an application provided handler executes special code when the program tries to read (or write) any of the protected pages <ref> [AEL88, BDS91, AL91] </ref>. Virtual memory read/write-barriers implemented in user space tend to be inefficient and intrusive. The cost of a page trap, crossing the kernel-user boundary, and calling a signal handler for every page is expensive [HMS92].
Reference: [AL91] <author> Andrew W. Appel and Kai Li. </author> <title> Virtual memory primitives for user programs. </title> <booktitle> In Fourth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS IV), </booktitle> <pages> pages 96-107, </pages> <address> Santa Clara, California, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: These techniques use read/write-barriers to keep track of pointer reads/writes and make sure that the mutator does not cause the collector to erroneously garbage collect accessible memory. Read/Write-barriers are implemented in two basic ways: compiler generated [Bro84], and virtual memory supported <ref> [AEL88, AL91] </ref>. Compiler generated read/write-barriers insert extra code at every pointer read/write operation in the program. <p> Many systems allow read/write-barriers to be implemented directly by programs using virtual memory page protection mechanisms. In such implementations, pages are read-protected (or write-protected), and an application provided handler executes special code when the program tries to read (or write) any of the protected pages <ref> [AEL88, BDS91, AL91] </ref>. Virtual memory read/write-barriers implemented in user space tend to be inefficient and intrusive. The cost of a page trap, crossing the kernel-user boundary, and calling a signal handler for every page is expensive [HMS92].
Reference: [AP87] <author> S. Abraham and J. Patel. </author> <title> Parallel garbage collection on a virtual memory system. </title> <editor> In E. Chiricozzi and A. D'Amato, editors, </editor> <booktitle> International Conference on Parallel Processing and Applications, </booktitle> <pages> pages 243-246, </pages> <address> L'Aquila, Italy, September 1987. </address> <publisher> Elsevier North-Holland. </publisher>
Reference-contexts: The snapshot can also be obtained by pushing old pointer values to a mark stack every time they are overwritten by the mutator [Yua90], by using special memory processors to create a copy-on-write of the mutator's memory <ref> [AP87] </ref>, or by building a snapshot in user space by protecting the memory and catching page faults with a special signal handler. In the latter case the handler takes a snapshot of the page, unprotects the page, and then the collector uses the snapshot page for tracing [DWH + 90].
Reference: [Bac86] <author> Maurice J. Bach. </author> <title> The Design of the Unix Operating System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1986. </year>
Reference-contexts: An added advantage for having two calls instead of one is that the child process can setup input, output, and some other process context before calling exec () in a more elegant way <ref> [Bac86] </ref>. 3 One way to prevent the first condition from happening is by using a read-barrier to make sure the mutator always sees only black or grey objects so no pointers to white objects will ever be written to black objects.
Reference: [Bak78] <author> Henry G. Baker, Jr. </author> <title> List processing in real time on a serial computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <month> April </month> <year> 1978. </year>
Reference-contexts: When the mutator tries to load a pointer to a white object, the read-barrier turns the white object either to grey by pushing it to the mark stack, or to black by immediately scanning the block for pointers. An example of such a collector is given in <ref> [Bak78] </ref>. Incremental update garbage collection algorithms prevent the first condition from happening by using a write-barrier to detect when a pointer to a white object is being written into a black object.
Reference: [Bak91] <author> Henry G. Baker, Jr. </author> <title> The Treadmill: Real-time garbage collection without motion sickness. </title> <booktitle> In OOPSLA '91 Workshop on Garbage Collection in Object-Oriented Systems, </booktitle> <month> October </month> <year> 1991. </year> <note> Position paper. Also appears as SIGPLAN Notices 27(3) 66-70, </note> <month> March </month> <year> 1992. </year>
Reference-contexts: This agreement adds extra dependencies between the modules. Garbage collection solves this problem by deallocating the object automatically when no module needs it. There are several algorithms for automatic garbage collection: mark and sweep collection [McC60], mark-compact collection [CN83], copying garbage collection [FY69, Che70], and non-copying implicit collection <ref> [Wan89, Bak91] </ref>. We choose to use mark and sweep garbage collection in our implementation since it can be implemented conservatively. Mark and sweep collection [McC60] consists of two phases: the mark phase and a sweep phase.
Reference: [BDS91] <author> Hans-J. Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In Proceedings of the 1991 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 157-164, </pages> <address> Toronto, Ontario, June 1991. </address> <publisher> ACM Press. </publisher>
Reference-contexts: These "stop-the-world" collectors are impractical in time critical and interactive applications where the implied pauses in execution are unacceptable. There is a class of garbage collection algorithms called incremental collectors that reduce or eliminate pause time by marking live memory concurrently with the mutator's execution <ref> [DLM + 78, Ste75, BDS91] </ref>. These techniques use read/write-barriers to keep track of pointer reads/writes and make sure that the mutator does not cause the collector to erroneously garbage collect accessible memory. Read/Write-barriers are implemented in two basic ways: compiler generated [Bro84], and virtual memory supported [AEL88, AL91]. <p> Besides the overhead implied by the execution of the extra code (proportional to the number of pointer reads/writes), compiler generated read/write-barriers are not possible in language implementations where no cooperation exists, e.g., standard C and C++ compilers <ref> [BW88, BDS91] </ref> 2 On the other hand, read/write-barriers that use virtual memory support can be used more widely (as long as the OS provides the necessary support). Many systems allow read/write-barriers to be implemented directly by programs using virtual memory page protection mechanisms. <p> Many systems allow read/write-barriers to be implemented directly by programs using virtual memory page protection mechanisms. In such implementations, pages are read-protected (or write-protected), and an application provided handler executes special code when the program tries to read (or write) any of the protected pages <ref> [AEL88, BDS91, AL91] </ref>. Virtual memory read/write-barriers implemented in user space tend to be inefficient and intrusive. The cost of a page trap, crossing the kernel-user boundary, and calling a signal handler for every page is expensive [HMS92]. <p> Optionally the white object could be turned to black by scanning it for pointers. Examples of garbage collectors that use incremental update are [DLM + 78], [Ste75], and <ref> [BDS91] </ref>. Instead of preventing the first condition, snapshot-at-beginning garbage collection algorithms prevent the second condition from happening by making sure that there always remains a path from the root set to the objects that were reachable when the collection started. <p> Incremental collectors that prevent the first condition for happening are different in their real-time response than those that prevent the second condition. Collectors that prevent the first condition may have to iterate one or more times the mark phase until no grey objects exist <ref> [BDS91] </ref>. Also the collector may need to pause continuously for every read/write operation, or completely at the end of the mark phase to catch up with the mutator. <p> This means that when the mutator runs out of blocks in some free list, it will get unmarked blocks from the next unsweeped page for this size. In this way, pages are swept on demand during allocation. This lazy sweep is similar to the one used in <ref> [BDS91] </ref>. 4 Implementation 4.1 The Allocator The memory allocator uses simple segregated free lists [Com64, WJNB95]. There are multiple free lists where each list contains blocks of a particular size. Each heap page contains objects of the same size and there is no splitting or coalescing of blocks. <p> This step is also done efficiently using bitwise word operations. This form of lazy sweep is more less similar to the one used by <ref> [BDS91] </ref>. However the difference is that since they do not have allocation-bits, mark and sweep phases can not go in parallel. <p> We expect that this could reduce to almost none the problem of false pointers. A similar approach is used by [BW88]. 5 Performance Comparison In this section we compare our implementation of cloning garbage collector with the publically available Boehm-Demers-Weiser conservative garbage collector (BDWGC ) <ref> [BDS91] </ref> 5 . This garbage collector has been ported to a broad number of operating systems and architectures and currently is used by several language implementations and applications. We use as a benchmark the ghostscript program. Ghostcript is a publically available version of a postscript previewer.
Reference: [Bro84] <author> Rodney A. Brooks. </author> <title> Trading data space for reduced time and code space in real-time collection on stock hardware. </title> <booktitle> In Conference Record of the 1984 ACM Symposium on LISP and Functional Programming, </booktitle> <pages> pages 108-113, </pages> <address> Austin, Texas, </address> <month> August </month> <year> 1984. </year> <note> ACM Press. </note>
Reference-contexts: These techniques use read/write-barriers to keep track of pointer reads/writes and make sure that the mutator does not cause the collector to erroneously garbage collect accessible memory. Read/Write-barriers are implemented in two basic ways: compiler generated <ref> [Bro84] </ref>, and virtual memory supported [AEL88, AL91]. Compiler generated read/write-barriers insert extra code at every pointer read/write operation in the program.
Reference: [BW88] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Besides the overhead implied by the execution of the extra code (proportional to the number of pointer reads/writes), compiler generated read/write-barriers are not possible in language implementations where no cooperation exists, e.g., standard C and C++ compilers <ref> [BW88, BDS91] </ref> 2 On the other hand, read/write-barriers that use virtual memory support can be used more widely (as long as the OS provides the necessary support). Many systems allow read/write-barriers to be implemented directly by programs using virtual memory page protection mechanisms. <p> Also a side effect of having a memory mapped heap is that the heap is allocated high in memory. This reduces the probability of false pointers (sequences of bits that look like pointers) since most of the false pointers are caused by low integer values <ref> [BW88] </ref>. Large blocks (blocks larger than a page) are also memory mapped. This allows the allocator to shrink the heap by unmapping large blocks that are not being used by the program. In this way no memory or swap space is committed to these blocks anymore. <p> This is the reason our garbage collector is conservative. In our collector any sequence of bytes that is aligned to a word and that points to the heap is considered a pointer <ref> [BW88] </ref>. Our garbage collector also supports internal pointers. Any pointer that points to any address inside an object is considered to point to the object. <p> In our GC library there is a special malloc call that allocates pointer free objects. We expect that this could reduce to almost none the problem of false pointers. A similar approach is used by <ref> [BW88] </ref>. 5 Performance Comparison In this section we compare our implementation of cloning garbage collector with the publically available Boehm-Demers-Weiser conservative garbage collector (BDWGC ) [BDS91] 5 .
Reference: [Che70] <author> C. J. </author> <title> Cheney. A nonrecursive list compacting algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 13(11) </volume> <pages> 677-678, </pages> <month> November </month> <year> 1970. </year>
Reference-contexts: This agreement adds extra dependencies between the modules. Garbage collection solves this problem by deallocating the object automatically when no module needs it. There are several algorithms for automatic garbage collection: mark and sweep collection [McC60], mark-compact collection [CN83], copying garbage collection <ref> [FY69, Che70] </ref>, and non-copying implicit collection [Wan89, Bak91]. We choose to use mark and sweep garbage collection in our implementation since it can be implemented conservatively. Mark and sweep collection [McC60] consists of two phases: the mark phase and a sweep phase.
Reference: [CN83] <author> Jacques Cohen and Alexandru Nicolau. </author> <title> Comparison of compacting algorithms for garbage collection. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(4) </volume> <pages> 532-553, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: This agreement adds extra dependencies between the modules. Garbage collection solves this problem by deallocating the object automatically when no module needs it. There are several algorithms for automatic garbage collection: mark and sweep collection [McC60], mark-compact collection <ref> [CN83] </ref>, copying garbage collection [FY69, Che70], and non-copying implicit collection [Wan89, Bak91]. We choose to use mark and sweep garbage collection in our implementation since it can be implemented conservatively. Mark and sweep collection [McC60] consists of two phases: the mark phase and a sweep phase.
Reference: [Com64] <author> W. T. </author> <title> Comfort. Multiword list items. </title> <journal> Communications of the ACM, </journal> <volume> 7(6), </volume> <month> June </month> <year> 1964. </year>
Reference-contexts: In this way, pages are swept on demand during allocation. This lazy sweep is similar to the one used in [BDS91]. 4 Implementation 4.1 The Allocator The memory allocator uses simple segregated free lists <ref> [Com64, WJNB95] </ref>. There are multiple free lists where each list contains blocks of a particular size. Each heap page contains objects of the same size and there is no splitting or coalescing of blocks.
Reference: [DLM + 78] <author> Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. </author> <title> On-the-fly garbage collection: An exercise in cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: These "stop-the-world" collectors are impractical in time critical and interactive applications where the implied pauses in execution are unacceptable. There is a class of garbage collection algorithms called incremental collectors that reduce or eliminate pause time by marking live memory concurrently with the mutator's execution <ref> [DLM + 78, Ste75, BDS91] </ref>. These techniques use read/write-barriers to keep track of pointer reads/writes and make sure that the mutator does not cause the collector to erroneously garbage collect accessible memory. Read/Write-barriers are implemented in two basic ways: compiler generated [Bro84], and virtual memory supported [AEL88, AL91]. <p> Since the collector will not rescan already scanned objects, this unmarked object will never be marked and it will be collected, even though it is reachable. It is easier to understand this problem using Dijkstra's three-color abstraction <ref> [DLM + 78] </ref>. During a mark phase objects that are marked and that have been scanned completely are considered black. Objects that are marked but not yet scanned are considered grey. Objects that are unmarked are white. <p> Optionally the white object could be turned to black by scanning it for pointers. Examples of garbage collectors that use incremental update are <ref> [DLM + 78] </ref>, [Ste75], and [BDS91]. Instead of preventing the first condition, snapshot-at-beginning garbage collection algorithms prevent the second condition from happening by making sure that there always remains a path from the root set to the objects that were reachable when the collection started.
Reference: [DWH + 90] <author> Alan Demers, Mark Weiser, Barry Hayes, Daniel Bobrow, and Scott Shenker. </author> <title> Combining generational and conservative garbage collection: Framework and implementations. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 261-269, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1990. </year> <note> ACM Press. </note>
Reference-contexts: In the latter case the handler takes a snapshot of the page, unprotects the page, and then the collector uses the snapshot page for tracing <ref> [DWH + 90] </ref>. Incremental collectors that prevent the first condition for happening are different in their real-time response than those that prevent the second condition. Collectors that prevent the first condition may have to iterate one or more times the mark phase until no grey objects exist [BDS91].
Reference: [FY69] <author> Robert R. Fenichel and Jerome C. Yochelson. </author> <title> A LISP garbage-collector for virtual-memory computer systems. </title> <journal> Communications of the ACM, </journal> <volume> 12(11) </volume> <pages> 611-612, </pages> <month> November </month> <year> 1969. </year> <month> 14 </month>
Reference-contexts: This agreement adds extra dependencies between the modules. Garbage collection solves this problem by deallocating the object automatically when no module needs it. There are several algorithms for automatic garbage collection: mark and sweep collection [McC60], mark-compact collection [CN83], copying garbage collection <ref> [FY69, Che70] </ref>, and non-copying implicit collection [Wan89, Bak91]. We choose to use mark and sweep garbage collection in our implementation since it can be implemented conservatively. Mark and sweep collection [McC60] consists of two phases: the mark phase and a sweep phase.
Reference: [HJ92] <author> Reed Hastings and Bob Joyce. Purify: </author> <title> Fast detection of memory leaks and access errors. </title> <booktitle> In USENIX Winter 1992 Technical Conference, </booktitle> <pages> pages 125-136, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1992. </year> <institution> USENIX Association. </institution>
Reference-contexts: There exist programs that help find memory errors such as the ones we have described <ref> [HJ92] </ref>. However, these programs only diagnose the problem not solve it. The programmer still has to find out when and where to correctly deallocate memory. Garbage collection solves both problems automatically. Besides reducing development effort, garbage collection also promotes modularity [Wil95]. For example, assume that two modules use explicit deallocation. <p> When the collection is 2 We are not taking into consideration modifying an already compiled program and inserting new code to keep track of pointer reads/writes <ref> [HJ92] </ref>. This approach is not trivial, and it still may introduce a significant overhead. 2 done, the clone passes the mark bits to the mutator and exits. The mutator uses the unmarked blocks in future allocations.
Reference: [HMS92] <author> Antony L. Hosking, J. Eliot B. Moss, and Darko Stefanovic. </author> <title> A comparative performance evaluation of write barrier implementations. </title> <editor> In Andreas Paepcke, editor, </editor> <booktitle> Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA '92), </booktitle> <pages> pages 92-109, </pages> <address> Vancouver, British Columbia, </address> <month> October </month> <year> 1992. </year> <note> ACM Press. Published as SIGPLAN Notices 27(10), </note> <month> October </month> <year> 1992. </year>
Reference-contexts: Virtual memory read/write-barriers implemented in user space tend to be inefficient and intrusive. The cost of a page trap, crossing the kernel-user boundary, and calling a signal handler for every page is expensive <ref> [HMS92] </ref>. Also when a page trap signal is produced inside a system call, the system call is unexpectedly interrupted. To prevent this, the trap has to be manually generated before the program makes a system call that potentially can cause a page trap.
Reference: [Knu73] <author> Donald E. Knuth. </author> <title> The Art of Computer Programming, volume 1: Fundamental Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1973. </year> <note> First edition published in 1968. </note>
Reference-contexts: 1 Introduction Garbage collection is the automatic deallocation of dynamically allocated memory that is no longer in use by a running program <ref> [Knu73] </ref>. The alternative, explicit deallocation, is error prone and requires the programmer to keep track of the liveness of the memory allocated. This is a frequent source of bugs that are difficult to track.
Reference: [McC60] <author> John McCarthy. </author> <title> Recursive functions of symbolic expressions and their computation by machine. </title> <journal> Communications of the ACM, </journal> <volume> 3(4) </volume> <pages> 184-195, </pages> <month> April </month> <year> 1960. </year>
Reference-contexts: This agreement adds extra dependencies between the modules. Garbage collection solves this problem by deallocating the object automatically when no module needs it. There are several algorithms for automatic garbage collection: mark and sweep collection <ref> [McC60] </ref>, mark-compact collection [CN83], copying garbage collection [FY69, Che70], and non-copying implicit collection [Wan89, Bak91]. We choose to use mark and sweep garbage collection in our implementation since it can be implemented conservatively. Mark and sweep collection [McC60] consists of two phases: the mark phase and a sweep phase. <p> There are several algorithms for automatic garbage collection: mark and sweep collection <ref> [McC60] </ref>, mark-compact collection [CN83], copying garbage collection [FY69, Che70], and non-copying implicit collection [Wan89, Bak91]. We choose to use mark and sweep garbage collection in our implementation since it can be implemented conservatively. Mark and sweep collection [McC60] consists of two phases: the mark phase and a sweep phase. The mark phase identifies the blocks that are garbage, and the sweep phase deallocates these blocks.
Reference: [Rit84] <author> D.M. Ritchie. </author> <title> The evolution of the unix time-sharing system. </title> <journal> Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1577-1594, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: In early versions of UNIX, fork () was implemented in only 27 lines of assembly code by creating an extra copy of the current process in the swap area <ref> [Rit84] </ref>.
Reference: [Ste75] <author> Guy L. Steele Jr. </author> <title> Multiprocessing compactifying garbage collection. </title> <journal> Communications of the ACM, </journal> <volume> 18(9) </volume> <pages> 495-508, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: These "stop-the-world" collectors are impractical in time critical and interactive applications where the implied pauses in execution are unacceptable. There is a class of garbage collection algorithms called incremental collectors that reduce or eliminate pause time by marking live memory concurrently with the mutator's execution <ref> [DLM + 78, Ste75, BDS91] </ref>. These techniques use read/write-barriers to keep track of pointer reads/writes and make sure that the mutator does not cause the collector to erroneously garbage collect accessible memory. Read/Write-barriers are implemented in two basic ways: compiler generated [Bro84], and virtual memory supported [AEL88, AL91]. <p> Optionally the white object could be turned to black by scanning it for pointers. Examples of garbage collectors that use incremental update are [DLM + 78], <ref> [Ste75] </ref>, and [BDS91]. Instead of preventing the first condition, snapshot-at-beginning garbage collection algorithms prevent the second condition from happening by making sure that there always remains a path from the root set to the objects that were reachable when the collection started.
Reference: [Wan89] <author> Thomas Wang. </author> <title> MM garbage collector for C++. </title> <type> Master's thesis, </type> <institution> California Polytechnic State University, </institution> <address> San Luis Obispo, California, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: This agreement adds extra dependencies between the modules. Garbage collection solves this problem by deallocating the object automatically when no module needs it. There are several algorithms for automatic garbage collection: mark and sweep collection [McC60], mark-compact collection [CN83], copying garbage collection [FY69, Che70], and non-copying implicit collection <ref> [Wan89, Bak91] </ref>. We choose to use mark and sweep garbage collection in our implementation since it can be implemented conservatively. Mark and sweep collection [McC60] consists of two phases: the mark phase and a sweep phase.
Reference: [Wil92] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <editor> In Yves Bekkers and Jacques Cohen, editors, </editor> <booktitle> International Workshop on Memory Management, number 637 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-42, </pages> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference: [Wil95] <author> Paul R. Wilson. </author> <title> Garbage collection. </title> <journal> Computing Surveys, </journal> <note> 1995. Expanded version of [Wil92]. Draft available via anonymous internet FTP from cs.utexas.edu as pub/garbage/bigsurv.ps. In revision, to appear. </note>
Reference-contexts: However, these programs only diagnose the problem not solve it. The programmer still has to find out when and where to correctly deallocate memory. Garbage collection solves both problems automatically. Besides reducing development effort, garbage collection also promotes modularity <ref> [Wil95] </ref>. For example, assume that two modules use explicit deallocation. Module 1 allocates an object and passes its reference to module 2. <p> When a grey object has been scanned completely, it turns black . At the end of a mark phase all objects that are still white are considered unreachable (garbage). The collector will miss a reachable object when both the following two conditions happen <ref> [Wil95] </ref>: 1. The mutator stores in a black object a pointer to some white object. 2. All the paths from grey objects to this white object are deleted.
Reference: [WJNB95] <author> Paul R. Wilson, Mark S. Johnstone, Michael Neely, and David Boles. </author> <title> Dynamic storage allocation: A survey and critical review. </title> <booktitle> In 1995 International Workshop on Memory Management, </booktitle> <address> Kinross, Scotland, UK, 1995. </address> <publisher> Springer Verlag LNCS. </publisher>
Reference-contexts: In this way, pages are swept on demand during allocation. This lazy sweep is similar to the one used in [BDS91]. 4 Implementation 4.1 The Allocator The memory allocator uses simple segregated free lists <ref> [Com64, WJNB95] </ref>. There are multiple free lists where each list contains blocks of a particular size. Each heap page contains objects of the same size and there is no splitting or coalescing of blocks.
Reference: [Yua90] <author> Taichi Yuasa. </author> <title> Real-time garbage collection on general-purpose machines. </title> <journal> Journal of Systems and Software, </journal> <volume> 11 </volume> <pages> 181-198, </pages> <year> 1990. </year>
Reference-contexts: The snapshot is automatically done inside the kernel through virtual memory copy-on-write techniques when cloning the process. The snapshot can also be obtained by pushing old pointer values to a mark stack every time they are overwritten by the mutator <ref> [Yua90] </ref>, by using special memory processors to create a copy-on-write of the mutator's memory [AP87], or by building a snapshot in user space by protecting the memory and catching page faults with a special signal handler.
Reference: [Zor93] <author> Benjamin Zorn. </author> <title> The measured cost of conservative garbage collection. </title> <journal> Software|Practice and Experience, </journal> <volume> 23(7) </volume> <pages> 733-756, </pages> <month> July </month> <year> 1993. </year> <month> 15 </month>
Reference-contexts: We use as a benchmark the ghostscript program. Ghostcript is a publically available version of a postscript previewer. The version of Ghostscript and the input files that are used in this comparison were obtained from the Zorn garbage collection test suite <ref> [Zor93] </ref> 6 . We choose ghostscript because it is one of the most problematic programs in the test suite: It has a large heap and it makes extensive use of dynamic memory. BDWGC can be configured to be either stop-the-world or incremental.
References-found: 27

