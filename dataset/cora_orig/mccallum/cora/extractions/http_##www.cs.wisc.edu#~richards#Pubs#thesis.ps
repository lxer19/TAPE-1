URL: http://www.cs.wisc.edu/~richards/Pubs/thesis.ps
Refering-URL: http://www.cs.wisc.edu/~richards/richards.html
Root-URL: 
Title: Contributions to Functional Programming in Logic  
Author: by Bradley E. Richards B.A., Gustavus Maarten H. van Emden, Supervisor Dr. Charles G. Morgan, Outside Member Dr. Kin F. Li, External Examiner c flBradley E. Richards, 
Degree: 1988 A thesis submitted in partial fulfillment of the requirements for the degree of Master of Science in the Department of  Dr. Mantis H.M. Cheng, Departmental Member  Philosophy)  
Address: Victoria  
Note: Dr.  All rights reserved. This thesis may not be reproduced in whole or in part, by mimeograph or other means, without the permission of the author.  
Affiliation: Adolphus College, Minnesota,  Computer Science  (Dept. of Computer Science)  (Dept. of Computer Science)  (Dept. of  (Dept. of Electrical and Computer Engineering)  University of  
Abstract: We accept this thesis as conforming to the required standard 
Abstract-found: 1
Intro-found: 1
Reference: [AKN86] <author> Hassan At-Kaci and Roger Nasr. Residuation: </author> <title> a paradigm for integrating logic and functional programming. </title> <type> Technical Report AI-359-86, </type> <institution> MCC, </institution> <year> 1986. </year>
Reference: [Che87] <author> M.H.M. Cheng. </author> <title> Lambda-equational Logic Programming. </title> <type> PhD thesis, </type> <institution> University of Waterloo, </institution> <year> 1987. </year>
Reference: [CY86] <author> Mantis H.M. Cheng and Keitaro Yukawa. </author> <title> Ap: an assertional programming system. </title> <type> Technical Report CS-86-11, </type> <institution> University of Waterloo, </institution> <year> 1986. </year>
Reference: [GM84] <author> J.A. Goguen and J. Meseguer. </author> <title> Equality, types, modules, and (why not?) generics for logic programming. </title> <journal> JLP, </journal> <volume> 2 </volume> <pages> 179-210, </pages> <year> 1984. </year>
Reference: [HO82] <author> C.M. Hoffman and M.J. O'Donnell. </author> <title> Programming with equations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(1) </volume> <pages> 83-112, </pages> <year> 1982. </year>
Reference: [HS86] <editor> J.R. Hindley and J.P. Seldin. </editor> <title> Introduction to Combinators and Lambda-Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference: [Hug84] <author> R.J.M. Hughes. </author> <title> The Design and Implementation of Programming Languages. </title> <type> PhD thesis, </type> <institution> Programming Research Group, Oxford, </institution> <year> 1984. </year>
Reference: [Joh85] <author> T. Johnsson. </author> <title> Lambda lifting: transforming programs to recursive equations. </title> <editor> In J.-P. Jouannaud, editor, </editor> <booktitle> Functional programming languages and com 61 BIBLIOGRAPHY 62 puter architecture, </booktitle> <pages> pages 190-203. </pages> <note> Springer-Verlag Lecture Notes in Computer Science 201, </note> <year> 1985. </year>
Reference: [Jon87] <editor> S.L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference: [Ken82] <author> J.R. Kennaway. </author> <title> The complexity of a translation of lambda calculus to com-binators. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of East Anglia, </institution> <year> 1982. </year>
Reference: [Kow70] <author> R.A. Kowalski. </author> <title> The case for using equality axioms in automatic demonstration. </title> <editor> In M. Laudet et al., editor, </editor> <booktitle> Symposium on Automatic Demonstration, </booktitle> <volume> volume 125, </volume> <pages> pages 112-127. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1970. </year> <note> Lecture Notes in Mathematics. </note>
Reference: [McC60] <author> J. McCarthy. </author> <title> Recursive functions of symbolic expressions and their computation by machine. </title> <journal> Comm. ACM, </journal> <volume> 3 </volume> <pages> 184-195, </pages> <year> 1960. </year>
Reference: [Nar88] <author> Sanjai Narain. Log(f): </author> <title> an optimal combination of logic programming, rewriting, and lazy evaluation. </title> <type> Technical report, </type> <institution> The RAND Corporation, </institution> <year> 1988. </year>
Reference: [O'D77] <author> M.J. O'Donnell. </author> <title> Computing in Systems Described by Equations. </title> <booktitle> Lecture Notes in Computer Science 58. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1977. </year>
Reference: [Rog67] <author> Hartley Rogers, Jr. </author> <title> Theory of Recursive Functions and Effective Computability. </title> <publisher> McGraw-Hill, </publisher> <year> 1967. </year>
Reference: [RW69] <author> G. Robinson and L. Wos. </author> <title> Paramodulation and theorem-proving in first-order theories with equality. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <pages> pages 135-150. </pages> <publisher> American Elsevier, </publisher> <address> New York, </address> <year> 1969. </year> <note> BIBLIOGRAPHY 63 </note>
Reference: [Tur79] <author> D.A. Turner. </author> <title> A new implementation technique for applicative languages. </title> <journal> Software Practice and Experience, </journal> <volume> 9 </volume> <pages> 31-49, </pages> <year> 1979. </year>
Reference: [Tur82] <author> D.A. Turner. </author> <title> Recursion equations as a programming language. </title> <editor> In J. Dar-lington, P. Henderson, and D. Turner, editors, </editor> <booktitle> Functional Programming and its Applications, </booktitle> <pages> pages 1-22. </pages> <publisher> Cambridge University Press, </publisher> <year> 1982. </year>
Reference: [Vas86] <author> P. Vasey. </author> <title> Qualified answers and their application to transformation. </title> <booktitle> In Proceedings of the Third International Logic Programming Conference, </booktitle> <pages> pages 425-432, </pages> <year> 1986. </year>
Reference-contexts: Second, and more importantly, the SLD-derivation is incomplete. Prolog derivations, when they terminate, are expected to succeed or fail. The derivation in Figure 6.2 does neither. It is as if a normal derivation were frozen before completion, yielding a "conditional answer" <ref> [Vas86, vE88] </ref>. That is, a clause whose head is the initial goal with the cumulative substitution applied to it, and whose body is the final goal statement in the derivation. The derivation proves that the conditional answer is logically implied by the input clauses of the SLD-derivation.
Reference: [vE88] <author> M.H. van Emden. </author> <title> Conditional answers for polymorphic type inference. In K.A. </title> <editor> Bowen and R.A. Kowalski, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <pages> pages 590-603. </pages> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: Second, and more importantly, the SLD-derivation is incomplete. Prolog derivations, when they terminate, are expected to succeed or fail. The derivation in Figure 6.2 does neither. It is as if a normal derivation were frozen before completion, yielding a "conditional answer" <ref> [Vas86, vE88] </ref>. That is, a clause whose head is the initial goal with the cumulative substitution applied to it, and whose body is the final goal statement in the derivation. The derivation proves that the conditional answer is logically implied by the input clauses of the SLD-derivation.
Reference: [vEM81] <author> M.H. van Emden and T.S.E. Maibaum. </author> <title> Equations compared with clauses for specification of abstract data types. </title> <booktitle> In Advances in Database Theory, </booktitle> <pages> pages 159-194. </pages> <publisher> Plenum Press, </publisher> <year> 1981. </year>
Reference-contexts: U; V ); which is the relationalized version of g (F ) : X = F : (F : X). (Note that the clause produced by this process is identical to the one used by Warren in Section 3.3.) 6.3 Our approach to relationalization A Prolog program is given in <ref> [vEM81] </ref> for relationalizing equations, but it is unjustified, and a poor example of logic programming. [vEY87] proves the correctness of the translation and describes an improved method for performing the conversion, but CHAPTER 6. COMPILATIONAL APPROACH 50 does not attempt automation.
Reference: [vEY87] <author> M.H. van Emden and K. Yukawa. </author> <title> Logic programming with equations. </title> <journal> The Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 265-288, </pages> <year> 1987. </year>
Reference-contexts: F : (F : X). (Note that the clause produced by this process is identical to the one used by Warren in Section 3.3.) 6.3 Our approach to relationalization A Prolog program is given in [vEM81] for relationalizing equations, but it is unjustified, and a poor example of logic programming. <ref> [vEY87] </ref> proves the correctness of the translation and describes an improved method for performing the conversion, but CHAPTER 6. COMPILATIONAL APPROACH 50 does not attempt automation.
Reference: [War82] <author> D.H.D. Warren. </author> <title> Higer-order extensions to prolog: are they needed? In J.E. </title> <editor> Hayes, Donald Michie, and Y-H. Pao, editors, </editor> <booktitle> Machine Intelligence 10, </booktitle> <pages> pages 441-454. </pages> <publisher> Ellis Horwood with John Willey and Sons, </publisher> <year> 1982. </year> <note> Lecture Notes in Mathematics 125. </note>
Reference-contexts: The relationship between -expressions, equations, and these two functional programming schemes is summarized in Figure 7.1. It should be noted that the results of relationalizing the "twice" example are identical to the clauses used by Warren in <ref> [War82] </ref> to compute the same expression in Prolog. However, it is impossible to tell if our translation is the same as his, as [War82] does not fully describe his technique. <p> It should be noted that the results of relationalizing the "twice" example are identical to the clauses used by Warren in <ref> [War82] </ref> to compute the same expression in Prolog. However, it is impossible to tell if our translation is the same as his, as [War82] does not fully describe his technique. One of the benefits of both of our approaches is that function-valued expressions can be returned to the user in -notation.
References-found: 23

