URL: http://www.cs.ucsb.edu/oocsb/self/papers/self4.0UserInterface.ps.Z
Refering-URL: http://www.cs.ucsb.edu/oocsb/self/papers/self4.0UserInterface.html
Root-URL: http://www.cs.ucsb.edu
Title: Abstract  
Abstract: Manipulating programs is hard, while manipulating objects in the physical world is often easy. Several attributes of the physical world help make it comprehensible and manipulable: concreteness, uniformity, and exibility. The Self programming system attempts to apply these attributes to the world within the computer. The semantics of the language, the efficiency and fidelity of its implementation, and the architecture of its user interface conspire to make the experience of constructing programs in Self immediate and tangible. We describe the mechanisms used to achieve this goal, and illustrate those mechanisms within the context of an extended programming task. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Blaschek. </author> <title> Object-Oriented Programming with Prototypes, </title> <publisher> Springer-Verlag, </publisher> <address> New York, Berlin 1994. </address>
Reference-contexts: A number of other prototype languages have been developed in recent years including Kevo, Glyphic Script, Omega, and NewtonScript (for overviews, see [16] and <ref> [1] </ref>). All of these languages have programming environments that allow objects to be inspected and edited graphically. Glyphic Script and NewtonScript also have UI construction facilities.
Reference: [2] <author> A. Borning and R. Duisberg. </author> <title> Constraint-Based Tools for Building User Interfaces, </title> <journal> ACM Transactions on Graphics 5(4) pp. </journal> <month> 345-374 (October </month> <year> 1981). </year>
Reference-contexts: Unfortunately, for lack of a high-performance implementation, most of the Glyphic Codeworks user interface framework, including its user interface components, is implemented in C; these parts of the system cannot be taken apart and modified at run-time. Garnet [12] and ThingLab <ref> [2] </ref> are prototype-based user interface construction environments. However, rather than making the underlying programming language more concrete, both systems attempt to hide or at least decrease its importance by using constraints to define user interface behavior.
Reference: [3] <author> L. Cardelli. </author> <title> Building User Interfaces by Direct Manipulation, </title> <booktitle> in Proc. ACM Symposium on User Interface Software (UIST '88), </booktitle> <pages> pp. </pages> <month> 152-166 (October </month> <year> 1988). </year>
Reference-contexts: It is most closely related to systems that combine both. User interface builders allow graphical user interfaces to be constructed by direct manipulation. Early work in this area includes Trillium [7], a direct-manipulation editor for photocopier interfaces, Cardellis dialog editor <ref> [3] </ref>, and the NeXT UI builder [21]. Most UI builders allow the interface to be tested by changing from edit-mode to run-mode; however, even in run-mode, the interface is typically not connected to its underlying application program.
Reference: [4] <author> B. Chang, D. Ungar, and R. Smith. </author> <title> Getting Close to Objects, </title> <editor> in M. Burnett, A. Goldberg, and T. Lewis, editors, </editor> <booktitle> Visual Object-Oriented Programming, Concepts and Environments, </booktitle> <pages> pp. 185-198, </pages> <publisher> Manning Publications, </publisher> <address> Greenwich, CT, </address> <year> 1995. </year>
Reference-contexts: The use of a single outliner per Self object supports the illusion that the outliner actually is the Self object: multiple representations of the same Self object would break down that illusion <ref> [4] </ref>. This restriction also helps decrease the screen clutter that many Smalltalk programmers are familiar with, in which several inspectors on the same object can become scattered or buried. <p> The Self system attempts to do the same for an object-oriented programming language. The look and feel of the Self system was heavily inuenced by the Alternate Reality Kit (ARK) [15], an earlier system by one of the authors and Seity <ref> [4] </ref>, an earlier user interface for the Self language. VII. Conclusions Over the years the Self project has been motivated by a vision of what computing should be. It draws on key properties of the physical world to create a computing system that is more malleable and more readily comprehensible.
Reference: [5] <institution> Director, MacroMedia Corp., </institution> <address> San Francisco, CA </address>
Reference-contexts: However, SUIT does not have an integrated programming environment; the application program itself cannot be changed at run-time. A number of commercial product such as Hypercard [10], MacroMedia Director <ref> [5] </ref>, and Visu-alBasic [20] combine a UI builder (perhaps for a specific domain) with a scripting language. User interfaces constructed with these systems can always be edited, and behavior can be added from within the system using the scripting language.
Reference: [6] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80, the Language and its Implementation, </title> <publisher> Addison Wes-ley, </publisher> <year> 1983. </year>
Reference-contexts: Reno differs from the Self interface in its interaction details, and in a display metaphor that is based on window objects viewing the contents of container objects. In the language area, Self is a direct descendant of Smalltalk-80 <ref> [6] </ref>.
Reference: [7] <author> D. Henderson. </author> <title> The Trillium User Interface Design Environment, </title> <booktitle> Proceedings of CHI '86, </booktitle> <pages> pp. </pages> <month> 221-227 (April </month> <year> 1986). </year>
Reference-contexts: Related work The Self system draws on previous work in two areas: user interface construction and object-oriented programming languages. It is most closely related to systems that combine both. User interface builders allow graphical user interfaces to be constructed by direct manipulation. Early work in this area includes Trillium <ref> [7] </ref>, a direct-manipulation editor for photocopier interfaces, Cardellis dialog editor [3], and the NeXT UI builder [21]. Most UI builders allow the interface to be tested by changing from edit-mode to run-mode; however, even in run-mode, the interface is typically not connected to its underlying application program.
Reference: [8] <author> U. Hlzle, C. Chambers, and D. Ungar. </author> <title> Debugging Optimized Code with Dynamic Deoptimization, </title> <booktitle> in Proc. ACM SIGPLAN 92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 32-43, </pages> <address> San Francisco, CA (June 1992). </address>
Reference-contexts: Proper support for debugging is an important part of making the programming process uid and efficient. The Self debugger takes advantage of the virtual machines technique of dynamic deoptimiza-tion <ref> [8] </ref> to present even highly optimized code in Self-level terms. The user can see Self level stack frames, fix any errors in the Self code, and continue. We believe this implementation lets one work in the style that is naturally called for by the language. VI.
Reference: [9] <author> U. Hlzle and D. Ungar. </author> <title> A Third-Generation Self Implementation: Reconciling Responsiveness with Performance, </title> <booktitle> in Proc. OOPSLA '92, </booktitle> <pages> pp. 229-243. </pages> <note> Also see U. </note> <author> Hlzle, </author> <title> Adaptive Optimization for Self: Reconciling High Performance with Exploratory Programming, </title> <type> Ph.D. Thesis, </type> <institution> Stanford University (August 1994). </institution>
Reference-contexts: Studies of the Self virtual machine have shown that, on the average, there are has invoked a color changing tool that unifies colors across most submorphs, and has invoked the meta menu item move to own window. about ten apparent message sends for every one that really happens <ref> [9] </ref>. Proper support for debugging is an important part of making the programming process uid and efficient. The Self debugger takes advantage of the virtual machines technique of dynamic deoptimiza-tion [8] to present even highly optimized code in Self-level terms.
Reference: [10] <institution> HyperCard, Apple Computer Inc., Cupertino, </institution> <address> CA. </address>
Reference-contexts: However, SUIT does not have an integrated programming environment; the application program itself cannot be changed at run-time. A number of commercial product such as Hypercard <ref> [10] </ref>, MacroMedia Director [5], and Visu-alBasic [20] combine a UI builder (perhaps for a specific domain) with a scripting language. User interfaces constructed with these systems can always be edited, and behavior can be added from within the system using the scripting language.
Reference: [11] <author> R. Kerr, M. Markley, M. Sonntag, T. Trower. </author> <title> Reno: A Component-Based User Interface, </title> <booktitle> in Proc. CHI 95 Conference Companion, </booktitle> <pages> pp 19-20 Denver, </pages> <month> (May </month> <year> 1995). </year>
Reference-contexts: Furthermore, the scripting languages cannot be used to define user interface widgets nor to extend the system in other ways. A system called Reno <ref> [11] </ref>, developed independently and concurrently with the Self user interface, has much of the feel we describe here. Display objects are very fine grained, and can be directly accessed at any time. For example, the user can directly embed any graphic into a line of text.
Reference: [12] <author> B. Myers, D. Giuse, and B. Vander Zanden. </author> <title> Declarative Programming in a Prototype-Instance System: Object-Oriented Programming without Writing Methods, </title> <booktitle> in Proc. OOPSLA '92, </booktitle> <pages> pp. </pages> <month> 184-200 (October </month> <year> 1992) </year>
Reference-contexts: Unfortunately, for lack of a high-performance implementation, most of the Glyphic Codeworks user interface framework, including its user interface components, is implemented in C; these parts of the system cannot be taken apart and modified at run-time. Garnet <ref> [12] </ref> and ThingLab [2] are prototype-based user interface construction environments. However, rather than making the underlying programming language more concrete, both systems attempt to hide or at least decrease its importance by using constraints to define user interface behavior.
Reference: [13] <author> R. Pausch, N. Young, R. DeLine. </author> <title> Simple User Interface Toolkit (SUIT): The Pascal of User Interface Toolkits, </title> <booktitle> in Proc. Symposium on User Interface Software and Technology (UIST '91), </booktitle> <pages> pp. </pages> <month> 117-125 (November </month> <year> 1991). </year>
Reference-contexts: Most user interface builders have a build or edit mode that is distinct from the actual application usage mode. (SUIT is a notable exception here <ref> [13] </ref>.) Most interface builders create a description for an application (i.e.: a C program whose execution creates the interface.) There is a deep run/edit switch in the design of such systems, unavoidable in many cases because the underlying system does not support incremental programming changes. <p> To test the UI in the context of the application, the user must recompile or relink and, after testing, must return to the UI builder to make further changes. The SUIT user interface builder <ref> [13] </ref> narrows the gap between editing and testing. SUIT uses a special key combination to distinguish editing gestures from normal user interactions.
Reference: [14] <author> D. Smith, C. Irby, R. Kimball, B. Verplank, and E. Harslem. </author> <title> Designing the Star user interface, </title> <journal> BYTE 7, </journal> <volume> 4, </volume> <pages> pp. </pages> <month> 242-282 (April </month> <year> 1982). </year>
Reference-contexts: Like Self, Garnet user-interfaces are composed of fine-grained graphical objects like rectangles and circles but, unlike Self, Garnet groups these objects using abstract objects (aggregates) that are not directly visible. The desktop metaphor <ref> [14] </ref> made files and directories more approachable by making them into tangible, manipulable objects. The Self system attempts to do the same for an object-oriented programming language.
Reference: [15] <author> R. Smith. </author> <title> Experiences with the Alternate Reality Kit, an Example of the Tension Between Literalism and Magic, </title> <booktitle> in Proc. CHI + GI Conference, </booktitle> <pages> pp 61-67 Toronto, </pages> <month> (April </month> <year> 1987). </year>
Reference-contexts: The desktop metaphor [14] made files and directories more approachable by making them into tangible, manipulable objects. The Self system attempts to do the same for an object-oriented programming language. The look and feel of the Self system was heavily inuenced by the Alternate Reality Kit (ARK) <ref> [15] </ref>, an earlier system by one of the authors and Seity [4], an earlier user interface for the Self language. VII. Conclusions Over the years the Self project has been motivated by a vision of what computing should be.
Reference: [16] <author> R. Smith, M. Lenctczner, W. Smith, A. Taival-saari, and D. Ungar. </author> <title> Prototype-Based Languages: Object Lessons from Class-Free Programming (Panel), </title> <booktitle> in Proc. OOPSLA '94, </booktitle> <pages> pp. </pages> <month> 102-112 (October </month> <year> 1994). </year> <title> Also see the panel summary of the same title, </title> <booktitle> in Addendum to the Proceedings of OOPSLA 94, </booktitle> <pages> pp. 48-53. </pages>
Reference-contexts: A number of other prototype languages have been developed in recent years including Kevo, Glyphic Script, Omega, and NewtonScript (for overviews, see <ref> [16] </ref> and [1]). All of these languages have programming environments that allow objects to be inspected and edited graphically. Glyphic Script and NewtonScript also have UI construction facilities.
Reference: [17] <author> R. Smith, D. Ungar, and B. Chang. </author> <title> The Use Mention Perspective on Programming for the Interface, </title> <editor> In Brad A. Myers, </editor> <title> Languages for Developing User Interfaces, </title> <publisher> Jones and Bartlett, </publisher> <address> Boston, MA, </address> <year> 1992. </year> <pages> pp. 79-89. </pages>
Reference-contexts: the resize button which he then incorporates into the simulation. tools are themselves elements of the everyday world, and can be modified using the same mechanisms used to modify other objects. 2] Run and edit unified There is another kind of uniformity exhibited here: the lack of a run/edit distinction <ref> [17] </ref>.
Reference: [18] <author> D. Ungar and R. Smith. </author> <title> Self: the Power of Simplicity, </title> <booktitle> in Proc. OOPSLA 87, </booktitle> <pages> pp. </pages> <month> 227-241 (October </month> <year> 1987). </year>
Reference-contexts: No class/non-class distinction Self is a prototype based system, and any object can have inheritance children, or can itself inherit from any other object. (For a fuller discussion of the utility of this exibility, see the original Self paper <ref> [18] </ref>.) In prototype based languages, an object can hold its own behavior, it need not be held on its behalf by some class. The programmer has more places to put behavior, thus more exibility. In Self, inheriting from an object gives you access to that objects slots.
Reference: [19] <author> D. Ungar, R. Smith, C. Chambers, and U. Hl-zle. </author> <title> Object, Message, and Performance: How They Coexist in Self. </title> <journal> Computer, </journal> <volume> 25(10), </volume> <pages> pp. 53-64. </pages> <month> (Octo-ber </month> <year> 1992). </year>
Reference-contexts: Previous papers have detailed how the design of Self, so extreme in its insistence on using object and message for everything, renders a conventional implementation unusable <ref> [19] </ref>. The Self virtual machine uses dynamic compilation based on statistical assessment of actual method usage to generate optimized code while the system runs. This optimization technique inlines many of the calls which would normally be dynamically dispatched.
Reference: [20] <institution> VisualBasic, MicroSoft Corp., </institution> <address> Redmond, WA </address>
Reference-contexts: However, SUIT does not have an integrated programming environment; the application program itself cannot be changed at run-time. A number of commercial product such as Hypercard [10], MacroMedia Director [5], and Visu-alBasic <ref> [20] </ref> combine a UI builder (perhaps for a specific domain) with a scripting language. User interfaces constructed with these systems can always be edited, and behavior can be added from within the system using the scripting language.
Reference: [21] <author> B. Webster. </author> <title> The NeXT Book, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: It is most closely related to systems that combine both. User interface builders allow graphical user interfaces to be constructed by direct manipulation. Early work in this area includes Trillium [7], a direct-manipulation editor for photocopier interfaces, Cardellis dialog editor [3], and the NeXT UI builder <ref> [21] </ref>. Most UI builders allow the interface to be tested by changing from edit-mode to run-mode; however, even in run-mode, the interface is typically not connected to its underlying application program.
References-found: 21

