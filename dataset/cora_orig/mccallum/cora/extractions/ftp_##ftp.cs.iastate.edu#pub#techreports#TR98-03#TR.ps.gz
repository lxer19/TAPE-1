URL: ftp://ftp.cs.iastate.edu/pub/techreports/TR98-03/TR.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/todd/papers/
Root-URL: 
Title: Multiple Dispatch as Dispatch on Tuples  
Author: Gary T. Leavens and Todd D. Millstein TR #-b 
Keyword: Multimethods, generic functions, object-oriented programming languages, single dispatch, multiple dispatch, tuples, product types, encapsulation, modularity, static typechecking, subtyping, inheritance, Tuple language.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: To appear in OOPSLA 98 Object-Oriented Programming, Systems, Langauges, and Applications, Vancouver, British Columbia, October 18-22, 1998.  
Date: April 1998, Revised May, July 1998  
Abstract: 1994 CR Categories: D.3.1 [Programming Languages] Formal Definitions and Theory semantics; D.3.2 [Programming Languages] Language Classifications object-oriented languages; D.3.3 [Programming Languages] Language Constructs and Features abstract data types, control structures, procedures, functions, and subroutines; D.3.m [Programming Languages] Miscellaneous multimethods, generic functions, single dispatch, multiple dispatch, type systems; F.3.3 [Logics and Meanings of Programs] Studies of Program Constructs control primitives, type structure. Copyright 1998 by the Association for Computing Machinery, Inc., 1998. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commerical advantage, the copyright notice, the title of this publication, and its date appear, and notice is given that copying is by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. 
Abstract-found: 1
Intro-found: 1
Reference: [Ada 83] <author> American National Standards Institute. </author> <title> Reference Manual for the Ada Programming Language. </title> <address> ANSI/MIL-STD 1815A, </address> <month> February, </month> <year> 1983. </year>
Reference-contexts: In particular, the method from the (ColorPoint, ColorPoint) tuple class is only invoked if both arguments are ColorPoint instances at run-time. The use of dynamic classes distinguishes multiple dispatch from static overloading (as found, for example, in Ada 83 <ref> [Ada 83] </ref>). The semantics of sending messages to tuples, multiple dispatch, is similar to that in Cecil [Chambers 95].
Reference: [Amadio & Cardelli 93] <author> Roberto M. Amadio and L. Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year>
Reference: [Arnold & Gosling 98] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. Second Edition, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1998. </year>
Reference-contexts: 1 INTRODUCTION Single dispatch, as found in C++ [Stroustrup 97], Java <ref> [Arnold & Gosling 98, Gosling et al. 96] </ref>, Smalltalk-80 [Goldberg & Robson 83], and Eiffel [Meyer 92, Meyer 97], selects a method using the dynamic class of one object, the messages receiver.
Reference: [Baumgartner et al. 96] <author> Gerald Baumgartner, Konstantin Lufer, Vincent F. Russo. </author> <title> On the Interaction of Object-Oriented Design patterns and Programming Languages. </title> <type> Technical Report CSD-TR-96-020, </type> <institution> Department of Computer Science, Purdue University, </institution> <month> February </month> <year> 1996. </year>
Reference-contexts: In order to define new operations on these elements without modifying the element classes, a separate hierarchy of visitors is created, one per operation. The code to invoke when a visit occurs is dependent both on which visitor and which element is used. Multimethods easily express the required semantics <ref> [Section 7, Baumgartner et al. 96] </ref>, while a singly-dispatched implementation must rely on unwieldy simulations of multiple dispatching. 3 TUPLE, THE MULTIPLE-DISPATCHING EXTENSION OF SDCORE Tuple extends SDCore with tuple expressions, tuple classes, tuple types, and the ability to declare and send messages to tuples, which gives multiple dispatch. <p> C. Sekar for comments on an earlier draft. Thanks to Craig Chambers for many discussions about multimethods. Thanks to Olga Antropova for the syntactic sugar idea mentioned in Section 4.1. Thanks to Vassily Litvinov for pointing us to <ref> [Baumgartner et al. 96] </ref> and to Craig Kaplan for an idea for an example. Leavenss work was supported in part by NSF Grants CCR 9593168 and CCR-9803843.
Reference: [Bobrow et al. 86] <author> Daniel G. Bobrow, Kenneth Kahn, George Kiczales, Larry Masinter, Mark Stefik, and Frank Zdybel. CommonLoops: </author> <title> Merging Lisp and Object-Oriented Programming. </title> <editor> In Norman Meyrowitz (editor), </editor> <booktitle> OOPSLA 86 Conference Proceedings, </booktitle> <address> Portland, Oregon, </address> <month> September </month> <year> 1986, </year> <title> volume 21, </title> <journal> number 11 of ACM SIGPLAN Notices, </journal> <pages> pp. 17-29. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> November, </month> <year> 1986. </year>
Reference-contexts: Multiple dispatch is in many ways more expressive and exible than single dispatch in object-oriented (OO) programming <ref> [Bobrow et al. 86, Chambers 92, Castagna 97, Moon 86] </ref>. In this paper we propose a new, simple, and orthogonal way of adding multiple dispatch to existing languages with single dispatch. The idea is to add tuples as primitive expressions and to allow messages to be sent to tuples.
Reference: [Bourdoncle & Merz 97] <author> Franois Bourdoncle and Stephan Merz. </author> <title> Type Checking Higher-Order Polymorphic Multi-Methods. </title> <booktitle> Conference Record of POPL 97: The 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Paris, France, </booktitle> <pages> pp. 302-315. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> January </month> <year> 1997. </year> <month> 9 </month>
Reference-contexts: It is interesting to speculate about the advantages that might be obtained by adding algebraic datatypes and more extensive pattern-matching features to object-oriented languages (see also <ref> [Bourdoncle & Merz 97, Ernst et al. 98] </ref>). 4 RELATED WORK In this section we discuss two kinds of related work. The first concerns generic-function languages; while these do not solve the problem we address in this paper, using such a language is a way to obtain multiple dispatch.
Reference: [Boyland & Castagna 97] <author> John Boyland and Giuseppe Castagna. </author> <title> Parasitic Methods: An Implementation of Multi-Methods for Java. </title> <booktitle> Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA 97). Volume 32, number 10 of ACM SIGPLAN Notices, </booktitle> <pages> pp. 66-76. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> November </month> <year> 1997. </year>
Reference-contexts: For example, since ColorPoint overrides the equal generic function in Point, it must duplicate the equal method declared within the Point class. As observed in the Bruce et al. paper, this is akin to the Ingalls technique for multiple polymorphism [Ingalls 86]. Parasitic multimethods <ref> [Boyland & Castagna 97] </ref>, a variant of encapsulated multimethods, remove this disadvantage by allowing parasitic methods to be inherited. The second problem caused by the two dispatches is that existing classes sometimes need to be modified when new subclasses are added to the system. <p> Boyland and Castagna also say that, compared with their textual ordering, ordering methods by specificity as we do in Tuple is very intuitive and clear <ref> [Page 73, Boyland & Castagna 97] </ref>.
Reference: [Bruce et al. 93] <author> Kim B. Bruce and Jon Crabtree and Thomas P. Murtagh and Robert van Gent and Allyn Dimock and Robert Muller. </author> <title> Safe and decidable type checking in an object-oriented language. </title> <editor> In Andreas Paepcke (editor), </editor> <booktitle> OOPSLA 93 Conference Proceedings. Volume 28, number 10 of ACM SIGPLAN Notices, </booktitle> <pages> pp. 29-46. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> October, </month> <year> 1993. </year>
Reference-contexts: In Section 3 we describe the additions to the single- dispatching core that make up our mechanism and support our first three claims. Section 4 supports the fourth claim by comparison with related work. In Section 5 we offer * With apologies to Bruce et al., whose TOOPLE language <ref> [Bruce et al. 93] </ref> is pronounced the same way. 2 some conclusions.
Reference: [Bruce et al. 95] <author> Kim Bruce, Luca Cardelli, Giuseppe Castagna, The Hopkins Object Group, Gary T. Leavens, and Benjamin Pierce. </author> <title> On Binary Methods. </title> <journal> Theory and Practice of Object Systems, </journal> <volume> 1(3) </volume> <pages> 221-242, </pages> <year> 1995. </year>
Reference-contexts: For example, p1.distanceFrom (ln2) has type int, assuming that p1 has type Point and ln2 has type Line. 2.3 Problems with Single Dispatching Single dispatching does not easily support some programming idioms. The best-known problem of this sort is the binary method problem <ref> [Bruce et al. 95] </ref>. <p> That is, since tuple classes have no special privileges to access the fields of their component instances, the encapsulation properties of classes are unaffected. However, because of this property, Tuple, like other multimethod languages, does not solve the privileged access aspect of the binary methods problem <ref> [Bruce et al. 95] </ref>. It may be that a mechanism such as C++ friendship grants would solve most of this in practice. We avoided giving methods in tuple classes default privileged access to the fields of the instances in a tuple because that would violate information hiding. <p> The problem is that we need to invoke the appropriate method based on both whether the first argument is a Point or ColorPoint and whether the second argument is a Terminal, Printer, or ColorPrinter. In a singly-dispatched language, an unnatural work-around such as Ingallss double dispatching technique <ref> [Ingalls 86, Bruce et al. 95] </ref> is required to encode the desired behavior. 3.3 Tuples vs. Classes The ability to express multiple dispatching via dispatching on tuples is not easy to simulate in a single-dispatching language, as is well-known [Bruce et al. 95]. <p> Classes The ability to express multiple dispatching via dispatching on tuples is not easy to simulate in a single-dispatching language, as is well-known <ref> [Bruce et al. 95] </ref>. The Ingalls double-dispatching technique mentioned above is a faithful simulation but often requires exponentially (in the size of the tuple) more methods than a multimethod-based solution. <p> The second, more closely-related work, addresses the same problem that we do: how to add support for multiple dispatch to languages with single dispatch. An inspirational idea for our work is the technique for avoiding binary methods by using product classes described by Bruce et al. <ref> [Section 3.2, Bruce et al. 95] </ref>. We discussed this in detail in Section 3.3 above. Another source of inspiration for this work was Castagnas paper on covariance and contravariance [Castagna 95]. <p> Second, our model maintains class-based encapsulation, keeping the semantics of objects as self-interpreting records. The generic function model gives this up and must base encapsulation on scoping constructs, such as packages [Chapter 11, Steele 90] or local declarations [Chambers & Leavens 97]. 4.2 Encapsulated and Parasitic Multimethods Encapsulated multimethods <ref> [Section 4.2.2, Bruce et al. 95] </ref> [Section 3.1.11, Castagna 97] are similar in spirit to our work in their attempt to integrate multimethods into existing singly-dispatched languages.
Reference: [Cardelli 88] <author> Luca Cardelli. </author> <title> A Semantics of Multiple Inheritance. </title> <journal> Information and Computation, </journal> 76(2/3):138-164, February/March, 1988. An earlier version appeared in the 1984 Semantics of Data Types Symposium, LNCS <volume> 173, </volume> pp. <pages> 51-66, </pages> Springer-Verlag, 1984. 
Reference-contexts: The class type, CN, where CN is a class name, is the type of instances of the class CN. Types are related by a simple subtyping relation. The types int and bool are only subtypes of themselves. The ordinary contravariant subtyping rule is used for function types <ref> [Cardelli 88] </ref>. A class type CN 1 is a subtype of another class type CN 2 if the class CN 1 is a subclass of the class CN 2 .
Reference: [Castagna et al. 92] <author> Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. </author> <title> A Calculus for Overloaded Functions with Subtyping. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <address> San Francisco, </address> <month> June, </month> <year> 1992, </year> <pages> pp. 182-192, </pages> <booktitle> volume 5, number 1 of LISP Pointers. ACM, </booktitle> <address> New York, January-March, </address> <year> 1992. </year>
Reference-contexts: The problem is that there exist two such tuple classes, and neither is more specific than the other. Therefore, at run-time such a method invocation will cause a method-ambiguous error to occur. Our solution is based on prior work on type checking for multimethods <ref> [Castagna et al. 92, Castagna 95] </ref>. For each pair of tuple classes (T 1 ,...,T n ) and (T 1 ,...,T n ) that have a 6 method named I that accepts k additional arguments, we check two conditions.
Reference: [Castagna 95] <author> Giuseppe Castagna. </author> <title> Covariance and contravariance: conict without a cause. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3) </volume> <pages> 431-447, </pages> <year> 1995. </year> <note> See also [Chapter 5, Castagna 97]. </note>
Reference-contexts: It stems from the asymmetry in the treatment of the two Point instances being tested for equality. In particular, one instance is the message receiver and is thereby dynamically dispatched upon, while the other is an ordinary argument to the message and plays no role in method selection <ref> [Castagna 95] </ref>. Multiple dispatch avoids this asymmetry by dynamically dispatching based on the run-time class of both arguments. A more general problem is the visitor design pattern [Pages 331-344, Gamma et al. 95]. This pattern consists of a hierarchy of classes, typically representing the elements of a structure. <p> The problem is that there exist two such tuple classes, and neither is more specific than the other. Therefore, at run-time such a method invocation will cause a method-ambiguous error to occur. Our solution is based on prior work on type checking for multimethods <ref> [Castagna et al. 92, Castagna 95] </ref>. For each pair of tuple classes (T 1 ,...,T n ) and (T 1 ,...,T n ) that have a 6 method named I that accepts k additional arguments, we check two conditions. <p> We discussed this in detail in Section 3.3 above. Another source of inspiration for this work was Castagnas paper on covariance and contravariance <ref> [Castagna 95] </ref>. This makes clear the key idea that covariance is used for all arguments that are involved in method lookup and contravariance for all arguments that are not involved in lookup.
Reference: [Castagna 97] <author> Giuseppe Castagna. </author> <title> Object-Oriented Programming A Unified Foundation. </title> <address> Birkhuser, Boston, </address> <year> 1997. </year>
Reference-contexts: Multiple dispatch is in many ways more expressive and exible than single dispatch in object-oriented (OO) programming <ref> [Bobrow et al. 86, Chambers 92, Castagna 97, Moon 86] </ref>. In this paper we propose a new, simple, and orthogonal way of adding multiple dispatch to existing languages with single dispatch. The idea is to add tuples as primitive expressions and to allow messages to be sent to tuples. <p> The generic function model gives this up and must base encapsulation on scoping constructs, such as packages [Chapter 11, Steele 90] or local declarations [Chambers & Leavens 97]. 4.2 Encapsulated and Parasitic Multimethods Encapsulated multimethods [Section 4.2.2, Bruce et al. 95] <ref> [Section 3.1.11, Castagna 97] </ref> are similar in spirit to our work in their attempt to integrate multimethods into existing singly-dispatched languages.
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <editor> In O. Lehrmann-Madsen, editor, </editor> <booktitle> ECOOP 92 Conference Proceedings, </booktitle> <address> Utrecht, the Netherlands, June/July, </address> <year> 1992, </year> <booktitle> volume 615 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 33-56. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Multiple dispatch, as found in CLOS [Chapter 28, Steele 90] [Paepcke 93], Dylan [Shalit 97, Feinberg et al. 97], and Cecil <ref> [Chambers 92, Chambers 95] </ref>, generalizes this idea, selecting a method based on the dynamic class of any subset of the messages arguments. Multiple dispatch is in many ways more expressive and exible than single dispatch in object-oriented (OO) programming [Bobrow et al. 86, Chambers 92, Castagna 97, Moon 86]. <p> Multiple dispatch is in many ways more expressive and exible than single dispatch in object-oriented (OO) programming <ref> [Bobrow et al. 86, Chambers 92, Castagna 97, Moon 86] </ref>. In this paper we propose a new, simple, and orthogonal way of adding multiple dispatch to existing languages with single dispatch. The idea is to add tuples as primitive expressions and to allow messages to be sent to tuples. <p> In particular, any client could access the fields of instances of a class C simply by creating a tuple class with C as a component. 3.2 Multiple Dispatch is not just for Binary Methods Multimethods are useful in many common situations other than binary methods <ref> [Chambers 92, Baumgarter et al. 96] </ref>. In particular, any time the piece of code to invoke depends on more than one argument to the message, a multimethod easily provides the desired semantics. For example, suppose one wants to print points to output devices.
Reference: [Chambers 95] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale: </title> <type> Version 2.0. </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> December, </month> <year> 1995. </year> <note> http:// www.cs.washington.edu/research/projects/cecil/www/ Papers/cecil-spec.html </note>
Reference-contexts: Multiple dispatch, as found in CLOS [Chapter 28, Steele 90] [Paepcke 93], Dylan [Shalit 97, Feinberg et al. 97], and Cecil <ref> [Chambers 92, Chambers 95] </ref>, generalizes this idea, selecting a method based on the dynamic class of any subset of the messages arguments. Multiple dispatch is in many ways more expressive and exible than single dispatch in object-oriented (OO) programming [Bobrow et al. 86, Chambers 92, Castagna 97, Moon 86]. <p> The use of dynamic classes distinguishes multiple dispatch from static overloading (as found, for example, in Ada 83 [Ada 83]). The semantics of sending messages to tuples, multiple dispatch, is similar to that in Cecil <ref> [Chambers 95] </ref>. Consider the expression (E 1 ,...,E n ).I (E n+1 ,...,E m ), where each E i has value v i , and where C d,i is the minimal dynamic class of v i . <p> Another possibility would be to maintain by-name typing but keep this typing and the associated subtyping relation completely orthogonal to the class and inheritance mechanisms. This is the approach taken in Cecil <ref> [Chambers 95] </ref>. We ruled out these designs for the sake of clarity and simplicity. Another design choice is whether to dispatch on classes or on types. In Tuple, this choice does not arise because of the strong correlation between classes and types.
Reference: [Chambers & Leavens 95] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and Modules for Multi-Methods. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(6) </volume> <pages> 805-843. </pages> <month> November, </month> <year> 1995. </year>
Reference-contexts: Because of the multiple dispatching involved, type checking messages sent to tuples is a bit more complex than checking messages sent to instances (see Appendix B for the formal typing rules). We divide the additions to SDCores type system into client-side and implementation-side rules <ref> [Chambers & Leavens 95] </ref>. The client-side rules check messages sent to tuples, while the implementation-side rules check tuple class declarations and their methods. <p> Therefore, a link-time check is necessary to ensure type safety. Research is underway to resolve this problem for generic function languages <ref> [Chambers & Leavens 95] </ref>, which would also resolve it for Tuple. However, to date no completely satisfactory solution has emerged. The design choices of encapsulated and parasitic multimethods were largely motivated by the goal of avoiding this loss of modularity.
Reference: [Chambers & Leavens 97] <author> Craig Chambers and Gary T. Leavens. BeCecil, </author> <title> A Core Object-Oriented Language with Block Structure and Multimethods: Semantics and Typing. </title> <institution> Department of Computer Science, Iowa State University, TR #96-17a, </institution> <month> April </month> <year> 1997. </year> <note> ftp:// ftp.cs.iastate.edu/pub/techreports/TR96-17/TR.ps.Z; the appendix sections only are in ftp://ftp.cs.iastate.edu/pub/ techreports/TR96-17/appendix.ps.Z. </note>
Reference-contexts: Second, our model maintains class-based encapsulation, keeping the semantics of objects as self-interpreting records. The generic function model gives this up and must base encapsulation on scoping constructs, such as packages [Chapter 11, Steele 90] or local declarations <ref> [Chambers & Leavens 97] </ref>. 4.2 Encapsulated and Parasitic Multimethods Encapsulated multimethods [Section 4.2.2, Bruce et al. 95] [Section 3.1.11, Castagna 97] are similar in spirit to our work in their attempt to integrate multimethods into existing singly-dispatched languages.
Reference: [Cook et al. 90] <author> William Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not Subtyping. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, California, </address> <pages> pp 125-135. </pages> <publisher> ACM, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: () - - class ColorPoint inherits Point - ... method equal (p:ColorPoint):bool -- a type error in SDCore - (xval = p.x () and yval = p.y ()) and colorval.equal (p.color ()) - - As is well-known, this makes it impossible for ColorPoint to be considered a subtype of Point <ref> [Cook et al. 90] </ref>. In other words, ColorPoint instances cannot be safely used wherever a Point is expected, so polymorphism on the point hierarchy is lost. (For this reason the example is ill-typed in SDCore.) The problem is semantic, and not a fault of the SDCore type system.
Reference: [Cook 90] <author> William Cook. </author> <title> Object-Oriented Programming versus Abstract Data Types. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop Proceedings, Noordwijkerhout, the Netherlands, May/June, 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 151-178. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Encapsulated and parasitic multimethods have an advantage in terms of modularity over both generic-function languages and Tuple. The modularity problem of generic-function languages, noted by Cook <ref> [Cook 90] </ref>, is that independently-developed program modules, each of which is free of the possibility of message-ambiguous errors, may cause message-ambiguous errors at run-time.
Reference: [Ernst et al. 98] <author> Michael D. Ernst, Craig Kaplan, and Craig Chambers. </author> <title> Predicate Dispatching: A Unified Theory of Dispatch. </title> <booktitle> To appear in ECOOP '98, the 12th European Conference on Object-Oriented Programming, </booktitle> <address> Brussels, Belgium, </address> <month> July, </month> <year> 1998. </year> <note> Also http://www.cs.washington.edu/ research/projects/cecil/www/www/Papers/gud.html. </note>
Reference-contexts: It is interesting to speculate about the advantages that might be obtained by adding algebraic datatypes and more extensive pattern-matching features to object-oriented languages (see also <ref> [Bourdoncle & Merz 97, Ernst et al. 98] </ref>). 4 RELATED WORK In this section we discuss two kinds of related work. The first concerns generic-function languages; while these do not solve the problem we address in this paper, using such a language is a way to obtain multiple dispatch.
Reference: [Feinberg et al. 97] <author> Neal Feinberg, Sonya E. Keene, Robert O. Mathews, and P. Tucker Withington. </author> <title> The Dylan Programming Book. </title> <publisher> Addison-Wesley Longman, </publisher> <address> Reading, Mass., </address> <year> 1997. </year>
Reference-contexts: Multiple dispatch, as found in CLOS [Chapter 28, Steele 90] [Paepcke 93], Dylan <ref> [Shalit 97, Feinberg et al. 97] </ref>, and Cecil [Chambers 92, Chambers 95], generalizes this idea, selecting a method based on the dynamic class of any subset of the messages arguments.
Reference: [Gamma et al. 95] <author> Erich Gamma and Richard Helm and Ralph Johnson and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass., </address> <year> 1995. </year>
Reference-contexts: Multiple dispatch avoids this asymmetry by dynamically dispatching based on the run-time class of both arguments. A more general problem is the visitor design pattern <ref> [Pages 331-344, Gamma et al. 95] </ref>. This pattern consists of a hierarchy of classes, typically representing the elements of a structure. In order to define new operations on these elements without modifying the element classes, a separate hierarchy of visitors is created, one per operation.
Reference: [Goguen & Meseguer 87] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Order-Sorted Algebra Solves the Constructor-Selector, Multiple Representation and Coercion Problems. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <pages> pp. 18-29. </pages> <publisher> IEEE Press, </publisher> <address> NY, </address> <month> June, </month> <year> 1987. </year>
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: 1 INTRODUCTION Single dispatch, as found in C++ [Stroustrup 97], Java [Arnold & Gosling 98, Gosling et al. 96], Smalltalk-80 <ref> [Goldberg & Robson 83] </ref>, and Eiffel [Meyer 92, Meyer 97], selects a method using the dynamic class of one object, the messages receiver.
Reference: [Gosling et al. 96] <author> James Gosling, Bill Joy, Guy Steele, Guy L. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass., </address> <year> 1996. </year>
Reference-contexts: 1 INTRODUCTION Single dispatch, as found in C++ [Stroustrup 97], Java <ref> [Arnold & Gosling 98, Gosling et al. 96] </ref>, Smalltalk-80 [Goldberg & Robson 83], and Eiffel [Meyer 92, Meyer 97], selects a method using the dynamic class of one object, the messages receiver.
Reference: [Ingalls 86] <author> D. H. H. Ingalls. </author> <title> A Simple Technique for Handling Multiple Polymorphism. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> OOPSLA 86 Conference Proceedings, </booktitle> <address> Portland, Oregon, </address> <month> November, </month> <year> 1986, </year> <title> volume 21, </title> <journal> number 11 of ACM SIGPLAN Notices, </journal> <pages> pp. 347-349. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> October, </month> <year> 1986. </year>
Reference-contexts: The problem is that we need to invoke the appropriate method based on both whether the first argument is a Point or ColorPoint and whether the second argument is a Terminal, Printer, or ColorPrinter. In a singly-dispatched language, an unnatural work-around such as Ingallss double dispatching technique <ref> [Ingalls 86, Bruce et al. 95] </ref> is required to encode the desired behavior. 3.3 Tuples vs. Classes The ability to express multiple dispatching via dispatching on tuples is not easy to simulate in a single-dispatching language, as is well-known [Bruce et al. 95]. <p> For example, since ColorPoint overrides the equal generic function in Point, it must duplicate the equal method declared within the Point class. As observed in the Bruce et al. paper, this is akin to the Ingalls technique for multiple polymorphism <ref> [Ingalls 86] </ref>. Parasitic multimethods [Boyland & Castagna 97], a variant of encapsulated multimethods, remove this disadvantage by allowing parasitic methods to be inherited. The second problem caused by the two dispatches is that existing classes sometimes need to be modified when new subclasses are added to the system.
Reference: [Kiczales & Rodriguez 93] <author> Gregor Kiczales and Luis H. Rodriguez Jr. </author> <title> Efficient Method Dispatch in PCL. </title> <note> In [Paepcke 93], Chapter 14. </note>
Reference-contexts: If there are applicable methods but no most-specific one, a message-ambiguous error occurs. Algorithms for efficiently implementing multiple dispatch exist (see, e.g., <ref> [Kiczales & Rodriguez 93] </ref>). This semantics immediately justifies part 1 (a) of our claim for the orthogonality of the multiple dispatch mechanism. An SDCore expression cannot send a message to a tuple.
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year> <month> 10 </month>
Reference-contexts: 1 INTRODUCTION Single dispatch, as found in C++ [Stroustrup 97], Java [Arnold & Gosling 98, Gosling et al. 96], Smalltalk-80 [Goldberg & Robson 83], and Eiffel <ref> [Meyer 92, Meyer 97] </ref>, selects a method using the dynamic class of one object, the messages receiver.
Reference: [Meyer 97] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. Second Edition, </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1997. </year>
Reference-contexts: 1 INTRODUCTION Single dispatch, as found in C++ [Stroustrup 97], Java [Arnold & Gosling 98, Gosling et al. 96], Smalltalk-80 [Goldberg & Robson 83], and Eiffel <ref> [Meyer 92, Meyer 97] </ref>, selects a method using the dynamic class of one object, the messages receiver.
Reference: [Milner et al. 90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: The syntax for sending a message to a tuple is analogous to that for sending a message to an instance. For example, (p1,p2).equal () sends the message equal () to the tuple (p1,p2), which will invoke one of the two * As in ML <ref> [Milner et al. 90] </ref>, we do not allow tuples of length one. This prevents ambiguity in the syntax and semantics. For example, an expression such as (x).g (y) is interpreted as a message sent to an instance, not to a tuple. Tuples have either zero, or two or more elements. <p> The names of the tuple formals in a tuple class are, in a sense, a generalization of self for a tuple. They also allow a very simple form of the pattern matching found in functional languages such as ML <ref> [Milner et al. 90] </ref>. Having the tuple formals be bound to the elements of the tuple allows Tuple, like ML, to include tuple values without needing to build into the language primitive operations to extract the components of a tuple.
Reference: [Moon 86] <author> David A. Moon. </author> <title> Object-Oriented Programming with Flavors. </title> <editor> In Norman Meyrowitz (editor), </editor> <booktitle> OOPSLA 86 Conference Proceedings, </booktitle> <address> Portland, Oregon, </address> <month> September </month> <year> 1986, </year> <title> volume 21, </title> <journal> number 11 of ACM SIGPLAN Notices, </journal> <pages> pp. 1-8. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> November, </month> <year> 1986. </year>
Reference-contexts: Multiple dispatch is in many ways more expressive and exible than single dispatch in object-oriented (OO) programming <ref> [Bobrow et al. 86, Chambers 92, Castagna 97, Moon 86] </ref>. In this paper we propose a new, simple, and orthogonal way of adding multiple dispatch to existing languages with single dispatch. The idea is to add tuples as primitive expressions and to allow messages to be sent to tuples.
Reference: [Paepcke 93] <author> Andreas Paepcke. </author> <title> Object-Oriented Programming: The CLOS Perspective. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Multiple dispatch, as found in CLOS [Chapter 28, Steele 90] <ref> [Paepcke 93] </ref>, Dylan [Shalit 97, Feinberg et al. 97], and Cecil [Chambers 92, Chambers 95], generalizes this idea, selecting a method based on the dynamic class of any subset of the messages arguments.
Reference: [Reynolds 80] <author> John C. Reynolds. </author> <title> Using Category Theory to Design Implicit Conversions and Generic Operators. </title> <editor> In Neil D. Jones (editor), </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, </booktitle> <pages> pp. 211-258. </pages> <booktitle> Volume 94 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1980. </year>
Reference: [Schmidt 94] <author> David A. Schmidt. </author> <title> The Structure of Typed Programming Languages. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference: [Shalit 97] <author> Andrew Shalit. </author> <title> The Dylan Reference Manual: The Definitive Guide to the New Object-Oriented Dynamic Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1997. </year>
Reference-contexts: Multiple dispatch, as found in CLOS [Chapter 28, Steele 90] [Paepcke 93], Dylan <ref> [Shalit 97, Feinberg et al. 97] </ref>, and Cecil [Chambers 92, Chambers 95], generalizes this idea, selecting a method based on the dynamic class of any subset of the messages arguments.
Reference: [Steele 90] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language (second edition). </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1990. </year>
Reference-contexts: 1 INTRODUCTION Single dispatch, as found in C++ [Stroustrup 97], Java [Arnold & Gosling 98, Gosling et al. 96], Smalltalk-80 [Goldberg & Robson 83], and Eiffel [Meyer 92, Meyer 97], selects a method using the dynamic class of one object, the messages receiver. Multiple dispatch, as found in CLOS <ref> [Chapter 28, Steele 90] </ref> [Paepcke 93], Dylan [Shalit 97, Feinberg et al. 97], and Cecil [Chambers 92, Chambers 95], generalizes this idea, selecting a method based on the dynamic class of any subset of the messages arguments. <p> Second, our model maintains class-based encapsulation, keeping the semantics of objects as self-interpreting records. The generic function model gives this up and must base encapsulation on scoping constructs, such as packages <ref> [Chapter 11, Steele 90] </ref> or local declarations [Chambers & Leavens 97]. 4.2 Encapsulated and Parasitic Multimethods Encapsulated multimethods [Section 4.2.2, Bruce et al. 95] [Section 3.1.11, Castagna 97] are similar in spirit to our work in their attempt to integrate multimethods into existing singly-dispatched languages.

Reference: [self] <institution> (p,cs,ts) |- self : T exp where (self:T) p </institution>

References-found: 37

