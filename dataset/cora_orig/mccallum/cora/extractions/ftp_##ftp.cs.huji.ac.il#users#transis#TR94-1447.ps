URL: ftp://ftp.cs.huji.ac.il/users/transis/TR94-1447.ps
Refering-URL: http://www.cs.huji.ac.il/labs/transis/abstracts94.html
Root-URL: http://www.cs.huji.ac.il
Title: Uniform Actions in Asynchronous Distributed Systems  
Author: Dalia Malki Ken Birman Aleta Ricciardi Andre Schiper TR - 
Affiliation: Department of Computer Science, Cornell University  
Abstract: We develop necessary conditions for the development of asynchronous distributed software that will perform uniform actions (events that if performed by any process, must be performed at all processes). The paper focuses on dynamic uniformity, which differs from the classical problems in that processes continually leave and join the ongoing computation. Here, we first treat a static version of the problem (lacking joins), and then extend the results so obtained to also include joins. Our results demonstrate that in contrast to Consensus, which cannot be solved in asynchronous systems with even a single faulty process, dynamic uniformity can be solved using a failure detection mechanism that makes bounded numbers of mistakes. Because dynamic uniformity arises in systems that maintain safety within a "primary partition" of a network, our paper provides a rigorous characterization of the framework upon which several existing distributed programming environments are based.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. Transis: </author> <title> A Communication Sub-System for High Availability. </title> <booktitle> In 22nd Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 76-84, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Our work on fault-tolerant distributed systems (Isis [5], Transis <ref> [1, 14] </ref>, and Horus [20]) gives rise to a desire to understand the theoretical foundations upon which such systems depend. These systems all use the virtual synchrony programming model [3], so it may not be surprising that they employ similar lower-level mechanisms.
Reference: [2] <author> Rida Bazzi and Gil Neiger. </author> <title> The Possibility and the Complexity of Achieving Fault-Tolerant Coordination. </title> <booktitle> In Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <volume> number 11, </volume> <pages> pages 203-214, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: We believe that Dynamic Uniformity (D-Uniformity) is the fundamental property required for many applications in asynchronous settings. Recently, focus has been drawn to uniform, or consistent, coordination, a strengthening of traditional agreement problems <ref> [15, 2, 12] </ref>. In non-uniform agreement, faulty processes are never required to behave consistently with their cohorts, even before they commit a fault.
Reference: [3] <author> K. P. Birman. </author> <title> Reliable Distributed Computing with the Isis Toolkit, chapter Virtual Synchrony Model. </title> <publisher> IEEE Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Our work on fault-tolerant distributed systems (Isis [5], Transis [1, 14], and Horus [20]) gives rise to a desire to understand the theoretical foundations upon which such systems depend. These systems all use the virtual synchrony programming model <ref> [3] </ref>, so it may not be surprising that they employ similar lower-level mechanisms. <p> Moreover, this solution does not set a total order on process additions, nor guarantees the virtually synchronous execution model, in which process additions are totally ordered with respect to regular actions in the system (see <ref> [3] </ref> for a precise definition of the virtual synchrony model). For example, Figure 6 depicts a "disordered" scenario, in which processes p and r perform a process addition (of t) and a regular action (fi) in different orders.
Reference: [4] <author> K. P. Birman and T. Joseph. </author> <title> Exploiting Virtual Synchrony in Distributed Systems. </title> <booktitle> In 11th Ann. Symp. Operating Systems Principles, </booktitle> <pages> pages 123-138, </pages> <month> Nov 87. </month>
Reference: [5] <author> K. P. Birman and R. van Renesse. </author> <title> Reliable Distributed Computing with the Isis Toolkit. </title> <publisher> IEEE Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Our work on fault-tolerant distributed systems (Isis <ref> [5] </ref>, Transis [1, 14], and Horus [20]) gives rise to a desire to understand the theoretical foundations upon which such systems depend. These systems all use the virtual synchrony programming model [3], so it may not be surprising that they employ similar lower-level mechanisms.
Reference: [6] <author> T. D. Chandra, V. Hadzilacos, and S. Toueg. </author> <title> The Weakest Failure Detector for Solving Consensus. </title> <booktitle> In proc. 11th annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 147-158, </pages> <year> 1992. </year>
Reference-contexts: We use the definition from <ref> [6] </ref> to compare membership services. Definition 1 (Chandra & Toueg) Let MS and MS 0 be membership services. MS is weaker than MS 0 if there is a protocol that, using MS 0 , can implement MS.
Reference: [7] <author> T. D. Chandra and S. Toueg. </author> <title> Unreliable Failure Detectors for Asynchronous Systems. </title> <booktitle> In proc. 10th annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 325-340, </pages> <year> 1991. </year>
Reference-contexts: In much prior work, Consensus has been considered the basic problem in achieving distributed coordination [16]. For example, Chandra and Toueg show that Consensus is equivalent to both fault detection and to atomic broadcast <ref> [7] </ref>. It is well known that Consensus has no solution in asynchronous environments in which even a single process may crash [11]. 1 Systems like Isis, Transis and Horus are unable to detect failures accurately, so unresponsive processes are excluded from participation in the system, as if they had crashed. <p> If communication to such a process is reestablished, it rejoins the system under a new process identifier. 2 While similar in role to a failure detector <ref> [7] </ref>, a membership service reports several types of membership events (e.g., joins, and leaves) in addition to suspected failures. 2 In contrast, our work shows D-Uniformity is strictly weaker than Consensus when all but two processes may crash, and as hard as Consensus only when all but one process may crash. <p> Now define ^c to be identical to c 0 except that p's history component in ^c terminates with the event crash p . This cut violates Lemma 4.1. (Figure 2 depicts such a bad scenario, with t = 1). As in <ref> [7] </ref> a membership service makes a mistake if and only if it removes a non-faulty process from the local view of some process. <p> Therefore, the information about fi will eventually propagate to all the live processes. If removals are stable, a WMS (t1) membership service can make t1 mistakes per process, or N fi (t1) mistakes globally. In <ref> [7] </ref> it is shown that for t &gt; 1, such a failure detector is not strong enough to solve consensus when f dN=2e. 8 When removals are not permanent, WMS (t1) can make infinitely may mistakes both about and to any process. <p> Lemma 4.5 The consensus problem is reducible to N 1-resilient D-Uniformity. Proof: A solution to N 1-resilient D-Uniformity requires a WMS (0). By definition any WMS (0) is a "perfect failure suspector" of <ref> [7] </ref>, and consensus can be solved using the perfect failure suspector.
Reference: [8] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: determining global states of distributed systems. </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: We assume familiarity with inter-event causality and the "happens-before" relation (e ! e 0 ) [13], and with consistent cuts <ref> [8] </ref>. A system run is an n-tuple of infinite process histories, one for each process in S. 5 A cut, then, is a finite prefix of a run.
Reference: [9] <author> K. M. Chandy and J. Misra. </author> <title> How processes learn. </title> <journal> Distributed Computing, </journal> <volume> 1(1) </volume> <pages> 40-52, </pages> <year> 1986. </year>
Reference-contexts: While the set of actions can be described, the specific actions to appear in any execution are not known a priori. Actions will arise at one process, which we model by saying that each action is owned by one process. In the terminology of Chandy and Misra <ref> [9] </ref>, the identity of an action is initially local to its owner, meaning that processes only learn about non-local actions by communicating with (or indirectly with) the action's owner. If fi is an action, let does p (fi) denote the event whereby process p performs fi.
Reference: [10] <author> D. Dolev, D. Malki, and H. R. </author> <title> Strong. An Asynchronous Membership Protocol that Tolerates Partitions. </title> <note> submitted for publication. Available as CS TR94-6, </note> <institution> Institute of Computer Science, the Hebrew University of Jerusalem, </institution> <year> 1994. </year>
Reference-contexts: Process p inserts t into FutureView p , and will therefore delay execution of fi until after t is added to the system. In the practical systems we study, the membership protocols (e.g., <ref> [10, 18] </ref>) require ordering of process additions, and enforce the virtual-synchrony property. Our study has demonstrated that these properties are not required for majority-threshold of uniform activity, and raises the question whether more efficient membership protocols can be developed to support this type of problems.
Reference: [11] <author> M. Fischer, N. Lynch, and M. Paterson. </author> <title> Impossibility of Distributed Consensus with One Faulty Process. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Thus, our work explains how distributed systems can be fault-tolerant "despite" the result of Fischer, Lynch and Patterson <ref> [11] </ref>: they can do so provided that the failure detection mechanism employed is sufficiently accurate (though it need not be as accurate as the failure detector needed to solve Consensus). In much prior work, Consensus has been considered the basic problem in achieving distributed coordination [16]. <p> For example, Chandra and Toueg show that Consensus is equivalent to both fault detection and to atomic broadcast [7]. It is well known that Consensus has no solution in asynchronous environments in which even a single process may crash <ref> [11] </ref>. 1 Systems like Isis, Transis and Horus are unable to detect failures accurately, so unresponsive processes are excluded from participation in the system, as if they had crashed. <p> Unlike D-Uniformity, these problems are evidently equivalent in difficulty to the Consensus problem. Generally, therefore, the conditions under which these systems guarantee progress in all layers may still be subject to the basic impossibility result of Fischer, Lynch and Patterson <ref> [11] </ref>. The analysis provided here gives the necessary and sufficient conditions for the lower level services only. Whether these services, by themselves, are of use for solving "interesting" coordination problems, is something yet to be studied. 2 System Model The system consists of a finite set S of process identifiers. <p> Corollary 3.2 D-Uniformity is strictly weaker than distributed consensus. Proof: Lemma 3.1 shows that D-Uniformity has solutions in an environment in which the consensus problem is unsolvable <ref> [11] </ref>. To see that D-Uniformity is solvable whenever consensus is solvable, assume consensus (val) is a multi-valued consensus atom. 6 That is, at each correct process, the consensus atom returns, in finite time, the same value.
Reference: [12] <author> Ajei Gopal. </author> <title> Fault-Tolerant Broadcasts and Multicasts: The Problem of Inconsistency and Contamination. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1992. </year>
Reference-contexts: We believe that Dynamic Uniformity (D-Uniformity) is the fundamental property required for many applications in asynchronous settings. Recently, focus has been drawn to uniform, or consistent, coordination, a strengthening of traditional agreement problems <ref> [15, 2, 12] </ref>. In non-uniform agreement, faulty processes are never required to behave consistently with their cohorts, even before they commit a fault.
Reference: [13] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Comm. ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: The initial system cut, c 0 , consists only of all the start p events (this will be discussed again in Section 5 to accommodate processes joining later in the computation). We assume familiarity with inter-event causality and the "happens-before" relation (e ! e 0 ) <ref> [13] </ref>, and with consistent cuts [8]. A system run is an n-tuple of infinite process histories, one for each process in S. 5 A cut, then, is a finite prefix of a run.
Reference: [14] <author> D. Malki, Y. Amir, D. Dolev, and S. Kramer. </author> <title> The Transis Approach to High Availability Cluster Communication. </title> <type> TR 94-14, </type> <institution> Inst. of Comp. Sci., The Hebrew University of Jerusalem, </institution> <month> June </month> <year> 1994. </year> <note> submitted for publication. </note>
Reference-contexts: 1 Introduction Our work on fault-tolerant distributed systems (Isis [5], Transis <ref> [1, 14] </ref>, and Horus [20]) gives rise to a desire to understand the theoretical foundations upon which such systems depend. These systems all use the virtual synchrony programming model [3], so it may not be surprising that they employ similar lower-level mechanisms.
Reference: [15] <author> Gil Neiger and Mark Tuttle. </author> <title> Common Knowledge and Consistent Simultaneous Coordination. </title> <booktitle> In 4th Intl. Workshop on Distributed Algorithms proceedings (WDAG-6), (LNCS, </booktitle> <volume> 486), number 4, </volume> <pages> pages 335-352, </pages> <year> 1990. </year>
Reference-contexts: We believe that Dynamic Uniformity (D-Uniformity) is the fundamental property required for many applications in asynchronous settings. Recently, focus has been drawn to uniform, or consistent, coordination, a strengthening of traditional agreement problems <ref> [15, 2, 12] </ref>. In non-uniform agreement, faulty processes are never required to behave consistently with their cohorts, even before they commit a fault.
Reference: [16] <author> M. Pease, R. Shostak, and L. Lamport. </author> <title> Reaching Agreement in the Presence of Faults. </title> <journal> Journal of ACM, </journal> <volume> 27(2) </volume> <pages> 228-234, </pages> <year> 1980. </year>
Reference-contexts: Our first result shows that D-Uniformity is achievable provided that a majority of the processes do not crash. Thus, dynamic uniformity is a problem for which coordinating the activity of only a majority of the processes suffices, and is therefore strictly weaker than Distributed Consensus <ref> [16] </ref>. We then explore the effect of adding a membership service to our asynchronous environment. <p> In much prior work, Consensus has been considered the basic problem in achieving distributed coordination <ref> [16] </ref>. For example, Chandra and Toueg show that Consensus is equivalent to both fault detection and to atomic broadcast [7].
Reference: [17] <author> A. Ricciardi. </author> <title> The Group Membership Problem in Asynchronous Systems. </title> <type> PhD thesis, </type> <institution> dept. of Computer Science, Cornell University, </institution> <month> November </month> <year> 1992. </year> <type> (TR 92-1313). </type>
Reference-contexts: Without further constraints, this membership service is unsafe for the purposes of D-Uniformity, even in failure-free runs. Another example membership service might maintain agreement about suspected failures (e.g., the service described in <ref> [17] </ref>). The advantage of such a service is that the protocol in Informally, this is done by successively reconfiguring the system into decreasing majority sets.
Reference: [18] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Using Process Groups to Implement Failure Detection in Asynchronous Environments. </title> <booktitle> In proc. annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 341-352, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Process p inserts t into FutureView p , and will therefore delay execution of fi until after t is added to the system. In the practical systems we study, the membership protocols (e.g., <ref> [10, 18] </ref>) require ordering of process additions, and enforce the virtual-synchrony property. Our study has demonstrated that these properties are not required for majority-threshold of uniform activity, and raises the question whether more efficient membership protocols can be developed to support this type of problems.
Reference: [19] <author> A. Schiper and A. Sandoz. </author> <title> Uniform Reliable Multicast in a Virtually Synchronous Environment. </title> <booktitle> In IEEE Proc. of the 13th Intl. Conf. on Distributed Computing Systems, </booktitle> <pages> pages 561-568, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Our work also sheds light on the protocol obligations for fault-tolerant distributed systems that operate in asynchronous environments. Finally, dynamic uniformity has implications for the implementation of uniform reliable multicast protocols, such as the protocols in <ref> [19] </ref> and the safe protocols of the Transis system. Acknowledgments We benefited from many discussions with Danny Dolev throughout this work, and accepted his valuable suggestions to the protocols and formulations in Section 5. We thank Fred Schneider for helpful comments on earlier versions of this paper.
Reference: [20] <author> R. van Renesse, K. P. Birman, R. Cooper, B. Glade, and P. Stephenson. </author> <title> Reliable Multicast between Microkernels. </title> <booktitle> In Proceedings of the USENIX workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 27-28, </pages> <month> April </month> <year> 1992. </year> <month> 20 </month>
Reference-contexts: 1 Introduction Our work on fault-tolerant distributed systems (Isis [5], Transis [1, 14], and Horus <ref> [20] </ref>) gives rise to a desire to understand the theoretical foundations upon which such systems depend. These systems all use the virtual synchrony programming model [3], so it may not be surprising that they employ similar lower-level mechanisms.
References-found: 20

