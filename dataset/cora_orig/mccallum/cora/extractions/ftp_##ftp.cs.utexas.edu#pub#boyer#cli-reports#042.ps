URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/042.ps
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/nqthm/nqthm-bibliography.html
Root-URL: http://www.cs.utexas.edu
Phone: (512) 322-9951  
Title: Addition of Free Variables to the PC-NQTHM Interactive Enhancement of the Boyer-Moore Theorem Prover  
Author: Matt Kaufmann 
Note: This research was supported in part by ONR Contract N00014-88-C-0454. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Office of Naval Research or the U.S. Government.  
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  
Date: #42 May, 1989 (revised March, 1990)  
Pubnum: Technical Report  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Matt Kaufmann, </author> <title> ``A User's Manual for an Interactive Enhancement to the Boyer-Moore Theorem Prover'', </title> <type> Tech. report 19, </type> <institution> Computational Logic, Inc., </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: 1. Introduction The PC-NQTHM system, also referred to below as ``the proof-checker'', is an interactive enhancement to the Boyer-Moore Theorem Prover (NQTHM). CLI Technical Report 19 <ref> [1] </ref> is a user's manual for PC-NQTHM as it existed in May 1988. Since that time we have, however, added a notion of ``free variables'' to that system. The present report documents changes since May 1988 that involve the addition of free variables to PC-NQTHM. <p> Since that time we have, however, added a notion of ``free variables'' to that system. The present report documents changes since May 1988 that involve the addition of free variables to PC-NQTHM. However, other changes from the version reported in <ref> [1] </ref>, besides those relating to free variables, can be found in the appendix at the end of this report. We assume that the reader has some familiarity with PC-NQTHM, either by way of having used it a little or by way of having looked briefly at the user's manual [1]. <p> in <ref> [1] </ref>, besides those relating to free variables, can be found in the appendix at the end of this report. We assume that the reader has some familiarity with PC-NQTHM, either by way of having used it a little or by way of having looked briefly at the user's manual [1]. The primary motivation behind this extension of PC-NQTHM was a desire to give support to an experimental modification of the Boyer-Moore Theorem Prover that allows first-order quantifiers; see [2]. <p> Roughly speaking, a free variable is one that may be instantiated any way one likes. Let's formalize this notion as follows. Recall from <ref> [1] </ref> that a proof state has the following fields -- except that we now add a new field, called FREE-VARIABLES: A state consists of: INSTRUCTION, CURRENT-TERM, GOVERNORS, CURRENT-ADDR-R, GOAL, OTHER-GOALS, CUMULATIVE-LEMMAS-USED, FREWRITE-DISABLED-RULES, ABBREVIATIONS, and FREE-VARIABLES. <p> To make this notion of soundness a bit more precise, let us recall the following definition from Appendix B of <ref> [1] </ref>. (Disclaimers regarding the sense in which certain issues are avoided may be found in that appendix. They apply here but will not be repeated here.) DEFINITION. <p> state stack that can be produced from an interactive session that begins with a call of the form (VERIFY &lt;term&gt;) and then results from the execution of a sequence of change commands. 4.3 Soundness Theorem We wish to prove the following theorem, which extends the theorem in Appendix B of <ref> [1] </ref> to the setting of the new proof-checker. It implies that in particular, if all the goals have true conclusions at the end of a proof, then the original goal (which of course never has free variables) is a theorem. <p> We will prove this theorem by induction on the length of the valid state stacks. First let us note (without proof) that all commands except INDUCT, PUT, COPY, and GENERALIZE have the following property (which is stronger than the property (*) on p. 56 of the manual, <ref> [1] </ref>): (+) A goal G is replaced by a goal G' (which may equal G) and zero or more new goals GG such that |- GG & G' -&gt; G. <p> = -by the lemma on restricting substitutions and (6)- 0 Q/(s // s ) triv 2 = -by definition of s -2 Q/s 2 21 Appendix A Other Changes In this appendix we document some of the main changes in the current version of PC-NQTHM from the version documented in <ref> [1] </ref>, other than the changes pertaining to free variables (which are already discussed above). The list below provides brief summaries only. The help facility should be used to get more information, e.g. submit (HELP FORWARD) to PC-NQTHM to obtain more information about FORWARD. These are in no particular order. 1. <p> The GENERALIZE command now uses GENERALIZE lemmas (see page 248 of [6]). (Use the help facility for details.) 4. REPEAT has been changed so that if all goals are proved then it's considered a ``success'' (in the sense of ``success'' and ``failure'' for commands, cf. <ref> [1] </ref>). 5. USE has been modified so that it warns the user when uninstantiated variables remain. 6. IFSPLIT is a new command that can be used to case split on the test of an IF expression. 7. BASH no longer automatically prints out the new goals created. <p> It was discovered that Symbolics Lisp machines can throw you into the cold load stream otherwise. (But akcl makes special provisions, which is why I've left the value of this variable at 8 for kcl.) One may feel free to set RESTART-STACK-DEPTH to another integer value, of course; see <ref> [1] </ref> for documentation. 24. The SPLIT command has been made more efficient at the cost of a very slight weakening of the heuristics for checking if the goal is already valid. I'd be surprised if anyone notices any difference here. 25.
Reference: 2. <author> Matt Kaufmann, ``DEFN-SK: </author> <title> An Extension of the Boyer-Moore Theorem Prover to Handle First-Order Quantifiers'', </title> <type> Tech. report 43, </type> <institution> Computational Logic, Inc., </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: The primary motivation behind this extension of PC-NQTHM was a desire to give support to an experimental modification of the Boyer-Moore Theorem Prover that allows first-order quantifiers; see <ref> [2] </ref>. In fact, some appropriate new macro commands have been created and used successfully (also reported in [2]) in the presence of first-order quantifiers; see 3.2 below. <p> The primary motivation behind this extension of PC-NQTHM was a desire to give support to an experimental modification of the Boyer-Moore Theorem Prover that allows first-order quantifiers; see <ref> [2] </ref>. In fact, some appropriate new macro commands have been created and used successfully (also reported in [2]) in the presence of first-order quantifiers; see 3.2 below. <p> the theorem prover if you want it to be able to take maximal advantage of metafunctions. -&gt;: Finally, let us give a little extra attention to the command SK*, which is very convenient to use in conjunction with DEFN-SK (the new Boyer-Moore event currently available in some experimental enhancements, cf. <ref> [2] </ref>). In order for SK* to work, it is necessary that appropriately named lemmas have been proved.
Reference: 3. <author> W.W. Bledsoe, P. Bruell, </author> <title> ``A Man-Machine Theorem-Proving System'', </title> <booktitle> Advance Papers of Third International Joint Conference on Artificial Intelligence, W.W. Bledsoe, </booktitle> <month> 5-1 (Spring) </month> <year> 1974. </year>
Reference-contexts: It contains some details about the exact interaction of free variables with various commands, notably GENERALIZE, that were not so fully given in previous sections. Here's a bit of background. A version of the PUT command appeared in an early natural deduction prover of Bledsoe <ref> [3] </ref>. This prover was incorporated into an early program verification system [4], whose descendent is the current prover for the Gypsy Verification Environment (GVE), [5]. PUT and COPY commands both exist in the current GVE prover, the latter having existed for some 5 years.
Reference: 4. <author> D.I. </author> <title> Good, R.L. London, W.W. Bledsoe, ``An Interactive Program Verification System'', </title> <booktitle> Proceedings of 1975 International Conference on Reliable Software, </booktitle> <institution> D.I. Good, </institution> <year> 1975. </year>
Reference-contexts: Here's a bit of background. A version of the PUT command appeared in an early natural deduction prover of Bledsoe [3]. This prover was incorporated into an early program verification system <ref> [4] </ref>, whose descendent is the current prover for the Gypsy Verification Environment (GVE), [5]. PUT and COPY commands both exist in the current GVE prover, the latter having existed for some 5 years.
Reference: 5. <author> Bill Young, </author> <title> ``Using the GVE: Examples of Proof Commands'', </title> <type> Tech. report 8, </type> <institution> Computational Logic, Inc., </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: Here's a bit of background. A version of the PUT command appeared in an early natural deduction prover of Bledsoe [3]. This prover was incorporated into an early program verification system [4], whose descendent is the current prover for the Gypsy Verification Environment (GVE), <ref> [5] </ref>. PUT and COPY commands both exist in the current GVE prover, the latter having existed for some 5 years. Our inspiration for the proof-checker's version of these commands came from the GVE prover, although we make no claims about similarity of implementation.
Reference: 6. <author> R. S. Boyer and J S. Moore, </author> <title> A Computational Logic Handbook, </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: Free variables and the new built-in commands 2.1 Free variables Our notion of free variables is similar to the notion described for the Boyer-Moore Theorem Prover in <ref> [6] </ref> on pages 235 and 325. Roughly speaking, a free variable is one that may be instantiated any way one likes. Let's formalize this notion as follows. <p> FORWARD has been improved from an earlier version so that it tries to prove the new goals generated and reports which new goals are unproved. 5 3. The GENERALIZE command now uses GENERALIZE lemmas (see page 248 of <ref> [6] </ref>). (Use the help facility for details.) 4. REPEAT has been changed so that if all goals are proved then it's considered a ``success'' (in the sense of ``success'' and ``failure'' for commands, cf. [1]). 5.
Reference: 7. <author> Matt Kaufmann, </author> <title> ``A Mechanically-checked Correctness Proof for Generalization in the Presence of Free Variables'', </title> <type> Tech. report 53, </type> <institution> Computational Logic, Inc., </institution> <note> to appear. Table of Contents </note>
Reference-contexts: When P0 fails, P/s1 reduces to P0, which by this case hypothesis reduces to F (false), and hence by (1) we again have (A). -| GENERALIZE. This part of the soundness proof is necessarily rather technical. A corresponding mechanically-checked proof has been performed using (pc-)nqthm and will appear in <ref> [7] </ref>. First, let us point out a precondition on the success of the GENERALIZE command, as reported by (HELP GENERALIZE): (GENERALIZE ((term1 V1) ... (termn Vn))): Replace each of the given terms by the indicated corresponding new variable, which must not occur anywhere in the current proof state.
Reference: 1. <institution> Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 </institution>
Reference-contexts: 1. Introduction The PC-NQTHM system, also referred to below as ``the proof-checker'', is an interactive enhancement to the Boyer-Moore Theorem Prover (NQTHM). CLI Technical Report 19 <ref> [1] </ref> is a user's manual for PC-NQTHM as it existed in May 1988. Since that time we have, however, added a notion of ``free variables'' to that system. The present report documents changes since May 1988 that involve the addition of free variables to PC-NQTHM. <p> Since that time we have, however, added a notion of ``free variables'' to that system. The present report documents changes since May 1988 that involve the addition of free variables to PC-NQTHM. However, other changes from the version reported in <ref> [1] </ref>, besides those relating to free variables, can be found in the appendix at the end of this report. We assume that the reader has some familiarity with PC-NQTHM, either by way of having used it a little or by way of having looked briefly at the user's manual [1]. <p> in <ref> [1] </ref>, besides those relating to free variables, can be found in the appendix at the end of this report. We assume that the reader has some familiarity with PC-NQTHM, either by way of having used it a little or by way of having looked briefly at the user's manual [1]. The primary motivation behind this extension of PC-NQTHM was a desire to give support to an experimental modification of the Boyer-Moore Theorem Prover that allows first-order quantifiers; see [2]. <p> Roughly speaking, a free variable is one that may be instantiated any way one likes. Let's formalize this notion as follows. Recall from <ref> [1] </ref> that a proof state has the following fields -- except that we now add a new field, called FREE-VARIABLES: A state consists of: INSTRUCTION, CURRENT-TERM, GOVERNORS, CURRENT-ADDR-R, GOAL, OTHER-GOALS, CUMULATIVE-LEMMAS-USED, FREWRITE-DISABLED-RULES, ABBREVIATIONS, and FREE-VARIABLES. <p> To make this notion of soundness a bit more precise, let us recall the following definition from Appendix B of <ref> [1] </ref>. (Disclaimers regarding the sense in which certain issues are avoided may be found in that appendix. They apply here but will not be repeated here.) DEFINITION. <p> state stack that can be produced from an interactive session that begins with a call of the form (VERIFY &lt;term&gt;) and then results from the execution of a sequence of change commands. 4.3 Soundness Theorem We wish to prove the following theorem, which extends the theorem in Appendix B of <ref> [1] </ref> to the setting of the new proof-checker. It implies that in particular, if all the goals have true conclusions at the end of a proof, then the original goal (which of course never has free variables) is a theorem. <p> We will prove this theorem by induction on the length of the valid state stacks. First let us note (without proof) that all commands except INDUCT, PUT, COPY, and GENERALIZE have the following property (which is stronger than the property (*) on p. 56 of the manual, <ref> [1] </ref>): (+) A goal G is replaced by a goal G' (which may equal G) and zero or more new goals GG such that |- GG & G' -&gt; G. <p> = -by the lemma on restricting substitutions and (6)- 0 Q/(s // s ) triv 2 = -by definition of s -2 Q/s 2 21 Appendix A Other Changes In this appendix we document some of the main changes in the current version of PC-NQTHM from the version documented in <ref> [1] </ref>, other than the changes pertaining to free variables (which are already discussed above). The list below provides brief summaries only. The help facility should be used to get more information, e.g. submit (HELP FORWARD) to PC-NQTHM to obtain more information about FORWARD. These are in no particular order. 1. <p> The GENERALIZE command now uses GENERALIZE lemmas (see page 248 of [6]). (Use the help facility for details.) 4. REPEAT has been changed so that if all goals are proved then it's considered a ``success'' (in the sense of ``success'' and ``failure'' for commands, cf. <ref> [1] </ref>). 5. USE has been modified so that it warns the user when uninstantiated variables remain. 6. IFSPLIT is a new command that can be used to case split on the test of an IF expression. 7. BASH no longer automatically prints out the new goals created. <p> It was discovered that Symbolics Lisp machines can throw you into the cold load stream otherwise. (But akcl makes special provisions, which is why I've left the value of this variable at 8 for kcl.) One may feel free to set RESTART-STACK-DEPTH to another integer value, of course; see <ref> [1] </ref> for documentation. 24. The SPLIT command has been made more efficient at the cost of a very slight weakening of the heuristics for checking if the goal is already valid. I'd be surprised if anyone notices any difference here. 25.



References-found: 8

