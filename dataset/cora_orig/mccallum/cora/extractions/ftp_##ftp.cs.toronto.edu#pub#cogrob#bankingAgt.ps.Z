URL: ftp://ftp.cs.toronto.edu/pub/cogrob/bankingAgt.ps.Z
Refering-URL: 
Root-URL: 
Email: lesperan@yorku.ca  fhector,shaneg@ai.toronto.edu  
Phone: 2  
Title: To appear in Intelligent Agent Systems: Theoretical and Practical Issues (Based on a Workshop An
Author: Cavedon, L., Rao, A., and Wobcke, W. Yves Lesperance Hector J. Levesque and Shane J. Ruman 
Address: 2275 Bayview Ave., Toronto, ON, Canada M4N 3M6  Toronto, ON, Canada M5S 1A4  
Affiliation: 1 Department of Computer Science, Glendon College, York University,  Department of Computer Science, University of Toronto  
Note: Held at PRICAI '96 Cairns, Australia, August 1996),  (Eds.), LNAI volume 1209, Springer-Verlag, 1997.  
Abstract: Golog is a new programming language based on a theory of action in the situation calculus that can be used to develop multi-agent applications. The Golog interpreter automatically maintains an explicit model of the agent's environment on the basis of user supplied axioms about the preconditions and effects of actions and the initial state of the environment. This allows agent programs to query the state of the environment and consider the effects of various possible courses of action before deciding how to act. This paper discusses a substantial multi-agent application developed in Golog: a system to support personal banking over computer networks. We describe the overall system and provide more details on the agent that assists the user in responding to changes in his financial situation. The advantages and limitations of Golog for developing multi-agent applications are discussed and various extensions are suggested.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Michael Dixon. </author> <title> Embedded Computation and the Semantics of Programs. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, Stanford, </institution> <address> CA, </address> <year> 1991. </year> <note> Also appeared as Xerox PARC Technical Report SSL-91-1. </note>
Reference-contexts: And this theory is used explicitly by the Golog interpreter. In contrast, an interpreter for an ordinary procedural language does not use its semantics explicitly. Nor do standard semantics of programming languages refer to aspects of the environment in which programs are executed <ref> [1] </ref>. Note that our approach focuses on high-level programming rather than plan synthesis at run-time. But sketchy plans are allowed; nondeterminism can be 6 used to infer the missing details.
Reference: 2. <author> M. Gelfond and Lifschitz. </author> <title> Representing action and change by logic programs. </title> <journal> Journal of Logic Programming, </journal> <pages> 17(301-327), </pages> <year> 1993. </year>
Reference-contexts: The main procedure the agent executes is controlPBA: 6 In this case, the axioms were translated into Prolog clauses by hand. We have been developing a preprocessor that does this automatically. It takes specifications in a high level notation similar to Gelfond and Lifschitz's A <ref> [2] </ref>.
Reference: 3. <author> Andrew R. Haas. </author> <title> The case for domain-specific frame axioms. In F.M. </title> <editor> Brown, editor, </editor> <booktitle> The Frame Problem in Artificial Intelligence: Proceedings of the 1987 Workshop, </booktitle> <pages> pages 343-348, </pages> <publisher> Lawrence, KA, </publisher> <address> April 1987. </address> <publisher> Morgan Kaufmann Publishing. </publisher>
Reference-contexts: Our approach incorporates a treatment of the frame problem due to Reiter [14] (who extends previous proposals by Pednault [12], Schubert [16] and Haas <ref> [3] </ref>). The basic idea behind this is to collect all effect axioms about a given fluent and assume that they specify all the ways the value of the fluent may change.
Reference: 4. <author> Yves Lesperance, Hector J. Levesque, F. Lin, Daniel Marcu, Raymond Reiter, and Richard B. Scherl. </author> <title> A logical approach to high-level robot programming a progress report. In Benjamin Kuipers, editor, Control of the Physical World by Intelligent Agents, </title> <booktitle> Papers from the 1994 AAAI Fall Symposium, </booktitle> <pages> pages 109-119, </pages> <address> New Orleans, LA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Golog is a new logic programming language for developing intelligent systems that are embedded in complex environments and use a model of the environment in deciding how to act <ref> [7, 4] </ref>. It is well suited to programming expert assistants, software agents, and intelligent robots. The language is based on a formal theory of action specified in an extended version of the situation calculus. <p> For a much more complete presentation of Golog, its foundations, and its implementation, we refer the reader to [7]. Prior to the personal banking system documented here, the most substantial application developed in Golog had been a robotics one <ref> [4] </ref>. The robot's task was mail delivery in an office environment. A high-level controller for the robot was programmed in Golog and interfaced to a software package that supports path planning and local navigation.
Reference: 5. <author> Yves Lesperance, Hector J. Levesque, F. Lin, Daniel Marcu, Raymond Reiter, and Richard B. Scherl. </author> <title> Foundations of a logical approach to agent programming. </title> <editor> In M. Wooldridge, J. P. Muller, and M. Tambe, editors, </editor> <booktitle> Intelligent Agents Volume II | Proceedings of the 1995 Workshop on Agent Theories, Architectures, and Languages (ATAL-95), Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 331-346. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Golog does not support interrupts or any other mechanism that would allow the current process to be suspended when an event that requires immediate attention occurs 10 (although the more recent concurrent version of the language, ConGolog, does <ref> [5] </ref>). So to get reactive behavior from the agent, one must explicitly program it to monitor its communications ports, take quick action when a message arrives, and return to monitoring its ports. When a new message arrives, whatever associated actions can be performed immediately are done. <p> Fortunately, an extended version of the language called Con-Golog which supports concurrent processes, priorities, and interrupts is under 15 development. This extended language allows event-driven behavior to be speci-fied very naturally using interrupts. In <ref> [5] </ref>, we describe how ConGolog could be used to develop a simple meeting scheduling application. Finally, there are some significant discrepancies between the Golog implementation and our theories of agency in the way knowledge, sensing, exogenous events, and the relation between planning and execution are treated.
Reference: 6. <author> Hector J. Levesque. </author> <booktitle> What is planning in the presence of sensing? In Proceedings of the Thirteenth National Conference on Artificial Intelligence, </booktitle> <pages> pages 1139-1146, </pages> <address> Portland, OR, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: We would like to develop an account that bridges this gap. The account of planning in the presence of sensing developed in <ref> [6] </ref> is a step towards this.
Reference: 7. <author> Hector J. Levesque, Raymond Reiter, Yves Lesperance, Fangzhen Lin, and Richard B. Scherl. GOLOG: </author> <title> A logic programming language for dynamic domains. </title> <note> To appear in the Journal of Logic Programming, special issue on Reasoning about Action and Change, </note> <year> 1996. </year>
Reference-contexts: 1 Introduction Golog is a new logic programming language for developing intelligent systems that are embedded in complex environments and use a model of the environment in deciding how to act <ref> [7, 4] </ref>. It is well suited to programming expert assistants, software agents, and intelligent robots. The language is based on a formal theory of action specified in an extended version of the situation calculus. <p> The complete definition appears in <ref> [7] </ref>. <p> Note that this is a limitation of the implementation, not the theory. For a much more complete presentation of Golog, its foundations, and its implementation, we refer the reader to <ref> [7] </ref>. Prior to the personal banking system documented here, the most substantial application developed in Golog had been a robotics one [4]. The robot's task was mail delivery in an office environment.
Reference: 8. <author> Fangzhen Lin and Raymond Reiter. </author> <title> How to progress a database (and why) I. logical foundations. </title> <editor> In Jon Doyle, Erik Sandewall, and Pietro Torasso, editors, </editor> <booktitle> Principles of Knowledge Representation and Reasoning: Proceedings of the Fourth International Conference, </booktitle> <pages> pages 425-436, </pages> <address> Bonn, Germany, 1994. </address> <publisher> Morgan Kauf-mann Publishing. </publisher>
Reference-contexts: One can also add directives to Golog programs to force the interpreter to commit when it gets to that point in the program. As well, whenever the interpreter commits and executes part of the program, it rolls its database forward to reflect the execution of the actions <ref> [8, 10] </ref>. We have developed a prototype Golog interpreter that is implemented in Prolog. This implementation requires that the program's precondition axioms, successor state axioms, and axioms about the initial state be expressible as Prolog clauses. Note that this is a limitation of the implementation, not the theory.
Reference: 9. <author> Fangzhen Lin and Raymond Reiter. </author> <title> State constraints revisited. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(5) </volume> <pages> 655-678, </pages> <year> 1994. </year>
Reference-contexts: 2 ; s; s 0 ): Nondeterministic choice of argument: Do (x ffi (x); s; s 0 ) = 9x Do (ffi (x); s; s 0 ): 3 This discussion ignores the ramification and qualification problems; a treatment com patible with our approach has been proposed by Lin and Reiter <ref> [9] </ref>. 4 Nondeterministic iteration: 4 Do (ffi fl ; s; s 0 ) = 8P f 8s 1 ; s 2 ; s 3 [P (s 1 ; s 2 ) ^ Do (ffi; s 2 ; s 3 ) P (s 1 ; s 3 )] g There is another
Reference: 10. <author> Fangzhen Lin and Raymond Reiter. </author> <title> How to progress a database II: The STRIPS connection. </title> <editor> In Chris S. Mellish, editor, </editor> <booktitle> Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 2001-2007, </pages> <address> Montreal, August 1995. </address> <publisher> Morgan Kaufmann Publishing. </publisher> <pages> 16 </pages>
Reference-contexts: One can also add directives to Golog programs to force the interpreter to commit when it gets to that point in the program. As well, whenever the interpreter commits and executes part of the program, it rolls its database forward to reflect the execution of the actions <ref> [8, 10] </ref>. We have developed a prototype Golog interpreter that is implemented in Prolog. This implementation requires that the program's precondition axioms, successor state axioms, and axioms about the initial state be expressible as Prolog clauses. Note that this is a limitation of the implementation, not the theory.
Reference: 11. <author> John McCarthy and Patrick Hayes. </author> <title> Some philosophical problems from the stand-point of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> volume 4, </volume> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <address> UK, </address> <year> 1979. </year>
Reference-contexts: what were the advantages and limitations of Golog for this kind of multi-agent application? We also mention some extensions of Golog that are under development and address some of the limitations encountered. 2 A Theory of Action Golog is based on a theory of action expressed in the situation calculus <ref> [11] </ref>, a predicate calculus dialect for representing dynamically changing worlds. In this framework, the world is taken to be in a certain state (or situation). That state 2 can only change as a result of an action being performed. <p> The above axioms are not sufficient if one wants to reason about change. It is usually necessary to add frame axioms that specify when fluents remain unchanged by actions. The frame problem <ref> [11] </ref> arises because the number of these frame axioms is of the order of the product of the number of fluents and the number of actions.
Reference: 12. <author> E. P. D. Pednault. </author> <title> ADL: Exploring the middle ground between STRIPS and the situation calculus. </title> <editor> In R.J. Brachman, H.J. Levesque, and R. Reiter, editors, </editor> <booktitle> Proceedings of the First International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 324-332, </pages> <address> Toronto, ON, May 1989. </address> <publisher> Morgan Kauf-mann Publishing. </publisher>
Reference-contexts: The frame problem [11] arises because the number of these frame axioms is of the order of the product of the number of fluents and the number of actions. Our approach incorporates a treatment of the frame problem due to Reiter [14] (who extends previous proposals by Pednault <ref> [12] </ref>, Schubert [16] and Haas [3]). The basic idea behind this is to collect all effect axioms about a given fluent and assume that they specify all the ways the value of the fluent may change.
Reference: 13. <author> V.R. Pratt. </author> <title> Semantical considerations on Floyd-Hoare logic. </title> <booktitle> In Proc. of the 17th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 109-121, </pages> <year> 1976. </year>
Reference-contexts: The complete definition appears in [7]. As in dynamic logic <ref> [13] </ref>, conditionals and while-loops can be defined in terms of the above constructs as follows: if then ffi 1 else ffi 2 endIf def while do ffi endWhile def We also define an iteration construct for x : (x)[ffi (x)] that performs ffi (x) for all x's such that (x) holds
Reference: 14. <author> Raymond Reiter. </author> <title> The frame problem in the situation calculus: A simple solution (sometimes) and a completeness result for goal regression. </title> <editor> In Vladimir Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 359-380. </pages> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1991. </year>
Reference-contexts: The frame problem [11] arises because the number of these frame axioms is of the order of the product of the number of fluents and the number of actions. Our approach incorporates a treatment of the frame problem due to Reiter <ref> [14] </ref> (who extends previous proposals by Pednault [12], Schubert [16] and Haas [3]). The basic idea behind this is to collect all effect axioms about a given fluent and assume that they specify all the ways the value of the fluent may change.
Reference: 15. <author> Shane J. Ruman. </author> <title> GOLOG as an agent-programming language: Experiments in developing banking applications. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Toronto, Toronto, ON, </institution> <year> 1996. </year>
Reference-contexts: We describe their design in detail in the next section. A complete description of 8 Fig. 2. System user interface. the whole system appears in <ref> [15] </ref>. <p> We are experimenting with Golog's nondeterminism as a mechanism for doing this kind of "planning". We also used Golog's situation calculus semantics to perform correctness proofs for some of the PBA agent's procedures, for instance refreshMoni-toredAccts; the proofs appear in <ref> [15] </ref>. This was relatively easy, since there was no need to move to a different formal framework and Golog programs already include much of the specifications that are required for formal analysis.
Reference: 16. <author> L.K. Schubert. </author> <title> Monotonic solution to the frame problem in the situation calculus: An efficient method for worlds with fully specified actions. In H.E. </title> <editor> Kyberg, R.P. Loui, and G.N. Carlson, editors, </editor> <booktitle> Knowledge Representation and Defeasible Reasoning, </booktitle> <pages> pages 23-67. </pages> <publisher> Kluwer Academic Press, </publisher> <address> Boston, MA, </address> <year> 1990. </year> <title> This article was processed using the L a T E X macro package with LLNCS style 17 </title>
Reference-contexts: Our approach incorporates a treatment of the frame problem due to Reiter [14] (who extends previous proposals by Pednault [12], Schubert <ref> [16] </ref> and Haas [3]). The basic idea behind this is to collect all effect axioms about a given fluent and assume that they specify all the ways the value of the fluent may change.
References-found: 16

