URL: ftp://ftp.cs.umd.edu/pub/realtime/param-dispatch.ps.gz
Refering-URL: http://www.cs.umd.edu/projects/TimeWare/TimeWare-index-no-abs.html
Root-URL: 
Title: Parametric Dispatching of Hard Real-Time Tasks  
Author: Richard Gerber, William Pugh, Manas Saksena frich, pugh, 
Keyword: Index Terms: Real-time, scheduling, dispatching, operating systems, linear constraints, variable elimination, programming languages.  
Note: In IEEE Transactions on Computers,  This research is supported in part by NSF grants CCR-9157384 and CCR-9209333, DARPA contract N00014-91-C 0195 and a Packard Fellowship.  
Address: College Park, MD 20742  
Affiliation: Department of Computer Science University of Maryland  
Email: manasg@cs.umd.edu  
Date: 44(3), March 1995.  
Abstract: In many real-time systems, relative timing constraints are imposed on a set of tasks. Generating a correct ordering for the tasks and deriving their proper start-time assignments is a NP-hard problem; it subsumes the Non-preemptive Scheduling Problem. If a total order is imposed on the tasks and the exact execution times of tasks are known a priori, we can statically determine feasible start times using linear-programming techniques. However, if a total order is imposed but we can only obtain upper and lower bounds on execution time, verifying that the constraints can be satisfied requires proving a formula with alternating existential and universal quantifiers. We present the technique of parametric dispatching to enforce such timing constraints. During an o*ine component, we check if the constraints can be guaranteed. If so, a calendar is produced that allows our online algorithm to generate upper and lower bounds on the start time of each task, based on the start times and execution times of previous tasks. A suitable start time for the task may then be selected taking into account the presence of other non-critical tasks in the system. For arbitrary constraints, our algorithm has worst-case exponential time complexity. But we have also identified a subclass of constraints, for which the o*ine component requires O(n 3 ) time and the online component requires worst-case linear time to generate the bounds on the start times for each task. The subclass is general enough to encompass many timing constraints envisioned for real-time systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Berry, S. Moisan, and J. Rigault. </author> <title> ESTEREL : Towards a Synchronous and Semantically Sound High Level Languauge for Real Time Applications. </title> <booktitle> In Real Time Systems Symposium, </booktitle> <pages> pages 30-37. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1983. </year>
Reference-contexts: Another approach is taken in MPL [18] and RTC++[10], where temporal scopes are implicitly defined through language constructs such as "within t do f: : : g," "at t do f: : : g" and "after t do f: : : g." Other real-time languages include Real-Time Euclid [13], Esterel <ref> [1] </ref> and RTC [22]. The abovementioned programming languages provide constructs that are sufficiently powerful to build almost any real-time application. However, it is one thing to simply write a real-time program, and quite another to ensure its desired execution behavior.
Reference: [2] <author> G. B. Dantzig and B. C. Eaves. </author> <title> Fourier-Motzkin Elimination and its Dual. </title> <journal> Journal of Combinatorial Theory (A), </journal> <volume> 14 </volume> <pages> 288-297, </pages> <year> 1973. </year>
Reference-contexts: Gerber, W. Pugh and M. Saksena 11 2.1.2 Elimination of Existentially Quantified Variables Intuitively, existential quantified variable elimination finds the n 1 dimension shadow cast by an n dimensional object. The method we use is Fourier-Motzkin variable elimination <ref> [2] </ref>. Fourier-Motzkin Elimination. Consider a system of linear constraints C in n variables (x 1 ; x 2 ; : : : ; x n ).
Reference: [3] <author> B. Dasarathy. </author> <title> Timing Constraints of Real-Time Systems: Constructs for Expressing Them, Methods of Validating Them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):80-86, </volume> <month> January </month> <year> 1985. </year>
Reference-contexts: Timing specifications are event-based, and they establish many such minimum/maximum constrained relationships between occurrences of events <ref> [3, 11] </ref>. However, when a specification is realized in an application program, event-driven constraints are usually translated into equivalent relationships between the start and finish times of tasks. This helps ease the process of scheduling the tasks, and then dispatching them to guarantee that the constraints will hold.
Reference: [4] <author> G. Fohler and C. Koza. </author> <title> Heuristic Scheduling for Distributed Real-Time Systems. </title> <type> MARS 6/89, </type> <institution> Technische Universitat Wien, Vienna, Austria, </institution> <month> April </month> <year> 1989. </year>
Reference-contexts: Indeed, most scheduling techniques admit only absolute constraints on the start times (e.g., s i 10) and finish times (e.g., s i + e i 100). These techniques include priority-based scheduling (such as rate-monotonic and earliest deadline first [16]), as well as explicit calendar-creation methods <ref> [23, 4, 21] </ref>. The general problem of non-preemptive scheduling is NP-complete [5].
Reference: [5] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability, a Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman Company, </publisher> <address> San Francisco, </address> <year> 1979. </year>
Reference-contexts: These techniques include priority-based scheduling (such as rate-monotonic and earliest deadline first [16]), as well as explicit calendar-creation methods [23, 4, 21]. The general problem of non-preemptive scheduling is NP-complete <ref> [5] </ref>. This is true even for the most simple of constraints - i.e., where e i is considered constant (or worst-case), and where constraints are on ready times (i.e., s i c) and deadlines (i.e., s i + e i c).
Reference: [6] <author> R. Gerber and I. Lee. </author> <title> Communicating Shared Resources: A model for distributed real-time systems. </title> <booktitle> In Proceedings of the 12th IEEE Real-time Systems Symposium, </booktitle> <pages> pages 68-78, </pages> <address> Santa Monica, California, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: By a practical task set, we mean one which contains the type of relative constraints expressible by a real-time programming language (e.g., <ref> [14, 15, 18, 6, 22] </ref>). A sequential program written in any of these languages imposes a set of what we call standard constraints. We define a standard constraint as one which induces a relationship between at most two tasks, and where all coefficients are unary.
Reference: [7] <author> C. C. Han and K. J. Lin. </author> <title> Job scheduling with temporal distance constraints. </title> <type> Technical Report UIUCDCS-R-89-1560, </type> <institution> University of Illinois at Urbana-Champaign, Department of Computer Science, </institution> <year> 1989. </year>
Reference-contexts: Gerber, W. Pugh and M. Saksena 19 and in each chain a task has a deadline relative to its immediate predecessor, an O (n 2 ) time has been presented. Similar results have been obtained for tasks with relative separation constraints <ref> [7] </ref>. Another possible approach is automated verification, such as that taken in Real-Time Logic (e.g., [12]). Theoretically, RTL provides the capability to analyze schedulabilty for tasks with relative constraints, and especially for the problem addressed in this paper (if one limits the domain to the integers).
Reference: [8] <author> C. C. Han and K. J. Lin. </author> <title> Scheduling real-time computations with separation constraints. </title> <journal> Information Processing Letters, </journal> <volume> 12 </volume> <pages> 61-66, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Han and Lin have generalized the scheduling problem to include relative deadline constraints <ref> [8] </ref>; a relative deadline constraint specifies the maximum separation between start times of two tasks (i.e., s i s j + c). Even with unit execution times, the problem of scheduling such tasks is shown to be NP-complete.
Reference: [9] <author> M. G. Harmon, T. P. Baker, and D. B. Whalley. </author> <title> A retargetable technique for predicting execution time. </title> <booktitle> In Proceedings, IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 68-77, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Our method incorporates this nondeterminism, and simply assumes that execution times can be bounded from above and below. We believe that this is a realistic assumption, especially since several tools have been developed to generate these bounds <ref> [9, 19, 17, 20] </ref>. But since exact execution times are not known a priori, constructing a schedule is not such a trivial matter. As we have stated, there may be constraints between s i and s j and e j (where i &lt; j); that is, R. Gerber, W.
Reference: [10] <author> Y. Ishikawa, H. Tokuda, and C. Mercer. </author> <title> Object-Oriented Real-Time Language Design: Constructs for Timing Constraints. </title> <booktitle> In Proceedings ECOOP/OOPSLA, </booktitle> <pages> pages 289-298, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: When realized in a computer system, constraints may either be expressed directly in a program, or specified externally to be used by a scheduler. Many experimental real-time languages have been proposed in the last decade <ref> [15, 18, 14, 10] </ref>; all of these languages provide first-class, real-time constructs. The DPS language [14] supports the notion of the "temporal scope," which is associated with attributes such as deadline, minimum and maximum release times, maximum execution time and maximum elapsed time. <p> In this paper we have restricted ourselves to finite, totally-ordered task sets. Such task sets arise in sequential programs with nested timing constraints, which are expressible in contemporary real-time programming languages <ref> [15, 18, 14, 10] </ref>. Our method can also be applied to periodic tasks that contain mutually constrained subtasks. For example, consider the periodic construct "every 100 do T od" where T n is the last subtask in T.
Reference: [11] <author> F. Jahanian and A.K. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(9):890-904, </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: Timing specifications are event-based, and they establish many such minimum/maximum constrained relationships between occurrences of events <ref> [3, 11] </ref>. However, when a specification is realized in an application program, event-driven constraints are usually translated into equivalent relationships between the start and finish times of tasks. This helps ease the process of scheduling the tasks, and then dispatching them to guarantee that the constraints will hold.
Reference: [12] <author> F. Jahanian and A.K. Mok. </author> <title> A graph theoretic approach for timing analysis and its implementation. </title> <journal> IEEE Transactions on Computers, </journal> <note> C-36(8):961-975, August 1987. </note> <author> R. Gerber, W. Pugh and M. </author> <month> Saksena 21 </month>
Reference-contexts: Similar results have been obtained for tasks with relative separation constraints [7]. Another possible approach is automated verification, such as that taken in Real-Time Logic (e.g., <ref> [12] </ref>). Theoretically, RTL provides the capability to analyze schedulabilty for tasks with relative constraints, and especially for the problem addressed in this paper (if one limits the domain to the integers). However, this technique and others like it are typically non-constructive, and hence not applicable to creating a parametric calendar.
Reference: [13] <author> E. Klingerman and A. Stoyenko. </author> <title> Real-time Euclid: A language for reliable real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(9):941-949, </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: Another approach is taken in MPL [18] and RTC++[10], where temporal scopes are implicitly defined through language constructs such as "within t do f: : : g," "at t do f: : : g" and "after t do f: : : g." Other real-time languages include Real-Time Euclid <ref> [13] </ref>, Esterel [1] and RTC [22]. The abovementioned programming languages provide constructs that are sufficiently powerful to build almost any real-time application. However, it is one thing to simply write a real-time program, and quite another to ensure its desired execution behavior.
Reference: [14] <author> I. Lee and V. Gehlot. </author> <title> Language Constructs for Real Time Programming. </title> <booktitle> In Real Time Systems Symposium, </booktitle> <pages> pages 57-66. </pages> <publisher> IEEE, </publisher> <year> 1985. </year>
Reference-contexts: By a practical task set, we mean one which contains the type of relative constraints expressible by a real-time programming language (e.g., <ref> [14, 15, 18, 6, 22] </ref>). A sequential program written in any of these languages imposes a set of what we call standard constraints. We define a standard constraint as one which induces a relationship between at most two tasks, and where all coefficients are unary. <p> When realized in a computer system, constraints may either be expressed directly in a program, or specified externally to be used by a scheduler. Many experimental real-time languages have been proposed in the last decade <ref> [15, 18, 14, 10] </ref>; all of these languages provide first-class, real-time constructs. The DPS language [14] supports the notion of the "temporal scope," which is associated with attributes such as deadline, minimum and maximum release times, maximum execution time and maximum elapsed time. <p> Many experimental real-time languages have been proposed in the last decade [15, 18, 14, 10]; all of these languages provide first-class, real-time constructs. The DPS language <ref> [14] </ref> supports the notion of the "temporal scope," which is associated with attributes such as deadline, minimum and maximum release times, maximum execution time and maximum elapsed time. Likewise, Flex [15] supports the notion of a constraint block, with associated attributed such as start time, finish time and duration. <p> In this paper we have restricted ourselves to finite, totally-ordered task sets. Such task sets arise in sequential programs with nested timing constraints, which are expressible in contemporary real-time programming languages <ref> [15, 18, 14, 10] </ref>. Our method can also be applied to periodic tasks that contain mutually constrained subtasks. For example, consider the periodic construct "every 100 do T od" where T n is the last subtask in T.
Reference: [15] <author> K. J. Lin and S. Natarajan. </author> <title> Expressing and Maintaining Timing Constraints in FLEX. </title> <booktitle> In Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: By a practical task set, we mean one which contains the type of relative constraints expressible by a real-time programming language (e.g., <ref> [14, 15, 18, 6, 22] </ref>). A sequential program written in any of these languages imposes a set of what we call standard constraints. We define a standard constraint as one which induces a relationship between at most two tasks, and where all coefficients are unary. <p> When realized in a computer system, constraints may either be expressed directly in a program, or specified externally to be used by a scheduler. Many experimental real-time languages have been proposed in the last decade <ref> [15, 18, 14, 10] </ref>; all of these languages provide first-class, real-time constructs. The DPS language [14] supports the notion of the "temporal scope," which is associated with attributes such as deadline, minimum and maximum release times, maximum execution time and maximum elapsed time. <p> The DPS language [14] supports the notion of the "temporal scope," which is associated with attributes such as deadline, minimum and maximum release times, maximum execution time and maximum elapsed time. Likewise, Flex <ref> [15] </ref> supports the notion of a constraint block, with associated attributed such as start time, finish time and duration. The attributes of each block may be constrained by the attributes of other blocks, yielding a set of global constraints not unlike the type we study in this paper. <p> In this paper we have restricted ourselves to finite, totally-ordered task sets. Such task sets arise in sequential programs with nested timing constraints, which are expressible in contemporary real-time programming languages <ref> [15, 18, 14, 10] </ref>. Our method can also be applied to periodic tasks that contain mutually constrained subtasks. For example, consider the periodic construct "every 100 do T od" where T n is the last subtask in T.
Reference: [16] <author> C. L. Liu and J. Layland. </author> <title> Scheduling algorithm for multiprogramming in a hard real-time environment. </title> <journal> Journal of the ACM., </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> Jan. </month> <year> 1973. </year>
Reference-contexts: Indeed, most scheduling techniques admit only absolute constraints on the start times (e.g., s i 10) and finish times (e.g., s i + e i 100). These techniques include priority-based scheduling (such as rate-monotonic and earliest deadline first <ref> [16] </ref>), as well as explicit calendar-creation methods [23, 4, 21]. The general problem of non-preemptive scheduling is NP-complete [5].
Reference: [17] <author> A. Mok, P. Ameransinghe, M. Chen, and K. Tantisirivat. </author> <title> Evaluating Tight Execution Time Bounds of Programs by Annotations. </title> <booktitle> In Proc. 6th IEEE Workshop on Real-Time Software and Operating Systems, </booktitle> <pages> pages 74-80, </pages> <year> 1989. </year>
Reference-contexts: Our method incorporates this nondeterminism, and simply assumes that execution times can be bounded from above and below. We believe that this is a realistic assumption, especially since several tools have been developed to generate these bounds <ref> [9, 19, 17, 20] </ref>. But since exact execution times are not known a priori, constructing a schedule is not such a trivial matter. As we have stated, there may be constraints between s i and s j and e j (where i &lt; j); that is, R. Gerber, W.
Reference: [18] <author> V. Nirkhe, S. Tripathi, and A. Agrawala. </author> <title> Language Support for the Maruti Real-Time System. </title> <booktitle> In Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1990. </year>
Reference-contexts: By a practical task set, we mean one which contains the type of relative constraints expressible by a real-time programming language (e.g., <ref> [14, 15, 18, 6, 22] </ref>). A sequential program written in any of these languages imposes a set of what we call standard constraints. We define a standard constraint as one which induces a relationship between at most two tasks, and where all coefficients are unary. <p> When realized in a computer system, constraints may either be expressed directly in a program, or specified externally to be used by a scheduler. Many experimental real-time languages have been proposed in the last decade <ref> [15, 18, 14, 10] </ref>; all of these languages provide first-class, real-time constructs. The DPS language [14] supports the notion of the "temporal scope," which is associated with attributes such as deadline, minimum and maximum release times, maximum execution time and maximum elapsed time. <p> The attributes of each block may be constrained by the attributes of other blocks, yielding a set of global constraints not unlike the type we study in this paper. Another approach is taken in MPL <ref> [18] </ref> and RTC++[10], where temporal scopes are implicitly defined through language constructs such as "within t do f: : : g," "at t do f: : : g" and "after t do f: : : g." Other real-time languages include Real-Time Euclid [13], Esterel [1] and RTC [22]. <p> In this paper we have restricted ourselves to finite, totally-ordered task sets. Such task sets arise in sequential programs with nested timing constraints, which are expressible in contemporary real-time programming languages <ref> [15, 18, 14, 10] </ref>. Our method can also be applied to periodic tasks that contain mutually constrained subtasks. For example, consider the periodic construct "every 100 do T od" where T n is the last subtask in T.
Reference: [19] <author> C. Park and A. C. Shaw. </author> <title> Experiments with a Program Timing Tool Based on Source Level Timing Schema. </title> <booktitle> In Proceedings IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 72-81, </pages> <month> dec </month> <year> 1990. </year>
Reference-contexts: Our method incorporates this nondeterminism, and simply assumes that execution times can be bounded from above and below. We believe that this is a realistic assumption, especially since several tools have been developed to generate these bounds <ref> [9, 19, 17, 20] </ref>. But since exact execution times are not known a priori, constructing a schedule is not such a trivial matter. As we have stated, there may be constraints between s i and s j and e j (where i &lt; j); that is, R. Gerber, W.
Reference: [20] <author> P. Puschner and C. Koza. </author> <title> Calculating the Maximum Execution Time of Real-Time Programs. </title> <journal> Journal of Real Time Systems, </journal> <volume> 1(2) </volume> <pages> 159-176, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Our method incorporates this nondeterminism, and simply assumes that execution times can be bounded from above and below. We believe that this is a realistic assumption, especially since several tools have been developed to generate these bounds <ref> [9, 19, 17, 20] </ref>. But since exact execution times are not known a priori, constructing a schedule is not such a trivial matter. As we have stated, there may be constraints between s i and s j and e j (where i &lt; j); that is, R. Gerber, W.
Reference: [21] <author> K. Ramamritham, J. A. Stankovik, and W. Zhao. </author> <title> Distributed scheduling of tasks with deadlines and resource requirements. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 38(8) </volume> <pages> 1110-1123, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Indeed, most scheduling techniques admit only absolute constraints on the start times (e.g., s i 10) and finish times (e.g., s i + e i 100). These techniques include priority-based scheduling (such as rate-monotonic and earliest deadline first [16]), as well as explicit calendar-creation methods <ref> [23, 4, 21] </ref>. The general problem of non-preemptive scheduling is NP-complete [5].
Reference: [22] <author> V. Wolfe, S. Davidson, and I. Lee. RTC: </author> <title> Language support for real-time concurrency. </title> <booktitle> In Proceedings of the 12th IEEE Real-time Systems Symposium, </booktitle> <pages> pages 43-52, </pages> <address> San Antonio, Texas, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: By a practical task set, we mean one which contains the type of relative constraints expressible by a real-time programming language (e.g., <ref> [14, 15, 18, 6, 22] </ref>). A sequential program written in any of these languages imposes a set of what we call standard constraints. We define a standard constraint as one which induces a relationship between at most two tasks, and where all coefficients are unary. <p> taken in MPL [18] and RTC++[10], where temporal scopes are implicitly defined through language constructs such as "within t do f: : : g," "at t do f: : : g" and "after t do f: : : g." Other real-time languages include Real-Time Euclid [13], Esterel [1] and RTC <ref> [22] </ref>. The abovementioned programming languages provide constructs that are sufficiently powerful to build almost any real-time application. However, it is one thing to simply write a real-time program, and quite another to ensure its desired execution behavior. Unfortunately, modern scheduling techniques have not caught up to these languages.
Reference: [23] <author> J. Xu and D. L. Parnas. </author> <title> Scheduling processes with release times, deadlines, precedence, and exclusion relations. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-16(3):360-369, </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: Indeed, most scheduling techniques admit only absolute constraints on the start times (e.g., s i 10) and finish times (e.g., s i + e i 100). These techniques include priority-based scheduling (such as rate-monotonic and earliest deadline first [16]), as well as explicit calendar-creation methods <ref> [23, 4, 21] </ref>. The general problem of non-preemptive scheduling is NP-complete [5].
References-found: 23

