URL: http://polaris.cs.uiuc.edu/reports/1336.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/polaris/rep2.html
Root-URL: http://www.cs.uiuc.edu
Email: tu,padua@csrd.uiuc.edu  
Title: Gated SSA Based Demand-Driven Symbolic Analysis  
Author: Peng Tu and David Padua 
Address: 1308 W. Main Street, Urbana, Illinois 61801-2307  
Affiliation: Center for Supercomputing Research and Development University of Illinois at Urbana-Champaign  
Abstract-found: 0
Intro-found: 1
Reference: [AWZ88] <author> B. Alpern, M. N. Wegman, and F. K. Zadeck. </author> <title> Detecting Equality of Variables in Programs. </title> <booktitle> In Proc. of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-11, </pages> <year> 1988. </year>
Reference-contexts: The redundant substitution of JMAX by Expr does not have to be performed. To implement backward substitution, we use a Static Single Assignment (SSA) <ref> [AWZ88] </ref> [RWZ88] program representation. The SSA form is obtained by renaming the scalar variables in the program so that the left-hand sides of all scalar assignments are different. <p> A special function, , is used at the confluence points of the control flow graph when it is necessary to select one of several renamed versions of a scalar variable. SSA has been used for determining equivalence of symbolic variables <ref> [AWZ88] </ref> and parallelization of imperative programs [CF87]. An efficient algorithm for constructing a minimal SSA representation of an imperative program can be found in [CFR + 91]. <p> Statement S' would then take the form: J 3 := (P; J 1 ; J 2 ) This form of the function returns the second or third parameter depending on the value of the predicate. This type of function is called a high-level function and was introduced in <ref> [AWZ88] </ref>. The Gated Single Assignment (GSA) which was proposed in [BMO90] as a part of the Program Dependence Web (PDW) also uses this form of the function. In this paper, we will use GSA as the intermediate representation for a program. <p> Incorporating path condition in the analysis provides us with more power than GSA or SSA alone. 2.3 Comparison of Symbolic Expressions The symbolic expression may still contain fl functions after path projection. In symbolic analysis, we sometimes need to compare these expressions. <ref> [AWZ88] </ref> defines a congruence 6 relation between expressions with assignments. The congruent variables are shown to have equivalent values under structural isomorphism. Structural isomorphism can only be used to determine equality; it cannot determine, for example, if one expression is always larger than another.
Reference: [BE94a] <author> William Blume and Rudolf Eigenmann. </author> <title> The Range Test: A Dependence Test for Symbolic, Non-linear Expressions. </title> <type> Technical Report 1345, </type> <institution> Univ. of Illinois at Urbana-Champaign, Cntr. for Supercomputing Res. & Dev., </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: The examples illustrate how these techniques improve the effectiveness of array privatization [TP93]. The techniques are also useful in improving the accuracy of dependence analysis <ref> [BE94b, BE94a] </ref>. The main task when performing privatization of an array A is to determine whether or not in all iterations of the do loop each access to an element of A is dominated by an assignment to the same element.
Reference: [BE94b] <author> William Blume and Rudolf Eigenmann. </author> <title> Symbolic Analysis Techniques Needed for the Effective Parallelization of the Perfect Ben chmarks. </title> <type> Technical Report 1332, </type> <institution> Univ. of Illinois at Urbana-Champaign, Cntr. for Supercomputing Res. & Dev., </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: The examples illustrate how these techniques improve the effectiveness of array privatization [TP93]. The techniques are also useful in improving the accuracy of dependence analysis <ref> [BE94b, BE94a] </ref>. The main task when performing privatization of an array A is to determine whether or not in all iterations of the do loop each access to an element of A is dominated by an assignment to the same element.
Reference: [BEF + 94] <author> Bill Blume, Rudolf Eigenmann, Keith Faigin, John Grout, Jay Hoeflinger, David Padua, Paul Petersen, Bill Pottenger, Lawrence Rauchwerger, Peng Tu, and Stephen Weatherford. </author> <title> Polaris: The Next Generation in Parallelizing Compilers. </title> <type> Technical Report 1375, </type> <institution> Univ of Illinois at Urbana-Champaign, Cntr for Supercomputing Res & Dev, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: 1 Introduction It has become increasingly evident that symbolic manipulation of expressions is necessary to support a number of analysis and transformation techniques used by parallelizing compilers. For example, symbolic analysis increases the accuracy of dependence analysis and array privatization <ref> [BEF + 94] </ref>[TP93], which are perhaps the two most important techniques for automatic parallelization. This paper presents a technique to determine the equality and inequality relations between symbolic expressions. The problem of determining the relationship between symbolic expressions is undecidable in general.
Reference: [BMO90] <author> R. Ballance, A. Maccabe, and K. Ottenstein. </author> <title> The Program Dependence Web: a Representation Supporting Control Data- and Demand-Driven Interpretation of Imperative Languages. </title> <booktitle> In Proceedings of the SIGPLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 257-271, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: This type of function is called a high-level function and was introduced in [AWZ88]. The Gated Single Assignment (GSA) which was proposed in <ref> [BMO90] </ref> as a part of the Program Dependence Web (PDW) also uses this form of the function. In this paper, we will use GSA as the intermediate representation for a program. <p> The loop label L is the first argument of this function. The function selects the last value of X computed by the loop. The function, as defined in <ref> [BMO90] </ref>, handles loops with a zero-trip count awkwardly. <p> Otherwise, X 4 will take the value from inside the loop when the loop exit condition is satisfied. In <ref> [BMO90] </ref>, an efficient algorithm is presented to construct GSA from the SSA representation and the control flow graph of a program. 2.2 Backward Substitution and Path Projection To derive the value for a symbolic variable at a point p in the GSA form of a program, we first perform backward substitution.
Reference: [CF87] <author> Ron Cytron and Jeanne Ferante. </author> <title> What's in a Name? or The Value of Renaming for Parallelism Detection and Storage Allocation. </title> <booktitle> In Proc. 1987 International Conf. on Parallel Processing, </booktitle> <pages> pages 19-27, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: A special function, , is used at the confluence points of the control flow graph when it is necessary to select one of several renamed versions of a scalar variable. SSA has been used for determining equivalence of symbolic variables [AWZ88] and parallelization of imperative programs <ref> [CF87] </ref>. An efficient algorithm for constructing a minimal SSA representation of an imperative program can be found in [CFR + 91].
Reference: [CFR + 91] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Ken-neth Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: SSA has been used for determining equivalence of symbolic variables [AWZ88] and parallelization of imperative programs [CF87]. An efficient algorithm for constructing a minimal SSA representation of an imperative program can be found in <ref> [CFR + 91] </ref>. <p> We can use the GSA representation to find out the value of JPLUS (J) at statement U. To this end, we use an extension of the SSA representation to include arrays in the following way <ref> [CFR + 91] </ref>: 1. Create a new array name for each array assignment; 2. Use the subscript to identify which element is assigned; 3. Replace the assignment with an update function ff (array; subscript; value).
Reference: [CH78] <author> P. Cousot and N. Halbwachs. </author> <title> Automatic Discovery of Linear Restraints among Variables of a Program. </title> <booktitle> In Proceedings of the 5th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-97, </pages> <month> January </month> <year> 1978. </year>
Reference: [CHT79] <author> T. E. Cheatham, G. H. Holloway, and J. A. Townley. </author> <title> Symbolic Evaluation and the Analysis of Programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(4) </volume> <pages> 402-417, </pages> <year> 1979. </year>
Reference: [CR85] <author> L. A. Clarke and D. J. Richardson. </author> <title> Applications of Symbolic Evaluation. </title> <journal> Journal of Systems and Software, </journal> <volume> 5(1) </volume> <pages> 15-35, </pages> <year> 1985. </year>
Reference: [GJ79] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of the NP-Completeness. </title> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: The problem of determining whether P C P is NP-Complete <ref> [GJ79] </ref>. However, because the number of boolean variables in a program is usually small, we expect the cost of computing the path projection to be small.
Reference: [HP92] <author> M. R. Haghighat and C. D. Polychronopoulos. </author> <title> Symbolic program analysis and optimization for parallelizing compilers. </title> <booktitle> In Proc. 5rd Workshop on Programming Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1992. </year>
Reference: [RWZ88] <author> B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> Global Value Numbers and Redundant Computation. </title> <booktitle> In Proc. of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 12-27, </pages> <year> 1988. </year>
Reference-contexts: The redundant substitution of JMAX by Expr does not have to be performed. To implement backward substitution, we use a Static Single Assignment (SSA) [AWZ88] <ref> [RWZ88] </ref> program representation. The SSA form is obtained by renaming the scalar variables in the program so that the left-hand sides of all scalar assignments are different.
Reference: [TP93] <author> Peng Tu and David Padua. </author> <title> Automatic array privatization. </title> <booktitle> In Proc. 6rd Workshop on Programming Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: The examples illustrate how these techniques improve the effectiveness of array privatization <ref> [TP93] </ref>. The techniques are also useful in improving the accuracy of dependence analysis [BE94b, BE94a].
Reference: [Wol92] <author> Michael Wolfe. </author> <title> Beyond induction variables. </title> <booktitle> ACM PLDI'92, </booktitle> <year> 1992. </year> <month> 12 </month>
Reference-contexts: When P is always true and A is a linear reference to an array, for example X (i), J 1 (i) is a reduction sum over X. For induction variable identification, this approach is equivalent to the Strong Connected Region (SCR) algorithm given by <ref> [Wol92] </ref>. However, the symbolic substitution scheme is more general because it can deal with those cases where no closed form expression can be obtained.
References-found: 15

