URL: ftp://www.cs.rutgers.edu/pub/technical-reports/dcs-tr-295a.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: borgida@cs.rutgers.edu  
Phone: Tel: 908-249-5062  
Title: On the Relationship between Description Logic and Predicate Logic Queries LCSR-TR-295-A  
Author: Alex Borgida 
Note: This work was conducted in part while the author was on sabbatical leave at AT&T Bell Laboratories, and it was supported in part by NSF Grant IRI 91-19310.  
Date: December 1992 Revised June 1993  
Address: New Brunswick, NJ 08903  
Affiliation: Dept. of Computer Science Rutgers University  
Abstract: Description Languages (DLs) are descendants of the kl-one [15] knowledge representation system, and form the basis of several object-centered knowledge base management systems developed in recent years, including ones in industrial use. Originally used for conceptual modeling (to define views), DLs are seeing increased use as query languages for retrieving information. This paper, aimed at a general audience that includes database researchers, considers the relationship between the expressive power of DLs and that of query languages based on Predicate Calculus. We show that all descriptions built using constructors currently considered in the literature can be expressed as formulae of the First Order Predicate Calculus with at most three variable symbols, though we have to allow numeric quantifiers and infinitary disjunction in order to handle a couple of special constructors. Conversely, we show that all first-order queries (formulae with one free variable) built up from unary and binary predicates using at most three variables can be expressed as descriptions. We establish similar results for the subset of FOPC involving two variable symbols. We also show that certain subsets of constructors can be used to express only formulae in such well-studied subsets of FOPC as conjunctive queries and existential queries. For these languages, we gain ideas for subsumption algorithms from the work in the database literature on the containment problem of existential queries. The paper also suggests how one can transfer to DLs results from the theoretical database literature about languages based on predicate calculus with recursion. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Afrati, F., Cosmadakis, S., and M. Yannakakis, </author> <title> "On Datalog vs. Polynomial Time", </title> <booktitle> Proc. ACM PODS'91, </booktitle> <pages> pp. 13-23. </pages>
Reference-contexts: This, and other results (such as those in <ref> [1] </ref>) might then be applied to description logics, to find other decidable subclasses of recursive definitions. As in the case of conjunctive queries, there exists the possibility of improved time bounds in the case of descriptions.
Reference: [2] <author> Anwar, T.M., Beck H. and Navathe S., </author> <title> "Knowledge Mining by imprecise querying: a classification-based approach", </title> <booktitle> Proc. 8th IEEE Data Engineering Conf., </booktitle> <address> Tempe, AZ, </address> <month> February </month> <year> 1992, </year> <pages> 622-630. </pages>
Reference-contexts: We summarize some of these applications of DLs, though for a fuller survey the reader is directed to [11]. The present work is directly motivated by the recent use of DLs as query languages to access data stored in relational databases <ref> [16, 2, 23] </ref>. There has been considerable research on the complexity of reasoning with descriptions, especially computing the subsumption (containment) relationship between them. Surprisingly little is known about their expressive power as query languages, in comparison with well-known formalisms based on Predicate Calculus (PC). <p> For these languages, we gain ideas for subsumption algorithms from the work in the database literature on the containment problem of existential queries. A brief consideration of two DLs that have appeared in the database literature (classic [12, 16] and candide <ref> [7, 2] </ref>) indicates that they can express queries that cannot be stated in Datalog, but cannot express certain first order queries. <p> More recently, DLs have been proposed and used as query languages, thus integrating the data description and data manipulation languages <ref> [12, 7, 2, 16] </ref>. This has been particularly fruitful in data exploration applications, where one or more users, who may not be fully familiar with the database contents, are looking for interesting facts, correlations, etc. <p> The special abilities of DLs lead to a number of advantages: * Detecting and reporting incoherence of queries. 3 * Query generalization: having asked a query that returns no individuals, the system can systematically try to generalize the description until it results in a concept with a non-empty answer <ref> [2] </ref>. * Query organization: When teams of users explore databases over periods of time, it is useful to be able to organize the queries themselves so that one can find similar queries that have been asked in the past [16]. <p> However, such problems do not appear to arise in practice. Not surprisingly, it is possible to introduce recursive definitions, such as BINARY-TREE = and [ TREE , at-most <ref> [2, branches] </ref>, all [branches,BINARY-TREE]] Note that here the recursion "bottoms out" in cases when an individual has 0 branches, rather than requiring a separate "base case" as is traditional in logic programming. (Such base cases can however be represented in DLs which have the or constructor.) Unfortunately, there are at least
Reference: [3] <author> Baader, F., </author> <title> "Terminological cycles in KLONE-based knowledge representation languages", </title> <booktitle> Proc. 1991 IJCAI, </booktitle> <address> SYdney, </address> <year> 1991, </year> <pages> pp. 621-626. </pages>
Reference-contexts: Unlike the situation in the Datalog/Prolog community, there is no agreed-on best choice. We summarize again some of the known results in the DL community (see [31] and <ref> [3] </ref>): Language Semantics Complexity and, all, at-most, at-least gfp, lfp PSPACE-complete and, all, same-as on functional roles, compose fp Undecidable The notion of recursion arises in the querying of FOL databases when the same predicate may occur on both sides of a Datalog rule.
Reference: [4] <author> Baader, F., and Hollunder, B., "KRIS: </author> <title> Knowledge representation and inference system", </title> <journal> ACM SIGART Bulletin 2(3), </journal> <month> June </month> <year> 1991, </year> <pages> 8 - 14. </pages>
Reference-contexts: Role constr. classic [12] and, all, at-least, at-most, fills*, one-of*, same-as on feature chains | loom [27] and, or, not, all, some, at-least, at-most, at-least-c, at-most-c, same-as, subset, not-same-as, fills, one-of role-and, compose, inverse, restrict, product, identity back [?] and, all, at-least, at-most, same-as, one-of role-and, product kris <ref> [4] </ref> and, or, not, all, some, at-least, at-most, same-as on feature chains role-and, restrict candide [7] and, or, not, all, fills, one-of, at-least, at-most, at-least-c | inv [9] and, all, at-least, at-most, one-of*, atomic not inverse Table 2: A few proposed languages and their constructors 5 Concept constr. Role constr.
Reference: [5] <editor> Baader, F., H-J. Burckert, J. Heinsohn, B. Hollunder, J. Muller, B. Nebel, W. Nutt, H. </editor> <title> Profitlich, Terminological Knowledge Representation: A Proposal for a Terminological Logic, </title> <type> DFKI Report, </type> <institution> DFKI, Saarbrucken, GERMANY, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: Table 1 presents the language KL, which consists of a quite comprehensive list of the constructors considered in the DL literature so far 1 ; it comes from recent survey papers [41] and an effort to establish a standard notation and semantics to support knowledge-base interchange <ref> [5] </ref>. The language of descriptions is obtained recursively by starting from atomic symbols for primitive concepts and roles. In the table and elsewhere, we use the symbols C; D; ::: to range over concept descriptions, p; q; ::: to range over role descriptions, and a; b; ::: to denote individuals.
Reference: [6] <author> Barwise, J., </author> <title> "On Moskovakis closure ordinals", </title> <journal> Journal of Symbolic Logic, </journal> <volume> 42, </volume> <year> 1977, </year> <month> p.292-296. </month>
Reference-contexts: Properties of such these language families have been studied, among others, by Henkin [22], Barwise <ref> [6] </ref>, Immerman [24, 17], and Kolaitis&Vardi [25]. 4.1 DLs without trans, at-least and at-most Our first result shows that almost everything that can be said with DLs, can be said with just a few variables.
Reference: [7] <author> Beck, H. W., Gala, S. K., and Navathe, S. B., </author> <title> "Classification as a Query Processing Technique in the CANDIDE Semantic Data Model," </title> <booktitle> Proc. 5th IEEE Data Engineering Conf., </booktitle> <month> February </month> <year> 1989, </year> <pages> pp. 572-581. </pages>
Reference-contexts: For these languages, we gain ideas for subsumption algorithms from the work in the database literature on the containment problem of existential queries. A brief consideration of two DLs that have appeared in the database literature (classic [12, 16] and candide <ref> [7, 2] </ref>) indicates that they can express queries that cannot be stated in Datalog, but cannot express certain first order queries. <p> Not surprisingly, DLs are therefore useful for capturing the conceptual schema of databases, i.e., as data definition languages. A number of papers have explored this aspect, including <ref> [12, 7, 8, 23] </ref>; in fact, it is shown in [9] how the Entity-Relationship and DAPLEX semantic models can be expressed in a DL. <p> More recently, DLs have been proposed and used as query languages, thus integrating the data description and data manipulation languages <ref> [12, 7, 2, 16] </ref>. This has been particularly fruitful in data exploration applications, where one or more users, who may not be fully familiar with the database contents, are looking for interesting facts, correlations, etc. <p> Moreover, users may record observations about the query and its answer, using "meta" objects. * Query formulation by refinement: A user exploring the database can use the classification hierarchy of concepts to refine her queries <ref> [34, 39, 7] </ref>. * Intensional query processing: The general processing strategy of DL queries is to "classify" the query description with respect to the pre-computed views (or saved previous queries), and then only test their instances rather than processing the entire database [7, 32]. * Schema browsing: Since concepts in the <p> classification hierarchy of concepts to refine her queries [34, 39, 7]. * Intensional query processing: The general processing strategy of DL queries is to "classify" the query description with respect to the pre-computed views (or saved previous queries), and then only test their instances rather than processing the entire database <ref> [7, 32] </ref>. * Schema browsing: Since concepts in the schema as well as queries can be compared for subsumption, users can explore and discover previously unknown generic facts, such as coding standards or constraints in Software Information Systems [20]. <p> chains | loom [27] and, or, not, all, some, at-least, at-most, at-least-c, at-most-c, same-as, subset, not-same-as, fills, one-of role-and, compose, inverse, restrict, product, identity back [?] and, all, at-least, at-most, same-as, one-of role-and, product kris [4] and, or, not, all, some, at-least, at-most, same-as on feature chains role-and, restrict candide <ref> [7] </ref> and, or, not, all, fills, one-of, at-least, at-most, at-least-c | inv [9] and, all, at-least, at-most, one-of*, atomic not inverse Table 2: A few proposed languages and their constructors 5 Concept constr. Role constr.
Reference: [8] <author> Bergamaschi, S., S. Lodi and C. Sartori, "Entity-Situation: </author> <title> a model for knowledge representation", </title> <publisher> EDBT'88. </publisher>
Reference-contexts: Not surprisingly, DLs are therefore useful for capturing the conceptual schema of databases, i.e., as data definition languages. A number of papers have explored this aspect, including <ref> [12, 7, 8, 23] </ref>; in fact, it is shown in [9] how the Entity-Relationship and DAPLEX semantic models can be expressed in a DL.
Reference: [9] <author> Bergamasci, S., Sartori, C., </author> <title> "On taxonomic reasoning in conceptual design", </title> <journal> ACM TODS, </journal> <note> in press. (Tech. Report 78, </note> <institution> Dipartimento di Informatica, Universita di Bologna, Italy, </institution> <month> January </month> <year> 1991) </year>
Reference-contexts: Not surprisingly, DLs are therefore useful for capturing the conceptual schema of databases, i.e., as data definition languages. A number of papers have explored this aspect, including [12, 7, 8, 23]; in fact, it is shown in <ref> [9] </ref> how the Entity-Relationship and DAPLEX semantic models can be expressed in a DL. The benefits of having a logic of descriptions in this case include the ability to automatically organize defined classes into the IS-A hierarchy, and checking the consistency of the class specifications. <p> at-most-c, same-as, subset, not-same-as, fills, one-of role-and, compose, inverse, restrict, product, identity back [?] and, all, at-least, at-most, same-as, one-of role-and, product kris [4] and, or, not, all, some, at-least, at-most, same-as on feature chains role-and, restrict candide [7] and, or, not, all, fills, one-of, at-least, at-most, at-least-c | inv <ref> [9] </ref> and, all, at-least, at-most, one-of*, atomic not inverse Table 2: A few proposed languages and their constructors 5 Concept constr. Role constr.
Reference: [10] <author> Blanco J.M., Illarramendi A., Perez J.M., Goni A., </author> <title> "Making A Federated System Active", </title> <booktitle> Proc. International Conference on Database and Expert Systems Applications, </booktitle> <address> Valencia (SPAIN), </address> <year> 1992, </year> <editor> A M. Tjoa and I. Ramos eds., </editor> <publisher> Springer-Verlag, </publisher> <pages> pp. 345-350 </pages>
Reference-contexts: For example, consider the description in Figure 1. It is constructed from identifiers denoting binary relations (called roles) (e.g., venue,players), individuals (e.g., Toronto, 1) and other, previously named or primitive classes (e.g., GAME, STADIUM) using de 2 and [GAME, all [venue,STADIUM], at-most <ref> [10, players] </ref>, all [players, fills [home-town,Toronto]], all [duration, one-of [1,2,3]]] scription constructors such as and, all, at-most, fills and one-of.
Reference: [11] <author> Borgida, A., </author> <title> "A new look at the foundations and utility of Description Logics (or Terminological Logics are not just for the Flightless Birds)", </title> <type> Technical Report, </type> <institution> Rutgers University, </institution> <year> 1992. </year>
Reference-contexts: We summarize some of these applications of DLs, though for a fuller survey the reader is directed to <ref> [11] </ref>. The present work is directly motivated by the recent use of DLs as query languages to access data stored in relational databases [16, 2, 23]. There has been considerable research on the complexity of reasoning with descriptions, especially computing the subsumption (containment) relationship between them.
Reference: [12] <author> Borgida, A., Brachman, R. J., McGuinness, D. L., and Resnick, L. A. </author> <title> "CLASSIC: A Structural Data Model for Objects," </title> <booktitle> Proc. 1989 ACM SIGMOD Conf., </booktitle> <month> June </month> <year> 1989, </year> <pages> pp. 59-67. </pages>
Reference-contexts: For these languages, we gain ideas for subsumption algorithms from the work in the database literature on the containment problem of existential queries. A brief consideration of two DLs that have appeared in the database literature (classic <ref> [12, 16] </ref> and candide [7, 2]) indicates that they can express queries that cannot be stated in Datalog, but cannot express certain first order queries. <p> Not surprisingly, DLs are therefore useful for capturing the conceptual schema of databases, i.e., as data definition languages. A number of papers have explored this aspect, including <ref> [12, 7, 8, 23] </ref>; in fact, it is shown in [9] how the Entity-Relationship and DAPLEX semantic models can be expressed in a DL. <p> More recently, DLs have been proposed and used as query languages, thus integrating the data description and data manipulation languages <ref> [12, 7, 2, 16] </ref>. This has been particularly fruitful in data exploration applications, where one or more users, who may not be fully familiar with the database contents, are looking for interesting facts, correlations, etc. <p> Concept constr. Role constr. classic <ref> [12] </ref> and, all, at-least, at-most, fills*, one-of*, same-as on feature chains | loom [27] and, or, not, all, some, at-least, at-most, at-least-c, at-most-c, same-as, subset, not-same-as, fills, one-of role-and, compose, inverse, restrict, product, identity back [?] and, all, at-least, at-most, same-as, one-of role-and, product kris [4] and, or, not, all, some,
Reference: [13] <author> Borgida, A., and Brachman, R., </author> <title> "Inference in the Interface to Intelligent and Cooperative Information Systems," </title> <booktitle> Workshop on Intelligent and Cooperative Information Systems, </booktitle> <month> October, </month> <year> 1991, </year> <title> Como, </title> <address> Italy. </address>
Reference: [14] <author> Borgida, A. and P. Patel-Schneider, </author> <title> A Semantics and Complete Algorithm for Subsumption in the classic Description Logic, </title> <type> manuscript, </type> <institution> Rutgers University and AT&T Bell Laboratories, </institution> <month> February </month> <year> 1992. </year> <note> Submitted for publication. </note>
Reference-contexts: Role constr. Complexity classic Polynomial <ref> [14] </ref> kris PSPACE [21] and,all, same-as | Undecidable [37] and, not, all, some, or compose, role-or, inverse, trans, restrict,top-role EXP-TIME [36] and, not, all, some, or compose, role-or, inverse, trans, restrict, fea tures, top-role Undecidable [36] Table 3: Some subsumption complexity results the former is considerably faster.
Reference: [15] <author> Brachman, R. J., </author> <title> "A Structural Paradigm for Representing Knowledge," </title> <type> Ph.D. Thesis, </type> <institution> Harvard University, Division of Engineering and Applied Physics, </institution> <year> 1977. </year> <note> Revised version published as BBN Report No. 3605, </note> <institution> Bolt Beranek and Newman, Inc., </institution> <address> Cambridge, MA, </address>
Reference-contexts: 1 Overview Description Languages (DLs) are descendants of the kl-one <ref> [15] </ref> knowledge representation system and form the basis of several object-centered knowledge base management systems developed in recent years, including ones in industrial use. Originally, they were used for conceptual modeling.
Reference: [16] <author> Brachman, R., P.Selfridge, L.Terveen, B.Altman, A. Borgida, F. Halper, T.Kirk, A.Lazar, D..McGuiness, L.Resnick, </author> <title> "Knowledge Representation Support for Data Archeology", </title> <booktitle> Proc. International Conference on Information and Knowledge Management, </booktitle> <address> Baltimore, MD, </address> <month> November </month> <year> 1992, </year> <month> pp.457-464. </month>
Reference-contexts: We summarize some of these applications of DLs, though for a fuller survey the reader is directed to [11]. The present work is directly motivated by the recent use of DLs as query languages to access data stored in relational databases <ref> [16, 2, 23] </ref>. There has been considerable research on the complexity of reasoning with descriptions, especially computing the subsumption (containment) relationship between them. Surprisingly little is known about their expressive power as query languages, in comparison with well-known formalisms based on Predicate Calculus (PC). <p> For these languages, we gain ideas for subsumption algorithms from the work in the database literature on the containment problem of existential queries. A brief consideration of two DLs that have appeared in the database literature (classic <ref> [12, 16] </ref> and candide [7, 2]) indicates that they can express queries that cannot be stated in Datalog, but cannot express certain first order queries. <p> More recently, DLs have been proposed and used as query languages, thus integrating the data description and data manipulation languages <ref> [12, 7, 2, 16] </ref>. This has been particularly fruitful in data exploration applications, where one or more users, who may not be fully familiar with the database contents, are looking for interesting facts, correlations, etc. <p> description until it results in a concept with a non-empty answer [2]. * Query organization: When teams of users explore databases over periods of time, it is useful to be able to organize the queries themselves so that one can find similar queries that have been asked in the past <ref> [16] </ref>.
Reference: [17] <author> J. Cai, M. Furer, and N. Immerman, </author> <title> "An optimal lower bound on the number of variables for graph identification", </title> <booktitle> Proc. FOCS 1989, </booktitle> <address> pp.612-617 </address>
Reference-contexts: Properties of such these language families have been studied, among others, by Henkin [22], Barwise [6], Immerman <ref> [24, 17] </ref>, and Kolaitis&Vardi [25]. 4.1 DLs without trans, at-least and at-most Our first result shows that almost everything that can be said with DLs, can be said with just a few variables. <p> y ^ (9z)( (neighbors (x; z) ^ x 6= z) ^ (neighbors (y; z) ^ y 6= z)) ) whose (rather cryptic) description equivalent is some [top-role, some [ role-and [ role-and [neighbor,role-not [identity]]], compose [ role-and [neighbor,role-not [identity]], inverse [role-and [neighbor,role-not [identity]]] ] ]] In a more recent paper <ref> [17] </ref>, Immerman et al. present graphs X (G k ) that cannot be distinguished using formulae of L k !;! (COUNT). These graphs can easily be described using only existential quantifiers and conjunction. <p> The proof of the relevant results relies on certain Ehrenfreucht-Fraisse pebbling games which are shown to correspond to L k !;! (COUNT). On the other hand, Kolaitis and Vardi [25] present a modified pebbling game that characterizes L k !;! (COUNT) extended with infinitary disjunction, and the proof in <ref> [17] </ref> goes through with this new game, thus establishing that transitive closure will not be helpful in expressing these queries.
Reference: [18] <author> Chandra, A., and P. Merlin, </author> <title> "Optimal implementation of conjunctive queries in relational databases", </title> <booktitle> Proc. ACM STOC'77, </booktitle> <year> 1977, </year> <pages> pp. 77-90. </pages>
Reference: [19] <author> Cosmadakis, S., H. Gaifman, P. Kanelakis, M. Vardi, </author> <title> "Decidable optimization problems for database logic programs", </title> <booktitle> Proc. STOC'88, pp.477-490. </booktitle> <pages> 17 </pages>
Reference-contexts: It is known that the containment problem for Datalog is undecidable. However, a number of special cases have been studied in the literature (e.g., <ref> [19, 28] </ref>). In particular, when recursion is limited to monadic predicates (which is what our concepts are!), it is known that containment is decidable: Proposition 1 (Cosmadakis et al.) Given possibly recursive definitions of unary predicates in Datalog 7 , query containment is decidable in doubly-exponential time.
Reference: [20] <author> Devanbu, P., Brachman, R. J., Ballard, B. W., and Selfridge, P. G., </author> <title> "LaSSIE: A Knowledge-Based Software Information System," </title> <journal> Communications of the ACM, </journal> <volume> 34(5), </volume> <month> May, </month> <year> 1991. </year>
Reference-contexts: and then only test their instances rather than processing the entire database [7, 32]. * Schema browsing: Since concepts in the schema as well as queries can be compared for subsumption, users can explore and discover previously unknown generic facts, such as coding standards or constraints in Software Information Systems <ref> [20] </ref>.
Reference: [21] <author> Donini, F., Lenzerini, M., Nardi, D., and Nutt, W., </author> <title> "The complexity of concept languages", </title> <booktitle> Proc. KR'91, </booktitle> <address> Boston, </address> <year> 1991. </year>
Reference-contexts: Role constr. Complexity classic Polynomial [14] kris PSPACE <ref> [21] </ref> and,all, same-as | Undecidable [37] and, not, all, some, or compose, role-or, inverse, trans, restrict,top-role EXP-TIME [36] and, not, all, some, or compose, role-or, inverse, trans, restrict, fea tures, top-role Undecidable [36] Table 3: Some subsumption complexity results the former is considerably faster. <p> With this in mind, we outline a translation from descriptions to formulae of FOPC with one or two arguments. Since primitive concepts and roles are in a one-to-one correspondence with unary 3 The complexity of many subsets of kris has been thoroughly explored in <ref> [21] </ref>, and they range from PTIME to PSPACE-complete. 6 and binary predicates, their translation is quite simple: primitive concept C is represented as C (x), and primitive role r as r (x; y). Thereafter, we proceed recursively, as suggested by the entries in Table 4.
Reference: [22] <author> Henkin, L., </author> <title> Logical systems containing only a finite number of symbols., </title> <institution> Presses de l'Universite de Montreal, </institution> <year> 1967. </year>
Reference-contexts: Properties of such these language families have been studied, among others, by Henkin <ref> [22] </ref>, Barwise [6], Immerman [24, 17], and Kolaitis&Vardi [25]. 4.1 DLs without trans, at-least and at-most Our first result shows that almost everything that can be said with DLs, can be said with just a few variables.
Reference: [23] <author> Illamarendi, A., Blanco, J. and A.Goni, </author> <title> "A uniform approach to design a federated system using BACK", </title> <booktitle> Proc. Terminological Logic Users Workshop, </booktitle> <address> Berlin, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: We summarize some of these applications of DLs, though for a fuller survey the reader is directed to [11]. The present work is directly motivated by the recent use of DLs as query languages to access data stored in relational databases <ref> [16, 2, 23] </ref>. There has been considerable research on the complexity of reasoning with descriptions, especially computing the subsumption (containment) relationship between them. Surprisingly little is known about their expressive power as query languages, in comparison with well-known formalisms based on Predicate Calculus (PC). <p> Not surprisingly, DLs are therefore useful for capturing the conceptual schema of databases, i.e., as data definition languages. A number of papers have explored this aspect, including <ref> [12, 7, 8, 23] </ref>; in fact, it is shown in [9] how the Entity-Relationship and DAPLEX semantic models can be expressed in a DL.
Reference: [24] <author> Immerman, N., </author> <title> "Upper and lower bounds for first-order expressibility", </title> <journal> J. Comp. Syst. Sciences, </journal> <volume> 25, </volume> <year> 1982, </year> <pages> pp. 76-98. </pages>
Reference-contexts: Properties of such these language families have been studied, among others, by Henkin [22], Barwise [6], Immerman <ref> [24, 17] </ref>, and Kolaitis&Vardi [25]. 4.1 DLs without trans, at-least and at-most Our first result shows that almost everything that can be said with DLs, can be said with just a few variables. <p> These formulas usually involve predicates over undirected graphs, whose nodes satisfy the undary predicate N odes, and whose edges are represented by the binary predicate N eighbors. To begin with, the results in Immerman <ref> [24] </ref> show that L k1 !;! does not allow the expression of such graph-theoretic properties as the existence of a k-subclique in a graph, or even the fact that the graph consists of k unconnected nodes (i.e., the cardinality of N odes is k and N eighbors is the empty relation).
Reference: [25] <author> Kolaitis, P., M. Vardi, </author> <title> "On the expressive power of Datalog: tools and a case study", </title> <booktitle> Proc. ACM PODS'91, </booktitle> <pages> pp. 61-71. </pages>
Reference-contexts: It is known that transitive closure cannot be formulated in standard first-order logic. However, following work such as that of Kolaitis & Vardi <ref> [25] </ref>, we can express the trans constructor using infinitary disjuntion: trans [p] is just p _ compose [p,p] _ compose [p,compose [p,p]] _ : : : Given that all but one of the constructors can be expressed in FOPC, the reader may wonder why we do not dispense with the special <p> Properties of such these language families have been studied, among others, by Henkin [22], Barwise [6], Immerman [24, 17], and Kolaitis&Vardi <ref> [25] </ref>. 4.1 DLs without trans, at-least and at-most Our first result shows that almost everything that can be said with DLs, can be said with just a few variables. <p> These graphs can easily be described using only existential quantifiers and conjunction. The proof of the relevant results relies on certain Ehrenfreucht-Fraisse pebbling games which are shown to correspond to L k !;! (COUNT). On the other hand, Kolaitis and Vardi <ref> [25] </ref> present a modified pebbling game that characterizes L k !;! (COUNT) extended with infinitary disjunction, and the proof in [17] goes through with this new game, thus establishing that transitive closure will not be helpful in expressing these queries.
Reference: [26] <author> Lenzerini, M. and Schaerf, A., </author> <title> "Concept Languages as Query Languages", </title> <booktitle> Proc. AAAI'91, </booktitle> <pages> pp. 471-476. </pages>
Reference: [27] <author> MacGregor, R. M., </author> <title> "A Deductive Pattern Matcher", </title> <booktitle> in Proceedings AAAI-87, </booktitle> <address> St. Paul, Minnesota (1987) 403-408. </address> <publisher> [28] van der Meyden, </publisher> <editor> R., </editor> <title> The complexity of querying indefinite information, </title> <type> PhD Thesis, </type> <institution> Rutgers University, </institution> <month> October </month> <year> 1992. </year> <note> (The portion relevant to this paper to appear in Theoretical Computer Science) </note>
Reference-contexts: Concept constr. Role constr. classic [12] and, all, at-least, at-most, fills*, one-of*, same-as on feature chains | loom <ref> [27] </ref> and, or, not, all, some, at-least, at-most, at-least-c, at-most-c, same-as, subset, not-same-as, fills, one-of role-and, compose, inverse, restrict, product, identity back [?] and, all, at-least, at-most, same-as, one-of role-and, product kris [4] and, or, not, all, some, at-least, at-most, same-as on feature chains role-and, restrict candide [7] and, or, not,
Reference: [29] <author> Nebel, B., </author> <title> "Computational Complexity of Terminological Reasoning in BACK," </title> <journal> Artificial Intelligence, </journal> <volume> 34(3) </volume> <pages> 371-383, </pages> <month> April, </month> <year> 1988. </year>
Reference: [30] <author> B. Nebel, </author> <title> "Terminological reasoning is inherently intractable", </title> <booktitle> Artificial Intelligence 43, </booktitle> <year> 1990, </year> <month> pp.235-249 </month>
Reference-contexts: Such intermediate definitions can be expanded, but they allow one to define concepts quite succinctly so that previously tractable cases of subsumption become CoNP-hard in the presence of terminology definitions <ref> [30] </ref>. However, such problems do not appear to arise in practice.
Reference: [31] <author> Nebel, B., </author> <title> "Terminological cycles: semantics and computational properties", </title> <editor> in J. Sowa, editor, </editor> <booktitle> Principles of Semantic Networks, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: recursion "bottoms out" in cases when an individual has 0 branches, rather than requiring a separate "base case" as is traditional in logic programming. (Such base cases can however be represented in DLs which have the or constructor.) Unfortunately, there are at least three different interpretations for recursive concept definitions <ref> [31] </ref>: minimal or maximal fixpoints, and "descriptive semantics" (where any fixed point is admitted). Unlike the situation in the Datalog/Prolog community, there is no agreed-on best choice. We summarize again some of the known results in the DL community (see [31] and [3]): Language Semantics Complexity and, all, at-most, at-least gfp, <p> are at least three different interpretations for recursive concept definitions <ref> [31] </ref>: minimal or maximal fixpoints, and "descriptive semantics" (where any fixed point is admitted). Unlike the situation in the Datalog/Prolog community, there is no agreed-on best choice. We summarize again some of the known results in the DL community (see [31] and [3]): Language Semantics Complexity and, all, at-most, at-least gfp, lfp PSPACE-complete and, all, same-as on functional roles, compose fp Undecidable The notion of recursion arises in the querying of FOL databases when the same predicate may occur on both sides of a Datalog rule.
Reference: [32] <author> Nebel, B. and C. Peltason, </author> <title> "Terminological Reasoning and Information Management", </title> <editor> D. Karagianis editor, </editor> <booktitle> Information Systems and Artificial Intelligence. </booktitle>
Reference-contexts: classification hierarchy of concepts to refine her queries [34, 39, 7]. * Intensional query processing: The general processing strategy of DL queries is to "classify" the query description with respect to the pre-computed views (or saved previous queries), and then only test their instances rather than processing the entire database <ref> [7, 32] </ref>. * Schema browsing: Since concepts in the schema as well as queries can be compared for subsumption, users can explore and discover previously unknown generic facts, such as coding standards or constraints in Software Information Systems [20].
Reference: [33] <author> Owsnicki-Klewe, B., </author> <title> "Configuration as a Consistency Maintenance Task," </title> <editor> in W. Hoeppner, editor, </editor> <booktitle> Proc. of GWAI-88, </booktitle> <publisher> Springer Verlag, </publisher> <month> September, </month> <year> 1988, </year> <pages> pp. 77-87. </pages>
Reference: [34] <author> Patel-Schneider, P. F., Brachman, R. J., and Levesque, H. J., "ARGON: </author> <title> Knowledge Representation Meets Information Retrieval," </title> <booktitle> Proc. First Conf. on Artificial Intelligence Applications, </booktitle> <address> Denver, CO, </address> <month> December, </month> <year> 1984, </year> <pages> pp. 280-286. </pages>
Reference-contexts: Moreover, users may record observations about the query and its answer, using "meta" objects. * Query formulation by refinement: A user exploring the database can use the classification hierarchy of concepts to refine her queries <ref> [34, 39, 7] </ref>. * Intensional query processing: The general processing strategy of DL queries is to "classify" the query description with respect to the pre-computed views (or saved previous queries), and then only test their instances rather than processing the entire database [7, 32]. * Schema browsing: Since concepts in the
Reference: [35] <author> Sagiv, Y. and M. Yannakakis, </author> <title> "Equivalence among relational expressions with the union and difference operators", </title> <journal> JACM 29:1, </journal> <year> 1981, </year> <month> pp.633-655. </month>
Reference-contexts: This result is in contrast with the proven NP-completeness of the containment problem for F OL (9; ^), and is connected with the fact that certain conjunctive queries (such as k-clique) cannot be stated in D conj . 14 Based on results in <ref> [35] </ref>, subsumption in a more expressive language, F OL (9; ^; _), which also allows disjunction, can be dealt with by putting the query in disjunctive normal form (with a po tential exponential blow-up), and then checking the component conjunctive queries for containment as before.
Reference: [36] <author> Schild, K., </author> <title> "A correspondence theory for terminological logics | preliminary report", </title> <booktitle> Proc. </booktitle> <address> IJCAI'91, Sydney, Australia. </address>
Reference-contexts: Role constr. Complexity classic Polynomial [14] kris PSPACE [21] and,all, same-as | Undecidable [37] and, not, all, some, or compose, role-or, inverse, trans, restrict,top-role EXP-TIME <ref> [36] </ref> and, not, all, some, or compose, role-or, inverse, trans, restrict, fea tures, top-role Undecidable [36] Table 3: Some subsumption complexity results the former is considerably faster. <p> Role constr. Complexity classic Polynomial [14] kris PSPACE [21] and,all, same-as | Undecidable [37] and, not, all, some, or compose, role-or, inverse, trans, restrict,top-role EXP-TIME <ref> [36] </ref> and, not, all, some, or compose, role-or, inverse, trans, restrict, fea tures, top-role Undecidable [36] Table 3: Some subsumption complexity results the former is considerably faster.
Reference: [37] <author> Schmidt-Schauss, M., </author> <title> "Subsumption in KL-ONE is undecidable", </title> <booktitle> in Proceedings KR'91, </booktitle> <address> Toronto, Canada, </address> <month> May </month> <year> 1989, </year> <pages> 421-431. </pages>
Reference-contexts: Role constr. Complexity classic Polynomial [14] kris PSPACE [21] and,all, same-as | Undecidable <ref> [37] </ref> and, not, all, some, or compose, role-or, inverse, trans, restrict,top-role EXP-TIME [36] and, not, all, some, or compose, role-or, inverse, trans, restrict, fea tures, top-role Undecidable [36] Table 3: Some subsumption complexity results the former is considerably faster.
Reference: [38] <author> Schmolze, J.G., D. Israel, </author> <title> "KL-ONE: semantics and classification", in Research in Knowledge Represet-nation for Natural Language Understanding | ANnual Report, </title> <type> Tech Report 5421, </type> <institution> BBN Laboratories, </institution> <year> 1983. </year>
Reference-contexts: Such a similarity was already exploited by Schmolze&Israel <ref> [38] </ref> to give a semantics for the original kl-one language using -calculus. We wish to pursue this similarity, but in order to compare the two formalisms we need a common framework.
Reference: [39] <author> Tou, F., M. Williams, R. Fikes, A. Henderson, T. Malone, "RABBIT: </author> <title> An intelligent database assistant", </title> <booktitle> Proc. </booktitle> <address> AAAI'82. </address>
Reference-contexts: Moreover, users may record observations about the query and its answer, using "meta" objects. * Query formulation by refinement: A user exploring the database can use the classification hierarchy of concepts to refine her queries <ref> [34, 39, 7] </ref>. * Intensional query processing: The general processing strategy of DL queries is to "classify" the query description with respect to the pre-computed views (or saved previous queries), and then only test their instances rather than processing the entire database [7, 32]. * Schema browsing: Since concepts in the
Reference: [40] <author> J. Ullman, </author> <title> Principles of database and Knowledge-Base Systems, </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: Its most significant consequence is the use for subsumption testing of the algorithm for detecting containment of conjunctive queries ([18] or Chapter 14 of <ref> [40] </ref>). That algorithm Skolemizes the contained query, and uses it as a database in which to check if the containing query has a non-empty answer.
Reference: [41] <author> Woods, W. A., and Schmolze, J. G., </author> <title> "The KL-ONE Family," Computers and Mathematics with Applications 23(2-5), </title> <booktitle> Special Issue on Semantic Networks in Artificial Intelligence. </booktitle> <pages> 18 </pages>
Reference-contexts: Table 1 presents the language KL, which consists of a quite comprehensive list of the constructors considered in the DL literature so far 1 ; it comes from recent survey papers <ref> [41] </ref> and an effort to establish a standard notation and semantics to support knowledge-base interchange [5]. The language of descriptions is obtained recursively by starting from atomic symbols for primitive concepts and roles.
References-found: 40

