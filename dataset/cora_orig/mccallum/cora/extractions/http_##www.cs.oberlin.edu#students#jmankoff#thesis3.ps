URL: http://www.cs.oberlin.edu/students/jmankoff/thesis3.ps
Refering-URL: http://www.cs.gatech.edu/people/home/jmankoff/honors.html
Root-URL: 
Email: (jmankoff@cs.oberlin.edu)  
Title: IIC: Information in Context  
Author: Jen Mankoff 
Date: January 5, 1996  
Affiliation: Oberlin College, Computer Science  
Abstract: IIC (Information in Context) is an interactive programming environment meant to be used for profiling and tracing functions, as well as for visualizing information about functions. IIC runs in the Scheme interpreter STk and has both a graphical and a textual user interface. By integrating a profiling environment with a visualization system, IIC gives the programmer the power to dissect the internals of her program. In addition, IIC gives the programmer the power to control what data is gathered through the use of scope IIC makes it possible to evaluate the efficiency of functions and to easily identify bottlenecks. IIC can also be useful for debugging. 
Abstract-found: 1
Intro-found: 1
Reference: [AC76] <author> F. E. Allen and J. Cocje. </author> <title> A program dataflow analysis procedure. </title> <journal> Communications of the ACM, </journal> <volume> 19(3) </volume> <pages> 137-147, </pages> <month> March </month> <year> 1976. </year>
Reference-contexts: This is generally referred to as "execution profiling" ([San94], [Kis92]) Execution trace: At runtime, a trace of functions called and arguments can be printed out. The trace function in Chez Scheme ([Dyb87]) provides an example of this Dataflow information: Dataflow information ([MJ81], [Bar93] <ref> [AC76] </ref>, [Ryd83], [KSF92], [OCH91], [Wei84], [AH90], [Bal93], [ASU86], [Dat82]) can be used to analyze possible execution paths which may be fol lowed in a program: * Dynamic dataflow analyses At runtime, information can be gathered about every function that is called, and which function it was called from ([Cho89]).
Reference: [AH90] <author> Hiralal Agrawal and Joseph R. Horgan. </author> <title> Dynamic program slicing. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 246-256. </pages> <publisher> ACM SIG-PLAN, ACM Press, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: This is generally referred to as "execution profiling" ([San94], [Kis92]) Execution trace: At runtime, a trace of functions called and arguments can be printed out. The trace function in Chez Scheme ([Dyb87]) provides an example of this Dataflow information: Dataflow information ([MJ81], [Bar93] [AC76], [Ryd83], [KSF92], [OCH91], [Wei84], <ref> [AH90] </ref>, [Bal93], [ASU86], [Dat82]) can be used to analyze possible execution paths which may be fol lowed in a program: * Dynamic dataflow analyses At runtime, information can be gathered about every function that is called, and which function it was called from ([Cho89]).
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: The trace function in Chez Scheme ([Dyb87]) provides an example of this Dataflow information: Dataflow information ([MJ81], [Bar93] [AC76], [Ryd83], [KSF92], [OCH91], [Wei84], [AH90], [Bal93], <ref> [ASU86] </ref>, [Dat82]) can be used to analyze possible execution paths which may be fol lowed in a program: * Dynamic dataflow analyses At runtime, information can be gathered about every function that is called, and which function it was called from ([Cho89]).
Reference: [Bal93] <author> Thomas Ball. </author> <title> What's in a region? or computing control dependence regions in near-linear time for reducible control flow. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2(1-4):1-16, </volume> <month> March-December </month> <year> 1993. </year>
Reference-contexts: This is generally referred to as "execution profiling" ([San94], [Kis92]) Execution trace: At runtime, a trace of functions called and arguments can be printed out. The trace function in Chez Scheme ([Dyb87]) provides an example of this Dataflow information: Dataflow information ([MJ81], [Bar93] [AC76], [Ryd83], [KSF92], [OCH91], [Wei84], [AH90], <ref> [Bal93] </ref>, [ASU86], [Dat82]) can be used to analyze possible execution paths which may be fol lowed in a program: * Dynamic dataflow analyses At runtime, information can be gathered about every function that is called, and which function it was called from ([Cho89]).
Reference: [Bar77] <author> Jeffery M. Barth. </author> <title> An interprocedural data flow analysis algorithm. </title> <booktitle> In The Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 119-131, </pages> <address> Los Angelos, California, </address> <month> January </month> <year> 1977. </year> <note> ACM Press. </note>
Reference: [Bar93] <author> Andrew J. Barnard. </author> <title> From Types to Dataflow: Code Analysis for an Object-Oriented Language. </title> <type> PhD thesis, </type> <institution> University of Manchester CS, </institution> <year> 1993. </year>
Reference-contexts: This is generally referred to as "execution profiling" ([San94], [Kis92]) Execution trace: At runtime, a trace of functions called and arguments can be printed out. The trace function in Chez Scheme ([Dyb87]) provides an example of this Dataflow information: Dataflow information ([MJ81], <ref> [Bar93] </ref> [AC76], [Ryd83], [KSF92], [OCH91], [Wei84], [AH90], [Bal93], [ASU86], [Dat82]) can be used to analyze possible execution paths which may be fol lowed in a program: * Dynamic dataflow analyses At runtime, information can be gathered about every function that is called, and which function it was called from ([Cho89]). <p> A type inference system can also help the programmer to determine what type the interpreter will assign to a variable. A comparison of the relative usefulness of type versus dataflow information can be found in <ref> [Bar93] </ref>. Text-based information: Program text can be scanned for cliches (i.e., the word sort, or standard algorithms, or loops) and this can be used to facilitate editing ([Wat94]) or provide suggestions (i.e., recognizing or giving warnings about potential endless loops).
Reference: [Ber93] <author> Karen L. Bernstein. </author> <title> Debugging strict functional programs. </title> <month> November </month> <year> 1993. </year>
Reference: [Cho89] <author> Jongdeok Choi. </author> <title> Parallel Program Debugging with Flowback Analysis. </title> <type> PhD thesis, </type> <institution> University of Wisconsin - Madison, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], <ref> [Cho89] </ref>, [Duc93], [GH92], [Kam90], [nML92], [Nai92], [NF92], [OCH91], [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access
Reference: [CJ91] <editor> William Clinger and Jonathon Rees, editors. </editor> <title> Revised 4 report on the algorithmic language scheme, </title> <year> 1991. </year>
Reference: [Cle43] <author> William S. Cleveland. </author> <title> The Elements of Graphing Data. Number ISBN 0-534-03730-5. Wadsworth Advanced Books and Software, </title> <address> CA, </address> <year> 1943. </year>
Reference-contexts: Note that the ticks along the bottom of the plus/goodfib-helper graph do not necessarily represent the exact number on which a data value will fall. The ticks are generated based on the suggestions of William Cleveland in <ref> [Cle43] </ref>. In general IIC aims for between 5 and 10 tick marks. It attempts to find integer values for these tick marks, but the algorithm has not been perfected, and occasionally it misses as in the plus/goodfib-helper graph in Figure 2. The help facilities in IIC are relatively simple.
Reference: [Cle93] <author> William S. Cleveland. </author> <title> Visualizing Data. Number ISBN 0-9634884-0-6 Cloth. </title> <publisher> Hobart Press, </publisher> <address> NJ, </address> <year> 1993. </year>
Reference-contexts: By visualizing parts of that information using graphs and charts, the programmer can extract meaning from it. The principles used by IIC for data visualization were derived from the work of William S. Cleveland ([Cle43], [JMCT83], <ref> [Cle93] </ref>). 4 Implementation IIC was implemented using the STk ([Gal]) interpreter. IIC was implemented solely at the scheme level: no modifications were made to the interpreter itself.
Reference: [Dat82] <institution> February 1982. Computer Magazine: </institution> <note> Focus on Dataflow. </note>
Reference-contexts: The trace function in Chez Scheme ([Dyb87]) provides an example of this Dataflow information: Dataflow information ([MJ81], [Bar93] [AC76], [Ryd83], [KSF92], [OCH91], [Wei84], [AH90], [Bal93], [ASU86], <ref> [Dat82] </ref>) can be used to analyze possible execution paths which may be fol lowed in a program: * Dynamic dataflow analyses At runtime, information can be gathered about every function that is called, and which function it was called from ([Cho89]).
Reference: [DFAB93] <author> Alan Dix, Janet Finlay, Gregory Abowd, and Russel Beale. </author> <title> Human-Computer Interaction. Number QA76.9.H85H85, </title> <address> ISBN 0-13-458266-7 (hbk.) - ISBN 0-13-437211-5 (pbk.). </address> <publisher> Prentice Hall International, </publisher> <address> UK, </address> <year> 1993. </year>
Reference-contexts: In addition, it integrates information gathering with information visualization and a graphical user interface meant to increase ease of use ([TS84], <ref> [DFAB93] </ref>). 1.2 Information in Context Context is defined as "The circumstances in which a particular event occurs" (from the Webster program, written by David A. Curry). In the case of IIC, an event is a function call. <p> The viewer can also display a dotplot of data chosen based on a viewer-provided function which selects input values. This allows the viewer, for example, to compare the performance of five different implementations of sort on lists of length 100. 4.3 The Interface The interface for IIC ([TS84], <ref> [DFAB93] </ref>) was not designed using a specific set of user interface guidelines. It does, however, attempt to fulfill the nine heuristics listed in Table 1 (from [NM90]).
Reference: [Duc93] <author> Mireille Ducasse. </author> <title> A pragmatic survey of automated debugging. </title> <booktitle> In 1st International Workshop on Automated and Algorithmic Debugging, </booktitle> <pages> pages 1-15. </pages> <institution> Department of Computer and Information Science, Linkoping University, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], [Cho89], <ref> [Duc93] </ref>, [GH92], [Kam90], [nML92], [Nai92], [NF92], [OCH91], [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access to
Reference: [Dyb87] <author> R. Kent Dybvig. </author> <title> The Scheme Programming Language. Number ISBN 0-13-791864-X 025. </title> <publisher> Prentice Hall, </publisher> <address> NJ, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], <ref> [Dyb87] </ref>, [Cho89], [Duc93], [GH92], [Kam90], [nML92], [Nai92], [NF92], [OCH91], [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer
Reference: [ELJ94] <author> Todd R. Eigenschink, Dave Love, and Aubrey Jaffer. Slib, </author> <title> the portable scheme library. </title> <month> April </month> <year> 1994. </year>
Reference-contexts: This alone would be a large programming project. 1 ([Ret93], p. 26) Integrated Problem Setting and Problem Solving: "Allow people to propose a partial solution (by choosing from a catalogue of parts or starting from scratch), consult the critics, then plan their next move." 2 (eg <ref> [ELJ94] </ref>) In the context of programming environments, such a catalogue might for example include the Scheme slib [ELJ94] library. Integrated Action and Reflection: This ties in with the above item. <p> Problem Setting and Problem Solving: "Allow people to propose a partial solution (by choosing from a catalogue of parts or starting from scratch), consult the critics, then plan their next move." 2 (eg <ref> [ELJ94] </ref>) In the context of programming environments, such a catalogue might for example include the Scheme slib [ELJ94] library. Integrated Action and Reflection: This ties in with the above item. When the programming process stalls, the programmer can consult a critic (in addition to reflecting or consulting the tutor or a friend).
Reference: [FF89] <author> Daniel P. Friedman and Matthias Felleisen. </author> <title> The Little Lisper. Number ISBN 0-574-24005-5. </title> <institution> Science Research Associates, Chicago, </institution> <note> 3rd edition, </note> <year> 1989. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], [Cho89], [Duc93], [GH92], [Kam90], [nML92], [Nai92], [NF92], [OCH91], [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], <ref> [FF89] </ref>) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access to a small subset of the information which could be useful to her.
Reference: [FL88] <author> Charles N. Fischer and Richard J. LeBlanc, Jr. </author> <title> Crafting A Compiler. Number ISBN 0-8053-3201-4. </title> <address> Benjamin/Cummings, Menlo Park, California, </address> <year> 1988. </year>
Reference: [Gal] <author> Erick Gallesio. </author> <title> Stk reference manual. </title> <type> 21 </type>
Reference: [GH92] <author> Michael Golan and David R. Hanson. </author> <title> Duel a very high-level debugging language. </title> <type> Technical Report CS-TR-399-92, </type> <institution> Princeton University, </institution> <month> November </month> <year> 1992. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], [Cho89], [Duc93], <ref> [GH92] </ref>, [Kam90], [nML92], [Nai92], [NF92], [OCH91], [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access to a
Reference: [HL] <author> Per Hammarlundt and Bjorn Lisper. </author> <title> On the relation between functional and data parallel programming languages. </title> <type> Technical report, </type> <institution> Royal Institute of Technology, </institution> ?? 
Reference: [HLR91] <author> Halbwachs, Lagnier, and Ralel. </author> <title> Generating efficient code from dataflow programs. </title> <type> Technical Report SPECTRE L8, </type> <institution> IMAGE, Grenoble, </institution> <year> 1991. </year>
Reference: [HO85] <author> Cordelia V. Hall and John T. O'Donnell. </author> <title> Debugging in a side effect free programming environment. </title> <booktitle> In Proceedings of the ACM SIGPLAN 85 Symposium on Language Issues in Programming Environments, </booktitle> <pages> pages 60-68. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1985. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], <ref> [HO85] </ref>, [NF93], [Dyb87], [Cho89], [Duc93], [GH92], [Kam90], [nML92], [Nai92], [NF92], [OCH91], [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow
Reference: [Hor90] <author> Susan Horowitz. </author> <title> Identifying the semantic and textual differences between two versions of a program. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 234-244. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1990. </year>
Reference: [JMCT83] <author> Beat Kleiner John M. Chambers, William S. Cleveland and Paul A. Tukey. </author> <title> Graphical Methods for Data Analysis. Number ISBN 0-87150-413-8 in Wadsworth Statistics/Probability series. </title> <publisher> Wadsworth International Group, CA and Duxbury Press, </publisher> <address> MA, </address> <year> 1983. </year>
Reference-contexts: By visualizing parts of that information using graphs and charts, the programmer can extract meaning from it. The principles used by IIC for data visualization were derived from the work of William S. Cleveland ([Cle43], <ref> [JMCT83] </ref>, [Cle93]). 4 Implementation IIC was implemented using the STk ([Gal]) interpreter. IIC was implemented solely at the scheme level: no modifications were made to the interpreter itself.
Reference: [Kam90] <author> Samuel Kamin. </author> <title> A debugging environment for functional programming in centaur. </title> <type> Technical Report 1265, </type> <institution> INRIA Sophia-Intipolis, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], [Cho89], [Duc93], [GH92], <ref> [Kam90] </ref>, [nML92], [Nai92], [NF92], [OCH91], [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access to a small
Reference: [Kis92] <author> Amir Shai Kishon. </author> <title> Theory and Art of Semantics-Directed Program Execution Monitoring. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], [Cho89], [Duc93], [GH92], [Kam90], [nML92], [Nai92], [NF92], [OCH91], [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], <ref> [Kis92] </ref>) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access to a small subset of the information which could be useful to her. <p> In addition, at runtime, a specific set of functions can be watched and their space usage/ CPU usage can be recorded. This is generally referred to as "execution profiling" ([San94], <ref> [Kis92] </ref>) Execution trace: At runtime, a trace of functions called and arguments can be printed out.
Reference: [KSF92] <author> Mariam Kamkar, Nahid Shahmehri, and Peter Fritzon. </author> <title> Interprocedural dynamic slicing. </title> <booktitle> In Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 370-384. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: This is generally referred to as "execution profiling" ([San94], [Kis92]) Execution trace: At runtime, a trace of functions called and arguments can be printed out. The trace function in Chez Scheme ([Dyb87]) provides an example of this Dataflow information: Dataflow information ([MJ81], [Bar93] [AC76], [Ryd83], <ref> [KSF92] </ref>, [OCH91], [Wei84], [AH90], [Bal93], [ASU86], [Dat82]) can be used to analyze possible execution paths which may be fol lowed in a program: * Dynamic dataflow analyses At runtime, information can be gathered about every function that is called, and which function it was called from ([Cho89]).
Reference: [Lef81] <author> Robert Lefferts. </author> <title> Elements of Graphics how to prepare charts and graphs for effective reports. Number ISBN 0-06-012578-0. </title> <publisher> Harper & Row, </publisher> <address> NY, </address> <year> 1981. </year>
Reference: [MJ81] <editor> Steven S. Muchnick and Neil D. Jones, editors. </editor> <title> Program Flow Analysis: Theory and Applications. Number ISBN 0-13-729681-9 in Software Series. </title> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference: [Nai92] <author> Lee Naish. </author> <title> Declarative debugging. </title> <type> Technical Report 92/6, </type> <institution> University of Melbourne, University of Melbourne, </institution> <address> Victoria, Australia, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], [Cho89], [Duc93], [GH92], [Kam90], [nML92], <ref> [Nai92] </ref>, [NF92], [OCH91], [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access to a small subset of
Reference: [NF92] <author> Henrik Nilsson and Peter Fritzson. </author> <title> Algorithmic debugging for lazy functional languages. </title> <booktitle> In Programming Language Implementation and Logic Programming, </booktitle> <pages> pages 385-399. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], [Cho89], [Duc93], [GH92], [Kam90], [nML92], [Nai92], <ref> [NF92] </ref>, [OCH91], [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access to a small subset of the
Reference: [NF93] <author> Henrik Nilsson and Peter Fritzson. </author> <title> Lazy algorithmic debugging: Ideas for practical implementation. </title> <booktitle> In 1st International Workshop on Automated and Algorithmic Debugging, </booktitle> <pages> pages 151-165. </pages> <institution> Department of Computer and Information Science, Linkoping University, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], <ref> [NF93] </ref>, [Dyb87], [Cho89], [Duc93], [GH92], [Kam90], [nML92], [Nai92], [NF92], [OCH91], [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the
Reference: [NM90] <author> Jakob Nielson and Rolf Molich. </author> <title> Heuristic evaluation of user interfaces. </title> <booktitle> In ACM Conference on Computer Human Interaction, </booktitle> <pages> pages 249-256. SIGCHI, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: It does, however, attempt to fulfill the nine heuristics listed in Table 1 (from <ref> [NM90] </ref>). In general, all of the important functions of IIC's interface are implemented both as part of the graphical user interface and as part of the textual user interface. IIC's interface consists of two windows: The "Watch Graph" and the "Watcher" windows. <p> In order to test these properties of IIC, people not involved in the development process of the program were asked to help with its evaluation. 5.1 User evaluation of the interface The standard approach to user evaluation of an interface involves developing a questionnaire about the interface. In <ref> [NM90] </ref>, it is shown that five to ten subjects without training in Human Computer Interaction, working independently, discovered more than two thirds of the known (to the researchers) problems with a user interface. In addition, those subjects found problems that were not previously known to the researchers.
Reference: [nML92] <author> Guy LaPalme nad Mario Latendresse. </author> <title> A debugging environment for lazy functional languages. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 5 </volume> <pages> 271-287, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], [Cho89], [Duc93], [GH92], [Kam90], <ref> [nML92] </ref>, [Nai92], [NF92], [OCH91], [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access to a small subset
Reference: [OCH91] <author> Ronald A. Olsson, Richard H. Crawford, and W. Wilson Ho. </author> <title> A dataflow approach to event-based debugging. </title> <journal> Software Practice and Experience, </journal> <volume> 21(2) </volume> <pages> 209-229, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], [Cho89], [Duc93], [GH92], [Kam90], [nML92], [Nai92], [NF92], <ref> [OCH91] </ref>, [Sha83], [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access to a small subset of the information <p> This is generally referred to as "execution profiling" ([San94], [Kis92]) Execution trace: At runtime, a trace of functions called and arguments can be printed out. The trace function in Chez Scheme ([Dyb87]) provides an example of this Dataflow information: Dataflow information ([MJ81], [Bar93] [AC76], [Ryd83], [KSF92], <ref> [OCH91] </ref>, [Wei84], [AH90], [Bal93], [ASU86], [Dat82]) can be used to analyze possible execution paths which may be fol lowed in a program: * Dynamic dataflow analyses At runtime, information can be gathered about every function that is called, and which function it was called from ([Cho89]).
Reference: [Ous94] <author> John K. Ousterhout. </author> <title> Tcl and the Tk Toolkit. Number ISBN 0-201-63337-X in Professional Computing Series. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year> <month> 22 </month>
Reference-contexts: STk has the following properties: Scheme: STk is, at heart, a Scheme interpreter. STk is R4RS [CJR91] compatible. Tk: The most important of the extensions to Scheme in STk (and the basis for the name STk - Scheme-Tk) is the Tk <ref> [Ous94] </ref> widget set. The TK widget set combined with the CLOS-like object system (see below) make it possible to quickly prototype user interfaces. A CLOS-like Object System: STk also comes with a CLOS-like object system.
Reference: [Ret93] <author> Marc Rettig. </author> <title> Cooperative software. </title> <journal> Communications of the ACM, </journal> <volume> 36(4) </volume> <pages> 23-28, </pages> <month> April </month> <year> 1993. </year> <title> Practical Programming. </title>
Reference-contexts: In <ref> [Ret93] </ref>, cooperative software is defined to have the following properties: Cooperative Software [Ret93]: Domain Orientation: A tool with this property can easily incorporate and represent aspects of the specific domain it is used in. This simplifies the problem of communicating with the user. Clearly, my tool has this property. <p> In <ref> [Ret93] </ref>, cooperative software is defined to have the following properties: Cooperative Software [Ret93]: Domain Orientation: A tool with this property can easily incorporate and represent aspects of the specific domain it is used in. This simplifies the problem of communicating with the user. Clearly, my tool has this property.
Reference: [Ryd83] <author> Barbara G. Ryder. </author> <title> Incremental data flow analysis. </title> <booktitle> In The Tenth ACM Symposium on Principals of Programming Languages, </booktitle> <pages> pages 167-176, </pages> <address> Austin, Texas, </address> <month> January </month> <year> 1983. </year> <note> ACM Press. </note>
Reference-contexts: This is generally referred to as "execution profiling" ([San94], [Kis92]) Execution trace: At runtime, a trace of functions called and arguments can be printed out. The trace function in Chez Scheme ([Dyb87]) provides an example of this Dataflow information: Dataflow information ([MJ81], [Bar93] [AC76], <ref> [Ryd83] </ref>, [KSF92], [OCH91], [Wei84], [AH90], [Bal93], [ASU86], [Dat82]) can be used to analyze possible execution paths which may be fol lowed in a program: * Dynamic dataflow analyses At runtime, information can be gathered about every function that is called, and which function it was called from ([Cho89]).
Reference: [San94] <author> Patrick M. Sansom. </author> <title> Execution Profiling for Non-strict Functional Languages. </title> <type> PhD thesis, </type> <institution> University of Glasgow, </institution> <year> 1994. </year>
Reference: [Sha83] <author> Ehud Y. Shapiro. </author> <title> Algorithmic Program Debugging. </title> <type> PhD thesis, </type> <institution> ACM Distinguished Dissertations, </institution> <year> 1983. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], [Cho89], [Duc93], [GH92], [Kam90], [nML92], [Nai92], [NF92], [OCH91], <ref> [Sha83] </ref>, [Sny90], [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access to a small subset of the information which
Reference: [Sny90] <author> Robin M. Snyder. </author> <title> Lazy debugging of lazy functional programs. </title> <journal> New Generation Computing, </journal> <volume> 3 </volume> <pages> 139-161, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], [Cho89], [Duc93], [GH92], [Kam90], [nML92], [Nai92], [NF92], [OCH91], [Sha83], <ref> [Sny90] </ref>, [Tol92], [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access to a small subset of the information which could
Reference: [Tol92] <author> Andrew Tolmach. </author> <title> Debugging Standard ML. </title> <type> PhD thesis, </type> <institution> Princeton University, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: 1 Introduction 1.1 Goals and Motivations While simple debuggers ([Ber93], [HO85], [NF93], [Dyb87], [Cho89], [Duc93], [GH92], [Kam90], [nML92], [Nai92], [NF92], [OCH91], [Sha83], [Sny90], <ref> [Tol92] </ref>, [WN88]), execution profilers ([San94], [Kis92]) and trace facilities like those available in Chez Scheme ([Dyb87], [FF89]) allow you to view events in a functions execution and to traverse the execution stack are widely available, they only allow the programmer access to a small subset of the information which could be
Reference: [TS84] <editor> John C. Thomas and Michael L. Schneider, editors. </editor> <booktitle> Human Factors in Computer Systems. Number ISBN 0-89391-146-1 in Human/Computer Interaction. </booktitle> <publisher> Ablex Publishing Co, </publisher> <address> New Jersey, </address> <year> 1984. </year>
Reference: [Wat94] <author> Richard C. Waters. </author> <title> Cliche-based program editors. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(1) </volume> <pages> 102-150, </pages> <month> January </month> <year> 1994. </year>
Reference: [Wei84] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: This is generally referred to as "execution profiling" ([San94], [Kis92]) Execution trace: At runtime, a trace of functions called and arguments can be printed out. The trace function in Chez Scheme ([Dyb87]) provides an example of this Dataflow information: Dataflow information ([MJ81], [Bar93] [AC76], [Ryd83], [KSF92], [OCH91], <ref> [Wei84] </ref>, [AH90], [Bal93], [ASU86], [Dat82]) can be used to analyze possible execution paths which may be fol lowed in a program: * Dynamic dataflow analyses At runtime, information can be gathered about every function that is called, and which function it was called from ([Cho89]).

References-found: 46

