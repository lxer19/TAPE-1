URL: http://cs.utep.edu/gelfond/papers/actions-jlp.ps
Refering-URL: http://cs.utep.edu/gelfond/gelfond.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Representing Action and Change by Logic Programs  
Author: Michael Gelfond Vladimir Lifschitz 
Address: El Paso, TX 79968  Austin, TX 78712  
Affiliation: Department of Computer Science University of Texas at El Paso  Department of Computer Sciences and Department of Philosophy University of Texas at Austin  
Abstract: We represent properties of actions in a logic programming language that uses both classical negation and negation as failure. The method is applicable to temporal projection problems with incomplete information, as well as to reasoning about the past. It is proved to be sound relative to a semantics of action based on states and transition functions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Krzysztof Apt and Marc Bezem. </author> <title> Acyclic programs. </title> <editor> In David Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 617-633, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction This paper extends the work of Eshghi and Kowalski [6], Evans [7] and Apt and Bezem <ref> [1] </ref> on representing properties of actions in logic programming languages with negation as failure. Our goal is to overcome some of the limitations of the earlier work. <p> Y 8. :Holds (Loaded; s) Holds (Alive ; Result (Shoot ; s)). Y 9. :Holds (Loaded; Result (Shoot ; s)). Y 10. Noninertial (Loaded; Shoot; s). It is instructive to compare this set of rules with the formalization of Yale Shooting given by Apt and Bezem <ref> [1] </ref>, who were only interested in temporal projection problems, and did not use classical negation. Instead of our four inertia rules, they have one, corresponding to the first of the rules (7). In addition, their program includes counterparts of Y 2, Y 3, Y 5 and Y 6.
Reference: [2] <author> Andrew Baker. </author> <title> Nonmonotonic reasoning in the framework of situation calculus. </title> <journal> Artificial Intelligence, </journal> <volume> 49 </volume> <pages> 5-23, </pages> <year> 1991. </year>
Reference-contexts: The domain is characterized by the propositions initially :Loaded; initially Alive ; Load causes Loaded; Shoot causes :Alive if Loaded; Shoot causes :Loaded: Example 3. The Murder Mystery domain, motivated by an example from <ref> [2] </ref>, is obtained from the Yale Shooting domain by substituting :Alive after Shoot; Wait (3) for the proposition initially :Loaded. Example 4. <p> The possibilities and limitations of different representation methods can be compared in a precise fashion. For instance, in [15] this approach is used to prove the equivalence of the methods for formalizing actions proposed earlier by Pednault [26], Reiter [31] and Baker <ref> [2] </ref> for the domains representable in A. On the other hand, this paper is one of the first experiments (along with [17], [27], [10]) on using extended logic programs for representing knowledge. Not much is known yet about mathematical properties of extended programs.
Reference: [3] <author> Chitta Baral and Michael Gelfond. </author> <title> Representing concurrent actions in extended logic programming. </title> <type> Manuscript, </type> <year> 1992. </year>
Reference-contexts: One way to include nondeterminism is to allow effect propositions to contain disjunctions, for instance: TossCoin causes Heads _ Tails: Semantically, in either case, nondeterministic transition functions will be used. In the corresponding logic program, the effect of TossCoin will be expressed by a disjunctive rule. In <ref> [3] </ref>, the extension of A is introduced in which one can describe the concurrent execution of actions.
Reference: [4] <author> Weidong Chen and David S. Warren. </author> <title> A goal-oriented approach to computing well-founded semantics. </title> <editor> In Krzysztof Apt, editor, </editor> <booktitle> Proc. Joint Int'l Conf. and Symp. on Logic Programming, </booktitle> <pages> pages 589-603, </pages> <year> 1992. </year>
Reference-contexts: The possibility of using the logic programs proposed in this paper for the automation of temporal reasoning, based on program transformations and the XOLDTNF metainterpreter <ref> [4] </ref>, is demonstrated in the forthcoming paper [20]. Two parts of this paper may be of more general interest. First, we introduce here a simple declarative language for describing actions, called A.
Reference: [5] <author> Phan Minh Dung. </author> <title> On the relations between stable and well-founded semantics of logic programs. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1992. </year> <note> To appear. </note>
Reference-contexts: pre-fixpoint of is any set X such that X X.) This characterization of the least fixpoint of is used in the proof of the soundness lemma below. 6 The existence of answer sets for such programs, and for programs of some more general types, was established by Phan Minh Dung <ref> [5] </ref> and Fran~cois Fages [8]. 23 7 Proof of the Soundness Lemma The results of the previous section are not directly applicable to programs with classical negation. It is known, however, that any extended program can be converted into a closely related program without classical negation, as follows [12].
Reference: [6] <author> Kave Eshghi and Robert Kowalski. </author> <title> Abduction compared with negation as failure. </title> <editor> In Giorgio Levi and Maurizio Martelli, editors, </editor> <booktitle> Logic Programming: Proc. of the Sixth Int'l Conf., </booktitle> <pages> pages 234-255, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction This paper extends the work of Eshghi and Kowalski <ref> [6] </ref>, Evans [7] and Apt and Bezem [1] on representing properties of actions in logic programming languages with negation as failure. Our goal is to overcome some of the limitations of the earlier work.
Reference: [7] <author> Chris Evans. </author> <title> Negation-as-failure as an approach to the Hanks and McDermott problem. </title> <booktitle> In Proc. of the Second Int'l Symp. on Artificial Intelligence, </booktitle> <year> 1989. </year> <month> 39 </month>
Reference-contexts: 1 Introduction This paper extends the work of Eshghi and Kowalski [6], Evans <ref> [7] </ref> and Apt and Bezem [1] on representing properties of actions in logic programming languages with negation as failure. Our goal is to overcome some of the limitations of the earlier work.
Reference: [8] <author> Fran~cois Fages. </author> <title> Consistency of Clark's completion and existence of stable models. </title> <note> Journal of Methods of logic in computer science, 1992. To appear. </note>
Reference-contexts: set X such that X X.) This characterization of the least fixpoint of is used in the proof of the soundness lemma below. 6 The existence of answer sets for such programs, and for programs of some more general types, was established by Phan Minh Dung [5] and Fran~cois Fages <ref> [8] </ref>. 23 7 Proof of the Soundness Lemma The results of the previous section are not directly applicable to programs with classical negation. It is known, however, that any extended program can be converted into a closely related program without classical negation, as follows [12].
Reference: [9] <author> Michael Gelfond. </author> <title> On stratified autoepistemic theories. </title> <booktitle> In Proc. AAAI-87, </booktitle> <pages> pages 207-211, </pages> <year> 1987. </year>
Reference: [10] <author> Michael Gelfond. </author> <title> Logic programming and reasoning with incomplete information. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <note> 1993. To appear. </note>
Reference-contexts: On the other hand, this paper is one of the first experiments (along with [17], [27], <ref> [10] </ref>) on using extended logic programs for representing knowledge. Not much is known yet about mathematical properties of extended programs. For this reason, in this initial experiment, the source language A was deliberately made quite simple, and we did not try to make the translation complete.
Reference: [11] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <editor> In Robert Kowalski and Kenneth Bowen, editors, </editor> <booktitle> Logic Programming: Proc. of the Fifth Int'l Conf. and Symp., </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: A counterexample is given showing that the translation is incomplete. A possible way of achieving completeness is discussed in the last section. Second, the proof of the main theorem depends on a relationship between stable models <ref> [11] </ref> and signings [18], that may be interesting as a part of the general theory of logic programming. The language A is introduced in Section 2, and Section 3 is a brief review of extended logic programs. <p> Recall that, for general logic programs, the notion of an answer set (or "stable model") can be defined by means of the following construction <ref> [11] </ref>. Let be a general logic program, with every rule replaced by all its ground instances.
Reference: [12] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> Classical negation in logic programs and disjunctive databases. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 365-385, </pages> <year> 1991. </year>
Reference-contexts: Extended logic programs, introduced in <ref> [12] </ref>, are, in this sense, different. The language of extended programs distinguishes between negation as failure not and classical negation :. <p> 10 The answers that an implementation of this language is supposed to give to the ground queries are: p : yes; r : unknown; s : unknown; t : yes; The semantics of extended logic programs defines when a set of ground literals is an answer set of a program <ref> [12] </ref>. A rule with variables is treated as shorthand for the set of its ground instances. For extended programs without variables, answer sets are defined in two steps. First, let be an extended program without variables that doesn't contain not . <p> It is known, however, that any extended program can be converted into a closely related program without classical negation, as follows <ref> [12] </ref>. For each predicate P occurring in , select a new predicate P 0 of the same arity. The atom P 0 (: : :) is the positive form of the negative literal :P (: : :); every positive literal is, by definition, its own positive form. <p> For any program , its positive form is the program obtained from by replacing each rule (4) by L + 1 ; : : : ; L + m+1 ; : : : ; not L + According to Proposition 2 from <ref> [12] </ref>, a consistent set X of ground literals is an answer set of if and only if X + is an answer set of the positive form of . <p> The next step will be to make the translation complete and applicable to domain descriptions containing similar propositions. It appears that both goals can be achieved by using the more expressive language of disjunctive programs <ref> [12] </ref> as the target language for the translation. The head of a disjunctive rule is a list of literals separated by occurrences of the "epistemic disjunction" symbol j.
Reference: [13] <author> Michael Gelfond, Vladimir Lifschitz, and Arkady Rabinov. </author> <title> What are the limitations of the situation calculus? In Robert Boyer, editor, Automated Reasoning: </title> <booktitle> Essays in Honor of Woody Bledsoe, </booktitle> <pages> pages 167-179. </pages> <publisher> Kluwer Academic, </publisher> <address> Dordrecht, </address> <year> 1991. </year> <month> 40 </month>
Reference-contexts: The translation to logic programming presented here is extended to this "concurrent A" in the spirit of <ref> [13] </ref>. The inconsistency of the Stolen Car domain (Example 4) illustrates the fact that A cannot be used for representing "causal anomalies," or "miracles" [21]. We plan to address this issue in further work, too.
Reference: [14] <author> Steve Hanks and Drew McDermott. </author> <title> Nonmonotonic logic and temporal projection. </title> <journal> Artificial Intelligence, </journal> <volume> 33(3) </volume> <pages> 379-412, </pages> <year> 1987. </year>
Reference-contexts: Two parts of this paper may be of more general interest. First, we introduce here a simple declarative language for describing actions, called A. Traditionally, ideas on representing properties of actions in classical logic or nonmonotonic formalisms are explained on specific examples, such as the "Yale shooting problem" from <ref> [14] </ref>. Competing approaches are evaluated and compared in terms of their ability to handle such examples. We propose to supplement the use of examples by a different method. <p> It consists of two effect propositions: Drop causes :Holding if Holding ; Drop causes Broken if Holding ; Fragile: 5 Example 2. The Yale Shooting domain, motivated by the example from <ref> [14] </ref> mentioned above, is defined as follows. The fluent names are Loaded and Alive ; the action names are Load, Shoot and Wait . The domain is characterized by the propositions initially :Loaded; initially Alive ; Load causes Loaded; Shoot causes :Alive if Loaded; Shoot causes :Loaded: Example 3.
Reference: [15] <author> G. N. Kartha. </author> <title> Soundness and completeness theorems for three formalizations of action. </title> <booktitle> In Working Papers of the Second Symposium on Logical Formalizations of Commonsense Reasoning, </booktitle> <year> 1993. </year>
Reference-contexts: The soundness and completeness of each formalization become precisely stated mathematical questions. The possibilities and limitations of different representation methods can be compared in a precise fashion. For instance, in <ref> [15] </ref> this approach is used to prove the equivalence of the methods for formalizing actions proposed earlier by Pednault [26], Reiter [31] and Baker [2] for the domains representable in A.
Reference: [16] <author> Henry Kautz. </author> <title> The logic of persistence. </title> <booktitle> In Proc. of AAAI-86, </booktitle> <pages> pages 401-405, </pages> <year> 1986. </year>
Reference-contexts: The Murder Mystery domain, motivated by an example from [2], is obtained from the Yale Shooting domain by substituting :Alive after Shoot; Wait (3) for the proposition initially :Loaded. Example 4. The Stolen Car domain, motivated by an example from <ref> [16] </ref>, has one fluent name Stolen and one action name Wait , and is characterized by two propositions: initially :Stolen ; Stolen after Wait; Wait ; Wait: To describe the semantics of A, we will define what the "models" of a domain description are, and when a value proposition is "entailed"
Reference: [17] <author> Robert Kowalski and Fariba Sadri. </author> <title> Logic programs with exceptions. </title> <editor> In David Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 598-613, </pages> <year> 1990. </year>
Reference-contexts: For instance, in [15] this approach is used to prove the equivalence of the methods for formalizing actions proposed earlier by Pednault [26], Reiter [31] and Baker [2] for the domains representable in A. On the other hand, this paper is one of the first experiments (along with <ref> [17] </ref>, [27], [10]) on using extended logic programs for representing knowledge. Not much is known yet about mathematical properties of extended programs. For this reason, in this initial experiment, the source language A was deliberately made quite simple, and we did not try to make the translation complete.
Reference: [18] <author> Kenneth Kunen. </author> <title> Signed data dependencies in logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 7(3) </volume> <pages> 231-245, </pages> <year> 1989. </year>
Reference-contexts: A counterexample is given showing that the translation is incomplete. A possible way of achieving completeness is discussed in the last section. Second, the proof of the main theorem depends on a relationship between stable models [11] and signings <ref> [18] </ref>, that may be interesting as a part of the general theory of logic programming. The language A is introduced in Section 2, and Section 3 is a brief review of extended logic programs. <p> ; B 1 ; : : : ; B m 62 S; B m+1 ; : : : ; B n 2 S: 5 For example, fpg is a signing for the program p not q; q not p; r q: 5 This is slightly different from the original definition <ref> [18] </ref>. 19 In this section we show that the answer sets of a general program which has a signing S can be characterized in terms of the fixpoints of a monotone operator.
Reference: [19] <author> Vladimir Lifschitz. </author> <title> A language for describing actions. </title> <booktitle> In Working Papers of the Second Symposium on Logical Formalizations of Commonsense Reasoning, </booktitle> <year> 1992. </year>
Reference-contexts: We plan to address this issue in further work, too. Our preferred approach to causal anomalies is to view them as evidence of unknown events that occur concurrently with the given actions and contribute to the properties of the new situation. One other dialect of A is described in <ref> [19] </ref>. It has symbols for temporal intervals over which actions may occur.
Reference: [20] <author> Vladimir Lifschitz, Norman McCain, and Hudson Turner. </author> <title> Automation of reasoning about action: A logic programming approach. </title> <note> In preparation, </note> <year> 1993. </year>
Reference-contexts: The possibility of using the logic programs proposed in this paper for the automation of temporal reasoning, based on program transformations and the XOLDTNF metainterpreter [4], is demonstrated in the forthcoming paper <ref> [20] </ref>. Two parts of this paper may be of more general interest. First, we introduce here a simple declarative language for describing actions, called A.
Reference: [21] <author> Vladimir Lifschitz and Arkady Rabinov. </author> <title> Miracles in formal theories of actions. </title> <journal> Artificial Intelligence, </journal> <volume> 38(2) </volume> <pages> 225-237, </pages> <year> 1989. </year> <month> 41 </month>
Reference-contexts: The translation to logic programming presented here is extended to this "concurrent A" in the spirit of [13]. The inconsistency of the Stolen Car domain (Example 4) illustrates the fact that A cannot be used for representing "causal anomalies," or "miracles" <ref> [21] </ref>. We plan to address this issue in further work, too. Our preferred approach to causal anomalies is to view them as evidence of unknown events that occur concurrently with the given actions and contribute to the properties of the new situation.
Reference: [22] <author> John McCarthy. </author> <title> Applications of circumscription to formalizing common sense knowledge. </title> <journal> Artificial Intelligence, </journal> <volume> 26(3) </volume> <pages> 89-116, </pages> <year> 1986. </year> <note> Reproduced in [23]. </note>
Reference-contexts: The rules (8) play the same role for reasoning "from the future to the past." The auxiliary predicate Noninertial is essentially an "abnormality predicate" <ref> [22] </ref>. Now we will define how translates value propositions and effect propositions. The following notation will be useful: For any fluent name F , and, if t is a situation term, Holds (:F; t) stands for :Holds (F; t).
Reference: [23] <author> John McCarthy. </author> <title> Formalizing common sense: papers by John McCarthy. </title> <publisher> Ablex, </publisher> <address> Norwood, NJ, </address> <year> 1990. </year>
Reference: [24] <author> John McCarthy and Patrick Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <volume> volume 4, </volume> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <year> 1969. </year> <note> Reproduced in [23]. </note>
Reference-contexts: Besides temporal projection, this class of reasoning problems includes, for instance, the cases when we want to use information about the current state of the world for 1 A fluent is something that may depend on the situation, as, for instance, the location of a moveable object <ref> [24] </ref>. In particular, propositional fluents are assertions that can be true or false depending on the situation. 2 answering questions about the past. 2 The view of logic programming accepted in this paper is strictly declarative.
Reference: [25] <author> Paul Morris. </author> <title> The anomalous extension problem in default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 35(3) </volume> <pages> 383-399, </pages> <year> 1988. </year>
Reference-contexts: In fact, the language of "extended logic programs" used in this paper is a subset of the system of default logic from [30], and our work can be viewed as a development of the approach to temporal reasoning based on nonnormal defaults <ref> [25] </ref>. The possibility of using the logic programs proposed in this paper for the automation of temporal reasoning, based on program transformations and the XOLDTNF metainterpreter [4], is demonstrated in the forthcoming paper [20]. Two parts of this paper may be of more general interest.
Reference: [26] <author> Edwin Pednault. </author> <title> ADL: Exploring the middle ground between STRIPS and the situation calculus. </title> <editor> In Ronald Brachman, Hector Levesque, and Raymond Reiter, editors, </editor> <booktitle> Proc. of the First Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 324-332, </pages> <year> 1989. </year>
Reference-contexts: The soundness and completeness of each formalization become precisely stated mathematical questions. The possibilities and limitations of different representation methods can be compared in a precise fashion. For instance, in [15] this approach is used to prove the equivalence of the methods for formalizing actions proposed earlier by Pednault <ref> [26] </ref>, Reiter [31] and Baker [2] for the domains representable in A. On the other hand, this paper is one of the first experiments (along with [17], [27], [10]) on using extended logic programs for representing knowledge. Not much is known yet about mathematical properties of extended programs.
Reference: [27] <author> Luis Pereira, Joaquim Aparicio, and Jose Alferes. </author> <title> Non-monotonic reasoning with well-founded semantics. </title> <booktitle> In Proc. of the Eight International Logic Programming Conference, </booktitle> <pages> pages 475-489, </pages> <year> 1992. </year> <month> 42 </month>
Reference-contexts: For instance, in [15] this approach is used to prove the equivalence of the methods for formalizing actions proposed earlier by Pednault [26], Reiter [31] and Baker [2] for the domains representable in A. On the other hand, this paper is one of the first experiments (along with [17], <ref> [27] </ref>, [10]) on using extended logic programs for representing knowledge. Not much is known yet about mathematical properties of extended programs. For this reason, in this initial experiment, the source language A was deliberately made quite simple, and we did not try to make the translation complete.
Reference: [28] <author> Luis Pereira and Jose lferes. </author> <title> Well-founded semantics for logic programs with explicit negation. </title> <booktitle> In Proc. of the Tenth European Conf. on Artificial Intelligence, </booktitle> <pages> pages 102-106, </pages> <year> 1992. </year>
Reference-contexts: The answer sets of a program are simply its extensions in the sense of default logic, intersected with the set of ground literals ([12], Proposition 3). Two other approaches to the semantics of logic programs with two kinds of negation are proposed in [29] and <ref> [28] </ref>. In the context of this paper, they can be shown to lead to the same result as the answer set semantics. 4 Describing Actions by Logic Programs Now we are ready to define the translation from A into the language of extended programs.
Reference: [29] <author> Teodor Przymusinski. </author> <title> Extended stable semantics for normal and disjunctive programs. </title> <editor> In David Warren and Peter Szeredi, editors, </editor> <booktitle> Logic Programming: Proc. of the Seventh Int'l Conf., </booktitle> <pages> pages 459-477, </pages> <year> 1990. </year>
Reference-contexts: The answer sets of a program are simply its extensions in the sense of default logic, intersected with the set of ground literals ([12], Proposition 3). Two other approaches to the semantics of logic programs with two kinds of negation are proposed in <ref> [29] </ref> and [28]. In the context of this paper, they can be shown to lead to the same result as the answer set semantics. 4 Describing Actions by Logic Programs Now we are ready to define the translation from A into the language of extended programs.
Reference: [30] <author> Raymond Reiter. </author> <title> A logic for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1,2):81-132, </volume> <year> 1980. </year>
Reference-contexts: In fact, the language of "extended logic programs" used in this paper is a subset of the system of default logic from <ref> [30] </ref>, and our work can be viewed as a development of the approach to temporal reasoning based on nonnormal defaults [25].
Reference: [31] <author> Raymond Reiter. </author> <title> The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression. </title> <editor> In Vladimir Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 359-380. </pages> <publisher> Academic Press, </publisher> <year> 1991. </year>
Reference-contexts: The possibilities and limitations of different representation methods can be compared in a precise fashion. For instance, in [15] this approach is used to prove the equivalence of the methods for formalizing actions proposed earlier by Pednault [26], Reiter <ref> [31] </ref> and Baker [2] for the domains representable in A. On the other hand, this paper is one of the first experiments (along with [17], [27], [10]) on using extended logic programs for representing knowledge. Not much is known yet about mathematical properties of extended programs.
Reference: [32] <author> Lenhart Schubert. </author> <title> Monotonic solution of the frame problem in the situation calculus: an efficient method for worlds with fully specified actions. In H.E. </title> <editor> Kyburg, R. Loui, and G. Carlson, editors, </editor> <booktitle> Knowledge Representation and Defeasible Reasoning, </booktitle> <pages> pages 23-67. </pages> <publisher> Kluwer, </publisher> <year> 1990. </year>
Reference-contexts: If n = 0, we will drop if and write simply A causes F: A proposition is a value proposition or an effect proposition. A domain description, or simply domain, is a set of propositions (not necessarily finite). Example 1. The Fragile Object domain, motivated by an example from <ref> [32] </ref>, has the fluent names Holding , Fragile and Broken, and the action Drop. It consists of two effect propositions: Drop causes :Holding if Holding ; Drop causes Broken if Holding ; Fragile: 5 Example 2.
Reference: [33] <author> Murray Shanahan. </author> <title> Prediction is deduction but explanation is abduction. </title> <booktitle> In Proc. of IJCAI-89, </booktitle> <pages> pages 1055-1060, </pages> <year> 1989. </year> <month> 43 </month>
Reference-contexts: methodology for representing action can be formally described as a translation from A, or from a subset or a superset of A, into 2 One possible way to represent reasoning about the past is to treat it as fundamentally different from temporal projection, and interpret it as "explanation" and "abduction" <ref> [33] </ref>. Our approach is more symmetric; we treat both forms of reasoning as deductive. 3 a "target language"|for instance, into a language based on classical logic or on circumscription, or into a logic programming language. <p> It has symbols for temporal intervals over which actions may occur. A referee has pointed out to us that there is a simple and elegant translation from A into a form of abductive logic programming with integrity constraints, which, inlike the method of <ref> [33] </ref>, handles all forms of temporal reasoning in a uniform way. It would be interesting to extend this translation to more expressive dialects of A also. Acknowledgements We would like to thank G. N.
Reference: [34] <author> Alfred Tarski. </author> <title> A lattice-theoretical fixpoint theorem and its applications. </title> <journal> Pacific Journal of Mathematics, </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year> <month> 44 </month>
Reference-contexts: Having proved Lemmas 1 and 2, we can use properties of the fixpoints of monotone operators given by the Knaster-Tarski theorem <ref> [34] </ref> to study the answer sets of a program with a signing.
References-found: 34

