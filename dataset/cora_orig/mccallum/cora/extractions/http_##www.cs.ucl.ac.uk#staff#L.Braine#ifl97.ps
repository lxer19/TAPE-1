URL: http://www.cs.ucl.ac.uk/staff/L.Braine/ifl97.ps
Refering-URL: http://www.cs.ucl.ac.uk/staff/L.Braine/researchdocs.html
Root-URL: http://www.cs.ucl.ac.uk
Email: L.Braine@cs.ucl.ac.uk C.Clack@cs.ucl.ac.uk  
Title: The CLOVER Rewrite Rules: A Translation from OOFP to FP (DRAFT)  
Author: Lee Braine and Chris Clack 
Address: Gower Street, London WC1E 6BT, UK  
Affiliation: Department of Computer Science, University College London,  
Abstract: There have been many attempts to integrate object-oriented and functional programming. Solving the conflicting requirements is difficult and only recently has a language, CLOVER, been designed that is both purely functional and purely object-oriented (and retains complete type safety). In this paper, we introduce the CLOVER rewrite rules by presenting a translation from CLOVER to a simple functional language. The object-oriented features are translated away in stages; the resulting translations are combined to provide a translation from object-oriented functional programming to functional programming. 
Abstract-found: 1
Intro-found: 1
Reference: [AC96] <author> M. Abadi and L. Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: By solving the apparently-conflicting language design requirements, CLOVER was the first language to combine these features. CLOVER adopts the Actor model [AH87] of object identity based on behaviours rather than updateable state. The formalisation of OOP covers many aspects, including a -calculus of objects [FHM94] and object calculi <ref> [AC96] </ref>. One of the key features of CLOVER is the combination of both dynamic typing and complete type safety.
Reference: [AH87] <author> G. Agha and C. Hewitt. </author> <title> Actors: A Conceptual Foundation for Concurrent Object-Oriented Programming. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 47-74, </pages> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: CLOVER's visual programming interface provides object identity based on behaviours rather than mutable state, with copy-semantics used for object update. The style of object manipulation is similar to the Actor model <ref> [AH87] </ref>, where objects are considered to exhibit sequences of behaviours. Our motivation is to investigate ways in which languages can support the flexibility of OOP, yet retain the expressibility and safety characteristics of FP languages (so that, for example, run-time debugging is greatly decreased). <p> The languages typically abandon one or more key features from either OOP or FP as part of the integration. By solving the apparently-conflicting language design requirements, CLOVER was the first language to combine these features. CLOVER adopts the Actor model <ref> [AH87] </ref> of object identity based on behaviours rather than updateable state. The formalisation of OOP covers many aspects, including a -calculus of objects [FHM94] and object calculi [AC96]. One of the key features of CLOVER is the combination of both dynamic typing and complete type safety.
Reference: [AM90] <author> A. Aiken and B. Murphy. </author> <title> Static Type Inference in a Dynamically Typed Language. </title> <booktitle> In Proceedings of the Eighteenth ACM Symposium on Principles of Programming Languages (POPL'91), </booktitle> <pages> pages 279-290, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The formalisation of OOP covers many aspects, including a -calculus of objects [FHM94] and object calculi [AC96]. One of the key features of CLOVER is the combination of both dynamic typing and complete type safety. Previous work in this area includes <ref> [AM90, AF95] </ref>, but this typically abandons complete type safety. 3 Overview of The Rewrite Rules In this section, we present an overview of the CLOVER rewrite rules and introduce our notations. CLOVER programs are compiled by program transformation into a standard functional language such as Haskell, Miranda or Clean.
Reference: [AF95] <author> A. Aiken and M. Fahndrich. </author> <title> Dynamic Typing and Subtype Inference. </title> <booktitle> Conference on Functional Programming Languages and Computer Architecture (FPCA'95), </booktitle> <pages> pages 182-191, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The formalisation of OOP covers many aspects, including a -calculus of objects [FHM94] and object calculi [AC96]. One of the key features of CLOVER is the combination of both dynamic typing and complete type safety. Previous work in this area includes <ref> [AM90, AF95] </ref>, but this typically abandons complete type safety. 3 Overview of The Rewrite Rules In this section, we present an overview of the CLOVER rewrite rules and introduce our notations. CLOVER programs are compiled by program transformation into a standard functional language such as Haskell, Miranda or Clean.
Reference: [AG93] <author> H. Ait-Kaci and J. Garrigue. </author> <title> Label-Selective -Calculus, Syntax and Confluence. </title> <booktitle> In Proceedings of the 13th International Conf. on Foundations of Software Technology and Theoretical Computer Science, Lecture Notes in Computer Science 761, </booktitle> <pages> pages 24-40, </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: There are several other components which have been omitted. These include record operations, default objects, `super' types, input/output and error handling. Note that standard record operations (such as labelled field selection and update) have been presented many times in the literature, for example <ref> [AG93] </ref>. 7 Example Translation In this section, we providing an example APC IO program and its resulting translation into TC.
Reference: [AP93] <author> H. Ait-Kaci and A. </author> <title> Podelski. Towards a Meaning of LIFE. </title> <journal> Journal of Logic Programming, </journal> 16(3&4):195-234, August 1993. 
Reference-contexts: In this section, we present an overview of the relevant work in these these areas. The reader seeking foundational information should refer to [CW85]. There have been many languages attempting to integrate OOP and FP, the closest to CLOVER being Kea [MHH91], Rapide [MMM91], HOP [DV96], LIFE <ref> [AP93] </ref>, Objective ML [RV96] and Object ML [RR96]. A brief survey is contained in [BC96].
Reference: [BC96] <author> L. Braine and C. Clack. </author> <title> Introducing CLOVER: an Object-Oriented Functional Language. </title> <editor> In W. Kluge, editor, </editor> <booktitle> Implementation of Functional Languages, 8th International Workshop, </booktitle> <month> September </month> <year> 1996, </year> <booktitle> Selected Papers, Lecture Notes in Computer Science 1268, </booktitle> <pages> pages 1-20, </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction CLOVER <ref> [BC96, BC97a, BC97b] </ref> is a visual object-oriented functional language which fully supports both object-oriented programming (OOP) and functional programming (FP) paradigms. <p> We believe that CLOVER was the first language to successfully combine all of the above features. For details of the design of the CLOVER language, and how the many design obstacles were overcome, the reader is referred to <ref> [BC96] </ref>. <p> Furthermore, we can generate concise and easy-to-understand code (which is more important than execution speed for our initial prototype implementation). In order to provide a focussed discussion, we ignore all issues related to type checking and assume that this has already been performed (as suggested in <ref> [BC96] </ref>). We similarly assume that the straightforward translation from CLOVER's visual notation, Object-Flow, to a textual notation, Object-Oriented Functional Code (OOFC), has already been performed. The goal is to describe the translation from an abstract form of this code into an abstract form of a simple target functional language. <p> The reader seeking foundational information should refer to [CW85]. There have been many languages attempting to integrate OOP and FP, the closest to CLOVER being Kea [MHH91], Rapide [MMM91], HOP [DV96], LIFE [AP93], Objective ML [RV96] and Object ML [RR96]. A brief survey is contained in <ref> [BC96] </ref>. We note that none of these combine the features we require (inheritance, subsumption and dynamic method despatch from OOP and referential transparency, higher-order functions, currying, partial applications and laziness from FP) into a single completely type-safe language. <p> APC's type system is purely object-oriented. Items can be objects (of class type), messages (of function type) or literals (of primitive type). Note the bracketed function types; these are necessary for higher-order messages so that we may identify the distinguished object (the last argument to a method) see <ref> [BC96] </ref> for details. <p> We also require the method despatchers to support standard FP features, such as curried and partially-applied methods (see <ref> [BC96] </ref> for details of the design of CLOVER's curried message application). We provide this functionality using explicit despatchers, one for each method. <p> Our work has demonstrated that it is possible to combine OOP and FP. Our solution provides dynamic types and dynamic despatch, yet this in done in a way that allows for static type-checking and complete type safety (see <ref> [BC96] </ref>). In this paper, we have demonstrated how CLOVER can be implemented by targetting a simple functional language.
Reference: [BC97a] <author> L. Braine and C. Clack. </author> <title> An Object-Oriented Functional Approach to Information Systems Engineering. </title> <booktitle> In Proceedings of the CAiSE'97 4th Doctoral Consortium on Advanced Information Systems Engineering, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: 1 Introduction CLOVER <ref> [BC96, BC97a, BC97b] </ref> is a visual object-oriented functional language which fully supports both object-oriented programming (OOP) and functional programming (FP) paradigms.
Reference: [BC97b] <author> L. Braine and C. Clack. Object-Flow. </author> <booktitle> To appear in Proceedings of the 13th IEEE Symposium on Visual Languages (VL'97), </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: 1 Introduction CLOVER <ref> [BC96, BC97a, BC97b] </ref> is a visual object-oriented functional language which fully supports both object-oriented programming (OOP) and functional programming (FP) paradigms.
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <year> 1985. </year>
Reference-contexts: In this section, we present an overview of the relevant work in these these areas. The reader seeking foundational information should refer to <ref> [CW85] </ref>. There have been many languages attempting to integrate OOP and FP, the closest to CLOVER being Kea [MHH91], Rapide [MMM91], HOP [DV96], LIFE [AP93], Objective ML [RV96] and Object ML [RR96]. A brief survey is contained in [BC96].
Reference: [DV96] <author> L. Dami and J. Vitek. </author> <title> Introduction to HOP, a Functional and Object-Oriented Language. </title> <note> Submitted for publication, </note> <year> 1996. </year>
Reference-contexts: In this section, we present an overview of the relevant work in these these areas. The reader seeking foundational information should refer to [CW85]. There have been many languages attempting to integrate OOP and FP, the closest to CLOVER being Kea [MHH91], Rapide [MMM91], HOP <ref> [DV96] </ref>, LIFE [AP93], Objective ML [RV96] and Object ML [RR96]. A brief survey is contained in [BC96].
Reference: [FHM94] <author> K. Fisher, F. Honsell, and J. Mitchell. </author> <title> A lambda calculus of objects and method specialization. </title> <journal> Nordic Journal of Computing, </journal> <volume> 1(1) </volume> <pages> 3-37, </pages> <month> Spring </month> <year> 1994. </year> <booktitle> Preliminary version appeared in Proceedings of the Eighth IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 26-38, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: By solving the apparently-conflicting language design requirements, CLOVER was the first language to combine these features. CLOVER adopts the Actor model [AH87] of object identity based on behaviours rather than updateable state. The formalisation of OOP covers many aspects, including a -calculus of objects <ref> [FHM94] </ref> and object calculi [AC96]. One of the key features of CLOVER is the combination of both dynamic typing and complete type safety.
Reference: [MHH91] <author> W. Mugridge, J. Hamer, and J. Hosking. </author> <title> Multi-methods in a Statically-Typed Programming Language. </title> <editor> In P. America, editor, </editor> <booktitle> Proceedings of the 5th European Conference on Object-Oriented programming (ECOOP'91), Lecture Notes in Computer Science 512, </booktitle> <pages> pages 307-324, </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In this section, we present an overview of the relevant work in these these areas. The reader seeking foundational information should refer to [CW85]. There have been many languages attempting to integrate OOP and FP, the closest to CLOVER being Kea <ref> [MHH91] </ref>, Rapide [MMM91], HOP [DV96], LIFE [AP93], Objective ML [RV96] and Object ML [RR96]. A brief survey is contained in [BC96].
Reference: [MMM91] <author> J. Mitchell, S. Meldal, and N. Madhav. </author> <title> An Extension of Standard ML Modules with Subtyping and Inheritance. </title> <booktitle> In Proceedings of the Eighteenth ACM Symposium on Principles of Programming Languages (POPL'91), </booktitle> <pages> pages 270-278, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: In this section, we present an overview of the relevant work in these these areas. The reader seeking foundational information should refer to [CW85]. There have been many languages attempting to integrate OOP and FP, the closest to CLOVER being Kea [MHH91], Rapide <ref> [MMM91] </ref>, HOP [DV96], LIFE [AP93], Objective ML [RV96] and Object ML [RR96]. A brief survey is contained in [BC96].
Reference: [RR96] <author> J. Reppy and J. Riecke. </author> <title> Simple Objects for Standard ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation (PLDI), SIGPLAN Notices 31(5), </booktitle> <pages> pages 171-180, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: The reader seeking foundational information should refer to [CW85]. There have been many languages attempting to integrate OOP and FP, the closest to CLOVER being Kea [MHH91], Rapide [MMM91], HOP [DV96], LIFE [AP93], Objective ML [RV96] and Object ML <ref> [RR96] </ref>. A brief survey is contained in [BC96]. We note that none of these combine the features we require (inheritance, subsumption and dynamic method despatch from OOP and referential transparency, higher-order functions, currying, partial applications and laziness from FP) into a single completely type-safe language.
Reference: [RV96] <author> D. Remy and J. Vouillon. </author> <title> Objective ML: A simple object-oriented extension of ML. </title> <booktitle> Presented at Third International Workshop on Foundations of Object-Oriented Languages (FOOL 3), </booktitle> <month> July </month> <year> 1996. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: The reader seeking foundational information should refer to [CW85]. There have been many languages attempting to integrate OOP and FP, the closest to CLOVER being Kea [MHH91], Rapide [MMM91], HOP [DV96], LIFE [AP93], Objective ML <ref> [RV96] </ref> and Object ML [RR96]. A brief survey is contained in [BC96]. We note that none of these combine the features we require (inheritance, subsumption and dynamic method despatch from OOP and referential transparency, higher-order functions, currying, partial applications and laziness from FP) into a single completely type-safe language.
References-found: 16

