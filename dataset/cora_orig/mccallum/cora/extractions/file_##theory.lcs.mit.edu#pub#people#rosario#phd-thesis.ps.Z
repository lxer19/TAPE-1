URL: file://theory.lcs.mit.edu/pub/people/rosario/phd-thesis.ps.Z
Refering-URL: http://theory.lcs.mit.edu/~rosario/research.html
Root-URL: 
Title: Theory and Practice of Verifiable Secret Sharing  
Author: by Rosario Gennaro Silvio Micali 
Degree: Laurea in  (1993) Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Doctor of Philosophy in Electrical Engineering and Computer Science at the  All rights reserved. Author  Certified by  Professor, Thesis Supervisor Accepted by F.R. Morgenthaler Chairman, Departmental Committee on Graduate Students  
Date: (1989)  May 1996  May 10, 1996  
Address: Italy  
Affiliation: Matematica, Universita di Catania,  S.M., Massachusetts Institute of Technology  MASSACHUSETTS INSTITUTE OF TECHNOLOGY  c Massachusetts Institute of Technology 1996.  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [AB83] <author> C. Asmuth and J. Bloom. </author> <title> A modular approach to key safeguarding. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-30:208-210, </volume> <month> March </month> <year> 1983. </year>
Reference: [BB89] <author> J. Bar-Ilan, and D. Beaver. </author> <title> Non-Cryptographic Fault-Tolerant Computing in a Constant Number of Rounds. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Distributed Computation, </booktitle> <address> pp.201-209, </address> <year> 1989. </year>
Reference-contexts: The first is an elegant and simple procedure for the shared computation of reciprocals, largely based on a protocol by Bar-Ilan and Beaver <ref> [BB89] </ref>. <p> k n ) = (u 1 ; : : : ; u n ) where (u 1 ; : : : ; u n ) (t;n) The following protocol for the above protocol was reinvented independently by us, but Beaver pointed out to us that it was already appeared in <ref> [BB89] </ref>. Our version is a simplified one for reasons of efficiency, although it loses in fault-tolerance. <p> The players reconstruct the value = ka by broadcasting the values i = k i a i + b i , and interpolating the corresponding 2t-degree polynomial using Berlekamp-Welch error-correcting procedure. 4. Each player computes his share u i of k 1 by setting u i 4 (from <ref> [BB89] </ref>) 1. Sim runs a Feldman-VSS protocol on a random secret for each good player to simulate the execution of Join-Feldman-RSS. Sim also receives the shares of the sharings done by the adversary for the bad players.
Reference: [BCC88] <author> G. Brassard, D. Chaum, and C. Crepeau. </author> <title> Minimum disclosure proofs of knowledge. </title> <journal> JCSS, </journal> <volume> 37(2) </volume> <pages> 156-189, </pages> <year> 1988. </year>
Reference-contexts: The protocol in figure 4-8 is actually not zero-knowledge. For example, a cheating verifier V fl can choose R in a different way than specified and then learn S R , which V fl could not compute by himself. However, there are well-known techniques <ref> [GMW91, BCC88, Gol95] </ref> to add the zero-knowledge property to the above protocol using the notion of a commitment function: Instead of P sending S R in Step 2, he sends a commitment commit (S R ), after which V reveals to P the values of i and j.
Reference: [BCDP91] <author> J. Boyar, D. Chaum, I. Damg-ard, and T. Pedersen. </author> <title> Convertible undeniable signatures. </title> <editor> In A.J. Menezes and S. A. Vanstone, editors, </editor> <booktitle> Proc. CRYPTO 90, </booktitle> <pages> pages 189-205. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> Lecture Notes in Computer Science No. 537. </note>
Reference-contexts: The sample message will be used in the extension of a protocol by Chaum's and van Antwerpen's <ref> [CA90, BCDP91] </ref>. In this section we assume that the dealer is trusted throughout the Dealing Phase, in Section 4.8.3 we show how to dispense with this assumption. 4.8 Interactive Robust Threshold RSA Signatures 120 4.8.1 Key Generation Protocol The dealer runs the DDFY-Sharing protocol in Section 4.6.3. <p> Then he proves in zero-knowledge to all other players that DL m (S i ) = DL w (W i ). The protocol Composite-EDL proves equality of discrete logs modulo a composite. It is based on a protocol by Chaum and van Antwerpen [CA90], which was further developed in <ref> [BCDP91] </ref>. However that protocol is designed to prove such a statement over a prime field Z p .
Reference: [Ben87] <author> J. Benaloh. </author> <title> Secret sharing homomorphisms: Keeping shares of a secret sharing. </title> <editor> In A. M. Odlyzko, editor, </editor> <booktitle> Proc. CRYPTO 86. </booktitle> <publisher> Springer, </publisher> <year> 1987. </year> <note> Lecture Notes in Computer Science No. 263. </note>
Reference-contexts: : : ; a n ) (t;n) sharing of a secret b, (b 1 ; : : : ; b n ) (t;n) ! b, then we have that (a 1 + b 1 ; : : : ; a n + b n ) ! a + b (see <ref> [Ben87] </ref> for a discussion of homomorphic secret sharing schemes.) * it is possible to verify that the secret being shared is indeed 0 by requesting that the test polynomials have all free term 0 checking that the broadcasted polynomials in rounds 3 and 9 have all free term 0 In the <p> ; a n ) (t;n) and a sharing of a secret b, (b 1 ; : : : ; b n ) (t;n) ! b, then we have that (a 1 + b 1 ; : : : ; a n + b n ) ! a + b (see <ref> [Ben87] </ref> for a discussion of homomorphic secret sharing schemes.) Indeed if this is the case, to realize such a protocol, all players act as dealers of a random local secret that they choose.
Reference: [BK89] <author> M. Blum and S. Kannan. </author> <title> Program correctness checking and the design of programs that check their work. </title> <booktitle> In Proc. of the 21st ACM Symposium on Theory of Computing, 1989. </booktitle> <volume> 130 Bibliography 131 </volume>
Reference-contexts: Notice also the dramatic improvement in fault-tolerance (we achieve t = n=4 compared to the t n in [Lan95].) In a recent and independent work, Frankel, Gemmel, and Yung [FGY96], have extended the notion of result-checking introduced by Blum <ref> [BK89] </ref>, to the setting of witness-based cryptographic checking. Among the main motivations for that work is the generation of a robust fault-tolerant RSA signature scheme.
Reference: [BL88] <author> J. Benaloh and J. Leichter. </author> <title> Generalized secret sharing and monotone functions. </title> <editor> In S. Goldwasser, editor, </editor> <booktitle> Proc. CRYPTO 88, </booktitle> <pages> pages 27-36. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <note> Lecture Notes in Computer Science No. 403. </note>
Reference-contexts: In researching this topic we came across to two papers that make passing references to this problem. 3.1 Preliminaries 53 In the original paper on generalized secret sharing <ref> [BL88] </ref>, the authors say that it is possible to extend the techniques of Feldman [Fel87] in order to achieve VSS over access structures. <p> Is it possible, at least for the weak adversary case, to devise a VSS protocol that is error-free and does not require a broadcast capability? Ideal structures: The running time of our protocols depend on ` the "size" of the access structure. In general this is inevitable (see <ref> [BL88] </ref>), however there are access structures for which this is not necessarily the case (for example threshold access structures). <p> Our algorithms use only the DNF formulation of the monotone formula. Is it possible to construct VSS protocols based on the algorithm of Benaloh-Leichter <ref> [BL88] </ref> for generic boolean monotone circuits? This would result in a more compact representation of the access structure and consequently in more efficient protocols. Secure Computation: Is it possible to define a notion of secure computation over general access structure.
Reference: [Bla79] <author> G. R. Blakley. </author> <title> Safeguarding cryptographic keys. </title> <booktitle> In Proc. AFIPS 1979 National Computer Conference, </booktitle> <pages> pages 313-317. </pages> <publisher> AFIPS, </publisher> <year> 1979. </year>
Reference-contexts: However, we object that what happens to be true for the VSS protocols based on Shamir's scheme, may not be true for all VSS protocols. For example we saw in Section 1.2.2 that in Blakley's (t; n)-threshold secret sharing scheme <ref> [Bla79] </ref> at the end of Recover a t-adversary has no information about the shares of the good players, even after seeing t shares and the secret.
Reference: [BGW88] <author> M. Ben-Or, S. Goldwasser, and A. Wigderson. </author> <title> Completeness theorems for fault-tolerant distributed computing. </title> <booktitle> In Proc. 20th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 1-10, </pages> <address> Chicago, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: In this chapter we recall previous work on threshold VSS and present a new stronger definition for such task. For the rest of the chapter, when not explicitly mentioned, we assume implicitly the threshold model. In the past, several definitions and protocols for VSS have been proposed (E.g., <ref> [CGMA85, BGW88, CCD88, FM88, Rab94] </ref>.) We contend, however, that these notions and these protocols are of limited use. <p> Theorem 2.3 Definition 2.13 is strictly stronger than Definition 2.11, that is, there are VSS protocols satisfying Definition 2.11, but not Definition 2.13. The proof of this theorem is based on the fact that usually VSS protocols (consider for example the one in <ref> [BGW88] </ref>) reconstruct the secret by just distributing each player's share to all other players. This does satisfy Definition 2.11 since there we do not put any requirement on the secrecy of the shares. <p> Notice that we cannot simply invoke the completeness theorems of <ref> [BGW88, CCD88, RB89] </ref> that say that any function can be computed securely in our model, in particular two functions shar and rec constituting a sharing-reconstructing pair. Indeed those results rely on VSS constructions, so we would be just biting our tail. <p> We obtain it by performing some modifications on a previous protocol due to Ben-Or, Goldwasser, and Wigderson <ref> [BGW88] </ref>. The modification actually occurs only in the Recover part, and uses techniques also developed in [BGW88], but within their "computational protocol" rather than in their VSS protocol. It is possible to obtain a better fault-tolerance by using the VSS protocol of Tal Rabin [Rab94]. <p> We obtain it by performing some modifications on a previous protocol due to Ben-Or, Goldwasser, and Wigderson <ref> [BGW88] </ref>. The modification actually occurs only in the Recover part, and uses techniques also developed in [BGW88], but within their "computational protocol" rather than in their VSS protocol. It is possible to obtain a better fault-tolerance by using the VSS protocol of Tal Rabin [Rab94]. We will sketch this construction in Section 2.7. Suppose we are dealing with a t-adversary A. <p> Let K be a security parameter which for simplicity we assume to be a multiple of n. For the sake of completeness, we first show the protocol Share-Verify, although it is the same as the one in <ref> [BGW88] </ref>. The protocol appears in Figure 2-1. Lemma 2.3 Protocol Share-Verify-A securely evaluates the function shar-a according to Definition 2.7. 2.6 A VSS protocol that satisfies our definition 41 Share-Verify-A ([BGW88]) Input for the dealer: A secret s 2 Z p . 1. <p> Remark: A completely error-free version of this protocol can be obtained by running a different zero-knowledge proof that the shares lie on a single polynomial. The proof uses a bivariate polynomial. Details can be found in <ref> [BGW88, FM88] </ref>. 2.6.3 The Recover protocol In [BGW88], the Recover protocol is performed by having each player distribute the input share s i . As we have shown in Section 2.5, this is not a secure computation of the function rec against a dynamic adversary. <p> Remark: A completely error-free version of this protocol can be obtained by running a different zero-knowledge proof that the shares lie on a single polynomial. The proof uses a bivariate polynomial. Details can be found in [BGW88, FM88]. 2.6.3 The Recover protocol In <ref> [BGW88] </ref>, the Recover protocol is performed by having each player distribute the input share s i . As we have shown in Section 2.5, this is not a secure computation of the function rec against a dynamic adversary. So we need to modify the above Recover protocol. <p> Proof As in the proof of Lemma 2.3 we start by defining the input and output functions of our protocol. The input function I i of player P i is defined as follow: let 2.6 A VSS protocol that satisfies our definition 45 Recover-A (Modified from <ref> [BGW88] </ref>): Input for each player P i : A value s i 1. Each player P i chooses random polynomials p i (x); q i;1 (x); : : : ; q i;2K (x) of degree t and with free term 0. <p> Let a (j) i the share received by player P j from P i 's sharing. 2. The players runs the recover protocol from <ref> [BGW88] </ref> on input s i + a (i) : : : + a (i) n , that is (a) Each player distributes s i + a (i) n . (b) Each player performs Berlekamp-Welch interpolation on the values received in round (2.a). This was possible because the protocol Share-Verify-A from [BGW88] <p> <ref> [BGW88] </ref> on input s i + a (i) : : : + a (i) n , that is (a) Each player distributes s i + a (i) n . (b) Each player performs Berlekamp-Welch interpolation on the values received in round (2.a). This was possible because the protocol Share-Verify-A from [BGW88] has the fol lowing properties: * it is homomorphic, i.e. given a sharing of a secret a, (a 1 ; : : : ; a n ) (t;n) sharing of a secret b, (b 1 ; : : : ; b n ) (t;n) ! b, then we have that <p> polynomials in rounds 3 and 9 have all free term 0 In the following we will refer to such protocols as 0-VSS. 2.7 On achieving fault-tolerance of n 2 50 2.7.2 Modifications to Rabin's protocol It turns out that Rabin's protocol [Rab94] has the same properties of the protocol in <ref> [BGW88] </ref>. In particular this means that we can apply the same transformation technique. Let Share-Verify-B be the sharing protocol in [Rab94]. Let 0-Share-Verify-B the 0-VSS protocol based on Share-Verify-B. <p> He is also allowed rushing (See Section 2.1, for the definitions of the above terms.) In the previous chapter we dealt with t-adversaries, that is adversaries who were allowed to corrupt at most t players. For example the protocols by Ben-Or, Gold-wasser and Wigderson <ref> [BGW88] </ref> and Chaum, Crepeau and Damgard [CCD88] enforce a bound of n=3 corrupted players. Tal Rabin improves this to n=2 in [Rab94]. <p> The protocol is based on similar techniques as <ref> [BGW88, CCD88] </ref>, but applied to the access structure secret sharing protocol described in Section 1.2.3. 3.3.1 A sketch of the protocol The basic idea of our weak VSS protocol is based on the cut-and-choose technique introduced in [BGW88, CCD88]. Let K be a security parameter. <p> The protocol is based on similar techniques as <ref> [BGW88, CCD88] </ref>, but applied to the access structure secret sharing protocol described in Section 1.2.3. 3.3.1 A sketch of the protocol The basic idea of our weak VSS protocol is based on the cut-and-choose technique introduced in [BGW88, CCD88]. Let K be a security parameter. During Share-Verify the dealer will share the secret s and Kn additional auxiliary secrets t (1) ; : : : ; t (Kn) according to the scheme in Section 1.2.3. <p> Broadcast channel/Error probability: Both our protocols rely on the existence of a broadcast channel and require a negligible probability of failure. Is this necessary? For example in the threshold case we know that it is possible to achieve VSS without a broadcast channel and in an error-free manner <ref> [BGW88, FM88] </ref>. Is it possible, at least for the weak adversary case, to devise a VSS protocol that is error-free and does not require a broadcast capability? Ideal structures: The running time of our protocols depend on ` the "size" of the access structure. <p> Secure Computation: Is it possible to define a notion of secure computation over general access structure. As in the threshold case <ref> [GMW87, BGW88, CCD88, RB89] </ref> the idea would be to have a set of n players and an access structure defined on it. <p> Indeed we know various protocols for the secure computation of any function f in a distributed manner (see for example <ref> [GMW87, BGW88, CCD88, RB89] </ref>.) However the generality of such protocols involves inefficiency and makes them hopelessly impractical for the task at hand. <p> In the following we will make several references to Shamir's Secret Sharing protocol Shamir-SS which we described in Section 1.2.1. The reader is referred to that section for details. 4.4.1 Feldman's VSS In Chapter 2 we recalled various VSS protocols <ref> [BGW88, Rab94] </ref>. They achieved security against an all-powerful adversary. Since in this chapter we are dealing with a computationally bounded adversary we use a different VSS protocol devised by Feldman [Fel87]. <p> In the following we 4.4 Existing Tools 89 will refer to this protocol by Feldman-VSS. 4.4.2 Pedersen's VSS This protocol was presented by Pedersen in [Ped92]. In contrast to Feldman's VSS protocol, this protocol provides information theoretic secrecy for the shared secret as the ones in <ref> [BGW88, Rab94] </ref>. This is required by some of our techniques in order to achieve provable security. However, in order to achieve security, Pedersen's VSS still uses in a crucial way the fact that the adversary is computationally bounded. <p> We will refer to this protocol as Joint-Zero-SS. Notice that by adding such "zero-shares" to existent shares of a secret , one obtains a randomization of the shares of without changing the secret (first noticed in <ref> [BGW88] </ref> and this is the property we use in Chapter 2 to protect the shares at reconstruction time.) This is the way we will typically use the Joint-Zero-SS protocol. 4.5 Robust DSS Threshold Signature Schemes In this section we present our results relative to the Digital Signature Standard. <p> We note that this solution to the problem of secret multiplication is a simplified version of the the protocols for the same problem presented in <ref> [BGW88, CCD88] </ref>. In those works extra steps were added in order to reduce the degree of the interpolation polynomial back to t. This involved zero-knowledge proofs and use of error-correction again, with the consequence of losing in efficiency. <p> Indeed if one is willing to pay the price for a complex degree-reduction step (as in the general secure multiparty computation protocols of <ref> [BGW88] </ref>) then one could bring the fault-tolerance to n1 2 . Another way to improve on the fault-tolerance is to avoid using error-correcting codes, but to use some other way to detect and discard incorrect shares.
Reference: [Boy86] <editor> C. Boyd. Digital Multisignatures. In H. Baker and F. Piper, editors, </editor> <booktitle> Cryptography and Coding, </booktitle> <pages> pages 241-246. </pages> <publisher> Claredon Press, </publisher> <year> 1986. </year>
Reference-contexts: We do not have such feature for the DSS protocol. The RSA results are described in Section 4.6. 4.3.1 Previous results Threshold signatures are part of a general approach known as threshold cryptography which was introduced by the works of Boyd <ref> [Boy86] </ref>, Desmedt [Des88], and Desmedt and Frankel [DF90]. This approach has received considerable attention in the literature; we refer the reader to [Des94] for a survey of the work in this area.
Reference: [BR94] <author> M. Bellare and P. Rogaway. </author> <title> Optimal asymmetric encryption. </title> <booktitle> In Euro-Crypt'94, </booktitle> <year> 1994. </year>
Reference-contexts: Commitment functions can be implemented in many ways. For example, in the above protocol commit (S R ) can be implemented as RSA encryption of S R concatenated with a random string r (the encryption is required to be semantically secure, see <ref> [GM84, BR94] </ref>), using a public key for which the private key is not known to V (and possibly, not even known to P ). To open the commitment, P reveals both S R and r.
Reference: [BW] <author> E. Berlekamp and L. Welch. </author> <title> Error correction of algebraic block codes. </title> <type> US Patent 4,633,470. </type>
Reference-contexts: sequence s i = f (x i ) one can reconstruct the coefficients of f in polynomial time even if up to t elements in the sequence are arbitrarily changed, provided that n 2t + d + 1 (2.2) Indeed this is the Berlekamp-Welch variant of the Reed-Solomon error-correcting code <ref> [BW] </ref>. For details readers can refer to a standard text like [PW72] or to the Appendix in [Sud96]. <p> They now compute the product of k and a, which maps k to a random point in Z q . To accomplish this each player broadcasts k i a i + b i . The polynomial of degree 2t is interpolated using Berlekamp-Welch error correcting protocol <ref> [BW] </ref>. The result of this interpolation is a random value , hence reveals no information on k. <p> As before s is computed from the appropriate shares. Whenever we reconstruct a secret, in order to detect bad shares contributed by malicious players we perform error-correcting using the Berlekamp and Welch decoder <ref> [BW] </ref>. As before randomization of polynomials (through the joint zero secret sharing protocols) is added in various places in order to hide possible partial information. The full protocol is exhibited in Figure 4-3 Notation. <p> The polynomial can be computed by using the Berlekamp-Welch decoder <ref> [BW] </ref> (see section 2.6.1.) Theorem 4.2 Assume n 4t+1 and to be in the presence of a malicious t-adversary A. Then protocol DSS-Thresh-Sig-2 is a secure threshold signature protocol for DSS. Proof The correctness of the protocol is due to the error correcting capabilities of polynomial interpolation.
Reference: [CA90] <editor> David Chaum and Hans Van Antwerpen. Undeniable signatures. In G. Brassard, editor, </editor> <booktitle> Proc. CRYPTO 89, </booktitle> <pages> pages 212-217. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> Lecture Notes in Computer Science No. 435. </note>
Reference-contexts: The sample message will be used in the extension of a protocol by Chaum's and van Antwerpen's <ref> [CA90, BCDP91] </ref>. In this section we assume that the dealer is trusted throughout the Dealing Phase, in Section 4.8.3 we show how to dispense with this assumption. 4.8 Interactive Robust Threshold RSA Signatures 120 4.8.1 Key Generation Protocol The dealer runs the DDFY-Sharing protocol in Section 4.6.3. <p> Then he proves in zero-knowledge to all other players that DL m (S i ) = DL w (W i ). The protocol Composite-EDL proves equality of discrete logs modulo a composite. It is based on a protocol by Chaum and van Antwerpen <ref> [CA90] </ref>, which was further developed in [BCDP91]. However that protocol is designed to prove such a statement over a prime field Z p .
Reference: [CCD88] <author> David Chaum, Claude Crepeau, and Ivan Damg-ard. </author> <title> Multiparty unconditionally secure protocols. </title> <booktitle> In Proc. 20th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 11-19, </pages> <address> Chicago, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: In this chapter we recall previous work on threshold VSS and present a new stronger definition for such task. For the rest of the chapter, when not explicitly mentioned, we assume implicitly the threshold model. In the past, several definitions and protocols for VSS have been proposed (E.g., <ref> [CGMA85, BGW88, CCD88, FM88, Rab94] </ref>.) We contend, however, that these notions and these protocols are of limited use. <p> Notice that we cannot simply invoke the completeness theorems of <ref> [BGW88, CCD88, RB89] </ref> that say that any function can be computed securely in our model, in particular two functions shar and rec constituting a sharing-reconstructing pair. Indeed those results rely on VSS constructions, so we would be just biting our tail. <p> For example the protocols by Ben-Or, Gold-wasser and Wigderson [BGW88] and Chaum, Crepeau and Damgard <ref> [CCD88] </ref> enforce a bound of n=3 corrupted players. Tal Rabin improves this to n=2 in [Rab94]. Given a network of players, with an access structure F defined on it, we need to define what kinds of adversary can be allowed in order to obtain fault-tolerance in the secret sharing process. <p> The protocol is based on similar techniques as <ref> [BGW88, CCD88] </ref>, but applied to the access structure secret sharing protocol described in Section 1.2.3. 3.3.1 A sketch of the protocol The basic idea of our weak VSS protocol is based on the cut-and-choose technique introduced in [BGW88, CCD88]. Let K be a security parameter. <p> The protocol is based on similar techniques as <ref> [BGW88, CCD88] </ref>, but applied to the access structure secret sharing protocol described in Section 1.2.3. 3.3.1 A sketch of the protocol The basic idea of our weak VSS protocol is based on the cut-and-choose technique introduced in [BGW88, CCD88]. Let K be a security parameter. During Share-Verify the dealer will share the secret s and Kn additional auxiliary secrets t (1) ; : : : ; t (Kn) according to the scheme in Section 1.2.3. <p> Secure Computation: Is it possible to define a notion of secure computation over general access structure. As in the threshold case <ref> [GMW87, BGW88, CCD88, RB89] </ref> the idea would be to have a set of n players and an access structure defined on it. <p> Indeed we know various protocols for the secure computation of any function f in a distributed manner (see for example <ref> [GMW87, BGW88, CCD88, RB89] </ref>.) However the generality of such protocols involves inefficiency and makes them hopelessly impractical for the task at hand. <p> We note that this solution to the problem of secret multiplication is a simplified version of the the protocols for the same problem presented in <ref> [BGW88, CCD88] </ref>. In those works extra steps were added in order to reduce the degree of the interpolation polynomial back to t. This involved zero-knowledge proofs and use of error-correction again, with the consequence of losing in efficiency.
Reference: [CGMA85] <author> B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch. </author> <title> Verifiable secret sharing and achieving simultaneity in the presence of faults. </title> <booktitle> In Proc. 26th IEEE Symp. on Foundations of Comp. Science, </booktitle> <pages> pages 383-395, </pages> <address> Portland, 1985. </address> <publisher> IEEE. </publisher>
Reference-contexts: In this chapter we recall previous work on threshold VSS and present a new stronger definition for such task. For the rest of the chapter, when not explicitly mentioned, we assume implicitly the threshold model. In the past, several definitions and protocols for VSS have been proposed (E.g., <ref> [CGMA85, BGW88, CCD88, FM88, Rab94] </ref>.) We contend, however, that these notions and these protocols are of limited use. <p> We also showed that such notions have no fault-tolerance, i.e., they are not able to tolerate players who act dishonestly during the protocol. In order to incorporate fault-tolerance, the notion of Verifiable Secret Sharing was introduced in the literature in <ref> [CGMA85] </ref> but only for the threshold model. In Chapter 2 we recalled previous works on threshold VSS and pointed out subtleties concerning the definition of VSS protocols. In this chapter we initiate an investigation of the problem of fault-tolerant sharing of secrets over general access structures.
Reference: [CMI93] <author> M. Cerecedo, T. Matsumoto, and H. Imai. </author> <title> Efficient and Secure Mul-tiparty Generation of Digital Signatures Based on Discrete Logarithms. </title> <journal> IEICE Trans. Fundamentals, </journal> <volume> E76-A(4):532-545, </volume> <month> April </month> <year> 1993. </year> <note> Bibliography 132 </note>
Reference-contexts: This approach has received considerable attention in the literature; we refer the reader to [Des94] for a survey of the work in this area. Particular examples of solutions to threshold signatures can be found in [DF92, DDFY94] for the case of RSA signatures, and <ref> [CMI93, Har94, Lan95] </ref> for ElGamal-type of signatures. Threshold DSS signatures schemes were recently studied by Langford [Lan95]. DSS signatures turn out to be less amenable to sharing techniques than RSA or even other ElGamal-type of signatures, e.g., see [CMI93, Har94]. <p> Threshold DSS signatures schemes were recently studied by Langford [Lan95]. DSS signatures turn out to be less amenable to sharing techniques than RSA or even other ElGamal-type of signatures, e.g., see <ref> [CMI93, Har94] </ref>. Langford has overcome some of these difficulties in the case of DSS, exhibiting a solution which requires a group of n = t 2 t + 1 players in order to tolerate up to t players that might refuse to participate in the signature protocol. <p> However there is also an advantage: at least one of the values muiltiplied is random and has been "recently" shared using a Joint-Feldman-VSS protocol. This observation led to a clever trick employed in <ref> [CMI93] </ref>. They show that in the situation described above it is possible to create "authentication pieces" for the resulting shares of the product. In their case both secrets are shared using Feldman-VSS.
Reference: [DDFY94] <author> Alredo De Santis, Yvo Desmedt, Yair Frankel, and Moti Yung. </author> <title> How to share a function securely. </title> <booktitle> In Proc. 26th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 522-533, </pages> <address> Santa Fe, 1994. </address> <publisher> IEEE. </publisher>
Reference-contexts: This approach has received considerable attention in the literature; we refer the reader to [Des94] for a survey of the work in this area. Particular examples of solutions to threshold signatures can be found in <ref> [DF92, DDFY94] </ref> for the case of RSA signatures, and [CMI93, Har94, Lan95] for ElGamal-type of signatures. Threshold DSS signatures schemes were recently studied by Langford [Lan95]. DSS signatures turn out to be less amenable to sharing techniques than RSA or even other ElGamal-type of signatures, e.g., see [CMI93, Har94]. <p> Verification Algorithm. A signature S of a message m can be publicly verified by checking that S e = m mod N . 4.6.2 Outline Threshold RSA signatures against eavesdropping or halting adversaries were known in the literature before <ref> [DF92, DDFY94] </ref>. The basic construction underlying the existing threshold RSA schemes can be roughly described as follows. Key Generation Protocol a dealer shares the secret key d, among the n players, such that each player P i has a "share" d i of d. <p> Signature Protocol when a message m is given, any subset of t+1 partial signatures S i = m d i mod N suffice to generate the signature for m. The best construction is due to De Santis, Desmedt, Frankel and Yung <ref> [DDFY94] </ref> and it is described in Section 4.6.3 Similarly to non-veriable secret sharing protocols, each of the existing schemes requires that all partial signatures, S i be correct, hence these schemes cannot tolerate 4.6 Robust RSA Threshold Signature Schemes 109 faults. <p> If the result is a proper signature, there is no need for the verification of the partial signatures. In the <ref> [DDFY94] </ref> solution the shares d 1 ; :::; d n of the secret key d can be viewed themselves as RSA secret keys. Thus the partial signatures S i can be viewed as RSA signatures themselves. <p> solution under the assumption that the dealer is honest, in Section 4.8.3 we point out how to add some simple verification steps to check on the dealer's work. 4.6 Robust RSA Threshold Signature Schemes 112 4.6.3 Threshold Sharing of RSA functions In this section we briefly describe the scheme in <ref> [DDFY94] </ref> which results in a threshold RSA signature scheme against an eavesdropping or halting adversary. This in turn is the basis of our fully fault-tolerant solutions. So we want to compute an RSA signature S = m d mod N where d is the secret key. <p> However the problem is that the sharing of the key must be done in the ring Z (N) and we need a field in order to compute the Lagrange coefficients. In <ref> [DDFY94] </ref> they solve this problem by extending Shamir's scheme to work over any abelian group (G; +). For our purposes let G be Z (N) . <p> : ; d i;(1) ] 2 G 1 are computed simply as S i = [m d i;1 ; : : : ; m d i;(1) ] So given a set V of t + 1 partial signatures we can compute S = j 0;j;V Clearly, the correctness of the <ref> [DDFY94] </ref> result relies heavily on the correctness of 4.7 The RSA Non-Interactive Solution 114 each partial signature. Observation 1: The partial signature of player P i in this scheme is just a vector of 1 "regular" RSA signatures. <p> Hence, it will suffice to check each of these signatures on its own. This will allow us in the following to perform operations simply modulo N and not in the algebraic structure described above. Thus, the extension of our protocols to the <ref> [DDFY94] </ref> construction is straightforward. Observation 2: We will assume that a partial signatures is good, if it is correct up to a sign.
Reference: [Des88] <author> Yvo Desmedt. </author> <title> Society and group oriented cryptography: A new concept. </title> <editor> In Carl Pomerance, editor, </editor> <booktitle> Proc. CRYPTO 87, </booktitle> <pages> pages 120-127. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <note> Lecture Notes in Computer Science No. 293. </note>
Reference-contexts: We do not have such feature for the DSS protocol. The RSA results are described in Section 4.6. 4.3.1 Previous results Threshold signatures are part of a general approach known as threshold cryptography which was introduced by the works of Boyd [Boy86], Desmedt <ref> [Des88] </ref>, and Desmedt and Frankel [DF90]. This approach has received considerable attention in the literature; we refer the reader to [Des94] for a survey of the work in this area.
Reference: [Des94] <author> Yvo G. Desmedt. </author> <title> Threshold cryptography. </title> <journal> European Transactions on Telecommunications, </journal> <volume> 5(4) </volume> <pages> 449-457, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: This approach has received considerable attention in the literature; we refer the reader to <ref> [Des94] </ref> for a survey of the work in this area. Particular examples of solutions to threshold signatures can be found in [DF92, DDFY94] for the case of RSA signatures, and [CMI93, Har94, Lan95] for ElGamal-type of signatures. Threshold DSS signatures schemes were recently studied by Langford [Lan95].
Reference: [DF90] <author> Yvo Desmedt and Yair Frankel. </author> <title> Threshold cryptosystems. </title> <editor> In G. Brassard, editor, </editor> <booktitle> Proc. CRYPTO 89, </booktitle> <pages> pages 307-315. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> Lecture Notes in Computer Science No. 435. </note>
Reference-contexts: We do not have such feature for the DSS protocol. The RSA results are described in Section 4.6. 4.3.1 Previous results Threshold signatures are part of a general approach known as threshold cryptography which was introduced by the works of Boyd [Boy86], Desmedt [Des88], and Desmedt and Frankel <ref> [DF90] </ref>. This approach has received considerable attention in the literature; we refer the reader to [Des94] for a survey of the work in this area.
Reference: [DF92] <author> Y. Desmedt and Y. Frankel. </author> <title> Shared generation of authenticators and signatures. </title> <editor> In J. Feigenbaum, editor, </editor> <booktitle> Proc. CRYPTO 91, </booktitle> <pages> pages 457-469. </pages> <publisher> Springer, </publisher> <year> 1992. </year> <note> Lecture Notes in Computer Science No. 576. </note>
Reference-contexts: This approach has received considerable attention in the literature; we refer the reader to [Des94] for a survey of the work in this area. Particular examples of solutions to threshold signatures can be found in <ref> [DF92, DDFY94] </ref> for the case of RSA signatures, and [CMI93, Har94, Lan95] for ElGamal-type of signatures. Threshold DSS signatures schemes were recently studied by Langford [Lan95]. DSS signatures turn out to be less amenable to sharing techniques than RSA or even other ElGamal-type of signatures, e.g., see [CMI93, Har94]. <p> Verification Algorithm. A signature S of a message m can be publicly verified by checking that S e = m mod N . 4.6.2 Outline Threshold RSA signatures against eavesdropping or halting adversaries were known in the literature before <ref> [DF92, DDFY94] </ref>. The basic construction underlying the existing threshold RSA schemes can be roughly described as follows. Key Generation Protocol a dealer shares the secret key d, among the n players, such that each player P i has a "share" d i of d.
Reference: [DH76] <author> W. Diffie and M. E. Hellman. </author> <title> New directions in cryptography. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-22:644-654, </volume> <month> November </month> <year> 1976. </year>
Reference: [Fel87] <author> P. Feldman. </author> <title> A practical scheme for non-interactive verifiable secret sharing. </title> <booktitle> In Proc. 28th IEEE Symp. on Foundations of Comp. Science, </booktitle> <pages> pages 427-438, </pages> <address> Los Angeles, 1987. </address> <publisher> IEEE. </publisher>
Reference-contexts: In researching this topic we came across to two papers that make passing references to this problem. 3.1 Preliminaries 53 In the original paper on generalized secret sharing [BL88], the authors say that it is possible to extend the techniques of Feldman <ref> [Fel87] </ref> in order to achieve VSS over access structures. In a more recent paper [Sta], Stadler proposes the notion of Publicly VSS in which the correctness of the sharing can be verified by any party in the network and not only by the shareholders. <p> They achieved security against an all-powerful adversary. Since in this chapter we are dealing with a computationally bounded adversary we use a different VSS protocol devised by Feldman <ref> [Fel87] </ref>. This protocol protects the secrecy of the shared secret only in a computational sense but has the advantage of being more efficient. <p> The section is structured as follows: in 4.5.1 we recall the Digital Signature Standard; in 4.5.2 we describe the key generation protocol which actually turns out to be a simple application of previous work of Feldman <ref> [Fel87] </ref> and Pedersen [Ped91]; in 4.5.4 we present a simple and extremely efficient protocol for the case of eavesdropping or halting adversary; the former protocol also serves as introduction to the full result 4.5 Robust DSS Threshold Signature Schemes 92 presented in 4.5.5. 4.5.1 The Digital Signature Standard (DSS) The Digital <p> In this section we simply sketch how to do this. The previous protocol used the Feldman and Pedersen VSS protocols <ref> [Fel87, Ped92] </ref> only to assure that secrets where shared correctly. When it came to authenticate the shares broadcasted by players in order to reconstruct a value, however we relied on error-correcting codes.
Reference: [FGY96] <author> Y. Frankel, P. Gemmell, and M. Yung. </author> <title> Witness-based Cryptographic Program Checking and Robust Function Sharing. </title> <note> To appear in proceedings of STOC96, </note> <year> 1996. </year>
Reference-contexts: Our results are the first robust threshold signature schemes for DSS. Notice also the dramatic improvement in fault-tolerance (we achieve t = n=4 compared to the t n in [Lan95].) In a recent and independent work, Frankel, Gemmel, and Yung <ref> [FGY96] </ref>, have extended the notion of result-checking introduced by Blum [BK89], to the setting of witness-based cryptographic checking. Among the main motivations for that work is the generation of a robust fault-tolerant RSA signature scheme. While [FGY96] provides a more general theoretical framework, our techniques, specifically designed 4.4 Existing Tools 88 <p> t n in [Lan95].) In a recent and independent work, Frankel, Gemmel, and Yung <ref> [FGY96] </ref>, have extended the notion of result-checking introduced by Blum [BK89], to the setting of witness-based cryptographic checking. Among the main motivations for that work is the generation of a robust fault-tolerant RSA signature scheme. While [FGY96] provides a more general theoretical framework, our techniques, specifically designed 4.4 Existing Tools 88 for RSA, result in much more efficient and practical solutions. In particular, our basic protocols involve just a small constant number of modular exponentiations while in [FGY96] a very large number, proportional to the security parameter, <p> While <ref> [FGY96] </ref> provides a more general theoretical framework, our techniques, specifically designed 4.4 Existing Tools 88 for RSA, result in much more efficient and practical solutions. In particular, our basic protocols involve just a small constant number of modular exponentiations while in [FGY96] a very large number, proportional to the security parameter, of such costly exponentiations is required. 4.4 Existing Tools In this section we recall a few known techniques that we use in our solutions.
Reference: [FM88] <author> Paul Feldman and Silvio Micali. </author> <title> An optimal probabilistic protocol for synchronous byzantine agreement. </title> <booktitle> In 20th ACM Symposium on Theory of Computing, </booktitle> <year> 1988. </year> <note> Final version to appear in the SIAM J. of Computing. </note>
Reference-contexts: In this chapter we recall previous work on threshold VSS and present a new stronger definition for such task. For the rest of the chapter, when not explicitly mentioned, we assume implicitly the threshold model. In the past, several definitions and protocols for VSS have been proposed (E.g., <ref> [CGMA85, BGW88, CCD88, FM88, Rab94] </ref>.) We contend, however, that these notions and these protocols are of limited use. <p> Indeed, and unfortunately, it is by now a well-known phenomenon that protocols that are secure by themselves, cease to be secure when used as a sub-protocols. In these cases the security of the entire protocol must be proven "from scratch" (for instance, this is the case in <ref> [FM88] </ref> where they use VSS as a tool to reach Byzantine agreement) rather than in a more natural and elegant "modular way." In this chapter we put forward a definition of VSS that guarantees reducibility; that is, security even when VSS is used as a sub-routine in an otherwise secure protocol. <p> To exactly capture the informal idea of VSS, has proven to be a hard task in itself. The definition reviewed below is that of <ref> [FM88] </ref>, which we will use as a token example of previous VSS definitions in the literature. Let us first introduce the notion of a fixed event. <p> Remark: A completely error-free version of this protocol can be obtained by running a different zero-knowledge proof that the shares lie on a single polynomial. The proof uses a bivariate polynomial. Details can be found in <ref> [BGW88, FM88] </ref>. 2.6.3 The Recover protocol In [BGW88], the Recover protocol is performed by having each player distribute the input share s i . As we have shown in Section 2.5, this is not a secure computation of the function rec against a dynamic adversary. <p> Any adversary (weak or strong) can corrupt the dealer. 3.2 Definitions In this section we adapt the definition by Feldman and Micali <ref> [FM88] </ref> described in Section 2.3 to the access structure model. As pointed out in Section 2.5 this definition is not completely satisfactory as it does not provide the reducibility property. <p> Broadcast channel/Error probability: Both our protocols rely on the existence of a broadcast channel and require a negligible probability of failure. Is this necessary? For example in the threshold case we know that it is possible to achieve VSS without a broadcast channel and in an error-free manner <ref> [BGW88, FM88] </ref>. Is it possible, at least for the weak adversary case, to devise a VSS protocol that is error-free and does not require a broadcast capability? Ideal structures: The running time of our protocols depend on ` the "size" of the access structure.
Reference: [Gam85] <author> T. El Gamal. </author> <title> A public key cryptosystem and a signature scheme based on discrete logarithms. </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> 31 </volume> <pages> 469-472, </pages> <year> 1985. </year> <note> Bibliography 133 </note>
Reference-contexts: protocol for the case of eavesdropping or halting adversary; the former protocol also serves as introduction to the full result 4.5 Robust DSS Threshold Signature Schemes 92 presented in 4.5.5. 4.5.1 The Digital Signature Standard (DSS) The Digital Signature Standard (DSS) [NIST91] is a signature scheme based on the El-Gamal <ref> [Gam85] </ref> and Schnorr's [Sch91] signature schemes, which was adopted as the US standard digital signature algorithm. In our description of the DSS protocol we follow the notation introduced in [Lan95], which differs from the original presentation of [NIST91] by switching k and k 1 .
Reference: [GJKRa] <author> Rosario Gennaro, Stas Jarecki, Hugo Krawczyk, and Tal Rabin. </author> <title> Robust threshold DSS signatures. </title> <note> To appear in EUROCRYPT 1996. </note>
Reference: [GJKRb] <author> Rosario Gennaro, Stas Jarecki, Hugo Krawczyk, and Tal Rabin. </author> <title> Robust and efficient sharing of RSA functions. </title> <note> To appear in CRYPTO 1996. </note>
Reference: [GM84] <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic encryption. </title> <journal> JCSS, </journal> <volume> 28(2) </volume> <pages> 270-299, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: The only differences are 1. since the adversary is static the simulators receive the inputs of the bad players right at the beginning of the simulation; 2. since the adversary is computationally bounded we allow the simulated view to be computationally indistinguishable (see <ref> [GM84] </ref>) from the real one. 4.3 Our results 86 4.2.4 The uninteresting solution Casting (as we did) the task of distributed generation of signatures as a secure evaluation of a function in a distributed manner, gives immediately a solution for any signature scheme S. <p> Commitment functions can be implemented in many ways. For example, in the above protocol commit (S R ) can be implemented as RSA encryption of S R concatenated with a random string r (the encryption is required to be semantically secure, see <ref> [GM84, BR94] </ref>), using a public key for which the private key is not known to V (and possibly, not even known to P ). To open the commitment, P reveals both S R and r.
Reference: [GM95] <author> Rosario Gennaro and Silvio Micali. </author> <title> Verifiable secret sharing as secure computation. </title> <booktitle> In EUROCRYPT'95, volume 921 of Lecture Notes in Computer Science, </booktitle> <pages> pages 168-182. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference: [GMR88] <author> Shafi Goldwasser, Silvio Micali, and Ronald L. Rivest. </author> <title> A digital signature scheme secure against adaptive chosen-message attacks. </title> <journal> SIAM J. Computing, </journal> <volume> 17(2) </volume> <pages> 281-308, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: In Section 4.5 and 4.6 we present the results about DSS and RSA respectively. 4.1 Signature Schemes In this section we recall the definition of signature schemes and their security from <ref> [GMR88] </ref>. A signature scheme S is a triple of polynomial time randomized algorithms (Key-Gen, Sig, Ver). Let K be a security parameter. Key-Gen is the key generation algorithm. <p> This is the analogous to the notion of existential unforgeability under chosen message attack as defined by Goldwasser, Micali, and Rivest <ref> [GMR88] </ref>. Following [GMR88] one can also define weaker notions of unforgeability (see Section 4.1.) In order to prove unforgeability we make use of the privacy feature of Definition 2.7. <p> This is the analogous to the notion of existential unforgeability under chosen message attack as defined by Goldwasser, Micali, and Rivest <ref> [GMR88] </ref>. Following [GMR88] one can also define weaker notions of unforgeability (see Section 4.1.) In order to prove unforgeability we make use of the privacy feature of Definition 2.7. <p> In other words, we could allow the adversary to gain knowledge provided that such knowledge is useless for forging. However our stronger definition subsumes this specific goal and provides a proof of security for any of the "flavors" of signature security as listed in <ref> [GMR88] </ref>. Indeed one can prove that if the underlying signature scheme S is unforgeable (in any of the flavors of [GMR88]) and T S is simulatable then T S is unforgeable (with the same flavor as S.) The Simulators. <p> However our stronger definition subsumes this specific goal and provides a proof of security for any of the "flavors" of signature security as listed in <ref> [GMR88] </ref>. Indeed one can prove that if the underlying signature scheme S is unforgeable (in any of the flavors of [GMR88]) and T S is simulatable then T S is unforgeable (with the same flavor as S.) The Simulators. The simulators for our protocols work mostly as described in Section 2.2.
Reference: [GMR89] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The knowledge complexity of interactive proof-systems. </title> <journal> SIAM. J. Computing, </journal> <volume> 18(1) </volume> <pages> 186-208, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: all initial configurations ~ ic, if view A P;Sim is the adversary view of the simulated execution of the protocol, we have that view A P;Network view A P;Sim (I.e., the two views are statistically indistinguishable.) For completeness we recall the definition of statistical indistinguishability of ensembles of random variables <ref> [GMR89] </ref>. Definition 2.8 Let X = (X n ) n and Y = (Y n ) n two countable families of random variables over the same probability space.
Reference: [GMW87] <author> O. Goldreich, S. Micali, and A. Wigderson. </author> <title> How to play any mental game. </title> <booktitle> In 19th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 218-229, </pages> <year> 1987. </year>
Reference-contexts: And she can further corrupt players after the function has been evaluated and learn their outputs. These problems should, however, be regarded as inevitable. Indeed, following <ref> [GMW87] </ref>, in [MR92] the authors call a protocol for evaluating f secure if it approximates the above ideal scenario "as closely as possible." The nature of this approximation is informally summarized below. Let us define the following quantities within the context of a protocol P . <p> Secure Computation: Is it possible to define a notion of secure computation over general access structure. As in the threshold case <ref> [GMW87, BGW88, CCD88, RB89] </ref> the idea would be to have a set of n players and an access structure defined on it. <p> Indeed we know various protocols for the secure computation of any function f in a distributed manner (see for example <ref> [GMW87, BGW88, CCD88, RB89] </ref>.) However the generality of such protocols involves inefficiency and makes them hopelessly impractical for the task at hand. <p> Verification of the parameters. We need to check that the dealer chooses the modulus n of the right form, i.e. n = pq with p = 2p 0 + 1 and q = 2q 0 + 1. Although this choice can be theoretically checked using the general results of <ref> [GMW87] </ref> on secure computation, the resultant solution would be hardly practical. To alleviate this problem one could have the dealer generate a large set of moduli n 1 ; n 2 ; from which the players collectively choose a random element, say n i .
Reference: [GMW91] <author> Oded Goldreich, Silvio Micali, and Avi Wigderson. </author> <title> Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems. </title> <journal> Journal of the ACM, </journal> <volume> 38(1) </volume> <pages> 691-729, </pages> <year> 1991. </year>
Reference-contexts: The protocol in figure 4-8 is actually not zero-knowledge. For example, a cheating verifier V fl can choose R in a different way than specified and then learn S R , which V fl could not compute by himself. However, there are well-known techniques <ref> [GMW91, BCC88, Gol95] </ref> to add the zero-knowledge property to the above protocol using the notion of a commitment function: Instead of P sending S R in Step 2, he sends a commitment commit (S R ), after which V reveals to P the values of i and j.
Reference: [Gol95] <author> Oded Goldreich. </author> <title> Foundation of Cryptography Fragments of a Book. </title> <booktitle> Electronic Colloquium on Computational Complexity, </booktitle> <month> February </month> <year> 1995. </year> <note> Available online from http://www.eccc.uni-trier.de/eccc/. </note>
Reference-contexts: The protocol in figure 4-8 is actually not zero-knowledge. For example, a cheating verifier V fl can choose R in a different way than specified and then learn S R , which V fl could not compute by himself. However, there are well-known techniques <ref> [GMW91, BCC88, Gol95] </ref> to add the zero-knowledge property to the above protocol using the notion of a commitment function: Instead of P sending S R in Step 2, he sends a commitment commit (S R ), after which V reveals to P the values of i and j.
Reference: [Har94] <author> Lein Harn. </author> <title> Group-oriented (t; n) threshold digital signature scheme and digital multisignature. </title> <journal> IEE Proc. Comput. Digit. Tech., </journal> <volume> 141(5) </volume> <pages> 307-313, </pages> <year> 1994. </year> <note> Bibliography 134 </note>
Reference-contexts: This approach has received considerable attention in the literature; we refer the reader to [Des94] for a survey of the work in this area. Particular examples of solutions to threshold signatures can be found in [DF92, DDFY94] for the case of RSA signatures, and <ref> [CMI93, Har94, Lan95] </ref> for ElGamal-type of signatures. Threshold DSS signatures schemes were recently studied by Langford [Lan95]. DSS signatures turn out to be less amenable to sharing techniques than RSA or even other ElGamal-type of signatures, e.g., see [CMI93, Har94]. <p> Threshold DSS signatures schemes were recently studied by Langford [Lan95]. DSS signatures turn out to be less amenable to sharing techniques than RSA or even other ElGamal-type of signatures, e.g., see <ref> [CMI93, Har94] </ref>. Langford has overcome some of these difficulties in the case of DSS, exhibiting a solution which requires a group of n = t 2 t + 1 players in order to tolerate up to t players that might refuse to participate in the signature protocol.
Reference: [ISN87] <author> M. Ito, A. Saito, and T. Nishizeki. </author> <title> Secret sharing scheme realizing general access structure. </title> <booktitle> In Proceedings IEEE Globecom '87, </booktitle> <pages> pages 99-102. </pages> <publisher> IEEE, </publisher> <year> 1987. </year>
Reference: [Kah67] <editor> D. Kahn. </editor> <booktitle> The Codebreakers. </booktitle> <address> Macmillian, New York, </address> <year> 1967. </year>
Reference: [KGH83] <author> E. Karnin, J. Greene, and M. Hellman. </author> <title> On sharing secret systems. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-29:35-41, </volume> <year> 1983. </year>
Reference: [Lan95] <author> S. Langford. </author> <title> Threshold DSS signatures without a trusted party. </title> <booktitle> In Crypto'95, </booktitle> <pages> pages 397-409. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <note> Lecture Notes in Computer Science No. 963. </note>
Reference-contexts: This approach has received considerable attention in the literature; we refer the reader to [Des94] for a survey of the work in this area. Particular examples of solutions to threshold signatures can be found in [DF92, DDFY94] for the case of RSA signatures, and <ref> [CMI93, Har94, Lan95] </ref> for ElGamal-type of signatures. Threshold DSS signatures schemes were recently studied by Langford [Lan95]. DSS signatures turn out to be less amenable to sharing techniques than RSA or even other ElGamal-type of signatures, e.g., see [CMI93, Har94]. <p> Particular examples of solutions to threshold signatures can be found in [DF92, DDFY94] for the case of RSA signatures, and [CMI93, Har94, Lan95] for ElGamal-type of signatures. Threshold DSS signatures schemes were recently studied by Langford <ref> [Lan95] </ref>. DSS signatures turn out to be less amenable to sharing techniques than RSA or even other ElGamal-type of signatures, e.g., see [CMI93, Har94]. <p> Our results are the first robust threshold signature schemes for DSS. Notice also the dramatic improvement in fault-tolerance (we achieve t = n=4 compared to the t n in <ref> [Lan95] </ref>.) In a recent and independent work, Frankel, Gemmel, and Yung [FGY96], have extended the notion of result-checking introduced by Blum [BK89], to the setting of witness-based cryptographic checking. Among the main motivations for that work is the generation of a robust fault-tolerant RSA signature scheme. <p> In our description of the DSS protocol we follow the notation introduced in <ref> [Lan95] </ref>, which differs from the original presentation of [NIST91] by switching k and k 1 . This change will allow a clearer presentation of our threshold DSS signature protocols. Key Generation.
Reference: [MR92] <author> S. Micali and P. Rogaway. </author> <title> Secure computation. </title> <editor> In J. Feigenbaum, editor, </editor> <booktitle> Proc. CRYPTO 91, </booktitle> <pages> pages 392-404. </pages> <publisher> Springer, </publisher> <year> 1992. </year> <note> Lecture Notes in Computer Science No. 576. </note>
Reference-contexts: A notion of security that guarantees reducibility has been presented by Micali and Rogaway <ref> [MR92] </ref>, for the problem of function evaluation. We thus wish to extend reducibility-guaranteeing notions of security to verifiable secret sharing protocols and concretely exhibit VSS protocols that provably satisfy these notions. More precisely, we achieve the following goals: 1. <p> Notice that the adversary A can see m only if somebody has been corrupted. 2.2 Secure Function Evaluation In this section we summarize the work of Micali and Rogaway on the definition of secure protocols for function evaluation <ref> [MR92] </ref>. <p> And she can further corrupt players after the function has been evaluated and learn their outputs. These problems should, however, be regarded as inevitable. Indeed, following [GMW87], in <ref> [MR92] </ref> the authors call a protocol for evaluating f secure if it approximates the above ideal scenario "as closely as possible." The nature of this approximation is informally summarized below. Let us define the following quantities within the context of a protocol P . <p> In particular, the following one: the definition above allows one to prove formally many desirable properties of secure protocols, the most interesting for us being reducibility: Theorem 2.1 (Reducibility <ref> [MR92] </ref>) Let f and g be two functions. Suppose there is a protocol P that securely evaluates f in the model of computation in which it can 2.3 Prior definitions of VSS. 30 perform ideal evaluations of g. Suppose also that there is a protocol Q that securely computes g. <p> Suppose also that there is a protocol Q that securely computes g. Denote with P Q the protocol in which the code of Q is substituted in P in the places where P ideally computes g. Then P Q is secure. Interested readers are referred to the original paper <ref> [MR92] </ref> for a proof of this statement and a complete and a formal description of their definition. Notation: Let P be a protocol computing the n-valued function f and Q be a protocol computing the function g. <p> The key idea for achieving this property is to cast VSS in terms of secure function evaluation. Accordingly, we shall define two special functions shar and rec, and demand that both of them be securely evaluated in the sense of <ref> [MR92] </ref> (see Section 2.2.) Let be a set. <p> Indeed those results rely on VSS constructions, so we would be just biting our tail. In particular by showing that Definition 2.13 is not empty, we are also showing that the Micali-Rogaway definition of security <ref> [MR92] </ref> is not empty either. 2.6 A VSS protocol that satisfies our definition 39 We show a VSS protocol of fault-tolerance t which is secure according to Definition 2.13 when n 3t + 1. <p> Security. We need to define what a secure threshold signature scheme is. In order to do so we go back to the definition of secure function evaluation in <ref> [MR92] </ref>.
Reference: [MS81] <author> R. McEliece and D. Sarwate. </author> <title> On sharing secrets and reed-solomon codes. </title> <journal> Communications of the ACM, </journal> <volume> 24(9) </volume> <pages> 583-584, </pages> <month> September </month> <year> 1981. </year>
Reference-contexts: For details readers can refer to a standard text like [PW72] or to the Appendix in [Sud96]. The application of error-correcting codes to secret sharing was first noticed by McEliece and Sarwate in <ref> [MS81] </ref>. 2.6 A VSS protocol that satisfies our definition 40 Let rec-a be the function rec-a (s 1 ; : : : ; s n ; *) = (s; : : : ; s; s) where s is the result of the Berlekamp-Welch decoder on input s 1 ; : :
Reference: [NIST91] <author> National Institute for Standards and Technology. </author> <title> A proposed federal information processing standard for digital signature standard (DSS). </title> <type> Technical Report FIPS PUB XX, </type> <institution> National Institute for Standards and Technology, </institution> <month> August </month> <year> 1991. </year> <note> DRAFT. </note>
Reference-contexts: We need ad hoc solutions constructed case by case for the specific signature scheme at hand. 4.3 Our results In this chapter we present robust threshold signature schemes for both the Digital Signature Standard (DSS) <ref> [NIST91] </ref> and the RSA signature scheme [RSA78]. The importance of providing threshold solutions for signatures schemes used in practice, is that those systems are the ones that will be deployed in the real world and hence they are the ones that require real protection. <p> in 4.5.4 we present a simple and extremely efficient protocol for the case of eavesdropping or halting adversary; the former protocol also serves as introduction to the full result 4.5 Robust DSS Threshold Signature Schemes 92 presented in 4.5.5. 4.5.1 The Digital Signature Standard (DSS) The Digital Signature Standard (DSS) <ref> [NIST91] </ref> is a signature scheme based on the El-Gamal [Gam85] and Schnorr's [Sch91] signature schemes, which was adopted as the US standard digital signature algorithm. In our description of the DSS protocol we follow the notation introduced in [Lan95], which differs from the original presentation of [NIST91] by switching k and <p> Digital Signature Standard (DSS) <ref> [NIST91] </ref> is a signature scheme based on the El-Gamal [Gam85] and Schnorr's [Sch91] signature schemes, which was adopted as the US standard digital signature algorithm. In our description of the DSS protocol we follow the notation introduced in [Lan95], which differs from the original presentation of [NIST91] by switching k and k 1 . This change will allow a clearer presentation of our threshold DSS signature protocols. Key Generation. <p> g ms 1 mod p This basically implies that the extra reduction mod q has the only purpose to shorten a DSS signature, but serves no security purpose. 4.5.2 DSS Threshold Key-generation An instance (p; q; g) of DSS can be generated using a public procedure (e.g., as specified in <ref> [NIST91] </ref>), or using randomness which is jointly provided by the players. To generate a pair of public and private keys in a distributed setting without a trusted party, we use a joint verifiable secret sharing protocol, following another protocol by Pedersen [Ped91].
Reference: [Ped91] <author> T. Pedersen. </author> <title> Distributed provers with applications to undeniable signatures. </title> <booktitle> In EuroCrypt'91, </booktitle> <year> 1991. </year>
Reference-contexts: The section is structured as follows: in 4.5.1 we recall the Digital Signature Standard; in 4.5.2 we describe the key generation protocol which actually turns out to be a simple application of previous work of Feldman [Fel87] and Pedersen <ref> [Ped91] </ref>; in 4.5.4 we present a simple and extremely efficient protocol for the case of eavesdropping or halting adversary; the former protocol also serves as introduction to the full result 4.5 Robust DSS Threshold Signature Schemes 92 presented in 4.5.5. 4.5.1 The Digital Signature Standard (DSS) The Digital Signature Standard (DSS) <p> To generate a pair of public and private keys in a distributed setting without a trusted party, we use a joint verifiable secret sharing protocol, following another protocol by Pedersen <ref> [Ped91] </ref>. That is the players run an execution of Joint-Feldman-RSS (see Section 4.4).
Reference: [Ped92] <author> T.P. Pedersen. </author> <title> Non-interactive and information-theoretic secure verifiable secret sharing. </title> <editor> In J. Feigenbaum, editor, </editor> <booktitle> Proc. CRYPTO 91, </booktitle> <pages> pages 129-140. </pages> <publisher> Springer, </publisher> <year> 1992. </year> <note> Lecture Notes in Computer Science No. 576. </note>
Reference-contexts: Notice that the value of the secret is only computationally secure, e.g., the value g a 0 = g mod p is leaked. In the following we 4.4 Existing Tools 89 will refer to this protocol by Feldman-VSS. 4.4.2 Pedersen's VSS This protocol was presented by Pedersen in <ref> [Ped92] </ref>. In contrast to Feldman's VSS protocol, this protocol provides information theoretic secrecy for the shared secret as the ones in [BGW88, Rab94]. This is required by some of our techniques in order to achieve provable security. <p> Assume nobody knows DL g (h), the discrete log in base g of h. Then a commitment to a value a can be computed as cmt (a; r) = g a h r mod p Pedersen shows in <ref> [Ped92] </ref> that for any a 2 Z q and for randomly uniformly chosen r 2 Z q the value cmt (a; r) is uniformly distributed in Z p , yielding thus no information about a. <p> In this section we simply sketch how to do this. The previous protocol used the Feldman and Pedersen VSS protocols <ref> [Fel87, Ped92] </ref> only to assure that secrets where shared correctly. When it came to authenticate the shares broadcasted by players in order to reconstruct a value, however we relied on error-correcting codes.
Reference: [PW72] <author> W. Peterson and E. Weldon. </author> <title> Error Correcting Codes. </title> <publisher> MIT Press, </publisher> <year> 1972. </year>
Reference-contexts: For details readers can refer to a standard text like <ref> [PW72] </ref> or to the Appendix in [Sud96].
Reference: [Rab94] <author> Tal Rabin. </author> <title> Robust sharing of secrets when the dealer is honest or cheating. </title> <journal> Journal of the ACM, </journal> <volume> 41(6) </volume> <pages> 1089-1109, </pages> <year> 1994. </year> <note> Bibliography 135 </note>
Reference-contexts: In this chapter we recall previous work on threshold VSS and present a new stronger definition for such task. For the rest of the chapter, when not explicitly mentioned, we assume implicitly the threshold model. In the past, several definitions and protocols for VSS have been proposed (E.g., <ref> [CGMA85, BGW88, CCD88, FM88, Rab94] </ref>.) We contend, however, that these notions and these protocols are of limited use. <p> We show that our new definition is not "empty", meaning we construct VSS protocols satisfying it. Such protocols are obtained by modifications of earlier ones due to Ben-Or, Goldwasser and Wigderson ([BGW88]) and T. Rabin <ref> [Rab94] </ref>. 2.1 Computational Model 25 2.1 Computational Model We consider n players P 1 ; : : : ; P n . A protocol is a set of instruction for these players. Each party run his own component of the protocol. <p> The modification actually occurs only in the Recover part, and uses techniques also developed in [BGW88], but within their "computational protocol" rather than in their VSS protocol. It is possible to obtain a better fault-tolerance by using the VSS protocol of Tal Rabin <ref> [Rab94] </ref>. We will sketch this construction in Section 2.7. Suppose we are dealing with a t-adversary A. Let n = 3t + 1, P 1 ; : : : ; P n the set of players and D the dealer. <p> Then the protocol P A =(Share-Verify-A, Recover-A) is a VSS protocol according to Definition 2.13 with fault-tolerance t. 2.7 On achieving fault-tolerance of n In this section we sketch how we can modify Tal Rabin's VSS protocol (see <ref> [Rab94] </ref>) so that it can fit our stronger definition. We will not go deep into the details of the modifications we are going to use Rabin's protocol as a basis to construct VSS protocols in the access structure model in Chapter 3. <p> have all free term 0 checking that the broadcasted polynomials in rounds 3 and 9 have all free term 0 In the following we will refer to such protocols as 0-VSS. 2.7 On achieving fault-tolerance of n 2 50 2.7.2 Modifications to Rabin's protocol It turns out that Rabin's protocol <ref> [Rab94] </ref> has the same properties of the protocol in [BGW88]. In particular this means that we can apply the same transformation technique. Let Share-Verify-B be the sharing protocol in [Rab94]. Let 0-Share-Verify-B the 0-VSS protocol based on Share-Verify-B. <p> as 0-VSS. 2.7 On achieving fault-tolerance of n 2 50 2.7.2 Modifications to Rabin's protocol It turns out that Rabin's protocol <ref> [Rab94] </ref> has the same properties of the protocol in [BGW88]. In particular this means that we can apply the same transformation technique. Let Share-Verify-B be the sharing protocol in [Rab94]. Let 0-Share-Verify-B the 0-VSS protocol based on Share-Verify-B. In order to make Rabin's VSS protocol secure according to Definition 2.13 we modify the reconstruction protocol as follows Recover-B (modified from [Rab94]) Input for Player P i : A value s i 1. each player P i runs 0-Share-Verify-B as the <p> Let Share-Verify-B be the sharing protocol in <ref> [Rab94] </ref>. Let 0-Share-Verify-B the 0-VSS protocol based on Share-Verify-B. In order to make Rabin's VSS protocol secure according to Definition 2.13 we modify the reconstruction protocol as follows Recover-B (modified from [Rab94]) Input for Player P i : A value s i 1. each player P i runs 0-Share-Verify-B as the dealer. Let a (j) i the share received by player P j from P i 's sharing. 2. The players run the reconstruction protocol from [Rab94] using s i + a <p> as follows Recover-B (modified from <ref> [Rab94] </ref>) Input for Player P i : A value s i 1. each player P i runs 0-Share-Verify-B as the dealer. Let a (j) i the share received by player P j from P i 's sharing. 2. The players run the reconstruction protocol from [Rab94] using s i + a (i) : : : + a (i) n as input. Rabin's protocol and its modification above achieve fault-tolerance t when n 2t + 1. <p> For example the protocols by Ben-Or, Gold-wasser and Wigderson [BGW88] and Chaum, Crepeau and Damgard [CCD88] enforce a bound of n=3 corrupted players. Tal Rabin improves this to n=2 in <ref> [Rab94] </ref>. Given a network of players, with an access structure F defined on it, we need to define what kinds of adversary can be allowed in order to obtain fault-tolerance in the secret sharing process. <p> The only thing that we must assure is that the secret is reconstructable at recover time in spite of the presence of potentially so many bad players 2 . The basic idea is drawn for Tal Rabin's check vectors technique <ref> [Rab94] </ref>. To make sure that a player broadcasts the correct share at recover time, the dealer distributes unconditionally secure authentication codes for the shares. When the share is broadcasted only the ones that can be authenticated are accepted as good. <p> At the same time she cannot get any information from the check vectors since they are unconditionally secure message authentication codes (see <ref> [Rab94] </ref>) so they leak no information about the missing shares. In order to prove that the secret is successfully reconstructed we need to prove that the shares accepted at the end of Recover are all the good ones and only the good ones. <p> By the instruction in round 4 this means that s m;j is accepted. Now let's prove that the probability that a bad share is accepted at the end of Recover is at most n 2 ` p . Indeed as Rabin proves in <ref> [Rab94] </ref>, the probability that a bad share ^s m;j is accepted is equal to the probability that P m;j guesses a value ^y (i) m;j such that the pair (^s m;j ; ^y (i) m;j ) passes equation (3.1). This probability is exactly 1 p . <p> The protocol is a modification of Rabin's threshold VSS protocol with honest majority <ref> [Rab94] </ref>. We proceed in two phases: first we describe a protocol which has only some of the desired features of a VSS, we call it a Semi-VSS. <p> Our protocol is modeled after a similar protocol by Rabin <ref> [Rab94] </ref>. She calls her protocol WSS for Weak Secret Sharing, but we chose the name of Semi-VSS to avoid confusion with our notion of weak adversary. The basic idea is that the dealer shares a secret using the protocol in Section 1.2.3. <p> At the same time she cannot get any information from the check vectors since they are unconditionally secure message authentication codes (see <ref> [Rab94] </ref>) so they leak no information about the missing shares. <p> Now let's prove that the probability that a bad share is accepted at the end of Semi-Recover is at most n 2 `K p . Indeed as Rabin proves in <ref> [Rab94] </ref>, the probability that a bad share ^s m;j is accepted is equal to the probability that P m;j guesses a value ^y m;j such that the pair (^s m;j ; ^y (i) m;j ) passes equation (3.2) for at least one of the K components being checked. <p> Such probability is is 1 ( 2k k 3.5.2 The full protocol Now we are ready to describe the full solution for VSS over general access structure against a strong adversary. This can be considered a modification of Rabin's protocol <ref> [Rab94] </ref> to work over access structures. The protocol is loosely based on the ideas behind VSS against a weak adversary. The main difference with the previous protocol is that during the Share-Verify phase each player will Semi-VSS his own shares among the other players. <p> In the following we will make several references to Shamir's Secret Sharing protocol Shamir-SS which we described in Section 1.2.1. The reader is referred to that section for details. 4.4.1 Feldman's VSS In Chapter 2 we recalled various VSS protocols <ref> [BGW88, Rab94] </ref>. They achieved security against an all-powerful adversary. Since in this chapter we are dealing with a computationally bounded adversary we use a different VSS protocol devised by Feldman [Fel87]. <p> In the following we 4.4 Existing Tools 89 will refer to this protocol by Feldman-VSS. 4.4.2 Pedersen's VSS This protocol was presented by Pedersen in [Ped92]. In contrast to Feldman's VSS protocol, this protocol provides information theoretic secrecy for the shared secret as the ones in <ref> [BGW88, Rab94] </ref>. This is required by some of our techniques in order to achieve provable security. However, in order to achieve security, Pedersen's VSS still uses in a crucial way the fact that the adversary is computationally bounded. <p> The original ICP <ref> [Rab94, RB89] </ref> works only over prime fields. A very rough description of the verification method is the following: assume two players P and V . The prover P holds values d P in Z (N) (the secret key) and y.
Reference: [Rab95] <author> M. Rabin. </author> <title> A Simplification Approach to Distributed Multiparty Computations. </title> <type> Personal communication to Tal Rabin, </type> <year> 1995. </year>
Reference-contexts: In those works extra steps were added in order to reduce the degree of the interpolation polynomial back to t. This involved zero-knowledge proofs and use of error-correction again, with the consequence of losing in efficiency. Even the simplified version of Rabin <ref> [Rab95] </ref> for this task involves non-trivial zero-knowledge proofs for verifiability.
Reference: [RB89] <author> T. Rabin and M. Ben-Or. </author> <title> Verifiable secret sharing and multiparty protocols with honest majority. </title> <booktitle> In 21st ACM Symposium on Theory of Computing, </booktitle> <pages> pages 73-85, </pages> <year> 1989. </year>
Reference-contexts: Notice that we cannot simply invoke the completeness theorems of <ref> [BGW88, CCD88, RB89] </ref> that say that any function can be computed securely in our model, in particular two functions shar and rec constituting a sharing-reconstructing pair. Indeed those results rely on VSS constructions, so we would be just biting our tail. <p> Secure Computation: Is it possible to define a notion of secure computation over general access structure. As in the threshold case <ref> [GMW87, BGW88, CCD88, RB89] </ref> the idea would be to have a set of n players and an access structure defined on it. <p> Indeed we know various protocols for the secure computation of any function f in a distributed manner (see for example <ref> [GMW87, BGW88, CCD88, RB89] </ref>.) However the generality of such protocols involves inefficiency and makes them hopelessly impractical for the task at hand. <p> The original ICP <ref> [Rab94, RB89] </ref> works only over prime fields. A very rough description of the verification method is the following: assume two players P and V . The prover P holds values d P in Z (N) (the secret key) and y.
Reference: [RSA78] <author> Ronald L. Rivest, Adi Shamir, and Leonard M. Adleman. </author> <title> A method for obtaining digital signatures and public-key cryptosystems. </title> <journal> Communications of the ACM, </journal> <volume> 21(2) </volume> <pages> 120-126, </pages> <year> 1978. </year>
Reference-contexts: We need ad hoc solutions constructed case by case for the specific signature scheme at hand. 4.3 Our results In this chapter we present robust threshold signature schemes for both the Digital Signature Standard (DSS) [NIST91] and the RSA signature scheme <ref> [RSA78] </ref>. The importance of providing threshold solutions for signatures schemes used in practice, is that those systems are the ones that will be deployed in the real world and hence they are the ones that require real protection. <p> for signature generation; in Sections 4.8 we present a somewhat less efficient interactive signature protocol, however this protocol has some other properties that can make it preferable to the non-interactive one. 4.6 Robust RSA Threshold Signature Schemes 108 4.6.1 The RSA signature scheme The RSA signature scheme was introduced in <ref> [RSA78] </ref> and has since become one of the most popular signature schemes in the cryptographic community. Key Generation. An RSA key is composed of a public key (N; e), and a secret key d, where: 1.
Reference: [Sch91] <author> C. P. Schnorr. </author> <title> Efficient signature generation by smart cards. </title> <journal> Journal of Cryptology, </journal> <volume> 4 </volume> <pages> 161-174, </pages> <year> 1991. </year>
Reference-contexts: case of eavesdropping or halting adversary; the former protocol also serves as introduction to the full result 4.5 Robust DSS Threshold Signature Schemes 92 presented in 4.5.5. 4.5.1 The Digital Signature Standard (DSS) The Digital Signature Standard (DSS) [NIST91] is a signature scheme based on the El-Gamal [Gam85] and Schnorr's <ref> [Sch91] </ref> signature schemes, which was adopted as the US standard digital signature algorithm. In our description of the DSS protocol we follow the notation introduced in [Lan95], which differs from the original presentation of [NIST91] by switching k and k 1 .
Reference: [Sch96] <author> Bruce Schneier. </author> <title> Applied Cryptography (Second Edition). </title> <publisher> John Wiley & Sons, </publisher> <year> 1996. </year>
Reference: [Sha79] <author> A. Shamir. </author> <title> How to share a secret. </title> <journal> Communications of the ACM, </journal> <volume> 22 </volume> <pages> 612-613, </pages> <month> November </month> <year> 1979. </year>
Reference-contexts: This is what we achieve with Definition 2.13. Probably one of the reasons this point may appear somewhat moot is that in Shamir's (t; n)-threshold secret sharing scheme <ref> [Sha79] </ref> (see Section 1.2.1) the shares consist 2.6 A VSS protocol that satisfies our definition 38 of the value of a polynomial of degree t with free term s. For a t-adversary who corrupts exactly t players, knowing the secret is equivalent to knowing the shares of all players. <p> : : : ; s n Lemma 2.2 If n 3t+1 then shar-a and rec-a constitute a sharing-reconstructing pair with parameter t Proof Domain Immediate once one sets = S = Z p and R = Z t p . t-uniformity This is the property first identified by Shamir in <ref> [Sha79] </ref>. Once one fixes l t shares and the secret s you get an underdetermined system of linear equations in the a i 's. <p> This in turn is the basis of our fully fault-tolerant solutions. So we want to compute an RSA signature S = m d mod N where d is the secret key. Suppose that we share d among n players using Shamir's (t; n)-threshold scheme <ref> [Sha79] </ref>. Let d i be the share of player P i . We know that d can be written as a linear combination of any set V of t + 1 shares d i (see Section 1.2.1): d = j where the 0;j;V 's are the appropriate Lagrange interpolation coefficients.
Reference: [Sta] <author> Markus Stadler. </author> <title> Publicly verifiable secret sharing. </title> <note> To appear in EURO-CRYPT 1996. </note>
Reference-contexts: In a more recent paper <ref> [Sta] </ref>, Stadler proposes the notion of Publicly VSS in which the correctness of the sharing can be verified by any party in the network and not only by the shareholders.
Reference: [Sti92] <author> D.R. Stinson. </author> <title> An explication of secret sharing schemes. Designs, Codes, </title> <journal> and Cryptography, </journal> <volume> 2 </volume> <pages> 357-390, </pages> <year> 1992. </year>
Reference: [Sti95] <author> Douglas R. Stinson. </author> <title> Cryptography: Theory and Practice. </title> <publisher> CRC Press, </publisher> <year> 1995. </year>
Reference: [Sud96] <author> Madhu Sudan. </author> <title> Efficient Checking of Polynomials and Proofs and the Hardness of Approximation Problems, </title> <booktitle> volume 1001 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: For details readers can refer to a standard text like [PW72] or to the Appendix in <ref> [Sud96] </ref>.
References-found: 57

