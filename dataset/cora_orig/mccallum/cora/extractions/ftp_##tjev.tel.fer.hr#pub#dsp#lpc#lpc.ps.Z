URL: ftp://tjev.tel.fer.hr/pub/dsp/lpc/lpc.ps.Z
Refering-URL: 
Root-URL: 
Email: newsham@wiliki.eng.hawaii.edu  
Title: Linear Predictive Coding on the ADSP-2105  
Author: Timothy N. Newsham 
Note: listing are included.  
Date: January 18, 1994  
Affiliation: Electrical Engineering Department University of Hawaii at Manoa  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Analog Devices. </author> <title> Digital Signal Processing Applications using the ADSP-2100 Family. </title> <publisher> Prentice-Hall, Inc. </publisher> <address> New Jersey. </address>
Reference-contexts: LPC uses an all- pole approximation. Using an all-zero (FIR) filter of order N we can predict the next output sample u 0 [N + 1] from the previous N samples u <ref> [1] </ref> through u [N ] as: u 0 [N + 1] = i=1 The parameters a [1] through a [N ] which we wish to find are the parameters to the all-zero filter which has the inverse spectral shape as the signal u [i]. <p> LPC uses an all- pole approximation. Using an all-zero (FIR) filter of order N we can predict the next output sample u 0 [N + 1] from the previous N samples u <ref> [1] </ref> through u [N ] as: u 0 [N + 1] = i=1 The parameters a [1] through a [N ] which we wish to find are the parameters to the all-zero filter which has the inverse spectral shape as the signal u [i]. <p> If the excitation signal is more random than periodic then the value of R e [pitch] will be small with respect to the power of the signal (which is R e [0]). We choose a threshold value X and call any signal voiced if the following equation holds true <ref> [1] </ref>: R e [pitch] R e [0] Experimentation shows that a good value for X is between 0:25 and 0:5. 5 3 The Algorithm To encode speech we first sample the speech. <p> The samples are then broken up into chunks that have only one sound and one pitch. This involves taking short segments of the speech (called frames) that are on the order of 20 to 30 milliseconds long <ref> [1] </ref> At 8khz these frames are 160 to 240 samples long and there are between 33 and 50 frames per second. These frames can be overlapping to provide more continuity between frames. <p> The indexing for the `u' variable is more complex. First u [9] is read and u [10] written, then u [8] read and u [9] written. In the final iteration u [0] is read and u <ref> [1] </ref> is written and the output value is copied into u [0]. The indexing in this program follows this pattern, remembering that the `u' values are arranged backwards, reads a value, moves backwards one, writes a value and moves forwards 2. After the 10th iteration the pointer points at u [1] <p> <ref> [1] </ref> is written and the output value is copied into u [0]. The indexing in this program follows this pattern, remembering that the `u' values are arranged backwards, reads a value, moves backwards one, writes a value and moves forwards 2. After the 10th iteration the pointer points at u [1] and is moved backwards by one to fill in u [0]. 4.4.4 Random The random number generation routine generates a single random number by the method of linear congruence. The algorithm and parts of the code are taken from [1] and modified appropriately. <p> After the 10th iteration the pointer points at u <ref> [1] </ref> and is moved backwards by one to fill in u [0]. 4.4.4 Random The random number generation routine generates a single random number by the method of linear congruence. The algorithm and parts of the code are taken from [1] and modified appropriately. The actual algorithm for the next random number is: x [n] = (1664525x [n 1] + 32767) mod 2 32 The routine uses double precision math and uses two words to store the previous value x [n 1]. <p> Next a loop is used to calculate the values a [j]R ij and subtract them from the accumulator. This is accomplished by having the I5 variable index R i1 through R 1 while the I0 register scans from a <ref> [1] </ref> to a [order 1]. At the end of the loop the I0 register points to a [order + 1] (this fact will be used later in the loop). <p> The parameter K i is computed from this value and stored at this point. Note that b [i] has not yet been stored, it is stored later when an index register is conveniently pointing at the proper memory location. Next the values b <ref> [1] </ref> through b [i1] are computed in another loop. This time the I0 register is used to index a [order1] to a [1] (the address for a [order1] is computed by subtracting 2 from the old value of I0 which you will remember pointed to a [order+1]) while I1 indexes the <p> Next the values b <ref> [1] </ref> through b [i1] are computed in another loop. This time the I0 register is used to index a [order1] to a [1] (the address for a [order1] is computed by subtracting 2 from the old value of I0 which you will remember pointed to a [order+1]) while I1 indexes the values a [1] through a [order1] and I2 indexes b [1] through b [order1]. <p> This time the I0 register is used to index a [order1] to a <ref> [1] </ref> (the address for a [order1] is computed by subtracting 2 from the old value of I0 which you will remember pointed to a [order+1]) while I1 indexes the values a [1] through a [order1] and I2 indexes b [1] through b [order1]. In each iteration one more value of b [j] is computed. When the loop completes the I2 pointer points to b [i] and the value for b [i] which was computed earlier is filled in. <p> the I0 register is used to index a [order1] to a <ref> [1] </ref> (the address for a [order1] is computed by subtracting 2 from the old value of I0 which you will remember pointed to a [order+1]) while I1 indexes the values a [1] through a [order1] and I2 indexes b [1] through b [order1]. In each iteration one more value of b [j] is computed. When the loop completes the I2 pointer points to b [i] and the value for b [i] which was computed earlier is filled in. <p> The function assumes that the input is in 1.15 fixed point representation. If the value passed is a negative then an error value is returned. The algorithm used to compute the square root is taken from <ref> [1] </ref> and is a polynomial fit to the curve f (x) = sqrt (x) on the interval of 0:5 x &lt; 1:0.
Reference: [2] <author> Analog Devices. </author> <title> ADSP-2101 ADSP2102 User's Manual Architecture. Analog Devices. </title>
Reference-contexts: R N1 R0 fi fi fi fi fi fi fi fi fi fi fi fi a <ref> [2] </ref> . . . fi fi fi fi fi fi = fi fi fi fi fi fi R 2 . . . fi fi fi fi fi fi We note that R i = R fl i [5] and if the signal is a real sequence R i = R i <p> With careful planning LPC can be implemented without any external RAM. The proces 8 sor can boot internal memory from an external source such as EEPROM when reset. For more information see <ref> [2] </ref>. 4.1.1 CPU The hardware design is fairly straight forward. At the center of the design is the ADSP2105. An EEPROM is attached to the data and address busses and is used by the processor to load the internal program memory whenever the chip is reset.
Reference: [3] <author> A. V. Oppenheim, R. W. Schafer. </author> <title> Discrete-Time Signal Processing. </title> <publisher> Prentice-Hall, Inc. </publisher> <address> New Jersey </address>
Reference-contexts: The model of speech generation used in Linear Predictive Coding is shown in Figure 1 <ref> [3] </ref>. First an excitation signal is generated, this corresponds to the voice-box in the throat for voiced sounds and the turbulent flow of air through the mouth for unvoiced sounds (such as the sounds `sh' and `t').
Reference: [4] <author> A. V. Oppenheim. </author> <title> Applications of Digital Signal Processing. </title> <publisher> Prentice-Hall, Inc. </publisher> <address> New Jersey. </address>
Reference-contexts: The resulting algorithm is 1 : E 0 = R 0 for i from 1 to N : K i = i1 X a [j]R ij 1 For a derivation see <ref> [4] </ref> and [5] 4 b [i] = K i for j from 1 to i 1 b [j] = a [j] K i a [i j] E i = (1 K i K i )E i1 where a [n] are the filter parameters for the FIR inverse filter and E is <p> The parameters K n , used as intermediate values, are known as reflection coefficients or k-parameters and are the parameters for an all-zero lattice filter which is equivalent to the FIR filter with parameters a. The final square error E N can be used to find the gain <ref> [4] </ref>: Gain = p We now have the filter parameters to an all-zero (FIR) filter that has the inverse spectral shape of the input sequence u [n]. We will want to reconstruct the spectral shape of the original sequence later.
Reference: [5] <author> S. Haykin. </author> <title> Adaptive Filter Theory. </title> <publisher> Prentice Hall, Inc. </publisher> <address> New Jersey 23 </address>
Reference-contexts: fi fi fi fi fi fi fi fi fi fi fi fi a [2] . . . fi fi fi fi fi fi = fi fi fi fi fi fi R 2 . . . fi fi fi fi fi fi We note that R i = R fl i <ref> [5] </ref> and if the signal is a real sequence R i = R i . The a [i] parameters can now be found by inverting the R matrix and multiplying by the R i vector. <p> The resulting algorithm is 1 : E 0 = R 0 for i from 1 to N : K i = i1 X a [j]R ij 1 For a derivation see [4] and <ref> [5] </ref> 4 b [i] = K i for j from 1 to i 1 b [j] = a [j] K i a [i j] E i = (1 K i K i )E i1 where a [n] are the filter parameters for the FIR inverse filter and E is the square
References-found: 5

