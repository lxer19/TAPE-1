URL: http://www.cs.kuleuven.ac.be/~lucdr/filp-papers/ostvold.ps
Refering-URL: http://www.cs.kuleuven.ac.be/~lucdr/filp.html
Root-URL: 
Email: Email: bjartem@idt.ntnu.no  
Phone: Phone: +47 73 59 44 83; fax +47 73 59 44 66  
Title: On inductive synthesis of declarative programs  
Author: Bjarte M. stvold 
Address: Gltshaugen, N-7034 Trondheim, Norway  
Affiliation: Department of Computer and Information Science Norwegian University of Science and Technology  
Abstract: We consider how different kinds of and aspects of declarative programming languages | logic, functional, type system | make them suitable for use in the context of inductive synthesis of programs. Then we formulate the inductive synthesis problem for functional programs and outline an algorithm for solving it. We conclude that higher-order definitions and type systems are very useful in inductive synthesis.
Abstract-found: 1
Intro-found: 1
Reference: [ 1 ] <author> F. Bergadano, D. Gunetti. </author> <title> Inductive synthesis of logic programs and inductive logic programming. </title> <editor> In Y. Deville (ed.), </editor> <booktitle> Proceedings of the International Workshop on Logic Program Synthesis and Transformation (LOPSTR'93), Workshops in Computing Series. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The goal is to (partially) automate the construction of programs implementing (recursive) algorithms by unsound reasoning from an incomplete specification in the form of examples and general problem-independent background knowledge. Drawing on the insights of these researchers <ref> [ 8; 6; 7; 1; 2 ] </ref> we identify the following problems for such synthesis: * The induced program may have a different meaning compared with what we intended | this problem is inherent to this synthesis approach, but it is also its strength: we need not have or specify completely
Reference: [ 2 ] <author> F. Bergadano, D. Gunetti. </author> <title> Inductive logic programming: From machine learning to software engineering. The MIT Press series in logic programming. </title> <publisher> The MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: The goal is to (partially) automate the construction of programs implementing (recursive) algorithms by unsound reasoning from an incomplete specification in the form of examples and general problem-independent background knowledge. Drawing on the insights of these researchers <ref> [ 8; 6; 7; 1; 2 ] </ref> we identify the following problems for such synthesis: * The induced program may have a different meaning compared with what we intended | this problem is inherent to this synthesis approach, but it is also its strength: we need not have or specify completely <p> as target concepts should only be used when the added flexibility over function definitions is essential | predicates may be "more than we want." 2 There appears to be agreement that schemas, sometimes called templates or skeletons, are essential in inductive synthesis as they capture recurring patterns in algorithm design <ref> [ 6; 2 ] </ref> . An advantage of functional programming is that schemas can be represented as first class values using higher-order function definitions, and thus staying within the type system with the advantages discussed above.
Reference: [ 3 ] <author> R. Bird, O. de Moor. </author> <title> The algebra of programming. </title> <publisher> Prentice Hall international series in computer science. Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: xs):(tail xs) == xs -- integers 0 + n == n n + m == m + n -- programming, &lt;A&gt; means `reduces to A' if &lt;True&gt; then e1 else e2 == e1 if &lt;False&gt; then e1 else e2 == e2 indirectly through the use of recursive higher-order function definitions <ref> [ 3; 12 ] </ref> or schemas.
Reference: [ 4 ] <author> Y. Deville. </author> <title> Logic Programming: Systematic Program Development. </title> <booktitle> International Series in Logic Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Deductive reasoning techniques are well established in program synthesis and transformation <ref> [ 15; 4 ] </ref> . They are concerned with making a complete specification operational or making some initial program more efficient without changing its semantics. There has been far less interest in inductive (unsound) reasoning techniques in program synthesis; Smith surveys some early work [ 17 ] .
Reference: [ 5 ] <author> C. Dornan. </author> <title> Type-Secure Meta-Programming. </title> <type> PhD thesis, </type> <institution> University of Bristol, U.K., </institution> <year> 1997. </year> <note> In preparation. </note>
Reference-contexts: Languages with a weak type system has the advantage that efficient meta-programming is easier to provide for language implementors, but this advantage is not inherent to weakly typed languages and statically typed languages are catching up <ref> [ 9; 5 ] </ref> . Static type systems have the advantage that they allow us to reject many programs statically, i.e., without testing them.
Reference: [ 6 ] <author> P. Flener. </author> <title> Logic Program Synthesis From Incomplete Information. </title> <booktitle> The Kluwer international series in engineering and computer science. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: The goal is to (partially) automate the construction of programs implementing (recursive) algorithms by unsound reasoning from an incomplete specification in the form of examples and general problem-independent background knowledge. Drawing on the insights of these researchers <ref> [ 8; 6; 7; 1; 2 ] </ref> we identify the following problems for such synthesis: * The induced program may have a different meaning compared with what we intended | this problem is inherent to this synthesis approach, but it is also its strength: we need not have or specify completely <p> as target concepts should only be used when the added flexibility over function definitions is essential | predicates may be "more than we want." 2 There appears to be agreement that schemas, sometimes called templates or skeletons, are essential in inductive synthesis as they capture recurring patterns in algorithm design <ref> [ 6; 2 ] </ref> . An advantage of functional programming is that schemas can be represented as first class values using higher-order function definitions, and thus staying within the type system with the advantages discussed above.
Reference: [ 7 ] <author> P. Flener. </author> <title> Inductive logic program synthesis with Dialogs. </title> <editor> In S. Muggleton (ed.), </editor> <booktitle> Proceedings of the Sixth International Workshop on Inductive Logic Programming (ILP-96), </booktitle> <volume> Report no. </volume> <pages> 96-019, </pages> <institution> Department of Computer and System Sciences, Stockholm University/ Royal Institute of Technology, Sweden, </institution> <year> 1996. </year>
Reference-contexts: The goal is to (partially) automate the construction of programs implementing (recursive) algorithms by unsound reasoning from an incomplete specification in the form of examples and general problem-independent background knowledge. Drawing on the insights of these researchers <ref> [ 8; 6; 7; 1; 2 ] </ref> we identify the following problems for such synthesis: * The induced program may have a different meaning compared with what we intended | this problem is inherent to this synthesis approach, but it is also its strength: we need not have or specify completely
Reference: [ 8 ] <author> P. Flener, L. Popelnsky. </author> <title> On the use of inductive reasoning in program synthesis: </title> <editor> Prejudice and prospects. In L. Fribourg, F. Turini (eds.), </editor> <booktitle> Proceedings of the International Workshops on Logic Program Synthesis and Transformation - Meta-Programming in Logic (LOPSTR'94 and META'94), no. 883 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The goal is to (partially) automate the construction of programs implementing (recursive) algorithms by unsound reasoning from an incomplete specification in the form of examples and general problem-independent background knowledge. Drawing on the insights of these researchers <ref> [ 8; 6; 7; 1; 2 ] </ref> we identify the following problems for such synthesis: * The induced program may have a different meaning compared with what we intended | this problem is inherent to this synthesis approach, but it is also its strength: we need not have or specify completely
Reference: [ 9 ] <author> P. Hill, J. Lloyd. </author> <title> The Godel Programming Language. </title> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Languages with a weak type system has the advantage that efficient meta-programming is easier to provide for language implementors, but this advantage is not inherent to weakly typed languages and statically typed languages are catching up <ref> [ 9; 5 ] </ref> . Static type systems have the advantage that they allow us to reject many programs statically, i.e., without testing them.
Reference: [ 10 ] <author> N. D. Jones, C. K. Gomard, P. Sestoft. </author> <title> Partial Evaluation and Program Generation. </title> <publisher> Prentice Hall international series in computer science. Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: By eliminating direct recursion and having a minimal set of schemas the search space the algorithm must consider is made smaller still. 4 Once a solution is obtained a deductive synthesis techniques such as partial evaluation <ref> [ 10 ] </ref> could be used to introduce direct recursion.
Reference: [ 11 ] <author> J. R. Koza. </author> <title> Genetic Programming: On the Programming of Computers by Means of Natural Selection. </title> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: In this section we consider how different kinds of and aspects of declarative programming languages make them suitable for use in the context of inductive synthesis. In current work on inductive synthesis Prolog dominates almost completely and in the related area of genetic programming <ref> [ 11 ] </ref> LISP is the language of choice. Languages with a weak type system has the advantage that efficient meta-programming is easier to provide for language implementors, but this advantage is not inherent to weakly typed languages and statically typed languages are catching up [ 9; 5 ] .
Reference: [ 12 ] <author> E. Meijer, G. Hutton. </author> <title> Bananas in space: Extending fold and unfold to exponential types. </title> <booktitle> In Seventh ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 324-333. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Some examples are given in Fig. 2. There is a systematic way to construct powerful higher-order function definitions for particular algebraic datatypes <ref> [ 12 ] </ref> . Logic programs define relations and relations have a major advantage over functions: there is a most general relation for a domain, whereas there is no most general function for any reasonable definition of `general'. <p> xs):(tail xs) == xs -- integers 0 + n == n n + m == m + n -- programming, &lt;A&gt; means `reduces to A' if &lt;True&gt; then e1 else e2 == e1 if &lt;False&gt; then e1 else e2 == e2 indirectly through the use of recursive higher-order function definitions <ref> [ 3; 12 ] </ref> or schemas.
Reference: [ 13 ] <author> S. Muggleton. </author> <title> Inverse entailment and Progol. </title> <journal> New Generation Computing, </journal> 13(3/4):245-286, 1995. 
Reference-contexts: compose y (dac ops y') -- list append append :: [a] -&gt; [a] -&gt; [a] append xs ys = dac ( null, "_ -&gt; ys, -- lambda function "as -&gt; (head as, tail as), (:) ) xs fac :: Int -&gt; Int "_ -&gt; 1, (*) ) n mode language <ref> [ 13 ] </ref> is a step in this direction, 1 but it stops short of proving polymorphism. Definitions of logic predicates are frequently written in a way making them more flexible than definitions in functional programming, e.g., the predicate append/3 can be used "backwards" to split a list in two. <p> algorithms (top-down, bottom-up), and in addition generalisation/specialisation of logic programs can be characterised syntactically | add/delete a literal in a programs clause or apply substitution/inverse substitution to it | thus making search operators efficient and easy to implement. (More fine-grained orders of generality exist, but they require more complex operators <ref> [ 18; 13 ] </ref> .) For inductive synthesis of functional programs the lack of generality orders is a serious problem.
Reference: [ 14 ] <author> S. Muggleton, L. De Raedt. </author> <title> Inductive logic programming: Theory and methods. </title> <journal> Journal of Logic Programming, </journal> <volume> 19, 20 </volume> <pages> 629-679, </pages> <year> 1994. </year>
Reference-contexts: There has been far less interest in inductive (unsound) reasoning techniques in program synthesis; Smith surveys some early work [ 17 ] . With the recent interest in inductive logic programming (ILP) <ref> [ 14 ] </ref> machine learning researchers have investigated the use of induction in logic program synthesis. The goal is to (partially) automate the construction of programs implementing (recursive) algorithms by unsound reasoning from an incomplete specification in the form of examples and general problem-independent background knowledge.
Reference: [ 15 ] <author> H. A. Partsch. </author> <title> Specification and Transformation of Programs: A Formal Approach to Software Development. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Deductive reasoning techniques are well established in program synthesis and transformation <ref> [ 15; 4 ] </ref> . They are concerned with making a complete specification operational or making some initial program more efficient without changing its semantics. There has been far less interest in inductive (unsound) reasoning techniques in program synthesis; Smith surveys some early work [ 17 ] .
Reference: [ 16 ] <author> J. Peterson, K. Hammond (eds.). </author> <title> Report on the programming language Haskell: A non-strict, purely functional language (version 1.3). </title> <type> Technical Report YALEU/DCS/RR-1106, </type> <institution> Department of Computer Science, Yale University, </institution> <month> May 1 </month> <year> 1996. </year>
Reference-contexts: An advantage of functional programming is that schemas can be represented as first class values using higher-order function definitions, and thus staying within the type system with the advantages discussed above. Fig. 1 shows a simple divide and conquer schema written in Haskell <ref> [ 16 ] </ref> | a statically typed functional programming language | and examples of its usage.
Reference: [ 17 ] <author> D. R. Smith. </author> <title> The synthesis of LISP programs from examples: A survey. </title> <editor> In A. W. Biermann, G. Guiho, Y. Kodratoff (eds.), </editor> <title> Automatic Program Construction Techniques, ch. 15. </title> <publisher> Macmillan, </publisher> <year> 1984. </year>
Reference-contexts: They are concerned with making a complete specification operational or making some initial program more efficient without changing its semantics. There has been far less interest in inductive (unsound) reasoning techniques in program synthesis; Smith surveys some early work <ref> [ 17 ] </ref> . With the recent interest in inductive logic programming (ILP) [ 14 ] machine learning researchers have investigated the use of induction in logic program synthesis.
Reference: [ 18 ] <author> P. R. J. van der Laag. </author> <title> An Analysis of Refinement Operators in Inductive Logic Programming. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Erasmus University of Rotterdam, </institution> <address> the Netherlands, </address> <year> 1995. </year> <title> No. </title> <booktitle> 102 in Tinbergen Institute Research Series. </booktitle>
Reference-contexts: algorithms (top-down, bottom-up), and in addition generalisation/specialisation of logic programs can be characterised syntactically | add/delete a literal in a programs clause or apply substitution/inverse substitution to it | thus making search operators efficient and easy to implement. (More fine-grained orders of generality exist, but they require more complex operators <ref> [ 18; 13 ] </ref> .) For inductive synthesis of functional programs the lack of generality orders is a serious problem.
References-found: 18

