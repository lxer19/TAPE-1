URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr92/tr92-049.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr92-abstracts.html
Root-URL: http://www.cis.ufl.edu
Email: hanson@cis.ufl.edu  
Title: Rule Condition Testing and Action Execution in Ariel  
Author: Eric N. Hanson 
Web: CIS-TR-92-049  
Address: Gainesville, FL 32611  
Affiliation: Database Systems Research and Development Center Computer and Information Sciences Department University of Florida,  
Abstract: This paper describes testing of rule conditions and execution of rule actions in the Ariel active DBMS. The Ariel rule system is tightly coupled with query and update processing. Ariel rules can have conditions based on a mix of patterns, events, and transitions. For testing rule conditions, Ariel makes use of a discrimination network composed of a special data structure for testing single-relation selection conditions efficiently, and a modified version of the TREAT algorithm, called A-TREAT, for testing join conditions. The key modification to TREAT (which could also be used in the Rete algorithm) is the use of virtual ff-memory nodes which save storage since they contain only the predicate associated with the memory node instead of copies of data matching the predicate. The rule-action executor in Ariel binds the data matching a rule's condition to the action of the rule at rule fire time, and executes the rule action using the query processor. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. M. Astrahan, M. W. Blasgen, D. D. Chamberlin, K. P. Eswaran, J. N. Gray, P. P. Griffiths, W. F. King, R. A. Lorie, P. R. McJones, J. W. Mehl, G. R. Putzolu, I. L. Traiger, B. W. Wade, and V. Watson. </author> <title> System R: Relational approach to database management. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(2) </volume> <pages> 97-137, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: a comprehensive active rule language for a relational DBMS which supports a set-oriented execution style, complex rule conditions combining patterns, events, and transitions, and execution of rule actions containing multiple database commands. 3 Architectural Overview The architecture of Ariel, shown in Figure 2, is similar to that of System R <ref> [1] </ref> with additional components attached for rule processing. When commands enter Ariel they are processed by the lexer, parser, and semantic analyzer. If they are queries or data manipulation commands, they are passed to the query optimizer.
Reference: [2] <author> M. Carey, D. DeWitt, D. Frank, G. Graefe, J. Richard-son, E. Shekita, and M. Muralikrishna. </author> <title> The architecture of the EXODUS extensible DBMS. </title> <booktitle> In Proceedings of the International Workshop on Object-Oriented Database Systems, </booktitle> <month> September </month> <year> 1986. </year>
Reference-contexts: If they are queries or data manipulation commands, they are passed to the query optimizer. Execution plans produced by the optimizer are carried out by the query plan executor. The executor is built on top of the storage system provided by the EXODUS database toolkit <ref> [2, 14] </ref>. <p> Moreover, preplanning strategies are all subject to errors where they run non-optimal plans, whereas always recompute always runs the optimal plan. A thorough investigation of pre-planning strategies vs. always recompute is a potential topic for future investigation. 6 Implementation and Performance Ariel is implemented using the EXODUS toolkit <ref> [2, 14] </ref> and in particular the E programming language [15], an extension of C++ with persistent objects. The current version of Ariel consists of about 28000 lines of C++/E code. Persistent objects simplified implementation of our catalogs and the rule index.
Reference: [3] <author> S. Chakravarthy et al. HiPAC: </author> <title> A research project in active, time-constrained database management, </title> <type> Final Technical Report. Technical Report XAIT-89-02, </type> <institution> Xerox Advanced Information Technology, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: tuple (RPL [4], Starburst rule system [22]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POST-GRES rule system [19, 20, 21], HiPAC <ref> [3] </ref>, DIPS [17], Alert [16]).
Reference: [4] <author> L. M. L. Delcambre and J. N. Etheredge. </author> <title> The relational production language: A production language for relational databases. </title> <booktitle> In Proceedings of the Second International Conference on Expert Database Systems, </booktitle> <pages> pages 153-162, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Other database rule system projects either: * do not address the need for efficient data structures for finding which rules match a particular tuple (RPL <ref> [4] </ref>, Starburst rule system [22]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POST-GRES rule system [19, 20, 21], HiPAC [3], DIPS [17],
Reference: [5] <author> K. P. Eswaran. </author> <title> Specifications, implementations and interactions of a trigger subsystem in an integrated database system. </title> <type> Technical report, </type> <institution> IBM Research Laboratory, </institution> <address> San Jose, CA, </address> <year> 1976. </year>
Reference-contexts: 1 Introduction Designers of database management systems have long wanted to transform databases from passive repositories for data into active systems that can respond immediately to a change in the state of the data, an event, or a transition between states <ref> [5] </ref>.
Reference: [6] <author> C. L. Forgy. </author> <title> OPS5 user's manual. </title> <type> Technical Report CMU-CS-81-135, </type> <institution> Carnegie-Mellon University, </institution> <address> Pitts-burgh, PA 15213, </address> <month> July </month> <year> 1981. </year>
Reference-contexts: The Ariel rule system is based on the production system model [7]. Our approach has been to adopt as much as possible from previous work on main-memory production systems such as OPS5 <ref> [6] </ref>, but make changes where necessary to improve the functionality and performance of a production system in a database environment. <p> are created by an append or a replace com mand. match while (rules left to run and not halt executed) do conflict resolution act match end 2.2.3 The Rule Execution Cycle Ariel controls rule execution using the recognize-act cycle, shown in Figure 1, which is commonly used in production systems <ref> [6] </ref>. The match step finds the set of rules that are eligible to run. The conflict resolution step selects a single rule for execution from the set of eligible rules. Finally, the act step executes the statements in the rule action.
Reference: [7] <author> C. L. Forgy. </author> <title> Rete: A fast algorithm for the many pattern/many object pattern match problem. </title> <journal> Artificial Intelligence, </journal> <volume> 19 </volume> <pages> 17-37, </pages> <year> 1982. </year>
Reference-contexts: The Ariel system is an implementation of a relational DBMS with a built-in rule system which has been designed to address the above issues. The Ariel rule system is based on the production system model <ref> [7] </ref>. Our approach has been to adopt as much as possible from previous work on main-memory production systems such as OPS5 [6], but make changes where necessary to improve the functionality and performance of a production system in a database environment. <p> Execution of rules is governed by a recognize-act cycle similar to that used in OPS5 <ref> [7] </ref>. Ariel rules get an opportunity to wake up after every database transition.
Reference: [8] <author> E. N. Hanson. </author> <title> The design and implementation of the Ariel active database rule system. </title> <type> Technical Report WSU-CS-91-06, </type> <institution> Wright State University, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: Other strategies can be developed which attempt to pre-optimize plans for rule actions, store them, and retrieve them at rule fire time to avoid the cost of run-time optimization <ref> [8] </ref>. All strategies that store plans must maintain the dependencies between those plans and database objects the plans touch such as tables and indexes, which makes those strategies more complicated from the outset.
Reference: [9] <author> E. N. Hanson. </author> <title> The interval skip list: A data structure for finding all intervals that overlap a point. </title> <booktitle> In Proceedings of the 1991 Workshop on Algorithms and Data Structures. </booktitle> <publisher> Springer Verlag, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: Readers are referred to [11] for a detailed discussion of the selection condition testing network in Ariel. A data structure called the interval skip list <ref> [9] </ref> can be used as an interval index in place of the interval binary search tree discussed in [11, 10].
Reference: [10] <author> E. N. Hanson and M. Chaabouni. </author> <title> The IBS tree: A data structure for finding all intervals that overlap a point. </title> <type> Technical Report WSU-CS-90-11, </type> <institution> Wright State University, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: Readers are referred to [11] for a detailed discussion of the selection condition testing network in Ariel. A data structure called the interval skip list [9] can be used as an interval index in place of the interval binary search tree discussed in <ref> [11, 10] </ref>. The interval skip list is much easier to implement than the IBS tree and performs as well. 4.2 Saving Storage Using Virtual ff-memories Here we describe a variation of the Rete and TREAT algorithms for minimizing storage use in database rule systems.
Reference: [11] <author> E. N. Hanson, M. Chaabouni, C. Kim, and Y. Wang. </author> <title> A predicate matching algorithm for database rule systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 271-280, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: An important performance optimization in A-TREAT is the use of a special top-level discrimination network for testing single-relation selection conditions of rules <ref> [11] </ref>. In addition, we introduce a technique for reducing the amount of state information stored in the network, whereby ff-memory nodes are replaced in some cases by virtual ff-memory nodes which contain only the predicate associated with the node, not the tuples matching the predicate. <p> This index makes use of an interval index called the interval binary search tree to efficiently test conditions that specify closed intervals (e.g., constant1 &lt; relation.attribute con-stant2), open intervals (e.g., constant &lt; relation.attribute) , or points (e.g., constant = relation.attribute). Readers are referred to <ref> [11] </ref> for a detailed discussion of the selection condition testing network in Ariel. A data structure called the interval skip list [9] can be used as an interval index in place of the interval binary search tree discussed in [11, 10]. <p> Readers are referred to [11] for a detailed discussion of the selection condition testing network in Ariel. A data structure called the interval skip list [9] can be used as an interval index in place of the interval binary search tree discussed in <ref> [11, 10] </ref>. The interval skip list is much easier to implement than the IBS tree and performs as well. 4.2 Saving Storage Using Virtual ff-memories Here we describe a variation of the Rete and TREAT algorithms for minimizing storage use in database rule systems. <p> Token testing time takes 2 to 3 milliseconds in our tests, which closely matches earlier predictions <ref> [11] </ref>. This speed should scale to much larger numbers of rules (given rules of similar structure) because of Ariel's top-level discrimination network for testing selection conditions of rules [11]. <p> Token testing time takes 2 to 3 milliseconds in our tests, which closely matches earlier predictions <ref> [11] </ref>. This speed should scale to much larger numbers of rules (given rules of similar structure) because of Ariel's top-level discrimination network for testing selection conditions of rules [11]. Not shown in the figures is that it takes approximately 0.06 seconds to run the action of a type 1, 2 or 3 rule in all cases.
Reference: [12] <author> E. N. Hanson, T. Harvey, and M. Roth. </author> <title> Experiences in DBMS implementation using an object-oriented persistent programming language and a database toolkit. </title> <booktitle> In Proceedings of the 1991 ACM Conference on Object-oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 314-328, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The current version of Ariel consists of about 28000 lines of C++/E code. Persistent objects simplified implementation of our catalogs and the rule index. The object-oriented programming features of C++ simplified and streamlined our design <ref> [12] </ref>.
Reference: [13] <author> A. Rastogi. </author> <title> Transition and event condition testing and rule execution in Ariel. </title> <type> Master's thesis, </type> <institution> Dept. of Computer Science and Eng., Wright State Univ., </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: The possible sequences of operations that may occur to a single tuple during a transition are shown below <ref> [13] </ref>: * Case 1: An insertion of a tuple t followed by one or more modifications of t (im fl ). The net effect of this transition is an insertion.
Reference: [14] <author> J. E. Richardson and M. J. Carey. </author> <title> Programming constructs for database system implementation in EXODUS. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 208-219, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: If they are queries or data manipulation commands, they are passed to the query optimizer. Execution plans produced by the optimizer are carried out by the query plan executor. The executor is built on top of the storage system provided by the EXODUS database toolkit <ref> [2, 14] </ref>. <p> Moreover, preplanning strategies are all subject to errors where they run non-optimal plans, whereas always recompute always runs the optimal plan. A thorough investigation of pre-planning strategies vs. always recompute is a potential topic for future investigation. 6 Implementation and Performance Ariel is implemented using the EXODUS toolkit <ref> [2, 14] </ref> and in particular the E programming language [15], an extension of C++ with persistent objects. The current version of Ariel consists of about 28000 lines of C++/E code. Persistent objects simplified implementation of our catalogs and the rule index.
Reference: [15] <author> J. E. Richardson, M. J. Carey, and D. T. Schuh. </author> <title> The design of the E programming language. </title> <type> Technical report, </type> <institution> University of Wisconsin, </institution> <year> 1989. </year> <note> To appear, ACM TOPLAS. </note>
Reference-contexts: A thorough investigation of pre-planning strategies vs. always recompute is a potential topic for future investigation. 6 Implementation and Performance Ariel is implemented using the EXODUS toolkit [2, 14] and in particular the E programming language <ref> [15] </ref>, an extension of C++ with persistent objects. The current version of Ariel consists of about 28000 lines of C++/E code. Persistent objects simplified implementation of our catalogs and the rule index. The object-oriented programming features of C++ simplified and streamlined our design [12].
Reference: [16] <author> U. Schreier, H. Pirahesh, R. Agrawal, and C. Mo-han. Alert: </author> <title> An architecture for transforming a passive DBMS into an active DBMS. </title> <booktitle> In Proc. 17th International Conference on Very Large Data Bases, </booktitle> <address> Barcelona, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: rule system [22]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POST-GRES rule system [19, 20, 21], HiPAC [3], DIPS [17], Alert <ref> [16] </ref>).
Reference: [17] <author> T. Sellis, C.-C. Lin, and L. Raschid. </author> <title> Data intensive production systems: The DIPS approach. </title> <booktitle> SIGMOD Record, </booktitle> <pages> pages 52-58, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: [4], Starburst rule system [22]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POST-GRES rule system [19, 20, 21], HiPAC [3], DIPS <ref> [17] </ref>, Alert [16]).
Reference: [18] <author> M. Stonebraker. </author> <title> Implementation of integrity con-straints and views by query modification. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 65-78, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: In Ariel, data matching the rule condition is stored in a temporary relation called the P-node. In the act phase, the statement (s) in the then part of the rule are bound to the P-node for the rule by a process of query modification <ref> [18] </ref>. The modified syntax tree for the command is then passed to the query optimizer which generates an optimal query execution plan. The plan is then interpreted to carry out the command. <p> At the time the rule is activated, the discrimination network for the rule is constructed, and the binding between the condition and the action of the rule is made explicit through a process of query modification <ref> [18] </ref>, after which the modified definition of the rule is stored in the rule catalog. During query modification, references to tuple variables shared between the rule condition and the rule action are transformed into explicit references to the P-node.
Reference: [19] <author> M. Stonebraker, E. Hanson, and S. Potamianos. </author> <title> The POSTGRES rule manager. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(7) </volume> <pages> 897-907, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: We extended POSTQUEL with a production-rule language called the Ariel Rule Language (ARL) to be discussed next. ARL is not related to the POSTGRES rule language <ref> [19, 20] </ref>. 2.1 Rule Language ARL is a production-rule language with enhancements for defining rules with conditions based not only on patterns, but also on events and transitions. The ARL syntax is based on the syntax of the query language. <p> rules match a particular tuple (RPL [4], Starburst rule system [22]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POST-GRES rule system <ref> [19, 20, 21] </ref>, HiPAC [3], DIPS [17], Alert [16]).
Reference: [20] <author> M. Stonebraker, M. Hearst, and S. Potaminos. </author> <title> A commentary on the POSTGRES rules system. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 18(3) </volume> <pages> 5-11, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: We extended POSTQUEL with a production-rule language called the Ariel Rule Language (ARL) to be discussed next. ARL is not related to the POSTGRES rule language <ref> [19, 20] </ref>. 2.1 Rule Language ARL is a production-rule language with enhancements for defining rules with conditions based not only on patterns, but also on events and transitions. The ARL syntax is based on the syntax of the query language. <p> rules match a particular tuple (RPL [4], Starburst rule system [22]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POST-GRES rule system <ref> [19, 20, 21] </ref>, HiPAC [3], DIPS [17], Alert [16]).
Reference: [21] <author> M. Stonebraker, L. Rowe, and M. Hirohama. </author> <title> The implementation of POSTGRES. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(7) </volume> <pages> 125-142, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: 8 summarizes and presents conclusions. 2 The Ariel Query and Rule Languages To simplify and narrow the scope of the Ariel project, we chose to support the relational data model and provide a subset of the POSTQUEL query language of POSTGRES for specifying data definition commands, queries and updates 1 <ref> [21] </ref>. POSTQUEL query and update commands retrieve, append, delete, and replace, are supported, along with commands for creating and destroying relations, and performing other utility functions. We extended POSTQUEL with a production-rule language called the Ariel Rule Language (ARL) to be discussed next. <p> rules match a particular tuple (RPL [4], Starburst rule system [22]), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POST-GRES rule system <ref> [19, 20, 21] </ref>, HiPAC [3], DIPS [17], Alert [16]).
Reference: [22] <author> J. Widom, R. J. Cochrane, and B. G. Lindsay. </author> <title> Implementing set-oriented production rules as an extension to Starburst. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Data Bases, </booktitle> <year> 1991. </year>
Reference-contexts: Other database rule system projects either: * do not address the need for efficient data structures for finding which rules match a particular tuple (RPL [4], Starburst rule system <ref> [22] </ref>), * do not provide a data structure for testing selection conditions, or * provide a data structure for testing selection conditions which cannot efficiently handle conditions placed on an arbitrary attribute (e.g., one without an index) (POST-GRES rule system [19, 20, 21], HiPAC [3], DIPS [17], Alert [16]).
References-found: 22

