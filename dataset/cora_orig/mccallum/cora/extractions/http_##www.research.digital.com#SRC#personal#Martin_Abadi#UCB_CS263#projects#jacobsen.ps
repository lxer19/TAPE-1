URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/UCB_CS263/projects/jacobsen.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/UCB_CS263/projects.html
Root-URL: http://www.research.digital.com
Email: jacobsen@icsi.berkeley.edu  
Title: Object oriented distributed computing infrastructures and programming language interoperability  
Author: Hans Arno Jacobsen 
Date: May 16, 1997  
Address: 1947 Center Street, Suit 600 Berkeley, CA 94703  
Affiliation: International Computer Science Institute  
Abstract: Achieving transparency and interoperability across distributed, heterogeneous computing environments is a major goal of several distributed computing frameworks, developed over the past five to seven years. This goes hand in hand with the question of how to provide an architectural framework that integrates different programming languages and paradigms for building distributed systems. This work presents an overview of common object oriented distributed computing infrastructures which address these problems. We motivate key concepts of the individual approaches and pin point their differences. Our main focus is on how the individual approaches achieve programming language interoperability. We present a detailed study that shows how to integrate the Sather object oriented programming language into one of the more common infrastructures. This manifests itself in the second part of our work which presents the IDL-to-Sather language mapping, developed. 
Abstract-found: 1
Intro-found: 1
Reference: [BJ97] <author> M. Spreitzer B. Janssen. </author> <title> Ilu reference manual. </title> <type> Technical report, </type> <note> Xerox Parc, </note> <year> 1997. </year>
Reference-contexts: In this paper we will take a comparative look at the following approaches: * The Common Object Request Broker Architecture (CORBA), specified by the Object Manage ment Group (OMG) [Gro95a] in 1989 and constantly refined up to the present day. * The Inter Language Unification (ILU) <ref> [BJ97] </ref> designed at Xerox Parc. * OLE/COM, Microsoft's proprietary solution to distributed component computing (recently renamed to ActiveX). * A programming language-based approache We will look at how these approaches are leveraging the boundaries of heterogeneous platforms, different operating systems and programming languages in order to solve the problem of system <p> Furthermore, it provides mechanisms for building distributed systems out of individual software components written in different programming languages. It is a specification as well as an implementation, freely available from Xerox Parc. ILU is described as an multi-language object interface system by its designers <ref> [BJ97] </ref>.
Reference: [Bro96] <author> K. Brockschmidt. </author> <title> Inside OLE. </title> <publisher> Microsoft Press, </publisher> <year> 1996. </year>
Reference-contexts: It is difficult to find a well rounded description and architectural overview of OLE/COM. We give, therefore, a very top-level description of the key concepts. We dtew our knowledge from <ref> [Bro96] </ref>. OLE was initially geared towards providing support for compound documents. Its initial name, Object Linking and Embedding, still reminds of that. By 1991 an object model for OLE, named COM (Component Object Model) was added. <p> OLE/COM, as it is currently available, does not offer support for building distributed systems. This is a considerable weakness, as compared to the 'competing' approaches. Language interoperability is achieved through the binary standard, strongly based on C++. The OLE/COM description <ref> [Bro96] </ref> allows interoperability with any language that allows for double pointer indirection. This seems to be a severe restriction, since most commercially accepted languages, besides C/C++, do not. 3 So far OLE/COM is only available for Microsoft Window and NT.
Reference: [Cha96] <author> D. Chappell. </author> <title> Dce and objects. </title> <type> Technical report, </type> <institution> (unknow), </institution> <year> 1996. </year>
Reference-contexts: The focus, there, however, is more on interoperability on the platform level and not so much on the programming languages level. Extensions have been deployed to introduce object oriented features into DCE, resulting in OODCE <ref> [Cha96] </ref>. Many 'special purpose solutions' for integrating diverse applications based on the object oriented paradigm have been proposed by independent companies over the last few years, for example, Open-Doc by CI-Labs/Apple, OpenStep by NeXT and Taligent by Taligent.
Reference: [Gro95a] <author> Object Management Group. </author> <title> The common object request broker architecture and specification. revision 2.0. </title> <type> Technical report, OMG, </type> <year> 1995. </year>
Reference-contexts: In this paper we will take a comparative look at the following approaches: * The Common Object Request Broker Architecture (CORBA), specified by the Object Manage ment Group (OMG) <ref> [Gro95a] </ref> in 1989 and constantly refined up to the present day. * The Inter Language Unification (ILU) [BJ97] designed at Xerox Parc. * OLE/COM, Microsoft's proprietary solution to distributed component computing (recently renamed to ActiveX). * A programming language-based approache We will look at how these approaches are leveraging the boundaries <p> Finally, we describe an alternate way to obtain programming language interoperability. The approach is based on programming language support, as offered by the Sather object oriented language. 2.1 The Object Management Architecture and CORBA The Common Object Request Broker Architecture specification, CORBA 2.0, <ref> [Gro95a] </ref> is an emerging standard for heterogeneous distributed object computing proposed by the Object Management Group 3 (OMG). CORBA is part of a larger architectural framework the Object Management Architecture (OMA) for distributed object computing at large. The OMA specification [Gro95a] was initially defined by the OMG in the fall of <p> CORBA The Common Object Request Broker Architecture specification, CORBA 2.0, <ref> [Gro95a] </ref> is an emerging standard for heterogeneous distributed object computing proposed by the Object Management Group 3 (OMG). CORBA is part of a larger architectural framework the Object Management Architecture (OMA) for distributed object computing at large. The OMA specification [Gro95a] was initially defined by the OMG in the fall of 1989 and revised in 1992. <p> Interface Repository ORB-Core Stubs Object implementation ORB Inter face Object Adapter DSI IDL Skeleton stub and skeleton interfaces standardized IDL-Interface Client Implement. Repository non-standardized, implementation specific Mappings of IDL to C, C++, SmallTalk and Ada have been defined <ref> [Gro95a] </ref>. Mappings for other languages are in preparation. In this work we will develop an IDL-to-Sather mapping, presented in great detail in section 4. It is important to understand that the language mapping is the actual interface to CORBA a programmer will see. <p> This is of course awkward, error prune and not recommended. Section 4.2 presents the IDL-to-Sather language mapping. The mapping follows the guidelines put forth by the OMG for language mappings <ref> [Gro95a] </ref> in general. We will motivate the IDL construct considered, but will not explain them at large. The nect section will give a brief overview of IDL. For more details refer to [Gro95a]. 4.1 The Interface Definition Language OMG IDL is a descriptive, non-algorithmic interface definition language with object oriented features <p> The mapping follows the guidelines put forth by the OMG for language mappings <ref> [Gro95a] </ref> in general. We will motivate the IDL construct considered, but will not explain them at large. The nect section will give a brief overview of IDL. For more details refer to [Gro95a]. 4.1 The Interface Definition Language OMG IDL is a descriptive, non-algorithmic interface definition language with object oriented features and support for distributed computing. It is very C++-like. It is used to describe interfaces of CORBA objects. Figure 4 gives a brief abstract overview of IDL. <p> An OMG IDL exception type refers to an OMG IDL exception definition. An OMG IDL template type is one of sequence&lt;T&gt;, string or array&lt;T&gt;. If not further specified, strings and sequences may either refer to bounded or unbounded template types, arrays are always of fixed size <ref> [Gro95a] </ref>. An OMG IDL basic type is one of short, long, double, ushort, ulong, boolean, or octet. We refer to identifiers in an OMG IDL definition as of being in global scope if the identifier appears outside any module and interface. <p> Respectively for identifiers used inside modules and interfaces, as 12 of being in module-scope and interface-scope. The IDL-to-Sather mapping is described by an intuitive formalism. Our goal is to precisely capture the mapping but not to overwhelm the reader with formality. The OMG <ref> [Gro95a] </ref> language mappings are all based on a more 'prosaic' description of the mapping enhanced with examples to illustrate the principal ideas. We think a more formal approach to illustrate the mapping is more helpful in generalizing the mapping and for reasoning about it. <p> Note, this will not cause name clashes of OMG IDL identifiers since OMG IDL identifiers are case insensitive. Furthermore, there is only one namespace for OMG IDL identifires so that using the same name for a constant and an interface produces compilation errors <ref> [Gro95a] </ref>. All other OMG IDL identifiers are mapped verbatim to Sather identifiers, according to the rules laid out below. <p> The scoping rules described above have to be used to 'mimic' the notion of a module. Modules are used in IDL to introduce namespace <ref> [Gro95a] </ref>, no other functionality is associated with them. 4.8 Ambiguities in Mapping The following ambiguities may arise for the defined mapping: //IDL struct bar_foo -...- -- Sather class BAR_FOO is ... 17 // IDL interface bar -struct foo-...-- -- Sather class BAR_FOO is ... //IDL -- Sather keyword interface PROTECT -- <p> An example has already been given in the section on scoping. OMG IDL allows for basic operations (+; ;...) to be specified in the constant declarations. These operations are evaluated statically by the IDL-to-Sather compiler according to the rules specified for these operations in <ref> [Gro95a] </ref>. 4.15 Mapping for basic data types All OMG IDL basic data types are mapped to Sather classes implementing the specified behavior. To present a coherent framework all OMG IDL basic types are named CORBA &lt;basic type&gt;. These types can be converted internally to other 'similar' Sather types, i.e. <p> A selector determines which kind of value is actually stored in the union. The union construct is motivated as a space saving type <ref> [Gro95a] </ref>. //IDL union &lt;identifier&gt; switch &lt;tag type&gt; case &lt;value of type 'tag type'&gt; : &lt;type 1&gt; &lt;identifier 1&gt;; case &lt;value of type 'tag type'&gt; : &lt;type 2&gt; &lt;identifier 2&gt;; default : &lt;type 3&gt; &lt;identifier 3&gt;; -; The tag type must be one of integer, char, boolean, or enum. - Sather class <p> Furthermore it must be possible to query the length of a sequence, as well. as its maximum capacity. IDL contains strings as separate types due the often available language support and their more efficient implementation <ref> [Gro95a] </ref> Strings also come in bound as well as unbound form. Moreover, IDL defines arrays, possibly multidimensional. <p> It is the part of the OMG CORBA specification least worked out <ref> [Gro95a] </ref>. Many decisions are left to the CORBA implementor. As a consequence smooth portability of object implementations can not be expected. The OMG promises a more elaborate standard in future revisions [Gro95a]. <p> It is the part of the OMG CORBA specification least worked out <ref> [Gro95a] </ref>. Many decisions are left to the CORBA implementor. As a consequence smooth portability of object implementations can not be expected. The OMG promises a more elaborate standard in future revisions [Gro95a]. To define an implementation in Sather, one must provide a concrete class which implements the behavior specified in the IDL interface. I.e. an implementation for the Sather interface class. Several different design patterns can be used to relate the Sather interface class with its implementation. <p> The operation 'boa' returns a reference to the basic object adaptor. 'Self' is per default available in Sather. 'boa' is realized as part of the common code included in every class. We complete this section by briefly discussing the two design patterns proposed in <ref> [Gro95a] </ref> for object implementations. They are implementation by inheritance, i.e. a concrete class is derived from the Sather interface class, and implementation by delegation, i.e. the Sather interface class is passed as parameter to a parametrized class and implemented therein. These are merely suggestions, other approaches are certainly possible.
Reference: [Gro95b] <author> Object Management Group. </author> <title> The corba common object service specification. </title> <type> Technical report, OMG, </type> <year> 1995. </year>
Reference-contexts: These services include naming service, transaction service, persistence service and trader service among others <ref> [Gro95b] </ref>. The Common Facilities are intended as application-level services. They may include services such as GUI components and editing facilities. This part of the architecture is still in the Request-For-Information-phase of the standardization process. The domain applications are user defined objects.
Reference: [OSF96] <author> OSF. </author> <title> Distributed computing environment. </title> <type> Technical report, </type> <institution> Open Software Foundation, </institution> <year> 1996. </year>
Reference-contexts: The Telecommunications Information Networking Architecture Consortium (TINA-C) provides its own solution, including a proper object definition language, ODL-95 [TC93]. Their primary focus is on interoperation between different networks. The Distributed Computing Environment (DCE), proposed by the OSF <ref> [OSF96] </ref> is an earlier approach to achieving interoperability in distributed environments. The focus, there, however, is more on interoperability on the platform level and not so much on the programming languages level. Extensions have been deployed to introduce object oriented features into DCE, resulting in OODCE [Cha96].
Reference: [SO96] <author> D. P. Stoutamire and Stephen M. Omohundro. </author> <title> The sather 1.1. specification. </title> <type> Technical report, ICSI, </type> <year> 1996. </year>
Reference: [TC93] <author> TINA-C. </author> <title> Dpe phase 0.1 specification. </title> <type> Technical report, </type> <institution> Telecommunication Information Networking Architecture Consortium, </institution> <month> Dezember </month> <year> 1993. </year> <month> 34 </month>
Reference-contexts: The above selection of systems was mainly due to their object oriented nature and apparent popularity. The Telecommunications Information Networking Architecture Consortium (TINA-C) provides its own solution, including a proper object definition language, ODL-95 <ref> [TC93] </ref>. Their primary focus is on interoperation between different networks. The Distributed Computing Environment (DCE), proposed by the OSF [OSF96] is an earlier approach to achieving interoperability in distributed environments.
References-found: 8

