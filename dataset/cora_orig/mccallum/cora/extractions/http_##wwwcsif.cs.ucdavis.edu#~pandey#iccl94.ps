URL: http://wwwcsif.cs.ucdavis.edu/~pandey/iccl94.ps
Refering-URL: http://www.cs.ucdavis.edu/~pandey/cyes.html
Root-URL: http://www.cs.ucdavis.edu
Email: fraju, browneg@cs.utexas.edu  
Title: A Compositional Approach to Concurrent Object-Oriented Programming  
Author: Raju Pandey J. C. Browne 
Address: Austin, TX 78712  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: This paper presents a model of concurrent object-oriented programming in which specification of computational behavior is separated from specification of interaction behavior of methods. It will be shown that this compositional approach to concurrent programming avoids some of the conceptual difficulties that have plagued the integration of concurrency and object-oriented models of programs. The compositional approach to concurrent object-oriented programming leads to declarative and incremental specification of interaction behavior and thus, to object/method definitions that can be readily adapted to different parallel execution environments. The approach supports inheritance of both method and synchronization specifications. It will be shown that compositional programming avoids the so-called inheritance anomaly. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Gul A Agha. </author> <title> ACTORS: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1986. </year>
Reference-contexts: such as CSP [13]; iii) approaches based on abstract data types (ADT) such as Monitors [12], ADT with path expressions [5], and SR [3]; iv) approaches based on sequential objects such as POOL-T [2], ABCL/1 [28], Concurrent SmallTalk [27], CC++ [6], Mentat [11], and Charm++ [15]; and v) actor-based approaches <ref> [1] </ref>. The languages differ in their support for internal and external con-currency and interaction, and inheritance. We first look at languages for their support of concur-rency within objects.
Reference: [2] <author> Pierre America. POOL-T: </author> <title> A Parallel Object-Oriented Lan--guage. </title> <editor> In A. Yonezawa and M. Tokoro, editors, </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pages 199-220. </pages> <publisher> The MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: server-based approaches such as Rendezvous-based languages ADA [9] and RPC-based languages; ii) approaches based on message passing such as CSP [13]; iii) approaches based on abstract data types (ADT) such as Monitors [12], ADT with path expressions [5], and SR [3]; iv) approaches based on sequential objects such as POOL-T <ref> [2] </ref>, ABCL/1 [28], Concurrent SmallTalk [27], CC++ [6], Mentat [11], and Charm++ [15]; and v) actor-based approaches [1]. The languages differ in their support for internal and external con-currency and interaction, and inheritance. We first look at languages for their support of concur-rency within objects. <p> The languages differ in their support for internal and external con-currency and interaction, and inheritance. We first look at languages for their support of concur-rency within objects. Languages such as Monitor [12], POOL-T <ref> [2] </ref>, ABCL/1 [28], and Concurrent Smalltalk [27] support only a single thread of execution within an object; concurrent invocations of methods are always serialized and scheduled for execution according to the policies of the implementation. Such language-imposed serializations define semantic dependencies among method invocations where there should be none. <p> The first, called interface control mechanism, is used to select a set of method requests from among concurrent requests for execution. It can be done either explicitly by executing a select statement, as in languages such as ADA [9], Mediator [10], and POOL-T <ref> [2] </ref>, or implicitly through interface control conditions [19, 17] which must be true (or false [8]) before a method can be executed. The second set of synchro nization mechanisms is used to specify interactions among method invocations that satisfy their respective interface control conditions and are executing concurrently.
Reference: [3] <author> G. R. Andrews. </author> <title> Synchronizing Resources. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 3(4) </volume> <pages> 405-430, </pages> <year> 1981. </year>
Reference-contexts: It is evident in i) server-based approaches such as Rendezvous-based languages ADA [9] and RPC-based languages; ii) approaches based on message passing such as CSP [13]; iii) approaches based on abstract data types (ADT) such as Monitors [12], ADT with path expressions [5], and SR <ref> [3] </ref>; iv) approaches based on sequential objects such as POOL-T [2], ABCL/1 [28], Concurrent SmallTalk [27], CC++ [6], Mentat [11], and Charm++ [15]; and v) actor-based approaches [1]. The languages differ in their support for internal and external con-currency and interaction, and inheritance.
Reference: [4] <author> J. P. Bahsoun and L. Feraud. </author> <title> A Model for Design Reusable Parallel Software Components. </title> <booktitle> In Parallel Architecture and Languages Europe, </booktitle> <volume> LNCS 605, </volume> <pages> pages 245-260. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We use event ordering constraint expressions to specify both interface control and interactions during executions. The problem of inheritance anomaly has been studied in great detail and many solutions <ref> [14, 24, 4, 22, 21, 19, 23, 18] </ref> have been proposed. Most of these solutions support inheritance of method implementations by separating the interface control conditions from method implementations, and by excluding any synchronization operations from the method implementations. <p> However, their inclusion violates the basis of resolution of the inheritance anomaly, namely, the separation of computational and interaction behaviors. In addition to the inheritance of method implementations, inheritance of interaction behavior specifications have also been explored in many languages. PCM <ref> [4] </ref> identifies two kinds of synchronization expressions of an object: the first, called concurrency constraints, do not depend on the state of the object, whereas the second, called state constraints, do. Concurrency constraints are defined separately in abstract classes, whereas state constraints are defined in classes.
Reference: [5] <author> R. H. Campbell and A. N. Habermann. </author> <title> The Specification of Process Synchronization by Path Expressions. </title> <booktitle> In Lecture Notes on Computer Sciences, </booktitle> <volume> volume 16, </volume> <pages> pages 89-102. </pages> <publisher> Springer Verlag, </publisher> <year> 1974. </year>
Reference-contexts: It is evident in i) server-based approaches such as Rendezvous-based languages ADA [9] and RPC-based languages; ii) approaches based on message passing such as CSP [13]; iii) approaches based on abstract data types (ADT) such as Monitors [12], ADT with path expressions <ref> [5] </ref>, and SR [3]; iv) approaches based on sequential objects such as POOL-T [2], ABCL/1 [28], Concurrent SmallTalk [27], CC++ [6], Mentat [11], and Charm++ [15]; and v) actor-based approaches [1]. The languages differ in their support for internal and external con-currency and interaction, and inheritance. <p> In this framework, certain method invocations may be concurrent at the program model level, while their executions may be serialized at the execution model level. Languages such as Path Expression <ref> [5] </ref>, CC++ [6], PO [7], and Mediator [10] also support concurrent method invocations within objects. Two kinds of synchronization mechanisms are used for specifying interaction behavior of methods. The first, called interface control mechanism, is used to select a set of method requests from among concurrent requests for execution.
Reference: [6] <author> K. Mani Chandy and Carl Kesselman. </author> <title> Compositional C++: Compositional Parallel Programming. </title> <type> Technical Report Caltech-CS-TR-92-13, Cal Tech, </type> <year> 1992. </year>
Reference-contexts: [9] and RPC-based languages; ii) approaches based on message passing such as CSP [13]; iii) approaches based on abstract data types (ADT) such as Monitors [12], ADT with path expressions [5], and SR [3]; iv) approaches based on sequential objects such as POOL-T [2], ABCL/1 [28], Concurrent SmallTalk [27], CC++ <ref> [6] </ref>, Mentat [11], and Charm++ [15]; and v) actor-based approaches [1]. The languages differ in their support for internal and external con-currency and interaction, and inheritance. We first look at languages for their support of concur-rency within objects. <p> In this framework, certain method invocations may be concurrent at the program model level, while their executions may be serialized at the execution model level. Languages such as Path Expression [5], CC++ <ref> [6] </ref>, PO [7], and Mediator [10] also support concurrent method invocations within objects. Two kinds of synchronization mechanisms are used for specifying interaction behavior of methods. The first, called interface control mechanism, is used to select a set of method requests from among concurrent requests for execution. <p> The second set of synchro nization mechanisms is used to specify interactions among method invocations that satisfy their respective interface control conditions and are executing concurrently. Examples of synchronization mechanisms are semaphores and locks, write-once-read-many shared variables <ref> [6] </ref>, data flow based data dependencies [11], and signal variables [12]. We use event ordering constraint expressions to specify both interface control and interactions during executions.
Reference: [7] <author> Antonio Corradi and Letizia Leonardi. </author> <title> An Object Model to Express Parallelism. </title> <booktitle> In Workshop on Object-based Concurrent Programming, ACM SIGPLAN Notices V. </booktitle> <volume> 24, No. 4, </volume> <pages> pages 152-155. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: In this framework, certain method invocations may be concurrent at the program model level, while their executions may be serialized at the execution model level. Languages such as Path Expression [5], CC++ [6], PO <ref> [7] </ref>, and Mediator [10] also support concurrent method invocations within objects. Two kinds of synchronization mechanisms are used for specifying interaction behavior of methods. The first, called interface control mechanism, is used to select a set of method requests from among concurrent requests for execution.
Reference: [8] <author> Svend Frolund. </author> <title> Inheritance of Synchronization Constraints in Concurrent Object-Oriented Programming Languages. </title> <booktitle> In ECOOP '92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 185-196. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: It can be done either explicitly by executing a select statement, as in languages such as ADA [9], Mediator [10], and POOL-T [2], or implicitly through interface control conditions [19, 17] which must be true (or false <ref> [8] </ref>) before a method can be executed. The second set of synchro nization mechanisms is used to specify interactions among method invocations that satisfy their respective interface control conditions and are executing concurrently. <p> A concurrent class is constructed by composing a set of behavior classes and free classes. Synchronizing Action [19] and PLOOC [23] also define and inherit interaction and computational behaviors separately. In <ref> [8] </ref>, interface control conditions are represented in a manner such that subclasses extend the interface control conditions of their methods by imposing additional interface control conditions. This is similar to our approach in that classes contain more general interaction constraints.
Reference: [9] <author> Narain H Gehani. </author> <title> Ada: Concurrent Programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1984. </year>
Reference-contexts: It is evident in i) server-based approaches such as Rendezvous-based languages ADA <ref> [9] </ref> and RPC-based languages; ii) approaches based on message passing such as CSP [13]; iii) approaches based on abstract data types (ADT) such as Monitors [12], ADT with path expressions [5], and SR [3]; iv) approaches based on sequential objects such as POOL-T [2], ABCL/1 [28], Concurrent SmallTalk [27], CC++ [6], <p> The first, called interface control mechanism, is used to select a set of method requests from among concurrent requests for execution. It can be done either explicitly by executing a select statement, as in languages such as ADA <ref> [9] </ref>, Mediator [10], and POOL-T [2], or implicitly through interface control conditions [19, 17] which must be true (or false [8]) before a method can be executed.
Reference: [10] <author> J. E. Grass and R. H. Campbell. Mediators: </author> <title> A Synchronization Mechanism. </title> <booktitle> In Sixth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 468-477, </pages> <year> 1986. </year>
Reference-contexts: The execution environment determines the manner in which method invocations are accepted and scheduled for execution. It can either be defined explicitly as in Mediators <ref> [10] </ref>, or be determined implicitly from the nature of synchronization specification mechanisms as well as the mechanisms used for the implementation of objects. In our object model, the execution environment associated with an object is derived implicitly from the composition of the object. <p> In this framework, certain method invocations may be concurrent at the program model level, while their executions may be serialized at the execution model level. Languages such as Path Expression [5], CC++ [6], PO [7], and Mediator <ref> [10] </ref> also support concurrent method invocations within objects. Two kinds of synchronization mechanisms are used for specifying interaction behavior of methods. The first, called interface control mechanism, is used to select a set of method requests from among concurrent requests for execution. <p> The first, called interface control mechanism, is used to select a set of method requests from among concurrent requests for execution. It can be done either explicitly by executing a select statement, as in languages such as ADA [9], Mediator <ref> [10] </ref>, and POOL-T [2], or implicitly through interface control conditions [19, 17] which must be true (or false [8]) before a method can be executed.
Reference: [11] <author> Andrew S. Grimshaw. </author> <title> Easy-to-Use Object-Oriented Parallel Processing with Mentat. </title> <journal> IEEE Computer, </journal> <volume> 26(6) </volume> <pages> 39-51, </pages> <year> 1993. </year>
Reference-contexts: RPC-based languages; ii) approaches based on message passing such as CSP [13]; iii) approaches based on abstract data types (ADT) such as Monitors [12], ADT with path expressions [5], and SR [3]; iv) approaches based on sequential objects such as POOL-T [2], ABCL/1 [28], Concurrent SmallTalk [27], CC++ [6], Mentat <ref> [11] </ref>, and Charm++ [15]; and v) actor-based approaches [1]. The languages differ in their support for internal and external con-currency and interaction, and inheritance. We first look at languages for their support of concur-rency within objects. <p> The second set of synchro nization mechanisms is used to specify interactions among method invocations that satisfy their respective interface control conditions and are executing concurrently. Examples of synchronization mechanisms are semaphores and locks, write-once-read-many shared variables [6], data flow based data dependencies <ref> [11] </ref>, and signal variables [12]. We use event ordering constraint expressions to specify both interface control and interactions during executions. The problem of inheritance anomaly has been studied in great detail and many solutions [14, 24, 4, 22, 21, 19, 23, 18] have been proposed.
Reference: [12] <author> C. A. R. Hoare. </author> <title> Monitor: An Operating System Structuring Concept. </title> <journal> Communication of the ACM, </journal> <volume> 17(10) </volume> <pages> 549-557, </pages> <year> 1974. </year>
Reference-contexts: It is evident in i) server-based approaches such as Rendezvous-based languages ADA [9] and RPC-based languages; ii) approaches based on message passing such as CSP [13]; iii) approaches based on abstract data types (ADT) such as Monitors <ref> [12] </ref>, ADT with path expressions [5], and SR [3]; iv) approaches based on sequential objects such as POOL-T [2], ABCL/1 [28], Concurrent SmallTalk [27], CC++ [6], Mentat [11], and Charm++ [15]; and v) actor-based approaches [1]. <p> The languages differ in their support for internal and external con-currency and interaction, and inheritance. We first look at languages for their support of concur-rency within objects. Languages such as Monitor <ref> [12] </ref>, POOL-T [2], ABCL/1 [28], and Concurrent Smalltalk [27] support only a single thread of execution within an object; concurrent invocations of methods are always serialized and scheduled for execution according to the policies of the implementation. <p> The second set of synchro nization mechanisms is used to specify interactions among method invocations that satisfy their respective interface control conditions and are executing concurrently. Examples of synchronization mechanisms are semaphores and locks, write-once-read-many shared variables [6], data flow based data dependencies [11], and signal variables <ref> [12] </ref>. We use event ordering constraint expressions to specify both interface control and interactions during executions. The problem of inheritance anomaly has been studied in great detail and many solutions [14, 24, 4, 22, 21, 19, 23, 18] have been proposed.
Reference: [13] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <journal> CACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: It is evident in i) server-based approaches such as Rendezvous-based languages ADA [9] and RPC-based languages; ii) approaches based on message passing such as CSP <ref> [13] </ref>; iii) approaches based on abstract data types (ADT) such as Monitors [12], ADT with path expressions [5], and SR [3]; iv) approaches based on sequential objects such as POOL-T [2], ABCL/1 [28], Concurrent SmallTalk [27], CC++ [6], Mentat [11], and Charm++ [15]; and v) actor-based approaches [1].
Reference: [14] <author> Dennis Kafura and Keung Lee. </author> <title> Inheritance in Actor based Concurrent Object-Oriented Languages. </title> <booktitle> In Proceedings ECOOP'89, </booktitle> <pages> pages 131-145. </pages> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: We use event ordering constraint expressions to specify both interface control and interactions during executions. The problem of inheritance anomaly has been studied in great detail and many solutions <ref> [14, 24, 4, 22, 21, 19, 23, 18] </ref> have been proposed. Most of these solutions support inheritance of method implementations by separating the interface control conditions from method implementations, and by excluding any synchronization operations from the method implementations.
Reference: [15] <author> L.V. Kale and Sanjeev Krishnan. CHARM++: </author> <title> A Portable Concurrent Object-Oriented System Based on C++. </title> <booktitle> In OOPSLA '93, </booktitle> <pages> pages 91-108. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: approaches based on message passing such as CSP [13]; iii) approaches based on abstract data types (ADT) such as Monitors [12], ADT with path expressions [5], and SR [3]; iv) approaches based on sequential objects such as POOL-T [2], ABCL/1 [28], Concurrent SmallTalk [27], CC++ [6], Mentat [11], and Charm++ <ref> [15] </ref>; and v) actor-based approaches [1]. The languages differ in their support for internal and external con-currency and interaction, and inheritance. We first look at languages for their support of concur-rency within objects.
Reference: [16] <author> Satoshi Matsuoka and Akinori Yonezawa. </author> <title> Analysis of Inheritance Anomaly in Object-Oriented Concurrent Programming Languages. </title> <booktitle> In Research Directions in Object-Based Concurrency. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, </address> <year> 1993. </year>
Reference-contexts: It does not appear, however, that there has been a fully consistent and coherent integration of the two. An example of the difficulty is the problem arising out of the interplay between inheritance and interaction among concurrent methods, the so-called inheritance anomaly <ref> [16] </ref>. An opinion [29] has been expressed that the inheritance anomaly is very difficult. Indeed, many concurrent object-oriented programming languages either limit the support for inheritance or do not support inheritance at all. <p> In concurrent object-oriented programming languages, there is a problem with the inheritance of method implementations. This problem, termed the inheritance anomaly <ref> [16] </ref>, arises due to the diverse synchronization requirements of a class and its subclasses. We clarify the problem through the following example: Assume that methods m j and m k are defined in a class C m .
Reference: [17] <author> Ciaran McHale, Bridget Walsh, Sean Baker, and Alexis Donnelly. </author> <title> Scheduling Predicates. </title> <booktitle> In Object-Based Concurrent Computing Workshop, ECOOP'91, </booktitle> <volume> LNCS 612, </volume> <pages> pages 177-193. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: It can be done either explicitly by executing a select statement, as in languages such as ADA [9], Mediator [10], and POOL-T [2], or implicitly through interface control conditions <ref> [19, 17] </ref> which must be true (or false [8]) before a method can be executed. The second set of synchro nization mechanisms is used to specify interactions among method invocations that satisfy their respective interface control conditions and are executing concurrently.
Reference: [18] <author> Jose Meseguer. </author> <title> Solving the Inheritance Anomaly in Concurrent Object-Oriented Programming. </title> <booktitle> In Proc. 7th ECOOP'93. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: We use event ordering constraint expressions to specify both interface control and interactions during executions. The problem of inheritance anomaly has been studied in great detail and many solutions <ref> [14, 24, 4, 22, 21, 19, 23, 18] </ref> have been proposed. Most of these solutions support inheritance of method implementations by separating the interface control conditions from method implementations, and by excluding any synchronization operations from the method implementations.
Reference: [19] <author> Christian Neusius. </author> <title> Synchronizing Actions. </title> <booktitle> In ECOOP '91, </booktitle> <pages> pages 118-132. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: It can be done either explicitly by executing a select statement, as in languages such as ADA [9], Mediator [10], and POOL-T [2], or implicitly through interface control conditions <ref> [19, 17] </ref> which must be true (or false [8]) before a method can be executed. The second set of synchro nization mechanisms is used to specify interactions among method invocations that satisfy their respective interface control conditions and are executing concurrently. <p> We use event ordering constraint expressions to specify both interface control and interactions during executions. The problem of inheritance anomaly has been studied in great detail and many solutions <ref> [14, 24, 4, 22, 21, 19, 23, 18] </ref> have been proposed. Most of these solutions support inheritance of method implementations by separating the interface control conditions from method implementations, and by excluding any synchronization operations from the method implementations. <p> The computational behavior of objects are defined in classes, called free classes (methods here are concurrent by default, as they are in our model). A concurrent class is constructed by composing a set of behavior classes and free classes. Synchronizing Action <ref> [19] </ref> and PLOOC [23] also define and inherit interaction and computational behaviors separately. In [8], interface control conditions are represented in a manner such that subclasses extend the interface control conditions of their methods by imposing additional interface control conditions.
Reference: [20] <author> Raju Pandey and James C. Browne. </author> <title> Event-based Composition of Concurrent Programs. </title> <booktitle> In Workshop on Languages and Compilers for Parallel Computation, Lecture Notes in Computer Science 768. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This paper presents a compositional approach to concurrent object-oriented programming. The model given here is an extension and application of the C-YES model <ref> [20] </ref> to object-oriented programming. The C-YES model provides a general framework for defining the concurrent composition of programs. <p> The concurrent programming methodology is not modular since component programs must be constructed with other components in view. Also, it is difficult to modify and extend a concurrent program, since changes in the composition may require changes in its components. The C-YES model <ref> [20] </ref> takes an alternate approach to composing a concurrent program from component programs. It is based on the observation that interactions among programs arise only when programs are composed in parallel, and hence should be defined when such a composition is defined. <p> Here, each parameter variable also denotes a set of method invocations. We use this approach for defining interaction points in this paper. In the other approach <ref> [20] </ref>, the mappings between the interaction parameters and the events are specified by explicitly labeling invocations of methods and/or compositions of methods. 3 A compositional approach We now present a compositional approach to concurrent object-oriented programming.
Reference: [21] <author> S. Crespi Reghizzi and G. Galli de Paratesi. </author> <title> Definition of Reusable Concurrent Software Components. </title> <booktitle> In ECOOP '91, </booktitle> <pages> pages 148-165. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: We use event ordering constraint expressions to specify both interface control and interactions during executions. The problem of inheritance anomaly has been studied in great detail and many solutions <ref> [14, 24, 4, 22, 21, 19, 23, 18] </ref> have been proposed. Most of these solutions support inheritance of method implementations by separating the interface control conditions from method implementations, and by excluding any synchronization operations from the method implementations. <p> Concurrency constraints are defined separately in abstract classes, whereas state constraints are defined in classes. The language provides mechanisms for inheriting and combining the two constraints. In DRAGOON <ref> [21] </ref>, interaction expressions are defined separately in classes called behavior classes. The computational behavior of objects are defined in classes, called free classes (methods here are concurrent by default, as they are in our model). A concurrent class is constructed by composing a set of behavior classes and free classes.
Reference: [22] <author> Etsuya Shibayama. </author> <title> Reuse of Concurrent Object Descriptions. </title> <booktitle> In Concurrency: Theory, Language, and Architecture, </booktitle> <volume> LNCS 491, </volume> <pages> pages 110-135. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: We use event ordering constraint expressions to specify both interface control and interactions during executions. The problem of inheritance anomaly has been studied in great detail and many solutions <ref> [14, 24, 4, 22, 21, 19, 23, 18] </ref> have been proposed. Most of these solutions support inheritance of method implementations by separating the interface control conditions from method implementations, and by excluding any synchronization operations from the method implementations.
Reference: [23] <author> Laurent Thomas. </author> <title> Extensibility and Reuse of Object-Oriented Synchronization Components. </title> <booktitle> In Parallel Architecture and Languages Europe, </booktitle> <volume> LNCS 605, </volume> <pages> pages 261-275. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We use event ordering constraint expressions to specify both interface control and interactions during executions. The problem of inheritance anomaly has been studied in great detail and many solutions <ref> [14, 24, 4, 22, 21, 19, 23, 18] </ref> have been proposed. Most of these solutions support inheritance of method implementations by separating the interface control conditions from method implementations, and by excluding any synchronization operations from the method implementations. <p> The computational behavior of objects are defined in classes, called free classes (methods here are concurrent by default, as they are in our model). A concurrent class is constructed by composing a set of behavior classes and free classes. Synchronizing Action [19] and PLOOC <ref> [23] </ref> also define and inherit interaction and computational behaviors separately. In [8], interface control conditions are represented in a manner such that subclasses extend the interface control conditions of their methods by imposing additional interface control conditions.
Reference: [24] <author> Chris Tomlinson and Vineet Singh. </author> <title> Inheritance and Synchronization with Enabled Sets. </title> <booktitle> In OOPSLA '89 Conference on Object-Oriented Programming, </booktitle> <pages> pages 103-112. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: We use event ordering constraint expressions to specify both interface control and interactions during executions. The problem of inheritance anomaly has been studied in great detail and many solutions <ref> [14, 24, 4, 22, 21, 19, 23, 18] </ref> have been proposed. Most of these solutions support inheritance of method implementations by separating the interface control conditions from method implementations, and by excluding any synchronization operations from the method implementations.
Reference: [25] <author> Peter Wegner. </author> <title> Dimensions of Object-Based Language Design. In OOPSLA'87, page 168. </title> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Object-orientation <ref> [25] </ref> and concurrency are perhaps the two most significant current topics in programming language research. Many programming languages that integrate concurrency and object-orientation have been proposed. Some of these are reviewed in section 4.
Reference: [26] <author> Peter Wegner and Stanley Zdonik. </author> <title> Inheritance as an Incremental Modification Mechanisms or What Like is and Isn't Like. </title> <booktitle> In ECOOP'88, </booktitle> <volume> LNCS 322, </volume> <pages> pages 55-77. </pages> <publisher> Springer Ver-lag, </publisher> <year> 1988. </year>
Reference-contexts: Such expressions may specify complex protocols among calling and called methods. Certain properties of the protocols can be verified by examining the nature of the interaction expressions. 3.2 Inheritance of interaction expressions In sequential object-oriented programming languages, inheritance <ref> [26] </ref> provides a powerful mechanism for organizing classes in a generalization-specialization relationship. In this hierarchy, classes near the top of the hierarchy capture more general information than the ones below. <p> Such a separation of the interaction behaviors has implications on the design of concurrent classes with respect to the reusability of both concurrent class and interaction behavior specifications. 3.4 Inheritance of method implementation In sequential object-oriented programming languages, inheritance <ref> [26] </ref> provides a basis for reusing method implementations. In concurrent object-oriented programming languages, there is a problem with the inheritance of method implementations. This problem, termed the inheritance anomaly [16], arises due to the diverse synchronization requirements of a class and its subclasses.
Reference: [27] <author> Y. Yokote and M. Tokoto. </author> <title> Concurrent Programming in Con-currentSmalltalk. </title> <editor> In A. Yonezawa and M. Tokoro, editors, </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pages 129-158. </pages> <publisher> The MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: languages ADA [9] and RPC-based languages; ii) approaches based on message passing such as CSP [13]; iii) approaches based on abstract data types (ADT) such as Monitors [12], ADT with path expressions [5], and SR [3]; iv) approaches based on sequential objects such as POOL-T [2], ABCL/1 [28], Concurrent SmallTalk <ref> [27] </ref>, CC++ [6], Mentat [11], and Charm++ [15]; and v) actor-based approaches [1]. The languages differ in their support for internal and external con-currency and interaction, and inheritance. We first look at languages for their support of concur-rency within objects. <p> The languages differ in their support for internal and external con-currency and interaction, and inheritance. We first look at languages for their support of concur-rency within objects. Languages such as Monitor [12], POOL-T [2], ABCL/1 [28], and Concurrent Smalltalk <ref> [27] </ref> support only a single thread of execution within an object; concurrent invocations of methods are always serialized and scheduled for execution according to the policies of the implementation. Such language-imposed serializations define semantic dependencies among method invocations where there should be none.
Reference: [28] <author> A. Yonezawa, J. Briot, and E. Shibayama. </author> <title> Modeling and Programming in Object-Oriented Concurrent Language ABCL/1. </title> <editor> In A. Yonezawa and M. Tokoro, editors, </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pages 55-89. </pages> <publisher> The MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: such as Rendezvous-based languages ADA [9] and RPC-based languages; ii) approaches based on message passing such as CSP [13]; iii) approaches based on abstract data types (ADT) such as Monitors [12], ADT with path expressions [5], and SR [3]; iv) approaches based on sequential objects such as POOL-T [2], ABCL/1 <ref> [28] </ref>, Concurrent SmallTalk [27], CC++ [6], Mentat [11], and Charm++ [15]; and v) actor-based approaches [1]. The languages differ in their support for internal and external con-currency and interaction, and inheritance. We first look at languages for their support of concur-rency within objects. <p> The languages differ in their support for internal and external con-currency and interaction, and inheritance. We first look at languages for their support of concur-rency within objects. Languages such as Monitor [12], POOL-T [2], ABCL/1 <ref> [28] </ref>, and Concurrent Smalltalk [27] support only a single thread of execution within an object; concurrent invocations of methods are always serialized and scheduled for execution according to the policies of the implementation. Such language-imposed serializations define semantic dependencies among method invocations where there should be none.
Reference: [29] <author> Akinori Yonezawa. </author> <title> Panel on Object-Based Concurrent Programming. </title> <booktitle> In Proceedings of the ECOOP-OOPSLA Workshop on Object-based Concurrent Programming, OOPS Messenger, </booktitle> <volume> Vol 2, No 2, </volume> <pages> pages 3-4. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: It does not appear, however, that there has been a fully consistent and coherent integration of the two. An example of the difficulty is the problem arising out of the interplay between inheritance and interaction among concurrent methods, the so-called inheritance anomaly [16]. An opinion <ref> [29] </ref> has been expressed that the inheritance anomaly is very difficult. Indeed, many concurrent object-oriented programming languages either limit the support for inheritance or do not support inheritance at all.
References-found: 29

