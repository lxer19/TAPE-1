URL: http://www.cs.rpi.edu/tr/92-8.ps
Refering-URL: http://www.cs.rpi.edu/tr/
Root-URL: 
Title: Resolution of Type Mismatches in an Engineering Persistent Object System  
Author: Alok Mehta David L. Spooner Martin Hardwick 
Address: Troy, New York 12180  
Affiliation: Rensselaer Design Research Center and Computer Science Department Rensselaer Polytechnic Institute  
Abstract: Many applications of objectoriented systems benefit from the ability to make objects persistent. To be fully effective, this persistence must be provided in such a way as to allow both the database of persistent objects and the applications to evolve. As they evolve, upward compatibility must be maintained so that new versions of applications can continue to use existing persistent objects and vice versa. This implies that a persistent object system must be able to handle type mismatches between objects in secondary storage and objects in an application program. In this paper, we formalize some of t he categories of type mismatches that can occur as a result of application program and database evolution. We show how the concept of an object manager can be used to resolve many of the mismatches in these categories. Finally, we discuss how object managers have been incorporated into a particular persistent object system under development at Rensselaer Polytechnic Institute. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> 21 </institution>
Reference: [Cox86] <author> B. J. Cox, </author> <title> ObjectOriented Programming , Addison-Wesley, </title> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference-contexts: Persistent object systems that provide this type of service typically have functionality ranging from simple algorithms that read and write the contents of an object <ref> [Cox86, Mey88] </ref> to full database management functionality for storing and querying objects [Kim90, Pen87]. Persistence of objects is not enough, however. An additional requirement of many applications is the ability to evolve.
Reference: [Har87] <author> M. Hardwick, </author> <title> "Why ROSE is Fast: Five Optimizations in the Design of an Experimental Database System for CAD/CAM Applications", </title> <booktitle> Proc. SIGMOD International Conference, </booktitle> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: The primary interface to ROSE is the programming language interface. The ROSE data model emphasizes flexible definition of composite object structures using EXPRESS, while the runtime system supports efficient manipulation of composite objects using a variety of storage optimizations <ref> [Har87] </ref>. A composite object in this case is an object that is an aggregation of other objects (see, for example, [Kim87]).
Reference: [Kim87] <author> W. Kim, J. Banerjee, H.T. Chou, J. F. Garza, and D. Woelk, </author> <title> "Composite Object Support in an ObjectOriented Database System", </title> <booktitle> Proc. OOPSLA '87, </booktitle> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: The ROSE data model emphasizes flexible definition of composite object structures using EXPRESS, while the runtime system supports efficient manipulation of composite objects using a variety of storage optimizations [Har87]. A composite object in this case is an object that is an aggregation of other objects (see, for example, <ref> [Kim87] </ref>). In the C++ version of ROSE, a C++ application program requests ROSE to retrieve a particular composite object from secondary storage and instantiate each of its component objects in the address space of the C++ program.
Reference: [Kim88] <author> W. Kim and H.-T. Chou, </author> <title> "Versions of Schema for ObjectOriented Databases", </title> <booktitle> Proc. 14th International Conference on VLDB, </booktitle> <publisher> Morgan Kaufman Publishing Company, </publisher> <year> 1988. </year>
Reference-contexts: These definitions are illustrated in Figure 1. Type mismatches are introduced either by changes made to the object declarations in an application program (the program schema) or by changes made to the definitions of the persistent objects in secondary storage (the database schema). For example, Orion <ref> [Kim88] </ref> and GemStone [Pen87] are two objectoriented database systems in which persistent objects can be stored. Both these systems provide a set of operators for editing the schema of a database. For GemStone these operators are shown in Figure 2. 6 3. <p> The "pay me later'' approach defers actual modification, possibly indefinitely. Data is either filtered or corrected at access time. If an application is developed using a different version of a schema, the interface must be able to convert data into a format acceptable to the application. Kim and Chou <ref> [Kim88] </ref> describe a model of schema versioning in which a new schema version can be used to access data defined under an older version of the schema. They do not describe how differences in data types between versions are resolved.
Reference: [Kim90] <author> W. Kim, </author> <title> Introduction to ObjectOriented Databases , The MIT Press, </title> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Persistent object systems that provide this type of service typically have functionality ranging from simple algorithms that read and write the contents of an object [Cox86, Mey88] to full database management functionality for storing and querying objects <ref> [Kim90, Pen87] </ref>. Persistence of objects is not enough, however. An additional requirement of many applications is the ability to evolve. Both the application system itself as well as the content and structure of the persistent data it uses change over time. <p> Related Work As we noted earlier, type mismatches are introduced by the evolution of the program schema and the database schema. The management of objectoriented schema evolution has not been investigated in depth, although its importance has been noted by many researchers <ref> [Ler90, Kim90] </ref>. There are two basic philosophies in adjusting to schema evolution: "pay me now or pay me later'' ([Pen87], p. 11). The first approach requires existing data and programs to be modified at the time the schema is changed.
Reference: [Ler90] <author> B. S. Lerner and A. N. Habermann, </author> <title> "Beyond Schema Evolution to Database Reorganization", </title> <booktitle> Proc. OOPSLA '90 Conference, </booktitle> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Given the requirements above, a tool that converts persistent objects from an old schema to a new one is not, by itself, an adequate solution to this problem (see <ref> [Ler90] </ref> for an example of such a schema conversion system). When multiple applications share a persistent object and one of these applications requires changes to the schema for the object, it may not be acceptable to convert the persistent object to conform to the new schema. <p> Related Work As we noted earlier, type mismatches are introduced by the evolution of the program schema and the database schema. The management of objectoriented schema evolution has not been investigated in depth, although its importance has been noted by many researchers <ref> [Ler90, Kim90] </ref>. There are two basic philosophies in adjusting to schema evolution: "pay me now or pay me later'' ([Pen87], p. 11). The first approach requires existing data and programs to be modified at the time the schema is changed. <p> Penney describes how this approach is implemented for the GemStone data management system in [Pen87]. Lerner and Habermann <ref> [Ler90] </ref> describe a scheme for the Gandalf programming environment that allows either approach. 19 The "pay me now" approach is easier to implement and incurs less overhead, but may not always be feasible or desirable.
Reference: [Mey88] <author> B. Meyer, </author> <title> ObjectOriented Software Construction, </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Persistent object systems that provide this type of service typically have functionality ranging from simple algorithms that read and write the contents of an object <ref> [Cox86, Mey88] </ref> to full database management functionality for storing and querying objects [Kim90, Pen87]. Persistence of objects is not enough, however. An additional requirement of many applications is the ability to evolve.
Reference: [Pen87] <author> D. J. Penney and J. Stein, </author> <title> "Class Modification in the GemStone Object-Oriented DBMS", </title> <booktitle> Proc. OOPSLA '87 Conference, </booktitle> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: Persistent object systems that provide this type of service typically have functionality ranging from simple algorithms that read and write the contents of an object [Cox86, Mey88] to full database management functionality for storing and querying objects <ref> [Kim90, Pen87] </ref>. Persistence of objects is not enough, however. An additional requirement of many applications is the ability to evolve. Both the application system itself as well as the content and structure of the persistent data it uses change over time. <p> These definitions are illustrated in Figure 1. Type mismatches are introduced either by changes made to the object declarations in an application program (the program schema) or by changes made to the definitions of the persistent objects in secondary storage (the database schema). For example, Orion [Kim88] and GemStone <ref> [Pen87] </ref> are two objectoriented database systems in which persistent objects can be stored. Both these systems provide a set of operators for editing the schema of a database. For GemStone these operators are shown in Figure 2. 6 3. <p> Penney describes how this approach is implemented for the GemStone data management system in <ref> [Pen87] </ref>. Lerner and Habermann [Ler90] describe a scheme for the Gandalf programming environment that allows either approach. 19 The "pay me now" approach is easier to implement and incurs less overhead, but may not always be feasible or desirable.
Reference: [Ska87] <author> A. Skarra and S. Zdonik, </author> <title> "Type Evolution in an ObjectOriented Database", in Research Directions in ObjectOriented Programming, </title> <editor> B. Shriver and P. Wegner (editors), </editor> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: Kim and Chou [Kim88] describe a model of schema versioning in which a new schema version can be used to access data defined under an older version of the schema. They do not describe how differences in data types between versions are resolved. In Skarra and Zdonik's model <ref> [Ska87] </ref>, filters are used to resolve type mismatches. Each type T has a version set interface, V T , that represents the union of all attributes, methods, and constraints that were ever defined for T.
Reference: [Smi88] <author> B. Smith, </author> <title> Product Data Exchange Specification: </title> <note> First Working Draft, NISTER 88-4004, NTIS Order Number PB 89-144794. </note>
Reference-contexts: Data 9 modeling in ROSE is based on the EXPRESS language of the emerging PDES/STEP standard for exchange of engineering product data <ref> [Smi88] </ref>. Entities defined in an EXPRESS model are converted automatically by a ROSE tool to classes in an object-oriented programming language such as C++ for application development. ROSE allows persistent objects to be mapped to different object classes in different application programs.
Reference: [STE92a] <institution> STEP Tools, Inc., ROSE 3.0 Reference Manual , Rensselaer Technology Park, </institution> <address> Troy, New York 12180, </address> <year> 1992. </year> <month> 22 </month>
Reference-contexts: We will discuss techniques for handling each category in the context of a persistent object system named ROSE under development at Rensselaer. 4.1 ROSE Persistent Object System ROSE is a persistent object manager for supporting concurrent engineering and information exchange in design and manufacturing systems <ref> [STE92a, STE92b] </ref>. Data 9 modeling in ROSE is based on the EXPRESS language of the emerging PDES/STEP standard for exchange of engineering product data [Smi88].
Reference: [STE92b] <institution> STEP Tools, Inc., ROSE 3.0 Tutorial Manual, Rensselaer Technology Park, </institution> <address> Troy, New York 12180, </address> <year> 1992. </year>
Reference-contexts: We will discuss techniques for handling each category in the context of a persistent object system named ROSE under development at Rensselaer. 4.1 ROSE Persistent Object System ROSE is a persistent object manager for supporting concurrent engineering and information exchange in design and manufacturing systems <ref> [STE92a, STE92b] </ref>. Data 9 modeling in ROSE is based on the EXPRESS language of the emerging PDES/STEP standard for exchange of engineering product data [Smi88].
References-found: 13

