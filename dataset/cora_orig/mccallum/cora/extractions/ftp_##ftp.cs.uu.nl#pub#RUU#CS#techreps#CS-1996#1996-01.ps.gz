URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1996/1996-01.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: email: wishnup@caplin.cs.ui.ac.id  
Title: Formalizing UNITY with HOL  
Author: I.S.W.B. Prasetya Dr Ir I. Wishnu S.B. Prasetya, 
Note: 1 current address:  
Address: P.O.Box 80.089, 3508 TB UTRECHT, the Netherlands  Indonesia, Kampus UI Depok, Depok 16424, Indonesia  
Affiliation: Department of Computer Science, Utrecht University  Faculty of Computer Science, University of  
Abstract-found: 0
Intro-found: 1
Reference: [And92] <author> Flemming Andersen. </author> <title> A Theorem Prover for UNITY in Higher Order Logic. </title> <type> PhD thesis, </type> <institution> Technical University of Denmark, </institution> <year> 1992. </year>
Reference-contexts: An example of property (specification) refinement will be presented in this chapter, but before we come to that, first it will be explained how we represent a UNITY program in HOL. UNITY itself has been embedded in HOL by Andersen <ref> [And92] </ref>. There are differences between our embedding of core UNITY with Andersen's. The main difference is that Andersen defines a program simply as a list of actions.
Reference: [Bac90] <author> R.J.R. </author> <title> Back. Refinement calculus, part ii: Parallel and reactive programs. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Lectures Notes in Computer Science 430: Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </booktitle> <pages> pages 42-66. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: This way of viewing programs is especially attractive if we consider a parallel execution of actions where strict orderings begin to break down. In fact, a number of distributed programming logics are based on this idea. Examples thereof are Action Systems <ref> [Bac90] </ref>, Temporal Logic of Action [Lam90], and UNITY [CM88]. In this chapter we will take a closer to UNITY. There are of course pros and contras for UNITY, but let us not discuss them here.
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceeding of the 5th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference: [Bou92] <author> R. Boulton. </author> <title> The hol arith library. </title> <type> Technical report, </type> <institution> Computer Laboratory University of Cambridge, </institution> <month> July </month> <year> 1992. </year>
Reference: [Bou94] <author> R.J. Boulton. </author> <title> Efficiency in a fully-expansive theorem prover. </title> <type> Technical Report 337, </type> <institution> University of Cambridge Computer Laboratory, </institution> <year> 1994. </year>
Reference-contexts: However, for limited applications, it is often possible to provide automatic procedures. The standard HOL package is supplied with a library called arith written by Boulton <ref> [Bou94] </ref>. The library contains a decision procedure to decide the validity of a certain subset 4 The name of the theorem defining the constant MAP happens to have the same name. These two MAPs really refer to different things. 2.5. AUTOMATIC PROVING Page 15 of arithmetic formulas over natural numbers.
Reference: [Bus94] <author> H. Busch. </author> <title> First-order automation for higher-order-logic theorem proving. </title> <editor> In T.F. Melham and J. Camilleri, editors, </editor> <booktitle> Lecture Notes in Computer Science 859: Higher Order Theorem Proving and Its Application, </booktitle> <pages> pages 97-122. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent system using temporal logic specifications. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 2 </volume> <pages> 224-263, </pages> <month> Jan. </month> <year> 1986. </year>
Reference: [CKW + 91] <author> I. Chakravarty, M. Kleyn, T.Y.C. Woo, R. Bagrodia, and V. Austel. </author> <title> Unity to uc: A case study in the derivation of parallel programs. </title> <editor> In J.P. Ben^atre and D. le Metayer, editors, </editor> <booktitle> Lecture Notes in Computer Science 574: Research Direction in High Level Prallel Programming Languages, </booktitle> <pages> pages 7-20. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: It is interesting to note that the amount of work using UNITY is small, compared to that of the traditional approach. A review of Pizzarello's industrial experience on the use of UNITY can be found in [Piz91]. In <ref> [CKW + 91] </ref> Chakravarty and his colleagues developed a simulation of the diffusion and aggregation of particles in a cement like porous media. In practice, many useful programs do not, in principle, terminate; some examples are file servers, routing programs in computer networks, and control systems in an air plane.
Reference: [CM88] <author> K.M. Chandy and J. Misra. </author> <title> Parallel Program Design A Foundation. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1988. </year> <note> 49 Page 50 BIBLIOGRAPHY </note>
Reference-contexts: This way of viewing programs is especially attractive if we consider a parallel execution of actions where strict orderings begin to break down. In fact, a number of distributed programming logics are based on this idea. Examples thereof are Action Systems [Bac90], Temporal Logic of Action [Lam90], and UNITY <ref> [CM88] </ref>. In this chapter we will take a closer to UNITY. There are of course pros and contras for UNITY, but let us not discuss them here. <p> We will show here how things can be done with UNITY, and leave it to the reader to judge what kinds of applications he wants to use the logic for. Examples of programs derivation and verification using UNITY are many. The introductory book to UNITY <ref> [CM88] </ref> itself contains numerous examples, ranging from a simple producer-consumer program, to a parallel garbage collection program. Realistic problems have also been addressed. In [Sta93] Staskauskas derives an I/O sub-system of an existing operating system, which is responsible for allocating I/O resources. <p> = 0 then x := 1 else skip [] if a 6= 0 then x := 1 else skip [] if x 6= 0 then y; x := y + 1; 0 else skip J 3.2 UNITY Programs UNITY is a programming logic invented by Chandy and Misra in 1988 <ref> [CM88] </ref> for reasoning about safety and progress behavior of distributed programs. Figure 3.1 displays an example. The precise syntax will be given later. The read and write sections declare, respectively, the read and write variables of the program. The init section describes the assumed initial states of the program. <p> As far as UNITY concerns, the actions can be implemented sequentially, fully parallel, or anything in between, as long as the atomicity and the fairness conditions of UNITY are being met. Perhaps, the best way to formulate the UNITY's philosophy is as worded by Chandy and Misra in <ref> [CM88] </ref>: A UNITY program describes what should be done in the sense that it specifies the initial state and the state transformations (i.e., the assignments). <p> THE PROGRAMMING LOGIC UNITY about the actions ordering and allocation, as such are considered to be implementation issues. Despite its simple view, UNITY has a relatively powerful logic. The wide range of applications considered in <ref> [CM88] </ref> illustrates this fact quite well. Still, to facilitate programming, more structuring methods would be appreciated. An example thereof is sequential composition of actions. Structuring is an issue which deserves more investigation in UNITY. <p> The syntax deviates slightly from the one in <ref> [CM88] </ref> 1 . hUnity Programi ::= prog hname of programi read hset of variablesi write hset of variablesi init hpredicatei assignhactionsi actions is a list of actions separated by []. <p> In this paper, we will only touch the topic of parallel composition, because this is Page 22 CHAPTER 3. THE PROGRAMMING LOGIC UNITY the most interesting composition in distributed programming. If the reader is interested, see for example <ref> [CM88, R.95, Pra95] </ref>. A consequence of the absence of ordering in the execution of a UNITY program is that the parallel composition of two programs can be modelled by simply merging the variables and actions of both programs. In UNITY parallel composition is denoted by []. <p> A consequence of the absence of ordering in the execution of a UNITY program is that the parallel composition of two programs can be modelled by simply merging the variables and actions of both programs. In UNITY parallel composition is denoted by []. In <ref> [CM88] </ref> the operator is also called program union. <p> In Figure 3.3 is a list of some interesting properties of unless and |there are more though, see for example <ref> [CM88] </ref>. The properties can be derived from the definition. <p> In UNITY, a program is derived by refining its initial specification 2 . Some laws were shown in the previous chapter (more can be found in <ref> [CM88, Pra95] </ref>). The laws also include compositionality laws, with which we can split a program into smaller components.
Reference: [Con86] <editor> R.L. et al. </editor> <title> Constable. Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference: [Coo72] <author> D.C. Cooper. </author> <title> Theorem proving in arithmetic without multiplication. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence fl, chapter 5, </booktitle> <pages> pages 91-99. </pages> <publisher> Edinburgh University Press, </publisher> <year> 1972. </year>
Reference-contexts: These two MAPs really refer to different things. 2.5. AUTOMATIC PROVING Page 15 of arithmetic formulas over natural numbers. The procedure is based on the Presburger natural number arithmetic <ref> [Coo72] </ref>.
Reference: [Dij76] <author> E.W. Dijkstra. </author> <title> A discipline of programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference: [GM93] <author> Mike J.C. Gordon and Tom F. Melham. </author> <title> Introduction to HOL. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference: [Goo85] <author> D.I. </author> <title> Good. Mechanical proofs about computer programs. In C.A.R. Hoare and J.C. Sheperdson, </title> <editor> editors, </editor> <booktitle> Mathematical Logic and Programming Languages, </booktitle> <pages> pages 55-75. </pages> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference: [Gri81] <editor> D. Gries. </editor> <booktitle> The science of computer programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference: [Gri90] <author> D. Gries. </author> <title> Formalism in teaching programming. In E.W. Dijkstra, editor, </title> <booktitle> Formal Development of Programs and Proofs, </booktitle> <pages> pages 229-236. </pages> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference: [Hoa69] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computers programs. </title> <journal> Commun. Ass. Comput. Mach., </journal> <volume> 12 </volume> <pages> 576-583, </pages> <year> 1969. </year>
Reference: [JS93] <author> J. J. Joyce and C. Seger. </author> <title> The hol-voss system: Model-checking inside a general-purpose theorem prover. </title> <editor> In J. J. Joyce and C. Seger, editors, </editor> <booktitle> Lecture Notes in Computer Science, 780 : Higher Order Logic Theorem Proving and its Applications: 6th International Workshop, </booktitle> <address> HUG'93,. </address> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: There is ongoing research that aims to integrate model checking tools with HOL 6 . For example, Joyce and Seger have integrated HOL with a model checker called Voss to check the validity of formulas from a simple interval temporal logic <ref> [JS93] </ref>. 5 In general, natural number arithmetic is not decidable if multiplication is included. So the best we can achieve is a partial decision procedure. 6 That is, the model checker is implemented as an external program.
Reference: [KB87] <author> J.E. King and W.J. </author> <title> Brophy. </title> <booktitle> Computer entomology. Scientific Honeyweller, </booktitle> <pages> 1986-87. </pages>
Reference-contexts: In [Piz92] Pizzarello used UNITY to correct an error found in a large operating system. The fault had been corrected before, and verified using the traditional approach of testing and tracing <ref> [KB87] </ref>. It is interesting to note that the amount of work using UNITY is small, compared to that of the traditional approach. A review of Pizzarello's industrial experience on the use of UNITY can be found in [Piz91].
Reference: [KKS91] <author> R. Kumar, T. Kropf, and K. Schneider. </author> <title> Integrating a first order automatic prover in the hol environment. </title> <booktitle> In Proceedings of the 1991 International Workshop on the HOL Theorem Proving System and Its Applications. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> August </month> <year> 1991. </year>
Reference: [Lam90] <author> L. Lamport. </author> <title> A temportal logic of actions. </title> <type> Technical Report 57, </type> <institution> Digital Systems Research Center, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: This way of viewing programs is especially attractive if we consider a parallel execution of actions where strict orderings begin to break down. In fact, a number of distributed programming logics are based on this idea. Examples thereof are Action Systems [Bac90], Temporal Logic of Action <ref> [Lam90] </ref>, and UNITY [CM88]. In this chapter we will take a closer to UNITY. There are of course pros and contras for UNITY, but let us not discuss them here.
Reference: [lL77] <author> G. le Lann. </author> <title> Distributed systems |towards a formal approach. </title> <editor> In B. Gilchrist, editor, </editor> <booktitle> nformation Processing '77, </booktitle> <pages> pages 155-160. </pages> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: The problem was first posed in <ref> [lL77] </ref>. Leader election has a lot of applications in distributed computing. For example, to appoint a central server when several candidates are available. The selection is required to be non-deterministic.
Reference: [Piz91] <author> A. Pizzarello. </author> <title> An indrustial experience in the use of unity. </title> <editor> In J.P. Ben^atre and D. le Metayer, editors, </editor> <booktitle> Lecture Notes in Computer Science 574: Research Direction in High Level Prallel Programming Languages, </booktitle> <pages> pages 38-49. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> BIBLIOGRAPHY Page 51 </note>
Reference-contexts: It is interesting to note that the amount of work using UNITY is small, compared to that of the traditional approach. A review of Pizzarello's industrial experience on the use of UNITY can be found in <ref> [Piz91] </ref>. In [CKW + 91] Chakravarty and his colleagues developed a simulation of the diffusion and aggregation of particles in a cement like porous media.
Reference: [Piz92] <author> A. Pizzarello. </author> <title> Formal methods in corrective software maintenance. In proceeding Formal Methods for Software Development: </title> <booktitle> International Seminar, </booktitle> <address> Milano, </address> <year> 1992. </year> <institution> Associazione Italiana Calcolo Automatico (AICA). </institution>
Reference-contexts: The introductory book to UNITY [CM88] itself contains numerous examples, ranging from a simple producer-consumer program, to a parallel garbage collection program. Realistic problems have also been addressed. In [Sta93] Staskauskas derives an I/O sub-system of an existing operating system, which is responsible for allocating I/O resources. In <ref> [Piz92] </ref> Pizzarello used UNITY to correct an error found in a large operating system. The fault had been corrected before, and verified using the traditional approach of testing and tracing [KB87].
Reference: [Pra94] <author> I.S.W.B. Prasetya. </author> <title> Error in the unity substitution rule for subscripted operators. </title> <journal> Formal Aspects of Computing, </journal> <volume> 6 </volume> <pages> 466-470, </pages> <year> 1994. </year>
Reference: [Pra95] <author> I.S.W.B. Prasetya. </author> <title> Mechanically Supported Design of Self-stabilizing Algorithms. </title> <type> PhD thesis, </type> <institution> Dept. of Comp. Science, Utrecht University, </institution> <year> 1995. </year>
Reference-contexts: In this paper, we will only touch the topic of parallel composition, because this is Page 22 CHAPTER 3. THE PROGRAMMING LOGIC UNITY the most interesting composition in distributed programming. If the reader is interested, see for example <ref> [CM88, R.95, Pra95] </ref>. A consequence of the absence of ordering in the execution of a UNITY program is that the parallel composition of two programs can be modelled by simply merging the variables and actions of both programs. In UNITY parallel composition is denoted by []. <p> In UNITY, a program is derived by refining its initial specification 2 . Some laws were shown in the previous chapter (more can be found in <ref> [CM88, Pra95] </ref>). The laws also include compositionality laws, with which we can split a program into smaller components.
Reference: [R.95] <author> Udink. R. </author> <title> Program Refinement in UNITY-like Environments. </title> <type> PhD thesis, </type> <institution> Utrecht University, </institution> <year> 1995. </year>
Reference-contexts: In this paper, we will only touch the topic of parallel composition, because this is Page 22 CHAPTER 3. THE PROGRAMMING LOGIC UNITY the most interesting composition in distributed programming. If the reader is interested, see for example <ref> [CM88, R.95, Pra95] </ref>. A consequence of the absence of ordering in the execution of a UNITY program is that the parallel composition of two programs can be modelled by simply merging the variables and actions of both programs. In UNITY parallel composition is denoted by [].
Reference: [San91] <author> B.A. Sanders. </author> <title> Eliminating the substitution axiom from UNITY logic. </title> <journal> Formal Aspects of Computing, </journal> <volume> 3(2) </volume> <pages> 189-205, </pages> <year> 1991. </year>
Reference: [SKR91] <author> K. Scneider, T. Kropf, and Kumar R. </author> <title> Integrating a first-order automatic prover in the hol environment. </title> <editor> In M Archer, Joyce J.J., Levitt K.N., and Windley P.J., editors, </editor> <booktitle> Proceedings of the 1991 International Workshop on the HOL Theorem Proving System and Its Applications. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: There is a library called faust written by Schneider, Kropf, and Kumar <ref> [SKR91] </ref> that provides a decision procedure to check the validity of many formulas from first order predicate logic.
Reference: [Sta93] <author> M.G. Staskauskas. </author> <title> Formal derivation of concurrent programs: An exanple from industry. </title> <journal> IEEE Transaction on Software Engineering, </journal> <volume> 19(5) </volume> <pages> 503-528, </pages> <year> 1993. </year>
Reference-contexts: Examples of programs derivation and verification using UNITY are many. The introductory book to UNITY [CM88] itself contains numerous examples, ranging from a simple producer-consumer program, to a parallel garbage collection program. Realistic problems have also been addressed. In <ref> [Sta93] </ref> Staskauskas derives an I/O sub-system of an existing operating system, which is responsible for allocating I/O resources. In [Piz92] Pizzarello used UNITY to correct an error found in a large operating system. The fault had been corrected before, and verified using the traditional approach of testing and tracing [KB87].
Reference: [UHK94] <author> R. Udink, T. Herman, and J. Kok. </author> <title> Compositional local progress in unity. </title> <booktitle> In proceeding of IFIP Working Conference on Programming Concepts, Methods and Calculi,, </booktitle> <year> 1994. </year>
Reference-contexts: In this case we simply have to instantiate the polymorphic type *var and *val to string and num. 2 Another method is to apply program refinement instead of property/specification refinement. This method is beyond the scope of this thesis. See for example <ref> [UHK94] </ref> Page 36 CHAPTER 4. EMBEDDING UNITY IN HOL In practice, people often want to have programs in which the variables have different types |and, which may include sophisticated types such as functions or trees. That is, we want a multi-typed universe of values.
References-found: 31

