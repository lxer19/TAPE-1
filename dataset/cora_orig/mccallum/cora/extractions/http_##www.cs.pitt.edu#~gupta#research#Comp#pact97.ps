URL: http://www.cs.pitt.edu/~gupta/research/Comp/pact97.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/optimization.html
Root-URL: 
Title: Path Profile Guided Partial Dead Code Elimination Using Predication  
Author: Rajiv Gupta David A. Berson Jesse Z. Fang 
Address: Pittsburgh, PA 15260 Santa Clara, CA 95052  
Affiliation: Dept. of Computer Science Microcomputer Research Lab University of Pittsburgh Intel Corporation  
Abstract: We present a path profile guided partial dead code elimination algorithm that uses predication to enable sinking for the removal of deadness along frequently executed paths at the expense of adding additional instructions along infrequently executed paths. Our approach to optimization is particularly suitable for VLIW architectures since it directs the efforts of the optimizer towards aggressively enabling generation of fast schedules along frequently executed paths by reducing their critical path lengths. The paper presents a cost-benefit data flow analysis that uses path profiling information to determine the profitability of using predication enabled sinking. The cost of predication enabled sinking of a statement past a merge point is determined by identifying paths along which an additional statement is introduced. The benefit of predication enabled sinking is determined by identifying paths along which additional dead code elimination is achieved due to predication. The results of this analysis are incorporated in a code sinking framework in which predication enabled sinking is allowed past merge points only if its benefit is determined to be greater than the cost. It is also demonstrated that trade-off can be performed between the compile time cost and the precision of cost-benefit analysis. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Ball and J. Larus, </author> <title> "Efficient Path Profiling," </title> <booktitle> 29th Annual IEEE/ACM International Symposium on Mi-croarchitecture, </booktitle> <address> Paris, France, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: Edge profiling gives the number of times each edge in the program flow graph is traversed and path profiling gives the number of times various acyclic paths in a program are traversed. In <ref> [1] </ref> it is shown that different path profiles can give rise to the same edge profiles. Thus, it is not possible to accurately identify frequently executed paths using edge profiles. Furthermore, Ball and Larus [1] have shown that path profile information can be collected efficiently. <p> In <ref> [1] </ref> it is shown that different path profiles can give rise to the same edge profiles. Thus, it is not possible to accurately identify frequently executed paths using edge profiles. Furthermore, Ball and Larus [1] have shown that path profile information can be collected efficiently. Therefore in this paper we rely on path profiling information. The example in Figure 1a illustrates our approach.
Reference: [2] <author> R. Bodik and R. Gupta, </author> <title> "Partial Dead Code Elimination using Slicing Transformations," </title> <booktitle> ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <address> Las Vegas, Nevada, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Thus, in order to beneficially exploit predication enabled code sinking for PDE, it is necessary to develop an approach for trade-off between quality of code along frequently and infrequently executed paths. Existing techniques for PDE <ref> [2, 19] </ref> do not take advantage of predication in performing PDE. <p> Since traditional approaches to PDE remove dead code along some paths without adding additional instructions along any path <ref> [2, 19] </ref>, they are essentially based on the assumption that all paths through the program are equally important. However, our approach which can trade-off the quality of code generated for infrequently executed paths for obtaining better code for frequently executed paths is based upon the realistic scenario encountered in practice.
Reference: [3] <author> R. Bodik and R. Gupta, </author> <title> "Array Data-Flow Analysis for Load-Store Optimizations in Superscalar Architectures," </title> <journal> International Journal of Parallel Programming, </journal> <volume> Vol. 24, No. 6, </volume> <pages> pages 481-512, </pages> <year> 1996. </year>
Reference-contexts: A set of nodes satisfying this property is a generalized dominator of the node at which the predicated statement is placed [7]. Efficient algorithms for identifying these set of nodes can be found in <ref> [3] </ref>. Finally it should be noted that there is a cost associated with the placement of an assignment. <p> The approach for cost-benefit analysis that we have presented is quite general and has also been applied to other problems including partial redundancy elimination [9], strength reduction [18], and load-store elimination from loops <ref> [3, 8] </ref>. The example in Figure 11 illustrates the application of our approach to partial redundancy elimination. In the first flow graph shown in Figure 11a, the evaluation of the expression x + y in node 7 is partially redundant.
Reference: [4] <author> D.M. Dhamdhere, </author> <title> "Practical Adaptation of Global Optimization Algorithm of Morel and Renvoise," </title> <journal> ACM Transactions on Programming Languages, </journal> <volume> 13(2) </volume> <pages> 291-294, </pages> <year> 1991. </year>
Reference: [5] <author> J.Z. Fang, </author> <title> "Compiler Algorithms on If-Conversion, Speculative Predicates Assignment and Predicated Code Optimizations," </title> <booktitle> Ninth Workshop on Languages and Compilers for Parallel Computers, </booktitle> <address> San Jose, Cal-ifornia, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: This modified framework uses the cost-benefit information to enable sinking of a partially dead statement past merge points where the benefit has been found to be greater than the cost. In previous work by Fang <ref> [5] </ref> the use of predication during sinking was also proposed. However, the algorithms described in [5] apply to single-entry-single-exit acyclic regions and no cost benefit analysis to guide predication is presented. In section 2 we present our PDE algorithm in detail. <p> In previous work by Fang <ref> [5] </ref> the use of predication during sinking was also proposed. However, the algorithms described in [5] apply to single-entry-single-exit acyclic regions and no cost benefit analysis to guide predication is presented. In section 2 we present our PDE algorithm in detail. In section 2.1 data flow analysis for computing cost-benefit information for acyclic graphs is discussed and its extensions for loops are presented.
Reference: [6] <author> J.A. Fisher, </author> <title> "Trace Scheduling: A Technique for Global Microcode Compaction," </title> <journal> IEEE Transactions on Computers, </journal> <volume> 30(7), </volume> <month> July </month> <year> 1981. </year>
Reference-contexts: The optimization strategy that we have developed is demonstrated through a new algorithm for partial dead code elimination (PDE). PDE is an important optimization for VLIW architectures since critical path lengths along frequently executed paths can be reduced through PDE <ref> [11, 6, 13] </ref>. Through code sinking, that is, delaying the execution of a code statement to later program points, PDE optimization moves instructions that are dead along critical paths off the critical paths [19, 22].
Reference: [7] <author> R. Gupta, </author> <title> "Generalized Dominators and Post-Dominators," </title> <booktitle> 19th Annual ACM SIGPLAN-SIGACT Symposium of Principles of Programming Languages, </booktitle> <pages> pages 246-257, </pages> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: In some restricted situations it is possible to determine placements of predicate assignments such that exactly one predicate assignment is encountered prior to reaching the predicated instruction. A set of nodes satisfying this property is a generalized dominator of the node at which the predicated statement is placed <ref> [7] </ref>. Efficient algorithms for identifying these set of nodes can be found in [3]. Finally it should be noted that there is a cost associated with the placement of an assignment.
Reference: [8] <author> R. Gupta, </author> <title> "Code Optimization as a Side Effect of Instruction Scheduling," </title> <booktitle> International Conference on High Performance Computing, </booktitle> <address> Bangalore, India, </address> <month> De-cember </month> <year> 1997. </year>
Reference-contexts: The approach for cost-benefit analysis that we have presented is quite general and has also been applied to other problems including partial redundancy elimination [9], strength reduction [18], and load-store elimination from loops <ref> [3, 8] </ref>. The example in Figure 11 illustrates the application of our approach to partial redundancy elimination. In the first flow graph shown in Figure 11a, the evaluation of the expression x + y in node 7 is partially redundant.
Reference: [9] <author> R. Gupta, D. Berson, and J.Z. Fang, </author> <title> "Path Profile Guided Partial Redundancy Elimination Using Speculation," </title> <type> Technical Report TR-97-13, </type> <institution> Dept. of Computer Science, University of Pittsburgh, </institution> <year> 1997. </year>
Reference-contexts: The approach for cost-benefit analysis that we have presented is quite general and has also been applied to other problems including partial redundancy elimination <ref> [9] </ref>, strength reduction [18], and load-store elimination from loops [3, 8]. The example in Figure 11 illustrates the application of our approach to partial redundancy elimination. In the first flow graph shown in Figure 11a, the evaluation of the expression x + y in node 7 is partially redundant. <p> Thus, in this situation it is beneficial to use the placement shown in Figure 11b. In <ref> [9] </ref> we describe in detail the combination of code speculation with the PRE optimization [16, 15]. Speculation is enabled at conditional nodes based upon cost-benefit analysis. In [10] we present predication based PRE and speculation based PRE algorithms that are resource sensitive.
Reference: [10] <author> R. Gupta, D. Berson, and J.Z. Fang, </author> <title> "Resource-Sensitive Profile-Directed Data Flow Analysis for Code Optimization," </title> <booktitle> The 30th Annual IEEE/ACM International Symposium on Microarchitecture, </booktitle> <institution> Research Triangle Park, North Carolina, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: Thus, in this situation it is beneficial to use the placement shown in Figure 11b. In [9] we describe in detail the combination of code speculation with the PRE optimization [16, 15]. Speculation is enabled at conditional nodes based upon cost-benefit analysis. In <ref> [10] </ref> we present predication based PRE and speculation based PRE algorithms that are resource sensitive. These algorithms compute code placements where the functional unit required for the execution of the placed algorithm is available. Only the optimization opportunities for which such placements exist are exploited.
Reference: [11] <author> R. Gupta and M.L. Soffa, </author> <title> "Region Scheduling: An Approach for Detecting and Redistributing Parallelism," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 421-431, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: The optimization strategy that we have developed is demonstrated through a new algorithm for partial dead code elimination (PDE). PDE is an important optimization for VLIW architectures since critical path lengths along frequently executed paths can be reduced through PDE <ref> [11, 6, 13] </ref>. Through code sinking, that is, delaying the execution of a code statement to later program points, PDE optimization moves instructions that are dead along critical paths off the critical paths [19, 22].
Reference: [12] <author> P. Hsu and E. Davidson, </author> <title> "Highly Concurrent Scalar Processing," </title> <booktitle> 13th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 386-395, </pages> <year> 1986. </year>
Reference-contexts: Through code sinking, that is, delaying the execution of a code statement to later program points, PDE optimization moves instructions that are dead along critical paths off the critical paths [19, 22]. Modern architectures <ref> [14, 12] </ref> that support predicated execution provide an opportunity for aggressively performing PDE since predication enables code sinking that is otherwise not possible. Furthermore, predication enabled code sinking may also introduce predicated versions of an instruction along paths where the instruction was not previously encountered.
Reference: [13] <author> W.W. Hwu, S.A. Mahlke, W.Y. Chen, P.P. Chang, N.J. Warter, R.A. Bringmann, R.G. Ouellette, R.E. Hank, T. Kiyohara, G.E. Haab, J.G. Holm, </author> <title> and D.M. Lavery, "The Superblock: An Effective Technique for VLIW and Superscalar Compilation," </title> <journal> Journal of Supercomputing, </journal> <volume> Vol. A, </volume> <pages> pages 229-248, </pages> <year> 1993. </year>
Reference-contexts: The optimization strategy that we have developed is demonstrated through a new algorithm for partial dead code elimination (PDE). PDE is an important optimization for VLIW architectures since critical path lengths along frequently executed paths can be reduced through PDE <ref> [11, 6, 13] </ref>. Through code sinking, that is, delaying the execution of a code statement to later program points, PDE optimization moves instructions that are dead along critical paths off the critical paths [19, 22].
Reference: [14] <author> V. Kathail, M. Schlansker, and B.R. Rau, </author> <title> "HPL Play-Doh Architecture Specification: Version 1.0," </title> <type> Technical Report HPL-93-80, </type> <institution> Computer Systems Laboratory, HP Labs, </institution> <address> Palo Alto, CA, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: Through code sinking, that is, delaying the execution of a code statement to later program points, PDE optimization moves instructions that are dead along critical paths off the critical paths [19, 22]. Modern architectures <ref> [14, 12] </ref> that support predicated execution provide an opportunity for aggressively performing PDE since predication enables code sinking that is otherwise not possible. Furthermore, predication enabled code sinking may also introduce predicated versions of an instruction along paths where the instruction was not previously encountered. <p> The above optimization also requires that the result of evaluating predicate p in node 1 must be saved till node 8. In an architecture such as PlayDoh, the predicates are stored in special predicate registers <ref> [14] </ref>. The approach we present first performs data flow analysis for computing the cost and benefit of sinking a statement past each relevant merge point. An extension of a code sinking algorithm by Knoop et al. [19] that incorporates predication is presented next.
Reference: [15] <author> E. Morel and C. </author> <title> Renvoise, "Global Optimization by Suppression of Partial Redundancies," </title> <journal> Communications of the ACM, </journal> <volume> 22(2) </volume> <pages> 96-103, </pages> <year> 1979. </year>
Reference-contexts: Thus, in this situation it is beneficial to use the placement shown in Figure 11b. In [9] we describe in detail the combination of code speculation with the PRE optimization <ref> [16, 15] </ref>. Speculation is enabled at conditional nodes based upon cost-benefit analysis. In [10] we present predication based PRE and speculation based PRE algorithms that are resource sensitive. These algorithms compute code placements where the functional unit required for the execution of the placed algorithm is available.
Reference: [16] <author> J. Knoop, O. Ruthing, and B. Steffen, </author> <title> "Lazy Code Motion," </title> <booktitle> ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 224-234, </pages> <year> 1992. </year>
Reference-contexts: Thus, in this situation it is beneficial to use the placement shown in Figure 11b. In [9] we describe in detail the combination of code speculation with the PRE optimization <ref> [16, 15] </ref>. Speculation is enabled at conditional nodes based upon cost-benefit analysis. In [10] we present predication based PRE and speculation based PRE algorithms that are resource sensitive. These algorithms compute code placements where the functional unit required for the execution of the placed algorithm is available.
Reference: [17] <author> J. Knoop, O. Ruthing, and B. Steffen, </author> <title> "The Power of Assignment Motion," </title> <booktitle> ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 233-245, </pages> <year> 1995. </year>
Reference: [18] <author> J. Knoop, O. Ruthing, and B. Steffen, </author> <title> "Lazy Strength Reduction," </title> <journal> Journal of Programming Languages, </journal> <volume> 1(1) </volume> <pages> 71-91, </pages> <year> 1993. </year>
Reference-contexts: The approach for cost-benefit analysis that we have presented is quite general and has also been applied to other problems including partial redundancy elimination [9], strength reduction <ref> [18] </ref>, and load-store elimination from loops [3, 8]. The example in Figure 11 illustrates the application of our approach to partial redundancy elimination. In the first flow graph shown in Figure 11a, the evaluation of the expression x + y in node 7 is partially redundant.
Reference: [19] <author> J. Knoop, O. Ruthing, and B. Steffen, </author> <title> "Partial Dead Code Elimination," </title> <booktitle> ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 147-158, </pages> <year> 1994. </year>
Reference-contexts: Through code sinking, that is, delaying the execution of a code statement to later program points, PDE optimization moves instructions that are dead along critical paths off the critical paths <ref> [19, 22] </ref>. Modern architectures [14, 12] that support predicated execution provide an opportunity for aggressively performing PDE since predication enables code sinking that is otherwise not possible. Furthermore, predication enabled code sinking may also introduce predicated versions of an instruction along paths where the instruction was not previously encountered. <p> Thus, in order to beneficially exploit predication enabled code sinking for PDE, it is necessary to develop an approach for trade-off between quality of code along frequently and infrequently executed paths. Existing techniques for PDE <ref> [2, 19] </ref> do not take advantage of predication in performing PDE. <p> Since traditional approaches to PDE remove dead code along some paths without adding additional instructions along any path <ref> [2, 19] </ref>, they are essentially based on the assumption that all paths through the program are equally important. However, our approach which can trade-off the quality of code generated for infrequently executed paths for obtaining better code for frequently executed paths is based upon the realistic scenario encountered in practice. <p> The approach we present first performs data flow analysis for computing the cost and benefit of sinking a statement past each relevant merge point. An extension of a code sinking algorithm by Knoop et al. <ref> [19] </ref> that incorporates predication is presented next. This modified framework uses the cost-benefit information to enable sinking of a partially dead statement past merge points where the benefit has been found to be greater than the cost. <p> The algorithms in this paper use the control flow graph representation of the program. Similar to the assumptions made by Knoop et al. in <ref> [19] </ref>, we also assume that each node in the control flow graph contains a single statement and nodes have been introduced along critical edges to allow code placement along the critical edges. However, this algorithm can be easily extended to apply to basic blocks. <p> (p), Cost s (texit) = T [p?s] fi P p2NLP AT HS x (postexit) F req (p), and N LIV E x (head) = 0. 2.2 Predication based Sinking Framework The framework that we propose is an extension of the partial dead code elimination framework developed by Knoop et al. <ref> [19] </ref>. Knoop's framework involves two main steps that are applied repeatedly till no further optimization is possible. The first step performs assignment sinking to enable dead code elimination and the second step performs assignment elimination to remove dead code.
Reference: [20] <author> S.A. Mahlke, W.Y. Chen, R.A. Bringmann, R.E. Hank, W.W. Hwu, B. Rau, and M. Schlansker, </author> <title> "Sentinel Scheduling for VLIW and Superscalar Processors," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 11(4) </volume> <pages> 376-408, </pages> <month> Nov. </month> <year> 1993. </year>
Reference: [21] <author> G. Ramalingam, </author> <title> "Data Flow Frequency Analysis," </title> <booktitle> ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 267-277, </pages> <year> 1996. </year>
Reference: [22] <author> M.S. Schlansker and V. Kathail, </author> <title> "Critical Path Reduction for Scalar Processors," </title> <booktitle> 28th Annual IEEE/ACM International Symposium on Microarchi-tecture, </booktitle> <address> Ann Arbor, Michigan, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Through code sinking, that is, delaying the execution of a code statement to later program points, PDE optimization moves instructions that are dead along critical paths off the critical paths <ref> [19, 22] </ref>. Modern architectures [14, 12] that support predicated execution provide an opportunity for aggressively performing PDE since predication enables code sinking that is otherwise not possible. Furthermore, predication enabled code sinking may also introduce predicated versions of an instruction along paths where the instruction was not previously encountered.
Reference: [23] <author> B. Steffen, </author> <title> "Data Flow Analysis as Model Checking," </title> <booktitle> Proceedings TACS'91, Sendai, </booktitle> <address> Japan, </address> <publisher> Springer-Verlag, LNCS 526, </publisher> <pages> pages 346-364, </pages> <year> 1991. </year>
References-found: 23

