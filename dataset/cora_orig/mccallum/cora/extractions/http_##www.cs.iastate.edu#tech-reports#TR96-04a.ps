URL: http://www.cs.iastate.edu/tech-reports/TR96-04a.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Protective Interface Specifications Keywords: Protective specifications; Specification languages; Underspecification; Partiality; Larch. Specifications languages, theory, Larch,
Author: Gary T. Leavens and Jeannette M. Wing TR #-a 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: 1996 CR Categories: D.2.1 [Software Engineering] Requirements/  
Date: April 1996, Revised October 1996  
Abstract: Submitted for publication. An earlier version of this paper was called "Protection from the Underspecified". This technical report is also CMU-CS-96-129R. c fl Copyright 1996 by Gary T. Leavens and Jeannette M. Wing. All rights reserved. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D.J. Andrews et al. </author> <title> Information technology programming languages - VDM-SL: First committee draft standard CD1387-1. Document ISO/IEC JTC1/SC22/WG19 N-20, </title> <booktitle> International Standards Organization, </booktitle> <month> November </month> <year> 1993. </year> <month> ftp://gatekeeper.dec.com/pub/standards/vdmsl/. </month>
Reference-contexts: For example, VDM-SL <ref> [17, 1] </ref> uses a logic called LPF [17, Section 3.3] [2, 18], which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K [9], uses a logic having just two logical values, but in which all other types have an improper value, ?, which
Reference: [2] <author> H. Barringer, J. H. Cheng, and C. B. Jones. </author> <title> A logic covering undefinedness in program proofs. </title> <journal> Acta Informatica, </journal> <volume> 21(3) </volume> <pages> 251-269, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: For example, VDM-SL [17, 1] uses a logic called LPF [17, Section 3.3] <ref> [2, 18] </ref>, which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K [9], uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions, and also models
Reference: [3] <author> A. Bijlsma. </author> <title> Semantics of quasi-boolean expressions. </title> <editor> In W. H. J. Feijen et al., editors, </editor> <booktitle> Beauty is Our Business, </booktitle> <pages> pages 27-35. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: In COLD-K there is also a definedness predicate, D, that allows one to explicitly reason about whether a term denotes a proper value or not. Other examples of this approach include <ref> [3, 4, 19, 26] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecification. In such a logic, one avoids specifying a value for undefined terms [12, 16].
Reference: [4] <author> A. Blikle. </author> <title> Three-valued predicates for software specification and validation. </title> <journal> Funda-menta Informaticae, </journal> <volume> XIV:387-410, </volume> <year> 1991. </year>
Reference-contexts: In COLD-K there is also a definedness predicate, D, that allows one to explicitly reason about whether a term denotes a proper value or not. Other examples of this approach include <ref> [3, 4, 19, 26] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecification. In such a logic, one avoids specifying a value for undefined terms [12, 16].
Reference: [5] <author> Andrzej Blikle. </author> <title> The clean termination of iterative programs. </title> <journal> Acta Informatica, </journal> <volume> 16 </volume> <pages> 199-217, </pages> <year> 1981. </year>
Reference-contexts: = fact 0 (k): The proof would proceed by induction on k. 3.2 Exact Predicates For use in proving protection, we define predicates of the form Exact (`E'), based on the form (i.e., the text) of each expression E. (These resemble the domain predicates, Dom (`E'), described by some authors <ref> [11, 8, 5] </ref>. However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial.
Reference: [6] <author> Manfred Broy and Martin Wirsing. </author> <title> Partial abstract types. </title> <journal> Acta Informatica, </journal> <volume> 18(1) </volume> <pages> 47-64, </pages> <month> November </month> <year> 1982. </year>
Reference-contexts: However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial. They also resemble the definedness predicate (D) used in studies of partial algebras <ref> [6] </ref> and in COLD [9]; however D is defined model theoretically, not syntactically, and is not incompletely extended to boolean terms.) The definition of Exact (`') is based on the exact clauses given in the trait's implications (and those of included traits).
Reference: [7] <author> J. H. Cheng and C. B. Jones. </author> <title> On the usability of logics which handle partial functions. </title> <editor> In C. Morgan and J. C. P. Woodcock, editors, </editor> <booktitle> Proceedings of the Third Refinement Workshop, Workshops in Computing Series, </booktitle> <pages> pages 51-69, </pages> <address> Berlin, 1990. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In this paper we consider what protection means with respect to partiality and un-derspecification. Our treatment of protection is not meant to be exhaustive, but merely to illustrate concepts that are useful with some logics that are widely used for formal specification. (See <ref> [7, 12] </ref> for surveys that also cover additional kinds of logics that might be used in formal specification, and hence might need their own concepts of protection.
Reference: [8] <author> D. Coleman and J. W. Hughes. </author> <title> The clean termination of Pascal programs. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 195-210, </pages> <year> 1979. </year> <month> 19 </month>
Reference-contexts: = fact 0 (k): The proof would proceed by induction on k. 3.2 Exact Predicates For use in proving protection, we define predicates of the form Exact (`E'), based on the form (i.e., the text) of each expression E. (These resemble the domain predicates, Dom (`E'), described by some authors <ref> [11, 8, 5] </ref>. However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial.
Reference: [9] <author> L. M. G. Feijs and H. B. M. Jonkers. </author> <title> Formal Specification and Design, </title> <booktitle> volume 35 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1992. </year>
Reference-contexts: For example, VDM-SL [17, 1] uses a logic called LPF [17, Section 3.3] [2, 18], which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K <ref> [9] </ref>, uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions, and also models computations that go into infinite loops or cause errors. <p> However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial. They also resemble the definedness predicate (D) used in studies of partial algebras [6] and in COLD <ref> [9] </ref>; however D is defined model theoretically, not syntactically, and is not incompletely extended to boolean terms.) The definition of Exact (`') is based on the exact clauses given in the trait's implications (and those of included traits).
Reference: [10] <author> Stephen J. Garland, John V. Guttag, and James J. Horning. </author> <title> Debugging Larch Shared Language specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(6) </volume> <pages> 1044-1057, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The concept of an exact term is based on an extension to LSL that allows one to specify which terms are not intended to be underspecified. This extension to LSL provides better documentation and allows enhanced debugging (in the sense of <ref> [10] </ref> [13, Chapter 7]) of LSL specifications. uses IntSetTrait; int pick (IntSet s) - requires size (s^) &gt; 0; ensures result = choose (s^) ^ s' = delete (choose (s^), s^); - 13 Level Facts Trait exact ) completely-defined Lemma 3.2 completely-defined 6= convertible Figure 7 BISL exact ) underspec-protective Corollary <p> B.1 Conversion In a LSL trait, one can state redundant properties (theorems) that one believes do (or should) hold. These redundant properties are stated in the implies section of the specification. Proofs of such properties can be attempted, and are a way of debugging the trait <ref> [10] </ref> [13, Chapter 7]. For our purposes, the most interesting kind of redundant property one can state in the implies section is that an operator is well-defined with respect to other operators. This is done by using a converts clause, as was done in Figure 14.
Reference: [11] <author> Steven M. </author> <title> German. Automating proofs of the absence of common runtime errors. </title> <booktitle> In Conference record of the Fifth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 105-118. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1978. </year>
Reference-contexts: = fact 0 (k): The proof would proceed by induction on k. 3.2 Exact Predicates For use in proving protection, we define predicates of the form Exact (`E'), based on the form (i.e., the text) of each expression E. (These resemble the domain predicates, Dom (`E'), described by some authors <ref> [11, 8, 5] </ref>. However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial.
Reference: [12] <author> David Gries and Fred B. Schneider. </author> <title> Avoiding the undefined by underspecification. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Computer Science Today: Recent Trends and Developments, number 1000 in Lecture Notes in Computer Science, </booktitle> <pages> pages 366-373. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: In this paper we consider what protection means with respect to partiality and un-derspecification. Our treatment of protection is not meant to be exhaustive, but merely to illustrate concepts that are useful with some logics that are widely used for formal specification. (See <ref> [7, 12] </ref> for surveys that also cover additional kinds of logics that might be used in formal specification, and hence might need their own concepts of protection. <p> Other examples of this approach include [3, 4, 19, 26]. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecification. In such a logic, one avoids specifying a value for undefined terms <ref> [12, 16] </ref>. In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove what its value is. <p> For example, head (empty) denotes some element of the appropriate type, even if the user has not specified what element that term denotes. Where an LSL specification is silent, terms take on some (unspecified) value. In common with other logics that use underspecification to avoid the undefined <ref> [12] </ref>, the logic of LSL is classical, and thus has several pleasing formal properties. However, as Jones pointed out in a recent paper [16], there are a few subtle aspects to this kind of logic that users should be aware of. <p> For example, one can writing factTrait as in Figure 5, where the equation for the recursive case is only postulated to hold for its intended domain <ref> [12] </ref>.
Reference: [13] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: In such a logic, one avoids specifying a value for undefined terms [12, 16]. In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove what its value is. For example, the Larch family BISLs <ref> [13] </ref> use a mathematical component, LSL [13, Chapter 4] [14], which has this kind of logic. (See Appendix A for more about underspecification and its relation to LSL.) The BISLs of the RESOLVE family [22] also use this kind of logic. <p> In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove what its value is. For example, the Larch family BISLs [13] use a mathematical component, LSL <ref> [13, Chapter 4] </ref> [14], which has this kind of logic. (See Appendix A for more about underspecification and its relation to LSL.) The BISLs of the RESOLVE family [22] also use this kind of logic. <p> Finally we define the notion of underspec-protection itself. The notion of a primed trait and term is a variation of the idea of "priming" traits and terms found in the Larch Prover (where it is used in proving that an operator is "converted" <ref> [13, pp. 142-4] </ref>). Definition 2.2 (Primed Trait, T 0 ) Let T be an LSL trait. <p> Then the trait factTrait 0 has fact replaced by fact 0 , but true and the boolean operators are not primed, and neither are 0, pred, and succ, because they are mentioned in the generated by clause of the trait Integer <ref> [13, p. 161] </ref>. (Operators mentioned in a generated by clause are meant to be a canonical way to describe values of a given sort; two ways to describe such values cannot both be canonical.) Similarly, if P is a term in the language of T , then let P 0 be <p> is no way to separate underspecification that is used to make operators "partial" from underspecification that is used to make specifications intentionally less constraining, as in a choose operator for sets. 3 A trait is a specification of mathematical vocabulary in an augmented form of first-order logic with equality; see <ref> [13, Chapter 4] </ref> for details. 6 factTrait: trait includes Integer introduces fact: Int ! Int asserts 8 i: Int fact (0) == 1; (i &gt; 0) ) fact (i) == i * fact (i-1); Trivial examples of completely-defined terms include variables, because in each trait T , T ` 8x : <p> A more interesting example is that, for factTrait, the term fact (27) is completely-defined, but both fact (-1) and fact (x), where x:Int, are not. As another example, the term choose (f1g [ f2g) is not completely-defined for the trait ChoiceSet (of <ref> [13, p. 176] </ref>). The following definition of when a procedure specification is protective says, in essence, that the precondition must be completely-defined for the used trait, and that whenever the precondition holds, then the postcondition must be completely-defined. <p> This is done by using a converts clause. A converts clause says that the axioms of the trait uniquely define the operators named in the clause, "relative to the other operators in the trait" <ref> [13, p. 142] </ref>. (See Appendix B for a more complete explanation of conversion.) Unfortunately, proving that an LSL operator is converted does not mean it is completely-defined; it may still be underspecified. For example, consider the trait in Figure 7. <p> The concept of an exact term is based on an extension to LSL that allows one to specify which terms are not intended to be underspecified. This extension to LSL provides better documentation and allows enhanced debugging (in the sense of [10] <ref> [13, Chapter 7] </ref>) of LSL specifications. uses IntSetTrait; int pick (IntSet s) - requires size (s^) &gt; 0; ensures result = choose (s^) ^ s' = delete (choose (s^), s^); - 13 Level Facts Trait exact ) completely-defined Lemma 3.2 completely-defined 6= convertible Figure 7 BISL exact ) underspec-protective Corollary 3.4 <p> head (empty) is "undefined.") 14 JonesExample1: trait includes Integer introduces it: ! OneElem f: Int ! OneElem asserts OneElem generated by it 8 i: Int f (i) == if i=0 then it else f (i-1) implies converts f: Int ! OneElem The logic used by the Larch Shared Language (LSL) <ref> [13, Chapter 4] </ref> [14] deals with partiality by using underspecification. As noted in the main body, this means that one avoids specifying a value for undefined terms, but the logic assumes that all functions are total. <p> B.1 Conversion In a LSL trait, one can state redundant properties (theorems) that one believes do (or should) hold. These redundant properties are stated in the implies section of the specification. Proofs of such properties can be attempted, and are a way of debugging the trait [10] <ref> [13, Chapter 7] </ref>. For our purposes, the most interesting kind of redundant property one can state in the implies section is that an operator is well-defined with respect to other operators. This is done by using a converts clause, as was done in Figure 14. <p> This is done by using a converts clause, as was done in Figure 14. A converts clause says that the axioms of the trait uniquely define the operators named in the clause, "relative to the other operators in the trait" <ref> [13, p. 142] </ref>. To prove this, one must show it for all possible arguments. The Larch Prover (LP) uses the following proof technique [13, pp. 142-4]. Let T ( ~ f) be a trait, which names operators ~ f in converts clauses in its implies section. <p> A converts clause says that the axioms of the trait uniquely define the operators named in the clause, "relative to the other operators in the trait" [13, p. 142]. To prove this, one must show it for all possible arguments. The Larch Prover (LP) uses the following proof technique <ref> [13, pp. 142-4] </ref>. Let T ( ~ f) be a trait, which names operators ~ f in converts clauses in its implies section. <p> B.2 An extension to LSL The exempting clause in the current LSL <ref> [13, Chapter 4] </ref> [14] does not have enough expressive power to state, in general, what is left underspecified. One can only exempt a class of terms that are described by constants or universally quantified variables.
Reference: [14] <author> John V. Guttag, James J. Horning, and Andres Modet. </author> <title> Report on the Larch Shared Language: Version 2.3. </title> <type> Technical Report 58, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> April </month> <year> 1990. </year> <title> Order from src-report@src.dec.com. </title>
Reference-contexts: In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove what its value is. For example, the Larch family BISLs [13] use a mathematical component, LSL [13, Chapter 4] <ref> [14] </ref>, which has this kind of logic. (See Appendix A for more about underspecification and its relation to LSL.) The BISLs of the RESOLVE family [22] also use this kind of logic. <p> "undefined.") 14 JonesExample1: trait includes Integer introduces it: ! OneElem f: Int ! OneElem asserts OneElem generated by it 8 i: Int f (i) == if i=0 then it else f (i-1) implies converts f: Int ! OneElem The logic used by the Larch Shared Language (LSL) [13, Chapter 4] <ref> [14] </ref> deals with partiality by using underspecification. As noted in the main body, this means that one avoids specifying a value for undefined terms, but the logic assumes that all functions are total. <p> B.2 An extension to LSL The exempting clause in the current LSL [13, Chapter 4] <ref> [14] </ref> does not have enough expressive power to state, in general, what is left underspecified. One can only exempt a class of terms that are described by constants or universally quantified variables.
Reference: [15] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: It also seems that the draft standard for Z <ref> [15, 24] </ref>, has decided to use this kind of logic [27]. It is not the purpose of this paper to advocate one kind of logic over another. Instead, this paper explores concepts of protection, with the aim of improving intuition about it and providing more guidance to specifiers.
Reference: [16] <author> C.B. Jones. </author> <title> Partial functions and logics: A warning. </title> <journal> Information Processing Letters, </journal> <volume> 54(2) </volume> <pages> 65-67, </pages> <year> 1995. </year>
Reference-contexts: Other examples of this approach include [3, 4, 19, 26]. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecification. In such a logic, one avoids specifying a value for undefined terms <ref> [12, 16] </ref>. In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove what its value is. <p> Where an LSL specification is silent, terms take on some (unspecified) value. In common with other logics that use underspecification to avoid the undefined [12], the logic of LSL is classical, and thus has several pleasing formal properties. However, as Jones pointed out in a recent paper <ref> [16] </ref>, there are a few subtle aspects to this kind of logic that users should be aware of. We translate Jones's first example into the LSL trait shown in Figure 14. This trait defines a sort, OneElem, a constant it, and a function f. <p> This trait defines a sort, OneElem, a constant it, and a function f. Because of the generated by clause, the sort OneElem has only one element, the constant it. (The current version of LSL allows such sorts, contrary to <ref> [16] </ref>.) In LSL f (-1) = it, because f has to take on some value when applied to -1, and the only possible value is it.
Reference: [17] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: For example, VDM-SL <ref> [17, 1] </ref> uses a logic called LPF [17, Section 3.3] [2, 18], which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K [9], uses a logic having just two logical values, but in which all other types have an improper value, ?, which <p> For example, VDM-SL [17, 1] uses a logic called LPF <ref> [17, Section 3.3] </ref> [2, 18], which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K [9], uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions,
Reference: [18] <author> Cliff B. Jones and Kees Middelburg. </author> <title> A typed logic of partial functions reconstructed classically. </title> <journal> Acta Informatica, </journal> <volume> 31(5) </volume> <pages> 399-430, </pages> <year> 1994. </year>
Reference-contexts: For example, VDM-SL [17, 1] uses a logic called LPF [17, Section 3.3] <ref> [2, 18] </ref>, which has three logical values and two kinds of equality. 1 As another example, the specification languages COLD-K [9], uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions, and also models
Reference: [19] <author> B. Konikowska, A. Tarlecki, and A. Blikle. </author> <title> A three-valued logic for software specification and validation. </title> <note> Fundamenta Informaticae, XIV:411-453, </note> <year> 1991. </year>
Reference-contexts: In COLD-K there is also a definedness predicate, D, that allows one to explicitly reason about whether a term denotes a proper value or not. Other examples of this approach include <ref> [3, 4, 19, 26] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecification. In such a logic, one avoids specifying a value for undefined terms [12, 16].
Reference: [20] <author> Gary T. Leavens. </author> <note> Larch/C++ Reference Manual. Version 4.16. Available in ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz or on the world wide web at the URL http://www.cs.iastate.edu/~leavens/larchc++.html, July 1996. </note>
Reference-contexts: This behavioral interface specification is to be implemented in C++, which explains the C++ syntax used to specify how it is to be called. The informal pre-and postconditions follow requires and ensures, respectively. (The keyword informally in Larch/C++ <ref> [20] </ref> signals the start of an informal predicate.) This specification is ill-defined, because it is not clear what the procedure should return when x is negative.
Reference: [21] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: Checks that a VDM-SL procedure is underspec-protective can be done in same way as we described them for the Larch family. Both kinds of protection may also be useful for writers of executable specifications. For example, in a language like Eiffel <ref> [21] </ref>, partiality-protection for a procedure would ensure that its precondition would be flagged as false instead of encountering an error, allowing an error to happen in its body, or encountering an error in its postcondition.
Reference: [22] <author> William F. Ogden, Murali Sitaraman, Bruce W. Weide, and Stuart H. </author> <title> Zweben. Part I: The RESOLVE framework and discipline | a research synopsis. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 19(4) </volume> <pages> 23-28, </pages> <month> Oct </month> <year> 1994. </year> <month> 20 </month>
Reference-contexts: For example, the Larch family BISLs [13] use a mathematical component, LSL [13, Chapter 4] [14], which has this kind of logic. (See Appendix A for more about underspecification and its relation to LSL.) The BISLs of the RESOLVE family <ref> [22] </ref> also use this kind of logic. It also seems that the draft standard for Z [15, 24], has decided to use this kind of logic [27]. It is not the purpose of this paper to advocate one kind of logic over another.
Reference: [23] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Also PVS <ref> [23] </ref> represents another kind of specification logic that should be considered in extending our concepts.) The first concept of protection we discuss is appropriate for behavioral interface specification languages (BISLs) that use a logic that accepts the existence of partial functions and has various non-classical ways to reason about them.
Reference: [24] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: It also seems that the draft standard for Z <ref> [15, 24] </ref>, has decided to use this kind of logic [27]. It is not the purpose of this paper to advocate one kind of logic over another. Instead, this paper explores concepts of protection, with the aim of improving intuition about it and providing more guidance to specifiers.
Reference: [25] <author> Jeannette Marie Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: * fact (i-1) FACTORIAL (x: int) result: int pre 0 x ^ x 8 post result = fact (x) factorial in VDM-SL. (Note that the factorial of 9 is larger than 2 16 .) 2 Protective Procedure Specifications The idea of protection in a BISL was first formulated by Wing <ref> [25, Section 5.1.4] </ref>.
Reference: [26] <author> U. Wolter, K. Didrich, F. Cornelius, M. Klar, R. Wessaly, and H. Ehrig. </author> <title> How to cope with the spectrum of spectrum. </title> <editor> In Manfred Broy and Stefan Jahnichen, editors, KORSO: </editor> <booktitle> Methods, Languages and Tools for the Construction of Correct Software, volume 1009 of Lecture Notes in Computer Science, </booktitle> <pages> pages 173-189. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: In COLD-K there is also a definedness predicate, D, that allows one to explicitly reason about whether a term denotes a proper value or not. Other examples of this approach include <ref> [3, 4, 19, 26] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecification. In such a logic, one avoids specifying a value for undefined terms [12, 16].
Reference: [27] <author> Jim Woodcock and Daniel Jackson. </author> <title> About the semantics of partial functions in Z. </title> <type> Personal communication, </type> <month> April </month> <year> 1996. </year>
Reference-contexts: It also seems that the draft standard for Z [15, 24], has decided to use this kind of logic <ref> [27] </ref>. It is not the purpose of this paper to advocate one kind of logic over another. Instead, this paper explores concepts of protection, with the aim of improving intuition about it and providing more guidance to specifiers.
References-found: 27

