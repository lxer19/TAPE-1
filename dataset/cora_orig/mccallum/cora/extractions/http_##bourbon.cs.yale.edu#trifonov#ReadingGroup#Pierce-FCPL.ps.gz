URL: http://bourbon.cs.yale.edu/trifonov/ReadingGroup/Pierce-FCPL.ps.gz
Refering-URL: http://bourbon.cs.yale.edu/trifonov/ReadingGroup/
Root-URL: http://www.cs.yale.edu
Title: Foundational Calculi for Programming Languages  
Author: Benjamin C. Pierce 
Date: December 22, 1995  
Affiliation: of Computer Science and Engineering]  
Note: [To appear in the CRC Handbook  
Abstract-found: 0
Intro-found: 1
Reference: [ Baeten and Weijland, 1990 ] <author> J. C. M. Baeten and W. P. Weijland. </author> <title> Process Algebra. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 18. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: CSP embodies similar ideas in the form of both a theory and a programming language (Occam). Other members of the family include the variant of CCS described in Hennessy's Algebraic Theory of Processes [ Hennessey, 1988 ] , and Bergstra, Klop, and Baeten's systems, collectively called ACP <ref> [ Baeten and Weijland, 1990 ] </ref> .
Reference: [ Barendregt, 1984 ] <author> H. P. Barendregt. </author> <title> The Lambda Calculus. </title> <address> North Holland, </address> <note> revised edition, </note> <year> 1984. </year>
Reference: [ Barendregt, 1990 ] <author> H. P. Barendregt. </author> <title> Functional programming and lambda calculus. </title> <booktitle> In van Leeuwen [ 1990 ] , chapter 7, </booktitle> <pages> pages 321-364. </pages>
Reference: [ Cleaveland et al., 1993 ] <author> Rance Cleaveland, Joachim Parrow, and Bernhard Steffen. </author> <title> The Concurrency Workbench: A semantics-based tool for the verification of concurrent systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Process calculi are widely used for specification and verification of concurrent systems, especially of communication protocols, both manually and with support from tools such as the Edinburgh Concurrency Workbench <ref> [ Cleaveland et al., 1993 ] </ref> . Numerous programming languages have combined the concurrency primitives of process calculi with more conventional features for sequential programming; well-known examples include Amber, Concurrent ML, and Facile. The "bare" pi-calculus is used the basis of the Pict language.
Reference: [ Davis, 1982 ] <author> Martin Davis. </author> <title> Computability and Unsolvability. </title> <publisher> Dover, </publisher> <year> 1982. </year> <note> Previous edition 1958. </note>
Reference-contexts: function definition and application in a clear, intuitive way, but all other known models of functional computation | Turing Machines, general recursive functions, control structures such as while and goto, etc. | can be shown to describe exactly the same class of functions. (For a survey of these results, see <ref> [ Davis, 1982 ] </ref> .) For concurrent and distributed systems, no such canonical model has yet emerged. Instead, many different "process calculi" are being studied, each embodying some particular set of primitives for concurrent computation.
Reference: [ Gordon, 1994 ] <author> Andrew D. Gordon. </author> <title> Functional Programming and Input/Output. </title> <publisher> Cambridge University Press, </publisher> <year> 1994. </year>
Reference-contexts: mathematical function of some carefully chosen sort) in such a way that two lambda-expressions have equivalent operational behavior if and only if they denote the same element of the model. 10 Operational notions of program equivalence such as applicative bisimulation have begin to recieve serious attention only relatively recently (e.g. <ref> [ Gordon, 1994 ] </ref> ). Implementation techniques for programming languages based on the lambda-calculus have a long history, from Landin's original "SECD machine" to more modern proposals such as the G-machine [ Peyton Jones and Lester, 1992 ] .
Reference: [ Groote and Vaandrager, 1992 ] <author> J.F. Groote and F.W. Vaandrager. </author> <title> Structured operational semantics and bisimulation as a congruence. </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 202-260, </pages> <year> 1992. </year>
Reference-contexts: The rapidly growing number of process calculi has led to interest in taxonomic frameworks such as Generalized Structured Operational Semantics <ref> [ Groote and Vaandrager, 1992 ] </ref> and action structures [ Milner, 1995 ] , in which many different process calculi can be embedded and their properties compared.
Reference: [ Gunter and Scott, 1990 ] <author> C. A. Gunter and D. S. Scott. </author> <title> Semantic domains. </title> <booktitle> In van Leeuwen [ 1990 ] , chapter 12, </booktitle> <pages> pages 633-674. </pages>
Reference-contexts: 2.5 Research Areas The study of denotational semantic models of the lambda-calculus and related systems has led to a rich research literature, surveyed in textbooks by BarendregtBarendregt, Gunter [ 1992 ] , Schmidt [ 1986 ] , and Winskel [ 1993 ] and a shorter article by Gunter and Scott <ref> [ Gunter and Scott, 1990 ] </ref> .
Reference: [ Gunter, 1992 ] <author> C. A. Gunter. </author> <title> Semantics of Programming Languages: Structures and Techniques. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference: [ Hennessey, 1988 ] <author> Matthew Hennessey. </author> <title> Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: CSP embodies similar ideas in the form of both a theory and a programming language (Occam). Other members of the family include the variant of CCS described in Hennessy's Algebraic Theory of Processes <ref> [ Hennessey, 1988 ] </ref> , and Bergstra, Klop, and Baeten's systems, collectively called ACP [ Baeten and Weijland, 1990 ] .
Reference: [ Hindley and Seldin, 1986 ] <author> J. Roger Hindley and Jonathan P. Seldin. </author> <title> Introduction to Combinators and -Calculus, volume 1 of London Mathematical Society Student Texts. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference: [ Hoare, 1985 ] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: The first historically, and among the most thoroughly studied, are Milner's Calculus of Communicating Systems, CCS [ Milner, 1980, Milner, 1989 ] , and Hoare's Communicating Sequential Processes, CSP <ref> [ Hoare, 1985 ] </ref> . CCS is the direct predecessor of the pi-calculus: it can be described informally as the "static" fragment of the pi-calculus where the messages exchanged during communication do not contain any data (i.e. every output is of the form xhi: P ).
Reference: [ Jones et al., 1993 ] <author> Niel D. Jones, Carsten K. Gomard, and Peter Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1993. </year>
Reference-contexts: A related theoretical development is work on "optimal" reduction strategies, which try to choose redexes so as to reach a normal form as quickly as possible. The lambda-calculus forms a common basis for work on optimization techniques such as partial evaluation <ref> [ Jones et al., 1993 ] </ref> ; related notations are being used as intermediate languages in optimizing compilers for high-level languages such as C.
Reference: [ Milner et al., 1992 ] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes (Parts I and II). </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-77, </pages> <year> 1992. </year>
Reference-contexts: ! P j [y=z]Q communication P j R ! Q j R if P ! Q reduction under j (-x)P ! (-x)Q if P ! Q reduction under - P ! Q if P P 0 ! Q 0 Q structural congruence calculus (or -calculus) of Milner, Parrow, and Walker <ref> [ Milner et al., 1992, Milner, 1991 ] </ref> . References to some other popular process calculi can be found at the end of the section.
Reference: [ Milner, 1980 ] <author> Robin Milner. </author> <title> A Calculus of Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1980. </year>
Reference-contexts: The first historically, and among the most thoroughly studied, are Milner's Calculus of Communicating Systems, CCS <ref> [ Milner, 1980, Milner, 1989 ] </ref> , and Hoare's Communicating Sequential Processes, CSP [ Hoare, 1985 ] .
Reference: [ Milner, 1989 ] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: The first historically, and among the most thoroughly studied, are Milner's Calculus of Communicating Systems, CCS <ref> [ Milner, 1980, Milner, 1989 ] </ref> , and Hoare's Communicating Sequential Processes, CSP [ Hoare, 1985 ] .
Reference: [ Milner, 1990 ] <author> R. Milner. </author> <title> Operational and algebraic semantics of concurrent processes. </title> <booktitle> In van Leeuwen [ 1990 ] , chapter 19, </booktitle> <pages> pages 1201-1242. </pages>
Reference: [ Milner, 1991 ] <author> Robin Milner. </author> <title> The polyadic -calculus: a tutorial. </title> <type> Technical Report ECS-LFCS-91-180, </type> <institution> Laboratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh, UK, </institution> <month> October </month> <year> 1991. </year> <booktitle> Proceedings of the International Summer School on Logic and Algebra of Specification, Marktoberdorf, </booktitle> <month> August </month> <year> 1991. </year> <title> Reprinted in Logic and Algebra of Specification, </title> <editor> ed. F. L. Bauer, W. Brauer, and H. Schwichtenberg, </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: ! P j [y=z]Q communication P j R ! Q j R if P ! Q reduction under j (-x)P ! (-x)Q if P ! Q reduction under - P ! Q if P P 0 ! Q 0 Q structural congruence calculus (or -calculus) of Milner, Parrow, and Walker <ref> [ Milner et al., 1992, Milner, 1991 ] </ref> . References to some other popular process calculi can be found at the end of the section.
Reference: [ Milner, 1995 ] <author> Robin Milner. </author> <title> Calculi for interaction. </title> <journal> Acta Informatica, </journal> <note> 1995. To appear. </note>
Reference-contexts: The rapidly growing number of process calculi has led to interest in taxonomic frameworks such as Generalized Structured Operational Semantics [ Groote and Vaandrager, 1992 ] and action structures <ref> [ Milner, 1995 ] </ref> , in which many different process calculi can be embedded and their properties compared.
Reference: [ Peyton Jones and Lester, 1992 ] <author> Simon L. Peyton Jones and David R. Lester. </author> <title> Implementing Functional Languages. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Implementation techniques for programming languages based on the lambda-calculus have a long history, from Landin's original "SECD machine" to more modern proposals such as the G-machine <ref> [ Peyton Jones and Lester, 1992 ] </ref> . A related theoretical development is work on "optimal" reduction strategies, which try to choose redexes so as to reach a normal form as quickly as possible.
Reference: [ Plotkin, 1975 ] <author> Gordon Plotkin. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: A reduction strategy is a rule specifying which redexes should be reduced first. There are several common reduction strategies (a classic comparison is <ref> [ Plotkin, 1975 ] </ref> ). The normal-order reduction strategy, sometimes called call-by-name reduction, always reduces the redex whose appears the furthest to the left.
Reference: [ Schmidt, 1986 ] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, </publisher> <year> 1986. </year>
Reference: [ Tennent, 1981 ] <author> R. D. Tennent. </author> <booktitle> Principles of Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: 1 Introduction In the mid 1960s, Landin observed that a complex programming language can be understood in terms of a tiny "core language" capturing the essential mechanisms of some programming, style together with a collection of convenient "derived forms" whose behavior is understood by translating them into the core (cf. <ref> [ Tennent, 1981 ] </ref> ). Landin's core language was the lambda-calculus, a formal system in which all computation is reduced to the basic operations of function definition and application.
Reference: [ van Glabbeek, 1993 ] <author> R. J. van Glabbeek. </author> <title> The linear time branching time spectrum II (the semantics of sequential systems with silent moves). </title> <booktitle> In Proceedings of CONCUR '93, </booktitle> <pages> pages 66-81, </pages> <year> 1993. </year>
Reference-contexts: For denotational approaches, the problem is finding a pragmatically satisfying definition of "real processes." For operational approaches, the (related) problem is that there are many possible definitions of "behavior," yielding numerous, subtly different, equivalences <ref> [ van Glabbeek, 1993 ] </ref> . So far, operational techniques have proved most successful, but both remain active research areas. As in lambda-calculus, the most intuitive way of defining operational equivalence is via some notion of contextual equivalence.
Reference: [ van Leeuwen, 1990 ] <editor> Jan van Leeuwen, editor. </editor> <booktitle> Handbook of Theoretical Computer Science, Volume B. </booktitle> <publisher> Elsevier / MIT Press, </publisher> <year> 1990. </year>

References-found: 25

