URL: http://www.cs.cornell.edu/Info/People/kreitz/PS-files/98-Communicate.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/kreitz/Abstracts/98-Communicate.html
Root-URL: 
Email: fkreitz,hayden,jyhg@cs.cornell.edu  
Title: A Proof Environment for the Development of Group Communication Systems  
Author: Christoph Kreitz Mark Hayden Jason Hickey 
Address: Ithaca, NY 14853-7501, U.S.A.  
Affiliation: Department of Computer Science, Cornell University  
Abstract: C. & H. Kirchner, ed. 15 th International Conference on Automated Deduction, LNAI xxx, pp. ??-??, Springer Verlag, 1998. Abstract. We present a theorem proving environment for the development of reliable and efficient group communication systems. Our approach makes methods of automated deduction applicable to the implementation of real-world systems by linking the Ensemble group communication toolkit to the NuPRL proof development system. We present tools for importing Ensemble's code into NuPRL and exporting it back into the programming environment. We discuss techniques for reasoning about critical properties of Ensemble as well as verified strategies for reconfiguring the Ensemble system in order to improve its performance in concrete applications.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Archer & C. Heitmeyer. </author> <title> Mechanical verification of timed automata: A case study. </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <address> Washington, DC, </address> <year> 1997. </year>
Reference-contexts: Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult [3, 5]. While in principle it is possible to prove the correctness of theoretical algorithms <ref> [19, 18, 1, 20] </ref> it is very difficult to transform these idealizations into implementations that can actually be used in real systems. Finally, the formalization barrier prevents formal tools for checking software correctness from being used to maximum benefit. <p> It is based on a formalization of a subset of the programming language Ocaml for which we have developed a type-theoretical semantics. Recent work on the specification and verification of timed automata <ref> [17, 1] </ref>, fault-tolerant systems [20], and protocol stacks for group communication systems [8] has demonstrated that formal reasoning about complex distributed algorithms is feasible.
Reference: 2. <author> W. Bibel, D. Korn, C. Kreitz, F. Kurucz, J. Otten, S. Schmitt, G. Stolpmann. </author> <title> A multi-level approach to program synthesis. </title> <booktitle> In Seventh International Workshop on Logic Program Synthesis and Transformation, </booktitle> <publisher> LNAI, Springer Verlag, </publisher> <year> 1998. </year>
Reference-contexts: For this purpose we will integrate additional tools from the field of automated deduction, such as an extended typechecking algorithm 2 This methodology has already been used successfully for program synthesis <ref> [13, 2] </ref>. [10], a proof procedure for first-order logic [15], and a proof planner for induc-tive proofs [2] into the logical programming environment. Furthermore, we are extending our formal database by verified theorems about major reconfiguration and verification steps, which we can then use as derived inference rules. <p> For this purpose we will integrate additional tools from the field of automated deduction, such as an extended typechecking algorithm 2 This methodology has already been used successfully for program synthesis [13, 2]. [10], a proof procedure for first-order logic [15], and a proof planner for induc-tive proofs <ref> [2] </ref> into the logical programming environment. Furthermore, we are extending our formal database by verified theorems about major reconfiguration and verification steps, which we can then use as derived inference rules. We aim at a modularization of the formal database in order to speed up the search for applicable lemmas.
Reference: 3. <author> K. Birman. </author> <title> Building Secure and Reliable Network Applications. </title> <publisher> Manning Publishing Company and Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction Group communication via computer networks is used in a wide range of applications <ref> [3] </ref>. Over the past years the development of a secure and reliable communications infrastructure has become increasingly important. But the current networks are inadequate to support safety-critical applications because considerable technical challenges have not been overcome yet. First, there is the performance cost of modularity. <p> But when modules are combined in a restricted context, much of the code becomes useless or redundant, leading to unnecessary large execution times. Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult <ref> [3, 5] </ref>. While in principle it is possible to prove the correctness of theoretical algorithms [19, 18, 1, 20] it is very difficult to transform these idealizations into implementations that can actually be used in real systems.
Reference: 4. <author> K. Birman & R. van Renesse. </author> <title> Reliable Distributed Computing with the Isis Toolkit. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: The first system, Isis <ref> [4] </ref>, became one of the first widely adopted technologies in this area and found its way into Stock Exchanges, Air Traffic Control Systems, and other safety-critical applications.
Reference: 5. <author> T. Chandra, V. Hadzilacos, S. Toueg, B. Charron-Bost. </author> <title> On the impossibility of group membership. </title> <booktitle> 15th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 322-330, </pages> <year> 1996. </year>
Reference-contexts: But when modules are combined in a restricted context, much of the code becomes useless or redundant, leading to unnecessary large execution times. Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult <ref> [3, 5] </ref>. While in principle it is possible to prove the correctness of theoretical algorithms [19, 18, 1, 20] it is very difficult to transform these idealizations into implementations that can actually be used in real systems.
Reference: 6. <author> R. Constable, et. al., </author> <title> Implementing Mathematics with the NuPRL proof development system. </title> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: In this paper we address these problems by showing how to make methods of automated deduction applicable to the implementation of a real-world system. Our approach links Ensemble [11], a flexible group communication toolkit, to NuPRL <ref> [6] </ref>, a proof system for mathematical reasoning about programs and for rewriting them into equivalent, but more efficient ones. <p> Fig. 1. Verifying and reconfiguring communication systems in NuPRL The NuPRL proof development system <ref> [6] </ref> is a framework for mathematical reasoning about programs and secure program transformations. Proof strategies, or tactics, can be tailored to follow the particular style of reasoning in distributed systems.
Reference: 7. <author> D. de Rauglaudre. </author> <note> Camlp4 version 1.06. </note> <institution> Institut National de Recherche en Informatique et en Automatique, </institution> <year> 1997. </year>
Reference-contexts: These generators will create appropriate terms and store all declared functions and types as new abstractions in NuPRL's library. In order to ensure faithfulness wrt. the Ocaml programming environment we chose the Camlp4 parser-preprocessor <ref> [7] </ref>, an isolated version of the original Ocaml-parser, as a tool for analyzing program text. Camlp4 generates an abstract syntax tree and Fig. 2. Translating between Ocaml and NuPRL: general methodology then calls an output module for further processing (e.g. pretty-printing or dumping the binary). <p> The module generates pieces of text for each node of the syntax tree, distinguishing the various kinds of identifiers, expressions, patterns, types, signature items, and module expressions according to the Ocaml specification <ref> [7, Appendix A] </ref>. Since a parser is restricted to a syntactical analysis of a single text file it cannot solve problems that arise when linking the code of several modules.
Reference: 8. <author> A. Fekete, N. Lynch, A. Shvartsman. </author> <title> Specifying and using a partitionable group communication service. </title> <booktitle> In 16th ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1997. </year>
Reference-contexts: It is based on a formalization of a subset of the programming language Ocaml for which we have developed a type-theoretical semantics. Recent work on the specification and verification of timed automata [17, 1], fault-tolerant systems [20], and protocol stacks for group communication systems <ref> [8] </ref> has demonstrated that formal reasoning about complex distributed algorithms is feasible. Our approach, however, is the first to make the code of a real-world communication system available for formal reasoning and to combine both verification and code reconfiguration within a single formal framework.
Reference: 9. <author> M. Gordon, R. Milner, C. Wadsworth. </author> <title> Edinburgh LCF: A mechanized Logic of Computation. </title> <publisher> LNCS 78, Springer Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Concerns about the reliability of such a technology base for truly secure networked applications led to the implementation of Ensemble [11, 12], which is based on Horus but coded almost entirely in the high-level programming language Ocaml [16], a member of the ML <ref> [9] </ref> language family with a clean semantics. Due to the use of ML, Ensemble turned out to be one of the most scalable and portable, but also one of the fastest existing reliable multicast systems.
Reference: 10. <author> O. Hafzo~gullar & C. </author> <title> Kreitz. Dead Code Elimination Through Type Inference. </title> <type> Technical Report TR 98-1698, </type> <institution> Cornell University, </institution> <year> 1998. </year>
Reference-contexts: For this purpose we will integrate additional tools from the field of automated deduction, such as an extended typechecking algorithm 2 This methodology has already been used successfully for program synthesis [13, 2]. <ref> [10] </ref>, a proof procedure for first-order logic [15], and a proof planner for induc-tive proofs [2] into the logical programming environment. Furthermore, we are extending our formal database by verified theorems about major reconfiguration and verification steps, which we can then use as derived inference rules.
Reference: 11. <author> M. Hayden. </author> <title> Ensemble Reference Manual. </title> <institution> Cornell University, </institution> <year> 1996. </year>
Reference-contexts: Few of these tools are integrated into software development environments, nor can they be flexibly and interactively invoked. In this paper we address these problems by showing how to make methods of automated deduction applicable to the implementation of a real-world system. Our approach links Ensemble <ref> [11] </ref>, a flexible group communication toolkit, to NuPRL [6], a proof system for mathematical reasoning about programs and for rewriting them into equivalent, but more efficient ones. <p> However, reconfiguring Horus protocol stacks is difficult and error prone because its layers are written in C and they are too complex to reason about. Concerns about the reliability of such a technology base for truly secure networked applications led to the implementation of Ensemble <ref> [11, 12] </ref>, which is based on Horus but coded almost entirely in the high-level programming language Ocaml [16], a member of the ML [9] language family with a clean semantics.
Reference: 12. <institution> The Ensemble distributed communication system. </institution> <note> System distribution and related information. http://www.cs.cornell.edu/Info/Projects/Ensemble </note>
Reference-contexts: However, reconfiguring Horus protocol stacks is difficult and error prone because its layers are written in C and they are too complex to reason about. Concerns about the reliability of such a technology base for truly secure networked applications led to the implementation of Ensemble <ref> [11, 12] </ref>, which is based on Horus but coded almost entirely in the high-level programming language Ocaml [16], a member of the ML [9] language family with a clean semantics.
Reference: 13. <author> C. </author> <title> Kreitz. Formal mathematics for verifiably correct program synthesis. </title> <journal> Journal of the IGPL, </journal> <volume> 4(1) </volume> <pages> 75-94, </pages> <year> 1996. </year>
Reference-contexts: For this purpose we will integrate additional tools from the field of automated deduction, such as an extended typechecking algorithm 2 This methodology has already been used successfully for program synthesis <ref> [13, 2] </ref>. [10], a proof procedure for first-order logic [15], and a proof planner for induc-tive proofs [2] into the logical programming environment. Furthermore, we are extending our formal database by verified theorems about major reconfiguration and verification steps, which we can then use as derived inference rules.
Reference: 14. <author> C. </author> <title> Kreitz. Formal reasoning about communication systems I: Embedding ML into type theory. </title> <type> Technical Report TR97-1637, </type> <institution> Cornell University, </institution> <year> 1997. </year>
Reference-contexts: In the rest of this section we briefly describe the formalization of Ocaml and the tools that translate between Ocaml programs and their formal representations. For a full account we refer the reader to our technical report <ref> [14] </ref>. 3.1 Formalizing Objective Caml in Type Theory Ocaml [16] is a strongly typed, (almost) functional language, which has been extended with a module system and an object calculus. <p> Name resolution (dealing with modules), determining the role of identifiers (variable or reference to user-defined object), and overloading (detecting the intended operator via type inference) therefore had to be addressed with meta-level object generators (see Section 4 of our technical report <ref> [14] </ref> for details). Translating formal representations of protocol layers back into Ocaml source code is easy, because their display is already genuine Ocaml code. Since NuPRL already provides a mechanism for printing libraries and proofs we only had to write a function that selects the objects to be printed. <p> The development of verification tactics for protocol stacks is also still in its beginning phase. So far we have developed and implemented a formal programming logic for the embedded subset of Ocaml (see Section 4 of our technical report <ref> [14] </ref> for details) and experimented with small examples like the above. We have also implemented a type-inference algorithm for the embedded subset of Ocaml and are currently extending it to provide a more detailed analysis of programs like checking array bounds, division errors, boolean annotations, etc. 1.-3. <p> These tactics include function inlining, symbolic evaluation, and knowledge-based simplification. They are based on the derived program evaluation rules mentioned in Section 3 (see also Section 4 of our technical report <ref> [14] </ref>) and on conditional rewrite rules, which are implemented via substitution and lemma application. These tactics are successful for a reconfiguration of individual protocol layers.
Reference: 15. <editor> C. Kreitz, J. Otten, S. Schmitt. </editor> <title> Guiding Program Development Systems by a Connection Based Proof Strategy. </title> <booktitle> In 5th International Workshop on Logic Program Synthesis and Transformation, </booktitle> <volume> LNCS 1048, </volume> <pages> pp. 137-151. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: For this purpose we will integrate additional tools from the field of automated deduction, such as an extended typechecking algorithm 2 This methodology has already been used successfully for program synthesis [13, 2]. [10], a proof procedure for first-order logic <ref> [15] </ref>, and a proof planner for induc-tive proofs [2] into the logical programming environment. Furthermore, we are extending our formal database by verified theorems about major reconfiguration and verification steps, which we can then use as derived inference rules.
Reference: 16. <author> X. Leroy. </author> <title> The Objective Caml system release 1.06. </title> <institution> Institut National de Recherche en Infor-matique et en Automatique, </institution> <year> 1997. </year>
Reference-contexts: Our approach links Ensemble [11], a flexible group communication toolkit, to NuPRL [6], a proof system for mathematical reasoning about programs and for rewriting them into equivalent, but more efficient ones. Because of the similarity between the core of Ocaml <ref> [16] </ref>, the implementation language of Ensemble, and Type Theory, the logical language of NuPRL, we were able to translate the complete implementation of Ensemble into NuPRL-terms and to apply proof tactics and verified program transformations to the actual Ensemble code. <p> Concerns about the reliability of such a technology base for truly secure networked applications led to the implementation of Ensemble [11, 12], which is based on Horus but coded almost entirely in the high-level programming language Ocaml <ref> [16] </ref>, a member of the ML [9] language family with a clean semantics. Due to the use of ML, Ensemble turned out to be one of the most scalable and portable, but also one of the fastest existing reliable multicast systems. <p> For this purpose we have provided a type-theoretical semantics for the programming language Ocaml that is faithful with respect to the Ocaml compiler and manual <ref> [16] </ref>. We have limited our formalization to the subset of Ocaml that is used in the implementation of finite state-event systems like Ensemble, i.e. the functional subset with simple imperative features. <p> In the rest of this section we briefly describe the formalization of Ocaml and the tools that translate between Ocaml programs and their formal representations. For a full account we refer the reader to our technical report [14]. 3.1 Formalizing Objective Caml in Type Theory Ocaml <ref> [16] </ref> is a strongly typed, (almost) functional language, which has been extended with a module system and an object calculus. Its functional core is similar to the language of type theory, but it has a different syntax and contains many additional features.
Reference: 17. <author> N. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1996. </year>
Reference-contexts: Because of this, a complete formal specification of protocol layers is rather complex and more difficult to verify. We are currently elaborating formal specifications of Ensemble's protocol layers and the code for layer composition using I/O-automata as in <ref> [17] </ref>. We intend to use timed automata as a means for specifying synchronization and liveness properties. The development of verification tactics for protocol stacks is also still in its beginning phase. <p> Formal reasoning about application systems can then be done solely on the basis of these formal specifications instead of the real code, which drastically simplifies the reasoning process. We believe that a formalization of the style of reasoning used in Lynch's book <ref> [17] </ref> may lead to successful verification tactics. 5 Fast-Track Reconfiguration of Protocol Stacks For the sake of flexibility, Ensemble's protocol layers can be combined almost arbitrarily. Few assumptions are made about adjacent layers and all types of messages (including errors) must be handled within the layer. <p> It is based on a formalization of a subset of the programming language Ocaml for which we have developed a type-theoretical semantics. Recent work on the specification and verification of timed automata <ref> [17, 1] </ref>, fault-tolerant systems [20], and protocol stacks for group communication systems [8] has demonstrated that formal reasoning about complex distributed algorithms is feasible.
Reference: 18. <author> P. Lincoln & J. Rushby. </author> <title> A formally verified algorithm for interactive consistency under a hybrid fault model. </title> <booktitle> In 23rd Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 402-411, </pages> <year> 1993. </year>
Reference-contexts: Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult [3, 5]. While in principle it is possible to prove the correctness of theoretical algorithms <ref> [19, 18, 1, 20] </ref> it is very difficult to transform these idealizations into implementations that can actually be used in real systems. Finally, the formalization barrier prevents formal tools for checking software correctness from being used to maximum benefit.
Reference: 19. <author> J. Rushby. </author> <title> Formal methods for dependable real-time systems. </title> <booktitle> In International Symposium on Real-Time Embedded Processing for Space Applications, </booktitle> <pages> pp. 355-366, </pages> <year> 1992. </year>
Reference-contexts: Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult [3, 5]. While in principle it is possible to prove the correctness of theoretical algorithms <ref> [19, 18, 1, 20] </ref> it is very difficult to transform these idealizations into implementations that can actually be used in real systems. Finally, the formalization barrier prevents formal tools for checking software correctness from being used to maximum benefit.
Reference: 20. <author> J. Rushby. </author> <title> Systematic formal verification for fault-tolerant time-triggered algorithms. In Dependable Computing for Critical Applications: </title> <booktitle> 6, </booktitle> <pages> pp. 191-210. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1997. </year>
Reference-contexts: Secondly, there is the secure implementation problem: designing and correctly implementing distributed systems is notoriously difficult [3, 5]. While in principle it is possible to prove the correctness of theoretical algorithms <ref> [19, 18, 1, 20] </ref> it is very difficult to transform these idealizations into implementations that can actually be used in real systems. Finally, the formalization barrier prevents formal tools for checking software correctness from being used to maximum benefit. <p> It is based on a formalization of a subset of the programming language Ocaml for which we have developed a type-theoretical semantics. Recent work on the specification and verification of timed automata [17, 1], fault-tolerant systems <ref> [20] </ref>, and protocol stacks for group communication systems [8] has demonstrated that formal reasoning about complex distributed algorithms is feasible.
Reference: 21. <author> R. van Renesse, K. Birman, & S. Maffeis. Horus: </author> <title> A flexible group communication system. </title> <journal> Communications of the ACM, </journal> <volume> 39(4) </volume> <pages> 76-83, </pages> <year> 1996. </year>
Reference-contexts: The first system, Isis [4], became one of the first widely adopted technologies in this area and found its way into Stock Exchanges, Air Traffic Control Systems, and other safety-critical applications. The architecture of Horus <ref> [21] </ref>, a modular redesign of Isis, is based on stacking protocol layers, which can be combined almost arbitrarily to match the needs of a particular application.
References-found: 21

