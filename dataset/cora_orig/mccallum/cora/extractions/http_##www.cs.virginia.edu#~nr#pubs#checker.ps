URL: http://www.cs.virginia.edu/~nr/pubs/checker.ps
Refering-URL: http://www.cs.virginia.edu/~nr/toolkit/
Root-URL: http://www.cs.virginia.edu
Email: mff@research.att.com  nr@cs.virginia.edu  
Title: Automatic Checking of Instruction Specifications  
Author: Mary Fernandez Norman Ramsey 
Keyword: Application generators. Machine-code toolkit. Specification testing.  
Address: 600 Mountain Ave. Murray Hill, NJ 07974  Charlottesville, VA, 22903  
Affiliation: AT&T Labs  Dept. of Computer Science University of Virginia  
Abstract: Retargeting applications that process machine code is a tedious and error-prone task. We help automate retargeting by describing instruction sets in a high-level specification language and by generating automatically the code for encoding and decoding instructions. Moreover, we provide automated assistance for checking machine descriptions. We check a specification for consistency both internally and externally. Internal checking forbids impossible instruction specifications, e.g., those that specify two values for a single bit. Internal checking warns about implausible specifications, e.g., those that don't specify values for all bits. Internal checks catch many mistakes, but they cannot guarantee that a specification accurately describes a target machine. Externally, we check a specification for consistency with an independent assembler. This technique increases a user's confidence in a specification's correctness and permits debugging in isolation of the target application. External validation is effective: it identified errors in specifications of the Intel Pentium, the MIPS, and the SPARC, after code generated from the latter two had been used in applications for over a year. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Auslander, M. Phillipose, C. Chambers, S. Eggers, and B. Bershad. </author> <title> Fast, effective dynamic compilation. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 149-158, </pages> <address> Philadelphia, PA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Processing machine code is also necessary for some less familiar, but increasingly important, tools. Run-time code generators, for example, are used in the implementations of functional and object-oriented languages <ref> [1, 9, 11] </ref>, and they support rapid prototyping and late optimizations by delaying code generation until procedure-call time. Machine-level protection enforcers [24] improve software reliability by guaranteeing that mutually untrusted modules in a program cannot corrupt each other's data or code.
Reference: [2] <author> T. Ball and J. R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 1319-1360, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: INTRODUCTION Many useful software-engineering tools can process machine-dependent information. Such tools include familiar testing tools, like Purify [10], which identifies hard-to-find memory leaks and errors. They also include profiling and tracing tools <ref> [2, 5] </ref>, which help identify performance bottlenecks. Tools like these are most useful when they transform machine code, because machine-code tools can be applied to any executable program, even those for which source is unavailable. Processing machine code is also necessary for some less familiar, but increasingly important, tools.
Reference: [3] <author> U. Banerjee. </author> <title> Dependence Analysis for Supercomputing. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, MA, </address> <year> 1988. </year>
Reference-contexts: If we find that new specifications have more complex constraints, simple improvements to our technique are possible. For example, many ILP algorithms preprocess equations using Banerjee's GCD test <ref> [3] </ref>, which reduces the number of variables and constraints, and for equality constraints, can answer the ILP decision problem in polynomial time. Although we expect users to write equations that have integer solutions, the GCD test is an easy way to tell the user if no integer solution exists.
Reference: [4] <author> O. C. Braun. </author> <title> Retargetability issues in worst-case timing analysis of embedded systems. </title> <type> Bachelor's thesis, </type> <institution> Dept of Computer Science, Princeton University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Our SLED specifications can be used to generate code for many different applications. Code generated from our specifications has been used in our own retargetable debugger [22] and retargetable, optimizing linker [6], and in a run-time code generator, a decompiler, and an execution-time analyzer <ref> [4] </ref>, developed by others. This paper describes the techniques we use to check a SLED specification for consistency with an independent assembler. By using such a widely available tool, we make it easy to check specifications.
Reference: [5] <author> B. Cmelik and D. Keppel. Shade: </author> <title> A fast instruction-set simulator for execution profiling. </title> <booktitle> In Proceedings of the 1994 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 128-137, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: INTRODUCTION Many useful software-engineering tools can process machine-dependent information. Such tools include familiar testing tools, like Purify [10], which identifies hard-to-find memory leaks and errors. They also include profiling and tracing tools <ref> [2, 5] </ref>, which help identify performance bottlenecks. Tools like these are most useful when they transform machine code, because machine-code tools can be applied to any executable program, even those for which source is unavailable. Processing machine code is also necessary for some less familiar, but increasingly important, tools.
Reference: [6] <author> M. F. Fernandez. </author> <title> Simple and effective link-time optimization of Modula-3 programs. </title> <booktitle> Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 30(6) </volume> <pages> 103-115, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Our SLED specifications can be used to generate code for many different applications. Code generated from our specifications has been used in our own retargetable debugger [22] and retargetable, optimizing linker <ref> [6] </ref>, and in a run-time code generator, a decompiler, and an execution-time analyzer [4], developed by others. This paper describes the techniques we use to check a SLED specification for consistency with an independent assembler. By using such a widely available tool, we make it easy to check specifications.
Reference: [7] <author> R. Fourer, D. M. Gay, and B. W. Kernighan. </author> <month> AMPL </month> : 
Reference-contexts: In our testing problem, the ILP solution must be computed. Algorithms exist for computing ILP solutions to data-dependency problems, but they are highly application-specific. Another alternative is having the checker use an external ILP solver <ref> [7] </ref>, but this requires that our users obtain the solver software, reducing the likelihood they will use the checker. If most machine specifications included large sets of complex equations, we could justify the effort required to implement an ILP algorithm.
References-found: 7

