URL: http://cs.nyu.edu/cs/faculty/overton/sdppack/v0.9-beta/doc/userman.ps
Refering-URL: http://cs.nyu.edu/cs/faculty/overton/sdppack/sdppack.html
Root-URL: 
Title: SDPPACK USER'S GUIDE VERSION 0:9 BETA FOR MATLAB  
Author: FARID ALIZADEH, JEAN-PIERRE A. HAEBERLY, MADHU V. NAYAKKANKUPPAM, MICHAEL L. OVERTON, AND STEFAN SCHMIETA 
Affiliation: NYU Computer Science Dept  
Web: Web: http://www.cs.nyu.edu/faculty/overton/sdppack/sdppack.html  
Note: This work was supported in part by the National Science Foundation.  
Date: JUNE 26, 1997  June 1997.  
Pubnum: 5.0  Technical Report,  
Abstract: This report describes SDPpack Version 0.9 Beta for Matlab 5.0. This version extends the previous release for semidefinite programming (SDP) to mixed semidefinite-quadratic-linear programs (SQLP), i.e. linear optimization problems over a product of semidefinite cones, quadratic cones and the nonnegative orthant. Together, these cones make up all possible homogeneous self-dual cones over the reals. The main routine implements a primal-dual Mehrotra predictor-corrector scheme based on the XZ+ZX search direction for SDP. More specialized routines are also available, one to solve SDP's with diagonal constraints only, and one to compute the Lovasz function of a graph, both using the XZ search direction. Routines are also provided to determine whether an SQLP is primal or dual degenerate at its solution and whether strict complementarity holds there. Primal nondegeneracy is associated with dual uniqueness and dual nondegeneracy with primal uniqueness, though these conditions are not equivalent if strict complementarity fails to hold. A routine is also provided to compute the condition number of an SQLP. The Matlab code calls mex files for improved performance; binaries are available for several platforms. Benchmarks show that the codes provide highly accurate solutions to a wide variety of problems. Copyright c fl 1997. All rights are reserved by the authors; restrictions in the copyright notice in each release also apply. SDPpack is software provided on an "as is" basis no warranties, express or implied. In particular, the authors make no representation about the merchantability of this software or its fitness for any specific purpose. For research and noncommercial use: (i) this software is available free of charge, (ii) permission is granted to use, copy or distribute this software free of charge provided the copyright message in each release is preserved in each copy or distribution, (iii) permission is granted to modify this software provided every distribution or copy of the modified software contains a clear record of the modifications, and (iv) any publication resulting from research that made use of this software should cite this document. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Alizadeh, J.-P. Haeberly, and M. L. Overton. </author> <title> Primal-dual interior-point methods for semi-definite programming: convergence rates, stability, and numerical methods. </title> <type> Technical Report 721, </type> <institution> NYU Computer Science Dept, </institution> <year> 1996. </year> <note> To appear in SIAM Journal on Optimization. </note>
Reference-contexts: Appendix C benchmarks this release of SDPpack on a set of test problems. 3. The Script sql.m and the Function fsql.m The Matlab routines sql.m and fsql.m solve SQLP's using a primal-dual Mehro-tra predictor-corrector scheme based on the XZ+ZX search direction 4 <ref> [1] </ref>. Its extension from SDP to SQLP is based on the discussion in [2] for quadratic cone constraints and will be described in more detail in a forthcoming technical report [3]. The simplest option for the user is to call the script sql.m, which automatically calls the Matlab function fsql.m. <p> See Section 3.1. These routines are in the sdppack directory. skron.m: This routine computes the symmetric Kronecker product <ref> [1] </ref> of two block diagonal matrices. The calling sequence is K = skron (M; N; blk) This routine is called only by sqlcond.m. preproc.m: This routine can be used to detect inconsistency of the constraints, or to identify and eliminate redundant constraints. <p> This provides an interesting class of problems, since the blocks in the resulting block vector Z Q must always be on the cone boundary at the 14 All these routines generate data uniformly distributed in <ref> [1; 1] </ref>. They may be modified to use the normal distribution by using randn instead of rand. 20 F. Alizadeh, J.-P. A. Haeberly, M. V. Nayakkankuppam, M. L. Overton and S. Schmieta solution, i.e. with the right-hand component of (7) always zero.
Reference: [2] <author> I. Adler and F. Alizadeh. </author> <title> Primal-Dual Interior Point Algorithms for Convex Quadratically Constrained and Semidefinite Optimization Problems. </title> <type> Technical Report RRR-111-95, </type> <institution> RUT-COR, Rutgers University, </institution> <year> 1995. </year>
Reference-contexts: The Script sql.m and the Function fsql.m The Matlab routines sql.m and fsql.m solve SQLP's using a primal-dual Mehro-tra predictor-corrector scheme based on the XZ+ZX search direction 4 [1]. Its extension from SDP to SQLP is based on the discussion in <ref> [2] </ref> for quadratic cone constraints and will be described in more detail in a forthcoming technical report [3]. The simplest option for the user is to call the script sql.m, which automatically calls the Matlab function fsql.m. <p> qcpos (Z.q,blk.q); [ x0 vz ] % check one complementary pair (x=0, z on boundary) [ z0 vx ] % check other complementary pair (z=0, x on boundary) This routine is in the sdppack directory since it is used by the main routines. arw.m: This routine computes the "arrow matrix" <ref> [2] </ref> which is used to derive the search direction for the quadratic part. The calling sequence is X = arw (x; blk) This routine is called only by sqlcond.m. svec.m, smat.m: These routines convert a symmetric block diagonal matrix into its vector representation and vice versa. See Section 3.1.
Reference: [3] <author> F. Alizadeh, J.-P Haeberly, M. V. Nayakankuppam, M. L. Overton, and S. Schmieta. </author> <title> Optimization with linear, quadratic and semidefinite constraints. </title> <note> In preparation, </note> <year> 1997. </year>
Reference-contexts: Its extension from SDP to SQLP is based on the discussion in [2] for quadratic cone constraints and will be described in more detail in a forthcoming technical report <ref> [3] </ref>. The simplest option for the user is to call the script sql.m, which automatically calls the Matlab function fsql.m. Additional scripts are provided to help the user set up the data, define necessary options, and initialize the variables (as described shortly). <p> It is important to realize that these conditions are defined with respect to the specified block structure (see [7]), so that they reduce to standard LP conditions in the special case that all blocks are one. The extensions of these concepts to SQLP's will be discussed in <ref> [3] </ref>. See also the comments in the codes for the definitions. The most important of these can be accessed using Matlab's help command. The routines are: pcond.m: Given the constraints of an SQLP, its block structure and a primal feasible point, this routine tests for primal degeneracy.
Reference: [4] <author> C. Helmberg, F. Rendl, R. J. Vanderbei, and H. Wolkowicz. </author> <title> An interior-point method for semidefinite programming. </title> <journal> SIAM Journal on Optimization, </journal> <volume> 6 </volume> <pages> 342-361, </pages> <year> 1996. </year>
Reference-contexts: These routines may be found in the special subdirectory. 10 5.1. Diagonally constrained SDP's. For the case of diagonally constrained problems (for example, MAX-CUT relaxations), the Schur complement equations can be formed and solved very efficiently using the XZ search direction 11 <ref> [4, 5] </ref>. The specialized routines dsdp.m and fdsdp.m take advantage of this. As before, the five steps involved in setting up and solving a problem are: preparing the data, setting the options, initializing the variables, invoking the solver, and interpreting the output.
Reference: [5] <author> M. Kojima, M. Shida, and S. Hara. </author> <title> Interior-point methods for the monotone linear complementarity problem in symmetric matrices. </title> <journal> SIAM Journal on Optimization, </journal> <volume> 6 </volume> <pages> 86-125, </pages> <year> 1997. </year>
Reference-contexts: These routines may be found in the special subdirectory. 10 5.1. Diagonally constrained SDP's. For the case of diagonally constrained problems (for example, MAX-CUT relaxations), the Schur complement equations can be formed and solved very efficiently using the XZ search direction 11 <ref> [4, 5] </ref>. The specialized routines dsdp.m and fdsdp.m take advantage of this. As before, the five steps involved in setting up and solving a problem are: preparing the data, setting the options, initializing the variables, invoking the solver, and interpreting the output.
Reference: [6] <author> F. Alizadeh, J.-P. Haeberly, and M. L. Overton. </author> <title> Complementarity and nondegeneracy in semi-definite programming. </title> <journal> Mathematical Programming, </journal> <volume> 77 </volume> <pages> 111-128, </pages> <year> 1997. </year>
Reference-contexts: The ladder2 Steiner tree example in Appendix C is an example of a QCLP for which strict complementarity fails. 6.2. Primal and dual nondegeneracy. Primal and dual nondegeneracy conditions are defined for SDP's in <ref> [6] </ref>. It is important to realize that these conditions are defined with respect to the specified block structure (see [7]), so that they reduce to standard LP conditions in the special case that all blocks are one. The extensions of these concepts to SQLP's will be discussed in [3]. <p> Avoid setting tol too small, especially if strict complementarity does not hold, in which case try values larger than 10 6 . Primal (dual) nondegeneracy implies the uniqueness of dual (primal) solutions. The converse is true if strict complementarity holds <ref> [6] </ref>. Before calling pcond.m or dcond.m for a diagonally constrained SDP or a Lovasz problem, the user must ensure that A:s, b and C:s have been constructed. This can easily be done by calling the appropriate script (dsdp.m or lsdp.m) with useXZ = 0 and opt:maxit = 0.
Reference: [7] <author> M. V. Nayakkankuppam and M. L. Overton. </author> <title> Conditioning of semidefinite programs. </title> <type> Technical report, </type> <institution> NYU Computer Science Dept, </institution> <month> March </month> <year> 1997. </year> <note> URL: http://www.cs.nyu.edu/phd students/madhu/sdp/papers.html. </note>
Reference-contexts: Primal and dual nondegeneracy. Primal and dual nondegeneracy conditions are defined for SDP's in [6]. It is important to realize that these conditions are defined with respect to the specified block structure (see <ref> [7] </ref>), so that they reduce to standard LP conditions in the special case that all blocks are one. The extensions of these concepts to SQLP's will be discussed in [3]. See also the comments in the codes for the definitions. <p> This can easily be done by calling the appropriate script (dsdp.m or lsdp.m) with useXZ = 0 and opt:maxit = 0. Upon termination of the script, the variables will be defined in the Matlab workspace. 6.3. The condition number. The condition number of an SDP is defined in <ref> [7] </ref> and its significance is discussed there. Briefly, the condition number of an SQLP is defined as the condition number of the Jacobian of the function to which Newton's SDPpack User's Guide (Version 0.9 Beta) 17 method is applied in defining the XZ+ZX search direction, evaluated at the solution.
Reference: [8] <author> F. Alizadeh, J.-P. Haeberly, M. V. Nayakkankuppam, and M. L. Overton. </author> <title> SDPpack user's guide, version 0.8 beta. </title> <type> Technical Report 734, </type> <institution> NYU Computer Science Dept, </institution> <month> March </month> <year> 1997. </year> <note> URL: http://www.cs.nyu.edu/phd students/madhu/sdppack/sdppack.html. </note>
References-found: 8

