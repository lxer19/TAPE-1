URL: ftp://theory.lcs.mit.edu/pub/people/oded/bgg-inc2.ps
Refering-URL: http://theory.lcs.mit.edu/~oded/bgg.html
Root-URL: 
Title: Incremental Cryptography and Application to Virus Protection  
Author: Mihir Bellare Oded Goldreich Shafi Goldwasser 
Abstract: The goal of incremental cryptography is to design cryptographic algorithms with the property that having applied the algorithm to a document, it is possible to quickly update the result of the algorithm for a modified document, rather than having to re-compute it from scratch. In settings where cryptographic algorithms such as encryption or signatures are frequently applied to changing documents, dramatic efficiency improvements can be achieved. One such setting is the use of authentication tags for virus protection. We consider documents that can be modified by powerful (and realistic) document modification operations such as insertion and deletion of character-strings (or equivalently cut and paste of text). We provide efficient incremental signature and message authentication schemes supporting the above document modification operations. They meet a strong notion of tamper-proof security which is appropriate for the virus protection setting. We initiate a study of incremental encryption, providing definitions as well as solutions. Finally, we raise the novel issue of "privacy" of incremental authentication schemes. Abstract to appear in Proceedings of the 27th ACM Symposium on the Theory of Computing, May 1995. 
Abstract-found: 1
Intro-found: 1
Reference: [AHU] <author> A. Aho, J. Ullman, and J. Hopcroft. </author> <title> The de-sign and analysis of computer algorithms. </title> <address> AddisonWesley, </address> <year> 1974. </year>
Reference-contexts: A standard construction, namely tree authentication a la Merkle [Me1, Me2], can be used to provide the first implementation of this idea. How- ever, this only works for replacement. To handle the more complex operations discussed above we use 2-3 trees <ref> [AHU] </ref>. The binary tree scheme. To help the reader understand what follows the binary tree scheme is now presented. The construction may be standard, but the proof that it achieves tamper resistance is not trivial; however we'll omit it because we present and prove correct a more general scheme below.
Reference: [AKS] <author> M. Ajtai, J. Koml os and E. Szemer edi. </author> <title> An O(n log n) sorting network. </title> <note> STOC 83. </note>
Reference-contexts: Finally, we set E 1 to hold the encryption of D 0 and drop the first ` elements of E 2 . Using the AKS sorting network <ref> [AKS] </ref>, our implementation of one epoch requires O (` log `) steps (whereas if we use Batcher's network we get a total of O (`) + `(log 2 `) steps). These steps can be partitioned evenly among the ` modification actions yielding the desired complexity.
Reference: [Ba] <author> K. Batcher. </author> <title> Sorting networks and their applica-tions. </title> <booktitle> AFIPS Spring Joint Computer Conference 32, </booktitle> <year> 1968. </year>
Reference-contexts: It is crucial that the sorting is performed by an efficient and oblivious sorting network such as Batcher's sorting network <ref> [Ba] </ref>. We stress that whenever two pairs are compared and switched/unswitched they are re-encrypted by E (and so the adversary cannot tell if they were switched or not). This guarantees that the entire sorting procedure does not leak any information to the adversary.
Reference: [BGG] <author> M. Bellare, O. Goldreich and S. Goldwasser. </author> <title> Incremental cryptography: The case of hashing and signing. </title> <type> Crypto 94. </type>
Reference-contexts: We note that files in this virus setting can grow very large and be subject to frequent updates; eg. consider a database being periodically altered. The idea of incremental cryptography, as we outlined in <ref> [BGG] </ref>, is to take advantage of such settings, and find ways to compute the cryptographic transformation on a document D not from scratch, but rather, somehow, as a fast function of the values of the cryptographic transformation on the documents from which D was constructed. <p> into account by providing exact security reductions: our theorems quantify the success of an adversary in breaking the underlying assumption as a function of her success in breaking the constructed scheme. 1.5 Previous work and comparison with ours The study of incremental cryptography was initiated by the current authors in <ref> [BGG] </ref>. The primitives considered there were collision free hashing and digital (public key) signatures. The text modification operation considered was replacement (of one message block by another). Incremental schemes based on the hardness of discrete log were provided. The signature scheme met the notion of basic security. <p> In addition, we introduce new concerns such as history-freeness and privacy. We provide the first solutions for message authentication achieving tamper-proof security, and hence for virus protection. Our schemes can be instantiated with DES and MD5 type primitives and thus are considerably more efficient than those of <ref> [BGG] </ref> which use the discrete log. <p> We distinguish two settings, or requirements, in security: basic security and the stronger notion of tamper proof security. Definitions of basic and tamper proof security, in the single-document setting, were provided in our previous work <ref> [BGG] </ref>. Here we extend both definitions to the multi-document setting. Basic security.
Reference: [BGR] <author> M. Bellare, R. Gu erin and P. Rogaway. </author> <title> XOR MACs: New methods for message authentication us-ing block ciphers. </title> <type> Manuscript, </type> <month> March </month> <year> 1994. </year>
Reference-contexts: It has incremental algorithms for (single block) insert and delete which require only four applications of the underlying PRF. It achieves basic security, and it also achieves privacy. It builds on some schemes of <ref> [BGR] </ref> which were incremental for replacement. Tree schemes. The second signature scheme provides tamper proof security, and hence is applicable to virus protection. <p> We introduce simple schemes supporting insertion and deletion. They extend the XOR schemes of <ref> [BGR] </ref> which were incremental for replacement. The chaining technique we introduce is quite general. The scheme. <p> Thus we run at essentially the same speed as the most widely used existing message authentication scheme with the added advantage of incrementality. As an aside we note that the XOR schemes of <ref> [BGR] </ref> require at least 25% more DES operations than the CBC. The fact that we have only a 5% overhead is due to the chaining and exhibits another advantage of this idea. Another good instantiation is via composition. Again let a be a DES key.
Reference: [BKR] <author> M. Bellare, J. Kilian and P. Rogaway. </author> <title> The security of cipher block chaining. </title> <type> Crypto 94. </type>
Reference-contexts: One example is to use only DES, assumed to be a PRF. For a 56 bit DES key a let the PRF f a , taking b-bit inputs, be defined by cipher block chaining| this is still a PRF <ref> [BKR] </ref>. Now note that the number of DES computations to compute the tag in our scheme is essentially just 5% more than that for doing DES CBC of the entire message.
Reference: [BR] <author> M. Bellare and P. Rogaway. </author> <title> Entity authentica-tion and key distribution. </title> <type> Crypto 93. </type>
Reference-contexts: Key to achieving practicality is appropriate instantiation of these abstract primitives by concrete ones. In particular, suitable "pseudorandom in practice" functions can be derived from DES, MD5 [Ri] and other such primitives as described for example in <ref> [BR] </ref>. The resulting XOR schemes can run within 1.05 times the speed of the most popular message authentication scheme in practice, namely the CBC MAC, with the added advantage of incrementality that the CBC MAC does not possess. <p> In particular, finite pseudorandom functions (ie. PRFs on fixed input and output lengths) are good starting points because they can be efficiently instantiated with block ciphers like DES or via hash functions like MD5 <ref> [BR] </ref>. <p> Let the PRF f a be defined by f a (x) = DES a (DES a (MD5 1 (x))MD5 2 (x)), where MD5 1 (resp. MD5 2 ) is the first (resp. second) half of the output of MD5| this is shown by <ref> [BR] </ref> to be a PRF assuming MD5 is a collision-free hash function and DES is a PRF. In software this may be faster than the above. Note that the scheme has additional efficiency properties.
Reference: [CW] <author> L. Carter and M. Wegman. </author> <title> Universal Classes of Hash Functions. </title> <journal> J. Computer and System Sciences 18, </journal> <pages> 143-154, </pages> <year> 1979. </year>
Reference-contexts: Notice that incrementing requires four/six computations of a PRF together with some XORs and other simple operations. It is this considerably faster than re-computing the tag from scratch. 7 For example, hashing under linear universal-2 hash functions <ref> [CW] </ref> yields an incremental fingerprinting scheme.
Reference: [Go] <author> O. Goldreich. </author> <title> Towards a Theory of Software Protection and Simulation by Oblivious RAMs. </title> <note> STOC 87. </note>
Reference-contexts: The scheme supports not only insert and delete but also cut and paste. The updates require a logarithmic (in the message length) number of applications of the given (non incremental) scheme. It uses 2-3 trees. Encryption. We extend ideas on software protection <ref> [Go, Os] </ref> to provide the first incremental encryption scheme. The efficiency here is however not as good as for our signature schemes. 1.4 From theory to practice Instantiation. <p> This might be acceptable in some settings, but a non-amortized solution is worth seeking. Another approach to incremental encryption is to use the idea of "software protection" as defined in <ref> [Go] </ref>. (The setting consists of a processor, having only a limited amount of local memory, to store and access information on an insecure remote memory. The simulation should be oblivious in the sense that the actual access pattern does not leak information about the original/simulated access pattern. <p> with the encryption.) A software protection scheme with polylogarithmic overhead exists [Os], but is also amortized, and using this results in an incremental encryption scheme whose efficiency is in the end not better than that of the trivial solution above. 9 However the ideas of the software protection schemes of <ref> [Go, Os] </ref> can be adapted to derive an incremental encryption scheme for (single symbol) insert/delete that is efficient in the strict sense (i.e., number of simulation steps per original operation) rather than in the amortized sense (as presented there). The adaptation is achieved by "pipelining." A brief description follows. <p> The first two sequence, E 1 and E 2 , are as above and suffice for decrypting the document. The additional sequence E 3 is an encryp <p>- 10 Here is where we use the ideas of <ref> [Go, Os] </ref>. tion of a "work area", denoted W = W [1] W [2`], used to implement the above procedure. <p> These steps can be partitioned evenly among the ` modification actions yielding the desired complexity. As stated above, each of the schemes presented in <ref> [Go, Os] </ref> can be adopted to yield an incremental encryption scheme for (single symbol) insert/delete that is efficient in the strict sense. This is done analogously to the above, provided hat the document length stays within some predetermined bounds (e.g., between `=2 and 2`).
Reference: [GGM] <author> O. Goldreich, S. Goldwasser and S. Micali. </author> <title> How to construct random functions. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 33, No. 4, </volume> <pages> 210-217, </pages> <year> 1986. </year>
Reference-contexts: XOR schemes. We present a particularly fast message authentication (ie. private key signature) scheme based on a pseudorandom function (PRF) <ref> [GGM] </ref>. It has incremental algorithms for (single block) insert and delete which require only four applications of the underlying PRF. It achieves basic security, and it also achieves privacy. It builds on some schemes of [BGR] which were incremental for replacement. Tree schemes. <p> The scheme. The key, denoted a, held by the parties is a pair (a 1 ; a 2 ) of random strings which specify pseudorandom functions f 1 = f a 1 and f 2 = f a 2 , chosen from a fixed underlying collection of PRFs <ref> [GGM] </ref>. We let rand denote the algorithm which given a string picks a random k bit string r, called a randomizer, and returns : r. <p> Let MA be an ordinary message authentication algorithm and MA a the tagging function induce by MA with the authentication-key a (e.g., MA a = f a , where f a is taken from a family of pseudorandom functions see <ref> [GGM] </ref>). Let VMA be the corresponding verification algorithm (e.g., VMA a (m; t) may merely consist of computing MA a (m) and checking whether it equals t). We stress that these primitives are not incremental ones; yet, we will build incremental schemes out of them. <p> The underlying message authentication scheme can be taken to be any of the standard ones. For example, the CBC MAC, or just one of the PRFs discussed above. (Any PRF is a MAC <ref> [GGM] </ref>). Our scheme has the additional property that it is secure even in face of an adversary who can see the authentication tags and even tamper with them.
Reference: [GM] <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic en-cryption. </title> <journal> J. of Computer and System Sciences 28, </journal> <pages> 270-299, </pages> <month> April </month> <year> 1984. </year>
Reference: [GMR] <author> S. Goldwasser, S. Micali and R. Rivest. </author> <title> A digital signature scheme secure against adaptive chosen-message attacks. </title> <journal> SIAM Journal of Computing, </journal> <volume> 17(2) </volume> <pages> 281-308, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: which a user applying the incremental algorithm is assured of the authenticity of the document and authentication tag to which the algorithm is applied| this is the natural case in which, for example, old documents and their authentication tags are stored securely on the user's machine, and the definition of <ref> [GMR] </ref> extends in the natural way. Specifically, the adversary may obtain signatures to documents of its choice by issuing corresponding create-document commands.
Reference: [KR] <author> R. Karp and M. Rabin. </author> <title> Efficient randomized pat-tern matching algorithms. </title> <journal> IBM J. of Research and Development Vol. </journal> <volume> 31, No. 2, </volume> <month> March </month> <year> 1987. </year>
Reference-contexts: Our schemes can be instantiated with DES and MD5 type primitives and thus are considerably more efficient than those of [BGG] which use the discrete log. For the problem of virus protection when the virus cannot see any authentication tags of files, the work of Karp and Rabin <ref> [KR] </ref> on fingerprints can be used. 3 Their fingerprint scheme is incremental with respect to single character replacement, but does not provide fast update for single character insert/delete. 3 This was observed by Rabin (Ben-Or, private communication). 3 2 Definitions In order to define incremental cryptographic algorithms and discuss their complexity <p> Our scheme has the additional property that it is secure even in face of an adversary who can see the authentication tags and even tamper with them. In contrast, the fingerprinting method of Karp-Rabin <ref> [KR] </ref> is secure only if the adversary cannot see the fingerprint. 4 Incremental encryption 4.1 The security of incremental encryption As discussed in the Introduction, the usage of incremental encryption algorithms may leak information that is kept secret when using a traditional encryption scheme.
Reference: [Me1] <author> R. Merkle. </author> <title> A certified digital signature scheme. </title> <type> Crypto 89. </type>
Reference-contexts: Specifically, before modifying a part of the tag, the incremental tagging algorithm checks that this part is "locally" valid. A standard construction, namely tree authentication a la Merkle <ref> [Me1, Me2] </ref>, can be used to provide the first implementation of this idea. How- ever, this only works for replacement. To handle the more complex operations discussed above we use 2-3 trees [AHU]. The binary tree scheme.
Reference: [Me2] <author> R. Merkle. </author> <title> Protocols for public key cryptosystems. </title> <booktitle> Proceedings of the 1980 Symposium on Security and Privacy. </booktitle>
Reference-contexts: Specifically, before modifying a part of the tag, the incremental tagging algorithm checks that this part is "locally" valid. A standard construction, namely tree authentication a la Merkle <ref> [Me1, Me2] </ref>, can be used to provide the first implementation of this idea. How- ever, this only works for replacement. To handle the more complex operations discussed above we use 2-3 trees [AHU]. The binary tree scheme.
Reference: [Os] <author> R. Ostrovsky. </author> <title> Efficient Computations on Oblivious RAMs. </title> <note> STOC 90. </note>
Reference-contexts: The scheme supports not only insert and delete but also cut and paste. The updates require a logarithmic (in the message length) number of applications of the given (non incremental) scheme. It uses 2-3 trees. Encryption. We extend ideas on software protection <ref> [Go, Os] </ref> to provide the first incremental encryption scheme. The efficiency here is however not as good as for our signature schemes. 1.4 From theory to practice Instantiation. <p> The translation from oblivious simulation of RAM to an incremental encryption scheme is quite obvious: the role of the processor is played by the user, whereas the remote memory is associated with the encryption.) A software protection scheme with polylogarithmic overhead exists <ref> [Os] </ref>, but is also amortized, and using this results in an incremental encryption scheme whose efficiency is in the end not better than that of the trivial solution above. 9 However the ideas of the software protection schemes of [Go, Os] can be adapted to derive an incremental encryption scheme for <p> with the encryption.) A software protection scheme with polylogarithmic overhead exists [Os], but is also amortized, and using this results in an incremental encryption scheme whose efficiency is in the end not better than that of the trivial solution above. 9 However the ideas of the software protection schemes of <ref> [Go, Os] </ref> can be adapted to derive an incremental encryption scheme for (single symbol) insert/delete that is efficient in the strict sense (i.e., number of simulation steps per original operation) rather than in the amortized sense (as presented there). The adaptation is achieved by "pipelining." A brief description follows. <p> The first two sequence, E 1 and E 2 , are as above and suffice for decrypting the document. The additional sequence E 3 is an encryp <p>- 10 Here is where we use the ideas of <ref> [Go, Os] </ref>. tion of a "work area", denoted W = W [1] W [2`], used to implement the above procedure. <p> These steps can be partitioned evenly among the ` modification actions yielding the desired complexity. As stated above, each of the schemes presented in <ref> [Go, Os] </ref> can be adopted to yield an incremental encryption scheme for (single symbol) insert/delete that is efficient in the strict sense. This is done analogously to the above, provided hat the document length stays within some predetermined bounds (e.g., between `=2 and 2`).
Reference: [Ri] <author> R. Rivest. </author> <title> The MD5 message-digest algorithm. IETF Network Working Group, </title> <type> RFC 1321, </type> <month> April </month> <year> 1992. </year>
Reference-contexts: Key to achieving practicality is appropriate instantiation of these abstract primitives by concrete ones. In particular, suitable "pseudorandom in practice" functions can be derived from DES, MD5 <ref> [Ri] </ref> and other such primitives as described for example in [BR]. The resulting XOR schemes can run within 1.05 times the speed of the most popular message authentication scheme in practice, namely the CBC MAC, with the added advantage of incrementality that the CBC MAC does not possess.
References-found: 17

