URL: http://www.research.microsoft.com/users/dsyme/reports/thesis.ps.gz
Refering-URL: http://www.research.microsoft.com/users/dsyme/projects.html
Root-URL: http://www.research.microsoft.com
Title: Declarative Theorem Proving for Operational Semantics  
Author: Don Syme 
Degree: A dissertation submitted for the degree of Doctor of Philosophy in the  
Address: Hall  
Affiliation: Trinity  University of Cambridge  
Abstract-found: 0
Intro-found: 1
Reference: [AGMT98] <author> J. S. Aitken, P. Gray, T. Melham, and M. Thomas. </author> <title> Interactive theorem proving: An empirical study of user activity. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 25(2):263284, </volume> <month> February </month> <year> 1998. </year>
Reference-contexts: A caveat: The studies are substantially different and the statistics are only meant to give a rough impression of the nature of the style of proof and specification used! Controlled experiments are possible in such a domain, but require a significant resources. Aitken et al. <ref> [AGMT98] </ref> have used controlled quantitative experiments to investigate interaction (but not proof style) in HOL and PVS. Similar experiments investigating proof style would be interesting but are beyond the scope of this thesis. Truly controlled experiments would be very difficult, after all these developments take years to construct (e.g.
Reference: [And97] <author> James H. Andrews. </author> <title> Executing formal specifications by translation to higher order logic programming. </title> <editor> In Elsa L. Gunter and Amy Felty, editors, </editor> <title> Theorem Proving in Higher Order Logics, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <pages> pages 1732. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: AKL supports the additional expressive power of linear inequality constraints, but does not support higher order features. Whals et al. do not consider the important issue of leveraging the static analysis algorithms available in the underlying logic programming engine clearly Mercury is particularly strong in this regard. Andrews <ref> [And97] </ref> translates the specification language S [JDD94] to Lambda Prolog [FGMP90], a higher order Prolog, and this work has quite a similar feel to our own. The result is convincing as far as it goes, however again static analyses are not utilised.
Reference: [Bai98] <author> Anthony Bailey. </author> <title> The Machine-checked literate formalisation of algebra in type theory. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Manchester, </institution> <year> 1998. </year>
Reference-contexts: These styles have not been systematized, and in often resemble aspects of our declarative proof language (e.g. Harrison is often careful to give sensible names when introducing local constants). In addition, Bailey <ref> [Bai98] </ref> has looked closely at the role of literate programming in supporting readable proofs for the LEGO [LP92] proof assistant, in the context of a major proof in algebra. He adopted a limited style of proof in places in order to maximize readability.
Reference: [BM81] <author> R. S. Boyer and J Strother Moore. </author> <title> Integrating decision procedures into heuristic theorem provers. </title> <type> Technical report, </type> <institution> Univ. of Texas, </institution> <year> 1981. </year>
Reference-contexts: Often the justification is simply a set of theorem names. Existing theorem provers with strong automation effectively support a kind of declarative proof at the top level. For example, the Boyer-Moore prover <ref> [BM81] </ref> is declarative in this sense the user conjectures a goal and the system tries to prove it. If the system fails, then the user adds more details and tries again. <p> The lesson is that when using rewriting as a preprocessor, the rewrite system must respect the behaviour of other automated routines. We use the ground decision procedures to: * Attempt to decide side conditions to conditional rewrites, after recursively grinding the condition, as in the Boyer-Moore prover <ref> [BM81] </ref>; * Attempt to decide the problem itself, again after grinding, but before model elimination. Other theorem provers do better: ideally, asserting an equality between ground terms into should make those terms indistinguishable for nearly all purposes (this appears to be an unstated aim of the PVS prover). <p> We have discussed this issue in Section 4.2.5. The scope of the prover was adequate for our case study, but any improvement in scope could dramatically simplify many proofs. 4.5 Related Work This chapter builds on many techniques developed in other theorem proving systems. Most notably, the Boyer-Moore prover <ref> [BM81] </ref> pioneered the use of rewriting, the decision procedures to solve conditions, and a tagging/pragma mechanism to identify suitable rewrites.
Reference: [BN98] <author> F. Baader and T. Nipkow. </author> <title> Term Rewriting and all that. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1998. </year>
Reference-contexts: confluence (that is, the order of application of rewrites should not influence the final result); normalization (does the rewrite system reduce terms to a normal form?); and completeness (does the rewrite systems fully solve a class of problems?) An excellent introduction to the theory of rewriting can be found in <ref> [BN98] </ref> and implementations in HOL and Isabelle are documented in [Bou92] and [Nip89].
Reference: [Bou92] <author> R. Boulton. </author> <title> Boyer-Moore automation for the HOL system. </title> <editor> In L.J.M. Claesen and M.J.C. Gordon, editors, </editor> <booktitle> International Workshop on Higher Order Logic Theorem Proving and its Applications, </booktitle> <pages> pages 133145, </pages> <address> Leuven, Belgium, </address> <month> September </month> <year> 1992. </year> <booktitle> IFIP TC10/WG10.2, </booktitle> <publisher> North-Holland. IFIP Transactions. </publisher>
Reference-contexts: not influence the final result); normalization (does the rewrite system reduce terms to a normal form?); and completeness (does the rewrite systems fully solve a class of problems?) An excellent introduction to the theory of rewriting can be found in [BN98] and implementations in HOL and Isabelle are documented in <ref> [Bou92] </ref> and [Nip89]. Some typical enhancements to basic rewriting described above are: * Conditional rewriting, e.g. i &gt; 0 ^ i length (t) ! el (i)(h :: t) ; el (i 1)(t) perhaps using decision procedures to solve conditions. * 2nd order and higher order matching.
Reference: [Bou95] <author> R. J. Boulton. </author> <title> Combining decision procedures in the HOL system. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 971:75ff, </address> <year> 1995. </year>
Reference-contexts: Nel-son and Oppen have a quite general scheme that has been successfully re-implemented in theorem proving systems <ref> [NO79, Bou95] </ref>.
Reference: [Bou97] <author> R. J. Boulton. </author> <title> A tool to support formal reasoning about computer languages. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 1217:81, </address> <year> 1997. </year>
Reference-contexts: Such a facility could be added, perhaps by using Boulton's Claret tools <ref> [Bou97] </ref>. 6.7. THE MODEL AS A DECLARE SPECIFICATION 115 * Around 5 Mercury mode violations, because of typing mistakes and some logical errors. * Around 5 logical mistakes in the typing and runtime rules, detected when actually executing expressions.
Reference: [COR + 95] <author> Judy Crow, Sam Owre, John Rushby, Natarajan Shankar, and Man-dayam Srivas. </author> <title> A tutorial introduction to PVS. </title> <booktitle> In Proceedings of the Workshop on Industrial-Strength Formal Specification Techniques, </booktitle> <address> Baco Raton, Florida, </address> <year> 1995. </year>
Reference-contexts: Where our techniques depart from best known practice we describe how they represent an improvement. By best known practice we mean the state-of-the-art in the domain as embodied in existing interactive theorem provers, such as Isabelle, ACL2, HOL and PVS <ref> [Pau90, GM93, COR + 95, KM96a, Har96a] </ref>. We use DECLARE as a means to demonstrate our ideas, though the ideas themselves are independent of the actual theorem proving system used. <p> Specification is succinct and a wide range of notational conventions are supported. Proofs are again described using tactics, and a number of powerful generic proof routines including first order provers and simplification engines are available. * PVS <ref> [COR + 95] </ref>. This is an implementation of a rich higher order logic, including predicate subtypes, notable for its excellent interactive environment, powerful integrated decision procedures and pragmatic approach 1.4. DECLARATIVE THEOREM PROVING AND DECLARE 7 to integrating model checking. <p> Commonly cited specification languages include: axiomatization in first order logic; the Z and VDM notations [Spi88, Jac88]; variants of higher order logic (e.g. the specification languages of HOL [GM93], PVS <ref> [COR + 95] </ref> and Isabelle/HOL [Pau90]); set theory; temporal logics; specialised formalisms for finite state machines and hardware; and restricted subsets of logic that are highly amenable 1 As distinct from the HOL or Isabelle/HOL implementations of higher order logic. 21 22 CHAPTER 2. SPECIFICATION AND VALIDATION to automation (e.g. <p> Nel-son and Oppen have a quite general scheme that has been successfully re-implemented in theorem proving systems [NO79, Bou95]. Shostak has an alternative scheme that is less general but reputedly faster, and this is used in the STeP and PVS theorem provers <ref> [Sho84, MBBC95, COR + 95] </ref>. 3 This subset (Presburger arithmetic) is usually expanded to include rational constants and functions that can be encoded in a linear/propositional framework, e.g. abs, max, min etc.
Reference: [DE97a] <author> S. Drossopoulou and S. Eisenbach. </author> <title> Java is type safe probably. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 1241:389ff, </address> <year> 1997. </year> <note> 157 158 BIBLIOGRAPHY </note>
Reference-contexts: Drossopoulou and Eisenbach have presented a formal semantics for approximately the same subset of Java that we treat here <ref> [DE97a] </ref>. Our work is based on theirs and improves it by correcting and clarifying many details. Our main aim has not been to find errors. <p> Of course, even if we prove properties of an abstract model of Java and/or the JVM, this does not guarantee the soundness of a particular implementation. 6.2.2 Comparison with Drossopoulou and Eisenbach Our model was originally based on that developed by Drossopoulou and Eisen-bach in version 2.01 of their paper <ref> [DE97b, DE97a] </ref>. 2 The differences in the subset considered are: 3 * Object has Methods. We allow the primitive class Object to have methods. It was when considering this extension that one mistake in the Java Language Specification was discovered (see Section 7.4). * Methods for Arrays. <p> We omit the typing rules for Java S , though they are for-malised in DECLARE. The rules to annotate Java S (; ann ) to produce Java A are similar to the Java S type-checking rules and again we omit them here (see also Drossopoulou and Eisenbach's work <ref> [DE97a] </ref>). 11 The function existsl checks that a predicate is satisfied for some element of a list. 6.6.
Reference: [DE97b] <author> Sophia Drossopoulou and Susan Eisenbach. </author> <title> Is the Java type system sound? (version 2.01). </title> <type> Technical report, </type> <institution> Imperial College, University of London, </institution> <address> Cambridge, CB2 3QG, U.K., </address> <month> January </month> <year> 1997. </year> <title> This version was distributed on the Internet. Please contact the authors if a copy is required for reference. </title>
Reference-contexts: Of course, even if we prove properties of an abstract model of Java and/or the JVM, this does not guarantee the soundness of a particular implementation. 6.2.2 Comparison with Drossopoulou and Eisenbach Our model was originally based on that developed by Drossopoulou and Eisen-bach in version 2.01 of their paper <ref> [DE97b, DE97a] </ref>. 2 The differences in the subset considered are: 3 * Object has Methods. We allow the primitive class Object to have methods. It was when considering this extension that one mistake in the Java Language Specification was discovered (see Section 7.4). * Methods for Arrays. <p> The reader should keep in mind that when these proofs were begun, the only guide available was the rough outline in <ref> [DE97b] </ref>, and this was based on a formulation of the problem that was subsequently found to contain 124 CHAPTER 7. TYPE SOUNDNESS FOR JAVA S errors. Thus the process was one of proof discovery rather than proof transcription.
Reference: [DE98] <author> Sophia Drossopoulou and Susan Eisenbach. </author> <title> What is Java binary compatibility? Accepted for publication at Object Oriented Programming, </title> <booktitle> Systems, Languages and Applications, </booktitle> <address> Vancouver, Canada, </address> <year> 1998. </year>
Reference-contexts: A striking example of its utility in this role is recent work by Drossopoulou and Eisenbach (whose work we shall consider in a case study in Chapters 6 and 6.6.2). They have used operational semantics to analyse the semantics of binary compatibility in the Java language <ref> [DE98] </ref>, and have consequently discovered a serious flaw in the type system of the language. Considering the importance of the language and the subtle nature of the problem they detected this is a remarkable result. <p> This justifies why we are interested in such results, but why formally check them? Formal checking is primarily a tool for maintaining certainty in the presence complexity. Our case study in Chapter 6 describes a large operational system that is still under going rapid development by language researchers <ref> [DE98] </ref>. It is difficult to maintain the integrity of paper proofs of properties as such systems develop: the number of cases to analyse is high and there is always the concern that some unexpected combination of language features will lead to a soundness problem. <p> If a version is needed for reference please contact the authors. 3 Note that Drossopoulou and Eisenbach have since progressed to model other aspects of the language such as exceptions and binary compatibility <ref> [DE98] </ref>. 98 CHAPTER 6. JAVA S The main differences in the model itself are: * Corrections. <p> The latter are used to model terms arising during execution and enjoy subtly different typing rules. Drossopoulou and Eisenbach have since reported that the language Java A is useful for modelling binary compatibility <ref> [DE98] </ref>, because it allows us to model precisely both compile-time and runtime analyses * Simpler Well-formedness. We adopt a suggestion by von Oheimb that well-formedness for environments be specified without reference to a declara tion order. * No Static Substitution.
Reference: [DFW96] <author> Drew Dean, Edward W. Felten, and Dan S. Wallach. </author> <title> Java security: from HotJava to Netscape and beyond. </title> <booktitle> In IEEE, editor, 1996 IEEE Symposium on Security and Privacy: </booktitle> <address> May 68, 1996, Oakland, California, pages 190200, 1109 Spring Street, Suite 300, Silver Spring, MD 20910, USA, 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Studies have uncovered flaws in the security of Java and its implementations, including its type system, and have pointed out the need for a formal semantics to complement the existing language definition <ref> [DFW96, GJS96] </ref>. A full formal treatment of many important aspects of the language (e.g. dynamic linking) has yet to be performed. Because of these things, type soundness is clearly a property we are interested in for this language.
Reference: [DT96] <author> D. Nazareth and T. Nipkow. </author> <title> Formal verification of algorithm W: The monomorphic case. </title> <editor> In J. Von Wright, J. Grundy, and J. Har-rison, editors, </editor> <booktitle> Ninth international Conference on Theorem Proving in Higher Order Logics TPHOL, volume 1125 of Lecture Notes in Computer Science, </booktitle> <pages> pages 331346, </pages> <address> Turku, Finland, August 1996. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: This culminated in the proof of the Church-Rosser theorem for combinatorial logic. The proof has since been reworked and improved in Isabelle [Ras95, Nip96]. * Nipkow, Naraschewski and Nazareth have proved the correctness of the W algorithm for type inference for a small functional language, using Isabelle-HOL <ref> [DT96] </ref>. 1 We do not use model in its proof theoretic sense, but rather to distinguish the abstract formal system (as expressed in the written mathematical vernacular) from the embedded for mal system (realised in a formal checking tool). 6 CHAPTER 1. <p> POP ASSUM LIST above, which forces all assumptions through a function). For example, the proof of the correctness of the W type inference algorithm in Nipkow and Nazareth's formulation <ref> [DT96] </ref> begins: (* correctness of W with respect to has_type *) goal W.thy "!A S t m n . new_tv n A --&gt; Some (S,t,m) = W e A n --&gt; $S A |- e :: t"; by (expr.induct_tac "e" 1); (* case Var n *) by (asm_full_simp_tac (simpset () addsplits
Reference: [FGMP90] <author> Amy Felty, Elsa Gunter, Dale Miller, and Frank Pfenning. </author> <title> prolog. </title> <editor> In M. E. Stickel, editor, </editor> <booktitle> Proceedings of the 10th International Conference on Automated Deduction, volume 449 of LNAI, </booktitle> <pages> pages 682681, </pages> <address> Kaiserslautern, FRG, July 1990. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: Whals et al. do not consider the important issue of leveraging the static analysis algorithms available in the underlying logic programming engine clearly Mercury is particularly strong in this regard. Andrews [And97] translates the specification language S [JDD94] to Lambda Prolog <ref> [FGMP90] </ref>, a higher order Prolog, and this work has quite a similar feel to our own. The result is convincing as far as it goes, however again static analyses are not utilised.
Reference: [Fro93] <author> Jacob Frost. </author> <title> A Case Study of Co-induction in Isabelle HOL. </title> <type> Technical Report 308, </type> <institution> University of Cambridge, Computer Laboratory, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: There are many other similar works on a smaller scale, for example those by Frost, Nesi and Melham <ref> [Fro93, Nes92, Mel91] </ref>. As indicated by the above list, researchers have applied a range of theorem proving tools to assist with the formal checking of proofs related to operational semantics.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: For example, in Chapter 6 we must argue that, in some sense, our model of the language conforms to the Java Language Specification <ref> [GJS96] </ref>. We regard the issue of validation as extremely important in the context of operational semantics. Without validation, we really have no guarantee that our theorem proving efforts have demonstrated anything useful. <p> Our main aim has not been to find errors. However, some significant mistakes in the original formulation adopted by Drossopoulou and Eisenbach were discovered, and we were able to provide feedback and suggestions to the authors. We also independently rediscovered a significant error in the Java Language Specification <ref> [GJS96] </ref>. Our methodology and tools enabled us to find the error relatively quickly, and this demonstrates the positive role that machine checking can play when used in conjunction with existing techniques. <p> We also briefly describe the representation of the model in DECLARE, and asses the use of DE CLARE for this purpose. The proof of type soundness itself is described in the next chapter. 6.1 Java Java <ref> [GJS96] </ref> is a programming language developed by Sun Microsystems, and has exploded in popularity over the last 3 years. Although sometimes over-hyped as heralding a new age of computing, the language design itself is highly competent, incorporating many ideas into a framework palatable for the existing base of C++ programmers. <p> Studies have uncovered flaws in the security of Java and its implementations, including its type system, and have pointed out the need for a formal semantics to complement the existing language definition <ref> [DFW96, GJS96] </ref>. A full formal treatment of many important aspects of the language (e.g. dynamic linking) has yet to be performed. Because of these things, type soundness is clearly a property we are interested in for this language. <p> The Java source language is compiled to a closely related bytecode format for the Java Virtual Machine (JVM). Although the languages are different, their type systems are quite similar. Java is defined by several standards, including those for the source language <ref> [GJS96] </ref> and the Java Virtual Machine [LY97]. 6.2 Our Model of Java S The aim of a type correctness proof is to bridge the gap between: * A model of the static checks performed on Java S programs; and * A model of the runtime execution of the same. <p> This process is described in detail in <ref> [GJS96] </ref>. 13 The heap is not garbage collected. A garbage collection rule allowing the collection of inaccessible items could be added. Note garbage collection is se mantically visible in Java because of the presence of finally methods. <p> One aspect of type soundness is captured in the following statement from the Java Language Specification <ref> [GJS96] </ref>: The type [of a variable or expression] limits the possible values that the variable can hold or the expression can produce at runtime. <p> There is no analogue of the class Object for interfaces; that is, while every class is an extension of class Object, there is no single interface of which all interfaces are extensions. 128 CHAPTER 7. TYPE SOUNDNESS FOR JAVA S <ref> [GJS96] </ref>, pages 87 and 185 The error was detected when trying to prove the existence of compatible methods and fields as we move from a type to a subtype, in particular from the type Object to an interface type. 7.4.2 Runtime Typechecking, Array Assignments, and Exceptions In Drossopoulou and Eisenbach's original
Reference: [GM93] <author> M.J.C Gordon and T.F Melham. </author> <title> Introduction to HOL: A Theorem Proving Assistant for Higher Order Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Where our techniques depart from best known practice we describe how they represent an improvement. By best known practice we mean the state-of-the-art in the domain as embodied in existing interactive theorem provers, such as Isabelle, ACL2, HOL and PVS <ref> [Pau90, GM93, COR + 95, KM96a, Har96a] </ref>. We use DECLARE as a means to demonstrate our ideas, though the ideas themselves are independent of the actual theorem proving system used. <p> Furthermore, as shall be clear in the following chapters, it is possible to draw on work from across the spectrum of theorem proving tools in order to provide this support. Some of the systems that have most influenced our work are: * HOL <ref> [GM93] </ref>. This is an implementation of polymorphic higher order logic implemented in an LCF-style [GMW77], that is the logic mechanized starting with a simple set of rules and axioms, and relies heavily on user-programmed rules of inference written in a dialect of ML. <p> Commonly cited specification languages include: axiomatization in first order logic; the Z and VDM notations [Spi88, Jac88]; variants of higher order logic (e.g. the specification languages of HOL <ref> [GM93] </ref>, PVS [COR + 95] and Isabelle/HOL [Pau90]); set theory; temporal logics; specialised formalisms for finite state machines and hardware; and restricted subsets of logic that are highly amenable 1 As distinct from the HOL or Isabelle/HOL implementations of higher order logic. 21 22 CHAPTER 2. <p> Sketching the Semantics For each construct we shall briefly describe its semantics by using a proof system with judgments * ` 0 , that is 0 is a conservative extension of (i.e. 0 possess a standard model (see <ref> [GM93] </ref>) if does); 2 * ` F, that is leads to a contradiction. 3 2 Actually the conservative extension relation is the reflexive transitive closure of this relation. 3 We prefer the simpler one-sided judgments ` F, as compared to the traditional two-sided sequent judgments of a sequent calculus because, when <p> Also see HOL <ref> [GM93] </ref> for proofs that such constructs do indeed form conservative extensions to higher order logic. ` F judgments are used when interpreting proofs. <p> use. 3.5 Second order Schema Application In principle, decomposition/enriching and automated proof with justifications are sufficient to describe any proof in higher order logic, assuming a modicum of power from the automated engine (e.g. that it implements the 8 primitive rules of higher order logic described by Gordon and Melham <ref> [GM93] </ref>). However, we have found it very useful to add one further construct for inductive arguments. The general form we have adopted is second-order schema application, which includes structural, rule and well-founded induction, and potentially a range of other proof strategies.
Reference: [GM95] <author> E. Gunter and S. Maharaj. </author> <title> Studying the ML module system in HOL. </title> <journal> The Computer Journal, </journal> <volume> 38(2):142151, </volume> <year> 1995. </year>
Reference-contexts: They proved some simple meta-level results, including the determinacy of the semantics, and developed a symbolic evaluator for proving results about particular programs. Gunter, Maharaj and Van Inwegen <ref> [ME93, GM95] </ref>, constructed a model for the dynamic semantics of the entire Standard ML language.
Reference: [GMW77] <author> Michael Gordon, R. Milner, and Christopher Wadsworth. </author> <title> Edin-burgh LCF. </title> <type> Internal Report CSR-11-77, </type> <institution> University of Edinburgh, Department of Computer Science, </institution> <month> September </month> <year> 1977. </year>
Reference-contexts: Some of the systems that have most influenced our work are: * HOL [GM93]. This is an implementation of polymorphic higher order logic implemented in an LCF-style <ref> [GMW77] </ref>, that is the logic mechanized starting with a simple set of rules and axioms, and relies heavily on user-programmed rules of inference written in a dialect of ML. HOL supports a wide range of specification constructs and automated reasoning routines. <p> INTRODUCTION terms of the logic. DECLARE has temporarily abandoned the traditional use of highly programmable meta-languages (such as the ML dialects in LCF-style systems <ref> [GMW77] </ref>) in order to investigate declarative rather than procedural proof specification techniques. The aim has been to find a small set of highly declarative commands to use for specification and proof, and we have found it useful to abandon the constraints of a strictly typed meta-language for this purpose. <p> Multiple goals are only useful for solving mutual recursion, and so the only proof rule we admit for the case n &gt; 1 is schema application. Modifying the semantic rule 3.1 for this case is straightforward. 3.6 Related Work 3.6.1 Tactics Tactics, first used in LCF <ref> [GMW77] </ref>, are the traditional mechanism for proof description in LCF-style systems.
Reference: [Gun94] <author> Elsa L. Gunter. </author> <title> A broader class of trees for recursive type definitions for HOL. </title> <editor> In Jeffery Joyce and Carl Seger, editors, </editor> <title> Higher Order Logic Theorem Proving and Its Applications, </title> <booktitle> volume 780 of BIBLIOGRAPHY 159 Lecture Notes in Computer Science, </booktitle> <pages> pages 141154. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1994. </year>
Reference-contexts: Often we need more specific algebras, e.g. well-typed programs. Typically we use predicate constraints to do this, defined inductively over the corresponding free algebra. Reductionist proofs of the existence of solutions (within higher order logic) for recursive type equations that include nested constructors have been automated by Gunter <ref> [Gun94] </ref>, and for simpler types by Melham [Mel88]. For our purposes it suffices to use a routine that generates the necessary axioms. Many other theorem provers admit a similar range of types (e.g. PVS, LCF and Is-abelle).
Reference: [Har95] <author> J. Harrison. </author> <title> Inductive Definitions: Automation and Application. </title> <editor> In E.T. Schubert, P.J. Windley, and J. Alves-Foss, editors, </editor> <booktitle> 8th International Workshop on Higher Order Logic Theorem Proving and its Applications, volume 971 of Lecture Notes in Computer Science, pages 200213, </booktitle> <address> Aspen Grove, Utah, USA, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: N) into this space. An inductive relation is the least fixed point of a monotonic set transformer F within the context of a universal set U . Such fixed points are guaranteed to exist by the Knaster-Tarski theorem [Tar55]. Good references to the theory and its mechanisation are <ref> [Pau94, JT92, Har95, PM93] </ref>. <p> Intuitively, a ; b holds if some derivation exists using only the rules above. In DECLARE we do not mechanise the theory of fixed points from first principles previous authors have addressed this issue <ref> [JT92, Har95, Pau94] </ref>. Instead, we use an axiomatization of each relation. Examples of the syntax of least fixed point declarations were shown in Section 1.4.3. 2.2.
Reference: [Har96a] <author> J. Harrison. </author> <title> HOL light: A tutorial introduction. </title> <editor> In M. Srivas and A. Camilleri, editors, </editor> <booktitle> First international conference on formal methods in computer-aided design, volume 1166 of Lecture Notes in Computer Science, </booktitle> <pages> pages 265269, </pages> <address> Palo Alto, CA, USA, November 1996. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: Where our techniques depart from best known practice we describe how they represent an improvement. By best known practice we mean the state-of-the-art in the domain as embodied in existing interactive theorem provers, such as Isabelle, ACL2, HOL and PVS <ref> [Pau90, GM93, COR + 95, KM96a, Har96a] </ref>. We use DECLARE as a means to demonstrate our ideas, though the ideas themselves are independent of the actual theorem proving system used. <p> The foundation is set theory, which pervades the system, and proofs are expressed as detailed proof outlines, leaving the machine to fill in the gaps. We discuss this system in more detail in Chapter 3. It has not been applied to operational seman tics. * HOL-lite <ref> [Har96a] </ref>. This is Harrison's elegant, rationalized implementation of HOL. Some confusing features have been dropped, and more effort has been put into automated reasoning routines. <p> Type checking is decidable and efficient, terms can be represented fairly compactly, and a fair degree of expressiveness is achieved. It is not ideal for all purposes, but is excellent for many. See Harrison's HOL-lite <ref> [Har96a] </ref> for an elegant implementation of h.o.l. from first principles. Logic of description v. logic of implementation Simple polymorphic higher order logic acts as the logic we use to provide a coherent semantic framework for the system we implement. We could call this the logic of discourse. <p> the type and term constants defined by D All ~c are fresh in ax is the algebraic axiom characterizing D ` ( sig ~c) ax ax It is possible to combine such rules into just one specification rule for type and term constants: see Harrison's rule in HOL-lite for example <ref> [Har96a] </ref>. Also see HOL [GM93] for proofs that such constructs do indeed form conservative extensions to higher order logic. ` F judgments are used when interpreting proofs.
Reference: [Har96b] <author> J. Harrison. </author> <title> A Mizar Mode for HOL. </title> <editor> In J. Von Wright, J. Grundy, and J. Harrison, editors, </editor> <booktitle> Ninth international Conference on Theorem Proving in Higher Order Logics TPHOL, volume 1125 of Lecture Notes in Computer Science, pages 203220, </booktitle> <address> Turku, Finland, August 1996. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: Proofs in DECLARE are expressed as proof outlines, in a language that approximates written mathematics. This builds on work done with similar languages by the Mizar group [Rud92] and Harrison <ref> [Har96b] </ref>. One traditional form of proof description is tactic proof, described more fully at the end of this chapter. <p> It is only in the specification that they are widely used. 3.6.3 Mizar Mizar is a well established system for formalizing general mathematics, and a phenomenal amount of the mathematical corpus has been covered. DECLARE has been inspired in part by the Mizar system and Harrison's `Mizar Mode' work <ref> [Har96b, Rud92] </ref>. In particular: * The concept of specifying proofs as documents in a palatable proof language is due to Mizar.
Reference: [Har97a] <author> John Harrison. </author> <title> First order logic in practice. </title> <editor> In Maria Paola Bonacina and Ulrich Furbach, editors, </editor> <booktitle> Int. Workshop on First-Order Theorem Proving (FTP'97), RISC-Linz Report Series No. </booktitle> <pages> 97-50, pages 8690. </pages> <institution> Johannes Kepler Universitat, Linz (Austria), </institution> <year> 1997. </year>
Reference-contexts: First order reasoning has been largely neglected in interactive higher order logic based theorem provers (e.g. PVS has no support for unification and HOL existed for years without it), with Isabelle being the major exception. In his summary of first order proof in practice <ref> [Har97a] </ref> , Harrison describes the situation of interactive theorem proving with respect to first order techniques as follows: There is a trend away from monolithic automated theorem provers towards using automation as a tool in support of interactive proof. ... It raises a number of issues that are often neglected... <p> The Horn clause restriction is also lifted by using the contrapositives of a set of formulae as the rule set. Model elimination is a simple and effective way to perform goal directed search, and as Harrison has reported <ref> [Har97a] </ref> in some cases it can even work effectively when the equality axioms are used directly. <p> To the author's knowledge, no other interactive prover uses automatic solving techniques during rewriting to the same extent as DECLARE: searching for such solutions is quite computationally expensive but exceptionally useful. Model elimination was first used in interactive higher order logic based theorem proving by Paulson and then Harrison <ref> [Har97a] </ref>, and in general we owe much to Harrison's excellent implementations of model checking and other procedures in HOL-lite. 84 CHAPTER 4.
Reference: [Har97b] <author> John R. Harrison. </author> <title> Proof style. </title> <type> Technical Report 410, </type> <institution> University of Cambridge Computer Laboratory, </institution> <address> Cambridge, CB2 3QG, U.K., </address> <month> January </month> <year> 1997. </year>
Reference-contexts: The technique represents a somewhat radical departure from standard practice in higher order logic theorem proving, and we explain the pros and cons of the approach. 3.1 The Principles of Declarative Proof Harrison <ref> [Har97b] </ref> describes several different uses of the word proof in the field of automated reasoning. Three of these are of interest here: 1.
Reference: [HJ89] <author> Ian J. Hayes and Cliff B. Jones. </author> <title> Specifications are not (necessarily) executable. </title> <type> Technical Report UMCS-90-12-1, </type> <institution> Department of Computer Science, University of Manchester, </institution> <address> Manchester M13 9PL, England, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: The executability of specifications has been widely discussed amongst users of the Z specification methodology. Early work by Hayes and Jones <ref> [HJ89] </ref> identified that executable specifications may be inferior to non-executable ones.
Reference: [Hut90] <author> Matthew Hutchins. </author> <title> Machine assisted reasoning about Standard ML using HOL, </title> <month> November </month> <year> 1990. </year> <institution> Australian National University Honours Thesis. </institution>
Reference-contexts: INTRODUCTION * Syme and Hutchins have embedded the dynamic semantics of the core language of Standard ML in the HOL system <ref> [Hut90, Sym93] </ref>. They proved some simple meta-level results, including the determinacy of the semantics, and developed a symbolic evaluator for proving results about particular programs. Gunter, Maharaj and Van Inwegen [ME93, GM95], constructed a model for the dynamic semantics of the entire Standard ML language.
Reference: [Inw96] <author> Myra Van Inwegen. </author> <title> The machine-assisted proof of programming language properties. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <month> December </month> <year> 1996. </year>
Reference-contexts: Gunter, Maharaj and Van Inwegen [ME93, GM95], constructed a model for the dynamic semantics of the entire Standard ML language. Van Inwegen has tackled the considerably more difficult task of proving type soundness for the core language <ref> [Inw96] </ref>, though the proof itself was beset with difficulties. * Norrish [Nor98] has developed a model of the C language in HOL based on the (informal) ANSI standard.
Reference: [Jac88] <author> M. I. Jackson. </author> <title> An overview of VDM. </title> <journal> SafetyNet, </journal> <volume> 2, </volume> <month> September </month> <year> 1988. </year>
Reference-contexts: Typically each technique is accompanied by a logic for use with the specification language, although sometimes the specification language is precisely the logic and sometimes no coherent and complete logic is immediately apparent. Commonly cited specification languages include: axiomatization in first order logic; the Z and VDM notations <ref> [Spi88, Jac88] </ref>; variants of higher order logic (e.g. the specification languages of HOL [GM93], PVS [COR + 95] and Isabelle/HOL [Pau90]); set theory; temporal logics; specialised formalisms for finite state machines and hardware; and restricted subsets of logic that are highly amenable 1 As distinct from the HOL or Isabelle/HOL implementations
Reference: [JDD94] <author> J. Joyce, N. Day, and M. Donat. </author> <title> S: A machine readable specification notation based on higher order logic. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 859:285ff, </address> <year> 1994. </year> <note> 160 BIBLIOGRAPHY </note>
Reference-contexts: Whals et al. do not consider the important issue of leveraging the static analysis algorithms available in the underlying logic programming engine clearly Mercury is particularly strong in this regard. Andrews [And97] translates the specification language S <ref> [JDD94] </ref> to Lambda Prolog [FGMP90], a higher order Prolog, and this work has quite a similar feel to our own. The result is convincing as far as it goes, however again static analyses are not utilised.
Reference: [JH94] <author> Sverker Janson and Seif Haridi. </author> <title> An introduction to AKL, A multi-paradigm programming language. </title> <editor> In B. Mayoh, E. Tyugu, and J. Penjaam, editors, </editor> <booktitle> Constraint Programming: Proceedings 1993 NATO ASI Parnu, Estonia, NATO Advanced Science Institute Series, </booktitle> <pages> pages 411443. </pages> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: Thus a specification can be given in a natural fashion, and an equivalence or refinement with an executable version can be proved. Wahls, Leavens and Baker [WLB98] use the constraint based programming language AKL <ref> [JH94] </ref> to provide an execution apparatus for their language SPECS-C++. The apparatus is roughly as flexible as our own, though the flexibility is provided by quite a different means: for example Mercury places con-juncts in a sensible execution order using mode analysis, while AKL does this by propagating constraints.
Reference: [JJM + 95] <author> J. Gulmann, J. Jensen, M. Jrgensen, N. Klarlund, T. Rauhe, and A. Sandholm. Mona: </author> <title> Monadic second-order logic in practice. </title> <editor> In U.H. Engberg, K.G. Larsen, and A. Skou, editors, </editor> <booktitle> TACAS, </booktitle> <pages> pages 5873. </pages> <publisher> Springer Verlag, LNCS, </publisher> <year> 1995. </year>
Reference-contexts: SPECIFICATION AND VALIDATION to automation (e.g. Monadic 2nd Order Logic <ref> [JJM + 95] </ref>) and process calculi. This is not the place to give a detailed analysis of the merits of these methods: Rushby has written a good introductory overview [Rus93].
Reference: [JT92] <author> J. Camilleri and T.F. Melham. </author> <title> Reasoning with inductively defined relations in the HOL theorem prover. </title> <type> Technical Report 265, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: summarize why in Chapter 8. 1.3.2 Related Work Many attempts have been made to reason about the operational semantics of programming languages in theorem proving systems: * Melham and Camilleri pioneered representational techniques for inductive relations in the HOL system and studied the operational semantics of some small imperative languages <ref> [JT92] </ref>. This culminated in the proof of the Church-Rosser theorem for combinatorial logic. <p> N) into this space. An inductive relation is the least fixed point of a monotonic set transformer F within the context of a universal set U . Such fixed points are guaranteed to exist by the Knaster-Tarski theorem [Tar55]. Good references to the theory and its mechanisation are <ref> [Pau94, JT92, Har95, PM93] </ref>. <p> Intuitively, a ; b holds if some derivation exists using only the rules above. In DECLARE we do not mechanise the theory of fixed points from first principles previous authors have addressed this issue <ref> [JT92, Har95, Pau94] </ref>. Instead, we use an axiomatization of each relation. Examples of the syntax of least fixed point declarations were shown in Section 1.4.3. 2.2.
Reference: [KB70] <author> D. E. Knuth and P. B. Bendix. </author> <title> Simple word problems in universal algebra. </title> <editor> In J. Leech, editor, </editor> <booktitle> Computational problems in abstract algebra, </booktitle> <pages> pages 263297. </pages> <publisher> Pergamon Press, </publisher> <address> Elmsford, N.Y, </address> <year> 1970. </year>
Reference-contexts: Like most theorem provers, DECLARE comes with theories of important constructs such as partial functions, sets, finite partial functions, finite sets, first order logic and lists. Rewriting gives effective (though incomplete) proof procedures in many of these domains . DECLARE does not implement Knuth-Bendix completion <ref> [KB70] </ref> on its rewrite set. It would be desirable to investigate the costs and benefits of this routine in the context of this problem domain, since occasionally the user must artificially modify the statement theorems to ensure a confluent and complete rewrite strategy.
Reference: [KM96a] <author> Matt Kaufmann and J. Strother Moore. ACL2: </author> <title> An industrial strength version of Nqthm. </title> <booktitle> COMPASS Proceedings of the Annual Conference on Computer Assurance, </booktitle> <pages> pages 2334, </pages> <year> 1996. </year> <journal> IEEE catalog number 96CH35960. </journal>
Reference-contexts: Where our techniques depart from best known practice we describe how they represent an improvement. By best known practice we mean the state-of-the-art in the domain as embodied in existing interactive theorem provers, such as Isabelle, ACL2, HOL and PVS <ref> [Pau90, GM93, COR + 95, KM96a, Har96a] </ref>. We use DECLARE as a means to demonstrate our ideas, though the ideas themselves are independent of the actual theorem proving system used.
Reference: [KM96b] <author> Matt Kaufmann and J Strother Moore. ACL2: </author> <title> An industrial strength version of nqthm. </title> <booktitle> In Compass'96: Eleventh Annual Conference on Computer Assurance, </booktitle> <pages> page 23, </pages> <address> Gaithersburg, Maryland, </address> <year> 1996. </year> <institution> National Institute of Standards and Technology. </institution>
Reference-contexts: This is an implementation of a rich higher order logic, including predicate subtypes, notable for its excellent interactive environment, powerful integrated decision procedures and pragmatic approach 1.4. DECLARATIVE THEOREM PROVING AND DECLARE 7 to integrating model checking. It has not been widely applied to opera tional semantics. * ACL2 <ref> [KM96b] </ref>. ACL2 and its predecessor Nqthm implement an integrated collection of rules for defining (or axiomatizing) recursive functions, stating properties of those functions, and rigorously establishing those properties. They are notable for their use of decision procedures, the pioneering use of rewriting, the underlying computational model and their induction heuristics.
Reference: [Lov68] <author> D. W. Loveland. </author> <title> Mechanical Theorem Proving by Model Elimination. </title> <journal> Journal of the ACM, </journal> <volume> 15:236251, </volume> <year> 1968. </year>
Reference-contexts: Combing first order proof with equational reasoning is particularly challenging: although equality may be axiomatized, this is not terribly effective, and special heuristic rules for equality are often used. The first order technique we use is model elimination <ref> [Lov68] </ref>, which is essentially the natural completion of Prolog as a proof technique when negation-as-failure is excluded. The Horn clause restriction is also lifted by using the contrapositives of a set of formulae as the rule set.
Reference: [LP92] <author> Zhaohui Luo and Robert Pollack. </author> <title> The LEGO proof development system: A user's manual. </title> <type> Technical Report ECS-LFCS-92-211, </type> <institution> University of Edinburgh, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: These styles have not been systematized, and in often resemble aspects of our declarative proof language (e.g. Harrison is often careful to give sensible names when introducing local constants). In addition, Bailey [Bai98] has looked closely at the role of literate programming in supporting readable proofs for the LEGO <ref> [LP92] </ref> proof assistant, in the context of a major proof in algebra. He adopted a limited style of proof in places in order to maximize readability. His source texts are not themselves particularly readable they first require extensive translation to L A T E X.
Reference: [LY97] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: The Java source language is compiled to a closely related bytecode format for the Java Virtual Machine (JVM). Although the languages are different, their type systems are quite similar. Java is defined by several standards, including those for the source language [GJS96] and the Java Virtual Machine <ref> [LY97] </ref>. 6.2 Our Model of Java S The aim of a type correctness proof is to bridge the gap between: * A model of the static checks performed on Java S programs; and * A model of the runtime execution of the same.
Reference: [Mau91] <author> M. Mauny. </author> <title> Functional programming using CAML. </title> <type> Technical Report RT-0129, </type> <institution> National Institute for Research in Computer and Control Sciences (INRIA), </institution> <year> 1991. </year>
Reference-contexts: The modules are compiled together and linked against some core functionality and a main program that executes all test pragmas (see also the example on page 13). 2.4.3 Related Work A previous version of this work generated executable code by compiling specifications to CaML-light <ref> [Mau91] </ref> and performing a modicum of mode analysis during this translation (see [Sym97b]). Although useful at the time, the translation was clumsy in comparison to the translation to Mercury. The Mercury version allows considerably more flexibility in the style in which specifications are written.
Reference: [MBBC95] <author> Z. Manna, N. Bjoerner, A. Browne, and E. Chang. </author> <title> STeP: The Stanford Temporal Prover. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 915:793ff, </address> <year> 1995. </year>
Reference-contexts: Nel-son and Oppen have a quite general scheme that has been successfully re-implemented in theorem proving systems [NO79, Bou95]. Shostak has an alternative scheme that is less general but reputedly faster, and this is used in the STeP and PVS theorem provers <ref> [Sho84, MBBC95, COR + 95] </ref>. 3 This subset (Presburger arithmetic) is usually expanded to include rational constants and functions that can be encoded in a linear/propositional framework, e.g. abs, max, min etc.
Reference: [McA89] <author> David McAllester. </author> <title> Ontic. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year> <note> BIBLIOGRAPHY 161 </note>
Reference-contexts: MacAllester has considered the question of obviousness with regard to automated deduction, and he has implemented some of his ideas in the Ontic system <ref> [McA89] </ref>. We have not tried to develop obviousness as an absolute concept, and are really more concerned with an automated prover that allows us to specify proof outlines that are, in some limited sense, natural.
Reference: [ME93] <editor> M. van Inwegen and E.L. Gunter. HOL-ML. In J.J. Joyce and C.-J.H. Seger, editors, </editor> <booktitle> International Workshop on Higher Order Logic Theorem Proving and its Applications, volume 780 of Lecture Notes in Computer Science, </booktitle> <pages> pages 5973, </pages> <address> Vancouver, Canada, </address> <month> August </month> <year> 1993. </year> <institution> University of British Columbia, </institution> <note> Springer-Verlag, published 1994. </note>
Reference-contexts: They proved some simple meta-level results, including the determinacy of the semantics, and developed a symbolic evaluator for proving results about particular programs. Gunter, Maharaj and Van Inwegen <ref> [ME93, GM95] </ref>, constructed a model for the dynamic semantics of the entire Standard ML language.
Reference: [Mel88] <author> Thomas F. Melham. </author> <title> Automating recursive type definitions in higher order logic. </title> <type> Technical Report 146, </type> <institution> University of Cambridge Computer Laboratory, </institution> <address> Cambridge CB2 3QG, England, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: Typically we use predicate constraints to do this, defined inductively over the corresponding free algebra. Reductionist proofs of the existence of solutions (within higher order logic) for recursive type equations that include nested constructors have been automated by Gunter [Gun94], and for simpler types by Melham <ref> [Mel88] </ref>. For our purposes it suffices to use a routine that generates the necessary axioms. Many other theorem provers admit a similar range of types (e.g. PVS, LCF and Is-abelle). Simple higher order logic requires that types be non-empty, and thus an initiality condition must be proved for each datatype.
Reference: [Mel91] <author> T. F. Melham. </author> <title> A mechanized theory of the -calculus in HOL. </title> <booktitle> In Informal Proceedings of the Second Logical Framework Workshop, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: There are many other similar works on a smaller scale, for example those by Frost, Nesi and Melham <ref> [Fro93, Nes92, Mel91] </ref>. As indicated by the above list, researchers have applied a range of theorem proving tools to assist with the formal checking of proofs related to operational semantics.
Reference: [Mel92] <author> Thomas F. Melham. </author> <title> The HOL logic extended with quantification over type variables. </title> <editor> In L.J.M. Claesen and M.J.C. Gordon, editors, </editor> <booktitle> International Workshop on Higher Order Logic Theorem Proving and its Applications, </booktitle> <pages> pages 318, </pages> <address> Leuven, Belgium, </address> <month> September </month> <year> 1992. </year> <booktitle> IFIP TC10/WG10.2, </booktitle> <publisher> North-Holland. IFIP Transactions. </publisher>
Reference-contexts: Many typing schemes are possible: we adopt the simple polymorphic typing scheme used in HOL and Isabelle. Other typing schemes, notably that of PVS, address issues such as predicate and structural subtyping. Melham's system allows quantification over type variables <ref> [Mel92] </ref>, and one can also admit record types. We have been able to survive without such features in our case study. The primitive terms of higher order logic are as in the -calculus: variables, constants, applications and functions. <p> We have not found this form useful in case studies. 5 Specification constructs that generate new monomorphic types within proofs would require quantification over type variables in the underlying logic <ref> [Mel92] </ref>, and admitting polymorphic types would require quantification over type functions. However, there is little need for the definition of types mid-proof. 46 CHAPTER 3. DECLARATIVE PROOF DESCRIPTION 3.3.1 A longer example We shall now look at a longer example of the use of enrichment/decomposition. <p> If we want to prove that W 1 is divergent, we use co-induction over an appropriately strengthened goal: 10 thm &lt;example&gt; if "W1 --&gt; W2" 9 Note type constants may not vary: this could be supported if we admitted quantification over type variables <ref> [Mel92] </ref> in the underlying logic. 10 Note we use co-induction to demonstrate membership of the set, and rules to prove nonmembership. This is the opposite way around to the inductive case, as expected! 58 CHAPTER 3.
Reference: [Mil80] <author> Robin Milner. </author> <title> A Calculus for Communicating Systems, </title> <booktitle> volume 92 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: Classic examples of its use include the formal definition of Standard ML [MTHM97] and the definition and theory of CCS <ref> [Mil80] </ref>.
Reference: [MLP79] <author> Richard A. De Millo, Richard J. Lipton, and Alan J. Perlis. </author> <title> Social processes and proofs of theorems and programs. </title> <journal> Communications of the ACM, </journal> <volume> 22(5):271280, </volume> <month> May </month> <year> 1979. </year>
Reference-contexts: In many ways, these issues form the heart of the matter. Proof is, after all, a social process as well as a formal one, as argued by De Millo, Lipton and Perlis <ref> [MLP79] </ref>. Presuming declarative proof description can be made at least as efficient as existing proof description techniques in the small, then the benefits in the large may well tip the balance in its favour.
Reference: [MS97] <author> Muller and Slind. </author> <title> Treating partiality in logic of total functions. </title> <journal> COMPJ: The Computer Journal, </journal> <volume> 40, </volume> <year> 1997. </year>
Reference-contexts: What happens outside this domain can vary greatly according to the logical treatment chosen. Muller and Slind's excellent overview of different treatments in a logic of total functions <ref> [MS97] </ref> demonstrates that it is essential to take an approach to partiality that is both accurate and pragmatic. The basic approaches available when using h.o.l. are: * Define fully. The function is given particular values outside its domain. * Underspecify.
Reference: [MTDR88] <author> M.J.C. Gordon, T.F. Melham, D. Sheperd, and R. Boulton. </author> <title> The UNWIND Library. Manual part of the HOL system, </title> <year> 1988. </year>
Reference-contexts: PVS, STeP and other systems implement various mixtures of ground decision procedures, and integrate them into the rewriting process. The elimination of existential and universal quantifiers by automatic solving is a generalisation of the manual unwinding techniques from HOL <ref> [MTDR88] </ref>, and relates to many adhoc (and often manual) techniques developed in other theorem provers. To the author's knowledge, no other interactive prover uses automatic solving techniques during rewriting to the same extent as DECLARE: searching for such solutions is quite computationally expensive but exceptionally useful.
Reference: [MTHM97] <author> Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> The MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: Classic examples of its use include the formal definition of Standard ML <ref> [MTHM97] </ref> and the definition and theory of CCS [Mil80].
Reference: [MW97] <author> William McCune and Larry Wos. </author> <title> Otterthe CADE-13 competition incarnations. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 18(2):211 220, </volume> <month> April </month> <year> 1997. </year>
Reference-contexts: This is, needless to say, an extremely difficult task! Unfortunately most existing work in automating non-propositional reasoning has produced provers that are far from black box. To take one example, the first order prover Otter <ref> [MW97] </ref> has over 100 different switches and endless potential configurations and, although each has its purpose, there has been no real attempt to characterize which switches are appropriate for which classes of problems, making the use of such provers somewhat of a black art. 2 Proof combined system. 2 Recently, an
Reference: [Nes92] <author> M. Nesi. </author> <title> Formalizing a modal logic for CSS in the HOL theorem prover. </title> <editor> In L.J.M. Claesen and M.J.C. Gordon, editors, </editor> <booktitle> International Workshop on Higher Order Logic Theorem Proving and its Applications, </booktitle> <pages> pages 279294, </pages> <address> Leuven, Belgium, </address> <month> September </month> <year> 1992. </year> <booktitle> IFIP TC10/WG10.2, </booktitle> <publisher> North-Holland. IFIP Transactions. </publisher>
Reference-contexts: There are many other similar works on a smaller scale, for example those by Frost, Nesi and Melham <ref> [Fro93, Nes92, Mel91] </ref>. As indicated by the above list, researchers have applied a range of theorem proving tools to assist with the formal checking of proofs related to operational semantics.
Reference: [Nip89] <author> Tobias Nipkow. </author> <title> Equational reasoning in Isabelle. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 12(2):123149, </address> <month> July </month> <year> 1989. </year>
Reference-contexts: the final result); normalization (does the rewrite system reduce terms to a normal form?); and completeness (does the rewrite systems fully solve a class of problems?) An excellent introduction to the theory of rewriting can be found in [BN98] and implementations in HOL and Isabelle are documented in [Bou92] and <ref> [Nip89] </ref>. Some typical enhancements to basic rewriting described above are: * Conditional rewriting, e.g. i &gt; 0 ^ i length (t) ! el (i)(h :: t) ; el (i 1)(t) perhaps using decision procedures to solve conditions. * 2nd order and higher order matching.
Reference: [Nip96] <author> T. Nipkow. </author> <title> More Church-Rosser proofs (in Isabelle/HOL). </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 1104:733ff, </address> <year> 1996. </year> <note> 162 BIBLIOGRAPHY </note>
Reference-contexts: This culminated in the proof of the Church-Rosser theorem for combinatorial logic. The proof has since been reworked and improved in Isabelle <ref> [Ras95, Nip96] </ref>. * Nipkow, Naraschewski and Nazareth have proved the correctness of the W algorithm for type inference for a small functional language, using Isabelle-HOL [DT96]. 1 We do not use model in its proof theoretic sense, but rather to distinguish the abstract formal system (as expressed in the written mathematical
Reference: [NL95] <author> William Newman and Mik Lamming. </author> <title> Interactive Systems Design. </title> <publisher> Addison-Wesley, </publisher> <month> December </month> <year> 1995. </year>
Reference-contexts: Comparing two systems that support the same overall tasks is considerably simpler. 3 There are, of course, many other issues involved in overall usability. See Chapter 1 of <ref> [NL95] </ref> for an excellent informal description. 5.2. IDECLARE 87 88 CHAPTER 5. INTERACTION FOR DECLARATIVE PROOF and stepping inside constructs such as case-splits. This is discussed fur ther in the next section. * Visualisation. <p> The times used are not meant to be definitive, and do not represent the outcome of a controlled experiment. They are merely indicative, and based on the author's experience. This method of analysis is adapted from the analysis techniques in Chapter 8 of Newman and Lamming's Interactive System Design <ref> [NL95] </ref>. The task we shall analyse is that described in the previous section: correcting an error in a justification in a proof. We have already outlined the steps required to do this in IDECLARE.
Reference: [NO79] <author> C. G. Nelson and D. C. Oppen. </author> <title> Simplifications by cooperating decision procedures. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 1(2), </volume> <year> 1979. </year>
Reference-contexts: Nel-son and Oppen have a quite general scheme that has been successfully re-implemented in theorem proving systems <ref> [NO79, Bou95] </ref>.
Reference: [NO80] <author> Greg Nelson and Derek C. Oppen. </author> <title> Fast decision procedures based on congruence closure. </title> <journal> Journal of the ACM, </journal> <volume> 27(2):356364, </volume> <month> April </month> <year> 1980. </year>
Reference-contexts: R, using only &lt;, &gt;, , , =, &lt;&gt;, +, ); 3 * Equational logic in the presence of uninterpreted function symbols, e.g. a = g (b) ! f (a; g (b)) = f (a; a), normally implemented by a congruence closure algorithm <ref> [NO80] </ref>; Frameworks exist for combining decision procedures for various theories. Nel-son and Oppen have a quite general scheme that has been successfully re-implemented in theorem proving systems [NO79, Bou95]. <p> The implementation is very naive (for example no term graph is used, but rather we explicitly substitute), but sufficient for our case studies. The central database is a sequence of convex sub-databases <ref> [NO80] </ref>, each corresponding to one case of the disjunctive normal form of the propositional structure of the logical environment. Each convex database supports assert and satisfy functions. The former is used to add available ground equalities, inequalities and propositional formulae.
Reference: [Nor98] <author> Michael Norrish. </author> <title> C Formalized in HOL. </title> <type> PhD thesis, </type> <institution> University of Cambridge, </institution> <month> August </month> <year> 1998. </year> <note> Submitted for examination. </note>
Reference-contexts: Gunter, Maharaj and Van Inwegen [ME93, GM95], constructed a model for the dynamic semantics of the entire Standard ML language. Van Inwegen has tackled the considerably more difficult task of proving type soundness for the core language [Inw96], though the proof itself was beset with difficulties. * Norrish <ref> [Nor98] </ref> has developed a model of the C language in HOL based on the (informal) ANSI standard. The main difficulty here was to even find a model for the language, and to derive results that avoid the complexities of the language when only simple constructs are used, e.g. <p> Table 3.3 presents statistics from three developments: the Java case study using DECLARE described in Chapters 6 and 7, a similar work by von Oheimb in Isabelle [Nv98] (see also Section 7.5.1), and Norrish's study of the operational semantics of C <ref> [Nor98] </ref>). A caveat: The studies are substantially different and the statistics are only meant to give a rough impression of the nature of the style of proof and specification used! Controlled experiments are possible in such a domain, but require a significant resources.
Reference: [Nv98] <author> T. Nipkow and D. von Oheimb. </author> <title> Java `ight is type-safe definitely. </title> <booktitle> In 25th ACM Symp. Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1998. </year>
Reference-contexts: Nor-rish has proved that in some situations the side-effecting nature of expressions may be safely ignored. We use this work to statistically contrast declarative and procedural styles of proof in Chapter 3. * Nipkow and von Oheimb <ref> [Nv98] </ref> have developed a proof of the type soundness of a subset of Java that closely resembles our own case study (see Chapter 6). There are many other similar works on a smaller scale, for example those by Frost, Nesi and Melham [Fro93, Nes92, Mel91]. <p> Table 3.3 presents statistics from three developments: the Java case study using DECLARE described in Chapters 6 and 7, a similar work by von Oheimb in Isabelle <ref> [Nv98] </ref> (see also Section 7.5.1), and Norrish's study of the operational semantics of C [Nor98]). <p> JAVA S The types that appear in the concrete syntax of Java S expressions are also shown in Figure 6.2. Following Oheimb's treatment <ref> [Nv98] </ref> we extend the domain of types to include a primitive void type, a null type to assign to the null literal during typechecking, and syntactically differentiate between reference and plain types. 45 We use t and to range over types, the latter used for method return types. 6.3 Preliminaries In <p> The statement of subject reduction does Wright and Felleisen [WF94] have studied type soundness proof techniques for a wide range of language constructs, though not for Java itself. They have not mechanized their proofs. Tobias Nipkow and David von Oheimb <ref> [Nv98] </ref> have developed a proof of the type soundness property for a similar subset of Java in the Isabelle theorem prover.
Reference: [Pau90] <author> L. C. Paulson. </author> <title> Isabelle: The next 700 theorem provers. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 361385. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: Where our techniques depart from best known practice we describe how they represent an improvement. By best known practice we mean the state-of-the-art in the domain as embodied in existing interactive theorem provers, such as Isabelle, ACL2, HOL and PVS <ref> [Pau90, GM93, COR + 95, KM96a, Har96a] </ref>. We use DECLARE as a means to demonstrate our ideas, though the ideas themselves are independent of the actual theorem proving system used. <p> HOL supports a wide range of specification constructs and automated reasoning routines. Proofs are described using tactics, a topic we shall return to in Section 3.6.1. * Isabelle <ref> [Pau90] </ref>. This is also an LCF-style system, but is generic and may be instantiated to a number of different object logics, including polymorphic higher order logic and set theory. Specification is succinct and a wide range of notational conventions are supported. <p> Commonly cited specification languages include: axiomatization in first order logic; the Z and VDM notations [Spi88, Jac88]; variants of higher order logic (e.g. the specification languages of HOL [GM93], PVS [COR + 95] and Isabelle/HOL <ref> [Pau90] </ref>); set theory; temporal logics; specialised formalisms for finite state machines and hardware; and restricted subsets of logic that are highly amenable 1 As distinct from the HOL or Isabelle/HOL implementations of higher order logic. 21 22 CHAPTER 2. SPECIFICATION AND VALIDATION to automation (e.g. <p> Grinding also eliminates local constants defined by an equality, so if a = t is a fact then a can be eliminated in favour of the term t. The set of safe rules could be made extensible by using methods from the Isabelle theorem prover <ref> [Pau90] </ref>. Pattern Based Splitting and Weakening Splitting follows fairly conventional lines, splitting on disjunctive formulae as in PVS, Isabelle and indeed most automated provers.
Reference: [Pau94] <author> L.C. Paulson. </author> <title> A fixedpoint approach to implementing (co)inductive definitions. </title> <editor> In Alan Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, volume 814 of LNAI, </booktitle> <pages> pages 148161, </pages> <address> Berlin, June/July 1994. </address> <publisher> Springer. </publisher>
Reference-contexts: N) into this space. An inductive relation is the least fixed point of a monotonic set transformer F within the context of a universal set U . Such fixed points are guaranteed to exist by the Knaster-Tarski theorem [Tar55]. Good references to the theory and its mechanisation are <ref> [Pau94, JT92, Har95, PM93] </ref>. <p> Intuitively, a ; b holds if some derivation exists using only the rules above. In DECLARE we do not mechanise the theory of fixed points from first principles previous authors have addressed this issue <ref> [JT92, Har95, Pau94] </ref>. Instead, we use an axiomatization of each relation. Examples of the syntax of least fixed point declarations were shown in Section 1.4.3. 2.2. <p> SPECIFICATION CONSTRUCTS FOR OPERATIONAL SEMANTICS 27 In the present implementation we do not generate the associated mono-tonicity proof obligations, since this is well-understood, as is the automatic checking of monotonicity conditions (e.g. see the Isabelle implementation <ref> [Pau94] </ref>). Explicit proofs of monotonicity could be given in the proof language described in the next chapter, if necessary. As with datatypes, theorems are generated that encode the logical properties of inductive relations in DECLARE.
Reference: [Pau97] <author> L.C. Paulson. </author> <title> Proving properties of security protocols by induction. </title> <booktitle> In PCSFW: Proceedings of The 10th Computer Security Foundations Workshop. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1997. </year>
Reference-contexts: Such formalizations are extremely common in computer science, and are used to provide specifications of: * The dynamic execution of programs; * Static checks on programs such as type checking and inference; * Statics and dynamics for highly non-deterministic systems such as process calculi; * Security protocols <ref> [Pau97] </ref>. Real machines such as hardware devices can also be described operationally, presuming an appropriate level of abstraction is chosen. Formal checking means proving properties to a sufficient degree that our formalization may be checked by a relatively simple computer program.
Reference: [PB97] <author> Roly Perera and Peter Bertelsen. </author> <title> The unofficial java bug report, </title> <month> June </month> <year> 1997. </year> <note> Once published on the WWW at http://www2.vo.lu/homepages/gmid/java.htm. </note>
Reference-contexts: presentation of the type soundness proof. 7.4.1 An Error in the Java Language Specification In the process of finishing the proofs of the lemmas described in Section 7.2.1 we independently rediscovered a significant flaw in the Java language specification that had recently been found by developers of a Java implementation <ref> [PB97] </ref>. In theory the flaw does not break type soundness, but the authors of the language specification have confirmed that the specification needs alteration.
Reference: [Plo91] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical report, </type> <institution> Computer Science Department, Aarhus University, </institution> <address> DK-8000 Aarhus C. Denmark, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Finally in Chapter 8 we reiterate the major themes we have addressed, summarize our results and discuss possible avenues for future research. 1.2 Structured Operational Semantics and its Uses This work shall focus on systems described by Structured Operational Semantics, a kind of operational description first developed systematically by Plotkin <ref> [Plo91] </ref> and which has subsequently become the standard technique for describing the formal semantics of programming languages, type systems and process calculi. Classic examples of its use include the formal definition of Standard ML [MTHM97] and the definition and theory of CCS [Mil80]. <p> : : : ; (C n ; fld n ) 7! val n C (object) | [[val 0 ; : : : ; val n1 ]] t (array) 6.6 The Runtime Semantics We follow Drossopoulou and Eisenbach and model execution by a transition semantics, i.e. a small step rewrite system <ref> [Plo91] </ref>. A small step system is chosen over a big step (evaluation semantics) because it enables us to state substantially stronger results about the runtime machine in particular we can prove that the abstract machine does not get stuck (see the liveness result in Chapter 7).
Reference: [PM93] <author> Chr. Paulin-Mohring. </author> <title> Inductive definitions in the system Coq; rules and properties. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 664:328ff, </address> <year> 1993. </year>
Reference-contexts: N) into this space. An inductive relation is the least fixed point of a monotonic set transformer F within the context of a universal set U . Such fixed points are guaranteed to exist by the Knaster-Tarski theorem [Tar55]. Good references to the theory and its mechanisation are <ref> [Pau94, JT92, Har95, PM93] </ref>.
Reference: [PR98] <author> F. Pessaux and F. Rouaix. </author> <title> The O'Caml-Tk implementation, 1998. From the O'Caml system distribution., </title> <note> available at http://pauillac.inria.fr/caml. </note>
Reference-contexts: Some elements of the feedback are again displayed in hypertext form, e.g. counter examples can be accessed by clicking on a highlighted region. This means large amounts of feedback can be displayed quickly and compactly. IDECLARE is implemented in Objective Caml-Tk <ref> [PR98] </ref> in 2000 lines of code, plus 10,000 lines shared with the batch-mode DECLARE implementation.
Reference: [Qia97] <author> Zhenyu Qian. </author> <title> A Formal Specification of Java Virtual Machine Instructions. </title> <type> Technical report, </type> <institution> Universitat Bremen, FB3 Informatik, D-28334 Bremen, Germany, </institution> <month> November </month> <year> 1997. </year> <note> BIBLIOGRAPHY 163 </note>
Reference-contexts: The two are closely related but the difference is non-trivial: for example there are JVM bytecodes that do not correspond to any Java text. Thus it remains a challenge to formalize and verify the corresponding type soundness property for the JVM (for an attempt see <ref> [Qia97] </ref>). However, unlike many high-level/low-level language combinations (e.g. C++/assembler) the type systems of Java and the JVM are closely related, and a comprehensive study of the former is a useful precursor to the study of the latter. <p> Isabelle is a mature system and has complementary strengths to DECLARE, notably strong generic automation and manifest soundness. A tool which unites these strengths with DECLARE's would be an exciting prospect. Several groups are working on type soundness properties for aspects of the JVM <ref> [SA98, Qia97] </ref>. These proofs have not yet been mechanized, and thus are somewhat removed from the concerns of this thesis. Chapter 8 Summary The aim of this dissertation has been to describe the use of a technique called declarative theorem proving to fully formalise reasoning about operational semantics.
Reference: [Ras95] <author> Ole Rasmussen. </author> <title> The Church-Rosser theorem in Isabelle: A proof porting experiment. </title> <type> Technical Report 364, </type> <institution> University of Cam-bridge, Computer Laboratory, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: This culminated in the proof of the Church-Rosser theorem for combinatorial logic. The proof has since been reworked and improved in Isabelle <ref> [Ras95, Nip96] </ref>. * Nipkow, Naraschewski and Nazareth have proved the correctness of the W algorithm for type inference for a small functional language, using Isabelle-HOL [DT96]. 1 We do not use model in its proof theoretic sense, but rather to distinguish the abstract formal system (as expressed in the written mathematical
Reference: [Rud92] <author> P. Rudnicki. </author> <title> An overview of the MIZAR project, </title> <note> 1992. Unpublished; available by anonymous FTP from menaik.cs.ualberta.ca as pub/Mizar/Mizar Over.tar.Z. </note>
Reference-contexts: They are notable for their use of decision procedures, the pioneering use of rewriting, the underlying computational model and their induction heuristics. We make heavy use of techniques from ACL2 and its predecessors in Chapter 4. * Mizar <ref> [Rud92] </ref>. This is a system for formalizing general mathematics, designed and used by mathematicians, and a phenomenal amount of the mathematical corpus has been covered. The foundation is set theory, which pervades the system, and proofs are expressed as detailed proof outlines, leaving the machine to fill in the gaps. <p> This mechanism was implemented, but was not used in the case studies. 2.3.2 Related Work Mizar <ref> [Rud92] </ref> allows facts to be labelled as they are stated, taking the current context and generating an implicative theorem. <p> Proofs in DECLARE are expressed as proof outlines, in a language that approximates written mathematics. This builds on work done with similar languages by the Mizar group <ref> [Rud92] </ref> and Harrison [Har96b]. One traditional form of proof description is tactic proof, described more fully at the end of this chapter. <p> It is only in the specification that they are widely used. 3.6.3 Mizar Mizar is a well established system for formalizing general mathematics, and a phenomenal amount of the mathematical corpus has been covered. DECLARE has been inspired in part by the Mizar system and Harrison's `Mizar Mode' work <ref> [Har96b, Rud92] </ref>. In particular: * The concept of specifying proofs as documents in a palatable proof language is due to Mizar.
Reference: [Rus93] <author> John Rushby. </author> <title> Formal methods and the certification of critical systems. </title> <type> Technical Report SRI-CSL-93-7, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year> <note> Also issued under the title Formal Methods and Digital Systems Validation for Airborne Systems as NASA Contractor Report 4551, December 1993. A book based on this material will be published by Cam-bridge University Press in 1998/9. </note>
Reference-contexts: SPECIFICATION AND VALIDATION to automation (e.g. Monadic 2nd Order Logic [JJM + 95]) and process calculi. This is not the place to give a detailed analysis of the merits of these methods: Rushby has written a good introductory overview <ref> [Rus93] </ref>. We choose a simple higher order logic as our foundational system: everything we do can be given a semantics by translation into this logic. <p> An excellent summary of the benefits of this approach can be found in <ref> [Rus93] </ref>. We now go on to give a brief account of higher order logic. We assume familiarity with first order logic. Second order logic allows quantification over predicates.
Reference: [SA98] <author> R. Stata and M. Abadi. </author> <title> A type system for Java bytecode subroutines. </title> <booktitle> In 25th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 149160, </pages> <month> January </month> <year> 1998. </year>
Reference-contexts: Isabelle is a mature system and has complementary strengths to DECLARE, notably strong generic automation and manifest soundness. A tool which unites these strengths with DECLARE's would be an exciting prospect. Several groups are working on type soundness properties for aspects of the JVM <ref> [SA98, Qia97] </ref>. These proofs have not yet been mechanized, and thus are somewhat removed from the concerns of this thesis. Chapter 8 Summary The aim of this dissertation has been to describe the use of a technique called declarative theorem proving to fully formalise reasoning about operational semantics.
Reference: [SHC96] <author> Zoltan Somogyi, Fergus Henderson, and Thomas Conway. </author> <title> The execution algorithm of Mercury, an efficient purely declarative logic programming language. </title> <journal> Journal of Logic Programming, </journal> <volume> 29(1 3):1764, </volume> <month> OctoberNovember </month> <year> 1996. </year>
Reference-contexts: We describe a range of specification constructs, their realisation in DECLARE, a new labelling system for extracting results that follow easily from specifications, and a new validation method based on translation to the Mercury <ref> [SHC96] </ref> system. * Proof Description i.e. methods for describing the proofs of problems that may not be solved immediately by automated reasoning. We describe what constitutes a declarative proof language, the pros and cons of a declarative approach to proof and the particular proof language implemented in DECLARE. <p> DECLARATIVE THEOREM PROVING AND DECLARE 13 Validation by execution Having completed a model of the toy language, it is natural to validate this model by executing it on some test cases. DECLARE can translate many specifications to a target language called Mercury <ref> [SHC96] </ref> by a relatively simple set of translations. We discuss validation and the translation to Mercury further in Section 2.4, and shall just give a taste of what is possible here. Mercury is a pure Prolog-like programming language with higher order predicates and functions. <p> Typechecking finds many bugs, but is well-understood, and so the remaining techniques are of more interest. As demonstrated in Section 1.4.3, we compile specifications to the programming language Mercury <ref> [SHC96] </ref> and leverage the static analysis and code generation facilities of that system. In the context of operational semantics this generates an interpreter for the language based directly on our definitions.
Reference: [Sho84] <author> R.E. Shostak. </author> <title> Deciding Combinations of Theories. </title> <journal> Journal of the ACM, </journal> <volume> 31(1):112, </volume> <month> January </month> <year> 1984. </year>
Reference-contexts: Nel-son and Oppen have a quite general scheme that has been successfully re-implemented in theorem proving systems [NO79, Bou95]. Shostak has an alternative scheme that is less general but reputedly faster, and this is used in the STeP and PVS theorem provers <ref> [Sho84, MBBC95, COR + 95] </ref>. 3 This subset (Presburger arithmetic) is usually expanded to include rational constants and functions that can be encoded in a linear/propositional framework, e.g. abs, max, min etc.
Reference: [Sli96] <author> K. Slind. </author> <title> Function definition in higher order logic. </title> <editor> In J. Von Wright, J. Grundy, and J. Harrison, editors, </editor> <booktitle> Ninth international Conference on Theorem Proving in Higher Order Logics TPHOL, volume 1125 of Lecture Notes in Computer Science, </booktitle> <pages> pages 381398, </pages> <address> Turku, Finland, August 1996. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: Slind has made a comprehensive study of this topic in the context of deductive frameworks <ref> [Sli96] </ref> and has implemented his algorithms in a package called TFL, suitable for use with HOL and Isabelle. Because his work has explored the issues thoroughly, for our purposes it is adequate to simply axiom-atize recursive functions.
Reference: [Spi67] <author> Michael Spivak. </author> <title> Calculus. </title> <editor> W. A. </editor> <publisher> Benjamin, Inc., </publisher> <address> New York, </address> <year> 1967. </year>
Reference-contexts: Traditional written mathematics makes little use of first order symbols, e.g. I was not able to find any in either General Topology by Willard or Calculus by Spivak <ref> [Spi67, Wil70] </ref>. Instead, they prefer to use first order terminology (not symbols), usually in the meta-language surrounding the terms they are manipulating (i.e. in problem statements and proof outlines).
Reference: [Spi88] <author> J. M. Spivey. </author> <title> Understanding Z. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 3. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1988. </year> <note> ISBN 0 521-33429-2. </note>
Reference-contexts: Typically each technique is accompanied by a logic for use with the specification language, although sometimes the specification language is precisely the logic and sometimes no coherent and complete logic is immediately apparent. Commonly cited specification languages include: axiomatization in first order logic; the Z and VDM notations <ref> [Spi88, Jac88] </ref>; variants of higher order logic (e.g. the specification languages of HOL [GM93], PVS [COR + 95] and Isabelle/HOL [Pau90]); set theory; temporal logics; specialised formalisms for finite state machines and hardware; and restricted subsets of logic that are highly amenable 1 As distinct from the HOL or Isabelle/HOL implementations
Reference: [SS97] <author> Geoff Sutcliffe and Christian B. Suttner. </author> <title> The CADE-13 ATP system competition. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 18(2):137138, </volume> <month> April </month> <year> 1997. </year>
Reference-contexts: there has been no real attempt to characterize which switches are appropriate for which classes of problems, making the use of such provers somewhat of a black art. 2 Proof combined system. 2 Recently, an autonomous mode has been added to Otter for the purposes of the CADE provers competition <ref> [SS97] </ref>. Clearly it would be desirable to harness the work that has gone into such provers within practical verification systems, and we consider this a good avenue for future research. 4.1.
Reference: [Sta95] <author> Richard Stallman. </author> <title> GNU Emacs manual. Free Software Foundation, </title> <address> 675 Mass Ave, Cambridge, MA 02139, USA, </address> <note> 11th, Emacs version 19.29 edition, </note> <month> June </month> <year> 1995. </year>
Reference-contexts: Our analysis is deliberately informal: we are simply trying to indicate the order of magnitude of the major contributing delays. same as the the logical cursor. Like many Emacs based environments <ref> [Sta95] </ref>, IDECLARE does have some understanding of the syntactic structure of a DECLARE article for example, it can syntactically detect the textual bounds on the next declaration when executing a Declare step.
Reference: [Sym93] <author> D. Syme. </author> <title> Reasoning with the Formal Definition of Standard ML in HOL. </title> <editor> In J.J. Joyce and C.-J.H. Seger, editors, </editor> <booktitle> International Workshop on Higher Order Logic Theorem Proving and its Applications, 164 BIBLIOGRAPHY volume 780 of Lecture Notes in Computer Science, </booktitle> <pages> pages 4359, </pages> <address> Vancouver, Canada, </address> <month> August </month> <year> 1993. </year> <institution> University of British Columbia, </institution> <note> Springer-Verlag, published 1994. </note>
Reference-contexts: INTRODUCTION * Syme and Hutchins have embedded the dynamic semantics of the core language of Standard ML in the HOL system <ref> [Hut90, Sym93] </ref>. They proved some simple meta-level results, including the determinacy of the semantics, and developed a symbolic evaluator for proving results about particular programs. Gunter, Maharaj and Van Inwegen [ME93, GM95], constructed a model for the dynamic semantics of the entire Standard ML language.
Reference: [Sym95] <author> D. Syme. </author> <title> A new interface for HOL ideas, </title> <booktitle> issues and implementation. Lecture Notes in Computer Science, </booktitle> <address> 971:324, </address> <year> 1995. </year>
Reference-contexts: This is precisely because a declarative description of a proof step tells us what is proved, and not how. Interactive logical navigation and debugging for tactic proofs was first developed in TkHol <ref> [Sym95] </ref> (the author's interface for the HOL theorem prover), where it is possible to interactively move through the THEN/THENL structure of a HOL proof. <p> This would not be overly difficult to implement in the current setting. * The current system allows only one active logical cursor. Experience with TkHol <ref> [Sym95] </ref> indicates that multiple active proofs are sometimes useful. Finally, we emphasise that IDECLARE does not maintain an exact correspondence between the logical cursor and the text of the document.
Reference: [Sym97a] <author> Don Syme. DECLARE: </author> <title> A prototype declarative proof system for higher order logic. </title> <type> Technical Report 416, </type> <institution> University of Cambridge Computer Laboratory, </institution> <address> Cambridge, CB2 3QG, U.K., </address> <month> March </month> <year> 1997. </year>
Reference-contexts: We have implemented these as the system DECLARE <ref> [Sym97a] </ref>. We use this system to demonstrate the principles underlying our techniques and how they may be implemented. We have also used this system for the case study described in Chapters 6 to 7. 8 CHAPTER 1.
Reference: [Sym97b] <author> Don Syme. </author> <title> Proving Java type soundness. </title> <type> Technical Report 427, </type> <institution> Computer Laboratory, Univeristy of Cambridge, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: linked against some core functionality and a main program that executes all test pragmas (see also the example on page 13). 2.4.3 Related Work A previous version of this work generated executable code by compiling specifications to CaML-light [Mau91] and performing a modicum of mode analysis during this translation (see <ref> [Sym97b] </ref>). Although useful at the time, the translation was clumsy in comparison to the translation to Mercury. The Mercury version allows considerably more flexibility in the style in which specifications are written. <p> a first-class type in our models of Java A and Java R , but exclude it at the source language Java S . null types are only used when typechecking Java S and are not needed for the internal languages Java A or Java R . 5 Our original model <ref> [Sym97b] </ref> used an overly complicated model of types, with multiple widening and well-formedness relations for these. When we modified the proof to take advantage of Oheimb's simpler formulation, the textual size of our formulation was reduced by around 15% a useful saving. 6.3.
Reference: [Tar55] <author> A. Tarski. </author> <title> A fixed point theorem and its applications. </title> <journal> Pacific J. Math., </journal> <pages> pages 285309, </pages> <year> 1955. </year>
Reference-contexts: N) into this space. An inductive relation is the least fixed point of a monotonic set transformer F within the context of a universal set U . Such fixed points are guaranteed to exist by the Knaster-Tarski theorem <ref> [Tar55] </ref>. Good references to the theory and its mechanisation are [Pau94, JT92, Har95, PM93].
Reference: [Typ98] <editor> Types mailing list archive, </editor> <year> 1998. </year> <note> Available at http://www.cs.indiana.edu/types on the WWW. </note>
Reference-contexts: For example, see the discussion on the types mailing list, where researchers were concerned that subject reduction does not hold for the Java source language <ref> [Typ98] </ref>. 7.5.
Reference: [WF94] <author> Andrew K. Wright and Matthias Felleisen. </author> <title> A syntactic approach to type soundness. Information and Computation, </title> <address> 115(1):3894, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: Exceptions are not mentioned in the statement of subject reduction, since conformance is also defined for exceptional configurations. * No Reasoning about Multiple Steps. The statement of subject reduction does Wright and Felleisen <ref> [WF94] </ref> have studied type soundness proof techniques for a wide range of language constructs, though not for Java itself. They have not mechanized their proofs.
Reference: [Wil70] <author> Stephen Willard. </author> <title> General Topology. </title> <publisher> Addison-Wesley, </publisher> <address> New York, </address> <year> 1970. </year>
Reference-contexts: Traditional written mathematics makes little use of first order symbols, e.g. I was not able to find any in either General Topology by Willard or Calculus by Spivak <ref> [Spi67, Wil70] </ref>. Instead, they prefer to use first order terminology (not symbols), usually in the meta-language surrounding the terms they are manipulating (i.e. in problem statements and proof outlines).

References-found: 88

