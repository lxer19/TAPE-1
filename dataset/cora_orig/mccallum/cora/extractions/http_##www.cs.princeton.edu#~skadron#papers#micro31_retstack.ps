URL: http://www.cs.princeton.edu/~skadron/papers/micro31_retstack.ps
Refering-URL: http://www.cs.princeton.edu/~skadron/pub_list.html
Root-URL: http://www.cs.princeton.edu
Email: E-mail: fskadron,psa,martonos,dougg@cs.princeton.edu  
Title: Improving Prediction for Procedure Returns with Return-Address-Stack Repair Mechanisms  
Author: Kevin Skadron Pritpal S. Ahuja Margaret Martonosi Douglas W. Clark 
Address: Princeton University  
Affiliation: Departments of Computer Science and Electrical Engineering  
Abstract: This paper evaluates several mechanisms for repairing the return-address stack after branch mispredictions. The return-address stack is a small but important structure for achieving better control-flow prediction accuracy and therefore better performance. But wrong-path execution after mispredictions frequently corrupts the return-address stack, making repair mechanisms necessary. If the processor implements multipath executionsimultaneously executing both sides of a branchthe contention among different paths makes the problem more severe. For conventional, single-path processors, this paper proposes saving both the top-of-stack pointer and the top-of-stack contents for later restoration in case of a mispre-diction. This simple technique achieves nearly 100% hit rates and improves performance by up to 8.7% compared to a stack with no repair mechanism. For multipath processors, providing each path with its own return-address stack completely eliminates contention, improving performance by over 25%. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. S. Ahuja, K. Skadron, M. Martonosi, and D. W. Clark. </author> <title> Multi-path execution: Opportunities and limits. </title> <booktitle> In Proc. 12th ICS, </booktitle> <pages> pages 10108, </pages> <month> July </month> <year> 1998. </year>
Reference-contexts: This paper examines the behavior and performance impact of return-address stacks, concentrating on mechanisms for repairing or preventing corruption. Cycle-level simulation of the SPECint95 suite is used to evaluate several mechanisms, and to gauge sensitivity to stack size. The paper also considers how a new execution model, multi-path execution <ref> [1, 21, 35, 36] </ref>, affects the return address stack. Multipath execution simultaneously executes down both sides of one or more branches. <p> Since over- and un-derflow are mainly a problem with small stacks, it may be better to just make the stack deeper. 5 Evaluation in a Multipath Processor Multipath execution <ref> [1, 21, 22, 35, 36] </ref>, rather than predicting which direction a branch takes, forks and executes speculatively down both paths. Once the branch resolves, the incorrect path is squashed. <p> Once the branch resolves, the incorrect path is squashed. Forked paths can in turn fork, but path contexts and execution resources are limited, so forking should be done selectively, on branches more likely to mispredict. This choice of when to fork can be made statically or dynamically <ref> [1, 17, 14, 35] </ref>. Although multipath execution requires substantial extra hardwareper-path contexts, more fetch, rename, and issue bandwidth, and a larger instruction windowthis extra hardware overlaps substantially with other likely directions for future microprocessors. These include clustered approaches [12], multithreaded processors [23], and particularly simultaneous multithreading (SMT) [34]. <p> Compress and vortex, on the other hand, suffer badly if returns are only predicted from the BTB. None of these choices has any impact on ijpeg, so we do 3 Because wrong paths intermingle in the RUU with correct paths, squashing must selectively invalidate RUU entries; see <ref> [1] </ref>, and [21] for the mechanism. The RUU is essentially a FIFO buffer, so these now-empty entries must still propagate to the front and be retired. not discuss it further. Using per-path stacks provides substantial gains for all the benchmarks.
Reference: [2] <author> D. I. August, D. A. Connors, J. C. Gyllenhaal, and W. W. Hwu. </author> <title> Architectural support for compiler-synthesized dynamic branch prediction strategies: Rationale and initial results. </title> <booktitle> In Proc. HPCA-3, </booktitle> <pages> pages 8493, </pages> <month> Feb. </month> <year> 1997. </year>
Reference-contexts: Hily and Seznec evaluate return-address-stack performance in a simultaneously-multithreaded processor; because calls and returns from different threads can be interleaved, they find per-thread stacks are a necessity [16]. Most work on control-flow prediction has focused on predicting directions of conditional branches <ref> [2, 4, 11, 24, 25, 31, 38, 39] </ref>. Attention is however turning toward other types of branches, as obtaining further improvements in conditional-branch accuracy becomes difficult. Researchers have recently begun focusing on general indirect jumps. Examining C++ programs, Calder and Grunwald observed that many indirect branches have a favored target.
Reference: [3] <author> D. Burger, T. M. Austin, and S. Bennett. </author> <title> Evaluating future microprocessors: the SimpleScalar tool set. </title> <type> Tech. Report TR-1308, </type> <institution> Univ. of Wisconsin-Madison Computer Sciences Dept., </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: Valid bits require identifiers for each in-flight branch; after a mis-prediction, these tags permit the processor to identify which stack entries have been corrupted. 3 Simulation Technique 3.1 Simulator We use HydraScalaran enhanced and multipath-capable version of SimpleScalar's <ref> [3] </ref> sim-outorderfor our experiments. SimpleScalar provides a toolbox of simulation componentslike a branch-predictor module, a cache module, and a statistics-gathering moduleas well as several simulators built from these components. Each simulator interprets executables compiled by gcc version 2.6.3, targeting a virtual instruction set that most closely resembles MIPS IV [29].
Reference: [4] <author> B. Calder and D. Grunwald. </author> <title> Fast & accurate instruction fetch and branch prediction. </title> <booktitle> In Proc. ISCA-21, </booktitle> <pages> pages 211, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Hily and Seznec evaluate return-address-stack performance in a simultaneously-multithreaded processor; because calls and returns from different threads can be interleaved, they find per-thread stacks are a necessity [16]. Most work on control-flow prediction has focused on predicting directions of conditional branches <ref> [2, 4, 11, 24, 25, 31, 38, 39] </ref>. Attention is however turning toward other types of branches, as obtaining further improvements in conditional-branch accuracy becomes difficult. Researchers have recently begun focusing on general indirect jumps. Examining C++ programs, Calder and Grunwald observed that many indirect branches have a favored target. <p> For each prediction, a selector chooses the component most likely to be correct by consulting its own 4K table of saturating 2-bit counters, indexed by global history [6]. Since many entries in the direction predictor correspond to not-taken branches (or are simply idle), the BTB is decoupled <ref> [4] </ref>, only allocating entries for taken branches. This permits the BTB to have fewer entries. The fetch engine fetches through not-taken branches and stops at taken branches. SimpleScalar updates the branch-prediction state during the instruction-commit stage.
Reference: [5] <author> B. Calder and D. Grunwald. </author> <title> Reducing indirect function call overhead in C++ programs. </title> <booktitle> In Proc. POPL-21, </booktitle> <pages> pages 397 408, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Examining C++ programs, Calder and Grunwald observed that many indirect branches have a favored target. They proposed associating a two-bit counter with branch target buffer (BTB) entries: two consecutive instances of a particular target address must occur in order to change an indirect branch's target <ref> [5] </ref>. More recently, Chang, Hao, and Patt have proposed augmenting a BTB with branch history to select among various possible targets for a particular indirect branch. Instead of history bits indicating branch directions, their proposed history contains previous branch targets [7].
Reference: [6] <author> P.-Y. Chang, E. Hao, and Y. N. Patt. </author> <title> Alternative implementations of hybrid branch predictors. </title> <booktitle> In Proc. Micro-28, </booktitle> <pages> pages 25257, </pages> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: For each prediction, a selector chooses the component most likely to be correct by consulting its own 4K table of saturating 2-bit counters, indexed by global history <ref> [6] </ref>. Since many entries in the direction predictor correspond to not-taken branches (or are simply idle), the BTB is decoupled [4], only allocating entries for taken branches. This permits the BTB to have fewer entries. The fetch engine fetches through not-taken branches and stops at taken branches.
Reference: [7] <author> P.-Y. Chang, E. Hao, and Y. N. Patt. </author> <title> Target prediction for indirect jumps. </title> <booktitle> In Proc. ISCA-24, </booktitle> <pages> pages 27483, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: More recently, Chang, Hao, and Patt have proposed augmenting a BTB with branch history to select among various possible targets for a particular indirect branch. Instead of history bits indicating branch directions, their proposed history contains previous branch targets <ref> [7] </ref>. Driesen and Holzle further examined history mechanisms for indirect-branch prediction [9]. Because returns are a special case of indirect branch, history mechanisms like these can potentially capture caller history well enough to distinguish among possible return targets.
Reference: [8] <author> Digital Semiconductor. </author> <title> Alpha 21164 Microprocessor: Hardware Reference Manual, </title> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: Most current high-performance processors include a return-address stack, but precise details about their management are rarely available. The DEC Alpha 21164 implements a 12-entry stack that can overflow and underflow <ref> [8] </ref>. The 21264 increases the size to 32 entries [15], and includes a (proprietary) stack-repair mechanism [10]. The Pentium MMX and Pentium II also implement a repair mechanism which uses valid bits to detect corrupted entries [13].
Reference: [9] <author> K. Driesen and U. Holzle. </author> <title> Accurate indirect branch prediction. </title> <booktitle> In Proc. ISCA-25, </booktitle> <pages> pages 16778, </pages> <month> July </month> <year> 1998. </year>
Reference-contexts: Instead of history bits indicating branch directions, their proposed history contains previous branch targets [7]. Driesen and Holzle further examined history mechanisms for indirect-branch prediction <ref> [9] </ref>. Because returns are a special case of indirect branch, history mechanisms like these can potentially capture caller history well enough to distinguish among possible return targets. These general mechanisms, however, do not achieve the near-100% accuracies possible with a return-address stack.
Reference: [10] <author> J. Emer. </author> <type> Personal communication, </type> <month> Mar. </month> <year> 1998. </year>
Reference-contexts: Most current high-performance processors include a return-address stack, but precise details about their management are rarely available. The DEC Alpha 21164 implements a 12-entry stack that can overflow and underflow [8]. The 21264 increases the size to 32 entries [15], and includes a (proprietary) stack-repair mechanism <ref> [10] </ref>. The Pentium MMX and Pentium II also implement a repair mechanism which uses valid bits to detect corrupted entries [13]. Cyrix recently patented a repair mechanism that preserves the top-of-stack pointer [27], similar to one of the mechanisms described here. Contributions. <p> The size of this shadow state is limited: in current processors, the shadow storage can accommodate at most a few in-flight branches4 in the case of the MIPS R10000 [28], and 20 in the case of the 21264 <ref> [10] </ref>. Note that the shadow state may in fact be physically distributed: the shadow register maps near the register-mapping table, the shadow TOS pointers near the return-address stack, and so forth. After a misprediction, the TOS pointer can be restored at the same time as the register map.
Reference: [11] <author> M. Evers, S. J. Patel, R. S. Chappell, and Y. N. Patt. </author> <title> An analysis of correlation and predictability: What makes two-level branch predictors work. </title> <booktitle> In Proc. ISCA-25, </booktitle> <pages> pages 52 61, </pages> <month> Jun. </month> <year> 1998. </year>
Reference-contexts: Hily and Seznec evaluate return-address-stack performance in a simultaneously-multithreaded processor; because calls and returns from different threads can be interleaved, they find per-thread stacks are a necessity [16]. Most work on control-flow prediction has focused on predicting directions of conditional branches <ref> [2, 4, 11, 24, 25, 31, 38, 39] </ref>. Attention is however turning toward other types of branches, as obtaining further improvements in conditional-branch accuracy becomes difficult. Researchers have recently begun focusing on general indirect jumps. Examining C++ programs, Calder and Grunwald observed that many indirect branches have a favored target.
Reference: [12] <author> K. I. Farkas, P. Chow, N. P. Jouppi, and Z. Vranesic. </author> <title> The multicluster architecture: Reducing cycle time through partitioning. </title> <booktitle> In Proc. Micro-30, </booktitle> <pages> pages 14959, </pages> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: Although multipath execution requires substantial extra hardwareper-path contexts, more fetch, rename, and issue bandwidth, and a larger instruction windowthis extra hardware overlaps substantially with other likely directions for future microprocessors. These include clustered approaches <ref> [12] </ref>, multithreaded processors [23], and particularly simultaneous multithreading (SMT) [34]. This paper mentions multipath execution because the design of the return-address stack proves critical to multi-path performance. A single, unified stack does not function properly in a multipath processor.
Reference: [13] <author> A. Glew. </author> <type> Personal communication, </type> <month> Mar. </month> <year> 1998. </year>
Reference-contexts: The DEC Alpha 21164 implements a 12-entry stack that can overflow and underflow [8]. The 21264 increases the size to 32 entries [15], and includes a (proprietary) stack-repair mechanism [10]. The Pentium MMX and Pentium II also implement a repair mechanism which uses valid bits to detect corrupted entries <ref> [13] </ref>. Cyrix recently patented a repair mechanism that preserves the top-of-stack pointer [27], similar to one of the mechanisms described here. Contributions.
Reference: [14] <author> D. Grunwald, A. Klauser, S. Manne, and A. Pleszkun. </author> <title> Confidence estimation for speculation control. </title> <booktitle> In Proc. ISCA-25, </booktitle> <pages> pages 12231, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: Once the branch resolves, the incorrect path is squashed. Forked paths can in turn fork, but path contexts and execution resources are limited, so forking should be done selectively, on branches more likely to mispredict. This choice of when to fork can be made statically or dynamically <ref> [1, 17, 14, 35] </ref>. Although multipath execution requires substantial extra hardwareper-path contexts, more fetch, rename, and issue bandwidth, and a larger instruction windowthis extra hardware overlaps substantially with other likely directions for future microprocessors. These include clustered approaches [12], multithreaded processors [23], and particularly simultaneous multithreading (SMT) [34].
Reference: [15] <author> L. Gwennap. </author> <title> Digital 21264 sets new standard. </title> <type> Microprocessor Report, </type> <pages> pages 1116, </pages> <month> Oct. 28, </month> <year> 1996. </year>
Reference-contexts: Most current high-performance processors include a return-address stack, but precise details about their management are rarely available. The DEC Alpha 21164 implements a 12-entry stack that can overflow and underflow [8]. The 21264 increases the size to 32 entries <ref> [15] </ref>, and includes a (proprietary) stack-repair mechanism [10]. The Pentium MMX and Pentium II also implement a repair mechanism which uses valid bits to detect corrupted entries [13]. Cyrix recently patented a repair mechanism that preserves the top-of-stack pointer [27], similar to one of the mechanisms described here. Contributions. <p> This modeling captures mis-speculation consequences like prefetching, cache pollution, and return-address-stack pollution, and is critical for accurately simulating multipath execution. Table 1 summarizes our baseline model, loosely modeled after the reported configuration of an Alpha 21264 <ref> [15] </ref>. The conditional-branch direction-predictor is a McFarling-style, two-component hybrid branch predictor [26] that combines a 4K GAg (global-history) predictor with a 1K fi 10 PAg (local-history) predictor [38].
Reference: [16] <author> S. Hily and A. Seznec. </author> <title> Branch prediction and simultaneous multithreading. </title> <booktitle> In Proc. PACT '96, </booktitle> <pages> pages 16973, </pages> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: The return history stack saves the pre-call history and restores it after subroutine returns. Hily and Seznec evaluate return-address-stack performance in a simultaneously-multithreaded processor; because calls and returns from different threads can be interleaved, they find per-thread stacks are a necessity <ref> [16] </ref>. Most work on control-flow prediction has focused on predicting directions of conditional branches [2, 4, 11, 24, 25, 31, 38, 39]. Attention is however turning toward other types of branches, as obtaining further improvements in conditional-branch accuracy becomes difficult. Researchers have recently begun focusing on general indirect jumps. <p> Multipath execution already requires path contexts to record various state about each path: PC, shadow register maps, etc. The return-address stack merely adds an additional element in the path context, and something that multithreading also requires <ref> [16] </ref>. Copying the stack need not take place in a single cycle. If the new stack only receives a correct TOS pointer in the first cycle, it can already receive pushes from the new path.
Reference: [17] <author> E. Jacobsen, E. Rotenberg, and J. E. Smith. </author> <title> Assigning confidence to conditional branch predictions. </title> <booktitle> In Proc. Micro-29, </booktitle> <pages> pages 14252, </pages> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: Once the branch resolves, the incorrect path is squashed. Forked paths can in turn fork, but path contexts and execution resources are limited, so forking should be done selectively, on branches more likely to mispredict. This choice of when to fork can be made statically or dynamically <ref> [1, 17, 14, 35] </ref>. Although multipath execution requires substantial extra hardwareper-path contexts, more fetch, rename, and issue bandwidth, and a larger instruction windowthis extra hardware overlaps substantially with other likely directions for future microprocessors. These include clustered approaches [12], multithreaded processors [23], and particularly simultaneous multithreading (SMT) [34].
Reference: [18] <author> Q. Jacobsen, E. Rotenberg, and J. E. Smith. </author> <title> Path-based next trace prediction. </title> <booktitle> In Proc. Micro-30, </booktitle> <pages> pages 1423, </pages> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: Earlier work includes Kaeli and Emma's 1991 paper describing a two-stack return-address predictor [20], and Webb's 1988 paper [37]. Jacobsen, Rotenberg, and Smith discuss return-address prediction in the context of a processor organized around traces <ref> [18] </ref>. The trace mechanisms replace the return-address stack. Returns that do not appear at the end of a trace are followed in the same trace by instructions from the return site. These return-site instructions may or may not be correct, but replace the prediction that a return-address stack would provide.
Reference: [19] <author> S. Jourdan, J. Stark, T.-H. Hsing, and Y. N. Patt. </author> <title> Recovery requirements of branch prediction storage structures in the presence ff mispredicted-path execution. </title> <booktitle> Int'l J. Parallel Programming, </booktitle> <address> 25(5):36383, </address> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: We suggest two different mechanisms for avoiding this corruption. Related work. The literature discusses procedure returns infrequently. The most relevant work, by Jourdan et al. 1 This paper uses stack and return-address stack interchangeably, and never speaks of the actual program stack in memory. <ref> [19] </ref>, evaluates repair mechanisms for the return-address stack as well as other branch-prediction structures. As we do, they find stack repair to be necessary for effective return-address prediction. They evaluate a self-checkpointing mechanism that saves popped entries to avoid overwriting them with future mis-speculated pushes. <p> One can, of course, save an arbitrary number of return-address-stack entries this way; the extreme would be to checkpoint the entire return-address stack each time a branch is predicted. Our results provide data for full-stack checkpointing as an upper limit. The sophisticated scheme proposed by Jourdan, et al. <ref> [19] </ref>, can have the effect of checkpointing the full stack, but requires a larger number of stack entries than the methods proposed here because it preserves popped entries. <p> Relative performance for different stack organizations under multipath execution. 2-path results are normalized to the 2-path, unified-stack case, and 4-path results to the 4-path, unified-stack case. 6 Conclusions This paper evaluates return-address-stack design in light of potential corruption by mis-speculated instructions, a problem raised by Jourdan et al. <ref> [19] </ref>. Without a return-address stack, return addresses are found in the BTB only a little over half the time (Table 4). A well-designed stack can eliminate most or all of these return mispredictions, producing speedups of up to 15% compared to using only a BTB.
Reference: [20] <author> D. R. Kaeli and P. G. Emma. </author> <title> Branch history table prediction of moving target branches due to subroutine returns. </title> <booktitle> In Proc. ISCA-18, </booktitle> <pages> pages 3441, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: But extra information is available: returns should pair up with corresponding subroutine calls. Since the return address is known at the time of the call (it is usually the next instruction after the call), a return-address stack 1 <ref> [20, 37] </ref> can match returns with corresponding calls. Like other prediction techniques, the stack's prediction is only a hint: the return instruction must still read the actual return-address register and commit. If the predicted return address is wrong, the corresponding mis-speculated computation must be squashed. <p> Each stack entry, in addition to saving a return address, also contains a pointer to the next valid stack entry. Earlier work includes Kaeli and Emma's 1991 paper describing a two-stack return-address predictor <ref> [20] </ref>, and Webb's 1988 paper [37]. Jacobsen, Rotenberg, and Smith discuss return-address prediction in the context of a processor organized around traces [18]. The trace mechanisms replace the return-address stack.
Reference: [21] <author> A. Klauser, V. Paithankar, and D. Grunwald. </author> <title> Selective eager execution on the PolyPath Architecture. </title> <booktitle> In Proc. ISCA-25, </booktitle> <pages> pages 25059, </pages> <month> July </month> <year> 1998. </year>
Reference-contexts: This paper examines the behavior and performance impact of return-address stacks, concentrating on mechanisms for repairing or preventing corruption. Cycle-level simulation of the SPECint95 suite is used to evaluate several mechanisms, and to gauge sensitivity to stack size. The paper also considers how a new execution model, multi-path execution <ref> [1, 21, 35, 36] </ref>, affects the return address stack. Multipath execution simultaneously executes down both sides of one or more branches. <p> Since over- and un-derflow are mainly a problem with small stacks, it may be better to just make the stack deeper. 5 Evaluation in a Multipath Processor Multipath execution <ref> [1, 21, 22, 35, 36] </ref>, rather than predicting which direction a branch takes, forks and executes speculatively down both paths. Once the branch resolves, the incorrect path is squashed. <p> Compress and vortex, on the other hand, suffer badly if returns are only predicted from the BTB. None of these choices has any impact on ijpeg, so we do 3 Because wrong paths intermingle in the RUU with correct paths, squashing must selectively invalidate RUU entries; see [1], and <ref> [21] </ref> for the mechanism. The RUU is essentially a FIFO buffer, so these now-empty entries must still propagate to the front and be retired. not discuss it further. Using per-path stacks provides substantial gains for all the benchmarks.
Reference: [22] <author> R. Kol and R. Ginosaur. Kin: </author> <title> A high performance asynchronous processor architecture. </title> <booktitle> In Proc. 12th ICS, </booktitle> <pages> pages 433440, </pages> <month> July </month> <year> 1998. </year>
Reference-contexts: Since over- and un-derflow are mainly a problem with small stacks, it may be better to just make the stack deeper. 5 Evaluation in a Multipath Processor Multipath execution <ref> [1, 21, 22, 35, 36] </ref>, rather than predicting which direction a branch takes, forks and executes speculatively down both paths. Once the branch resolves, the incorrect path is squashed.
Reference: [23] <author> J. Laudon, A. Gupta, and M. Horowitz. </author> <title> Interleaving: A mul-tithreading technique targeting multiprocessors and workstations. </title> <booktitle> In Proc. ASPLOS-IV, </booktitle> <pages> pages 308318, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: Although multipath execution requires substantial extra hardwareper-path contexts, more fetch, rename, and issue bandwidth, and a larger instruction windowthis extra hardware overlaps substantially with other likely directions for future microprocessors. These include clustered approaches [12], multithreaded processors <ref> [23] </ref>, and particularly simultaneous multithreading (SMT) [34]. This paper mentions multipath execution because the design of the return-address stack proves critical to multi-path performance. A single, unified stack does not function properly in a multipath processor.
Reference: [24] <author> C.-C. Lee, I.-C. K. Chen, and T. N. Mudge. </author> <title> The bi-mode branch predictor. </title> <booktitle> In Proc. Micro-30, </booktitle> <pages> pages 413, </pages> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: Hily and Seznec evaluate return-address-stack performance in a simultaneously-multithreaded processor; because calls and returns from different threads can be interleaved, they find per-thread stacks are a necessity [16]. Most work on control-flow prediction has focused on predicting directions of conditional branches <ref> [2, 4, 11, 24, 25, 31, 38, 39] </ref>. Attention is however turning toward other types of branches, as obtaining further improvements in conditional-branch accuracy becomes difficult. Researchers have recently begun focusing on general indirect jumps. Examining C++ programs, Calder and Grunwald observed that many indirect branches have a favored target.
Reference: [25] <author> S. Mahlke and B. Natarajan. </author> <title> Compiler synthesized dynamic branch prediction. </title> <booktitle> In Proc. Micro-29, </booktitle> <pages> pages 153164, </pages> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: Hily and Seznec evaluate return-address-stack performance in a simultaneously-multithreaded processor; because calls and returns from different threads can be interleaved, they find per-thread stacks are a necessity [16]. Most work on control-flow prediction has focused on predicting directions of conditional branches <ref> [2, 4, 11, 24, 25, 31, 38, 39] </ref>. Attention is however turning toward other types of branches, as obtaining further improvements in conditional-branch accuracy becomes difficult. Researchers have recently begun focusing on general indirect jumps. Examining C++ programs, Calder and Grunwald observed that many indirect branches have a favored target.
Reference: [26] <author> S. McFarling. </author> <title> Combining branch predictors. </title> <type> Tech. </type> <note> Note TN-36, DEC WRL, </note> <month> June </month> <year> 1993. </year>
Reference-contexts: This modeling captures mis-speculation consequences like prefetching, cache pollution, and return-address-stack pollution, and is critical for accurately simulating multipath execution. Table 1 summarizes our baseline model, loosely modeled after the reported configuration of an Alpha 21264 [15]. The conditional-branch direction-predictor is a McFarling-style, two-component hybrid branch predictor <ref> [26] </ref> that combines a 4K GAg (global-history) predictor with a 1K fi 10 PAg (local-history) predictor [38]. For each prediction, a selector chooses the component most likely to be correct by consulting its own 4K table of saturating 2-bit counters, indexed by global history [6].
Reference: [27] <author> S. McMahan, </author> <title> Cyrix Corp. Branch processing unit with a return stack including repair using pointers from different pipe stages. </title> <type> U.S. Patent No. </type> <institution> 5,706,491, </institution> <month> Jan., </month> <year> 1998. </year>
Reference-contexts: The 21264 increases the size to 32 entries [15], and includes a (proprietary) stack-repair mechanism [10]. The Pentium MMX and Pentium II also implement a repair mechanism which uses valid bits to detect corrupted entries [13]. Cyrix recently patented a repair mechanism that preserves the top-of-stack pointer <ref> [27] </ref>, similar to one of the mechanisms described here. Contributions.
Reference: [28] <institution> MIPS Technologies. </institution> <note> MIPS R10000 Microprocessor User's Manual, </note> <month> Jun. </month> <year> 1995. </year> <note> Version 1.0. </note>
Reference-contexts: Saving the TOS pointer merely adds several bits per branch to this shadow state. The size of this shadow state is limited: in current processors, the shadow storage can accommodate at most a few in-flight branches4 in the case of the MIPS R10000 <ref> [28] </ref>, and 20 in the case of the 21264 [10]. Note that the shadow state may in fact be physically distributed: the shadow register maps near the register-mapping table, the shadow TOS pointers near the return-address stack, and so forth.
Reference: [29] <author> C. Price. </author> <title> MIPS IV Instruction Set, Revision 3.1. MIPS Technologies, </title> <publisher> Inc., </publisher> <address> Mountain View, CA, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: SimpleScalar provides a toolbox of simulation componentslike a branch-predictor module, a cache module, and a statistics-gathering moduleas well as several simulators built from these components. Each simulator interprets executables compiled by gcc version 2.6.3, targeting a virtual instruction set that most closely resembles MIPS IV <ref> [29] </ref>. The simulators instantiate a virtual machine and can emulate the object program's execution in varying levels of detail.
Reference: [30] <author> K. Skadron, P. S. Ahuja, M. Martonosi, and D. W. Clark. </author> <title> A quantitative evaluation of branch prediction's impact on instruction-window size and cache size. </title> <type> Tech. Report TR-578-98, </type> <institution> Princeton Dept. of Comp. Sci., </institution> <month> April </month> <year> 1998. </year>
Reference-contexts: Testing this segment's representativeness by running a subset of our experiments for 250 million instructions verifies that the chosen segments provide representative behavior in terms of return-address-stack behavior as well as branch prediction accuracy, cache performance, and overall IPC. A detailed examination of these time-series miss-rate results appears in <ref> [30] </ref>, which discusses the choice of a simulation sample in more detail. Cycle-level simulations are run in a fast mode to reach the chosen simulation window. In this fast mode no mi-croarchitectural simulation takes place; only the caches and branch predictor are updated.
Reference: [31] <author> J. E. Smith. </author> <title> A study of branch prediction strategies. </title> <booktitle> In Proc. ISCA-8, </booktitle> <pages> pages 13548, </pages> <month> May </month> <year> 1981. </year>
Reference-contexts: Hily and Seznec evaluate return-address-stack performance in a simultaneously-multithreaded processor; because calls and returns from different threads can be interleaved, they find per-thread stacks are a necessity [16]. Most work on control-flow prediction has focused on predicting directions of conditional branches <ref> [2, 4, 11, 24, 25, 31, 38, 39] </ref>. Attention is however turning toward other types of branches, as obtaining further improvements in conditional-branch accuracy becomes difficult. Researchers have recently begun focusing on general indirect jumps. Examining C++ programs, Calder and Grunwald observed that many indirect branches have a favored target.
Reference: [32] <author> G. S. Sohi and A. S. Vajapeyam. </author> <title> Instruction issue logic for high-performance, interruptible pipelined processors. </title> <booktitle> In Proc. ISCA-14, </booktitle> <pages> pages 2734, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Indirect-jump targets therefore cannot be computed by the dedicated adder in the decode stage, so if the BTB mispredicts the target, the error is only detected in the writeback stage. HydraScalar simulates a 64-entry unified active list, issue queue, and rename register filea register update unit, or RUU <ref> [32] </ref>. The architectural registers (32 each for integer and floating-point) are separate and updated on commit; renaming determines whether operands reside in the RUU or in architectural state. A 32-entry load-store queue (LSQ) disambiguates memory references: stores may only pass preceding memory references whose addresses are known not to conflict.
Reference: [33] <institution> The Standard Performance Evaluation Corporation. </institution> <note> WWW Site. http://www.specbench.org, Dec. </note> <year> 1996. </year>
Reference-contexts: Otherwise, issue selects the oldest ready instructions. Finally, the cache hierarchy is a conventional two-level, non-blocking organization with separate first-level instruction and data caches. For these simulations, HydraScalar models a pipelined bus with a fixed fetch spacing. 3.2 Benchmarks The SPEC integer benchmarks <ref> [33] </ref> are summarized in Table 2. Simulations use the provided reference in puts. All benchmarks are compiled using gcc -O3 -funroll-loops (-O3 includes inlining). Simulations include all non-kernel behavior, such as library code.
Reference: [34] <author> D. M. Tullsen, S. J. Eggers, and H. M. Levy. </author> <title> Simultaneous multithreading: Maximizing on-chip parallelism. </title> <booktitle> In Proc. ISCA-22, </booktitle> <pages> pages 392403, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Although multipath execution requires substantial extra hardwareper-path contexts, more fetch, rename, and issue bandwidth, and a larger instruction windowthis extra hardware overlaps substantially with other likely directions for future microprocessors. These include clustered approaches [12], multithreaded processors [23], and particularly simultaneous multithreading (SMT) <ref> [34] </ref>. This paper mentions multipath execution because the design of the return-address stack proves critical to multi-path performance. A single, unified stack does not function properly in a multipath processor. With concurrent paths simultaneously modifying the stack, corruption is almost certain, even with full-stack checkpointing.
Reference: [35] <author> A. Uht and V. Sindagi. </author> <title> Disjoint eager execution: An optimal form of speculative execution. </title> <booktitle> In Proc. Micro-28, </booktitle> <pages> pages 31325, </pages> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: This paper examines the behavior and performance impact of return-address stacks, concentrating on mechanisms for repairing or preventing corruption. Cycle-level simulation of the SPECint95 suite is used to evaluate several mechanisms, and to gauge sensitivity to stack size. The paper also considers how a new execution model, multi-path execution <ref> [1, 21, 35, 36] </ref>, affects the return address stack. Multipath execution simultaneously executes down both sides of one or more branches. <p> Since over- and un-derflow are mainly a problem with small stacks, it may be better to just make the stack deeper. 5 Evaluation in a Multipath Processor Multipath execution <ref> [1, 21, 22, 35, 36] </ref>, rather than predicting which direction a branch takes, forks and executes speculatively down both paths. Once the branch resolves, the incorrect path is squashed. <p> Once the branch resolves, the incorrect path is squashed. Forked paths can in turn fork, but path contexts and execution resources are limited, so forking should be done selectively, on branches more likely to mispredict. This choice of when to fork can be made statically or dynamically <ref> [1, 17, 14, 35] </ref>. Although multipath execution requires substantial extra hardwareper-path contexts, more fetch, rename, and issue bandwidth, and a larger instruction windowthis extra hardware overlaps substantially with other likely directions for future microprocessors. These include clustered approaches [12], multithreaded processors [23], and particularly simultaneous multithreading (SMT) [34].
Reference: [36] <author> S. Wallace, B. Calder, and D. M. Tullsen. </author> <title> Threaded multiple path execution. </title> <booktitle> In Proc. ISCA-25, </booktitle> <pages> pages 23849, </pages> <month> July </month> <year> 1998. </year>
Reference-contexts: This paper examines the behavior and performance impact of return-address stacks, concentrating on mechanisms for repairing or preventing corruption. Cycle-level simulation of the SPECint95 suite is used to evaluate several mechanisms, and to gauge sensitivity to stack size. The paper also considers how a new execution model, multi-path execution <ref> [1, 21, 35, 36] </ref>, affects the return address stack. Multipath execution simultaneously executes down both sides of one or more branches. <p> Since over- and un-derflow are mainly a problem with small stacks, it may be better to just make the stack deeper. 5 Evaluation in a Multipath Processor Multipath execution <ref> [1, 21, 22, 35, 36] </ref>, rather than predicting which direction a branch takes, forks and executes speculatively down both paths. Once the branch resolves, the incorrect path is squashed.
Reference: [37] <author> C. F. Webb. </author> <title> Subroutine call/return stack. </title> <journal> IBM Tech. Disc. Bulletin, </journal> <volume> 30(11), </volume> <month> Apr. </month> <year> 1988. </year>
Reference-contexts: But extra information is available: returns should pair up with corresponding subroutine calls. Since the return address is known at the time of the call (it is usually the next instruction after the call), a return-address stack 1 <ref> [20, 37] </ref> can match returns with corresponding calls. Like other prediction techniques, the stack's prediction is only a hint: the return instruction must still read the actual return-address register and commit. If the predicted return address is wrong, the corresponding mis-speculated computation must be squashed. <p> Each stack entry, in addition to saving a return address, also contains a pointer to the next valid stack entry. Earlier work includes Kaeli and Emma's 1991 paper describing a two-stack return-address predictor [20], and Webb's 1988 paper <ref> [37] </ref>. Jacobsen, Rotenberg, and Smith discuss return-address prediction in the context of a processor organized around traces [18]. The trace mechanisms replace the return-address stack. Returns that do not appear at the end of a trace are followed in the same trace by instructions from the return site.
Reference: [38] <author> T.-Y. Yeh and Y. N. Patt. </author> <title> A comparison of dynamic branch predictors that use two levels of branch history. </title> <booktitle> In Proc. ISCA-20, </booktitle> <pages> pages 25766, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Hily and Seznec evaluate return-address-stack performance in a simultaneously-multithreaded processor; because calls and returns from different threads can be interleaved, they find per-thread stacks are a necessity [16]. Most work on control-flow prediction has focused on predicting directions of conditional branches <ref> [2, 4, 11, 24, 25, 31, 38, 39] </ref>. Attention is however turning toward other types of branches, as obtaining further improvements in conditional-branch accuracy becomes difficult. Researchers have recently begun focusing on general indirect jumps. Examining C++ programs, Calder and Grunwald observed that many indirect branches have a favored target. <p> Table 1 summarizes our baseline model, loosely modeled after the reported configuration of an Alpha 21264 [15]. The conditional-branch direction-predictor is a McFarling-style, two-component hybrid branch predictor [26] that combines a 4K GAg (global-history) predictor with a 1K fi 10 PAg (local-history) predictor <ref> [38] </ref>. For each prediction, a selector chooses the component most likely to be correct by consulting its own 4K table of saturating 2-bit counters, indexed by global history [6].
Reference: [39] <author> C. Young, N. Gloy, and M. D. Smith. </author> <title> A comparative analysis of schemes for correlated branch prediction. </title> <booktitle> In Proc. ISCA-22, </booktitle> <pages> pages 27686, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Hily and Seznec evaluate return-address-stack performance in a simultaneously-multithreaded processor; because calls and returns from different threads can be interleaved, they find per-thread stacks are a necessity [16]. Most work on control-flow prediction has focused on predicting directions of conditional branches <ref> [2, 4, 11, 24, 25, 31, 38, 39] </ref>. Attention is however turning toward other types of branches, as obtaining further improvements in conditional-branch accuracy becomes difficult. Researchers have recently begun focusing on general indirect jumps. Examining C++ programs, Calder and Grunwald observed that many indirect branches have a favored target.
References-found: 39

