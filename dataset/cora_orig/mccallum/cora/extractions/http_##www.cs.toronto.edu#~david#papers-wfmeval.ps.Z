URL: http://www.cs.toronto.edu/~david/papers-wfmeval.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: david@cs.toronto.edu  
Title: Computing the Well-founded Semantics for Constraint Extensions of Datalog  
Author: David Toman 
Address: Toronto, Ontario, Canada M5S 1A4  
Affiliation: Department of Computer Science, University of Toronto  
Abstract: We present a new technique for computing the well-founded semantics for constraint extensions of Datalog : . The method is based on tabulated resolution enhanced with a new refinement strategy for deriving negative conclusions. This approach leads to an efficient and terminating query evaluation algorithm that preserves the goal-oriented nature of the resolution based methods.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Abiteboul, S., Hull, R., Vianu, V. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: There are two solutions: the "database" solution: we syntactically restrict the class of queries to allowed queries|those for which the difference is guaranteed to be total. This approach is usually taken by the deductive systems <ref> [1, 18] </ref>. the "logic programming" solution: we check for definedness of the difference at run-time and signal an error if the difference is undefined. This approach is taken by most of the resolution-based methods|they term this situation query floundering [3, 4, 5, 19].
Reference: 2. <author> Beeri, C., Ramakrishnan, R. </author> <title> On the Power of Magic. </title> <booktitle> Proc. ACM-PODS 1987, </booktitle> <pages> 21-37. </pages>
Reference-contexts: Then the number of rewriting steps is at most 3f (P ) + c. This bound holds even if the original program P is rewritten using the MST [13], assuming the SIPS <ref> [2] </ref> used in the MST transformation matches the selection rule (SL). 4 Implementation Issues Future Work In this section we consider several implementation issues connected with the proposed evaluation method. 9 It is the sum of the number of operations in the internal loops over all the iterations of the external
Reference: 3. <author> Bol, R., Degerstedt, L. </author> <title> Tabulated Resolution for Well Founded Semantics. </title> <booktitle> Proc. ILPS 1993. </booktitle>
Reference-contexts: The two main approaches to computing the well-founded semantics of Datalog : programs are the bottom-up methods, usually based on the Alternating fixpoint [10, 13, 20, 31], or the top-down methods, based on a variation of SLD-resolution <ref> [3, 4, 5, 19] </ref>. <p> based on a well-known equality (stated with slight abuse of notation as) "gfp X:F (X) = : lfp X::F (:X)", and can be traced in almost all other proposals for query evaluation under the well-founded semantics, e.g., the alternating fixpoint [10, 31] or various modifications of the SLD-resolution (global SLS-resolution <ref> [3, 14, 19] </ref> or SLG-resolution [4, 5]). <p> This approach is usually taken by the deductive systems [1, 18]. the "logic programming" solution: we check for definedness of the difference at run-time and signal an error if the difference is undefined. This approach is taken by most of the resolution-based methods|they term this situation query floundering <ref> [3, 4, 5, 19] </ref>. Example 4.2 In [18] a restricted (safe) Datalog with integer gap-order constraints was introduced.
Reference: 4. <author> Chen, W., Warren, D. S. </author> <title> Query Evaluation under the Well Founded Semantics. </title> <booktitle> Proc. ACM-PODS 1993: </booktitle> <pages> 168-179 </pages>
Reference-contexts: The two main approaches to computing the well-founded semantics of Datalog : programs are the bottom-up methods, usually based on the Alternating fixpoint [10, 13, 20, 31], or the top-down methods, based on a variation of SLD-resolution <ref> [3, 4, 5, 19] </ref>. <p> Note that the bottom-up algorithms can not avoid the recomputation due to the nature of the alternating fixpoint (cf. Section 2.3), Moreover, the proposed method can reuse results from the vast recent developments in the area of top-down evaluation of deductive queries <ref> [5, 4, 27] </ref>, especially from the very efficient compilation techniques developed for the top-down query processing 1 . Results in [27] suggest that (for definite programs) most of these results can be used for query evaluation in the constraint case provided the groundness restrictions are lifted. <p> (stated with slight abuse of notation as) "gfp X:F (X) = : lfp X::F (:X)", and can be traced in almost all other proposals for query evaluation under the well-founded semantics, e.g., the alternating fixpoint [10, 31] or various modifications of the SLD-resolution (global SLS-resolution [3, 14, 19] or SLG-resolution <ref> [4, 5] </ref>). <p> In this section we introduce a new alternative method for evaluating the Datalog C;: programs. The technique is based on Constraint Memoing [27] and SLG-resolution <ref> [4] </ref> enhanced with a refinement-based handling of negative subgoals. The algorithm computes both the positive conclusions and overestimates concurrently using a constraint version of tabulated resolution [27]. The recomputation of the overestimates is avoided by creating dependent answers. <p> Thus the evaluation is complexity-wise no worse than the bottom-up evaluation of stratified Datalog. Note that this is not true for the lazy approaches, e.g., the SLG resolution <ref> [4] </ref>. Safe Datalog, Floundering Queries. The other problem we face is the requirement of a total complementation operation on the constraint class. This is often not possible or feasible. Thus we look for restricted versions of complementation, e.g., the set difference in relational algebra. <p> This approach is usually taken by the deductive systems [1, 18]. the "logic programming" solution: we check for definedness of the difference at run-time and signal an error if the difference is undefined. This approach is taken by most of the resolution-based methods|they term this situation query floundering <ref> [3, 4, 5, 19] </ref>. Example 4.2 In [18] a restricted (safe) Datalog with integer gap-order constraints was introduced. <p> Related work. There are two other proposals for top-down evaluation of logic programs with negation close to our work: First, the SLG resolution <ref> [4] </ref> designed to compute the well-founded model for logic programs. However, SLG does not allow non-ground negative subgoals and this restriction can not be easily lifted by introducing of constraints closed under complements: SLG does not terminate if non-ground negative literals are introduced.
Reference: 5. <author> Chen, W., Swift, T., Warren, D. S. </author> <title> Efficient Top-Down Computation of Queries under the Well-Founded Semantics. </title> <type> JLP 24(3): </type> <month> 161-199 </month> <year> (1995). </year>
Reference-contexts: The two main approaches to computing the well-founded semantics of Datalog : programs are the bottom-up methods, usually based on the Alternating fixpoint [10, 13, 20, 31], or the top-down methods, based on a variation of SLD-resolution <ref> [3, 4, 5, 19] </ref>. <p> Note that the bottom-up algorithms can not avoid the recomputation due to the nature of the alternating fixpoint (cf. Section 2.3), Moreover, the proposed method can reuse results from the vast recent developments in the area of top-down evaluation of deductive queries <ref> [5, 4, 27] </ref>, especially from the very efficient compilation techniques developed for the top-down query processing 1 . Results in [27] suggest that (for definite programs) most of these results can be used for query evaluation in the constraint case provided the groundness restrictions are lifted. <p> (stated with slight abuse of notation as) "gfp X:F (X) = : lfp X::F (:X)", and can be traced in almost all other proposals for query evaluation under the well-founded semantics, e.g., the alternating fixpoint [10, 31] or various modifications of the SLD-resolution (global SLS-resolution [3, 14, 19] or SLG-resolution <ref> [4, 5] </ref>). <p> In this paper we use the simplest approach to deriving this set. However, more sophisticated methods <ref> [5] </ref> are immediately applicable. Now we can present the rewriting rules of Constraint Memoing (WF): Definition 3.5 (Constraint Memoing (WF) Rewriting Rules) Let S be a finite set of Constraint Memoing (WF) nodes. The rewriting system contains following rules: Clause Resolution (CR). <p> This is analogous to computing the complement of all the overestimates in the alternating fixpoint approach. However, an incremental version of the DE rule would be preferable and is in the focus of future research. Also, using the goal completion detection technique <ref> [5] </ref> we can determine the frontier sets for completed goals on fly. This is especially important in the case of stratified Datalog C;: programs. Under this assumption we can show: Theorem 4.1 (Stratified Datalog C;: ) Let P be a modularly stratified Data-log program [20]. <p> This approach is usually taken by the deductive systems [1, 18]. the "logic programming" solution: we check for definedness of the difference at run-time and signal an error if the difference is undefined. This approach is taken by most of the resolution-based methods|they term this situation query floundering <ref> [3, 4, 5, 19] </ref>. Example 4.2 In [18] a restricted (safe) Datalog with integer gap-order constraints was introduced.
Reference: 6. <author> Freire J., Swift, T., Warren, D. S. </author> <title> Taking I/O Seriously: Resolution Reconsidered for Disk. </title> <type> Manuscript. </type> <institution> SUNY at Stony Brook, </institution> <year> 1996. </year>
Reference-contexts: standard definition of the well-founded semantics (for ground Datalog : programs) and show correctness and termination of the constraint version of an alternating fixpoint query evaluation procedure for Datalog C;: . 1 Benchmarks for main-memory systems can be found in [25, 11, 27] and for a disk based system in <ref> [6] </ref>. 2 A set-at-a-time like computation is easily achieved by allowing finite disjunction constraints. 2.1 The Constraint Representation We use constraints to encode possibly infinite sets of ground tuples.
Reference: 7. <author> Jaffar J., Maher, M. J. </author> <title> Constraint Logic Programming: A Survey. </title> <journal> J. Logic Programming 1994, </journal> <volume> 19. 20 </volume> <pages> 503-581. </pages>
Reference: 8. <author> Kanellakis, P. C., Goldin, D. </author> <title> Constraint Programming and Database Query Languages. </title> <booktitle> Proc. 2nd TACS, </booktitle> <year> 1994. </year>
Reference-contexts: Then the carrier of the class of Dense Order Constraints is generated from the set C 0 = fp &lt; x; x &lt; y; x &lt; r : p; r 2 Ag. The constraint operations on this set are defined in, e.g., <ref> [8, 9, 12] </ref>. The following definition states a fundamental property of constraint classes on which the termination proofs of bottom-up query evaluation procedures are (implicitly) based [17, 21, 26, 28]: Definition 2.3 (Constraint compact Constraint Class) Let C be a constraint class.
Reference: 9. <author> Kanellakis, P. C., Kuper, G. M., Revesz, </author> <title> P.Z . Constraint Query Languages. </title> <journal> Journal of Computer and System Sciences 51(1) </journal> <pages> 26-52, </pages> <year> 1995. </year>
Reference-contexts: The restriction to ground tuples is not natural (and often not feasible) when constraints are used as the data representation <ref> [9] </ref>: in this setting the sets of ground tuples represented by constraints are often infinite. On the other hand, the constraint representation has often better closure properties (cf. Section 2, Example 2.2 or [9]) than the ground representation. <p> ground tuples is not natural (and often not feasible) when constraints are used as the data representation <ref> [9] </ref>: in this setting the sets of ground tuples represented by constraints are often infinite. On the other hand, the constraint representation has often better closure properties (cf. Section 2, Example 2.2 or [9]) than the ground representation. In this paper we propose a top-down query evaluation procedure based on tabulated resolution enhanced with a new refinement phase|Constraint Mem-oing (WF). The procedure computes answers for arbitrary constraint Datalog : (Datalog C;: ) queries under the well-founded semantics. <p> It is parametrized by abstract operations associated with the constraint representation specific to the given constraint class. Thus the algorithm can be easily extended to accommodate various classes of constraints <ref> [9, 17, 21, 26] </ref>. The termination of the algorithm is guaranteed. We provide a sufficient criterion (as a property of the given class of constraints) that guarantees termination of arbitrary Datalog C;: queries. The evaluation is goal-oriented. <p> Then the carrier of the class of Dense Order Constraints is generated from the set C 0 = fp &lt; x; x &lt; y; x &lt; r : p; r 2 Ag. The constraint operations on this set are defined in, e.g., <ref> [8, 9, 12] </ref>. The following definition states a fundamental property of constraint classes on which the termination proofs of bottom-up query evaluation procedures are (implicitly) based [17, 21, 26, 28]: Definition 2.3 (Constraint compact Constraint Class) Let C be a constraint class.
Reference: 10. <author> Kemp, D. B., Srivastava, D., Stuckey, P. J. </author> <title> Bottom-up evaluation and query optimization of well-founded models. </title> <note> Theoretical Computer Science 146 (1995) 145-184. </note>
Reference-contexts: There have been numerous proposals for query evaluation procedures under the well-founded semantics. The two main approaches to computing the well-founded semantics of Datalog : programs are the bottom-up methods, usually based on the Alternating fixpoint <ref> [10, 13, 20, 31] </ref>, or the top-down methods, based on a variation of SLD-resolution [3, 4, 5, 19]. <p> This approach is based on a well-known equality (stated with slight abuse of notation as) "gfp X:F (X) = : lfp X::F (:X)", and can be traced in almost all other proposals for query evaluation under the well-founded semantics, e.g., the alternating fixpoint <ref> [10, 31] </ref> or various modifications of the SLD-resolution (global SLS-resolution [3, 14, 19] or SLG-resolution [4, 5]).
Reference: 11. <author> Sagonas, K., Swift, T., Warren, D. S. </author> <title> XDB as an Efficient Deductive Database Engine. </title> <booktitle> Proc. 1994 ACM SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pp. 442-453, </pages> <year> 1994. </year>
Reference-contexts: Then we present a standard definition of the well-founded semantics (for ground Datalog : programs) and show correctness and termination of the constraint version of an alternating fixpoint query evaluation procedure for Datalog C;: . 1 Benchmarks for main-memory systems can be found in <ref> [25, 11, 27] </ref> and for a disk based system in [6]. 2 A set-at-a-time like computation is easily achieved by allowing finite disjunction constraints. 2.1 The Constraint Representation We use constraints to encode possibly infinite sets of ground tuples.
Reference: 12. <author> Langford, C. </author> <title> Some Theorems on Deducibility. </title> <journal> Annals of Mathematics, </journal> <volume> vol. 28, </volume> <pages> 16-40, 459-471, </pages> <year> 1927. </year>
Reference-contexts: Then the carrier of the class of Dense Order Constraints is generated from the set C 0 = fp &lt; x; x &lt; y; x &lt; r : p; r 2 Ag. The constraint operations on this set are defined in, e.g., <ref> [8, 9, 12] </ref>. The following definition states a fundamental property of constraint classes on which the termination proofs of bottom-up query evaluation procedures are (implicitly) based [17, 21, 26, 28]: Definition 2.3 (Constraint compact Constraint Class) Let C be a constraint class.
Reference: 13. <author> Morishita, S. </author> <title> An alternating fixpoint tailored to magic programs. </title> <booktitle> Proc. ACM-PODS 1993: </booktitle> <pages> 123-134. </pages>
Reference-contexts: There have been numerous proposals for query evaluation procedures under the well-founded semantics. The two main approaches to computing the well-founded semantics of Datalog : programs are the bottom-up methods, usually based on the Alternating fixpoint <ref> [10, 13, 20, 31] </ref>, or the top-down methods, based on a variation of SLD-resolution [3, 4, 5, 19]. <p> The evaluation is goal-oriented. We show that our new method is never worse than the bottom-up method based on a constraint version of the alternating fixpoint. This remains true even for Datalog C;: programs transformed using MST <ref> [13] </ref>. The method avoids recomputation of already known conclusions using a new refinement technique. Note that the bottom-up algorithms can not avoid the recomputation due to the nature of the alternating fixpoint (cf. <p> Then the number of rewriting steps is at most 3f (P ) + c. This bound holds even if the original program P is rewritten using the MST <ref> [13] </ref>, assuming the SIPS [2] used in the MST transformation matches the selection rule (SL). 4 Implementation Issues Future Work In this section we consider several implementation issues connected with the proposed evaluation method. 9 It is the sum of the number of operations in the internal loops over all the <p> Selection Rules, Search Strategies. The proposed method is very flexible: it does not impose any particular order on the application of the rewriting rules while maintaining correctness. This leads an open door to optimization of the query evaluation. Note that program transformation based techniques (e.g., <ref> [13, 16, 22] </ref>) transform the original program before the evaluation starts. Thus the SIPS is fixed during the evaluation. Our method allows the use of adaptive search strategies and selection rules to improve the evaluation efficiency. Extension to Well-founded Semantics for Aggregation.
Reference: 14. <author> Przymusinski, T. C. </author> <title> Every Logic Program Has a Natural Stratification And an Iterated Least Fixed Point Model. </title> <booktitle> Proc. ACM-PODS 1989: </booktitle> <pages> 11-21 </pages>
Reference-contexts: based on a well-known equality (stated with slight abuse of notation as) "gfp X:F (X) = : lfp X::F (:X)", and can be traced in almost all other proposals for query evaluation under the well-founded semantics, e.g., the alternating fixpoint [10, 31] or various modifications of the SLD-resolution (global SLS-resolution <ref> [3, 14, 19] </ref> or SLG-resolution [4, 5]).
Reference: 15. <author> Ramakrishnan, R., Srivastava, D., Sudarshan, S. </author> <title> CORAL: Control, relations, </title> <booktitle> and logic. Proc. 18th VLDB, </booktitle> <pages> 238-249, </pages> <year> 1992. </year>
Reference-contexts: However, it introduces an interesting way of computing the fr (G; C) sets. On the other hand there are several proposals for computing the well-founded model bottom-up. They are usually based on the alternating fixpoint technique, e.g., <ref> [15] </ref>. The only exception is the Well-founded Ordered Search technique [22]. Note that while the Well-founded Ordered Search restricts the use of the alternating fixpoint to minimum, it can not avoid it completely.
Reference: 16. <author> Ramakrishnan, R., Srivastava, D., Sudarshan, S. </author> <title> Controlling the Search in Bottom-up evaluation Proc. </title> <booktitle> JICSLP'92, </booktitle> <pages> 273-287, </pages> <year> 1992. </year>
Reference-contexts: Selection Rules, Search Strategies. The proposed method is very flexible: it does not impose any particular order on the application of the rewriting rules while maintaining correctness. This leads an open door to optimization of the query evaluation. Note that program transformation based techniques (e.g., <ref> [13, 16, 22] </ref>) transform the original program before the evaluation starts. Thus the SIPS is fixed during the evaluation. Our method allows the use of adaptive search strategies and selection rules to improve the evaluation efficiency. Extension to Well-founded Semantics for Aggregation.
Reference: 17. <author> Revesz, P. Z. </author> <title> A Closed Form Evaluation for Datalog Queries with Integer (Gap)- Order Constraints. </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 116, no. 1, </volume> <pages> 117-149, </pages> <year> 1993. </year>
Reference-contexts: It is parametrized by abstract operations associated with the constraint representation specific to the given constraint class. Thus the algorithm can be easily extended to accommodate various classes of constraints <ref> [9, 17, 21, 26] </ref>. The termination of the algorithm is guaranteed. We provide a sufficient criterion (as a property of the given class of constraints) that guarantees termination of arbitrary Datalog C;: queries. The evaluation is goal-oriented. <p> The constraint operations on this set are defined in, e.g., [8, 9, 12]. The following definition states a fundamental property of constraint classes on which the termination proofs of bottom-up query evaluation procedures are (implicitly) based <ref> [17, 21, 26, 28] </ref>: Definition 2.3 (Constraint compact Constraint Class) Let C be a constraint class. <p> The safety criterion essentially states that only unary gap-order constraints (i.e., constraints of the form x &lt; c or x &gt; c) may pass through negation|appear as answers to literals used under negation in the query. <ref> [17] </ref> shows that the class of gap-order constraints is constraint compact and the safety restriction of [18] ensures closure under the limited complementation. Thus we can use our technique to evaluate safe Datalog queries over gap-order constraints. Selection Rules, Search Strategies.
Reference: 18. <author> Revesz, P. </author> <title> Safe Stratified Datalog with Integer Order Programs. </title> <booktitle> In Proc. First International Conference on Constraint Programming, </booktitle> <editor> Montanari U., Rossi F. eds., </editor> <publisher> Springer-Verlag LNCS 976, </publisher> <address> Cassis, France, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: There are two solutions: the "database" solution: we syntactically restrict the class of queries to allowed queries|those for which the difference is guaranteed to be total. This approach is usually taken by the deductive systems <ref> [1, 18] </ref>. the "logic programming" solution: we check for definedness of the difference at run-time and signal an error if the difference is undefined. This approach is taken by most of the resolution-based methods|they term this situation query floundering [3, 4, 5, 19]. <p> This approach is taken by most of the resolution-based methods|they term this situation query floundering [3, 4, 5, 19]. Example 4.2 In <ref> [18] </ref> a restricted (safe) Datalog with integer gap-order constraints was introduced. <p> criterion essentially states that only unary gap-order constraints (i.e., constraints of the form x &lt; c or x &gt; c) may pass through negation|appear as answers to literals used under negation in the query. [17] shows that the class of gap-order constraints is constraint compact and the safety restriction of <ref> [18] </ref> ensures closure under the limited complementation. Thus we can use our technique to evaluate safe Datalog queries over gap-order constraints. Selection Rules, Search Strategies. The proposed method is very flexible: it does not impose any particular order on the application of the rewriting rules while maintaining correctness.
Reference: 19. <author> Ross, K. A. </author> <title> A Procedural Semantics for Well Founded Negation in Logic Programs. </title> <booktitle> Proc. ACM-PODS 1989: </booktitle> <pages> 22-33. </pages>
Reference-contexts: The two main approaches to computing the well-founded semantics of Datalog : programs are the bottom-up methods, usually based on the Alternating fixpoint [10, 13, 20, 31], or the top-down methods, based on a variation of SLD-resolution <ref> [3, 4, 5, 19] </ref>. <p> W P is monotone [31] and thus a unique M WF (P ) exists for any P . Note that replacing T P by T k P for k ! in the definition of W P leads to the same well founded model <ref> [19] </ref>. 2.3 Closed-form Bottom-up Evaluation Definition 2.6 does not give a constructive definition of the well-founded model. The problem is in the definition of the greatest unfounded set which is not constructive. <p> based on a well-known equality (stated with slight abuse of notation as) "gfp X:F (X) = : lfp X::F (:X)", and can be traced in almost all other proposals for query evaluation under the well-founded semantics, e.g., the alternating fixpoint [10, 31] or various modifications of the SLD-resolution (global SLS-resolution <ref> [3, 14, 19] </ref> or SLG-resolution [4, 5]). <p> This approach is usually taken by the deductive systems [1, 18]. the "logic programming" solution: we check for definedness of the difference at run-time and signal an error if the difference is undefined. This approach is taken by most of the resolution-based methods|they term this situation query floundering <ref> [3, 4, 5, 19] </ref>. Example 4.2 In [18] a restricted (safe) Datalog with integer gap-order constraints was introduced.
Reference: 20. <author> Ross, K. A. </author> <title> Modular Stratification and Magic Sets for Datalog Programs with Negation. </title> <booktitle> Proc ACM-PODS 1990, </booktitle> <pages> 161-171. </pages>
Reference-contexts: There have been numerous proposals for query evaluation procedures under the well-founded semantics. The two main approaches to computing the well-founded semantics of Datalog : programs are the bottom-up methods, usually based on the Alternating fixpoint <ref> [10, 13, 20, 31] </ref>, or the top-down methods, based on a variation of SLD-resolution [3, 4, 5, 19]. <p> This is especially important in the case of stratified Datalog C;: programs. Under this assumption we can show: Theorem 4.1 (Stratified Datalog C;: ) Let P be a modularly stratified Data-log program <ref> [20] </ref>.
Reference: 21. <author> Srivastava, D., Ramakrishnan, R., Revesz, P. Z. </author> <title> Constraint Objects. </title> <booktitle> Proc. Intl. Workshop on Principles and Practice of Constraint Programming, </booktitle> <pages> 218-228, </pages> <year> 1994. </year>
Reference-contexts: It is parametrized by abstract operations associated with the constraint representation specific to the given constraint class. Thus the algorithm can be easily extended to accommodate various classes of constraints <ref> [9, 17, 21, 26] </ref>. The termination of the algorithm is guaranteed. We provide a sufficient criterion (as a property of the given class of constraints) that guarantees termination of arbitrary Datalog C;: queries. The evaluation is goal-oriented. <p> The constraint operations on this set are defined in, e.g., [8, 9, 12]. The following definition states a fundamental property of constraint classes on which the termination proofs of bottom-up query evaluation procedures are (implicitly) based <ref> [17, 21, 26, 28] </ref>: Definition 2.3 (Constraint compact Constraint Class) Let C be a constraint class.
Reference: 22. <author> Stuckey, P., Sudarshan, S. </author> <title> Well-Founded Ordered Search. </title> <booktitle> Foundations of Software Technology and Theoretical Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: Selection Rules, Search Strategies. The proposed method is very flexible: it does not impose any particular order on the application of the rewriting rules while maintaining correctness. This leads an open door to optimization of the query evaluation. Note that program transformation based techniques (e.g., <ref> [13, 16, 22] </ref>) transform the original program before the evaluation starts. Thus the SIPS is fixed during the evaluation. Our method allows the use of adaptive search strategies and selection rules to improve the evaluation efficiency. Extension to Well-founded Semantics for Aggregation. <p> However, it introduces an interesting way of computing the fr (G; C) sets. On the other hand there are several proposals for computing the well-founded model bottom-up. They are usually based on the alternating fixpoint technique, e.g., [15]. The only exception is the Well-founded Ordered Search technique <ref> [22] </ref>. Note that while the Well-founded Ordered Search restricts the use of the alternating fixpoint to minimum, it can not avoid it completely. Our technique avoids the alternating fixpoint computation altogether by introducing the overestimates and using the refinement rules (see [22] for comparison of SLG resolution with Well-founded Ordered Search). <p> The only exception is the Well-founded Ordered Search technique <ref> [22] </ref>. Note that while the Well-founded Ordered Search restricts the use of the alternating fixpoint to minimum, it can not avoid it completely. Our technique avoids the alternating fixpoint computation altogether by introducing the overestimates and using the refinement rules (see [22] for comparison of SLG resolution with Well-founded Ordered Search). Moreover, all the deductive systems that support well-founded semantics are restricted to allowed queries and thus the techniques are not directly applicable to the constraint case.
Reference: 23. <author> Stuckey, P. </author> <title> Negation in Constraint Logic Programming. </title> <journal> Information and Computation, </journal> <volume> 118(1): </volume> <pages> 12-33, </pages> <year> 1995. </year>
Reference-contexts: set by a dual concept: Definition 3.4 (Frontier of a Derivation) We define fr (G; C) = fD : such that ans (G; D [L]) is derived from root (G; C) and is consistent with the current state of derivationg The intuition behind the use of the frontier (similarly to <ref> [23] </ref>) is to capture the frontier (non-failed) nodes in a representation of a SLD-resolution tree and assume they resolve to an empty clause without any additional restrictions (i.e., the most optimistic consistent overestimate). In this paper we use the simplest approach to deriving this set. <p> However, SLG does not allow non-ground negative subgoals and this restriction can not be easily lifted by introducing of constraints closed under complements: SLG does not terminate if non-ground negative literals are introduced. The other approach <ref> [23] </ref> is also in the area of general logic programs and thus termination can not be guaranteed. Moreover, this approach is based on resolution without tabulation which leads to unnecessary recomputation of known derivations. However, it introduces an interesting way of computing the fr (G; C) sets.
Reference: 24. <author> Sudarshan S., Srivastava, D., Ramakrishnan R., Beeri, C. </author> <title> Extending the Well-Founded and Valid Semantics for Aggregation. </title> <booktitle> Proc. </booktitle> <address> ILPS'93 , 590-608, </address> <year> 1993. </year>
Reference-contexts: Thus the SIPS is fixed during the evaluation. Our method allows the use of adaptive search strategies and selection rules to improve the evaluation efficiency. Extension to Well-founded Semantics for Aggregation. The proposed evaluation technique can be also extended to evaluate the Well-founded Semantics of Datalog queries with aggregation <ref> [24] </ref>. The delaying technique used for the negative literals can be used for the literals under an aggregation operator. Similarly, the refinement operation remains unchanged. The main problem of incorporating aggregation lies in the determining of the frontier in the presence of aggregation. <p> Similarly, the refinement operation remains unchanged. The main problem of incorporating aggregation lies in the determining of the frontier in the presence of aggregation. However, the bottom-up methods face the same problem (cf. <ref> [24] </ref> for discussion of Well-founded Semantics for Aggregation). 5 Conclusion We introduced a new query evaluation method based on tabulated resolution for computing the well-founded semantics for Datalog C;: programs and shown its correctness and termination. Related work.
Reference: 25. <author> Swift, T., Warren, D. </author> <title> Analysis of SLG-WAM Evaluation of Definite Programs. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <year> 1994, </year> <pages> 219-235. </pages>
Reference-contexts: Then we present a standard definition of the well-founded semantics (for ground Datalog : programs) and show correctness and termination of the constraint version of an alternating fixpoint query evaluation procedure for Datalog C;: . 1 Benchmarks for main-memory systems can be found in <ref> [25, 11, 27] </ref> and for a disk based system in [6]. 2 A set-at-a-time like computation is easily achieved by allowing finite disjunction constraints. 2.1 The Constraint Representation We use constraints to encode possibly infinite sets of ground tuples.
Reference: 26. <author> Toman, D., Chomicki, J., Rogers D. S. </author> <title> Datalog with Integer Periodicity Constraints. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <year> 1994, </year> <pages> 189-203. </pages>
Reference-contexts: It is parametrized by abstract operations associated with the constraint representation specific to the given constraint class. Thus the algorithm can be easily extended to accommodate various classes of constraints <ref> [9, 17, 21, 26] </ref>. The termination of the algorithm is guaranteed. We provide a sufficient criterion (as a property of the given class of constraints) that guarantees termination of arbitrary Datalog C;: queries. The evaluation is goal-oriented. <p> The constraint operations on this set are defined in, e.g., [8, 9, 12]. The following definition states a fundamental property of constraint classes on which the termination proofs of bottom-up query evaluation procedures are (implicitly) based <ref> [17, 21, 26, 28] </ref>: Definition 2.3 (Constraint compact Constraint Class) Let C be a constraint class.
Reference: 27. <author> Toman, D. </author> <title> Top-Down beats Bottom-Up for Constraint Based Extensions of Datalog. </title> <booktitle> Proc. 1995 International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1995, </year> <pages> 98-112. </pages>
Reference-contexts: Note that the bottom-up algorithms can not avoid the recomputation due to the nature of the alternating fixpoint (cf. Section 2.3), Moreover, the proposed method can reuse results from the vast recent developments in the area of top-down evaluation of deductive queries <ref> [5, 4, 27] </ref>, especially from the very efficient compilation techniques developed for the top-down query processing 1 . Results in [27] suggest that (for definite programs) most of these results can be used for query evaluation in the constraint case provided the groundness restrictions are lifted. <p> Section 2.3), Moreover, the proposed method can reuse results from the vast recent developments in the area of top-down evaluation of deductive queries [5, 4, 27], especially from the very efficient compilation techniques developed for the top-down query processing 1 . Results in <ref> [27] </ref> suggest that (for definite programs) most of these results can be used for query evaluation in the constraint case provided the groundness restrictions are lifted. Note also, that in the constraint setting the difference between set-at-a-time and tuple-at-a-time approaches is blurred 2 . <p> Then we present a standard definition of the well-founded semantics (for ground Datalog : programs) and show correctness and termination of the constraint version of an alternating fixpoint query evaluation procedure for Datalog C;: . 1 Benchmarks for main-memory systems can be found in <ref> [25, 11, 27] </ref> and for a disk based system in [6]. 2 A set-at-a-time like computation is easily achieved by allowing finite disjunction constraints. 2.1 The Constraint Representation We use constraints to encode possibly infinite sets of ground tuples. <p> In this section we introduce a new alternative method for evaluating the Datalog C;: programs. The technique is based on Constraint Memoing <ref> [27] </ref> and SLG-resolution [4] enhanced with a refinement-based handling of negative subgoals. The algorithm computes both the positive conclusions and overestimates concurrently using a constraint version of tabulated resolution [27]. The recomputation of the overestimates is avoided by creating dependent answers. <p> The technique is based on Constraint Memoing <ref> [27] </ref> and SLG-resolution [4] enhanced with a refinement-based handling of negative subgoals. The algorithm computes both the positive conclusions and overestimates concurrently using a constraint version of tabulated resolution [27]. The recomputation of the overestimates is avoided by creating dependent answers. These dependencies are later used by a refinement operator in order to keep the computation consistent. We present the method as a rewriting system over a set of nodes representing the current state of the derivation. <p> P r o o f: It is sufficient that the equivalence holds for an arbitrary reduction sequence. This can be done by induction on stages of the W ground (P ) (only if part) and by the relative "age" of the ans nodes (if part), similarly to <ref> [27] </ref>. The result then follows from Theorem 3.7 and Lemma 3.8.
Reference: 28. <author> Ullman J. D. </author> <title> Principles of Database and Knowledge-base Systems, </title> <booktitle> Vol. 1,2. Computer Science Systems, </booktitle> <year> 1989. </year>
Reference-contexts: The constraint operations on this set are defined in, e.g., [8, 9, 12]. The following definition states a fundamental property of constraint classes on which the termination proofs of bottom-up query evaluation procedures are (implicitly) based <ref> [17, 21, 26, 28] </ref>: Definition 2.3 (Constraint compact Constraint Class) Let C be a constraint class.
Reference: 29. <author> Van Gelder, A., Ross, K. A., Schlipf, J. S. </author> <title> Unfounded Sets and well-founded semantics for general logic programs. </title> <booktitle> Proc. ACM Symposium on Principles of Database Systems, </booktitle> <year> 1988. </year>
Reference-contexts: 1 Introduction The well-founded semantics of Datalog : programs <ref> [29, 30] </ref> provides a robust model for handling negation in deductive databases (and in general logic programming systems). There have been numerous proposals for query evaluation procedures under the well-founded semantics. <p> The set ground (P ) is possibly infinite. However, the clauses in ground (P ) do not contain constraints. Thus we can determine its Well-founded model using the standard definition <ref> [29] </ref>: Definition 2.6 (Well-founded Model) Let P be Datalog C;: program and I + and I disjoint sets of ground atoms. We call the pair (I + ; I ) a (ground) three-valued interpretation. 6 A mapping from the variable names to the universe of the constraint class C.
Reference: 30. <author> Van Gelder, A., Ross, K. A., Schlipf, J. S. </author> <title> The Well-Founded Semantics for General Logic Programs. </title> <journal> JACM 38(3): </journal> <note> 620-650 (1991). 31. </note> <author> van Gelder, A. </author> <title> The Alternating Fixpoint of Logic Programs with Negation. </title> <booktitle> Proc. </booktitle> <month> ACM-PODS </month> <year> 1989: </year> <month> 1-10. </month> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: 1 Introduction The well-founded semantics of Datalog : programs <ref> [29, 30] </ref> provides a robust model for handling negation in deductive databases (and in general logic programming systems). There have been numerous proposals for query evaluation procedures under the well-founded semantics.
References-found: 30

