URL: ftp://cse.ogi.edu/pub/tech-reports/1998/98-012.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Anderson, D.P., Y. Osawa, and R. Govindan, </author> <title> File System for Continuous Media. </title> <journal> ACM Transactions on Computer Systems, </journal> <year> 1992. </year> <month> 311337. </month>
Reference-contexts: Previous work in continuous media and real-time file systems is also related to synthetic files. Continuous media file system research has largely focused on optimizing overall throughput and guaranteeing individual stream bandwidth to simple, nonadaptive media clients <ref> [1, 2, 9] </ref>. Real-time file systems leverage the real-time facilities of the underlying operating system, and combine careful data layout and disk scheduling to provide latency guarantees for file system requests [12, 17].
Reference: [2] <author> Bolosky, W.J., R.P. Fitzgerald, and J.R. Douceur. </author> <booktitle> Distributed Schedule Management in the Tiger Video Fileserver Sixteenth ACM Symposium on Operating Systems Principles . 1997. </booktitle> <address> Saint Malo, France. </address>
Reference-contexts: Previous work in continuous media and real-time file systems is also related to synthetic files. Continuous media file system research has largely focused on optimizing overall throughput and guaranteeing individual stream bandwidth to simple, nonadaptive media clients <ref> [1, 2, 9] </ref>. Real-time file systems leverage the real-time facilities of the underlying operating system, and combine careful data layout and disk scheduling to provide latency guarantees for file system requests [12, 17].
Reference: [3] <author> Cen, S., </author> <title> Demostrating the Effect of Software Feedback on a Distributed Real-Time MPEG Video Audio Player Demonstration at the 1995 ACM Multimedia Conference . 1995. </title> <address> San Francisco, CA. </address>
Reference-contexts: Complicating matters further, since synthetic files are designed for QoS-adaptive applications, the system has to adapt to variations from the application as well. Our implementation of synthetic files uses software feedback <ref> [3, 10] </ref> to dynamically adjust the prefetch horizon based on observed and predicted device latencies. We used the SWiFT toolkit [3] to construct feedback-based rate controllers for both synthesis and prefetching. The synthesizer produces data for the application and consumes data from the prefetcher. <p> Our implementation of synthetic files uses software feedback [3, 10] to dynamically adjust the prefetch horizon based on observed and predicted device latencies. We used the SWiFT toolkit <ref> [3] </ref> to construct feedback-based rate controllers for both synthesis and prefetching. The synthesizer produces data for the application and consumes data from the prefetcher. In turn, the prefetcher produces data for the synthesizer and consumes data from I/O devices.
Reference: [4] <author> Crowley, C., </author> <title> Operating Systems: A Design-Oriented Approach . 1997, </title> <publisher> Chicago: Irwin. </publisher>
Reference-contexts: Another view of the synthetic file interface is that it provides application-defined structure to data at the file system level. This feature is reminiscent of early structured file systems, such as those described in <ref> [4] </ref>. In these systems applications defined file data formats, which were stored on disk in variable-length records, and could be indexed and accessed with different patterns.
Reference: [5] <author> Custer, H., </author> <title> Inside Windows NT . 1993: </title> <publisher> Microsoft Press. </publisher>
Reference-contexts: The new threshold is applied to all data read after its application. 4.2 Feedback-Control of Prefetching and Synthesis Many file systems optimize caching and prefetching policies for simple sequential accesses <ref> [5, 6, 11] </ref>. Synthetic files make these optimizations available to more complex data access patterns, but they also complicate the task of prefetching, since block-to-block access times can vary significantly as a synthetic file references data with long and/or variable strides.
Reference: [6] <institution> Digital Equipment Incorporated, Digital Unix 1995: </institution> <address> Waltham, MA. </address>
Reference-contexts: The new threshold is applied to all data read after its application. 4.2 Feedback-Control of Prefetching and Synthesis Many file systems optimize caching and prefetching policies for simple sequential accesses <ref> [5, 6, 11] </ref>. Synthetic files make these optimizations available to more complex data access patterns, but they also complicate the task of prefetching, since block-to-block access times can vary significantly as a synthetic file references data with long and/or variable strides.
Reference: [7] <author> Kiczales, G. </author> <booktitle> Towards a New Model of Abstraction in the Engineering of Software Proceedings of IMSA 1992 Workshop on Reection and Metalevel Architectures </booktitle>
Reference: [8] <author> Kotz, D.F., </author> <title> Prefetching and Caching Techniques in File Systems for MIMD Multiprocessors Department of Computer Science . 1991, </title> <institution> Duke University: Durham, North Carolina. </institution>
Reference-contexts: Third, they constitute a meta-interface municating access pattern information to the prefetcher. 9 The use of access pattern information to drive prefetching is not new. Kotz investigated automatic detection and prediction of complex access patterns <ref> [8] </ref>. Because of the limits of automatic prediction-based approaches, more recent filesystem research has proposed informed interfaces through which applications disclose information about upcoming access patterns. TIP-2 [13], for example, uses disclosure hints of upcoming accesses to drive its buffer management policy.
Reference: [9] <author> Lougher, P. and D. Shepherd, </author> <title> The Design of a Storage Server for Continuous Media. </title> <journal> The Computer Journal, </journal> <year> 1993. </year>
Reference-contexts: Previous work in continuous media and real-time file systems is also related to synthetic files. Continuous media file system research has largely focused on optimizing overall throughput and guaranteeing individual stream bandwidth to simple, nonadaptive media clients <ref> [1, 2, 9] </ref>. Real-time file systems leverage the real-time facilities of the underlying operating system, and combine careful data layout and disk scheduling to provide latency guarantees for file system requests [12, 17].
Reference: [10] <author> Massalin, H. and C. Pu, </author> <title> Fine-Grain Adaptive Scheduling Using Feedback. </title> <booktitle> Computing Systems, </booktitle> <year> 1990. </year>
Reference-contexts: Complicating matters further, since synthetic files are designed for QoS-adaptive applications, the system has to adapt to variations from the application as well. Our implementation of synthetic files uses software feedback <ref> [3, 10] </ref> to dynamically adjust the prefetch horizon based on observed and predicted device latencies. We used the SWiFT toolkit [3] to construct feedback-based rate controllers for both synthesis and prefetching. The synthesizer produces data for the application and consumes data from the prefetcher.
Reference: [11] <editor> McKusick, </editor> <publisher> M.K., </publisher>
Reference-contexts: The new threshold is applied to all data read after its application. 4.2 Feedback-Control of Prefetching and Synthesis Many file systems optimize caching and prefetching policies for simple sequential accesses <ref> [5, 6, 11] </ref>. Synthetic files make these optimizations available to more complex data access patterns, but they also complicate the task of prefetching, since block-to-block access times can vary significantly as a synthetic file references data with long and/or variable strides.
References-found: 11

