URL: http://www.cs.umn.edu/crisys/Publications/icfem97.ps
Refering-URL: http://www.cs.umn.edu/crisys/pubs.htm
Root-URL: http://www.cs.umn.edu
Email: fheimdahl,thompsong@cs.umn.edu  
Title: Specification and Analysis of System Level Inter-Component Communication  
Author: Mats P.E. Heimdahl and Jeffrey M. Thompson 
Address: Minneapolis, MN 55455  
Affiliation: University of Minnesota, Institute of Technology Department of Computer Science, 4-192 EE/CS Bldg.  
Abstract: In embedded systems the interfaces between software and its embedding environment are a major source of costly errors. For example, Lutz reported that 20% - 35% of the safety related errors discovered during integration and system testing of two spacecraft were related to the interfaces between the software and the embedding hardware. Also, the software's operating environment is likely to change over time further complicating the issues related to system level inter-component communication. In this paper we discussed a formal approach to the specification and analysis of inter-component communication using a revised version of the RSML (Requirements State Machine Language) specification language. The formalism allows rigorous specification of the physical aspects of the inter-component communication and enables encapsulation of communication related properties in well defined interface specifications. This allows us to both analyze a system design and detect incompatibilities between connected components and use the interface specifications as simple safety kernels to enforce safety and simple liveness constraints. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Consortium requirements engineering guidebook. Techni cal Report SPC-92060-CMC, Software Productivity Consor tium Services Corporation, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Also, by encapsulating information in well defined units we can parcel the formal analysis for certain properties [24, 25] and greatly reduce the complexity of the analysis task. Other approaches to high-level specification of embedded system behavior, in particular SCR used in the CoRE method <ref> [1, 2, 10] </ref>, advocate rigorous capture of information about the measured and controlled variables in the software's environment. This work with its roots in the pioneering specification of the control software for the A7 aircraft [11] has helped shape our approach to the specification of inter-component communication.
Reference: [2] <author> S. Faulk, J. Brackett, P. Ward, and J. K. Jr. </author> <title> The Core method for real-time requirements. </title> <journal> IEEE Software, </journal> <volume> 9(5), </volume> <month> September </month> <year> 1992. </year>
Reference-contexts: Also, by encapsulating information in well defined units we can parcel the formal analysis for certain properties [24, 25] and greatly reduce the complexity of the analysis task. Other approaches to high-level specification of embedded system behavior, in particular SCR used in the CoRE method <ref> [1, 2, 10] </ref>, advocate rigorous capture of information about the measured and controlled variables in the software's environment. This work with its roots in the pioneering specification of the control software for the A7 aircraft [11] has helped shape our approach to the specification of inter-component communication.
Reference: [3] <author> S. Gerhart, D. Craigen, and T. Ralston. </author> <title> Experience with formal methods in critical systems. </title> <journal> IEEE Software, </journal> <volume> vol 11(1):2139, </volume> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation fl This work has been partially supported by NSF grants CCR-9624324 and CCR-9615088, and University of Minnesota Grant in Aid of Research 1003-521-5965. <ref> [3, 4, 7, 9, 10, 11, 16] </ref>. However, methods for rigorous specification and analysis of the communication between physically distinct components in a system is currently not well supported in any of the approaches.
Reference: [4] <author> S. Gerhart, D. Craigen, and T. Ralston. </author> <title> Formal methods real ity check: Industrial usage. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2):9098, </volume> <month> February </month> <year> 1995. </year>
Reference-contexts: The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation fl This work has been partially supported by NSF grants CCR-9624324 and CCR-9615088, and University of Minnesota Grant in Aid of Research 1003-521-5965. <ref> [3, 4, 7, 9, 10, 11, 16] </ref>. However, methods for rigorous specification and analysis of the communication between physically distinct components in a system is currently not well supported in any of the approaches.
Reference: [5] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex sys tems. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 8:231274, </address> <year> 1987. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts <ref> [5, 6, 7] </ref>, SCR (Software Cost Reduction) [10, 11], and the Requirements State Machine Language (RSML) [16], are powerful modeling languages suitable for specification of software for these types of systems. <p> RSML overview RSML was developed as a requirements specification language specifically for embedded systems. The language is based on hierarchical finite state machines and is in many ways similar to Statecharts by David Harel; for example, RSML supports parallelism, hierarchies, and guarded transitions borrowed from Statecharts (Figure 1) <ref> [5, 8] </ref>. In RSML we view a system as a collection of components connected by communication channels. A graphical representation (RSML notation) of a collection of system components and communication channels can be seen in the system using the state machines mentioned above.
Reference: [6] <author> D. Harel. </author> <title> On visual formalisms. </title> <journal> Communications of the ACM, </journal> <volume> 31(5):514530, </volume> <month> May </month> <year> 1988. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts <ref> [5, 6, 7] </ref>, SCR (Software Cost Reduction) [10, 11], and the Requirements State Machine Language (RSML) [16], are powerful modeling languages suitable for specification of software for these types of systems.
Reference: [7] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot. State-mate: </author> <title> A working environment for the development of com plex reactive systems. </title> <journal> IEEE Transactions on Software Engi neering, </journal> <volume> 16(4):403414, </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts <ref> [5, 6, 7] </ref>, SCR (Software Cost Reduction) [10, 11], and the Requirements State Machine Language (RSML) [16], are powerful modeling languages suitable for specification of software for these types of systems. <p> The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation fl This work has been partially supported by NSF grants CCR-9624324 and CCR-9615088, and University of Minnesota Grant in Aid of Research 1003-521-5965. <ref> [3, 4, 7, 9, 10, 11, 16] </ref>. However, methods for rigorous specification and analysis of the communication between physically distinct components in a system is currently not well supported in any of the approaches.
Reference: [8] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive sys tems. </title> <editor> In K. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 477498. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: RSML overview RSML was developed as a requirements specification language specifically for embedded systems. The language is based on hierarchical finite state machines and is in many ways similar to Statecharts by David Harel; for example, RSML supports parallelism, hierarchies, and guarded transitions borrowed from Statecharts (Figure 1) <ref> [5, 8] </ref>. In RSML we view a system as a collection of components connected by communication channels. A graphical representation (RSML notation) of a collection of system components and communication channels can be seen in the system using the state machines mentioned above.
Reference: [9] <author> M. P. Heimdahl and N. Leveson. </author> <title> Completeness and Consis tency Analysis of State-Based Requirements. </title> <journal> IEEE Trans actions on Software Engineering, </journal> <volume> TSE-22(6):363377, </volume> <month> June </month> <year> 1996. </year>
Reference-contexts: The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation fl This work has been partially supported by NSF grants CCR-9624324 and CCR-9615088, and University of Minnesota Grant in Aid of Research 1003-521-5965. <ref> [3, 4, 7, 9, 10, 11, 16] </ref>. However, methods for rigorous specification and analysis of the communication between physically distinct components in a system is currently not well supported in any of the approaches.
Reference: [10] <author> C. L. Heitmeyer, R. Jeffords, and B. L. Labaw. </author> <title> Consistency checking of SCR-style requirements specifications. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> vol-5(3):231261, </volume> <month> July </month> <year> 1996. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts [5, 6, 7], SCR (Software Cost Reduction) <ref> [10, 11] </ref>, and the Requirements State Machine Language (RSML) [16], are powerful modeling languages suitable for specification of software for these types of systems. <p> The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation fl This work has been partially supported by NSF grants CCR-9624324 and CCR-9615088, and University of Minnesota Grant in Aid of Research 1003-521-5965. <ref> [3, 4, 7, 9, 10, 11, 16] </ref>. However, methods for rigorous specification and analysis of the communication between physically distinct components in a system is currently not well supported in any of the approaches. <p> Also, by encapsulating information in well defined units we can parcel the formal analysis for certain properties [24, 25] and greatly reduce the complexity of the analysis task. Other approaches to high-level specification of embedded system behavior, in particular SCR used in the CoRE method <ref> [1, 2, 10] </ref>, advocate rigorous capture of information about the measured and controlled variables in the software's environment. This work with its roots in the pioneering specification of the control software for the A7 aircraft [11] has helped shape our approach to the specification of inter-component communication.
Reference: [11] <author> K. L. Heninger. </author> <title> Specifying software for complex systems: New techniques and their application. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 6(1):213, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts [5, 6, 7], SCR (Software Cost Reduction) <ref> [10, 11] </ref>, and the Requirements State Machine Language (RSML) [16], are powerful modeling languages suitable for specification of software for these types of systems. <p> The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation fl This work has been partially supported by NSF grants CCR-9624324 and CCR-9615088, and University of Minnesota Grant in Aid of Research 1003-521-5965. <ref> [3, 4, 7, 9, 10, 11, 16] </ref>. However, methods for rigorous specification and analysis of the communication between physically distinct components in a system is currently not well supported in any of the approaches. <p> This work with its roots in the pioneering specification of the control software for the A7 aircraft <ref> [11] </ref> has helped shape our approach to the specification of inter-component communication.
Reference: [12] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <booktitle> Com munications of the ACM, </booktitle> <address> 21(8):666677, </address> <year> 1978. </year>
Reference-contexts: The guarded commands and synchronous communication mechanism are simplified versions of CSP <ref> [12] </ref>. The communication occurs through channels between components.
Reference: [13] <author> M. S. Jaffe, N. G. Leveson, M. P. Heimdahl, and B. Mel hart. </author> <title> Software requirements analysis for real-time process control systems. </title> <journal> IEEE Transactions on Software Engineer ing, </journal> <volume> 17(3):241258, </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: The problems often involve misunderstandings about how the hardware operates, incompatibilities in the timing between the sending and receiving side, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated <ref> [13, 15, 17, 18, 19] </ref>. Furthermore, the software's operating environment is likely to change over time further complicating the issues related to system level inter-component communication.
Reference: [14] <author> N. Leveson, T. Shimeall, J. Stolzy, and J. Thomas. </author> <title> Designing for safe software. </title> <booktitle> In Proceedings of the AIAA 21st Aerospace Sciences Meeting, </booktitle> <pages> pages 15, </pages> <year> 1993. </year>
Reference-contexts: Constraints and constraint verification Since all communication is encapsulated in the interfaces, the guarding condition in a handler is effectively a precondition for the communication defined by that handler to take place. This encapsulation acts as a simple kernel architecture <ref> [14, 22] </ref>; through these preconditions we can assure that no undesired outputs leave our model and that no damaging inputs enter our model.
Reference: [15] <author> N. G. Leveson. </author> <title> Software safety: What, why, and how. </title> <journal> ACM Computing surveys, </journal> <volume> 18(2), </volume> <month> June </month> <year> 1986. </year>
Reference-contexts: The problems often involve misunderstandings about how the hardware operates, incompatibilities in the timing between the sending and receiving side, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated <ref> [13, 15, 17, 18, 19] </ref>. Furthermore, the software's operating environment is likely to change over time further complicating the issues related to system level inter-component communication.
Reference: [16] <author> N. G. Leveson, M. P. Heimdahl, H. Hildreth, and J. D. Reese. </author> <title> Requirements specification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9):694707, </volume> <month> September </month> <year> 1994. </year>
Reference-contexts: Languages based on hierarchical finite state machines, for example, Statecharts [5, 6, 7], SCR (Software Cost Reduction) [10, 11], and the Requirements State Machine Language (RSML) <ref> [16] </ref>, are powerful modeling languages suitable for specification of software for these types of systems. <p> The languages are relatively easy to use, allow automated verification of properties such as completeness and consistency, and support some execution and dynamic evaluation fl This work has been partially supported by NSF grants CCR-9624324 and CCR-9615088, and University of Minnesota Grant in Aid of Research 1003-521-5965. <ref> [3, 4, 7, 9, 10, 11, 16] </ref>. However, methods for rigorous specification and analysis of the communication between physically distinct components in a system is currently not well supported in any of the approaches. <p> The formalism is influenced by our previous experiences using RSML to capture the requirements of a large avionics system <ref> [16] </ref>. <p> Previous and related work At an abstract level, an embedded control system can be viewed as a collection of physically distinct components communicating over unidirectional communication channels, a view successfully adopted in the RSML approach and used to model TCAS II <ref> [16] </ref>. TCAS II is an airborne collision avoidance system for commercial aircraft. The components represent physically separate pieces of the system: a software controller, sensors and actuators (analog or digital), and physical processes. <p> Therefore, the notation must be easily understood so that it will be used to capture information about the inter-component communication. Support capture of essential properties: Melhart and Leveson <ref> [16, 19] </ref> have discussed a collection of fundamental assumptions about inter-component communication that should always be captured in the specification of an embedded system, for example, assumptions about maximum and minimum values and expected separation between consecutive messages exchanged over interfaces. Our notation must support the capture of such assumptions. <p> A macro is simply a named AND/OR table defined elsewhere in the document. A detailed description of the notation can be found in <ref> [16] </ref>. 3. Communication model In our formal definition of the RSML communication mechanisms we use a layered approach. We use Alan Shaw's Communicating Real-Time State Machines [23] to define the semantics of a collection of low-level RSML communication primitives. <p> To facilitate ease of specification and encapsulation we supply a high-level language based on our communication primitives. As a high-level interface description language we chose to use simple textual forms (Figure 13). Leveson et al. successfully used a similar approach when specifying the communication mechanisms for TCAS II <ref> [16] </ref>. The definitions in this paper are an extension and refinement of their approach. Send-Receive communication: The interface definition in Figure 6 and 7 are small examples of interface definitions in RSML. A realistic example taken from TCAS II is presented in Section 5.
Reference: [17] <author> R. Lutz. </author> <title> Targeting safety-related errors during software re quirements analysis. </title> <booktitle> In Proceedings of the First ACM SIG SOFT Symposium on the Foundations of Software Engineer ing, </booktitle> <year> 1993. </year>
Reference-contexts: For example, Lutz reported that 20% - 35% of the safety related errors discovered during integration and system testing of two spacecraft were related to the interfaces between the software and the embedding hardware <ref> [18, 17] </ref>. The problems often involve misunderstandings about how the hardware operates, incompatibilities in the timing between the sending and receiving side, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated [13, 15, 17, 18, 19]. <p> The problems often involve misunderstandings about how the hardware operates, incompatibilities in the timing between the sending and receiving side, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated <ref> [13, 15, 17, 18, 19] </ref>. Furthermore, the software's operating environment is likely to change over time further complicating the issues related to system level inter-component communication.
Reference: [18] <author> R. R. Lutz. </author> <title> Analyzing software requirements errors in safety-critical, embedded systems. </title> <booktitle> In Proceedings of the IEEE International Symposium on Requirements Engineer ing, </booktitle> <pages> pages 3546, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: For example, Lutz reported that 20% - 35% of the safety related errors discovered during integration and system testing of two spacecraft were related to the interfaces between the software and the embedding hardware <ref> [18, 17] </ref>. The problems often involve misunderstandings about how the hardware operates, incompatibilities in the timing between the sending and receiving side, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated [13, 15, 17, 18, 19]. <p> The problems often involve misunderstandings about how the hardware operates, incompatibilities in the timing between the sending and receiving side, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated <ref> [13, 15, 17, 18, 19] </ref>. Furthermore, the software's operating environment is likely to change over time further complicating the issues related to system level inter-component communication.
Reference: [19] <author> B. Melhart. </author> <title> Specification and Analysis of the Requirements for Embedded Software with an External Interaction Model. </title> <type> PhD thesis, </type> <institution> University of California, Irvine, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: The problems often involve misunderstandings about how the hardware operates, incompatibilities in the timing between the sending and receiving side, failure to detect and respond to inputs outside the normal operating regime, and failure to prevent undesirable outputs from being generated <ref> [13, 15, 17, 18, 19] </ref>. Furthermore, the software's operating environment is likely to change over time further complicating the issues related to system level inter-component communication. <p> Therefore, the notation must be easily understood so that it will be used to capture information about the inter-component communication. Support capture of essential properties: Melhart and Leveson <ref> [16, 19] </ref> have discussed a collection of fundamental assumptions about inter-component communication that should always be captured in the specification of an embedded system, for example, assumptions about maximum and minimum values and expected separation between consecutive messages exchanged over interfaces. Our notation must support the capture of such assumptions.
Reference: [20] <author> S. Owre, N. Shankar, and J.M.Rushby. </author> <title> The PVS Specifica tion Language. </title> <institution> Computer Science Laboratory; SRI Inter national, </institution> <address> Menlo Park, CA 94025, </address> <note> beta release edition, </note> <month> April </month> <year> 1993. </year>
Reference-contexts: The next section gives an example of the translation approach. 5.2. Generating proof obligations for PVS The Prototype Verification System (PVS) is a verification system that provides an interactive environment for the development and analysis of formal specifications <ref> [20, 21] </ref>. PVS consists of a specification language, a parser, a type-checker, an interactive theorem prover, and various browsing tools. To illustrate our approach, consider the interface definition in Figure 13 and the assertion in Figure 12.
Reference: [21] <author> S. Owre, N. Shankar, and J.M.Rushby. </author> <title> User Guide for the PVS Specification and Verification System. </title> <institution> Computer Sci ence Laboratory; SRI International, </institution> <address> Menlo Park, CA 94025, </address> <note> beta release edition, </note> <month> March </month> <year> 1993. </year>
Reference-contexts: The next section gives an example of the translation approach. 5.2. Generating proof obligations for PVS The Prototype Verification System (PVS) is a verification system that provides an interactive environment for the development and analysis of formal specifications <ref> [20, 21] </ref>. PVS consists of a specification language, a parser, a type-checker, an interactive theorem prover, and various browsing tools. To illustrate our approach, consider the interface definition in Figure 13 and the assertion in Figure 12.
Reference: [22] <author> J. Rushby. </author> <title> Safe and Secure Computing Systems, chapter 13, Kernels for Safety?, pages 210220. </title> <publisher> Blackwell Scientific Publications, </publisher> <year> 1989. </year>
Reference-contexts: Constraints and constraint verification Since all communication is encapsulated in the interfaces, the guarding condition in a handler is effectively a precondition for the communication defined by that handler to take place. This encapsulation acts as a simple kernel architecture <ref> [14, 22] </ref>; through these preconditions we can assure that no undesired outputs leave our model and that no damaging inputs enter our model.
Reference: [23] <author> A. C. Shaw. </author> <title> Communicating real-time state machines. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(9):805 816, </volume> <month> September </month> <year> 1992. </year>
Reference-contexts: A macro is simply a named AND/OR table defined elsewhere in the document. A detailed description of the notation can be found in [16]. 3. Communication model In our formal definition of the RSML communication mechanisms we use a layered approach. We use Alan Shaw's Communicating Real-Time State Machines <ref> [23] </ref> to define the semantics of a collection of low-level RSML communication primitives. We then provide a high-level notation that supports the encapsulation of the inter-component communication in interface specifications. 3.1. Low-Level foundation Shaw's notation is based on communicating finite state machines.
Reference: [24] <author> R. N. Taylor. </author> <title> A general purpose algorithm for analyzing con current programs. </title> <journal> Communications of the ACM, </journal> <volume> 26(5), </volume> <month> May </month> <year> 1983. </year>
Reference-contexts: Thus, the communication specifications must allow us to encapsulate information that is likely to change. Also, by encapsulating information in well defined units we can parcel the formal analysis for certain properties <ref> [24, 25] </ref> and greatly reduce the complexity of the analysis task. Other approaches to high-level specification of embedded system behavior, in particular SCR used in the CoRE method [1, 2, 10], advocate rigorous capture of information about the measured and controlled variables in the software's environment.
Reference: [25] <author> M. Young. </author> <title> How to leave out details: Error-preserving ab stractions of state-space models. </title> <booktitle> In TAV 2, </booktitle> <year> 1988. </year>
Reference-contexts: Thus, the communication specifications must allow us to encapsulate information that is likely to change. Also, by encapsulating information in well defined units we can parcel the formal analysis for certain properties <ref> [24, 25] </ref> and greatly reduce the complexity of the analysis task. Other approaches to high-level specification of embedded system behavior, in particular SCR used in the CoRE method [1, 2, 10], advocate rigorous capture of information about the measured and controlled variables in the software's environment.
References-found: 25

