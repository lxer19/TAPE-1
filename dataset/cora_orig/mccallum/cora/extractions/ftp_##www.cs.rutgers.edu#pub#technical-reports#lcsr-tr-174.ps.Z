URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-174.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: INTERPROCEDURAL ALIASING IN THE PRESENCE OF POINTERS  Written under the direction of  
Author: BY WILLIAM ALEXANDER LANDI Barbara Gershon Ryder 
Degree: A dissertation submitted to the Graduate School|New Brunswick  in partial fulfillment of the requirements for the degree of Doctor of Philosophy  and approved by  
Date: January, 1992  
Note: Graduate Program in Computer Science  
Address: New Jersey  Brunswick, New Jersey  
Affiliation: Rutgers, The State University of  New  
Abstract-found: 0
Intro-found: 1
Reference: [AHU74] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: If R is a regular expression, let L (R) denote the language R represents. Also let L be the set of regular expressions, R, such that L (R) 6= ;. L is complete for P-space <ref> [AHU74] </ref>. We will reduce L to various alias problems. We will need the following lemma throughout this section. <p> Theorem 9.2 (pp. 322-323) if <ref> [AHU74] </ref> is identical to Lemma 4.8.1 except we have the additional claim that for all 2 if (s i ,,s j ) 2 then in-degree (s j ) = 1 An examination of the NFA construction in [AHU74] will verify that the above claim is true. 2 We now reduce L <p> Theorem 9.2 (pp. 322-323) if <ref> [AHU74] </ref> is identical to Lemma 4.8.1 except we have the additional claim that for all 2 if (s i ,,s j ) 2 then in-degree (s j ) = 1 An examination of the NFA construction in [AHU74] will verify that the above claim is true. 2 We now reduce L to Intraprocedural May Alias and the complement of Intrapro-cedural Must Alias.
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: For example, consider the following example: 2 flp = 0; while (i &lt; 2) f s 2 : flp = flp + x; g We would like to optimize the above code using code motion <ref> [ASU86] </ref> to: s 0 : i = 0; s 1 : x = 5; while (i &lt; 2) f i = i + 1; s 3 : If flp is not aliased to x at s 0 , both versions of the code will have x = 5 and flp = <p> Object names provide ways to refer to objects in a program. An object name is a variable and a (possibly empty) sequence of dereferences and field accesses. A syntax-directed definition <ref> [ASU86] </ref> for object names is in Figure 2.2. Because we have prohibited casting, we are interested only in object names which do not have type error. <p> Chow and Rudmik's algorithm suffers because they treat interprocedural alias as an intraprocedural problem. That is, in their analysis they do not insure that, when a procedure returns, control passes to the call site which invoked it. In addition, they handle local variables incorrectly. <ref> [ASU86] </ref> presents an intraprocedural algorithm for finding aliases in the presence of single level pointers which is similar to the intraprocedural portion of Chow and Rudmik's algorithm, except that they allow arrays treated as aggregates. It is also similar to the our intraprocedural algorithm presented in Chapter 4.2.
Reference: [Ban78] <author> J. P. Banning. </author> <title> A Method for Determining the Side Effects of Procedure Calls. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering, Stanford University, </institution> <year> 1978. </year>
Reference-contexts: Without alias information, this and many other optimizations can not be done. Originally, we became interested in this problem while working on ISMM [Ryd89], an incremental data flow analyzer which solves the modification side effect problem (MOD) <ref> [Ban78, Ban79, Bur90, CK84, CK87b] </ref> for C programs and is designed to help programmers maintain large evolving software systems. MOD is an interprocedural data flow problem, meaning that we determine semantic information about programs across 3 procedure boundaries 1 .
Reference: [Ban79] <author> J. Banning. </author> <title> An efficient way to find the side effects of procedure calls and the aliases of variables. </title> <booktitle> In Conference Record of the Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: When this execution path traverses more than one procedure, we are solving the Interprocedural May Alias Problem. Although the calculation of aliases for FORTRAN is well understood <ref> [Ban79, Coo85, CK89, Mye81] </ref>, we show that general pointers added as a language construct cause the problem of computing aliases to become N P -hard, a situation for which no good approximation algorithms exist. <p> Without alias information, this and many other optimizations can not be done. Originally, we became interested in this problem while working on ISMM [Ryd89], an incremental data flow analyzer which solves the modification side effect problem (MOD) <ref> [Ban78, Ban79, Bur90, CK84, CK87b] </ref> for C programs and is designed to help programmers maintain large evolving software systems. MOD is an interprocedural data flow problem, meaning that we determine semantic information about programs across 3 procedure boundaries 1 . <p> In other words assuming all paths through the program are executable <ref> [Ban79] </ref>. 14 complement of Intraprocedural Must Alias: The precise solution for complement of Intraprocedural Must Alias is f [n; ha; bi] j 9 a path, n 1 n 2 :::n i1 n, in the CFG on which ha; bi does not holdg. visible: At a call site, an object name (for <p> Many algorithms have been developed to solve for aliasing in the presence of call-by-reference formals (i.e., aliasing in FORTRAN). Myers [Mye81] presents an algorithm for finding alias sets which is precise under the traditional assumptions of static analysis <ref> [Ban79] </ref>. If an alias set S is in Myers' solution at a program point p, then on some path to p, every (and only) the aliases represented in S exist at p. <p> To avoid this problem, later algorithms, including our algorithm, compute alias pairs instead of alias sets, because the number of alias pairs is polynomial in the number of variables in the program. Some precise polynomial time algorithms for finding aliases 16 in FORTRAN programs are <ref> [Ban79, Bur90, Coo85, CK89] </ref>. [MR91] presents an incremental algorithm for finding aliases in the presence of call-by-reference parameters. <p> Theorem 4.1.2 There exists a polynomial algorithm for determining precise Interpro-cedural Must Alias sets in the presence of reference formals. The problem of determining Interprocedural May Alias sets in the presence of reference formals has been examined extensively. Most notable are the algorithms presented in <ref> [Ban79, Coo85, CK89, Mye81] </ref>. We do not present any formal proofs of Theorem 4.1.1 and Theorem 4.1.2, which follow directly from previous work. <p> Both of these theorems are easy corollaries of Theorem 4.3.1 and Theorem 4.3.2. 27 Intraprocedural Intraprocedural Interprocedural Interprocedural Alias Mechanism May Alias Must Alias May Alias Must Alias Reference Formals, Polynomial Polynomial No Pointers, <ref> [Ban79, Coo85] </ref> [Ban79, Coo85] No Structures (Theorem 4.1.1) (Theorem 4.1.2) Single level pointers, Polynomial Polynomial Polynomial Polynomial No Ref. <p> Both of these theorems are easy corollaries of Theorem 4.3.1 and Theorem 4.3.2. 27 Intraprocedural Intraprocedural Interprocedural Interprocedural Alias Mechanism May Alias Must Alias May Alias Must Alias Reference Formals, Polynomial Polynomial No Pointers, <ref> [Ban79, Coo85] </ref> [Ban79, Coo85] No Structures (Theorem 4.1.1) (Theorem 4.1.2) Single level pointers, Polynomial Polynomial Polynomial Polynomial No Ref.
Reference: [Bec85] <author> L. L. Beck. </author> <title> System Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1985. </year>
Reference-contexts: It ranges from 0.7 to 238.7 with an average of 41.4. 67 Max Aliases 67 For make with k = 1, it is 674.8. The average is 74.7 if make is included. 122 Program Description allroots Find all the roots of a polynomial assembler SIC assembler <ref> [Bec85] </ref> compress UNIX: compress data diff UNIX: show file differences diffh fast diff; UNIX diff -h ed UNIX line editor football a football statistics program fixoutput a simple translator learn introduction to UNIX lex generator of a lexical analyzer lex315 a scanner for a subset of C loader SIC loader [Bec85] <p> <ref> [Bec85] </ref> compress UNIX: compress data diff UNIX: show file differences diffh fast diff; UNIX diff -h ed UNIX line editor football a football statistics program fixoutput a simple translator learn introduction to UNIX lex generator of a lexical analyzer lex315 a scanner for a subset of C loader SIC loader [Bec85] make UNIX: helps maintain programs poker a game of cards pokerd a variant of poker simulator SIC machine simulator/debugger [Bec85] tbl UNIX: format tables for nroff and troff tp tape formatting ul UNIX: underline 123 ICFG May Aliases/ Max Aliases Program Nodes Aliases Node at one Node allroots 359 240 <p> football a football statistics program fixoutput a simple translator learn introduction to UNIX lex generator of a lexical analyzer lex315 a scanner for a subset of C loader SIC loader <ref> [Bec85] </ref> make UNIX: helps maintain programs poker a game of cards pokerd a variant of poker simulator SIC machine simulator/debugger [Bec85] tbl UNIX: format tables for nroff and troff tp tape formatting ul UNIX: underline 123 ICFG May Aliases/ Max Aliases Program Nodes Aliases Node at one Node allroots 359 240 0.7 3 fixoutput 584 1,856 3.2 12 diffh 587 7,184 12.2 45 poker 865 1,962 2.3 108 ul 1,256 79,555
Reference: [Bur90] <author> M. Burke. </author> <title> An interval-based approach to exhaustive and incremental in-terprocedural data flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 341-395, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Without alias information, this and many other optimizations can not be done. Originally, we became interested in this problem while working on ISMM [Ryd89], an incremental data flow analyzer which solves the modification side effect problem (MOD) <ref> [Ban78, Ban79, Bur90, CK84, CK87b] </ref> for C programs and is designed to help programmers maintain large evolving software systems. MOD is an interprocedural data flow problem, meaning that we determine semantic information about programs across 3 procedure boundaries 1 . <p> The MOD problem is traditionally decomposed into simpler problems, which, when combined, yield the MOD solution. ISMM is an incremental implementation of the standard FORTRAN decomposition for the MOD problem <ref> [CK84, CK87a, Bur90] </ref>. However, the difference between C and FORTRAN turned out to be a major theoretical difficulty. One of the major components of the MOD decomposition is determining aliases. The MOD solution is obtained by first ignoring alias effects and afterward factoring them to obtain the full solution. <p> To avoid this problem, later algorithms, including our algorithm, compute alias pairs instead of alias sets, because the number of alias pairs is polynomial in the number of variables in the program. Some precise polynomial time algorithms for finding aliases 16 in FORTRAN programs are <ref> [Ban79, Bur90, Coo85, CK89] </ref>. [MR91] presents an incremental algorithm for finding aliases in the presence of call-by-reference parameters.
Reference: [Car88] <author> M. D. Carroll. </author> <title> A new pointer-removing program transformation. </title> <type> Unpublished manuscript, </type> <year> 1988. </year>
Reference-contexts: This transformation is essentially the inverse of refizing as developed by Carroll <ref> [Car88] </ref>.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Conference Record of the Fourth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: The problem addressed by [Deu90] is another order of magnitude complication over general aliasing. He allows closures (partially evaluated functions) and continuations (storing of runtime environment for later reuse). [Deu90] uses a very formal abstract interpretation <ref> [CC77] </ref> and is difficult to read. 3.3 Conflict/Dependence Analysis A related area of research is the work done by the compiling community on dependence analysis and conflict detection in programs with recursive structures [CWZ90, Gua88, HA90, HN89, HPR89, JM82, LH88]. This is particularly important for parallelizing programs. <p> We have borrowed this notion from them and use it in our algorithm. In [JM82] Jones and Muchnick show how to do interprocedural data flow analysis in the presence of recursive structures. They use abstract interpretation <ref> [CC77] </ref> to do this. <p> This allows easy dependence detection. [HPR89] also use abstract interpretation as a framework for presenting their solution. However, they extended <ref> [CC77] </ref> by adding a fourth semantics; the instrumented semantics. This was done to prove the validity of their abstraction. It is unclear whether this extension will have utility outside of their paper. Hendren and Nicolau [HN89, HN90] take a different approach.
Reference: [CK84] <author> K. Cooper and K. Kennedy. </author> <title> Efficient computation of flow insensitive in-terprocedural summary information. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 247-258, </pages> <month> June </month> <year> 1984. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 19, No 6. </volume>
Reference-contexts: Without alias information, this and many other optimizations can not be done. Originally, we became interested in this problem while working on ISMM [Ryd89], an incremental data flow analyzer which solves the modification side effect problem (MOD) <ref> [Ban78, Ban79, Bur90, CK84, CK87b] </ref> for C programs and is designed to help programmers maintain large evolving software systems. MOD is an interprocedural data flow problem, meaning that we determine semantic information about programs across 3 procedure boundaries 1 . <p> The MOD problem is traditionally decomposed into simpler problems, which, when combined, yield the MOD solution. ISMM is an incremental implementation of the standard FORTRAN decomposition for the MOD problem <ref> [CK84, CK87a, Bur90] </ref>. However, the difference between C and FORTRAN turned out to be a major theoretical difficulty. One of the major components of the MOD decomposition is determining aliases. The MOD solution is obtained by first ignoring alias effects and afterward factoring them to obtain the full solution.
Reference: [CK87a] <author> K. Cooper and K. Kennedy. </author> <title> Complexity of interprocedural side-effect analysis. </title> <institution> Computer Science Department Technical Report TR87-61, Rice University, </institution> <month> October </month> <year> 1987. </year>
Reference-contexts: The MOD problem is traditionally decomposed into simpler problems, which, when combined, yield the MOD solution. ISMM is an incremental implementation of the standard FORTRAN decomposition for the MOD problem <ref> [CK84, CK87a, Bur90] </ref>. However, the difference between C and FORTRAN turned out to be a major theoretical difficulty. One of the major components of the MOD decomposition is determining aliases. The MOD solution is obtained by first ignoring alias effects and afterward factoring them to obtain the full solution.
Reference: [CK87b] <author> K. Cooper and K. Kennedy. </author> <title> Efficient computation of flow-insensitive inter-procedural summary information: A correction. </title> <institution> Computer Science Department Technical Report TR87-60, Rice University, </institution> <month> October </month> <year> 1987. </year>
Reference-contexts: Without alias information, this and many other optimizations can not be done. Originally, we became interested in this problem while working on ISMM [Ryd89], an incremental data flow analyzer which solves the modification side effect problem (MOD) <ref> [Ban78, Ban79, Bur90, CK84, CK87b] </ref> for C programs and is designed to help programmers maintain large evolving software systems. MOD is an interprocedural data flow problem, meaning that we determine semantic information about programs across 3 procedure boundaries 1 .
Reference: [CK89] <author> K. Cooper and K. Kennedy. </author> <title> Fast interprocedural alias analysis. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-59, </pages> <month> January </month> <year> 1989. </year> <month> 252 </month>
Reference-contexts: When this execution path traverses more than one procedure, we are solving the Interprocedural May Alias Problem. Although the calculation of aliases for FORTRAN is well understood <ref> [Ban79, Coo85, CK89, Mye81] </ref>, we show that general pointers added as a language construct cause the problem of computing aliases to become N P -hard, a situation for which no good approximation algorithms exist. <p> To avoid this problem, later algorithms, including our algorithm, compute alias pairs instead of alias sets, because the number of alias pairs is polynomial in the number of variables in the program. Some precise polynomial time algorithms for finding aliases 16 in FORTRAN programs are <ref> [Ban79, Bur90, Coo85, CK89] </ref>. [MR91] presents an incremental algorithm for finding aliases in the presence of call-by-reference parameters. <p> Theorem 4.1.2 There exists a polynomial algorithm for determining precise Interpro-cedural Must Alias sets in the presence of reference formals. The problem of determining Interprocedural May Alias sets in the presence of reference formals has been examined extensively. Most notable are the algorithms presented in <ref> [Ban79, Coo85, CK89, Mye81] </ref>. We do not present any formal proofs of Theorem 4.1.1 and Theorem 4.1.2, which follow directly from previous work. <p> These lists tend to grow very slowly, if at all, with program size. They can be considered constant size <ref> [CK89] </ref>. * alias at exit implies (Appendix D.3) contains loops that must be executed once for each call site to the procedure that contains the exit node.
Reference: [Coo85] <author> K. Cooper. </author> <title> Analyzing aliases of reference formal parameters. </title> <booktitle> In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-290, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: When this execution path traverses more than one procedure, we are solving the Interprocedural May Alias Problem. Although the calculation of aliases for FORTRAN is well understood <ref> [Ban79, Coo85, CK89, Mye81] </ref>, we show that general pointers added as a language construct cause the problem of computing aliases to become N P -hard, a situation for which no good approximation algorithms exist. <p> To avoid this problem, later algorithms, including our algorithm, compute alias pairs instead of alias sets, because the number of alias pairs is polynomial in the number of variables in the program. Some precise polynomial time algorithms for finding aliases 16 in FORTRAN programs are <ref> [Ban79, Bur90, Coo85, CK89] </ref>. [MR91] presents an incremental algorithm for finding aliases in the presence of call-by-reference parameters. <p> Theorem 4.1.2 There exists a polynomial algorithm for determining precise Interpro-cedural Must Alias sets in the presence of reference formals. The problem of determining Interprocedural May Alias sets in the presence of reference formals has been examined extensively. Most notable are the algorithms presented in <ref> [Ban79, Coo85, CK89, Mye81] </ref>. We do not present any formal proofs of Theorem 4.1.1 and Theorem 4.1.2, which follow directly from previous work. <p> Both of these theorems are easy corollaries of Theorem 4.3.1 and Theorem 4.3.2. 27 Intraprocedural Intraprocedural Interprocedural Interprocedural Alias Mechanism May Alias Must Alias May Alias Must Alias Reference Formals, Polynomial Polynomial No Pointers, <ref> [Ban79, Coo85] </ref> [Ban79, Coo85] No Structures (Theorem 4.1.1) (Theorem 4.1.2) Single level pointers, Polynomial Polynomial Polynomial Polynomial No Ref. <p> Both of these theorems are easy corollaries of Theorem 4.3.1 and Theorem 4.3.2. 27 Intraprocedural Intraprocedural Interprocedural Interprocedural Alias Mechanism May Alias Must Alias May Alias Must Alias Reference Formals, Polynomial Polynomial No Pointers, <ref> [Ban79, Coo85] </ref> [Ban79, Coo85] No Structures (Theorem 4.1.1) (Theorem 4.1.2) Single level pointers, Polynomial Polynomial Polynomial Polynomial No Ref.
Reference: [Coo89] <author> B. G. Cooper. </author> <title> Ambitious data flow analysis of procedural programs. </title> <type> Master's thesis, </type> <institution> University of Minnesota, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: In addition to her other extensions to Weihl, Coutant also considers the use of pragmas, user provided information about aliasing, to improve the precision of her aliasing algorithm. Benjamin Cooper <ref> [Coo89] </ref> has developed an algorithm which uses explicit path information in the form of alias histories to insure (for interprocedural paths) that a procedure returns to the call site that invoked it. <p> One possible solution to this problem is to keep path information and use it to avoid paths which are not realizable. This concept of "alias histories" is used by <ref> [Coo89, SP81] </ref>. We have not chosen this approach. Instead, we use the idea of solving a data flow problem for a procedure assuming an alias condition on entry.
Reference: [Cou86] <author> D. S. Coutant. </author> <title> Retargetable high-level alias analysis. </title> <booktitle> In Conference Record of the Thirteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 110-118, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: It is also similar to the our intraprocedural algorithm presented in Chapter 4.2. Coutant <ref> [Cou86] </ref> extended Weihl's work in a different direction. She kept his restriction of finding program aliases but relaxed his restriction to 1-limiting and added additional language constructs (for example, structures and arrays).
Reference: [CR82] <author> A. Chow and A. Rudmik. </author> <title> The design of a data flow analyzer. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 106-113, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: This was because Weihl's algorithm does not give information of sufficient quality to be useful for this problem. Some empirical observations on the size of the alias solutions produced by Weihl's algorithm can be found in Figure 6.1 in Chapter 6. Chow and Rudmik <ref> [CR82] </ref> also presented an algorithm for finding aliases in the presence of single level pointers. Their approach is in some sense a generalization of Weihl's approach to computing program point aliases instead of program aliases. <p> Formals (Theorem 4.6.1) (Theorem 4.6.2) (Corollary 4.6.1) (Corollary 4.6.2) Table 4.1: Alias problem decomposition and classification 28 4.2 Single Level Pointers Before we precede to our own results in this area, it should be mentioned that Chow and Rudmik <ref> [CR82] </ref> previously attempted to devise an algorithm for determining aliases in the presence of this mechanism. Their definition of "precise Interprocedural May Alias" is weaker than ours, in that we consider only realizable paths in the ICFG, while they consider all paths. <p> If holds ([n; ha; bi]) = true regardless of any other holds value, then the edge t; [n; ha; bi] would be in the SPPAG. Like Chow and Rudmik <ref> [CR82] </ref>, we consider the relationship on an execution path between aliases that hold before a statement is executed and aliases that hold after it is executed. Consider any node [n; ha; bi] 20 in the SPPAG.
Reference: [CWZ90] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 25, No 6. </volume>
Reference-contexts: We use a solution that is roughly analogous to k-limited as defined by Jones and Muchnick [JM79]. Less naive schemes have be developed <ref> [CWZ90, HN89, HPR89, LH88] </ref>, but we have yet to examine their suitability for our purposes. Object names provide ways to refer to objects in a program. An object name is a variable and a (possibly empty) sequence of dereferences and field accesses. <p> functions) and continuations (storing of runtime environment for later reuse). [Deu90] uses a very formal abstract interpretation [CC77] and is difficult to read. 3.3 Conflict/Dependence Analysis A related area of research is the work done by the compiling community on dependence analysis and conflict detection in programs with recursive structures <ref> [CWZ90, Gua88, HA90, HN89, HPR89, JM82, LH88] </ref>. This is particularly important for parallelizing programs. A conflict [LH88] occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location (loc), thus preventing the possibility of those statements being executed in parallel. <p> For us, a recursive function call is treated no differently than an non-recursive call and we avoid the imprecision of meeting the various conditions that hold at entry to the recursive procedure. Chase, Wegman, and Zadeck <ref> [CWZ90] </ref> use storage shape graphs to represent the dynamic store, but they change the notion of k-limiting. The original idea of k-limiting was simply to represent everything further than distance k from a labeled node by a summary node. <p> However, if the data structure being represented was a linked list of even length, the even length information would be lost by such a representation. They propose a method of "limiting" graphs that would preserve such information. It seems possible to view <ref> [CWZ90] </ref> storage shape graph as some type of finite state automaton. We are not sure how this relates to [HN89, HN90]'s limited regular expressions which are used to represent path expressions. [CWZ90] also gives an algorithm for determining if an underlying data structure is a list or tree, and seems to <p> They propose a method of "limiting" graphs that would preserve such information. It seems possible to view <ref> [CWZ90] </ref> storage shape graph as some type of finite state automaton. We are not sure how this relates to [HN89, HN90]'s limited regular expressions which are used to represent path expressions. [CWZ90] also gives an algorithm for determining if an underlying data structure is a list or tree, and seems to agree with [HN89, HN90] that such information can be gainfully exploited. Guarna [Gua88] uses trees to represent what we defined as object names.
Reference: [Deu90] <author> A. Deutsch. </author> <title> On determining lifetime and aliasing of dynamically allocated data in higher-order functional specifications. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 157-168, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Cooper's method seems time and space infeasible without restricting the size of the alias sets. There also has been some work <ref> [Deu90, NPD87] </ref> in detecting aliases in higher order programming languages (i.e., languages where functions are treated like any other data type). [NPD87] only considers programs with single level dereferences and has the 19 added difficulty of tracking the binding of functions to names. <p> Interprocedurally, they solve the alias problem for a procedure with the initial information induced by each call chain 9 . They fail to take advantage of using assumed alias pairs instead of initial alias sets. The problem addressed by <ref> [Deu90] </ref> is another order of magnitude complication over general aliasing. He allows closures (partially evaluated functions) and continuations (storing of runtime environment for later reuse). [Deu90] uses a very formal abstract interpretation [CC77] and is difficult to read. 3.3 Conflict/Dependence Analysis A related area of research is the work done by <p> They fail to take advantage of using assumed alias pairs instead of initial alias sets. The problem addressed by <ref> [Deu90] </ref> is another order of magnitude complication over general aliasing. He allows closures (partially evaluated functions) and continuations (storing of runtime environment for later reuse). [Deu90] uses a very formal abstract interpretation [CC77] and is difficult to read. 3.3 Conflict/Dependence Analysis A related area of research is the work done by the compiling community on dependence analysis and conflict detection in programs with recursive structures [CWZ90, Gua88, HA90, HN89, HPR89, JM82, LH88].
Reference: [Gua88] <author> C. A. Guarna. </author> <title> A technique for analyzing pointer and structure references in parallel restructuring compilers. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <pages> pages 212-220, </pages> <year> 1988. </year>
Reference-contexts: functions) and continuations (storing of runtime environment for later reuse). [Deu90] uses a very formal abstract interpretation [CC77] and is difficult to read. 3.3 Conflict/Dependence Analysis A related area of research is the work done by the compiling community on dependence analysis and conflict detection in programs with recursive structures <ref> [CWZ90, Gua88, HA90, HN89, HPR89, JM82, LH88] </ref>. This is particularly important for parallelizing programs. A conflict [LH88] occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location (loc), thus preventing the possibility of those statements being executed in parallel. <p> Guarna <ref> [Gua88] </ref> uses trees to represent what we defined as object names. Where we defined object names by the set of names derivable from a grammar, Guarna uses the actual parse trees. He then redefines the traditional data dependence calculation [PW86] in terms of these trees.
Reference: [HA90] <author> W.L. Harrison III and Z. Ammarguellat. </author> <title> Parcel and miprac: Parallelizers for symbolic and numeric programs. </title> <booktitle> In International Workshop on Compilers for Parallel Computers, </booktitle> <month> December </month> <year> 1990. </year>
Reference-contexts: functions) and continuations (storing of runtime environment for later reuse). [Deu90] uses a very formal abstract interpretation [CC77] and is difficult to read. 3.3 Conflict/Dependence Analysis A related area of research is the work done by the compiling community on dependence analysis and conflict detection in programs with recursive structures <ref> [CWZ90, Gua88, HA90, HN89, HPR89, JM82, LH88] </ref>. This is particularly important for parallelizing programs. A conflict [LH88] occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location (loc), thus preventing the possibility of those statements being executed in parallel.
Reference: [Hec77] <author> M. S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> Elsevier North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: Introduction Programming language environments contain tools to improve the quality, efficiency, understandability, and usability of code. Tools such as optimizers, debuggers, testers, verifiers, and parallelizers, use data flow analysis <ref> [Hec77] </ref> to statically extract semantic information from programs so as to increase their efficacy. Alias information is important semantic information that can greatly affect the quality of optimized code and the utility of many other program languages tools. <p> Since MOD and many other data flow solutions are extremely useful, especially in optimization, we decided to derive a better algorithm for determining aliases in C and reformulate MOD 1 In contrast, an intraprocedural data flow problem <ref> [Hec77] </ref> is one that concerns semantic information within procedures and does not deal with procedure calls. 4 for the C paradigm. We are still looking at approaches for MOD; the rest of this thesis is devoted to the problem of solving for aliases. <p> We allow arrays but simply treat them as aggregates. We represent programs by interprocedural control flow graphs (ICFGs) that we originally presented in [LR91]. An ICFG is, intuitively, the union of the control flow graphs (CFGs) 5 <ref> [Hec77] </ref> for each procedure, with calls connected to the procedures they invoke. <p> The obvious solution is to use the intraprocedural algorithm on the ICFG. This, unfortunately, introduces imprecision. The intraprocedural algorithm computes the MFP (maximum fixed point) for a distributive framework and thus computes the MOP (meet over all paths) solution <ref> [Hec77] </ref>. We cannot use this same approach in the interprocedural algorithm because not all paths in the ICFG are realizable; a procedure call must return to the site that invoked it. <p> In the second step, aliases introduced are propagated through a call node to the corresponding entry node of the called procedure, ignoring edges from exit nodes to returns. Conceptually, this is analogous to propagation on the program call graph <ref> [Hec77] </ref>. 23 This idea of using Conditional May Aliases does not seem promising at first, as there are an exponential number of possible sets of aliases. But Lemma 4.2.1 insures that it is sufficient to consider sets A where j A j 1. <p> O 0 is the set of all object names in the program which may have aliases. Let POSSIBLE ALIASES 0 = (O 0 fi O 0 ). 170 POSSIBLE-ALIASE S 0 is the set of all possible aliases. Define the lattice <ref> [Hec77] </ref> L 0 = (powerset (POSSIBLE-ALIASES 0 ); (v); [(u); POSSIBLE-ALIASES 0 (?); ; (&gt;)) Let bind n (AA), n a call node in the ICFG and AA 2 P OSSIBLE ALIASES 0 , be defined as in Appendix C.2. <p> O is the set of all object names in the program which may have aliases. "non visible" represents object names which are not visible. Let POSSIBLE ALIASES=(O fi O) fhnon visible; non visibleig. POSSIBLE-ALIASE S is the set of all possible aliases. Define the lattice <ref> [Hec77] </ref> L = (S; v; u; ?; &gt;) as * S = powerset (POSSIBLE-ALIASE S) [ f alse * a v b iff (a = f alse) or (a b) 82 * a u b = &gt; &lt; f alse if (a = f alse) or (b = f alse) a
Reference: [HN89] <author> L. J. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <booktitle> In Proceedings of the 1989 International Conference on Parallel Processing, </booktitle> <pages> pages 49-56, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: We use a solution that is roughly analogous to k-limited as defined by Jones and Muchnick [JM79]. Less naive schemes have be developed <ref> [CWZ90, HN89, HPR89, LH88] </ref>, but we have yet to examine their suitability for our purposes. Object names provide ways to refer to objects in a program. An object name is a variable and a (possibly empty) sequence of dereferences and field accesses. <p> functions) and continuations (storing of runtime environment for later reuse). [Deu90] uses a very formal abstract interpretation [CC77] and is difficult to read. 3.3 Conflict/Dependence Analysis A related area of research is the work done by the compiling community on dependence analysis and conflict detection in programs with recursive structures <ref> [CWZ90, Gua88, HA90, HN89, HPR89, JM82, LH88] </ref>. This is particularly important for parallelizing programs. A conflict [LH88] occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location (loc), thus preventing the possibility of those statements being executed in parallel. <p> However, they extended [CC77] by adding a fourth semantics; the instrumented semantics. This was done to prove the validity of their abstraction. It is unclear whether this extension will have utility outside of their paper. Hendren and Nicolau <ref> [HN89, HN90] </ref> take a different approach. They assume that something is known about the underlying data structure; for example, it is a linked list, tree, dag, etc... This assumption is necessary for their analysis, but is also verified by their algorithm. <p> The path expression in row h r and column h c represents the relationship (if any) between h r and h c . They are restricted regular expressions 11 . <ref> [HN89, HN90] </ref> is an interprocedural algorithm and in the absence of recursion 12 is interprocedurally analogous to our assumed alias algorithm. <p> We should be able to reduce the amount of redundant calculation being done by not having to re-do the calculation for identical portions of different assumed path matrices. In the presence of recursion 14 , <ref> [HN89, HN90] </ref> would use what amounted to an assumed condition (p in in their nomenclature) which is the meet of all the conditions on entry to the procedure for that recursive invocation. <p> They propose a method of "limiting" graphs that would preserve such information. It seems possible to view [CWZ90] storage shape graph as some type of finite state automaton. We are not sure how this relates to <ref> [HN89, HN90] </ref>'s limited regular expressions which are used to represent path expressions. [CWZ90] also gives an algorithm for determining if an underlying data structure is a list or tree, and seems to agree with [HN89, HN90] that such information can be gainfully exploited. <p> We are not sure how this relates to <ref> [HN89, HN90] </ref>'s limited regular expressions which are used to represent path expressions. [CWZ90] also gives an algorithm for determining if an underlying data structure is a list or tree, and seems to agree with [HN89, HN90] that such information can be gainfully exploited. Guarna [Gua88] uses trees to represent what we defined as object names. Where we defined object names by the set of names derivable from a grammar, Guarna uses the actual parse trees. <p> He does account for point-specific aliasing, but he does a transitive closure on his May Alias solution at each program point to insure safety. 13 We have not as yet determined whether such an assumption would be viable for <ref> [HN89, HN90] </ref>. 14 and while loops 23 We think this is very imprecise, because, although aliasing on a path is a transitive relation, May Alias is not and the transitive closures will almost certainly introduce unnecessary imprecision. 24 Chapter 4 Classification of the Alias Problems Problem Classification We have analyzed the
Reference: [HN90] <author> L. J. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: However, they extended [CC77] by adding a fourth semantics; the instrumented semantics. This was done to prove the validity of their abstraction. It is unclear whether this extension will have utility outside of their paper. Hendren and Nicolau <ref> [HN89, HN90] </ref> take a different approach. They assume that something is known about the underlying data structure; for example, it is a linked list, tree, dag, etc... This assumption is necessary for their analysis, but is also verified by their algorithm. <p> The path expression in row h r and column h c represents the relationship (if any) between h r and h c . They are restricted regular expressions 11 . <ref> [HN89, HN90] </ref> is an interprocedural algorithm and in the absence of recursion 12 is interprocedurally analogous to our assumed alias algorithm. <p> We should be able to reduce the amount of redundant calculation being done by not having to re-do the calculation for identical portions of different assumed path matrices. In the presence of recursion 14 , <ref> [HN89, HN90] </ref> would use what amounted to an assumed condition (p in in their nomenclature) which is the meet of all the conditions on entry to the procedure for that recursive invocation. <p> They propose a method of "limiting" graphs that would preserve such information. It seems possible to view [CWZ90] storage shape graph as some type of finite state automaton. We are not sure how this relates to <ref> [HN89, HN90] </ref>'s limited regular expressions which are used to represent path expressions. [CWZ90] also gives an algorithm for determining if an underlying data structure is a list or tree, and seems to agree with [HN89, HN90] that such information can be gainfully exploited. <p> We are not sure how this relates to <ref> [HN89, HN90] </ref>'s limited regular expressions which are used to represent path expressions. [CWZ90] also gives an algorithm for determining if an underlying data structure is a list or tree, and seems to agree with [HN89, HN90] that such information can be gainfully exploited. Guarna [Gua88] uses trees to represent what we defined as object names. Where we defined object names by the set of names derivable from a grammar, Guarna uses the actual parse trees. <p> He does account for point-specific aliasing, but he does a transitive closure on his May Alias solution at each program point to insure safety. 13 We have not as yet determined whether such an assumption would be viable for <ref> [HN89, HN90] </ref>. 14 and while loops 23 We think this is very imprecise, because, although aliasing on a path is a transitive relation, May Alias is not and the transitive closures will almost certainly introduce unnecessary imprecision. 24 Chapter 4 Classification of the Alias Problems Problem Classification We have analyzed the
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 28-40, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: We use a solution that is roughly analogous to k-limited as defined by Jones and Muchnick [JM79]. Less naive schemes have be developed <ref> [CWZ90, HN89, HPR89, LH88] </ref>, but we have yet to examine their suitability for our purposes. Object names provide ways to refer to objects in a program. An object name is a variable and a (possibly empty) sequence of dereferences and field accesses. <p> functions) and continuations (storing of runtime environment for later reuse). [Deu90] uses a very formal abstract interpretation [CC77] and is difficult to read. 3.3 Conflict/Dependence Analysis A related area of research is the work done by the compiling community on dependence analysis and conflict detection in programs with recursive structures <ref> [CWZ90, Gua88, HA90, HN89, HPR89, JM82, LH88] </ref>. This is particularly important for parallelizing programs. A conflict [LH88] occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location (loc), thus preventing the possibility of those statements being executed in parallel. <p> Two statements conflict if one writes and the other reads (or writes) a node in their respective alias graphs with the same label. While the conflict detection becomes easy, the labeling processes is not trivial. Unlike [LH88], Horwitz, Pfeiffer, and Reps <ref> [HPR89] </ref> are interested in intraprocedu-ral detection of dependencies. They also do this by augmenting [JM79] graphs, but, whereas unique labels were added in [LH88], here each node is labeled with the allocation site that last assigned to the storage represented by the node. This allows easy dependence detection. [HPR89] also use <p> and Reps <ref> [HPR89] </ref> are interested in intraprocedu-ral detection of dependencies. They also do this by augmenting [JM79] graphs, but, whereas unique labels were added in [LH88], here each node is labeled with the allocation site that last assigned to the storage represented by the node. This allows easy dependence detection. [HPR89] also use abstract interpretation as a framework for presenting their solution. However, they extended [CC77] by adding a fourth semantics; the instrumented semantics. This was done to prove the validity of their abstraction. It is unclear whether this extension will have utility outside of their paper.
Reference: [HRB88] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 35-46, </pages> <month> July </month> <year> 1988. </year> <journal> SIG-PLAN NOTICES, </journal> <volume> Vol. 23, No. 7. </volume> <pages> 253 </pages>
Reference-contexts: alias pairs in the set A = fA 1 ; A 2 ; :::; A m g holding at n 1 and the execution of path P implies that ha; bi holds at n i then 23 A similar two pass approach to construct interprocedural program slices was presented in <ref> [HRB88] </ref> and in [HS90]. 24 I.e., our alias solution will be imprecise but all actual alias pairs will be contained within the solution calculated. 34 either assuming no aliases at n 1 and executing path P forces ha; bi to hold at n i or 9k (1 k m) such that
Reference: [HS90] <author> M. J. Harrold and M. L. Soffa. </author> <title> Computation of interprocedural definition and use dependencies. </title> <booktitle> In Proceedings of the 1990 International Conference on Computer Languages, </booktitle> <pages> pages 297-306, </pages> <year> 1990. </year>
Reference-contexts: the set A = fA 1 ; A 2 ; :::; A m g holding at n 1 and the execution of path P implies that ha; bi holds at n i then 23 A similar two pass approach to construct interprocedural program slices was presented in [HRB88] and in <ref> [HS90] </ref>. 24 I.e., our alias solution will be imprecise but all actual alias pairs will be contained within the solution calculated. 34 either assuming no aliases at n 1 and executing path P forces ha; bi to hold at n i or 9k (1 k m) such that when assuming only
Reference: [JM79] <author> N. Jones and S. Muchnick. </author> <title> Flow analysis and optimization of lisp-like structures. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice Hall, </publisher> <year> 1979. </year>
Reference-contexts: Thus, any practical alias algorithm will have to represent the set of all possible objects and the alias relationships between those objects with a (small) finite data structure. We use a solution that is roughly analogous to k-limited as defined by Jones and Muchnick <ref> [JM79] </ref>. Less naive schemes have be developed [CWZ90, HN89, HPR89, LH88], but we have yet to examine their suitability for our purposes. Object names provide ways to refer to objects in a program. An object name is a variable and a (possibly empty) sequence of dereferences and field accesses. <p> Thus, for k = 1, p-&gt;f 1 -&gt;f 2 would be represented by p-&gt;f 1 (and not by flp). We will borrow Jones and Muchnick <ref> [JM79] </ref> terminology and call this k-limiting, even though they k-limit dynamic structures while we k-limit object names, because the two processes are analogous. <p> Thus dependence analysis and alias analysis have different goals and restrictions placed on them. We will concentrate on papers in the dependence analysis community that deal with recursive data structures. Jones and Muchnick <ref> [JM79] </ref> first analyzed how to track dynamic LISP-like structures; most research in this area is based in some way on the ideas in [JM79]. They restrict themselves to an intraprocedural domain, and use graphs to represent the structure of dynamic memory. <p> We will concentrate on papers in the dependence analysis community that deal with recursive data structures. Jones and Muchnick <ref> [JM79] </ref> first analyzed how to track dynamic LISP-like structures; most research in this area is based in some way on the ideas in [JM79]. They restrict themselves to an intraprocedural domain, and use graphs to represent the structure of dynamic memory. Nodes in the graph represent locations in memory and (directed) edges represents the fact that one location refers to the other. <p> level our alias algorithm can be viewed in their model as abstracting the program store with a set of (k-limited) alias pairs and abstracting the runtime stack with a single assumed alias pair (or with no alias assumption). 21 Larus and Hilfinger [LH88] developed an algorithm for conflict detection using <ref> [JM79] </ref>. They use an alias graph to represent the dynamic store. They extended the graphs in [JM79] to make alias graphs by adding unique labels to each node, thus making it easy to detect conflicts. <p> a set of (k-limited) alias pairs and abstracting the runtime stack with a single assumed alias pair (or with no alias assumption). 21 Larus and Hilfinger [LH88] developed an algorithm for conflict detection using <ref> [JM79] </ref>. They use an alias graph to represent the dynamic store. They extended the graphs in [JM79] to make alias graphs by adding unique labels to each node, thus making it easy to detect conflicts. Two statements conflict if one writes and the other reads (or writes) a node in their respective alias graphs with the same label. <p> While the conflict detection becomes easy, the labeling processes is not trivial. Unlike [LH88], Horwitz, Pfeiffer, and Reps [HPR89] are interested in intraprocedu-ral detection of dependencies. They also do this by augmenting <ref> [JM79] </ref> graphs, but, whereas unique labels were added in [LH88], here each node is labeled with the allocation site that last assigned to the storage represented by the node. This allows easy dependence detection. [HPR89] also use abstract interpretation as a framework for presenting their solution. <p> on some path 17 to an immediate predecessor of t and hflx; flyi also holds on some path to 15 By a level of indirection, we mean using the value stored in a location as the address of another location. 16 For example, k-limited as defined by Jones and Muchnick <ref> [JM79] </ref>. 17 Remember that holds is defined after execution of the last statement on the path. 25 an immediate predecessor of t.
Reference: [JM82] <author> N. D. Jones and S. S. Muchnick. </author> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: functions) and continuations (storing of runtime environment for later reuse). [Deu90] uses a very formal abstract interpretation [CC77] and is difficult to read. 3.3 Conflict/Dependence Analysis A related area of research is the work done by the compiling community on dependence analysis and conflict detection in programs with recursive structures <ref> [CWZ90, Gua88, HA90, HN89, HPR89, JM82, LH88] </ref>. This is particularly important for parallelizing programs. A conflict [LH88] occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location (loc), thus preventing the possibility of those statements being executed in parallel. <p> Summary nodes are used to represent the portions of the graph that must be collapsed to meet the requirements of k-limiting. k-limiting effectively reduces the number of graphs to a finite number. We have borrowed this notion from them and use it in our algorithm. In <ref> [JM82] </ref> Jones and Muchnick show how to do interprocedural data flow analysis in the presence of recursive structures. They use abstract interpretation [CC77] to do this.
Reference: [Kil73] <author> G. Kildall. </author> <title> A unified approach to global program optimization. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: However, the nature of Conditional Must Alias has little in common with Conditional May Alias. 28 We directly prove that the MFP of our equations is the same as the precise May Alias solution, thus we do not need to prove distributivity of our function space to show MFP MOP <ref> [Kil73] </ref>. 43 ICFG-node may-alias (ICFG-node) EN T RY main ; r = N U LL ; CALL A (q) ; RET U RN A (q) ; CALL A (&p) ; RET U RN A (&p) fhflp; flqi ; hflq; flqig EX IT main fhflp; flqi ; hflq; flqig EN T RY
Reference: [KS86] <author> H. Korth and A. Silberschatz. </author> <title> Database System Concepts. </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1986. </year>
Reference-contexts: We do not do this because, even for single level pointers, this would require at least O (n fl v 4 ) space. 42 The solution we choose is to do dynamic hashing. We use the dynamic hashing scheme presented in <ref> [KS86] </ref> (except we did not implement table shrinking as, for our purposes, this is never needed) giving us constant time operations in the average case. We implement the needed operations as follows: * Set may-hold ([(node; AA); PA]) to f alse for all possible node,AA, and P A.
Reference: [Lar89] <author> J. R. Larus. </author> <title> Restructuring Symbolic Programs for Concurrent Execution on Multiprocessors. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: He considers FORTRAN-like aliasing (i.e., aliasing that is the result of passing call-by-reference parameters); however, he did not classify the alias problem itself. All our N P-hardness proofs are variations of Myers' proof. Larus <ref> [Lar89] </ref> also modified Myers' proof to prove that intraprocedural aliasing in the presence of structures is N P -hard. Owing to their common origin, Larus' and our N P -hardness proofs are similar. <p> Even in those cases, it seems likely that this approximation will rarely occur. All N P-hardness proofs are variations of proofs by Myers [Mye81]; a similar, although independently discovered proof for recursive structure aliasing (as indicated in Table 4.1) can be found in <ref> [Lar89] </ref>. All problems which are categorized as polynomial time are corollaries of proofs of Theorem 4.2.3 or Theorem 4.2.4. <p> Formals, is N P-hard is N P-hard No Structures (Theorem 4.4.1) (Theorem 4.4.2) (Corollary 4.4.1) (Corollary 4.4.2) Single level pointers, - N P-hard Complement Pointer Reference is N P-hard Formals, (Theorem 4.5.1) (Theorem 4.5.2) No Structures Single level pointers, N P-hard Complement N P-hard Complement Structures, <ref> [Lar89] </ref> is N P-hard [Lar89] is N P-hard No Ref. <p> Formals, is N P-hard is N P-hard No Structures (Theorem 4.4.1) (Theorem 4.4.2) (Corollary 4.4.1) (Corollary 4.4.2) Single level pointers, - N P-hard Complement Pointer Reference is N P-hard Formals, (Theorem 4.5.1) (Theorem 4.5.2) No Structures Single level pointers, N P-hard Complement N P-hard Complement Structures, <ref> [Lar89] </ref> is N P-hard [Lar89] is N P-hard No Ref. <p> Further, every truth assignment corresponds to some such path. This idea of using aliases to represent a truth assignment is from Myers [Mye81]; Larus <ref> [Lar89] </ref> independently developed a similar proof for aliasing in dynamic structures. Now consider the paths from L2 to L3. <p> The proof of Theorem 4.6.1 is by reduction from the 3-SAT problem for V n l i;2 _ l i;3 ) with variables fv 1 ; v 2 ; :::; v m g. Larus <ref> [Lar89] </ref> presents an alternate proof of this theorem. Our proof is conceptually identical to the proof of Theorem 4.4.1. The reduction is specified by the program in Figure 4.16 which is polynomial in the size of the 3-SAT problem.
Reference: [LH88] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <month> July </month> <year> 1988. </year> <journal> SIGPLAN NOTICES, </journal> <volume> Vol. 23, No. </volume> <pages> 7. </pages>
Reference-contexts: We use a solution that is roughly analogous to k-limited as defined by Jones and Muchnick [JM79]. Less naive schemes have be developed <ref> [CWZ90, HN89, HPR89, LH88] </ref>, but we have yet to examine their suitability for our purposes. Object names provide ways to refer to objects in a program. An object name is a variable and a (possibly empty) sequence of dereferences and field accesses. <p> functions) and continuations (storing of runtime environment for later reuse). [Deu90] uses a very formal abstract interpretation [CC77] and is difficult to read. 3.3 Conflict/Dependence Analysis A related area of research is the work done by the compiling community on dependence analysis and conflict detection in programs with recursive structures <ref> [CWZ90, Gua88, HA90, HN89, HPR89, JM82, LH88] </ref>. This is particularly important for parallelizing programs. A conflict [LH88] occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location (loc), thus preventing the possibility of those statements being executed in parallel. <p> This is particularly important for parallelizing programs. A conflict <ref> [LH88] </ref> occurs between two statements when one statement writes a location and the other accesses (reads or writes) the same location (loc), thus preventing the possibility of those statements being executed in parallel. <p> Nevertheless, at a high level our alias algorithm can be viewed in their model as abstracting the program store with a set of (k-limited) alias pairs and abstracting the runtime stack with a single assumed alias pair (or with no alias assumption). 21 Larus and Hilfinger <ref> [LH88] </ref> developed an algorithm for conflict detection using [JM79]. They use an alias graph to represent the dynamic store. They extended the graphs in [JM79] to make alias graphs by adding unique labels to each node, thus making it easy to detect conflicts. <p> Two statements conflict if one writes and the other reads (or writes) a node in their respective alias graphs with the same label. While the conflict detection becomes easy, the labeling processes is not trivial. Unlike <ref> [LH88] </ref>, Horwitz, Pfeiffer, and Reps [HPR89] are interested in intraprocedu-ral detection of dependencies. They also do this by augmenting [JM79] graphs, but, whereas unique labels were added in [LH88], here each node is labeled with the allocation site that last assigned to the storage represented by the node. <p> While the conflict detection becomes easy, the labeling processes is not trivial. Unlike <ref> [LH88] </ref>, Horwitz, Pfeiffer, and Reps [HPR89] are interested in intraprocedu-ral detection of dependencies. They also do this by augmenting [JM79] graphs, but, whereas unique labels were added in [LH88], here each node is labeled with the allocation site that last assigned to the storage represented by the node. This allows easy dependence detection. [HPR89] also use abstract interpretation as a framework for presenting their solution. However, they extended [CC77] by adding a fourth semantics; the instrumented semantics.
Reference: [Lom77] <author> D. Lomet. </author> <title> Data flow analysis in the presence of procedure calls. </title> <journal> Journal of Research and Development, </journal> <volume> 21(6) </volume> <pages> 559-571, </pages> <month> November </month> <year> 1977. </year>
Reference-contexts: We have not chosen this approach. Instead, we use the idea of solving a data flow problem for a procedure assuming an alias condition on entry. This is reminiscent of Lomet's approach to solving data flow problems under different aliasing conditions <ref> [Lom77] </ref> and also to Marlowe's notion of a representative data flow problem [MR90]. The key idea in our solution to the unrealizable path problem is to devise a two step algorithm.
Reference: [LR90] <author> W. Landi and B. G. Ryder. </author> <title> Aliasing with and without pointers: A problem taxonomy. </title> <institution> Center for Computer Aids for Industrial Productivity Technical Report CAIP-TR-125, Rutgers University, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: However, it is polynomial time and precise and is extensible to the Interprocedural May Alias problem. The algorithm below is explained in a manner to aid understanding; it is not an efficient implementation. This algorithm was originally presented in <ref> [LR90] </ref>. However, the presentation in [LR90] contains the following implicit assumption that, while valid in practice, is not reasonable in the proofs contained in this chapter. Consider the statement, "p = q". In [LR90] we assumed that hflp; flqi holds on any path through "p = q", but this is only <p> However, it is polynomial time and precise and is extensible to the Interprocedural May Alias problem. The algorithm below is explained in a manner to aid understanding; it is not an efficient implementation. This algorithm was originally presented in <ref> [LR90] </ref>. However, the presentation in [LR90] contains the following implicit assumption that, while valid in practice, is not reasonable in the proofs contained in this chapter. Consider the statement, "p = q". In [LR90] we assumed that hflp; flqi holds on any path through "p = q", but this is only valid if q is not <p> This algorithm was originally presented in <ref> [LR90] </ref>. However, the presentation in [LR90] contains the following implicit assumption that, while valid in practice, is not reasonable in the proofs contained in this chapter. Consider the statement, "p = q". In [LR90] we assumed that hflp; flqi holds on any path through "p = q", but this is only valid if q is not N U LL. <p> We do this on the same ten C programs that we analyzed using Weihl's algorithm to justify our development of a new approximation algorithm <ref> [LR90] </ref> 64 ; a short description of each program can be found in Figure 6.2 on p. 122. As expected Weihl's algorithm reports more program aliases than our algorithm. <p> We are only able to time the second stage of the calculation, which on large programs dominates execution time. In Table 6.2, we compare the time of our algorithm versus the time for Weihl's algorithm (second stage only). Again, this is a 64 In <ref> [LR90] </ref>, the number of aliases found by Weihl are reported as twice what they are reported here because aliases were counted twice (i.e., once for ha; bi and once for hb; ai). 65 This number is not statistically significant.
Reference: [LR91] <author> W. Landi and B. G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: We allow arrays but simply treat them as aggregates. We represent programs by interprocedural control flow graphs (ICFGs) that we originally presented in <ref> [LR91] </ref>. An ICFG is, intuitively, the union of the control flow graphs (CFGs) 5 [Hec77] for each procedure, with calls connected to the procedures they invoke. <p> As in <ref> [LR91] </ref> we will represent aliases by unordered pairs of object names (for example, hv; flpi). The order is unimportant because the alias relation is symmetric. <p> Consider the following example (where q is global to P but r is not and q,r, and f are all type "int *"): 43 In <ref> [LR91] </ref> we referred to this by "". 83 int y; f a=&y; main () f int x; P (); Note: The call to P in main creates the alias pair hflb; xi and destroys the alias pair hfla; xi. * fi call P (q) ? * fi entry P (f) store
Reference: [LS88] <author> S. B. Lippman and B. Stroustrup. </author> <title> Pointers to class members in c++. </title> <booktitle> In Proceedings of the 1988 USENIX C++ Conference, </booktitle> <pages> pages 305-323, </pages> <year> 1988. </year>
Reference-contexts: Also we need to investigate the utility of such information. * We wish to investigate alias analysis in object-oriented programming paradigms, for example pointers to class members <ref> [LS88] </ref>. 140 Appendix A Dictionary of Functions address type (type) returns the type of objects which can point to type. (Chapter 2.2) alias consequences (alias) is the set of all aliases that are implied by alias.
Reference: [MR90] <author> T. J. Marlowe and B. G. Ryder. </author> <title> An efficient hybrid algorithm for incremental data flow analysis. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 184-196, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Instead, we use the idea of solving a data flow problem for a procedure assuming an alias condition on entry. This is reminiscent of Lomet's approach to solving data flow problems under different aliasing conditions [Lom77] and also to Marlowe's notion of a representative data flow problem <ref> [MR90] </ref>. The key idea in our solution to the unrealizable path problem is to devise a two step algorithm.
Reference: [MR91] <author> T. J. Marlowe and B. G. Ryder. </author> <title> Hybrid incremental alias algorithms. </title> <booktitle> In Proceedings of the Twentyfourth Hawaii International Conference on System Sciences, Volume II, Software, </booktitle> <pages> pages 428-437, </pages> <month> January </month> <year> 1991. </year> <month> 254 </month>
Reference-contexts: To avoid this problem, later algorithms, including our algorithm, compute alias pairs instead of alias sets, because the number of alias pairs is polynomial in the number of variables in the program. Some precise polynomial time algorithms for finding aliases 16 in FORTRAN programs are [Ban79, Bur90, Coo85, CK89]. <ref> [MR91] </ref> presents an incremental algorithm for finding aliases in the presence of call-by-reference parameters.
Reference: [Mye81] <author> E. M. Myers. </author> <title> A precise interprocedural data flow algorithm. </title> <booktitle> In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: When this execution path traverses more than one procedure, we are solving the Interprocedural May Alias Problem. Although the calculation of aliases for FORTRAN is well understood <ref> [Ban79, Coo85, CK89, Mye81] </ref>, we show that general pointers added as a language construct cause the problem of computing aliases to become N P -hard, a situation for which no good approximation algorithms exist. <p> The second concerns other alias algorithms in the presence of pointers. The third is conflict/dependence detection which, while not identical to alias analysis and not directly addressed in this thesis, is similar enough to warrant comment. 3.1 Theoretical Classification Myers <ref> [Mye81] </ref> proves that certain data flow problems in the presence of aliases are N P-complete. He considers FORTRAN-like aliasing (i.e., aliasing that is the result of passing call-by-reference parameters); however, he did not classify the alias problem itself. All our N P-hardness proofs are variations of Myers' proof. <p> Owing to their common origin, Larus' and our N P -hardness proofs are similar. Many algorithms have been developed to solve for aliasing in the presence of call-by-reference formals (i.e., aliasing in FORTRAN). Myers <ref> [Mye81] </ref> presents an algorithm for finding alias sets which is precise under the traditional assumptions of static analysis [Ban79]. If an alias set S is in Myers' solution at a program point p, then on some path to p, every (and only) the aliases represented in S exist at p. <p> Benjamin Cooper [Coo89] has developed an algorithm which uses explicit path information in the form of alias histories to insure (for interprocedural paths) that a procedure returns to the call site that invoked it. His alias histories are based on <ref> [Mye81] </ref>, and consist of the last call site on the execution stack and a set of aliases that hold on the path to the entry of the procedure. <p> Even in those cases, it seems likely that this approximation will rarely occur. All N P-hardness proofs are variations of proofs by Myers <ref> [Mye81] </ref>; a similar, although independently discovered proof for recursive structure aliasing (as indicated in Table 4.1) can be found in [Lar89]. All problems which are categorized as polynomial time are corollaries of proofs of Theorem 4.2.3 or Theorem 4.2.4. <p> Theorem 4.1.2 There exists a polynomial algorithm for determining precise Interpro-cedural Must Alias sets in the presence of reference formals. The problem of determining Interprocedural May Alias sets in the presence of reference formals has been examined extensively. Most notable are the algorithms presented in <ref> [Ban79, Coo85, CK89, Mye81] </ref>. We do not present any formal proofs of Theorem 4.1.1 and Theorem 4.1.2, which follow directly from previous work. <p> Further, every truth assignment corresponds to some such path. This idea of using aliases to represent a truth assignment is from Myers <ref> [Mye81] </ref>; Larus [Lar89] independently developed a similar proof for aliasing in dynamic structures. Now consider the paths from L2 to L3.
Reference: [NPD87] <author> A. Neirynck, P. Panangaden, and A. Demers. </author> <title> Computation of aliases and support sets. </title> <booktitle> In Conference Record of the Fourteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 274-283, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Cooper's method seems time and space infeasible without restricting the size of the alias sets. There also has been some work <ref> [Deu90, NPD87] </ref> in detecting aliases in higher order programming languages (i.e., languages where functions are treated like any other data type). [NPD87] only considers programs with single level dereferences and has the 19 added difficulty of tracking the binding of functions to names. <p> Cooper's method seems time and space infeasible without restricting the size of the alias sets. There also has been some work [Deu90, NPD87] in detecting aliases in higher order programming languages (i.e., languages where functions are treated like any other data type). <ref> [NPD87] </ref> only considers programs with single level dereferences and has the 19 added difficulty of tracking the binding of functions to names. Interprocedurally, they solve the alias problem for a procedure with the initial information induced by each call chain 9 . <p> 11 They need to be restricted so that equality of path expressions can be computed in time polynomial in the size of the expressions. 12 and function calls within intraprocedural loops 22 analogy; they don't use have assumed path matrices, but rather propagate path matrices along execution paths, and like <ref> [NPD87] </ref> effectively analyze a procedure once for each calling chain which invokes it. However, if our idea of limiting the assumption to a single alias assumption is valid for their problem 13 , then both these methods would produce the same solution, but ours would do so more efficiently.
Reference: [PRL91] <author> H.D. Pande, B. G. Ryder, and W. Landi. </author> <title> Interprocedural def-use associations in c programs. </title> <booktitle> In Proceedings of the Fifth Testing, Analysis, and Verification Symposium, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: This algorithm is used by <ref> [PRL91] </ref>. * Formulation of the Conditional May Alias problem (Chapter 4.2.3, p. 32), which we feel maybe more useful than May Alias for data flow analysis in the presence of 2 Precision is a measure of the erroneous information contained in the solution. 3 However, it is possible for the intraprocedural <p> The work in <ref> [PRL91] </ref> indicates that this indeed was the case for reaching definitions, and we are currently investigating the suitability of Conditional May Alias information for MOD. * Development of an approximation algorithm for Interprocedural May Alias in the presence of pointers (Chapter 5) that is provably as precise as possible in the <p> Table 6.7 indicates that this is indeed the case in terms of the number of relations computed. The maximum ratio of our Conditional May Alias solution to our May Alias solution is 5.9; for k = 2 the average is 1.6. As indicated in <ref> [PRL91] </ref>, the additional information in Conditional May Alias can lead to more precise results in problems like Reaching Definitions. <p> However, we still need to investigate the possibility of using other mechanisms for limiting the representation for dynamic stores. * We will continue and generalize the research in <ref> [PRL91] </ref> by investigating the utility of Conditional May Alias in various data flow problems, especially MOD. * We wish to remove the restrictions we placed on C, especially to allow the presence of function variables. * We want to extend our precise algorithm for Interprocedural Must Alias in the presence of
Reference: [PW86] <author> D. A. Padua and M. J. Wolfe. </author> <title> Advanced compiler optimizations for supercomputers. </title> <journal> Communications of the ACM, </journal> <volume> 29(12) </volume> <pages> 1184-1201, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: A data dependence exists between two statements iff they conflict and there is an execution path from one program point to the other on which loc is not written. There are actually three types of data dependences <ref> [PW86, Wol89] </ref>; flow dependences, anti-dependences, and output dependences. The type of dependence is determined by the direction of the path and which endpoint (s) write loc. Algorithms for detecting dependences (or conflicts) need more information than an alias calculation. <p> Guarna [Gua88] uses trees to represent what we defined as object names. Where we defined object names by the set of names derivable from a grammar, Guarna uses the actual parse trees. He then redefines the traditional data dependence calculation <ref> [PW86] </ref> in terms of these trees.
Reference: [RP88] <author> B. G. Ryder and H. Pande. </author> <title> The interprocedural structure of c programs: An empirical study. </title> <institution> Laboratory for Computer Science Research Technical Report LCSR-TR-99, Department of Computer Science, Rutgers University, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: These programs came from a pool of available C programs that was collected for an ongoing empirical study of the structure of C programs <ref> [RP88] </ref>. Programs were selected from that pool if they met the following restrictions: * Program size not much larger than 5,000 lines. * Use of function variables was simple enough to resolve by hand. * Little or no pointer casting. * Few nested structures. <p> Figure 6.2 contains a short description of the programs we used (many of these descriptions can be found in <ref> [RP88] </ref>). Since our implementation is defined in terms of k-limiting, where k is a run-time constant, our studies include a comparison of our algorithm's behavior on the same program for different values of k. We tried k = 1, 2, 3, and 4.
Reference: [Ryd89] <author> B. G. Ryder. </author> <title> Ismm: Incremental software maintenance manager. </title> <booktitle> In Proceedings of the IEEE Computer Society Conference on Software Maintenance, </booktitle> <pages> pages 142-164, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Without alias information, this and many other optimizations can not be done. Originally, we became interested in this problem while working on ISMM <ref> [Ryd89] </ref>, an incremental data flow analyzer which solves the modification side effect problem (MOD) [Ban78, Ban79, Bur90, CK84, CK87b] for C programs and is designed to help programmers maintain large evolving software systems.
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189-234. </pages> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: One possible solution to this problem is to keep path information and use it to avoid paths which are not realizable. This concept of "alias histories" is used by <ref> [Coo89, SP81] </ref>. We have not chosen this approach. Instead, we use the idea of solving a data flow problem for a procedure assuming an alias condition on entry.
Reference: [Wei80a] <author> W. E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <type> Master's thesis, </type> <institution> M.I.T., </institution> <month> June </month> <year> 1980. </year>
Reference-contexts: These facts suggest that existing FORTRAN alias algorithms are not extensible to handle pointers. Existing Alias Algorithms Originally we tried using an extant alias technique <ref> [Wei80a] </ref> for finding aliases with pointers combined with the FORTRAN decomposition for solving MOD. Using this information resulted in a solution that safely claimed, for all practical purposes, every statement could modify every variable. <p> Using this information resulted in a solution that safely claimed, for all practical purposes, every statement could modify every variable. This was the result of using an inappropriate decomposition for MOD for C and the fact that the extant aliasing technique <ref> [Wei80a] </ref> was too approximate (see Chapter 3). <p> The main ideas of our algorithm are highlighted in the text and the interested reader can find pseudo-code for the algorithm in the figures and Appendices. Our algorithm is program-point-specific and thus more precise than Weihl's algorithm <ref> [Wei80a] </ref>. We currently have a prototype implementation in C for analyzing C programs. 5 Precision 2 and Efficiency of Approximate Algorithm In Chapter 6 we give some theoretical bounds on the precision of our algorithm and for any other approximation algorithm. <p> We empirically compared our approximate algorithm to Weihl's algorithm <ref> [Wei80a] </ref>. Not surprisingly, we found that our algorithm was slower but produced a more precise solution (Chapter 6.3). * Isolation of sources of approximation for our algorithm (Lemma E.1.1 (p. 245)). <p> an alias at entry of a procedure, they assume an alias at the head node of a strongly connected component of the call graph. 3.2 Algorithms for Finding Aliases in Programs with Pointers One of the first algorithms for finding aliases in the presence of pointers was developed by Weihl <ref> [Wei80a, Wei80b] </ref>. Weihl finds program aliases (aliases on some path in the program) rather than program point aliases (aliases on some path to a specific program point) and approximates object names using 1-limiting. His solution is fairly simple. <p> Finally, the theoretical and empirical investigation of our algorithm showed that for at least one definition of precision, in the worst case no algorithm can be more precise 139 than our algorithm. It also empirically yielded very encouraging precision results and showed great improvement over the extant technique <ref> [Wei80a] </ref>. 7.2 Future Work The main thrust of the thesis has been the development of a good algorithm for approximating aliases in the presence of pointers and while the initial results are promising, the algorithm presented here is by no means the last word on the subject.
Reference: [Wei80b] <author> W. E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <booktitle> In Conference Record of the Seventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: an alias at entry of a procedure, they assume an alias at the head node of a strongly connected component of the call graph. 3.2 Algorithms for Finding Aliases in Programs with Pointers One of the first algorithms for finding aliases in the presence of pointers was developed by Weihl <ref> [Wei80a, Wei80b] </ref>. Weihl finds program aliases (aliases on some path in the program) rather than program point aliases (aliases on some path to a specific program point) and approximates object names using 1-limiting. His solution is fairly simple.
Reference: [Wol89] <author> Michael Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year> <month> 255 </month>
Reference-contexts: A data dependence exists between two statements iff they conflict and there is an execution path from one program point to the other on which loc is not written. There are actually three types of data dependences <ref> [PW86, Wol89] </ref>; flow dependences, anti-dependences, and output dependences. The type of dependence is determined by the direction of the path and which endpoint (s) write loc. Algorithms for detecting dependences (or conflicts) need more information than an alias calculation.
References-found: 48

