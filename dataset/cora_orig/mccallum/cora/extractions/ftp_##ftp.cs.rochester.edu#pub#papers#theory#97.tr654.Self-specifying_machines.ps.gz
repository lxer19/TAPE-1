URL: ftp://ftp.cs.rochester.edu/pub/papers/theory/97.tr654.Self-specifying_machines.ps.gz
Refering-URL: http://www.cs.rochester.edu/trs/theory-trs.html
Root-URL: 
Title: Self-Specifying Machines  A natural variant accepts exactly the languages in R #P  
Author: Lane A. Hemaspaandra Harald Hempel and Gerd Wechsung 
Note: m (NP).  a constant number of questions to NP.  
Date: April 9, 1997  
Address: Rochester, NY 14627, USA  07740 Jena, Germany  
Affiliation: Department of Computer Science University of Rochester  Institut fur Informatik Friedrich-Schiller-Universitat Jena  
Abstract: We study the computational power of machines that specify their own ac ceptance types, and show that they accept exactly the languages in R #P m (P). We show that these two classes coincide if and only if P #P[1] = P #P[1]:NP[O(1)] , where the latter class denotes the sets acceptable via at most one question to #P followed by at most
Abstract-found: 1
Intro-found: 1
Reference: [ABT96] <author> M. Agrawal, R. Beigel, and T. Thierauf. </author> <title> Pinpointing computation with modular queries in the boolean hierarchy. </title> <booktitle> In Proceedings of the 16th Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 322-334. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #1180, </note> <month> December </month> <year> 1996. </year>
Reference: [BC93] <author> D. Bovet and P. Crescenzi. </author> <title> Introduction to the Theory of Complexity. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference: [BCS92] <author> D. Bovet, P. Crescenzi, and R. Silvestri. </author> <title> A uniform approach to define complexity classes. </title> <journal> Theoretical Computer Science, </journal> <volume> 104(2) </volume> <pages> 263-283, </pages> <year> 1992. </year>
Reference: [BDG95] <author> J. Balcazar, J. Daz, and J. Gabarro. </author> <title> Structural Complexity I. </title> <booktitle> EATCS Monographs in Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1995. </year>
Reference: [BLS84] <author> R. Book, T. Long, and A. Selman. </author> <title> Quantitative relativizations of complexity classes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 13(3) </volume> <pages> 461-487, </pages> <year> 1984. </year>
Reference: [BLS85] <author> R. Book, T. Long, and A. Selman. </author> <title> Qualitative relativizations of complexity classes. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 30 </volume> <pages> 395-413, </pages> <year> 1985. </year>
Reference: [CF91] <author> J. Cai and M. Furst. </author> <title> PSPACE survives constant-width bottlenecks. </title> <journal> International Journal of Foundations of Computer Science, </journal> <volume> 2(1) </volume> <pages> 67-76, </pages> <year> 1991. </year>
Reference-contexts: the two answers (even given a "lying" answer to the first query) is: accept if and only if the second answer is "yes." 4 of those languages having easy "implicit membership tests" [HH91], and also is exactly the class of languages accepted at the second level of Cai and Furst's <ref> [CF91] </ref> safe storage hierarchy ([Ogi94], see also the discussion in [HO96]).
Reference: [CH90] <author> J. Cai and L. Hemachandra. </author> <title> On the power of parity polynomial time. </title> <journal> Mathematical Systems Theory, </journal> <volume> 23(2) </volume> <pages> 95-106, </pages> <year> 1990. </year>
Reference-contexts: This can all be done via one query to #SAT, as it is well known that three parallel queries to #SAT can be encoded as one query to #SAT ([PZ83], see also <ref> [CH90] </ref>). Using the answer to item (a), M v (x) then determines the first query to SAT that would be made by M (x), namely, the SAT query M (x) makes after M (x) gets the reply from its #SAT query.
Reference: [FFK94] <author> S. Fenner, L. Fortnow, and S. Kurtz. </author> <title> Gap-definable counting classes. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 48(1) </volume> <pages> 116-148, </pages> <year> 1994. </year>
Reference: [GKR + 95] <author> F. Green, J. Kobler, K. Regan, T. Schwentick, and J. Toran. </author> <title> The power of the middle bit of a #P function. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 50(4) </volume> <pages> 456-467, </pages> <year> 1995. </year>
Reference-contexts: Work done in part while visiting Le Moyne College. Email: wechsung@informatik.uni-jena.de. 1 one set serves simultaneously as the fixed accepting type of all sets in PP PH . This follows immediately from the fact that PP PH MP (Green et al. <ref> [GKR + 95] </ref>, who also define the "middle bit" class MP). Thus, in the notation to soon be introduced, the fixed set MiddleBit has the property that PP PH R #P m (fMiddleBitg). In contrast, some classes have been defined via an external function or set specifying their acceptance type.
Reference: [GP86] <author> L. Goldschlager and I. Parberry. </author> <title> On the construction of parallel computers from various bases of boolean functions. </title> <journal> Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 43-58, </pages> <year> 1986. </year>
Reference: [Gre95] <author> F. Green. </author> <title> Lower bounds for depth-three circuits with equals and mod-gates. </title> <booktitle> In Proceedings of the 12th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 71-82. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #900, </note> <month> March </month> <year> 1995. </year>
Reference-contexts: That 10 is, PP P P #P [1] P #P [1]:NP [1] + P #P [2] PSPACE (the first containment|which is nontrivial|is due to Toda [Tod91]), yet no known oracle separates PP P from PSPACE (see Green <ref> [Gre95] </ref> for background and for progress on a related line). On the other hand, as even P NP [O (log n)]:#P [1] easily equals P #P [1] (via the technique of [CH90,PZ83]), clearly if query order can be swapped in the characterization of SelfOutput then SelfPath = SelfOutput.
Reference: [HH91] <author> L. Hemachandra and A. Hoene. </author> <title> On sets with efficient implicit membership tests. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(6) </volume> <pages> 1148-1156, </pages> <year> 1991. </year>
Reference-contexts: However, for flexible language classes such as P, NP, etc., and flexible function classes such as #P, OptP [Kre88], etc., this equality will hold, as has been noted by Hemaspaandra and Hoene <ref> [HH91] </ref> for the particular case of R OptP m (P). <p> assume that the querying machine always makes exactly two queries and that its truth table with respect to the two answers (even given a "lying" answer to the first query) is: accept if and only if the second answer is "yes." 4 of those languages having easy "implicit membership tests" <ref> [HH91] </ref>, and also is exactly the class of languages accepted at the second level of Cai and Furst's [CF91] safe storage hierarchy ([Ogi94], see also the discussion in [HO96]).
Reference: [HHH96] <author> E. Hemaspaandra, L. Hemaspaandra, and H. Hempel. </author> <title> Query order in the polynomial hierarchy. </title> <type> Technical Report TR-634, </type> <institution> University of Rochester, Department of Computer Science, Rochester, </institution> <address> NY, </address> <month> September </month> <year> 1996. </year>
Reference: [HHH97] <author> E. Hemaspaandra, L. Hemaspaandra, and H. Hempel. </author> <title> R SN 1-tt (NP) distinguishes robust many-one and Turing completeness. </title> <booktitle> In Proceedings of the 3rd Italian Conference on Algorithms and Complexity, </booktitle> <pages> pages 49-60. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #1203, </note> <month> March </month> <year> 1997. </year>
Reference: [HHT] <author> Y. Han, L. Hemaspaandra, and T. Thierauf. </author> <title> Threshold computation and cryptographic security. </title> <journal> SIAM Journal on Computing. </journal> <note> To appear. 14 </note>
Reference-contexts: However, under our definition, on each input x every possible binary string of exactly p (jxj) bits corresponds uniquely to a computation path.) Though normalization is known not to be important in defining NP languages or even|as shown by Simon [Sim75]|PP languages, there is evidence <ref> [HHT] </ref> that the type of normalization one uses is critical in defining BPP languages. Here, it will be important in our definition of SelfPath; however, in our definition of SelfOutput, the same class would be defined even if a normalization requirement were added. <p> This holds true in the unbounded-error case. It is also true in the bounded-error case (i.e., BPP is the same class whether one defines it using the former normalization or the latter normalization). 12 may be different depending on whether or not there is a normalization requirement <ref> [HHT, JMT94,HVW96] </ref>. Recall that SelfOutput does remain the same whether defined with or without the requirement that the underlying machines be normalized.
Reference: [HHW] <author> L. Hemaspaandra, H. Hempel, and G. Wechsung. </author> <title> Query order. </title> <journal> SIAM Journal on Computing. </journal> <note> To appear. </note>
Reference-contexts: For any a and b for which b a is defined and any class C, let R b a (C) = fL fi (9C 2 C)[L b Hemaspaandra, Hempel, and Wechsung <ref> [HHW] </ref> introduced the study of the power of ordered query access (other papers on or related to query order include [HHH96,ABT96, Wag97,HHH97]). We adopt this notion, and extend it to the function class case and to 3 the positive query case.
Reference: [HHW95] <author> L. Hemaspaandra, H. Hempel, and G. Wechsung. </author> <title> Query order and self-specifying machines. </title> <type> Technical Report TR-596, </type> <institution> University of Rochester, Department of Computer Science, Rochester, </institution> <address> NY, </address> <month> October </month> <year> 1995. </year>
Reference: [HJ95] <author> L. Hemaspaandra and S. Jha. </author> <title> Defying upward and downward separation. </title> <journal> Information and Computation, </journal> <volume> 121(1) </volume> <pages> 1-13, </pages> <year> 1995. </year>
Reference-contexts: However, we show that these two classes are equal if and only if P #P [1] = P #P [1]:NP [O (1)] . This is a so-called "downward separation" result (see, e.g., <ref> [HJ95] </ref>, for some background), and indeed what 2 our proof actually establishes is that the following three conditions are equivalent: 1. P #P [1] = P #P [1]:NP [1] + , 3. P #P [1] = P #P [1]:NP [O (1)] .
Reference: [HLS + 93] <author> U. Hertrampf, C. Lautemann, T. Schwentick, H. Vollmer, and K. Wagner. </author> <title> On the power of polynomial time bit-reductions. </title> <booktitle> In Proceedings of the 8th Structure in Complexity Theory Conference, </booktitle> <pages> pages 200-207. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1993. </year>
Reference: [HO96] <author> L. Hemaspaandra and M. Ogihara. </author> <title> Universally serializable computation. </title> <type> Technical Report TR-638, </type> <institution> University of Rochester, Department of Computer Science, Rochester, </institution> <address> NY, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: first query) is: accept if and only if the second answer is "yes." 4 of those languages having easy "implicit membership tests" [HH91], and also is exactly the class of languages accepted at the second level of Cai and Furst's [CF91] safe storage hierarchy ([Ogi94], see also the discussion in <ref> [HO96] </ref>).
Reference: [HV95] <author> L. Hemaspaandra and H. Vollmer. </author> <title> The Satanic notations: Counting classes beyond #P and other definitional adventures. </title> <journal> SIGACT News, </journal> <volume> 26(1) </volume> <pages> 2-13, </pages> <year> 1995. </year>
Reference-contexts: Often, though not always, Vollmer's classes are referred to using notation such as # NP, in order to avoid ambiguity as to whether his classes or Valiant's classes are being discussed (see <ref> [HV95] </ref>).
Reference: [HVW96] <author> U. Hertrampf, H. Vollmer, and K. Wagner. </author> <title> On balanced versus unbalanced computation trees. </title> <journal> Mathematical Systems Theory, </journal> <volume> 29(4) </volume> <pages> 411-421, </pages> <month> July/August </month> <year> 1996. </year>
Reference: [HW97] <author> H. Hempel and G. Wechsung. </author> <title> On the power of #P reductions. </title> <type> Technical Report Math/Inf/97/2, </type> <institution> Institut fur Informatik, Friedrich-Schiller-Universitat-Jena, Jena, Ger-many, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: Theorem 3.4 equivalently says P #P [1] = P #P [1]:NP [1] + () P #P [1] = P #P [1]:NP [O (1)] . Related work shows that the equality of SelfPath and SelfOutput would collapse the boolean hierarchy over SelfOutput <ref> [HW97] </ref>. Proof of Theorem 3.4: We will prove this in two steps.
Reference: [JMT94] <author> B. Jenner, P. McKenzie, and D. Therien. </author> <title> Logspace and logtime leaf languages. </title> <booktitle> In Proceedings of the 9th Structure in Complexity Theory Conference, </booktitle> <pages> pages 242-253. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June/July </month> <year> 1994. </year>
Reference: [KL80] <author> R. Karp and R. Lipton. </author> <title> Some connections between nonuniform and uniform complexity classes. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 302-309, </pages> <month> April </month> <year> 1980. </year> <note> An extended version has also appeared as: Turing machines that take advice, </note> <editor> L'Enseignement Mathematique, </editor> <booktitle> 2nd series 28, </booktitle> <year> 1982, </year> <pages> pages 191-209. </pages>
Reference-contexts: Generalizing the seminal "advice classes" notion of Karp and Lipton <ref> [KL80] </ref>, Kobler and Thierauf [KT94] have studied an interesting notion, which appeared previously in work of Krentel and others, that they note is related to many-one reductions via functions.
Reference: [Kre88] <author> M. Krentel. </author> <title> The complexity of optimization problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 36 </volume> <pages> 490-509, </pages> <year> 1988. </year>
Reference-contexts: However, for flexible language classes such as P, NP, etc., and flexible function classes such as #P, OptP <ref> [Kre88] </ref>, etc., this equality will hold, as has been noted by Hemaspaandra and Hoene [HH91] for the particular case of R OptP m (P). <p> They capture the power of a class whose computation is aided by some advice provided by some complexity-bounded function class. Indeed, R OptP m (P) turns out, as Krentel established <ref> [Kre88] </ref>, to be exactly P NP .
Reference: [KST89] <author> J. Kobler, U. Schoning, and J. Toran. </author> <title> On counting and approximation. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 363-379, </pages> <year> 1989. </year>
Reference-contexts: that if in the definition of SelfOutput we replace "x 2 L () #acc M (x) is the integer reading of the output of some accepting path" with "x 2 L () span M (x) is the integer reading of the output of some accepting path" (where span M (x) <ref> [KST89] </ref> as is standard denotes the number of distinct outputs of M (x)), then the class defined remains unchanged. From Theorem 3.1 and the discussion of Section 2, it is clear that we have the following.
Reference: [KT94] <author> J. Kobler and T. Thierauf. </author> <title> Complexity-restricted advice functions. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23(2) </volume> <pages> 261-275, </pages> <year> 1994. </year>
Reference-contexts: Generalizing the seminal "advice classes" notion of Karp and Lipton [KL80], Kobler and Thierauf <ref> [KT94] </ref> have studied an interesting notion, which appeared previously in work of Krentel and others, that they note is related to many-one reductions via functions.
Reference: [LLS75] <author> R. Ladner, N. Lynch, and A. Selman. </author> <title> A comparison of polynomial time reducibilities. </title> <journal> Theoretical Computer Science, </journal> <volume> 1(2) </volume> <pages> 103-124, </pages> <year> 1975. </year>
Reference: [Ogi94] <author> M. </author> <title> Ogihara. </title> <booktitle> On serializable languages. International Journal of Foundations of Computer Science, </booktitle> <address> 5(3-4):303-318, </address> <year> 1994. </year>
Reference: [OH93] <author> M. Ogiwara and L. Hemachandra. </author> <title> A complexity theory for closure properties. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 46(3) </volume> <pages> 295-325, </pages> <year> 1993. </year>
Reference: [Pap94] <author> C. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year> <month> 15 </month>
Reference: [PZ83] <author> C. Papadimitriou and S. Zachos. </author> <title> Two remarks on the power of counting. </title> <booktitle> In Proceedings 6th GI Conference on Theoretical Computer Science, </booktitle> <pages> pages 269-276. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #145, </note> <year> 1983. </year>
Reference: [Sel82] <author> A. Selman. </author> <title> Reductions on NP and P-selective sets. </title> <journal> Theoretical Computer Science, </journal> <volume> 19 </volume> <pages> 287-304, </pages> <year> 1982. </year>
Reference: [Sim75] <author> J. Simon. </author> <title> On Some Central Problems in Computational Complexity. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <address> Ithaca, N.Y., </address> <month> January </month> <year> 1975. </year> <note> Available as Cornell Department of Computer Science Technical Report TR75-224. </note>
Reference: [Tod91] <author> S. </author> <title> Toda. Computational Complexity of Counting Complexity Classes. </title> <type> PhD thesis, </type> <institution> Tokyo Institute of Technology, Department of Computer Science, </institution> <address> Tokyo, Japan, </address> <year> 1991. </year>
Reference-contexts: In fact, separating even over a vastly larger gap that includes these classes is an open issue. That 10 is, PP P P #P [1] P #P [1]:NP [1] + P #P [2] PSPACE (the first containment|which is nontrivial|is due to Toda <ref> [Tod91] </ref>), yet no known oracle separates PP P from PSPACE (see Green [Gre95] for background and for progress on a related line).
Reference: [Val79a] <author> L. Valiant. </author> <title> The complexity of computing the permanent. </title> <journal> Theoretical Computer Science, </journal> <volume> 8 </volume> <pages> 189-201, </pages> <year> 1979. </year>
Reference-contexts: Similar claims hold for R #P m (C = P) and (with a bit of care) for R #P m (PP). Let us adopt Valiant's <ref> [Val79a] </ref> standard definition of #NP (informally, #NP = (#P) NP ), and the analogous definition of #PH (informally, #PH = (#P) PH ) [WT92]. 3 In this paper, we have discussed a number of "R #P m " closures of classes.
Reference: [Val79b] <author> L. Valiant. </author> <title> The complexity of enumeration and reliability problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 8(3) </volume> <pages> 410-421, </pages> <year> 1979. </year>
Reference: [Vol94] <author> H. Vollmer. </author> <title> Komplexitatsklassen von Funktionen. </title> <type> PhD thesis, </type> <institution> Universitat Wurzburg, Institut fur Informatik, Wurzburg, Germany, </institution> <year> 1994. </year>
Reference-contexts: However, note that from Toda and Watanabe's [WT92] result #PH FP #P [1] we can easily prove the following proposition, which says that "R #NP m " closures (or even 3 Vollmer <ref> [Vol94] </ref> and Toda and Watanabe ([WT92], using the different notation "NUMC") have proposed interesting and different "#"-type classes.
Reference: [VW93] <author> H. Vollmer and K. Wagner. </author> <title> The complexity of finding middle elements. </title> <journal> International Journal of Foundations of Computer Science, </journal> <volume> 4 </volume> <pages> 293-307, </pages> <year> 1993. </year>
Reference-contexts: Does SelfPath remain the same class if its normalization requirement is removed? Clearly the resulting class contains SelfPath, i.e., P #P [1] , and is contained in P #P (which Vollmer and Wagner <ref> [VW93] </ref> showed equals P "NameofMiddlePath"[1] ; thus P "NameofMiddlePath"[1] , though it is an upper bound for the unnormalized version of SelfPath, does not offer a tighter upper bound than P #P ). Acknowledgments We are grateful to Edith Hemaspaandra, Johannes Kobler, and Jorg Rothe for helpful conversations and suggestions.
Reference: [Wag86] <author> K. Wagner. </author> <title> Some observations on the connection between counting and recursion. </title> <journal> Theoretical Computer Science, </journal> <volume> 47 </volume> <pages> 131-147, </pages> <year> 1986. </year>
Reference: [Wag97] <author> K. Wagner. </author> <title> A note on parallel queries and the difference hierarchy (draft). </title> <type> Manuscript, </type> <month> February 3, </month> <year> 1997. </year>
Reference-contexts: equal P NP [1]:#P [1] (indeed, even P #P [1] = P NP [O (log n)]:#P [1] ), the comments of the previous paragraph give some weak evidence that order of access may be important in determining computational power, a theme that has been raised and studied in other settings <ref> [HHW,HHH96,ABT96, Wag97] </ref>. Unfortunately, in the present setting, giving firm evidence for this seems hard.
Reference: [WT92] <author> O. Watanabe and S. </author> <title> Toda. Polynomial time 1-Turing reductions from #PH to #P. </title> <journal> Theoretical Computer Science, </journal> <volume> 100 </volume> <pages> 205-221, </pages> <year> 1992. </year> <month> 16 </month>
Reference-contexts: Similar claims hold for R #P m (C = P) and (with a bit of care) for R #P m (PP). Let us adopt Valiant's [Val79a] standard definition of #NP (informally, #NP = (#P) NP ), and the analogous definition of #PH (informally, #PH = (#P) PH ) <ref> [WT92] </ref>. 3 In this paper, we have discussed a number of "R #P m " closures of classes. One might naturally wonder whether the "R #NP m " closures of the classes yield even greater computational power. However, note that from Toda and Watanabe's [WT92] result #PH FP #P [1] we <p> (informally, #PH = (#P) PH ) <ref> [WT92] </ref>. 3 In this paper, we have discussed a number of "R #P m " closures of classes. One might naturally wonder whether the "R #NP m " closures of the classes yield even greater computational power. However, note that from Toda and Watanabe's [WT92] result #PH FP #P [1] we can easily prove the following proposition, which says that "R #NP m " closures (or even 3 Vollmer [Vol94] and Toda and Watanabe ([WT92], using the different notation "NUMC") have proposed interesting and different "#"-type classes. <p> Here, we uniformly use Valiant's classes, though we mention in passing that for #PH the two notions are known to coincide <ref> [WT92, Proposition 3.1] </ref>. 9 "R #PH m " closures) yield no greater computational power than "R #P m " closures. (We say C is closed downwards under p m reductions if R p m (C) C.) Proposition 3.2 For any complexity class C closed downwards under p m reductions, it holds <p> For the "" inclusion, let A 2 R #PH m (C) via f 2 #PH and C 2 C. Thus, x 2 A () string (f (x)) 2 C. Note that due to the inclusion #PH FP #P [1] <ref> [WT92] </ref>, we also have string (f ()) 2 FP #P [1] . Hence there exist a DPTM M and a function g 2 #P such that, for each x 2 fl , M g [1] (x) computes string (f (x)).
References-found: 44

