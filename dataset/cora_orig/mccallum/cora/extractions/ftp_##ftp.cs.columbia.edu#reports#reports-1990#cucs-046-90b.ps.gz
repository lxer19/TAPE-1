URL: ftp://ftp.cs.columbia.edu/reports/reports-1990/cucs-046-90b.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1990.html
Root-URL: http://www.cs.columbia.edu
Title: An Object-Based Programming Model for Shared Data  
Author: Gail E. Kaiser Brent Hailpern Gail E. Kaiser and Brent Hailpern 
Keyword: database, distributed system, financial application, programming language design, rapidly changing data, sharing  
Note: Copyright 1990  Hailpern's current address is  
Address: New York, NY 10027 Yorktown Heights, NY 10598  Orchard Road, Armonk, NY 10504.  
Affiliation: Columbia University IBM Research Division Department of Computer Science T.J. Watson Research Center  IBM, Old  
Email: kaiser@cs.columbia.edu bth@ibm.com  
Date: 21 December 1990  
Abstract: The classical object model supports private data within objects and clean interfaces between objects, and by definition does not permit sharing of data among arbitrary objects. This is a problem for real-world applications such as advanced financial services and integrated network management where the same data logically belongs to multiple objects and may be distributed over multiple nodes on the network. Rather than give up the advantages of encapsulated objects in modeling real-world entities, we propose a new object model that supports shared data in a distributed environment. The key is separating distribution of computation units from information hiding concerns. Minimal units of data and control, called facets, may be shared among multiple objects and are grouped into processes. Thus a single object, or information hiding unit, may be distributed among multiple processes, or computation units. In other words, different facets of the same object may reside in different address spaces on different machines. We introduce our new object model, describe a motivating example from the financial domain, and then explain facets, objects and processes, followed by timing and synchronization concerns. 
Abstract-found: 1
Intro-found: 1
Reference: [Agha 86] <author> Gul Agha. </author> <title> Actors A Model of Concurrent Computation in Distributed Systems. </title> <publisher> The MIT Press, </publisher> <address> Cambridge MA, </address> <year> 1986. </year>
Reference-contexts: The classical object model permits code and data definitions to be shared via inheritance, but not data values. Data values can be shared symmetrically but non-transparently, by encapsulating the shared data in a third object accessed through message passing <ref> [Agha 86] </ref>. Data can be shared asymmetrically by encapsulating it within one of the objects, which may access it transparently, but the only access available to other objects is through message passing; any sharing is by convention and outside the programming model.
Reference: [Bach 86] <author> Maurice J. Bach. </author> <title> The Design of the UNIX Operating System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs NJ, </address> <year> 1986. </year>
Reference-contexts: Figure 2-4 compares a very simple case involving only two instruments with all polling at the same frequency. We prefer a more sophisticated solution in which the shared prices are monitored by simple daemons <ref> [Bach 86] </ref>. Each daemon contains a trigger that informs the main-line strategy when something ``interesting'' happens. Active values and polling both employ two entities, one representing the prices and the other the portfolio manager. <p> The implementation of inter-facet communication is based on threads. There are many notions of thread, running a spectrum from light-weight as in Mach's raw threads [Rashid 87] to medium-weight as in Mach's C-thread package [Cooper 88] to heavy-weight as in a full Unix process <ref> [Bach 86] </ref>. The common concept is that a thread has a single locus of control. What distinguishes the variety of threads is the degrees of ownership of context (registers, stack), data resources (address space), computation resources (processor time) and communication resources (network bandwidth).
Reference: [Bacon 89] <author> David F. Bacon and Robert E. Strom. </author> <title> Implementing the Hermes Process Model. </title> <type> Technical Report RC 14518, </type> <institution> IBM T.J. Watson Research Center, </institution> <month> March, </month> <year> 1989. </year>
Reference-contexts: When an external call is made to a handler, a process is created within the guardian to service that call. The internal state can be shared among processes within a guardian, but cannot be shared among multiple guardians. Hermes <ref> [Bacon 89] </ref> is another language that provides both objects and processes. In Hermes, the process defines the external interface, in terms of typed ports; objects are encapsulated inside 33 processes and there is only one thread of control per process.
Reference: [Baker 87] <institution> T.P. Baker. </institution>
Reference-contexts: Explicit blocking in the sense of rendezvous is not acceptable in the context of timing constraints <ref> [Baker 87] </ref>. 31 8. Implementation Two subsets of PROFIT, called Asset and Bankrupt, have been implemented. Example stock trading programs written in the two dialects are given in appendices. Each uses a different syntax, as we intentionally avoided defining any particular syntax, and instead concentrated on the underlying programming model.
References-found: 4

