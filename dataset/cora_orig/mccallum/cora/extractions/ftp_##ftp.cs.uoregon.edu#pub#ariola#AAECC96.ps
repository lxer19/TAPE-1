URL: ftp://ftp.cs.uoregon.edu/pub/ariola/AAECC96.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Email: e-mail: ariola@cs.uoregon.edu  
Title: Relating Graph and Term Rewriting via Bohm Models  
Author: Zena M. Ariola 
Address: OR 97403-1202  
Affiliation: Computer Information Science Department University of Oregon, Eugene,  
Abstract: Dealing properly with sharing is important for expressing some of the common compiler optimizations as source-to-source transformations, such as common subexpressions elimination, lifting of free expressions and removal of invariants from a loop. Term graph rewriting is a computational model to accommodate these concerns. In this paper we are interested in defining a term model for term graph rewriting systems, which allows us to prove total correctness of those optimizations. We introduce the notion of Bohm tree, and show that for orthogonal term graph rewriting systems, Bohm tree equivalence defines a congruence. Total correctness then follows in a straightforward way from showing that if a program M contains less sharing than a program N , then both M and N have the same Bohm tree. Using Bohm trees we also show that orthogonal term graph rewriting systems are a correct implementation of orthogonal term rewriting systems. This boils down to showing that the behavior of a term graph can be deduced from its finite approximations, that is, graph rewriting is a continuous operation. Our approach differs from that of other researchers which is based on infinite rewriting. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Z. M. Ariola. </author> <title> An Algebraic Approach to the Compilation and Operational Semantics of Functional Languages with I-structures. </title> <type> PhD thesis, MIT Technical Report TR-544, </type> <year> 1992. </year>
Reference-contexts: In the next section we introduce the function BT which returns the Bohm tree of a TRS term. The function BT defines a congruence relation on the set of TRS terms, moreover, in <ref> [1] </ref> we have also shown that the interpretation function BT defines a stable model; that is, for any information, say a, of C [M ] there exists a minimum amount of information of M that is sufficient to derive a. 4.1. <p> Notice that a reduction of newly created redexes only is inside-out. Notation: given a term graph g and redex z occurring in g, we denote as n z the corresponding node in G (g), where G (g) is the graph associated to g (see <ref> [1] </ref>). Definition 4.19. (Ordering on Redexes) Given a term graph g and two distinct redexes z 1 ; z 2 occur Relating Graph and Term Rewriting via Bohm Models 24 ring in g.
Reference: 2. <author> Z. M. Ariola and Arvind. P-TAC: </author> <title> A parallel intermediate language. </title> <booktitle> In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> London, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: In fact, we have successfully described the operational semantics and the compilation of the implicitly parallel language Id [28] using two different graph rewriting systems, called Kid (Kernel Id) and P-TAC (Parallel Relating Graph and Term Rewriting via Bohm Models 2 Three Address Code) <ref> [2, 3, 4] </ref>, where P-TAC describes sharing in a first-order system, while Kid includes -abstraction. Term graph rewriting has been described in the literature in terms of either category theory notions [12, 13, 14, 15, 22, 27, 30] or more implementation oriented concepts [9, 11, 29, 32]. <p> A way of assuring that BT is a congruence is to show that the behavior of C [g] can be inferred from the observations about g, where C <ref> [2] </ref> is a context, as defined below. Definition 3.30. A context C [2] is a term graph defined over the signature extended with a special symbol 2. <p> A way of assuring that BT is a congruence is to show that the behavior of C [g] can be inferred from the observations about g, where C <ref> [2] </ref> is a context, as defined below. Definition 3.30. A context C [2] is a term graph defined over the signature extended with a special symbol 2. <p> We want to show the following: 8C <ref> [2] </ref>; C [g] BT fC [Bl (a)] j a 2 Print fl (g)g (1) where Print fl ( F S fPrint fl (s) j s 2 Sg, and Bl (a) represents the term graph obtained by assigning a unique name to each subterm of a. Definition 3.31. <p> Example 3.32. (i) Consider the following rule: fx = G (x 1 ); x 1 = A (x 1 )g ! fx = 1g : Let g fx 1 = A (x 1 ); in x 1 g and C <ref> [2] </ref> fx 1 = G (x 2 ); x 2 = 2; in x 1 g. Since C [g] ! 1, we would conclude that the answer of C [g] is f; 1g. <p> However, 1 can not be obtained by plugging in the context any observation about g. g is not a redex and its expansions are stable, thus the answer of g is f; A (); A (A ()); g. Let us insert in the context C <ref> [2] </ref> any of the above observations: the answer of C [] is because C [] is not a redex but can become a redex. The same applies if we plug any other observation of g in C [2]. <p> Let us insert in the context C <ref> [2] </ref> any of the above observations: the answer of C [] is because C [] is not a redex but can become a redex. The same applies if we plug any other observation of g in C [2]. <p> is , for any observation a of g. (ii) Consider the following rule: fx = G (x 1 ); x 1 = A (y; y)g ! fx = 1g : Let g fx = A (x 1 ; x 1 ); x 1 = B (0); in xg and C <ref> [2] </ref> fx 1 = G (x 2 ); x 2 = 2; in x 1 g. The answer of g is f; A (; ); ; A (B (0); B (0))g. <p> We have Bl (a) ! h C [Bl (a)] v BT C [h] (by the monotonicity of v BT with respect to ! (Lemma 3.33)) BT C [g] (by soundness of BT (Theorem 3.29)) : 2 In order to prove the other direction, that is, 8C <ref> [2] </ref>; C [g] v BT fC [Bl (a)] j a 2 Print fl (g)g we show: (i) if g !! h then the information associated to each expansion of h can be obtained by reducing an expansion of g; (ii) not too much information is lost by applying !-reductions.
Reference: 3. <author> Z. M. Ariola and Arvind. </author> <title> Compilation of Id. </title> <booktitle> In Proc. of the Fourth Worskshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Santa Clara, California, </address> <publisher> Springer-Verlag LNCS 589, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: In fact, we have successfully described the operational semantics and the compilation of the implicitly parallel language Id [28] using two different graph rewriting systems, called Kid (Kernel Id) and P-TAC (Parallel Relating Graph and Term Rewriting via Bohm Models 2 Three Address Code) <ref> [2, 3, 4] </ref>, where P-TAC describes sharing in a first-order system, while Kid includes -abstraction. Term graph rewriting has been described in the literature in terms of either category theory notions [12, 13, 14, 15, 22, 27, 30] or more implementation oriented concepts [9, 11, 29, 32].
Reference: 4. <author> Z. M. Ariola and Arvind. </author> <title> A syntactic approach to program transformations. </title> <booktitle> In Proc. ACM SIGPLAN Symposium on Partial Evaluation and Semantics Based Program Manipulation, </booktitle> <institution> Yale University, </institution> <address> New Haven, CT, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: In fact, we have successfully described the operational semantics and the compilation of the implicitly parallel language Id [28] using two different graph rewriting systems, called Kid (Kernel Id) and P-TAC (Parallel Relating Graph and Term Rewriting via Bohm Models 2 Three Address Code) <ref> [2, 3, 4] </ref>, where P-TAC describes sharing in a first-order system, while Kid includes -abstraction. Term graph rewriting has been described in the literature in terms of either category theory notions [12, 13, 14, 15, 22, 27, 30] or more implementation oriented concepts [9, 11, 29, 32].
Reference: 5. <author> Z. M. Ariola and Arvind. </author> <title> Graph rewriting systems for efficient compilation. </title> <editor> In M. R. Sleep, M. J. Plasmeijer, and M. C. D. J. van Eekelen, editors, </editor> <title> Term Graph Rewriting: </title> <journal> Theory and Practice, </journal> <pages> pages 77-90. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections. Both approaches, though of indisputable merit, fall short in providing a clear, mathematically manageable framework for term graph rewriting. We provide, instead, an equational treatment of term graph rewriting <ref> [5, 6, 8] </ref>, based on the observation that a natural way of linearly representing a graph is by associating a unique name to each node, and then writing down the interconnections through a set of recursion equations.
Reference: 6. <author> Z. M. Ariola and Arvind. </author> <title> Properties of a first-order functional language with sharing. </title> <journal> Theoretical Computer Science, </journal> <volume> 146, </volume> <year> 1995. </year>
Reference-contexts: The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections. Both approaches, though of indisputable merit, fall short in providing a clear, mathematically manageable framework for term graph rewriting. We provide, instead, an equational treatment of term graph rewriting <ref> [5, 6, 8] </ref>, based on the observation that a natural way of linearly representing a graph is by associating a unique name to each node, and then writing down the interconnections through a set of recursion equations. <p> Moreover, circular equations of the kind x = x are rewritten to x = *, where * is a new constant called `black hole'. As shown in <ref> [6, 8] </ref> this guarantees the confluence of term graph rewriting without overlapping rules. A term is said to be in canonical form if all the substitutions, the rewriting of circular equations, the flattening, and the removal of garbage have been performed. <p> Theorem 2.11. A term graph rewriting system without overlapping rules is confluent up to renaming. Proof. See <ref> [6, 8] </ref>. 2 Definition 2.12. (Orthogonal) A term (graph) rewriting system is said to be orthogonal if all the rules are left-linear and non-overlapping. Hereafter, we will only consider orthogonal term (graph) rewriting systems. Relating Graph and Term Rewriting via Bohm Models 7 3. <p> To cope with this phenomenon in the -calculus, both Wadsworth [33] and Levy [26] have introduced the notion of !-rule, which states P ! . Huet and Levy have applied the same concept to orthogonal TRSs [21], and in <ref> [6] </ref> we have extended the work to term graph rewriting systems without overlapping rules. According to [6], the stable part of a term graph is computed by replacing its redexes and "potential redexes" by , where a term is a "potential redex" if it can become a redex by either replacing <p> Huet and Levy have applied the same concept to orthogonal TRSs [21], and in <ref> [6] </ref> we have extended the work to term graph rewriting systems without overlapping rules. According to [6], the stable part of a term graph is computed by replacing its redexes and "potential redexes" by , where a term is a "potential redex" if it can become a redex by either replacing with some other term or by increasing its sharing. <p> While, with respect to the above rules, g 1 fx = F (x); in xg is considered to be stable. Thus, in <ref> [6] </ref> sharing is part of our observations. <p> fx = cons (x 1 ; x); x 1 = 1; in xg h 1 fx = F (x 1 ); x 1 = 1; in xg and the rule fx = F (y)g ! fx = cons (y; x 1 ); x 1 = F (y)g : According to <ref> [6] </ref>, the information associated to h 1 is contained in the information associated to g 1 , but not vice versa. <p> Instead, following <ref> [6] </ref> we would have concluded that the answer of g 1 is f; cons (; ); cons (1; ); ; fx = cons (1; x); in xgg : While the answer of h 1 is the same as above. <p> R [ R 1 is an orthogonal term graph rewriting system and thus is subcommutative <ref> [8, 6] </ref>. Let Bl (M ) !! R 1 Bl (N ) and Bl (M ) !! R g. We want to show that each information contained in g is obtained by reducting Bl (N ). <p> Suppose C [g] !! h, we want to show that each information about h, say a, can be obtained by plugging in the context some observation about g. Due to the subcommutativity of a term graph rewriting system <ref> [6] </ref> we first reorder the reduction C [g] !! h, in a way consisting of first reducing all redexes inside g and then reducing the redexes in the context; that is, %! Relating Graph and Term Rewriting via Bohm Models 18 where C [g 0 ] %! g 0 h means <p> Let A fl 1 be the reduction g ! z i 1 be the projection of A with respect to A fl 1 , which is well-defined due to the subcommutative property of term graph rewriting systems. Due to the non-duplicative property of term graph rewriting systems <ref> [6] </ref>, we have that the length of the reduction A n A fl 1 is less than the length of A; therefore, there exists an inside-out reduction, called A fl 2 , of A n A fl 1 .
Reference: 7. <author> Z. M. Ariola, C. Braun, and J. W. Klop. </author> <title> A graph rewriting system to express state and sequentialization in a parallel setting. </title> <booktitle> In Proc. 5th International Workshop on Graph Grammars and their Application to Computer Science, </booktitle> <address> Williamsburg, Virgina, </address> <year> 1994. </year>
Reference-contexts: We thus define the canonical form of a term graph g as follows: (i) compute the normal form of g, say g 1 , with respect to the Flattening rule; y As discussed in <ref> [7] </ref> disallowing garbage collection makes term graph rewriting suitable to describe a notion of state.
Reference: 8. <author> Z. M. Ariola and J. W. Klop. </author> <title> Equational term graph rewriting. </title> <note> To appear in Fundamenta Informaticae. Extended version: CWI Report CS-R9552. </note> <year> 1995. </year>
Reference-contexts: The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections. Both approaches, though of indisputable merit, fall short in providing a clear, mathematically manageable framework for term graph rewriting. We provide, instead, an equational treatment of term graph rewriting <ref> [5, 6, 8] </ref>, based on the observation that a natural way of linearly representing a graph is by associating a unique name to each node, and then writing down the interconnections through a set of recursion equations. <p> The advantage of this approach, as discussed in <ref> [8] </ref>, is that one can use the intuitions of Equational Logic in manipulating these equations. Our treatment of term graph rewriting is very general in that cyclic graphs are admitted; most of the literature on graph rewriting is still concerned with directed acyclic graphs only [31]. <p> E.g., fx : F (x; y); y : G (x)g in the language DACTL [18]. However, we insist on an equational notation, not just for the sake of style, but because we want to express term graph operations in terms of equational transformations <ref> [8] </ref>. Definition 2.1. (Term graph) Let be a first-order signature. <p> Moreover, circular equations of the kind x = x are rewritten to x = *, where * is a new constant called `black hole'. As shown in <ref> [6, 8] </ref> this guarantees the confluence of term graph rewriting without overlapping rules. A term is said to be in canonical form if all the substitutions, the rewriting of circular equations, the flattening, and the removal of garbage have been performed. <p> Theorem 2.11. A term graph rewriting system without overlapping rules is confluent up to renaming. Proof. See <ref> [6, 8] </ref>. 2 Definition 2.12. (Orthogonal) A term (graph) rewriting system is said to be orthogonal if all the rules are left-linear and non-overlapping. Hereafter, we will only consider orthogonal term (graph) rewriting systems. Relating Graph and Term Rewriting via Bohm Models 7 3. <p> Intuitively, g ! h if h can be obtained from g by replacing with any other term or by increasing the sharing in g. The !-ordering captures what in the literature is known as rooted homomorphism <ref> [8, 11, 32] </ref>. For example, we have We will then show that if g ! h then Print (g) Print (h). In the following, Fv (g) and Bv (g) denote the free and bound variables of g, respectively. <p> Herein we assume * = ! . Relating Graph and Term Rewriting via Bohm Models 13 Proposition 3.23. The !-ordering is a partial order. Proof. See <ref> [8] </ref>. 2 Proposition 3.24. Let z be a bound variable of g. If g j z is not a redex and g j z ! h, with h a redex, then Print (g) = Print (g [z ]). Proof. <p> R [ R 1 is an orthogonal term graph rewriting system and thus is subcommutative <ref> [8, 6] </ref>. Let Bl (M ) !! R 1 Bl (N ) and Bl (M ) !! R g. We want to show that each information contained in g is obtained by reducting Bl (N ).
Reference: 9. <author> H. Barendregt, T. Brus, M. van Eekelen, J. Glauert, J. Kennaway, M. van Leer, M. Plasmeijer, and M. R. Sleep. </author> <title> Towards an intermediate language based on graph rewriting. </title> <booktitle> In Proc. Conference on Parallel Architecture and Languages Europe (PARLE '87), </booktitle> <address> Eindhoven, The Netherlands, </address> <publisher> Springer-Verlag LNCS 259, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Term graph rewriting has been described in the literature in terms of either category theory notions [12, 13, 14, 15, 22, 27, 30] or more implementation oriented concepts <ref> [9, 11, 29, 32] </ref>. The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections. Both approaches, though of indisputable merit, fall short in providing a clear, mathematically manageable framework for term graph rewriting.
Reference: 10. <author> H. P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: In Section 3, we introduce a function Print which given a term graph g returns the stable information associated with g. The information gathered by reducing g is then collected in a set called Print fl (g). Print fl (g) represents the answer or Bohm tree <ref> [10] </ref> computed by g. We take the answer as our criterion for equating terms, and we show that this equality is a congruence for a subclass of term graph rewriting systems, namely those without overlapping and non-left-linear rules (i.e., orthogonal term graph rewriting systems). <p> We automatically perform the removal of the equation x 1 = F (x) (garbage collection) y . Analogous to the notion of ff-equivalence in -calculus <ref> [10] </ref>, term graphs whose difference may be regarded as merely syntactic noise, are equated. <p> ohm Domain: !-T rees 1 ) The domain of observations, called !-T rees 1 , is the ideal completion of !-T rees, that is, !-T rees 1 = fS j S !-T rees and S is an ideal g : The elements of !-T rees 1 are called Bohm trees <ref> [10] </ref>. Definition 3.18. (Printable Value of a Term Graph) Given a term graph g, the printable value of g is Print (g) = fa j a 2 !-T rees; a t b; b 2 f!(g k ) j k 0gg: Proposition 3.19.
Reference: 11. <author> H. P. Barendregt, M. C. J. D. van Eekelen, J. R. W. Glauert, J. R. Kennaway, M. J. Plasmeijer, and M. R. Sleep. </author> <title> Term graph rewriting. </title> <editor> In J. W. de Bakker, A. J. Nijman, and P. C. Treleaven, editors, </editor> <booktitle> Proc. Conference on Parallel Architecture and Languages Europe (PARLE '87), </booktitle> <address> Eindhoven, The Netherlands, </address> <publisher> Springer-Verlag LNCS 259, </publisher> <pages> pages 141-158, </pages> <year> 1987. </year>
Reference-contexts: Term graph rewriting has been described in the literature in terms of either category theory notions [12, 13, 14, 15, 22, 27, 30] or more implementation oriented concepts <ref> [9, 11, 29, 32] </ref>. The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections. Both approaches, though of indisputable merit, fall short in providing a clear, mathematically manageable framework for term graph rewriting. <p> The correctness of graph rewriting with respect to term rewriting is also explored in <ref> [11] </ref>, where the relation is based on the notion of normal form, which leads to some undesirable conclusions when cyclic term graphs are admitted, namely that graph rewriting is unsound. We believe that the notion of normal form is inadequate for such a comparison. <p> Finally, using the notion of Bohm tree, in Section 4, we show that orthogonal term graph rewriting systems are a correct implementation of orthogonal term rewriting systems (same conditions apply: non-overlapping and left-linear rules only). The notion of Bohm tree allows us to consider cyclic graphs, differently from <ref> [11] </ref>. Using term graph rewriting we also show the classical fact of completeness of inside-out reduction for orthogonal term rewriting systems (TRSs). This result is needed to provide a term model for TRSs. We conclude the paper with our thoughts on future work. 2. <p> Herein term graphs are assumed to be in canonical form. Term graph rewriting rules have also an equational format, differently from <ref> [11, 29, 32] </ref>, in which rules are expressed in terms of multi-rooted graphs. <p> Intuitively, g ! h if h can be obtained from g by replacing with any other term or by increasing the sharing in g. The !-ordering captures what in the literature is known as rooted homomorphism <ref> [8, 11, 32] </ref>. For example, we have We will then show that if g ! h then Print (g) Print (h). In the following, Fv (g) and Bv (g) denote the free and bound variables of g, respectively.
Reference: 12. <author> H. Ehrig. </author> <title> Introduction to the algebraic theory of graph grammars. </title> <booktitle> In Proc. 1st International Workshop on Graph Grammars and their Application to Computer Science, </booktitle> <publisher> Springer-Verlag LNCS 73, </publisher> <pages> pages 1-69, </pages> <year> 1989. </year>
Reference-contexts: Term graph rewriting has been described in the literature in terms of either category theory notions <ref> [12, 13, 14, 15, 22, 27, 30] </ref> or more implementation oriented concepts [9, 11, 29, 32]. The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections.
Reference: 13. <editor> H. Ehrig, M. Nagl, and G. Rozenberg, editors. </editor> <booktitle> Proc. 2nd International Workshop on Graph Grammars and their Application to Computer Science, </booktitle> <address> Haus Ohrbeck, Germany, </address> <publisher> Springer-Verlag LNCS 153. </publisher> <year> 1983. </year>
Reference-contexts: Term graph rewriting has been described in the literature in terms of either category theory notions <ref> [12, 13, 14, 15, 22, 27, 30] </ref> or more implementation oriented concepts [9, 11, 29, 32]. The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections.
Reference: 14. <editor> H. Ehrig, M. Nagl, G. Rozenberg, and A. Rosenfeld, editors. </editor> <booktitle> 3nd International Workshop on Graph Grammars and their Application to Computer Science, </booktitle> <address> Warrenton, Virginia, </address> <publisher> USA Springer-Verlag LNCS 291. </publisher> <year> 1987. </year>
Reference-contexts: Term graph rewriting has been described in the literature in terms of either category theory notions <ref> [12, 13, 14, 15, 22, 27, 30] </ref> or more implementation oriented concepts [9, 11, 29, 32]. The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections.
Reference: 15. <editor> H. Ehrig, M. Nagl, G. Rozenberg, and A. Rosenfeld, editors. </editor> <booktitle> Proc. 4th International Workshop on Graph Grammars and their Application to Computer Science, </booktitle> <address> Bremen, Germany, </address> <publisher> Springer-Verlag LNCS 532. </publisher> <year> 1991. </year> <title> Relating Graph and Term Rewriting via Bohm Models 27 </title>
Reference-contexts: Term graph rewriting has been described in the literature in terms of either category theory notions <ref> [12, 13, 14, 15, 22, 27, 30] </ref> or more implementation oriented concepts [9, 11, 29, 32]. The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections.
Reference: 16. <author> W. M. Farmer. </author> <title> A correctness proof for combinator reduction with cycles. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 123-134, </pages> <year> 1990. </year>
Reference-contexts: Similar notations appear in the literature <ref> [16, 18] </ref>. E.g., fx : F (x; y); y : G (x)g in the language DACTL [18]. However, we insist on an equational notation, not just for the sake of style, but because we want to express term graph operations in terms of equational transformations [8].
Reference: 17. <author> W. M. Farmer and R. J. Watro. </author> <title> Redex capturing in term graph rewriting. </title> <editor> In R. V. Book, editor, </editor> <booktitle> Proc. 4th International Conference on Rewriting Techniques and Applications (RTA-91), </booktitle> <address> Como, Italy, </address> <publisher> Springer-Verlag LNCS 488, </publisher> <pages> pages 13-24, </pages> <year> 1991. </year>
Reference-contexts: We believe that the notion of normal form is inadequate for such a comparison. This point was already stressed by Wadsworth in his analysis of the relation between the syntactic and the semantic aspects of the -calculus [34, 35]. Other researchers <ref> [17, 23, 24] </ref> have based the relation on rewriting of infinite terms. Instead, our approach is based on showing that the behavior of a graph can be deduced from its finite approximations. In other words, we show that graph rewriting is a continuous operation.
Reference: 18. <author> J. R. W. Glauert, J. R. Kennaway, and M. R. Sleep. Dactl: </author> <title> An experimental graph rewriting language. </title> <booktitle> In Proc. 4th International Workshop on Graph Grammars and their Application to Computer Science, </booktitle> <address> Bremen, Germany, </address> <publisher> Springer-Verlag LNCS 532, </publisher> <pages> pages 378-395, </pages> <year> 1990. </year>
Reference-contexts: Similar notations appear in the literature <ref> [16, 18] </ref>. E.g., fx : F (x; y); y : G (x)g in the language DACTL [18]. However, we insist on an equational notation, not just for the sake of style, but because we want to express term graph operations in terms of equational transformations [8]. <p> Similar notations appear in the literature [16, 18]. E.g., fx : F (x; y); y : G (x)g in the language DACTL <ref> [18] </ref>. However, we insist on an equational notation, not just for the sake of style, but because we want to express term graph operations in terms of equational transformations [8]. Definition 2.1. (Term graph) Let be a first-order signature.
Reference: 19. <author> M. Hennessy. </author> <title> Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: of Observations) The set of all observations is !-T rees = f!(g k ) j for all term graphs g; k 0g: In order to guarantee that infinite chains in !-T rees have a limit, we apply the ideal completion method to turn !-T rees into a complete partial order <ref> [19] </ref>.
Reference: 20. <author> P. Hudak, S. Peyton Jones, P. Wadler, B. Boutel, J. Fairbairn, J. Fasel, K. Hammond, J. Hughes, T. Johnsson, D. Kieburtz, R. Nikhil, W. Partain, and J. Peterson. </author> <title> Report on the programming language Haskell. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5) </volume> <pages> 1-64, </pages> <year> 1992. </year>
Reference-contexts: The motivation for this work came from a desire to formalize the operational semantics of languages such as Id [28] and pH (a parallel variant of Haskell <ref> [20] </ref>).
Reference: 21. <author> G. Huet and J.-J. Levy. </author> <title> Computations in orthogonal rewriting systems 1 and 2. </title> <booktitle> In Computational logic. Essays in Honor of Alan Robinson. </booktitle> <editor> Ed. J.-L. Lassez & G.D. Plotkin, </editor> <year> 1991. </year>
Reference-contexts: To cope with this phenomenon in the -calculus, both Wadsworth [33] and Levy [26] have introduced the notion of !-rule, which states P ! . Huet and Levy have applied the same concept to orthogonal TRSs <ref> [21] </ref>, and in [6] we have extended the work to term graph rewriting systems without overlapping rules.
Reference: 22. <author> J. R. Kennaway. </author> <title> On graph rewriting. </title> <journal> Theoretical Computer Science, </journal> <volume> 52 </volume> <pages> 37-58, </pages> <year> 1987. </year>
Reference-contexts: Term graph rewriting has been described in the literature in terms of either category theory notions <ref> [12, 13, 14, 15, 22, 27, 30] </ref> or more implementation oriented concepts [9, 11, 29, 32]. The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections.
Reference: 23. <author> J. R. Kennaway, J. W. Klop, M. R. Sleep, and F. J. de Vries. </author> <title> The adequacy of term graph rewriting for simulating term rewriting. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 493-523, </pages> <year> 1994. </year>
Reference-contexts: We believe that the notion of normal form is inadequate for such a comparison. This point was already stressed by Wadsworth in his analysis of the relation between the syntactic and the semantic aspects of the -calculus [34, 35]. Other researchers <ref> [17, 23, 24] </ref> have based the relation on rewriting of infinite terms. Instead, our approach is based on showing that the behavior of a graph can be deduced from its finite approximations. In other words, we show that graph rewriting is a continuous operation.
Reference: 24. <author> J. R. Kennaway, J. W. Klop, M. R. Sleep, and F. J. de Vries. </author> <title> Transfinite reductions in orthogonal term rewriting systems. </title> <journal> Information and Computation, </journal> <volume> 119(1), </volume> <year> 1995. </year>
Reference-contexts: We believe that the notion of normal form is inadequate for such a comparison. This point was already stressed by Wadsworth in his analysis of the relation between the syntactic and the semantic aspects of the -calculus [34, 35]. Other researchers <ref> [17, 23, 24] </ref> have based the relation on rewriting of infinite terms. Instead, our approach is based on showing that the behavior of a graph can be deduced from its finite approximations. In other words, we show that graph rewriting is a continuous operation.
Reference: 25. <author> J. W. Klop. </author> <title> Term rewriting systems. </title> <editor> In S. Abramsky, D. Gabbay, and T. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume II, </volume> <pages> pages 1-116. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: R exp (g) is an orthogonal TRS. As described in the previous example we rewrite the root of a term graph g according to R exp (g) following the Gross-Knuth or Kleene reduction strategy <ref> [25] </ref>. Notation: M !! GK n N denotes n (TRS) reduction steps according to the Gross-Knuth strategy. In the following definition, N is computed with respect to the expansion rules.
Reference: 26. <author> J.-J. Levy. </author> <title> Reductions Correctes et Optimales dans le Lambda-Calcul. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <month> October </month> <year> 1978. </year>
Reference-contexts: The printable value corresponds to the notions of instant semantics [36] and direct approximation <ref> [26, 33] </ref> introduced for the -calculus. As for the -calculus, all redexes must first be substituted by a new constant , which stands for no information. However, this is not enough to guarantee the monotonicity of the information content with respect to reduction. <p> The problem is due to the upward creation of redexes; that is, even though a term M is not a redex, it can become so when some redexes under it are performed. To cope with this phenomenon in the -calculus, both Wadsworth [33] and Levy <ref> [26] </ref> have introduced the notion of !-rule, which states P ! . Huet and Levy have applied the same concept to orthogonal TRSs [21], and in [6] we have extended the work to term graph rewriting systems without overlapping rules. <p> In order to determine if an expansion is stable we associate to a term graph rule a set of TRS rules, called !-rules as in <ref> [26, 33] </ref>. The aim of a !-rule is to reduce to potential redexes. Relating Graph and Term Rewriting via Bohm Models 10 Definition 3.9. (Unwinding) Let g be an acyclic term graph rooted at x, with fy 1 ; ; y k g the set of its free variables.
Reference: 27. <author> M. Lowe. </author> <title> Algebraic approach to single pushout graph transformation. </title> <journal> Theoretical Computer Science, </journal> <volume> 109 </volume> <pages> 181-224, </pages> <year> 1993. </year>
Reference-contexts: Term graph rewriting has been described in the literature in terms of either category theory notions <ref> [12, 13, 14, 15, 22, 27, 30] </ref> or more implementation oriented concepts [9, 11, 29, 32]. The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections.
Reference: 28. <author> R. S. Nikhil. </author> <title> Id (Version 90.1) Reference Manual. </title> <type> Technical Report CSG Memo 284-2, </type> <institution> MIT Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, MA 02139, USA, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Moreover, due to its implicit parallelism it is also suitable as an intermediate language for compilation on parallel machines. In fact, we have successfully described the operational semantics and the compilation of the implicitly parallel language Id <ref> [28] </ref> using two different graph rewriting systems, called Kid (Kernel Id) and P-TAC (Parallel Relating Graph and Term Rewriting via Bohm Models 2 Three Address Code) [2, 3, 4], where P-TAC describes sharing in a first-order system, while Kid includes -abstraction. <p> The motivation for this work came from a desire to formalize the operational semantics of languages such as Id <ref> [28] </ref> and pH (a parallel variant of Haskell [20]).
Reference: 29. <author> M. J. Plasmeijer and M. C. J. D. van Eekelen. </author> <title> Functional Programming and Parallel Graph Rewriting. </title> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Term graph rewriting has been described in the literature in terms of either category theory notions [12, 13, 14, 15, 22, 27, 30] or more implementation oriented concepts <ref> [9, 11, 29, 32] </ref>. The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections. Both approaches, though of indisputable merit, fall short in providing a clear, mathematically manageable framework for term graph rewriting. <p> Herein term graphs are assumed to be in canonical form. Term graph rewriting rules have also an equational format, differently from <ref> [11, 29, 32] </ref>, in which rules are expressed in terms of multi-rooted graphs.
Reference: 30. <author> J. C. Raoult. </author> <title> On graph rewritings. </title> <journal> Theoretical Computer Science, </journal> <volume> 32 </volume> <pages> 1-24, </pages> <year> 1984. </year>
Reference-contexts: Term graph rewriting has been described in the literature in terms of either category theory notions <ref> [12, 13, 14, 15, 22, 27, 30] </ref> or more implementation oriented concepts [9, 11, 29, 32]. The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections.
Reference: 31. <author> M. R. Sleep, M. J. Plasmeijer, and M. C. D. J. van Eekelen, </author> <title> editors. Term Graph Rewriting: Theory and Practice. </title> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: Our treatment of term graph rewriting is very general in that cyclic graphs are admitted; most of the literature on graph rewriting is still concerned with directed acyclic graphs only <ref> [31] </ref>. This paper develops a semantics for orthogonal (cyclic) term graph rewriting, which can be used to show total correctness of the above mentioned compiler optimizations, and to prove that term graph rewriting is a correct implementation of term rewriting.
Reference: 32. <author> J. E. W. Smetsers. </author> <title> Graph Rewriting and Functional Languages. </title> <type> PhD thesis, </type> <institution> University of Nijmegen, </institution> <year> 1993. </year>
Reference-contexts: Term graph rewriting has been described in the literature in terms of either category theory notions [12, 13, 14, 15, 22, 27, 30] or more implementation oriented concepts <ref> [9, 11, 29, 32] </ref>. The first describes graph rewriting steps as single or double push-outs. The second uses notions like pointers, redirection, indirections. Both approaches, though of indisputable merit, fall short in providing a clear, mathematically manageable framework for term graph rewriting. <p> Herein term graphs are assumed to be in canonical form. Term graph rewriting rules have also an equational format, differently from <ref> [11, 29, 32] </ref>, in which rules are expressed in terms of multi-rooted graphs. <p> Intuitively, g ! h if h can be obtained from g by replacing with any other term or by increasing the sharing in g. The !-ordering captures what in the literature is known as rooted homomorphism <ref> [8, 11, 32] </ref>. For example, we have We will then show that if g ! h then Print (g) Print (h). In the following, Fv (g) and Bv (g) denote the free and bound variables of g, respectively.
Reference: 33. <author> C. Wadsworth. </author> <title> Semantics and Pragmatics of the Lambda-Calculus. 1971. </title> <type> PhD thesis, </type> <institution> University of Oxford. </institution>
Reference-contexts: The printable value corresponds to the notions of instant semantics [36] and direct approximation <ref> [26, 33] </ref> introduced for the -calculus. As for the -calculus, all redexes must first be substituted by a new constant , which stands for no information. However, this is not enough to guarantee the monotonicity of the information content with respect to reduction. <p> The problem is due to the upward creation of redexes; that is, even though a term M is not a redex, it can become so when some redexes under it are performed. To cope with this phenomenon in the -calculus, both Wadsworth <ref> [33] </ref> and Levy [26] have introduced the notion of !-rule, which states P ! . Huet and Levy have applied the same concept to orthogonal TRSs [21], and in [6] we have extended the work to term graph rewriting systems without overlapping rules. <p> In order to determine if an expansion is stable we associate to a term graph rule a set of TRS rules, called !-rules as in <ref> [26, 33] </ref>. The aim of a !-rule is to reduce to potential redexes. Relating Graph and Term Rewriting via Bohm Models 10 Definition 3.9. (Unwinding) Let g be an acyclic term graph rooted at x, with fy 1 ; ; y k g the set of its free variables.
Reference: 34. <author> C. Wadsworth. </author> <title> The relation between computational and denotational properties for scott's d 1 -models of the lambda-calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 5, </volume> <year> 1976. </year>
Reference-contexts: We believe that the notion of normal form is inadequate for such a comparison. This point was already stressed by Wadsworth in his analysis of the relation between the syntactic and the semantic aspects of the -calculus <ref> [34, 35] </ref>. Other researchers [17, 23, 24] have based the relation on rewriting of infinite terms. Instead, our approach is based on showing that the behavior of a graph can be deduced from its finite approximations. In other words, we show that graph rewriting is a continuous operation.
Reference: 35. <author> C. Wadsworth. </author> <title> Approximate reduction and lambda calculus models. </title> <journal> Theoretical Computer Science, </journal> <volume> 7, </volume> <year> 1978. </year> <title> Relating Graph and Term Rewriting via Bohm Models 28 </title>
Reference-contexts: We believe that the notion of normal form is inadequate for such a comparison. This point was already stressed by Wadsworth in his analysis of the relation between the syntactic and the semantic aspects of the -calculus <ref> [34, 35] </ref>. Other researchers [17, 23, 24] have based the relation on rewriting of infinite terms. Instead, our approach is based on showing that the behavior of a graph can be deduced from its finite approximations. In other words, we show that graph rewriting is a continuous operation.
Reference: 36. <author> P. Welch. </author> <title> Continuous semantics and inside-out reductions. In -Calculus and Computer Science Theory, </title> <publisher> Italy (Springer-Verlag LNCS 37), </publisher> <month> March </month> <year> 1975. </year>
Reference-contexts: Bohm Model for Orthogonal term graph rewriting systems We want to define the printable value of a term graph g as the stable part of g, that is, that part that will never change during reduction. The printable value corresponds to the notions of instant semantics <ref> [36] </ref> and direct approximation [26, 33] introduced for the -calculus. As for the -calculus, all redexes must first be substituted by a new constant , which stands for no information. However, this is not enough to guarantee the monotonicity of the information content with respect to reduction.
References-found: 36

