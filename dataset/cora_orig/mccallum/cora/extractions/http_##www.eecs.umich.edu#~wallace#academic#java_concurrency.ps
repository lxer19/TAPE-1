URL: http://www.eecs.umich.edu/~wallace/academic/java_concurrency.ps
Refering-URL: http://www.eecs.umich.edu/~wallace/academic/
Root-URL: http://www.eecs.umich.edu
Email: gurevich@microsoft.com  wallace@eecs.umich.edu  
Title: An ASM specification of Java concurrency  
Author: Yuri Gurevich Charles Wallace 
Date: February 8, 1999  
Address: Redmond, WA 98052-6399  Ann Arbor, MI 48109-2122  
Affiliation: Microsoft Research  EECS, University of Michigan  
Abstract: We present a mathematically precise, platform-independent model of Java concurrency using the Abstract State Machine methodology. We cover all aspects of Java threads and synchronization, in a series of steps which gradually add details to the model. At each step, we point out subtleties and ambiguities. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> E. Borger (editor). </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference: [2] <author> E. Borger. </author> <title> Why use Evolving Algebras for hardware and software engineering? In Proceedings of SOF-SEM, </title> <year> 1995. </year>
Reference: [3] <author> E. Borger and W. Schulte. </author> <title> A programmer friendly modular definition of the semantics of Java. </title> <editor> In J. Alves-Foss, editor, </editor> <title> Formal Syntax and Semantics of Java. </title> <publisher> Springer, </publisher> <year> 1998. </year>
Reference-contexts: We find our imperative approach helpful in uncovering hidden assumptions and ambiguities in the JLS, and in highlighting implementation issues. There are several formalizations of Java in the literature. <ref> [3] </ref> gives a semantic analysis of Java that results in exposing a hierarchy of natural sublanguages of Java. [3] has been used in [4] to analyze the correctness of the translation from Java to Java Virtual Machine bytecode. [3] takes static semantics for granted and restricts itself to the sequential fragment <p> We find our imperative approach helpful in uncovering hidden assumptions and ambiguities in the JLS, and in highlighting implementation issues. There are several formalizations of Java in the literature. <ref> [3] </ref> gives a semantic analysis of Java that results in exposing a hierarchy of natural sublanguages of Java. [3] has been used in [4] to analyze the correctness of the translation from Java to Java Virtual Machine bytecode. [3] takes static semantics for granted and restricts itself to the sequential fragment of Java. [24] gives static and dynamic semantics of full Java, using Montages ([15, 17]); this paper can <p> There are several formalizations of Java in the literature. <ref> [3] </ref> gives a semantic analysis of Java that results in exposing a hierarchy of natural sublanguages of Java. [3] has been used in [4] to analyze the correctness of the translation from Java to Java Virtual Machine bytecode. [3] takes static semantics for granted and restricts itself to the sequential fragment of Java. [24] gives static and dynamic semantics of full Java, using Montages ([15, 17]); this paper can be viewed as an elaboration of the portion of [24] devoted to Java concurrency.
Reference: [4] <author> E. Borger and W. Schulte. </author> <title> Defining the Java Virtual Machine as platform for provably correct Java compilation. </title> <editor> In L. Brim, J. Gruska, and J. Zlatuska, editors, </editor> <booktitle> Mathematical Foundations of Computer Science 1998. </booktitle> <publisher> Springer, </publisher> <year> 1998. </year>
Reference-contexts: There are several formalizations of Java in the literature. [3] gives a semantic analysis of Java that results in exposing a hierarchy of natural sublanguages of Java. [3] has been used in <ref> [4] </ref> to analyze the correctness of the translation from Java to Java Virtual Machine bytecode. [3] takes static semantics for granted and restricts itself to the sequential fragment of Java. [24] gives static and dynamic semantics of full Java, using Montages ([15, 17]); this paper can be viewed as an elaboration
Reference: [5] <author> P. Cenciarelli, A. Knapp, B. Reus, and M. Wirsing. </author> <title> &gt;From sequential to multi-threaded Java: An event-based operational semantics. </title> <editor> In M. Johnson, editor, </editor> <booktitle> Algebraic Methodology and Software Technology, </booktitle> <pages> pages 75-90. </pages> <publisher> Springer, </publisher> <year> 1997. </year>
Reference-contexts: Other formal models of (fragments of) Java include [6] and <ref> [5] </ref>. [6] has been used to prove type safety properties of the language; it also focuses on the sequential fragment of Java. Like this paper, [5] focuses on concurrency, but leaves out some aspects, e.g., volatile variables, prescient store actions, and Thread and ThreadGroup methods. <p> Other formal models of (fragments of) Java include [6] and <ref> [5] </ref>. [6] has been used to prove type safety properties of the language; it also focuses on the sequential fragment of Java. Like this paper, [5] focuses on concurrency, but leaves out some aspects, e.g., volatile variables, prescient store actions, and Thread and ThreadGroup methods. It is based on the Structural Operational Semantics (SOS) methodology ([19]) and is given in a declarative style, in keeping with the presentation in the JLS.
Reference: [6] <author> S. Drossopoulou and S. Eisenbach. </author> <title> Java is type safe probably. </title> <booktitle> In Proceedings of ECOOP, </booktitle> <pages> pages 389-418. </pages> <publisher> Springer, </publisher> <year> 1997. </year>
Reference-contexts: Other formal models of (fragments of) Java include <ref> [6] </ref> and [5]. [6] has been used to prove type safety properties of the language; it also focuses on the sequential fragment of Java. Like this paper, [5] focuses on concurrency, but leaves out some aspects, e.g., volatile variables, prescient store actions, and Thread and ThreadGroup methods. <p> Other formal models of (fragments of) Java include <ref> [6] </ref> and [5]. [6] has been used to prove type safety properties of the language; it also focuses on the sequential fragment of Java. Like this paper, [5] focuses on concurrency, but leaves out some aspects, e.g., volatile variables, prescient store actions, and Thread and ThreadGroup methods.
Reference: [7] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: The increasing popularity of Java and, more importantly, its emphasis on cross-platform compatibility ([8]) make the need for such a specification even stronger. We present a model of the concurrent features of Java, using the Abstract State Machine (ASM) 1 methodology ([10, 21, 22]). We use <ref> [7] </ref>, the Java Language Specification manual (JLS), as our reference for the language. The JLS is an informal specification, and due to the ambiguity which pervades natural language, it can be interpreted in different ways. Our model gives an unambiguous specification which reflects our interpretation of the JLS.
Reference: [8] <author> J. Gosling and H. McGilton. </author> <title> The Java Language Environment: </title> <note> A White Paper. Available at [13], </note> <year> 1996. </year>
Reference: [9] <author> Y. Gurevich. </author> <title> Evolving Algebras: an attempt to discover semantics. </title> <editor> In G. Rozenberg and A. Saloma, editors, </editor> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <pages> pages 266-292. </pages> <publisher> World Scientific, </publisher> <year> 1993. </year>
Reference: [10] <author> Y. Gurevich. </author> <title> Evolving Algebras 1993: Lipari guide. </title> <booktitle> In [1], </booktitle> <pages> pages 9-36. </pages>
Reference-contexts: In x5, we introduce locks, which are used to limit concurrency within a program, and in x6, we cover the related notions of waiting and notification. In x7 we discuss prescient store actions. A brief description of ASMs appears in xA; for a more comprehensive treatment, see <ref> [10, 11] </ref>. In xB we define our ASM models of Java concurrency. 2 Threads and variables In a single-threaded computation, a single agent executes the instructions of a program, one at a time.
Reference: [11] <author> Y. Gurevich. </author> <note> May 1997 draft of the ASM guide. Available at [21], </note> <year> 1997. </year>
Reference-contexts: In x5, we introduce locks, which are used to limit concurrency within a program, and in x6, we cover the related notions of waiting and notification. In x7 we discuss prescient store actions. A brief description of ASMs appears in xA; for a more comprehensive treatment, see <ref> [10, 11] </ref>. In xB we define our ASM models of Java concurrency. 2 Threads and variables In a single-threaded computation, a single agent executes the instructions of a program, one at a time.
Reference: [12] <author> C. Horstmann and G. Cornell. </author> <title> Core Java 1.1, volume II: Advanced Features. </title> <publisher> Sun Microsystems Press, </publisher> <year> 1998. </year>
Reference-contexts: It is not stated explicitly in the JLS what happens if start is invoked upon a thread that is already alive. However, the intent seems to be that the invoker of start throws an exception and nothing happens to the invokee (e.g., see <ref> [12] </ref>). The JLS rules impose some obligations on threads which they may not be able to fulfill after they have stopped. By Rules 2.1 and 2.3 (following the strict interpretation of "uniquely paired"), every access message must be loaded in.
Reference: [13] <institution> Sun Microsystems. Java technology home page. </institution> <note> http://java.sun.com/. </note>
Reference: [14] <author> A. Jolin. </author> <title> Java's atomic assignment: The key to simpler data access across threads. </title> <type> Java Report 3(8), </type> <pages> 27-36, </pages> <year> 1998. </year>
Reference-contexts: if it is a load action, then the read action corresponding to that load action must follow the lock action, as seen by main memory. 8 Conclusion As interest in the language increases, Java developers are starting to examine and exploit the details of the Java concurrency model (e.g., see <ref> [16, 18, 14] </ref>). We feel that our specification has several things to offer the Java community. Our alternative view of Java concurrency brings to light some issues that might otherwise remain hidden in the JLS.
Reference: [15] <author> P. Kutter and A. Pierantonio. </author> <title> Montages specifications of realistic programming languages. </title> <journal> Journal of Universal Computer Science 3(5), </journal> <pages> 416-442, </pages> <year> 1997. </year>
Reference: [16] <author> D. Lea. </author> <title> Concurrent Programming in Java. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: if it is a load action, then the read action corresponding to that load action must follow the lock action, as seen by main memory. 8 Conclusion As interest in the language increases, Java developers are starting to examine and exploit the details of the Java concurrency model (e.g., see <ref> [16, 18, 14] </ref>). We feel that our specification has several things to offer the Java community. Our alternative view of Java concurrency brings to light some issues that might otherwise remain hidden in the JLS.
Reference: [17] <institution> Computer Engineering and Networks Laboratory, ETH Zurich. Montages home page. </institution> <note> http://www.tik.ee.ethz.ch/~montages/. </note>
Reference: [18] <author> S. Oaks and H. Wong. </author> <title> Java Threads. </title> <publisher> O'Reilly and Associates, </publisher> <year> 1997. </year>
Reference-contexts: if it is a load action, then the read action corresponding to that load action must follow the lock action, as seen by main memory. 8 Conclusion As interest in the language increases, Java developers are starting to examine and exploit the details of the Java concurrency model (e.g., see <ref> [16, 18, 14] </ref>). We feel that our specification has several things to offer the Java community. Our alternative view of Java concurrency brings to light some issues that might otherwise remain hidden in the JLS.
Reference: [19] <author> G. Plotkin. </author> <title> Structural Operational Semantics (Lecture notes). </title> <type> Technical Report DAIMI FN-19, </type> <institution> Aarhus University, </institution> <year> 1981. </year>
Reference: [20] <author> G. Steele. </author> <type> Personal communication. </type>
Reference-contexts: According to <ref> [20] </ref>, the strict interpretation is what the authors of the JLS intended, so we adopt it here. However, we find that a lenient interpretation of the term in Rule 2.1 has some advantages that make it worth discussing. Read/load order. <p> Note that the choice of interpretation of "uniquely paired" determines whether every access message must be loaded in. The strict interpretation, under which every access message is loaded in, is simpler and more appealing from a logical perspective, which is why it is the intended interpretation, according to <ref> [20] </ref>. But note that spurious read actions are innocuous: failing to load in a given access message has only the effect of making a thread's working memory less up-to-date than possible. <p> According to <ref> [20] </ref>, the strict interpretation is what the authors of the JLS intended. Store actions. <p> For instance, in some cases it may be desirable to have the last assign actions of a thread stored out, while in other cases it may be clearly undesirable; consider a thread which is stopped because it is computing erroneous results. According to <ref> [20] </ref>, this is still an open issue. For simplicity, we take the view that stopped threads are not obligated to do any further actions. A thread that is alive can be suspended, in which case it remains alive but does nothing. <p> A suspended thread resumes (becomes unsuspended) when some other thread invokes the method resume upon its Thread instance. It is not clear whether a suspended thread can issue load or store actions, and according to <ref> [20] </ref> this is an unresolved issue. Here we choose the more permissive interpretation. A thread may be marked as a daemon. Such threads are intended to execute only in conjunction with non-daemon threads.
Reference: [21] <institution> University of Michigan. ASM home page. </institution> <note> http://www.eecs.umich.edu/groups/gasm/. </note>
Reference: [22] <institution> University of Paderborn. ASM home page. </institution> <note> http://www.uni-paderborn.de/cs/asm.html. </note>
Reference: [23] <institution> University of Paderborn. </institution> <note> ASM tool page. http://www.uni-paderborn.de/cs/asm/ASMToolPage. </note>
Reference: [24] <author> C. Wallace. </author> <title> The semantics of the Java programming language: Preliminary version. </title> <type> Technical Report CSE-TR-355-97, </type> <institution> University of Michigan, </institution> <year> 1997. </year> <month> 36 </month>
Reference-contexts: semantic analysis of Java that results in exposing a hierarchy of natural sublanguages of Java. [3] has been used in [4] to analyze the correctness of the translation from Java to Java Virtual Machine bytecode. [3] takes static semantics for granted and restricts itself to the sequential fragment of Java. <ref> [24] </ref> gives static and dynamic semantics of full Java, using Montages ([15, 17]); this paper can be viewed as an elaboration of the portion of [24] devoted to Java concurrency. <p> of the translation from Java to Java Virtual Machine bytecode. [3] takes static semantics for granted and restricts itself to the sequential fragment of Java. <ref> [24] </ref> gives static and dynamic semantics of full Java, using Montages ([15, 17]); this paper can be viewed as an elaboration of the portion of [24] devoted to Java concurrency. Other formal models of (fragments of) Java include [6] and [5]. [6] has been used to prove type safety properties of the language; it also focuses on the sequential fragment of Java.
References-found: 24

