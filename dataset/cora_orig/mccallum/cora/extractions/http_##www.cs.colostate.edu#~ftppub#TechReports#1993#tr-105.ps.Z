URL: http://www.cs.colostate.edu/~ftppub/TechReports/1993/tr-105.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Affiliation: Department of Computer Science Colorado State University  
Abstract: An Adjustable Gradient Filter for Volume Visualization Michael E. Goss Technical Report CS-93-105 April 13, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [Ant79] <author> Andreas Antoniou. </author> <title> Digital Filters: Analysis and Design. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Multiplying the filter by a window function (a function which gradually tapers off toward 0 at the edges) can be used to reduce the effects of truncation of the filter. The Kaiser window <ref> [Ant79] </ref> is particularly useful since it has an adjustable parameter ff (alpha) which controls how quickly it tapers off to zero at the edges.
Reference: [Bui75] <author> Bui Tuong Phong. </author> <title> Illumination for computer generated pictures. </title> <journal> Communications of the ACM, </journal> <volume> 18(6) </volume> <pages> 311-317, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: One common thread in many of these methods is the way in which shading is performed to generate images. The goal is typically to display the best approximation possible to a surface (detected by some classification method), shading the surface using the 1 standard Gouraud [Gou71] or Phong <ref> [Bui75] </ref> shading models. The surface normal vectors required by these shading models are usually found using gradient vectors calculated from the voxel values (sometimes known as the gray-level gradient [T + 90]).
Reference: [CKBB90] <author> Daniel Cohen, Arie Kaufman, Reuven Bakalash, and Samuel Bergman. </author> <title> Real time discrete shading. </title> <journal> The Visual Computer, </journal> <volume> 6(1) </volume> <pages> 16-27, </pages> <month> February </month> <year> 1990. </year> <note> Also in [Kau91]. </note>
Reference-contexts: The use of additional off-axis data reduces sensitivity to noise and aliasing, although it is computationally expensive and produces additional smoothing which may or may not be desired. Cohen et. al. <ref> [CKBB90] </ref> consider using a larger neighborhood with a depth-buffer (Z-buffer) based gradient calculation. In this case increasing the neighborhood size using the depth-buffer congradient shading technique will smooth the picture while a smaller neighborhood will be more sensitive to small changes on the surface.
Reference: [CLL + 88] <author> H. E. Cline, W. E. Lorensen, S. Ludke, C. R. Crawford, and B. C. Teeter. </author> <title> Two algorithms for the three-dimensional reconstruction of tomograms. </title> <journal> Medical Physics, </journal> <volume> 15(3) </volume> <pages> 320-327, </pages> <note> May/June 1988. Also in [Kau91]. </note>
Reference-contexts: One class of algorithm extracts surface information as a 3D model, which can then be rendered using conventional rendering techniques. Lorensen, Cline, et. al. <ref> [LC87, CLL + 88] </ref> use the center difference calculation to compute the gradient vector for shading of models extracted from volume data: polygonal models constructed from a volume in the marching cubes algorithm and point primitives in the dividing cubes algorithm.
Reference: [DCH88] <author> Robert A. Drebin, Loren Carpenter, and Pat Hanrahan. </author> <title> Volume rendering. </title> <journal> Computer Graphics, </journal> <volume> 22(4) </volume> <pages> 65-74, </pages> <month> August </month> <year> 1988. </year> <booktitle> SIGGRAPH Conference Proceedings. </booktitle>
Reference-contexts: Levoy describes a ray-casting method [Lev88, Lev90] which uses the center difference to compute gradient vectors used for classification as well as for shading. Westover [Wes90] uses the the same shading techniques for some images with a forward (voxel to pixel) mapping rendering technique. Drebin, Carpenter, and Hanrahan <ref> [DCH88] </ref> use the center difference to compute gradient vectors for both classification and shading in a voxel to pixel projection method.
Reference: [Gou71] <author> Henri Gouraud. </author> <title> Continuous shading of curved surfaces. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-20(6):623-629, </volume> <month> June </month> <year> 1971. </year>
Reference-contexts: One common thread in many of these methods is the way in which shading is performed to generate images. The goal is typically to display the best approximation possible to a surface (detected by some classification method), shading the surface using the 1 standard Gouraud <ref> [Gou71] </ref> or Phong [Bui75] shading models. The surface normal vectors required by these shading models are usually found using gradient vectors calculated from the voxel values (sometimes known as the gray-level gradient [T + 90]).
Reference: [GP93] <author> Michael E. Goss and Ivor P. </author> <title> Page. Normal vector generation for sampled data using fourier filtering. </title> <journal> The Journal of Visualization and Computer Animation, </journal> <volume> 4(1) </volume> <pages> 33-49, </pages> <month> January-March </month> <year> 1993. </year>
Reference-contexts: be seen from the form of this result that g (n) can be generated using the IDFT of G: g (n) = dt = N k=N=2 2ikn For the more common case of non-periodic data, a good approximation can be obtained by applying a leveling procedure to compute the slope <ref> [GP93] </ref>. The leveling procedure subtracts a line having the mean slope of the samples (x (N)x (0)) (N1)T , finds the slope g of this leveled function, and then adds the mean slope to each g (n).
Reference: [H + 90] <author> Karl Heinz Hohne et al. </author> <title> 3D visualization of tomographic volume data using the generalized voxel model. </title> <journal> The Visual Computer, </journal> (6):28-36, 1990. 
Reference-contexts: Westover [Wes90] uses the the same shading techniques for some images with a forward (voxel to pixel) mapping rendering technique. Drebin, Carpenter, and Hanrahan [DCH88] use the center difference to compute gradient vectors for both classification and shading in a voxel to pixel projection method. Hohne, Tiede, et. al. <ref> [H + 90, T + 90] </ref> also use a technique originated by Zucker and Hummel [ZH81] which computes a weighted average of center differences along each axis and the diagonals closest to that axis.
Reference: [Kau91] <author> Arie Kaufman, </author> <title> editor. Volume Visualization. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference: [LC87] <author> William E. Lorensen and Harvey E. Cline. </author> <title> Marching cubes: A high resolution 3D surface construction algorithm. </title> <journal> Computer Graphics, </journal> <volume> 21(4) </volume> <pages> 163-169, </pages> <month> July </month> <year> 1987. </year> <booktitle> SIG-GRAPH Conference Proceedings. </booktitle>
Reference-contexts: One class of algorithm extracts surface information as a 3D model, which can then be rendered using conventional rendering techniques. Lorensen, Cline, et. al. <ref> [LC87, CLL + 88] </ref> use the center difference calculation to compute the gradient vector for shading of models extracted from volume data: polygonal models constructed from a volume in the marching cubes algorithm and point primitives in the dividing cubes algorithm.
Reference: [Lev88] <author> Marc Levoy. </author> <title> Display of surfaces from volume data. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 8(3) </volume> <pages> 29-37, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: The other broad class of volume visualization algorithms generate pixel values directly from the source data without an intermediate geometric model. Levoy describes a ray-casting method <ref> [Lev88, Lev90] </ref> which uses the center difference to compute gradient vectors used for classification as well as for shading. Westover [Wes90] uses the the same shading techniques for some images with a forward (voxel to pixel) mapping rendering technique. <p> CThead is a 256 fi 256 fi 113 voxel CT image of a head. Both source data sets come from the University of North Carolina Volume Rendering Test Dataset, Volume II. The images in the figures were generated using ray casting techniques based on <ref> [Lev88] </ref>, but the effect of the gradient filter on the level of detail visible in the images should be similar using other volume visualization techniques. The images were rendered at a resolution of 400 fi 400 pixels, using the Phong shading model.
Reference: [Lev90] <author> Marc Levoy. </author> <title> A hybrid ray tracer for rendering polygon and volume data. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 10(2) </volume> <pages> 33-40, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The other broad class of volume visualization algorithms generate pixel values directly from the source data without an intermediate geometric model. Levoy describes a ray-casting method <ref> [Lev88, Lev90] </ref> which uses the center difference to compute gradient vectors used for classification as well as for shading. Westover [Wes90] uses the the same shading techniques for some images with a forward (voxel to pixel) mapping rendering technique.
Reference: [OS75] <author> Alan V. Oppenheim and Ronald W. Schafer. </author> <title> Digital Signal Processing. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1975. </year>
Reference-contexts: In order to correctly reconstruct the original function x a (t) from samples x (n), the sample spacing T must satisfy the relationship T &lt; 1 2F , where F is the highest frequency present in x a (t) (2F is the Nyquist sampling rate) <ref> [OS75] </ref>.
Reference: [PFTV88] <author> William H. Press, Brian P. Flannery, Saul A. Teukolsky, and William T. Vetterling. </author> <title> Numerical Recipes in C: </title> <booktitle> The Art of Scientific Computing. </booktitle> <address> Cambridge UP, Cambridge, England, </address> <year> 1988. </year> <month> 9 </month>
Reference-contexts: A Kaiser window of N samples with parameter ff is computed as w ff (n) = I 0 (ff) 2 N where I 0 (x) is the order 0 modified Bessel function <ref> [PFTV88] </ref> of x, and fi is calculated from ff as fi = ff 1 2n 2 Kaiser windows with values of ff near 0 approximate a rectangular window, while increasing values of ff smooth the transition to 0 at the edges of the window.
Reference: [T + 90] <author> Ulf Tiede et al. </author> <title> Investigation of medical 3D-rendering algorithms. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 10(2) </volume> <pages> 41-53, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The surface normal vectors required by these shading models are usually found using gradient vectors calculated from the voxel values (sometimes known as the gray-level gradient <ref> [T + 90] </ref>). These gradient vectors are perpendicular to the estimated surface of constant density, and so can be used as surface normal vectors. The most commonly used method for approximation of the volume gradient vector is the center difference. <p> Westover [Wes90] uses the the same shading techniques for some images with a forward (voxel to pixel) mapping rendering technique. Drebin, Carpenter, and Hanrahan [DCH88] use the center difference to compute gradient vectors for both classification and shading in a voxel to pixel projection method. Hohne, Tiede, et. al. <ref> [H + 90, T + 90] </ref> also use a technique originated by Zucker and Hummel [ZH81] which computes a weighted average of center differences along each axis and the diagonals closest to that axis.
Reference: [Wes90] <author> Lee Westover. </author> <title> Footprint evaluation for volume rendering. </title> <journal> Computer Graphics, </journal> <volume> 24(4) </volume> <pages> 367-376, </pages> <month> August </month> <year> 1990. </year> <booktitle> SIGGRAPH Conference Proceedings. </booktitle>
Reference-contexts: The other broad class of volume visualization algorithms generate pixel values directly from the source data without an intermediate geometric model. Levoy describes a ray-casting method [Lev88, Lev90] which uses the center difference to compute gradient vectors used for classification as well as for shading. Westover <ref> [Wes90] </ref> uses the the same shading techniques for some images with a forward (voxel to pixel) mapping rendering technique. Drebin, Carpenter, and Hanrahan [DCH88] use the center difference to compute gradient vectors for both classification and shading in a voxel to pixel projection method.

References-found: 16

