URL: http://www.cs.purdue.edu/homes/palsberg/paper/toplas-to-appear.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Title: Equality-Based Flow Analysis versus Recursive Types  
Author: Jens Palsberg 
Date: June 9, 1998  
Affiliation: Purdue University  
Abstract: Equality-based control-flow analysis has been studied by Henglein, Bondorf and Jtrgensen, DeFouw, Grove, and Chambers, and others. It is faster than the subset-based 0-CFA, but also more approximate. Heintze asserted in 1995 that a program can be safety checked with an equality-based control-flow analysis if and only if it can be typed with recursive types. In this paper we falsify Heintze's assertion, and we present a type system equivalent to equality-based control-flow analysis. The new type system contains both recursive types and an unusual notion of subtyping. We have s t if s and t unfold to the same regular tree, and we have ? t &gt; where t is a function type. In particular, there is no non-trivial subtyping between function types. fl Purdue University, Dept of Computer Science, W Lafayette, IN 47907, USA, palsberg@cs.purdue.edu.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <year> 1993. </year> <note> Also in Proc. POPL'91. </note>
Reference-contexts: safety analysis performs a task akin to type inference, in the sense that "safe" is like "typable." Palsberg and O'Keefe [12] showed that a program can be safety checked with 0-CFA if and only if it can be typed in Amadio and Cardelli's type system with subtyping and recursive types <ref> [1] </ref>. The proof of this connection makes explicit the close relationship between flow and subtyping. Heintze asserted in 1995 [7] that a program can be safety checked with 0-CFA = if and only if it can be typed with recursive types.
Reference: [2] <author> J. Michael Ashley. </author> <title> A practical and flexible flow analysis for higher-order languages. </title> <booktitle> In Proc. POPL'96, 23nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 184-194, </pages> <year> 1996. </year>
Reference-contexts: DeFouw, Grove, and Chambers [5] experimentally compared a family of flow-analysis algorithms whose time complexities are at most cubic time. Both 0-CFA = and some of its variants do well in that comparison. Ashley <ref> [2] </ref> has also presented a flow analysis with time complexity less than cubic time. It remains open how it relates to 0-CFA = . Bondorf and Jtrgensen [3] implemented both 0-CFA and 0-CFA = for Scheme as part of the partial evaluator Similix.
Reference: [3] <author> Anders Bondorf and Jesper Jtrgensen. </author> <title> Efficient analyses for realistic off-line partial evaluation. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(3) </volume> <pages> 315-346, </pages> <year> 1993. </year>
Reference-contexts: In this paper we address an instance of the question: Question: How does flow analysis relate to type systems? Our focus is on: 1. equality-based control-flow analysis which has been studied by Henglein [9], Bondorf and Jtrgensen <ref> [3] </ref>, DeFouw, Grove, and Chambers [5], and others, and 2. recursive types which, for example, are present in a restricted form in Java [6], in the form of recursive interfaces where equality and subtyping is based on names rather than structure. <p> Both 0-CFA = and some of its variants do well in that comparison. Ashley [2] has also presented a flow analysis with time complexity less than cubic time. It remains open how it relates to 0-CFA = . Bondorf and Jtrgensen <ref> [3] </ref> implemented both 0-CFA and 0-CFA = for Scheme as part of the partial evaluator Similix. For Scheme, the condition of finite types does not hold in general. They concluded that the two analyses have comparable precision for their application, and that 0-CFA = is much faster.
Reference: [4] <author> Kim B. Bruce, Luca Cardelli, Giuseppe Castagna, Jonathan Eifrig, Scott F. Smith, Valery Trifonov, Gary T. Leavens, and Benjamin C. Pierce. </author> <title> On binary methods. </title> <journal> Theory and Practice of Object Systems, </journal> <volume> 1(3) </volume> <pages> 221-242, </pages> <year> 1995. </year>
Reference-contexts: Shapiro and Horwitz [15] presented an experimental comparison of the two algorithms, and it confirms the theoretical conclusion that 0-CFA = is faster and more approximate than 0-CFA . For an object-oriented language like Java, the condition of finite types is seldomly satisfied because of, for example, binary methods <ref> [4] </ref>. DeFouw, Grove, and Chambers [5] experimentally compared a family of flow-analysis algorithms whose time complexities are at most cubic time. Both 0-CFA = and some of its variants do well in that comparison. Ashley [2] has also presented a flow analysis with time complexity less than cubic time.
Reference: [5] <author> Greg DeFouw, David Grove, and Craig Chambers. </author> <title> Fast interprocedural class analysis. </title> <booktitle> In Proc. POPL'98, 25th Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 222-236, </pages> <address> San Diego, California, </address> <month> January </month> <year> 1998. </year>
Reference-contexts: In this paper we address an instance of the question: Question: How does flow analysis relate to type systems? Our focus is on: 1. equality-based control-flow analysis which has been studied by Henglein [9], Bondorf and Jtrgensen [3], DeFouw, Grove, and Chambers <ref> [5] </ref>, and others, and 2. recursive types which, for example, are present in a restricted form in Java [6], in the form of recursive interfaces where equality and subtyping is based on names rather than structure. Equality-based control-flow analysis is a simplification of subset-based control-flow analysis [16, 11, 8]. <p> For an object-oriented language like Java, the condition of finite types is seldomly satisfied because of, for example, binary methods [4]. DeFouw, Grove, and Chambers <ref> [5] </ref> experimentally compared a family of flow-analysis algorithms whose time complexities are at most cubic time. Both 0-CFA = and some of its variants do well in that comparison. Ashley [2] has also presented a flow analysis with time complexity less than cubic time.
Reference: [6] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Question: How does flow analysis relate to type systems? Our focus is on: 1. equality-based control-flow analysis which has been studied by Henglein [9], Bondorf and Jtrgensen [3], DeFouw, Grove, and Chambers [5], and others, and 2. recursive types which, for example, are present in a restricted form in Java <ref> [6] </ref>, in the form of recursive interfaces where equality and subtyping is based on names rather than structure. Equality-based control-flow analysis is a simplification of subset-based control-flow analysis [16, 11, 8].
Reference: [7] <author> Nevin Heintze. </author> <title> Control-flow analysis and type systems. </title> <booktitle> In Proc. SAS'95, International Static Analysis Symposium. </booktitle> <publisher> Springer-Verlag (LNCS 983), </publisher> <address> Glasgow, Scotland, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: The proof of this connection makes explicit the close relationship between flow and subtyping. Heintze asserted in 1995 <ref> [7] </ref> that a program can be safety checked with 0-CFA = if and only if it can be typed with recursive types. This assertion is reasonable because it says that, intuitively, if we replace subset inclusions by equalities, then the need for subtyping disappears.
Reference: [8] <author> Nevin Heintze and David McAllester. </author> <title> Linear-time subtransitive control flow analysis. </title> <booktitle> In Proc. ACM SIGPLAN 1997 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 261-272, </pages> <year> 1997. </year>
Reference-contexts: Equality-based control-flow analysis is a simplification of subset-based control-flow analysis <ref> [16, 11, 8] </ref>. We will use the abbreviations: * 0-CFA : subset-based control-flow analysis, and * 0-CFA = : equality-based control-flow analysis. 0-CFA is also known as, simply, 0-CFA. <p> Both have been implemented many times for various purposes. In general, for functional and object-oriented languages, 0-CFA can be executed in cubic time. For programs with finite types, 0-CFA can be executed in quadratic time <ref> [8] </ref>, and specific flow-oriented questions such as "identify all functions called from only one call site" can be answered in linear time [8]. For comparison, 0 CFA = can always be executed in almost-linear time [9]. <p> In general, for functional and object-oriented languages, 0-CFA can be executed in cubic time. For programs with finite types, 0-CFA can be executed in quadratic time <ref> [8] </ref>, and specific flow-oriented questions such as "identify all functions called from only one call site" can be answered in linear time [8]. For comparison, 0 CFA = can always be executed in almost-linear time [9]. <p> Which one of 0-CFA and 0 CFA = is the better choice in practice? For a language like ML [10] where functions have finite polymorphic types and data may have recursive types, experiments by Heintze and McAllester <ref> [8] </ref> indicate that it is a good choice to use 0-CFA . They implemented a variant 2 of the quadratic-time algorithm for 0-CFA which treated data in a much simplified way. For the problem of pointer analysis, there are algorithms which are close cousins of 0-CFA and 0-CFA = [17].
Reference: [9] <author> Fritz Henglein. </author> <title> Dynamic typing. </title> <booktitle> In Proc. ESOP'92, European Symposium on Programming, </booktitle> <pages> pages 233-253. </pages> <publisher> Springer-Verlag (LNCS 582), </publisher> <year> 1992. </year>
Reference-contexts: In this paper we address an instance of the question: Question: How does flow analysis relate to type systems? Our focus is on: 1. equality-based control-flow analysis which has been studied by Henglein <ref> [9] </ref>, Bondorf and Jtrgensen [3], DeFouw, Grove, and Chambers [5], and others, and 2. recursive types which, for example, are present in a restricted form in Java [6], in the form of recursive interfaces where equality and subtyping is based on names rather than structure. <p> For programs with finite types, 0-CFA can be executed in quadratic time [8], and specific flow-oriented questions such as "identify all functions called from only one call site" can be answered in linear time [8]. For comparison, 0 CFA = can always be executed in almost-linear time <ref> [9] </ref>. Which one of 0-CFA and 0 CFA = is the better choice in practice? For a language like ML [10] where functions have finite polymorphic types and data may have recursive types, experiments by Heintze and McAllester [8] indicate that it is a good choice to use 0-CFA .
Reference: [10] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year> <month> 15 </month>
Reference-contexts: For comparison, 0 CFA = can always be executed in almost-linear time [9]. Which one of 0-CFA and 0 CFA = is the better choice in practice? For a language like ML <ref> [10] </ref> where functions have finite polymorphic types and data may have recursive types, experiments by Heintze and McAllester [8] indicate that it is a good choice to use 0-CFA . They implemented a variant 2 of the quadratic-time algorithm for 0-CFA which treated data in a much simplified way.
Reference: [11] <author> Jens Palsberg. </author> <title> Closure analysis in constraint form. </title> <journal> ACM Transactions on Program--ming Languages and Systems, </journal> <volume> 17(1) </volume> <pages> 47-62, </pages> <month> January </month> <year> 1995. </year> <note> Preliminary version in Proc. </note> <editor> CAAP'94, </editor> <booktitle> Colloquium on Trees in Algebra and Programming, </booktitle> <publisher> Springer-Verlag (LNCS 787), </publisher> <pages> pages 276-290, </pages> <address> Edinburgh, Scotland, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Equality-based control-flow analysis is a simplification of subset-based control-flow analysis <ref> [16, 11, 8] </ref>. We will use the abbreviations: * 0-CFA : subset-based control-flow analysis, and * 0-CFA = : equality-based control-flow analysis. 0-CFA is also known as, simply, 0-CFA. <p> In summary, 0-CFA = has in experiments proved to be a preferable alternative to 0-CFA for many applications. Flow analyses such as 0-CFA can be formulated using constraints, see for example <ref> [11, 14] </ref>. This approach proceeds in two steps: 1) derive flow constraints from the program text, and 2) compute the least solution of the constraints. The least solution is the desired flow information. The precision of the analysis stems from the choice of constraints. <p> The least solution is the desired flow information. The precision of the analysis stems from the choice of constraints. For example, one choice leads to 0-CFA , and another choice leads to 0-CFA = . The kind of flow constraints used in, for example, the paper <ref> [11] </ref> always admits a least solution. We can turn a flow analysis into a predicate which accepts and rejects programs, by extending it with safety constraints.
Reference: [12] <author> Jens Palsberg and Patrick M. O'Keefe. </author> <title> A type system equivalent to flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(4) </volume> <pages> 576-599, </pages> <month> July </month> <year> 1995. </year> <note> Preliminary version in Proc. </note> <editor> POPL'95, </editor> <booktitle> 22nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-378, </pages> <address> San Francisco, California, </address> <month> Jan-uary </month> <year> 1995. </year>
Reference-contexts: Such a safety analysis performs a task akin to type inference, in the sense that "safe" is like "typable." Palsberg and O'Keefe <ref> [12] </ref> showed that a program can be safety checked with 0-CFA if and only if it can be typed in Amadio and Cardelli's type system with subtyping and recursive types [1]. The proof of this connection makes explicit the close relationship between flow and subtyping. <p> Given that Heintze's assertion is false, we are left with two questions: 1. which type system corresponds to 0-CFA = ?, and 2. which control-flow analysis corresponds to recursive types? Palsberg and O'Keefe's result <ref> [12] </ref> implies that E 1 and E 2 can be typed if we have both recursive types and Amadio/Cardelli subtyping. Their result also seem to indicate that adding both recursive types and all of the Amadio/Cardelli subtyping to match 0-CFA = would be overkill. <p> If we allow non-trivial subtyping between function types, then the constraints on type correctness become <ref> [12] </ref>: [[x:e]] hxi ! [[e]] In particular, this opens the possibility for a non-trivial relationship: hxi ! [[e]] [[e 0 ]] ! [[(x:e)e 0 ]] and hence [[e 0 ]] hxi These constraints are closely related to the flow constraints used in 0-CFA [12]. <p> then the constraints on type correctness become <ref> [12] </ref>: [[x:e]] hxi ! [[e]] In particular, this opens the possibility for a non-trivial relationship: hxi ! [[e]] [[e 0 ]] ! [[(x:e)e 0 ]] and hence [[e 0 ]] hxi These constraints are closely related to the flow constraints used in 0-CFA [12]. We also show that if a program can be safety checked with a certain restriction of 0-CFA = , then it can be typed with recursive types. Our restriction of 0-CFA = is that all flow sets must be nonempty and consistent. <p> To prove that lemma we use the technique from [13]. Lemma 4.4 shows that if P is RS-typable, then P is 0-CFA = safe. To prove that lemma we use a technique which is more direct than the one used to show a similar result, for 0-CFA , in <ref> [12] </ref>. From Flows to Types First we consider the mapping of flows to types. <p> ) [ fIntg) ; and change the constraints from Section 2 such that the constraints for 0 and succ e become: fIntg [[0]] [[e]] fIntg (a safety constraint) fIntg [[succ e]] : There is a systematic way of obtaining this modified flow analysis: begin with the con straints for 0-CFA <ref> [12] </ref> and * change hxi [[x]] to hxi = [[x]], and * change fx:eg [[e 1 ]] ) [[e 2 ]] hxi to fx:eg [[e 1 ]] ) [[e]] = [[e 1 e 2 ]] : All other constraints remain the same.
Reference: [13] <author> Jens Palsberg and Christina Pavlopoulou. </author> <title> From polyvariant flow information to intersection and union types. </title> <booktitle> In Proc. POPL'98, 25th Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 197-208, </pages> <address> San Diego, Cal-ifornia, </address> <month> January </month> <year> 1998. </year>
Reference-contexts: We prove this theorem in two steps. Lemma 4.3 shows that if P is 0-CFA = safe, then P is RS-typable. To prove that lemma we use the technique from <ref> [13] </ref>. Lemma 4.4 shows that if P is RS-typable, then P is 0-CFA = safe. To prove that lemma we use a technique which is more direct than the one used to show a similar result, for 0-CFA , in [12].
Reference: [14] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-Oriented Type Systems. </title> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference-contexts: In summary, 0-CFA = has in experiments proved to be a preferable alternative to 0-CFA for many applications. Flow analyses such as 0-CFA can be formulated using constraints, see for example <ref> [11, 14] </ref>. This approach proceeds in two steps: 1) derive flow constraints from the program text, and 2) compute the least solution of the constraints. The least solution is the desired flow information. The precision of the analysis stems from the choice of constraints.
Reference: [15] <author> Marc Shapiro and Susan Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In Proc. POPL'97, 24th Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <year> 1997. </year>
Reference-contexts: For the problem of pointer analysis, there are algorithms which are close cousins of 0-CFA and 0-CFA = [17]. For this problem, the condition of finite types does not hold in general. Shapiro and Horwitz <ref> [15] </ref> presented an experimental comparison of the two algorithms, and it confirms the theoretical conclusion that 0-CFA = is faster and more approximate than 0-CFA . For an object-oriented language like Java, the condition of finite types is seldomly satisfied because of, for example, binary methods [4].
Reference: [16] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, CMU, </type> <month> May </month> <year> 1991. </year> <month> CMU-CS-91-145. </month>
Reference-contexts: Equality-based control-flow analysis is a simplification of subset-based control-flow analysis <ref> [16, 11, 8] </ref>. We will use the abbreviations: * 0-CFA : subset-based control-flow analysis, and * 0-CFA = : equality-based control-flow analysis. 0-CFA is also known as, simply, 0-CFA.
Reference: [17] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Proc. POPL'96, 23nd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 32-41, </pages> <year> 1996. </year> <month> 16 </month>
Reference-contexts: They implemented a variant 2 of the quadratic-time algorithm for 0-CFA which treated data in a much simplified way. For the problem of pointer analysis, there are algorithms which are close cousins of 0-CFA and 0-CFA = <ref> [17] </ref>. For this problem, the condition of finite types does not hold in general. Shapiro and Horwitz [15] presented an experimental comparison of the two algorithms, and it confirms the theoretical conclusion that 0-CFA = is faster and more approximate than 0-CFA .
References-found: 17

