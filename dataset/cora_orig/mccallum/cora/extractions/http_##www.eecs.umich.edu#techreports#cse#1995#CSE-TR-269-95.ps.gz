URL: http://www.eecs.umich.edu/techreports/cse/1995/CSE-TR-269-95.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse95.html
Root-URL: http://www.eecs.umich.edu
Title: Monitoring and Assertion-Checking of Real Time Specifications in Modechart  Constance Heitmeyer  
Author: Monica Brockmeyer Farnam Jahanian Bruce Labaw 
Keyword: Index terms: real time systems, specification, symbolic execution, monitoring and assertion checking, formal methods.  
Note: This work is supported in part by the Naval Research Laboratory under Grant N00014-94-P2015.  
Address: Ann Arbor, MI 48109-2122  Washington, DC 20375  
Affiliation: Department of Electrical Engineering and Computer Science University of Michigan  Center for High Assurance Computer Systems Naval Research Laboratory  
Email: email: fmonicab,farnamg@eecs.umich.edu  email: fheitmeye,labawg@itd.nrl.navy.mil  
Phone: tel. (313) 936-2974  
Date: October 26, 1995  
Abstract: This paper describes the integration of a monitoring and assertion checking tool into the Modechart Toolset, a suite of integrated tools providing system specification, formal verification, static analysis, and specification simulation for real-time systems. The monitoring and assertion checking tool, MAC, supports monitoring of symbolic execution traces generated by the Modechart simulator, permitting testing of specifications early in the design phase and providing a mechanism for evaluating properties of the system on a particular execution trace. These capabilities are provided by the automatic translation of assertions in a declarative language (such as Real Time Logic) into monitoring fragments, written in Modechart, which augment the original specification to perform monitoring and assertion checking during simulation. In addition, we discuss several major issues of monitoring and assertion checking in this context. In particular, a key issue is that not all assertions can be evaluated with a bounded event history. A primary goal of this research is the identification of classes of assertions for which the number of events which must be recored for monitoring is independent of the length of the computation to be monitored. We address this problem by exploiting the semantics of Modechart to identify classes of assertions for which monitoring is simplified to evaluation of a state predicate on a finite event history having a bound which is established a priori. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: Each event type is represented by a node and timing constraints between event types are represented by weighted edges between nodes. The graph is then checked for negative weight cycles using the Floyd-Warshall algorithm <ref> [1] </ref>. Alternatively, when a bound has ben established for the event history, it is also possible to define Mode-chart monitoring fragments or other automata to perform the actual checking.
Reference: [2] <author> James F. Allen. </author> <title> Maintaining knowledge about temporal intervals. </title> <journal> Communications of the ACM, </journal> <volume> 26(11) </volume> <pages> 832-843, </pages> <year> 1983. </year>
Reference-contexts: Such an interval has the additional property that no two occurrences of that interval can be open simultaneously. The following axiom is added for each mode: 8i@(E 2 ; i) + C 2 &lt; @(E 1 ; i + 1) + C 1 Allen <ref> [2] </ref> introduced a taxonomy of temporal relationships for two intervals of time. We introduce in Table 3 a set of primitive relationships loosely derived from his system.
Reference: [3] <author> B. Boehm. </author> <title> Software Engineering Economics. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year> <month> 30 </month>
Reference-contexts: Other studies have demonstrated that errors in the specification are the most frequent types of software errors and the most expensive to correct <ref> [3, 22] </ref>. The source of safety-critical failures can often be traced to requirements, specification, or design errors very early in the software development process [20]. It has been argued that formal specification methods can reduce the number of errors in a specification by preventing imprecision and ambiguity.
Reference: [4] <author> S. Chodrow, F. Jahanian, and M. Donner. </author> <title> Run-time monitoring of real-time systems. </title> <booktitle> In Proc. of 12th Real-Time Systems Symposium, </booktitle> <pages> pages 74-83, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: This means that it must be possible to ascertain the satisfiability of inequalities containing one or more variable terms. For such assertions, an elegant mechanism <ref> [4, 12] </ref> for checking satisfiability maps the inequality into a graph. Each event type is represented by a node and timing constraints between event types are represented by weighted edges between nodes. The graph is then checked for negative weight cycles using the Floyd-Warshall algorithm [1].
Reference: [5] <author> P. C. Clements, C. L. Heitmeyer, B. G. Labaw, and A. T. Rose. </author> <title> MT: A toolset for specifying and analyzing real-time systems. </title> <booktitle> In Proc. IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: This approach we have adopted for our tool and is described in more detail in Sections 3 and 5. 5 3 Integration of Monitoring with the Modechart Toolset The Modechart Toolset (MT), developed by the Naval Research Laboratory provides a graphical user interface for entering Modechart specifications <ref> [5, 23] </ref>. In addition, the toolset provides formal verification, static completeness and consistency checking, and specification simulation. This section describes the Monitoring and Assertion-Checking Tool (MAC) and its integration with MT. The Modechart Simulator provides symbolic execution of Modechart specifications.
Reference: [6] <author> Miguel Felder and Angelo Morzenti. </author> <title> Validating real-time systems by history-checking trio specifications. </title> <booktitle> In Procedings of the 14th International Confernence on Software Engineering, </booktitle> <address> New York, NY, 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: It is also possible to set breakpoints in the Statechart code. In addition, the STATEMATE system provides a simulation control language to provide additional control over the generation of execution traces. History-checking of TRIO specifications is provided in the recent work of <ref> [6] </ref>. TRIO is a first order temporal logic which deals with time in a quantitative way by providing a metric to indicate distance in time between events. History-checking is provided by applying a tableaux-based algorithm to a history (execution trace) of a TRIO specification.
Reference: [7] <author> D.A. Gabel. </author> <title> Technology 1994: </title> <journal> Software engineering. IEEE Spectrum, </journal> <volume> 31(1) </volume> <pages> 38-41, </pages> <month> january </month> <year> 1994. </year>
Reference-contexts: Ensuring that such systems meet their prescribed specifications is a growing challenge that faces the industry in the coming decade. Several studies have demonstrated that the cost of detecting and removing software errors increases significantly as the development process moves from requirements specification toward production <ref> [7] </ref>. In fact, the cost of removing an error from a system specification is an order of magnitude smaller than the cost of removing it from a system that is going through integration testing.
Reference: [8] <author> D. Haban and K. G. Shin. </author> <title> Application of real-time monitoring to scheduling tasks with random execution times. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 16(12) </volume> <pages> 1374-1389, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: See [28] for many of the major contributions with regard to distributed systems as well as several which address monitoring in the context of real time systems. Special hardware support for collecting run-time data in real time applications has been considered in a number of recent papers <ref> [8, 19, 27] </ref>. These approaches introduce specialized co-processors for the collection and analysis of run-time information. The use of special-purpose hardware allows non-intrusive monitoring of a system by recording the run-time information in a large repository, often for post analysis.
Reference: [9] <author> D. Haban and D. Wybranietz. </author> <title> A hybrid monitor for behavior and performance analysis of distributed systems. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 16(2) </volume> <pages> 197-211, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: These approaches introduce specialized co-processors for the collection and analysis of run-time information. The use of special-purpose hardware allows non-intrusive monitoring of a system by recording the run-time information in a large repository, often for post analysis. A related work <ref> [9] </ref> studies the use of monitoring information to aid in scheduling tasks.
Reference: [10] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8, </volume> <year> 1987. </year>
Reference-contexts: It provides a compact and structured way to represent real time systems. Although similar to Harel's Statecharts <ref> [10] </ref>, Modechart is specifically designed for the specification of real time systems. It allows for the specification of modes which represent control information which impose structure on the operation of a system. Modechart is extended from Statecharts with constructs for expressing timing constraints. <p> This paper discusses the additional issues of early detection of violations, minimization of the number of messages required for monitoring, and clocks and timer granularity. The STATEMATE system [11], based on Statecharts <ref> [10] </ref>, provides symbolic execution of system spec 29 ifications. In an approach similar to ours, these executions can be monitored via special "watchdog" code which is defined by the user in Statecharts. There is no automatic generation of watchdog code.
Reference: [11] <author> D. Harel et al. Statemate: </author> <title> A working environment for the development of complex reactive systems. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> SE-16(4), </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: For a discussion of an approach to run-time monitoring of RTL assertions in distributed real time systems see [15]. This paper discusses the additional issues of early detection of violations, minimization of the number of messages required for monitoring, and clocks and timer granularity. The STATEMATE system <ref> [11] </ref>, based on Statecharts [10], provides symbolic execution of system spec 29 ifications. In an approach similar to ours, these executions can be monitored via special "watchdog" code which is defined by the user in Statecharts. There is no automatic generation of watchdog code.
Reference: [12] <author> F. Jahanian. </author> <title> Run-time monitoring of real-time systems. </title> <editor> In Sang H. Son, editor, </editor> <booktitle> Advances in Real-Time Computing, chapter 18. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1994. </year>
Reference-contexts: This means that it must be possible to ascertain the satisfiability of inequalities containing one or more variable terms. For such assertions, an elegant mechanism <ref> [4, 12] </ref> for checking satisfiability maps the inequality into a graph. Each event type is represented by a node and timing constraints between event types are represented by weighted edges between nodes. The graph is then checked for negative weight cycles using the Floyd-Warshall algorithm [1]. <p> S.RC.PROCESS-&gt; & ->JUST_GOT_IN S.RC.PROCESS-&gt; (5,5) (8,8) 28 control mode has satisfiable and unsatisfied modes with a single transition from the satisfiable mode to the unsatisfied mode defined in exactly the same manner as for the composition of single-mode assertions. 6 Related Work The foundations for our work are found in <ref> [12] </ref> which develops the framework for understanding a system computation in terms of an event-based model. The problem of bounding event histories is described here as well as the distinction between synchronous and asynchronous monitoring.
Reference: [13] <author> F. Jahanian and A. Goyal. </author> <title> A formalism for monitoring real-time constraints at run-time. </title> <booktitle> In Proc. of Fault-Tolerant Computing Symposium (FTCS-20), </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: And finally, the tool permits the user to incorporate his or her own monitoring fragments developed in Modechart into the original specification. One model for formal specification and monitoring of constraints <ref> [13, 14, 15] </ref> in time-critical systems is based on timestamping events as they occur and maintaining an event history of such occurrences. The event history is then checked to determine whether a given assertion is satisfied by a computation. <p> A more formal approach to real time monitoring, including the development of the idea of a computation prefix is provided in <ref> [13] </ref>. More attention has been given to the issues of on-line or run-time monitoring than to that of monitoring and assertion checking of symbolic executions of real time systems.
Reference: [14] <author> F. Jahanian and A. K. Mok. Modechart: </author> <title> A specification language for real-time systems. </title> <journal> IEEE Trans. Software Engineering, </journal> <month> 20(10), </month> <year> 1994. </year>
Reference-contexts: The Modechart Toolset (MT)[5] is a collection of integrated tools developed by the Naval Research Laboratory together with researchers from the University of Texas to address these challenges. MT supports the formal specification of real time behavior in a language called Modechart <ref> [14] </ref> and formal analysis via formal verification, simulation, and completeness and consistency checking. The toolset includes facilities for creating and editing Modechart specifications. Users may symbolically execute the specifications with an automatic simulation tool to confirm that the specification is consistent with their intent. <p> These monitoring fragments are symbolically executed together with the original specification to provide monitoring and assertion checking capabilities. MT's specification language, Modechart, is a hierarchical, graphically-oriented specification language for real time systems and protocols <ref> [14] </ref>. A first-order language, Real Time Logic (RTL) [16], can be used to construct assertions which are checked against specification simulations generated from Modechart specifications. RTL allows the description of ordering and distance requirements between event occurrences. However, not all assertions expressible in RTL can be effectively monitored. <p> And finally, the tool permits the user to incorporate his or her own monitoring fragments developed in Modechart into the original specification. One model for formal specification and monitoring of constraints <ref> [13, 14, 15] </ref> in time-critical systems is based on timestamping events as they occur and maintaining an event history of such occurrences. The event history is then checked to determine whether a given assertion is satisfied by a computation. <p> In Section 3.2, we describe our approach to monitoring and assertion-checking and the integration of the MAC Tool into the Modechart Toolset. Finally, in Section 3.3, we return to our robot example to demonstrate our approach. 3.1 Overview of the Modechart Language: A Robot Controller Example Modechart <ref> [14] </ref> is a graphical specification language based on concurrent finite state diagrams. It provides a compact and structured way to represent real time systems. Although similar to Harel's Statecharts [10], Modechart is specifically designed for the specification of real time systems. <p> More precisely, M was entered before the current moment of time, and since then, M has not exited before the current moment. Further discussion of the possible predicates on modes can be found in <ref> [23, 14] </ref>. Finally, more complex mode transition expressions can be formed from triggers and timing constraints. More elaborate triggers can be composed by taking the conjuncts of trigger expressions, and these conjuncts can be disjuncted together with timing expressions.
Reference: [15] <author> F. Jahanian, R. Rajkumar, and S. Raju. </author> <title> Monitoring timing constraints in distributed real-time systems. </title> <journal> Journal of Real-Time Systems, </journal> <volume> 7(3), </volume> <year> 1994. </year>
Reference-contexts: And finally, the tool permits the user to incorporate his or her own monitoring fragments developed in Modechart into the original specification. One model for formal specification and monitoring of constraints <ref> [13, 14, 15] </ref> in time-critical systems is based on timestamping events as they occur and maintaining an event history of such occurrences. The event history is then checked to determine whether a given assertion is satisfied by a computation. <p> The FLEX language provides the constructs for specifying delay and deadline constraints in a program. For a discussion of an approach to run-time monitoring of RTL assertions in distributed real time systems see <ref> [15] </ref>. This paper discusses the additional issues of early detection of violations, minimization of the number of messages required for monitoring, and clocks and timer granularity. The STATEMATE system [11], based on Statecharts [10], provides symbolic execution of system spec 29 ifications.
Reference: [16] <author> Farnam Jahanian and Aloysius Ka-Lau Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> SE-12(9):890-904, </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: These monitoring fragments are symbolically executed together with the original specification to provide monitoring and assertion checking capabilities. MT's specification language, Modechart, is a hierarchical, graphically-oriented specification language for real time systems and protocols [14]. A first-order language, Real Time Logic (RTL) <ref> [16] </ref>, can be used to construct assertions which are checked against specification simulations generated from Modechart specifications. RTL allows the description of ordering and distance requirements between event occurrences. However, not all assertions expressible in RTL can be effectively monitored. Our tool addresses this challenge in several ways.
Reference: [17] <author> Kevin B. Kenny and Kwei-Jay Lin. </author> <title> Building flexible real-time systems using the flex language. </title> <journal> IEEE Computer, </journal> <volume> 24(5) </volume> <pages> 70-78, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: These events are sent periodically by the local host to a remote host for displaying the execution history. The invasiveness of the monitoring facility is included in the schedulability analysis. Monitoring and detecting violations of certain predefined timing constraints have been proposed in real time languages, such as FLEX <ref> [17] </ref>. The FLEX language provides the constructs for specifying delay and deadline constraints in a program. For a discussion of an approach to run-time monitoring of RTL assertions in distributed real time systems see [15].
Reference: [18] <author> C. Kilpatrick, K. Schwan, and D. Ogle. </author> <title> Using languages for capture, analysis, and display of performance information for parallel or distributed systems. </title> <booktitle> In Int'l Conf. on Computer Languages, </booktitle> <year> 1990. </year>
Reference-contexts: Because the monitoring nodes do not contribute any network traffic, interference is avoided. A work closer to our approach is a system for collection and analysis of distributed/parallel (real time) programs <ref> [18] </ref>. The work is based on an earlier system for exploring the use of an extended E-R model for specification and access to monitoring information at run-time [25]. The assumption is that the relational model is an appropriate formalism for structuring the information generated by a distributed system.
Reference: [19] <author> H. Kopetz, A. Damm, C. Koza, M. Mulazzani, W. Schwabl, C. Senft, and R. Zainlinger. </author> <title> Distributed fault-tolerant real-time systems: The MARS approach. </title> <journal> IEEE Micro, </journal> <volume> 9(1) </volume> <pages> 25-40, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: See [28] for many of the major contributions with regard to distributed systems as well as several which address monitoring in the context of real time systems. Special hardware support for collecting run-time data in real time applications has been considered in a number of recent papers <ref> [8, 19, 27] </ref>. These approaches introduce specialized co-processors for the collection and analysis of run-time information. The use of special-purpose hardware allows non-intrusive monitoring of a system by recording the run-time information in a large repository, often for post analysis. <p> These approaches emphasize event detection rather than the issues connected with monitoring more complex behaviors of a system. [24] gives an overview of the important issues of run-time monitoring for real-time distributed systems and illustrates these issues in terms of the test methodology developed for the MARS system <ref> [19] </ref>. This approach uses special monitoring nodes between system nodes to collect communication events which are saved for later analysis. Because the monitoring nodes do not contribute any network traffic, interference is avoided.
Reference: [20] <author> N. G. Leveson. </author> <title> Software safety. </title> <booktitle> 11th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <month> May </month> <year> 1994. </year> <type> Invited Talk. </type>
Reference-contexts: Other studies have demonstrated that errors in the specification are the most frequent types of software errors and the most expensive to correct [3, 22]. The source of safety-critical failures can often be traced to requirements, specification, or design errors very early in the software development process <ref> [20] </ref>. It has been argued that formal specification methods can reduce the number of errors in a specification by preventing imprecision and ambiguity. Furthermore, formal specifications are amenable to formal analysis techniques including consistency and completeness checks, validation and testing, and verification.
Reference: [21] <author> Charles E. McDowell and David P. Helmbold. </author> <title> Debugging concurrent programs. </title> <editor> In Jeffrey J. P. Tsai and Steve J. H. Yang, editors, </editor> <title> Monitoring and Debugging of Distributed Real-Time Systems. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1995. </year>
Reference-contexts: This is described in Section 5. displayed by the Modechart Simulator. Mode names are listed on the vertical axis on the left and the elapsed time is displayed across the top in this "time-process diagram" <ref> [21] </ref>. A thick horizontal line indicates the period of time during which each mode is active. The particular execution displayed violates the delay assertion. It can be seen from this diagram that at time point 27, S.RC.Process becomes active and exits at time point 32.
Reference: [22] <author> R. Pressman. </author> <title> Software Engineering A practitioner's Approach. </title> <publisher> McGraw Hill, </publisher> <address> New York, NY, </address> <note> 3rd edition, </note> <year> 1992. </year>
Reference-contexts: Other studies have demonstrated that errors in the specification are the most frequent types of software errors and the most expensive to correct <ref> [3, 22] </ref>. The source of safety-critical failures can often be traced to requirements, specification, or design errors very early in the software development process [20]. It has been argued that formal specification methods can reduce the number of errors in a specification by preventing imprecision and ambiguity.
Reference: [23] <author> A. Rose, M. Perez, and P. Clements. </author> <title> Modechart toolset user's guide. </title> <type> Technical Report NRL/MRL/5540-94-7427, </type> <institution> Center for Computer High Assurance Systems, Naval Research Lab, </institution> <address> Washington, D.C., </address> <month> February </month> <year> 1994. </year>
Reference-contexts: This approach we have adopted for our tool and is described in more detail in Sections 3 and 5. 5 3 Integration of Monitoring with the Modechart Toolset The Modechart Toolset (MT), developed by the Naval Research Laboratory provides a graphical user interface for entering Modechart specifications <ref> [5, 23] </ref>. In addition, the toolset provides formal verification, static completeness and consistency checking, and specification simulation. This section describes the Monitoring and Assertion-Checking Tool (MAC) and its integration with MT. The Modechart Simulator provides symbolic execution of Modechart specifications. <p> More precisely, M was entered before the current moment of time, and since then, M has not exited before the current moment. Further discussion of the possible predicates on modes can be found in <ref> [23, 14] </ref>. Finally, more complex mode transition expressions can be formed from triggers and timing constraints. More elaborate triggers can be composed by taking the conjuncts of trigger expressions, and these conjuncts can be disjuncted together with timing expressions.
Reference: [24] <author> Werner Schutz. </author> <title> Fundamental issues in testing distributed real-time systems. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 7(2) </volume> <pages> 129-157, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: The monitored information is fed back to the operating system for achieving an adaptive behavior. These approaches emphasize event detection rather than the issues connected with monitoring more complex behaviors of a system. <ref> [24] </ref> gives an overview of the important issues of run-time monitoring for real-time distributed systems and illustrates these issues in terms of the test methodology developed for the MARS system [19]. This approach uses special monitoring nodes between system nodes to collect communication events which are saved for later analysis.
Reference: [25] <author> Richard Snodgrass. </author> <title> A relational approach to monitoring complex systems. </title> <journal> ACM Trans. Computer Systems, </journal> <volume> 6(2) </volume> <pages> 157-196, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: A work closer to our approach is a system for collection and analysis of distributed/parallel (real time) programs [18]. The work is based on an earlier system for exploring the use of an extended E-R model for specification and access to monitoring information at run-time <ref> [25] </ref>. The assumption is that the relational model is an appropriate formalism for structuring the information generated by a distributed system. A real time monitor developed for the ARTS distributed operating system is presented in [26].
Reference: [26] <author> Hideyuki Tokuda, Makoto Kotera, and Clifford W. Mercer. </author> <title> A real-time monitor for a distributed real-time operating system. </title> <booktitle> Proceedings of the ACM SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, published in ACM SIGPLAN Notices, </booktitle> <volume> 24(1) </volume> <pages> 68-77, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The assumption is that the relational model is an appropriate formalism for structuring the information generated by a distributed system. A real time monitor developed for the ARTS distributed operating system is presented in <ref> [26] </ref>. The proposed monitor requires certain support from the kernel, such as notification of the state changes of a process, including waking-up, and being scheduled. In particular the ARTS kernel records these events that are seen by the operating system as the state changes of a process.
Reference: [27] <author> J. J. P. Tsai, K.-Y. Fang, and H.-Y. Chen. </author> <title> A non-invasive architecture to monitor real-time distributed systems. </title> <journal> IEEE Computer, </journal> <volume> 23(3) </volume> <pages> 11-23, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: See [28] for many of the major contributions with regard to distributed systems as well as several which address monitoring in the context of real time systems. Special hardware support for collecting run-time data in real time applications has been considered in a number of recent papers <ref> [8, 19, 27] </ref>. These approaches introduce specialized co-processors for the collection and analysis of run-time information. The use of special-purpose hardware allows non-intrusive monitoring of a system by recording the run-time information in a large repository, often for post analysis.
Reference: [28] <author> Jeffrey J. P. Tsai and Steve J. H. Yang, </author> <title> editors. Monitoring and Debugging of Distributed Real-Time Systems. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1995. </year> <month> 31 </month>
Reference-contexts: Run-time monitoring systems must address problems related to the probe effect including perturbation and event reordering, in addition to the issues we describe. Moreover, the research has focused on monitoring facilities for parallel and distributed systems, rather than for real time systems. See <ref> [28] </ref> for many of the major contributions with regard to distributed systems as well as several which address monitoring in the context of real time systems. Special hardware support for collecting run-time data in real time applications has been considered in a number of recent papers [8, 19, 27].
References-found: 28

