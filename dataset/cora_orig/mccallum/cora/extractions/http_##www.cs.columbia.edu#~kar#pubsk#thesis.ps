URL: http://www.cs.columbia.edu/~kar/pubsk/thesis.ps
Refering-URL: http://www.cs.columbia.edu/~kar/pubsk/pubsk.html
Root-URL: http://www.cs.columbia.edu
Title: THE SEMANTICS OF DEDUCTIVE DATABASES  
Author: Kenneth Andrew Ross 
Degree: a dissertation submitted to the department of computer science and the committee on graduate studies of stanford university in partial fulfillment of the requirements for the degree of doctor of philosophy By  
Date: August 1991  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> H. Abelson and G. J. Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> McGraw Hill, </publisher> <year> 1985. </year>
Reference-contexts: Roughly, declarativeness means that the person writing in that language specifies "what to compute" and not "how to compute it." For discussion of the relative merits of declarative and procedural (or imperative) systems, see <ref> [1, 39, 40, 55, 69, 113] </ref>. In principle, declarativeness requires less of a user or programmer, and can thus be the basis of a system in which writing queries can be significantly less time-consuming than with a procedural language.
Reference: [2] <author> S. Abiteboul. </author> <title> Towards a deductive object-oriented database language. </title> <booktitle> In Proceedings of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <year> 1989. </year>
Reference-contexts: In languages such as HiLog it is possible to define parameterized procedures, or in the object-oriented terminology, "methods." A promising approach is the integration of some object oriented features in a deductive database framework. Various such attempts have been reported in <ref> [2, 44, 62, 123] </ref>. A successful integration would provide mechanisms for encapsulation, inheritance, complex objects and other object-oriented concepts while retaining the declarativeness and formal basis of deductive databases.
Reference: [3] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural and declarative database update languages. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <year> 1988. </year>
Reference-contexts: We believe that this agreement indicates a robustness of the semantics, and provides evidence that it coincides well with intuition, at least in the context of deductive databases. 3.1.4 Inflationary Semantics The inflationary semantics was proposed in [54] and, independently, in <ref> [3] </ref>. The idea behind the inflationary semantics is to treat negation as expressing "not currently true." If p is an atom, then :p is considered satisfied if, at the current stage of the iteration, p has not been derived. <p> It is of no concern if p is later established; no inferences are undone. While first formally studied (in the absence of other features) in <ref> [3, 54] </ref>, the inflationary interpretation of negation has been a feature of rule-based expert systems languages such as OPS5 3 [16, 29]. <p> We say that the query Q is expressible in a semantics S if the relation Q (D) is definable in S. The following theorem summarizes results from <ref> [3, 53, 54, 104] </ref>. 8 Here, "" denotes proper containment. Also, 1 1 denotes the class of queries expressible by second-order formulas of the form 8X 1 8X n ( ~ X) where is first-order, and the variables X i are second order, ranging over relations rather than values.
Reference: [4] <author> A. V. Aho and J. D. Ullman. </author> <title> Universality of data retrieval languages. </title> <booktitle> In 6th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 110-120, </pages> <year> 1979. </year>
Reference-contexts: We can represent the transitive closure using two rules one of which is recursive. tc (X; Y ) e (X; Y ) It is precisely this recursiveness that makes the rules we use more expressive than relational algebra or relation calculus expressions <ref> [4] </ref>. (We shall be more precise about the nature of rules in Chapter 2.) We shall also want to incorporate negation by default in our rules. For example we may use the rule single (X ) person (X ); :married (X) to determine people who are single.
Reference: [5] <author> K. R. Apt and M. Bezem. </author> <title> Acyclic programs. </title> <booktitle> In Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <year> 1990. </year>
Reference-contexts: In order to be able to use well-founded negation in logic programs, a corresponding procedural semantics is necessary. This chapter presents such a procedural semantics. Global SLS-resolution is not effective, as discussed below. However, for certain subclasses of programs, global SLS-resolution is effective. For acyclic programs <ref> [5, 20] </ref> or, more generally, for modularly acyclic programs [97] global SLS-resolution is effective (see Chapter 7). <p> In the absence of loops, some desirable semantic properties hold, and certain program optimizations become possible. We generalize the class of "acyclic" programs <ref> [5, 20] </ref> to what we call "modularly acyclic" programs. <p> The following definition of acyclic programs is from <ref> [5] </ref>. In [20] they are termed !-locally hierarchical programs. <p> Another interesting consequence of a program's acyclicity is that SLDNF-resolution terminates for bounded goals, since all SLD-trees are finite. We shall extend these results (together with some other results) to the class of modularly acyclic programs. The following results are summarized in <ref> [5] </ref>. 120 CHAPTER 7. MODULAR ACYCLICITY Theorem 7.2.1: Let P be an acyclic program. Then 1. T P has a unique fixpoint, M P . 2. M P is the perfect model of P . 3. M P is the unique Herbrand model of comp (P ). 4. <p> MODULAR ACYCLICITY 121 is not an acyclic program, even if there are no cycles in either tc or e. However, if e is a finite acyclic relation, then the above program is modularly acyclic. The reason that the program above is not considered acyclic according to the definitions of <ref> [5] </ref> is that the instantiation tc (a; a) e (a; a); tc (a; a) of the second rule precludes any level mapping, since tc (a; a) would have to be of lower level than itself.
Reference: [6] <author> K. R. Apt, H. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148, </pages> <address> Los Altos, CA, 1988. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Two such classes are stratified programs (Definition 2.1.9) and locally stratified programs (Definition 2.1.10). The stratified class has been treated in <ref> [6, 24, 59, 116] </ref>, and elsewhere. The locally stratified class, defined and studied by Przymusinski [82], is a superset of the class of stratified programs. Przymusinski defined perfect models, and showed that every locally stratified program has a unique perfect model. These classes are discussed further in Section 3.6. <p> For normal programs there has been much recent work on semantics in the presence of negation in the rule bodies. Stratification is a syntactic restriction on programs that prevents a predicate from recursing negatively through itself <ref> [6, 24, 116] </ref>. A stratified program has a well defined semantics given by the Herbrand model constructed by taking least fixpoints at successively higher "levels." However, there are nonstratified programs for which a clear semantics can be discerned.
Reference: [7] <author> K. R. Apt and M. H. Van Emden. </author> <title> Contributions to the theory of logic programming. </title> <journal> JACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference-contexts: Then the bottom-up evaluation of P 0 correctly answers the query Q with respect to the least Herbrand model of P . Proof : By Theorem 6.4.1, the soundness and completeness of SLD-resolution <ref> [7, 28, 45, 60] </ref> with respect to the least Herbrand model, and since MTRR (P ) and MTRR 0 (P ) are equivalent for all EDB and IDB predicates from P . Note that our correctness result doesn't state that the bottom-up evaluation of MTRR (P ) terminates.
Reference: [8] <author> I. Balbin, K. Meenkashi, and K. Ramamohanarao. </author> <title> An efficient labelling algorithm for magic set computation on stratified databases. </title> <type> Technical Report 88/1, </type> <institution> Dept. of Computer Science, University of Melbourne, </institution> <year> 1988. </year>
Reference-contexts: In the absence of negation, bottom-up computation may be made at least as efficient as a top-down approach by the use of an optimization technique known as magic sets [112]. Several authors have considered the problem of extending the magic sets method to stratified programs. The approach of <ref> [8, 9] </ref> is to relabel predicates in a stratified program in such a way that the magic transformation results in a stratified program. This method does not work for all stratified programs, though.
Reference: [9] <author> I. Balbin, G. S. Port, and K. Ramamohanarao. </author> <title> Magic set computation for on stratified databases. </title> <type> Technical Report 87/3, </type> <institution> Dept. of Computer Science, University of Melbourne, </institution> <year> 1987. </year>
Reference-contexts: In the absence of negation, bottom-up computation may be made at least as efficient as a top-down approach by the use of an optimization technique known as magic sets [112]. Several authors have considered the problem of extending the magic sets method to stratified programs. The approach of <ref> [8, 9] </ref> is to relabel predicates in a stratified program in such a way that the magic transformation results in a stratified program. This method does not work for all stratified programs, though.
Reference: [10] <author> I. Balbin, G. S. Port, K. Ramamohanarao, and K. Meenkashi. </author> <title> Efficient bottom-up computation of queries on stratified databases. </title> <journal> Journal of Logic Programming, </journal> <note> 1989. (to appear). </note>
Reference-contexts: This method does not work for all stratified programs, though. More recently, these authors have considered a "structured" bottom-up method that uses control information in order to sequence rule execution <ref> [10] </ref>. The approach of [14] is similar in nature to this structured bottom-up method. The authors perform the magic rewriting, which may result in an unstratified program, and then impose constraints on the order of evaluation of rules, in the form of regular expressions.
Reference: [11] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the Fifth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: For non-recursive queries many well-known optimizations for relational databases can be applied. Several techniques for optimizing recursive queries have been recently proposed, including "magic-sets," "right-linear evaluation," "counting methods" and so on. (See [113] for a comprehensive discussion of these and other strategies.) Magic-sets <ref> [11, 13, 88, 93] </ref> is a general technique that can, in principle, be applied to any (recursive or nonrecursive) deductive database. By passing binding information from the query itself into the rule evaluation, magic sets restricts the computation to tuples that are in some sense relevant. <p> Top-down can beat bottom-up evaluation of the original program because it can restrict the computation to only those tuples relevant to the query. This problem is now well-understood for programs without negation, and several techniques have been proposed [12]. One of these is magic sets <ref> [11, 13, 88] </ref>, which rewrites the program in such a way that the binding information that would have been passed down by a top-down method is incorporated into the bottom-up evaluation. <p> Modular acyclicity is a sufficient condition for the "finite forest" property [64]. As observed in [64] the cost of duplicate detection and elimination can be a large proportion of the total cost of query evaluation. Magic-sets is a widely employed technique for rewriting programs for efficient bottom-up evaluation <ref> [11, 13, 88] </ref>. Rewriting a modularly acyclic program using magic set techniques does not necessarily yield a modularly acyclic program. Hence one may ask whether tuples are generated only finitely often when evaluating the magic-rewritten program.
Reference: [12] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In 1986 ACM-SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 16-52, </pages> <year> 1986. </year> <note> 150 BIBLIOGRAPHY </note>
Reference-contexts: Top-down can beat bottom-up evaluation of the original program because it can restrict the computation to only those tuples relevant to the query. This problem is now well-understood for programs without negation, and several techniques have been proposed <ref> [12] </ref>. One of these is magic sets [11, 13, 88], which rewrites the program in such a way that the binding information that would have been passed down by a top-down method is incorporated into the bottom-up evaluation.
Reference: [13] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <journal> Journal of Logic Programming, </journal> <volume> 10 </volume> <pages> 255-300, </pages> <year> 1991. </year> <note> Preliminary version appeared in the 6th ACM Symposium on Principles of Database Systems, </note> <year> 1987. </year>
Reference-contexts: For non-recursive queries many well-known optimizations for relational databases can be applied. Several techniques for optimizing recursive queries have been recently proposed, including "magic-sets," "right-linear evaluation," "counting methods" and so on. (See [113] for a comprehensive discussion of these and other strategies.) Magic-sets <ref> [11, 13, 88, 93] </ref> is a general technique that can, in principle, be applied to any (recursive or nonrecursive) deductive database. By passing binding information from the query itself into the rule evaluation, magic sets restricts the computation to tuples that are in some sense relevant. <p> Nevertheless, the author believes that programs that cannot be rearranged into permissible versions will be rare in practice. 70 CHAPTER 5. EVALUATION: MEMOING AND MAGIC SETS Passing bindings from left to right is one of many possible "sideways information passing strategies" (sips) that could be used <ref> [13] </ref>. Alternative strategies can be put into our framework by applying Definition 5.2.6 with a refined notion of a rule prefix. <p> Top-down can beat bottom-up evaluation of the original program because it can restrict the computation to only those tuples relevant to the query. This problem is now well-understood for programs without negation, and several techniques have been proposed [12]. One of these is magic sets <ref> [11, 13, 88] </ref>, which rewrites the program in such a way that the binding information that would have been passed down by a top-down method is incorporated into the bottom-up evaluation. <p> Modular acyclicity is a sufficient condition for the "finite forest" property [64]. As observed in [64] the cost of duplicate detection and elimination can be a large proportion of the total cost of query evaluation. Magic-sets is a widely employed technique for rewriting programs for efficient bottom-up evaluation <ref> [11, 13, 88] </ref>. Rewriting a modularly acyclic program using magic set techniques does not necessarily yield a modularly acyclic program. Hence one may ask whether tuples are generated only finitely often when evaluating the magic-rewritten program.
Reference: [14] <author> C. Beeri, R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Magic implementation of stratified logic programs. </title> <type> (manuscript), </type> <year> 1989. </year>
Reference-contexts: This method does not work for all stratified programs, though. More recently, these authors have considered a "structured" bottom-up method that uses control information in order to sequence rule execution [10]. The approach of <ref> [14] </ref> is similar in nature to this structured bottom-up method. The authors perform the magic rewriting, which may result in an unstratified program, and then impose constraints on the order of evaluation of rules, in the form of regular expressions.
Reference: [15] <author> A. Brodsky and Y. Sagiv. </author> <title> Inference of monotonicity constraints in Datalog programs. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1989. </year>
Reference-contexts: When changes to m occur, we have to check only that acyclicity is not violated. In fact, acyclicity is the typical example of a semantic constraint guaranteeing modular stratifiability. Such constraints are similar in nature to "monotonicity constraints" discussed in <ref> [15] </ref>, which were used in the context of testing the termination of Datalog programs without negation. Placing constraints on components enables a modular approach to writing programs. <p> evaluation in some cases, one can use an adaptive duplicate elimination strategy that eliminates duplicates only "when necessary." While we show that both modular stratifiability and modular acyclicity are undecidable properties of programs, there are situations where modular acyclicity can be demonstrated quite easily using the techniques of monotonicity constraints <ref> [15] </ref>. 7.2 Modular Acyclicity We shall generalize the class of acyclic programs to the class of modularly acyclic programs, in the same way that local stratification is generalized to modular stratification in Section 5.2. 118 7.2. <p> The proof of Theorem 7.2.5 does use one acyclicity constraint, and undecidability therefore follows for multiple acyclicity constraints. Modular stratification and modular acyclicity for all EDB's is undecidable even in the function-free case. However, sufficient conditions for modular acyclicity and modular stratification can be established using monotonicity constraints <ref> [15] </ref>. A monotonicity constraint is similar to an acyclicity constraint, except that a partial order on domain values is specified in advance. More than one partial order may be necessary, and inferences about each partial order must be made independently, since they may not be mutually compatible.
Reference: [16] <author> L. Brownston. </author> <title> Programming Expert Systems in OPS5: An Introduction to Rule-based Programming. </title> <publisher> Addison Wesley, </publisher> <year> 1985. </year>
Reference-contexts: It is of no concern if p is later established; no inferences are undone. While first formally studied (in the absence of other features) in [3, 54], the inflationary interpretation of negation has been a feature of rule-based expert systems languages such as OPS5 3 <ref> [16, 29] </ref>. One may argue that the inflationary semantics does not provide a declarative semantics for negation on the grounds that the stage of the iteration is too important in defining a semantics. 2 A model is total if it is 2-valued, i.e., nothing is made undefined.
Reference: [17] <author> F. Bry, </author> <month> Dec. </month> <year> 1989. </year> <type> (personal communication). </type>
Reference-contexts: In [18], Bry outlines a magic sets method for what he calls constructively consistent programs. Unfortunately, the section on magic sets in that paper is very brief. Only after the paper [96] was written did we become aware of the details of Bry's work <ref> [17] </ref>. The class of constructively consistent programs also generalizes the class of stratified programs, and constructively consistent programs have a two-valued semantics. Bry's method handles negative dependencies by storing clauses rather than atoms.
Reference: [18] <author> F. Bry. </author> <title> Logic programming as constructivism: A formalization and its application to databases. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1989. </year>
Reference-contexts: Unfounded sets are defined in Section 3.3. Since the well-founded semantics was presented at a conference [118], several alternative formulations of the well-founded semantics have been developed <ref> [18, 33, 84, 117] </ref>. We believe that this agreement indicates a robustness of the semantics, and provides evidence that it coincides well with intuition, at least in the context of deductive databases. 3.1.4 Inflationary Semantics The inflationary semantics was proposed in [54] and, independently, in [3]. <p> They define a property called weak stratification 1 and demonstrate that the magic rewriting of a stratified program must be weakly stratified. The evaluation of weakly stratified programs is analogous to the evaluation of stratified programs in that one computes an iterated least fixpoint, lowest level first. In <ref> [18] </ref>, Bry outlines a magic sets method for what he calls constructively consistent programs. Unfortunately, the section on magic sets in that paper is very brief. Only after the paper [96] was written did we become aware of the details of Bry's work [17].
Reference: [19] <author> F. Bry. </author> <title> Query evaluaton in recursive databases: Bottom-up and top-down reconciled. </title> <booktitle> In Proceedings of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <year> 1989. </year>
Reference-contexts: This transformation will allow the tail recursive evaluation of the right-recursive portion of the program while the remainder of the program is evaluated according to standard magic set techniques. The advantages of bottom-up methods over top-down methods are discussed in [113]. Bry's translation of SLD-resolution <ref> [19] </ref> explicitly represents the intermediate tuples, and hence does not take advantage of this potential optimization. We extend the magic templates method of Ramakrishnan [88] in which the magic predicates have the same arity as their corresponding IDB predicates, and nonground tuples are allowed.
Reference: [20] <author> L. Cavedon. </author> <title> Continuity, consistency, and completeness properties for logic programs. </title> <booktitle> In Proceedings of the Sixth International Conference on Logic Programming, </booktitle> <year> 1989. </year>
Reference-contexts: In order to be able to use well-founded negation in logic programs, a corresponding procedural semantics is necessary. This chapter presents such a procedural semantics. Global SLS-resolution is not effective, as discussed below. However, for certain subclasses of programs, global SLS-resolution is effective. For acyclic programs <ref> [5, 20] </ref> or, more generally, for modularly acyclic programs [97] global SLS-resolution is effective (see Chapter 7). <p> In the absence of loops, some desirable semantic properties hold, and certain program optimizations become possible. We generalize the class of "acyclic" programs <ref> [5, 20] </ref> to what we call "modularly acyclic" programs. <p> The following definition of acyclic programs is from [5]. In <ref> [20] </ref> they are termed !-locally hierarchical programs.
Reference: [21] <author> D. Chan. </author> <title> Constructive negation based on the completed database. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <year> 1988. </year>
Reference-contexts: Some results in this direction have been presented in [58], and some more recent work has described a process called "constructive negation" in which negative subgoals are used to generate negative bindings <ref> [21, 84] </ref>. Whether such methods will be useful in practice, or whether ground negation is sufficient for most purposes remains to be seen. Restricting programs and goals to be range-restricted (Definition 2.1.8), for example, guarantees freedom from floundering. <p> By placing this predicate to the left of each floundering subgoal, one can prevent floundering without losing any expressive power. An alternative approach, which merits further research, would be to incorporate constructive negation <ref> [21, 84] </ref> into the evaluation mechanisms proposed in this chapter. Nevertheless, the author believes that programs that cannot be rearranged into permissible versions will be rare in practice. 70 CHAPTER 5. <p> CONCLUSIONS a variable. One may like to give the "answer" X 6= a. However the traditional definition of answer substitution does not permit such "nonsubstitutions." Several authors have considered generalizing the notion of answer substitution to incorporate inequality substitutions <ref> [21, 84] </ref>. For function-free programs there is a normal form for such substitutions. In it unclear whether there is an overwhelming need for constructive negation in deductive databases; such a need would have to be demonstrated by empirical evidence. There is scope to generalize bottom-up techniques to handle constructive negation.
Reference: [22] <author> E. P. F. Chan. </author> <title> A possible world semantics for non-Horn databases. </title> <type> Technical Report CS-89-47, </type> <institution> University of Waterloo, </institution> <year> 1989. </year>
Reference-contexts: Disjunctive programs allow information of the form p _ q without knowing p or q. We generalized the semantics in two ways, one "exclusive" in nature and the other "inclusive" in nature. There have been a number of other proposals for semantics in disjunctive databases <ref> [22, 61, 70, 82, 87, 100, 102] </ref>. There remain several problematic aspects to disjunctive reasoning. One issue is complexity. With some exceptions, authors have ignored the complexity of their semantics.
Reference: [23] <author> A. Chandra and D. Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> JCSS, </journal> <volume> 25(1) </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: Theorem 3.9.1 below shows that the data complexity of the well-founded semantics, as defined by Vardi [119], is polynomial. From this standpoint it is competitive with other methods, such as the stratified semantics, whose data complexity has been studied elsewhere <ref> [23, 42, 47, 119] </ref>, and the Fitting model (as remarked below). Definition 3.9.1: The data complexity of an IDB with respect to a fixed ground atomic query Q is defined as the computational complexity of deciding the answer to Q as a function of the size of the EDB. <p> By assuming a distinguished predicate that provides an ordering of database elements, it can be shown that on finite EDB's the inductively definable relations are precisely those computable in polynomial time <ref> [23, 42, 47, 119] </ref>. Schlipf has shown that while equally expressive over infinite Herbrand universes, the translation from Fitting's semantics to the well-founded semantics cannot be performed in a compositional manner [104].
Reference: [24] <author> A. Chandra and D. Harel. </author> <title> Horn clause queries and generalizations. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(1) </volume> <pages> 1-15, </pages> <year> 1985. </year>
Reference-contexts: Two such classes are stratified programs (Definition 2.1.9) and locally stratified programs (Definition 2.1.10). The stratified class has been treated in <ref> [6, 24, 59, 116] </ref>, and elsewhere. The locally stratified class, defined and studied by Przymusinski [82], is a superset of the class of stratified programs. Przymusinski defined perfect models, and showed that every locally stratified program has a unique perfect model. These classes are discussed further in Section 3.6. <p> For normal programs there has been much recent work on semantics in the presence of negation in the rule bodies. Stratification is a syntactic restriction on programs that prevents a predicate from recursing negatively through itself <ref> [6, 24, 116] </ref>. A stratified program has a well defined semantics given by the Herbrand model constructed by taking least fixpoints at successively higher "levels." However, there are nonstratified programs for which a clear semantics can be discerned.
Reference: [25] <author> W. Chen, M. Kifer, and D. S. Warren. HiLog: </author> <title> A first order semantics for higher-order logic programming constructs. </title> <booktitle> In Proc. North American Logic Programming Conference, </booktitle> <year> 1989. </year>
Reference-contexts: The argument of 2 will always be a ground atom. Instances of the meta-predicates described above may be thought of as atoms in the logic called HiLog <ref> [25] </ref>. <p> We use a version of magic templates with supplementary predicates, as in [113]. We also view magic as a meta-predicate in the sense of HiLog <ref> [25] </ref> rather than having a separate magic predicate m p for each p. We consider only Horn programs (with function symbols) in this chapter. Programs with negation can be handled in a similar way using the methods of Chapter 5. <p> We call the the transformation above "magic templates with right-recursion." We denote the result of applying the rewriting to a program P by MTRR (P ). Note that item 2 generates a HiLog rule <ref> [25] </ref>, not a first-order rule. Before we discuss the correctness of this transformation, let us see how it handles the program of Example 6.2.1. Example 6.3.1: We label p as right-recursive. <p> Proof : The proof in [109] goes through even with the restriction that l is acyclic. Chapter 8 Semantics for Second Order Programs A number of "higher order" logics for programming languages and database systems have been recently proposed. One of these proposals is HiLog <ref> [25] </ref>. HiLog provides a declarative framework for incorporating second order features into logic programs. HiLog has also been chosen by the NAIL! group at Stanford University as the basis for its deductive database system. <p> HiLog allows arbitrary terms to be relation names. Hence, in the formal development, there is no distinction between function, constant and predicate symbols. In rules, variables may appear not only in argument positions, but also in predicate names. In <ref> [25] </ref> the semantics of HiLog is defined, and it is shown that unification is decidable and that resolution is both sound and complete for HiLog. <p> A HiLog program is a finite set of HiLog rules. 2 In this chapter, where the meaning is clear, we may omit the word "HiLog" from the above definitions. We use the adjective "normal" to distinguish the concepts of normal programs from those of HiLog programs. Example 8.1.1: <ref> [25] </ref> The following HiLog program implements the Lisp-style maplist operation. maplist (F )([]; []) maplist (F )([XjR]; [Y jZ]) F (X; Y ); maplist (F )(R; Z) One calls the predicate maplist (f ) (for some ground term f ), with lists as arguments. maplist (f ) succeeds, possibly binding variables <p> The HiLog Herbrand universe will always be a countably infinite set. Since we shall be dealing with a 3-valued logic, we shall define an Herbrand interpretation to be a consistent set of ground (HiLog) literals. If neither an atom nor its negation is 1 In <ref> [25] </ref> the restriction n 1 is made, excluding 0-ary predicates (but without losing any expressive power). In this paper, we distinguish between variables appearing in predicate names and those appearing in arguments, and so we shall allow 0-ary predicates.
Reference: [26] <author> P. Cholak. </author> <title> Post correspondence problem and Prolog programs. </title> <type> manuscript, </type> <institution> Dept. of Mathematics, University of Wisconsin, </institution> <year> 1988. </year>
Reference-contexts: Alternatively, we could eliminate duplicates "at join time," when a pass is made through the relation anyway, rather than after each insertion. 122 CHAPTER 7. MODULAR ACYCLICITY 7.2.3 Decidability In the case where function symbols are allowed, testing for local stratification or acyclicity is undecidable <ref> [26] </ref>. In the function-free case, however, it is decidable whether a given program is locally stratified or acyclic. One may ask, in a database context, whether a property holds of a program for all possible relations assignable to EDB predicates.
Reference: [27] <author> K. L. Clark. </author> <title> Negation as failure. </title> <editor> In Gallaire and Minker, editors, </editor> <booktitle> Logic and Databases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: We give a brief overview of previous approaches in this section, and leave the formal definitions until later in this chapter. 3.1.1 Program Completion Semantics The original "program completion" approach is due to Clark <ref> [27] </ref>, and has been discussed in detail by Shepherdson [107, 108], Kunen [56], and Lloyd [60]. The idea behind the completed program is to replace collections of "if " definitions by one "if and only if " definition. <p> Clark introduced the completed program as a way of formalizing the notion that facts not inferable from the rules in the program were to be regarded as false <ref> [27] </ref>. Fitting studied models of the completed program in a 3-valued logic, and showed that all such models were fixed points of a certain operator [34]. <p> THREE-VALUED MODELS OF THE PROGRAM COMPLETION 25 3.4.2 Three-Valued Models The original "logical consequence" approach essentially declares that only conclusions that are logical consequences (in the classical, 2-valued sense) of the completed program should be inferred <ref> [27, 48, 60, 107] </ref>.
Reference: [28] <author> K. L. Clark. </author> <title> Predicate logic as a computational formalism. </title> <type> Technical Report 79/59, </type> <institution> Department of Computing, Imperial College, </institution> <year> 1979. </year>
Reference-contexts: Then the bottom-up evaluation of P 0 correctly answers the query Q with respect to the least Herbrand model of P . Proof : By Theorem 6.4.1, the soundness and completeness of SLD-resolution <ref> [7, 28, 45, 60] </ref> with respect to the least Herbrand model, and since MTRR (P ) and MTRR 0 (P ) are equivalent for all EDB and IDB predicates from P . Note that our correctness result doesn't state that the bottom-up evaluation of MTRR (P ) terminates.
Reference: [29] <author> T. Cooper. </author> <title> Rule-based Programming with OPS5. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year> <note> BIBLIOGRAPHY 151 </note>
Reference-contexts: It is of no concern if p is later established; no inferences are undone. While first formally studied (in the absence of other features) in [3, 54], the inflationary interpretation of negation has been a feature of rule-based expert systems languages such as OPS5 3 <ref> [16, 29] </ref>. One may argue that the inflationary semantics does not provide a declarative semantics for negation on the grounds that the stage of the iteration is too important in defining a semantics. 2 A model is total if it is 2-valued, i.e., nothing is made undefined.
Reference: [30] <author> S. Dietrich and D. S. Warren. </author> <title> Dynamic programming strategies for the evaluation of recursive queries. </title> <type> Technical Report 85/31, </type> <institution> Computer Science Department, State University of New York at Stony Brook, </institution> <year> 1985. </year>
Reference-contexts: A way of pruning infinite branches is discussed in the next section. 5.3.2 Top-Down with Memoing Despite the soundness and completeness demonstrated in the previous section, global SLS-resolution may get lost down an infinite positive branch and hence not terminate. Several authors <ref> [30, 120, 121] </ref> have considered this problem in the context of Horn programs, and have proposed a form of memoing in which a positive literal is not "admissible" for selection if it is an instance of one of its ancestors.
Reference: [31] <author> R. A. DiPaola. </author> <title> The recursive unsolvability of the decision problem for the class of definite formulas. </title> <journal> JACM, </journal> <volume> 16(2):p.324, </volume> <year> 1969. </year>
Reference-contexts: For example if P is the range-restricted program X (a) X (X); :X (a) and Q contains the single fact r (r), then P [ Q has no stable model even though each of P and Q have stable models. Since domain independence is undecidable for normal programs <ref> [31] </ref> it follows that preservation under extensions for HiLog programs is also undecidable.
Reference: [32] <author> M. A. E. Dummett. </author> <title> Elements of Intuitionism. </title> <publisher> Clarendon Press, Oxford, </publisher> <year> 1977. </year>
Reference-contexts: DECLARATIVE SEMANTICS However, factoring possibilities in the given program do not always carry over to the completed program, and a _ :a does not simplify to true in either 3-valued logic [34, 56] or intuitionistic logic <ref> [32] </ref>. Thus caution is needed to keep a coherent system.
Reference: [33] <author> Ph. M. Dung and K. Kanchanasut. </author> <title> A natural semantics for logic programs with negation. </title> <type> Technical report, </type> <institution> Asian Institute of Technology, </institution> <address> Bankok 10501, Thailand, </address> <year> 1989. </year> <type> (manuscript). </type>
Reference-contexts: Unfounded sets are defined in Section 3.3. Since the well-founded semantics was presented at a conference [118], several alternative formulations of the well-founded semantics have been developed <ref> [18, 33, 84, 117] </ref>. We believe that this agreement indicates a robustness of the semantics, and provides evidence that it coincides well with intuition, at least in the context of deductive databases. 3.1.4 Inflationary Semantics The inflationary semantics was proposed in [54] and, independently, in [3].
Reference: [34] <author> M. </author> <title> Fitting. A Kripke-Kleene semantics for logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(4) </volume> <pages> 295-312, </pages> <year> 1985. </year>
Reference-contexts: For some programs the completed program is inconsistent; for some others, the completed program is consistent but gives too weak a semantics for database applications. We shall illustrate these claims with examples in Section 3.7. Fitting <ref> [34] </ref> and Kunen [56] gave markedly different, more uniform, semantics by interpreting the completed program in a 3-valued constructive logic, elegantly eliminating some difficulties of the Clark program completion approach. <p> Hence I 0 is a total model. Our notion of partial model is not the same as the natural notions of models used in 3-valued logics, such as in the approaches of Fitting <ref> [34] </ref> and Kunen [56]. Nevertheless, the well-founded partial model we construct will also be a model in Fitting's 3-valued sense. <p> As described more formally later, the well-founded semantics uses conditions (1) and (2) to draw negative conclusions. Essentially, it simultaneously infers all atoms in A to be false. By contrast, the semantics of <ref> [34] </ref> uses only condition (1) to draw negative conclusions. The closed sets of Ross and Topor [100] were defined only with condition (2). <p> Fitting studied models of the completed program in a 3-valued logic, and showed that all such models were fixed points of a certain operator <ref> [34] </ref>. <p> However, because the truth of each literal is based on traditional 2-valued logic, we call this the 2-valued program completion (2PC) interpretation. The 3-valued interpretations were made explicit by Fitting <ref> [34] </ref> and Kunen [56], who also used 3-valued logic to evaluate formulas. Whereas (p _ :p) must be true in 2-valued logic, in 3-valued logic it may also be ?. <p> Their common part (intersection) is f:p; qg. However, here the 2PC interpretation is not a 3-valued model . 2 One principal result in <ref> [34] </ref> is that the completion of every program has a (unique) minimum 3-valued Herbrand model. Fitting suggests that this model be taken for the semantics of the program, and hereafter we call it the Fitting model . <p> To any partial interpretation I there corresponds the obvious 3-valued interpretation in which atoms missing from I are assigned the truth value ?. In this setting, our partial interpretations are the same as Fitting's basic sets <ref> [34] </ref>. <p> Note that N P is the portion of U P produced by condition (1) of Definition 3.3.1. 2 Fitting also constructs 3-valued models with a fixed point operator <ref> [34] </ref>. For positive inferences, T P is as in Definition 3.3.3. For negative inferences he uses (in effect) the transformation N P (I ) defined above. <p> In general, though, programs may have no stable model at all. 40 CHAPTER 3. DECLARATIVE SEMANTICS However, factoring possibilities in the given program do not always carry over to the completed program, and a _ :a does not simplify to true in either 3-valued logic <ref> [34, 56] </ref> or intuitionistic logic [32]. Thus caution is needed to keep a coherent system. <p> Membership in M P is decidable. Here, T P is the two-valued immediate consequence operator defined in [60]. N P is the three valued immediate consequence operator of Fitting <ref> [34] </ref> (See Definition 3.4.5). Our main semantic results are summarized in the following theorem. Theorem 7.2.2: Let P be a modularly acyclic program. Then 1. T P has a unique fixpoint, M P . 2. M P is the well-founded model of P , which is two-valued. 3.
Reference: [35] <author> S. Ganguly, S. Greco, and C. Zaniolo. </author> <title> Minimum and maximum predicates in deductive databases. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference-contexts: Providing a sound semantic basis for declarative systems with aggregation is an important issue. Recursion through aggregation causes similar semantic problems to recursion through negation. Some results in this direction have been reported in <ref> [35, 50, 99, 110] </ref>. 9.2.2 Disjunctive Programs In [95] we generalize the well-founded semantics to disjunctive programs. Disjunctive programs allow information of the form p _ q without knowing p or q. We generalized the semantics in two ways, one "exclusive" in nature and the other "inclusive" in nature.
Reference: [36] <author> M. Gelfond. </author> <title> On stratified autoepistemic theories. </title> <booktitle> In Proc. AAAI, </booktitle> <year> 1987. </year>
Reference-contexts: Recent experience has cast doubt on this attitude (see [37] for discussion), and spurred the search for further improvements in the definition of the "canonical model." Gelfond and Lifschitz propose an elegant definition of a stable model that is closely related to our work [37]. Drawing on ideas in <ref> [36] </ref>, they define a "stable model" as one that is able to reproduce itself in a certain sense; a program may have zero, one, or many stable models. In 16 CHAPTER 3. <p> The resulting 3-valued interpretation is recursively enumerable, but may not be a 3-valued model. Kunen's main theorem states that this interpretation characterizes the 3-valued logical consequences of the completed program. 3.5 Stable Models Gelfond introduced an approach to negation through stable models <ref> [36] </ref>, and motivated it by appealing to autoepistemic logic, as developed by Moore [71]. The theory has been further developed by Gelfond and Lifschitz [37], and also by Marek and Truszczynski [65, 66]. In this section we follow the definition of [37], which defines stability without reference to autoepistemic logic.
Reference: [37] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <year> 1988. </year>
Reference-contexts: Thus failure to have a perfect model was thought to indicate a flaw in the program rather than in the definition of perfect models. Recent experience has cast doubt on this attitude (see <ref> [37] </ref> for discussion), and spurred the search for further improvements in the definition of the "canonical model." Gelfond and Lifschitz propose an elegant definition of a stable model that is closely related to our work [37]. <p> Recent experience has cast doubt on this attitude (see <ref> [37] </ref> for discussion), and spurred the search for further improvements in the definition of the "canonical model." Gelfond and Lifschitz propose an elegant definition of a stable model that is closely related to our work [37]. Drawing on ideas in [36], they define a "stable model" as one that is able to reproduce itself in a certain sense; a program may have zero, one, or many stable models. In 16 CHAPTER 3. <p> The theory has been further developed by Gelfond and Lifschitz <ref> [37] </ref>, and also by Marek and Truszczynski [65, 66]. In this section we follow the definition of [37], which defines stability without reference to autoepistemic logic. We show that if a program has a total well-founded model, that model is the unique stable model. <p> The theory has been further developed by Gelfond and Lifschitz <ref> [37] </ref>, and also by Marek and Truszczynski [65, 66]. In this section we follow the definition of [37], which defines stability without reference to autoepistemic logic. We show that if a program has a total well-founded model, that model is the unique stable model. We also discuss two programs which do not have total well-founded models but do have unique stable models. <p> We also discuss two programs which do not have total well-founded models but do have unique stable models. Whether inferring (or not inferring) the truth of these extra literals is "a bug or a feature" of either approach we leave for the reader's judgement. Gelfond and Lifschitz <ref> [37] </ref> define a stable model to be one that reproduces itself in a certain three stage transformation, which we call the stability transformation. If a program has only one stable model, that is called its unique stable model. Stable models refer to 2-valued logic. <p> As another motivational example, we consider a program that is not locally stratified, as defined in Section 3.6, yet has a well-founded model when the EDB relation is acyclic. Example 3.7.3: This example is essentially the same as one discussed by Gelfond and Lifs-chitz <ref> [37] </ref>, and is one of the examples that led to the formulation of well-founded semantics, as well as the stable model semantics. <p> Then R M (F ), as given in Example 5.2.3 is locally stratified, and so P is modularly stratified. Note that P itself is not locally stratified. 2 Our definition of reduction also bears some similarity to the stability tranformation of Gelfond and Lifschitz <ref> [37] </ref> (see Definition 3.5.1). If the well-founded model for a component is total, then that model is also its unique stable model. <p> This observation led to the development of the well-founded semantics [118] and the stable-model semantics <ref> [37] </ref> which provide semantics for programs that are not necessarily stratified. (See Chapter 3.) 126 8.1. HILOG 127 In this chapter we generalize the well-founded semantics and stable model semantics to HiLog programs that can have negation in the rule bodies.
Reference: [38] <author> M. Gelfond and V. Lifschitz. </author> <title> Logic programs with classical negation. </title> <type> manuscript, </type> <month> September </month> <year> 1989. </year>
Reference-contexts: As in relational algebra or calculus, one assumes that one has complete information, and that an atom is false unless it is derivable in some sense. Several authors have considered adding explicit negation to programs <ref> [38] </ref>. The idea is to allow explicit negative information to be represented in addition to information inferred false by default.
Reference: [39] <author> M. R. Genesereth and M. L. Ginsberg. </author> <title> Logic programming. </title> <journal> C. ACM, </journal> <volume> 28 </volume> <pages> 933-941, </pages> <year> 1985. </year>
Reference-contexts: Roughly, declarativeness means that the person writing in that language specifies "what to compute" and not "how to compute it." For discussion of the relative merits of declarative and procedural (or imperative) systems, see <ref> [1, 39, 40, 55, 69, 113] </ref>. In principle, declarativeness requires less of a user or programmer, and can thus be the basis of a system in which writing queries can be significantly less time-consuming than with a procedural language.
Reference: [40] <author> M. R. Genesereth and N. J. Nilsson. </author> <booktitle> Logical Foundations of Artificial Intelligence. </booktitle> <publisher> Morgan Kaufman, </publisher> <year> 1987. </year>
Reference-contexts: Roughly, declarativeness means that the person writing in that language specifies "what to compute" and not "how to compute it." For discussion of the relative merits of declarative and procedural (or imperative) systems, see <ref> [1, 39, 40, 55, 69, 113] </ref>. In principle, declarativeness requires less of a user or programmer, and can thus be the basis of a system in which writing queries can be significantly less time-consuming than with a procedural language.
Reference: [41] <author> S. A. Greibach. </author> <title> A new normal form theorem for context-free phrase structure grammars. </title> <journal> J.ACM, </journal> <volume> 12(1) </volume> <pages> 42-52, </pages> <year> 1965. </year>
Reference-contexts: Proof : The proof is similar to that of Theorem 7.2.4, except some additional details are needed to make the result of the construction modularly acyclic. Every context-free language not containing the empty string can be generated by a context-free grammar in Greibach normal form <ref> [41] </ref>. If G is a context-free grammar in Greibach normal form, then Q (G) has the property that every rule (apart from the one with head matching the query) has a subgoal of the form l (I 0 ; A j ; I 1 ).
Reference: [42] <author> Y. Gurevich and S. Shelah. </author> <title> Fixed-point extensions of first order logic. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 32 </volume> <pages> 265-280, </pages> <year> 1986. </year>
Reference-contexts: Theorem 3.9.1 below shows that the data complexity of the well-founded semantics, as defined by Vardi [119], is polynomial. From this standpoint it is competitive with other methods, such as the stratified semantics, whose data complexity has been studied elsewhere <ref> [23, 42, 47, 119] </ref>, and the Fitting model (as remarked below). Definition 3.9.1: The data complexity of an IDB with respect to a fixed ground atomic query Q is defined as the computational complexity of deciding the answer to Q as a function of the size of the EDB. <p> By assuming a distinguished predicate that provides an ordering of database elements, it can be shown that on finite EDB's the inductively definable relations are precisely those computable in polynomial time <ref> [23, 42, 47, 119] </ref>. Schlipf has shown that while equally expressive over infinite Herbrand universes, the translation from Fitting's semantics to the well-founded semantics cannot be performed in a compositional manner [104].
Reference: [43] <author> S. Hanks and D. McDermott. </author> <title> Default reasoning, nonmonotonic logics, and the frame problem. </title> <booktitle> In AAAI Conference, </booktitle> <pages> pages 328-333, </pages> <year> 1986. </year>
Reference-contexts: We choose to ignore this second condition here. Also, the property of being a perfect model for a locally stratified program is independent of the particular level mapping used. 3.7. MOTIVATING EXAMPLES 33 Example 3.7.1: This example is abstracted from the "Yale shootout" example due to Hanks and McDermott <ref> [43] </ref>. <p> (1); shoots (1); noise (1) However, an alternative minimal model exists: loaded (0); shoots (0); noise (0); :loaded (1); shoots (1); :noise (1) Since noise (1) is not true in all minimal models, the circumscription approach does not allow it to be concluded, which was a main point made in <ref> [43] </ref>. However, the well-founded model is the intended one. To compare with other approaches: The 2PC model and Fitting model are also the intended model here. The program is stratified, so the stratified semantics agrees with the well-founded semantics.
Reference: [44] <author> A. Heuer and P. Sander. </author> <title> Semantics and evaluation of rules over complex objects. </title> <booktitle> In Proceedings of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <year> 1989. </year>
Reference-contexts: In languages such as HiLog it is possible to define parameterized procedures, or in the object-oriented terminology, "methods." A promising approach is the integration of some object oriented features in a deductive database framework. Various such attempts have been reported in <ref> [2, 44, 62, 123] </ref>. A successful integration would provide mechanisms for encapsulation, inheritance, complex objects and other object-oriented concepts while retaining the declarativeness and formal basis of deductive databases.
Reference: [45] <author> R. Hill. </author> <title> Lush resolution and its completeness. </title> <type> Technical Report DCL Memo 78, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <year> 1974. </year>
Reference-contexts: Then the bottom-up evaluation of P 0 correctly answers the query Q with respect to the least Herbrand model of P . Proof : By Theorem 6.4.1, the soundness and completeness of SLD-resolution <ref> [7, 28, 45, 60] </ref> with respect to the least Herbrand model, and since MTRR (P ) and MTRR 0 (P ) are equivalent for all EDB and IDB predicates from P . Note that our correctness result doesn't state that the bottom-up evaluation of MTRR (P ) terminates.
Reference: [46] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to automata theory, languages, and computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year> <note> 152 BIBLIOGRAPHY </note>
Reference-contexts: Let L be the context-free language generating the invalid computations of a Turing machine M (minus the empty string) constructed using standard techniques as in <ref> [46] </ref>. Then LL L if and only if L (M ) = ;, since if there were something in L (M ) then the corresponding valid computation could be split into two nonempty invalid computations, implying LL 6 L.
Reference: [47] <author> N. Immerman. </author> <title> Relational queries computable in polynomial time. </title> <journal> Information and Control, </journal> <volume> 68(1) </volume> <pages> 86-104, </pages> <year> 1986. </year>
Reference-contexts: Theorem 3.9.1 below shows that the data complexity of the well-founded semantics, as defined by Vardi [119], is polynomial. From this standpoint it is competitive with other methods, such as the stratified semantics, whose data complexity has been studied elsewhere <ref> [23, 42, 47, 119] </ref>, and the Fitting model (as remarked below). Definition 3.9.1: The data complexity of an IDB with respect to a fixed ground atomic query Q is defined as the computational complexity of deciding the answer to Q as a function of the size of the EDB. <p> By assuming a distinguished predicate that provides an ordering of database elements, it can be shown that on finite EDB's the inductively definable relations are precisely those computable in polynomial time <ref> [23, 42, 47, 119] </ref>. Schlipf has shown that while equally expressive over infinite Herbrand universes, the translation from Fitting's semantics to the well-founded semantics cannot be performed in a compositional manner [104].
Reference: [48] <author> J. Jaffar, J.-L. Lassez, and J. Lloyd. </author> <title> Completeness of the negation-as-failure rule. </title> <booktitle> In Int'l Joint Conf. on Artificial Intelligence, </booktitle> <pages> pages 500-506, </pages> <year> 1983. </year>
Reference-contexts: Jaffar, Lassez and Lloyd showed that SLDNF was complete (in the same sense) for Horn programs with non-floundering 1 queries consisting of a conjunction of positive and/or negative literals <ref> [48] </ref>. SLDNF-resolution was further investigated for normal logic programs by Lloyd [60] (who coined the term SLDNF-resolution), Shepherdson [107, 108] (q.v. for further bibliography), and others. <p> THREE-VALUED MODELS OF THE PROGRAM COMPLETION 25 3.4.2 Three-Valued Models The original "logical consequence" approach essentially declares that only conclusions that are logical consequences (in the classical, 2-valued sense) of the completed program should be inferred <ref> [27, 48, 60, 107] </ref>. <p> This method is sound with respect to the completion of the program, and is complete for Horn programs (possibly with negative subgoals in the goal only) <ref> [48] </ref>. Based on the perfect model approach, Przymusinski introduced SLS-resolution [85]. SLS-resolution is a top-down procedural semantics that uses an extension of SLD-resolution to answer queries. Przymusinski showed that for stratified programs with non-floundering queries, SLS-resolution is sound and complete with respect to the unique perfect model of the program.
Reference: [49] <author> D. B. Kemp, K. Ramamohanarao, and Z. Somogyi. Right-, </author> <title> left- and multi-linear rule transformations that maintain context information. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1990. </year>
Reference-contexts: The idea of "carrying around" a pointer from a subquery to the "top query" was introduced in a simpler form in <ref> [49] </ref> and (independently) in [73] for right-linear programs with multiple bindings. While our transformation may sometimes do worse than magic templates, we can show that it does no worse for the class of nonrepeating programs. 114 CHAPTER 6.
Reference: [50] <author> D. B. Kemp and P. J. Stuckey. </author> <title> Semantics of logic programs with aggregates. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <year> 1991. </year>
Reference-contexts: Providing a sound semantic basis for declarative systems with aggregation is an important issue. Recursion through aggregation causes similar semantic problems to recursion through negation. Some results in this direction have been reported in <ref> [35, 50, 99, 110] </ref>. 9.2.2 Disjunctive Programs In [95] we generalize the well-founded semantics to disjunctive programs. Disjunctive programs allow information of the form p _ q without knowing p or q. We generalized the semantics in two ways, one "exclusive" in nature and the other "inclusive" in nature.
Reference: [51] <author> D. B. Kemp and R. W. Topor. </author> <title> Completeness of a top down query evaluation procedure for stratified databases. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <year> 1988. </year>
Reference-contexts: An alternative justification is that SLS-resolution is effective for a limited class of programs, and for a less limited class (say, the class of stratified function-free programs) SLS-resolution can be extended with memoing features to make it effective <ref> [51, 106] </ref>. (See Chapter 5 for further discussion of memoing.) The main drawback of SLDNF-resolution is that it is too weak. <p> In the absence of function symbols, the Herbrand Base is finite, and so effective procedures exist. 3 For modularly stratified function-free programs global SLS-resolution may be made effective by using the memoing techniques of <ref> [51, 106] </ref> to prune loops (see Chapter 5). There are three sources of non-effectiveness in global SLS-resolution: 1. Infinite branches of an SLP-tree are treated as failed. 2. <p> This issue is related to the notion of compositionality (see Section 3.8). Kemp and Topor, and Seki and Itoh have proposed (similar) extensions of the QSQR/SLD top-down query evaluation procedure of Vieille [120, 121] from Horn programs to the class of stratified programs <ref> [51, 106] </ref>. We further generalize their methods, called QSQR/SLS-resolution in [51], to the class of modularly stratified programs. In the absence of negation, bottom-up computation may be made at least as efficient as a top-down approach by the use of an optimization technique known as magic sets [112]. <p> Kemp and Topor, and Seki and Itoh have proposed (similar) extensions of the QSQR/SLD top-down query evaluation procedure of Vieille [120, 121] from Horn programs to the class of stratified programs [51, 106]. We further generalize their methods, called QSQR/SLS-resolution in <ref> [51] </ref>, to the class of modularly stratified programs. In the absence of negation, bottom-up computation may be made at least as efficient as a top-down approach by the use of an optimization technique known as magic sets [112]. <p> Several authors [30, 120, 121] have considered this problem in the context of Horn programs, and have proposed a form of memoing in which a positive literal is not "admissible" for selection if it is an instance of one of its ancestors. Kemp and Topor <ref> [51] </ref> and, independently, Seki and Itoh [106] have generalized these proposals to the class of stratified programs. We extend these methods to a larger class of programs, namely those programs that have finite negation trees, and still retain soundness, completeness and termination properties. <p> In particular, this method can be extended to permissible programs. We now present our extension of the QSQR/SLS-procedure. While our method is similar to <ref> [51] </ref>, there are several differences that we shall explain after giving the definitions. Our version of the QSQR/SLS procedure, given in Algorithm 5.3.1, is presented in such a way that the comparison with bottom-up evaluation will be clearer later on. <p> In the query evaluation procedure described below we will "memo" those facts that we have already derived so that we can re-use them in other parts of the computation. We memo all IDB predicates; in the terminology of <ref> [51] </ref>, the set of "r-predicates" is the set of all IDB predicates. 74 CHAPTER 5. <p> We omit the details here. We now explain the major differences between Algorithm 5.3.1 and the algorithms presented in <ref> [51] </ref> and [106]. The first difference is in how the lemmas are established. In [51], "proof-segments" of SLD-type trees are used rather than derivation trees. <p> We omit the details here. We now explain the major differences between Algorithm 5.3.1 and the algorithms presented in <ref> [51] </ref> and [106]. The first difference is in how the lemmas are established. In [51], "proof-segments" of SLD-type trees are used rather than derivation trees. In [106] they are called "subrefutations." The definition of proof segments is complicated by the fact that subsidiary information about other subgoals is embedded in the trees. <p> Our dynamic approach has the advantage that only those subgoals that do depend negatively on lower-level subgoals are suspended, while other subgoals can be expanded during that time. Unlike <ref> [51] </ref> and [106], our method distinguishes between EDB subgoals and IDB subgoals, using simple look-ups for EDB subgoals rather than performing resolution on them. A more technical difference occurs in step 3 of our algorithm. In [51] and other similar work on top-down methods with memoing [105, 106] it is possible <p> Unlike <ref> [51] </ref> and [106], our method distinguishes between EDB subgoals and IDB subgoals, using simple look-ups for EDB subgoals rather than performing resolution on them. A more technical difference occurs in step 3 of our algorithm. In [51] and other similar work on top-down methods with memoing [105, 106] it is possible to generate a subquery at a certain point, and at a later point in the same round generate a more general subquery, in which computation is repeated. <p> Our method can handle all programs with finite negation trees, rather than only stratified programs. In fact, the proofs of soundness, completeness and termination from <ref> [51] </ref> extend in a straightforward way to programs with finite negation trees. The essential part of the proofs in [51] is an inductive argument on the number of levels guaranteed by the stratification. <p> Our method can handle all programs with finite negation trees, rather than only stratified programs. In fact, the proofs of soundness, completeness and termination from <ref> [51] </ref> extend in a straightforward way to programs with finite negation trees. The essential part of the proofs in [51] is an inductive argument on the number of levels guaranteed by the stratification. The only change to the proofs to reach the larger class is to proceed by induction on the height of the negation tree. If the negation tree is finite, then the proofs succeed. <p> If the negation tree is finite, then the proofs succeed. The differences outined above do not affect correctness; they show that in some cases the method proposed in <ref> [51] </ref> performs more (redundant) computation than ours. Theorem 5.3.3: (Correctness) Let P be a range-restricted nonfloundering program having finite negation trees. Let L be a literal, (ground if negative), and let the query be ?-L. <p> Then Algorithm 5.3.1 terminates such that for every ground substitution for L: L belongs to the (total) well-founded model for P if and only if L is output. Proof : The proof is similar to that in <ref> [51] </ref>, with a proof by induction on the finite number of levels guaranteed by the finite negation tree, rather than on the levels generated by a stratification. The comparison is with global SLS-resolution rather than with SLS-resolution of [85] since the latter is well-defined only for locally stratified programs.
Reference: [52] <author> J. M. Kerisit and J. M. Pugin. </author> <title> Efficient query answering on stratified databases. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <year> 1988. </year>
Reference-contexts: These constraints ensure that a subgoal is "fully evaluated" before a predicate depending negatively on that subgoal is considered. Kerisit and Pugin also consider extending magic sets to programs with stratified negation <ref> [52] </ref>. They define a property called weak stratification 1 and demonstrate that the magic rewriting of a stratified program must be weakly stratified. The evaluation of weakly stratified programs is analogous to the evaluation of stratified programs in that one computes an iterated least fixpoint, lowest level first.
Reference: [53] <author> P. G. Kolaitis. </author> <title> The expressive power of stratified programs. </title> <journal> Information and Computation, </journal> <volume> 90 </volume> <pages> 50-66, </pages> <year> 1991. </year>
Reference-contexts: Interestingly, this program turns out to be closely related to a game described by Kolaitis, and used to prove that there are queries in fixpoint logic that are not expressible by function-free stratified programs <ref> [53] </ref>. <p> We say that the query Q is expressible in a semantics S if the relation Q (D) is definable in S. The following theorem summarizes results from <ref> [3, 53, 54, 104] </ref>. 8 Here, "" denotes proper containment. Also, 1 1 denotes the class of queries expressible by second-order formulas of the form 8X 1 8X n ( ~ X) where is first-order, and the variables X i are second order, ranging over relations rather than values. <p> P is a game-playing program <ref> [53] </ref> in which a position X is "winning" [w (X)] if there is a move from X to a position Y [m (X; Y )] and Y is a losing position [:w (Y )]. (This is the same program as in Example 3.7.3.) P is not stratified or even locally stratified. <p> In fact Kolaitis <ref> [53] </ref> has shown that no stratified function-free program can express the intended semantics of P . The intuition behind this expressiveness result is that stratified programs have a fixed number of strata through which one can recurse through negation.
Reference: [54] <author> P. G. Kolaitis and C. H. Papadimitriou. </author> <title> Why not negation by fixpoint? In ACM Symposium on Principles of Database Systems, </title> <year> 1988. </year>
Reference-contexts: We believe that this agreement indicates a robustness of the semantics, and provides evidence that it coincides well with intuition, at least in the context of deductive databases. 3.1.4 Inflationary Semantics The inflationary semantics was proposed in <ref> [54] </ref> and, independently, in [3]. The idea behind the inflationary semantics is to treat negation as expressing "not currently true." If p is an atom, then :p is considered satisfied if, at the current stage of the iteration, p has not been derived. <p> It is of no concern if p is later established; no inferences are undone. While first formally studied (in the absence of other features) in <ref> [3, 54] </ref>, the inflationary interpretation of negation has been a feature of rule-based expert systems languages such as OPS5 3 [16, 29]. <p> We say that the query Q is expressible in a semantics S if the relation Q (D) is definable in S. The following theorem summarizes results from <ref> [3, 53, 54, 104] </ref>. 8 Here, "" denotes proper containment. Also, 1 1 denotes the class of queries expressible by second-order formulas of the form 8X 1 8X n ( ~ X) where is first-order, and the variables X i are second order, ranging over relations rather than values.
Reference: [55] <author> R. A. Kowalski. </author> <title> Algorithm = Logic + Control. </title> <journal> C.ACM, </journal> <volume> 22(7) </volume> <pages> 424-436, </pages> <year> 1979. </year>
Reference-contexts: Roughly, declarativeness means that the person writing in that language specifies "what to compute" and not "how to compute it." For discussion of the relative merits of declarative and procedural (or imperative) systems, see <ref> [1, 39, 40, 55, 69, 113] </ref>. In principle, declarativeness requires less of a user or programmer, and can thus be the basis of a system in which writing queries can be significantly less time-consuming than with a procedural language.
Reference: [56] <author> K. Kunen. </author> <title> Negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(4) </volume> <pages> 289-308, </pages> <year> 1987. </year>
Reference-contexts: We give a brief overview of previous approaches in this section, and leave the formal definitions until later in this chapter. 3.1.1 Program Completion Semantics The original "program completion" approach is due to Clark [27], and has been discussed in detail by Shepherdson [107, 108], Kunen <ref> [56] </ref>, and Lloyd [60]. The idea behind the completed program is to replace collections of "if " definitions by one "if and only if " definition. The completed program (or completed database) is not a normal program, but a conjunction of "if and only if " formulas. <p> For some programs the completed program is inconsistent; for some others, the completed program is consistent but gives too weak a semantics for database applications. We shall illustrate these claims with examples in Section 3.7. Fitting [34] and Kunen <ref> [56] </ref> gave markedly different, more uniform, semantics by interpreting the completed program in a 3-valued constructive logic, elegantly eliminating some difficulties of the Clark program completion approach. The third truth value, ?, connotes undefined truth value and is "less information than" both true and false, which are incomparable. <p> Hence I 0 is a total model. Our notion of partial model is not the same as the natural notions of models used in 3-valued logics, such as in the approaches of Fitting [34] and Kunen <ref> [56] </ref>. Nevertheless, the well-founded partial model we construct will also be a model in Fitting's 3-valued sense. <p> However, because the truth of each literal is based on traditional 2-valued logic, we call this the 2-valued program completion (2PC) interpretation. The 3-valued interpretations were made explicit by Fitting [34] and Kunen <ref> [56] </ref>, who also used 3-valued logic to evaluate formulas. Whereas (p _ :p) must be true in 2-valued logic, in 3-valued logic it may also be ?. <p> Kunen describes a variant that differs from Fitting's in two important ways: (1) the iteration is always stopped at !, and (2) the Herbrand universe is defined with respect to a language with an infinite set of function symbols, which properly includes those that occur in the program <ref> [56] </ref>. The resulting 3-valued interpretation is recursively enumerable, but may not be a 3-valued model. <p> In general, though, programs may have no stable model at all. 40 CHAPTER 3. DECLARATIVE SEMANTICS However, factoring possibilities in the given program do not always carry over to the completed program, and a _ :a does not simplify to true in either 3-valued logic <ref> [34, 56] </ref> or intuitionistic logic [32]. Thus caution is needed to keep a coherent system.
Reference: [57] <author> K. Kunen. </author> <title> Some remarks on the completed database. </title> <type> Technical Report 775, </type> <institution> Univ. of Wisconsin, Madison, WI 53706, </institution> <year> 1988. </year> <booktitle> (Abstract appeared in 5th Int'l Conf. Symp. on Logic Programming, </booktitle> <address> Seattle, </address> <month> Aug. </month> <year> 1988). </year>
Reference-contexts: well-founded model, which is the unique stable model. 2 In fact, Kunen has recently shown that in his 3-valued logical consequence semantics, a "strict" logic program without function symbols cannot define a predicate that is true in the transitive closure of a relation, false in its complement, and nowhere undefined <ref> [57] </ref>. Informally, a "strict" program is one in which the dependence of one predicate on another (or itself ) is either through an even number of negations or through an odd number, but not both.
Reference: [58] <author> J.-L. Lassez and K. Marriott. </author> <title> Explicit representation of terms defined by counter examples. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 3 </volume> <pages> 301-317, </pages> <year> 1987. </year>
Reference-contexts: Some results in this direction have been presented in <ref> [58] </ref>, and some more recent work has described a process called "constructive negation" in which negative subgoals are used to generate negative bindings [21, 84]. Whether such methods will be useful in practice, or whether ground negation is sufficient for most purposes remains to be seen.
Reference: [59] <author> V. Lifschitz. </author> <title> On the declarative semantics of logic programs with negation. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 177-192, </pages> <address> Los Altos, CA, 1988. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Two such classes are stratified programs (Definition 2.1.9) and locally stratified programs (Definition 2.1.10). The stratified class has been treated in <ref> [6, 24, 59, 116] </ref>, and elsewhere. The locally stratified class, defined and studied by Przymusinski [82], is a superset of the class of stratified programs. Przymusinski defined perfect models, and showed that every locally stratified program has a unique perfect model. These classes are discussed further in Section 3.6.
Reference: [60] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> New York, 2nd edition, </address> <year> 1987. </year>
Reference-contexts: Chapter 2 Preliminaries In this chapter we present some of the basic terminology used throughout this thesis. We assume some familiarity with first order logic, relational algebra, and relational calculus. Most of the terminology used here is borrowed from Lloyd <ref> [60] </ref> and Ullman [113]. 2.1 Terminology In this section we introduce our notation and basic definitions, and describe the class of normal programs that we shall be considering in this thesis. <p> Such programs have also been called allowed <ref> [60] </ref> or safe [113]. 2 Definition 2.1.9: A program is stratified if there is an assignment of ordinal levels to predicates such that whenever a predicate appears negatively in the body of a rule, the predicate in the head of that rule is of strictly higher level, and whenever a predicate <p> We give a brief overview of previous approaches in this section, and leave the formal definitions until later in this chapter. 3.1.1 Program Completion Semantics The original "program completion" approach is due to Clark [27], and has been discussed in detail by Shepherdson [107, 108], Kunen [56], and Lloyd <ref> [60] </ref>. The idea behind the completed program is to replace collections of "if " definitions by one "if and only if " definition. The completed program (or completed database) is not a normal program, but a conjunction of "if and only if " formulas. <p> Jaffar, Lassez and Lloyd showed that SLDNF was complete (in the same sense) for Horn programs with non-floundering 1 queries consisting of a conjunction of positive and/or negative literals [48]. SLDNF-resolution was further investigated for normal logic programs by Lloyd <ref> [60] </ref> (who coined the term SLDNF-resolution), Shepherdson [107, 108] (q.v. for further bibliography), and others. For some programs the completed program is inconsistent; for some others, the completed program is consistent but gives too weak a semantics for database applications. We shall illustrate these claims with examples in Section 3.7. <p> Fitting 1 A top-down method flounders if it encounters a negative subgoal containing an unbound variable. It is not sound to recursively expand a negative subgoal containing a variable since the quantification of the variable changes from universal to existential. See <ref> [60] </ref> for a discussion. 14 3.1. APPROACHES TO SEMANTICS 15 showed that the completion of every program has a (unique) minimum 3-valued model, and suggested that this model be taken for the semantics of the program. <p> THREE-VALUED MODELS OF THE PROGRAM COMPLETION 25 3.4.2 Three-Valued Models The original "logical consequence" approach essentially declares that only conclusions that are logical consequences (in the classical, 2-valued sense) of the completed program should be inferred <ref> [27, 48, 60, 107] </ref>. <p> The occurrence of a free variable Y in the negative subgoal is called "unsafe" because it is not limited to any domain. This derivation is said to have floundered <ref> [60] </ref>. Finally, let us note that in the unaugmented program p (1) is false in the well-founded semantics and in the Fitting semantics, but not in the 2PC semantics or Kunen semantics. <p> Such a result may be proved using a "switching lemma." See <ref> [60] </ref> for details. 4.4. GROUND SLP-TREES AND GROUND GLOBAL TREES 51 In light of this observation, we get Lemma 4.4.1 below. Let G 1 ] G 2 denote the goal formed as the left-to-right conjunction of the literals in G 1 and G 2 . Clearly, ] is associative. <p> Gffi as an unrestricted derivation from G, i.e., a derivation in which we do not insist that unifiers be most general. (In the ground SLP-tree, such unifiers always make the resulting goal ground.) The proof of this lemma is then very similar to the proof of the "mgu lemma" in <ref> [60] </ref>, and the details are omitted here. Lemma 4.5.3: Let G be a goal. <p> Then fl 0 = , and so is indeed more general than . We cannot substitute P for P 0 in the third item in Theorem 4.6.2 as illustrated by Example 4.6.1. Some texts (for example <ref> [60] </ref>) make the implicit assumption that extra ground terms exist in order to prove completeness results. The purpose of the augmented program is to formally include sufficiently many such ground terms in the Herbrand universe. <p> In fact, we still get O (m + n) complexity when the e relation has cycles (and has size O (n)) as in part (c). 2 6.4 Correctness We shall show that our method is correct by comparison with SLD-resolution of <ref> [60] </ref>. In the case where there are no right-recursive predicates, our result implies the correctness of magic templates, as shown previously in [88]. Our version of SLD-resolution uses a left-to-right computation rule. Definition 6.4.1: (SLD-tree) Let P be a program and G a goal. <p> Then the bottom-up evaluation of P 0 correctly answers the query Q with respect to the least Herbrand model of P . Proof : By Theorem 6.4.1, the soundness and completeness of SLD-resolution <ref> [7, 28, 45, 60] </ref> with respect to the least Herbrand model, and since MTRR (P ) and MTRR 0 (P ) are equivalent for all EDB and IDB predicates from P . Note that our correctness result doesn't state that the bottom-up evaluation of MTRR (P ) terminates. <p> For all ground atoms A that do not flounder, A 2 M P iff there exists an SLS-refutation for the query ?-A with respect to P . 7. Membership in M P is decidable. Here, T P is the two-valued immediate consequence operator defined in <ref> [60] </ref>. N P is the three valued immediate consequence operator of Fitting [34] (See Definition 3.4.5). Our main semantic results are summarized in the following theorem. Theorem 7.2.2: Let P be a modularly acyclic program. Then 1. T P has a unique fixpoint, M P . 2.
Reference: [61] <author> J. Lobo, J. Minker, and A. Rajasekar. </author> <title> Extending the semantics of logic programs to disjunctive logic programs. </title> <booktitle> In Proceedings of the Sixth International Conference on Logic Programming, </booktitle> <year> 1989. </year>
Reference-contexts: Disjunctive programs allow information of the form p _ q without knowing p or q. We generalized the semantics in two ways, one "exclusive" in nature and the other "inclusive" in nature. There have been a number of other proposals for semantics in disjunctive databases <ref> [22, 61, 70, 82, 87, 100, 102] </ref>. There remain several problematic aspects to disjunctive reasoning. One issue is complexity. With some exceptions, authors have ignored the complexity of their semantics.
Reference: [62] <author> Y. Lou and Z. M. Ozsoyoglu. LLO: </author> <title> An object-oriented deductive language with methods and method inheritance. </title> <booktitle> In 1991 ACM-SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 198-207, </pages> <year> 1991. </year> <note> BIBLIOGRAPHY 153 </note>
Reference-contexts: In languages such as HiLog it is possible to define parameterized procedures, or in the object-oriented terminology, "methods." A promising approach is the integration of some object oriented features in a deductive database framework. Various such attempts have been reported in <ref> [2, 44, 62, 123] </ref>. A successful integration would provide mechanisms for encapsulation, inheritance, complex objects and other object-oriented concepts while retaining the declarativeness and formal basis of deductive databases.
Reference: [63] <author> M. J. Maher. </author> <title> Equivalences of logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 388-402, </pages> <address> Los Altos, CA, 1988. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: A simple way to remove this behavior is to augment the program, as described in this section. We proceed informally here, and refer to <ref> [63] </ref> for a formal discussion.
Reference: [64] <author> M. J. Maher and R. Ramakrishnan. </author> <title> Deja vu in fixpoints of logic programs. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming, </booktitle> <year> 1989. </year>
Reference-contexts: Since duplicate elimination is therefore not necessary for termination, we can choose to discard or defer duplicate elimination in order to speed up query evaluation. As remarked in <ref> [64] </ref> the cost of duplicate detection can be a large proportion of the total cost of query evaluation. <p> However, for modularly acyclic programs tuples can only be generated a finite number of times, and so for Datalog programs bottom-up evaluation would still terminate. Modular acyclicity is a sufficient condition for the "finite forest" property <ref> [64] </ref>. As observed in [64] the cost of duplicate detection and elimination can be a large proportion of the total cost of query evaluation. Magic-sets is a widely employed technique for rewriting programs for efficient bottom-up evaluation [11, 13, 88]. <p> However, for modularly acyclic programs tuples can only be generated a finite number of times, and so for Datalog programs bottom-up evaluation would still terminate. Modular acyclicity is a sufficient condition for the "finite forest" property <ref> [64] </ref>. As observed in [64] the cost of duplicate detection and elimination can be a large proportion of the total cost of query evaluation. Magic-sets is a widely employed technique for rewriting programs for efficient bottom-up evaluation [11, 13, 88].
Reference: [65] <author> A. Marek and M. Truszczynski. </author> <title> Autoepistemic logic. </title> <type> Technical report, </type> <institution> University of Kentucky, </institution> <year> 1988. </year> <type> (manuscript). </type>
Reference-contexts: The theory has been further developed by Gelfond and Lifschitz [37], and also by Marek and Truszczynski <ref> [65, 66] </ref>. In this section we follow the definition of [37], which defines stability without reference to autoepistemic logic. We show that if a program has a total well-founded model, that model is the unique stable model. <p> Proof : See [118]. The Fitting model also has polynomial data complexity (for function-free programs). The proof is similar to that of Theorem 3.9.1 above. In contrast, Marek and Truszczynski <ref> [65] </ref> have shown that, even for propositional normal logic programs P , determining whether P has a stable model at all is NP-complete. 3.10 Expressive Power In this section we compare the various semantics according to the (formal) criterion of expressiveness. There are several types of expressiveness results.
Reference: [66] <author> W. Marek. </author> <title> Stable theories in autoepistemic logic. </title> <type> Technical report, </type> <institution> University of Kentucky, </institution> <year> 1986. </year> <type> (manuscript). </type>
Reference-contexts: The theory has been further developed by Gelfond and Lifschitz [37], and also by Marek and Truszczynski <ref> [65, 66] </ref>. In this section we follow the definition of [37], which defines stability without reference to autoepistemic logic. We show that if a program has a total well-founded model, that model is the unique stable model.
Reference: [67] <author> J. McCarthy. </author> <title> Circumscription a form of non-monotonic reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 27-39, </pages> <year> 1980. </year>
Reference-contexts: The basic idea is to consider all minimal Herbrand models to be canonical ones. This semantics infers all sentences true in all minimal models, in a style similar to circumscription <ref> [67] </ref>. However, considering all minimal models ignores the implicit priority relationship between the head and the body of the rules. For example, the rule p :q would be treated in an identical fashion to the rule q :p by the GCWA. <p> The subfield dealing with negation by default has been known as "nonmonotonic reasoning." Most of the AI formalisms are expressed in a logical framework, but aim to cover arbitrary theories rather than logic programs or deductive databases. Among these proposals are circumscription <ref> [67, 68] </ref>, default theories [92] and autoepistemic logic [71]. These proposals are all based on classical logic: circumscription employs a second order minimization axiom; default theories use a "consistency" modal operator; autoepistemic logic uses a "belief " modal operator.
Reference: [68] <author> J. McCarthy. </author> <title> Applications of circumscription to formalizing common sense knowledge. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 89-116, </pages> <year> 1986. </year>
Reference-contexts: The subfield dealing with negation by default has been known as "nonmonotonic reasoning." Most of the AI formalisms are expressed in a logical framework, but aim to cover arbitrary theories rather than logic programs or deductive databases. Among these proposals are circumscription <ref> [67, 68] </ref>, default theories [92] and autoepistemic logic [71]. These proposals are all based on classical logic: circumscription employs a second order minimization axiom; default theories use a "consistency" modal operator; autoepistemic logic uses a "belief " modal operator.
Reference: [69] <author> D. McDermott. </author> <title> A critique of pure reason. </title> <booktitle> Computational Intelligence, </booktitle> <year> 1987. </year>
Reference-contexts: Roughly, declarativeness means that the person writing in that language specifies "what to compute" and not "how to compute it." For discussion of the relative merits of declarative and procedural (or imperative) systems, see <ref> [1, 39, 40, 55, 69, 113] </ref>. In principle, declarativeness requires less of a user or programmer, and can thus be the basis of a system in which writing queries can be significantly less time-consuming than with a procedural language.
Reference: [70] <author> J. Minker. </author> <title> On indefinite databases and the closed world assumption. </title> <booktitle> In Proc. Sixth Conference on Automated Deduction, </booktitle> <pages> pages 292-308. </pages> <publisher> Springer Verlag, </publisher> <year> 1982. </year>
Reference-contexts: This least model is well-accepted as a canonical model for Horn programs. A closely related idea, the closed world assumption, was introduced in the context of deductive databases by Reiter [91]. The generalized closed world assumption (GCWA) was proposed by Minker to handle disjunctive databases <ref> [70] </ref> without producing the inconsistency typical of the closed world assumption when the program is not Horn. The basic idea is to consider all minimal Herbrand models to be canonical ones. This semantics infers all sentences true in all minimal models, in a style similar to circumscription [67]. <p> Disjunctive programs allow information of the form p _ q without knowing p or q. We generalized the semantics in two ways, one "exclusive" in nature and the other "inclusive" in nature. There have been a number of other proposals for semantics in disjunctive databases <ref> [22, 61, 70, 82, 87, 100, 102] </ref>. There remain several problematic aspects to disjunctive reasoning. One issue is complexity. With some exceptions, authors have ignored the complexity of their semantics.
Reference: [71] <author> R. C. Moore. </author> <title> Semantical considerations on nonmonotonic logic. </title> <journal> Artificial Intelligence, </journal> <volume> 25 </volume> <pages> 75-94, </pages> <year> 1985. </year>
Reference-contexts: Among these proposals are circumscription [67, 68], default theories [92] and autoepistemic logic <ref> [71] </ref>. These proposals are all based on classical logic: circumscription employs a second order minimization axiom; default theories use a "consistency" modal operator; autoepistemic logic uses a "belief " modal operator. <p> Kunen's main theorem states that this interpretation characterizes the 3-valued logical consequences of the completed program. 3.5 Stable Models Gelfond introduced an approach to negation through stable models [36], and motivated it by appealing to autoepistemic logic, as developed by Moore <ref> [71] </ref>. The theory has been further developed by Gelfond and Lifschitz [37], and also by Marek and Truszczynski [65, 66]. In this section we follow the definition of [37], which defines stability without reference to autoepistemic logic.
Reference: [72] <author> Y. N. Moschovakis. </author> <title> Elementary Induction on Abstract Structures. </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1974. </year>
Reference-contexts: 1 of ground literals are defined recursively by: I 0 = ;: For successor ordinal ff = fl + 1, I fl+1 = W P (I fl ): For limit ordinal ff, I ff = [ I fi : Finally, define I 1 = [ I ff : Following Moschovakis <ref> [72] </ref>, for any literal p in I 1 , we define the stage of p to be the least ordinal ff such that p 2 I ff . <p> The Herbrand base is countable, so for some countable ordinal ff, I 1 = I ff . Definition 3.3.5: The closure ordinal for the sequence I ff is the least ordinal ff such that I 1 = I ff (cf. <ref> [72] </ref>). 2 Examples can be constructed where the closure ordinal is above !, but such examples are likely to be very rare in practice. (See Example 4.3.1 in Chapter 4 for such a program.) In the case of a function-free program with a finite EDB, which is common in deductive databases, <p> SEMANTICS between queries expressible in the following semantics: Datalog Stratified Fitting = Well-founded = Inductive = Inflationary Stable = co-NP = 1 1 Here "Datalog" represents the least model semantics for negation-free programs and "Stratified" represents the stratified semantics for stratified programs. "Inductive" represents the class of inductively definable queries <ref> [72] </ref>, which are those queries definable in first-order fixpoint logic. The following theorem summarizes results from [104].
Reference: [73] <author> I. S. Mumick and H. Pirahesh. </author> <title> Right-linear and overbound queries. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference-contexts: The idea of "carrying around" a pointer from a subquery to the "top query" was introduced in a simpler form in [49] and (independently) in <ref> [73] </ref> for right-linear programs with multiple bindings. While our transformation may sometimes do worse than magic templates, we can show that it does no worse for the class of nonrepeating programs. 114 CHAPTER 6.
Reference: [74] <author> I. S. Mumick, H. Pirahesh, and R. Ramakrishnan. </author> <title> The magic of duplicates and aggregates. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1990. </year>
Reference-contexts: Rewriting a modularly acyclic program using magic set techniques does not necessarily yield a modularly acyclic program. Hence one may ask whether tuples are generated only finitely often when evaluating the magic-rewritten program. Mumick et al. <ref> [74] </ref> have considered using duplicates as semantically meaningful entities, where the number of copies of a tuple corresponds to the number of derivations of that tuple.
Reference: [75] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: Deductive database theory is reasonably mature, having been studied in its own right for almost a decade, and, in the context of logic programming, for longer. However, deductive database systems have only recently become available. For descriptions of various systems see <ref> [75, 79, 80, 89, 114] </ref>. The main advantages of deductive databases are expressiveness and declarativeness. One needs to be convinced that the extra expressiveness gives a useful extension to, say, relational algebra.
Reference: [76] <author> J. F. Naughton, R. Ramakrishnan, Y. Sagiv, and J. D. Ullman. </author> <title> Argument reduction by factoring. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1989. </year>
Reference-contexts: By passing binding information from the query itself into the rule evaluation, magic sets restricts the computation to tuples that are in some sense relevant. In Chapter 5 we extend these magic-sets techniques to programs with (not necessarily stratified) negation. Other techniques, such as right-linear evaluation <ref> [76, 77] </ref> give better performance than magic sets for restricted classes of programs. Common programs such as transitive closures fall into the class of right-linear programs. The right-linear optimization can be thought of as a (limited) form of tail-recursion elimination. <p> We consider cases where top-down without memoing beats magic set bottom-up methods because "intermediate" predicates are not fully computed. In some cases, top-down Prolog-style evaluation effectively applies tail-recursion elimination. It is this tail-recursion elimination that is exploited for right-linear programs in <ref> [76, 77] </ref>. We use this observation about top-down evaluation to motivate a bottom-up formalization of tail-recursion elimination. This formalization improves on top-down evaluation in that it remains efficient even when top-down evaluation does not terminate. <p> At the end of this section we shall show that the modified magic templates method does no worse (and often much better) than ordinary magic templates for nonrepeating programs. So far, the examples where savings over magic sets are achieved have been right linear programs, so that right-linear optimization <ref> [76, 77, 113] </ref> could have been applied. Definition 6.5.2: (Right Linearity) Let P be a program in which there is a single IDB predicate p, which is labelled as right-recursive. Let ff be an adornment for p. Then P is right-linear with respect to ff if 1.
Reference: [77] <author> J. F. Naughton, R. Ramakrishnan, Y. Sagiv, and J. D. Ullman. </author> <title> Efficient evaluation of right-, left-, and multi-linear rules. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <year> 1989. </year>
Reference-contexts: By passing binding information from the query itself into the rule evaluation, magic sets restricts the computation to tuples that are in some sense relevant. In Chapter 5 we extend these magic-sets techniques to programs with (not necessarily stratified) negation. Other techniques, such as right-linear evaluation <ref> [76, 77] </ref> give better performance than magic sets for restricted classes of programs. Common programs such as transitive closures fall into the class of right-linear programs. The right-linear optimization can be thought of as a (limited) form of tail-recursion elimination. <p> We consider cases where top-down without memoing beats magic set bottom-up methods because "intermediate" predicates are not fully computed. In some cases, top-down Prolog-style evaluation effectively applies tail-recursion elimination. It is this tail-recursion elimination that is exploited for right-linear programs in <ref> [76, 77] </ref>. We use this observation about top-down evaluation to motivate a bottom-up formalization of tail-recursion elimination. This formalization improves on top-down evaluation in that it remains efficient even when top-down evaluation does not terminate. <p> At the end of this section we shall show that the modified magic templates method does no worse (and often much better) than ordinary magic templates for nonrepeating programs. So far, the examples where savings over magic sets are achieved have been right linear programs, so that right-linear optimization <ref> [76, 77, 113] </ref> could have been applied. Definition 6.5.2: (Right Linearity) Let P be a program in which there is a single IDB predicate p, which is labelled as right-recursive. Let ff be an adornment for p. Then P is right-linear with respect to ff if 1. <p> We have provided a syntactic sufficient condition for nonrepetition, namely weak right-linearity. The class of weakly-right-linear programs properly includes the class of right-linear programs. As noted by Sagiv [101], the class of left-linear rules <ref> [77] </ref> can be generalized in a symmetric way. Left-linear optimization and mixed-linear optimization [77] can then be suitably generalized for programs with rules that commute and are either weakly right-linear or "weakly left-linear." Chapter 7 Modular Acyclicity 7.1 Introduction We now consider the issue of acyclicity, i.e., the absence of both <p> We have provided a syntactic sufficient condition for nonrepetition, namely weak right-linearity. The class of weakly-right-linear programs properly includes the class of right-linear programs. As noted by Sagiv [101], the class of left-linear rules <ref> [77] </ref> can be generalized in a symmetric way. Left-linear optimization and mixed-linear optimization [77] can then be suitably generalized for programs with rules that commute and are either weakly right-linear or "weakly left-linear." Chapter 7 Modular Acyclicity 7.1 Introduction We now consider the issue of acyclicity, i.e., the absence of both positive and negative loops in logic programs or deductive databases.
Reference: [78] <author> J.-M. Nicolas. </author> <title> Logic for improving integrity checking in relational databases. </title> <journal> Acta Informatica, </journal> <volume> 18(3) </volume> <pages> 227-253, </pages> <year> 1982. </year>
Reference-contexts: However, there does exist a large class of normal programs for which the HiLog semantics and the normal semantics coincide, namely the class of range restricted programs. Range restricted programs are guaranteed to be domain independent for normal programs <ref> [78] </ref>. Recall the definition of range-restrictedness from Chapter 2.
Reference: [79] <author> G. Phipps. </author> <title> Glue: A deductive database programming language. </title> <type> Technical Report TR-CS-90-14, </type> <institution> Kansas State University, </institution> <year> 1990. </year> <booktitle> Proceedings of the NACLP'90 Workshop on Deductive Databases. </booktitle> <address> 154 BIBLIOGRAPHY </address>
Reference-contexts: GENERALIZATIONS 101 With a slight change of syntax, the rewritten program of Algorithm 5.4.1 may be interpreted as statements in the database programming language GLUE <ref> [79, 80] </ref>. In fact, Algorithm 5.4.1 is the basis of a compiler that has been implemented by the author and others as part of the NAIL! system at Stanford University. Chapter 6 Tail recursion elimination 6.1 Introduction Right-linear evaluation is a specialized optimization technique for evaluating queries on right-linear programs. <p> Deductive database theory is reasonably mature, having been studied in its own right for almost a decade, and, in the context of logic programming, for longer. However, deductive database systems have only recently become available. For descriptions of various systems see <ref> [75, 79, 80, 89, 114] </ref>. The main advantages of deductive databases are expressiveness and declarativeness. One needs to be convinced that the extra expressiveness gives a useful extension to, say, relational algebra.
Reference: [80] <author> G. Phipps, M. Derr, and K. A. Ross. </author> <title> Glue-Nail: A deductive database system. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <year> 1991. </year>
Reference-contexts: One would write queries in NAIL, resorting to Glue for updates, I/O, and when specialized algorithms need to be implemented. We shall not discuss the Glue language in this thesis; the interested reader is referred to <ref> [80] </ref>. In this thesis we shall concentrate on an abstract declarative component for a database system. The model for declarative specification that we choose is that of a deductive database. Our queries and our database will be expressed in terms of logical rules. <p> GENERALIZATIONS 101 With a slight change of syntax, the rewritten program of Algorithm 5.4.1 may be interpreted as statements in the database programming language GLUE <ref> [79, 80] </ref>. In fact, Algorithm 5.4.1 is the basis of a compiler that has been implemented by the author and others as part of the NAIL! system at Stanford University. Chapter 6 Tail recursion elimination 6.1 Introduction Right-linear evaluation is a specialized optimization technique for evaluating queries on right-linear programs. <p> Deductive database theory is reasonably mature, having been studied in its own right for almost a decade, and, in the context of logic programming, for longer. However, deductive database systems have only recently become available. For descriptions of various systems see <ref> [75, 79, 80, 89, 114] </ref>. The main advantages of deductive databases are expressiveness and declarativeness. One needs to be convinced that the extra expressiveness gives a useful extension to, say, relational algebra.
Reference: [81] <author> H. Przymusinska and T. C. Przymusinski. </author> <title> Weakly perfect model semantics for logic programs. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <year> 1988. </year>
Reference-contexts: However, in a top-down system, the status of subgoals is unknown until they are themselves expanded, and so such a restriction on the selection of subgoals is unlikely to be useful. Observe that if R is not positivistic, then we will not be able to achieve completeness. Example 4.3.2: <ref> [81] </ref> Let P be the program p :s; q; :r r p; :q The well-founded model for P is fs; :p; :q; :rg. <p> In many cases, two truth values suffice to model the situation under consideration. So we desire a condition on the program, more general than stratification, that ensures that the well-founded semantics is two-valued. Recently Przymusinska and Przymusinski <ref> [81] </ref> have isolated the class of weakly stratified programs as such a class. <p> We must now consider what conditions must be placed on those components containing predicates depending negatively upon themselves. We want the well-founded semantics to be total, i.e., to make every ground literal either true or false. Weak stratifiability <ref> [81] </ref> is such a condition, and as we shall see, all modularly stratified programs are weakly stratified. There is another important issue, namely the ordering of literals in the body of rules. <p> MODULARLY STRATIFIED PROGRAMS 65 This definition of reduction is similar to the definition of reduction in <ref> [81] </ref> used to define weak stratifiability. There are two differences: 1. We restrict M to only those predicates used by F . 2. We do not delete instantiated clauses whose heads appear elsewhere in the program as unit facts. <p> For example, the game program from Example 5.2.1 above is modularly stratified if and only if m is acyclic. This property is unlike stratification, for example, where checking that a program is stratified can be done syntactically. We now show that modularly stratified programs are also weakly stratified <ref> [81] </ref>. Theorem 5.2.1: Every modularly stratified program is weakly stratified. Proof : It is not difficult to show that a program P is weakly stratified if and only if, for every component F of P , 1. <p> There is a total well-founded model M for the union of all components F 0 F , and 2. The reduction of F modulo M is weakly stratified. Since all locally stratified programs are weakly stratified <ref> [81] </ref>, we can show by induction on the level of components that modularly stratified programs are weakly stratified. The converse of Theorem 5.2.1 is false, as illustrated by Example 5.2.2. Also, every stratified program is modularly stratified, as is every locally stratified program. <p> Also, every stratified program is modularly stratified, as is every locally stratified program. Corollary 5.2.2: Every modularly stratified program has a total well-founded model that is its unique stable model. Proof : Since this property holds for weakly stratified programs <ref> [81] </ref>. 66 CHAPTER 5. EVALUATION: MEMOING AND MAGIC SETS To see how the well-founded model of a program may be composed from those of its components, recall that a locally stratified program has a unique perfect model [82] and hence a total well-founded model that coincides with the perfect model.
Reference: [82] <author> T. C. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216, </pages> <address> Los Altos, CA, 1988. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Two such classes are stratified programs (Definition 2.1.9) and locally stratified programs (Definition 2.1.10). The stratified class has been treated in [6, 24, 59, 116], and elsewhere. The locally stratified class, defined and studied by Przymusinski <ref> [82] </ref>, is a superset of the class of stratified programs. Przymusinski defined perfect models, and showed that every locally stratified program has a unique perfect model. These classes are discussed further in Section 3.6. <p> Przymusinski carried the above idea to a finer grain by defining a program to be locally stratified (Definition 2.1.10) if it is possible to assign ordinal levels to ground atoms in the instantiated program with the same constraints on levels as for stratification <ref> [82] </ref>. Note that a locally stratified program is stratified if all atoms with the same predicate symbol can be assigned the same level. The extension handles situations where the "recursive negation" is apparent, but not real. <p> A typical example is the program even (s (X )) :even (X) even (0) 32 CHAPTER 3. DECLARATIVE SEMANTICS where each ground atom can be given a level equal to the power of s in its argument. To give a semantics to locally stratified programs Przymusinski <ref> [82] </ref> has given a definition for a perfect model of a program. <p> Chapter 5 Evaluation: Memoing and Magic Sets 5.1 Background Much recent work has concerned defining the semantics of negation in deductive databases. The "perfect model semantics" <ref> [82] </ref> has been generally accepted as natural, and is the basis for several experimental deductive database systems. Unfortunately, the perfect model semantics applies only to programs that are stratified (or locally stratified). <p> Proof : Since this property holds for weakly stratified programs [81]. 66 CHAPTER 5. EVALUATION: MEMOING AND MAGIC SETS To see how the well-founded model of a program may be composed from those of its components, recall that a locally stratified program has a unique perfect model <ref> [82] </ref> and hence a total well-founded model that coincides with the perfect model. The "lowest" components must be locally stratified; compute their well founded model M . <p> Disjunctive programs allow information of the form p _ q without knowing p or q. We generalized the semantics in two ways, one "exclusive" in nature and the other "inclusive" in nature. There have been a number of other proposals for semantics in disjunctive databases <ref> [22, 61, 70, 82, 87, 100, 102] </ref>. There remain several problematic aspects to disjunctive reasoning. One issue is complexity. With some exceptions, authors have ignored the complexity of their semantics.
Reference: [83] <author> T. C. Przymusinski. </author> <title> Every logic program has a natural stratification and an iterated fixed point model. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <year> 1989. </year>
Reference-contexts: For further 42 4.2. TERMINOLOGY 43 discussion see Section 4.7. Przymusinski had independently described a similar procedural semantics that he also calls "SLS-resolution" <ref> [83] </ref>. 4.2 Terminology Definition 4.2.1: A computation rule is a rule for selecting one or more literals from a query. We assume that a computation rule may depend more than the current query. <p> Our construction relaxes this requirement by allowing all subsidiary SLP-trees to be constructed recursively. Recently, Przymusinski has independently defined a similar extension of SLS-resolution using induction on what he terms the "dynamic stratification" of a program <ref> [83] </ref>. Dynamic stratification corresponds roughly to what we have called the level of the global tree for a goal. One advantage of our construction is that the level is a consequence of the definition of global trees, rather than a precondition of its definition.
Reference: [84] <author> T. C. Przymusinski. </author> <title> On constructive negation in logic programming. </title> <booktitle> In Proceedings, North American Conference on Logic Programming, </booktitle> <year> 1989. </year>
Reference-contexts: Unfounded sets are defined in Section 3.3. Since the well-founded semantics was presented at a conference [118], several alternative formulations of the well-founded semantics have been developed <ref> [18, 33, 84, 117] </ref>. We believe that this agreement indicates a robustness of the semantics, and provides evidence that it coincides well with intuition, at least in the context of deductive databases. 3.1.4 Inflationary Semantics The inflationary semantics was proposed in [54] and, independently, in [3]. <p> Some results in this direction have been presented in [58], and some more recent work has described a process called "constructive negation" in which negative subgoals are used to generate negative bindings <ref> [21, 84] </ref>. Whether such methods will be useful in practice, or whether ground negation is sufficient for most purposes remains to be seen. Restricting programs and goals to be range-restricted (Definition 2.1.8), for example, guarantees freedom from floundering. <p> By placing this predicate to the left of each floundering subgoal, one can prevent floundering without losing any expressive power. An alternative approach, which merits further research, would be to incorporate constructive negation <ref> [21, 84] </ref> into the evaluation mechanisms proposed in this chapter. Nevertheless, the author believes that programs that cannot be rearranged into permissible versions will be rare in practice. 70 CHAPTER 5. <p> CONCLUSIONS a variable. One may like to give the "answer" X 6= a. However the traditional definition of answer substitution does not permit such "nonsubstitutions." Several authors have considered generalizing the notion of answer substitution to incorporate inequality substitutions <ref> [21, 84] </ref>. For function-free programs there is a normal form for such substitutions. In it unclear whether there is an overwhelming need for constructive negation in deductive databases; such a need would have to be demonstrated by empirical evidence. There is scope to generalize bottom-up techniques to handle constructive negation.
Reference: [85] <author> T. C. Przymusinski. </author> <title> On the declarative and procedural semantics of logic programs. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 167-205, </pages> <year> 1989. </year>
Reference-contexts: agree that p (1) is true in the augmented program. 2 Przymusinski proposes an alternative solution to what he terms the "Universal Query Problem." In proving the soundness and completeness of SLS-resolution with respect to the perfect model semantics, he considers all perfect models rather than just perfect Herbrand models <ref> [85] </ref>. These models have to be models of Clark's equality theory (Definition 3.4.2). Chapter 4 Procedural Semantics In this chapter we shall look for a procedural counterpart to the declarative semantics of Chapter 3. <p> This method is sound with respect to the completion of the program, and is complete for Horn programs (possibly with negative subgoals in the goal only) [48]. Based on the perfect model approach, Przymusinski introduced SLS-resolution <ref> [85] </ref>. SLS-resolution is a top-down procedural semantics that uses an extension of SLD-resolution to answer queries. Przymusinski showed that for stratified programs with non-floundering queries, SLS-resolution is sound and complete with respect to the unique perfect model of the program. Unfortunately, SLS-resolution is not effective in general. <p> Przymusinski showed that for stratified programs with non-floundering queries, SLS-resolution is sound and complete with respect to the unique perfect model of the program. Unfortunately, SLS-resolution is not effective in general. It was argued in <ref> [85] </ref> that SLS-resolution may be considered a theoretical construct, an ideal query answering procedure to which various effective approximations may be compared. <p> Proof : The proof is similar to that in [51], with a proof by induction on the finite number of levels guaranteed by the finite negation tree, rather than on the levels generated by a stratification. The comparison is with global SLS-resolution rather than with SLS-resolution of <ref> [85] </ref> since the latter is well-defined only for locally stratified programs. We implicitly use the soundness and completeness of global SLS-resolution with respect to the well-founded semantics. 5.4 Bottom-Up Evaluation It is desirable to have a bottom-up alternative to global SLS-resolution, which is top-down. <p> Adding an unrelated fact such as r (b) would change the answer to the query ?p by supplying an additional constant to the vocabulary. This issue is related to the universal query problem discussed in <ref> [85, 118] </ref>. One solution is to augment the program with extra function and constant symbols so that this problem does not occur. 8.2.
Reference: [86] <author> T. C. Przymusinski. </author> <title> Three-valued nonmonotonic formalisms and logic programming. </title> <booktitle> In Proceedings of the First International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <year> 1989. </year>
Reference-contexts: Przymusinski has shown an equivalence between the well-founded semantics and versions of each of these three formalisms when the AI formalisms are expressed in a 3-valued logic <ref> [86] </ref>. One must be cautious, however, since when expressed in 3-valued logic the modified formalisms yield significant differences from the corresponding 2-valued approaches. 3.2 Partial Interpretations We shall be working extensively with sets of literals, for which we now introduce some notation.
Reference: [87] <author> T. C. Przymusinski. </author> <title> Stationary semantics for disjunctive logic programs and deductive databases. </title> <booktitle> In Proceedings, North American Conference on Logic Programming, </booktitle> <year> 1990. </year>
Reference-contexts: Disjunctive programs allow information of the form p _ q without knowing p or q. We generalized the semantics in two ways, one "exclusive" in nature and the other "inclusive" in nature. There have been a number of other proposals for semantics in disjunctive databases <ref> [22, 61, 70, 82, 87, 100, 102] </ref>. There remain several problematic aspects to disjunctive reasoning. One issue is complexity. With some exceptions, authors have ignored the complexity of their semantics.
Reference: [88] <author> R. Ramakrishnan. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <year> 1988. </year>
Reference-contexts: For non-recursive queries many well-known optimizations for relational databases can be applied. Several techniques for optimizing recursive queries have been recently proposed, including "magic-sets," "right-linear evaluation," "counting methods" and so on. (See [113] for a comprehensive discussion of these and other strategies.) Magic-sets <ref> [11, 13, 88, 93] </ref> is a general technique that can, in principle, be applied to any (recursive or nonrecursive) deductive database. By passing binding information from the query itself into the rule evaluation, magic sets restricts the computation to tuples that are in some sense relevant. <p> Top-down can beat bottom-up evaluation of the original program because it can restrict the computation to only those tuples relevant to the query. This problem is now well-understood for programs without negation, and several techniques have been proposed [12]. One of these is magic sets <ref> [11, 13, 88] </ref>, which rewrites the program in such a way that the binding information that would have been passed down by a top-down method is incorporated into the bottom-up evaluation. <p> In Section 5.4.3 we describe a magic sets method for evaluating modularly stratified programs bottom-up. In particular, this method also works for stratified programs. Our proposal extends the magic templates method of <ref> [88] </ref> rather than the original magic sets proposals. Before we introduce the magic sets transformation, we describe a transformation of the program whose bottom-up evaluation is sound and complete with respect to the well-founded semantics for nonfloundering programs with finite negation trees, and in particular, for permissible programs. <p> Using magic predicates in the body restricts the tuples generated during the bottom-up computation to those that are relevant. We use a version of the magic templates method <ref> [88] </ref> that is also described in [113]. For every predicate p in the program we introduce a new "magic" predicate m p. Magic predicates have the same number of arguments as the original predicates. <p> We will thus be able to demonstrate that the two algorithms have the same complexity. Note that our claim is stronger than the more common claim that various methods infer the same sets of tuples. Some authors have considered the issue of "sip-optimality" <ref> [88, 105] </ref>. <p> The advantages of bottom-up methods over top-down methods are discussed in [113]. Bry's translation of SLD-resolution [19] explicitly represents the intermediate tuples, and hence does not take advantage of this potential optimization. We extend the magic templates method of Ramakrishnan <ref> [88] </ref> in which the magic predicates have the same arity as their corresponding IDB predicates, and nonground tuples are allowed. We use a version of magic templates with supplementary predicates, as in [113]. <p> In the case where there are no right-recursive predicates, our result implies the correctness of magic templates, as shown previously in <ref> [88] </ref>. Our version of SLD-resolution uses a left-to-right computation rule. Definition 6.4.1: (SLD-tree) Let P be a program and G a goal. <p> There is, of course, the overhead of having an extra argument in the sup tuples. At worst, this would add a small constant factor to the overall cost. With the extension proposed above we can do better than "sip-optimal" <ref> [88] </ref> (See Definition 5.5.1). Modulo the magic tuples, magic templates is sip-optimal [88]. Modulo the magic and query tuples, our extension is at worst sip-optimal for nonrepeating programs, by Theorem 6.5.1. <p> At worst, this would add a small constant factor to the overall cost. With the extension proposed above we can do better than "sip-optimal" <ref> [88] </ref> (See Definition 5.5.1). Modulo the magic tuples, magic templates is sip-optimal [88]. Modulo the magic and query tuples, our extension is at worst sip-optimal for nonrepeating programs, by Theorem 6.5.1. <p> Modular acyclicity is a sufficient condition for the "finite forest" property [64]. As observed in [64] the cost of duplicate detection and elimination can be a large proportion of the total cost of query evaluation. Magic-sets is a widely employed technique for rewriting programs for efficient bottom-up evaluation <ref> [11, 13, 88] </ref>. Rewriting a modularly acyclic program using magic set techniques does not necessarily yield a modularly acyclic program. Hence one may ask whether tuples are generated only finitely often when evaluating the magic-rewritten program.
Reference: [89] <author> R. Ramakrishnan, P. Bothner, D. Srivastava, and S. Sudarshan. </author> <title> CORAL: A database programming language. </title> <type> Technical Report TR-CS-90-14, </type> <institution> Kansas State University, </institution> <year> 1990. </year> <booktitle> Proceedings of the NACLP'90 Workshop on Deductive Databases. </booktitle>
Reference-contexts: Deductive database theory is reasonably mature, having been studied in its own right for almost a decade, and, in the context of logic programming, for longer. However, deductive database systems have only recently become available. For descriptions of various systems see <ref> [75, 79, 80, 89, 114] </ref>. The main advantages of deductive databases are expressiveness and declarativeness. One needs to be convinced that the extra expressiveness gives a useful extension to, say, relational algebra.
Reference: [90] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Rule ordering in bottom-up fixpoint evaluation of logic programs. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1990. </year>
Reference-contexts: In practice, rule order can affect the number of rounds before the iteration converges. Such issues are discussed in <ref> [90] </ref>. We could demonstrate the correctness of Algorithm 5.4.1 by comparison with the methods of the previous section. However we shall show a closer connection between Algorithm 5.4.1 and Algorithm 5.3.1 that identifies a one-to-one correspondence between steps of each method.
Reference: [91] <author> R. Reiter. </author> <title> On closed world databases. </title> <editor> In Gallaire and Minker, editors, </editor> <booktitle> Logic and Databases, </booktitle> <pages> pages 55-76. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: It can be shown that Horn programs have a unique least Herbrand model. This least model is well-accepted as a canonical model for Horn programs. A closely related idea, the closed world assumption, was introduced in the context of deductive databases by Reiter <ref> [91] </ref>. The generalized closed world assumption (GCWA) was proposed by Minker to handle disjunctive databases [70] without producing the inconsistency typical of the closed world assumption when the program is not Horn. The basic idea is to consider all minimal Herbrand models to be canonical ones. <p> And if both are declared false at once, we have an inconsistency. 2 Simultaneously negating all the atoms in an unfounded set effectively invokes the "closed-world assumption" <ref> [91] </ref> in Horn clause programs; if H is the Herbrand base and I is the set of atoms that represents the minimum Herbrand model of a Horn clause program [115], then H I, the set of atoms not in I, is unfounded with respect to I . See Theorem 3.3.7.
Reference: [92] <author> R. Reiter. </author> <title> A logic for default reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 81-132, </pages> <year> 1980. </year>
Reference-contexts: The subfield dealing with negation by default has been known as "nonmonotonic reasoning." Most of the AI formalisms are expressed in a logical framework, but aim to cover arbitrary theories rather than logic programs or deductive databases. Among these proposals are circumscription [67, 68], default theories <ref> [92] </ref> and autoepistemic logic [71]. These proposals are all based on classical logic: circumscription employs a second order minimization axiom; default theories use a "consistency" modal operator; autoepistemic logic uses a "belief " modal operator.
Reference: [93] <author> J. Rohmer, R. Lescoeur, and J. M. Kerisit. </author> <title> The alexander method | a technique for the processing of recursive axioms in deductive databases. </title> <journal> New Generation Computing, </journal> <volume> 4(3) </volume> <pages> 273-286, </pages> <year> 1986. </year>
Reference-contexts: For non-recursive queries many well-known optimizations for relational databases can be applied. Several techniques for optimizing recursive queries have been recently proposed, including "magic-sets," "right-linear evaluation," "counting methods" and so on. (See [113] for a comprehensive discussion of these and other strategies.) Magic-sets <ref> [11, 13, 88, 93] </ref> is a general technique that can, in principle, be applied to any (recursive or nonrecursive) deductive database. By passing binding information from the query itself into the rule evaluation, magic sets restricts the computation to tuples that are in some sense relevant.
Reference: [94] <author> K. A. Ross. </author> <title> A procedural semantics for well-founded negation in logic programs. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1989. </year> <note> Also Stanford University Technical Report STAN-CS-88-1233. Full version to appear in Journal of Logic Programming. BIBLIOGRAPHY 155 </note>
Reference: [95] <author> K. A. Ross. </author> <title> The well-founded semantics for disjunctive logic programs. </title> <booktitle> In Proceedings of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <year> 1989. </year>
Reference-contexts: Providing a sound semantic basis for declarative systems with aggregation is an important issue. Recursion through aggregation causes similar semantic problems to recursion through negation. Some results in this direction have been reported in [35, 50, 99, 110]. 9.2.2 Disjunctive Programs In <ref> [95] </ref> we generalize the well-founded semantics to disjunctive programs. Disjunctive programs allow information of the form p _ q without knowing p or q. We generalized the semantics in two ways, one "exclusive" in nature and the other "inclusive" in nature.
Reference: [96] <author> K. A. Ross. </author> <title> Modular stratification and magic sets for Datalog programs with negation. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1990. </year> <note> Full version submitted for journal publication. </note>
Reference-contexts: In [18], Bry outlines a magic sets method for what he calls constructively consistent programs. Unfortunately, the section on magic sets in that paper is very brief. Only after the paper <ref> [96] </ref> was written did we become aware of the details of Bry's work [17]. The class of constructively consistent programs also generalizes the class of stratified programs, and constructively consistent programs have a two-valued semantics. Bry's method handles negative dependencies by storing clauses rather than atoms.
Reference: [97] <author> K. A. Ross. </author> <title> Modular acyclicity and tail recursion in logic programs. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference-contexts: This chapter presents such a procedural semantics. Global SLS-resolution is not effective, as discussed below. However, for certain subclasses of programs, global SLS-resolution is effective. For acyclic programs [5, 20] or, more generally, for modularly acyclic programs <ref> [97] </ref> global SLS-resolution is effective (see Chapter 7). In the absence of function symbols, the Herbrand Base is finite, and so effective procedures exist. 3 For modularly stratified function-free programs global SLS-resolution may be made effective by using the memoing techniques of [51, 106] to prune loops (see Chapter 5).
Reference: [98] <author> K. A. Ross. </author> <title> On negation in HiLog. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year> <note> Full version submitted for journal publication. </note>
Reference: [99] <author> K. A. Ross and Y. Sagiv. </author> <title> Monotonic aggregation in deductive databases. </title> <type> (manuscript), </type> <month> August </month> <year> 1991. </year>
Reference-contexts: Providing a sound semantic basis for declarative systems with aggregation is an important issue. Recursion through aggregation causes similar semantic problems to recursion through negation. Some results in this direction have been reported in <ref> [35, 50, 99, 110] </ref>. 9.2.2 Disjunctive Programs In [95] we generalize the well-founded semantics to disjunctive programs. Disjunctive programs allow information of the form p _ q without knowing p or q. We generalized the semantics in two ways, one "exclusive" in nature and the other "inclusive" in nature.
Reference: [100] <author> K. A. Ross and R. W. Topor. </author> <title> Inferring negative information from disjunctive databases. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4 </volume> <pages> 397-424, </pages> <year> 1988. </year> <note> Also appeared as Melbourne University Technical Report 87/1. </note>
Reference-contexts: The key idea in our formulation is the concept of an "unfounded set," which is an adaptation of the "closed set" developed for disjunctive databases by Ross and Topor <ref> [100] </ref>, and is essentially the same as the "securable set" in [103]. Unfounded sets are defined in Section 3.3. Since the well-founded semantics was presented at a conference [118], several alternative formulations of the well-founded semantics have been developed [18, 33, 84, 117]. <p> We shall discuss 3-valued models in Section 3.4. 3.3 Unfounded Sets and Well-Founded Partial Models In this section we define unfounded sets, which are a variation of closed sets that were defined for disjunctive databases by Ross and Topor in <ref> [100] </ref>. Unfounded sets provide the basis for negative conclusions in the well-founded semantics. 3.3. UNFOUNDED SETS AND WELL-FOUNDED PARTIAL MODELS 19 3.3.1 Unfounded Sets Definition 3.3.1: Let a program P , its associated Herbrand base H, and a partial interpretation I be given. <p> As described more formally later, the well-founded semantics uses conditions (1) and (2) to draw negative conclusions. Essentially, it simultaneously infers all atoms in A to be false. By contrast, the semantics of [34] uses only condition (1) to draw negative conclusions. The closed sets of Ross and Topor <ref> [100] </ref> were defined only with condition (2). <p> Disjunctive programs allow information of the form p _ q without knowing p or q. We generalized the semantics in two ways, one "exclusive" in nature and the other "inclusive" in nature. There have been a number of other proposals for semantics in disjunctive databases <ref> [22, 61, 70, 82, 87, 100, 102] </ref>. There remain several problematic aspects to disjunctive reasoning. One issue is complexity. With some exceptions, authors have ignored the complexity of their semantics.
Reference: [101] <author> Y. Sagiv, </author> <year> 1990. </year> <type> (personal communication). </type>
Reference-contexts: In the case of function-free programs, the evaluation of MTRR (P ) is guaranteed to terminate. 6.5 Nonrepetition When rightmost subgoals of right recursive predicates satisfy the condition of right-linearity, our transformation is essentially the same as one developed by Sagiv <ref> [101] </ref> for this special case. The idea of "carrying around" a pointer from a subquery to the "top query" was introduced in a simpler form in [49] and (independently) in [73] for right-linear programs with multiple bindings. <p> We have provided a syntactic sufficient condition for nonrepetition, namely weak right-linearity. The class of weakly-right-linear programs properly includes the class of right-linear programs. As noted by Sagiv <ref> [101] </ref>, the class of left-linear rules [77] can be generalized in a symmetric way.
Reference: [102] <author> C. Sakama. </author> <title> Possible model semantics for disjunctive databases. </title> <booktitle> In Proceedings of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <year> 1989. </year>
Reference-contexts: Disjunctive programs allow information of the form p _ q without knowing p or q. We generalized the semantics in two ways, one "exclusive" in nature and the other "inclusive" in nature. There have been a number of other proposals for semantics in disjunctive databases <ref> [22, 61, 70, 82, 87, 100, 102] </ref>. There remain several problematic aspects to disjunctive reasoning. One issue is complexity. With some exceptions, authors have ignored the complexity of their semantics.
Reference: [103] <author> J. S. Schlipf. </author> <title> Negation by securable failure in logic programming. </title> <type> (manuscript), </type> <year> 1987. </year>
Reference-contexts: The key idea in our formulation is the concept of an "unfounded set," which is an adaptation of the "closed set" developed for disjunctive databases by Ross and Topor [100], and is essentially the same as the "securable set" in <ref> [103] </ref>. Unfounded sets are defined in Section 3.3. Since the well-founded semantics was presented at a conference [118], several alternative formulations of the well-founded semantics have been developed [18, 33, 84, 117].
Reference: [104] <author> J. S. Schlipf. </author> <title> The expressive powers of the logic programming semantics. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1990. </year> <institution> (also University of Cincinnati Department of Computer Science Technical Report CIS-TR-90-3). </institution>
Reference-contexts: Thus, one would like the composition 6 of an arbitrary program component defining the e relation with my transitive closure program to have the expected semantics. The criterion of compositionality is closely related to what Schlipf calls the "principle of stratification" in <ref> [104] </ref>. The are also tradeoffs among the other criteria. <p> We shall say that a semantics is compositional if the following condition holds. This condition is based on Schlipf's "Principle of Stratification" <ref> [104] </ref>. <p> For the stable model semantics we may say that a ground literal l is true with respect to the stable model semantics if l belongs to all stable models. 7 The following definition is based on <ref> [104] </ref>. If S is a semantics, then let S P;D be the corresponding 3-valued interpretation for the IDB P and EDB D. <p> We say that the query Q is expressible in a semantics S if the relation Q (D) is definable in S. The following theorem summarizes results from <ref> [3, 53, 54, 104] </ref>. 8 Here, "" denotes proper containment. Also, 1 1 denotes the class of queries expressible by second-order formulas of the form 8X 1 8X n ( ~ X) where is first-order, and the variables X i are second order, ranging over relations rather than values. <p> Theorem 3.10.1: For function-free programs over finite EDB's the following relationships hold 7 If the program has no stable models then for the purposes of this section on expressive power we shall follow the approach of <ref> [104] </ref> an include every literal in the "interpretation." We shall ignore the fact that the resulting structure is inconsistent (and hence not really a 3-valued interpretation). 8 These results make assumptions about the existence of certain distinguished constant symbols. See the cited references for these minor assumptions. 38 CHAPTER 3. <p> The following theorem summarizes results from <ref> [104] </ref>. Theorem 3.10.2: For normal programs over EDB's giving infinite Herbrand universes, the following relationships hold between queries expressible in the following semantics: Fitting = Well-founded = Inductive = Stable = 1 1 There are several other interesting expressibility results in the literature. <p> Schlipf has shown that while equally expressive over infinite Herbrand universes, the translation from Fitting's semantics to the well-founded semantics cannot be performed in a compositional manner <ref> [104] </ref>.
Reference: [105] <author> H. Seki. </author> <title> On the power of alexander templates. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1989. </year>
Reference-contexts: Unlike [51] and [106], our method distinguishes between EDB subgoals and IDB subgoals, using simple look-ups for EDB subgoals rather than performing resolution on them. A more technical difference occurs in step 3 of our algorithm. In [51] and other similar work on top-down methods with memoing <ref> [105, 106] </ref> it is possible to generate a subquery at a certain point, and at a later point in the same round generate a more general subquery, in which computation is repeated. For example, suppose we encounter the selected atom p (X; X). <p> We will thus be able to demonstrate that the two algorithms have the same complexity. Note that our claim is stronger than the more common claim that various methods infer the same sets of tuples. Some authors have considered the issue of "sip-optimality" <ref> [88, 105] </ref>. <p> Proof : By Theorem 5.5.1 and Theorem 5.3.3. 100 CHAPTER 5. EVALUATION: MEMOING AND MAGIC SETS In particular, Corollary 5.5.2 holds for all permissible programs. Corollary 5.5.3: The semi-naive bottom-up computation of SMR (P) has the same time complexity as QSQR/SLS. Seki <ref> [105] </ref> demonstrates a similar correspondence to that of Theorem 5.5.1 in the context of (not necessarily range-restricted) programs without negation. Ignoring our extension to programs with negation, our procedures are slightly different from Seki's: we use regional duplicate elimination while Seki uses incremental duplicate elimination.
Reference: [106] <author> H. Seki and H. Itoh. </author> <title> A query evaluation method for stratified programs under the extended CWA. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <year> 1988. </year>
Reference-contexts: An alternative justification is that SLS-resolution is effective for a limited class of programs, and for a less limited class (say, the class of stratified function-free programs) SLS-resolution can be extended with memoing features to make it effective <ref> [51, 106] </ref>. (See Chapter 5 for further discussion of memoing.) The main drawback of SLDNF-resolution is that it is too weak. <p> In the absence of function symbols, the Herbrand Base is finite, and so effective procedures exist. 3 For modularly stratified function-free programs global SLS-resolution may be made effective by using the memoing techniques of <ref> [51, 106] </ref> to prune loops (see Chapter 5). There are three sources of non-effectiveness in global SLS-resolution: 1. Infinite branches of an SLP-tree are treated as failed. 2. <p> This issue is related to the notion of compositionality (see Section 3.8). Kemp and Topor, and Seki and Itoh have proposed (similar) extensions of the QSQR/SLD top-down query evaluation procedure of Vieille [120, 121] from Horn programs to the class of stratified programs <ref> [51, 106] </ref>. We further generalize their methods, called QSQR/SLS-resolution in [51], to the class of modularly stratified programs. In the absence of negation, bottom-up computation may be made at least as efficient as a top-down approach by the use of an optimization technique known as magic sets [112]. <p> Kemp and Topor [51] and, independently, Seki and Itoh <ref> [106] </ref> have generalized these proposals to the class of stratified programs. We extend these methods to a larger class of programs, namely those programs that have finite negation trees, and still retain soundness, completeness and termination properties. In particular, this method can be extended to permissible programs. <p> We omit the details here. We now explain the major differences between Algorithm 5.3.1 and the algorithms presented in [51] and <ref> [106] </ref>. The first difference is in how the lemmas are established. In [51], "proof-segments" of SLD-type trees are used rather than derivation trees. In [106] they are called "subrefutations." The definition of proof segments is complicated by the fact that subsidiary information about other subgoals is embedded in the trees. <p> We omit the details here. We now explain the major differences between Algorithm 5.3.1 and the algorithms presented in [51] and <ref> [106] </ref>. The first difference is in how the lemmas are established. In [51], "proof-segments" of SLD-type trees are used rather than derivation trees. In [106] they are called "subrefutations." The definition of proof segments is complicated by the fact that subsidiary information about other subgoals is embedded in the trees. In our case, every derivation tree contains only information relevant to the subgoal at the root of the tree. <p> Our dynamic approach has the advantage that only those subgoals that do depend negatively on lower-level subgoals are suspended, while other subgoals can be expanded during that time. Unlike [51] and <ref> [106] </ref>, our method distinguishes between EDB subgoals and IDB subgoals, using simple look-ups for EDB subgoals rather than performing resolution on them. A more technical difference occurs in step 3 of our algorithm. <p> Unlike [51] and [106], our method distinguishes between EDB subgoals and IDB subgoals, using simple look-ups for EDB subgoals rather than performing resolution on them. A more technical difference occurs in step 3 of our algorithm. In [51] and other similar work on top-down methods with memoing <ref> [105, 106] </ref> it is possible to generate a subquery at a certain point, and at a later point in the same round generate a more general subquery, in which computation is repeated. For example, suppose we encounter the selected atom p (X; X).
Reference: [107] <author> J. C. Shepherdson. </author> <title> Negation as failure, II. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(3) </volume> <pages> 185-202, </pages> <year> 1985. </year>
Reference-contexts: We give a brief overview of previous approaches in this section, and leave the formal definitions until later in this chapter. 3.1.1 Program Completion Semantics The original "program completion" approach is due to Clark [27], and has been discussed in detail by Shepherdson <ref> [107, 108] </ref>, Kunen [56], and Lloyd [60]. The idea behind the completed program is to replace collections of "if " definitions by one "if and only if " definition. The completed program (or completed database) is not a normal program, but a conjunction of "if and only if " formulas. <p> Jaffar, Lassez and Lloyd showed that SLDNF was complete (in the same sense) for Horn programs with non-floundering 1 queries consisting of a conjunction of positive and/or negative literals [48]. SLDNF-resolution was further investigated for normal logic programs by Lloyd [60] (who coined the term SLDNF-resolution), Shepherdson <ref> [107, 108] </ref> (q.v. for further bibliography), and others. For some programs the completed program is inconsistent; for some others, the completed program is consistent but gives too weak a semantics for database applications. We shall illustrate these claims with examples in Section 3.7. <p> THREE-VALUED MODELS OF THE PROGRAM COMPLETION 25 3.4.2 Three-Valued Models The original "logical consequence" approach essentially declares that only conclusions that are logical consequences (in the classical, 2-valued sense) of the completed program should be inferred <ref> [27, 48, 60, 107] </ref>.
Reference: [108] <author> J. C. Shepherdson. </author> <title> Negation in logic programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88, </pages> <address> Los Altos, CA, 1988. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: We give a brief overview of previous approaches in this section, and leave the formal definitions until later in this chapter. 3.1.1 Program Completion Semantics The original "program completion" approach is due to Clark [27], and has been discussed in detail by Shepherdson <ref> [107, 108] </ref>, Kunen [56], and Lloyd [60]. The idea behind the completed program is to replace collections of "if " definitions by one "if and only if " definition. The completed program (or completed database) is not a normal program, but a conjunction of "if and only if " formulas. <p> Jaffar, Lassez and Lloyd showed that SLDNF was complete (in the same sense) for Horn programs with non-floundering 1 queries consisting of a conjunction of positive and/or negative literals [48]. SLDNF-resolution was further investigated for normal logic programs by Lloyd [60] (who coined the term SLDNF-resolution), Shepherdson <ref> [107, 108] </ref> (q.v. for further bibliography), and others. For some programs the completed program is inconsistent; for some others, the completed program is consistent but gives too weak a semantics for database applications. We shall illustrate these claims with examples in Section 3.7.
Reference: [109] <author> O. Shmueli. </author> <title> Decidability and expressiveness aspects of logic queries. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1987. </year>
Reference-contexts: We could ignore the negative subgoal, and establish that cycles do not occur in these rules since the second argument of p is decreasing with respect to &lt; at each step. 7.3 Shmueli's Construction In this section we review the construction of Datalog programs from context-free grammars from <ref> [109] </ref>. Let G = (N; T; P; S) be a context free grammar, where N is a finite set of nonterminals, T is a finite set of terminals, P is a finite set of productions and S is the start symbol. <p> Lemma 7.3.1: Let G 1 and G 2 be context-free grammars not producing the empty string. Then Q (G 1 ) Q (G 2 ) if and only if L (G 1 ) L (G 2 ). Proof : See <ref> [109] </ref>. In Section 7.2.3 we need a slight variant of this lemma when l is constrained to be acyclic. Let Q 1 and Q 2 be query-program pairs. <p> Let C be the acyclicity constraint specifying that the EDB relation l is acyclic in its first and third arguments. Then Q (G 1 ) C Q (G 2 ) if and only if L (G 1 ) L (G 2 ). Proof : The proof in <ref> [109] </ref> goes through even with the restriction that l is acyclic. Chapter 8 Semantics for Second Order Programs A number of "higher order" logics for programming languages and database systems have been recently proposed. One of these proposals is HiLog [25].
Reference: [110] <author> S. Sudarshan and R. Ramakrishnan. </author> <title> Aggregation and relevance in deductive databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1991. </year> <note> 156 BIBLIOGRAPHY </note>
Reference-contexts: Providing a sound semantic basis for declarative systems with aggregation is an important issue. Recursion through aggregation causes similar semantic problems to recursion through negation. Some results in this direction have been reported in <ref> [35, 50, 99, 110] </ref>. 9.2.2 Disjunctive Programs In [95] we generalize the well-founded semantics to disjunctive programs. Disjunctive programs allow information of the form p _ q without knowing p or q. We generalized the semantics in two ways, one "exclusive" in nature and the other "inclusive" in nature.
Reference: [111] <author> M. Takizawa. </author> <title> Distributed database system | JDDBS. </title> <booktitle> JARECT, Computer Science and Technologies, </booktitle> <volume> 7 </volume> <pages> 262-282, </pages> <year> 1983. </year>
Reference-contexts: In principle, declarativeness requires less of a user or programmer, and can thus be the basis of a system in which writing queries can be significantly less time-consuming than with a procedural language. Empirical results along these lines (for older database technology) have been reported in <ref> [111] </ref>. 1 Of course, declarativeness is not a black-or-white issue. Different people have different tastes in this respect. Compared with previous approaches, the database language SQL was far more declarative, and became widely accepted at least partly because of this feature. <p> Even more serious, though, is that potential for optimization is lost. An autonomous database may batch 1 It is also shown in <ref> [111] </ref> that coding queries in the procedural language produced queries that could be evaluated faster than the corresponding queries in the declarative language. It is unclear whether this comparison reflects well on the programmers in the study, or badly on the optimizer used in their declarative system.
Reference: [112] <author> J. D. Ullman. </author> <title> Bottom-up beats top-down for datalog. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1989. </year>
Reference-contexts: We further generalize their methods, called QSQR/SLS-resolution in [51], to the class of modularly stratified programs. In the absence of negation, bottom-up computation may be made at least as efficient as a top-down approach by the use of an optimization technique known as magic sets <ref> [112] </ref>. Several authors have considered the problem of extending the magic sets method to stratified programs. The approach of [8, 9] is to relabel predicates in a stratified program in such a way that the magic transformation results in a stratified program. <p> In fact, for Datalog programs without negation, semi-naive bottom-up evaluation of the rewritten program performs at least as well as a straightforward top-down method <ref> [112] </ref>. In Section 5.4.3 we describe a magic sets method for evaluating modularly stratified programs bottom-up. In particular, this method also works for stratified programs. Our proposal extends the magic templates method of [88] rather than the original magic sets proposals. <p> TOP-DOWN CAN BEAT BOTTOM-UP 103 6.2 Top-Down Can Beat Bottom-Up You may be startled by the title of this section, especially if you have seen the paper "Bottom-up Beats Top-down for Datalog," <ref> [112] </ref>. However, there is no inconsistency here: the model of top-down computation in [112] uses a (weak) form of memoing, whereas the one used in this section does not. <p> TOP-DOWN CAN BEAT BOTTOM-UP 103 6.2 Top-Down Can Beat Bottom-Up You may be startled by the title of this section, especially if you have seen the paper "Bottom-up Beats Top-down for Datalog," <ref> [112] </ref>. However, there is no inconsistency here: the model of top-down computation in [112] uses a (weak) form of memoing, whereas the one used in this section does not.
Reference: [113] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge Base Systems. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year> <title> (Two volumes). </title>
Reference-contexts: Roughly, declarativeness means that the person writing in that language specifies "what to compute" and not "how to compute it." For discussion of the relative merits of declarative and procedural (or imperative) systems, see <ref> [1, 39, 40, 55, 69, 113] </ref>. In principle, declarativeness requires less of a user or programmer, and can thus be the basis of a system in which writing queries can be significantly less time-consuming than with a procedural language. <p> In large databases they could make the difference between a query being feasible or infeasible. For non-recursive queries many well-known optimizations for relational databases can be applied. Several techniques for optimizing recursive queries have been recently proposed, including "magic-sets," "right-linear evaluation," "counting methods" and so on. (See <ref> [113] </ref> for a comprehensive discussion of these and other strategies.) Magic-sets [11, 13, 88, 93] is a general technique that can, in principle, be applied to any (recursive or nonrecursive) deductive database. <p> Chapter 2 Preliminaries In this chapter we present some of the basic terminology used throughout this thesis. We assume some familiarity with first order logic, relational algebra, and relational calculus. Most of the terminology used here is borrowed from Lloyd [60] and Ullman <ref> [113] </ref>. 2.1 Terminology In this section we introduce our notation and basic definitions, and describe the class of normal programs that we shall be considering in this thesis. <p> Such programs have also been called allowed [60] or safe <ref> [113] </ref>. 2 Definition 2.1.9: A program is stratified if there is an assignment of ordinal levels to predicates such that whenever a predicate appears negatively in the body of a rule, the predicate in the head of that rule is of strictly higher level, and whenever a predicate appears positively in <p> We present a magic sets transformation for modularly stratified programs that enables efficient computation bottom-up. In fact, we demonstrate a one-to-one correspondence between steps of (our extension of) QSQR/SLS-resolution and our magic-sets method. See <ref> [113] </ref> for a discussion of why bottom-up methods are likely to be preferable to top-down methods. In this chapter we assume all programs are function-free normal programs. <p> Every predicate has a unique minimal complete component to which it belongs. A program may be broken up into complete components according to the equivalence classes (called strongly connected components in <ref> [113] </ref>) induced on the predicates. <p> Bottom-up methods have the potential to work in a relation-at-a-time fashion, using efficient 80 CHAPTER 5. EVALUATION: MEMOING AND MAGIC SETS methods to compute large joins. See <ref> [113] </ref> for further discussion on the relative merits of top-down versus bottom-up methods. 5.4.1 Naive and Semi-Naive Evaluation "Naive" and "semi-naive" bottom-up evaluation of rules for programs without negation are now standard concepts in deductive databases [113]. <p> EVALUATION: MEMOING AND MAGIC SETS methods to compute large joins. See <ref> [113] </ref> for further discussion on the relative merits of top-down versus bottom-up methods. 5.4.1 Naive and Semi-Naive Evaluation "Naive" and "semi-naive" bottom-up evaluation of rules for programs without negation are now standard concepts in deductive databases [113]. While we shall rely on semi-naive evaluation, there is one subtlety that arises due to the presence of variables. When tuples can have variables in them 9 we must perform something more sophisticated than duplicate elimination. <p> Using magic predicates in the body restricts the tuples generated during the bottom-up computation to those that are relevant. We use a version of the magic templates method [88] that is also described in <ref> [113] </ref>. For every predicate p in the program we introduce a new "magic" predicate m p. Magic predicates have the same number of arguments as the original predicates. <p> We now define the supplementary magic rewriting of a program. We base our presentation on <ref> [113] </ref>. Definition 5.4.4: (Supplementary magic rewriting) Let P be a program. The supplementary magic rewriting of P , denoted SMR (P), contains three sets of rules, denoted P 0 , P 1 and P 2 . <p> Using this data structure will allow us to avoid recomputing the implication inside the universal quantifier every time P 2 is executed. Note that P 2 converges in one step since it is not recursive. As noted in <ref> [113] </ref>, we can further optimize the rewriting in several ways. For example, since the there is only one rule for each sup j:0 , and each such rule has only one subgoal, we could substitute the body of the rule directly into every place that sup j:0 is used. <p> To achieve such a program, occurrences of the same prediacte should be renamed apart if they have different binding patterns; also, subgoal rectification is necessary for subgoals with repeated variables. See <ref> [113] </ref> for details of how renaming and subgoal rectification are done. With our assumption about unique binding patterns, we can specialize the magic, dp and dn meta predicates so that their arguments contain only the bound variables from the original rules. <p> This transformation will allow the tail recursive evaluation of the right-recursive portion of the program while the remainder of the program is evaluated according to standard magic set techniques. The advantages of bottom-up methods over top-down methods are discussed in <ref> [113] </ref>. Bry's translation of SLD-resolution [19] explicitly represents the intermediate tuples, and hence does not take advantage of this potential optimization. We extend the magic templates method of Ramakrishnan [88] in which the magic predicates have the same arity as their corresponding IDB predicates, and nonground tuples are allowed. <p> We extend the magic templates method of Ramakrishnan [88] in which the magic predicates have the same arity as their corresponding IDB predicates, and nonground tuples are allowed. We use a version of magic templates with supplementary predicates, as in <ref> [113] </ref>. We also view magic as a meta-predicate in the sense of HiLog [25] rather than having a separate magic predicate m p for each p. We consider only Horn programs (with function symbols) in this chapter. <p> A vector ~ X represents a vector of terms, not necessarily lone variables. We now review the supplementary version of magic templates described in <ref> [113] </ref>. <p> At the end of this section we shall show that the modified magic templates method does no worse (and often much better) than ordinary magic templates for nonrepeating programs. So far, the examples where savings over magic sets are achieved have been right linear programs, so that right-linear optimization <ref> [76, 77, 113] </ref> could have been applied. Definition 6.5.2: (Right Linearity) Let P be a program in which there is a single IDB predicate p, which is labelled as right-recursive. Let ff be an adornment for p. Then P is right-linear with respect to ff if 1. <p> For each recursive rule, each argument of p that is free according to ff has the same variable in both the head and the recursive subgoal, and each of these variables appears only in these two positions. 2 In fact, it is noted in <ref> [113] </ref> that Prolog effectively applies tail-recursion optimization for right-linear programs. We shall demonstrate below some examples of nonrepeating programs that are not right linear, for which tail-recursion elimination produces a significant speedup.
Reference: [114] <author> J. Vaghani, K. Ramamohanarao, D. B. Kemp, Z. Somogyi, and P. J. Stuckey. </author> <title> The Aditi deductive database system. </title> <type> Technical Report TR-CS-90-14, </type> <institution> Kansas State University, </institution> <year> 1990. </year> <booktitle> Proceedings of the NACLP'90 Workshop on Deductive Databases. </booktitle>
Reference-contexts: Deductive database theory is reasonably mature, having been studied in its own right for almost a decade, and, in the context of logic programming, for longer. However, deductive database systems have only recently become available. For descriptions of various systems see <ref> [75, 79, 80, 89, 114] </ref>. The main advantages of deductive databases are expressiveness and declarativeness. One needs to be convinced that the extra expressiveness gives a useful extension to, say, relational algebra.
Reference: [115] <author> M. H. Van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> JACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: at once, we have an inconsistency. 2 Simultaneously negating all the atoms in an unfounded set effectively invokes the "closed-world assumption" [91] in Horn clause programs; if H is the Herbrand base and I is the set of atoms that represents the minimum Herbrand model of a Horn clause program <ref> [115] </ref>, then H I, the set of atoms not in I, is unfounded with respect to I . See Theorem 3.3.7. It is immediate that the union of arbitrary unfounded sets is an unfounded set. <p> I 1 is a total model, and we call this the well-founded model ; otherwise we call I 1 the well-founded partial model . 2 Theorem 3.3.7: Every Horn program has a well-founded model I 1 , which is the minimum model in the sense of Van Emden and Kowalski <ref> [115] </ref>, i.e., its positive literals are contained in every Herbrand model. Proof : Let H be the Herbrand base and let Q be the set of positive literals of I 1 . Q is a fixed point of T P [115]. <p> minimum model in the sense of Van Emden and Kowalski <ref> [115] </ref>, i.e., its positive literals are contained in every Herbrand model. Proof : Let H be the Herbrand base and let Q be the set of positive literals of I 1 . Q is a fixed point of T P [115]. In view of Theorem 3.3.6 it is sufficient to show that H Q U P (I 1 ). Let p be any positive literal in H Q. <p> We call P 00 the reduction of P with respect to I. 28 CHAPTER 3. DECLARATIVE SEMANTICS 3. Since P 00 is a Horn program, we can form its minimum (2-valued) model as in the standard least Herbrand model semantics <ref> [115] </ref>. In this context, "minimum," means that the set of positive literals is minimized, and hence the set of negative literals is maximized. <p> First, we briefly examine past work on procedural semantics. 4.1 Previous Approaches Based on the completion, Clark proposed a top-down procedural semantics known as "Negation as Failure," which when combined with SLD-resolution <ref> [115] </ref> is referred to as SLDNF-resolution. This method is sound with respect to the completion of the program, and is complete for Horn programs (possibly with negative subgoals in the goal only) [48]. Based on the perfect model approach, Przymusinski introduced SLS-resolution [85].
Reference: [116] <author> A. Van Gelder. </author> <title> Negation as failure using tight derivations for general logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 6(1) </volume> <pages> 109-133, </pages> <year> 1989. </year> <note> Preliminary versions appeared in Third IEEE Symp. on Logic Programming (1986), and Foundations of Deductive Databases and Logic Programming, </note> <editor> J. Minker, ed., </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Two such classes are stratified programs (Definition 2.1.9) and locally stratified programs (Definition 2.1.10). The stratified class has been treated in <ref> [6, 24, 59, 116] </ref>, and elsewhere. The locally stratified class, defined and studied by Przymusinski [82], is a superset of the class of stratified programs. Przymusinski defined perfect models, and showed that every locally stratified program has a unique perfect model. These classes are discussed further in Section 3.6. <p> For normal programs there has been much recent work on semantics in the presence of negation in the rule bodies. Stratification is a syntactic restriction on programs that prevents a predicate from recursing negatively through itself <ref> [6, 24, 116] </ref>. A stratified program has a well defined semantics given by the Herbrand model constructed by taking least fixpoints at successively higher "levels." However, there are nonstratified programs for which a clear semantics can be discerned.
Reference: [117] <author> A. Van Gelder. </author> <title> The alternating fixpoint of logic programs with negation. </title> <journal> Journal of Computer and System Sciences, </journal> <note> 1992. (to appear). Available as UCSC-CRL-89-39. Preliminary abstract appeared in Eighth ACM Symposium on Principles of Database Systems, </note> <year> 1989. </year>
Reference-contexts: Unfounded sets are defined in Section 3.3. Since the well-founded semantics was presented at a conference [118], several alternative formulations of the well-founded semantics have been developed <ref> [18, 33, 84, 117] </ref>. We believe that this agreement indicates a robustness of the semantics, and provides evidence that it coincides well with intuition, at least in the context of deductive databases. 3.1.4 Inflationary Semantics The inflationary semantics was proposed in [54] and, independently, in [3].
Reference: [118] <author> A. Van Gelder, K. A. Ross, and J. S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <booktitle> In Proc. Seventh ACM Symposium on Principles of Database Systems, </booktitle> <year> 1988. </year> <note> Full version to appear in J.ACM. </note>
Reference-contexts: Unfounded sets are defined in Section 3.3. Since the well-founded semantics was presented at a conference <ref> [118] </ref>, several alternative formulations of the well-founded semantics have been developed [18, 33, 84, 117]. <p> Theorem 3.5.2: (Van Gelder, Schlipf ) Let M be a total model of P . Then M is stable if and only if it is a fixed point of W P . Proof : See <ref> [118] </ref>. Corollary 3.5.3: Let I be a total interpretation of P . Then I is a fixed point of S if and only if it is a fixed point of W P . <p> We shall generalize the concept of local stratification to "modular stratification" in Chapter 5; when the move relation is acyclic, the above program is modularly stratified. 2 For an extended example involving a VLSI layout problem that might easily arise in practice, see <ref> [118] </ref>. A theme that runs through these examples is that well-founded semantics frequently agrees with other semantics, but seems to avoid their awkward cases. <p> Proof : See <ref> [118] </ref>. The Fitting model also has polynomial data complexity (for function-free programs). The proof is similar to that of Theorem 3.9.1 above. <p> However, even with a preferential computation rule, SLDNF-resolution is incomplete as it does not treat infinite branches of an SLP-tree as failed. 3 A polynomial time algorithm for constructing the well-founded model for function-free programs, that is bottom-up in nature, is given in the full version of <ref> [118] </ref>. Chapter 5 Evaluation: Memoing and Magic Sets 5.1 Background Much recent work has concerned defining the semantics of negation in deductive databases. The "perfect model semantics" [82] has been generally accepted as natural, and is the basis for several experimental deductive database systems. <p> A stratified program has a well defined semantics given by the Herbrand model constructed by taking least fixpoints at successively higher "levels." However, there are nonstratified programs for which a clear semantics can be discerned. This observation led to the development of the well-founded semantics <ref> [118] </ref> and the stable-model semantics [37] which provide semantics for programs that are not necessarily stratified. (See Chapter 3.) 126 8.1. HILOG 127 In this chapter we generalize the well-founded semantics and stable model semantics to HiLog programs that can have negation in the rule bodies. <p> Adding an unrelated fact such as r (b) would change the answer to the query ?p by supplying an additional constant to the vocabulary. This issue is related to the universal query problem discussed in <ref> [85, 118] </ref>. One solution is to augment the program with extra function and constant symbols so that this problem does not occur. 8.2.
Reference: [119] <author> M. Y. Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> In 14th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 137-145, </pages> <year> 1982. </year>
Reference-contexts: However, for function-free programs, the Herbrand universe is finite and the construction is effective. Theorem 3.9.1 below shows that the data complexity of the well-founded semantics, as defined by Vardi <ref> [119] </ref>, is polynomial. From this standpoint it is competitive with other methods, such as the stratified semantics, whose data complexity has been studied elsewhere [23, 42, 47, 119], and the Fitting model (as remarked below). <p> Theorem 3.9.1 below shows that the data complexity of the well-founded semantics, as defined by Vardi [119], is polynomial. From this standpoint it is competitive with other methods, such as the stratified semantics, whose data complexity has been studied elsewhere <ref> [23, 42, 47, 119] </ref>, and the Fitting model (as remarked below). Definition 3.9.1: The data complexity of an IDB with respect to a fixed ground atomic query Q is defined as the computational complexity of deciding the answer to Q as a function of the size of the EDB. <p> By assuming a distinguished predicate that provides an ordering of database elements, it can be shown that on finite EDB's the inductively definable relations are precisely those computable in polynomial time <ref> [23, 42, 47, 119] </ref>. Schlipf has shown that while equally expressive over infinite Herbrand universes, the translation from Fitting's semantics to the well-founded semantics cannot be performed in a compositional manner [104].
Reference: [120] <author> L. Vieille. </author> <title> Recursive axioms in deductive databases: The query-subquery approach. </title> <booktitle> In Proc. First International Conference on Expert Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: This issue is related to the notion of compositionality (see Section 3.8). Kemp and Topor, and Seki and Itoh have proposed (similar) extensions of the QSQR/SLD top-down query evaluation procedure of Vieille <ref> [120, 121] </ref> from Horn programs to the class of stratified programs [51, 106]. We further generalize their methods, called QSQR/SLS-resolution in [51], to the class of modularly stratified programs. <p> A way of pruning infinite branches is discussed in the next section. 5.3.2 Top-Down with Memoing Despite the soundness and completeness demonstrated in the previous section, global SLS-resolution may get lost down an infinite positive branch and hence not terminate. Several authors <ref> [30, 120, 121] </ref> have considered this problem in the context of Horn programs, and have proposed a form of memoing in which a positive literal is not "admissible" for selection if it is an instance of one of its ancestors.
Reference: [121] <author> L. Vieille. </author> <title> A database-complete proof procedure based on SLD-resolution. </title> <booktitle> In Proc. Fourth International Conference on Logic Programming, </booktitle> <year> 1987. </year>
Reference-contexts: This issue is related to the notion of compositionality (see Section 3.8). Kemp and Topor, and Seki and Itoh have proposed (similar) extensions of the QSQR/SLD top-down query evaluation procedure of Vieille <ref> [120, 121] </ref> from Horn programs to the class of stratified programs [51, 106]. We further generalize their methods, called QSQR/SLS-resolution in [51], to the class of modularly stratified programs. <p> A way of pruning infinite branches is discussed in the next section. 5.3.2 Top-Down with Memoing Despite the soundness and completeness demonstrated in the previous section, global SLS-resolution may get lost down an infinite positive branch and hence not terminate. Several authors <ref> [30, 120, 121] </ref> have considered this problem in the context of Horn programs, and have proposed a form of memoing in which a positive literal is not "admissible" for selection if it is an instance of one of its ancestors.
Reference: [122] <author> J. Widom and S. Finkelstein. </author> <title> A syntax and semantics for set-oriented production rules in relational database systems. </title> <type> manuscript, </type> <institution> IBM Corporation, </institution> <year> 1989. </year>
Reference-contexts: In OPS5 it is possible to update the database within rules, and so it certainly does not provide the sort of declarativeness we are looking for. Nevertheless, there may be a role for production-rule based languages like OPS5 in database systems, for "triggers" <ref> [122] </ref> or as a general purpose language. 3.2. PARTIAL INTERPRETATIONS 17 For example, consider the program q t; :p p At the first iteration t and p are inferred, and no more facts are generated at later stages.
Reference: [123] <author> L. Wong. </author> <title> Inference rules in object oriented programming systems. </title> <booktitle> In Proceedings of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <year> 1989. </year>
Reference-contexts: In languages such as HiLog it is possible to define parameterized procedures, or in the object-oriented terminology, "methods." A promising approach is the integration of some object oriented features in a deductive database framework. Various such attempts have been reported in <ref> [2, 44, 62, 123] </ref>. A successful integration would provide mechanisms for encapsulation, inheritance, complex objects and other object-oriented concepts while retaining the declarativeness and formal basis of deductive databases.
References-found: 123

