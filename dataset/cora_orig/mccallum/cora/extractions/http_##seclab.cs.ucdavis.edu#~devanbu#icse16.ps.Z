URL: http://seclab.cs.ucdavis.edu/~devanbu/icse16.ps.Z
Refering-URL: http://seclab.cs.ucdavis.edu/~devanbu/prem_papers.html
Root-URL: http://www.cs.ucdavis.edu
Email: fprem,jonesg@research.att.com  
Title: The Use of Description Logics in KBSE systems Survey Paper  
Author: Premkumar T. Devanbu Mark A. Jones 
Date: February 9, 1994  
Address: Murray Hill, NJ 07063  
Affiliation: Artificial Intelligence Principles Research Department AT&T Bell Laboratories  
Abstract: The increasing size and complexity of many software systems demand a greater emphasis on capturing and maintaining knowledge at many different levels within the software development process. This knowledge includes descriptions of the hardware and software components and their behavior, external and internal design specifications, and support for system testing. The knowledge-based software engineering (KBSE) research paradigm is concerned with systems that use formally represented knowledge, with associated inference procedures, to support the various subactivi-ties of software development. As they grow in scale, KBSE systems must balance expressivity and inferential power with the real demands of knowledge base construction, maintenance, performance and comprehensibility. Description Logics (DL's) possess several features a terminological orientation, a formal semantics and efficient reasoning procedures which offer an effective tradeoff of these factors. We discuss three KBSE systems in which DL's capture some of the requisite knowledge needed to support design, coding and testing activities. We close with a discussion of the benefits of DL's and ways to address some of their limitations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Brooks, F. P. </author> <title> No Silver Bullet: </title> <journal> Essence and Accidents of Software Engineering. IEEE Computer Magazine, </journal> <month> April, </month> <year> 1987. </year>
Reference-contexts: Brooks <ref> [1] </ref> calls this the invisibility problem, and claims that it is both a key obstacle to successful software engineering and an essential property of software. While the structure of automobiles and buildings can be elucidated by blueprints or mechanical drawings, there is nothing analogous for software systems.
Reference: [Brachman & Levesque 1984] <author> Brachman, R.J. and Levesque, H.J. </author> <title> The Tractability of Subsumption in Frame-Based Description Languages. </title> <booktitle> In Proc. of the National Conference on Artificial Intelligence, </booktitle> <address> Austin, TX, 34-37, </address> <year> 1984. </year>
Reference-contexts: Unfortunately, as the number of such constructs are added to a DL, the difficulty of reasoning with them increases. This topic has been studied extensively <ref> [Brachman & Levesque 1984, 17, 8] </ref>, and difficulty of computing with various combinations of operators is now well understood.
Reference: [2] <author> Brachman, R.J., Borgida, A., McGuinness, D.L., and Alperin Resnick, L. </author> <title> The CLASSIC Knowledge Representation System, Or, KL-ONE: The Next Generation. </title> <booktitle> In preprints of Workshop on Formal Aspects of Semantic Networks, </booktitle> <address> Santa Catalina Island, CA, </address> <year> 1989. </year>
Reference: [3] <author> Borgida, A., Brachman, R.J., McGuinness, D.L., and Resnick, L.A. </author> <title> CLASSIC: A Structural Data Model for Objects. </title> <booktitle> In Proc. of ACM SIGMOD-89, Portland, Oregon, </booktitle> <pages> 58-67, </pages> <year> 1989. </year>
Reference-contexts: They reason with descriptions of individuals, roles (relationships between individuals), and concepts (sets of individuals that share common properties). Quite complex descriptions may be formed in DL's such as classic <ref> [3] </ref>. Individuals are specific named objects that occur in the domain of interest. In a knowledge base containing cross-reference information about global names in a software system, these may be individuals like MainInit, GetEnv, OutFileId. <p> For a full discussion of the features of classic, see <ref> [3] </ref>; for our purposes, it is useful to summarize the principal types of inference mechanisms supported by description logics such as classic: Subsumption: DL's automatically infer IS-A (sub-sumption) relationships between individuals and concepts, and between concepts, based on the semantics of the description. <p> KITSS can be viewed as providing knowledge-assisted translation, somewhat analogous to the assistance provided to human translators by machine translation systems [11]. The classic knowledge representation system <ref> [3] </ref> provides a DL that figures prominently in this task.
Reference: [4] <author> Borgida, A. and Brachman, R. ProtoDL: </author> <title> A customizable knowledge base management system, </title> <booktitle> Proceedings, Conference on Information and Knowledge Management, </booktitle> <address> Baltimore, MD, </address> <year> 1992. </year>
Reference-contexts: In LaSSIE, constructs were added to classic to form sequences, non deterministic choices, and loops over actions; new algorithms to perform subsumption over these constructs were developed. This extension (clasp [6]) could not be fully integrated with classic; however, the ProtoDL <ref> [4] </ref> system is specifically designed for this purpose: a basic scaffolding of DL operations can be extended by defining new constructs and a set of required operations for each construct.
Reference: [5] <author> Brachman, R.J., McGuinness, D.L., Patel-Schneider, P.F., Alperin Resnick, L., and Borgida, A. </author> <title> Living with CLASSIC: When and How to Use a KL-ONE-like Language. In Formal Aspects of Semantic Networks, </title> <editor> J. Sowa, ed., </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: To adequately represent the dynamic model required an expressive power beyond a terminological logic such as classic. For example, classic is not suited well for performing the kind of extensive temporal reasoning <ref> [5] </ref> that is required by the analyzer. KITSS uses, instead, a linear-time first-order resolution theorem prover with a weak temporal logic. This non-standard logic has four modal operators holds, occurs, begins, and ends which are sufficient to represent all temporal aspects of our domain. <p> Although description logics have many attractive properties, there are representation and reasoning tasks for which they are unsuitable. A further discussion of their limitations can be found in Brachman et al <ref> [5] </ref>.
Reference: [6] <author> Devanbu, P. and Litman, D. </author> <title> Plan-Based Terminological Reasoning. </title> <booktitle> In Proceedings of KR '91, </booktitle> <address> Boston, MA, </address> <year> 1991. </year>
Reference-contexts: The analyzer also does a limited amount of plan generation since the test cases include intentional statements such as "make station A busy". Although simple forms of planning have been implemented in the classic framework (see <ref> [6] </ref>), KITSS did not use it for this purpose. To adequately represent the dynamic model required an expressive power beyond a terminological logic such as classic. For example, classic is not suited well for performing the kind of extensive temporal reasoning [5] that is required by the analyzer. <p> In LaSSIE, constructs were added to classic to form sequences, non deterministic choices, and loops over actions; new algorithms to perform subsumption over these constructs were developed. This extension (clasp <ref> [6] </ref>) could not be fully integrated with classic; however, the ProtoDL [4] system is specifically designed for this purpose: a basic scaffolding of DL operations can be extended by defining new constructs and a set of required operations for each construct.
Reference: [7] <author> Devanbu, P., Brachman, R., Selfridge, P., and Bal-lard, B. </author> <title> LaSSIE: A Knowledge-based Software Information System. </title> <booktitle> In Communications of the ACM, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: In addition, the user may need to know certain general rules about connecting trunks. For example, in the architecture, it should be implemented by sending an TrnkConn message to the TrnkMgr process; there may be records to be logged when international trunks are connected. The LaSSIE system <ref> [7] </ref> was an attempt to address the invisibility problem by providing the software developer with a knowledge based information system with inferential ability, enhanced with a natural language interface and a graphical browser.
Reference: [8] <author> Donini, F., Lenzerini, M., Nardi, D., Nutt, W. </author> <title> The Complexity of Concept Languages </title>
Reference-contexts: Unfortunately, as the number of such constructs are added to a DL, the difficulty of reasoning with them increases. This topic has been studied extensively <ref> [Brachman & Levesque 1984, 17, 8] </ref>, and difficulty of computing with various combinations of operators is now well understood. <p> This topic has been studied extensively [Brachman & Levesque 1984, 17, 8], and difficulty of computing with various combinations of operators is now well understood. For example, reasoning with just and, all, and not is polynomial <ref> [8] </ref>; as more constructs are added, subsumption becomes increasingly more difficult, and very powerful languages such as KL-ONE are known to be undecidable [17]. Most practical DL's such as classic deliberately limit the constructs they allow in order to provide a reasonably efficient subsumption procedure.
Reference: [9] <author> Hammond, K. CHEF: </author> <title> A Model of Case-based reasoning, </title> <booktitle> Proceedings, Fifth National Conference on Artificial Intelligence, </booktitle> <month> August </month> <year> 1986, </year> <title> Philadephia, </title> <address> PA. </address>
Reference-contexts: The support for reference resolution in the natural language module in KITSS is analogous: given a referring description, we find the set of individuals which are subsumed by it. Note that retrieval can be performed by other methods such as case-based reasoning systems (CBR) <ref> [9] </ref>. CBR systems use a form of nearest neighbor reasoning to retrieve similar instances. Such systems, however, do not use semantically well-founded inferences and they explicitly eschew the idea of forming class abstractions.
Reference: [10] <author> Jones, M.A. and Eisner, </author> <title> J.E. A Probabilistic Parser Applied to Software Testing Documents. </title> <booktitle> In Proc. of the 10th National Conference on Artificial Intelligence, </booktitle> <address> San Jose, CA, 322-328, </address> <year> 1992. </year>
Reference-contexts: While the processing of unrestricted natural language text is still beyond the state of the art, the sentences that KITSS must process form a reasonably limited sublanguage (informally called "telephonese"). One of the major successes in KITSS was a trainable, statistical parsing technology for such sublanguages <ref> [10] </ref>. The parser maintains syntactic-semantic statistics on the linguistic constructs that it encounters during training. The statistics reflect what concepts occur in the language that people use to describe the external behavior of the device.
Reference: [11] <author> Kelly, V.E. and Jones, M.A. </author> <year> 1993. </year> <title> KITSS: A Knowledge-Based Translation System for Test Scenarios. </title> <booktitle> In Proc. of the 11th National Conference on Artificial Intelligence, </booktitle> <address> Washington, D.C., </address> <pages> 804-810. </pages>
Reference-contexts: The automation of the conversion task, while quite challenging, is less ambitious than general program synthesis since the program steps are informally specified in the English test case. KITSS can be viewed as providing knowledge-assisted translation, somewhat analogous to the assistance provided to human translators by machine translation systems <ref> [11] </ref>. The classic knowledge representation system [3] provides a DL that figures prominently in this task.
Reference: [12] <author> Levesque, H. </author> <title> A Functional Approach to Knowledge Representation, </title> <journal> Artificial Intelligence, </journal> <year> 1986. </year>
Reference-contexts: Build around the DL: In many cases, the DL's can be used an "abstract data type" at the "knowledge level" <ref> [12] </ref>, which provides a basic, well-defined reasoning functionality in an efficient manner; the rest of the job is done by software constructed around the DL subsystem.
Reference: [13] <author> Lewis-Johnson, W. and Benner, K.M. </author> <booktitle> The Current Status of Knowledge-based Software Engineering. </booktitle> <address> USC/ISI, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Every aspect of software development, particularly in large systems, demands a great deal of knowledge and understanding of the software practitioner. In his comprehensive survey of KBSE research <ref> [13] </ref>, Lewis Johnson lists a wide range of systems that assist different software engineering activities such as requirements acquisition, software synthesis and analysis, and software project management.
Reference: [14] <author> MacGregor, R. M. </author> <title> Inside the loom Description Classifier. </title> <journal> ACM SIGART Bulletin 2(3), </journal> <year> 1991 </year>
Reference-contexts: To execute a completed design, the developer has to identify (or deduce) and meet all new or modified com mitments. This is a difficult, knowledge-intensive pro-cess which COMET supports, using a knowledge base of module descriptions to identify, derive, and track commitment creation and fulfillment. COMET uses the loom <ref> [14] </ref> description logic. 5.1 The COMET Knowledge base To use COMET in this fashion, one must first populate its knowledge base with descriptions of a set of basic modules (including behavior and input/output commitments). In the radar tracking domain, basic modules might include spatial geometry and Newto-nian mechanics.
Reference: [15] <author> Mark, W., Tyler, S., McGuire, J., Schlossberg, J. </author> <title> Commitment-Based Software Development. </title> <journal> IEEE Transactions on Software Engineering 18:10, </journal> <volume> Octo-ber, </volume> <year> 1992. </year>
Reference-contexts: In this way, each of the fields Verb, Name, ID, Field-ID, and Text are filled in automatically when an individual of type Administration-Command is classified. 5 The COMET system COMET <ref> [15] </ref> is concerned with assisting a developer with module design in the context of an existing design framework. Modules are viewed as having signature and behavior. The signature embodies commitments that the module makes to its input and output. <p> An example is BINARYSEARCH in 5 (d), which shows that binary search 2 These adapted slightly from examples shown in <ref> [15] </ref>, for our own narrative and terminological consistency. (define-concept ASSIGN-CONTACT2TRACK (and PROCEDURE-MODULE (some submodule NEWTRACKFIND) (some input-port (and SORTED-ARRAY (all type TRACK))) (some submodule UPDATETRACKS))) (a) (define concept NEWTRACKFIND (and PROCEDURE-MODULE (some input-port (and SORTED-ARRAY (all element-type TRACK))) (some input-port (exactly 1 type CONTACT)) (some behavior BINTRACKFIND) (exactly 1 out-port (exactly <p> For this, it makes intimate use of the collection of module descriptions in the knowledge base. COMET graphic user interface (adapted very slightly from <ref> [15] </ref>.) Here, boxes represent data, and ovals represent procedures. Edges represent commitments (either data flow or control flow); unmet commitments are shown solid lines, and changed to dotted lines as they are met in the current design. <p> A module is a candidate if "it's description is subsumed by the developer's description, and their commitments can potentially be met in the current design <ref> [15] </ref>" (italics ours). So, an exact match is not necessary; the designer can work with something similar and adapt it. Candidate descriptions are presented to the user in the DM (shaded oval). The user selects one of these, modifies it, and incorporates it into the design in the MD.
Reference: [16] <author> Nonnenmann, U., and Eddy J.K. </author> <title> KITSS A Functional Software Testing System Using a Hybrid Domain Model. </title> <booktitle> In Proc. of 8th IEEE Conference on Artificial Intelligence Applications. </booktitle> <address> Monterey, CA: </address> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: hears dial tone A dials B Verify that B is not ringing with ringping Verify that C is ringing with normal ring C goes offhook Verify that A is talking to C CLEANUP A goes onhook B goes onhook C goes onhook Admin the switch using admin-script-2 Scripts System (KITSS) <ref> [16] </ref> provides automated assistance in converting test cases into the executable testing language. An example of the target output for KITSS (corresponding to the test case in Figure 3) is shown in Figure 4.
Reference: [17] <author> Patel-Schneider, P.F. </author> <title> Undecidability of Subsump-tion in NIKL, </title> <journal> Artificial Intelligence 39:2, </journal> <year> 1989. </year>
Reference-contexts: Unfortunately, as the number of such constructs are added to a DL, the difficulty of reasoning with them increases. This topic has been studied extensively <ref> [Brachman & Levesque 1984, 17, 8] </ref>, and difficulty of computing with various combinations of operators is now well understood. <p> For example, reasoning with just and, all, and not is polynomial [8]; as more constructs are added, subsumption becomes increasingly more difficult, and very powerful languages such as KL-ONE are known to be undecidable <ref> [17] </ref>. Most practical DL's such as classic deliberately limit the constructs they allow in order to provide a reasonably efficient subsumption procedure.
Reference: [18] <author> Refine Users Manual, </author> <title> The Reasoning Systems Corporation, </title> <address> Palo, Alto, CA.. </address>
Reference-contexts: A similar use of these constraints can be found in configuration systems. This capability in DL's is very limited (though adequate for the applications described here). For more sophisticated kinds of matching/translation, a transformational systems such as refine <ref> [18] </ref> may be more suitable. Situations arise where the limited power of DL's becomes an issue. In such cases, there are several pragmatic approaches used in the systems we describe and others: Living within the DL: For some KBSE systems, all the necessary reasoning is supported by the description logic.
Reference: [19] <author> Swartout, B., and Neches, R. </author> <title> The shifting terminological space: an impediment to evolvability, </title> <booktitle> in Proceedings, AAAI-86. </booktitle>
Reference-contexts: and classification also play a crucial role in helping to build the different module descriptions into the KB and keep it organized. 6 Summary and Conclusions DL's offer advantages in several tasks: Terminological reasoning: Many of the problems of scale and evolution in software systems involve issues of terminology (vocabulary). <ref> [19] </ref> argue that, in languages which lack an independent definition of terminology, terms acquire meaning solely by virtue of the rules (or formulae) in which they occur. Since the meanings of terms are implicit, it becomes harder to maintain such systems.
Reference: [20] <author> Waters, R. </author> <title> A Method for Automatically Analyzing Programs. </title> <booktitle> In Proceedings, IJCAI '79, </booktitle> <address> Tokyo, Japan, </address> <year> 1979. </year>
Reference-contexts: An experienced developer is fluent in the vocabulary of the domain model. She understands how the objects and operations therein are manifest in the architecture and constrained for this particular system. Her knowledge includes various code idioms (or "cliches" <ref> [20] </ref>), and how they are combined to implement the switching features such as POTS. Besides the architecture and the domain views, the LaSSIE knowledge base includes the code view, which simply consists of syntactic information such as the functions, variables, and files that comprise the system.
Reference: [21] <author> Zave, P, and Jackson, M. </author> <title> Techniques for Partial Specification and Specification of Switching Systems. </title> <booktitle> In Proceedings of the VDM '91 Symposium, </booktitle> <year> 1991. </year>
Reference-contexts: The theorem proving is tractable due to the tight integration between knowledge representation and reasoning. The challenging task in building the dynamic model was to understand and extract what the invariants, constraints, and rules were <ref> [21] </ref>. Representing them then in the temporal logic was much easier.
References-found: 22

