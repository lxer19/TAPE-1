URL: http://www.cs.ucsb.edu/~mcguire/papers/97:q_wk.ps
Refering-URL: http://www.cs.ucsb.edu/~mcguire/
Root-URL: http://www.cs.ucsb.edu
Title: Generating Trace Checkers for Test Oracles  
Author: H. W. McGuire, L. K. Dillon Y. S. Ramakrishna 
Keyword: formal specification, verification, specification-based test oracles, tableau methods, propositional temporal logic, test validation.  
Address: Santa Barbara, CA 93106  New York Stony Brook, NY 11794  
Affiliation: Department of Computer Science University of California  Computer Science Department State University of  
Abstract: A generic tableau algorithm, which is the basis for a general customizable method for producing test oracles from temporal logic specifications, is described in [8]. The algorithm accepts semantic rules as parameters for building the semantic tableau for a specification. Parameterizing the tableau algorithm by semantic rules permits it to easily accommodate a variety of temporal operators and provides a clean mechanism for fine-tuning the algorithm to produce efficient oracles. In this paper, we report on our prototype implementation of the algorithm and on our experience with its use. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Blum and H. Wasserman. </author> <title> Program result-checking: A theory of testing meets a test of theory. </title> <booktitle> In Proc. IEEE Symp. Foundations of Computer Science, </booktitle> <year> 1994. </year>
Reference: [2] <author> G. V. Bochmann, R. Dssouli, and J. R. Zhao. </author> <title> Trace analysis for conformance and arbitration testing. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 15(11) </volume> <pages> 1347-1355, </pages> <month> November </month> <year> 1989. </year>
Reference: [3] <author> J. Burch, E. Clarke, K. McMillan, D. Dill, and L. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proc. 5th IEEE Symp. Logic in Computer Science, </booktitle> <pages> pp. 428-439, </pages> <year> 1990. </year>
Reference-contexts: of oracles can be useful in revealing faults. (Test generation, and the extent of "coverage" afforded by specific tests, is beyond the scope of this paper.) Much of the recent impressive progress in model checking can be traced to the development of symbolic techniques, for example binary decision diagrams (BDDs) <ref> [3] </ref>, and of partial order techniques [23]. However, neither symbolic techniques nor partial order techniques would seem beneficial for constructing test oracles.
Reference: [4] <author> S. E. Chodrow, F. Jahanian, and M. Donner. </author> <title> Run-time monitoring of real-time systems. </title> <booktitle> In Proc. IEEE Real-Time Systems Symp., </booktitle> <pages> pp. 74-83, </pages> <address> San Antonio, TX, </address> <month> December </month> <year> 1991. </year>
Reference: [5] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: But specifications of critical correctness properties tend to be short and concise, and therefore produce efficient oracles with which to check execution traces. Model checking subjects a model of a system to exhaustive analysis and decides whether the model satisfies a given specification <ref> [5, 26] </ref>. Current model-checking technology does not yet allow complete automated verification of general systems, because of their large state spaces. For this reason, model checking is used to verify an abstract model of the system, rather than the program (s) implementing it.
Reference: [6] <author> L. K. Dillon. </author> <title> Temporal Oracles for Testing and Debugging Concurrent Software Systems. </title> <booktitle> In Proc. Software Quality Week 1995 (8th International Conf.), Paper No. 3-T-4. Software Research Institute, </booktitle> <address> San Francisco, </address> <year> 1995. </year>
Reference-contexts: While PTL may have some advantages such as simplicity, an advantage of GIL is that a fault in a trace being checked can be shown graphically; such display is illustrated in <ref> [6, 9] </ref>.
Reference: [7] <author> L. K. Dillon, G. Kutty, L. E. Moser, P. M. Melliar-Smith, and Y. S. Ramakrishna. </author> <title> A graphical interval logic for specifying concurrent systems. </title> <journal> ACM Trans. Software Engineering and Methodology, </journal> <volume> 3(2) </volume> <pages> 131-165, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: This paper describes the design of our prototype oracle generator for Propositional Temporal Logic (PTL) [13] and Graphical Interval Logic (GIL) <ref> [7] </ref>. We discuss our laboratory experiments using different semantic rules to determine the effect on the tableau generated to check test traces. We also provide some comparison of the efficiency of oracles generated by our tableau method with that of GIL-based oracles generated by other methods [18]. <p> r in (2 0 ) is fi j 7 * .7 * .in1 2 (:in2 ^ turn1); and for (2 0 ) altogether: 2 B @ turn1 ) j 7 * .7 * . j 7 * .7 * .in1 2 (:in2 ^ turn1) 2 (in2 ^ turn1) 1 C <ref> [7] </ref> formalizes this translation for GIL. Appendix A here defines the GIL operators used in this paper. To obtain semantic tableaux from GIL specifications, we instantiate the algorithm defined in Subsection 4.2 with rules for reducing GIL operators. Reduction rules for GIL are more complex than those for PTL. <p> In each of the rules [r p] and [r t], I is the same as the interval on the left side of the "!," and I s is also the same interval except that it is qualified to be of non-null duration (this is called "strong"; see <ref> [7] </ref>); and formula p is restricted to be purely propositional (i.e. containing no temporal operators). Table 2: Sample reduction rules for GIL. The GIL specifications (1 0 ) and (2 0 ) and the GIL reduction rules can be used like the PTL material above, yielding analogous results. <p> When a trace violates a specification, the oracle can provide feedback regarding the fault that was detected [9]. We had previously applied the tableau algorithm in this paper with our own high-level temporal logic, Graphical Interval Logic (GIL), an interval temporal logic with a graphical representation <ref> [7] </ref>. The definition of a tableau procedure for a real-time extension of GIL appears without proof in [19]. <p> Complete details for GIL | including formalization of the translation to this textual form | are given in <ref> [7] </ref>. Definition A.2 The following BNF summarizes the syntax of the GIL operators: ::= 7 * .t 7 * .t 1 7 * .7 * .t 7 * .7 * .t 1 f ::= If 1 where t is a `target' formula and f and f 1 are formulas. <p> 6= ?, then l 0 &lt; l 1 and S [l 0 ::l 1 ) j= f . (The notation "S [l 0 ::l 1 )" naturally specifies the subsequence of S starting at l 0 and ending just before l 1 .) For further details including NNF equivalences, see <ref> [7] </ref>. The next definition relates to flow graphs. Definition A.3 Let G = (Alph; Locs ; Trans; Lab; Flow ; Init; Fin) denote a flow graph. Additionally, for a location L 2 Locs , let Out (L) and In (L) denote the sets of outgoing and incoming transitions, respectively.
Reference: [8] <author> L. K. Dillon and Y. S. Ramakrishna. </author> <title> Generating oracles from your favorite temporal logic specifications. </title> <booktitle> Proc. 4th ACM SIGSOFT Symp. Foundations of Software Engineering, </booktitle> <pages> pp. 106-117, </pages> <address> San Francisco, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Similar considerations fl This research was supported in part by NSF Grant CCR-9505392. impede specification-dependent optimizations which could result in more efficient oracles. We describe a generic tableau algorithm, which is the basis for a general customizable method for producing oracles from temporal logic specifications, in <ref> [8] </ref>. A procedure for producing semantic tableaux from specifications is obtained by instantiating the generic tableau algorithm with rules expressing the semantics of the operators in a temporal logic. The semantic tableau generated from a specification describes a finite state automaton that accepts precisely those state sequences satisfying the specification. <p> We also provide some comparison of the efficiency of oracles generated by our tableau method with that of GIL-based oracles generated by other methods [18]. This paper presents some material from <ref> [8] </ref> as well as new material based on implementing the method and using the implementation. In Section 2, we discuss the relationship between our work and the substantial body of other work on tableau decision procedures. <p> Because the number of formulas that can be generated in this fashion is finite, only a finite number of locations can be produced, and the elaboration process eventually terminates. The tableau algorithm is given in <ref> [8] </ref>; we use "TPROC ()" to denote it. <p> A proof that TPROC () produces a correct tableau procedure when instantiated with a set of rules that is both valid and complete appears in <ref> [8] </ref>. By Observation 4.10 and Observation 4.13, therefore, TPROC 1 (2; 3) accepts precisely those state sequences satisfying the given specification for mula f 0 . 4.3 Customizing the Tableau Method To use the tableau method with additional temporal operators, we need only supply it with appropriate reduction rules.
Reference: [9] <author> L. K. Dillon and Q. Yu. </author> <title> Oracles for checking temporal properties of concurrent systems. </title> <booktitle> In Proc. 2nd ACM SIGSOFT Symp. Foundations of Software Engineering, </booktitle> <pages> pp. 140-153, </pages> <address> New Orleans, </address> <month> December </month> <year> 1994. </year> <note> ACM Press. </note>
Reference-contexts: In Section 5 we discuss our implementation, including results from our experiments with it. In conclusion, we briefly describe our ongoing research in Section 6. 2 Related Work The relationship between our work on test oracles and that of others engaged in testing research is discussed in <ref> [9] </ref>. Here, we concentrate on work related to tableau decision procedures in theorem proving and verification. Most propositional temporal logics are interpreted over infinite state sequences, permitting formulas to specify properties of both terminating and nonterminating executions [13]. <p> We use LTL formulas to describe properties that are to be verified of test executions. We therefore assume state sequences are: * Finite, because test executions are finite. * Non-empty, because every test execution begins in an initial state. The example in <ref> [9] </ref> illustrates methods for defining primitive propositions and for generating finite state sequences that represent test executions of an Ada tasking program. [17] 2 more generally discusses (issues of) representation-mapping from actual behavior of a system being checked to some kind of trace that can be directly compared to or evaluated <p> While PTL may have some advantages such as simplicity, an advantage of GIL is that a fault in a trace being checked can be shown graphically; such display is illustrated in <ref> [6, 9] </ref>. <p> They can therefore support run-time monitoring and debugging, in addition to post-execution checking of logged traces. When a trace violates a specification, the oracle can provide feedback regarding the fault that was detected <ref> [9] </ref>. We had previously applied the tableau algorithm in this paper with our own high-level temporal logic, Graphical Interval Logic (GIL), an interval temporal logic with a graphical representation [7]. The definition of a tableau procedure for a real-time extension of GIL appears without proof in [19]. <p> the GIL tableau procedure and to facilitate exploration of methods for improving it. 7 A set of formulas is locally inconsistent if it contains false or if there is a formula f for which the set contains both f and :f . 11 For various reasons which are discussed in <ref> [9] </ref>, the GIL tableau procedure that we first implemented for the GIL verifier did not readily fulfill the needs of an oracle. We therefore implemented the oracle generator for GIL based on the tableau algorithm described in this paper.
Reference: [10] <author> V. J. Griswold. </author> <title> Core algorithms for autonomous monitoring of distributed systems. </title> <booktitle> In Proc. ACM/ONR Work. Parallel and Distributed Debugging, </booktitle> <pages> pp. 36-45, </pages> <month> May </month> <year> 1991. </year>
Reference: [11] <author> T. Henzinger. </author> <title> The Temporal Specification and Verification of Real-Time Systems. </title> <type> Technical Report No. STAN-CS-91-1380 (Ph.D. dissertation), </type> <institution> Dept. of Computer Science, Stan-ford University, Stanford, California, </institution> <year> 1991. </year>
Reference-contexts: logics, time is specified via a variable "T" which would need to be encoded; and time might advance only in increments that involve a given fundamental increment "." Other temporal logics use multiple (auxiliary) clocks; and then further, some clocks may advance at different rates. (For such temporal logics, see <ref> [11] </ref>.) Our implementation uses the basic scheme of [13] to represent states: states include formulas, but no clocks; and transitions coincide with next-operators fl and J any special "tick ." An assumed time-increment is handled by the user interpreting the standard interval between each pair of successive states as desired; for
Reference: [12] <author> Y. Kesten, Z. Manna, H. McGuire, and A. Pnueli. </author> <title> A decision algorithm for full propositional temporal logic. </title> <editor> In C. Cour-coubetis, ed., </editor> <booktitle> Proc. 1993 Int. Conf. Computer-Aided Verification, vol. 697 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 97-109, </pages> <address> Berlin, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The first tableau methods for linear time temporal logics were designed for deciding the validity of formulas. An excellent discussion of these methods is found in [24]. The tableau algorithm described in this paper is very similar to the incremental tableau algorithm that is presented briefly in <ref> [12] </ref> and in more detail in [14]; in fact, we borrow terminology from both of those works. While virtually all tableau methods are driven by semantic rules, little attention has been devoted to correctness criteria for rules. <p> For all of our albeit laboratory experiments, each runs essentially instantaneously. It is worthwhile to mention that, as with <ref> [12, 14] </ref> from which the implementation here was derived, in addition to checking traces, the implementation can further be used to verify formulas. This functionality was used, for example, to (re-)determine appropriate lemmas for the theoretical problem of the railroad-crossing [20], which includes real-time.
Reference: [13] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: This paper describes the design of our prototype oracle generator for Propositional Temporal Logic (PTL) <ref> [13] </ref> and Graphical Interval Logic (GIL) [7]. We discuss our laboratory experiments using different semantic rules to determine the effect on the tableau generated to check test traces. <p> Here, we concentrate on work related to tableau decision procedures in theorem proving and verification. Most propositional temporal logics are interpreted over infinite state sequences, permitting formulas to specify properties of both terminating and nonterminating executions <ref> [13] </ref>. However, this general interpretation requires translation to more powerful and costly automata than simple finite state automata (FSA), e.g., Buchi automata [25]. Buchi automata are not required to check traces generated during testing since test traces are necessarily finite. <p> In doing so, it helps motivate the algorithm, described in Section 4, for generating semantic tableaux from temporal specifications. The algorithm requires a specification that is written in a propositional linear-time temporal logic (LTL) <ref> [13] </ref>, and it must be parameterized by rules that express the semantics of the logical operators. We present specifications in two different LTLs, Propositional Temporal Logic (PTL) and Graphical Interval Logic (GIL), manifes-tating our scheme for parameterizability by different temporal logics. <p> (The numbers beneath events are explained subsequently.) An execution trace satisfies an LTL formula if the formula holds at the first state of the state sequence induced by the trace. 3.1 Specification in PTL The main specification-language that we use in this paper is the Propositional Temporal Logic (PTL) of <ref> [13] </ref>. But see also the next subsection (below) for an example using a different temporal logic, Graphical Interval Logic (GIL). <p> which would need to be encoded; and time might advance only in increments that involve a given fundamental increment "." Other temporal logics use multiple (auxiliary) clocks; and then further, some clocks may advance at different rates. (For such temporal logics, see [11].) Our implementation uses the basic scheme of <ref> [13] </ref> to represent states: states include formulas, but no clocks; and transitions coincide with next-operators fl and J any special "tick ." An assumed time-increment is handled by the user interpreting the standard interval between each pair of successive states as desired; for example, in one use of the implementation, the
Reference: [14] <author> H. McGuire. </author> <title> Two Methods for Checking Formulas of Temporal Logic | Part I: "A Method for Checking Propositional Temporal Formulas." </title> <type> Technical Report No. STAN-CS-TR-95-1551 (Ph.D. dissertation), </type> <institution> Dept. of Computer Science, Stanford University, Stanford, California, </institution> <year> 1995. </year>
Reference-contexts: An excellent discussion of these methods is found in [24]. The tableau algorithm described in this paper is very similar to the incremental tableau algorithm that is presented briefly in [12] and in more detail in <ref> [14] </ref>; in fact, we borrow terminology from both of those works. While virtually all tableau methods are driven by semantic rules, little attention has been devoted to correctness criteria for rules. <p> This equivalence was used in the production of Figure 7. 5 Implementation and Initial Results 5.1 Sketch of the Implementation Our current implementation of an LTL oracle generator is derived from the implementation of <ref> [14] </ref>. It comprises approximately 8000 lines of C++ code (including comments); documentation comprises approximately 8 pages. L 0 = f 23a ^ 23b ^ 23c g This implementation separates the overall processing described in this paper into several phases: To begin, phase 0 efficiently encodes the given reduction rules. <p> of all possible relevant formulas is constructed as the closure (see Definition 4.11) of the given specification-formula, and then indices of formulas for the bit-vector representation of sets of formulas are determined as indices in the list of all relevant formulas. 10 Temporal Logic (including past operators), Metric Temporal Logic, <ref> [14] </ref> and Graphical Interval Logic. Another issue faced in implementing the generic approach which is supposed to apply to arbitrary temporal logics is that a simple tableau may not cleanly match the semantic structure of a given temporal logic. <p> For all of our albeit laboratory experiments, each runs essentially instantaneously. It is worthwhile to mention that, as with <ref> [12, 14] </ref> from which the implementation here was derived, in addition to checking traces, the implementation can further be used to verify formulas. This functionality was used, for example, to (re-)determine appropriate lemmas for the theoretical problem of the railroad-crossing [20], which includes real-time.
Reference: [15] <author> L. E. Moser, Y. S. Ramakrishna, G. Kutty, P. M. Melliar-Smith, and L. K. Dillon. </author> <title> A graphical environment for the design of concurrent real-time systems. </title> <journal> ACM Trans. Software Engineering and Methodology, </journal> <volume> 6(1) </volume> <pages> 31-79, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: We have recently begun experimentation to handle a restricted version of GIL's primitive for expressing real-time, "len (]" <ref> [15] </ref>. An example of this construct's use is "len (3:0; 5:0]," which restricts the duration of an interval to at least 3.0 and no more than 5.0 time units.
Reference: [16] <author> A. Morzenti, D. Mandrioli, and C. Ghezzi. </author> <title> A model parametric real-time logic. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 14(4) </volume> <pages> 521-573, </pages> <month> October </month> <year> 1992. </year>
Reference: [17] <author> T. O. O'Malley. </author> <title> A Model of Specification-Based Test Oracles. </title> <type> Ph.D. dissertation, </type> <institution> Dept. of Information and Computer Science, University of California, Irvine, California, </institution> <year> 1996. </year>
Reference-contexts: We therefore assume state sequences are: * Finite, because test executions are finite. * Non-empty, because every test execution begins in an initial state. The example in [9] illustrates methods for defining primitive propositions and for generating finite state sequences that represent test executions of an Ada tasking program. <ref> [17] </ref> 2 more generally discusses (issues of) representation-mapping from actual behavior of a system being checked to some kind of trace that can be directly compared to or evaluated with a specification.
Reference: [18] <author> T. O. O'Malley, D. J. Richardson, and L. K. Dillon. </author> <title> Efficient specification-based oracles for critical systems. </title> <editor> In Wal-ter Scacchi and Richard Taylor, eds., </editor> <booktitle> Proc. 1996 California Systems Symp., </booktitle> <pages> pp. 50-59, </pages> <address> Los Angeles, CA, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: We discuss our laboratory experiments using different semantic rules to determine the effect on the tableau generated to check test traces. We also provide some comparison of the efficiency of oracles generated by our tableau method with that of GIL-based oracles generated by other methods <ref> [18] </ref>. This paper presents some material from [8] as well as new material based on implementing the method and using the implementation. In Section 2, we discuss the relationship between our work and the substantial body of other work on tableau decision procedures. <p> The generalized simplification-scheme described immediately above also has the effect desired for simplifications of keeping the size small: sizes produced by our implementation have been found to be the same as sizes produced by <ref> [18] </ref>. Also as expected, our adaptable scheme, allowing different rules in phase 0 while phases 1 and 2 remain unchanged, has facilitated developing `good' reduction rules. <p> A GIL oracle generator also allows us to compare the efficiency of oracles generated by our tableau method with GIL-based oracles that are generated by other methods <ref> [18, 21] </ref>. Our current ongoing work on this topic comprises generalizing our implementation to handle a wider variety of semantic structures in temporal logics, such as event-based semantics (instead of the state-based semantics here) and real-time clocks.
Reference: [19] <author> Y. S. Ramakrishna. </author> <title> Interval Logics for Temporal Specification and Verification. </title> <type> Ph.D. dissertation, </type> <institution> Dept. Computer and Electrical Engineering, University of California, Santa Barbara, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: We had previously applied the tableau algorithm in this paper with our own high-level temporal logic, Graphical Interval Logic (GIL), an interval temporal logic with a graphical representation [7]. The definition of a tableau procedure for a real-time extension of GIL appears without proof in <ref> [19] </ref>.
Reference: [20] <author> Y. S. Ramakrishna, P. M. Melliar-Smith, L. E. Moser, L. K. Dillon, and G. Kutty. </author> <title> Really Visual Temporal Reasoning. </title> <booktitle> In Proc. Fourth IEEE Real-Time Systems Symposium, </booktitle> <pages> pp. 262-273, </pages> <address> Raleigh-Durham, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: It is worthwhile to mention that, as with [12, 14] from which the implementation here was derived, in addition to checking traces, the implementation can further be used to verify formulas. This functionality was used, for example, to (re-)determine appropriate lemmas for the theoretical problem of the railroad-crossing <ref> [20] </ref>, which includes real-time. Also, an incorrect deduction published in [20] was found and corrected. <p> This functionality was used, for example, to (re-)determine appropriate lemmas for the theoretical problem of the railroad-crossing <ref> [20] </ref>, which includes real-time. Also, an incorrect deduction published in [20] was found and corrected.
Reference: [21] <author> D. J. Richardson. TAOS: </author> <title> Testing with analysis and oracle support. </title> <booktitle> In Proc. Inter. Symp. Software Testing and Analysis, </booktitle> <pages> pp. 138-153, </pages> <address> Seattle, WA, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: A GIL oracle generator also allows us to compare the efficiency of oracles generated by our tableau method with GIL-based oracles that are generated by other methods <ref> [18, 21] </ref>. Our current ongoing work on this topic comprises generalizing our implementation to handle a wider variety of semantic structures in temporal logics, such as event-based semantics (instead of the state-based semantics here) and real-time clocks.
Reference: [22] <author> D. J. Richardson, S. L. Aha, and T. O. O'Malley. </author> <title> Specification-based test oracles for reactive systems. </title> <booktitle> In Proc. 14th Inter. Conf. Software Engineering, </booktitle> <pages> pp. 105-118, </pages> <address> Mel-bourne, AUS, </address> <month> May </month> <year> 1992. </year>
Reference: [23] <author> A. Valmari. </author> <title> A stubborn attack on state explosion. </title> <editor> In Clarke and Kursham, editors, </editor> <booktitle> Proc. 1990 Int'l. Conf. Computer-Aided Verification, </booktitle> <pages> pp. 25-41, </pages> <address> New Brunswick, NJ, </address> <month> June </month> <year> 1990. </year> <title> No. </title> <booktitle> 3 in DIMACS Series in Discrete Mathematics and Theoretical, </booktitle> <address> Providence, RI, </address> <year> 1991. </year> <month> 13 </month>
Reference-contexts: revealing faults. (Test generation, and the extent of "coverage" afforded by specific tests, is beyond the scope of this paper.) Much of the recent impressive progress in model checking can be traced to the development of symbolic techniques, for example binary decision diagrams (BDDs) [3], and of partial order techniques <ref> [23] </ref>. However, neither symbolic techniques nor partial order techniques would seem beneficial for constructing test oracles.
Reference: [24] <author> P. Wolper. </author> <title> The tableau method for temporal logic: An overview. </title> <journal> In Logique et Analyse, </journal> <volume> vol. </volume> <pages> 110-111, pp. 119-136, </pages> <month> June-September </month> <year> 1985. </year>
Reference-contexts: Buchi automata are not required to check traces generated during testing since test traces are necessarily finite. The first tableau methods for linear time temporal logics were designed for deciding the validity of formulas. An excellent discussion of these methods is found in <ref> [24] </ref>. The tableau algorithm described in this paper is very similar to the incremental tableau algorithm that is presented briefly in [12] and in more detail in [14]; in fact, we borrow terminology from both of those works.
Reference: [25] <author> P. Wolper. </author> <title> On the relation of programs and computations to models of temporal logic. </title> <booktitle> In Proc. Conf. Temporal Logic in Specification, vol. 398 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 75-123, </pages> <address> Altrincham, England, April 1987. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Most propositional temporal logics are interpreted over infinite state sequences, permitting formulas to specify properties of both terminating and nonterminating executions [13]. However, this general interpretation requires translation to more powerful and costly automata than simple finite state automata (FSA), e.g., Buchi automata <ref> [25] </ref>. Buchi automata are not required to check traces generated during testing since test traces are necessarily finite. The first tableau methods for linear time temporal logics were designed for deciding the validity of formulas. An excellent discussion of these methods is found in [24].
Reference: [26] <author> P. Wolper, E. Clarke, A. Donnelly, D. Jackson, W. Roscoe, and J. Woodcock & A. Simpson. </author> <title> How to tackle concur-rency. </title> <booktitle> In Proc. Software Quality Week 1995 (8th International Conf.), Paper No. 2-A-4. Software Research Institute, </booktitle> <address> San Francisco, </address> <year> 1995. </year> <month> 14 </month>
Reference-contexts: But specifications of critical correctness properties tend to be short and concise, and therefore produce efficient oracles with which to check execution traces. Model checking subjects a model of a system to exhaustive analysis and decides whether the model satisfies a given specification <ref> [5, 26] </ref>. Current model-checking technology does not yet allow complete automated verification of general systems, because of their large state spaces. For this reason, model checking is used to verify an abstract model of the system, rather than the program (s) implementing it.
References-found: 26

