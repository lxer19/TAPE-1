URL: http://www.cis.ohio-state.edu/~gcao/paper/icdcs98b.ps.Z
Refering-URL: http://www.cis.ohio-state.edu/~gcao/publications.html
Root-URL: 
Email: E-mail: fgcao, singhalg@cis.ohio-state.edu  
Title: Low-Cost Checkpointing with Mutable Checkpoints in Mobile Computing Systems  
Author: Guohong Cao and Mukesh Singhal 
Address: Columbus, OH 43201  
Affiliation: Department of Computer and Information Science The Ohio State University  
Date: May 1998  
Note: The 18 th International Conference on Distributed Computing Systems,  
Abstract: Mobile computing raises many new issues, such as lack of stable storage, low bandwidth of wireless channel, high mobility, and limited battery life. These new issues make traditional checkpointing algorithms unsuitable. In this paper, we introduce the concept of "mutable checkpoint", which is neither a tentative checkpoint nor a permanent checkpoint. Mutable checkpoints can be saved any where; e.g., the memory or local disk of M Hs. In this way, taking a mutable checkpoint avoids the overhead of transferring large amount of data to the stable storage in M SS over the wireless network. Based on mutable checkpoints, our non-blocking algorithm avoids avalanche effect, minimizes the number of synchronization messages, and forces only a minimum number of processes to take their checkpoints on the sta ble storage.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Arup Acharya and B.R. Badrinath. </author> <title> "Checkpointing Distributed Applications on Mobil Computers". </title> <booktitle> the Third Intl. Conf. on Parallel and Distributed Information Systems, </booktitle> <month> Sep. </month> <year> 1994. </year>
Reference-contexts: To communicate with mobile computers, a conventional distributed system is augmented with mobile support stations (M SSs) that act as access points for the mobile computers by wireless networks. The mobility of M Hs raises some new issues <ref> [1, 7] </ref> that complicate the design of checkpointing algorithms: * Changes in the location of an M H complicate the routing of messages. Messages sent by an M H to another M H may have to be rerouted because the destination M H has moved. <p> Locating an M H gen erally increases the delay and message complexity. * Due to the vulnerability of mobile computers to catastrophic failures, e.g., loss, theft, or physical damage, the disk storage on an M H cannot be considered the stable storage. A reasonable solution <ref> [1] </ref> is to utilize the stable storage at M SSs to store checkpoints of M Hs. Thus, to take a checkpoint, an M H has to transfer large amount of data to its local M SS over the wireless network. <p> In Section 3, we present a low-cost checkpointing algorithm for mobile computing systems. The correctness proof is provided in Section 4. Section 5 concludes the paper. 2 Preliminaries 2.1 Computation Model A mobile computing system consists of a large number of mobile hosts (MHs) <ref> [1] </ref> and relatively fewer static hosts called mobile support stations (M SSs). The M SSs are connected by a static wired network, which provides reliable F IF O delivery of messages. A cell is a logical or geographical coverage area under an M SS. <p> To initiate a checkpointing, P 2 takes its own checkpoint and sends checkpoint request messages to P 1 , P 3 and P 4 , since R 2 <ref> [1] </ref> = 1; R 2 [3] = 1, and R 2 [4] = 1. When P 2 's request reaches P 4 , P 4 takes a checkpoint. Then, P 4 sends message m3 to P 3 . <p> P 1 discards C 1;2 when it makes checkpoint C 1;1 permanent or receives P 0 's cp update, whichever is earlier. 3.5 Compared to Other Works Acharya and Badrinath <ref> [1] </ref> were the first to present an checkpointing algorithm for mobile computing system. In their uncoordinated checkpointing algorithm, an M H has to take a local checkpoint whenever a message reception is preceded by a message sent at that M H.
Reference: [2] <author> G. Cao and M. Singhal. </author> <title> "On Consistent Checkpointing in Distributed Systems". </title> <type> OSU Technical Report #OSU-CISRC-9/97-TR44, </type> <year> 1997. </year>
Reference-contexts: Prakash-Singhal algorithm [11] was the first algorithm to combine these two approaches. More specifically, it only forces minimum number of processes to take checkpoints and does not block the underlying computation during the checkpointing. However, we found that this algorithm may result in an inconsistency <ref> [2] </ref> in some situations. We prove that there does not exist a non-blocking algorithm which forces only a minimum number of processes to take their checkpoints. <p> By using csn and the initiator identification number, they claim that their non-blocking algorithm can avoid inconsistencies and minimize the number of checkpoints during checkpointing. However, we showed that their algorithm may result in an inconsistency <ref> [2] </ref> and we proved that there does not exist a non-blocking algorithm which forces only a minimum number of processes to take their checkpoints [2]. <p> However, we showed that their algorithm may result in an inconsistency <ref> [2] </ref> and we proved that there does not exist a non-blocking algorithm which forces only a minimum number of processes to take their checkpoints [2]. Since the proof is not the major concern of this paper, we only briefly mention the basic idea using an example. 2.4 Impossibility of Checkpointing In Figure 2, assume messages m6 and m7 do not exist. <p> Because of m4, there is a new relationship between P 1 and P 2 such that P 2 will receive a checkpoint request associated with C 1;1 . There are two possible approaches for P 2 to get the new relationship (called the z-dependency in <ref> [2] </ref>). Approach 1: Tracing the in-coming messages. P 2 gets the new z-dependency information from P 1 , so P 1 has to know the z-dependency information before it sends m5 and appends the z-dependency informa tion to m5. <p> Another checkpointing algorithm for mobile computing system is the Prakash-Singhal algorithm [11]. However, their algorithm has some problems and may result in an inconsistency <ref> [2] </ref>. 4 Correctness Proof In Section 3.2, R i represents all dependency relations in the current checkpoint period. Due to the introduction of mutable checkpoints, R i may represent the dependency relations after the last mutable checkpoint. <p> These new constraints require that the checkpointing algorithm should be non-blocking and only forces minimum number of processes to take checkpoints. However, according to our previous result <ref> [2] </ref>, there does not exist a non-blocking algorithm which forces only a minimum number of processes to take their checkpoints.
Reference: [3] <author> Y. Deng and E.K. Park. </author> <title> "Checkpointing and Rollback-Recovery Algorithms in Distributed Systems". </title> <journal> Journal of Systems and Software, </journal> <pages> pages 59-71, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: In order to record a consistent global checkpoint, processes must synchronize their checkpointing activities. Therefore, consistent checkpointing suffers from high overhead associated with the checkpointing process. Much of the previous work <ref> [3, 5, 6] </ref> in consistent checkpointing has focused on minimizing the number of synchronization messages and the number of checkpoints during checkpointing. However, these algorithms (called blocking algorithms) force all relevant processes in the system to block their computations during the checkpointing process. <p> With this, the reconnect routine terminates and the relocated mobile host M H i resumes normal communication with other M Hs (or M SSs) in the system. 2.3 Non-blocking Algorithms Most existing consistent checkpointing algorithms <ref> [3, 6] </ref> rely on the two-phase protocol and save two kinds of checkpoints on the stable storage: tentative and permanent. In the first phase, the initiator takes a tentative checkpoint and forces all relevant processes to take tentative checkpoints. <p> In Figure 3, when m2 arrives at P 1 , P 1 takes a mutable checkpoint C 1;1 before processing m2 because m2:csn &gt; csn 1 <ref> [3] </ref>. C 1;1 will be turned into a tentative checkpoint when P 1 receives the checkpoint request sent by P 2 . If P 0 has finished its checkpointing process before it sends m1, P 1 does not need to take a mutable checkpoint C 1;2 . <p> To initiate a checkpointing, P 2 takes its own checkpoint and sends checkpoint request messages to P 1 , P 3 and P 4 , since R 2 [1] = 1; R 2 <ref> [3] </ref> = 1, and R 2 [4] = 1. When P 2 's request reaches P 4 , P 4 takes a checkpoint. Then, P 4 sends message m3 to P 3 .
Reference: [4] <author> E.N. Elnozahy, D.B. Johnson, and W. Zwaenepoel. </author> <title> "The Performance of Consistent Checkpointing". </title> <booktitle> Proc. of the 11th Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 86-95, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Moreover, in mobile computing systems, due to the mobility of M Hs, a message may be routed several times before reaching its destination. Therefore, blocking algorithms may further degrade the performance of these systems <ref> [4] </ref>. Recently, nonblocking algorithms [4, 12] have received considerable attention. In these algorithms, processes need not block during checkpointing by using a checkpointing sequence number to identify orphan messages. <p> Moreover, in mobile computing systems, due to the mobility of M Hs, a message may be routed several times before reaching its destination. Therefore, blocking algorithms may further degrade the performance of these systems [4]. Recently, nonblocking algorithms <ref> [4, 12] </ref> have received considerable attention. In these algorithms, processes need not block during checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [4, 12] require all processes in the computation to take a checkpoint during the checkpointing, even though many of them may not be <p> Therefore, blocking algorithms may further degrade the performance of these systems [4]. Recently, nonblocking algorithms <ref> [4, 12] </ref> have received considerable attention. In these algorithms, processes need not block during checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [4, 12] require all processes in the computation to take a checkpoint during the checkpointing, even though many of them may not be necessary. Prakash-Singhal algorithm [11] was the first algorithm to combine these two approaches. <p> Suppose P 3 receives m1 before it receives the checkpoint request from P 2 , and when P 3 receives the checkpoint request from P 2 , it takes a checkpoint (see Figure 1). In this case, m1 becomes an orphan. Most non-blocking algorithms <ref> [4, 12] </ref> use a Checkpoint Sequence Number (csn) to avoid inconsistencies. More specifically, a process is forced to take a checkpoint if it receives a computation message whose csn is greater than its local csn. <p> When P 2 's request reaches P 4 , P 4 takes a checkpoint. Then, P 4 sends message m3 to P 3 . When m3 arrives at P 3 , P 3 takes a checkpoint before processing it because m3:csn &gt; csn 3 <ref> [4] </ref>. For the same reason, P 1 takes a checkpoint before processing m2. P 0 has not communicated with other processes before it takes a local checkpoint. Later, it sends a message m1 to P 1 . <p> To initiate a checkpointing, P 2 takes its own checkpoint and sends checkpoint request messages to P 1 , P 3 and P 4 , since R 2 [1] = 1; R 2 [3] = 1, and R 2 <ref> [4] </ref> = 1. When P 2 's request reaches P 4 , P 4 takes a checkpoint. Then, P 4 sends message m3 to P 3 . When m3 arrives at P 3 , P 3 takes a mutable checkpoint before processing it because m3:csn &gt; csn 3 [4] and P <p> R 2 <ref> [4] </ref> = 1. When P 2 's request reaches P 4 , P 4 takes a checkpoint. Then, P 4 sends message m3 to P 3 . When m3 arrives at P 3 , P 3 takes a mutable checkpoint before processing it because m3:csn &gt; csn 3 [4] and P 3 has sent a message during the current checkpoint interval. For the same reason, P 1 takes a mutable checkpoint before processing m2. P 0 has not communicated with other processes before it takes a local checkpoint. Later, it sends a message m1 to P 1 .
Reference: [5] <author> J. Kim and T. Park. </author> <title> "An Efficient Protocol For Check-pointing Recovery in Distributed Systems". </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: In order to record a consistent global checkpoint, processes must synchronize their checkpointing activities. Therefore, consistent checkpointing suffers from high overhead associated with the checkpointing process. Much of the previous work <ref> [3, 5, 6] </ref> in consistent checkpointing has focused on minimizing the number of synchronization messages and the number of checkpoints during checkpointing. However, these algorithms (called blocking algorithms) force all relevant processes in the system to block their computations during the checkpointing process.
Reference: [6] <author> R. Koo and S. Toueg. </author> <title> "Checkpointing and Rollback-Recovery for Distributed Systems". </title> <journal> IEEE Trans. on Software Engineering, </journal> <pages> pages 23-31, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: The disconnection of M Hs should not prevent the checkpointing process. These constraints make traditional checkpointing algorithms for distributed systems unsuitable for mobile computing systems. Consistent checkpointing is an attractive approach for transparently adding fault tolerance to distributed applications since it avoids domino effect <ref> [6] </ref> and minimizes the stable storage requirement. In this approach, the state of each process in the system is periodically saved on the stable storage, which is called a checkpoint of the process. To recover from a failure, the system restarts its execution from a previous consistent global checkpoint. <p> A system state is said to be consistent if it contains no orphan message; i.e., a message whose receive event is recorded in the state of the destination process, but its send event is lost <ref> [6] </ref>. In order to record a consistent global checkpoint, processes must synchronize their checkpointing activities. Therefore, consistent checkpointing suffers from high overhead associated with the checkpointing process. <p> In order to record a consistent global checkpoint, processes must synchronize their checkpointing activities. Therefore, consistent checkpointing suffers from high overhead associated with the checkpointing process. Much of the previous work <ref> [3, 5, 6] </ref> in consistent checkpointing has focused on minimizing the number of synchronization messages and the number of checkpoints during checkpointing. However, these algorithms (called blocking algorithms) force all relevant processes in the system to block their computations during the checkpointing process. <p> With this, the reconnect routine terminates and the relocated mobile host M H i resumes normal communication with other M Hs (or M SSs) in the system. 2.3 Non-blocking Algorithms Most existing consistent checkpointing algorithms <ref> [3, 6] </ref> rely on the two-phase protocol and save two kinds of checkpoints on the stable storage: tentative and permanent. In the first phase, the initiator takes a tentative checkpoint and forces all relevant processes to take tentative checkpoints.
Reference: [7] <author> P. Krishna, N.H. Vaidya, and D.K. Pradhan. </author> <title> "Recovery in Distributed Mobile Environments". </title> <booktitle> IEEE Workshop on Advances in Parallel and Distributed System, </booktitle> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: To communicate with mobile computers, a conventional distributed system is augmented with mobile support stations (M SSs) that act as access points for the mobile computers by wireless networks. The mobility of M Hs raises some new issues <ref> [1, 7] </ref> that complicate the design of checkpointing algorithms: * Changes in the location of an M H complicate the routing of messages. Messages sent by an M H to another M H may have to be rerouted because the destination M H has moved. <p> To save energy, the M H can power down individual components during periods of low activity <ref> [7] </ref>. This strategy is referred to as the doze mode operation. An M H in the doze mode is woken up on receiving a message.
Reference: [8] <author> L. Lamport. </author> <title> "Time, Clocks and Ordering of Events in Distributed Systems". </title> <journal> Communication of the ACM, </journal> <month> July </month> <year> 1978. </year>
Reference-contexts: are two possible situations under which P j 's checkpoint is taken: Case 1: P j 's checkpoint is taken due to a request from P i , Then: send (m) at P j ! 1 receive (m) at P i 1 ! is the "happened before" relation described in <ref> [8] </ref> receive (m) at P i ! checkpoint taken at P i checkpoint taken at P i ! P i sent request to P j P i sent request to P j ! checkpoint taken at P j Using the transitivity property of !, we have: send (m) at P j
Reference: [9] <author> R. Netzer and J. Xu. </author> <title> "Necessary and Sufficient Conditions for Consistent Global Snapshots". </title> <journal> IEEE Trans. on Parallel and Distributed System, </journal> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: Each checkpoint taken by a process is assigned a unique sequence number. The i th (i 0) checkpoint of process P q is assigned a sequence number i and is de noted by C p;i . The i th checkpoint interval <ref> [9] </ref> of process P p denotes all the computation performed between its i th and (i+1) th checkpoint, including the i th checkpoint but not the (i + 1) th checkpoint. 2.2 Handling Mobility Changes in the location of an M H complicate the routing of messages.
Reference: [10] <author> R. Prakash and M. Singhal. </author> <title> "Maximal Global Snapshot with Concurrent Initiators". </title> <booktitle> Proc. of the Sixth IEEE Symp. on Parallel and Distributed Processing, </booktitle> <pages> pages 344-351, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: If so, it appends its trigger to the computation message. 3.3 The Checkpointing Algorithm To clearly present the algorithm, we assume that at any time, at most one checkpointing is in progress. Multiple concurrent checkpointings can be handled using the techniques in <ref> [10] </ref>. Checkpointing initiation: Any site can initiate a checkpointing.
Reference: [11] <author> R. Prakash and M. Singhal. </author> <title> "Low-Cost Checkpointing and Failure Recovery in Mobile Computing Systems". </title> <journal> IEEE Trans. on Parallel and Distributed System, </journal> <pages> pages 1035-1048, </pages> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: In these algorithms, processes need not block during checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [4, 12] require all processes in the computation to take a checkpoint during the checkpointing, even though many of them may not be necessary. Prakash-Singhal algorithm <ref> [11] </ref> was the first algorithm to combine these two approaches. More specifically, it only forces minimum number of processes to take checkpoints and does not block the underlying computation during the checkpointing. However, we found that this algorithm may result in an inconsistency [2] in some situations. <p> When P 3 receives m1, it takes a checkpoint before processing m1 since the csn appended to m1 is larger than its local csn. This scheme works only when every process in the computation can receive each checkpoint request and then increases its own csn. Since Prakash-Singhal algorithm <ref> [11] </ref> only forces part of processes to take checkpoints, the csn of some processes may be out-of-date, and may not be able to avoid inconsistencies. <p> P i expects to receive a message from P j with checkpoint sequence number csn i [j]. weight: a non-negative variable of type real with maximum value of 1. It is used to detect the termination of the checkpointing <ref> [11] </ref>. trigger i : a tuple (pid, inum) maintained by each process P i . pid indicates the checkpointing initiator that triggered this process to take its latest checkpoint. inum indicates the csn at process pid when it took its own local checkpoint on initiating the checkpoint ing. sent i : <p> If the send and receive of messages are interleaved, the local checkpoints will be equal to half of the number of computation messages, which reduces system performance. Another checkpointing algorithm for mobile computing system is the Prakash-Singhal algorithm <ref> [11] </ref>. However, their algorithm has some problems and may result in an inconsistency [2]. 4 Correctness Proof In Section 3.2, R i represents all dependency relations in the current checkpoint period. Due to the introduction of mutable checkpoints, R i may represent the dependency relations after the last mutable checkpoint. <p> Certainly, the reception of m is not recorded in the last checkpoint of P i . Theorem 2 The checkpointing algorithm terminates within a finite time. Proof. The proof is similar to <ref> [11] </ref>. 5 Conclusions Mobile computing is a rapidly emerging trend in distributed computing. A mobile computing system consists of mobile hosts (M Hs) and mobile support stations (M SSs), connected by a communication network.
Reference: [12] <author> L.M. Silva and J.G. Silva. </author> <title> "Global Checkpointing for Distributed Programs". </title> <booktitle> Proc. of the 11th Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 155-162, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: Moreover, in mobile computing systems, due to the mobility of M Hs, a message may be routed several times before reaching its destination. Therefore, blocking algorithms may further degrade the performance of these systems [4]. Recently, nonblocking algorithms <ref> [4, 12] </ref> have received considerable attention. In these algorithms, processes need not block during checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [4, 12] require all processes in the computation to take a checkpoint during the checkpointing, even though many of them may not be <p> Therefore, blocking algorithms may further degrade the performance of these systems [4]. Recently, nonblocking algorithms <ref> [4, 12] </ref> have received considerable attention. In these algorithms, processes need not block during checkpointing by using a checkpointing sequence number to identify orphan messages. However, these algorithms [4, 12] require all processes in the computation to take a checkpoint during the checkpointing, even though many of them may not be necessary. Prakash-Singhal algorithm [11] was the first algorithm to combine these two approaches. <p> Suppose P 3 receives m1 before it receives the checkpoint request from P 2 , and when P 3 receives the checkpoint request from P 2 , it takes a checkpoint (see Figure 1). In this case, m1 becomes an orphan. Most non-blocking algorithms <ref> [4, 12] </ref> use a Checkpoint Sequence Number (csn) to avoid inconsistencies. More specifically, a process is forced to take a checkpoint if it receives a computation message whose csn is greater than its local csn.
Reference: [13] <author> F. Teraoka, Y. Yokote, and M. Tokoro. </author> <title> "A Network Architecture Providing Host Migration Transparency". </title> <booktitle> Proc. of ACM SIGCOMM'91, </booktitle> <month> Sep. </month> <year> 1991. </year>
Reference-contexts: Messages sent by an M H to another M H may have to be rerouted because the destination M H disconnected from the old M SS and is now connected to a new M SS. Many routing protocols for the network layer have been proposed <ref> [13] </ref> to handle M H mobility. An M H may get disconnected from the network for an arbitrary period of time. At the application level, the checkpointing algorithm may generate a request for the disconnected M H to take a checkpoint.
References-found: 13

