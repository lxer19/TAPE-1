URL: http://www.research.att.com/~stubblebine/98fc.ps
Refering-URL: http://www.research.att.com/~stubblebine/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Publicly Verifiable Lotteries: Applications of Delaying Functions  
Author: David M. Goldschlag Stuart G. Stubblebine 
Date: February, 1998  
Abstract: This paper uses delaying functions, functions that require significant calculation time, in the development of a one-pass lottery scheme in which winners are chosen fairly using only internal information. Since all this information may be published (even before the lottery closes), anyone can do the calculation and therefore verify that the winner was chosen correctly. Since the calculation uses a delaying function, ticket purchasers cannot take advantage of this information. Fraud on the part of the lottery agent is detectable and no single ticket purchaser needs to be trusted. Coalitions of purchasers attempting to control the winning ticket calculation are either unsuccessful or are detected. The scheme can be made resistant to coalitions of arbitrary size. Since we assume that coalitions of larger size are harder to assemble, the probability that the lottery is fair can be made arbitrarily high. The paper defines delaying functions and contrasts them with pricing functions [8] and time-lock puzzles [16].
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. Aiello, S. Venkatesan, and R. Venkatesan. </author> <title> Design of practical and provably good random number generators. </title> <booktitle> Proceedings of the Sixth Annual ACM-SIAM Symposium on Discrete Algorithms, ACM, </booktitle> <address> New York, NY, </address> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Given a minimum operation time p and an interval following p i.e. [p; q], the probability that the function is computable on average is less than or equal to * before the interval and the probability increases monotonically from <ref> [*; 1] </ref> over that interval where * can be made arbitrarily small. The function f is computationally secure. <p> The client agent randomly generates the seed according to a uniform distribution over this range. Standardized implementations of the client agent can help insure that the client agent correctly generates the seed using available techniques for random number generation <ref> [1] </ref>. Clients not obeying the protocol specification may be defined to belong to the coalition attempting to control the lottery. (If the set is thus expanded, the number of distinct client agents required may need to increase to achieve the same probability of fairness.) Message 2 represents the lottery ticket.
Reference: [2] <author> M. Bellare, J. Garay, and T. Rabin. </author> <title> Distributed Pseudo-Random Bit Generators ANew Way to Speed-Up Shared Coin Tossing, </title> <booktitle> PODC'96, ACM, </booktitle> <year> 1996. </year>
Reference-contexts: Cai et. al. propose functions that have shortcuts that make them easy to verify, and functions that are easier to verify than to compute. Rivest [15] defines several types of electronic lotteries. There has been much work on distributed coin flipping <ref> [2, 4, 5, 12] </ref>. The protocols are expensive for each participant and are multi-pass. Also, Kahn, Kalai, and Linial [10] prove that it is information theoretically impossible to design functions that cannot be controlled by some strict subset of their inputs.
Reference: [3] <author> T. Beth and Y. Desmedt. </author> <title> Identification tokens-or: solving the chess grandmaster problem. </title> <booktitle> Advances in Cryptology - CRYPTO '90 Proceedings, </booktitle> <pages> pp. 169-176. </pages>
Reference-contexts: So the puzzlemaker must be trusted not to cheat. The related work is summarized in Table 1. (A blank space in the table means that the property on the left is not a requirement for the function at the top of the column.) Beth and Desmedt <ref> [3] </ref> present a time based solution to the chess grandmas 11 ter problem. Their solution involves delay, not expensive computation. They solve the problem of how to prevent a man in the middle from playing two grandmasters against one another, and claiming a significant win.
Reference: [4] <author> M. Blum. </author> <title> Coin flipping by telephone-a protocol for solving impossible problems. </title> <booktitle> Spring COMPCON 82, IEEE, </booktitle> <year> 1982, </year> <pages> pp. 133-137. </pages>
Reference-contexts: Cai et. al. propose functions that have shortcuts that make them easy to verify, and functions that are easier to verify than to compute. Rivest [15] defines several types of electronic lotteries. There has been much work on distributed coin flipping <ref> [2, 4, 5, 12] </ref>. The protocols are expensive for each participant and are multi-pass. Also, Kahn, Kalai, and Linial [10] prove that it is information theoretically impossible to design functions that cannot be controlled by some strict subset of their inputs.
Reference: [5] <author> A. Broder. </author> <title> A provably secure polynomial approximation scheme for the distributed lottery problem. </title> <booktitle> Proceedings of the 4th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1985, </year> <pages> pp. 136-148. </pages>
Reference-contexts: Cai et. al. propose functions that have shortcuts that make them easy to verify, and functions that are easier to verify than to compute. Rivest [15] defines several types of electronic lotteries. There has been much work on distributed coin flipping <ref> [2, 4, 5, 12] </ref>. The protocols are expensive for each participant and are multi-pass. Also, Kahn, Kalai, and Linial [10] prove that it is information theoretically impossible to design functions that cannot be controlled by some strict subset of their inputs.
Reference: [6] <author> J. Y. Cai, A. Nerurkar, M. Y. Wu. </author> <title> The Design of Uncheatable Benchmarks Using Complexity Theory, </title> <type> technical report 97-10, </type> <institution> Department of Computer Science, SUNY Buffalo, </institution> <year> 1997. </year>
Reference-contexts: Cai et. al use moderately hard functions in the design of uncheatable benchmarks <ref> [6] </ref>. Benchmarks use problems that take significant computation time. However, if the input data is known a-priori, machine architectures can be optimized for those inputs. A solution is to select inputs randomly for each test.
Reference: [7] <author> D. Chaum, </author> <title> "Security without Identification: Transaction Systems to Make Big Brother Obsolete", </title> <journal> CACM (28,10), </journal> <month> October </month> <year> 1985, </year> <pages> pp. 1030-1044. </pages>
Reference: [8] <author> C. Dwork, and M. Naor. </author> <title> Pricing via processing or combating junk mail. </title> <type> Weizmann Technical Report CS95-20, </type> <note> 1995 (Also preliminary version in CRYPTO '92, pp. 139-147). 13 </note>
Reference-contexts: In the absence of other assumptions, this work would preclude our result. However, that work does not place computational constraints on the coalition controlling the inputs. Other work has used calculation time as a barrier <ref> [8, 9, 16, 13] </ref>. But none of the solutions have all the properties that we require here: Unlike time-lock puzzles [16, 13], the solution should not be known in advance to anyone, not even the puzzlemaker. <p> And, although easy verification of the solution may be convenient, it is not a requirement here. Unlike pricing functions <ref> [8, 9] </ref>, the cost of a security breach is high. This paper is organized as follows. In section 2, we present definitions. Section 3 describes our solution including lottery registration, ticket purchase, 2 critical purchase phase, and winning entry calculation. In section 5, we present related work. <p> Third, if the calculation of the winning number depends only upon purchased tickets and not upon some extra information (such as a "trusted" third party selecting a random number), then we say the lottery is closed. Delaying functions. We borrow complexity terminology from <ref> [8] </ref>. However, our definitions are not identical. We choose a calculation function that is moderately hard to compute, as opposed to easy or cryptographically hard. Depending on the lottery requirements, this may mean that the calculation time takes several hours, using the fastest known implementation. <p> In contrast, for the different problem of controlling access to a resource, Dwork and Naor present a technique requiring a user to compute a moderately hard, but not intractable (cryptographically hard) function which they call a pricing function <ref> [8] </ref>. They present solutions based on extracting square roots modulo a prime, the Fiat-Shamir signature scheme, and the Ong-Schnorr-Shamir (cracked) signature scheme. <p> As our lottery design is resistant to the dilemma proposed above, we do not place the hard to verify requirement on our delaying functions. The class of delaying functions may include the functions of <ref> [8, 9] </ref>. Since delaying functions do not have the easy to verify or shortcut requirement, they can be easier to construct, simply by choosing functions that have a high operation count and cannot be parallelized. <p> A candidate delaying function may use a cryptographic cipher with a very long period to generate a sufficient amount of keystream. Delaying functions are related to pricing functions, time-lock puzzles, and other work that uses calculation time as a barrier <ref> [8, 9, 16, 13] </ref>.
Reference: [9] <author> M. K. Franklin and D. Malkhi. </author> <title> Auditable Metering with Lightweight Se--curity, </title> <booktitle> Financial Cryptography 1997, </booktitle> <volume> LNCS Vol. 1318, </volume> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: In the absence of other assumptions, this work would preclude our result. However, that work does not place computational constraints on the coalition controlling the inputs. Other work has used calculation time as a barrier <ref> [8, 9, 16, 13] </ref>. But none of the solutions have all the properties that we require here: Unlike time-lock puzzles [16, 13], the solution should not be known in advance to anyone, not even the puzzlemaker. <p> And, although easy verification of the solution may be convenient, it is not a requirement here. Unlike pricing functions <ref> [8, 9] </ref>, the cost of a security breach is high. This paper is organized as follows. In section 2, we present definitions. Section 3 describes our solution including lottery registration, ticket purchase, 2 critical purchase phase, and winning entry calculation. In section 5, we present related work. <p> In a similar fashion, Franklin and Malkhi <ref> [9] </ref> use repeated hashing as evidence that a certain amount of time has elapsed. These papers' motivating applications, preventing and/or detecting junk email, and metering web clicks for advertising revenue, have two important properties that are not present in lotteries. <p> As our lottery design is resistant to the dilemma proposed above, we do not place the hard to verify requirement on our delaying functions. The class of delaying functions may include the functions of <ref> [8, 9] </ref>. Since delaying functions do not have the easy to verify or shortcut requirement, they can be easier to construct, simply by choosing functions that have a high operation count and cannot be parallelized. <p> A candidate delaying function may use a cryptographic cipher with a very long period to generate a sufficient amount of keystream. Delaying functions are related to pricing functions, time-lock puzzles, and other work that uses calculation time as a barrier <ref> [8, 9, 16, 13] </ref>.
Reference: [10] <author> J. Kahn, G. Kalai, and N. Linial. </author> <title> The influence of variables on Boolean functions. </title> <booktitle> 29th Annual Symposium on Foundations of Computer Science, </booktitle> <address> IEEE Washington, DC, USA, </address> <year> 1988, </year> <pages> pp. 68-80. </pages>
Reference-contexts: Where one party has a role that makes him more trusted than another (i.e., the lottery agent), that party incriminates himself when cheating. Furthermore, it is easy for individual purchasers to provide the evidence. 3. We detect, instead of prevent, denial of service attacks. Prior research <ref> [10] </ref> indicates that it is information theoretically impossible to construct a Boolean function that cannot be controlled by sufficiently large sized subsets of its inputs. In the absence of other assumptions, this work would preclude our result. <p> Rivest [15] defines several types of electronic lotteries. There has been much work on distributed coin flipping [2, 4, 5, 12]. The protocols are expensive for each participant and are multi-pass. Also, Kahn, Kalai, and Linial <ref> [10] </ref> prove that it is information theoretically impossible to design functions that cannot be controlled by some strict subset of their inputs.
Reference: [11] <author> J. Kelsey, B. Schneier, C. Hall, and D. Wagner. </author> <note> 1997 Information Security Workshop. See http://http.cs.berkeley.edu/ daw/keystretch.ps. </note>
Reference-contexts: Also, related work discusses the use of collision-resistant hash functions iteratively to add a known number of bits to the expected difficulty of an exhaustive search attack on keys <ref> [11] </ref>. Finally, we note if registration certificates are blinded for anonymity, care must be taken that the communications channel not identify the customer [19]. 6 Conclusion This paper presented a publicly verifiable lottery scheme that can be made fair with arbitrarily high probability.
Reference: [12] <author> E. Kushilevitz, Y. Mansour, and M. Rabin, </author> <title> On Lotteries with Unique Winners, </title> <journal> SIAM Journal on Discrete Mathematics, </journal> <volume> vol. 8, No. 1, </volume> <pages> pp. 93-98, </pages> <month> February, </month> <year> 1995. </year>
Reference-contexts: Cai et. al. propose functions that have shortcuts that make them easy to verify, and functions that are easier to verify than to compute. Rivest [15] defines several types of electronic lotteries. There has been much work on distributed coin flipping <ref> [2, 4, 5, 12] </ref>. The protocols are expensive for each participant and are multi-pass. Also, Kahn, Kalai, and Linial [10] prove that it is information theoretically impossible to design functions that cannot be controlled by some strict subset of their inputs.
Reference: [13] <author> R. Merkle. </author> <title> Secure Communications Over Insecure Channels. </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 4, </volume> <month> April, </month> <year> 1978, </year> <pages> pp. 284-299. </pages>
Reference-contexts: In the absence of other assumptions, this work would preclude our result. However, that work does not place computational constraints on the coalition controlling the inputs. Other work has used calculation time as a barrier <ref> [8, 9, 16, 13] </ref>. But none of the solutions have all the properties that we require here: Unlike time-lock puzzles [16, 13], the solution should not be known in advance to anyone, not even the puzzlemaker. <p> However, that work does not place computational constraints on the coalition controlling the inputs. Other work has used calculation time as a barrier [8, 9, 16, 13]. But none of the solutions have all the properties that we require here: Unlike time-lock puzzles <ref> [16, 13] </ref>, the solution should not be known in advance to anyone, not even the puzzlemaker. And, although easy verification of the solution may be convenient, it is not a requirement here. Unlike pricing functions [8, 9], the cost of a security breach is high. <p> Rivest et. al. [16] propose time-lock puzzles where a puzzlemaker can create a puzzle that requires a well defined amount of computation time to solve. The proposal is related to <ref> [13] </ref> but is not parallelizable. Unlike delaying functions, the solution is known to the puzzlemaker, but is then discarded. So the puzzlemaker must be trusted not to cheat. <p> A candidate delaying function may use a cryptographic cipher with a very long period to generate a sufficient amount of keystream. Delaying functions are related to pricing functions, time-lock puzzles, and other work that uses calculation time as a barrier <ref> [8, 9, 16, 13] </ref>.
Reference: [14] <editor> A. Menezes, P. van Oorschot, and S. Vanstone. </editor> <publisher> Handbook of Applied Cryptography , CRC Press, </publisher> <year> 1997. </year>
Reference-contexts: Hash computation. Compute h (s 1 ; s 2 ; :::) where s 1 ; s 2 ; : : : represents the concatenation of all seed parameters of tickets purchased during the critical purchase phase p. We require that h () be preimage resistant and non-correlating <ref> [14, 20] </ref>. 2. Delay calculation. Input the result of step 1 to a delaying function (as defined in section 2). If the range of step 2 does not map directly to a winning ticket (e.g., sequence number) then the following step may be needed: 3. Winner computation.
Reference: [15] <author> R. Rivest. </author> <title> Electronic Lottery Tickets as Micropayments, </title> <booktitle> Financial Cryptography 1997. </booktitle>
Reference-contexts: However, this makes independent verification of the result difficult (perhaps the machine computed the wrong result quickly!). Cai et. al. propose functions that have shortcuts that make them easy to verify, and functions that are easier to verify than to compute. Rivest <ref> [15] </ref> defines several types of electronic lotteries. There has been much work on distributed coin flipping [2, 4, 5, 12]. The protocols are expensive for each participant and are multi-pass.
Reference: [16] <author> R. Rivest, A. Shamir, and D. Wagner. </author> <title> Time-lock puzzles and timed-release Crypto. </title> <type> Unpublished manuscript, </type> <month> February, </month> <year> 1996. </year> <note> See http://theory.lcs.mit.edu/~rivest/RivestShamirWagner-timelock.ps. </note>
Reference-contexts: In the absence of other assumptions, this work would preclude our result. However, that work does not place computational constraints on the coalition controlling the inputs. Other work has used calculation time as a barrier <ref> [8, 9, 16, 13] </ref>. But none of the solutions have all the properties that we require here: Unlike time-lock puzzles [16, 13], the solution should not be known in advance to anyone, not even the puzzlemaker. <p> However, that work does not place computational constraints on the coalition controlling the inputs. Other work has used calculation time as a barrier [8, 9, 16, 13]. But none of the solutions have all the properties that we require here: Unlike time-lock puzzles <ref> [16, 13] </ref>, the solution should not be known in advance to anyone, not even the puzzlemaker. And, although easy verification of the solution may be convenient, it is not a requirement here. Unlike pricing functions [8, 9], the cost of a security breach is high. <p> The class of delaying functions may include the functions of [8, 9]. Since delaying functions do not have the easy to verify or shortcut requirement, they can be easier to construct, simply by choosing functions that have a high operation count and cannot be parallelized. Rivest et. al. <ref> [16] </ref> propose time-lock puzzles where a puzzlemaker can create a puzzle that requires a well defined amount of computation time to solve. The proposal is related to [13] but is not parallelizable. Unlike delaying functions, the solution is known to the puzzlemaker, but is then discarded. <p> A candidate delaying function may use a cryptographic cipher with a very long period to generate a sufficient amount of keystream. Delaying functions are related to pricing functions, time-lock puzzles, and other work that uses calculation time as a barrier <ref> [8, 9, 16, 13] </ref>.
Reference: [17] <author> S. Roman. </author> <title> Coding and Information Theory. Graduate texts in Mathematics number 134, </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Choose winning entries by computing the Hamming distance between the result of step 2 and the winning number parameter (expressed in binary) in the tickets. 2 (The Hamming distance d (x; y) from x to y is the number of positions in which the two strings differ <ref> [17] </ref>.) The use of a cipher in OFB mode may be a good delaying function. The cipher should have a large period, large linear complexity, and good statistical properties.
Reference: [18] <author> P. Syverson, S. Stubblebine, and D. Goldschlag. </author> <title> Unlinkable Serial Transactions, </title> <booktitle> Financial Cryptography 1997, </booktitle> <volume> LNCS Vol. 1318, </volume> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference: [19] <author> P. Syverson, D. Goldschlag, and M. Reed. </author> <title> Anonymous Connections and Onion Routing, </title> <booktitle> Proceedings of the Symposium on Security and Privacy , Oakland, </booktitle> <address> CA, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: Finally, we note if registration certificates are blinded for anonymity, care must be taken that the communications channel not identify the customer <ref> [19] </ref>. 6 Conclusion This paper presented a publicly verifiable lottery scheme that can be made fair with arbitrarily high probability.
Reference: [20] <author> A. Webster and S. Tavares. </author> <title> One the design of S-boxes, </title> <booktitle> Advances in Cryptology - Crypto 85 (LNCS 218), </booktitle> <pages> pp. 523-534, </pages> <year> 1986. </year>
Reference-contexts: Hash computation. Compute h (s 1 ; s 2 ; :::) where s 1 ; s 2 ; : : : represents the concatenation of all seed parameters of tickets purchased during the critical purchase phase p. We require that h () be preimage resistant and non-correlating <ref> [14, 20] </ref>. 2. Delay calculation. Input the result of step 1 to a delaying function (as defined in section 2). If the range of step 2 does not map directly to a winning ticket (e.g., sequence number) then the following step may be needed: 3. Winner computation.
Reference: [21] <author> P. R. Zimmerman. </author> <note> PGPfone Owner's Manual, Version 1.0 beta 7, July 8, 1996, p. 33. </note>
Reference-contexts: They assume that communication takes some time, and do not require parties to otherwise identify themselves. (This is in contrast to PGP-Phone <ref> [21] </ref>, which requires parties to read the negotiated key-the right sounding voice reading shared keying material is hard to forge in real-time.) Finally, we briefly touch on other work. Cai et. al use moderately hard functions in the design of uncheatable benchmarks [6].
References-found: 21

