URL: http://www.cs.utexas.edu/users/kedar/papers/psynch.ps
Refering-URL: http://www.cs.utexas.edu/users/kedar/papers/psynch.html
Root-URL: 
Title: Automatic Verification of Parameterized Synchronous Systems  
Author: E. Allen Emerson and Kedar S. Namjoshi 
Address: Austin, U.S.A.  
Affiliation: Department of Computer Sciences, The University of Texas at  
Abstract: Systems with an arbitrary number of homogeneous processes occur in many applications. The Parameterized Model Checking Problem (PMCP) is to determine whether a temporal property is true of every size instance of the system. We consider systems formed by a synchronous parallel composition of a single control process with an arbitrary number of homogeneous user processes, and show that the PMCP is decidable for properties expressed in an indexed propositional temporal logic. While the problem is in general PSPACE-complete, our initial experi mental results indicate that the method is usable in practice. 
Abstract-found: 1
Intro-found: 1
Reference: [AK 86] <author> Apt, K., Kozen, D. </author> <title> Limits for automatic verification of finite-state concurrent systems. </title> <journal> IPL 15, </journal> <pages> pp. 307-309. </pages>
Reference-contexts: The general problem, then, is the Parameterized Model Checking Problem (PMCP): to determine whether a temporal property is true of every size instance of the the system. This is known to be undecidable in general <ref> [AK 86, Su 88] </ref>; however, it is decidable algorithmically for restricted classes [GS 92, EN 95], and there are methods with some degree of automation [Lu 84, ShG 89, KM 89, WL 89, V 93, CGJ 95]. <p> All of them, however, possess certain limitations, which is perhaps not surprising since the PMCP is undecidable in general (cf. <ref> [AK 86] </ref>,[Su 88]). Many of the methods are only partially automated, requiring human ingenuity to construct, e.g., a process invariant or closure process (cf. [CG 87], [BCG 89], [KM 89], [WL 89]).
Reference: [BCG 89] <author> Browne, M. C., Clarke, E. M., Grumberg, O. </author> <title> Reasoning about Networks with Many Identical Finite State Processes, </title> <journal> Information and Computation, </journal> <volume> vol. 81, no. 1, </volume> <pages> pp. 13-31, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: The formal semantics of these logics is defined in the usual way <ref> [Em 90, BCG 89, ES 95] </ref>, and we write M; s j= f to mean that formula f is true in structure M at state s. 3 The abstract model For a given (C; U ) family, we construct an abstract process A which includes all computations of every size instance <p> All of them, however, possess certain limitations, which is perhaps not surprising since the PMCP is undecidable in general (cf. [AK 86],[Su 88]). Many of the methods are only partially automated, requiring human ingenuity to construct, e.g., a process invariant or closure process (cf. [CG 87], <ref> [BCG 89] </ref>, [KM 89], [WL 89]). Some could be fully automated but do not appear to have a clearly defined class of protocols on which they are guaranteed to succeed (cf. [ShG 89], [V 93], [CGJ 95]).
Reference: [CE 81] <author> Clarke, </author> <title> E.M., Emerson, E.A. Design and Synthesis of Synchronization Skeletons using Branching Time Temporal Logic. </title> <booktitle> Workshop on Logics of Programs, </booktitle> <publisher> Springer-Verlag LNCS 131. </publisher>
Reference: [CES 86] <author> Clarke, </author> <title> E.M., Emerson, E.A., and Sistla, A.P., Automatic Verification of Finite-State Concurrent Systems using Temporal Logic, </title> <journal> ACM Trans. Prog. Lang. and Sys., </journal> <volume> vol. 8, no. 2, </volume> <pages> pp. 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference: [CFJ 93] <author> Clarke, E.M., Filkorn, T., Jha, S. </author> <title> Exploiting Symmetry in Temporal Logic Model Checking, </title> <booktitle> 5th CAV, </booktitle> <publisher> Springer-Verlag LNCS 697. </publisher>
Reference-contexts: Hence there is complete symmetry among the user processes in any size instance of a (C; U ) family, and the PMCP for formulae of type (2) and (3) reduces that for formulae of type (1). The following lemmas are based on those in <ref> [ES 93, CFJ 93] </ref> (cf. [ID 93]) Let f (i) be a CTL fl formula with propositions over the states of C and over the states of U indexed with i, and let f (i; j) be a CTL fl formula with propositions over the states of C and over the
Reference: [CG 87] <author> Clarke, E.M., Grumberg, O. </author> <title> Avoiding the State Explosion Problem in Temporal Logic Model Checking Algorithms, </title> <month> PODC </month> <year> 1987. </year>
Reference-contexts: All of them, however, possess certain limitations, which is perhaps not surprising since the PMCP is undecidable in general (cf. [AK 86],[Su 88]). Many of the methods are only partially automated, requiring human ingenuity to construct, e.g., a process invariant or closure process (cf. <ref> [CG 87] </ref>, [BCG 89], [KM 89], [WL 89]). Some could be fully automated but do not appear to have a clearly defined class of protocols on which they are guaranteed to succeed (cf. [ShG 89], [V 93], [CGJ 95]). <p> Abstract graphs (for asynchronous systems) were considered in [ESr 90] for synthesis, [V 93] for automatic but incomplete verification, and in <ref> [CG 87] </ref>, where they are called process closures. Interestingly, [CG 87] show (in our notation) that if, for some k, C k U k k A is appropriately bisimilar to C k U k+1 k A, then it suffices to model check instances of size at most k to solve the <p> Abstract graphs (for asynchronous systems) were considered in [ESr 90] for synthesis, [V 93] for automatic but incomplete verification, and in <ref> [CG 87] </ref>, where they are called process closures. Interestingly, [CG 87] show (in our notation) that if, for some k, C k U k k A is appropriately bisimilar to C k U k+1 k A, then it suffices to model check instances of size at most k to solve the PMCP.
Reference: [CGJ 95] <author> Clarke, E.M., Grumberg, O., Jha, S. </author> <title> Verifying Parameterized Networks using Abstraction and Regular Languages. </title> <type> CONCUR 95. </type>
Reference-contexts: Some could be fully automated but do not appear to have a clearly defined class of protocols on which they are guaranteed to succeed (cf. [ShG 89], [V 93], <ref> [CGJ 95] </ref>). Abstract graphs (for asynchronous systems) were considered in [ESr 90] for synthesis, [V 93] for automatic but incomplete verification, and in [CG 87], where they are called process closures.
Reference: [Em 90] <author> Emerson, </author> <title> E.A., Temporal and Modal Logic, </title> <booktitle> in Handbook of Theoretical Computer Science, </booktitle> <volume> vol. </volume> <editor> B, (J. van Leeuwen, ed.), Elsevier/North-Holland, </editor> <year> 1991. </year>
Reference-contexts: The formal semantics of these logics is defined in the usual way <ref> [Em 90, BCG 89, ES 95] </ref>, and we write M; s j= f to mean that formula f is true in structure M at state s. 3 The abstract model For a given (C; U ) family, we construct an abstract process A which includes all computations of every size instance
Reference: [EN 95] <author> Emerson, </author> <title> E.A., Namjoshi, K.S. Reasoning about Rings. </title> <booktitle> Proc. ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1995. </year>
Reference-contexts: The general problem, then, is the Parameterized Model Checking Problem (PMCP): to determine whether a temporal property is true of every size instance of the the system. This is known to be undecidable in general [AK 86, Su 88]; however, it is decidable algorithmically for restricted classes <ref> [GS 92, EN 95] </ref>, and there are methods with some degree of automation [Lu 84, ShG 89, KM 89, WL 89, V 93, CGJ 95]. This previous work (with the exception of [KM 89]) was oriented toward asynchronous systems.
Reference: [ES 93] <author> Emerson, </author> <title> E.A., Sistla, A.P. Symmetry and Model Checking, </title> <booktitle> 5th CAV, </booktitle> <publisher> Springer-Verlag LNCS 697. </publisher>
Reference-contexts: Hence there is complete symmetry among the user processes in any size instance of a (C; U ) family, and the PMCP for formulae of type (2) and (3) reduces that for formulae of type (1). The following lemmas are based on those in <ref> [ES 93, CFJ 93] </ref> (cf. [ID 93]) Let f (i) be a CTL fl formula with propositions over the states of C and over the states of U indexed with i, and let f (i; j) be a CTL fl formula with propositions over the states of C and over the
Reference: [ES 95] <author> Emerson, </author> <title> E.A., Sistla, A.P. Utilizing Symmetry when Model Checking under Fairness Assumptions: An Automata-theoretic approach. </title> <booktitle> CAV 1995. </booktitle> <pages> 11 </pages>
Reference-contexts: The formal semantics of these logics is defined in the usual way <ref> [Em 90, BCG 89, ES 95] </ref>, and we write M; s j= f to mean that formula f is true in structure M at state s. 3 The abstract model For a given (C; U ) family, we construct an abstract process A which includes all computations of every size instance <p> : A portion of the abstract graph for the example in FIG 1. (K;fIg) X 0 = f (I; A);(I;B)g (L; fA;Bg) (K; fC; Dg) X 2 = f (A; C);(B; D)g To determine if such cycles are present, we resolve a cycle in M into a "threaded graph" (cf. <ref> [ES 95] </ref>) which shows explicitly which local user state in an abstract state is driven into which other local user state in the next abstract state. This information is obtained from the transition label.
Reference: [ESr 90] <author> Emerson, E.A., Srinivasan, J. </author> <title> A decidable temporal logic to reason about many pro-cesses. </title> <month> PODC </month> <year> 1990. </year>
Reference-contexts: Some could be fully automated but do not appear to have a clearly defined class of protocols on which they are guaranteed to succeed (cf. [ShG 89], [V 93], [CGJ 95]). Abstract graphs (for asynchronous systems) were considered in <ref> [ESr 90] </ref> for synthesis, [V 93] for automatic but incomplete verification, and in [CG 87], where they are called process closures.
Reference: [GS 92] <author> German, </author> <title> S.M., Sistla, A.P. Reasoning about Systems with Many Processes. </title> <journal> J.ACM, </journal> <volume> Vol. 39, Number 3, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: The general problem, then, is the Parameterized Model Checking Problem (PMCP): to determine whether a temporal property is true of every size instance of the the system. This is known to be undecidable in general [AK 86, Su 88]; however, it is decidable algorithmically for restricted classes <ref> [GS 92, EN 95] </ref>, and there are methods with some degree of automation [Lu 84, ShG 89, KM 89, WL 89, V 93, CGJ 95]. This previous work (with the exception of [KM 89]) was oriented toward asynchronous systems. <p> Our approach, in contrast, is a fully automated, sound and complete one (i.e., always generates a correct "yes" or "no" answer to the PMCP). Another such approach appears in <ref> [GS 92] </ref>. They also consider systems with a single control process and an arbitrary number of user processes, but with asynchronous CCS-type interactions. Unfortunately, their algorithm has exponential space (double exponential time) worst case complexity. Our framework thus differs from [GS 92] in these significant respects: (a) the parallel composition operator <p> Another such approach appears in <ref> [GS 92] </ref>. They also consider systems with a single control process and an arbitrary number of user processes, but with asynchronous CCS-type interactions. Unfortunately, their algorithm has exponential space (double exponential time) worst case complexity. Our framework thus differs from [GS 92] in these significant respects: (a) the parallel composition operator is synchronous; (b) we permit guards testing "everywhere" conditions (i.e., of the form 8i E (i)); (c) it is more tractable (PSPACE vs. EXPSPACE) 4 . <p> EXPSPACE) 4 . Partial synchrony can also be handled 4 On the other hand, for their model of computation with all user processes but no control process, there is a polynomial time algorithm <ref> [GS 92] </ref>. We believe that our PSPACE-completeness result is not an insurmountable barrier to practical utility, given BDD-based implementations, as suggested in section 6. 10 in our framework. These factors permit us to represent a wider range of concurrent systems. <p> These factors permit us to represent a wider range of concurrent systems. For example, the bus protocol described in Section 6 relies on the ability to test everywhere conditions, which are not permitted in <ref> [GS 92] </ref>. There is a noteworthy limitation in the modeling power of our present framework. Because of the covering lemma (Lemma 1), an algorithm for mutual exclusion cannot be implemented in our model (cf. [GS 92]'s control process-free model), even with the control process. <p> in Section 6 relies on the ability to test everywhere conditions, which are not permitted in <ref> [GS 92] </ref>. There is a noteworthy limitation in the modeling power of our present framework. Because of the covering lemma (Lemma 1), an algorithm for mutual exclusion cannot be implemented in our model (cf. [GS 92]'s control process-free model), even with the control process. We suspect it is possible to overcome this restriction, and are working on it. Finally, it is interesting to note that we can show that for fully asynchronous computation (interleaving semantics), the PMCP for our model becomes undecidable.
Reference: [HB 95] <author> Hojati, R., Brayton, R. </author> <title> Automatic Datapath Abstraction in Hardware Systems, </title> <booktitle> CAV 1995. </booktitle>
Reference: [ID 93] <author> Ip, C., Dill, D. </author> <title> Better verification through symmetry. </title> <booktitle> Proc. 11th Intl. Symp. on Computer Hardware Description Languages and their Applications. </booktitle>
Reference-contexts: Hence there is complete symmetry among the user processes in any size instance of a (C; U ) family, and the PMCP for formulae of type (2) and (3) reduces that for formulae of type (1). The following lemmas are based on those in [ES 93, CFJ 93] (cf. <ref> [ID 93] </ref>) Let f (i) be a CTL fl formula with propositions over the states of C and over the states of U indexed with i, and let f (i; j) be a CTL fl formula with propositions over the states of C and over the states of U indexed with
Reference: [KM 89] <author> Kurshan, R.P., McMillan, K. </author> <title> A Structural Induction Theorem for Processes, </title> <month> PODC </month> <year> 1989. </year>
Reference-contexts: This previous work (with the exception of <ref> [KM 89] </ref>) was oriented toward asynchronous systems. We propose a fully automated approach to the PMCP for synchronous systems. We consider synchronous systems with a unique control process and an arbitrary number of homogeneous user processes. Each system is thus parameterized by the number of user processes. <p> All of them, however, possess certain limitations, which is perhaps not surprising since the PMCP is undecidable in general (cf. [AK 86],[Su 88]). Many of the methods are only partially automated, requiring human ingenuity to construct, e.g., a process invariant or closure process (cf. [CG 87], [BCG 89], <ref> [KM 89] </ref>, [WL 89]). Some could be fully automated but do not appear to have a clearly defined class of protocols on which they are guaranteed to succeed (cf. [ShG 89], [V 93], [CGJ 95]).
Reference: [LSY 94] <author> Li, J., Suzuki, I., Yamashita, M. </author> <title> Fair Petri Nets and structural induction for rings of processes. </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 135(2), </volume> <year> 1994. </year> <pages> pp. 337-404. </pages>
Reference: [LP85] <author> Litchtenstein, O., and Pnueli, A., </author> <title> Checking That Finite State Concurrent Programs Satisfy Their Linear Specifications, </title> <booktitle> POPL 85, </booktitle> <pages> pp. 97-107. </pages>
Reference-contexts: To model-check such a property, we follow the automata-theoretic approach of [VW 86] : To determine if M; M j= Eh, construct a Buchi automaton B h for h, and check that the language of the product Buchi automaton of M and B h is non-empty (cf. <ref> [LP85] </ref>). The check for the property Ah is easily reduced to that for the earlier case by noting that M; M j= Ah iff M; M 6j= E:h. We say that formula Ah is universal iff it is true for every size instance of the family.
Reference: [Lo 93] <author> Long, D. </author> <title> Model Checking, Abstraction, and Compositional Verification. </title> <type> Ph.D. Thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1993. </year>
Reference: [Lu 84] <author> Lubachevsky, B. </author> <title> An Approach to Automating the Verification of Compact Parallel Coordination Programs I. </title> <journal> Acta Informatica 21, </journal> <year> 1984. </year>
Reference-contexts: Pong and Dubois [PD 95] propose a similar abstract graph construction for verification of safety properties of cache coherence protocols. They consider a synchronous model with broadcast actions. Although sound for verification, their method appears to be incomplete. Lubachevsky <ref> [Lu 84] </ref> makes an interesting early report of the use of an abstract graph similar to a "region graph" for parameterized asynchronous programs using Fetch-and-Add primitives; however, while it caters for (partial) automation, the completeness of the method is not established and it is not clear that it can be made
Reference: [MP 92] <author> Manna, Z., Pnueli, A. </author> <title> Temporal Logic of Reactive and Concurrent Systems: Specification, </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: PLTL is the standard propositional linear temporal logic built up from atomic propositions, boolean connectives, and temporal operators G (always), F (sometime), X (next time), and U (until) <ref> [Pn 77, MP 92] </ref>. CTL fl is a branching temporal logic which extends PLTL by allowing the path quantifiers A (for all fullpaths) and E (for some fullpath). Many interesting correctness properties of parameterized systems can be expressed in one of the following forms: 1.
Reference: [McM92] <author> McMillan, K., </author> <title> Symbolic Model Checking: An Approach to the State Explosion Problem, </title> <type> Ph.D. Thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1992. </year>
Reference-contexts: We show by a generic reduction that the PMCP is PSPACE-hard. As a result of the symmetry inherent in the system, the PMCP for the other types of formulae reduces to the PMCP for the first type. We have implemented this algorithm in SMV <ref> [McM92] </ref> and used it to check correctness of a bus arbitration protocol. Our initial experimental results indicate that the algorithm should be useful in practice. Section 2 defines the system model and the logic used for expressing correctness properties. <p> Hence, messages with lower priority cannot prevail over higher priority messages. We implemented the algorithm by generating SMV <ref> [McM92] </ref> code to describe the abstract process transitions, given a description of the next-state relation of the user and control processes. Since the correctness property is a safety property, we were able to simplify the implementation as described following Theorem 3.
Reference: [Pn 77] <author> Pnueli, A. </author> <title> The Temporal Logic of Programs. </title> <booktitle> FOCS 1977. </booktitle>
Reference-contexts: PLTL is the standard propositional linear temporal logic built up from atomic propositions, boolean connectives, and temporal operators G (always), F (sometime), X (next time), and U (until) <ref> [Pn 77, MP 92] </ref>. CTL fl is a branching temporal logic which extends PLTL by allowing the path quantifiers A (for all fullpaths) and E (for some fullpath). Many interesting correctness properties of parameterized systems can be expressed in one of the following forms: 1.
Reference: [PD 95] <author> Pong, F., Dubois, M. </author> <title> A New Approach for the Verification of Cache Coherence Protocols. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <month> August </month> <year> 1995. </year>
Reference-contexts: However, they do not show that such a cutoff k always exists, and their method is not guaranteed to be complete. Pong and Dubois <ref> [PD 95] </ref> propose a similar abstract graph construction for verification of safety properties of cache coherence protocols. They consider a synchronous model with broadcast actions. Although sound for verification, their method appears to be incomplete. <p> Acknowledgements: We would like to thank Carl Pixley of Motorola for suggesting the bus protocol example, and the CAV '96 referees for bringing <ref> [PD 95] </ref> to our attention.
Reference: [RS 85] <author> Reif, J., Sistla, A. P. </author> <title> A multiprocess network logic with temporal and spatial modalities. </title> <type> JCSS 30(1), </type> <year> 1985. </year>
Reference: [RS 93] <author> Rho, J. K., Somenzi, F. </author> <title> Automatic Generation of Network Invariants for the Verification of Iterative Sequential Systems. </title> <note> CAV 1993, LNCS 697. </note>
Reference: [SAE 92] <editor> SAE J1850 Class B data communication network interface. </editor> <publisher> Society of Automotive Engineers, Inc., </publisher> <year> 1992. </year>
Reference-contexts: (i; j) is universal for a (C; U ) family iff Ah (0; 0 0 ) is universal for the control process in the family ((CjU jU ); U ). 6 Applications We have implemented this algorithm to verify a bus arbitration protocol based on the SAE J1850 draft standard <ref> [SAE 92] </ref> for automobile applications. This is a protocol where many microcon-trollers can transmit symbols along a shared single-wire bus in a car. As a consequence of this 9 restriction, symbols are encoded by the width of a pulse.
Reference: [ShG 89] <author> Shtadler, Z., Grumberg, O. </author> <title> Network Grammars, Communication Behaviours and Automatic Verification. </title> <publisher> Springer-Verlag, LNCS 407. </publisher>
Reference-contexts: Some could be fully automated but do not appear to have a clearly defined class of protocols on which they are guaranteed to succeed (cf. <ref> [ShG 89] </ref>, [V 93], [CGJ 95]). Abstract graphs (for asynchronous systems) were considered in [ESr 90] for synthesis, [V 93] for automatic but incomplete verification, and in [CG 87], where they are called process closures.
Reference: [Su 88] <author> Suzuki, I. </author> <title> Proving properties of a ring of finite state machines. </title> <journal> IPL 28, </journal> <pages> pp. 213-214. </pages>
Reference-contexts: The general problem, then, is the Parameterized Model Checking Problem (PMCP): to determine whether a temporal property is true of every size instance of the the system. This is known to be undecidable in general <ref> [AK 86, Su 88] </ref>; however, it is decidable algorithmically for restricted classes [GS 92, EN 95], and there are methods with some degree of automation [Lu 84, ShG 89, KM 89, WL 89, V 93, CGJ 95].
Reference: [Va9?] <author> Vardi, M. </author> <title> An Automata-theoretic Approach to Linear Temporal Logic, Proceedings of Banff Higher Order Workshop on Logics for Concurrency, </title> <journal> F. </journal> <note> Moller, ed., Springer-Verlag LNCS, to appear. 12 </note>
Reference: [VW 86] <author> Vardi, M., Wolper, P. </author> <title> An Automata-theoretic Approach to Automatic Program Veri--fication, </title> <booktitle> Proc. IEEE LICS, </booktitle> <pages> pp. 332-344, </pages> <year> 1986. </year>
Reference-contexts: To model-check such a property, we follow the automata-theoretic approach of <ref> [VW 86] </ref> : To determine if M; M j= Eh, construct a Buchi automaton B h for h, and check that the language of the product Buchi automaton of M and B h is non-empty (cf. [LP85]).
Reference: [V 93] <author> Vernier, I. </author> <title> Specification and Verification of Parameterized Parallel Programs. </title> <booktitle> Proc. 8th Intl. Symp. on Computer and Information Sciences, Istanbul, Turkey, </booktitle> <pages> pp. 622-625. </pages>
Reference-contexts: Some could be fully automated but do not appear to have a clearly defined class of protocols on which they are guaranteed to succeed (cf. [ShG 89], <ref> [V 93] </ref>, [CGJ 95]). Abstract graphs (for asynchronous systems) were considered in [ESr 90] for synthesis, [V 93] for automatic but incomplete verification, and in [CG 87], where they are called process closures. <p> Some could be fully automated but do not appear to have a clearly defined class of protocols on which they are guaranteed to succeed (cf. [ShG 89], <ref> [V 93] </ref>, [CGJ 95]). Abstract graphs (for asynchronous systems) were considered in [ESr 90] for synthesis, [V 93] for automatic but incomplete verification, and in [CG 87], where they are called process closures.
Reference: [WL 89] <author> Wolper, P., Lovinfosse, V. </author> <title> Verifying Properties of Large Sets of Processes with Network Invariants. </title> <publisher> Springer-Verlag, LNCS 407. </publisher> <pages> 13 </pages>
Reference-contexts: Many of the methods are only partially automated, requiring human ingenuity to construct, e.g., a process invariant or closure process (cf. [CG 87], [BCG 89], [KM 89], <ref> [WL 89] </ref>). Some could be fully automated but do not appear to have a clearly defined class of protocols on which they are guaranteed to succeed (cf. [ShG 89], [V 93], [CGJ 95]).
References-found: 33

