URL: http://www.cs.umsl.edu/Faculty/janikow/psdocs/cgp.CMwA.ps
Refering-URL: http://www.cs.bham.ac.uk/~wbl/biblio/gp-bibliography.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: emailto:janikow@radom.umsl.edu  
Title: A Methodology for Processing Problem Constraints in Genetic Programming  
Author: Cezary Z. Janikow 
Date: November 6, 1997  
Address: St. Louis  
Affiliation: Department of Mathematics and Computer Science University of Missouri  
Abstract: Search mechanisms of artificial intelligence combine two elements: representation, which determines the search space, and a search mechanism, which actually explores the space. Unfortunately, many searches may explore redundant and/or invalid solutions. Genetic programming refers to a class of evolutionary algorithms based on genetic algorithms but utilizing a parameterized representation in the form of trees. These algorithms perform searches based on simulation of nature. They face the same problems of redundant/invalid subspaces. These problems have just recently been addressed in a systematic manner. This paper presents a methodology devised for the public domain genetic programming tool lil-gp. This methodology uses data typing and semantic information to constrain the representation space so that only valid, and possibly unique, solutions will be explored. The user enters problem-specific constraints, which are transformed into a normal set. This set is checked for feasibility, and subsequently it is used to limit the space being explored. The constraints can determine valid, possibly unique space. Moreover, they can also be used to exclude subspaces the user considers uninteresting, using some problem-specific knowledge. A simple example is followed thoroughly to illustrate the constraint language, transformations, and the normal set. Experiments with boolean 11-multiplexer illustrate practical applications of the method to limit redundant space exploration by utilizing problem-specific knowledge. fl Supported by a grant from NASA/JSC: NAG 9-847.
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Leonard Bolc & Jerzy Cytowski. </editor> <booktitle> Search Methods for Artificial Intelligence. </booktitle> <publisher> Academic Press, </publisher> <year> 1992. </year>
Reference-contexts: For example, solving a two-dimensional integer optimization problem with both domains [1,100] would involve searching through the space of 10,000 solutions (one for each pair). This search may be random, enumerated exhaustive, or heuristic <ref> [1] </ref>. However, in most practical problems of interest to artificial intelligence, the space of potential solutions is too large to be explicitly retained and effectively randomly or exhaustively searched by an algorithms. <p> Given a complete set of operators, some control strategy is then used to manage the search. Such approaches are called state-space searches in artificial intelligence <ref> [1] </ref>. Evolutionary algorithms utilize state-space searches. The subspace being explored is retained in the population of chromosomes. Genetic operators, such as mutation and crossover, generate new solutions from the existing ones.
Reference: [2] <author> Lawrence Davis (ed.). </author> <title> Handbook of Genetic Algorithms. </title> <publisher> Van Nostrand Reinhold, </publisher> <year> 1991. </year>
Reference-contexts: This idea has been long realized and practiced in artificial intelligence. There, one class of algorithms borrows ideas from nature, namely population dynamics, selective pressure, and information inheritance by offspring, to organize its search. This is the class of evolutionary algorithms. Genetic algorithms (GAs) <ref> [2, 3, 4] </ref> are the most extensively studied and applied evolutionary algorithms. A GA uses a population of chromosomes coding individual potential solutions. These chromosomes undergo a simulated evolution facing Darwinian selective pressure. Chromosomes which are better with respect to a simulated environment have increasing survival chances. <p> Most genetic algorithms operate on fixed-length chromosomes, which may not be suitable for some problems. To deal with that, some genetic algorithms adapted variable-length representation, as in machine learning [3, 5]. Moreover, traditional genetic algorithms use low-level binary representation, but many recent applications use other abstracted alphabets <ref> [2, 5] </ref>. Genetic programming (GP) [7, 8, 9] uses trees to represent chromosomes. At first used to generate LISP computer programs, GP is also being used to solve problems where solutions have arbitrary interpretations [7]. Tree representation is richer than that of linear fixed-length strings.
Reference: [3] <author> David E. Goldberg. </author> <title> Genetic Algorithms in Search, Optimization, and Machine Learning. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: This idea has been long realized and practiced in artificial intelligence. There, one class of algorithms borrows ideas from nature, namely population dynamics, selective pressure, and information inheritance by offspring, to organize its search. This is the class of evolutionary algorithms. Genetic algorithms (GAs) <ref> [2, 3, 4] </ref> are the most extensively studied and applied evolutionary algorithms. A GA uses a population of chromosomes coding individual potential solutions. These chromosomes undergo a simulated evolution facing Darwinian selective pressure. Chromosomes which are better with respect to a simulated environment have increasing survival chances. <p> Chromosomes interact with each other via crossover to produce new offspring solutions, and they are subjected to mutation. Most genetic algorithms operate on fixed-length chromosomes, which may not be suitable for some problems. To deal with that, some genetic algorithms adapted variable-length representation, as in machine learning <ref> [3, 5] </ref>. Moreover, traditional genetic algorithms use low-level binary representation, but many recent applications use other abstracted alphabets [2, 5]. Genetic programming (GP) [7, 8, 9] uses trees to represent chromosomes.
Reference: [4] <author> Holland, J. </author> <title> Adaptation in Natural and Artificial Systems. </title> <publisher> University of Michigan Press, </publisher> <year> 1975. </year>
Reference-contexts: This idea has been long realized and practiced in artificial intelligence. There, one class of algorithms borrows ideas from nature, namely population dynamics, selective pressure, and information inheritance by offspring, to organize its search. This is the class of evolutionary algorithms. Genetic algorithms (GAs) <ref> [2, 3, 4] </ref> are the most extensively studied and applied evolutionary algorithms. A GA uses a population of chromosomes coding individual potential solutions. These chromosomes undergo a simulated evolution facing Darwinian selective pressure. Chromosomes which are better with respect to a simulated environment have increasing survival chances.
Reference: [5] <author> Cezary Z. Janikow. </author> <title> "A Knowledge-Intensive GA for Supervised Learning". </title> <booktitle> Machine Learning 13 (1993), </booktitle> <pages> pp. 189-228. 21 </pages>
Reference-contexts: Chromosomes interact with each other via crossover to produce new offspring solutions, and they are subjected to mutation. Most genetic algorithms operate on fixed-length chromosomes, which may not be suitable for some problems. To deal with that, some genetic algorithms adapted variable-length representation, as in machine learning <ref> [3, 5] </ref>. Moreover, traditional genetic algorithms use low-level binary representation, but many recent applications use other abstracted alphabets [2, 5]. Genetic programming (GP) [7, 8, 9] uses trees to represent chromosomes. <p> Most genetic algorithms operate on fixed-length chromosomes, which may not be suitable for some problems. To deal with that, some genetic algorithms adapted variable-length representation, as in machine learning [3, 5]. Moreover, traditional genetic algorithms use low-level binary representation, but many recent applications use other abstracted alphabets <ref> [2, 5] </ref>. Genetic programming (GP) [7, 8, 9] uses trees to represent chromosomes. At first used to generate LISP computer programs, GP is also being used to solve problems where solutions have arbitrary interpretations [7]. Tree representation is richer than that of linear fixed-length strings. <p> The subspace being explored is retained in the population of chromosomes. Genetic operators, such as mutation and crossover, generate new solutions from the existing ones. The control is stochastic, promoting exploration of "better" subspaces (additional heuristics may be used to further guide the search, as in <ref> [5] </ref>). In GP, a set of functions and a set of terminals are defined. Elements of these label the internal and the external nodes, respectively. Interpretations of those elements are given by providing implementations for evaluating nodes labeling them. <p> : F Root = fif g F fl = ; F fl not = fif; or; and; notg 16 F 1 and = fif; or; andg F 1 or = fif; org Previous experience with other evolutionary algorithms using DNF representation suggest that DNF is "the right" representation (GIL system, <ref> [5] </ref>). Thus, we would expect both E 2 and E 3 to do relatively well. <p> It seems that the reasons are similar to those above if will prove to be the most effective and thus extremely important. The fact that GP fails to efficiently evolve DNF solutions is striking when compared against another evolutionary program designed for machine learning. GIL <ref> [5] </ref> is a genetic algorithm with specialized DNF representation, specialized inductive operators, and evolutionary state-space search controlled by inductive heuristics.
Reference: [6] <author> Cezary Z. Janikow. </author> <title> "Constrained Genetic Programming". </title> <note> Submitted to Evolutionary Computation. </note>
Reference-contexts: Our objective is to provide a systematic means, while making sure that the means do not increase the overall computational complexity. In this paper, we present a method suitable for, and implemented with, a standard GP tool lil-gp. This methodology is a somehow weaker version of <ref> [6] </ref>, modified specifically for lil-gp. lil-gp is a tool [11] for developing GP applications. Its implementation is based on the standard GP closure property [8], which states that every function can call any other function and that any terminal can provide values for any function argument. <p> Recently, other methods have been explored and proposed. For example, Montana has developed means for ensuring that only valid trees evolve (Strongly Typed Genetic Programming - STGP [10]), and we independently proposed a similar methodology for processing more arbitrary constraints in Constrained Genetic Programming (CGP) <ref> [6] </ref>. CGP, in addition to providing means for avoiding exploration of invalid subspaces, also provides for specification/avoidance of both redundant subspaces as well as subspaces which are perfectly valid but some problem-specific heuristics suggest to exclude them from being desired solutions. <p> The objectives of CGP is to provide means to specify syntax and semantic constraints, and to provide efficient systematic mechanisms to enforce them <ref> [6] </ref>. We have just implemented a pilot tool 1 , which incorporates CGP with the widely used GP tool lil-gp1.02 (lil-gp allows forrest chromosomes, which for computer programs corresponds to program modules our current methodology deals with a single tree, but it is currently being extended). <p> Syntactic constraints include typing function arguments, values returned by functions, and individual terminals. These are similar to those of Mon-tana [10]. Semantic constraints are additional restrictions based on function or terminal interpretation. The methodology presented here is a weaker version of that presented in <ref> [6] </ref>, but it is the one that has been implemented with lil-gp. 3 CGP Methodology 3.1 Constraint specifications In lil-gp [11], functions and terminals fall into three categories. <p> In lil-gp [11], terminal sets for type III are not extensively defined. Instead, they are defined by generating functions, which return uniform random elements from the appropriate ranges. Ranges for functions of type I and type II and not explicitly defined either. In <ref> [6] </ref> we defined the notion of domain/range compatibility (denoted here )), which can be used to infer validity of using functions and terminals as arguments to other functions. That notion, based on sets, allows automated processing of such compatibilities. <p> To avoid extra complexity, we express a somehow lesser constraint, one which restricts only immediate arguments (in the original theory it is possible to specify the stronger constraint for this function set, because that theory is based on sets rather than functions <ref> [6] </ref>).
Reference: [7] <editor> Kenneth E. Kinnear, Jr. (ed.) </editor> <booktitle> Advances in Genetic Programming. </booktitle> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: To deal with that, some genetic algorithms adapted variable-length representation, as in machine learning [3, 5]. Moreover, traditional genetic algorithms use low-level binary representation, but many recent applications use other abstracted alphabets [2, 5]. Genetic programming (GP) <ref> [7, 8, 9] </ref> uses trees to represent chromosomes. At first used to generate LISP computer programs, GP is also being used to solve problems where solutions have arbitrary interpretations [7]. Tree representation is richer than that of linear fixed-length strings. However, there is a price to pay for this richness. <p> Genetic programming (GP) [7, 8, 9] uses trees to represent chromosomes. At first used to generate LISP computer programs, GP is also being used to solve problems where solutions have arbitrary interpretations <ref> [7] </ref>. Tree representation is richer than that of linear fixed-length strings. However, there is a price to pay for this richness. In general, the number of trees should equal the number of potential solutions, with one-to-one mapping between them. Unfortunately, this is hardly ever possible. <p> Therefore, some means of dealing with such cases, such as possibly avoiding the exploration of such extraneous trees, are desired. While for some problems some ad-hoc mechanisms have been proposed <ref> [7, 8] </ref>, there is no general methodology. Our objective is to provide a systematic means, while making sure that the means do not increase the overall computational complexity. In this paper, we present a method suitable for, and implemented with, a standard GP tool lil-gp.
Reference: [8] <editor> John R. Koza. </editor> <booktitle> Genetic Programming. </booktitle> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: To deal with that, some genetic algorithms adapted variable-length representation, as in machine learning [3, 5]. Moreover, traditional genetic algorithms use low-level binary representation, but many recent applications use other abstracted alphabets [2, 5]. Genetic programming (GP) <ref> [7, 8, 9] </ref> uses trees to represent chromosomes. At first used to generate LISP computer programs, GP is also being used to solve problems where solutions have arbitrary interpretations [7]. Tree representation is richer than that of linear fixed-length strings. However, there is a price to pay for this richness. <p> Therefore, some means of dealing with such cases, such as possibly avoiding the exploration of such extraneous trees, are desired. While for some problems some ad-hoc mechanisms have been proposed <ref> [7, 8] </ref>, there is no general methodology. Our objective is to provide a systematic means, while making sure that the means do not increase the overall computational complexity. In this paper, we present a method suitable for, and implemented with, a standard GP tool lil-gp. <p> In this paper, we present a method suitable for, and implemented with, a standard GP tool lil-gp. This methodology is a somehow weaker version of [6], modified specifically for lil-gp. lil-gp is a tool [11] for developing GP applications. Its implementation is based on the standard GP closure property <ref> [8] </ref>, which states that every function can call any other function and that any terminal can provide values for any function argument. Even though this is usually called a "property", it is in fact a necessity in the absence of other means for dealing 2 with invalid trees. <p> Both approaches may face potential problems. Too many ad-hoc redundancies may easily change problem characteristics (problem landscape). Too many extinction-bound solutions waste computational resources and may cause premature convergence (over-selection in GP <ref> [8] </ref>). Recently, other methods have been explored and proposed. For example, Montana has developed means for ensuring that only valid trees evolve (Strongly Typed Genetic Programming - STGP [10]), and we independently proposed a similar methodology for processing more arbitrary constraints in Constrained Genetic Programming (CGP) [6]. <p> GP also allows another operator, selection, which simply copies chromosomes to the new population. Since all trees are evolved from the primitive elements, these must be sufficient to generate the sought tree. The assumption that this is indeed the case is called the sufficiency principle <ref> [8] </ref>. However, in general to satisfy sufficiency a large number of functions must be given. This unfortunately exponentially explodes the search space. In up-to-date applications, this is dealt with by providing "the right" functions and terminals. <p> In fact, this issue arises in any state-space search, and has yet to be addressed. We hope that our tool will help in studying this issue. We will use the widely studied 11-multiplexer problem <ref> [8] </ref>. Multiplexer is a boolean circuit with a number of inputs and exactly one output. In practical applications, a multiplexer is used to propagate exactly one of the inputs to the output. <p> a 0 d 5 _ a 2 a 1 a 0 d 4 _ a 2 a 1 a 0 d 3 _ a 2 a 1 a 0 d 2 _ a 2 a 1 a 0 d 1 _ a 2 a 1 a 0 d 0 In <ref> [8] </ref>, Koza has proposed to use the following function set F I = fand; or; not; if g and terminals F II = fa 0 : : : a 2 ; d 0 : : : d 7 g (no F III functions) for evolving the 11-multiplexer function 14 with GP.
Reference: [9] <editor> John R. Koza. </editor> <booktitle> Genetic Programming II. </booktitle> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: To deal with that, some genetic algorithms adapted variable-length representation, as in machine learning [3, 5]. Moreover, traditional genetic algorithms use low-level binary representation, but many recent applications use other abstracted alphabets [2, 5]. Genetic programming (GP) <ref> [7, 8, 9] </ref> uses trees to represent chromosomes. At first used to generate LISP computer programs, GP is also being used to solve problems where solutions have arbitrary interpretations [7]. Tree representation is richer than that of linear fixed-length strings. However, there is a price to pay for this richness.
Reference: [10] <author> David J. Montana. </author> <title> "Strongly typed genetic programming". </title> <journal> Evolutionary Computation, </journal> <volume> Vol. 3, No. 2, </volume> <year> 1995. </year>
Reference-contexts: Too many extinction-bound solutions waste computational resources and may cause premature convergence (over-selection in GP [8]). Recently, other methods have been explored and proposed. For example, Montana has developed means for ensuring that only valid trees evolve (Strongly Typed Genetic Programming - STGP <ref> [10] </ref>), and we independently proposed a similar methodology for processing more arbitrary constraints in Constrained Genetic Programming (CGP) [6]. <p> In general, the constraints we propose for the pruning include both 4 syntactic and semantic elements. Syntactic constraints include typing function arguments, values returned by functions, and individual terminals. These are similar to those of Mon-tana <ref> [10] </ref>. Semantic constraints are additional restrictions based on function or terminal interpretation. <p> That notion, based on sets, allows automated processing of such compatibilities. With lil-gp, these capabilities cannot be automated since no explicit sets are used, and the resulting methodology is somehow weaker (section 4 gives an example). Therefore, all compatibility specifications are left to user's responsibility (similarly to Montana's approach <ref> [10] </ref>). This unfortunately means that the user must be trained in the domain. Fortunately, our preprocessing offers a user-friendly method to specify constraints which method can deal with inconsistent and/or redundant specifications. Definition 1 Define the following Tspecs (syntactic constraints): 5 1. <p> Moreover, some Tspecs also implicitly restrict what function can call other functions. Tspecs are analogous to function prototypes and data typing in the context of tree-like computer programs, and thus they are similar to Montana's type restrictions <ref> [10] </ref>). Example 1 Assume F I = ff 1 ; f 2 ; f 3 g with arities 3, 2, and 1, respectively. Assume F II = ff 4 g and F III = ff 5 ; f 6 ; f 7 g. <p> Proposition 13 helps identify functions causing only infinite trees to be valid. Such cases can be reported to the user. Moreover, the troublesome functions can be removed from consideration. This feature, along with useless functions, is not currently implemented. Montana <ref> [10] </ref> presents a procedure which also takes tree depth into account. 3.2.5 CGP lil-gp mutation lil-gp mutates a tree by selecting a random node (different probabilities for internal and external nodes). The mutated node becomes the root of a subtree, which is grown as determined by some parameters. <p> In particular, we did not even explore the methodology's impact on the more serious problem of invalid subspaces, where we expect the benefits to amplify. We are also currently extending the implementation for ADFs (automatically defined functions), which will allow similar capabilities to Montana's generic functions <ref> [10] </ref> yet more general (as our crossover is more general). One should point out that the current constraint specification language does not allow for arbitrary constraints to be expressed. In particular, this lil-gp's version is even weaker than the originally proposed methodology.
Reference: [11] <author> Douglas Zonker & Bill Punch. </author> <note> lil-gp 1.0 User's Manual. zonker@isl.cps.msu.edu. 22 </note>
Reference-contexts: In this paper, we present a method suitable for, and implemented with, a standard GP tool lil-gp. This methodology is a somehow weaker version of [6], modified specifically for lil-gp. lil-gp is a tool <ref> [11] </ref> for developing GP applications. Its implementation is based on the standard GP closure property [8], which states that every function can call any other function and that any terminal can provide values for any function argument. <p> Semantic constraints are additional restrictions based on function or terminal interpretation. The methodology presented here is a weaker version of that presented in [6], but it is the one that has been implemented with lil-gp. 3 CGP Methodology 3.1 Constraint specifications In lil-gp <ref> [11] </ref>, functions and terminals fall into three categories. Let us call them functions of type I, II, and III (as described below), and sets of those functions will be denoted as F I , F II , and F III . <p> In other words, these terminal values are provided by the environment (as for a function reading the current temperature). III. Ephemeral random constant terminals. These are functions of no arguments, which are instantiated individually in each tree, thus the values are independent of the envi ronment. In lil-gp <ref> [11] </ref>, terminal sets for type III are not extensively defined. Instead, they are defined by generating functions, which return uniform random elements from the appropriate ranges. Ranges for functions of type I and type II and not explicitly defined either.
References-found: 11

