URL: http://www.cs.utah.edu/~ratan/papers/spaa98.ps.gz
Refering-URL: http://www.cs.utah.edu/~ratan/res.html
Root-URL: 
Email: Contact email: fghughal,mokkedemg@cs.utah.edu  
Title: Verification of Runway-PA8000 memory model using "Test model-checking" technique  
Author: Rajnish Ghughal, Abdel Mokkedem, Ratan Nalumasu, and Ganesh Gopalakrishnan 
Address: Salt Lake City, UT 84112-9205  
Affiliation: Department of Computer Science, University of Utah,  
Abstract: We have developed a formal technique called test model-checking for debugging claimed conformance to formal memory models by realistic memory systems and multiprocessor machines. Test model-checking is an embedding of a formal testing method called Archtest in the model-checking framework. In this paper, we describe our technique and illustrate it on the problem of checking sequential consistency of (a model of) the HP PA8000 symmetric multiprocessing (SMP) bus called Runway. Our experiments show that test model-checking is an effective method for use in the typically iterative design cycle of complex memory systems to quickly detect ordering violations and pinpoint their cause.
Abstract-found: 1
Intro-found: 1
Reference: [AG96] <author> Sarita V. Adve and Kourosh Gharachorloo. </author> <title> Shared memory consistency models: A tutorial. </title> <journal> Computer, </journal> <volume> 29(12) </volume> <pages> 66-76, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: 1 Introduction The fundamentally important problem <ref> [AG96] </ref> of verifying whether a given memory system conforms to a formal memory model appears in a number of contexts, including CPU design [Col92, GK94], I/O bus design [Cor97], and even in multi-threaded language design [GJS96]. <p> Most today's parallel machines provide relaxed memory models in order to increase the potential optimizations possible for hardware and compiler designers <ref> [AG96] </ref>. Test model-checking allows to test memory systems for a variety of relaxed memory models by combining different elemental rules. We are also working on extending the set of tests described in Archtest to include tests for TSO, PSO, and RMO. Acknowledgment We would like to thank Dr.
Reference: [BCS96] <author> William R. Bryg, Kenneth K. Chan, and Nicholas S.Fiduccia. </author> <title> A high-performance, low-cost multiprocessor bus for workstations and midrange servers. </title> <journal> Hewlett-Packard Journal, </journal> <pages> pages 18-24, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: We do not believe that such descriptions will scale up. On the other hand, the test model-checking method has not only been able to comfortably handle the memory system defined by the symmetric multiprocessor (SMP) bus called Runway <ref> [BCS96, GGH + 97] </ref> used by Hewlett-Packard in their high-end machines, but also it discovered many subtle bugs in early models describing this bus that we created. Our model includes a number of details such as split transactions, out of order transaction completions, and even an element of speculative execution.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract intepretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proceedings of 4th POPL, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, CA, </address> <publisher> ACM Press, </publisher> <year> 1977. </year>
Reference-contexts: For example, the assertions pertaining to the sequential consistency of lazy caching [Ger95], a simple memory system, expressed in various temporal logics (by [Gra94] in 8CTL fl [CES86] and [LLOR97] in TLA [Lam94]) are quite complex. In [Gra94], abstract interpretation <ref> [CC77] </ref> is employed to reduce infinite-system verification to finite 8CTL fl model-checking. They apply this technique to verify the sequential consistency of lazy caching with unbounded queues.
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM TOPLAS, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: Even approaches based on conventional model-checking are impossibly difficult to use in practice. For example, the assertions pertaining to the sequential consistency of lazy caching [Ger95], a simple memory system, expressed in various temporal logics (by [Gra94] in 8CTL fl <ref> [CES86] </ref> and [LLOR97] in TLA [Lam94]) are quite complex. In [Gra94], abstract interpretation [CC77] is employed to reduce infinite-system verification to finite 8CTL fl model-checking. They apply this technique to verify the sequential consistency of lazy caching with unbounded queues.
Reference: [Col] <author> W. W. Collier. </author> <title> Multiprocessor diagnostics. </title> <address> http://www.infomall.org/diagnostics/archtest.html. </address>
Reference-contexts: While Archtest is an incomplete testing method in that it does not, under all circumstances, detect violations of memory orderings [Col92], its tests have been shown to be sufficiently incisive to be useful in practice <ref> [Col] </ref>. Being based on Archtest, test model-checking is also incomplete. However, none of the (presumed) complete alternatives to date have been shown to be practical for verifying large designs. For example [PD96] involves the use of manually guided mechanical theorem proving.
Reference: [Col92] <author> W. W. Collier. </author> <title> Reasoning About Parallel Architectures. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction The fundamentally important problem [AG96] of verifying whether a given memory system conforms to a formal memory model appears in a number of contexts, including CPU design <ref> [Col92, GK94] </ref>, I/O bus design [Cor97], and even in multi-threaded language design [GJS96]. As the semantics of memory orderings are too subtle to be fathomed through informal reasoning alone, formal verification methods have a natural role to play here. <p> Test model-checking formally adapts to the realm of model-checking a formal architectural testing method called Archtest that has previously been successfully used on a number of commercial multiprocessors. While Archtest is an incomplete testing method in that it does not, under all circumstances, detect violations of memory orderings <ref> [Col92] </ref>, its tests have been shown to be sufficiently incisive to be useful in practice [Col]. Being based on Archtest, test model-checking is also incomplete. However, none of the (presumed) complete alternatives to date have been shown to be practical for verifying large designs. <p> We still have not found a satisfactory answer because the test of [McM93] uses only one location which then couldn't make it a test for sequential consistency; it could plausibly be a test for coherence|which again does not correspond to what Collier formally proves in <ref> [Col92] </ref>. In this context, our contribution has been to not only answer the above question (see Figure 1 which captures the test of [McM93]), but also to describe formally the finite-state abstractions that justify porting other tests from [Col92] to a model-checking framework. <p> for coherence|which again does not correspond to what Collier formally proves in <ref> [Col92] </ref>. In this context, our contribution has been to not only answer the above question (see Figure 1 which captures the test of [McM93]), but also to describe formally the finite-state abstractions that justify porting other tests from [Col92] to a model-checking framework. In [PD96], the authors use a method called aggregation on a distributed shared memory coherence protocol used in an experimental multiprocessor, to arrive at a simplified model of system behavior. Their technique involves manually assisted theorem proving. <p> In adapting the tests of Archtest, test model-checking gives the effect of choosing k = 1. Thus, we cover all possible schedules. 2 2 Overview of Test Model-checking Archtest is based on the theory presented in <ref> [Col92] </ref> that formally defines and characterizes architectural rules obeyed by memory subsystems of multiprocessors. Although these rules are elemental, in realistic memory systems the rules manifest in compound form. <p> For this reason, such cache updates requests are marked (with a ?). How do we check for sequential consistency? As suggested in <ref> [Col92] </ref>, we can show that sequential consistency is A (CM P; P O; W A). Archtest [Col92] does not provide a single compound test to check for A (CM P; P O; W A), but several tests can be combined. <p> For this reason, such cache updates requests are marked (with a ?). How do we check for sequential consistency? As suggested in <ref> [Col92] </ref>, we can show that sequential consistency is A (CM P; P O; W A). Archtest [Col92] does not provide a single compound test to check for A (CM P; P O; W A), but several tests can be combined. <p> This combination is exactly equivalent to testing sequential consistency because P O implies RO and W O (as formally defined in <ref> [Col92] </ref>). For every memory system we consider, a VIS Verilog model is created and these two tests are used to check for sequential consistency. <p> A very desirable feature one can provide in a tool based on test model-checking is a menu of previously generated test automata for the various compound rules in <ref> [Col92] </ref>, using which designers can probe their model. Our Verilog model captures quite faithfully the behavior of Runway cache coherence protocol and the PA8000 ordering rules.
Reference: [Cor97] <author> Francisco Corella, </author> <month> April </month> <year> 1997. </year> <title> Invited talk at Computer Hardware Description Languages 1997, Toledo, Spain, on Verifying I/O Systems. </title>
Reference-contexts: 1 Introduction The fundamentally important problem [AG96] of verifying whether a given memory system conforms to a formal memory model appears in a number of contexts, including CPU design [Col92, GK94], I/O bus design <ref> [Cor97] </ref>, and even in multi-threaded language design [GJS96]. As the semantics of memory orderings are too subtle to be fathomed through informal reasoning alone, formal verification methods have a natural role to play here.
Reference: [DPN93] <author> David L. Dill, Seungjoon Park, and Andreas Nowatzyk. </author> <title> Formal specification of abstract memory models. </title> <editor> In Gaetano Borriello and Carl Ebeling, editors, </editor> <booktitle> Research on Integrated Systems, </booktitle> <pages> pages 38-52. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: In [PD96], the authors use a method called aggregation on a distributed shared memory coherence protocol used in an experimental multiprocessor, to arrive at a simplified model of system behavior. Their technique involves manually assisted theorem proving. The work in [HMTLB95] as well as <ref> [DPN93] </ref> are aimed at verifying that synchronization routines work correctly under various memory models, where the memory models themselves are described using finite-state operational models. In [GK97, GK94], the authors study the problem of deciding whether a given set of traces are sequentially consistent.
Reference: [Ger95] <author> Rob Gerth. </author> <title> Introduction to sequential consistency and the lazy caching algorithm. </title> <booktitle> Distributed Computing, </booktitle> <year> 1995. </year> <note> Also can be found in http://www.research.digital.com/SRC/tla/papers.html#Lazy. </note>
Reference-contexts: For example [PD96] involves the use of manually guided mechanical theorem proving. Even approaches based on conventional model-checking are impossibly difficult to use in practice. For example, the assertions pertaining to the sequential consistency of lazy caching <ref> [Ger95] </ref>, a simple memory system, expressed in various temporal logics (by [Gra94] in 8CTL fl [CES86] and [LLOR97] in TLA [Lam94]) are quite complex. In [Gra94], abstract interpretation [CC77] is employed to reduce infinite-system verification to finite 8CTL fl model-checking. <p> Serial memories are often used to define sequential consistency (SC for short) operationally <ref> [Ger95] </ref>. 7 Lazy caching The lazy caching protocol [Ger95] also implements SC, and is geared towards a bus based architecture. The memory interface still consists of reads and writes; however, caches are interposed between the shared memory and the processors. <p> Serial memories are often used to define sequential consistency (SC for short) operationally <ref> [Ger95] </ref>. 7 Lazy caching The lazy caching protocol [Ger95] also implements SC, and is geared towards a bus based architecture. The memory interface still consists of reads and writes; however, caches are interposed between the shared memory and the processors.
Reference: [GGH + 97] <author> G. Gopalakrishnan, R. Ghughal, R. Hosabettu, A. Mokkedem, and R. Nalumasu. </author> <title> Formal modeling and validation applied to a commercial coherent bus: A case study. </title> <editor> In Hon F. Li and David K. Probst, editors, CHARME, </editor> <address> Montreal, Canada, </address> <year> 1997. </year>
Reference-contexts: We do not believe that such descriptions will scale up. On the other hand, the test model-checking method has not only been able to comfortably handle the memory system defined by the symmetric multiprocessor (SMP) bus called Runway <ref> [BCS96, GGH + 97] </ref> used by Hewlett-Packard in their high-end machines, but also it discovered many subtle bugs in early models describing this bus that we created. Our model includes a number of details such as split transactions, out of order transaction completions, and even an element of speculative execution.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java T M Language Specification. Sun Microsystems, </title> <address> 1.0 edition, </address> <month> August </month> <year> 1996. </year> <note> appeared also as book with same title in Addison-Wesleys 'The Java Series'. 11 </note>
Reference-contexts: 1 Introduction The fundamentally important problem [AG96] of verifying whether a given memory system conforms to a formal memory model appears in a number of contexts, including CPU design [Col92, GK94], I/O bus design [Cor97], and even in multi-threaded language design <ref> [GJS96] </ref>. As the semantics of memory orderings are too subtle to be fathomed through informal reasoning alone, formal verification methods have a natural role to play here. Unfortunately, previous solutions to this problem have either demanded valuable human expertise and time or have required complex temporal assertions to be made.
Reference: [GK94] <author> Phillip B. Gibbons and Ephraim Korach. </author> <title> On testing cache-coherent shared memories. </title> <booktitle> In Proceedings of the 6th Annual Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 177-188, </pages> <address> New York, NY, USA, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction The fundamentally important problem [AG96] of verifying whether a given memory system conforms to a formal memory model appears in a number of contexts, including CPU design <ref> [Col92, GK94] </ref>, I/O bus design [Cor97], and even in multi-threaded language design [GJS96]. As the semantics of memory orderings are too subtle to be fathomed through informal reasoning alone, formal verification methods have a natural role to play here. <p> Their technique involves manually assisted theorem proving. The work in [HMTLB95] as well as [DPN93] are aimed at verifying that synchronization routines work correctly under various memory models, where the memory models themselves are described using finite-state operational models. In <ref> [GK97, GK94] </ref>, the authors study the problem of deciding whether a given set of traces are sequentially consistent. These works do not address the problem we study, namely that of establishing that a detailed memory system model written in an HDL conforms to a formal memory model.
Reference: [GK97] <author> Phillip B. Gibbons and Ephraim Korach. </author> <title> Testing shared memories. </title> <journal> SIAM Journal on Computing, </journal> <volume> 26(4) </volume> <pages> 1208-1244, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: Their technique involves manually assisted theorem proving. The work in [HMTLB95] as well as [DPN93] are aimed at verifying that synchronization routines work correctly under various memory models, where the memory models themselves are described using finite-state operational models. In <ref> [GK97, GK94] </ref>, the authors study the problem of deciding whether a given set of traces are sequentially consistent. These works do not address the problem we study, namely that of establishing that a detailed memory system model written in an HDL conforms to a formal memory model.
Reference: [Gra94] <author> S. Graf. </author> <title> Verification of a distributed cache memory by using abstractions. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 818:207-??, </address> <year> 1994. </year>
Reference-contexts: For example [PD96] involves the use of manually guided mechanical theorem proving. Even approaches based on conventional model-checking are impossibly difficult to use in practice. For example, the assertions pertaining to the sequential consistency of lazy caching [Ger95], a simple memory system, expressed in various temporal logics (by <ref> [Gra94] </ref> in 8CTL fl [CES86] and [LLOR97] in TLA [Lam94]) are quite complex. In [Gra94], abstract interpretation [CC77] is employed to reduce infinite-system verification to finite 8CTL fl model-checking. They apply this technique to verify the sequential consistency of lazy caching with unbounded queues. <p> For example, the assertions pertaining to the sequential consistency of lazy caching [Ger95], a simple memory system, expressed in various temporal logics (by <ref> [Gra94] </ref> in 8CTL fl [CES86] and [LLOR97] in TLA [Lam94]) are quite complex. In [Gra94], abstract interpretation [CC77] is employed to reduce infinite-system verification to finite 8CTL fl model-checking. They apply this technique to verify the sequential consistency of lazy caching with unbounded queues. <p> They apply this technique to verify the sequential consistency of lazy caching with unbounded queues. They recognize that to get an exact characterization of sequential consistency involving only the observable event names, one needs full second order logic <ref> [Gra94] </ref>. To be able to express sequential consistency 1 in 8CTL fl , they give a stronger characterization of sequential consistency, the temporal formula de-scribing which is very complex. We do not believe that such descriptions will scale up.
Reference: [HB95] <author> R. Hojati and R. Brayton. </author> <title> Automatic datapath abstraction of hardware systems. </title> <booktitle> In Conference on Computer-Aided Verification, </booktitle> <year> 1995. </year>
Reference-contexts: We also assume that the system is address semi-dependent <ref> [HB95] </ref>, i.e., the control logic can at most compare two addresses for equality or inequality and base its actions on the outcome of this test.
Reference: [HMTLB95] <author> R. Hojati, R. Mueller-Thuns, P. Loewenstein, and R. Brayton. </author> <title> Automatic verification of memory systems which service their requests out of order. </title> <booktitle> In CHDL, </booktitle> <pages> pages 623-639, </pages> <year> 1995. </year>
Reference-contexts: In [PD96], the authors use a method called aggregation on a distributed shared memory coherence protocol used in an experimental multiprocessor, to arrive at a simplified model of system behavior. Their technique involves manually assisted theorem proving. The work in <ref> [HMTLB95] </ref> as well as [DPN93] are aimed at verifying that synchronization routines work correctly under various memory models, where the memory models themselves are described using finite-state operational models. In [GK97, GK94], the authors study the problem of deciding whether a given set of traces are sequentially consistent.
Reference: [Lam93] <author> Leslie Lamport. </author> <title> How to make a correct multiprocess program execute correctly on a multiprocessor. </title> <type> Technical report, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: The processors and the memory have to synchronize on these read and write events. The serial memory protocol for n processors and a memory is shown in Figure 5. A sequentially consistent memory system <ref> [Lam93] </ref> requires that there be a single self-consistent trace t of memory operations that when projected onto the memory operations of each individual processor P i (R i (a; d) and W i (a; d) for processor i) is according to program order for P i .
Reference: [Lam94] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year> <note> Also appeared as SRC Research Report 79. </note>
Reference-contexts: Even approaches based on conventional model-checking are impossibly difficult to use in practice. For example, the assertions pertaining to the sequential consistency of lazy caching [Ger95], a simple memory system, expressed in various temporal logics (by [Gra94] in 8CTL fl [CES86] and [LLOR97] in TLA <ref> [Lam94] </ref>) are quite complex. In [Gra94], abstract interpretation [CC77] is employed to reduce infinite-system verification to finite 8CTL fl model-checking. They apply this technique to verify the sequential consistency of lazy caching with unbounded queues.
Reference: [LLOR97] <author> P. Ladkin, L. Lamport, B. Olivier, and D. Roegel. </author> <title> Lazy caching in tla. </title> <booktitle> Distributed Computing, </booktitle> <year> 1997. </year>
Reference-contexts: Even approaches based on conventional model-checking are impossibly difficult to use in practice. For example, the assertions pertaining to the sequential consistency of lazy caching [Ger95], a simple memory system, expressed in various temporal logics (by [Gra94] in 8CTL fl [CES86] and <ref> [LLOR97] </ref> in TLA [Lam94]) are quite complex. In [Gra94], abstract interpretation [CC77] is employed to reduce infinite-system verification to finite 8CTL fl model-checking. They apply this technique to verify the sequential consistency of lazy caching with unbounded queues.
Reference: [McM93] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1993. </year>
Reference-contexts: Our model includes a number of details such as split transactions, out of order transaction completions, and even an element of speculative execution. The errors we made in capturing these details could well have been made in an actual industrial context. In <ref> [McM93] </ref>, a CTL property that encodes a test for memory orderings has been discussed under the section heading `Sequential Consistency'. To give a historic perspective, the test model-checking idea originated in our attempt to answer the question of which memory ordering rule (s) the test of [McM93] is really verifying. <p> In <ref> [McM93] </ref>, a CTL property that encodes a test for memory orderings has been discussed under the section heading `Sequential Consistency'. To give a historic perspective, the test model-checking idea originated in our attempt to answer the question of which memory ordering rule (s) the test of [McM93] is really verifying. We still have not found a satisfactory answer because the test of [McM93] uses only one location which then couldn't make it a test for sequential consistency; it could plausibly be a test for coherence|which again does not correspond to what Collier formally proves in [Col92]. <p> To give a historic perspective, the test model-checking idea originated in our attempt to answer the question of which memory ordering rule (s) the test of <ref> [McM93] </ref> is really verifying. We still have not found a satisfactory answer because the test of [McM93] uses only one location which then couldn't make it a test for sequential consistency; it could plausibly be a test for coherence|which again does not correspond to what Collier formally proves in [Col92]. <p> In this context, our contribution has been to not only answer the above question (see Figure 1 which captures the test of <ref> [McM93] </ref>), but also to describe formally the finite-state abstractions that justify porting other tests from [Col92] to a model-checking framework. In [PD96], the authors use a method called aggregation on a distributed shared memory coherence protocol used in an experimental multiprocessor, to arrive at a simplified model of system behavior.
Reference: [Mok] <author> A. Mokkedem. </author> <title> Verification of three memory systems using test model-checking. </title> <address> http://www.cs.utah.edu/~mokkedem/vis/vis.html. </address>
Reference-contexts: We will describe the Runway model along with some of the subtle bugs that we could detect using test model-checking in greater detail. The verification results are summarized in figure 6. Details of all our experiments can be obtained from the Web <ref> [Mok] </ref> or by contacting the authors. Serial memory and sequential consistency In a serial memory the interface of the memory comprises read and writes events (R i (a; d), W i (a; d)) for each processor P i . <p> We did not try to model each of these features in their full glory, but we did include a modicum of these aggressive features into our VIS model, which in fact occupies more than 2,000 lines of VIS Verilog code (see <ref> [Mok] </ref>). For instance all essential features of (a), (b), (c), and (e) are included, (f) is abstracted by using nondeterminism. (d) is abstracted as explained below. Abstraction of Queues Additional abstraction effort was necessary to make our model digestible by VIS.
Reference: [NGMG98] <author> R. Nalumasu, R. Ghughal, A. Mokkedem, and G. Gopalakrishnan. </author> <title> The `test model-checking' approach to the verification of formal memory models of multiprocessors. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Utah, </institution> <address> Salt Lake City, UT 84112-9205, </address> <month> January </month> <year> 1998. </year> <note> also available in http://www.cs.utah.edu/~mokkedem/vis/paper.html. </note>
Reference: [PD96] <author> Seungjoon Park and David L. Dill. </author> <title> Verification of FLASH cache coherence protocol by aggregation of distributed transactions. </title> <booktitle> In SPAA, </booktitle> <pages> pages 288-296, </pages> <address> Padua, Italy, </address> <month> June 24-26, </month> <year> 1996. </year>
Reference-contexts: Being based on Archtest, test model-checking is also incomplete. However, none of the (presumed) complete alternatives to date have been shown to be practical for verifying large designs. For example <ref> [PD96] </ref> involves the use of manually guided mechanical theorem proving. Even approaches based on conventional model-checking are impossibly difficult to use in practice. <p> In this context, our contribution has been to not only answer the above question (see Figure 1 which captures the test of [McM93]), but also to describe formally the finite-state abstractions that justify porting other tests from [Col92] to a model-checking framework. In <ref> [PD96] </ref>, the authors use a method called aggregation on a distributed shared memory coherence protocol used in an experimental multiprocessor, to arrive at a simplified model of system behavior. Their technique involves manually assisted theorem proving.
Reference: [Ver] <author> Vis-1.2 release. </author> <note> http://www-cad.eecs.berkeley.edu/Respep/Research/vis/index.html. 12 </note>
Reference-contexts: PARI guarantees that if a client has c2cw transaction then it gets the highest priority to go to the Runway. 4 Verification using Test Model-checking To demonstrate the effectiveness of our approach, we verified three different memory systems, namely serial memory, lazy caching, and Runway-PA8000, all using VIS <ref> [Ver] </ref>. Since this paper is mainly devoted to describing Runway-PA8000, we will only briefly discuss serial memory and lazy caching. We will describe the Runway model along with some of the subtle bugs that we could detect using test model-checking in greater detail.
References-found: 24

