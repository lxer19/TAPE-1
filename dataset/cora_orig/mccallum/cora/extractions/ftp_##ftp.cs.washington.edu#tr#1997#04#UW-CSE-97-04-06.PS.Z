URL: ftp://ftp.cs.washington.edu/tr/1997/04/UW-CSE-97-04-06.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: An Empirical Analysis of C Preprocessor Use  
Author: Michael Ernst Greg J. Badros David Notkin 
Abstract: Technical Report UW-CSE-97-04-06 Department of Computer Science and Engineering University of Washington Box 352350, Seattle, WA 98195-2350 USA fmernst,gjb,notking@cs.washington.edu 22 April 1997 Abstract The C programming language is intimately connected to its macro preprocessor. This relationship affects, indeed generally hinders, both the tools (compilers, debuggers, call graph extractors, etc.) built to engineer C programs and also the ease of translating to other languages such as C++. This paper analyzes 27 packages comprising 1.2 million lines of publicly available C code, determining how the preprocessor is used in practice. We developed a framework for analyzing preprocessor usage and used it to extract information about the incidence of preprocessor directives, the frequency of macro use and redefinition, the purposes of macros (in terms of both definitions and uses), and expressibility of macros in terms of other C or C++ language features. We particularly note data that are material to the development of tools for C or C++, including translating from C to C++ to reduce preprocessor usage. The results are of interest to language designers, tool writers, programmers, and software engineers.
Abstract-found: 1
Intro-found: 1
Reference: [CE95] <author> Martin D. Carroll and Margaret A. Ellis. </author> <title> Designing and Coding Reusable C++. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: However, we did find guidance on using C macros effectively and tools for checking macro usage. Carroll and Ellis state that "almost all uses of macros can be eliminated from C++ libraries" <ref> [CE95, p. 146] </ref>. They list eight categories of macro usage and explain how to convert them into C++ mechanisms. They do not discuss automatic conversion, but focus on instructing the software engineer on better ways to do Cpp-like things.
Reference: [EGHT94] <author> David Evans, John Guttag, Jim Horning, and Yang Meng Tan. LCLint: </author> <title> A tool for using specifications to check code. </title> <booktitle> In Proceedings of SIGSOFT '94 Second ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 87-96, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: The implementation of lint is complicated by the fact that it tries to replicate significant functions of both the C compiler and the preprocessor. LCLint performs many of lint's checks and also allows the programmer to add annotations which enable additional checks <ref> [Eva96b, EGHT94] </ref>. LCLint optionally checks function-like macros | that is, those which take arguments | for macro arguments on the left hand side of assignments, for 17 statements playing the role of expressions, and for consistent return types.
Reference: [Eva96a] <author> David Evans. </author> <note> LCLint User's Guide, version 2.2 edition, August 1996. http://larch-www.lcs.mit.edu:8001/larch/lclint/guide/guide.html. </note>
Reference-contexts: The latter are often used to create a block and perform actions that must occur at its beginning and end, as for BEGIN_GC_PROTECT and END_GC_PROTECT. 2 By contrast, LCLint considers assignment to a macro argument dangerous but does not appear to check for assignments to local variables. <ref> [Eva96a] </ref> 3 Since the body is already a complete statement, the extra semicolon can cause problems such as mis-parsing of nested if statements.
Reference: [Eva96b] <author> David Evans. </author> <title> Static detection of dynamic memory errors. </title> <booktitle> In ACM SIGPLAN '96: Programming Language Design and Implementation, </booktitle> <pages> pages 44-53, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: The implementation of lint is complicated by the fact that it tries to replicate significant functions of both the C compiler and the preprocessor. LCLint performs many of lint's checks and also allows the programmer to add annotations which enable additional checks <ref> [Eva96b, EGHT94] </ref>. LCLint optionally checks function-like macros | that is, those which take arguments | for macro arguments on the left hand side of assignments, for 17 statements playing the role of expressions, and for consistent return types.
Reference: [HS95] <author> Samuel P. Harbison and Guy L. Steele Jr. </author> <title> C: A Reference Manual. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <note> fourth edition, </note> <year> 1995. </year>
Reference-contexts: 1 Introduction The C programming language [KR88] is intimately connected to its macro preprocessor, Cpp <ref> [HS95, Ch. 3] </ref>. C is incomplete without the preprocessor, which supplies essential facilities such as file inclusion, definition of constants and macros, and conditional compilation.
Reference: [KR88] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <note> second edition, </note> <year> 1988. </year>
Reference-contexts: 1 Introduction The C programming language <ref> [KR88] </ref> is intimately connected to its macro preprocessor, Cpp [HS95, Ch. 3]. C is incomplete without the preprocessor, which supplies essential facilities such as file inclusion, definition of constants and macros, and conditional compilation.
Reference: [KS94] <author> Maren Krone and Gregor Snelting. </author> <title> On the inference of configuration structures from source code. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 49-57. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: Four packages | bison, gnuchess, remind, and workman | had no macro classification failures. These packages contain 93, 297, 932, and 58 macro definitions, respectively. 83% of macros are expressions | mostly constants; further analysis of the conditional compilation structure (in the style of Krone and Snelting <ref> [KS94] </ref>) and of the macros with free variables (essentially achieving dynamic scoping) is needed to see which of the roughly 33% of expression macros should be easy to convert to C++ language features such as constants or enumerated values. <p> We are more interested in analyzing, describing, and automatically removing such uses so that tools can better process existing code without requiring human interaction or producing misleading results. Krone and Snelting use mathematical concept analysis to determine the conditional compilation structure of code <ref> [KS94] </ref>. They determine, for each line, which preprocessor macros it depends upon, and display that information in a lattice. They do not determine how macros depend upon one another directly, only by their nesting in #if, and the information conveyed is about the program as a whole.
Reference: [MNL96] <author> Gail C. Murphy, David Notkin, and E. </author> <title> Lan. An empirical study of static call graph extractors. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <pages> pages 90-99, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: As yet another related example, call graph extractors generally work in terms of the post-processed code, even when a human is the intended consumer of the call graph <ref> [MNL96] </ref>. Some tools even leave the software engineer responsible for inferring the mapping between the original and the post-processed source, which is an undesirable and error-prone situation.
Reference: [OJ97] <author> Robert O'Callahan and Daniel Jackson. Lackwit: </author> <title> A program understanding tool based on type inference. </title> <booktitle> In Proceedings of the 1997 International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: On the other hand, the analysis also convinces us that, by extending our analysis framework with some class type inferencing techniques (similar to those used by Siff and Reps for C to C++ translation [SR96], O'Callahan 2 and Jackson for program understanding <ref> [OJ97] </ref>, and others), we can take significant steps towards a tool that usefully converts a high percentage of Cpp code into C++ language features. 1 We are interested not in translations that merely allow a C program to be compiled by a C++ compiler (which is usually easy, by intentional design
Reference: [SR96] <author> Michael Siff and Thomas Reps. </author> <title> Program generalization for software reuse: From C to C++. </title> <booktitle> In Proceedings of SIGSOFT '96 Fourth ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 135-146, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: On the other hand, the analysis also convinces us that, by extending our analysis framework with some class type inferencing techniques (similar to those used by Siff and Reps for C to C++ translation <ref> [SR96] </ref>, O'Callahan 2 and Jackson for program understanding [OJ97], and others), we can take significant steps towards a tool that usefully converts a high percentage of Cpp code into C++ language features. 1 We are interested not in translations that merely allow a C program to be compiled by a C++ <p> As another example, Siff and Reps describe a technique that uses type inferencing to produce C++ function templates from C; however, the input is "a C program component that : : : has been preprocessed so that all include files are incorporated and all macros expanded <ref> [SR96, p. 145] </ref>." Such preprocessing may limit the readability and reusability of the resulting C++ templates. As yet another related example, call graph extractors generally work in terms of the post-processed code, even when a human is the intended consumer of the call graph [MNL96].
Reference: [Str94] <author> Bjarne Stroustrup. </author> <title> The Design and Evolution of C++. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: The designer of C++, which shares C's preprocessor, also noted these problems: "Occasionally, even the most extreme uses of Cpp are useful, but its facilities are so unstructured and intrusive that they are a constant problem to programmers, maintainers, people porting code, and tool builders." <ref> [Str94, p. 424] </ref> fl Supported by a National Science Foundation Graduate Fellowship. <p> However, the only realistic and responsible way of doing that is first to make it redundant, then encourage people to use the better alternatives, and then | years later | banish Cpp into the program development environment with the other extra-linguistic tools where it belongs <ref> [Str94, p. 426] </ref>. C++ contains features | such as constant variables, inline functions, templates, and reference parameters | that obviate many uses of Cpp. Thus, translation to C++ is a path for partial elimination of Cpp.
Reference: [WC93] <author> Daniel Weise and Roger Crew. </author> <title> Programmable syntax macros. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 156-165, </pages> <address> Albuquerque, NM, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: An alternative approach which avoids the clumsiness of a separate language of limited express-ibility is to make the macro language more powerful | perhaps even using the language itself via constructs evaluated at compile time rather than run time. (The macro systems of Common Lisp and Scheme, and their descendants <ref> [WC93] </ref> take this approach.) An extreme example would be to provide a full-fledged reflection capability. Such an approach is highly general, powerful, and and theoretically clean; it circumvents many of the limitations of Cpp.
Reference: [Zel83] <author> Polle T. Zellweger. </author> <title> An interactive high-level debugger for control-flow optimized programs. </title> <type> Tech--nical Report CSL-83-1, </type> <institution> Xerox Palo Alto Research Center, Palo Alto, California, </institution> <month> January </month> <year> 1983. </year> <month> 19 </month>
Reference-contexts: For instance, source-level debuggers have no symbolic names or types for constants and functions introduced via #define, nor can tools trace or set breakpoints in function macros, as they can for ordinary functions (even those that have been inlined <ref> [Zel83] </ref>).
References-found: 13

