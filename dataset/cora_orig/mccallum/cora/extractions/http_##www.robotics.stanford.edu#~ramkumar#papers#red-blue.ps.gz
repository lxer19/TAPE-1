URL: http://www.robotics.stanford.edu/~ramkumar/papers/red-blue.ps.gz
Refering-URL: http://www.robotics.stanford.edu/~ramkumar/publications.html
Root-URL: http://www.robotics.stanford.edu
Email: e-mail:  
Title: Sets Of Connected Line Segments  
Author: Julien Basch, Leonidas J. Guibas, and G. D. Ramkumar 
Web: fjbasch, guibas, ramg cs.stanford.edu  
Address: Stanford, CA 94305, USA  
Affiliation: Department of Computer Science Stanford University  
Note: Two  
Abstract: Reporting Red-Blue Intersections Between Abstract. We present a new line sweep algorithm, HeapSweep, for reporting bichromatic (`purple') intersections between a red and a blue family of line segments. If the union of the segments in each family is connected as a point set, HeapSweep reports all k purple intersections in time O((n + k)ff(n) log 3 n), where n is the total number of input segments and ff(n) is the familiar inverse Ackermann function. To achieve these bounds, the algorithm keeps only partial information about the vertical ordering between segments of the same color, using a new data structure called a kinetic queue. In order to analyze the running time of HeapSweep, we also show that a simple polygon containing a set of n line segments can be partitioned into monotone regions by lines cutting these segments fi(n log n) times.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> P. K. Agarwal. </author> <title> Partitioning arrangements of lines: II. </title> <journal> Applications. Discrete Comput. Geom., </journal> <volume> 5 </volume> <pages> 533-573, </pages> <year> 1990. </year>
Reference-contexts: For this latter problem, Guibas, Overmars, and Sharir [20] gave a randomized O (n 4=3+* + k) solution using partitioning techniques (what has since become known as cuttings; de-randomization tools developed later can also be applied). Agarwal <ref> [1] </ref> adapted this technique to the red-blue version of the problem, lowering the running time to O (n 4=3 log n + k) for reporting and obtained a method for counting in time O (n 4=3 log n) as well, at the cost of increasing the space requirement to fi (n <p> Some of the algorithms described above are essentially combinatorial [7, 22, 3, 12], and work as well if the line segments are replaced by x-monotone algebraic arcs of bounded degree. Others <ref> [9, 11, 1] </ref> make a more essential use of the affine structure of the input and cannot be so adapted. <p> The spurious intersections generated by the spanning trees cause a total running time of O ((n r p p k)ff (n) log 3 n). General case in linear space. In order to solve the general red-blue inter-section problem in linear space, the cuttings technique <ref> [20, 1] </ref> can be applied, but the running time becomes O (n 4=3+* + k). The * term can be made as small as desired, but at the cost of a increased hidden constant in the space bounds.
Reference: 2. <author> P. K. Agarwal, M. de Berg, J. Matousek, and O. Schwarzkopf. </author> <title> Constructing levels in arrangements and higher order Voronoi diagrams. </title> <booktitle> In Proc. 10th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 67-75, </pages> <year> 1994. </year>
Reference-contexts: on S 0 is a uniform random variable on all permutations of S 0 , and thus the probability that s i ; s j are parent and child is 2=(ffi S (v) + 2): ut Levels in arrangements of lines and segments are a well-studied topic in computational geometry <ref> [2, 25] </ref>. Although estimating the exact number of vertices at level ` has proven difficult, a simple bound on the number of vertices of level at most ` can be obtained using standard random sampling techniques [12]. Lemma 4.4. Let S be a set of s segments in the plane.
Reference: 3. <author> P. K. Agarwal and M. Sharir. </author> <title> Red-blue intersection detection algorithms, with applications to motion planning and collision detection. </title> <booktitle> In Proc. 4th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 70-80, </pages> <year> 1988. </year>
Reference-contexts: This condition often pertains in situations where the purple intersection problem itself arises (e.g., in the overlay of line arrangements, or of simply-connected planar subdivisions though in the latter case the disjoint methods above apply). Under the hypothesis of connectedness, Agarwal and Sharir <ref> [3] </ref> looked at the problem of detecting a single purple intersection. <p> Using the recent randomized algorithm of Chazelle et al. [11] to compute a single-face, a purple intersection is detected in time O (nff (n) log n), where ff (n) is the slowly growing inverse of Ackermann's function. Some of the algorithms described above are essentially combinatorial <ref> [7, 22, 3, 12] </ref>, and work as well if the line segments are replaced by x-monotone algebraic arcs of bounded degree. Others [9, 11, 1] make a more essential use of the affine structure of the input and cannot be so adapted. <p> Using HeapSweep, we obtain a O ((n 4=3 + k)ff (n) log 3 n) algorithm to report all intersections in the general case, with a linear space cost that has a small implied constant. This can be done by preprocessing the input to identify connected subsets of segments (see <ref> [20, 3] </ref>), on which it is then possible to use the variation of HeapSweep for known components mentioned above. Details are omitted in this paper. j-level.
Reference: 4. <author> C. Aragon and R. Seidel. </author> <title> Randomized search trees. </title> <booktitle> In Proc. 30th Annu. IEEE Sympos. Found. Comput. Sci., </booktitle> <pages> pages 540-545, </pages> <year> 1989. </year>
Reference-contexts: If each object in a set is given two numbers, a rank and a priority, there is a unique binary tree which is both a search tree on the ranks and a heap on the priorities. Such a tree is well-known and called a treap - Aragon and Seidel <ref> [4] </ref> used it to create their popular randomized search tree data structure, which is a treap on objects with a given rank and a randomly assigned priority. The randomization guarantees that this structure is balanced with high probability. <p> Then E [D x (H)] = O (log jSj). The expected cost of an insertion or a deletion in H at any time is O (t Q log jSj) Proof. This result is an immediate consequence of the original analysis of treaps by Aragon and Seidel <ref> [4] </ref>, once we notice that uniformly random ranks on elements of preassigned priorities defines the same distribution on the space where the ranks are fixed and the priorities are random. An insertion of an element in the heater thus causes an expected O (log jSj) rotations.
Reference: 5. <author> J. Basch, L. J. Guibas, and J. Hershberger. </author> <title> Data structures for mobile data. </title> <note> In preparation. </note>
Reference-contexts: To achieve these bounds, we revisit the line sweep paradigm and relax the requirement that the segments be completely ordered along the sweep line. The algorithm uses a new data structure called a kinetic queue <ref> [5] </ref>, for which we describe both a randomized (a heater) and a deterministic implementation (a kinetic tournament). The analysis of HeapSweep requires a combinatorial lemma on the monotone decomposition of a polygon containing line segments, as was briefly mentioned in the abstract. <p> Hence, the number of internal events is exactly equal to the running time of the divide and conquer algorithm, which is well known to be O (sff (s) log s) [21]. This type of analysis will be elaborated upon in <ref> [5] </ref>. The tournament tree can be made dynamic as follows. Imagine a very large sequence of leaves and a perfectly balanced prototypical tournament tree built upon that sequence.
Reference: 6. <author> J. Basch, L.J. Guibas, G.D. Ramkumar, and L. Ramshaw. </author> <title> Polyhedral tracings and their convolution. </title> <booktitle> In Proc. 2nd Workshop on Algorithmic Fundations of Robotics, </booktitle> <year> 1996. </year>
Reference-contexts: t Q mentioned above, this implies the desired bound on the running time of HeapSweep, which is randomized or deterministic depending on the specific kinetic queue implementation. ut 5 Applications and Related Results The algorithm HeapSweep was developed in the context of a theory of polyhedral tracings and their convolution <ref> [6] </ref>. In a few words, one obtains the convolution of two polyhedra (a red and a blue) by first computing their geometric duals, projecting these duals on the unit sphere, and then computing all pairs of red-blue intersecting features.
Reference: 7. <author> J. L. Bentley and T. A. Ottmann. </author> <title> Algorithms for reporting and counting geometric intersections. </title> <journal> IEEE Trans. Comput., </journal> <volume> C-28:643-647, </volume> <year> 1979. </year>
Reference-contexts: In what follows, we denote by n the number of (red and blue) input segments, and by k the number of purple intersections. The case where each input set is disjoint has been extensively studied. In the early days of computational geometry, Bentley and Ottmann <ref> [7] </ref> introduced their well-known line sweep algorithm, which reports all purple intersections in time O ((n + k) log n). Mairson and Stolfi [22] were the first to find an asymptotically optimal algorithm running in O (n log n+k) time. <p> Using the recent randomized algorithm of Chazelle et al. [11] to compute a single-face, a purple intersection is detected in time O (nff (n) log n), where ff (n) is the slowly growing inverse of Ackermann's function. Some of the algorithms described above are essentially combinatorial <ref> [7, 22, 3, 12] </ref>, and work as well if the line segments are replaced by x-monotone algebraic arcs of bounded degree. Others [9, 11, 1] make a more essential use of the affine structure of the input and cannot be so adapted.
Reference: 8. <author> B. Chazelle. </author> <title> Filtering search: a new approach to query-answering. </title> <journal> SIAM J. Comput., </journal> <volume> 15 </volume> <pages> 703-724, </pages> <year> 1986. </year>
Reference-contexts: The bounds we obtained also give hope that a filtering search technique <ref> [8] </ref> coupled with geometric partitioning could achieve an optimal O (n log n + k) running time (in a sense, HeapSweep is an instance of filtering search, as it detects more intersections than necessary but not too many more).
Reference: 9. <author> B. Chazelle and H. Edelsbrunner. </author> <title> An optimal algorithm for intersecting line segments in the plane. </title> <journal> J. ACM, </journal> <volume> 39 </volume> <pages> 1-54, </pages> <year> 1992. </year>
Reference-contexts: The same optimal time bound for reporting purple intersections was achieved later by several different methods <ref> [9, 10, 12, 27] </ref>. Especially worthy of mention among these is the hereditary segment tree data structure of Chazelle, Edelsbrunner, Guibas, and Sharir [10], which can also be used to count all purple intersections in O (n log n) time. <p> Some of the algorithms described above are essentially combinatorial [7, 22, 3, 12], and work as well if the line segments are replaced by x-monotone algebraic arcs of bounded degree. Others <ref> [9, 11, 1] </ref> make a more essential use of the affine structure of the input and cannot be so adapted.
Reference: 10. <author> B. Chazelle, H. Edelsbrunner, L. Guibas, and M. Sharir. </author> <title> Algorithms for bichro-matic line segment problems and polyhedral terrains. </title> <journal> Algorithmica, </journal> <volume> 11 </volume> <pages> 116-132, </pages> <year> 1994. </year>
Reference-contexts: The same optimal time bound for reporting purple intersections was achieved later by several different methods <ref> [9, 10, 12, 27] </ref>. Especially worthy of mention among these is the hereditary segment tree data structure of Chazelle, Edelsbrunner, Guibas, and Sharir [10], which can also be used to count all purple intersections in O (n log n) time. <p> The same optimal time bound for reporting purple intersections was achieved later by several different methods [9, 10, 12, 27]. Especially worthy of mention among these is the hereditary segment tree data structure of Chazelle, Edelsbrunner, Guibas, and Sharir <ref> [10] </ref>, which can also be used to count all purple intersections in O (n log n) time. Thus, in the disjoint case, asymptotically optimal and practical algorithms are known. <p> There doesn't seem to be any hope of adapting HeapSweep to solve the counting problem efficiently. The hereditary segment-tree approach <ref> [10] </ref> used to obtain an optimal algorithm for counting purple intersections in the disjoint case cannot be adapted either, since segment tree nodes may have a disconnected set of segments.
Reference: 11. <author> B. Chazelle, H. Edelsbrunner, L. Guibas, M. Sharir, and J. Snoeyink. </author> <title> Computing a face in an arrangement of line segments and related problems. </title> <journal> SIAM J. Comput., </journal> <volume> 22 </volume> <pages> 1286-1302, </pages> <year> 1993. </year>
Reference-contexts: If the blue and red segment sets are connected, the set of purple intersections is non-empty iff the boundaries of F and F 0 intersect, and this can be tested via a Bentley-Ottmann sweep. Using the recent randomized algorithm of Chazelle et al. <ref> [11] </ref> to compute a single-face, a purple intersection is detected in time O (nff (n) log n), where ff (n) is the slowly growing inverse of Ackermann's function. <p> Some of the algorithms described above are essentially combinatorial [7, 22, 3, 12], and work as well if the line segments are replaced by x-monotone algebraic arcs of bounded degree. Others <ref> [9, 11, 1] </ref> make a more essential use of the affine structure of the input and cannot be so adapted.
Reference: 12. <author> K. L. Clarkson and P. W. Shor. </author> <title> Applications of random sampling in computational geometry, II. </title> <journal> Discrete Comput. Geom., </journal> <volume> 4 </volume> <pages> 387-421, </pages> <year> 1989. </year>
Reference-contexts: The same optimal time bound for reporting purple intersections was achieved later by several different methods <ref> [9, 10, 12, 27] </ref>. Especially worthy of mention among these is the hereditary segment tree data structure of Chazelle, Edelsbrunner, Guibas, and Sharir [10], which can also be used to count all purple intersections in O (n log n) time. <p> Using the recent randomized algorithm of Chazelle et al. [11] to compute a single-face, a purple intersection is detected in time O (nff (n) log n), where ff (n) is the slowly growing inverse of Ackermann's function. Some of the algorithms described above are essentially combinatorial <ref> [7, 22, 3, 12] </ref>, and work as well if the line segments are replaced by x-monotone algebraic arcs of bounded degree. Others [9, 11, 1] make a more essential use of the affine structure of the input and cannot be so adapted. <p> The analysis proceeds as follows. We first observe that the probability of a given intersection to cause an update in the heater is related only to its level (defined below). We then perform a standard computation a la Clarkson-Shor <ref> [12] </ref>, based on the well known combinatorial result bounding the complexity of the upper envelope of a set of line segments. Definition 4.2 (Level in an arrangement). <p> Although estimating the exact number of vertices at level ` has proven difficult, a simple bound on the number of vertices of level at most ` can be obtained using standard random sampling techniques <ref> [12] </ref>. Lemma 4.4. Let S be a set of s segments in the plane. Denote by t ` the number of vertices that have level exactly `. Then: X t i (` + 1)sff (s) : Proof. This is a special case of Clarkson and Shor [12], Theorem 3.1. ut Lemma <p> standard random sampling techniques <ref> [12] </ref>. Lemma 4.4. Let S be a set of s segments in the plane. Denote by t ` the number of vertices that have level exactly `. Then: X t i (` + 1)sff (s) : Proof. This is a special case of Clarkson and Shor [12], Theorem 3.1. ut Lemma 4.5. Let H be a heater sweeping over s segments in the plane. Denote by C (H) the number of intersections that cause an update of H. Then E [C (H)] = O (sff (s) log s).
Reference: 13. <author> R. Cole, M. Sharir, and C. K. Yap. </author> <title> On k-hulls and related problems. </title> <journal> SIAM J. Comput., </journal> <volume> 16 </volume> <pages> 61-77, </pages> <year> 1987. </year>
Reference-contexts: This generalizes the results of Edelsbrunner and Welzl [18], who computed the j-level of an arrangement of line segments in O ((n + k) log 2 n) time using a line sweep technique that can be retroactively be seen as a precursor of HeapSweep. Cole, Sharir, and Yap <ref> [13] </ref> improved these bounds to O ((n + k) log 2 j). Both methods mentioned above use the data structure of Overmars and van Leeuven [26] for dynamic maintenance of a convex hull with insertions and deletion cost of O (log 2 n) per operation. <p> We also wish to thank an anonymous referee for pointing out the reference <ref> [13] </ref>. Leonidas Guibas wishes to acknowledge support by NSF Grant CCR-9215219 and US Army Grant 5-23542A during this research.
Reference: 14. <author> M. de Berg. </author> <type> Personal communication. </type> <year> 1996. </year>
Reference-contexts: Mark de Berg pointed out that this data structure can also be used in HeapSweep, in replacement of the kinetic queue, giving an improved O ((n + k) log 3 n) algorithm for reporting all k purple intersections between n red and blue line segments <ref> [14] </ref>. Kinetic heaps. We mentioned earlier that the most straightforward idea for implementing a kinetic queue is to use a standard binary heap.
Reference: 15. <author> M. de Berg and O. Schwarzkopf. </author> <title> Cuttings and applications. </title> <type> Report RUU-CS-92-26, </type> <institution> Dept. Comput. Sci., Utrecht Univ., </institution> <address> Utrecht, Netherlands, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: in these time bounds is unlikely, as the general case falls within a class of problems at least as hard as Hopcroft's problem of detecting an incidence between a set of n points and a set of n lines; the fastest known algorithm for Hopcroft's problem is due to Matousek <ref> [15, 24] </ref>, and runs in O (n 4=3 2 O (log fl n) ) time. For a certain general class of algorithms, a lower bound of (n 4=3 ) for this problem was recently given by Erickson [19].
Reference: 16. <author> H. Edelsbrunner and L. J. Guibas. </author> <title> Topologically sweeping an arrangement. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 38 </volume> <pages> 165-194, </pages> <year> 1989. </year> <note> Corrigendum in 42 (1991), 249-251. </note>
Reference-contexts: In order to reduce this overhead, we would like to see an integration of our technique (that relaxes the vertical ordering of the sweep line) with the methods of Edelsbrunner and Guibas <ref> [16] </ref> or Mairson and Stolfi [22] (that relax the horizontal ordering of the sweep).
Reference: 17. <author> H. Edelsbrunner and E. P. Mucke. </author> <title> Simulation of simplicity: a technique to cope with degenerate cases in geometric algorithms. </title> <journal> ACM Trans. Graph., </journal> <volume> 9 </volume> <pages> 66-104, </pages> <year> 1990. </year>
Reference-contexts: Standard perturbation techniques can be used to guarantee that this is always the case <ref> [17] </ref>. In the traditional Bentley-Ottmann line sweep, a balanced search tree is used to represent the state of the sweep line. This search tree stores the exact top-to-bottom ordering of the line segments intersecting the sweep line.
Reference: 18. <author> H. Edelsbrunner and E. Welzl. </author> <title> Constructing belts in two-dimensional arrangements with applications. </title> <journal> SIAM J. Comput., </journal> <volume> 15 </volume> <pages> 271-284, </pages> <year> 1986. </year>
Reference-contexts: This generalizes the results of Edelsbrunner and Welzl <ref> [18] </ref>, who computed the j-level of an arrangement of line segments in O ((n + k) log 2 n) time using a line sweep technique that can be retroactively be seen as a precursor of HeapSweep.
Reference: 19. <author> J. Erickson. </author> <title> New lower bounds for Hopcroft's problem. </title> <booktitle> In Proc. 11th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pages 127-137, </pages> <year> 1995. </year>
Reference-contexts: For a certain general class of algorithms, a lower bound of (n 4=3 ) for this problem was recently given by Erickson <ref> [19] </ref>. Given this situation, we were motivated to seek additional conditions which make easier the task of reporting the purple intersections. A natural condition is that of connectedness for each of the monochromatic inputs, as introduced above.
Reference: 20. <author> L. Guibas, M. Overmars, and M. Sharir. </author> <title> Intersecting line segments, ray shooting, and other applications of geometric partitioning techniques. </title> <booktitle> In Proc. 1st Scand. Workshop Algorithm Theory, volume 318 of Lecture Notes in Computer Science, </booktitle> <pages> pages 64-73. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: For certain inputs k 0 can be (n 2 ), while the desired output can be much smaller. This version of the problem seems to be of about the same difficulty as reporting all segment intersections in a given family. For this latter problem, Guibas, Overmars, and Sharir <ref> [20] </ref> gave a randomized O (n 4=3+* + k) solution using partitioning techniques (what has since become known as cuttings; de-randomization tools developed later can also be applied). <p> The spurious intersections generated by the spanning trees cause a total running time of O ((n r p p k)ff (n) log 3 n). General case in linear space. In order to solve the general red-blue inter-section problem in linear space, the cuttings technique <ref> [20, 1] </ref> can be applied, but the running time becomes O (n 4=3+* + k). The * term can be made as small as desired, but at the cost of a increased hidden constant in the space bounds. <p> Using HeapSweep, we obtain a O ((n 4=3 + k)ff (n) log 3 n) algorithm to report all intersections in the general case, with a linear space cost that has a small implied constant. This can be done by preprocessing the input to identify connected subsets of segments (see <ref> [20, 3] </ref>), on which it is then possible to use the variation of HeapSweep for known components mentioned above. Details are omitted in this paper. j-level.
Reference: 21. <author> S. Hart and M. Sharir. </author> <title> Nonlinearity of Davenport-Schinzel sequences and of generalized path compression schemes. </title> <journal> Combinatorica, </journal> <volume> 6 </volume> <pages> 151-177, </pages> <year> 1986. </year>
Reference-contexts: Hence, the number of internal events is exactly equal to the running time of the divide and conquer algorithm, which is well known to be O (sff (s) log s) <ref> [21] </ref>. This type of analysis will be elaborated upon in [5]. The tournament tree can be made dynamic as follows. Imagine a very large sequence of leaves and a perfectly balanced prototypical tournament tree built upon that sequence.
Reference: 22. <author> H. G. Mairson and J. Stolfi. </author> <title> Reporting and counting intersections between two sets of line segments. </title> <editor> In R. A. Earnshaw, editor, </editor> <booktitle> Theoretical Foundations of Computer Graphics and CAD, volume F40 of NATO ASI, </booktitle> <pages> pages 307-325. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, West Germany, </address> <year> 1988. </year>
Reference-contexts: The case where each input set is disjoint has been extensively studied. In the early days of computational geometry, Bentley and Ottmann [7] introduced their well-known line sweep algorithm, which reports all purple intersections in time O ((n + k) log n). Mairson and Stolfi <ref> [22] </ref> were the first to find an asymptotically optimal algorithm running in O (n log n+k) time. <p> Using the recent randomized algorithm of Chazelle et al. [11] to compute a single-face, a purple intersection is detected in time O (nff (n) log n), where ff (n) is the slowly growing inverse of Ackermann's function. Some of the algorithms described above are essentially combinatorial <ref> [7, 22, 3, 12] </ref>, and work as well if the line segments are replaced by x-monotone algebraic arcs of bounded degree. Others [9, 11, 1] make a more essential use of the affine structure of the input and cannot be so adapted. <p> In order to reduce this overhead, we would like to see an integration of our technique (that relaxes the vertical ordering of the sweep line) with the methods of Edelsbrunner and Guibas [16] or Mairson and Stolfi <ref> [22] </ref> (that relax the horizontal ordering of the sweep).
Reference: 23. <author> J. Matousek. </author> <title> Spanning trees with low crossing number. </title> <journal> Informatique Theorique et Applications, </journal> <volume> 25(2) </volume> <pages> 103-123, </pages> <year> 1991. </year>
Reference-contexts: If one point from each component is given, it is possible to compute a low stabbing number spanning tree between these points <ref> [23] </ref>, and thus provide connected input to HeapSweep. The spurious intersections generated by the spanning trees cause a total running time of O ((n r p p k)ff (n) log 3 n). General case in linear space.
Reference: 24. <author> J. Matousek. </author> <title> Range searching with efficient hierarchical cuttings. </title> <journal> Discrete Comput. Geom., </journal> <volume> 10(2) </volume> <pages> 157-182, </pages> <year> 1993. </year>
Reference-contexts: in these time bounds is unlikely, as the general case falls within a class of problems at least as hard as Hopcroft's problem of detecting an incidence between a set of n points and a set of n lines; the fastest known algorithm for Hopcroft's problem is due to Matousek <ref> [15, 24] </ref>, and runs in O (n 4=3 2 O (log fl n) ) time. For a certain general class of algorithms, a lower bound of (n 4=3 ) for this problem was recently given by Erickson [19].
Reference: 25. <author> K. Mulmuley. </author> <title> On levels in arrangements and Voronoi diagrams. </title> <journal> Discrete Comput. Geom., </journal> <volume> 6 </volume> <pages> 307-338, </pages> <year> 1991. </year>
Reference-contexts: on S 0 is a uniform random variable on all permutations of S 0 , and thus the probability that s i ; s j are parent and child is 2=(ffi S (v) + 2): ut Levels in arrangements of lines and segments are a well-studied topic in computational geometry <ref> [2, 25] </ref>. Although estimating the exact number of vertices at level ` has proven difficult, a simple bound on the number of vertices of level at most ` can be obtained using standard random sampling techniques [12]. Lemma 4.4. Let S be a set of s segments in the plane.
Reference: 26. <author> M. H. Overmars and J. van Leeuwen. </author> <title> Maintenance of configurations in the plane. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 23 </volume> <pages> 166-204, </pages> <year> 1981. </year>
Reference-contexts: Cole, Sharir, and Yap [13] improved these bounds to O ((n + k) log 2 j). Both methods mentioned above use the data structure of Overmars and van Leeuven <ref> [26] </ref> for dynamic maintenance of a convex hull with insertions and deletion cost of O (log 2 n) per operation.
Reference: 27. <author> Larry Palazzi and Jack Snoeyink. </author> <title> Counting and reporting red/blue segment inter-sections. </title> <booktitle> In Proc. 3rd Workshop Algorithms Data Struct., volume 709 of Lecture Notes in Computer Science, </booktitle> <pages> pages 530-540, </pages> <year> 1993. </year>
Reference-contexts: The same optimal time bound for reporting purple intersections was achieved later by several different methods <ref> [9, 10, 12, 27] </ref>. Especially worthy of mention among these is the hereditary segment tree data structure of Chazelle, Edelsbrunner, Guibas, and Sharir [10], which can also be used to count all purple intersections in O (n log n) time.
Reference: 28. <author> M. Sharir and P. K. Agarwal. </author> <title> Davenport-Schinzel Sequences and Their Geometric Applications. </title> <publisher> Cambridge University Press, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: When considering x--monotone arcs such that any pair intersects at most s times, it is common to encounter the function s (n), which denotes the almost-linear maximum length of an (n; s) Davenport-Schinzel sequence; for more material on Davenport-Schinzel sequences the reader is referred to <ref> [28] </ref>. In this paper, we present a new line sweep algorithm called HeapSweep, that reports all the purple intersections between two sets of connected segments. This algorithm runs in time O ((n + k)ff (n) log 3 n).
References-found: 28

