URL: ftp://ftp.ifad.dk/pub/papers/fme971.ps.gz
Refering-URL: http://www.ifad.dk/publications/publications.html
Root-URL: 
Phone: 2  
Title: A Proof Obligation Generator for VDM-SL  
Author: Bernhard K. Aichernig and Peter Gorm Larsen 
Address: Munzgrabenstr. 11/II, 8010 Graz, Austria  Denmark  
Affiliation: 1 Graz University of Technology, Institute of Software Technology (IST),  Institute of Applied Computer Science (IFAD), Forskerparken 10, 5230 Odense M,  
Abstract: In this paper an extension of the IFAD VDM-SL Toolbox with a proof obligation generator is described. Static type checking in VDM is undecidable in general and therefore the type checker must be incomplete. Hence, for the "difficult" parts introducing undecidability, it is up to the user to verify the consistency of a specification. Instead of providing error messages and warnings, the approach of generating proof obligations for the consistency of VDM-SL specifications is taken. The overall goal of this work is to automate the generation of proof obligations for VDM-SL. Proof obligation generation has already been carried out for a number of related notations, but VDM-SL contains a number of challenging constructs (e.g. patterns, non-disjoint union types, and operations) for which new research is presented in this paper. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J.-R. </author> <title> Abrial. The B Book Assigning Programs to Meanings. </title> <publisher> Cambridge University Press, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: The TCCs relate to subtypes, partial operators and the termination of recursive functions. B-Method: The B-Toolkit [17] has a proof obligation generator, that can be invoked from the "Main Environment". The POs are generated according to the correctness criteria which are required to hold within the B-Method <ref> [1] </ref>. Thus, for example the criteria requires that an Abstract Machine initialisa-tion must establish the invariant, and that each operation re-establishes the invariant.
Reference: 2. <author> S. Agerholm and J. Frost. </author> <title> An Isabelle-based theorem prover for VDM-SL. </title> <booktitle> In Proceedings of the 10th International Conference on Theorem Proving in Higher Order Logics (TPHOLs'97), </booktitle> <publisher> LNCS. Springer-Verlag, </publisher> <month> August </month> <year> 1997. </year>
Reference-contexts: For a=b the condition for consistency is b 6= 0. If all POs generated for a specification can be proved, then the specification is consistent. Therefore, the POs are designed to be loaded into the proof tool of the Toolbox, which is currently under development at IFAD <ref> [3, 2] </ref>. However, many of the generated proof obligations are trivial or simple, and can be informally justified by simply inspecting the PO. The notion of POs for VDM has been based on previous work [21, 20, 6].
Reference: 3. <author> S. Agerholm and J. Frost. </author> <title> Towards an integrated CASE and theorem proving tool for VDM-SL. </title> <address> FME'97, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: For a=b the condition for consistency is b 6= 0. If all POs generated for a specification can be proved, then the specification is consistent. Therefore, the POs are designed to be loaded into the proof tool of the Toolbox, which is currently under development at IFAD <ref> [3, 2] </ref>. However, many of the generated proof obligations are trivial or simple, and can be informally justified by simply inspecting the PO. The notion of POs for VDM has been based on previous work [21, 20, 6].
Reference: 4. <author> Bernhard K. Aichernig. </author> <title> A Proof Obligation Generator for the IFAD VDM-SL Toolbox. </title> <type> Master's thesis, </type> <institution> Technical University Graz, Austria, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: In the following section this modification of the type checker is explained. 3 The Proof Obligation Generator The existing type checker specification document was extended with one extra module and the total size became approximately 300 pages <ref> [4] </ref>. The test cases and the test environment were naturally also adapted to take these changes into account. The central idea underlying the approach presented here (proposed in [10, 11]) is to extend type checking by generating proof obligations for the "difficult" parts which cause the undecidability. <p> From a tool point of view this work is an improvement of the existing VDM-SL Toolbox. For a more detailed presentation of this work we refer the reader to <ref> [4] </ref>. At present no work has been done on generating proof obligations for termination of recursive functions. This work could also be extended by a closer integration with the proof tool being developed.
Reference: 5. <author> K. Apt. </author> <title> Ten Years of Hoare's Logic: A survey Part I. </title> <journal> ACM-TOPLAS, </journal> <volume> 3(4) </volume> <pages> 431-483, </pages> <month> Oct </month> <year> 1981. </year>
Reference-contexts: Traditional proof systems for statements use a pre-post strategy where a pre-predicate describes what is supposed to hold before execution of a specific statement and a post-predicate describes what will hold after executing the statement <ref> [19, 5] </ref>. A few proof rules for VDM-SL statements, which are adapted for exception handling, can be found in [22]. Implicit operations can be treated as implicit functions, which means a sat-isfiability proof obligation is generated to ensure consistency.
Reference: 6. <author> Juan Bicarregui, John Fitzgerald, Peter Lindsay, Richard Moore, and Brian Ritchie. </author> <title> Proof in VDM: A Practitioner's Guide. </title> <publisher> FACIT. Springer-Verlag, </publisher> <year> 1994. </year> <note> ISBN 3-540-19813-X. </note>
Reference-contexts: However, many of the generated proof obligations are trivial or simple, and can be informally justified by simply inspecting the PO. The notion of POs for VDM has been based on previous work <ref> [21, 20, 6] </ref>. The main contribution of this work is the automation of the generation of POs. In addition, Sections 5 and 6 present new work in the areas of patterns and explicit operations where no existing research for POs was present. <p> The rule states that the conclusion holds whenever the hypotheses hold <ref> [6, 20] </ref>. The abstract syntax for a proof rule is: PrfRule :: hyp : Sequent fl con : AllExpr ; To be compatible with the proof theory a hypothesis is defined as a sequent P ` R.
Reference: 7. <author> Hans Bruun, Flemming Damm, and Bo Stig Hansen. </author> <title> An Approach to the Static Semantics of VDM-SL. In VDM '91: </title> <booktitle> Formal Software Development Methods, </booktitle> <pages> pages 220-253. </pages> <publisher> VDM Europe, Springer-Verlag, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: Thus, we are only able to show very small extracts from this specification here. 2.1 Rejection and Acceptance Type checking for VDM-SL is somewhat different from what is usually found in programming languages <ref> [7, 10] </ref>. According to the standard of VDM-SL [23] a dual strategy of type checking is applied: (1) Impossibly consistent specifications are rejected. For example, the type checker will raise an error message if a specification contains the expression 1 + true.
Reference: 8. <author> Bernard Carre, William Marsh, and Jon Garnsworthy. </author> <title> SPARK: A Safety-Related Ada Subset. </title> <booktitle> In Ada UK Conference, </booktitle> <pages> pages 1-19, </pages> <month> August 22 </month> <year> 1992. </year>
Reference-contexts: Our work covers a wider area, e.g. union types and patterns. Thus, domain checking is a subset of our consistency checks. SPARK: SPARK is an annotated subset of Ada, designed to eliminate ambiguities and insecurities of the full Ada language <ref> [8] </ref>. The SPARK Examiner, a tool which checks conformance of a program to the rules of SPARK, also generate POs called "verification conditions". Mandatory annotations in a program are used to generate these POs. However, SPARK does not allow exceptions and overloading and has simplified scope and visibility rules.
Reference: 9. <author> Dan Craigen, Sentot Kromodimoeljo, Irwin Meisels, Bill Pase, and Mark Saaltink. </author> <title> Eves: An overview. </title> <editor> In S. Prehn and W.J. Toetenel, editors, </editor> <booktitle> VDM'91 Formal Software Development Methods, </booktitle> <pages> pages 389-405. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: Thus, for example the criteria requires that an Abstract Machine initialisa-tion must establish the invariant, and that each operation re-establishes the invariant. Z/EVES: The Z/EVES system [28, 29], a Z front-end to the theorem prover EVES <ref> [9] </ref> provides domain checking for Z specifications, which is the generation of proof obligations to ensure that all functions and operators are applied with parameters inside their domain. The same is done in our work, but Z does not have a type system as rich as VDM [18].
Reference: 10. <author> Flemming Damm, Hans Bruun, and Bo Stig Hansen. </author> <title> On Type Checking in VDM and Related Consistency Issues. In VDM '91: </title> <booktitle> Formal Software Development Methods, </booktitle> <pages> pages 45-62. </pages> <publisher> VDM Europe, Springer-Verlag, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: Thus, we are only able to show very small extracts from this specification here. 2.1 Rejection and Acceptance Type checking for VDM-SL is somewhat different from what is usually found in programming languages <ref> [7, 10] </ref>. According to the standard of VDM-SL [23] a dual strategy of type checking is applied: (1) Impossibly consistent specifications are rejected. For example, the type checker will raise an error message if a specification contains the expression 1 + true. <p> Due to the rich type system of VDM-SL a simple comparison is not possible in general. Furthermore, the task is statically undecidable in general, because of non-disjoint unions and subtypes <ref> [10] </ref>. The operation 3 performing the compatibility check IsCompatible takes three arguments. The first argument specifies the kind of type checking that should be performed (POS or DEF). The next two arguments (TpR1, TpR2) are the types that must be checked. <p> These predicates denote the possible and definite well-formedness of an expression <ref> [10, 23] </ref>. If the existing type checker of the IFAD VDM-SL Toolbox performs possible type checking (POS mode) an expression is rejected if it is not possibly well-formed. <p> The test cases and the test environment were naturally also adapted to take these changes into account. The central idea underlying the approach presented here (proposed in <ref> [10, 11] </ref>) is to extend type checking by generating proof obligations for the "difficult" parts which cause the undecidability. In this section we will describe how the existing type checker has been extended and modified to perform this task. <p> The central idea influencing this work comes from Flemming M. Damm, Hans Bruun, and Bo Stig Hansen <ref> [10, 11] </ref>. But also some other tools (methods) already generating proof obligations motivated this extension of the IFAD VDM-SL Toolbox with a proof obligation generator. RAISE: In the RAISE Specification Language [15, 27] an expressive notion of types is also used for type checking.
Reference: 11. <author> Flemming M. Damm and Bo Stig Hansen. </author> <title> Generation of Proof Obligations for Type Consistency. </title> <type> Technical Report 1993-123, </type> <institution> Department of Computer Science, Technical University of Denmark, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: The test cases and the test environment were naturally also adapted to take these changes into account. The central idea underlying the approach presented here (proposed in <ref> [10, 11] </ref>) is to extend type checking by generating proof obligations for the "difficult" parts which cause the undecidability. In this section we will describe how the existing type checker has been extended and modified to perform this task. <p> The central idea influencing this work comes from Flemming M. Damm, Hans Bruun, and Bo Stig Hansen <ref> [10, 11] </ref>. But also some other tools (methods) already generating proof obligations motivated this extension of the IFAD VDM-SL Toolbox with a proof obligation generator. RAISE: In the RAISE Specification Language [15, 27] an expressive notion of types is also used for type checking.
Reference: 12. <author> John Dawes. </author> <title> The VDM-SL Reference Guide. </title> <publisher> Pitman, </publisher> <year> 1991. </year> <note> ISBN 0-273-03151-1. </note>
Reference-contexts: The match value 2 can only be matched against the value itself. Possible values matching the set enumeration pattern are f1, 2g or ftrue, 2g. A full description of all different kinds of patterns can be found in <ref> [12, 31] </ref>. In general, type checking patterns can be seen as checking if the patterns can match associated values. If they cannot, the specification has to be rejected. A pattern identifier, for example, is compatible to all types, but a set enumeration pattern expects a set type.
Reference: 13. <author> Rene Elmstrtm, Peter Gorm Larsen, and Poul Btgh Lassen. </author> <title> The IFAD VDM-SL Toolbox: A Practical Approach to Formal Specifications. </title> <journal> ACM Sigplan Notices, </journal> <volume> 29(9) </volume> <pages> 77-80, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: 1 Introduction During the last few years the interest in formal software development has been growing rapidly. One of the main reasons for this is the availability of tools to support the developer in using these formal methods. This paper describes an extension of the IFAD VDM-SL Toolbox <ref> [13, 24] </ref>, a commercial CASE tool supporting the Vienna Development Method (VDM). Amongst other features the Toolbox provides parsing and type checking of specifications written in VDM-SL, the specification language of VDM, which has been standardised under ISO [23, 26].
Reference: 14. <author> Jon Garnsworthy, Ian O`Neill, and Bernhard Carre. </author> <title> Automatic Proof of Absence of Run-time Errors. </title> <booktitle> In Ada UK Conference. </booktitle> <address> London Docklands, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: However, SPARK does not allow exceptions and overloading and has simplified scope and visibility rules. Unlike in our approach to operations, where annotations (assertions) are generated as proof obligations, in SPARK the annotations are added by the programmer in order to be able to generate POs <ref> [14] </ref>. 8 Concluding Remarks In this paper we have presented an approach for automatic generation of proof obligations for VDM-SL. We have shown the general strategy and presented more details about the kinds of constructs for which this kind of proof obligation generation has not been done before.
Reference: 15. <author> The RAISE Language Group. </author> <title> The RAISE Specification Language. The BCS Practitioners Series. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: The central idea influencing this work comes from Flemming M. Damm, Hans Bruun, and Bo Stig Hansen [10, 11]. But also some other tools (methods) already generating proof obligations motivated this extension of the IFAD VDM-SL Toolbox with a proof obligation generator. RAISE: In the RAISE Specification Language <ref> [15, 27] </ref> an expressive notion of types is also used for type checking. As a separate facility, not part of type checking, proof obligations called "confidence conditions" may be generated. These rule out, e.g., dynamic type errors.
Reference: 16. <author> The VDM Tool Group. </author> <title> User Manual for the IFAD VDM-SL Toolbox. </title> <type> Technical report, </type> <institution> IFAD, </institution> <month> May </month> <year> 1996. </year> <month> IFAD-VDM-4. </month>
Reference-contexts: In the IFAD VDM-SL Toolbox the two modes of type checking are selected by setting an option <ref> [16] </ref>. As mentioned in the introduction not only partial operators cause undecidability, but also the rich type system of VDM-SL. This is mainly due to the fact that the union type is an ordinary set-theoretic union without injection and projection functions.
Reference: 17. <author> Howard Haughton. </author> <title> Specification in B: An Introduction Using the B Toolkit. </title> <publisher> World Scientific Publishing, </publisher> <year> 1996. </year>
Reference-contexts: The type checker in PVS generates proof obligations called TCCs (Type Correctness Condition). However, PVS only supports (tagged) disjoint union types, which do not cause un-decidability like the non-disjoint unions in VDM-SL. The TCCs relate to subtypes, partial operators and the termination of recursive functions. B-Method: The B-Toolkit <ref> [17] </ref> has a proof obligation generator, that can be invoked from the "Main Environment". The POs are generated according to the correctness criteria which are required to hold within the B-Method [1].
Reference: 18. <author> I.J. Hayes, C.B. Jones, and J.E. </author> <title> Nicholls. Understanding the Differences Between VDM and Z. </title> <booktitle> FACS Europe, </booktitle> <pages> pages 7-30, </pages> <month> Autumn </month> <year> 1993. </year>
Reference-contexts: The same is done in our work, but Z does not have a type system as rich as VDM <ref> [18] </ref>. Our work covers a wider area, e.g. union types and patterns. Thus, domain checking is a subset of our consistency checks. SPARK: SPARK is an annotated subset of Ada, designed to eliminate ambiguities and insecurities of the full Ada language [8].
Reference: 19. <author> C.A.R. Hoare. </author> <title> An Axiomatic Basis for Computer Programming. </title> <journal> Communications of teh ACM, </journal> <volume> 12(10) </volume> <pages> 576-581, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: Traditional proof systems for statements use a pre-post strategy where a pre-predicate describes what is supposed to hold before execution of a specific statement and a post-predicate describes what will hold after executing the statement <ref> [19, 5] </ref>. A few proof rules for VDM-SL statements, which are adapted for exception handling, can be found in [22]. Implicit operations can be treated as implicit functions, which means a sat-isfiability proof obligation is generated to ensure consistency.
Reference: 20. <author> Cliff Jones, Kevin Jones, Peter Linsay, and Richard Moore, </author> <title> editors. mural: A Formal Development Support System. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> ISBN 3-540-19651-X. </note>
Reference-contexts: However, many of the generated proof obligations are trivial or simple, and can be informally justified by simply inspecting the PO. The notion of POs for VDM has been based on previous work <ref> [21, 20, 6] </ref>. The main contribution of this work is the automation of the generation of POs. In addition, Sections 5 and 6 present new work in the areas of patterns and explicit operations where no existing research for POs was present. <p> The rule states that the conclusion holds whenever the hypotheses hold <ref> [6, 20] </ref>. The abstract syntax for a proof rule is: PrfRule :: hyp : Sequent fl con : AllExpr ; To be compatible with the proof theory a hypothesis is defined as a sequent P ` R.
Reference: 21. <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <note> second edition, 1990. ISBN 0-13-880733-7. </note>
Reference-contexts: It is a model-oriented method, i.e. its formal descriptions (VDM specifications) consist of an explicit model of the system being constructed. A system design is generated through a series of specifications, where each specification is more concrete and closer to the implementation than the previous one <ref> [21] </ref>. Each of these development steps introduces a formal refinement statement which, when appropriately verified, ensures the (relative) correctness of the implemented system. The existing type checker of the IFAD VDM-SL Toolbox supports extensive consistency checks according to the static semantics of the ISO standard. <p> However, many of the generated proof obligations are trivial or simple, and can be informally justified by simply inspecting the PO. The notion of POs for VDM has been based on previous work <ref> [21, 20, 6] </ref>. The main contribution of this work is the automation of the generation of POs. In addition, Sections 5 and 6 present new work in the areas of patterns and explicit operations where no existing research for POs was present. <p> Both may be undecidable. The first because of union and subtypes, the second because of partial operators and functions with pre-conditions. In addition to these two categories the new POG also generates satisfiability obligations for implicitly defined functions and operations <ref> [21] </ref>. 4.1 Type Compatibility A compatibility check fails if the actual type and an expected type are overlapping, but the first is not a subtype of the second.
Reference: 22. <author> Peter Gorm Larsen. </author> <title> Towards Proof Rules for VDM-SL. </title> <type> PhD thesis, </type> <institution> Technical University of Denmark, Department of Computer Science, </institution> <month> March </month> <year> 1995. ID-TR:1995-160. </year>
Reference-contexts: A few proof rules for VDM-SL statements, which are adapted for exception handling, can be found in <ref> [22] </ref>. Implicit operations can be treated as implicit functions, which means a sat-isfiability proof obligation is generated to ensure consistency.
Reference: 23. <author> P.G. Larsen, B. S. Hansen, H. Brunn, N. Plat, H. Toetenel, D. J. Andrews, J. Dawes, G. Parkin, and et. al. </author> <title> Information Technology Programming languages, their environments and system software interfaces - Vienna Development Method Specification Language Part 1: Base language, </title> <address> ISO/IEC 13817-1, </address> <month> De-cember </month> <year> 1996. </year>
Reference-contexts: This paper describes an extension of the IFAD VDM-SL Toolbox [13, 24], a commercial CASE tool supporting the Vienna Development Method (VDM). Amongst other features the Toolbox provides parsing and type checking of specifications written in VDM-SL, the specification language of VDM, which has been standardised under ISO <ref> [23, 26] </ref>. VDM is one of the most widely used formal methods, and it can be applied to the construction of a large variety of software systems. It is a model-oriented method, i.e. its formal descriptions (VDM specifications) consist of an explicit model of the system being constructed. <p> Thus, we are only able to show very small extracts from this specification here. 2.1 Rejection and Acceptance Type checking for VDM-SL is somewhat different from what is usually found in programming languages [7, 10]. According to the standard of VDM-SL <ref> [23] </ref> a dual strategy of type checking is applied: (1) Impossibly consistent specifications are rejected. For example, the type checker will raise an error message if a specification contains the expression 1 + true. <p> These predicates denote the possible and definite well-formedness of an expression <ref> [10, 23] </ref>. If the existing type checker of the IFAD VDM-SL Toolbox performs possible type checking (POS mode) an expression is rejected if it is not possibly well-formed.
Reference: 24. <author> Paul Mukherjee. </author> <title> Computer-aided Validation of Formal Specifications. </title> <journal> Software Engineering Journal, </journal> <pages> pages 133-140, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction During the last few years the interest in formal software development has been growing rapidly. One of the main reasons for this is the availability of tools to support the developer in using these formal methods. This paper describes an extension of the IFAD VDM-SL Toolbox <ref> [13, 24] </ref>, a commercial CASE tool supporting the Vienna Development Method (VDM). Amongst other features the Toolbox provides parsing and type checking of specifications written in VDM-SL, the specification language of VDM, which has been standardised under ISO [23, 26].
Reference: 25. <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal Verification for Fault-Tolerant Architectures: Some Lessons Learned. </title> <editor> In J.C.P. Woodcock and P.G. Larsen, editors, FME'93: </editor> <booktitle> Industrial-Strength Formal Methods, </booktitle> <pages> pages 482-501. </pages> <booktitle> Formal Methods Europe, </booktitle> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1993. </year> <note> Lecture Notes in Computer Science 670. </note>
Reference-contexts: RAISE: In the RAISE Specification Language [15, 27] an expressive notion of types is also used for type checking. As a separate facility, not part of type checking, proof obligations called "confidence conditions" may be generated. These rule out, e.g., dynamic type errors. PVS: PVS (Prototype Verification System) <ref> [25] </ref> is an environment for specification and verification consisting of a specification language, a parser, a type checker, and an interactive theorem prover. The type checker in PVS generates proof obligations called TCCs (Type Correctness Condition).
Reference: 26. <author> Nico Plat and Peter Gorm Larsen. </author> <title> An Overview of the ISO/VDM-SL Standard. </title> <journal> Sigplan Notices, </journal> <volume> 27(8) </volume> <pages> 76-82, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: This paper describes an extension of the IFAD VDM-SL Toolbox [13, 24], a commercial CASE tool supporting the Vienna Development Method (VDM). Amongst other features the Toolbox provides parsing and type checking of specifications written in VDM-SL, the specification language of VDM, which has been standardised under ISO <ref> [23, 26] </ref>. VDM is one of the most widely used formal methods, and it can be applied to the construction of a large variety of software systems. It is a model-oriented method, i.e. its formal descriptions (VDM specifications) consist of an explicit model of the system being constructed.
Reference: 27. <author> The RAISE Method Group. </author> <title> The RAISE Development Method. The BCS Practitioners Series. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1995. </year>
Reference-contexts: The central idea influencing this work comes from Flemming M. Damm, Hans Bruun, and Bo Stig Hansen [10, 11]. But also some other tools (methods) already generating proof obligations motivated this extension of the IFAD VDM-SL Toolbox with a proof obligation generator. RAISE: In the RAISE Specification Language <ref> [15, 27] </ref> an expressive notion of types is also used for type checking. As a separate facility, not part of type checking, proof obligations called "confidence conditions" may be generated. These rule out, e.g., dynamic type errors.
Reference: 28. <author> Mark Saaltink. </author> <title> Z and EVES. </title> <editor> In J.E. Nicholls, editor, </editor> <booktitle> Z User Workshop, </booktitle> <address> York 1991, </address> <pages> pages 223-242. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <note> Workshops in Computing. </note>
Reference-contexts: The POs are generated according to the correctness criteria which are required to hold within the B-Method [1]. Thus, for example the criteria requires that an Abstract Machine initialisa-tion must establish the invariant, and that each operation re-establishes the invariant. Z/EVES: The Z/EVES system <ref> [28, 29] </ref>, a Z front-end to the theorem prover EVES [9] provides domain checking for Z specifications, which is the generation of proof obligations to ensure that all functions and operators are applied with parameters inside their domain.
Reference: 29. <author> Mark Saaltink. </author> <title> The Z/EVES system. </title> <type> Technical report, </type> <institution> ORA Canada, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: The POs are generated according to the correctness criteria which are required to hold within the B-Method [1]. Thus, for example the criteria requires that an Abstract Machine initialisa-tion must establish the invariant, and that each operation re-establishes the invariant. Z/EVES: The Z/EVES system <ref> [28, 29] </ref>, a Z front-end to the theorem prover EVES [9] provides domain checking for Z specifications, which is the generation of proof obligations to ensure that all functions and operators are applied with parameters inside their domain.
Reference: 30. <author> R.D. Tennent. </author> <booktitle> Principles of Programming Languages. Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey 07632, </address> <year> 1981. </year>
Reference-contexts: Also the proof tool does not yet deal with operations and statements. The main reason for this lack is the totally different way of proving in the imperative world: Due to side effects <ref> [30] </ref>, the whole history of state changes has to be considered. Traditional proof systems for statements use a pre-post strategy where a pre-predicate describes what is supposed to hold before execution of a specific statement and a post-predicate describes what will hold after executing the statement [19, 5].
Reference: 31. <author> The VDM Tool Group. </author> <title> The IFAD VDM-SL Language. </title> <type> Technical report, </type> <institution> IFAD, </institution> <month> May </month> <year> 1996. </year> <title> IFAD-VDM-1. This article was typeset using the L A T E X macro package with the LLNCS2E class. </title>
Reference-contexts: The match value 2 can only be matched against the value itself. Possible values matching the set enumeration pattern are f1, 2g or ftrue, 2g. A full description of all different kinds of patterns can be found in <ref> [12, 31] </ref>. In general, type checking patterns can be seen as checking if the patterns can match associated values. If they cannot, the specification has to be rejected. A pattern identifier, for example, is compatible to all types, but a set enumeration pattern expects a set type.
References-found: 31

