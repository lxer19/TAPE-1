URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1995/UM-CS-1995-076.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/95-076.html
Root-URL: 
Title: Accounting for Purpose in Specifying Requirements for Process Programs  
Author: Stanley M. Sutton, Jr. 
Note: This work was supported by the Advanced Research Projects Agency under grant F30602-94-C-0137.  
Address: Amherst, Massachusetts 01003  
Affiliation: Laboratory for Advanced Software Engineering Research Computer Science Department University of Massachusetts  
Abstract: CMPSCI Technical Report 95-76 July 1995 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Russell J. Abbott. </author> <title> An Integrated Approach to Software Development. </title> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: Comparable statements are found in [17] (p. 132), <ref> [1] </ref> (p. 1), and [20] (p. 278). In contrast, many different kinds of uses, reflecting different high-level purposes, have been suggested for software-process programs and related forms of process representation.
Reference: [2] <author> V. Ambriola, P. Ciancarini, and Montangero. </author> <title> Software process enactment in oikos. </title> <booktitle> In Proc. of the Fourth ACM SIGSOFT Symposium on Practical Software Development Environments, </booktitle> <pages> pages 183-192, </pages> <address> 1990. Irvine, California. </address>
Reference-contexts: individual process programs or models: * Static representation, static analysis, and comparison [19, 23] * Static representation and simulation [18] * Simulation and implementation [7] * Simulation and dynamic analysis [12, 14] * Guidance and recognition [11] * Static representation and implementation [16, 22, 7] * Manual and automated implementation <ref> [10, 5, 2] </ref> This diversity of purposes, which may be manifest in a single process program, can have a profound influence on the requirements for a program.
Reference: [3] <author> Israel Z. Ben-Shaul and Gail Kaiser. </author> <title> A paradigm for decentralized process modeling and its realization in the oz environment. </title> <booktitle> In Proc. of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 179-188, </pages> <year> 1994. </year>
Reference-contexts: Processes specified formally as programs may also provide the basis for process treaties and summits (described in <ref> [3] </ref>). * Process simulation, in which the program is executed to provide a dynamic model of process behavior. Simulations can be used for process prototyping and for dynamic process analysis, that is, the analysis of patterns of behavior.
Reference: [4] <author> Bruce I. Blum. </author> <title> Software Engineering-A Holistic View. </title> <publisher> Oxford University Press, </publisher> <address> New York, </address> <year> 1992. </year>
Reference: [5] <author> R. F. Bruynooghe, J. M. Parker, and J. S. </author> <title> Rowles. PSS: A system for process enactment. </title> <booktitle> In Proc. of the First International Conference on the Software Process, </booktitle> <pages> pages 128 - 141, </pages> <address> 1991. Redondo Beach, California, </address> <month> October, </month> <year> 1991. </year> <month> 20 </month>
Reference-contexts: individual process programs or models: * Static representation, static analysis, and comparison [19, 23] * Static representation and simulation [18] * Simulation and implementation [7] * Simulation and dynamic analysis [12, 14] * Guidance and recognition [11] * Static representation and implementation [16, 22, 7] * Manual and automated implementation <ref> [10, 5, 2] </ref> This diversity of purposes, which may be manifest in a single process program, can have a profound influence on the requirements for a program.
Reference: [6] <author> Jonathan E. Cook and Alexander L. Wolf. </author> <title> Towards metrics for process validation. </title> <booktitle> In Proc. of the Third International Conference on the Software Process, </booktitle> <pages> pages 33-44, </pages> <year> 1994. </year>
Reference: [7] <author> Wolfgang Deiters and Volker Gruhn. </author> <title> Managing software processes in the environment melmac. </title> <booktitle> In Proc. of the Fourth ACM SIGSOFT Symposium on Practical Software Development Environments, </booktitle> <pages> pages 193-205, </pages> <address> 1990. Irvine, California. </address>
Reference-contexts: Differing combinations of purposes have been given for individual process programs or models: * Static representation, static analysis, and comparison [19, 23] * Static representation and simulation [18] * Simulation and implementation <ref> [7] </ref> * Simulation and dynamic analysis [12, 14] * Guidance and recognition [11] * Static representation and implementation [16, 22, 7] * Manual and automated implementation [10, 5, 2] This diversity of purposes, which may be manifest in a single process program, can have a profound influence on the requirements for <p> Differing combinations of purposes have been given for individual process programs or models: * Static representation, static analysis, and comparison [19, 23] * Static representation and simulation [18] * Simulation and implementation [7] * Simulation and dynamic analysis [12, 14] * Guidance and recognition [11] * Static representation and implementation <ref> [16, 22, 7] </ref> * Manual and automated implementation [10, 5, 2] This diversity of purposes, which may be manifest in a single process program, can have a profound influence on the requirements for a program.
Reference: [8] <author> P. H. Feiler and W. S. Humphrey. </author> <title> Software process development and enactment concepts and definitions. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 28 - 40, </pages> <year> 1993. </year>
Reference-contexts: A similar distinction can be drawn analogously between the static and dynamic aspects of a software process. For example, static process representation by definitions or models is distinguished from the dynamic interpretation of those models <ref> [8, 13] </ref>. 1 A simple model of the software-process system where process programs are involved thus has two dimensions. It represents both the overall software process and the process program, 1 Of course, a process program can also be a kind of process model or definition. <p> A schematic representation of such a model is shown in Figure 1. 3.2 Properties of Software-Process Systems A number of properties of software-process systems have been identified and (sometimes variously) defined <ref> [8, 13, 21] </ref>. Among the properties that are especially relevant to the use of process programs are consistency, precision, fidelity, verifiability, coordination, correspondence, dependence, and determinability. <p> It addresses the question of whether a process program is the correct one for the specified process. * Precision is the degree to which the process specification details process activities that will yield accurate, i.e., intended, results <ref> [8] </ref>. It relates static specifications to dynamic behaviors, most typically at the level of the overall process. * Fidelity is the faithfulness with which a defined process is followed [8]. <p> process. * Precision is the degree to which the process specification details process activities that will yield accurate, i.e., intended, results <ref> [8] </ref>. It relates static specifications to dynamic behaviors, most typically at the level of the overall process. * Fidelity is the faithfulness with which a defined process is followed [8]. It relates the actual behavior of an executing process to the process specification. * Verifiability is the ability to measure the degree to which behavior conforms to a specification or definition. <p> For example, analysis may help to determine whether each process step is accompanied by a corresponding logging operation as required in support of process verification. * Process fitness: Fitness is the ease with which a process specification actually can be followed <ref> [8] </ref>. Fitness in general depends on a number of factors such as the understandability of the process specification, sensibility and correctness of the process, and factors that affect the implementability of the specification.
Reference: [9] <author> Christer Fernstrom. </author> <title> PROCESS WEAVER: Adding process support to UNIX. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 12 - 26, </pages> <year> 1993. </year>
Reference-contexts: These may be applied in process discovery ([6]) and in process planning for management purposes [12, 14]. * Process implementation, in which the program is executed in support of creating a software product. Such programs may differ widely in the degree and kind of support for process execution <ref> [9] </ref>, ranging from passive process guidance to process control to process automation. * Process proxy, in which the program is executed to support the process, but where the program is also intended to represent the process for purposes such as process monitoring, process measurement, process analysis, and process discovery. (Process proxy <p> However, even where "implementation" in some sense is the general goal of a process program, the particular sort of support for process execution can vary widely. For example, four different categories of support are identified in <ref> [9] </ref>, including loosely coupled enactment, active process support, process enforcement, and process automation. These have very different ramifications for process-program requirements, and, moreover, they may be used in combinations and variations.
Reference: [10] <author> Christer Fernstrom and Lennart Ohlsson. </author> <title> Integration needs in process enacted environments. </title> <booktitle> In Proc. of the First International Conference on the Software Process, </booktitle> <pages> pages 142 - 158, </pages> <address> 1991. Redondo Beach, California, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: individual process programs or models: * Static representation, static analysis, and comparison [19, 23] * Static representation and simulation [18] * Simulation and implementation [7] * Simulation and dynamic analysis [12, 14] * Guidance and recognition [11] * Static representation and implementation [16, 22, 7] * Manual and automated implementation <ref> [10, 5, 2] </ref> This diversity of purposes, which may be manifest in a single process program, can have a profound influence on the requirements for a program.
Reference: [11] <author> Karen E. Huff and Victor Lesser. </author> <title> A plan-based intelligent assistent that supports the software development process. </title> <booktitle> In ACM Symposium on Practical Software Development Environments, </booktitle> <pages> pages 97 - 106, </pages> <year> 1988. </year>
Reference-contexts: Differing combinations of purposes have been given for individual process programs or models: * Static representation, static analysis, and comparison [19, 23] * Static representation and simulation [18] * Simulation and implementation [7] * Simulation and dynamic analysis [12, 14] * Guidance and recognition <ref> [11] </ref> * Static representation and implementation [16, 22, 7] * Manual and automated implementation [10, 5, 2] This diversity of purposes, which may be manifest in a single process program, can have a profound influence on the requirements for a program.
Reference: [12] <author> Marc I. Kellner. </author> <title> Software process modeling support for management planning and control. </title> <booktitle> In Proc. of the First International Conference on the Software Process, </booktitle> <pages> pages 8 - 28, </pages> <address> 1991. Redondo Beach, California, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: Simulations can be used for process prototyping and for dynamic process analysis, that is, the analysis of patterns of behavior. These may be applied in process discovery ([6]) and in process planning for management purposes <ref> [12, 14] </ref>. * Process implementation, in which the program is executed in support of creating a software product. <p> Differing combinations of purposes have been given for individual process programs or models: * Static representation, static analysis, and comparison [19, 23] * Static representation and simulation [18] * Simulation and implementation [7] * Simulation and dynamic analysis <ref> [12, 14] </ref> * Guidance and recognition [11] * Static representation and implementation [16, 22, 7] * Manual and automated implementation [10, 5, 2] This diversity of purposes, which may be manifest in a single process program, can have a profound influence on the requirements for a program.
Reference: [13] <author> Jacques Lonchamp. </author> <title> A structured conceptual and terminological framework for software process engineering. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 41-53, </pages> <year> 1993. </year>
Reference-contexts: A similar distinction can be drawn analogously between the static and dynamic aspects of a software process. For example, static process representation by definitions or models is distinguished from the dynamic interpretation of those models <ref> [8, 13] </ref>. 1 A simple model of the software-process system where process programs are involved thus has two dimensions. It represents both the overall software process and the process program, 1 Of course, a process program can also be a kind of process model or definition. <p> A schematic representation of such a model is shown in Figure 1. 3.2 Properties of Software-Process Systems A number of properties of software-process systems have been identified and (sometimes variously) defined <ref> [8, 13, 21] </ref>. Among the properties that are especially relevant to the use of process programs are consistency, precision, fidelity, verifiability, coordination, correspondence, dependence, and determinability. <p> For example, a process program that only weakly determines the software process cannot be counted on to support the fidelity of the process. 3 In <ref> [13] </ref> verification is defined as directed towards the formal proof of properties of a process model. In this sense it can be considered as contributing to consistency as defined above, in that proofs of process-program properties can be used to assess conformance to process specifications.
Reference: [14] <author> Peiwei Mi and Walt Scacchi. </author> <title> Modeling articulation work in software engineering processes. </title> <booktitle> In Proc. of the First International Conference on the Software Process, </booktitle> <pages> pages 188 - 201, </pages> <address> 1991. Redondo Beach, California, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: Simulations can be used for process prototyping and for dynamic process analysis, that is, the analysis of patterns of behavior. These may be applied in process discovery ([6]) and in process planning for management purposes <ref> [12, 14] </ref>. * Process implementation, in which the program is executed in support of creating a software product. <p> Differing combinations of purposes have been given for individual process programs or models: * Static representation, static analysis, and comparison [19, 23] * Static representation and simulation [18] * Simulation and implementation [7] * Simulation and dynamic analysis <ref> [12, 14] </ref> * Guidance and recognition [11] * Static representation and implementation [16, 22, 7] * Manual and automated implementation [10, 5, 2] This diversity of purposes, which may be manifest in a single process program, can have a profound influence on the requirements for a program.
Reference: [15] <institution> National Research Council. Information Technology for Manufacturing-A Research Agenda. National Academy Press, </institution> <address> Washington, D. C., </address> <year> 1995. </year>
Reference-contexts: Research issues for the use of information technology in manufacturing processes include the development of process descriptions that allow processes to be analyzed, enforced, and simulated, and the development of process-description languages that are both man- and machine-intelligible <ref> [15] </ref>.
Reference: [16] <author> Leon J. Osterweil. </author> <title> Software processes are software, too. </title> <booktitle> In Proc. Ninth International Conference on Software Engineering, 1987. </booktitle> <address> Monterey, CA, March 30 - April 2, </address> <year> 1987. </year>
Reference-contexts: Differing combinations of purposes have been given for individual process programs or models: * Static representation, static analysis, and comparison [19, 23] * Static representation and simulation [18] * Simulation and implementation [7] * Simulation and dynamic analysis [12, 14] * Guidance and recognition [11] * Static representation and implementation <ref> [16, 22, 7] </ref> * Manual and automated implementation [10, 5, 2] This diversity of purposes, which may be manifest in a single process program, can have a profound influence on the requirements for a program. <p> Finally, Section 7 presents a summary and conclusions. 2 Why Process Programs Serve Multiple Purposes Process programs as a group have been addressed to a diversity of purposes since software processes became a domain for programming <ref> [16] </ref>. This diversity of purpose seems to be inherent in the domain, making the explicit recognition and accommodation of multiple purposes essential in specifying their requirements. Support for process execution is arguably the ultimate goal of process programming (since execution may be taken as the ultimate goal for processes).
Reference: [17] <author> Roger S. Pressman. </author> <title> Software Engineering-A Practitioner's Approach. </title> <publisher> McGraw-Hill, Inc., </publisher> <address> third edition, </address> <year> 1992. </year> <month> 21 </month>
Reference-contexts: The implementation-orientation of most software is reflected in typical in textbook treatments of requirements engineering, for example, "Once we have established what we want, we can proceed to the next level of modeling and define how to implement it" ([4], p. 83). Comparable statements are found in <ref> [17] </ref> (p. 132), [1] (p. 1), and [20] (p. 278). In contrast, many different kinds of uses, reflecting different high-level purposes, have been suggested for software-process programs and related forms of process representation.
Reference: [18] <author> Motoshi Saeki, Tsuyoshi Kaneko, and Masaki Sakamoto. </author> <title> A method for software process modeling and description using LOTOS. </title> <booktitle> In Proc. of the First International Conference on the Software Process, </booktitle> <pages> pages 90 - 104, </pages> <address> 1991. Redondo Beach, California, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: Differing combinations of purposes have been given for individual process programs or models: * Static representation, static analysis, and comparison [19, 23] * Static representation and simulation <ref> [18] </ref> * Simulation and implementation [7] * Simulation and dynamic analysis [12, 14] * Guidance and recognition [11] * Static representation and implementation [16, 22, 7] * Manual and automated implementation [10, 5, 2] This diversity of purposes, which may be manifest in a single process program, can have a profound
Reference: [19] <author> Xiping Song and Leon J. Osterweil. </author> <title> Experience with an approach to comparing software design methodologies. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 20(5) </volume> <pages> 145-165, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Differing combinations of purposes have been given for individual process programs or models: * Static representation, static analysis, and comparison <ref> [19, 23] </ref> * Static representation and simulation [18] * Simulation and implementation [7] * Simulation and dynamic analysis [12, 14] * Guidance and recognition [11] * Static representation and implementation [16, 22, 7] * Manual and automated implementation [10, 5, 2] This diversity of purposes, which may be manifest in a <p> Process programs afford the opportunity to simulate processes that are otherwise too cumbersome and costly to test directly. Additionally, programming can provide a common syntactic and semantic framework in which to analyze and compare processes that have been represented by various less formal means <ref> [19] </ref>. In such ways the process domain poses a number of different sorts of problems to which programming is applicable. Characteristics of the domain of software processes also motivate the assignment of multiple purposes to individual process programs.
Reference: [20] <author> Donald V. Steward. </author> <title> Software Engineering with Analysis and Design. </title> <publisher> Brooks/Cole Publishing Company, </publisher> <address> Monterey, California, </address> <year> 1987. </year>
Reference-contexts: Comparable statements are found in [17] (p. 132), [1] (p. 1), and <ref> [20] </ref> (p. 278). In contrast, many different kinds of uses, reflecting different high-level purposes, have been suggested for software-process programs and related forms of process representation. Potential uses of process programs include: * Process specification, in which the process program provides a formal definition of the process.
Reference: [21] <author> Stanley M. Sutton, Jr. </author> <title> Opportunities, limitations, and tradeoffs in process programming. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 135-146, </pages> <year> 1993. </year>
Reference-contexts: A schematic representation of such a model is shown in Figure 1. 3.2 Properties of Software-Process Systems A number of properties of software-process systems have been identified and (sometimes variously) defined <ref> [8, 13, 21] </ref>. Among the properties that are especially relevant to the use of process programs are consistency, precision, fidelity, verifiability, coordination, correspondence, dependence, and determinability. <p> primary concern here between the behavior and specification of the software process. 3 * Coordination is the extent to which concurrent behaviors in the software process and process program are mutually appropriate, i.e., that the process is behaving correctly with respect to the execution of the program and vice versa <ref> [21] </ref>. <p> process tasks to engineers, the process program (in coordination) may be expected to send out notices to the engineers of their assignments. * Correspondence is the degree to which individual steps and patterns of behavior in the software process match steps and patterns in the behavior of the process program <ref> [21] </ref>. For example, a Modify Code step in the process may be matched by a corresponding Modify Code procedure in the process program. A related concept proposed here is prospective correspondence. <p> This relates the behavior of a software process to a description in a process program; it implies that the behavior of the process would correspond to the behavior of the program, if the program were executed. * Dependence characterizes the reliance of process execution on process program execution <ref> [21] </ref>. A process with a high dependence on its process program will not be able to execute significantly unless the program is able to execute. * Determinability [21] reflects the extent to which the behavior of the process is directed and constrained by the behavior of the process program. <p> to the behavior of the program, if the program were executed. * Dependence characterizes the reliance of process execution on process program execution <ref> [21] </ref>. A process with a high dependence on its process program will not be able to execute significantly unless the program is able to execute. * Determinability [21] reflects the extent to which the behavior of the process is directed and constrained by the behavior of the process program.
Reference: [22] <author> Stanley M. Sutton, Jr., Dennis Heimbigner, and Leon J. Osterweil. APPL/A: </author> <title> A language for software-process programming. </title> <journal> ACM Trans. on Software Engineering and Methodology, </journal> <volume> 4(3), </volume> <month> July </month> <year> 1995. </year> <note> to appear. </note>
Reference-contexts: Differing combinations of purposes have been given for individual process programs or models: * Static representation, static analysis, and comparison [19, 23] * Static representation and simulation [18] * Simulation and implementation [7] * Simulation and dynamic analysis [12, 14] * Guidance and recognition [11] * Static representation and implementation <ref> [16, 22, 7] </ref> * Manual and automated implementation [10, 5, 2] This diversity of purposes, which may be manifest in a single process program, can have a profound influence on the requirements for a program.
Reference: [23] <author> Masato Suzuki and Takuya Katayama. </author> <title> Meta-operations in the process model HFSP for the dynamics and flexibility of software processes. </title> <booktitle> In Proc. of the First International Conference on the Software Process, </booktitle> <pages> pages 202 - 217, </pages> <address> 1991. Redondo Beach, California, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: Differing combinations of purposes have been given for individual process programs or models: * Static representation, static analysis, and comparison <ref> [19, 23] </ref> * Static representation and simulation [18] * Simulation and implementation [7] * Simulation and dynamic analysis [12, 14] * Guidance and recognition [11] * Static representation and implementation [16, 22, 7] * Manual and automated implementation [10, 5, 2] This diversity of purposes, which may be manifest in a
Reference: [24] <author> Alex L. Wolf and David S. Rosenblum. </author> <title> A study in software process data capture and analysis. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 115-124, </pages> <year> 1983. </year>
Reference-contexts: The motivation for this use of process programs stems from the difficulty of capturing process behavior directly <ref> [24] </ref>. However, if the behavior of the process program is representative of the behavior of the process, then the behavior of the process can be studied indirectly by studying the behavior of the process program.
References-found: 24

