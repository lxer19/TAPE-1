URL: ftp://ftp.cs.colorado.edu/users/hull/calc-with-scalar-funcs.ps
Refering-URL: http://www.cs.concordia.ca/~faculty/grahne/courses/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fmarthae,hull,jacobsg@pollux.usc.edu  
Title: Safety and Translation of Calculus Queries with Scalar Functions Keywords: relational calculus, safety, domain independent,
Author: Martha Escobar-Molano and Richard Hull and Dean Jacobs 
Date: March 25, 1993  
Address: Los Angeles, CA 90089-0782 USA  
Affiliation: Computer Science Department University of Southern California  
Abstract: If the relational calculus is embedded into an imperative programming language, then scalar functions on the underlying domain (e.g., arithmetic operators and user-defined functions) should be accessible from within calculus formulas. This paper generalizes previous work on the relational calculus to this context. The notions of "domain independence" and "allowed" are generalized, and it is shown that all allowed calculus queries with (total) scalar functions are domain independent. The van Gelder-Topor algorithm for translating allowed calculus queries into the relational algebra is also generalized. In order to accomodate functions, an extended algebra is used. The translation framework uses "finiteness dependencies"; these are analogous to functional dependencies and carry information about how subformulas involving scalar functions can restrict the possible range of variables. A special family of succinct "reduced" covers for sets of finiteness dependencies is used in the development. A number of considerations with regard to applying this concept in practical settings are discussed.
Abstract-found: 1
Intro-found: 1
Reference: [AB88] <author> Serge Abiteboul and Catriel Beeri. </author> <title> On the power of languages for the manipulation of complex objects. </title> <type> Technical Report 846, </type> <institution> INRIA, </institution> <month> Mai </month> <year> 1988. </year>
Reference-contexts: In our extended algebra (a subset of the language Heraclitus [Alg,C] [GHJ92, GHJ93]) point-wise evaluation of scalar functions is accomplished by an extended projection operator, which is analgous to the apply-append operator of the OOAlgebra [Day89]; see also <ref> [AB88] </ref>. For example, project ([@1,f (@1)],R) computes the binary relation having one tuple t for each tuple in R, where t (1) is in R and t (2) = f (t (1)). Query q 1 is thus equivalent to project ([g (f (@1))],R). <p> Also, in the context of a conventional programming language, it might be impossible to compute the inverse of f . In this paper we use a natural generalization of domain independent called here embedded domain independent (this is called "bounded depth domain independent" in <ref> [AB88] </ref>; see also [BM92a, BM92b]). As with the usual notion of domain independent, if a calculus query q is embedded domain independent then it can be evaluated against input instances by examining only a finite subset of the underlying domain of values. <p> In this section we briefly mention other investigations related to this paper. The paper <ref> [AB88] </ref> explores the incorporation of functions into query languages for complex objects; develops a syntactic notion of "safe" calculus; and shows the equivalence of the calculus, the algebra and a datalog-like language. <p> As noted above, the notion of embedded domain independent developed in the current paper is a restriction to the flat relational case of the notion of bounded depth domain independent in <ref> [AB88] </ref>. The notion of safe calculus queries developed in [AB88] is based on "range-restriction" of variables occurring in calculus formulas. <p> As noted above, the notion of embedded domain independent developed in the current paper is a restriction to the flat relational case of the notion of bounded depth domain independent in <ref> [AB88] </ref>. The notion of safe calculus queries developed in [AB88] is based on "range-restriction" of variables occurring in calculus formulas. <p> For example, R (x) ^ 9y (f (x) = y ^ :R (y)) is em-allowed but not range restricted. The translation of em-allowed queries into the algebra presented here will produce, at an intermediate stage, equivalent calculus queries which are range-restricted. The paper <ref> [AB88] </ref> also provides a translation from range-restricted calculus formulas into the algebra. This translation is motivated from a primarily theoretical perspective. <p> This translation is motivated from a primarily theoretical perspective. In particular, the algebra query q 0 resulting from calculus query q will in some cases involve a construction of the active domain of the input instance, although more efficient algebra queries may be available. As a simple example, <ref> [AB88] </ref> would translate the query fx; y; z j R (x; y; z) ^ :S (y; z)g into project ([@1,@2,@3], join (f@2==@4,@3==@5g, R, (Adom fi Adom) - S)), where Adom is the unary algebra query which computes the active domain of the query and its input. <p> The notion of "strict DB-domain independent" defined there is very close to our notion of embedded domain independent. The only significant difference is that in [BM92a], the 4 term closure is constructed using both functions and their inverses. Essentially in the spirit of <ref> [AB88] </ref>, [BM92a] provides a definition of "safe" calculus queries, shows that they are strict DB-domain independent, and indicates how to translate these into algebra queries. As with [AB88], the notion of safe used is strictly weaker than our em-allowed, and the translation is potentially less efficient. <p> Essentially in the spirit of <ref> [AB88] </ref>, [BM92a] provides a definition of "safe" calculus queries, shows that they are strict DB-domain independent, and indicates how to translate these into algebra queries. As with [AB88], the notion of safe used is strictly weaker than our em-allowed, and the translation is potentially less efficient. A third related investigation is described in [Top91], which studies the algebra, calculus, and datalog languages. <p> In the formal development the tone is abstract; Section 9 describes how this abstract development can be generalized to the more practical setting. The current section introduces "embedded domain independence" (called "bounded depth domain independence" in <ref> [AB88] </ref>), a generalization of the notion of "domain independence" that incorporates scalar functions. <p> The translation from the calculus to the algebra can be generalized to handle this case. The main modification is to transformations T13 to T16; in particular, in each transformation the phrase `em-allowed' is replaced by `em-allowed for X'. (d) As discussed in <ref> [AB88] </ref>, it is possible to incorporate externally defined predicates, both arithmetic ones such as `&lt;', and user-defined ones. In general, these can be viewed as giving no bounding information, analogous to atoms t 1 = t 2 where t 1 ; t 2 are not variables.
Reference: [Arm74] <author> W. W. Armstrong. </author> <title> Dependency structures of data base relationships. </title> <booktitle> Proc. IFIP Congress, </booktitle> <publisher> North Holland, Amsterdam, </publisher> <pages> pages 580-583, </pages> <year> 1974. </year>
Reference-contexts: To this end we first define a partial order on FinDs (cf. <ref> [Arm74] </ref>): Definition: Let W ! U and X ! Y be FinDs. Then W ! U refines X ! Y , denoted W ! U X ! Y , if X W and U Y For example, x ! zw xy ! z. Clearly, is reflexive, antisymmetric and transitive.
Reference: [BB79] <author> C. Beeri and P. A. Bernstein. </author> <title> Computational Problems Related to the Design of Normal Form Relational Schemas. </title> <journal> ACM Transactions on Database Systems 4:1, </journal> <pages> pages 30-59, </pages> <year> 1979. </year>
Reference-contexts: It follows from the algorithm for computing the fd-closure <ref> [BB79] </ref> (see also [Ull88]) and the fact that there must exist a positive em-allowed subformula i k , that there is a permutation i 1 ; : : : ; i n of 1; : : :; n such that bd (~ j ) j= ; ! f ree (~ j <p> By using the fd-closure algorithm of <ref> [BB79] </ref>, each conjunction of = ~ 1 ^ : : : ^ ~ n can be sorted in time linear in the length of rbd (~ 1 ); : : :; rbd (~ n ). 2 We now present the inductive definition of rbd, and follow with a discussion of some
Reference: [BM92a] <author> C. Beeri and T. Milo. </author> <title> Functional and predicative programming in OODB's. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 176-190, </pages> <year> 1992. </year>
Reference-contexts: Also, in the context of a conventional programming language, it might be impossible to compute the inverse of f . In this paper we use a natural generalization of domain independent called here embedded domain independent (this is called "bounded depth domain independent" in [AB88]; see also <ref> [BM92a, BM92b] </ref>). As with the usual notion of domain independent, if a calculus query q is embedded domain independent then it can be evaluated against input instances by examining only a finite subset of the underlying domain of values. It is undecidable whether a calculus query is (embedded) domain independent. <p> In contrast, we follow [GT91] and translate this into R - project ([@1,@2,@3],join (f@2==@4,@3==@5g,R,S)). In practical settings, a direct execution of the latter query will be considerably cheaper than one of the former query. The paper <ref> [BM92a] </ref> (see also [BM92b]) studies the issue of safe calculus queries and their translation to an algebra in a much richer context based on the perspective of algebraic specifications. <p> This set C essentially plays the role of the "DB-window" of <ref> [BM92a] </ref>. We define a query q to be embedded domain independent if there is some k such that for each instance I it yields the same answer on all interpretations which "agree" on term k (adom (q; I)). In contrast, [BM92a] develops a family of related notions of domain independence. <p> set C essentially plays the role of the "DB-window" of <ref> [BM92a] </ref>. We define a query q to be embedded domain independent if there is some k such that for each instance I it yields the same answer on all interpretations which "agree" on term k (adom (q; I)). In contrast, [BM92a] develops a family of related notions of domain independence. The notion of "strict DB-domain independent" defined there is very close to our notion of embedded domain independent. The only significant difference is that in [BM92a], the 4 term closure is constructed using both functions and their inverses. <p> In contrast, <ref> [BM92a] </ref> develops a family of related notions of domain independence. The notion of "strict DB-domain independent" defined there is very close to our notion of embedded domain independent. The only significant difference is that in [BM92a], the 4 term closure is constructed using both functions and their inverses. Essentially in the spirit of [AB88], [BM92a] provides a definition of "safe" calculus queries, shows that they are strict DB-domain independent, and indicates how to translate these into algebra queries. <p> The notion of "strict DB-domain independent" defined there is very close to our notion of embedded domain independent. The only significant difference is that in <ref> [BM92a] </ref>, the 4 term closure is constructed using both functions and their inverses. Essentially in the spirit of [AB88], [BM92a] provides a definition of "safe" calculus queries, shows that they are strict DB-domain independent, and indicates how to translate these into algebra queries. As with [AB88], the notion of safe used is strictly weaker than our em-allowed, and the translation is potentially less efficient. <p> f of arity n in F , F (f )(b 1 ; : : : ; b n ) = F 0 (f )(b 1 ; : : : ; b n ). 1 The "neighborhoods" used here can be viewed as specialized versions of the k-closure of "DB-windows" of <ref> [BM92a] </ref>; here we extend the active domain by application of functions but not their inverses 8 Notice that if the pre-interpretations P and P 0 agree on C to level i, then term i+1 P (C) = term i+1 P 0 (C).
Reference: [BM92b] <author> C. Beeri and T. Milo. </author> <title> On databases, queries, and domain independence. </title> <type> Technical report, </type> <institution> Hebrew University, </institution> <year> 1992. </year>
Reference-contexts: Also, in the context of a conventional programming language, it might be impossible to compute the inverse of f . In this paper we use a natural generalization of domain independent called here embedded domain independent (this is called "bounded depth domain independent" in [AB88]; see also <ref> [BM92a, BM92b] </ref>). As with the usual notion of domain independent, if a calculus query q is embedded domain independent then it can be evaluated against input instances by examining only a finite subset of the underlying domain of values. It is undecidable whether a calculus query is (embedded) domain independent. <p> In contrast, we follow [GT91] and translate this into R - project ([@1,@2,@3],join (f@2==@4,@3==@5g,R,S)). In practical settings, a direct execution of the latter query will be considerably cheaper than one of the former query. The paper [BM92a] (see also <ref> [BM92b] </ref>) studies the issue of safe calculus queries and their translation to an algebra in a much richer context based on the perspective of algebraic specifications.
Reference: [Coh86] <author> Don Cohen. </author> <title> Programming by specification and annotation. </title> <booktitle> In Proc. of AAAI, </booktitle> <year> 1986. </year>
Reference-contexts: Also, unlike [Top91], we present a heuristic to simplify the computations involving FinDs required to implement the translation. A final research effort concerning safety of calculus queries and translation of them is described in <ref> [Coh86] </ref>. Unlike most other approaches, the focus here is on translation from the calculus directly into a physical implementation, without passing through the algebra. Furthermore, information about the implementations of the relations can be incorporated into the translation. <p> This is specified in the system using the "annotations" `PERSON: ; yields f1,2g' and `PERSON: f1g yields f2g'. These are closely related to the FinDs used here. The focus in <ref> [Coh86] </ref> is on generating a (partial) list of answer tuples, rather than producing the complete set of answer tuples. As a result, the framework can accomodate infinite relations 5 and infinite query answers. The system described in [Coh86] includes a compiler (which has been implemented and used for several years) that <p> These are closely related to the FinDs used here. The focus in <ref> [Coh86] </ref> is on generating a (partial) list of answer tuples, rather than producing the complete set of answer tuples. As a result, the framework can accomodate infinite relations 5 and infinite query answers. The system described in [Coh86] includes a compiler (which has been implemented and used for several years) that translates calculus queries directly into physical implementations (compatible with the annotations) based on nested loops and physical access structures, and which generate the list of answer tuples. <p> While there appears to be a close relationship between the semantics and use of the annotations in <ref> [Coh86] </ref> and FinDs in the current paper, a detailed comparison of the approaches has not been performed. 3 Two Examples In this section we present two examples which illustrate how scalar functions naturally arise in practical queries, and how our framework is used to analyze and translate these queries into the
Reference: [Day89] <author> Umeshwar Dayal. </author> <title> Queries and views in an object-oriented data model. </title> <booktitle> In Proc. of Second Intl. Workshop on Database Programming Languages, </booktitle> <pages> pages 80-102. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: In our extended algebra (a subset of the language Heraclitus [Alg,C] [GHJ92, GHJ93]) point-wise evaluation of scalar functions is accomplished by an extended projection operator, which is analgous to the apply-append operator of the OOAlgebra <ref> [Day89] </ref>; see also [AB88]. For example, project ([@1,f (@1)],R) computes the binary relation having one tuple t for each tuple in R, where t (1) is in R and t (2) = f (t (1)). Query q 1 is thus equivalent to project ([g (f (@1))],R).
Reference: [Dem82] <author> R. Demolombe. </author> <title> Syntactical characterization of a subset of domain independent formulas. </title> <type> Technical report, </type> <institution> Onera-Cert, </institution> <year> 1982. </year>
Reference-contexts: We expect that the framework used here for generalizing allowed to em-allowed can also be used to incorporate scalar functions into other syntactic criteria for safety (e.g., safe DRC [Ull88], evaluable <ref> [Dem82, GT91] </ref>). A key component in our program is the development of an algorithm which translates em-allowed calculus queries into equivalent relational algebra queries. Our algorithm is a generalization of the algorithm for allowed calculus queries presented in [GT91], which is based on a family of transformations on calculus queries.
Reference: [End72] <author> H. B. Enderton. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1972. </year>
Reference-contexts: We assume familiarity with the basic notions of relational database theory (cf. [Mai83, Ull88]), and of mathematical logic (cf. <ref> [End72] </ref>). We assume a one-sorted logic, and let dom denote a countably infinite set of "uninterpreted" constants. We assume a countably infinite set of variables var, a countably infinite set of relation names with associated arities, and a countably infinite set of function names with associated arities.
Reference: [GHJ92] <author> S. Ghandeharizadeh, R. Hull, and D. Jacobs. </author> <title> Implementation of delayed updates in Heraclitus. </title> <booktitle> In Proc. of Intl. Conf. on Extending Data Base Technology, </booktitle> <year> 1992. </year>
Reference-contexts: In our extended algebra (a subset of the language Heraclitus [Alg,C] <ref> [GHJ92, GHJ93] </ref>) point-wise evaluation of scalar functions is accomplished by an extended projection operator, which is analgous to the apply-append operator of the OOAlgebra [Day89]; see also [AB88]. <p> This is defined similarly for formulas ' and queries q. Also, we use, e.g., adom (q; I) to denote adom (q) [ adom (I). The extended relational algebra used here (see <ref> [GHJ92, GHJ93] </ref>) is based on coordinate positions. The extension to incorporate function symbols is natural, and easily understood from the examples given.
Reference: [GHJ93] <author> S. Ghandeharizadeh, R. Hull, D. Jacobs, et. al. </author> <title> On Implementing a Language for Specifying Active Database Execution Models. </title> <type> Technical Report, </type> <institution> Computer Science Department, University of Southern California. </institution> <month> February, </month> <year> 1993. </year>
Reference-contexts: In our extended algebra (a subset of the language Heraclitus [Alg,C] <ref> [GHJ92, GHJ93] </ref>) point-wise evaluation of scalar functions is accomplished by an extended projection operator, which is analgous to the apply-append operator of the OOAlgebra [Day89]; see also [AB88]. <p> This is defined similarly for formulas ' and queries q. Also, we use, e.g., adom (q; I) to denote adom (q) [ adom (I). The extended relational algebra used here (see <ref> [GHJ92, GHJ93] </ref>) is based on coordinate positions. The extension to incorporate function symbols is natural, and easily understood from the examples given.
Reference: [GT91] <author> A. van Gelder and R.W. Topor. </author> <title> Safety and translation of relational calculus queries. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 16(2) </volume> <pages> 235-278, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The algorithm can be viewed as a generalization and modification of one presented in <ref> [GT91] </ref>. It adopts and generalizes the notion of finiteness dependency (FinD) from [RBS87]; these are essentially functional dependencies applied to this context. The paper also presents (d) a succinct class of "reduced" covers for sets of FinDs, that improves the efficiency of the translation algorithm. <p> We expect that the framework used here for generalizing allowed to em-allowed can also be used to incorporate scalar functions into other syntactic criteria for safety (e.g., safe DRC [Ull88], evaluable <ref> [Dem82, GT91] </ref>). A key component in our program is the development of an algorithm which translates em-allowed calculus queries into equivalent relational algebra queries. Our algorithm is a generalization of the algorithm for allowed calculus queries presented in [GT91], which is based on a family of transformations on calculus queries. <p> A key component in our program is the development of an algorithm which translates em-allowed calculus queries into equivalent relational algebra queries. Our algorithm is a generalization of the algorithm for allowed calculus queries presented in <ref> [GT91] </ref>, which is based on a family of transformations on calculus queries. An important subtly here is that a new transformation not in [GT91] is needed in order to successfully translate all em-allowed queries into the algebra. <p> Our algorithm is a generalization of the algorithm for allowed calculus queries presented in <ref> [GT91] </ref>, which is based on a family of transformations on calculus queries. An important subtly here is that a new transformation not in [GT91] is needed in order to successfully translate all em-allowed queries into the algebra. <p> as detailed below the query q 4 fx; y j:(((f (x) 6= y ^ g (x) 6= y) _ R (x; y)) ^ ((h (x) 6= y ^ k (x) 6= y) _ P (x; y))) is em-allowed and embedded domain independent, but (the natural generalizations of) the transformations of <ref> [GT91] </ref> are not sufficient to translate this into the extended algebra. A second difficulty in performing the generalization involves the order in which subformulas can be evaluated. <p> Brief conclusions are offered in Section 10. An appendix provides many of the technical proofs and algorithms used in the development. 3 2 Related Work As suggested in the Introduction, the work presented here can be viewed primarily as an extension and synthesis of work in <ref> [GT91] </ref> and [RBS87]. In this section we briefly mention other investigations related to this paper. The paper [AB88] explores the incorporation of functions into query languages for complex objects; develops a syntactic notion of "safe" calculus; and shows the equivalence of the calculus, the algebra and a datalog-like language. <p> In contrast, we follow <ref> [GT91] </ref> and translate this into R - project ([@1,@2,@3],join (f@2==@4,@3==@5g,R,S)). In practical settings, a direct execution of the latter query will be considerably cheaper than one of the former query. <p> q 5 fx; y j (R (x) ^ f (x) = y) _ (S (y) ^ g (y) = x)g is em-allowed but not safe.] The paper [Top91] presents a sketch of a translation from the safe calculus to an extended algebra, suggesting that natural generalizations of the transformations of <ref> [GT91] </ref> are sufficient. Our work follows the spirit of this sketch, but provides complete details and a complete proof of correctness. In particular, we provide an additional transformation (T10 in Section 7), which, as noted in the Introduction, is needed to translate some em-allowed queries. <p> Notably, query q 4 of the Introduction does satisfy the syntactic safeness condition of [Top91] but cannot be translated using only the natural generalizations of the transformations of <ref> [GT91] </ref>. Also, unlike [Top91], we present a heuristic to simplify the computations involving FinDs required to implement the translation. A final research effort concerning safety of calculus queries and translation of them is described in [Coh86]. <p> This will be defined so that for each formula ', ' j= bd ('). However, bd may not include all FinDs satisfied by '. The bd function can be viewed as a generalization of the gen operator of <ref> [GT91] </ref>. In the context without scalar functions, the function gen returns a set of variables known to be bound 3 In this context and below, `' means "is identical to". 10 to the active domain by a formula '. <p> ( ) all FinDs in which some variable in fx 1 ; : : :; x n g occurs) fl;' B11 8x 1 : : : 8x n (bd ( ) all FinDs in which some variable in fx 1 ; : : :; x n g occurs) fl;' Following <ref> [GT91] </ref>, the pushnot operator "pushes" negations one step towards the atoms in formulas: Definition: Given a formula :' where ' is not an atom representing a finite relation, the function pushnot (:') returns a formula, as follows 5 : :' pushnot (:') :(~ 1 ^ : : : ^ ~ n <p> Then ' is em-allowed. 2 It can be shown that if ' has no function symbols, then ' is em-allowed if and only if ' is allowed in the sense of <ref> [GT91] </ref>. We now state one of the main results of the paper. It is demonstrated in the course of translating em-allowed formulas into equivalent algebra queries; see the end of the next section. <p> Theorem 6.6: If 8 ' is em-allowed then ' is embedded domain independent at level jj'jj 1. 7 From the Calculus to the Algebra In this section we describe a non-trivial generalization of the algorithm of <ref> [GT91] </ref> for translating allowed formulas into equivalent algebra queries. Both the algorithm of [GT91] and our algorithm perform the translation in four steps: (1) Replace all subformulas of the form 8' by :9:'. <p> Theorem 6.6: If 8 ' is em-allowed then ' is embedded domain independent at level jj'jj 1. 7 From the Calculus to the Algebra In this section we describe a non-trivial generalization of the algorithm of <ref> [GT91] </ref> for translating allowed formulas into equivalent algebra queries. Both the algorithm of [GT91] and our algorithm perform the translation in four steps: (1) Replace all subformulas of the form 8' by :9:'. <p> Steps (1), (2) and (3) are accomplished using families of transformations, which map subfor-mulas to subformulas, and step (4) is accomplished with transformations mapping subformulas to algebra expressions. The major differences between our algorithm and that of <ref> [GT91] </ref> are as follows: (a) In steps 3 and 4, FinDs influence the choice of some transformation steps. (b) Our notion of "positive" and "negative" formulas is slightly different. [GT91] views all atoms t 1 = t 2 and t 1 6= t 2 as "positive" for primarily technical reasons. <p> The major differences between our algorithm and that of <ref> [GT91] </ref> are as follows: (a) In steps 3 and 4, FinDs influence the choice of some transformation steps. (b) Our notion of "positive" and "negative" formulas is slightly different. [GT91] views all atoms t 1 = t 2 and t 1 6= t 2 as "positive" for primarily technical reasons. <p> We view atoms of the form t 1 = t 2 to be positive, because they may give bounding information, and view t 1 6= t 2 as negative (see Example 7.6). (c) In step 2 we introduce a transformation (called T10 here), not present in <ref> [GT91] </ref>. (d) In step 3 our transformation T15 is slightly different from the analogous transformation of [GT91] (also called T15 there). Their transformation is subsumed by ours. (e) In step 3 we introduce a transformation T16 not present in [GT91]. <p> be positive, because they may give bounding information, and view t 1 6= t 2 as negative (see Example 7.6). (c) In step 2 we introduce a transformation (called T10 here), not present in <ref> [GT91] </ref>. (d) In step 3 our transformation T15 is slightly different from the analogous transformation of [GT91] (also called T15 there). Their transformation is subsumed by ours. (e) In step 3 we introduce a transformation T16 not present in [GT91]. <p> 2 we introduce a transformation (called T10 here), not present in <ref> [GT91] </ref>. (d) In step 3 our transformation T15 is slightly different from the analogous transformation of [GT91] (also called T15 there). Their transformation is subsumed by ours. (e) In step 3 we introduce a transformation T16 not present in [GT91]. Difference (c) is included so that queries such as q 4 of the Introduction (see Example 7.6 below) that satisfy the definition of em-allowed, can be successfully translated into the algebra. <p> A simplified formula is positive if it is not negative. We consider the formula t 1 6= t 2 as negative while in <ref> [GT91] </ref> it is considered positive. This permits our notion of ENF to be slightly more restrictive than that of [GT91], without disturbing the validity of our construction. It is also used in the proof of Lemma 7.10 below. The third condition in the following definition has no analog in [GT91]; it <p> A simplified formula is positive if it is not negative. We consider the formula t 1 6= t 2 as negative while in <ref> [GT91] </ref> it is considered positive. This permits our notion of ENF to be slightly more restrictive than that of [GT91], without disturbing the validity of our construction. It is also used in the proof of Lemma 7.10 below. The third condition in the following definition has no analog in [GT91]; it is included here to help ensure that transformation T15 preserves em-allowedness. <p> in <ref> [GT91] </ref> it is considered positive. This permits our notion of ENF to be slightly more restrictive than that of [GT91], without disturbing the validity of our construction. It is also used in the proof of Lemma 7.10 below. The third condition in the following definition has no analog in [GT91]; it is included here to help ensure that transformation T15 preserves em-allowedness. Definition: A formula is in Existential Normal Form (ENF) if and only if (1) It is simplified. (2) Each disjunction in the formula satisfies: 15 a. <p> Then, repeat this process until a fixed point is reached. The output of RANF on input ' is denoted RANF ('). As in <ref> [GT91] </ref>, the algorithm is nondeterministic, so it can be optimized. Example 7.8: Consider the formula resulting from Example 7.4, namely ' 00 If we apply the algorithm RANF, we have to apply T13 because (R (x; w) ^ :T (y)) is not em-allowed. <p> This last step illustrates how the presence of functions can lead to a non-em-allowed constructive atom, and hence the need for transformation T16, which is not included in <ref> [GT91] </ref>. 2 Our transformation T15 is less restrictive than the analog in [GT91], because we do not insist that ~ i 1 ^: : :^~ i k is in RANF. This permits us more flexibility to group only the needed subformulas with . <p> This last step illustrates how the presence of functions can lead to a non-em-allowed constructive atom, and hence the need for transformation T16, which is not included in <ref> [GT91] </ref>. 2 Our transformation T15 is less restrictive than the analog in [GT91], because we do not insist that ~ i 1 ^: : :^~ i k is in RANF. This permits us more flexibility to group only the needed subformulas with . There is subtly in connection with applying T15. <p> If this occurred, then it would be impossible to apply T15. This kind of situation cannot occur in the context of <ref> [GT91] </ref>. The following technical lemma demonstrated in the Appendix (Sublemma A.17) shows that this situation cannot arise in our context, either. Lemma 7.10: If T15 can be applied, then bd (: ) = ; fl;: . <p> We expect this could be used to generalize other safety criteria, such as `safe' in [Ull88] or `evaluability' in <ref> [GT91] </ref>, to incorporate scalar functions. The algorithm presented here is open to optimization along several dimentions. <p> This is established with the following lemma. This lemma relies in part on transformation T10, which does not have an analog in <ref> [GT91] </ref>. Note that if (: ^ ~ 1 ^ : : : ^ ~ n ) is an em-allowed subformula of a formula ' in ENF, then satisfies the conditions of the lemma.
Reference: [HJ91] <author> R. Hull and D. Jacobs. </author> <title> Language constructs for programming active databases. </title> <booktitle> In Proc. of Intl. Conf. on Very Large Data Bases, </booktitle> <pages> pages 455-468, </pages> <year> 1991. </year> <month> 52 </month>
Reference: [JH91] <author> D. Jacobs and R. Hull. </author> <title> Database programming with delayed updates. </title> <booktitle> In Intl. Workshop on Database Programming Languages, </booktitle> <address> San Mateo, Calif., 1991. </address> <publisher> Morgan-Kaufmann, Inc. </publisher> <pages> pp. 416-428. </pages>
Reference: [Mai83] <author> David Maier. </author> <title> The Theory of Relational Databases. </title> <publisher> Computer Science Press, </publisher> <address> Potomac, Maryland, </address> <year> 1983. </year>
Reference-contexts: We assume familiarity with the basic notions of relational database theory (cf. <ref> [Mai83, Ull88] </ref>), and of mathematical logic (cf. [End72]). We assume a one-sorted logic, and let dom denote a countably infinite set of "uninterpreted" constants.
Reference: [RBS87] <author> R. Ramakrishnan, F. Bancilhon, and A. Silberschatz. </author> <title> Safety of recursive horn clauses with infinite relations (extended abstract). </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 328-339, </pages> <year> 1987. </year>
Reference-contexts: The algorithm can be viewed as a generalization and modification of one presented in [GT91]. It adopts and generalizes the notion of finiteness dependency (FinD) from <ref> [RBS87] </ref>; these are essentially functional dependencies applied to this context. The paper also presents (d) a succinct class of "reduced" covers for sets of FinDs, that improves the efficiency of the translation algorithm. <p> Brief conclusions are offered in Section 10. An appendix provides many of the technical proofs and algorithms used in the development. 3 2 Related Work As suggested in the Introduction, the work presented here can be viewed primarily as an extension and synthesis of work in [GT91] and <ref> [RBS87] </ref>. In this section we briefly mention other investigations related to this paper. The paper [AB88] explores the incorporation of functions into query languages for complex objects; develops a syntactic notion of "safe" calculus; and shows the equivalence of the calculus, the algebra and a datalog-like language. <p> As suggested by the examples in Sections 1 and 3, in our generalization equalities involving func tion terms can be used to infer additional bounding information, which will be captured using a generalization of the finiteness dependencies (FinDs) of <ref> [RBS87] </ref>. The section begins by introducing FinDs, then defines the function bd which associates FinDs to formulas, and finally gives the definition of embedded allowed (abbreviated "em-allowed"). <p> More intricate inferences can be made, e.g., if u; v; w range over non-negative integers, then R (w) and u + v = w bounds all of u; v; w; in this case techniques such as those found in <ref> [RBS87] </ref> might be applied. 10 Conclusions This paper gives a framework to incorporate scalar functions into database queries. We expect this could be used to generalize other safety criteria, such as `safe' in [Ull88] or `evaluability' in [GT91], to incorporate scalar functions.
Reference: [Sch77] <author> J. W. Schmidt. </author> <title> Some high level language constructs for data of type relation. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 2(3) </volume> <pages> 247-261, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: 1 Introduction An important research goal for the 90's is the development of programming languages which support database functionalities. One approach, illustrated by PASCAL/R <ref> [Sch77] </ref>, is to extend an imperative language, in this case PASCAL, to incorporate access to a particular database model, in this case the relational model. In this approach, it is desirable to permit as much communication as possible between the underlying programming language and the database access language.
Reference: [Top87] <author> R. Topor. </author> <title> Domain independent formulas and databases. </title> <journal> Theoretical Computer Science, </journal> <volume> 52(3) </volume> <pages> 281-307, </pages> <year> 1987. </year>
Reference-contexts: It is undecidable whether a calculus query is (embedded) domain independent. Several decidable syntactic criteria for queries which guarantee domain independence have been developed in the literature. In this paper we generalize the criteria called allowed <ref> [Top87] </ref> to incorporate scalar functions. <p> Intuitively, this implies that the behavior of F on only term i (adom (q; I)), i.e., on a small "neighborhood" of adom (q; I), need be considered when evaluating q on I. 6 Embedded allowed This section generalizes the notion of "allowed" <ref> [Top87] </ref> to incorporate scalar functions. A key element in the notion of allowed involves inferring from syntactic properties of a calculus formula that a given variable ranges, for all practical purposes, over a bounded set of possible values.
Reference: [Top91] <author> R.W. Topor. </author> <title> Theory of Database Queries with Arithmetic Relations. </title> <type> Tech. Report TR 90/10, </type> <institution> Computer Science Department, University of Melbourne. </institution> <month> (See also: </month> <title> "Safe database queries with arithmetic relations", </title> <booktitle> in Proc. 14th Australian Computer Science Conf., </booktitle> <pages> pages 1-13, </pages> <address> Sydney, </address> <year> 1991.) </year>
Reference-contexts: As with [AB88], the notion of safe used is strictly weaker than our em-allowed, and the translation is potentially less efficient. A third related investigation is described in <ref> [Top91] </ref>, which studies the algebra, calculus, and datalog languages. In that paper the underlying domain is partitioned into two sorts: the sort Z holding the integers and a second sort, essentially what we call dom, ranging over a disjoint set of uninterpreted atomic constants. <p> Our approach differs primarily in that we permit functions to be applied to all elements of the underlying domain. Also, in the case of the calculus, our notion of embedded domain independent is different than the conjunction of <ref> [Top91] </ref>'s domain independent and finite, because [Top91] does not consider query evaluations using domains based on subsets of Z. (For example, the query fx j x = 0 ^ 8u9v (u + 1 = v)g is not embedded domain independent, but it is domain independent and finite for [Top91].) [Top91] develops a notion of safe calculus queries. <p> conjunction of <ref> [Top91] </ref>'s domain independent and finite, because [Top91] does not consider query evaluations using domains based on subsets of Z. (For example, the query fx j x = 0 ^ 8u9v (u + 1 = v)g is not embedded domain independent, but it is domain independent and finite for [Top91].) [Top91] develops a notion of safe calculus queries. This uses FinDs and the notion of "limited" variables in subformulas (cf. [Ull88]). <p> of <ref> [Top91] </ref>'s domain independent and finite, because [Top91] does not consider query evaluations using domains based on subsets of Z. (For example, the query fx j x = 0 ^ 8u9v (u + 1 = v)g is not embedded domain independent, but it is domain independent and finite for [Top91].) [Top91] develops a notion of safe calculus queries. This uses FinDs and the notion of "limited" variables in subformulas (cf. [Ull88]). <p> The notion of safe there is strictly weaker than em-allowed. [Containment is demonstrated by an induction, and the query q 5 fx; y j (R (x) ^ f (x) = y) _ (S (y) ^ g (y) = x)g is em-allowed but not safe.] The paper <ref> [Top91] </ref> presents a sketch of a translation from the safe calculus to an extended algebra, suggesting that natural generalizations of the transformations of [GT91] are sufficient. Our work follows the spirit of this sketch, but provides complete details and a complete proof of correctness. <p> In particular, we provide an additional transformation (T10 in Section 7), which, as noted in the Introduction, is needed to translate some em-allowed queries. Notably, query q 4 of the Introduction does satisfy the syntactic safeness condition of <ref> [Top91] </ref> but cannot be translated using only the natural generalizations of the transformations of [GT91]. Also, unlike [Top91], we present a heuristic to simplify the computations involving FinDs required to implement the translation. A final research effort concerning safety of calculus queries and translation of them is described in [Coh86]. <p> Notably, query q 4 of the Introduction does satisfy the syntactic safeness condition of <ref> [Top91] </ref> but cannot be translated using only the natural generalizations of the transformations of [GT91]. Also, unlike [Top91], we present a heuristic to simplify the computations involving FinDs required to implement the translation. A final research effort concerning safety of calculus queries and translation of them is described in [Coh86]. <p> Notice that without the transformation T10, no other transformations (i.e., none of T1 to T9 or T11 to T16) can be applied to ' 3 . As mentioned in Section 2, the formula ' 3 does satisfy the definition of `safe' in <ref> [Top91] </ref>, but cannot be transformed into RANF or the algebra using only the transformations described there. 2 As shown in the Appendix (Lemmas A.14 and A.16): Lemma 7.7: Given an em-allowed formula ', ENF (') terminates and yields an equivalent formula in Existential Normal Form that is em-allowed. 7.3 Transforming a
Reference: [Ull88] <author> Jeffrey D. Ullman. </author> <title> Principles of Database and Knowledgebase Systems. </title> <publisher> Computer Science Press, </publisher> <address> Potomac, Maryland, </address> <year> 1988. </year> <month> 53 </month>
Reference-contexts: We expect that the framework used here for generalizing allowed to em-allowed can also be used to incorporate scalar functions into other syntactic criteria for safety (e.g., safe DRC <ref> [Ull88] </ref>, evaluable [Dem82, GT91]). A key component in our program is the development of an algorithm which translates em-allowed calculus queries into equivalent relational algebra queries. <p> This uses FinDs and the notion of "limited" variables in subformulas (cf. <ref> [Ull88] </ref>). <p> We assume familiarity with the basic notions of relational database theory (cf. <ref> [Mai83, Ull88] </ref>), and of mathematical logic (cf. [End72]). We assume a one-sorted logic, and let dom denote a countably infinite set of "uninterpreted" constants. <p> An analogous statement holds for w and ' 2 . 2 It can be shown that FinDs satisfy the properties of functional dependencies (FDs) (e.g., see <ref> [Ull88] </ref>). <p> It follows from the algorithm for computing the fd-closure [BB79] (see also <ref> [Ull88] </ref>) and the fact that there must exist a positive em-allowed subformula i k , that there is a permutation i 1 ; : : : ; i n of 1; : : :; n such that bd (~ j ) j= ; ! f ree (~ j ) for each <p> We expect this could be used to generalize other safety criteria, such as `safe' in <ref> [Ull88] </ref> or `evaluability' in [GT91], to incorporate scalar functions. The algorithm presented here is open to optimization along several dimentions.
References-found: 20

