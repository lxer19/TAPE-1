URL: http://www.merl.com/reports/TR91-03/TR91-03.ps.gz
Refering-URL: http://www.merl.com/reports/TR91-03/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: by  
Author: Charles Rich Richard C. Waters 
Address: Cambridge Massachusetts 02139  
Note: Submitted to IEEE Transactions on Knowledge and Data Engineering,  
Date: 91-03 September 30, 1991  September 1991.  
Affiliation: Mitsubishi Electric Research Laboratories  201 Broadway  
Pubnum: Technical Report  
Abstract: Essentially all current software engineering tools share a common technological approach: They use a shallow representation of software objects and manipulate this representation using procedural methods. This approach has the benefit that it allows one to get off to a fast start and quickly provide a tool that delivers benefits. In addition, software engineering tools can undoubtedly be extended to a considerable extent within this approach. However, the approach will eventually reach a point of diminishing returns where more knowledge-intensive approaches will be needed to achieve significantly higher levels of capability. We believe that the software engineering tools of the future will have to rely on deep representation, inspection methods, and intelligent assistance. Deep representation will be necessary to capture a sufficiently large part of knowledge about programming in general and particular programs. Inspection methods (recognizing standard solutions rather than reinventing them) will be necessary to deal with complexity. Intelligent assistance will be necessary, because complete automation is not a realistic possibility in the foreseeable future, rather only parts of the programming process can be automated. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Chapman, </author> <title> A Program Testing Assistant, </title> <journal> Comm. of the ACM, </journal> <volume> 25(9) </volume> <pages> 625-634, </pages> <month> September </month> <year> 1982. </year>
Reference-contexts: A deeper representation would help here also: If test cases are indexed according to the design features they test, rather than just the parts of the code they exercise, it would be easier to select the most relevant tests. A modest step in this direction is demonstrated in <ref> [1] </ref>. Systems analysis. At the heart of all current systems analysis tools is some kind of diagram editor. Engineers can interactively draw boxes and arrows on the screen, with various annotations on them indicating the type of data, type of operation, etc.
Reference: [2] <author> E. J. Chikofsky, </author> <title> Computer-Aided Software Engineering (CASE), </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1989. </year>
Reference: [3] <author> C. Gane, </author> <title> Computer-Aided Software Engineering: The Methodologies, the Products, and the Future, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1990. </year>
Reference: [4] <author> H.B. </author> <title> Reubenstein and R.C. Waters, "The Requirements Apprentice: Automated Assistance for Requirements Acquisition," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3) </volume> <pages> 226-240, </pages> <month> March </month> <year> 1991. </year>
Reference: [5] <author> C. Rich, </author> <title> "The Layered Architecture of a System for Reasoning about Programs," </title> <booktitle> Proc. of the 9th Int. Joint Conference on Artificial Intelligence, </booktitle> <pages> pp. 540-546, </pages> <month> August </month> <year> 1985. </year>
Reference: [6] <author> C. Rich and R.C. Waters, </author> <title> The Programmer's Apprentice, </title> <publisher> Addison-Wesley, Reading MA and ACM Press, </publisher> <address> Baltimore MD, </address> <year> 1990. </year>
Reference-contexts: To go dramatically beyond the level of current tools and support complex algorithmic changes in a program, one has to move beyond superficial representations like parse trees and use direct representations of control and data flow such as the Plan Calculus <ref> [6] </ref> to represent programs and their designs. As compared to program text or parse trees, the Plan Calculus makes data flow, control flow, and the design of a program more explicit. This facilitates the direct manipulation of these features. <p> Program construction tools could also benefit from the introduction of inspection methods, as illustrated by the Knowledge-Based Editor in Emacs <ref> [6] </ref>. This system demonstrates that a library of implementation cliches represented as plans makes it possible to support the rapid construction and modification of programs by means of commands that are phrased in terms of algorithms and their structure rather than program text.
Reference: [7] <author> C. Rich and L. M. Wills, </author> <title> "Recognizing a Program's Design: A Graph-Parsing Approach," </title> <journal> IEEE Software, </journal> <volume> 7(1) </volume> <pages> 82-89, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: It is likely that the internal operation of restructuring tools would also be simplified by using such a representation, as compared to operating directly on the source code. A much deeper level of reverse engineering is illustrated by the Recognizer implemented by Wills <ref> [7, 9] </ref>. Based on a library of design and implementation cliches represented using the Plan Calculus, the Recognizer takes a program (which is also represented using plans) and parses it to determine how the program could have been constructed using the cliches.
Reference: [8] <author> R.C. Waters and Y.M. Tan, </author> <title> "Toward a Design Apprentice: Supporting Reuse and Evolution in Software Design," </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 16(2) </volume> <pages> 33-44, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Looking further into the future, it will be possible to deepen the representations used in program construction in the direction of making design decisions explicit, as illustrated in the Design Apprentice scenario in <ref> [8] </ref>. Reverse engineering. The term reverse engineering has come into use recently to describe the application of software engineering tools to existing software, i.e., software not necessarily produced using advanced tools in the first place.
Reference: [9] <author> L. M. Wills, </author> <title> "Automated Program Recognition: A Feasibility Demonstration," </title> <journal> Artificial Intelligence, </journal> <volume> 45(1-2):113-171, </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: It is likely that the internal operation of restructuring tools would also be simplified by using such a representation, as compared to operating directly on the source code. A much deeper level of reverse engineering is illustrated by the Recognizer implemented by Wills <ref> [7, 9] </ref>. Based on a library of design and implementation cliches represented using the Plan Calculus, the Recognizer takes a program (which is also represented using plans) and parses it to determine how the program could have been constructed using the cliches.
Reference: [10] <editor> Proceedings of the 3rd, </editor> <booktitle> 4th, and 5th Int. Workshops on Software Specification and Design, </booktitle> <publisher> Computer Society Press, </publisher> <address> Washington DC, </address> <year> 1985, 1987, </year> <note> and 1989. </note>
References-found: 10

