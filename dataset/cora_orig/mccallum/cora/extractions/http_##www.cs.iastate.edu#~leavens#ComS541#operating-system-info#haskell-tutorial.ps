URL: http://www.cs.iastate.edu/~leavens/ComS541/operating-system-info/haskell-tutorial.ps
Refering-URL: http://www.cs.iastate.edu/~leavens/ComS541/operating-system-info/
Root-URL: http://www.cs.iastate.edu
Title: A Gentle Introduction to Haskell  
Author: Paul Hudak Joseph H. Fasel 
Affiliation: Yale University Department of Computer Science  University of California Los Alamos National Laboratory  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Bird and P. Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Introduction to Functional Programming <ref> [1] </ref>, which uses a language sufficiently similar to Haskell to make translation between the two quite easy. For a useful survey of functional programming languages and techniques, including some of the language design principles used in Haskell, see [2].
Reference: [2] <author> P. Hudak. </author> <title> Conception, evolution, and application of functional programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 359-411, </pages> <year> 1989. </year>
Reference-contexts: Introduction to Functional Programming [1], which uses a language sufficiently similar to Haskell to make translation between the two quite easy. For a useful survey of functional programming languages and techniques, including some of the language design principles used in Haskell, see <ref> [2] </ref>. Our general strategy for introducing language features is this: motivate the idea, define some terms, give some examples, and then point to the Report for details. We suggest, however, that the reader completely ignore the details until this document has been completely read.
Reference: [3] <editor> P. Hudak, S. Peyton Jones, and P. Wadler (editors). </editor> <title> Report on the Programming Language Haskell, A Non-strict Purely Functional Language (Version 1.2). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference: [4] <author> R.S. Nikhil. </author> <title> Id (version 90.0) reference manual. </title> <type> Technical report, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: of numbers from 1 to 100: squares = array (1,100) [i := i * i | i &lt;- [1..100]] This array expression is typical in using a list comprehension for the association list; in fact, this usage results in array expressions much like the array comprehensions of the language Id <ref> [4] </ref>.
Reference: [5] <editor> J. Rees and W. Clinger (eds.). </editor> <title> The revised 3 report on the algorithmic language Scheme. </title> <journal> SIG-PLAN Notices, </journal> <volume> 21(12) </volume> <pages> 37-79, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: For example, if we add Text to the deriving clause for type Day, above, we obtain show [Monday..Wednesday] ) "[Monday,Tuesday,Wednesday]" 5.5 Numbers Haskell provides a rich collection of numeric types, based on those of Scheme <ref> [5] </ref>, which in turn are based on Common Lisp [6]. (Those languages, however, are dynamically typed.) The standard types include fixed- and arbitrary-precision integers, ratios (rational numbers) formed from each integer type, and single- and double-precision real and complex floating-point.
Reference: [6] <author> G.L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Burlington, Mass., </address> <year> 1984. </year>
Reference-contexts: For example, if we add Text to the deriving clause for type Day, above, we obtain show [Monday..Wednesday] ) "[Monday,Tuesday,Wednesday]" 5.5 Numbers Haskell provides a rich collection of numeric types, based on those of Scheme [5], which in turn are based on Common Lisp <ref> [6] </ref>. (Those languages, however, are dynamically typed.) The standard types include fixed- and arbitrary-precision integers, ratios (rational numbers) formed from each integer type, and single- and double-precision real and complex floating-point.
Reference: [7] <author> P. Wadler. </author> <title> How to replace failure by a list of successes. </title> <booktitle> In Proceedings of Conference on Functional Programming Languages and Computer Architecture, </booktitle> <volume> LNCS Vol. 201, </volume> <pages> pages 113-128. </pages> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Now that we can turn trees into strings, let's turn to the inverse problem. The basic idea is a parser for a type a, which is a function that takes a string and returns a list of (a, String) pairs <ref> [7] </ref>.
References-found: 7

